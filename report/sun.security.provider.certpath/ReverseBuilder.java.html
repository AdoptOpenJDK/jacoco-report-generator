<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReverseBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.provider.certpath</a> &gt; <span class="el_source">ReverseBuilder.java</span></div><h1>ReverseBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider.certpath;

import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.Principal;
import java.security.cert.CertificateException;
import java.security.cert.CertPathValidatorException;
import java.security.cert.CertStore;
import java.security.cert.CertStoreException;
import java.security.cert.PKIXBuilderParameters;
import java.security.cert.PKIXCertPathChecker;
import java.security.cert.PKIXParameters;
import java.security.cert.PKIXReason;
import java.security.cert.TrustAnchor;
import java.security.cert.X509Certificate;
import java.security.cert.X509CertSelector;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.LinkedList;
import java.util.Set;

import javax.security.auth.x500.X500Principal;

import sun.security.provider.certpath.PKIX.BuilderParams;
import sun.security.util.Debug;
import sun.security.x509.Extension;
import static sun.security.x509.PKIXExtensions.*;
import sun.security.x509.X500Name;
import sun.security.x509.X509CertImpl;
import sun.security.x509.PolicyMappingsExtension;

/**
 * This class represents a reverse builder, which is able to retrieve
 * matching certificates from CertStores and verify a particular certificate
 * against a ReverseState.
 *
 * @since       1.4
 * @author      Sean Mullan
 * @author      Yassir Elley
 */

class ReverseBuilder extends Builder {

<span class="nc" id="L74">    private Debug debug = Debug.getInstance(&quot;certpath&quot;);</span>

    private final Set&lt;String&gt; initPolicies;

    /**
     * Initialize the builder with the input parameters.
     *
     * @param params the parameter set used to build a certification path
     */
    ReverseBuilder(BuilderParams buildParams) {
<span class="nc" id="L84">        super(buildParams);</span>

<span class="nc" id="L86">        Set&lt;String&gt; initialPolicies = buildParams.initialPolicies();</span>
<span class="nc" id="L87">        initPolicies = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (initialPolicies.isEmpty()) {</span>
            // if no initialPolicies are specified by user, set
            // initPolicies to be anyPolicy by default
<span class="nc" id="L91">            initPolicies.add(PolicyChecker.ANY_POLICY);</span>
        } else {
<span class="nc" id="L93">            initPolicies.addAll(initialPolicies);</span>
        }
<span class="nc" id="L95">    }</span>

    /**
     * Retrieves all certs from the specified CertStores that satisfy the
     * requirements specified in the parameters and the current
     * PKIX state (name constraints, policy constraints, etc).
     *
     * @param currentState the current state.
     *        Must be an instance of &lt;code&gt;ReverseState&lt;/code&gt;
     * @param certStores list of CertStores
     */
    @Override
    Collection&lt;X509Certificate&gt; getMatchingCerts
        (State currState, List&lt;CertStore&gt; certStores)
        throws CertStoreException, CertificateException, IOException
    {
<span class="nc" id="L111">        ReverseState currentState = (ReverseState) currState;</span>

<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (debug != null)</span>
<span class="nc" id="L114">            debug.println(&quot;In ReverseBuilder.getMatchingCerts.&quot;);</span>

        /*
         * The last certificate could be an EE or a CA certificate
         * (we may be building a partial certification path or
         * establishing trust in a CA).
         *
         * Try the EE certs before the CA certs. It will be more
         * common to build a path to an end entity.
         */
<span class="nc" id="L124">        Collection&lt;X509Certificate&gt; certs =</span>
<span class="nc" id="L125">            getMatchingEECerts(currentState, certStores);</span>
<span class="nc" id="L126">        certs.addAll(getMatchingCACerts(currentState, certStores));</span>

<span class="nc" id="L128">        return certs;</span>
    }

    /*
     * Retrieves all end-entity certificates which satisfy constraints
     * and requirements specified in the parameters and PKIX state.
     */
    private Collection&lt;X509Certificate&gt; getMatchingEECerts
        (ReverseState currentState, List&lt;CertStore&gt; certStores)
        throws CertStoreException, CertificateException, IOException {

        /*
         * Compose a CertSelector to filter out
         * certs which do not satisfy requirements.
         *
         * First, retrieve clone of current target cert constraints, and
         * then add more selection criteria based on current validation state.
         */
<span class="nc" id="L146">        X509CertSelector sel = (X509CertSelector) targetCertConstraints.clone();</span>

        /*
         * Match on issuer (subject of previous cert)
         */
<span class="nc" id="L151">        sel.setIssuer(currentState.subjectDN);</span>

        /*
         * Match on certificate validity date.
         */
<span class="nc" id="L156">        sel.setCertificateValid(buildParams.date());</span>

        /*
         * Policy processing optimizations
         */
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (currentState.explicitPolicy == 0)</span>
<span class="nc" id="L162">            sel.setPolicy(getMatchingPolicies());</span>

        /*
         * If previous cert has a subject key identifier extension,
         * use it to match on authority key identifier extension.
         */
        /*if (currentState.subjKeyId != null) {
          AuthorityKeyIdentifierExtension authKeyId = new AuthorityKeyIdentifierExtension(
                (KeyIdentifier) currentState.subjKeyId.get(SubjectKeyIdentifierExtension.KEY_ID),
                null, null);
        sel.setAuthorityKeyIdentifier(authKeyId.getExtensionValue());
        }*/

        /*
         * Require EE certs
         */
<span class="nc" id="L178">        sel.setBasicConstraints(-2);</span>

        /* Retrieve matching certs from CertStores */
<span class="nc" id="L181">        HashSet&lt;X509Certificate&gt; eeCerts = new HashSet&lt;&gt;();</span>
<span class="nc" id="L182">        addMatchingCerts(sel, certStores, eeCerts, true);</span>

<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L185">            debug.println(&quot;ReverseBuilder.getMatchingEECerts got &quot;</span>
<span class="nc" id="L186">                          + eeCerts.size() + &quot; certs.&quot;);</span>
        }
<span class="nc" id="L188">        return eeCerts;</span>
    }

    /*
     * Retrieves all CA certificates which satisfy constraints
     * and requirements specified in the parameters and PKIX state.
     */
    private Collection&lt;X509Certificate&gt; getMatchingCACerts
        (ReverseState currentState, List&lt;CertStore&gt; certStores)
        throws CertificateException, CertStoreException, IOException {

        /*
         * Compose a CertSelector to filter out
         * certs which do not satisfy requirements.
         */
<span class="nc" id="L203">        X509CertSelector sel = new X509CertSelector();</span>

        /*
         * Match on issuer (subject of previous cert)
         */
<span class="nc" id="L208">        sel.setIssuer(currentState.subjectDN);</span>

        /*
         * Match on certificate validity date.
         */
<span class="nc" id="L213">        sel.setCertificateValid(buildParams.date());</span>

        /*
         * Match on target subject name (checks that current cert's
         * name constraints permit it to certify target).
         * (4 is the integer type for DIRECTORY name).
         */
<span class="nc" id="L220">        byte[] subject = targetCertConstraints.getSubjectAsBytes();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (subject != null) {</span>
<span class="nc" id="L222">            sel.addPathToName(4, subject);</span>
        } else {
<span class="nc" id="L224">            X509Certificate cert = targetCertConstraints.getCertificate();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (cert != null) {</span>
<span class="nc" id="L226">                sel.addPathToName(4,</span>
<span class="nc" id="L227">                                  cert.getSubjectX500Principal().getEncoded());</span>
            }
        }

        /*
         * Policy processing optimizations
         */
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (currentState.explicitPolicy == 0)</span>
<span class="nc" id="L235">            sel.setPolicy(getMatchingPolicies());</span>

        /*
         * If previous cert has a subject key identifier extension,
         * use it to match on authority key identifier extension.
         */
        /*if (currentState.subjKeyId != null) {
          AuthorityKeyIdentifierExtension authKeyId = new AuthorityKeyIdentifierExtension(
                (KeyIdentifier) currentState.subjKeyId.get(SubjectKeyIdentifierExtension.KEY_ID),
                                null, null);
          sel.setAuthorityKeyIdentifier(authKeyId.getExtensionValue());
        }*/

        /*
         * Require CA certs
         */
<span class="nc" id="L251">        sel.setBasicConstraints(0);</span>

        /* Retrieve matching certs from CertStores */
<span class="nc" id="L254">        ArrayList&lt;X509Certificate&gt; reverseCerts = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L255">        addMatchingCerts(sel, certStores, reverseCerts, true);</span>

        /* Sort remaining certs using name constraints */
<span class="nc" id="L258">        Collections.sort(reverseCerts, new PKIXCertComparator());</span>

<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (debug != null)</span>
<span class="nc" id="L261">            debug.println(&quot;ReverseBuilder.getMatchingCACerts got &quot; +</span>
<span class="nc" id="L262">                          reverseCerts.size() + &quot; certs.&quot;);</span>
<span class="nc" id="L263">        return reverseCerts;</span>
    }

    /*
     * This inner class compares 2 PKIX certificates according to which
     * should be tried first when building a path to the target. For
     * now, the algorithm is to look at name constraints in each cert and those
     * which constrain the path closer to the target should be
     * ranked higher. Later, we may want to consider other components,
     * such as key identifiers.
     */
<span class="nc" id="L274">    class PKIXCertComparator implements Comparator&lt;X509Certificate&gt; {</span>

<span class="nc" id="L276">        private Debug debug = Debug.getInstance(&quot;certpath&quot;);</span>

        @Override
        public int compare(X509Certificate cert1, X509Certificate cert2) {

            /*
             * if either cert certifies the target, always
             * put at head of list.
             */
<span class="nc" id="L285">            X500Principal targetSubject = buildParams.targetSubject();</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            if (cert1.getSubjectX500Principal().equals(targetSubject)) {</span>
<span class="nc" id="L287">                return -1;</span>
            }
<span class="nc bnc" id="L289" title="All 2 branches missed.">            if (cert2.getSubjectX500Principal().equals(targetSubject)) {</span>
<span class="nc" id="L290">                return 1;</span>
            }

            int targetDist1;
            int targetDist2;
            try {
<span class="nc" id="L296">                X500Name targetSubjectName = X500Name.asX500Name(targetSubject);</span>
<span class="nc" id="L297">                targetDist1 = Builder.targetDistance(</span>
                    null, cert1, targetSubjectName);
<span class="nc" id="L299">                targetDist2 = Builder.targetDistance(</span>
                    null, cert2, targetSubjectName);
<span class="nc" id="L301">            } catch (IOException e) {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L303">                    debug.println(&quot;IOException in call to Builder.targetDistance&quot;);</span>
<span class="nc" id="L304">                    e.printStackTrace();</span>
                }
<span class="nc" id="L306">                throw new ClassCastException</span>
                    (&quot;Invalid target subject distinguished name&quot;);
<span class="nc" id="L308">            }</span>

<span class="nc bnc" id="L310" title="All 2 branches missed.">            if (targetDist1 == targetDist2)</span>
<span class="nc" id="L311">                return 0;</span>

<span class="nc bnc" id="L313" title="All 2 branches missed.">            if (targetDist1 == -1)</span>
<span class="nc" id="L314">                return 1;</span>

<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (targetDist1 &lt; targetDist2)</span>
<span class="nc" id="L317">                return -1;</span>

<span class="nc" id="L319">            return 1;</span>
        }
    }

    /**
     * Verifies a matching certificate.
     *
     * This method executes any of the validation steps in the PKIX path validation
     * algorithm which were not satisfied via filtering out non-compliant
     * certificates with certificate matching rules.
     *
     * If the last certificate is being verified (the one whose subject
     * matches the target subject, then the steps in Section 6.1.4 of the
     * Certification Path Validation algorithm are NOT executed,
     * regardless of whether or not the last cert is an end-entity
     * cert or not. This allows callers to certify CA certs as
     * well as EE certs.
     *
     * @param cert the certificate to be verified
     * @param currentState the current state against which the cert is verified
     * @param certPathList the certPathList generated thus far
     */
    @Override
    void verifyCert(X509Certificate cert, State currState,
        List&lt;X509Certificate&gt; certPathList)
        throws GeneralSecurityException
    {
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L347">            debug.println(&quot;ReverseBuilder.verifyCert(SN: &quot;</span>
<span class="nc" id="L348">                + Debug.toHexString(cert.getSerialNumber())</span>
<span class="nc" id="L349">                + &quot;\n  Subject: &quot; + cert.getSubjectX500Principal() + &quot;)&quot;);</span>
        }

<span class="nc" id="L352">        ReverseState currentState = (ReverseState) currState;</span>

        /* we don't perform any validation of the trusted cert */
<span class="nc bnc" id="L355" title="All 2 branches missed.">        if (currentState.isInitial()) {</span>
<span class="nc" id="L356">            return;</span>
        }

        // Don't bother to verify untrusted certificate more.
<span class="nc" id="L360">        currentState.untrustedChecker.check(cert,</span>
<span class="nc" id="L361">                                    Collections.&lt;String&gt;emptySet());</span>

        /*
         * check for looping - abort a loop if
         * ((we encounter the same certificate twice) AND
         * ((policyMappingInhibited = true) OR (no policy mapping
         * extensions can be found between the occurrences of the same
         * certificate)))
         * in order to facilitate the check to see if there are
         * any policy mapping extensions found between the occurrences
         * of the same certificate, we reverse the certpathlist first
         */
<span class="nc bnc" id="L373" title="All 4 branches missed.">        if ((certPathList != null) &amp;&amp; (!certPathList.isEmpty())) {</span>
<span class="nc" id="L374">            List&lt;X509Certificate&gt; reverseCertList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            for (X509Certificate c : certPathList) {</span>
<span class="nc" id="L376">                reverseCertList.add(0, c);</span>
<span class="nc" id="L377">            }</span>

<span class="nc" id="L379">            boolean policyMappingFound = false;</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            for (X509Certificate cpListCert : reverseCertList) {</span>
<span class="nc" id="L381">                X509CertImpl cpListCertImpl = X509CertImpl.toImpl(cpListCert);</span>
<span class="nc" id="L382">                PolicyMappingsExtension policyMappingsExt =</span>
<span class="nc" id="L383">                        cpListCertImpl.getPolicyMappingsExtension();</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">                if (policyMappingsExt != null) {</span>
<span class="nc" id="L385">                    policyMappingFound = true;</span>
                }
<span class="nc bnc" id="L387" title="All 2 branches missed.">                if (debug != null)</span>
<span class="nc" id="L388">                    debug.println(&quot;policyMappingFound = &quot; + policyMappingFound);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                if (cert.equals(cpListCert)) {</span>
<span class="nc bnc" id="L390" title="All 4 branches missed.">                    if ((buildParams.policyMappingInhibited()) ||</span>
                        (!policyMappingFound)){
<span class="nc bnc" id="L392" title="All 2 branches missed.">                        if (debug != null)</span>
<span class="nc" id="L393">                            debug.println(&quot;loop detected!!&quot;);</span>
<span class="nc" id="L394">                        throw new CertPathValidatorException(&quot;loop detected&quot;);</span>
                    }
                }
<span class="nc" id="L397">            }</span>
        }

        /* check if target cert */
<span class="nc" id="L401">        boolean finalCert = cert.getSubjectX500Principal().equals(buildParams.targetSubject());</span>

        /* check if CA cert */
<span class="nc bnc" id="L404" title="All 2 branches missed.">        boolean caCert = (cert.getBasicConstraints() != -1 ? true : false);</span>

        /* if there are more certs to follow, verify certain constraints */
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (!finalCert) {</span>

            /* check if CA cert */
<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (!caCert)</span>
<span class="nc" id="L411">                throw new CertPathValidatorException(&quot;cert is NOT a CA cert&quot;);</span>

            /* If the certificate was not self-issued, verify that
             * remainingCerts is greater than zero
             */
<span class="nc bnc" id="L416" title="All 4 branches missed.">            if ((currentState.remainingCACerts &lt;= 0) &amp;&amp; !X509CertImpl.isSelfIssued(cert)) {</span>
<span class="nc" id="L417">                    throw new CertPathValidatorException</span>
                        (&quot;pathLenConstraint violated, path too long&quot;, null,
                         null, -1, PKIXReason.PATH_TOO_LONG);
            }

            /*
             * Check keyUsage extension (only if CA cert and not final cert)
             */
<span class="nc" id="L425">            KeyChecker.verifyCAKeyUsage(cert);</span>

        } else {

            /*
             * If final cert, check that it satisfies specified target
             * constraints
             */
<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (targetCertConstraints.match(cert) == false) {</span>
<span class="nc" id="L434">                throw new CertPathValidatorException(&quot;target certificate &quot; +</span>
                    &quot;constraints check failed&quot;);
            }
        }

        /*
         * Check revocation.
         */
<span class="nc bnc" id="L442" title="All 4 branches missed.">        if (buildParams.revocationEnabled() &amp;&amp; currentState.revChecker != null) {</span>
<span class="nc" id="L443">            currentState.revChecker.check(cert, Collections.&lt;String&gt;emptySet());</span>
        }

        /* Check name constraints if this is not a self-issued cert */
<span class="nc bnc" id="L447" title="All 4 branches missed.">        if (finalCert || !X509CertImpl.isSelfIssued(cert)){</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (currentState.nc != null) {</span>
                try {
<span class="nc bnc" id="L450" title="All 2 branches missed.">                    if (!currentState.nc.verify(cert)){</span>
<span class="nc" id="L451">                        throw new CertPathValidatorException</span>
                            (&quot;name constraints check failed&quot;, null, null, -1,
                             PKIXReason.INVALID_NAME);
                    }
<span class="nc" id="L455">                } catch (IOException ioe) {</span>
<span class="nc" id="L456">                    throw new CertPathValidatorException(ioe);</span>
<span class="nc" id="L457">                }</span>
            }
        }

        /*
         * Check policy
         */
<span class="nc" id="L464">        X509CertImpl certImpl = X509CertImpl.toImpl(cert);</span>
<span class="nc" id="L465">        currentState.rootNode = PolicyChecker.processPolicies</span>
<span class="nc" id="L466">            (currentState.certIndex, initPolicies,</span>
            currentState.explicitPolicy, currentState.policyMapping,
            currentState.inhibitAnyPolicy,
<span class="nc" id="L469">            buildParams.policyQualifiersRejected(), currentState.rootNode,</span>
            certImpl, finalCert);

        /*
         * Check CRITICAL private extensions
         */
<span class="nc" id="L475">        Set&lt;String&gt; unresolvedCritExts = cert.getCriticalExtensionOIDs();</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (unresolvedCritExts == null) {</span>
<span class="nc" id="L477">            unresolvedCritExts = Collections.&lt;String&gt;emptySet();</span>
        }

        /*
         * Check that the signature algorithm is not disabled.
         */
<span class="nc" id="L483">        currentState.algorithmChecker.check(cert, unresolvedCritExts);</span>

<span class="nc bnc" id="L485" title="All 2 branches missed.">        for (PKIXCertPathChecker checker : currentState.userCheckers) {</span>
<span class="nc" id="L486">            checker.check(cert, unresolvedCritExts);</span>
<span class="nc" id="L487">        }</span>

        /*
         * Look at the remaining extensions and remove any ones we have
         * already checked. If there are any left, throw an exception!
         */
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (!unresolvedCritExts.isEmpty()) {</span>
<span class="nc" id="L494">            unresolvedCritExts.remove(BasicConstraints_Id.toString());</span>
<span class="nc" id="L495">            unresolvedCritExts.remove(NameConstraints_Id.toString());</span>
<span class="nc" id="L496">            unresolvedCritExts.remove(CertificatePolicies_Id.toString());</span>
<span class="nc" id="L497">            unresolvedCritExts.remove(PolicyMappings_Id.toString());</span>
<span class="nc" id="L498">            unresolvedCritExts.remove(PolicyConstraints_Id.toString());</span>
<span class="nc" id="L499">            unresolvedCritExts.remove(InhibitAnyPolicy_Id.toString());</span>
<span class="nc" id="L500">            unresolvedCritExts.remove(SubjectAlternativeName_Id.toString());</span>
<span class="nc" id="L501">            unresolvedCritExts.remove(KeyUsage_Id.toString());</span>
<span class="nc" id="L502">            unresolvedCritExts.remove(ExtendedKeyUsage_Id.toString());</span>

<span class="nc bnc" id="L504" title="All 2 branches missed.">            if (!unresolvedCritExts.isEmpty())</span>
<span class="nc" id="L505">                throw new CertPathValidatorException</span>
                    (&quot;Unrecognized critical extension(s)&quot;, null, null, -1,
                     PKIXReason.UNRECOGNIZED_CRIT_EXT);
        }

        /*
         * Check signature.
         */
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (buildParams.sigProvider() != null) {</span>
<span class="nc" id="L514">            cert.verify(currentState.pubKey, buildParams.sigProvider());</span>
        } else {
<span class="nc" id="L516">            cert.verify(currentState.pubKey);</span>
        }
<span class="nc" id="L518">    }</span>

    /**
     * Verifies whether the input certificate completes the path.
     * This checks whether the cert is the target certificate.
     *
     * @param cert the certificate to test
     * @return a boolean value indicating whether the cert completes the path.
     */
    @Override
    boolean isPathCompleted(X509Certificate cert) {
<span class="nc" id="L529">        return cert.getSubjectX500Principal().equals(buildParams.targetSubject());</span>
    }

    /** Adds the certificate to the certPathList
     *
     * @param cert the certificate to be added
     * @param certPathList the certification path list
     */
    @Override
    void addCertToPath(X509Certificate cert,
        LinkedList&lt;X509Certificate&gt; certPathList) {
<span class="nc" id="L540">        certPathList.addLast(cert);</span>
<span class="nc" id="L541">    }</span>

    /** Removes final certificate from the certPathList
     *
     * @param certPathList the certification path list
     */
    @Override
    void removeFinalCertFromPath(LinkedList&lt;X509Certificate&gt; certPathList) {
<span class="nc" id="L549">        certPathList.removeLast();</span>
<span class="nc" id="L550">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>