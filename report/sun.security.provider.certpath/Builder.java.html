<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Builder.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.provider.certpath</a> &gt; <span class="el_source">Builder.java</span></div><h1>Builder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider.certpath;

import java.io.IOException;
import java.security.AccessController;
import java.security.GeneralSecurityException;
import java.security.cert.*;
import java.util.*;

import sun.security.action.GetBooleanAction;
import sun.security.provider.certpath.PKIX.BuilderParams;
import sun.security.util.Debug;
import sun.security.x509.GeneralNames;
import sun.security.x509.GeneralNameInterface;
import sun.security.x509.GeneralSubtrees;
import sun.security.x509.NameConstraintsExtension;
import sun.security.x509.SubjectAlternativeNameExtension;
import sun.security.x509.X500Name;
import sun.security.x509.X509CertImpl;

/**
 * Abstract class representing a builder, which is able to retrieve
 * matching certificates and is able to verify a particular certificate.
 *
 * @since       1.4
 * @author      Sean Mullan
 * @author      Yassir Elley
 */

public abstract class Builder {

<span class="fc" id="L56">    private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);</span>
    private Set&lt;String&gt; matchingPolicies;
    final BuilderParams buildParams;
    final X509CertSelector targetCertConstraints;

    /**
     * Flag indicating whether support for the caIssuers field of the
     * Authority Information Access extension shall be enabled. Currently
     * disabled by default for compatibility reasons.
     */
<span class="fc" id="L66">    final static boolean USE_AIA = AccessController.doPrivileged</span>
<span class="fc" id="L67">        (new GetBooleanAction(&quot;com.sun.security.enableAIAcaIssuers&quot;));</span>

    /**
     * Initialize the builder with the input parameters.
     *
     * @param params the parameter set used to build a certification path
     */
<span class="fc" id="L74">    Builder(BuilderParams buildParams) {</span>
<span class="fc" id="L75">        this.buildParams = buildParams;</span>
<span class="fc" id="L76">        this.targetCertConstraints =</span>
<span class="fc" id="L77">            (X509CertSelector)buildParams.targetCertConstraints();</span>
<span class="fc" id="L78">    }</span>

    /**
     * Retrieves certificates from the list of certStores using the buildParams
     * and the currentState as a filter
     *
     * @param currentState the current State
     * @param certStores list of CertStores
     */
    abstract Collection&lt;X509Certificate&gt; getMatchingCerts
        (State currentState, List&lt;CertStore&gt; certStores)
        throws CertStoreException, CertificateException, IOException;

    /**
     * Verifies the cert against the currentState, using the certPathList
     * generated thus far to help with loop detection
     *
     * @param cert the certificate to be verified
     * @param currentState the current state against which the cert is verified
     * @param certPathList the certPathList generated thus far
     */
    abstract void verifyCert(X509Certificate cert, State currentState,
                             List&lt;X509Certificate&gt; certPathList)
        throws GeneralSecurityException;

    /**
     * Verifies whether the input certificate completes the path.
     * When building forward, a trust anchor will complete the path.
     * When building reverse, the target certificate will complete the path.
     *
     * @param cert the certificate to test
     * @return a boolean value indicating whether the cert completes the path.
     */
    abstract boolean isPathCompleted(X509Certificate cert);

    /**
     * Adds the certificate to the certPathList
     *
     * @param cert the certificate to be added
     * @param certPathList the certification path list
     */
    abstract void addCertToPath(X509Certificate cert,
                                LinkedList&lt;X509Certificate&gt; certPathList);

    /**
     * Removes final certificate from the certPathList
     *
     * @param certPathList the certification path list
     */
    abstract void removeFinalCertFromPath
        (LinkedList&lt;X509Certificate&gt; certPathList);

    /**
     * get distance of one GeneralName from another
     *
     * @param base GeneralName at base of subtree
     * @param test GeneralName to be tested against base
     * @param incomparable the value to return if the names are
     *  incomparable
     * @return distance of test name from base, where 0
     *         means exact match, 1 means test is an immediate
     *         child of base, 2 means test is a grandchild, etc.
     *         -1 means test is a parent of base, -2 means test
     *         is a grandparent, etc.
     */
    static int distance(GeneralNameInterface base,
                        GeneralNameInterface test, int incomparable)
    {
<span class="nc bnc" id="L146" title="All 6 branches missed.">        switch (base.constrains(test)) {</span>
        case GeneralNameInterface.NAME_DIFF_TYPE:
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L149">                debug.println(&quot;Builder.distance(): Names are different types&quot;);</span>
            }
<span class="nc" id="L151">            return incomparable;</span>
        case GeneralNameInterface.NAME_SAME_TYPE:
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L154">                debug.println(&quot;Builder.distance(): Names are same type but &quot; +</span>
                    &quot;in different subtrees&quot;);
            }
<span class="nc" id="L157">            return incomparable;</span>
        case GeneralNameInterface.NAME_MATCH:
<span class="nc" id="L159">            return 0;</span>
        case GeneralNameInterface.NAME_WIDENS:
<span class="nc" id="L161">            break;</span>
        case GeneralNameInterface.NAME_NARROWS:
<span class="nc" id="L163">            break;</span>
        default: // should never occur
<span class="nc" id="L165">            return incomparable;</span>
        }

        /* names are in same subtree */
<span class="nc" id="L169">        return test.subtreeDepth() - base.subtreeDepth();</span>
    }

    /**
     * get hop distance of one GeneralName from another in links where
     * the names need not have an ancestor/descendant relationship.
     * For example, the hop distance from ou=D,ou=C,o=B,c=US to
     * ou=F,ou=E,ou=C,o=B,c=US is 3: D-&gt;C, C-&gt;E, E-&gt;F.  The hop distance
     * from ou=C,o=B,c=US to ou=D,ou=C,o=B,c=US is -1: C-&gt;D
     *
     * @param base GeneralName
     * @param test GeneralName to be tested against base
     * @param incomparable the value to return if the names are
     *  incomparable
     * @return distance of test name from base measured in hops in the
     *         namespace hierarchy, where 0 means exact match.  Result
     *         is positive if path is some number of up hops followed by
     *         some number of down hops; result is negative if path is
     *         some number of down hops.
     */
    static int hops(GeneralNameInterface base, GeneralNameInterface test,
                    int incomparable)
    {
<span class="nc" id="L192">        int baseRtest = base.constrains(test);</span>
<span class="nc bnc" id="L193" title="All 6 branches missed.">        switch (baseRtest) {</span>
        case GeneralNameInterface.NAME_DIFF_TYPE:
<span class="nc bnc" id="L195" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L196">                debug.println(&quot;Builder.hops(): Names are different types&quot;);</span>
            }
<span class="nc" id="L198">            return incomparable;</span>
        case GeneralNameInterface.NAME_SAME_TYPE:
            /* base and test are in different subtrees */
<span class="nc" id="L201">            break;</span>
        case GeneralNameInterface.NAME_MATCH:
            /* base matches test */
<span class="nc" id="L204">            return 0;</span>
        case GeneralNameInterface.NAME_WIDENS:
            /* base is ancestor of test */
<span class="nc" id="L207">            return (test.subtreeDepth()-base.subtreeDepth());</span>
        case GeneralNameInterface.NAME_NARROWS:
            /* base is descendant of test */
<span class="nc" id="L210">            return (test.subtreeDepth()-base.subtreeDepth());</span>
        default: // should never occur
<span class="nc" id="L212">            return incomparable;</span>
        }

        /* names are in different subtrees */
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (base.getType() != GeneralNameInterface.NAME_DIRECTORY) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L218">                debug.println(&quot;Builder.hops(): hopDistance not implemented &quot; +</span>
                    &quot;for this name type&quot;);
            }
<span class="nc" id="L221">            return incomparable;</span>
        }
<span class="nc" id="L223">        X500Name baseName = (X500Name)base;</span>
<span class="nc" id="L224">        X500Name testName = (X500Name)test;</span>
<span class="nc" id="L225">        X500Name commonName = baseName.commonAncestor(testName);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (commonName == null) {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L228">                debug.println(&quot;Builder.hops(): Names are in different &quot; +</span>
                    &quot;namespaces&quot;);
            }
<span class="nc" id="L231">            return incomparable;</span>
        } else {
<span class="nc" id="L233">            int commonDistance = commonName.subtreeDepth();</span>
<span class="nc" id="L234">            int baseDistance = baseName.subtreeDepth();</span>
<span class="nc" id="L235">            int testDistance = testName.subtreeDepth();</span>
<span class="nc" id="L236">            return (baseDistance + testDistance - (2 * commonDistance));</span>
        }
    }

    /**
     * Determine how close a given certificate gets you toward
     * a given target.
     *
     * @param constraints Current NameConstraints; if null,
     *        then caller must verify NameConstraints
     *        independently, realizing that this certificate
     *        may not actually lead to the target at all.
     * @param cert Candidate certificate for chain
     * @param target GeneralNameInterface name of target
     * @return distance from this certificate to target:
     * &lt;ul&gt;
     * &lt;li&gt;-1 means certificate could be CA for target, but
     *     there are no NameConstraints limiting how close
     * &lt;li&gt; 0 means certificate subject or subjectAltName
     *      matches target
     * &lt;li&gt; 1 means certificate is permitted to be CA for
     *      target.
     * &lt;li&gt; 2 means certificate is permitted to be CA for
     *      parent of target.
     * &lt;li&gt;&amp;gt;0 in general, means certificate is permitted
     *     to be a CA for this distance higher in the naming
     *     hierarchy than the target, plus 1.
     * &lt;/ul&gt;
     * &lt;p&gt;Note that the subject and/or subjectAltName of the
     * candidate cert does not have to be an ancestor of the
     * target in order to be a CA that can issue a certificate to
     * the target. In these cases, the target distance is calculated
     * by inspecting the NameConstraints extension in the candidate
     * certificate. For example, suppose the target is an X.500 DN with
     * a value of &quot;CN=mullan,OU=ireland,O=sun,C=us&quot; and the
     * NameConstraints extension in the candidate certificate
     * includes a permitted component of &quot;O=sun,C=us&quot;, which implies
     * that the candidate certificate is allowed to issue certs in
     * the &quot;O=sun,C=us&quot; namespace. The target distance is 3
     * ((distance of permitted NC from target) + 1).
     * The (+1) is added to distinguish the result from the case
     * which returns (0).
     * @throws IOException if certificate does not get closer
     */
    static int targetDistance(NameConstraintsExtension constraints,
                              X509Certificate cert, GeneralNameInterface target)
            throws IOException
    {
        /* ensure that certificate satisfies existing name constraints */
<span class="nc bnc" id="L285" title="All 4 branches missed.">        if (constraints != null &amp;&amp; !constraints.verify(cert)) {</span>
<span class="nc" id="L286">            throw new IOException(&quot;certificate does not satisfy existing name &quot;</span>
                + &quot;constraints&quot;);
        }

        X509CertImpl certImpl;
        try {
<span class="nc" id="L292">            certImpl = X509CertImpl.toImpl(cert);</span>
<span class="nc" id="L293">        } catch (CertificateException e) {</span>
<span class="nc" id="L294">            throw new IOException(&quot;Invalid certificate&quot;, e);</span>
<span class="nc" id="L295">        }</span>
        /* see if certificate subject matches target */
<span class="nc" id="L297">        X500Name subject = X500Name.asX500Name(certImpl.getSubjectX500Principal());</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (subject.equals(target)) {</span>
            /* match! */
<span class="nc" id="L300">            return 0;</span>
        }

<span class="nc" id="L303">        SubjectAlternativeNameExtension altNameExt =</span>
<span class="nc" id="L304">            certImpl.getSubjectAlternativeNameExtension();</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (altNameExt != null) {</span>
<span class="nc" id="L306">            GeneralNames altNames = altNameExt.get(</span>
                    SubjectAlternativeNameExtension.SUBJECT_NAME);
            /* see if any alternative name matches target */
<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (altNames != null) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                for (int j = 0, n = altNames.size(); j &lt; n; j++) {</span>
<span class="nc" id="L311">                    GeneralNameInterface altName = altNames.get(j).getName();</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                    if (altName.equals(target)) {</span>
<span class="nc" id="L313">                        return 0;</span>
                    }
                }
            }
        }


        /* no exact match; see if certificate can get us to target */

        /* first, get NameConstraints out of certificate */
<span class="nc" id="L323">        NameConstraintsExtension ncExt = certImpl.getNameConstraintsExtension();</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (ncExt == null) {</span>
<span class="nc" id="L325">            return -1;</span>
        }

        /* merge certificate's NameConstraints with current NameConstraints */
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (constraints != null) {</span>
<span class="nc" id="L330">            constraints.merge(ncExt);</span>
        } else {
            // Make sure we do a clone here, because we're probably
            // going to modify this object later and we don't want to
            // be sharing it with a Certificate object!
<span class="nc" id="L335">            constraints = (NameConstraintsExtension) ncExt.clone();</span>
        }

<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L339">            debug.println(&quot;Builder.targetDistance() merged constraints: &quot;</span>
<span class="nc" id="L340">                + String.valueOf(constraints));</span>
        }
        /* reduce permitted by excluded */
<span class="nc" id="L343">        GeneralSubtrees permitted =</span>
<span class="nc" id="L344">                constraints.get(NameConstraintsExtension.PERMITTED_SUBTREES);</span>
<span class="nc" id="L345">        GeneralSubtrees excluded =</span>
<span class="nc" id="L346">                constraints.get(NameConstraintsExtension.EXCLUDED_SUBTREES);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (permitted != null) {</span>
<span class="nc" id="L348">            permitted.reduce(excluded);</span>
        }
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L351">            debug.println(&quot;Builder.targetDistance() reduced constraints: &quot;</span>
                + permitted);
        }
        /* see if new merged constraints allow target */
<span class="nc bnc" id="L355" title="All 2 branches missed.">        if (!constraints.verify(target)) {</span>
<span class="nc" id="L356">            throw new IOException(&quot;New certificate not allowed to sign &quot;</span>
                + &quot;certificate for target&quot;);
        }
        /* find distance to target, if any, in permitted */
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (permitted == null) {</span>
            /* certificate is unconstrained; could sign for anything */
<span class="nc" id="L362">            return -1;</span>
        }
<span class="nc bnc" id="L364" title="All 2 branches missed.">        for (int i = 0, n = permitted.size(); i &lt; n; i++) {</span>
<span class="nc" id="L365">            GeneralNameInterface perName = permitted.get(i).getName().getName();</span>
<span class="nc" id="L366">            int distance = distance(perName, target, -1);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (distance &gt;= 0) {</span>
<span class="nc" id="L368">                return (distance + 1);</span>
            }
        }
        /* no matching type in permitted; cert holder could certify target */
<span class="nc" id="L372">        return -1;</span>
    }

    /**
     * This method can be used as an optimization to filter out
     * certificates that do not have policies which are valid.
     * It returns the set of policies (String OIDs) that should exist in
     * the certificate policies extension of the certificate that is
     * needed by the builder. The logic applied is as follows:
     * &lt;p&gt;
     *   1) If some initial policies have been set *and* policy mappings are
     *   inhibited, then acceptable certificates are those that include
     *   the ANY_POLICY OID or with policies that intersect with the
     *   initial policies.
     *   2) If no initial policies have been set *or* policy mappings are
     *   not inhibited then we don't have much to work with. All we know is
     *   that a certificate must have *some* policy because if it didn't
     *   have any policy then the policy tree would become null (and validation
     *   would fail).
     *
     * @return the Set of policies any of which must exist in a
     * cert's certificate policies extension in order for a cert to be selected.
     */
    Set&lt;String&gt; getMatchingPolicies() {
<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (matchingPolicies != null) {</span>
<span class="nc" id="L397">            Set&lt;String&gt; initialPolicies = buildParams.initialPolicies();</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            if ((!initialPolicies.isEmpty()) &amp;&amp;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                (!initialPolicies.contains(PolicyChecker.ANY_POLICY)) &amp;&amp;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">                (buildParams.policyMappingInhibited()))</span>
            {
<span class="nc" id="L402">                matchingPolicies = new HashSet&lt;&gt;(initialPolicies);</span>
<span class="nc" id="L403">                matchingPolicies.add(PolicyChecker.ANY_POLICY);</span>
            } else {
                // we just return an empty set to make sure that there is
                // at least a certificate policies extension in the cert
<span class="nc" id="L407">                matchingPolicies = Collections.&lt;String&gt;emptySet();</span>
            }
        }
<span class="nc" id="L410">        return matchingPolicies;</span>
    }

    /**
     * Search the specified CertStores and add all certificates matching
     * selector to resultCerts. Self-signed certs are not useful here
     * and therefore ignored.
     *
     * If the targetCert criterion of the selector is set, only that cert
     * is examined and the CertStores are not searched.
     *
     * If checkAll is true, all CertStores are searched for matching certs.
     * If false, the method returns as soon as the first CertStore returns
     * a matching cert(s).
     *
     * Returns true iff resultCerts changed (a cert was added to the collection)
     */
    boolean addMatchingCerts(X509CertSelector selector,
                             Collection&lt;CertStore&gt; certStores,
                             Collection&lt;X509Certificate&gt; resultCerts,
                             boolean checkAll)
    {
<span class="fc" id="L432">        X509Certificate targetCert = selector.getCertificate();</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (targetCert != null) {</span>
            // no need to search CertStores
<span class="fc bfc" id="L435" title="All 2 branches covered.">            if (selector.match(targetCert) &amp;&amp; !X509CertImpl.isSelfSigned</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">                (targetCert, buildParams.sigProvider())) {</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L438">                    debug.println(&quot;Builder.addMatchingCerts: adding target cert&quot;);</span>
                }
<span class="fc" id="L440">                return resultCerts.add(targetCert);</span>
            }
<span class="fc" id="L442">            return false;</span>
        }
<span class="fc" id="L444">        boolean add = false;</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">        for (CertStore store : certStores) {</span>
            try {
<span class="fc" id="L447">                Collection&lt;? extends Certificate&gt; certs =</span>
<span class="fc" id="L448">                                        store.getCertificates(selector);</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">                for (Certificate cert : certs) {</span>
<span class="fc" id="L450">                    if (!X509CertImpl.isSelfSigned</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">                        ((X509Certificate)cert, buildParams.sigProvider())) {</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">                        if (resultCerts.add((X509Certificate)cert)) {</span>
<span class="fc" id="L453">                            add = true;</span>
                        }
                    }
<span class="fc" id="L456">                }</span>
<span class="fc bfc" id="L457" title="All 4 branches covered.">                if (!checkAll &amp;&amp; add) {</span>
<span class="fc" id="L458">                    return true;</span>
                }
<span class="nc" id="L460">            } catch (CertStoreException cse) {</span>
                // if getCertificates throws a CertStoreException, we ignore
                // it and move on to the next CertStore
<span class="nc bnc" id="L463" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L464">                    debug.println(&quot;Builder.addMatchingCerts, non-fatal &quot; +</span>
                        &quot;exception retrieving certs: &quot; + cse);
<span class="nc" id="L466">                    cse.printStackTrace();</span>
                }
<span class="fc" id="L468">            }</span>
<span class="fc" id="L469">        }</span>
<span class="fc" id="L470">        return add;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>