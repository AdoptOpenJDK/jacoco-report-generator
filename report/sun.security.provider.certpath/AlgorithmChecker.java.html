<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AlgorithmChecker.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.provider.certpath</a> &gt; <span class="el_source">AlgorithmChecker.java</span></div><h1>AlgorithmChecker.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider.certpath;

import java.security.AlgorithmConstraints;
import java.security.CryptoPrimitive;
import java.util.Collection;
import java.util.Collections;
import java.util.Set;
import java.util.EnumSet;
import java.util.HashSet;
import java.math.BigInteger;
import java.security.PublicKey;
import java.security.KeyFactory;
import java.security.AlgorithmParameters;
import java.security.NoSuchAlgorithmException;
import java.security.GeneralSecurityException;
import java.security.cert.Certificate;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.security.cert.PKIXCertPathChecker;
import java.security.cert.TrustAnchor;
import java.security.cert.CRLException;
import java.security.cert.CertificateException;
import java.security.cert.CertPathValidatorException;
import java.security.cert.CertPathValidatorException.BasicReason;
import java.security.cert.PKIXReason;
import java.io.IOException;
import java.security.interfaces.*;
import java.security.spec.*;

import sun.security.util.DisabledAlgorithmConstraints;
import sun.security.x509.X509CertImpl;
import sun.security.x509.X509CRLImpl;
import sun.security.x509.AlgorithmId;

/**
 * A &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; implementation to check whether a
 * specified certificate contains the required algorithm constraints.
 * &lt;p&gt;
 * Certificate fields such as the subject public key, the signature
 * algorithm, key usage, extended key usage, etc. need to conform to
 * the specified algorithm constraints.
 *
 * @see PKIXCertPathChecker
 * @see PKIXParameters
 */
final public class AlgorithmChecker extends PKIXCertPathChecker {

    private final AlgorithmConstraints constraints;
    private final PublicKey trustedPubKey;
    private PublicKey prevPubKey;

<span class="fc" id="L77">    private final static Set&lt;CryptoPrimitive&gt; SIGNATURE_PRIMITIVE_SET =</span>
<span class="fc" id="L78">                                    EnumSet.of(CryptoPrimitive.SIGNATURE);</span>

    private final static DisabledAlgorithmConstraints
<span class="fc" id="L81">        certPathDefaultConstraints = new DisabledAlgorithmConstraints(</span>
            DisabledAlgorithmConstraints.PROPERTY_CERTPATH_DISABLED_ALGS);

    /**
     * Create a new &lt;code&gt;AlgorithmChecker&lt;/code&gt; with the algorithm
     * constraints specified in security property
     * &quot;jdk.certpath.disabledAlgorithms&quot;.
     *
     * @param anchor the trust anchor selected to validate the target
     *     certificate
     */
    public AlgorithmChecker(TrustAnchor anchor) {
<span class="fc" id="L93">        this(anchor, certPathDefaultConstraints);</span>
<span class="fc" id="L94">    }</span>

    /**
     * Create a new &lt;code&gt;AlgorithmChecker&lt;/code&gt; with the
     * given {@code AlgorithmConstraints}.
     * &lt;p&gt;
     * Note that this constructor will be used to check a certification
     * path where the trust anchor is unknown, or a certificate list which may
     * contain the trust anchor. This constructor is used by SunJSSE.
     *
     * @param constraints the algorithm constraints (or null)
     */
<span class="fc" id="L106">    public AlgorithmChecker(AlgorithmConstraints constraints) {</span>
<span class="fc" id="L107">        this.prevPubKey = null;</span>
<span class="fc" id="L108">        this.trustedPubKey = null;</span>
<span class="fc" id="L109">        this.constraints = constraints;</span>
<span class="fc" id="L110">    }</span>

    /**
     * Create a new &lt;code&gt;AlgorithmChecker&lt;/code&gt; with the
     * given &lt;code&gt;TrustAnchor&lt;/code&gt; and &lt;code&gt;AlgorithmConstraints&lt;/code&gt;.
     *
     * @param anchor the trust anchor selected to validate the target
     *     certificate
     * @param constraints the algorithm constraints (or null)
     *
     * @throws IllegalArgumentException if the &lt;code&gt;anchor&lt;/code&gt; is null
     */
    public AlgorithmChecker(TrustAnchor anchor,
<span class="fc" id="L123">            AlgorithmConstraints constraints) {</span>

<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (anchor == null) {</span>
<span class="nc" id="L126">            throw new IllegalArgumentException(</span>
                        &quot;The trust anchor cannot be null&quot;);
        }

<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (anchor.getTrustedCert() != null) {</span>
<span class="fc" id="L131">            this.trustedPubKey = anchor.getTrustedCert().getPublicKey();</span>
        } else {
<span class="fc" id="L133">            this.trustedPubKey = anchor.getCAPublicKey();</span>
        }

<span class="fc" id="L136">        this.prevPubKey = trustedPubKey;</span>
<span class="fc" id="L137">        this.constraints = constraints;</span>
<span class="fc" id="L138">    }</span>

    @Override
    public void init(boolean forward) throws CertPathValidatorException {
        //  Note that this class does not support forward mode.
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (!forward) {</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (trustedPubKey != null) {</span>
<span class="fc" id="L145">                prevPubKey = trustedPubKey;</span>
            } else {
<span class="fc" id="L147">                prevPubKey = null;</span>
            }
        } else {
<span class="nc" id="L150">            throw new</span>
                CertPathValidatorException(&quot;forward checking not supported&quot;);
        }
<span class="fc" id="L153">    }</span>

    @Override
    public boolean isForwardCheckingSupported() {
        //  Note that as this class does not support forward mode, the method
        //  will always returns false.
<span class="fc" id="L159">        return false;</span>
    }

    @Override
    public Set&lt;String&gt; getSupportedExtensions() {
<span class="nc" id="L164">        return null;</span>
    }

    @Override
    public void check(Certificate cert,
            Collection&lt;String&gt; unresolvedCritExts)
            throws CertPathValidatorException {

<span class="pc bpc" id="L172" title="2 of 4 branches missed.">        if (!(cert instanceof X509Certificate) || constraints == null) {</span>
            // ignore the check for non-x.509 certificate or null constraints
<span class="nc" id="L174">            return;</span>
        }

<span class="fc" id="L177">        X509CertImpl x509Cert = null;</span>
        try {
<span class="fc" id="L179">            x509Cert = X509CertImpl.toImpl((X509Certificate)cert);</span>
<span class="nc" id="L180">        } catch (CertificateException ce) {</span>
<span class="nc" id="L181">            throw new CertPathValidatorException(ce);</span>
<span class="fc" id="L182">        }</span>

<span class="fc" id="L184">        PublicKey currPubKey = x509Cert.getPublicKey();</span>
<span class="fc" id="L185">        String currSigAlg = x509Cert.getSigAlgName();</span>

<span class="fc" id="L187">        AlgorithmId algorithmId = null;</span>
        try {
<span class="fc" id="L189">            algorithmId = (AlgorithmId)x509Cert.get(X509CertImpl.SIG_ALG);</span>
<span class="nc" id="L190">        } catch (CertificateException ce) {</span>
<span class="nc" id="L191">            throw new CertPathValidatorException(ce);</span>
<span class="fc" id="L192">        }</span>

<span class="fc" id="L194">        AlgorithmParameters currSigAlgParams = algorithmId.getParameters();</span>

        // Check the current signature algorithm
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (!constraints.permits(</span>
                SIGNATURE_PRIMITIVE_SET,
                currSigAlg, currSigAlgParams)) {
<span class="fc" id="L200">            throw new CertPathValidatorException(</span>
                &quot;Algorithm constraints check failed: &quot; + currSigAlg,
                null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
        }

        // check the key usage and key size
<span class="fc" id="L206">        boolean[] keyUsage = x509Cert.getKeyUsage();</span>
<span class="pc bpc" id="L207" title="1 of 4 branches missed.">        if (keyUsage != null &amp;&amp; keyUsage.length &lt; 9) {</span>
<span class="nc" id="L208">            throw new CertPathValidatorException(</span>
                &quot;incorrect KeyUsage extension&quot;,
                null, null, -1, PKIXReason.INVALID_KEY_USAGE);
        }

<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (keyUsage != null) {</span>
<span class="fc" id="L214">            Set&lt;CryptoPrimitive&gt; primitives =</span>
<span class="fc" id="L215">                        EnumSet.noneOf(CryptoPrimitive.class);</span>

<span class="pc bpc" id="L217" title="2 of 8 branches missed.">            if (keyUsage[0] || keyUsage[1] || keyUsage[5] || keyUsage[6]) {</span>
                // keyUsage[0]: KeyUsage.digitalSignature
                // keyUsage[1]: KeyUsage.nonRepudiation
                // keyUsage[5]: KeyUsage.keyCertSign
                // keyUsage[6]: KeyUsage.cRLSign
<span class="fc" id="L222">                primitives.add(CryptoPrimitive.SIGNATURE);</span>
            }

<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (keyUsage[2]) {      // KeyUsage.keyEncipherment</span>
<span class="fc" id="L226">                primitives.add(CryptoPrimitive.KEY_ENCAPSULATION);</span>
            }

<span class="pc bpc" id="L229" title="1 of 2 branches missed.">            if (keyUsage[3]) {      // KeyUsage.dataEncipherment</span>
<span class="nc" id="L230">                primitives.add(CryptoPrimitive.PUBLIC_KEY_ENCRYPTION);</span>
            }

<span class="fc bfc" id="L233" title="All 2 branches covered.">            if (keyUsage[4]) {      // KeyUsage.keyAgreement</span>
<span class="fc" id="L234">                primitives.add(CryptoPrimitive.KEY_AGREEMENT);</span>
            }

            // KeyUsage.encipherOnly and KeyUsage.decipherOnly are
            // undefined in the absence of the keyAgreement bit.

<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            if (!primitives.isEmpty()) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                if (!constraints.permits(primitives, currPubKey)) {</span>
<span class="fc" id="L242">                    throw new CertPathValidatorException(</span>
                        &quot;algorithm constraints check failed&quot;,
                        null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
                }
            }
        }

        // Check with previous cert for signature algorithm and public key
<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (prevPubKey != null) {</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            if (currSigAlg != null) {</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">                if (!constraints.permits(</span>
                        SIGNATURE_PRIMITIVE_SET,
                        currSigAlg, prevPubKey, currSigAlgParams)) {
<span class="nc" id="L255">                    throw new CertPathValidatorException(</span>
                        &quot;Algorithm constraints check failed: &quot; + currSigAlg,
                        null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
                }
            }

            // Inherit key parameters from previous key
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">            if (PKIX.isDSAPublicKeyWithoutParams(currPubKey)) {</span>
                // Inherit DSA parameters from previous key
<span class="nc bnc" id="L264" title="All 2 branches missed.">                if (!(prevPubKey instanceof DSAPublicKey)) {</span>
<span class="nc" id="L265">                    throw new CertPathValidatorException(&quot;Input key is not &quot; +</span>
                        &quot;of a appropriate type for inheriting parameters&quot;);
                }

<span class="nc" id="L269">                DSAParams params = ((DSAPublicKey)prevPubKey).getParams();</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                if (params == null) {</span>
<span class="nc" id="L271">                    throw new CertPathValidatorException(</span>
                                    &quot;Key parameters missing&quot;);
                }

                try {
<span class="nc" id="L276">                    BigInteger y = ((DSAPublicKey)currPubKey).getY();</span>
<span class="nc" id="L277">                    KeyFactory kf = KeyFactory.getInstance(&quot;DSA&quot;);</span>
<span class="nc" id="L278">                    DSAPublicKeySpec ks = new DSAPublicKeySpec(y,</span>
<span class="nc" id="L279">                                                       params.getP(),</span>
<span class="nc" id="L280">                                                       params.getQ(),</span>
<span class="nc" id="L281">                                                       params.getG());</span>
<span class="nc" id="L282">                    currPubKey = kf.generatePublic(ks);</span>
<span class="nc" id="L283">                } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L284">                    throw new CertPathValidatorException(&quot;Unable to generate &quot; +</span>
<span class="nc" id="L285">                        &quot;key with inherited parameters: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L286">                }</span>
            }
        }

        // reset the previous public key
<span class="fc" id="L291">        prevPubKey = currPubKey;</span>

        // check the extended key usage, ignore the check now
        // List&lt;String&gt; extendedKeyUsages = x509Cert.getExtendedKeyUsage();

        // DO NOT remove any unresolved critical extensions
<span class="fc" id="L297">    }</span>

    /**
     * Try to set the trust anchor of the checker.
     * &lt;p&gt;
     * If there is no trust anchor specified and the checker has not started,
     * set the trust anchor.
     *
     * @param anchor the trust anchor selected to validate the target
     *     certificate
     */
    void trySetTrustAnchor(TrustAnchor anchor) {
        // Don't bother if the check has started or trust anchor has already
        // specified.
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        if (prevPubKey == null) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (anchor == null) {</span>
<span class="nc" id="L313">                throw new IllegalArgumentException(</span>
                        &quot;The trust anchor cannot be null&quot;);
            }

            // Don't bother to change the trustedPubKey.
<span class="nc bnc" id="L318" title="All 2 branches missed.">            if (anchor.getTrustedCert() != null) {</span>
<span class="nc" id="L319">                prevPubKey = anchor.getTrustedCert().getPublicKey();</span>
            } else {
<span class="nc" id="L321">                prevPubKey = anchor.getCAPublicKey();</span>
            }
        }
<span class="fc" id="L324">    }</span>

    /**
     * Check the signature algorithm with the specified public key.
     *
     * @param key the public key to verify the CRL signature
     * @param crl the target CRL
     */
    static void check(PublicKey key, X509CRL crl)
                        throws CertPathValidatorException {

<span class="fc" id="L335">        X509CRLImpl x509CRLImpl = null;</span>
        try {
<span class="fc" id="L337">            x509CRLImpl = X509CRLImpl.toImpl(crl);</span>
<span class="nc" id="L338">        } catch (CRLException ce) {</span>
<span class="nc" id="L339">            throw new CertPathValidatorException(ce);</span>
<span class="fc" id="L340">        }</span>

<span class="fc" id="L342">        AlgorithmId algorithmId = x509CRLImpl.getSigAlgId();</span>
<span class="fc" id="L343">        check(key, algorithmId);</span>
<span class="fc" id="L344">    }</span>

    /**
     * Check the signature algorithm with the specified public key.
     *
     * @param key the public key to verify the CRL signature
     * @param crl the target CRL
     */
    static void check(PublicKey key, AlgorithmId algorithmId)
                        throws CertPathValidatorException {
<span class="fc" id="L354">        String sigAlgName = algorithmId.getName();</span>
<span class="fc" id="L355">        AlgorithmParameters sigAlgParams = algorithmId.getParameters();</span>

<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        if (!certPathDefaultConstraints.permits(</span>
                SIGNATURE_PRIMITIVE_SET, sigAlgName, key, sigAlgParams)) {
<span class="nc" id="L359">            throw new CertPathValidatorException(</span>
                &quot;algorithm check failed: &quot; + sigAlgName + &quot; is disabled&quot;,
                null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
        }
<span class="fc" id="L363">    }</span>

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>