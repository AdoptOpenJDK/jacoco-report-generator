<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SunCertPathBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.provider.certpath</a> &gt; <span class="el_source">SunCertPathBuilder.java</span></div><h1>SunCertPathBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider.certpath;

import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.PublicKey;
import java.security.cert.*;
import java.security.cert.PKIXReason;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.LinkedList;
import java.util.Set;
import javax.security.auth.x500.X500Principal;

import sun.security.provider.certpath.PKIX.BuilderParams;
import static sun.security.x509.PKIXExtensions.*;
import sun.security.util.Debug;

/**
 * This class is able to build certification paths in either the forward
 * or reverse directions.
 *
 * &lt;p&gt; If successful, it returns a certification path which has succesfully
 * satisfied all the constraints and requirements specified in the
 * PKIXBuilderParameters object and has been validated according to the PKIX
 * path validation algorithm defined in RFC 3280.
 *
 * &lt;p&gt; This implementation uses a depth-first search approach to finding
 * certification paths. If it comes to a point in which it cannot find
 * any more certificates leading to the target OR the path length is too long
 * it backtracks to previous paths until the target has been found or
 * all possible paths have been exhausted.
 *
 * &lt;p&gt; This implementation is not thread-safe.
 *
 * @since       1.4
 * @author      Sean Mullan
 * @author      Yassir Elley
 */
public final class SunCertPathBuilder extends CertPathBuilderSpi {

<span class="fc" id="L71">    private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);</span>

    /*
     * private objects shared by methods
     */
    private BuilderParams buildParams;
    private CertificateFactory cf;
<span class="fc" id="L78">    private boolean pathCompleted = false;</span>
    private PolicyNode policyTreeResult;
    private TrustAnchor trustAnchor;
    private PublicKey finalPublicKey;

    /**
     * Create an instance of &lt;code&gt;SunCertPathBuilder&lt;/code&gt;.
     *
     * @throws CertPathBuilderException if an error occurs
     */
<span class="fc" id="L88">    public SunCertPathBuilder() throws CertPathBuilderException {</span>
        try {
<span class="fc" id="L90">            cf = CertificateFactory.getInstance(&quot;X.509&quot;);</span>
<span class="nc" id="L91">        } catch (CertificateException e) {</span>
<span class="nc" id="L92">            throw new CertPathBuilderException(e);</span>
<span class="fc" id="L93">        }</span>
<span class="fc" id="L94">    }</span>

    @Override
    public CertPathChecker engineGetRevocationChecker() {
<span class="nc" id="L98">        return new RevocationChecker();</span>
    }

    /**
     * Attempts to build a certification path using the Sun build
     * algorithm from a trusted anchor(s) to a target subject, which must both
     * be specified in the input parameter set. By default, this method will
     * attempt to build in the forward direction. In order to build in the
     * reverse direction, the caller needs to pass in an instance of
     * SunCertPathBuilderParameters with the buildForward flag set to false.
     *
     * &lt;p&gt;The certification path that is constructed is validated
     * according to the PKIX specification.
     *
     * @param params the parameter set for building a path. Must be an instance
     *  of &lt;code&gt;PKIXBuilderParameters&lt;/code&gt;.
     * @return a certification path builder result.
     * @exception CertPathBuilderException Exception thrown if builder is
     *  unable to build a complete certification path from the trusted anchor(s)
     *  to the target subject.
     * @throws InvalidAlgorithmParameterException if the given parameters are
     *  inappropriate for this certification path builder.
     */
    @Override
    public CertPathBuilderResult engineBuild(CertPathParameters params)
        throws CertPathBuilderException, InvalidAlgorithmParameterException {

<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L126">            debug.println(&quot;SunCertPathBuilder.engineBuild(&quot; + params + &quot;)&quot;);</span>
        }

<span class="fc" id="L129">        buildParams = PKIX.checkBuilderParams(params);</span>
<span class="fc" id="L130">        return build();</span>
    }

    private PKIXCertPathBuilderResult build() throws CertPathBuilderException {
<span class="fc" id="L134">        List&lt;List&lt;Vertex&gt;&gt; adjList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L135">        PKIXCertPathBuilderResult result = buildCertPath(false, adjList);</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (result == null) {</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L138">                debug.println(&quot;SunCertPathBuilder.engineBuild: 2nd pass&quot;);</span>
            }
            // try again
<span class="fc" id="L141">            adjList.clear();</span>
<span class="fc" id="L142">            result = buildCertPath(true, adjList);</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">            if (result == null) {</span>
<span class="fc" id="L144">                throw new SunCertPathBuilderException(&quot;unable to find valid &quot;</span>
                    + &quot;certification path to requested target&quot;,
                    new AdjacencyList(adjList));
            }
        }
<span class="fc" id="L149">        return result;</span>
    }

    private PKIXCertPathBuilderResult buildCertPath(boolean searchAllCertStores,
                                                    List&lt;List&lt;Vertex&gt;&gt; adjList)
        throws CertPathBuilderException
    {
        // Init shared variables and build certification path
<span class="fc" id="L157">        pathCompleted = false;</span>
<span class="fc" id="L158">        trustAnchor = null;</span>
<span class="fc" id="L159">        finalPublicKey = null;</span>
<span class="fc" id="L160">        policyTreeResult = null;</span>
<span class="fc" id="L161">        LinkedList&lt;X509Certificate&gt; certPathList = new LinkedList&lt;&gt;();</span>
        try {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">            if (buildParams.buildForward()) {</span>
<span class="fc" id="L164">                buildForward(adjList, certPathList, searchAllCertStores);</span>
            } else {
<span class="nc" id="L166">                buildReverse(adjList, certPathList);</span>
            }
<span class="nc" id="L168">        } catch (GeneralSecurityException | IOException e) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L170">                debug.println(&quot;SunCertPathBuilder.engineBuild() exception in &quot;</span>
                    + &quot;build&quot;);
<span class="nc" id="L172">                e.printStackTrace();</span>
            }
<span class="nc" id="L174">            throw new SunCertPathBuilderException(&quot;unable to find valid &quot;</span>
                + &quot;certification path to requested target&quot;, e,
                new AdjacencyList(adjList));
<span class="fc" id="L177">        }</span>

        // construct SunCertPathBuilderResult
        try {
<span class="fc bfc" id="L181" title="All 2 branches covered.">            if (pathCompleted) {</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">                if (debug != null)</span>
<span class="nc" id="L183">                    debug.println(&quot;SunCertPathBuilder.engineBuild() &quot;</span>
                                  + &quot;pathCompleted&quot;);

                // we must return a certpath which has the target
                // as the first cert in the certpath - i.e. reverse
                // the certPathList
<span class="fc" id="L189">                Collections.reverse(certPathList);</span>

<span class="fc" id="L191">                return new SunCertPathBuilderResult(</span>
<span class="fc" id="L192">                    cf.generateCertPath(certPathList), trustAnchor,</span>
                    policyTreeResult, finalPublicKey,
                    new AdjacencyList(adjList));
            }
<span class="nc" id="L196">        } catch (CertificateException e) {</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L198">                debug.println(&quot;SunCertPathBuilder.engineBuild() exception &quot;</span>
                              + &quot;in wrap-up&quot;);
<span class="nc" id="L200">                e.printStackTrace();</span>
            }
<span class="nc" id="L202">            throw new SunCertPathBuilderException(&quot;unable to find valid &quot;</span>
                + &quot;certification path to requested target&quot;, e,
                new AdjacencyList(adjList));
<span class="fc" id="L205">        }</span>

<span class="fc" id="L207">        return null;</span>
    }

    /*
     * Private build reverse method.
     */
    private void buildReverse(List&lt;List&lt;Vertex&gt;&gt; adjacencyList,
                              LinkedList&lt;X509Certificate&gt; certPathList)
        throws GeneralSecurityException, IOException
    {
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L218">            debug.println(&quot;SunCertPathBuilder.buildReverse()...&quot;);</span>
<span class="nc" id="L219">            debug.println(&quot;SunCertPathBuilder.buildReverse() InitialPolicies: &quot;</span>
<span class="nc" id="L220">                + buildParams.initialPolicies());</span>
        }

<span class="nc" id="L223">        ReverseState currentState = new ReverseState();</span>
        /* Initialize adjacency list */
<span class="nc" id="L225">        adjacencyList.clear();</span>
<span class="nc" id="L226">        adjacencyList.add(new LinkedList&lt;Vertex&gt;());</span>

        /*
         * Perform a search using each trust anchor, until a valid
         * path is found
         */
<span class="nc" id="L232">        Iterator&lt;TrustAnchor&gt; iter = buildParams.trustAnchors().iterator();</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L234">            TrustAnchor anchor = iter.next();</span>

            /* check if anchor satisfies target constraints */
<span class="nc bnc" id="L237" title="All 2 branches missed.">            if (anchorIsTarget(anchor, buildParams.targetCertConstraints())) {</span>
<span class="nc" id="L238">                this.trustAnchor = anchor;</span>
<span class="nc" id="L239">                this.pathCompleted = true;</span>
<span class="nc" id="L240">                this.finalPublicKey = anchor.getTrustedCert().getPublicKey();</span>
<span class="nc" id="L241">                break;</span>
            }

            // skip anchor if it contains a DSA key with no DSA params
<span class="nc" id="L245">            X509Certificate trustedCert = anchor.getTrustedCert();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            PublicKey pubKey = trustedCert != null ? trustedCert.getPublicKey()</span>
<span class="nc" id="L247">                                                   : anchor.getCAPublicKey();</span>

<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (PKIX.isDSAPublicKeyWithoutParams(pubKey)) {</span>
<span class="nc" id="L250">                continue;</span>
            }

            /* Initialize current state */
<span class="nc" id="L254">            currentState.initState(buildParams);</span>
<span class="nc" id="L255">            currentState.updateState(anchor, buildParams);</span>

<span class="nc" id="L257">            currentState.algorithmChecker = new AlgorithmChecker(anchor);</span>
<span class="nc" id="L258">            currentState.untrustedChecker = new UntrustedChecker();</span>
            try {
<span class="nc" id="L260">                depthFirstSearchReverse(null, currentState,</span>
                                        new ReverseBuilder(buildParams),
                                        adjacencyList, certPathList);
<span class="nc" id="L263">            } catch (GeneralSecurityException | IOException e) {</span>
                // continue on error if more anchors to try
<span class="nc bnc" id="L265" title="All 2 branches missed.">                if (iter.hasNext())</span>
<span class="nc" id="L266">                    continue;</span>
                else
<span class="nc" id="L268">                    throw e;</span>
<span class="nc" id="L269">            }</span>

            // break out of loop if search is successful
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (pathCompleted) {</span>
<span class="nc" id="L273">                break;</span>
            }
<span class="nc" id="L275">        }</span>

<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L278">            debug.println(&quot;SunCertPathBuilder.buildReverse() returned from &quot;</span>
                + &quot;depthFirstSearchReverse()&quot;);
<span class="nc" id="L280">            debug.println(&quot;SunCertPathBuilder.buildReverse() &quot;</span>
<span class="nc" id="L281">                + &quot;certPathList.size: &quot; + certPathList.size());</span>
        }
<span class="nc" id="L283">    }</span>

    /*
     * Private build forward method.
     */
    private void buildForward(List&lt;List&lt;Vertex&gt;&gt; adjacencyList,
                              LinkedList&lt;X509Certificate&gt; certPathList,
                              boolean searchAllCertStores)
        throws GeneralSecurityException, IOException
    {
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L294">            debug.println(&quot;SunCertPathBuilder.buildForward()...&quot;);</span>
        }

        /* Initialize current state */
<span class="fc" id="L298">        ForwardState currentState = new ForwardState();</span>
<span class="fc" id="L299">        currentState.initState(buildParams.certPathCheckers());</span>

        /* Initialize adjacency list */
<span class="fc" id="L302">        adjacencyList.clear();</span>
<span class="fc" id="L303">        adjacencyList.add(new LinkedList&lt;Vertex&gt;());</span>

<span class="fc" id="L305">        currentState.untrustedChecker = new UntrustedChecker();</span>

<span class="fc" id="L307">        depthFirstSearchForward(buildParams.targetSubject(), currentState,</span>
                                new ForwardBuilder(buildParams,
                                                   searchAllCertStores),
                                adjacencyList, certPathList);
<span class="fc" id="L311">    }</span>

    /*
     * This method performs a depth first search for a certification
     * path while building forward which meets the requirements set in
     * the parameters object.
     * It uses an adjacency list to store all certificates which were
     * tried (i.e. at one time added to the path - they may not end up in
     * the final path if backtracking occurs). This information can
     * be used later to debug or demo the build.
     *
     * See &quot;Data Structure and Algorithms, by Aho, Hopcroft, and Ullman&quot;
     * for an explanation of the DFS algorithm.
     *
     * @param dN the distinguished name being currently searched for certs
     * @param currentState the current PKIX validation state
     */
    private void depthFirstSearchForward(X500Principal dN,
                                         ForwardState currentState,
                                         ForwardBuilder builder,
                                         List&lt;List&lt;Vertex&gt;&gt; adjList,
                                         LinkedList&lt;X509Certificate&gt; cpList)
        throws GeneralSecurityException, IOException
    {
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L336">            debug.println(&quot;SunCertPathBuilder.depthFirstSearchForward(&quot; + dN</span>
<span class="nc" id="L337">                          + &quot;, &quot; + currentState.toString() + &quot;)&quot;);</span>
        }

        /*
         * Find all the certificates issued to dN which
         * satisfy the PKIX certification path constraints.
         */
<span class="fc" id="L344">        Collection&lt;X509Certificate&gt; certs =</span>
<span class="fc" id="L345">            builder.getMatchingCerts(currentState, buildParams.certStores());</span>
<span class="fc" id="L346">        List&lt;Vertex&gt; vertices = addVertices(certs, adjList);</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L348">            debug.println(&quot;SunCertPathBuilder.depthFirstSearchForward(): &quot;</span>
<span class="nc" id="L349">                          + &quot;certs.size=&quot; + vertices.size());</span>
        }

        /*
         * For each cert in the collection, verify anything
         * that hasn't been checked yet (signature, revocation, etc)
         * and check for loops. Call depthFirstSearchForward()
         * recursively for each good cert.
         */

               vertices:
<span class="fc bfc" id="L360" title="All 2 branches covered.">        for (Vertex vertex : vertices) {</span>
            /**
             * Restore state to currentState each time through the loop.
             * This is important because some of the user-defined
             * checkers modify the state, which MUST be restored if
             * the cert eventually fails to lead to the target and
             * the next matching cert is tried.
             */
<span class="fc" id="L368">            ForwardState nextState = (ForwardState) currentState.clone();</span>
<span class="fc" id="L369">            X509Certificate cert = vertex.getCertificate();</span>

            try {
<span class="fc" id="L372">                builder.verifyCert(cert, nextState, cpList);</span>
<span class="nc" id="L373">            } catch (GeneralSecurityException gse) {</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L375">                    debug.println(&quot;SunCertPathBuilder.depthFirstSearchForward()&quot;</span>
                                  + &quot;: validation failed: &quot; + gse);
<span class="nc" id="L377">                    gse.printStackTrace();</span>
                }
<span class="nc" id="L379">                vertex.setThrowable(gse);</span>
<span class="nc" id="L380">                continue;</span>
<span class="fc" id="L381">            }</span>

            /*
             * Certificate is good.
             * If cert completes the path,
             *    process userCheckers that don't support forward checking
             *    and process policies over whole path
             *    and backtrack appropriately if there is a failure
             * else if cert does not complete the path,
             *    add it to the path
             */
<span class="fc bfc" id="L392" title="All 2 branches covered.">            if (builder.isPathCompleted(cert)) {</span>

<span class="pc bpc" id="L394" title="1 of 2 branches missed.">                if (debug != null)</span>
<span class="nc" id="L395">                    debug.println(&quot;SunCertPathBuilder.depthFirstSearchForward()&quot;</span>
                                  + &quot;: commencing final verification&quot;);

<span class="fc" id="L398">                List&lt;X509Certificate&gt; appendedCerts = new ArrayList&lt;&gt;(cpList);</span>

                /*
                 * if the trust anchor selected is specified as a trusted
                 * public key rather than a trusted cert, then verify this
                 * cert (which is signed by the trusted public key), but
                 * don't add it yet to the cpList
                 */
<span class="fc bfc" id="L406" title="All 2 branches covered.">                if (builder.trustAnchor.getTrustedCert() == null) {</span>
<span class="fc" id="L407">                    appendedCerts.add(0, cert);</span>
                }

<span class="fc" id="L410">                Set&lt;String&gt; initExpPolSet =</span>
<span class="fc" id="L411">                    Collections.singleton(PolicyChecker.ANY_POLICY);</span>

<span class="fc" id="L413">                PolicyNodeImpl rootNode = new PolicyNodeImpl(null,</span>
                    PolicyChecker.ANY_POLICY, null, false, initExpPolSet, false);

<span class="fc" id="L416">                List&lt;PKIXCertPathChecker&gt; checkers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L417">                PolicyChecker policyChecker</span>
<span class="fc" id="L418">                    = new PolicyChecker(buildParams.initialPolicies(),</span>
<span class="fc" id="L419">                                        appendedCerts.size(),</span>
<span class="fc" id="L420">                                        buildParams.explicitPolicyRequired(),</span>
<span class="fc" id="L421">                                        buildParams.policyMappingInhibited(),</span>
<span class="fc" id="L422">                                        buildParams.anyPolicyInhibited(),</span>
<span class="fc" id="L423">                                        buildParams.policyQualifiersRejected(),</span>
                                        rootNode);
<span class="fc" id="L425">                checkers.add(policyChecker);</span>

                // add the algorithm checker
<span class="fc" id="L428">                checkers.add(new AlgorithmChecker(builder.trustAnchor));</span>

<span class="fc" id="L430">                BasicChecker basicChecker = null;</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">                if (nextState.keyParamsNeeded()) {</span>
<span class="nc" id="L432">                    PublicKey rootKey = cert.getPublicKey();</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">                    if (builder.trustAnchor.getTrustedCert() == null) {</span>
<span class="nc" id="L434">                        rootKey = builder.trustAnchor.getCAPublicKey();</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                        if (debug != null)</span>
<span class="nc" id="L436">                            debug.println(</span>
                                &quot;SunCertPathBuilder.depthFirstSearchForward &quot; +
                                &quot;using buildParams public key: &quot; +
<span class="nc" id="L439">                                rootKey.toString());</span>
                    }
<span class="nc" id="L441">                    TrustAnchor anchor = new TrustAnchor</span>
<span class="nc" id="L442">                        (cert.getSubjectX500Principal(), rootKey, null);</span>

                    // add the basic checker
<span class="nc" id="L445">                    basicChecker = new BasicChecker(anchor, buildParams.date(),</span>
<span class="nc" id="L446">                                                    buildParams.sigProvider(),</span>
                                                    true);
<span class="nc" id="L448">                    checkers.add(basicChecker);</span>
                }

<span class="fc" id="L451">                buildParams.setCertPath(cf.generateCertPath(appendedCerts));</span>

<span class="fc" id="L453">                boolean revCheckerAdded = false;</span>
<span class="fc" id="L454">                List&lt;PKIXCertPathChecker&gt; ckrs = buildParams.certPathCheckers();</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                for (PKIXCertPathChecker ckr : ckrs) {</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                    if (ckr instanceof PKIXRevocationChecker) {</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                        if (revCheckerAdded) {</span>
<span class="nc" id="L458">                            throw new CertPathValidatorException(</span>
                                &quot;Only one PKIXRevocationChecker can be specified&quot;);
                        }
<span class="nc" id="L461">                        revCheckerAdded = true;</span>
                        // if it's our own, initialize it
<span class="nc bnc" id="L463" title="All 2 branches missed.">                        if (ckr instanceof RevocationChecker) {</span>
<span class="nc" id="L464">                            ((RevocationChecker)ckr).init(builder.trustAnchor,</span>
                                                          buildParams);
                        }
                    }
<span class="nc" id="L468">                }</span>
                // only add a RevocationChecker if revocation is enabled and
                // a PKIXRevocationChecker has not already been added
<span class="pc bpc" id="L471" title="1 of 4 branches missed.">                if (buildParams.revocationEnabled() &amp;&amp; !revCheckerAdded) {</span>
<span class="fc" id="L472">                    checkers.add(new RevocationChecker(builder.trustAnchor,</span>
                                                       buildParams));
                }

<span class="fc" id="L476">                checkers.addAll(ckrs);</span>

                // Why we don't need BasicChecker and RevocationChecker
                // if nextState.keyParamsNeeded() is false?

<span class="fc bfc" id="L481" title="All 2 branches covered.">                for (int i = 0; i &lt; appendedCerts.size(); i++) {</span>
<span class="fc" id="L482">                    X509Certificate currCert = appendedCerts.get(i);</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">                    if (debug != null)</span>
<span class="nc" id="L484">                        debug.println(&quot;current subject = &quot;</span>
<span class="nc" id="L485">                                      + currCert.getSubjectX500Principal());</span>
<span class="fc" id="L486">                    Set&lt;String&gt; unresCritExts =</span>
<span class="fc" id="L487">                        currCert.getCriticalExtensionOIDs();</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">                    if (unresCritExts == null) {</span>
<span class="nc" id="L489">                        unresCritExts = Collections.&lt;String&gt;emptySet();</span>
                    }

<span class="fc bfc" id="L492" title="All 2 branches covered.">                    for (PKIXCertPathChecker currChecker : checkers) {</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">                        if (!currChecker.isForwardCheckingSupported()) {</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">                            if (i == 0) {</span>
<span class="fc" id="L495">                                currChecker.init(false);</span>

                                // The user specified
                                // AlgorithmChecker may not be
                                // able to set the trust anchor until now.
<span class="fc bfc" id="L500" title="All 2 branches covered.">                                if (currChecker instanceof AlgorithmChecker) {</span>
<span class="fc" id="L501">                                    ((AlgorithmChecker)currChecker).</span>
<span class="fc" id="L502">                                        trySetTrustAnchor(builder.trustAnchor);</span>
                                }
                            }

                            try {
<span class="fc" id="L507">                                currChecker.check(currCert, unresCritExts);</span>
<span class="fc" id="L508">                            } catch (CertPathValidatorException cpve) {</span>
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">                                if (debug != null)</span>
<span class="nc" id="L510">                                    debug.println</span>
<span class="nc" id="L511">                                    (&quot;SunCertPathBuilder.depthFirstSearchForward(): &quot; +</span>
                                    &quot;final verification failed: &quot; + cpve);
<span class="fc" id="L513">                                vertex.setThrowable(cpve);</span>
<span class="fc" id="L514">                                continue vertices;</span>
<span class="fc" id="L515">                            }</span>
                        }
<span class="fc" id="L517">                    }</span>

                    /*
                     * Remove extensions from user checkers that support
                     * forward checking. After this step, we will have
                     * removed all extensions that all user checkers
                     * are capable of processing.
                     */
                    for (PKIXCertPathChecker checker :
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">                         buildParams.certPathCheckers())</span>
                    {
<span class="nc bnc" id="L528" title="All 2 branches missed.">                        if (checker.isForwardCheckingSupported()) {</span>
<span class="nc" id="L529">                            Set&lt;String&gt; suppExts =</span>
<span class="nc" id="L530">                                checker.getSupportedExtensions();</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                            if (suppExts != null) {</span>
<span class="nc" id="L532">                                unresCritExts.removeAll(suppExts);</span>
                            }
                        }
<span class="nc" id="L535">                    }</span>

<span class="fc bfc" id="L537" title="All 2 branches covered.">                    if (!unresCritExts.isEmpty()) {</span>
<span class="fc" id="L538">                        unresCritExts.remove(BasicConstraints_Id.toString());</span>
<span class="fc" id="L539">                        unresCritExts.remove(NameConstraints_Id.toString());</span>
<span class="fc" id="L540">                        unresCritExts.remove(CertificatePolicies_Id.toString());</span>
<span class="fc" id="L541">                        unresCritExts.remove(PolicyMappings_Id.toString());</span>
<span class="fc" id="L542">                        unresCritExts.remove(PolicyConstraints_Id.toString());</span>
<span class="fc" id="L543">                        unresCritExts.remove(InhibitAnyPolicy_Id.toString());</span>
<span class="fc" id="L544">                        unresCritExts.remove(</span>
<span class="fc" id="L545">                            SubjectAlternativeName_Id.toString());</span>
<span class="fc" id="L546">                        unresCritExts.remove(KeyUsage_Id.toString());</span>
<span class="fc" id="L547">                        unresCritExts.remove(ExtendedKeyUsage_Id.toString());</span>

<span class="pc bpc" id="L549" title="1 of 2 branches missed.">                        if (!unresCritExts.isEmpty()) {</span>
<span class="nc" id="L550">                            throw new CertPathValidatorException</span>
                                (&quot;unrecognized critical extension(s)&quot;, null,
                                 null, -1, PKIXReason.UNRECOGNIZED_CRIT_EXT);
                        }
                    }
                }
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">                if (debug != null)</span>
<span class="nc" id="L557">                    debug.println(&quot;SunCertPathBuilder.depthFirstSearchForward()&quot;</span>
                        + &quot;: final verification succeeded - path completed!&quot;);
<span class="fc" id="L559">                pathCompleted = true;</span>

                /*
                 * if the user specified a trusted public key rather than
                 * trusted certs, then add this cert (which is signed by
                 * the trusted public key) to the cpList
                 */
<span class="fc bfc" id="L566" title="All 2 branches covered.">                if (builder.trustAnchor.getTrustedCert() == null)</span>
<span class="fc" id="L567">                    builder.addCertToPath(cert, cpList);</span>
                // Save the trust anchor
<span class="fc" id="L569">                this.trustAnchor = builder.trustAnchor;</span>

                /*
                 * Extract and save the final target public key
                 */
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">                if (basicChecker != null) {</span>
<span class="nc" id="L575">                    finalPublicKey = basicChecker.getPublicKey();</span>
                } else {
                    Certificate finalCert;
<span class="fc bfc" id="L578" title="All 2 branches covered.">                    if (cpList.isEmpty()) {</span>
<span class="fc" id="L579">                        finalCert = builder.trustAnchor.getTrustedCert();</span>
                    } else {
<span class="fc" id="L581">                        finalCert = cpList.getLast();</span>
                    }
<span class="fc" id="L583">                    finalPublicKey = finalCert.getPublicKey();</span>
                }

<span class="fc" id="L586">                policyTreeResult = policyChecker.getPolicyTree();</span>
<span class="fc" id="L587">                return;</span>
            } else {
<span class="fc" id="L589">                builder.addCertToPath(cert, cpList);</span>
            }

            /* Update the PKIX state */
<span class="fc" id="L593">            nextState.updateState(cert);</span>

            /*
             * Append an entry for cert in adjacency list and
             * set index for current vertex.
             */
<span class="fc" id="L599">            adjList.add(new LinkedList&lt;Vertex&gt;());</span>
<span class="fc" id="L600">            vertex.setIndex(adjList.size() - 1);</span>

            /* recursively search for matching certs at next dN */
<span class="fc" id="L603">            depthFirstSearchForward(cert.getIssuerX500Principal(), nextState,</span>
                                    builder, adjList, cpList);

            /*
             * If path has been completed, return ASAP!
             */
<span class="fc bfc" id="L609" title="All 2 branches covered.">            if (pathCompleted) {</span>
<span class="fc" id="L610">                return;</span>
            } else {
                /*
                 * If we get here, it means we have searched all possible
                 * certs issued by the dN w/o finding any matching certs.
                 * This means we have to backtrack to the previous cert in
                 * the path and try some other paths.
                 */
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">                if (debug != null)</span>
<span class="nc" id="L619">                    debug.println(&quot;SunCertPathBuilder.depthFirstSearchForward()&quot;</span>
                                  + &quot;: backtracking&quot;);
<span class="fc" id="L621">                builder.removeFinalCertFromPath(cpList);</span>
            }
<span class="fc" id="L623">        }</span>
<span class="fc" id="L624">    }</span>

    /*
     * This method performs a depth first search for a certification
     * path while building reverse which meets the requirements set in
     * the parameters object.
     * It uses an adjacency list to store all certificates which were
     * tried (i.e. at one time added to the path - they may not end up in
     * the final path if backtracking occurs). This information can
     * be used later to debug or demo the build.
     *
     * See &quot;Data Structure and Algorithms, by Aho, Hopcroft, and Ullman&quot;
     * for an explanation of the DFS algorithm.
     *
     * @param dN the distinguished name being currently searched for certs
     * @param currentState the current PKIX validation state
     */
    private void depthFirstSearchReverse(X500Principal dN,
                                         ReverseState currentState,
                                         ReverseBuilder builder,
                                         List&lt;List&lt;Vertex&gt;&gt; adjList,
                                         LinkedList&lt;X509Certificate&gt; cpList)
        throws GeneralSecurityException, IOException
    {
<span class="nc bnc" id="L648" title="All 2 branches missed.">        if (debug != null)</span>
<span class="nc" id="L649">            debug.println(&quot;SunCertPathBuilder.depthFirstSearchReverse(&quot; + dN</span>
<span class="nc" id="L650">                + &quot;, &quot; + currentState.toString() + &quot;)&quot;);</span>

        /*
         * Find all the certificates issued by dN which
         * satisfy the PKIX certification path constraints.
         */
<span class="nc" id="L656">        Collection&lt;X509Certificate&gt; certs =</span>
<span class="nc" id="L657">            builder.getMatchingCerts(currentState, buildParams.certStores());</span>
<span class="nc" id="L658">        List&lt;Vertex&gt; vertices = addVertices(certs, adjList);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">        if (debug != null)</span>
<span class="nc" id="L660">            debug.println(&quot;SunCertPathBuilder.depthFirstSearchReverse(): &quot;</span>
<span class="nc" id="L661">                + &quot;certs.size=&quot; + vertices.size());</span>

        /*
         * For each cert in the collection, verify anything
         * that hasn't been checked yet (signature, revocation, etc)
         * and check for loops. Call depthFirstSearchReverse()
         * recursively for each good cert.
         */
<span class="nc bnc" id="L669" title="All 2 branches missed.">        for (Vertex vertex : vertices) {</span>
            /**
             * Restore state to currentState each time through the loop.
             * This is important because some of the user-defined
             * checkers modify the state, which MUST be restored if
             * the cert eventually fails to lead to the target and
             * the next matching cert is tried.
             */
<span class="nc" id="L677">            ReverseState nextState = (ReverseState) currentState.clone();</span>
<span class="nc" id="L678">            X509Certificate cert = vertex.getCertificate();</span>
            try {
<span class="nc" id="L680">                builder.verifyCert(cert, nextState, cpList);</span>
<span class="nc" id="L681">            } catch (GeneralSecurityException gse) {</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                if (debug != null)</span>
<span class="nc" id="L683">                    debug.println(&quot;SunCertPathBuilder.depthFirstSearchReverse()&quot;</span>
                        + &quot;: validation failed: &quot; + gse);
<span class="nc" id="L685">                vertex.setThrowable(gse);</span>
<span class="nc" id="L686">                continue;</span>
<span class="nc" id="L687">            }</span>

            /*
             * Certificate is good, add it to the path (if it isn't a
             * self-signed cert) and update state
             */
<span class="nc bnc" id="L693" title="All 2 branches missed.">            if (!currentState.isInitial())</span>
<span class="nc" id="L694">                builder.addCertToPath(cert, cpList);</span>
            // save trust anchor
<span class="nc" id="L696">            this.trustAnchor = currentState.trustAnchor;</span>

            /*
             * Check if path is completed, return ASAP if so.
             */
<span class="nc bnc" id="L701" title="All 2 branches missed.">            if (builder.isPathCompleted(cert)) {</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                if (debug != null)</span>
<span class="nc" id="L703">                    debug.println(&quot;SunCertPathBuilder.depthFirstSearchReverse()&quot;</span>
                        + &quot;: path completed!&quot;);
<span class="nc" id="L705">                pathCompleted = true;</span>

<span class="nc" id="L707">                PolicyNodeImpl rootNode = nextState.rootNode;</span>

<span class="nc bnc" id="L709" title="All 2 branches missed.">                if (rootNode == null)</span>
<span class="nc" id="L710">                    policyTreeResult = null;</span>
                else {
<span class="nc" id="L712">                    policyTreeResult = rootNode.copyTree();</span>
<span class="nc" id="L713">                    ((PolicyNodeImpl)policyTreeResult).setImmutable();</span>
                }

                /*
                 * Extract and save the final target public key
                 */
<span class="nc" id="L719">                finalPublicKey = cert.getPublicKey();</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">                if (PKIX.isDSAPublicKeyWithoutParams(finalPublicKey)) {</span>
<span class="nc" id="L721">                    finalPublicKey =</span>
                        BasicChecker.makeInheritedParamsKey
<span class="nc" id="L723">                            (finalPublicKey, currentState.pubKey);</span>
                }

<span class="nc" id="L726">                return;</span>
            }

            /* Update the PKIX state */
<span class="nc" id="L730">            nextState.updateState(cert);</span>

            /*
             * Append an entry for cert in adjacency list and
             * set index for current vertex.
             */
<span class="nc" id="L736">            adjList.add(new LinkedList&lt;Vertex&gt;());</span>
<span class="nc" id="L737">            vertex.setIndex(adjList.size() - 1);</span>

            /* recursively search for matching certs at next dN */
<span class="nc" id="L740">            depthFirstSearchReverse(cert.getSubjectX500Principal(), nextState,</span>
                                    builder, adjList, cpList);

            /*
             * If path has been completed, return ASAP!
             */
<span class="nc bnc" id="L746" title="All 2 branches missed.">            if (pathCompleted) {</span>
<span class="nc" id="L747">                return;</span>
            } else {
                /*
                 * If we get here, it means we have searched all possible
                 * certs issued by the dN w/o finding any matching certs. This
                 * means we have to backtrack to the previous cert in the path
                 * and try some other paths.
                 */
<span class="nc bnc" id="L755" title="All 2 branches missed.">                if (debug != null)</span>
<span class="nc" id="L756">                    debug.println(&quot;SunCertPathBuilder.depthFirstSearchReverse()&quot;</span>
                        + &quot;: backtracking&quot;);
<span class="nc bnc" id="L758" title="All 2 branches missed.">                if (!currentState.isInitial())</span>
<span class="nc" id="L759">                    builder.removeFinalCertFromPath(cpList);</span>
            }
<span class="nc" id="L761">        }</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">        if (debug != null)</span>
<span class="nc" id="L763">            debug.println(&quot;SunCertPathBuilder.depthFirstSearchReverse() all &quot;</span>
                + &quot;certs in this adjacency list checked&quot;);
<span class="nc" id="L765">    }</span>

    /*
     * Adds a collection of matching certificates to the
     * adjacency list.
     */
    private static List&lt;Vertex&gt; addVertices(Collection&lt;X509Certificate&gt; certs,
                                            List&lt;List&lt;Vertex&gt;&gt; adjList)
    {
<span class="fc" id="L774">        List&lt;Vertex&gt; l = adjList.get(adjList.size() - 1);</span>

<span class="fc bfc" id="L776" title="All 2 branches covered.">        for (X509Certificate cert : certs) {</span>
<span class="fc" id="L777">            Vertex v = new Vertex(cert);</span>
<span class="fc" id="L778">            l.add(v);</span>
<span class="fc" id="L779">        }</span>

<span class="fc" id="L781">        return l;</span>
    }

    /**
     * Returns true if trust anchor certificate matches specified
     * certificate constraints.
     */
    private static boolean anchorIsTarget(TrustAnchor anchor,
                                          CertSelector sel)
    {
<span class="nc" id="L791">        X509Certificate anchorCert = anchor.getTrustedCert();</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">        if (anchorCert != null) {</span>
<span class="nc" id="L793">            return sel.match(anchorCert);</span>
        }
<span class="nc" id="L795">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>