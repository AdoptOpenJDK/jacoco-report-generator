<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AdjacencyList.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.provider.certpath</a> &gt; <span class="el_source">AdjacencyList.java</span></div><h1>AdjacencyList.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.security.provider.certpath;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

/**
 * An AdjacencyList is used to store the history of certification paths
 * attempted in constructing a path from an initiator to a target. The
 * AdjacencyList is initialized with a &lt;code&gt;List&lt;/code&gt; of
 * &lt;code&gt;List&lt;/code&gt;s, where each sub-&lt;code&gt;List&lt;/code&gt; contains objects of
 * type &lt;code&gt;Vertex&lt;/code&gt;. A &lt;code&gt;Vertex&lt;/code&gt; describes one possible or
 * actual step in the chain building process, and the associated
 * &lt;code&gt;Certificate&lt;/code&gt;. Specifically, a &lt;code&gt;Vertex&lt;/code&gt; object
 * contains a &lt;code&gt;Certificate&lt;/code&gt; and an index value referencing the
 * next sub-list in the process. If the index value is -1 then this
 * &lt;code&gt;Vertex&lt;/code&gt; doesn't continue the attempted build path.
 * &lt;p&gt;
 * Example:
 * &lt;p&gt;
 * Attempted Paths:&lt;ul&gt;
 * &lt;li&gt;C1-&amp;gt;C2-&amp;gt;C3
 * &lt;li&gt;C1-&amp;gt;C4-&amp;gt;C5
 * &lt;li&gt;C1-&amp;gt;C4-&amp;gt;C6
 * &lt;li&gt;C1-&amp;gt;C4-&amp;gt;C7
 * &lt;li&gt;C1-&amp;gt;C8-&amp;gt;C9
 * &lt;li&gt;C1-&amp;gt;C10-&amp;gt;C11
 * &lt;/ul&gt;
 * &lt;p&gt;
 * AdjacencyList structure:&lt;ul&gt;
 * &lt;li&gt;AL[0] = C1,1
 * &lt;li&gt;AL[1] = C2,2   =&amp;gt;C4,3   =&amp;gt;C8,4     =&amp;gt;C10,5
 * &lt;li&gt;AL[2] = C3,-1
 * &lt;li&gt;AL[3] = C5,-1  =&amp;gt;C6,-1  =&amp;gt;C7,-1
 * &lt;li&gt;AL[4] = C9,-1
 * &lt;li&gt;AL[5] = C11,-1
 * &lt;/ul&gt;
 * &lt;p&gt;
 * The iterator method returns objects of type &lt;code&gt;BuildStep&lt;/code&gt;, not
 * objects of type &lt;code&gt;Vertex&lt;/code&gt;.
 * A &lt;code&gt;BuildStep&lt;/code&gt; contains a &lt;code&gt;Vertex&lt;/code&gt; and a result code,
 * accessible via getResult method. There are five result values.
 * &lt;code&gt;POSSIBLE&lt;/code&gt; denotes that the current step represents a
 * &lt;code&gt;Certificate&lt;/code&gt; that the builder is considering at this point in
 * the build. &lt;code&gt;FOLLOW&lt;/code&gt; denotes a &lt;code&gt;Certificate&lt;/code&gt; (one of
 * those noted as &lt;code&gt;POSSIBLE&lt;/code&gt;) that the builder is using to try
 * extending the chain. &lt;code&gt;BACK&lt;/code&gt; represents that a
 * &lt;code&gt;FOLLOW&lt;/code&gt; was incorrect, and is being removed from the chain.
 * There is exactly one &lt;code&gt;FOLLOW&lt;/code&gt; for each &lt;code&gt;BACK&lt;/code&gt;. The
 * values &lt;code&gt;SUCCEED&lt;/code&gt; and &lt;code&gt;FAIL&lt;/code&gt; mean that we've come to
 * the end of the build process, and there will not be any more entries in
 * the list.
 * &lt;p&gt;
 * @see sun.security.provider.certpath.BuildStep
 * @see sun.security.provider.certpath.Vertex
 * &lt;p&gt;
 * @author  seth proctor
 * @since   1.4
 */
public class AdjacencyList {

    // the actual set of steps the AdjacencyList represents
    private ArrayList&lt;BuildStep&gt; mStepList;

    // the original list, just for the toString method
    private List&lt;List&lt;Vertex&gt;&gt; mOrigList;

    /**
     * Constructs a new &lt;code&gt;AdjacencyList&lt;/code&gt; based on the specified
     * &lt;code&gt;List&lt;/code&gt;. See the example above.
     *
     * @param list a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;List&lt;/code&gt;s of
     *             &lt;code&gt;Vertex&lt;/code&gt; objects
     */
<span class="fc" id="L100">    public AdjacencyList(List&lt;List&lt;Vertex&gt;&gt; list) {</span>
<span class="fc" id="L101">        mStepList = new ArrayList&lt;BuildStep&gt;();</span>
<span class="fc" id="L102">        mOrigList = list;</span>
<span class="fc" id="L103">        buildList(list, 0, null);</span>
<span class="fc" id="L104">    }</span>

    /**
     * Gets an &lt;code&gt;Iterator&lt;/code&gt; to iterate over the set of
     * &lt;code&gt;BuildStep&lt;/code&gt;s in build-order. Any attempts to change
     * the list through the remove method will fail.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; over the &lt;code&gt;BuildStep&lt;/code&gt;s
     */
    public Iterator&lt;BuildStep&gt; iterator() {
<span class="nc" id="L114">        return Collections.unmodifiableList(mStepList).iterator();</span>
    }

    /**
     * Recursive, private method which actually builds the step list from
     * the given adjacency list. &lt;code&gt;Follow&lt;/code&gt; is the parent BuildStep
     * that we followed to get here, and if it's null, it means that we're
     * at the start.
     */
    private boolean buildList(List&lt;List&lt;Vertex&gt;&gt; theList, int index,
                              BuildStep follow) {

        // Each time this method is called, we're examining a new list
        // from the global list. So, we have to start by getting the list
        // that contains the set of Vertexes we're considering.
<span class="fc" id="L129">        List&lt;Vertex&gt; l = theList.get(index);</span>

        // we're interested in the case where all indexes are -1...
<span class="fc" id="L132">        boolean allNegOne = true;</span>
        // ...and in the case where every entry has a Throwable
<span class="fc" id="L134">        boolean allXcps = true;</span>

<span class="fc bfc" id="L136" title="All 2 branches covered.">        for (Vertex v : l) {</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (v.getIndex() != -1) {</span>
                // count an empty list the same as an index of -1...this
                // is to patch a bug somewhere in the builder
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">                if (theList.get(v.getIndex()).size() != 0)</span>
<span class="fc" id="L141">                    allNegOne = false;</span>
            } else {
<span class="fc bfc" id="L143" title="All 2 branches covered.">                if (v.getThrowable() == null)</span>
<span class="fc" id="L144">                    allXcps = false;</span>
            }
            // every entry, regardless of the final use for it, is always
            // entered as a possible step before we take any actions
<span class="fc" id="L148">            mStepList.add(new BuildStep(v, BuildStep.POSSIBLE));</span>
<span class="fc" id="L149">        }</span>

<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (allNegOne) {</span>
            // There are two cases that we could be looking at here. We
            // may need to back up, or the build may have succeeded at
            // this point. This is based on whether or not any
            // exceptions were found in the list.
<span class="fc bfc" id="L156" title="All 2 branches covered.">            if (allXcps) {</span>
                // we need to go back...see if this is the last one
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">                if (follow == null)</span>
<span class="nc" id="L159">                    mStepList.add(new BuildStep(null, BuildStep.FAIL));</span>
                else
<span class="fc" id="L161">                    mStepList.add(new BuildStep(follow.getVertex(),</span>
                                                BuildStep.BACK));

<span class="fc" id="L164">                return false;</span>
            } else {
                // we succeeded...now the only question is which is the
                // successful step? If there's only one entry without
                // a throwable, then that's the successful step. Otherwise,
                // we'll have to make some guesses...
<span class="fc" id="L170">                List&lt;Vertex&gt; possibles = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">                for (Vertex v : l) {</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">                    if (v.getThrowable() == null)</span>
<span class="fc" id="L173">                        possibles.add(v);</span>
<span class="fc" id="L174">                }</span>

<span class="pc bpc" id="L176" title="1 of 2 branches missed.">                if (possibles.size() == 1) {</span>
                    // real easy...we've found the final Vertex
<span class="fc" id="L178">                    mStepList.add(new BuildStep(possibles.get(0),</span>
                                                BuildStep.SUCCEED));
                } else {
                    // ok...at this point, there is more than one Cert
                    // which might be the succeed step...how do we know
                    // which it is? I'm going to assume that our builder
                    // algorithm is good enough to know which is the
                    // correct one, and put it first...but a FIXME goes
                    // here anyway, and we should be comparing to the
                    // target/initiator Cert...
<span class="nc" id="L188">                    mStepList.add(new BuildStep(possibles.get(0),</span>
                                                BuildStep.SUCCEED));
                }

<span class="fc" id="L192">                return true;</span>
            }
        } else {
            // There's at least one thing that we can try before we give
            // up and go back. Run through the list now, and enter a new
            // BuildStep for each path that we try to follow. If none of
            // the paths we try produce a successful end, we're going to
            // have to back out ourselves.
<span class="fc" id="L200">            boolean success = false;</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">            for (Vertex v : l) {</span>

                // Note that we'll only find a SUCCEED case when we're
                // looking at the last possible path, so we don't need to
                // consider success in the while loop

<span class="fc bfc" id="L208" title="All 2 branches covered.">                if (v.getIndex() != -1) {</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">                    if (theList.get(v.getIndex()).size() != 0) {</span>
                        // If the entry we're looking at doesn't have an
                        // index of -1, and doesn't lead to an empty list,
                        // then it's something we follow!
<span class="fc" id="L213">                        BuildStep bs = new BuildStep(v, BuildStep.FOLLOW);</span>
<span class="fc" id="L214">                        mStepList.add(bs);</span>
<span class="fc" id="L215">                        success = buildList(theList, v.getIndex(), bs);</span>
                    }
                }
<span class="fc" id="L218">            }</span>

<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (success) {</span>
                // We're already finished!
<span class="fc" id="L222">                return true;</span>
            } else {
                // We failed, and we've exhausted all the paths that we
                // could take. The only choice is to back ourselves out.
<span class="fc bfc" id="L226" title="All 2 branches covered.">                if (follow == null)</span>
<span class="fc" id="L227">                    mStepList.add(new BuildStep(null, BuildStep.FAIL));</span>
                else
<span class="fc" id="L229">                    mStepList.add(new BuildStep(follow.getVertex(),</span>
                                                BuildStep.BACK));

<span class="fc" id="L232">                return false;</span>
            }
        }
    }

    /**
     * Prints out a string representation of this AdjacencyList.
     *
     * @return String representation
     */
    @Override
    public String toString() {
<span class="nc" id="L244">        StringBuilder sb = new StringBuilder(&quot;[\n&quot;);</span>

<span class="nc" id="L246">        int i = 0;</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        for (List&lt;Vertex&gt; l : mOrigList) {</span>
<span class="nc" id="L248">            sb.append(&quot;LinkedList[&quot;).append(i++).append(&quot;]:\n&quot;);</span>

<span class="nc bnc" id="L250" title="All 2 branches missed.">            for (Vertex step : l) {</span>
<span class="nc" id="L251">                sb.append(step.toString()).append(&quot;\n&quot;);</span>
<span class="nc" id="L252">            }</span>
<span class="nc" id="L253">        }</span>
<span class="nc" id="L254">        sb.append(&quot;]\n&quot;);</span>

<span class="nc" id="L256">        return sb.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>