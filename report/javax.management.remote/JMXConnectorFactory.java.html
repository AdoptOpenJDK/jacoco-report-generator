<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>JMXConnectorFactory.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.management.remote</a> &gt; <span class="el_source">JMXConnectorFactory.java</span></div><h1>JMXConnectorFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management.remote;

import com.sun.jmx.mbeanserver.Util;
import java.io.IOException;
import java.net.MalformedURLException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;
import java.util.ServiceLoader;
import java.util.StringTokenizer;
import java.security.AccessController;
import java.security.PrivilegedAction;

import com.sun.jmx.remote.util.ClassLogger;
import com.sun.jmx.remote.util.EnvHelp;
import sun.reflect.misc.ReflectUtil;


/**
 * &lt;p&gt;Factory to create JMX API connector clients.  There
 * are no instances of this class.&lt;/p&gt;
 *
 * &lt;p&gt;Connections are usually made using the {@link
 * #connect(JMXServiceURL) connect} method of this class.  More
 * advanced applications can separate the creation of the connector
 * client, using {@link #newJMXConnector(JMXServiceURL, Map)
 * newJMXConnector} and the establishment of the connection itself, using
 * {@link JMXConnector#connect(Map)}.&lt;/p&gt;
 *
 * &lt;p&gt;Each client is created by an instance of {@link
 * JMXConnectorProvider}.  This instance is found as follows.  Suppose
 * the given {@link JMXServiceURL} looks like
 * &lt;code&gt;&quot;service:jmx:&lt;em&gt;protocol&lt;/em&gt;:&lt;em&gt;remainder&lt;/em&gt;&quot;&lt;/code&gt;.
 * Then the factory will attempt to find the appropriate {@link
 * JMXConnectorProvider} for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;.  Each
 * occurrence of the character &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; in
 * &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; is replaced by &lt;code&gt;.&lt;/code&gt; or
 * &lt;code&gt;_&lt;/code&gt;, respectively.&lt;/p&gt;
 *
 * &lt;p&gt;A &lt;em&gt;provider package list&lt;/em&gt; is searched for as follows:&lt;/p&gt;
 *
 * &lt;ol&gt;
 *
 * &lt;li&gt;If the &lt;code&gt;environment&lt;/code&gt; parameter to {@link
 * #newJMXConnector(JMXServiceURL, Map) newJMXConnector} contains the
 * key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the
 * associated value is the provider package list.
 *
 * &lt;li&gt;Otherwise, if the system property
 * &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; exists, then its value
 * is the provider package list.
 *
 * &lt;li&gt;Otherwise, there is no provider package list.
 *
 * &lt;/ol&gt;
 *
 * &lt;p&gt;The provider package list is a string that is interpreted as a
 * list of non-empty Java package names separated by vertical bars
 * (&lt;code&gt;|&lt;/code&gt;).  If the string is empty, then so is the provider
 * package list.  If the provider package list is not a String, or if
 * it contains an element that is an empty string, a {@link
 * JMXProviderException} is thrown.&lt;/p&gt;
 *
 * &lt;p&gt;If the provider package list exists and is not empty, then for
 * each element &lt;code&gt;&lt;em&gt;pkg&lt;/em&gt;&lt;/code&gt; of the list, the factory
 * will attempt to load the class
 *
 * &lt;blockquote&gt;
 * &lt;code&gt;&lt;em&gt;pkg&lt;/em&gt;.&lt;em&gt;protocol&lt;/em&gt;.ClientProvider&lt;/code&gt;
 * &lt;/blockquote&gt;

 * &lt;p&gt;If the &lt;code&gt;environment&lt;/code&gt; parameter to {@link
 * #newJMXConnector(JMXServiceURL, Map) newJMXConnector} contains the
 * key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the
 * associated value is the class loader to use to load the provider.
 * If the associated value is not an instance of {@link
 * java.lang.ClassLoader}, an {@link
 * java.lang.IllegalArgumentException} is thrown.&lt;/p&gt;
 *
 * &lt;p&gt;If the &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt;
 * key is not present in the &lt;code&gt;environment&lt;/code&gt; parameter, the
 * calling thread's context class loader is used.&lt;/p&gt;
 *
 * &lt;p&gt;If the attempt to load this class produces a {@link
 * ClassNotFoundException}, the search for a handler continues with
 * the next element of the list.&lt;/p&gt;
 *
 * &lt;p&gt;Otherwise, a problem with the provider found is signalled by a
 * {@link JMXProviderException} whose {@link
 * JMXProviderException#getCause() &lt;em&gt;cause&lt;/em&gt;} indicates the underlying
 * exception, as follows:&lt;/p&gt;
 *
 * &lt;ul&gt;
 *
 * &lt;li&gt;if the attempt to load the class produces an exception other
 * than &lt;code&gt;ClassNotFoundException&lt;/code&gt;, that is the
 * &lt;em&gt;cause&lt;/em&gt;;
 *
 * &lt;li&gt;if {@link Class#newInstance()} for the class produces an
 * exception, that is the &lt;em&gt;cause&lt;/em&gt;.
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt;If no provider is found by the above steps, including the
 * default case where there is no provider package list, then the
 * implementation will use its own provider for
 * &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a
 * &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none.  An
 * implementation may choose to find providers by other means.  For
 * example, it may support the &lt;a
 * href=&quot;{@docRoot}/../technotes/guides/jar/jar.html#Service Provider&quot;&gt;
 * JAR conventions for service providers&lt;/a&gt;, where the service
 * interface is &lt;code&gt;JMXConnectorProvider&lt;/code&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;Every implementation must support the RMI connector protocol with
 * the default RMI transport, specified with string &lt;code&gt;rmi&lt;/code&gt;.
 * An implementation may optionally support the RMI connector protocol
 * with the RMI/IIOP transport, specified with the string
 * &lt;code&gt;iiop&lt;/code&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;Once a provider is found, the result of the
 * &lt;code&gt;newJMXConnector&lt;/code&gt; method is the result of calling {@link
 * JMXConnectorProvider#newJMXConnector(JMXServiceURL,Map) newJMXConnector}
 * on the provider.&lt;/p&gt;
 *
 * &lt;p&gt;The &lt;code&gt;Map&lt;/code&gt; parameter passed to the
 * &lt;code&gt;JMXConnectorProvider&lt;/code&gt; is a new read-only
 * &lt;code&gt;Map&lt;/code&gt; that contains all the entries that were in the
 * &lt;code&gt;environment&lt;/code&gt; parameter to {@link
 * #newJMXConnector(JMXServiceURL,Map)
 * JMXConnectorFactory.newJMXConnector}, if there was one.
 * Additionally, if the
 * &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; key is not
 * present in the &lt;code&gt;environment&lt;/code&gt; parameter, it is added to
 * the new read-only &lt;code&gt;Map&lt;/code&gt;.  The associated value is the
 * calling thread's context class loader.&lt;/p&gt;
 *
 * @since 1.5
 */
public class JMXConnectorFactory {

    /**
     * &lt;p&gt;Name of the attribute that specifies the default class
     * loader. This class loader is used to deserialize return values and
     * exceptions from remote &lt;code&gt;MBeanServerConnection&lt;/code&gt;
     * calls.  The value associated with this attribute is an instance
     * of {@link ClassLoader}.&lt;/p&gt;
     */
    public static final String DEFAULT_CLASS_LOADER =
        &quot;jmx.remote.default.class.loader&quot;;

    /**
     * &lt;p&gt;Name of the attribute that specifies the provider packages
     * that are consulted when looking for the handler for a protocol.
     * The value associated with this attribute is a string with
     * package names separated by vertical bars (&lt;code&gt;|&lt;/code&gt;).&lt;/p&gt;
     */
    public static final String PROTOCOL_PROVIDER_PACKAGES =
        &quot;jmx.remote.protocol.provider.pkgs&quot;;

    /**
     * &lt;p&gt;Name of the attribute that specifies the class
     * loader for loading protocol providers.
     * The value associated with this attribute is an instance
     * of {@link ClassLoader}.&lt;/p&gt;
     */
    public static final String PROTOCOL_PROVIDER_CLASS_LOADER =
        &quot;jmx.remote.protocol.provider.class.loader&quot;;

    private static final String PROTOCOL_PROVIDER_DEFAULT_PACKAGE =
        &quot;com.sun.jmx.remote.protocol&quot;;

<span class="nc" id="L199">    private static final ClassLogger logger =</span>
        new ClassLogger(&quot;javax.management.remote.misc&quot;, &quot;JMXConnectorFactory&quot;);

    /** There are no instances of this class.  */
<span class="nc" id="L203">    private JMXConnectorFactory() {</span>
<span class="nc" id="L204">    }</span>

    /**
     * &lt;p&gt;Creates a connection to the connector server at the given
     * address.&lt;/p&gt;
     *
     * &lt;p&gt;This method is equivalent to {@link
     * #connect(JMXServiceURL,Map) connect(serviceURL, null)}.&lt;/p&gt;
     *
     * @param serviceURL the address of the connector server to
     * connect to.
     *
     * @return a &lt;code&gt;JMXConnector&lt;/code&gt; whose {@link
     * JMXConnector#connect connect} method has been called.
     *
     * @exception NullPointerException if &lt;code&gt;serviceURL&lt;/code&gt; is null.
     *
     * @exception IOException if the connector client or the
     * connection cannot be made because of a communication problem.
     *
     * @exception SecurityException if the connection cannot be made
     * for security reasons.
     */
    public static JMXConnector connect(JMXServiceURL serviceURL)
            throws IOException {
<span class="nc" id="L229">        return connect(serviceURL, null);</span>
    }

    /**
     * &lt;p&gt;Creates a connection to the connector server at the given
     * address.&lt;/p&gt;
     *
     * &lt;p&gt;This method is equivalent to:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * JMXConnector conn = JMXConnectorFactory.newJMXConnector(serviceURL,
     *                                                         environment);
     * conn.connect(environment);
     * &lt;/pre&gt;
     *
     * @param serviceURL the address of the connector server to connect to.
     *
     * @param environment a set of attributes to determine how the
     * connection is made.  This parameter can be null.  Keys in this
     * map must be Strings.  The appropriate type of each associated
     * value depends on the attribute.  The contents of
     * &lt;code&gt;environment&lt;/code&gt; are not changed by this call.
     *
     * @return a &lt;code&gt;JMXConnector&lt;/code&gt; representing the newly-made
     * connection.  Each successful call to this method produces a
     * different object.
     *
     * @exception NullPointerException if &lt;code&gt;serviceURL&lt;/code&gt; is null.
     *
     * @exception IOException if the connector client or the
     * connection cannot be made because of a communication problem.
     *
     * @exception SecurityException if the connection cannot be made
     * for security reasons.
     */
    public static JMXConnector connect(JMXServiceURL serviceURL,
                                       Map&lt;String,?&gt; environment)
            throws IOException {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (serviceURL == null)</span>
<span class="nc" id="L268">            throw new NullPointerException(&quot;Null JMXServiceURL&quot;);</span>
<span class="nc" id="L269">        JMXConnector conn = newJMXConnector(serviceURL, environment);</span>
<span class="nc" id="L270">        conn.connect(environment);</span>
<span class="nc" id="L271">        return conn;</span>
    }

    private static &lt;K,V&gt; Map&lt;K,V&gt; newHashMap() {
<span class="nc" id="L275">        return new HashMap&lt;K,V&gt;();</span>
    }

    private static &lt;K&gt; Map&lt;K,Object&gt; newHashMap(Map&lt;K,?&gt; map) {
<span class="nc" id="L279">        return new HashMap&lt;K,Object&gt;(map);</span>
    }

    /**
     * &lt;p&gt;Creates a connector client for the connector server at the
     * given address.  The resultant client is not connected until its
     * {@link JMXConnector#connect(Map) connect} method is called.&lt;/p&gt;
     *
     * @param serviceURL the address of the connector server to connect to.
     *
     * @param environment a set of attributes to determine how the
     * connection is made.  This parameter can be null.  Keys in this
     * map must be Strings.  The appropriate type of each associated
     * value depends on the attribute.  The contents of
     * &lt;code&gt;environment&lt;/code&gt; are not changed by this call.
     *
     * @return a &lt;code&gt;JMXConnector&lt;/code&gt; representing the new
     * connector client.  Each successful call to this method produces
     * a different object.
     *
     * @exception NullPointerException if &lt;code&gt;serviceURL&lt;/code&gt; is null.
     *
     * @exception IOException if the connector client cannot be made
     * because of a communication problem.
     *
     * @exception MalformedURLException if there is no provider for the
     * protocol in &lt;code&gt;serviceURL&lt;/code&gt;.
     *
     * @exception JMXProviderException if there is a provider for the
     * protocol in &lt;code&gt;serviceURL&lt;/code&gt; but it cannot be used for
     * some reason.
     */
    public static JMXConnector newJMXConnector(JMXServiceURL serviceURL,
                                               Map&lt;String,?&gt; environment)
            throws IOException {

        final Map&lt;String,Object&gt; envcopy;
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (environment == null)</span>
<span class="nc" id="L317">            envcopy = newHashMap();</span>
        else {
<span class="nc" id="L319">            EnvHelp.checkAttributes(environment);</span>
<span class="nc" id="L320">            envcopy = newHashMap(environment);</span>
        }

<span class="nc" id="L323">        final ClassLoader loader = resolveClassLoader(envcopy);</span>
<span class="nc" id="L324">        final Class&lt;JMXConnectorProvider&gt; targetInterface =</span>
                JMXConnectorProvider.class;
<span class="nc" id="L326">        final String protocol = serviceURL.getProtocol();</span>
        final String providerClassName = &quot;ClientProvider&quot;;
<span class="nc" id="L328">        final JMXServiceURL providerURL = serviceURL;</span>

<span class="nc" id="L330">        JMXConnectorProvider provider = getProvider(providerURL, envcopy,</span>
                                               providerClassName,
                                               targetInterface,
                                               loader);

<span class="nc" id="L335">        IOException exception = null;</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (provider == null) {</span>
            // Loader is null when context class loader is set to null
            // and no loader has been provided in map.
            // com.sun.jmx.remote.util.Service class extracted from j2se
            // provider search algorithm doesn't handle well null classloader.
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (loader != null) {</span>
                try {
<span class="nc" id="L343">                    JMXConnector connection =</span>
<span class="nc" id="L344">                        getConnectorAsService(loader, providerURL, envcopy);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                    if (connection != null)</span>
<span class="nc" id="L346">                        return connection;</span>
<span class="nc" id="L347">                } catch (JMXProviderException e) {</span>
<span class="nc" id="L348">                    throw e;</span>
<span class="nc" id="L349">                } catch (IOException e) {</span>
<span class="nc" id="L350">                    exception = e;</span>
<span class="nc" id="L351">                }</span>
            }
<span class="nc" id="L353">            provider = getProvider(protocol, PROTOCOL_PROVIDER_DEFAULT_PACKAGE,</span>
<span class="nc" id="L354">                            JMXConnectorFactory.class.getClassLoader(),</span>
                            providerClassName, targetInterface);
        }

<span class="nc bnc" id="L358" title="All 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L359">            MalformedURLException e =</span>
                new MalformedURLException(&quot;Unsupported protocol: &quot; + protocol);
<span class="nc bnc" id="L361" title="All 2 branches missed.">            if (exception == null) {</span>
<span class="nc" id="L362">                throw e;</span>
            } else {
<span class="nc" id="L364">                throw EnvHelp.initCause(e, exception);</span>
            }
        }

<span class="nc" id="L368">        final Map&lt;String,Object&gt; fixedenv =</span>
<span class="nc" id="L369">                Collections.unmodifiableMap(envcopy);</span>

<span class="nc" id="L371">        return provider.newJMXConnector(serviceURL, fixedenv);</span>
    }

    private static String resolvePkgs(Map&lt;String, ?&gt; env)
            throws JMXProviderException {

<span class="nc" id="L377">        Object pkgsObject = null;</span>

<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (env != null)</span>
<span class="nc" id="L380">            pkgsObject = env.get(PROTOCOL_PROVIDER_PACKAGES);</span>

<span class="nc bnc" id="L382" title="All 2 branches missed.">        if (pkgsObject == null)</span>
<span class="nc" id="L383">            pkgsObject =</span>
<span class="nc" id="L384">                AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {</span>
                    public String run() {
<span class="nc" id="L386">                        return System.getProperty(PROTOCOL_PROVIDER_PACKAGES);</span>
                    }
                });

<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (pkgsObject == null)</span>
<span class="nc" id="L391">            return null;</span>

<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (!(pkgsObject instanceof String)) {</span>
<span class="nc" id="L394">            final String msg = &quot;Value of &quot; + PROTOCOL_PROVIDER_PACKAGES +</span>
                &quot; parameter is not a String: &quot; +
<span class="nc" id="L396">                pkgsObject.getClass().getName();</span>
<span class="nc" id="L397">            throw new JMXProviderException(msg);</span>
        }

<span class="nc" id="L400">        final String pkgs = (String) pkgsObject;</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (pkgs.trim().equals(&quot;&quot;))</span>
<span class="nc" id="L402">            return null;</span>

        // pkgs may not contain an empty element
<span class="nc bnc" id="L405" title="All 4 branches missed.">        if (pkgs.startsWith(&quot;|&quot;) || pkgs.endsWith(&quot;|&quot;) ||</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            pkgs.indexOf(&quot;||&quot;) &gt;= 0) {</span>
<span class="nc" id="L407">            final String msg = &quot;Value of &quot; + PROTOCOL_PROVIDER_PACKAGES +</span>
                &quot; contains an empty element: &quot; + pkgs;
<span class="nc" id="L409">            throw new JMXProviderException(msg);</span>
        }

<span class="nc" id="L412">        return pkgs;</span>
    }

    static &lt;T&gt; T getProvider(JMXServiceURL serviceURL,
                             final Map&lt;String, Object&gt; environment,
                             String providerClassName,
                             Class&lt;T&gt; targetInterface,
                             final ClassLoader loader)
            throws IOException {

<span class="nc" id="L422">        final String protocol = serviceURL.getProtocol();</span>

<span class="nc" id="L424">        final String pkgs = resolvePkgs(environment);</span>

<span class="nc" id="L426">        T instance = null;</span>

<span class="nc bnc" id="L428" title="All 2 branches missed.">        if (pkgs != null) {</span>
<span class="nc" id="L429">            instance =</span>
<span class="nc" id="L430">                getProvider(protocol, pkgs, loader, providerClassName,</span>
                            targetInterface);

<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (instance != null) {</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                boolean needsWrap = (loader != instance.getClass().getClassLoader());</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                environment.put(PROTOCOL_PROVIDER_CLASS_LOADER, needsWrap ? wrap(loader) : loader);</span>
            }
        }

<span class="nc" id="L439">        return instance;</span>
    }

    static &lt;T&gt; Iterator&lt;T&gt; getProviderIterator(final Class&lt;T&gt; providerClass,
                                               final ClassLoader loader) {
<span class="nc" id="L444">       ServiceLoader&lt;T&gt; serviceLoader =</span>
<span class="nc" id="L445">                ServiceLoader.load(providerClass, loader);</span>
<span class="nc" id="L446">       return serviceLoader.iterator();</span>
    }

    private static ClassLoader wrap(final ClassLoader parent) {
<span class="nc bnc" id="L450" title="All 2 branches missed.">        return parent != null ? AccessController.doPrivileged(new PrivilegedAction&lt;ClassLoader&gt;() {</span>
            @Override
            public ClassLoader run() {
<span class="nc" id="L453">                return new ClassLoader(parent) {</span>
                    @Override
                    protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
<span class="nc" id="L456">                        ReflectUtil.checkPackageAccess(name);</span>
<span class="nc" id="L457">                        return super.loadClass(name, resolve);</span>
                    }
                };
            }
        }) : null;
    }

    private static JMXConnector getConnectorAsService(ClassLoader loader,
                                                      JMXServiceURL url,
                                                      Map&lt;String, ?&gt; map)
        throws IOException {

<span class="nc" id="L469">        Iterator&lt;JMXConnectorProvider&gt; providers =</span>
<span class="nc" id="L470">                getProviderIterator(JMXConnectorProvider.class, loader);</span>
        JMXConnector connection;
<span class="nc" id="L472">        IOException exception = null;</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">        while (providers.hasNext()) {</span>
<span class="nc" id="L474">            JMXConnectorProvider provider = providers.next();</span>
            try {
<span class="nc" id="L476">                connection = provider.newJMXConnector(url, map);</span>
<span class="nc" id="L477">                return connection;</span>
<span class="nc" id="L478">            } catch (JMXProviderException e) {</span>
<span class="nc" id="L479">                throw e;</span>
<span class="nc" id="L480">            } catch (Exception e) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">                if (logger.traceOn())</span>
<span class="nc" id="L482">                    logger.trace(&quot;getConnectorAsService&quot;,</span>
                                 &quot;URL[&quot; + url +
                                 &quot;] Service provider exception: &quot; + e);
<span class="nc bnc" id="L485" title="All 2 branches missed.">                if (!(e instanceof MalformedURLException)) {</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                    if (exception == null) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                        if (e instanceof IOException) {</span>
<span class="nc" id="L488">                            exception = (IOException) e;</span>
                        } else {
<span class="nc" id="L490">                            exception = EnvHelp.initCause(</span>
<span class="nc" id="L491">                                new IOException(e.getMessage()), e);</span>
                        }
                    }
                }
<span class="nc" id="L495">                continue;</span>
            }
        }
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (exception == null)</span>
<span class="nc" id="L499">            return null;</span>
        else
<span class="nc" id="L501">            throw exception;</span>
    }

    static &lt;T&gt; T getProvider(String protocol,
                              String pkgs,
                              ClassLoader loader,
                              String providerClassName,
                              Class&lt;T&gt; targetInterface)
            throws IOException {

<span class="nc" id="L511">        StringTokenizer tokenizer = new StringTokenizer(pkgs, &quot;|&quot;);</span>

<span class="nc bnc" id="L513" title="All 2 branches missed.">        while (tokenizer.hasMoreTokens()) {</span>
<span class="nc" id="L514">            String pkg = tokenizer.nextToken();</span>
<span class="nc" id="L515">            String className = (pkg + &quot;.&quot; + protocol2package(protocol) +</span>
                                &quot;.&quot; + providerClassName);
            Class&lt;?&gt; providerClass;
            try {
<span class="nc" id="L519">                providerClass = Class.forName(className, true, loader);</span>
<span class="nc" id="L520">            } catch (ClassNotFoundException e) {</span>
                //Add trace.
<span class="nc" id="L522">                continue;</span>
<span class="nc" id="L523">            }</span>

<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (!targetInterface.isAssignableFrom(providerClass)) {</span>
<span class="nc" id="L526">                final String msg =</span>
                    &quot;Provider class does not implement &quot; +
<span class="nc" id="L528">                    targetInterface.getName() + &quot;: &quot; +</span>
<span class="nc" id="L529">                    providerClass.getName();</span>
<span class="nc" id="L530">                throw new JMXProviderException(msg);</span>
            }

            // We have just proved that this cast is correct
<span class="nc" id="L534">            Class&lt;? extends T&gt; providerClassT = Util.cast(providerClass);</span>
            try {
<span class="nc" id="L536">                return providerClassT.newInstance();</span>
<span class="nc" id="L537">            } catch (Exception e) {</span>
<span class="nc" id="L538">                final String msg =</span>
                    &quot;Exception when instantiating provider [&quot; + className +
                    &quot;]&quot;;
<span class="nc" id="L541">                throw new JMXProviderException(msg, e);</span>
            }
        }

<span class="nc" id="L545">        return null;</span>
    }

    static ClassLoader resolveClassLoader(Map&lt;String, ?&gt; environment) {
<span class="nc" id="L549">        ClassLoader loader = null;</span>

<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (environment != null) {</span>
            try {
<span class="nc" id="L553">                loader = (ClassLoader)</span>
<span class="nc" id="L554">                    environment.get(PROTOCOL_PROVIDER_CLASS_LOADER);</span>
<span class="nc" id="L555">            } catch (ClassCastException e) {</span>
                final String msg =
                    &quot;The ClassLoader supplied in the environment map using &quot; +
                    &quot;the &quot; + PROTOCOL_PROVIDER_CLASS_LOADER +
                    &quot; attribute is not an instance of java.lang.ClassLoader&quot;;
<span class="nc" id="L560">                throw new IllegalArgumentException(msg);</span>
<span class="nc" id="L561">            }</span>
        }

<span class="nc bnc" id="L564" title="All 2 branches missed.">        if (loader == null) {</span>
<span class="nc" id="L565">            loader = Thread.currentThread().getContextClassLoader();</span>
        }

<span class="nc" id="L568">        return loader;</span>
    }

    private static String protocol2package(String protocol) {
<span class="nc" id="L572">        return protocol.replace('+', '.').replace('-', '_');</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>