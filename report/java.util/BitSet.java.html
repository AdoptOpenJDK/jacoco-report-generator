<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BitSet.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">BitSet.java</span></div><h1>BitSet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.LongBuffer;
import java.util.stream.IntStream;
import java.util.stream.StreamSupport;

/**
 * This class implements a vector of bits that grows as needed. Each
 * component of the bit set has a {@code boolean} value. The
 * bits of a {@code BitSet} are indexed by nonnegative integers.
 * Individual indexed bits can be examined, set, or cleared. One
 * {@code BitSet} may be used to modify the contents of another
 * {@code BitSet} through logical AND, logical inclusive OR, and
 * logical exclusive OR operations.
 *
 * &lt;p&gt;By default, all bits in the set initially have the value
 * {@code false}.
 *
 * &lt;p&gt;Every bit set has a current size, which is the number of bits
 * of space currently in use by the bit set. Note that the size is
 * related to the implementation of a bit set, so it may change with
 * implementation. The length of a bit set relates to logical length
 * of a bit set and is defined independently of implementation.
 *
 * &lt;p&gt;Unless otherwise noted, passing a null parameter to any of the
 * methods in a {@code BitSet} will result in a
 * {@code NullPointerException}.
 *
 * &lt;p&gt;A {@code BitSet} is not safe for multithreaded use without
 * external synchronization.
 *
 * @author  Arthur van Hoff
 * @author  Michael McCloskey
 * @author  Martin Buchholz
 * @since   JDK1.0
 */
<span class="fc bfc" id="L65" title="All 2 branches covered.">public class BitSet implements Cloneable, java.io.Serializable {</span>
    /*
     * BitSets are packed into arrays of &quot;words.&quot;  Currently a word is
     * a long, which consists of 64 bits, requiring 6 address bits.
     * The choice of word size is determined purely by performance concerns.
     */
    private final static int ADDRESS_BITS_PER_WORD = 6;
    private final static int BITS_PER_WORD = 1 &lt;&lt; ADDRESS_BITS_PER_WORD;
    private final static int BIT_INDEX_MASK = BITS_PER_WORD - 1;

    /* Used to shift left or right for a partial word mask */
    private static final long WORD_MASK = 0xffffffffffffffffL;

    /**
     * @serialField bits long[]
     *
     * The bits in this BitSet.  The ith bit is stored in bits[i/64] at
     * bit position i % 64 (where bit position 0 refers to the least
     * significant bit and 63 refers to the most significant bit).
     */
<span class="fc" id="L85">    private static final ObjectStreamField[] serialPersistentFields = {</span>
        new ObjectStreamField(&quot;bits&quot;, long[].class),
    };

    /**
     * The internal field corresponding to the serialField &quot;bits&quot;.
     */
    private long[] words;

    /**
     * The number of words in the logical size of this BitSet.
     */
<span class="pc" id="L97">    private transient int wordsInUse = 0;</span>

    /**
     * Whether the size of &quot;words&quot; is user-specified.  If so, we assume
     * the user knows what he's doing and try harder to preserve it.
     */
<span class="pc" id="L103">    private transient boolean sizeIsSticky = false;</span>

    /* use serialVersionUID from JDK 1.0.2 for interoperability */
    private static final long serialVersionUID = 7997698588986878753L;

    /**
     * Given a bit index, return word index containing it.
     */
    private static int wordIndex(int bitIndex) {
<span class="fc" id="L112">        return bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;</span>
    }

    /**
     * Every public method must preserve these invariants.
     */
    private void checkInvariants() {
<span class="pc bpc" id="L119" title="1 of 6 branches missed.">        assert(wordsInUse == 0 || words[wordsInUse - 1] != 0);</span>
<span class="pc bpc" id="L120" title="2 of 6 branches missed.">        assert(wordsInUse &gt;= 0 &amp;&amp; wordsInUse &lt;= words.length);</span>
<span class="pc bpc" id="L121" title="1 of 6 branches missed.">        assert(wordsInUse == words.length || words[wordsInUse] == 0);</span>
<span class="fc" id="L122">    }</span>

    /**
     * Sets the field wordsInUse to the logical size in words of the bit set.
     * WARNING:This method assumes that the number of words actually in use is
     * less than or equal to the current value of wordsInUse!
     */
    private void recalculateWordsInUse() {
        // Traverse the bitset until a used word is found
        int i;
<span class="fc bfc" id="L132" title="All 2 branches covered.">        for (i = wordsInUse-1; i &gt;= 0; i--)</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">            if (words[i] != 0)</span>
<span class="fc" id="L134">                break;</span>

<span class="fc" id="L136">        wordsInUse = i+1; // The new logical size</span>
<span class="fc" id="L137">    }</span>

    /**
     * Creates a new bit set. All bits are initially {@code false}.
     */
<span class="fc" id="L142">    public BitSet() {</span>
<span class="fc" id="L143">        initWords(BITS_PER_WORD);</span>
<span class="fc" id="L144">        sizeIsSticky = false;</span>
<span class="fc" id="L145">    }</span>

    /**
     * Creates a bit set whose initial size is large enough to explicitly
     * represent bits with indices in the range {@code 0} through
     * {@code nbits-1}. All bits are initially {@code false}.
     *
     * @param  nbits the initial size of the bit set
     * @throws NegativeArraySizeException if the specified initial size
     *         is negative
     */
<span class="fc" id="L156">    public BitSet(int nbits) {</span>
        // nbits can't be negative; size 0 is OK
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        if (nbits &lt; 0)</span>
<span class="nc" id="L159">            throw new NegativeArraySizeException(&quot;nbits &lt; 0: &quot; + nbits);</span>

<span class="fc" id="L161">        initWords(nbits);</span>
<span class="fc" id="L162">        sizeIsSticky = true;</span>
<span class="fc" id="L163">    }</span>

    private void initWords(int nbits) {
<span class="fc" id="L166">        words = new long[wordIndex(nbits-1) + 1];</span>
<span class="fc" id="L167">    }</span>

    /**
     * Creates a bit set using words as the internal representation.
     * The last word (if there is one) must be non-zero.
     */
<span class="nc" id="L173">    private BitSet(long[] words) {</span>
<span class="nc" id="L174">        this.words = words;</span>
<span class="nc" id="L175">        this.wordsInUse = words.length;</span>
<span class="nc" id="L176">        checkInvariants();</span>
<span class="nc" id="L177">    }</span>

    /**
     * Returns a new bit set containing all the bits in the given long array.
     *
     * &lt;p&gt;More precisely,
     * &lt;br&gt;{@code BitSet.valueOf(longs).get(n) == ((longs[n/64] &amp; (1L&lt;&lt;(n%64))) != 0)}
     * &lt;br&gt;for all {@code n &lt; 64 * longs.length}.
     *
     * &lt;p&gt;This method is equivalent to
     * {@code BitSet.valueOf(LongBuffer.wrap(longs))}.
     *
     * @param longs a long array containing a little-endian representation
     *        of a sequence of bits to be used as the initial bits of the
     *        new bit set
     * @return a {@code BitSet} containing all the bits in the long array
     * @since 1.7
     */
    public static BitSet valueOf(long[] longs) {
        int n;
<span class="nc bnc" id="L197" title="All 4 branches missed.">        for (n = longs.length; n &gt; 0 &amp;&amp; longs[n - 1] == 0; n--)</span>
            ;
<span class="nc" id="L199">        return new BitSet(Arrays.copyOf(longs, n));</span>
    }

    /**
     * Returns a new bit set containing all the bits in the given long
     * buffer between its position and limit.
     *
     * &lt;p&gt;More precisely,
     * &lt;br&gt;{@code BitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n/64) &amp; (1L&lt;&lt;(n%64))) != 0)}
     * &lt;br&gt;for all {@code n &lt; 64 * lb.remaining()}.
     *
     * &lt;p&gt;The long buffer is not modified by this method, and no
     * reference to the buffer is retained by the bit set.
     *
     * @param lb a long buffer containing a little-endian representation
     *        of a sequence of bits between its position and limit, to be
     *        used as the initial bits of the new bit set
     * @return a {@code BitSet} containing all the bits in the buffer in the
     *         specified range
     * @since 1.7
     */
    public static BitSet valueOf(LongBuffer lb) {
<span class="nc" id="L221">        lb = lb.slice();</span>
        int n;
<span class="nc bnc" id="L223" title="All 4 branches missed.">        for (n = lb.remaining(); n &gt; 0 &amp;&amp; lb.get(n - 1) == 0; n--)</span>
            ;
<span class="nc" id="L225">        long[] words = new long[n];</span>
<span class="nc" id="L226">        lb.get(words);</span>
<span class="nc" id="L227">        return new BitSet(words);</span>
    }

    /**
     * Returns a new bit set containing all the bits in the given byte array.
     *
     * &lt;p&gt;More precisely,
     * &lt;br&gt;{@code BitSet.valueOf(bytes).get(n) == ((bytes[n/8] &amp; (1&lt;&lt;(n%8))) != 0)}
     * &lt;br&gt;for all {@code n &lt;  8 * bytes.length}.
     *
     * &lt;p&gt;This method is equivalent to
     * {@code BitSet.valueOf(ByteBuffer.wrap(bytes))}.
     *
     * @param bytes a byte array containing a little-endian
     *        representation of a sequence of bits to be used as the
     *        initial bits of the new bit set
     * @return a {@code BitSet} containing all the bits in the byte array
     * @since 1.7
     */
    public static BitSet valueOf(byte[] bytes) {
<span class="nc" id="L247">        return BitSet.valueOf(ByteBuffer.wrap(bytes));</span>
    }

    /**
     * Returns a new bit set containing all the bits in the given byte
     * buffer between its position and limit.
     *
     * &lt;p&gt;More precisely,
     * &lt;br&gt;{@code BitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n/8) &amp; (1&lt;&lt;(n%8))) != 0)}
     * &lt;br&gt;for all {@code n &lt; 8 * bb.remaining()}.
     *
     * &lt;p&gt;The byte buffer is not modified by this method, and no
     * reference to the buffer is retained by the bit set.
     *
     * @param bb a byte buffer containing a little-endian representation
     *        of a sequence of bits between its position and limit, to be
     *        used as the initial bits of the new bit set
     * @return a {@code BitSet} containing all the bits in the buffer in the
     *         specified range
     * @since 1.7
     */
    public static BitSet valueOf(ByteBuffer bb) {
<span class="nc" id="L269">        bb = bb.slice().order(ByteOrder.LITTLE_ENDIAN);</span>
        int n;
<span class="nc bnc" id="L271" title="All 4 branches missed.">        for (n = bb.remaining(); n &gt; 0 &amp;&amp; bb.get(n - 1) == 0; n--)</span>
            ;
<span class="nc" id="L273">        long[] words = new long[(n + 7) / 8];</span>
<span class="nc" id="L274">        bb.limit(n);</span>
<span class="nc" id="L275">        int i = 0;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        while (bb.remaining() &gt;= 8)</span>
<span class="nc" id="L277">            words[i++] = bb.getLong();</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        for (int remaining = bb.remaining(), j = 0; j &lt; remaining; j++)</span>
<span class="nc" id="L279">            words[i] |= (bb.get() &amp; 0xffL) &lt;&lt; (8 * j);</span>
<span class="nc" id="L280">        return new BitSet(words);</span>
    }

    /**
     * Returns a new byte array containing all the bits in this bit set.
     *
     * &lt;p&gt;More precisely, if
     * &lt;br&gt;{@code byte[] bytes = s.toByteArray();}
     * &lt;br&gt;then {@code bytes.length == (s.length()+7)/8} and
     * &lt;br&gt;{@code s.get(n) == ((bytes[n/8] &amp; (1&lt;&lt;(n%8))) != 0)}
     * &lt;br&gt;for all {@code n &lt; 8 * bytes.length}.
     *
     * @return a byte array containing a little-endian representation
     *         of all the bits in this bit set
     * @since 1.7
    */
    public byte[] toByteArray() {
<span class="nc" id="L297">        int n = wordsInUse;</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (n == 0)</span>
<span class="nc" id="L299">            return new byte[0];</span>
<span class="nc" id="L300">        int len = 8 * (n-1);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        for (long x = words[n - 1]; x != 0; x &gt;&gt;&gt;= 8)</span>
<span class="nc" id="L302">            len++;</span>
<span class="nc" id="L303">        byte[] bytes = new byte[len];</span>
<span class="nc" id="L304">        ByteBuffer bb = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        for (int i = 0; i &lt; n - 1; i++)</span>
<span class="nc" id="L306">            bb.putLong(words[i]);</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        for (long x = words[n - 1]; x != 0; x &gt;&gt;&gt;= 8)</span>
<span class="nc" id="L308">            bb.put((byte) (x &amp; 0xff));</span>
<span class="nc" id="L309">        return bytes;</span>
    }

    /**
     * Returns a new long array containing all the bits in this bit set.
     *
     * &lt;p&gt;More precisely, if
     * &lt;br&gt;{@code long[] longs = s.toLongArray();}
     * &lt;br&gt;then {@code longs.length == (s.length()+63)/64} and
     * &lt;br&gt;{@code s.get(n) == ((longs[n/64] &amp; (1L&lt;&lt;(n%64))) != 0)}
     * &lt;br&gt;for all {@code n &lt; 64 * longs.length}.
     *
     * @return a long array containing a little-endian representation
     *         of all the bits in this bit set
     * @since 1.7
    */
    public long[] toLongArray() {
<span class="nc" id="L326">        return Arrays.copyOf(words, wordsInUse);</span>
    }

    /**
     * Ensures that the BitSet can hold enough words.
     * @param wordsRequired the minimum acceptable number of words.
     */
    private void ensureCapacity(int wordsRequired) {
<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (words.length &lt; wordsRequired) {</span>
            // Allocate larger of doubled size or required size
<span class="fc" id="L336">            int request = Math.max(2 * words.length, wordsRequired);</span>
<span class="fc" id="L337">            words = Arrays.copyOf(words, request);</span>
<span class="fc" id="L338">            sizeIsSticky = false;</span>
        }
<span class="fc" id="L340">    }</span>

    /**
     * Ensures that the BitSet can accommodate a given wordIndex,
     * temporarily violating the invariants.  The caller must
     * restore the invariants before returning to the user,
     * possibly using recalculateWordsInUse().
     * @param wordIndex the index to be accommodated.
     */
    private void expandTo(int wordIndex) {
<span class="fc" id="L350">        int wordsRequired = wordIndex+1;</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (wordsInUse &lt; wordsRequired) {</span>
<span class="fc" id="L352">            ensureCapacity(wordsRequired);</span>
<span class="fc" id="L353">            wordsInUse = wordsRequired;</span>
        }
<span class="fc" id="L355">    }</span>

    /**
     * Checks that fromIndex ... toIndex is a valid range of bit indices.
     */
    private static void checkRange(int fromIndex, int toIndex) {
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if (fromIndex &lt; 0)</span>
<span class="nc" id="L362">            throw new IndexOutOfBoundsException(&quot;fromIndex &lt; 0: &quot; + fromIndex);</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        if (toIndex &lt; 0)</span>
<span class="nc" id="L364">            throw new IndexOutOfBoundsException(&quot;toIndex &lt; 0: &quot; + toIndex);</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">        if (fromIndex &gt; toIndex)</span>
<span class="nc" id="L366">            throw new IndexOutOfBoundsException(&quot;fromIndex: &quot; + fromIndex +</span>
                                                &quot; &gt; toIndex: &quot; + toIndex);
<span class="fc" id="L368">    }</span>

    /**
     * Sets the bit at the specified index to the complement of its
     * current value.
     *
     * @param  bitIndex the index of the bit to flip
     * @throws IndexOutOfBoundsException if the specified index is negative
     * @since  1.4
     */
    public void flip(int bitIndex) {
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        if (bitIndex &lt; 0)</span>
<span class="nc" id="L380">            throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);</span>

<span class="fc" id="L382">        int wordIndex = wordIndex(bitIndex);</span>
<span class="fc" id="L383">        expandTo(wordIndex);</span>

<span class="fc" id="L385">        words[wordIndex] ^= (1L &lt;&lt; bitIndex);</span>

<span class="fc" id="L387">        recalculateWordsInUse();</span>
<span class="fc" id="L388">        checkInvariants();</span>
<span class="fc" id="L389">    }</span>

    /**
     * Sets each bit from the specified {@code fromIndex} (inclusive) to the
     * specified {@code toIndex} (exclusive) to the complement of its current
     * value.
     *
     * @param  fromIndex index of the first bit to flip
     * @param  toIndex index after the last bit to flip
     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,
     *         or {@code toIndex} is negative, or {@code fromIndex} is
     *         larger than {@code toIndex}
     * @since  1.4
     */
    public void flip(int fromIndex, int toIndex) {
<span class="fc" id="L404">        checkRange(fromIndex, toIndex);</span>

<span class="fc bfc" id="L406" title="All 2 branches covered.">        if (fromIndex == toIndex)</span>
<span class="fc" id="L407">            return;</span>

<span class="fc" id="L409">        int startWordIndex = wordIndex(fromIndex);</span>
<span class="fc" id="L410">        int endWordIndex   = wordIndex(toIndex - 1);</span>
<span class="fc" id="L411">        expandTo(endWordIndex);</span>

<span class="fc" id="L413">        long firstWordMask = WORD_MASK &lt;&lt; fromIndex;</span>
<span class="fc" id="L414">        long lastWordMask  = WORD_MASK &gt;&gt;&gt; -toIndex;</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (startWordIndex == endWordIndex) {</span>
            // Case 1: One word
<span class="fc" id="L417">            words[startWordIndex] ^= (firstWordMask &amp; lastWordMask);</span>
        } else {
            // Case 2: Multiple words
            // Handle first word
<span class="fc" id="L421">            words[startWordIndex] ^= firstWordMask;</span>

            // Handle intermediate words, if any
<span class="fc bfc" id="L424" title="All 2 branches covered.">            for (int i = startWordIndex+1; i &lt; endWordIndex; i++)</span>
<span class="fc" id="L425">                words[i] ^= WORD_MASK;</span>

            // Handle last word
<span class="fc" id="L428">            words[endWordIndex] ^= lastWordMask;</span>
        }

<span class="fc" id="L431">        recalculateWordsInUse();</span>
<span class="fc" id="L432">        checkInvariants();</span>
<span class="fc" id="L433">    }</span>

    /**
     * Sets the bit at the specified index to {@code true}.
     *
     * @param  bitIndex a bit index
     * @throws IndexOutOfBoundsException if the specified index is negative
     * @since  JDK1.0
     */
    public void set(int bitIndex) {
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        if (bitIndex &lt; 0)</span>
<span class="nc" id="L444">            throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);</span>

<span class="fc" id="L446">        int wordIndex = wordIndex(bitIndex);</span>
<span class="fc" id="L447">        expandTo(wordIndex);</span>

<span class="fc" id="L449">        words[wordIndex] |= (1L &lt;&lt; bitIndex); // Restores invariants</span>

<span class="fc" id="L451">        checkInvariants();</span>
<span class="fc" id="L452">    }</span>

    /**
     * Sets the bit at the specified index to the specified value.
     *
     * @param  bitIndex a bit index
     * @param  value a boolean value to set
     * @throws IndexOutOfBoundsException if the specified index is negative
     * @since  1.4
     */
    public void set(int bitIndex, boolean value) {
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if (value)</span>
<span class="fc" id="L464">            set(bitIndex);</span>
        else
<span class="fc" id="L466">            clear(bitIndex);</span>
<span class="fc" id="L467">    }</span>

    /**
     * Sets the bits from the specified {@code fromIndex} (inclusive) to the
     * specified {@code toIndex} (exclusive) to {@code true}.
     *
     * @param  fromIndex index of the first bit to be set
     * @param  toIndex index after the last bit to be set
     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,
     *         or {@code toIndex} is negative, or {@code fromIndex} is
     *         larger than {@code toIndex}
     * @since  1.4
     */
    public void set(int fromIndex, int toIndex) {
<span class="fc" id="L481">        checkRange(fromIndex, toIndex);</span>

<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (fromIndex == toIndex)</span>
<span class="fc" id="L484">            return;</span>

        // Increase capacity if necessary
<span class="fc" id="L487">        int startWordIndex = wordIndex(fromIndex);</span>
<span class="fc" id="L488">        int endWordIndex   = wordIndex(toIndex - 1);</span>
<span class="fc" id="L489">        expandTo(endWordIndex);</span>

<span class="fc" id="L491">        long firstWordMask = WORD_MASK &lt;&lt; fromIndex;</span>
<span class="fc" id="L492">        long lastWordMask  = WORD_MASK &gt;&gt;&gt; -toIndex;</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (startWordIndex == endWordIndex) {</span>
            // Case 1: One word
<span class="fc" id="L495">            words[startWordIndex] |= (firstWordMask &amp; lastWordMask);</span>
        } else {
            // Case 2: Multiple words
            // Handle first word
<span class="fc" id="L499">            words[startWordIndex] |= firstWordMask;</span>

            // Handle intermediate words, if any
<span class="fc bfc" id="L502" title="All 2 branches covered.">            for (int i = startWordIndex+1; i &lt; endWordIndex; i++)</span>
<span class="fc" id="L503">                words[i] = WORD_MASK;</span>

            // Handle last word (restores invariants)
<span class="fc" id="L506">            words[endWordIndex] |= lastWordMask;</span>
        }

<span class="fc" id="L509">        checkInvariants();</span>
<span class="fc" id="L510">    }</span>

    /**
     * Sets the bits from the specified {@code fromIndex} (inclusive) to the
     * specified {@code toIndex} (exclusive) to the specified value.
     *
     * @param  fromIndex index of the first bit to be set
     * @param  toIndex index after the last bit to be set
     * @param  value value to set the selected bits to
     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,
     *         or {@code toIndex} is negative, or {@code fromIndex} is
     *         larger than {@code toIndex}
     * @since  1.4
     */
    public void set(int fromIndex, int toIndex, boolean value) {
<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (value)</span>
<span class="fc" id="L526">            set(fromIndex, toIndex);</span>
        else
<span class="fc" id="L528">            clear(fromIndex, toIndex);</span>
<span class="fc" id="L529">    }</span>

    /**
     * Sets the bit specified by the index to {@code false}.
     *
     * @param  bitIndex the index of the bit to be cleared
     * @throws IndexOutOfBoundsException if the specified index is negative
     * @since  JDK1.0
     */
    public void clear(int bitIndex) {
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">        if (bitIndex &lt; 0)</span>
<span class="nc" id="L540">            throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);</span>

<span class="fc" id="L542">        int wordIndex = wordIndex(bitIndex);</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (wordIndex &gt;= wordsInUse)</span>
<span class="fc" id="L544">            return;</span>

<span class="fc" id="L546">        words[wordIndex] &amp;= ~(1L &lt;&lt; bitIndex);</span>

<span class="fc" id="L548">        recalculateWordsInUse();</span>
<span class="fc" id="L549">        checkInvariants();</span>
<span class="fc" id="L550">    }</span>

    /**
     * Sets the bits from the specified {@code fromIndex} (inclusive) to the
     * specified {@code toIndex} (exclusive) to {@code false}.
     *
     * @param  fromIndex index of the first bit to be cleared
     * @param  toIndex index after the last bit to be cleared
     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,
     *         or {@code toIndex} is negative, or {@code fromIndex} is
     *         larger than {@code toIndex}
     * @since  1.4
     */
    public void clear(int fromIndex, int toIndex) {
<span class="fc" id="L564">        checkRange(fromIndex, toIndex);</span>

<span class="fc bfc" id="L566" title="All 2 branches covered.">        if (fromIndex == toIndex)</span>
<span class="fc" id="L567">            return;</span>

<span class="fc" id="L569">        int startWordIndex = wordIndex(fromIndex);</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (startWordIndex &gt;= wordsInUse)</span>
<span class="fc" id="L571">            return;</span>

<span class="fc" id="L573">        int endWordIndex = wordIndex(toIndex - 1);</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">        if (endWordIndex &gt;= wordsInUse) {</span>
<span class="fc" id="L575">            toIndex = length();</span>
<span class="fc" id="L576">            endWordIndex = wordsInUse - 1;</span>
        }

<span class="fc" id="L579">        long firstWordMask = WORD_MASK &lt;&lt; fromIndex;</span>
<span class="fc" id="L580">        long lastWordMask  = WORD_MASK &gt;&gt;&gt; -toIndex;</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">        if (startWordIndex == endWordIndex) {</span>
            // Case 1: One word
<span class="fc" id="L583">            words[startWordIndex] &amp;= ~(firstWordMask &amp; lastWordMask);</span>
        } else {
            // Case 2: Multiple words
            // Handle first word
<span class="fc" id="L587">            words[startWordIndex] &amp;= ~firstWordMask;</span>

            // Handle intermediate words, if any
<span class="fc bfc" id="L590" title="All 2 branches covered.">            for (int i = startWordIndex+1; i &lt; endWordIndex; i++)</span>
<span class="fc" id="L591">                words[i] = 0;</span>

            // Handle last word
<span class="fc" id="L594">            words[endWordIndex] &amp;= ~lastWordMask;</span>
        }

<span class="fc" id="L597">        recalculateWordsInUse();</span>
<span class="fc" id="L598">        checkInvariants();</span>
<span class="fc" id="L599">    }</span>

    /**
     * Sets all of the bits in this BitSet to {@code false}.
     *
     * @since 1.4
     */
    public void clear() {
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">        while (wordsInUse &gt; 0)</span>
<span class="nc" id="L608">            words[--wordsInUse] = 0;</span>
<span class="fc" id="L609">    }</span>

    /**
     * Returns the value of the bit with the specified index. The value
     * is {@code true} if the bit with the index {@code bitIndex}
     * is currently set in this {@code BitSet}; otherwise, the result
     * is {@code false}.
     *
     * @param  bitIndex   the bit index
     * @return the value of the bit with the specified index
     * @throws IndexOutOfBoundsException if the specified index is negative
     */
    public boolean get(int bitIndex) {
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">        if (bitIndex &lt; 0)</span>
<span class="nc" id="L623">            throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);</span>

<span class="fc" id="L625">        checkInvariants();</span>

<span class="fc" id="L627">        int wordIndex = wordIndex(bitIndex);</span>
<span class="fc bfc" id="L628" title="All 4 branches covered.">        return (wordIndex &lt; wordsInUse)</span>
            &amp;&amp; ((words[wordIndex] &amp; (1L &lt;&lt; bitIndex)) != 0);
    }

    /**
     * Returns a new {@code BitSet} composed of bits from this {@code BitSet}
     * from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive).
     *
     * @param  fromIndex index of the first bit to include
     * @param  toIndex index after the last bit to include
     * @return a new {@code BitSet} from a range of this {@code BitSet}
     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,
     *         or {@code toIndex} is negative, or {@code fromIndex} is
     *         larger than {@code toIndex}
     * @since  1.4
     */
    public BitSet get(int fromIndex, int toIndex) {
<span class="fc" id="L645">        checkRange(fromIndex, toIndex);</span>

<span class="fc" id="L647">        checkInvariants();</span>

<span class="fc" id="L649">        int len = length();</span>

        // If no set bits in range return empty bitset
<span class="fc bfc" id="L652" title="All 4 branches covered.">        if (len &lt;= fromIndex || fromIndex == toIndex)</span>
<span class="fc" id="L653">            return new BitSet(0);</span>

        // An optimization
<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (toIndex &gt; len)</span>
<span class="fc" id="L657">            toIndex = len;</span>

<span class="fc" id="L659">        BitSet result = new BitSet(toIndex - fromIndex);</span>
<span class="fc" id="L660">        int targetWords = wordIndex(toIndex - fromIndex - 1) + 1;</span>
<span class="fc" id="L661">        int sourceIndex = wordIndex(fromIndex);</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">        boolean wordAligned = ((fromIndex &amp; BIT_INDEX_MASK) == 0);</span>

        // Process all words but the last word
<span class="fc bfc" id="L665" title="All 2 branches covered.">        for (int i = 0; i &lt; targetWords - 1; i++, sourceIndex++)</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">            result.words[i] = wordAligned ? words[sourceIndex] :</span>
                (words[sourceIndex] &gt;&gt;&gt; fromIndex) |
                (words[sourceIndex+1] &lt;&lt; -fromIndex);

        // Process the last word
<span class="fc" id="L671">        long lastWordMask = WORD_MASK &gt;&gt;&gt; -toIndex;</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">        result.words[targetWords - 1] =</span>
            ((toIndex-1) &amp; BIT_INDEX_MASK) &lt; (fromIndex &amp; BIT_INDEX_MASK)
            ? /* straddles source words */
            ((words[sourceIndex] &gt;&gt;&gt; fromIndex) |
             (words[sourceIndex+1] &amp; lastWordMask) &lt;&lt; -fromIndex)
            :
            ((words[sourceIndex] &amp; lastWordMask) &gt;&gt;&gt; fromIndex);

        // Set wordsInUse correctly
<span class="fc" id="L681">        result.wordsInUse = targetWords;</span>
<span class="fc" id="L682">        result.recalculateWordsInUse();</span>
<span class="fc" id="L683">        result.checkInvariants();</span>

<span class="fc" id="L685">        return result;</span>
    }

    /**
     * Returns the index of the first bit that is set to {@code true}
     * that occurs on or after the specified starting index. If no such
     * bit exists then {@code -1} is returned.
     *
     * &lt;p&gt;To iterate over the {@code true} bits in a {@code BitSet},
     * use the following loop:
     *
     *  &lt;pre&gt; {@code
     * for (int i = bs.nextSetBit(0); i &gt;= 0; i = bs.nextSetBit(i+1)) {
     *     // operate on index i here
     * }}&lt;/pre&gt;
     *
     * @param  fromIndex the index to start checking from (inclusive)
     * @return the index of the next set bit, or {@code -1} if there
     *         is no such bit
     * @throws IndexOutOfBoundsException if the specified index is negative
     * @since  1.4
     */
    public int nextSetBit(int fromIndex) {
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">        if (fromIndex &lt; 0)</span>
<span class="nc" id="L709">            throw new IndexOutOfBoundsException(&quot;fromIndex &lt; 0: &quot; + fromIndex);</span>

<span class="fc" id="L711">        checkInvariants();</span>

<span class="fc" id="L713">        int u = wordIndex(fromIndex);</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">        if (u &gt;= wordsInUse)</span>
<span class="fc" id="L715">            return -1;</span>

<span class="fc" id="L717">        long word = words[u] &amp; (WORD_MASK &lt;&lt; fromIndex);</span>

        while (true) {
<span class="fc bfc" id="L720" title="All 2 branches covered.">            if (word != 0)</span>
<span class="fc" id="L721">                return (u * BITS_PER_WORD) + Long.numberOfTrailingZeros(word);</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">            if (++u == wordsInUse)</span>
<span class="fc" id="L723">                return -1;</span>
<span class="fc" id="L724">            word = words[u];</span>
        }
    }

    /**
     * Returns the index of the first bit that is set to {@code false}
     * that occurs on or after the specified starting index.
     *
     * @param  fromIndex the index to start checking from (inclusive)
     * @return the index of the next clear bit
     * @throws IndexOutOfBoundsException if the specified index is negative
     * @since  1.4
     */
    public int nextClearBit(int fromIndex) {
        // Neither spec nor implementation handle bitsets of maximal length.
        // See 4816253.
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">        if (fromIndex &lt; 0)</span>
<span class="nc" id="L741">            throw new IndexOutOfBoundsException(&quot;fromIndex &lt; 0: &quot; + fromIndex);</span>

<span class="fc" id="L743">        checkInvariants();</span>

<span class="fc" id="L745">        int u = wordIndex(fromIndex);</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">        if (u &gt;= wordsInUse)</span>
<span class="fc" id="L747">            return fromIndex;</span>

<span class="fc" id="L749">        long word = ~words[u] &amp; (WORD_MASK &lt;&lt; fromIndex);</span>

        while (true) {
<span class="fc bfc" id="L752" title="All 2 branches covered.">            if (word != 0)</span>
<span class="fc" id="L753">                return (u * BITS_PER_WORD) + Long.numberOfTrailingZeros(word);</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">            if (++u == wordsInUse)</span>
<span class="fc" id="L755">                return wordsInUse * BITS_PER_WORD;</span>
<span class="fc" id="L756">            word = ~words[u];</span>
        }
    }

    /**
     * Returns the index of the nearest bit that is set to {@code true}
     * that occurs on or before the specified starting index.
     * If no such bit exists, or if {@code -1} is given as the
     * starting index, then {@code -1} is returned.
     *
     * &lt;p&gt;To iterate over the {@code true} bits in a {@code BitSet},
     * use the following loop:
     *
     *  &lt;pre&gt; {@code
     * for (int i = bs.length(); (i = bs.previousSetBit(i-1)) &gt;= 0; ) {
     *     // operate on index i here
     * }}&lt;/pre&gt;
     *
     * @param  fromIndex the index to start checking from (inclusive)
     * @return the index of the previous set bit, or {@code -1} if there
     *         is no such bit
     * @throws IndexOutOfBoundsException if the specified index is less
     *         than {@code -1}
     * @since  1.7
     */
    public int previousSetBit(int fromIndex) {
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (fromIndex &lt; 0) {</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">            if (fromIndex == -1)</span>
<span class="nc" id="L784">                return -1;</span>
<span class="nc" id="L785">            throw new IndexOutOfBoundsException(</span>
                &quot;fromIndex &lt; -1: &quot; + fromIndex);
        }

<span class="nc" id="L789">        checkInvariants();</span>

<span class="nc" id="L791">        int u = wordIndex(fromIndex);</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">        if (u &gt;= wordsInUse)</span>
<span class="nc" id="L793">            return length() - 1;</span>

<span class="nc" id="L795">        long word = words[u] &amp; (WORD_MASK &gt;&gt;&gt; -(fromIndex+1));</span>

        while (true) {
<span class="nc bnc" id="L798" title="All 2 branches missed.">            if (word != 0)</span>
<span class="nc" id="L799">                return (u+1) * BITS_PER_WORD - 1 - Long.numberOfLeadingZeros(word);</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">            if (u-- == 0)</span>
<span class="nc" id="L801">                return -1;</span>
<span class="nc" id="L802">            word = words[u];</span>
        }
    }

    /**
     * Returns the index of the nearest bit that is set to {@code false}
     * that occurs on or before the specified starting index.
     * If no such bit exists, or if {@code -1} is given as the
     * starting index, then {@code -1} is returned.
     *
     * @param  fromIndex the index to start checking from (inclusive)
     * @return the index of the previous clear bit, or {@code -1} if there
     *         is no such bit
     * @throws IndexOutOfBoundsException if the specified index is less
     *         than {@code -1}
     * @since  1.7
     */
    public int previousClearBit(int fromIndex) {
<span class="nc bnc" id="L820" title="All 2 branches missed.">        if (fromIndex &lt; 0) {</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">            if (fromIndex == -1)</span>
<span class="nc" id="L822">                return -1;</span>
<span class="nc" id="L823">            throw new IndexOutOfBoundsException(</span>
                &quot;fromIndex &lt; -1: &quot; + fromIndex);
        }

<span class="nc" id="L827">        checkInvariants();</span>

<span class="nc" id="L829">        int u = wordIndex(fromIndex);</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (u &gt;= wordsInUse)</span>
<span class="nc" id="L831">            return fromIndex;</span>

<span class="nc" id="L833">        long word = ~words[u] &amp; (WORD_MASK &gt;&gt;&gt; -(fromIndex+1));</span>

        while (true) {
<span class="nc bnc" id="L836" title="All 2 branches missed.">            if (word != 0)</span>
<span class="nc" id="L837">                return (u+1) * BITS_PER_WORD -1 - Long.numberOfLeadingZeros(word);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">            if (u-- == 0)</span>
<span class="nc" id="L839">                return -1;</span>
<span class="nc" id="L840">            word = ~words[u];</span>
        }
    }

    /**
     * Returns the &quot;logical size&quot; of this {@code BitSet}: the index of
     * the highest set bit in the {@code BitSet} plus one. Returns zero
     * if the {@code BitSet} contains no set bits.
     *
     * @return the logical size of this {@code BitSet}
     * @since  1.2
     */
    public int length() {
<span class="fc bfc" id="L853" title="All 2 branches covered.">        if (wordsInUse == 0)</span>
<span class="fc" id="L854">            return 0;</span>

<span class="fc" id="L856">        return BITS_PER_WORD * (wordsInUse - 1) +</span>
<span class="fc" id="L857">            (BITS_PER_WORD - Long.numberOfLeadingZeros(words[wordsInUse - 1]));</span>
    }

    /**
     * Returns true if this {@code BitSet} contains no bits that are set
     * to {@code true}.
     *
     * @return boolean indicating whether this {@code BitSet} is empty
     * @since  1.4
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L868" title="All 2 branches covered.">        return wordsInUse == 0;</span>
    }

    /**
     * Returns true if the specified {@code BitSet} has any bits set to
     * {@code true} that are also set to {@code true} in this {@code BitSet}.
     *
     * @param  set {@code BitSet} to intersect with
     * @return boolean indicating whether this {@code BitSet} intersects
     *         the specified {@code BitSet}
     * @since  1.4
     */
    public boolean intersects(BitSet set) {
<span class="fc bfc" id="L881" title="All 2 branches covered.">        for (int i = Math.min(wordsInUse, set.wordsInUse) - 1; i &gt;= 0; i--)</span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">            if ((words[i] &amp; set.words[i]) != 0)</span>
<span class="fc" id="L883">                return true;</span>
<span class="fc" id="L884">        return false;</span>
    }

    /**
     * Returns the number of bits set to {@code true} in this {@code BitSet}.
     *
     * @return the number of bits set to {@code true} in this {@code BitSet}
     * @since  1.4
     */
    public int cardinality() {
<span class="fc" id="L894">        int sum = 0;</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">        for (int i = 0; i &lt; wordsInUse; i++)</span>
<span class="fc" id="L896">            sum += Long.bitCount(words[i]);</span>
<span class="fc" id="L897">        return sum;</span>
    }

    /**
     * Performs a logical &lt;b&gt;AND&lt;/b&gt; of this target bit set with the
     * argument bit set. This bit set is modified so that each bit in it
     * has the value {@code true} if and only if it both initially
     * had the value {@code true} and the corresponding bit in the
     * bit set argument also had the value {@code true}.
     *
     * @param set a bit set
     */
    public void and(BitSet set) {
<span class="fc bfc" id="L910" title="All 2 branches covered.">        if (this == set)</span>
<span class="fc" id="L911">            return;</span>

<span class="fc bfc" id="L913" title="All 2 branches covered.">        while (wordsInUse &gt; set.wordsInUse)</span>
<span class="fc" id="L914">            words[--wordsInUse] = 0;</span>

        // Perform logical AND on words in common
<span class="fc bfc" id="L917" title="All 2 branches covered.">        for (int i = 0; i &lt; wordsInUse; i++)</span>
<span class="fc" id="L918">            words[i] &amp;= set.words[i];</span>

<span class="fc" id="L920">        recalculateWordsInUse();</span>
<span class="fc" id="L921">        checkInvariants();</span>
<span class="fc" id="L922">    }</span>

    /**
     * Performs a logical &lt;b&gt;OR&lt;/b&gt; of this bit set with the bit set
     * argument. This bit set is modified so that a bit in it has the
     * value {@code true} if and only if it either already had the
     * value {@code true} or the corresponding bit in the bit set
     * argument has the value {@code true}.
     *
     * @param set a bit set
     */
    public void or(BitSet set) {
<span class="fc bfc" id="L934" title="All 2 branches covered.">        if (this == set)</span>
<span class="fc" id="L935">            return;</span>

<span class="fc" id="L937">        int wordsInCommon = Math.min(wordsInUse, set.wordsInUse);</span>

<span class="fc bfc" id="L939" title="All 2 branches covered.">        if (wordsInUse &lt; set.wordsInUse) {</span>
<span class="fc" id="L940">            ensureCapacity(set.wordsInUse);</span>
<span class="fc" id="L941">            wordsInUse = set.wordsInUse;</span>
        }

        // Perform logical OR on words in common
<span class="fc bfc" id="L945" title="All 2 branches covered.">        for (int i = 0; i &lt; wordsInCommon; i++)</span>
<span class="fc" id="L946">            words[i] |= set.words[i];</span>

        // Copy any remaining words
<span class="fc bfc" id="L949" title="All 2 branches covered.">        if (wordsInCommon &lt; set.wordsInUse)</span>
<span class="fc" id="L950">            System.arraycopy(set.words, wordsInCommon,</span>
                             words, wordsInCommon,
                             wordsInUse - wordsInCommon);

        // recalculateWordsInUse() is unnecessary
<span class="fc" id="L955">        checkInvariants();</span>
<span class="fc" id="L956">    }</span>

    /**
     * Performs a logical &lt;b&gt;XOR&lt;/b&gt; of this bit set with the bit set
     * argument. This bit set is modified so that a bit in it has the
     * value {@code true} if and only if one of the following
     * statements holds:
     * &lt;ul&gt;
     * &lt;li&gt;The bit initially has the value {@code true}, and the
     *     corresponding bit in the argument has the value {@code false}.
     * &lt;li&gt;The bit initially has the value {@code false}, and the
     *     corresponding bit in the argument has the value {@code true}.
     * &lt;/ul&gt;
     *
     * @param  set a bit set
     */
    public void xor(BitSet set) {
<span class="fc" id="L973">        int wordsInCommon = Math.min(wordsInUse, set.wordsInUse);</span>

<span class="fc bfc" id="L975" title="All 2 branches covered.">        if (wordsInUse &lt; set.wordsInUse) {</span>
<span class="fc" id="L976">            ensureCapacity(set.wordsInUse);</span>
<span class="fc" id="L977">            wordsInUse = set.wordsInUse;</span>
        }

        // Perform logical XOR on words in common
<span class="fc bfc" id="L981" title="All 2 branches covered.">        for (int i = 0; i &lt; wordsInCommon; i++)</span>
<span class="fc" id="L982">            words[i] ^= set.words[i];</span>

        // Copy any remaining words
<span class="fc bfc" id="L985" title="All 2 branches covered.">        if (wordsInCommon &lt; set.wordsInUse)</span>
<span class="fc" id="L986">            System.arraycopy(set.words, wordsInCommon,</span>
                             words, wordsInCommon,
                             set.wordsInUse - wordsInCommon);

<span class="fc" id="L990">        recalculateWordsInUse();</span>
<span class="fc" id="L991">        checkInvariants();</span>
<span class="fc" id="L992">    }</span>

    /**
     * Clears all of the bits in this {@code BitSet} whose corresponding
     * bit is set in the specified {@code BitSet}.
     *
     * @param  set the {@code BitSet} with which to mask this
     *         {@code BitSet}
     * @since  1.2
     */
    public void andNot(BitSet set) {
        // Perform logical (a &amp; !b) on words in common
<span class="fc bfc" id="L1004" title="All 2 branches covered.">        for (int i = Math.min(wordsInUse, set.wordsInUse) - 1; i &gt;= 0; i--)</span>
<span class="fc" id="L1005">            words[i] &amp;= ~set.words[i];</span>

<span class="fc" id="L1007">        recalculateWordsInUse();</span>
<span class="fc" id="L1008">        checkInvariants();</span>
<span class="fc" id="L1009">    }</span>

    /**
     * Returns the hash code value for this bit set. The hash code depends
     * only on which bits are set within this {@code BitSet}.
     *
     * &lt;p&gt;The hash code is defined to be the result of the following
     * calculation:
     *  &lt;pre&gt; {@code
     * public int hashCode() {
     *     long h = 1234;
     *     long[] words = toLongArray();
     *     for (int i = words.length; --i &gt;= 0; )
     *         h ^= words[i] * (i + 1);
     *     return (int)((h &gt;&gt; 32) ^ h);
     * }}&lt;/pre&gt;
     * Note that the hash code changes if the set of bits is altered.
     *
     * @return the hash code value for this bit set
     */
    public int hashCode() {
<span class="nc" id="L1030">        long h = 1234;</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        for (int i = wordsInUse; --i &gt;= 0; )</span>
<span class="nc" id="L1032">            h ^= words[i] * (i + 1);</span>

<span class="nc" id="L1034">        return (int)((h &gt;&gt; 32) ^ h);</span>
    }

    /**
     * Returns the number of bits of space actually in use by this
     * {@code BitSet} to represent bit values.
     * The maximum element in the set is the size - 1st element.
     *
     * @return the number of bits currently in this bit set
     */
    public int size() {
<span class="fc" id="L1045">        return words.length * BITS_PER_WORD;</span>
    }

    /**
     * Compares this object against the specified object.
     * The result is {@code true} if and only if the argument is
     * not {@code null} and is a {@code Bitset} object that has
     * exactly the same set of bits set to {@code true} as this bit
     * set. That is, for every nonnegative {@code int} index {@code k},
     * &lt;pre&gt;((BitSet)obj).get(k) == this.get(k)&lt;/pre&gt;
     * must be true. The current sizes of the two bit sets are not compared.
     *
     * @param  obj the object to compare with
     * @return {@code true} if the objects are the same;
     *         {@code false} otherwise
     * @see    #size()
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">        if (!(obj instanceof BitSet))</span>
<span class="nc" id="L1064">            return false;</span>
<span class="pc bpc" id="L1065" title="1 of 2 branches missed.">        if (this == obj)</span>
<span class="nc" id="L1066">            return true;</span>

<span class="fc" id="L1068">        BitSet set = (BitSet) obj;</span>

<span class="fc" id="L1070">        checkInvariants();</span>
<span class="fc" id="L1071">        set.checkInvariants();</span>

<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">        if (wordsInUse != set.wordsInUse)</span>
<span class="nc" id="L1074">            return false;</span>

        // Check words in use by both BitSets
<span class="fc bfc" id="L1077" title="All 2 branches covered.">        for (int i = 0; i &lt; wordsInUse; i++)</span>
<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">            if (words[i] != set.words[i])</span>
<span class="nc" id="L1079">                return false;</span>

<span class="fc" id="L1081">        return true;</span>
    }

    /**
     * Cloning this {@code BitSet} produces a new {@code BitSet}
     * that is equal to it.
     * The clone of the bit set is another bit set that has exactly the
     * same bits set to {@code true} as this bit set.
     *
     * @return a clone of this bit set
     * @see    #size()
     */
    public Object clone() {
<span class="fc bfc" id="L1094" title="All 2 branches covered.">        if (! sizeIsSticky)</span>
<span class="fc" id="L1095">            trimToSize();</span>

        try {
<span class="fc" id="L1098">            BitSet result = (BitSet) super.clone();</span>
<span class="fc" id="L1099">            result.words = words.clone();</span>
<span class="fc" id="L1100">            result.checkInvariants();</span>
<span class="fc" id="L1101">            return result;</span>
<span class="nc" id="L1102">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L1103">            throw new InternalError(e);</span>
        }
    }

    /**
     * Attempts to reduce internal storage used for the bits in this bit set.
     * Calling this method may, but is not required to, affect the value
     * returned by a subsequent call to the {@link #size()} method.
     */
    private void trimToSize() {
<span class="fc bfc" id="L1113" title="All 2 branches covered.">        if (wordsInUse != words.length) {</span>
<span class="fc" id="L1114">            words = Arrays.copyOf(words, wordsInUse);</span>
<span class="fc" id="L1115">            checkInvariants();</span>
        }
<span class="fc" id="L1117">    }</span>

    /**
     * Save the state of the {@code BitSet} instance to a stream (i.e.,
     * serialize it).
     */
    private void writeObject(ObjectOutputStream s)
        throws IOException {

<span class="nc" id="L1126">        checkInvariants();</span>

<span class="nc bnc" id="L1128" title="All 2 branches missed.">        if (! sizeIsSticky)</span>
<span class="nc" id="L1129">            trimToSize();</span>

<span class="nc" id="L1131">        ObjectOutputStream.PutField fields = s.putFields();</span>
<span class="nc" id="L1132">        fields.put(&quot;bits&quot;, words);</span>
<span class="nc" id="L1133">        s.writeFields();</span>
<span class="nc" id="L1134">    }</span>

    /**
     * Reconstitute the {@code BitSet} instance from a stream (i.e.,
     * deserialize it).
     */
    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {

<span class="nc" id="L1143">        ObjectInputStream.GetField fields = s.readFields();</span>
<span class="nc" id="L1144">        words = (long[]) fields.get(&quot;bits&quot;, null);</span>

        // Assume maximum length then find real length
        // because recalculateWordsInUse assumes maintenance
        // or reduction in logical size
<span class="nc" id="L1149">        wordsInUse = words.length;</span>
<span class="nc" id="L1150">        recalculateWordsInUse();</span>
<span class="nc bnc" id="L1151" title="All 4 branches missed.">        sizeIsSticky = (words.length &gt; 0 &amp;&amp; words[words.length-1] == 0L); // heuristic</span>
<span class="nc" id="L1152">        checkInvariants();</span>
<span class="nc" id="L1153">    }</span>

    /**
     * Returns a string representation of this bit set. For every index
     * for which this {@code BitSet} contains a bit in the set
     * state, the decimal representation of that index is included in
     * the result. Such indices are listed in order from lowest to
     * highest, separated by &quot;,&amp;nbsp;&quot; (a comma and a space) and
     * surrounded by braces, resulting in the usual mathematical
     * notation for a set of integers.
     *
     * &lt;p&gt;Example:
     * &lt;pre&gt;
     * BitSet drPepper = new BitSet();&lt;/pre&gt;
     * Now {@code drPepper.toString()} returns &quot;{@code {}}&quot;.
     * &lt;pre&gt;
     * drPepper.set(2);&lt;/pre&gt;
     * Now {@code drPepper.toString()} returns &quot;{@code {2}}&quot;.
     * &lt;pre&gt;
     * drPepper.set(4);
     * drPepper.set(10);&lt;/pre&gt;
     * Now {@code drPepper.toString()} returns &quot;{@code {2, 4, 10}}&quot;.
     *
     * @return a string representation of this bit set
     */
    public String toString() {
<span class="fc" id="L1179">        checkInvariants();</span>

<span class="pc bpc" id="L1181" title="1 of 2 branches missed.">        int numBits = (wordsInUse &gt; 128) ?</span>
<span class="pc" id="L1182">            cardinality() : wordsInUse * BITS_PER_WORD;</span>
<span class="fc" id="L1183">        StringBuilder b = new StringBuilder(6*numBits + 2);</span>
<span class="fc" id="L1184">        b.append('{');</span>

<span class="fc" id="L1186">        int i = nextSetBit(0);</span>
<span class="fc bfc" id="L1187" title="All 2 branches covered.">        if (i != -1) {</span>
<span class="fc" id="L1188">            b.append(i);</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">            for (i = nextSetBit(i+1); i &gt;= 0; i = nextSetBit(i+1)) {</span>
<span class="fc" id="L1190">                int endOfRun = nextClearBit(i);</span>
<span class="fc" id="L1191">                do { b.append(&quot;, &quot;).append(i); }</span>
<span class="fc bfc" id="L1192" title="All 2 branches covered.">                while (++i &lt; endOfRun);</span>
            }
        }

<span class="fc" id="L1196">        b.append('}');</span>
<span class="fc" id="L1197">        return b.toString();</span>
    }

    /**
     * Returns a stream of indices for which this {@code BitSet}
     * contains a bit in the set state. The indices are returned
     * in order, from lowest to highest. The size of the stream
     * is the number of bits in the set state, equal to the value
     * returned by the {@link #cardinality()} method.
     *
     * &lt;p&gt;The bit set must remain constant during the execution of the
     * terminal stream operation.  Otherwise, the result of the terminal
     * stream operation is undefined.
     *
     * @return a stream of integers representing set indices
     * @since 1.8
     */
    public IntStream stream() {
<span class="nc" id="L1215">        class BitSetIterator implements PrimitiveIterator.OfInt {</span>
<span class="nc" id="L1216">            int next = nextSetBit(0);</span>

            @Override
            public boolean hasNext() {
<span class="nc bnc" id="L1220" title="All 2 branches missed.">                return next != -1;</span>
            }

            @Override
            public int nextInt() {
<span class="nc bnc" id="L1225" title="All 2 branches missed.">                if (next != -1) {</span>
<span class="nc" id="L1226">                    int ret = next;</span>
<span class="nc" id="L1227">                    next = nextSetBit(next+1);</span>
<span class="nc" id="L1228">                    return ret;</span>
                } else {
<span class="nc" id="L1230">                    throw new NoSuchElementException();</span>
                }
            }
        }

<span class="nc" id="L1235">        return StreamSupport.intStream(</span>
                () -&gt; Spliterators.spliterator(
                        new BitSetIterator(), cardinality(),
                        Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.SORTED),
                Spliterator.SIZED | Spliterator.SUBSIZED |
                        Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.SORTED,
                false);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>