<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PropertyPermission.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">PropertyPermission.java</span></div><h1>PropertyPermission.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.io.Serializable;
import java.io.IOException;
import java.security.*;
import java.util.Map;
import java.util.HashMap;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Collections;
import java.io.ObjectStreamField;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import sun.security.util.SecurityConstants;

/**
 * This class is for property permissions.
 *
 * &lt;P&gt;
 * The name is the name of the property (&quot;java.home&quot;,
 * &quot;os.name&quot;, etc). The naming
 * convention follows the  hierarchical property naming convention.
 * Also, an asterisk
 * may appear at the end of the name, following a &quot;.&quot;, or by itself, to
 * signify a wildcard match. For example: &quot;java.*&quot; and &quot;*&quot; signify a wildcard
 * match, while &quot;*java&quot; and &quot;a*b&quot; do not.
 * &lt;P&gt;
 * The actions to be granted are passed to the constructor in a string containing
 * a list of one or more comma-separated keywords. The possible keywords are
 * &quot;read&quot; and &quot;write&quot;. Their meaning is defined as follows:
 *
 * &lt;DL&gt;
 *    &lt;DT&gt; read
 *    &lt;DD&gt; read permission. Allows &lt;code&gt;System.getProperty&lt;/code&gt; to
 *         be called.
 *    &lt;DT&gt; write
 *    &lt;DD&gt; write permission. Allows &lt;code&gt;System.setProperty&lt;/code&gt; to
 *         be called.
 * &lt;/DL&gt;
 * &lt;P&gt;
 * The actions string is converted to lowercase before processing.
 * &lt;P&gt;
 * Care should be taken before granting code permission to access
 * certain system properties.  For example, granting permission to
 * access the &quot;java.home&quot; system property gives potentially malevolent
 * code sensitive information about the system environment (the Java
 * installation directory).  Also, granting permission to access
 * the &quot;user.name&quot; and &quot;user.home&quot; system properties gives potentially
 * malevolent code sensitive information about the user environment
 * (the user's account name and home directory).
 *
 * @see java.security.BasicPermission
 * @see java.security.Permission
 * @see java.security.Permissions
 * @see java.security.PermissionCollection
 * @see java.lang.SecurityManager
 *
 *
 * @author Roland Schemers
 * @since 1.2
 *
 * @serial exclude
 */

public final class PropertyPermission extends BasicPermission {

    /**
     * Read action.
     */
    private final static int READ    = 0x1;

    /**
     * Write action.
     */
    private final static int WRITE   = 0x2;
    /**
     * All actions (read,write);
     */
    private final static int ALL     = READ|WRITE;
    /**
     * No actions.
     */
    private final static int NONE    = 0x0;

    /**
     * The actions mask.
     *
     */
    private transient int mask;

    /**
     * The actions string.
     *
     * @serial
     */
    private String actions; // Left null as long as possible, then
                            // created and re-used in the getAction function.

    /**
     * initialize a PropertyPermission object. Common to all constructors.
     * Also called during de-serialization.
     *
     * @param mask the actions mask to use.
     *
     */
    private void init(int mask) {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if ((mask &amp; ALL) != mask)</span>
<span class="nc" id="L134">            throw new IllegalArgumentException(&quot;invalid actions mask&quot;);</span>

<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if (mask == NONE)</span>
<span class="nc" id="L137">            throw new IllegalArgumentException(&quot;invalid actions mask&quot;);</span>

<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (getName() == null)</span>
<span class="nc" id="L140">            throw new NullPointerException(&quot;name can't be null&quot;);</span>

<span class="fc" id="L142">        this.mask = mask;</span>
<span class="fc" id="L143">    }</span>

    /**
     * Creates a new PropertyPermission object with the specified name.
     * The name is the name of the system property, and
     * &lt;i&gt;actions&lt;/i&gt; contains a comma-separated list of the
     * desired actions granted on the property. Possible actions are
     * &quot;read&quot; and &quot;write&quot;.
     *
     * @param name the name of the PropertyPermission.
     * @param actions the actions string.
     *
     * @throws NullPointerException if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; is empty or if
     * &lt;code&gt;actions&lt;/code&gt; is invalid.
     */
    public PropertyPermission(String name, String actions) {
<span class="fc" id="L160">        super(name,actions);</span>
<span class="fc" id="L161">        init(getMask(actions));</span>
<span class="fc" id="L162">    }</span>

    /**
     * Checks if this PropertyPermission object &quot;implies&quot; the specified
     * permission.
     * &lt;P&gt;
     * More specifically, this method returns true if:
     * &lt;ul&gt;
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; is an instanceof PropertyPermission,
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;'s actions are a subset of this
     * object's actions, and
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;'s name is implied by this object's
     *      name. For example, &quot;java.*&quot; implies &quot;java.home&quot;.
     * &lt;/ul&gt;
     * @param p the permission to check against.
     *
     * @return true if the specified permission is implied by this object,
     * false if not.
     */
    public boolean implies(Permission p) {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        if (!(p instanceof PropertyPermission))</span>
<span class="nc" id="L183">            return false;</span>

<span class="fc" id="L185">        PropertyPermission that = (PropertyPermission) p;</span>

        // we get the effective mask. i.e., the &quot;and&quot; of this and that.
        // They must be equal to that.mask for implies to return true.

<span class="pc bpc" id="L190" title="1 of 4 branches missed.">        return ((this.mask &amp; that.mask) == that.mask) &amp;&amp; super.implies(that);</span>
    }

    /**
     * Checks two PropertyPermission objects for equality. Checks that &lt;i&gt;obj&lt;/i&gt; is
     * a PropertyPermission, and has the same name and actions as this object.
     * &lt;P&gt;
     * @param obj the object we are testing for equality with this object.
     * @return true if obj is a PropertyPermission, and has the same name and
     * actions as this PropertyPermission object.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L203">            return true;</span>

<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (! (obj instanceof PropertyPermission))</span>
<span class="nc" id="L206">            return false;</span>

<span class="nc" id="L208">        PropertyPermission that = (PropertyPermission) obj;</span>

<span class="nc bnc" id="L210" title="All 2 branches missed.">        return (this.mask == that.mask) &amp;&amp;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            (this.getName().equals(that.getName()));</span>
    }

    /**
     * Returns the hash code value for this object.
     * The hash code used is the hash code of this permissions name, that is,
     * &lt;code&gt;getName().hashCode()&lt;/code&gt;, where &lt;code&gt;getName&lt;/code&gt; is
     * from the Permission superclass.
     *
     * @return a hash code value for this object.
     */
    public int hashCode() {
<span class="nc" id="L223">        return this.getName().hashCode();</span>
    }

    /**
     * Converts an actions String to an actions mask.
     *
     * @param actions the action string.
     * @return the actions mask.
     */
    private static int getMask(String actions) {

<span class="fc" id="L234">        int mask = NONE;</span>

<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        if (actions == null) {</span>
<span class="nc" id="L237">            return mask;</span>
        }

        // Use object identity comparison against known-interned strings for
        // performance benefit (these values are used heavily within the JDK).
<span class="fc bfc" id="L242" title="All 2 branches covered.">        if (actions == SecurityConstants.PROPERTY_READ_ACTION) {</span>
<span class="fc" id="L243">            return READ;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        } if (actions == SecurityConstants.PROPERTY_WRITE_ACTION) {</span>
<span class="fc" id="L245">            return WRITE;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        } else if (actions == SecurityConstants.PROPERTY_RW_ACTION) {</span>
<span class="fc" id="L247">            return READ|WRITE;</span>
        }

<span class="fc" id="L250">        char[] a = actions.toCharArray();</span>

<span class="fc" id="L252">        int i = a.length - 1;</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        if (i &lt; 0)</span>
<span class="nc" id="L254">            return mask;</span>

<span class="fc bfc" id="L256" title="All 2 branches covered.">        while (i != -1) {</span>
            char c;

            // skip whitespace
<span class="pc bpc" id="L260" title="6 of 12 branches missed.">            while ((i!=-1) &amp;&amp; ((c = a[i]) == ' ' ||</span>
                               c == '\r' ||
                               c == '\n' ||
                               c == '\f' ||
                               c == '\t'))
<span class="nc" id="L265">                i--;</span>

            // check for the known strings
            int matchlen;

<span class="pc bpc" id="L270" title="11 of 18 branches missed.">            if (i &gt;= 3 &amp;&amp; (a[i-3] == 'r' || a[i-3] == 'R') &amp;&amp;</span>
                          (a[i-2] == 'e' || a[i-2] == 'E') &amp;&amp;
                          (a[i-1] == 'a' || a[i-1] == 'A') &amp;&amp;
                          (a[i] == 'd' || a[i] == 'D'))
            {
<span class="fc" id="L275">                matchlen = 4;</span>
<span class="fc" id="L276">                mask |= READ;</span>

<span class="pc bpc" id="L278" title="16 of 22 branches missed.">            } else if (i &gt;= 4 &amp;&amp; (a[i-4] == 'w' || a[i-4] == 'W') &amp;&amp;</span>
                                 (a[i-3] == 'r' || a[i-3] == 'R') &amp;&amp;
                                 (a[i-2] == 'i' || a[i-2] == 'I') &amp;&amp;
                                 (a[i-1] == 't' || a[i-1] == 'T') &amp;&amp;
                                 (a[i] == 'e' || a[i] == 'E'))
            {
<span class="fc" id="L284">                matchlen = 5;</span>
<span class="fc" id="L285">                mask |= WRITE;</span>

            } else {
                // parse error
<span class="nc" id="L289">                throw new IllegalArgumentException(</span>
                        &quot;invalid permission: &quot; + actions);
            }

            // make sure we didn't just match the tail of a word
            // like &quot;ackbarfaccept&quot;.  Also, skip to the comma.
<span class="fc" id="L295">            boolean seencomma = false;</span>
<span class="fc bfc" id="L296" title="All 4 branches covered.">            while (i &gt;= matchlen &amp;&amp; !seencomma) {</span>
<span class="pc bpc" id="L297" title="1 of 3 branches missed.">                switch(a[i-matchlen]) {</span>
                case ',':
<span class="fc" id="L299">                    seencomma = true;</span>
<span class="fc" id="L300">                    break;</span>
                case ' ': case '\r': case '\n':
                case '\f': case '\t':
<span class="fc" id="L303">                    break;</span>
                default:
<span class="nc" id="L305">                    throw new IllegalArgumentException(</span>
                            &quot;invalid permission: &quot; + actions);
                }
<span class="fc" id="L308">                i--;</span>
            }

            // point i at the location of the comma minus one (or -1).
<span class="fc" id="L312">            i -= matchlen;</span>
<span class="fc" id="L313">        }</span>

<span class="fc" id="L315">        return mask;</span>
    }


    /**
     * Return the canonical string representation of the actions.
     * Always returns present actions in the following order:
     * read, write.
     *
     * @return the canonical string representation of the actions.
     */
    static String getActions(int mask) {
<span class="fc" id="L327">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L328">        boolean comma = false;</span>

<span class="fc bfc" id="L330" title="All 2 branches covered.">        if ((mask &amp; READ) == READ) {</span>
<span class="fc" id="L331">            comma = true;</span>
<span class="fc" id="L332">            sb.append(&quot;read&quot;);</span>
        }

<span class="fc bfc" id="L335" title="All 2 branches covered.">        if ((mask &amp; WRITE) == WRITE) {</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">            if (comma) sb.append(',');</span>
<span class="fc" id="L337">            else comma = true;</span>
<span class="fc" id="L338">            sb.append(&quot;write&quot;);</span>
        }
<span class="fc" id="L340">        return sb.toString();</span>
    }

    /**
     * Returns the &quot;canonical string representation&quot; of the actions.
     * That is, this method always returns present actions in the following order:
     * read, write. For example, if this PropertyPermission object
     * allows both write and read actions, a call to &lt;code&gt;getActions&lt;/code&gt;
     * will return the string &quot;read,write&quot;.
     *
     * @return the canonical string representation of the actions.
     */
    public String getActions() {
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (actions == null)</span>
<span class="fc" id="L354">            actions = getActions(this.mask);</span>

<span class="fc" id="L356">        return actions;</span>
    }

    /**
     * Return the current action mask.
     * Used by the PropertyPermissionCollection
     *
     * @return the actions mask.
     */
    int getMask() {
<span class="fc" id="L366">        return mask;</span>
    }

    /**
     * Returns a new PermissionCollection object for storing
     * PropertyPermission objects.
     * &lt;p&gt;
     *
     * @return a new PermissionCollection object suitable for storing
     * PropertyPermissions.
     */
    public PermissionCollection newPermissionCollection() {
<span class="fc" id="L378">        return new PropertyPermissionCollection();</span>
    }


    private static final long serialVersionUID = 885438825399942851L;

    /**
     * WriteObject is called to save the state of the PropertyPermission
     * to a stream. The actions are serialized, and the superclass
     * takes care of the name.
     */
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException
    {
        // Write out the actions. The superclass takes care of the name
        // call getActions to make sure actions field is initialized
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (actions == null)</span>
<span class="nc" id="L395">            getActions();</span>
<span class="nc" id="L396">        s.defaultWriteObject();</span>
<span class="nc" id="L397">    }</span>

    /**
     * readObject is called to restore the state of the PropertyPermission from
     * a stream.
     */
    private synchronized void readObject(java.io.ObjectInputStream s)
         throws IOException, ClassNotFoundException
    {
        // Read in the action, then initialize the rest
<span class="nc" id="L407">        s.defaultReadObject();</span>
<span class="nc" id="L408">        init(getMask(actions));</span>
<span class="nc" id="L409">    }</span>
}

/**
 * A PropertyPermissionCollection stores a set of PropertyPermission
 * permissions.
 *
 * @see java.security.Permission
 * @see java.security.Permissions
 * @see java.security.PermissionCollection
 *
 *
 * @author Roland Schemers
 *
 * @serial include
 */
final class PropertyPermissionCollection extends PermissionCollection
    implements Serializable
{

    /**
     * Key is property name; value is PropertyPermission.
     * Not serialized; see serialization section at end of class.
     */
    private transient Map&lt;String, PropertyPermission&gt; perms;

    /**
     * Boolean saying if &quot;*&quot; is in the collection.
     *
     * @see #serialPersistentFields
     */
    // No sync access; OK for this to be stale.
    private boolean all_allowed;

    /**
     * Create an empty PropertyPermissionCollection object.
     */
<span class="fc" id="L446">    public PropertyPermissionCollection() {</span>
<span class="fc" id="L447">        perms = new HashMap&lt;&gt;(32);     // Capacity for default policy</span>
<span class="fc" id="L448">        all_allowed = false;</span>
<span class="fc" id="L449">    }</span>

    /**
     * Adds a permission to the PropertyPermissions. The key for the hash is
     * the name.
     *
     * @param permission the Permission object to add.
     *
     * @exception IllegalArgumentException - if the permission is not a
     *                                       PropertyPermission
     *
     * @exception SecurityException - if this PropertyPermissionCollection
     *                                object has been marked readonly
     */
    public void add(Permission permission) {
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (! (permission instanceof PropertyPermission))</span>
<span class="nc" id="L465">            throw new IllegalArgumentException(&quot;invalid permission: &quot;+</span>
                                               permission);
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (isReadOnly())</span>
<span class="nc" id="L468">            throw new SecurityException(</span>
                &quot;attempt to add a Permission to a readonly PermissionCollection&quot;);

<span class="fc" id="L471">        PropertyPermission pp = (PropertyPermission) permission;</span>
<span class="fc" id="L472">        String propName = pp.getName();</span>

<span class="fc" id="L474">        synchronized (this) {</span>
<span class="fc" id="L475">            PropertyPermission existing = perms.get(propName);</span>

<span class="fc bfc" id="L477" title="All 2 branches covered.">            if (existing != null) {</span>
<span class="fc" id="L478">                int oldMask = existing.getMask();</span>
<span class="fc" id="L479">                int newMask = pp.getMask();</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">                if (oldMask != newMask) {</span>
<span class="nc" id="L481">                    int effective = oldMask | newMask;</span>
<span class="nc" id="L482">                    String actions = PropertyPermission.getActions(effective);</span>
<span class="nc" id="L483">                    perms.put(propName, new PropertyPermission(propName, actions));</span>
                }
<span class="fc" id="L485">            } else {</span>
<span class="fc" id="L486">                perms.put(propName, pp);</span>
            }
<span class="pc" id="L488">        }</span>

<span class="fc bfc" id="L490" title="All 2 branches covered.">        if (!all_allowed) {</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">            if (propName.equals(&quot;*&quot;))</span>
<span class="fc" id="L492">                all_allowed = true;</span>
        }
<span class="fc" id="L494">    }</span>

    /**
     * Check and see if this set of permissions implies the permissions
     * expressed in &quot;permission&quot;.
     *
     * @param permission the Permission object to compare
     *
     * @return true if &quot;permission&quot; is a proper subset of a permission in
     * the set, false if not.
     */
    public boolean implies(Permission permission) {
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">        if (! (permission instanceof PropertyPermission))</span>
<span class="nc" id="L507">                return false;</span>

<span class="fc" id="L509">        PropertyPermission pp = (PropertyPermission) permission;</span>
        PropertyPermission x;

<span class="fc" id="L512">        int desired = pp.getMask();</span>
<span class="fc" id="L513">        int effective = 0;</span>

        // short circuit if the &quot;*&quot; Permission was added
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (all_allowed) {</span>
<span class="fc" id="L517">            synchronized (this) {</span>
<span class="fc" id="L518">                x = perms.get(&quot;*&quot;);</span>
<span class="pc" id="L519">            }</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">            if (x != null) {</span>
<span class="fc" id="L521">                effective |= x.getMask();</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">                if ((effective &amp; desired) == desired)</span>
<span class="fc" id="L523">                    return true;</span>
            }
        }

        // strategy:
        // Check for full match first. Then work our way up the
        // name looking for matches on a.b.*

<span class="fc" id="L531">        String name = pp.getName();</span>
        //System.out.println(&quot;check &quot;+name);

<span class="fc" id="L534">        synchronized (this) {</span>
<span class="fc" id="L535">            x = perms.get(name);</span>
<span class="pc" id="L536">        }</span>

<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (x != null) {</span>
            // we have a direct hit!
<span class="fc" id="L540">            effective |= x.getMask();</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">            if ((effective &amp; desired) == desired)</span>
<span class="fc" id="L542">                return true;</span>
        }

        // work our way up the tree...
        int last, offset;

<span class="fc" id="L548">        offset = name.length()-1;</span>

<span class="fc bfc" id="L550" title="All 2 branches covered.">        while ((last = name.lastIndexOf(&quot;.&quot;, offset)) != -1) {</span>

<span class="fc" id="L552">            name = name.substring(0, last+1) + &quot;*&quot;;</span>
            //System.out.println(&quot;check &quot;+name);
<span class="fc" id="L554">            synchronized (this) {</span>
<span class="fc" id="L555">                x = perms.get(name);</span>
<span class="pc" id="L556">            }</span>

<span class="pc bpc" id="L558" title="1 of 2 branches missed.">            if (x != null) {</span>
<span class="nc" id="L559">                effective |= x.getMask();</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                if ((effective &amp; desired) == desired)</span>
<span class="nc" id="L561">                    return true;</span>
            }
<span class="fc" id="L563">            offset = last -1;</span>
        }

        // we don't have to check for &quot;*&quot; as it was already checked
        // at the top (all_allowed), so we just return false
<span class="fc" id="L568">        return false;</span>
    }

    /**
     * Returns an enumeration of all the PropertyPermission objects in the
     * container.
     *
     * @return an enumeration of all the PropertyPermission objects.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Enumeration&lt;Permission&gt; elements() {
        // Convert Iterator of Map values into an Enumeration
<span class="fc" id="L580">        synchronized (this) {</span>
            /**
             * Casting to rawtype since Enumeration&lt;PropertyPermission&gt;
             * cannot be directly cast to Enumeration&lt;Permission&gt;
             */
<span class="fc" id="L585">            return (Enumeration)Collections.enumeration(perms.values());</span>
<span class="nc" id="L586">        }</span>
    }

    private static final long serialVersionUID = 7015263904581634791L;

    // Need to maintain serialization interoperability with earlier releases,
    // which had the serializable field:
    //
    // Table of permissions.
    //
    // @serial
    //
    // private Hashtable permissions;
    /**
     * @serialField permissions java.util.Hashtable
     *     A table of the PropertyPermissions.
     * @serialField all_allowed boolean
     *     boolean saying if &quot;*&quot; is in the collection.
     */
<span class="fc" id="L605">    private static final ObjectStreamField[] serialPersistentFields = {</span>
        new ObjectStreamField(&quot;permissions&quot;, Hashtable.class),
        new ObjectStreamField(&quot;all_allowed&quot;, Boolean.TYPE),
    };

    /**
     * @serialData Default fields.
     */
    /*
     * Writes the contents of the perms field out as a Hashtable for
     * serialization compatibility with earlier releases. all_allowed
     * unchanged.
     */
    private void writeObject(ObjectOutputStream out) throws IOException {
        // Don't call out.defaultWriteObject()

        // Copy perms into a Hashtable
<span class="nc" id="L622">        Hashtable&lt;String, Permission&gt; permissions =</span>
<span class="nc" id="L623">            new Hashtable&lt;&gt;(perms.size()*2);</span>
<span class="nc" id="L624">        synchronized (this) {</span>
<span class="nc" id="L625">            permissions.putAll(perms);</span>
<span class="nc" id="L626">        }</span>

        // Write out serializable fields
<span class="nc" id="L629">        ObjectOutputStream.PutField pfields = out.putFields();</span>
<span class="nc" id="L630">        pfields.put(&quot;all_allowed&quot;, all_allowed);</span>
<span class="nc" id="L631">        pfields.put(&quot;permissions&quot;, permissions);</span>
<span class="nc" id="L632">        out.writeFields();</span>
<span class="nc" id="L633">    }</span>

    /*
     * Reads in a Hashtable of PropertyPermissions and saves them in the
     * perms field. Reads in all_allowed.
     */
    private void readObject(ObjectInputStream in)
        throws IOException, ClassNotFoundException
    {
        // Don't call defaultReadObject()

        // Read in serialized fields
<span class="nc" id="L645">        ObjectInputStream.GetField gfields = in.readFields();</span>

        // Get all_allowed
<span class="nc" id="L648">        all_allowed = gfields.get(&quot;all_allowed&quot;, false);</span>

        // Get permissions
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L652">        Hashtable&lt;String, PropertyPermission&gt; permissions =</span>
<span class="nc" id="L653">            (Hashtable&lt;String, PropertyPermission&gt;)gfields.get(&quot;permissions&quot;, null);</span>
<span class="nc" id="L654">        perms = new HashMap&lt;&gt;(permissions.size()*2);</span>
<span class="nc" id="L655">        perms.putAll(permissions);</span>
<span class="nc" id="L656">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>