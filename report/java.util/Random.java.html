<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Random.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">Random.java</span></div><h1>Random.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;
import java.io.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.DoubleConsumer;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.StreamSupport;

import sun.misc.Unsafe;

/**
 * An instance of this class is used to generate a stream of
 * pseudorandom numbers. The class uses a 48-bit seed, which is
 * modified using a linear congruential formula. (See Donald Knuth,
 * &lt;i&gt;The Art of Computer Programming, Volume 2&lt;/i&gt;, Section 3.2.1.)
 * &lt;p&gt;
 * If two instances of {@code Random} are created with the same
 * seed, and the same sequence of method calls is made for each, they
 * will generate and return identical sequences of numbers. In order to
 * guarantee this property, particular algorithms are specified for the
 * class {@code Random}. Java implementations must use all the algorithms
 * shown here for the class {@code Random}, for the sake of absolute
 * portability of Java code. However, subclasses of class {@code Random}
 * are permitted to use other algorithms, so long as they adhere to the
 * general contracts for all the methods.
 * &lt;p&gt;
 * The algorithms implemented by class {@code Random} use a
 * {@code protected} utility method that on each invocation can supply
 * up to 32 pseudorandomly generated bits.
 * &lt;p&gt;
 * Many applications will find the method {@link Math#random} simpler to use.
 *
 * &lt;p&gt;Instances of {@code java.util.Random} are threadsafe.
 * However, the concurrent use of the same {@code java.util.Random}
 * instance across threads may encounter contention and consequent
 * poor performance. Consider instead using
 * {@link java.util.concurrent.ThreadLocalRandom} in multithreaded
 * designs.
 *
 * &lt;p&gt;Instances of {@code java.util.Random} are not cryptographically
 * secure.  Consider instead using {@link java.security.SecureRandom} to
 * get a cryptographically secure pseudo-random number generator for use
 * by security-sensitive applications.
 *
 * @author  Frank Yellin
 * @since   1.0
 */
public
class Random implements java.io.Serializable {
    /** use serialVersionUID from JDK 1.1 for interoperability */
    static final long serialVersionUID = 3905348978240129619L;

    /**
     * The internal state associated with this pseudorandom number generator.
     * (The specs for the methods in this class describe the ongoing
     * computation of this value.)
     */
    private final AtomicLong seed;

    private static final long multiplier = 0x5DEECE66DL;
    private static final long addend = 0xBL;
    private static final long mask = (1L &lt;&lt; 48) - 1;

    private static final double DOUBLE_UNIT = 0x1.0p-53; // 1.0 / (1L &lt;&lt; 53)

    // IllegalArgumentException messages
    static final String BadBound = &quot;bound must be positive&quot;;
    static final String BadRange = &quot;bound must be greater than origin&quot;;
    static final String BadSize  = &quot;size must be non-negative&quot;;

    /**
     * Creates a new random number generator. This constructor sets
     * the seed of the random number generator to a value very likely
     * to be distinct from any other invocation of this constructor.
     */
    public Random() {
<span class="nc" id="L105">        this(seedUniquifier() ^ System.nanoTime());</span>
<span class="nc" id="L106">    }</span>

    private static long seedUniquifier() {
        // L'Ecuyer, &quot;Tables of Linear Congruential Generators of
        // Different Sizes and Good Lattice Structure&quot;, 1999
        for (;;) {
<span class="nc" id="L112">            long current = seedUniquifier.get();</span>
<span class="nc" id="L113">            long next = current * 181783497276652981L;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">            if (seedUniquifier.compareAndSet(current, next))</span>
<span class="nc" id="L115">                return next;</span>
<span class="nc" id="L116">        }</span>
    }

<span class="nc" id="L119">    private static final AtomicLong seedUniquifier</span>
        = new AtomicLong(8682522807148012L);

    /**
     * Creates a new random number generator using a single {@code long} seed.
     * The seed is the initial value of the internal state of the pseudorandom
     * number generator which is maintained by method {@link #next}.
     *
     * &lt;p&gt;The invocation {@code new Random(seed)} is equivalent to:
     *  &lt;pre&gt; {@code
     * Random rnd = new Random();
     * rnd.setSeed(seed);}&lt;/pre&gt;
     *
     * @param seed the initial seed
     * @see   #setSeed(long)
     */
<span class="nc" id="L135">    public Random(long seed) {</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (getClass() == Random.class)</span>
<span class="nc" id="L137">            this.seed = new AtomicLong(initialScramble(seed));</span>
        else {
            // subclass might have overriden setSeed
<span class="nc" id="L140">            this.seed = new AtomicLong();</span>
<span class="nc" id="L141">            setSeed(seed);</span>
        }
<span class="nc" id="L143">    }</span>

    private static long initialScramble(long seed) {
<span class="nc" id="L146">        return (seed ^ multiplier) &amp; mask;</span>
    }

    /**
     * Sets the seed of this random number generator using a single
     * {@code long} seed. The general contract of {@code setSeed} is
     * that it alters the state of this random number generator object
     * so as to be in exactly the same state as if it had just been
     * created with the argument {@code seed} as a seed. The method
     * {@code setSeed} is implemented by class {@code Random} by
     * atomically updating the seed to
     *  &lt;pre&gt;{@code (seed ^ 0x5DEECE66DL) &amp; ((1L &lt;&lt; 48) - 1)}&lt;/pre&gt;
     * and clearing the {@code haveNextNextGaussian} flag used by {@link
     * #nextGaussian}.
     *
     * &lt;p&gt;The implementation of {@code setSeed} by class {@code Random}
     * happens to use only 48 bits of the given seed. In general, however,
     * an overriding method may use all 64 bits of the {@code long}
     * argument as a seed value.
     *
     * @param seed the initial seed
     */
    synchronized public void setSeed(long seed) {
<span class="nc" id="L169">        this.seed.set(initialScramble(seed));</span>
<span class="nc" id="L170">        haveNextNextGaussian = false;</span>
<span class="nc" id="L171">    }</span>

    /**
     * Generates the next pseudorandom number. Subclasses should
     * override this, as this is used by all other methods.
     *
     * &lt;p&gt;The general contract of {@code next} is that it returns an
     * {@code int} value and if the argument {@code bits} is between
     * {@code 1} and {@code 32} (inclusive), then that many low-order
     * bits of the returned value will be (approximately) independently
     * chosen bit values, each of which is (approximately) equally
     * likely to be {@code 0} or {@code 1}. The method {@code next} is
     * implemented by class {@code Random} by atomically updating the seed to
     *  &lt;pre&gt;{@code (seed * 0x5DEECE66DL + 0xBL) &amp; ((1L &lt;&lt; 48) - 1)}&lt;/pre&gt;
     * and returning
     *  &lt;pre&gt;{@code (int)(seed &gt;&gt;&gt; (48 - bits))}.&lt;/pre&gt;
     *
     * This is a linear congruential pseudorandom number generator, as
     * defined by D. H. Lehmer and described by Donald E. Knuth in
     * &lt;i&gt;The Art of Computer Programming,&lt;/i&gt; Volume 3:
     * &lt;i&gt;Seminumerical Algorithms&lt;/i&gt;, section 3.2.1.
     *
     * @param  bits random bits
     * @return the next pseudorandom value from this random number
     *         generator's sequence
     * @since  1.1
     */
    protected int next(int bits) {
        long oldseed, nextseed;
<span class="nc" id="L200">        AtomicLong seed = this.seed;</span>
        do {
<span class="nc" id="L202">            oldseed = seed.get();</span>
<span class="nc" id="L203">            nextseed = (oldseed * multiplier + addend) &amp; mask;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        } while (!seed.compareAndSet(oldseed, nextseed));</span>
<span class="nc" id="L205">        return (int)(nextseed &gt;&gt;&gt; (48 - bits));</span>
    }

    /**
     * Generates random bytes and places them into a user-supplied
     * byte array.  The number of random bytes produced is equal to
     * the length of the byte array.
     *
     * &lt;p&gt;The method {@code nextBytes} is implemented by class {@code Random}
     * as if by:
     *  &lt;pre&gt; {@code
     * public void nextBytes(byte[] bytes) {
     *   for (int i = 0; i &lt; bytes.length; )
     *     for (int rnd = nextInt(), n = Math.min(bytes.length - i, 4);
     *          n-- &gt; 0; rnd &gt;&gt;= 8)
     *       bytes[i++] = (byte)rnd;
     * }}&lt;/pre&gt;
     *
     * @param  bytes the byte array to fill with random bytes
     * @throws NullPointerException if the byte array is null
     * @since  1.1
     */
    public void nextBytes(byte[] bytes) {
<span class="nc bnc" id="L228" title="All 2 branches missed.">        for (int i = 0, len = bytes.length; i &lt; len; )</span>
<span class="nc" id="L229">            for (int rnd = nextInt(),</span>
<span class="nc" id="L230">                     n = Math.min(len - i, Integer.SIZE/Byte.SIZE);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">                 n-- &gt; 0; rnd &gt;&gt;= Byte.SIZE)</span>
<span class="nc" id="L232">                bytes[i++] = (byte)rnd;</span>
<span class="nc" id="L233">    }</span>

    /**
     * The form of nextLong used by LongStream Spliterators.  If
     * origin is greater than bound, acts as unbounded form of
     * nextLong, else as bounded form.
     *
     * @param origin the least value, unless greater than bound
     * @param bound the upper bound (exclusive), must not equal origin
     * @return a pseudorandom value
     */
    final long internalNextLong(long origin, long bound) {
<span class="nc" id="L245">        long r = nextLong();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (origin &lt; bound) {</span>
<span class="nc" id="L247">            long n = bound - origin, m = n - 1;</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            if ((n &amp; m) == 0L)  // power of two</span>
<span class="nc" id="L249">                r = (r &amp; m) + origin;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            else if (n &gt; 0L) {  // reject over-represented candidates</span>
<span class="nc" id="L251">                for (long u = r &gt;&gt;&gt; 1;            // ensure nonnegative</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                     u + m - (r = u % n) &lt; 0L;    // rejection check</span>
<span class="nc" id="L253">                     u = nextLong() &gt;&gt;&gt; 1) // retry</span>
                    ;
<span class="nc" id="L255">                r += origin;</span>
            }
            else {              // range not representable as long
<span class="nc bnc" id="L258" title="All 4 branches missed.">                while (r &lt; origin || r &gt;= bound)</span>
<span class="nc" id="L259">                    r = nextLong();</span>
            }
        }
<span class="nc" id="L262">        return r;</span>
    }

    /**
     * The form of nextInt used by IntStream Spliterators.
     * For the unbounded case: uses nextInt().
     * For the bounded case with representable range: uses nextInt(int bound)
     * For the bounded case with unrepresentable range: uses nextInt()
     *
     * @param origin the least value, unless greater than bound
     * @param bound the upper bound (exclusive), must not equal origin
     * @return a pseudorandom value
     */
    final int internalNextInt(int origin, int bound) {
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (origin &lt; bound) {</span>
<span class="nc" id="L277">            int n = bound - origin;</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (n &gt; 0) {</span>
<span class="nc" id="L279">                return nextInt(n) + origin;</span>
            }
            else {  // range not representable as int
                int r;
                do {
<span class="nc" id="L284">                    r = nextInt();</span>
<span class="nc bnc" id="L285" title="All 4 branches missed.">                } while (r &lt; origin || r &gt;= bound);</span>
<span class="nc" id="L286">                return r;</span>
            }
        }
        else {
<span class="nc" id="L290">            return nextInt();</span>
        }
    }

    /**
     * The form of nextDouble used by DoubleStream Spliterators.
     *
     * @param origin the least value, unless greater than bound
     * @param bound the upper bound (exclusive), must not equal origin
     * @return a pseudorandom value
     */
    final double internalNextDouble(double origin, double bound) {
<span class="nc" id="L302">        double r = nextDouble();</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (origin &lt; bound) {</span>
<span class="nc" id="L304">            r = r * (bound - origin) + origin;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            if (r &gt;= bound) // correct for rounding</span>
<span class="nc" id="L306">                r = Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1);</span>
        }
<span class="nc" id="L308">        return r;</span>
    }

    /**
     * Returns the next pseudorandom, uniformly distributed {@code int}
     * value from this random number generator's sequence. The general
     * contract of {@code nextInt} is that one {@code int} value is
     * pseudorandomly generated and returned. All 2&lt;sup&gt;32&lt;/sup&gt; possible
     * {@code int} values are produced with (approximately) equal probability.
     *
     * &lt;p&gt;The method {@code nextInt} is implemented by class {@code Random}
     * as if by:
     *  &lt;pre&gt; {@code
     * public int nextInt() {
     *   return next(32);
     * }}&lt;/pre&gt;
     *
     * @return the next pseudorandom, uniformly distributed {@code int}
     *         value from this random number generator's sequence
     */
    public int nextInt() {
<span class="nc" id="L329">        return next(32);</span>
    }

    /**
     * Returns a pseudorandom, uniformly distributed {@code int} value
     * between 0 (inclusive) and the specified value (exclusive), drawn from
     * this random number generator's sequence.  The general contract of
     * {@code nextInt} is that one {@code int} value in the specified range
     * is pseudorandomly generated and returned.  All {@code bound} possible
     * {@code int} values are produced with (approximately) equal
     * probability.  The method {@code nextInt(int bound)} is implemented by
     * class {@code Random} as if by:
     *  &lt;pre&gt; {@code
     * public int nextInt(int bound) {
     *   if (bound &lt;= 0)
     *     throw new IllegalArgumentException(&quot;bound must be positive&quot;);
     *
     *   if ((bound &amp; -bound) == bound)  // i.e., bound is a power of 2
     *     return (int)((bound * (long)next(31)) &gt;&gt; 31);
     *
     *   int bits, val;
     *   do {
     *       bits = next(31);
     *       val = bits % bound;
     *   } while (bits - val + (bound-1) &lt; 0);
     *   return val;
     * }}&lt;/pre&gt;
     *
     * &lt;p&gt;The hedge &quot;approximately&quot; is used in the foregoing description only
     * because the next method is only approximately an unbiased source of
     * independently chosen bits.  If it were a perfect source of randomly
     * chosen bits, then the algorithm shown would choose {@code int}
     * values from the stated range with perfect uniformity.
     * &lt;p&gt;
     * The algorithm is slightly tricky.  It rejects values that would result
     * in an uneven distribution (due to the fact that 2^31 is not divisible
     * by n). The probability of a value being rejected depends on n.  The
     * worst case is n=2^30+1, for which the probability of a reject is 1/2,
     * and the expected number of iterations before the loop terminates is 2.
     * &lt;p&gt;
     * The algorithm treats the case where n is a power of two specially: it
     * returns the correct number of high-order bits from the underlying
     * pseudo-random number generator.  In the absence of special treatment,
     * the correct number of &lt;i&gt;low-order&lt;/i&gt; bits would be returned.  Linear
     * congruential pseudo-random number generators such as the one
     * implemented by this class are known to have short periods in the
     * sequence of values of their low-order bits.  Thus, this special case
     * greatly increases the length of the sequence of values returned by
     * successive calls to this method if n is a small power of two.
     *
     * @param bound the upper bound (exclusive).  Must be positive.
     * @return the next pseudorandom, uniformly distributed {@code int}
     *         value between zero (inclusive) and {@code bound} (exclusive)
     *         from this random number generator's sequence
     * @throws IllegalArgumentException if bound is not positive
     * @since 1.2
     */
    public int nextInt(int bound) {
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (bound &lt;= 0)</span>
<span class="nc" id="L388">            throw new IllegalArgumentException(BadBound);</span>

<span class="nc" id="L390">        int r = next(31);</span>
<span class="nc" id="L391">        int m = bound - 1;</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if ((bound &amp; m) == 0)  // i.e., bound is a power of 2</span>
<span class="nc" id="L393">            r = (int)((bound * (long)r) &gt;&gt; 31);</span>
        else {
<span class="nc" id="L395">            for (int u = r;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">                 u - (r = u % bound) + m &lt; 0;</span>
<span class="nc" id="L397">                 u = next(31))</span>
                ;
        }
<span class="nc" id="L400">        return r;</span>
    }

    /**
     * Returns the next pseudorandom, uniformly distributed {@code long}
     * value from this random number generator's sequence. The general
     * contract of {@code nextLong} is that one {@code long} value is
     * pseudorandomly generated and returned.
     *
     * &lt;p&gt;The method {@code nextLong} is implemented by class {@code Random}
     * as if by:
     *  &lt;pre&gt; {@code
     * public long nextLong() {
     *   return ((long)next(32) &lt;&lt; 32) + next(32);
     * }}&lt;/pre&gt;
     *
     * Because class {@code Random} uses a seed with only 48 bits,
     * this algorithm will not return all possible {@code long} values.
     *
     * @return the next pseudorandom, uniformly distributed {@code long}
     *         value from this random number generator's sequence
     */
    public long nextLong() {
        // it's okay that the bottom word remains signed.
<span class="nc" id="L424">        return ((long)(next(32)) &lt;&lt; 32) + next(32);</span>
    }

    /**
     * Returns the next pseudorandom, uniformly distributed
     * {@code boolean} value from this random number generator's
     * sequence. The general contract of {@code nextBoolean} is that one
     * {@code boolean} value is pseudorandomly generated and returned.  The
     * values {@code true} and {@code false} are produced with
     * (approximately) equal probability.
     *
     * &lt;p&gt;The method {@code nextBoolean} is implemented by class {@code Random}
     * as if by:
     *  &lt;pre&gt; {@code
     * public boolean nextBoolean() {
     *   return next(1) != 0;
     * }}&lt;/pre&gt;
     *
     * @return the next pseudorandom, uniformly distributed
     *         {@code boolean} value from this random number generator's
     *         sequence
     * @since 1.2
     */
    public boolean nextBoolean() {
<span class="nc bnc" id="L448" title="All 2 branches missed.">        return next(1) != 0;</span>
    }

    /**
     * Returns the next pseudorandom, uniformly distributed {@code float}
     * value between {@code 0.0} and {@code 1.0} from this random
     * number generator's sequence.
     *
     * &lt;p&gt;The general contract of {@code nextFloat} is that one
     * {@code float} value, chosen (approximately) uniformly from the
     * range {@code 0.0f} (inclusive) to {@code 1.0f} (exclusive), is
     * pseudorandomly generated and returned. All 2&lt;sup&gt;24&lt;/sup&gt; possible
     * {@code float} values of the form &lt;i&gt;m&amp;nbsp;x&amp;nbsp;&lt;/i&gt;2&lt;sup&gt;-24&lt;/sup&gt;,
     * where &lt;i&gt;m&lt;/i&gt; is a positive integer less than 2&lt;sup&gt;24&lt;/sup&gt;, are
     * produced with (approximately) equal probability.
     *
     * &lt;p&gt;The method {@code nextFloat} is implemented by class {@code Random}
     * as if by:
     *  &lt;pre&gt; {@code
     * public float nextFloat() {
     *   return next(24) / ((float)(1 &lt;&lt; 24));
     * }}&lt;/pre&gt;
     *
     * &lt;p&gt;The hedge &quot;approximately&quot; is used in the foregoing description only
     * because the next method is only approximately an unbiased source of
     * independently chosen bits. If it were a perfect source of randomly
     * chosen bits, then the algorithm shown would choose {@code float}
     * values from the stated range with perfect uniformity.&lt;p&gt;
     * [In early versions of Java, the result was incorrectly calculated as:
     *  &lt;pre&gt; {@code
     *   return next(30) / ((float)(1 &lt;&lt; 30));}&lt;/pre&gt;
     * This might seem to be equivalent, if not better, but in fact it
     * introduced a slight nonuniformity because of the bias in the rounding
     * of floating-point numbers: it was slightly more likely that the
     * low-order bit of the significand would be 0 than that it would be 1.]
     *
     * @return the next pseudorandom, uniformly distributed {@code float}
     *         value between {@code 0.0} and {@code 1.0} from this
     *         random number generator's sequence
     */
    public float nextFloat() {
<span class="nc" id="L489">        return next(24) / ((float)(1 &lt;&lt; 24));</span>
    }

    /**
     * Returns the next pseudorandom, uniformly distributed
     * {@code double} value between {@code 0.0} and
     * {@code 1.0} from this random number generator's sequence.
     *
     * &lt;p&gt;The general contract of {@code nextDouble} is that one
     * {@code double} value, chosen (approximately) uniformly from the
     * range {@code 0.0d} (inclusive) to {@code 1.0d} (exclusive), is
     * pseudorandomly generated and returned.
     *
     * &lt;p&gt;The method {@code nextDouble} is implemented by class {@code Random}
     * as if by:
     *  &lt;pre&gt; {@code
     * public double nextDouble() {
     *   return (((long)next(26) &lt;&lt; 27) + next(27))
     *     / (double)(1L &lt;&lt; 53);
     * }}&lt;/pre&gt;
     *
     * &lt;p&gt;The hedge &quot;approximately&quot; is used in the foregoing description only
     * because the {@code next} method is only approximately an unbiased
     * source of independently chosen bits. If it were a perfect source of
     * randomly chosen bits, then the algorithm shown would choose
     * {@code double} values from the stated range with perfect uniformity.
     * &lt;p&gt;[In early versions of Java, the result was incorrectly calculated as:
     *  &lt;pre&gt; {@code
     *   return (((long)next(27) &lt;&lt; 27) + next(27))
     *     / (double)(1L &lt;&lt; 54);}&lt;/pre&gt;
     * This might seem to be equivalent, if not better, but in fact it
     * introduced a large nonuniformity because of the bias in the rounding
     * of floating-point numbers: it was three times as likely that the
     * low-order bit of the significand would be 0 than that it would be 1!
     * This nonuniformity probably doesn't matter much in practice, but we
     * strive for perfection.]
     *
     * @return the next pseudorandom, uniformly distributed {@code double}
     *         value between {@code 0.0} and {@code 1.0} from this
     *         random number generator's sequence
     * @see Math#random
     */
    public double nextDouble() {
<span class="nc" id="L532">        return (((long)(next(26)) &lt;&lt; 27) + next(27)) * DOUBLE_UNIT;</span>
    }

    private double nextNextGaussian;
<span class="nc" id="L536">    private boolean haveNextNextGaussian = false;</span>

    /**
     * Returns the next pseudorandom, Gaussian (&quot;normally&quot;) distributed
     * {@code double} value with mean {@code 0.0} and standard
     * deviation {@code 1.0} from this random number generator's sequence.
     * &lt;p&gt;
     * The general contract of {@code nextGaussian} is that one
     * {@code double} value, chosen from (approximately) the usual
     * normal distribution with mean {@code 0.0} and standard deviation
     * {@code 1.0}, is pseudorandomly generated and returned.
     *
     * &lt;p&gt;The method {@code nextGaussian} is implemented by class
     * {@code Random} as if by a threadsafe version of the following:
     *  &lt;pre&gt; {@code
     * private double nextNextGaussian;
     * private boolean haveNextNextGaussian = false;
     *
     * public double nextGaussian() {
     *   if (haveNextNextGaussian) {
     *     haveNextNextGaussian = false;
     *     return nextNextGaussian;
     *   } else {
     *     double v1, v2, s;
     *     do {
     *       v1 = 2 * nextDouble() - 1;   // between -1.0 and 1.0
     *       v2 = 2 * nextDouble() - 1;   // between -1.0 and 1.0
     *       s = v1 * v1 + v2 * v2;
     *     } while (s &gt;= 1 || s == 0);
     *     double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);
     *     nextNextGaussian = v2 * multiplier;
     *     haveNextNextGaussian = true;
     *     return v1 * multiplier;
     *   }
     * }}&lt;/pre&gt;
     * This uses the &lt;i&gt;polar method&lt;/i&gt; of G. E. P. Box, M. E. Muller, and
     * G. Marsaglia, as described by Donald E. Knuth in &lt;i&gt;The Art of
     * Computer Programming&lt;/i&gt;, Volume 3: &lt;i&gt;Seminumerical Algorithms&lt;/i&gt;,
     * section 3.4.1, subsection C, algorithm P. Note that it generates two
     * independent values at the cost of only one call to {@code StrictMath.log}
     * and one call to {@code StrictMath.sqrt}.
     *
     * @return the next pseudorandom, Gaussian (&quot;normally&quot;) distributed
     *         {@code double} value with mean {@code 0.0} and
     *         standard deviation {@code 1.0} from this random number
     *         generator's sequence
     */
    synchronized public double nextGaussian() {
        // See Knuth, ACP, Section 3.4.1 Algorithm C.
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (haveNextNextGaussian) {</span>
<span class="nc" id="L586">            haveNextNextGaussian = false;</span>
<span class="nc" id="L587">            return nextNextGaussian;</span>
        } else {
            double v1, v2, s;
            do {
<span class="nc" id="L591">                v1 = 2 * nextDouble() - 1; // between -1 and 1</span>
<span class="nc" id="L592">                v2 = 2 * nextDouble() - 1; // between -1 and 1</span>
<span class="nc" id="L593">                s = v1 * v1 + v2 * v2;</span>
<span class="nc bnc" id="L594" title="All 4 branches missed.">            } while (s &gt;= 1 || s == 0);</span>
<span class="nc" id="L595">            double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);</span>
<span class="nc" id="L596">            nextNextGaussian = v2 * multiplier;</span>
<span class="nc" id="L597">            haveNextNextGaussian = true;</span>
<span class="nc" id="L598">            return v1 * multiplier;</span>
        }
    }

    // stream methods, coded in a way intended to better isolate for
    // maintenance purposes the small differences across forms.

    /**
     * Returns a stream producing the given {@code streamSize} number of
     * pseudorandom {@code int} values.
     *
     * &lt;p&gt;A pseudorandom {@code int} value is generated as if it's the result of
     * calling the method {@link #nextInt()}.
     *
     * @param streamSize the number of values to generate
     * @return a stream of pseudorandom {@code int} values
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero
     * @since 1.8
     */
    public IntStream ints(long streamSize) {
<span class="nc bnc" id="L619" title="All 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L620">            throw new IllegalArgumentException(BadSize);</span>
<span class="nc" id="L621">        return StreamSupport.intStream</span>
<span class="nc" id="L622">                (new RandomIntsSpliterator</span>
                         (this, 0L, streamSize, Integer.MAX_VALUE, 0),
                 false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code int}
     * values.
     *
     * &lt;p&gt;A pseudorandom {@code int} value is generated as if it's the result of
     * calling the method {@link #nextInt()}.
     *
     * @implNote This method is implemented to be equivalent to {@code
     * ints(Long.MAX_VALUE)}.
     *
     * @return a stream of pseudorandom {@code int} values
     * @since 1.8
     */
    public IntStream ints() {
<span class="nc" id="L641">        return StreamSupport.intStream</span>
<span class="nc" id="L642">                (new RandomIntsSpliterator</span>
                         (this, 0L, Long.MAX_VALUE, Integer.MAX_VALUE, 0),
                 false);
    }

    /**
     * Returns a stream producing the given {@code streamSize} number
     * of pseudorandom {@code int} values, each conforming to the given
     * origin (inclusive) and bound (exclusive).
     *
     * &lt;p&gt;A pseudorandom {@code int} value is generated as if it's the result of
     * calling the following method with the origin and bound:
     * &lt;pre&gt; {@code
     * int nextInt(int origin, int bound) {
     *   int n = bound - origin;
     *   if (n &gt; 0) {
     *     return nextInt(n) + origin;
     *   }
     *   else {  // range not representable as int
     *     int r;
     *     do {
     *       r = nextInt();
     *     } while (r &lt; origin || r &gt;= bound);
     *     return r;
     *   }
     * }}&lt;/pre&gt;
     *
     * @param streamSize the number of values to generate
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code int} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero, or {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     * @since 1.8
     */
    public IntStream ints(long streamSize, int randomNumberOrigin,
                          int randomNumberBound) {
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L682">            throw new IllegalArgumentException(BadSize);</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if (randomNumberOrigin &gt;= randomNumberBound)</span>
<span class="nc" id="L684">            throw new IllegalArgumentException(BadRange);</span>
<span class="nc" id="L685">        return StreamSupport.intStream</span>
<span class="nc" id="L686">                (new RandomIntsSpliterator</span>
                         (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),
                 false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code
     * int} values, each conforming to the given origin (inclusive) and bound
     * (exclusive).
     *
     * &lt;p&gt;A pseudorandom {@code int} value is generated as if it's the result of
     * calling the following method with the origin and bound:
     * &lt;pre&gt; {@code
     * int nextInt(int origin, int bound) {
     *   int n = bound - origin;
     *   if (n &gt; 0) {
     *     return nextInt(n) + origin;
     *   }
     *   else {  // range not representable as int
     *     int r;
     *     do {
     *       r = nextInt();
     *     } while (r &lt; origin || r &gt;= bound);
     *     return r;
     *   }
     * }}&lt;/pre&gt;
     *
     * @implNote This method is implemented to be equivalent to {@code
     * ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
     *
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code int} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     * @since 1.8
     */
    public IntStream ints(int randomNumberOrigin, int randomNumberBound) {
<span class="nc bnc" id="L725" title="All 2 branches missed.">        if (randomNumberOrigin &gt;= randomNumberBound)</span>
<span class="nc" id="L726">            throw new IllegalArgumentException(BadRange);</span>
<span class="nc" id="L727">        return StreamSupport.intStream</span>
<span class="nc" id="L728">                (new RandomIntsSpliterator</span>
                         (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),
                 false);
    }

    /**
     * Returns a stream producing the given {@code streamSize} number of
     * pseudorandom {@code long} values.
     *
     * &lt;p&gt;A pseudorandom {@code long} value is generated as if it's the result
     * of calling the method {@link #nextLong()}.
     *
     * @param streamSize the number of values to generate
     * @return a stream of pseudorandom {@code long} values
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero
     * @since 1.8
     */
    public LongStream longs(long streamSize) {
<span class="nc bnc" id="L747" title="All 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L748">            throw new IllegalArgumentException(BadSize);</span>
<span class="nc" id="L749">        return StreamSupport.longStream</span>
<span class="nc" id="L750">                (new RandomLongsSpliterator</span>
                         (this, 0L, streamSize, Long.MAX_VALUE, 0L),
                 false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code long}
     * values.
     *
     * &lt;p&gt;A pseudorandom {@code long} value is generated as if it's the result
     * of calling the method {@link #nextLong()}.
     *
     * @implNote This method is implemented to be equivalent to {@code
     * longs(Long.MAX_VALUE)}.
     *
     * @return a stream of pseudorandom {@code long} values
     * @since 1.8
     */
    public LongStream longs() {
<span class="nc" id="L769">        return StreamSupport.longStream</span>
<span class="nc" id="L770">                (new RandomLongsSpliterator</span>
                         (this, 0L, Long.MAX_VALUE, Long.MAX_VALUE, 0L),
                 false);
    }

    /**
     * Returns a stream producing the given {@code streamSize} number of
     * pseudorandom {@code long}, each conforming to the given origin
     * (inclusive) and bound (exclusive).
     *
     * &lt;p&gt;A pseudorandom {@code long} value is generated as if it's the result
     * of calling the following method with the origin and bound:
     * &lt;pre&gt; {@code
     * long nextLong(long origin, long bound) {
     *   long r = nextLong();
     *   long n = bound - origin, m = n - 1;
     *   if ((n &amp; m) == 0L)  // power of two
     *     r = (r &amp; m) + origin;
     *   else if (n &gt; 0L) {  // reject over-represented candidates
     *     for (long u = r &gt;&gt;&gt; 1;            // ensure nonnegative
     *          u + m - (r = u % n) &lt; 0L;    // rejection check
     *          u = nextLong() &gt;&gt;&gt; 1) // retry
     *         ;
     *     r += origin;
     *   }
     *   else {              // range not representable as long
     *     while (r &lt; origin || r &gt;= bound)
     *       r = nextLong();
     *   }
     *   return r;
     * }}&lt;/pre&gt;
     *
     * @param streamSize the number of values to generate
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code long} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero, or {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     * @since 1.8
     */
    public LongStream longs(long streamSize, long randomNumberOrigin,
                            long randomNumberBound) {
<span class="nc bnc" id="L814" title="All 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L815">            throw new IllegalArgumentException(BadSize);</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">        if (randomNumberOrigin &gt;= randomNumberBound)</span>
<span class="nc" id="L817">            throw new IllegalArgumentException(BadRange);</span>
<span class="nc" id="L818">        return StreamSupport.longStream</span>
<span class="nc" id="L819">                (new RandomLongsSpliterator</span>
                         (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),
                 false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code
     * long} values, each conforming to the given origin (inclusive) and bound
     * (exclusive).
     *
     * &lt;p&gt;A pseudorandom {@code long} value is generated as if it's the result
     * of calling the following method with the origin and bound:
     * &lt;pre&gt; {@code
     * long nextLong(long origin, long bound) {
     *   long r = nextLong();
     *   long n = bound - origin, m = n - 1;
     *   if ((n &amp; m) == 0L)  // power of two
     *     r = (r &amp; m) + origin;
     *   else if (n &gt; 0L) {  // reject over-represented candidates
     *     for (long u = r &gt;&gt;&gt; 1;            // ensure nonnegative
     *          u + m - (r = u % n) &lt; 0L;    // rejection check
     *          u = nextLong() &gt;&gt;&gt; 1) // retry
     *         ;
     *     r += origin;
     *   }
     *   else {              // range not representable as long
     *     while (r &lt; origin || r &gt;= bound)
     *       r = nextLong();
     *   }
     *   return r;
     * }}&lt;/pre&gt;
     *
     * @implNote This method is implemented to be equivalent to {@code
     * longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
     *
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code long} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     * @since 1.8
     */
    public LongStream longs(long randomNumberOrigin, long randomNumberBound) {
<span class="nc bnc" id="L863" title="All 2 branches missed.">        if (randomNumberOrigin &gt;= randomNumberBound)</span>
<span class="nc" id="L864">            throw new IllegalArgumentException(BadRange);</span>
<span class="nc" id="L865">        return StreamSupport.longStream</span>
<span class="nc" id="L866">                (new RandomLongsSpliterator</span>
                         (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),
                 false);
    }

    /**
     * Returns a stream producing the given {@code streamSize} number of
     * pseudorandom {@code double} values, each between zero
     * (inclusive) and one (exclusive).
     *
     * &lt;p&gt;A pseudorandom {@code double} value is generated as if it's the result
     * of calling the method {@link #nextDouble()}}.
     *
     * @param streamSize the number of values to generate
     * @return a stream of {@code double} values
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero
     * @since 1.8
     */
    public DoubleStream doubles(long streamSize) {
<span class="nc bnc" id="L886" title="All 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L887">            throw new IllegalArgumentException(BadSize);</span>
<span class="nc" id="L888">        return StreamSupport.doubleStream</span>
<span class="nc" id="L889">                (new RandomDoublesSpliterator</span>
                         (this, 0L, streamSize, Double.MAX_VALUE, 0.0),
                 false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code
     * double} values, each between zero (inclusive) and one
     * (exclusive).
     *
     * &lt;p&gt;A pseudorandom {@code double} value is generated as if it's the result
     * of calling the method {@link #nextDouble()}}.
     *
     * @implNote This method is implemented to be equivalent to {@code
     * doubles(Long.MAX_VALUE)}.
     *
     * @return a stream of pseudorandom {@code double} values
     * @since 1.8
     */
    public DoubleStream doubles() {
<span class="nc" id="L909">        return StreamSupport.doubleStream</span>
<span class="nc" id="L910">                (new RandomDoublesSpliterator</span>
                         (this, 0L, Long.MAX_VALUE, Double.MAX_VALUE, 0.0),
                 false);
    }

    /**
     * Returns a stream producing the given {@code streamSize} number of
     * pseudorandom {@code double} values, each conforming to the given origin
     * (inclusive) and bound (exclusive).
     *
     * &lt;p&gt;A pseudorandom {@code double} value is generated as if it's the result
     * of calling the following method with the origin and bound:
     * &lt;pre&gt; {@code
     * double nextDouble(double origin, double bound) {
     *   double r = nextDouble();
     *   r = r * (bound - origin) + origin;
     *   if (r &gt;= bound) // correct for rounding
     *     r = Math.nextDown(bound);
     *   return r;
     * }}&lt;/pre&gt;
     *
     * @param streamSize the number of values to generate
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code double} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero
     * @throws IllegalArgumentException if {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     * @since 1.8
     */
    public DoubleStream doubles(long streamSize, double randomNumberOrigin,
                                double randomNumberBound) {
<span class="nc bnc" id="L944" title="All 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L945">            throw new IllegalArgumentException(BadSize);</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if (!(randomNumberOrigin &lt; randomNumberBound))</span>
<span class="nc" id="L947">            throw new IllegalArgumentException(BadRange);</span>
<span class="nc" id="L948">        return StreamSupport.doubleStream</span>
<span class="nc" id="L949">                (new RandomDoublesSpliterator</span>
                         (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),
                 false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code
     * double} values, each conforming to the given origin (inclusive) and bound
     * (exclusive).
     *
     * &lt;p&gt;A pseudorandom {@code double} value is generated as if it's the result
     * of calling the following method with the origin and bound:
     * &lt;pre&gt; {@code
     * double nextDouble(double origin, double bound) {
     *   double r = nextDouble();
     *   r = r * (bound - origin) + origin;
     *   if (r &gt;= bound) // correct for rounding
     *     r = Math.nextDown(bound);
     *   return r;
     * }}&lt;/pre&gt;
     *
     * @implNote This method is implemented to be equivalent to {@code
     * doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
     *
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code double} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     * @since 1.8
     */
    public DoubleStream doubles(double randomNumberOrigin, double randomNumberBound) {
<span class="nc bnc" id="L982" title="All 2 branches missed.">        if (!(randomNumberOrigin &lt; randomNumberBound))</span>
<span class="nc" id="L983">            throw new IllegalArgumentException(BadRange);</span>
<span class="nc" id="L984">        return StreamSupport.doubleStream</span>
<span class="nc" id="L985">                (new RandomDoublesSpliterator</span>
                         (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),
                 false);
    }

    /**
     * Spliterator for int streams.  We multiplex the four int
     * versions into one class by treating a bound less than origin as
     * unbounded, and also by treating &quot;infinite&quot; as equivalent to
     * Long.MAX_VALUE. For splits, it uses the standard divide-by-two
     * approach. The long and double versions of this class are
     * identical except for types.
     */
    static final class RandomIntsSpliterator implements Spliterator.OfInt {
        final Random rng;
        long index;
        final long fence;
        final int origin;
        final int bound;
        RandomIntsSpliterator(Random rng, long index, long fence,
<span class="nc" id="L1005">                              int origin, int bound) {</span>
<span class="nc" id="L1006">            this.rng = rng; this.index = index; this.fence = fence;</span>
<span class="nc" id="L1007">            this.origin = origin; this.bound = bound;</span>
<span class="nc" id="L1008">        }</span>

        public RandomIntsSpliterator trySplit() {
<span class="nc" id="L1011">            long i = index, m = (i + fence) &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">            return (m &lt;= i) ? null :</span>
                   new RandomIntsSpliterator(rng, i, index = m, origin, bound);
        }

        public long estimateSize() {
<span class="nc" id="L1017">            return fence - index;</span>
        }

        public int characteristics() {
<span class="nc" id="L1021">            return (Spliterator.SIZED | Spliterator.SUBSIZED |</span>
                    Spliterator.NONNULL | Spliterator.IMMUTABLE);
        }

        public boolean tryAdvance(IntConsumer consumer) {
<span class="nc bnc" id="L1026" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L1027">            long i = index, f = fence;</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L1029">                consumer.accept(rng.internalNextInt(origin, bound));</span>
<span class="nc" id="L1030">                index = i + 1;</span>
<span class="nc" id="L1031">                return true;</span>
            }
<span class="nc" id="L1033">            return false;</span>
        }

        public void forEachRemaining(IntConsumer consumer) {
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L1038">            long i = index, f = fence;</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L1040">                index = f;</span>
<span class="nc" id="L1041">                Random r = rng;</span>
<span class="nc" id="L1042">                int o = origin, b = bound;</span>
                do {
<span class="nc" id="L1044">                    consumer.accept(r.internalNextInt(o, b));</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                } while (++i &lt; f);</span>
            }
<span class="nc" id="L1047">        }</span>
    }

    /**
     * Spliterator for long streams.
     */
    static final class RandomLongsSpliterator implements Spliterator.OfLong {
        final Random rng;
        long index;
        final long fence;
        final long origin;
        final long bound;
        RandomLongsSpliterator(Random rng, long index, long fence,
<span class="nc" id="L1060">                               long origin, long bound) {</span>
<span class="nc" id="L1061">            this.rng = rng; this.index = index; this.fence = fence;</span>
<span class="nc" id="L1062">            this.origin = origin; this.bound = bound;</span>
<span class="nc" id="L1063">        }</span>

        public RandomLongsSpliterator trySplit() {
<span class="nc" id="L1066">            long i = index, m = (i + fence) &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">            return (m &lt;= i) ? null :</span>
                   new RandomLongsSpliterator(rng, i, index = m, origin, bound);
        }

        public long estimateSize() {
<span class="nc" id="L1072">            return fence - index;</span>
        }

        public int characteristics() {
<span class="nc" id="L1076">            return (Spliterator.SIZED | Spliterator.SUBSIZED |</span>
                    Spliterator.NONNULL | Spliterator.IMMUTABLE);
        }

        public boolean tryAdvance(LongConsumer consumer) {
<span class="nc bnc" id="L1081" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L1082">            long i = index, f = fence;</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L1084">                consumer.accept(rng.internalNextLong(origin, bound));</span>
<span class="nc" id="L1085">                index = i + 1;</span>
<span class="nc" id="L1086">                return true;</span>
            }
<span class="nc" id="L1088">            return false;</span>
        }

        public void forEachRemaining(LongConsumer consumer) {
<span class="nc bnc" id="L1092" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L1093">            long i = index, f = fence;</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L1095">                index = f;</span>
<span class="nc" id="L1096">                Random r = rng;</span>
<span class="nc" id="L1097">                long o = origin, b = bound;</span>
                do {
<span class="nc" id="L1099">                    consumer.accept(r.internalNextLong(o, b));</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                } while (++i &lt; f);</span>
            }
<span class="nc" id="L1102">        }</span>

    }

    /**
     * Spliterator for double streams.
     */
    static final class RandomDoublesSpliterator implements Spliterator.OfDouble {
        final Random rng;
        long index;
        final long fence;
        final double origin;
        final double bound;
        RandomDoublesSpliterator(Random rng, long index, long fence,
<span class="nc" id="L1116">                                 double origin, double bound) {</span>
<span class="nc" id="L1117">            this.rng = rng; this.index = index; this.fence = fence;</span>
<span class="nc" id="L1118">            this.origin = origin; this.bound = bound;</span>
<span class="nc" id="L1119">        }</span>

        public RandomDoublesSpliterator trySplit() {
<span class="nc" id="L1122">            long i = index, m = (i + fence) &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">            return (m &lt;= i) ? null :</span>
                   new RandomDoublesSpliterator(rng, i, index = m, origin, bound);
        }

        public long estimateSize() {
<span class="nc" id="L1128">            return fence - index;</span>
        }

        public int characteristics() {
<span class="nc" id="L1132">            return (Spliterator.SIZED | Spliterator.SUBSIZED |</span>
                    Spliterator.NONNULL | Spliterator.IMMUTABLE);
        }

        public boolean tryAdvance(DoubleConsumer consumer) {
<span class="nc bnc" id="L1137" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L1138">            long i = index, f = fence;</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L1140">                consumer.accept(rng.internalNextDouble(origin, bound));</span>
<span class="nc" id="L1141">                index = i + 1;</span>
<span class="nc" id="L1142">                return true;</span>
            }
<span class="nc" id="L1144">            return false;</span>
        }

        public void forEachRemaining(DoubleConsumer consumer) {
<span class="nc bnc" id="L1148" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L1149">            long i = index, f = fence;</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L1151">                index = f;</span>
<span class="nc" id="L1152">                Random r = rng;</span>
<span class="nc" id="L1153">                double o = origin, b = bound;</span>
                do {
<span class="nc" id="L1155">                    consumer.accept(r.internalNextDouble(o, b));</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">                } while (++i &lt; f);</span>
            }
<span class="nc" id="L1158">        }</span>
    }

    /**
     * Serializable fields for Random.
     *
     * @serialField    seed long
     *              seed for random computations
     * @serialField    nextNextGaussian double
     *              next Gaussian to be returned
     * @serialField      haveNextNextGaussian boolean
     *              nextNextGaussian is valid
     */
<span class="nc" id="L1171">    private static final ObjectStreamField[] serialPersistentFields = {</span>
        new ObjectStreamField(&quot;seed&quot;, Long.TYPE),
        new ObjectStreamField(&quot;nextNextGaussian&quot;, Double.TYPE),
        new ObjectStreamField(&quot;haveNextNextGaussian&quot;, Boolean.TYPE)
    };

    /**
     * Reconstitute the {@code Random} instance from a stream (that is,
     * deserialize it).
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {

<span class="nc" id="L1184">        ObjectInputStream.GetField fields = s.readFields();</span>

        // The seed is read in as {@code long} for
        // historical reasons, but it is converted to an AtomicLong.
<span class="nc" id="L1188">        long seedVal = fields.get(&quot;seed&quot;, -1L);</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">        if (seedVal &lt; 0)</span>
<span class="nc" id="L1190">          throw new java.io.StreamCorruptedException(</span>
                              &quot;Random: invalid seed&quot;);
<span class="nc" id="L1192">        resetSeed(seedVal);</span>
<span class="nc" id="L1193">        nextNextGaussian = fields.get(&quot;nextNextGaussian&quot;, 0.0);</span>
<span class="nc" id="L1194">        haveNextNextGaussian = fields.get(&quot;haveNextNextGaussian&quot;, false);</span>
<span class="nc" id="L1195">    }</span>

    /**
     * Save the {@code Random} instance to a stream.
     */
    synchronized private void writeObject(ObjectOutputStream s)
        throws IOException {

        // set the values of the Serializable fields
<span class="nc" id="L1204">        ObjectOutputStream.PutField fields = s.putFields();</span>

        // The seed is serialized as a long for historical reasons.
<span class="nc" id="L1207">        fields.put(&quot;seed&quot;, seed.get());</span>
<span class="nc" id="L1208">        fields.put(&quot;nextNextGaussian&quot;, nextNextGaussian);</span>
<span class="nc" id="L1209">        fields.put(&quot;haveNextNextGaussian&quot;, haveNextNextGaussian);</span>

        // save them
<span class="nc" id="L1212">        s.writeFields();</span>
<span class="nc" id="L1213">    }</span>

    // Support for resetting seed while deserializing
<span class="nc" id="L1216">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span>
    private static final long seedOffset;
    static {
        try {
<span class="nc" id="L1220">            seedOffset = unsafe.objectFieldOffset</span>
<span class="nc" id="L1221">                (Random.class.getDeclaredField(&quot;seed&quot;));</span>
<span class="nc" id="L1222">        } catch (Exception ex) { throw new Error(ex); }</span>
<span class="nc" id="L1223">    }</span>
    private void resetSeed(long seedVal) {
<span class="nc" id="L1225">        unsafe.putObjectVolatile(this, seedOffset, new AtomicLong(seedVal));</span>
<span class="nc" id="L1226">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>