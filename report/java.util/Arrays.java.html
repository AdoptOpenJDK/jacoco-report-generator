<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Arrays.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">Arrays.java</span></div><h1>Arrays.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.lang.reflect.Array;
import java.util.concurrent.ForkJoinPool;
import java.util.function.BinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.IntFunction;
import java.util.function.IntToDoubleFunction;
import java.util.function.IntToLongFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * This class contains various methods for manipulating arrays (such as
 * sorting and searching). This class also contains a static factory
 * that allows arrays to be viewed as lists.
 *
 * &lt;p&gt;The methods in this class all throw a {@code NullPointerException},
 * if the specified array reference is null, except where noted.
 *
 * &lt;p&gt;The documentation for the methods contained in this class includes
 * briefs description of the &lt;i&gt;implementations&lt;/i&gt;. Such descriptions should
 * be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than parts of the
 * &lt;i&gt;specification&lt;/i&gt;. Implementors should feel free to substitute other
 * algorithms, so long as the specification itself is adhered to. (For
 * example, the algorithm used by {@code sort(Object[])} does not have to be
 * a MergeSort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @author Josh Bloch
 * @author Neal Gafter
 * @author John Rose
 * @since  1.2
 */
<span class="fc bfc" id="L69" title="All 2 branches covered.">public class Arrays {</span>

    /**
     * The minimum array length below which a parallel sorting
     * algorithm will not further partition the sorting task. Using
     * smaller sizes typically results in memory contention across
     * tasks that makes parallel speedups unlikely.
     */
    private static final int MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13;

    // Suppresses default constructor, ensuring non-instantiability.
<span class="nc" id="L80">    private Arrays() {}</span>

    /**
     * A comparator that implements the natural ordering of a group of
     * mutually comparable elements. May be used when a supplied
     * comparator is null. To simplify code-sharing within underlying
     * implementations, the compare method only declares type Object
     * for its second argument.
     *
     * Arrays class implementor's note: It is an empirical matter
     * whether ComparableTimSort offers any performance benefit over
     * TimSort used with this comparator.  If not, you are better off
     * deleting or bypassing ComparableTimSort.  There is currently no
     * empirical case for separating them for parallel sorting, so all
     * public Object parallelSort methods use the same comparator
     * based implementation.
     */
<span class="nc" id="L97">    static final class NaturalOrder implements Comparator&lt;Object&gt; {</span>
        @SuppressWarnings(&quot;unchecked&quot;)
        public int compare(Object first, Object second) {
<span class="nc" id="L100">            return ((Comparable&lt;Object&gt;)first).compareTo(second);</span>
        }
<span class="nc" id="L102">        static final NaturalOrder INSTANCE = new NaturalOrder();</span>
    }

    /**
     * Checks that {@code fromIndex} and {@code toIndex} are in
     * the range and throws an exception if they aren't.
     */
    private static void rangeCheck(int arrayLength, int fromIndex, int toIndex) {
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        if (fromIndex &gt; toIndex) {</span>
<span class="nc" id="L111">            throw new IllegalArgumentException(</span>
                    &quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);
        }
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (fromIndex &lt; 0) {</span>
<span class="nc" id="L115">            throw new ArrayIndexOutOfBoundsException(fromIndex);</span>
        }
<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (toIndex &gt; arrayLength) {</span>
<span class="fc" id="L118">            throw new ArrayIndexOutOfBoundsException(toIndex);</span>
        }
<span class="fc" id="L120">    }</span>

    /*
     * Sorting methods. Note that all public &quot;sort&quot; methods take the
     * same form: Performing argument checks if necessary, and then
     * expanding arguments into those required for the internal
     * implementation methods residing in other package-private
     * classes (except for legacyMergeSort, included in this class).
     */

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     */
    public static void sort(int[] a) {
<span class="nc" id="L142">        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="nc" id="L143">    }</span>

    /**
     * Sorts the specified range of the array into ascending order. The range
     * to be sorted extends from the index {@code fromIndex}, inclusive, to
     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
     * the range to be sorted is empty.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     */
    public static void sort(int[] a, int fromIndex, int toIndex) {
<span class="nc" id="L166">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L167">        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="nc" id="L168">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     */
    public static void sort(long[] a) {
<span class="nc" id="L182">        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="nc" id="L183">    }</span>

    /**
     * Sorts the specified range of the array into ascending order. The range
     * to be sorted extends from the index {@code fromIndex}, inclusive, to
     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
     * the range to be sorted is empty.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     */
    public static void sort(long[] a, int fromIndex, int toIndex) {
<span class="nc" id="L206">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L207">        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="nc" id="L208">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     */
    public static void sort(short[] a) {
<span class="nc" id="L222">        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="nc" id="L223">    }</span>

    /**
     * Sorts the specified range of the array into ascending order. The range
     * to be sorted extends from the index {@code fromIndex}, inclusive, to
     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
     * the range to be sorted is empty.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     */
    public static void sort(short[] a, int fromIndex, int toIndex) {
<span class="nc" id="L246">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L247">        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="nc" id="L248">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     */
    public static void sort(char[] a) {
<span class="nc" id="L262">        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="nc" id="L263">    }</span>

    /**
     * Sorts the specified range of the array into ascending order. The range
     * to be sorted extends from the index {@code fromIndex}, inclusive, to
     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
     * the range to be sorted is empty.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     */
    public static void sort(char[] a, int fromIndex, int toIndex) {
<span class="nc" id="L286">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L287">        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="nc" id="L288">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     */
    public static void sort(byte[] a) {
<span class="nc" id="L302">        DualPivotQuicksort.sort(a, 0, a.length - 1);</span>
<span class="nc" id="L303">    }</span>

    /**
     * Sorts the specified range of the array into ascending order. The range
     * to be sorted extends from the index {@code fromIndex}, inclusive, to
     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
     * the range to be sorted is empty.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     */
    public static void sort(byte[] a, int fromIndex, int toIndex) {
<span class="fc" id="L326">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="fc" id="L327">        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);</span>
<span class="fc" id="L328">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
     * value compares neither less than, greater than, nor equal to any value,
     * even itself. This method uses the total order imposed by the method
     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
     * {@code 0.0f} and {@code Float.NaN} is considered greater than any
     * other value and all {@code Float.NaN} values are considered equal.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     */
    public static void sort(float[] a) {
<span class="nc" id="L350">        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="nc" id="L351">    }</span>

    /**
     * Sorts the specified range of the array into ascending order. The range
     * to be sorted extends from the index {@code fromIndex}, inclusive, to
     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
     * the range to be sorted is empty.
     *
     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
     * value compares neither less than, greater than, nor equal to any value,
     * even itself. This method uses the total order imposed by the method
     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
     * {@code 0.0f} and {@code Float.NaN} is considered greater than any
     * other value and all {@code Float.NaN} values are considered equal.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     */
    public static void sort(float[] a, int fromIndex, int toIndex) {
<span class="nc" id="L382">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L383">        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="nc" id="L384">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
     * value compares neither less than, greater than, nor equal to any value,
     * even itself. This method uses the total order imposed by the method
     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
     * {@code 0.0d} and {@code Double.NaN} is considered greater than any
     * other value and all {@code Double.NaN} values are considered equal.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     */
    public static void sort(double[] a) {
<span class="nc" id="L406">        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="nc" id="L407">    }</span>

    /**
     * Sorts the specified range of the array into ascending order. The range
     * to be sorted extends from the index {@code fromIndex}, inclusive, to
     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
     * the range to be sorted is empty.
     *
     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
     * value compares neither less than, greater than, nor equal to any value,
     * even itself. This method uses the total order imposed by the method
     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
     * {@code 0.0d} and {@code Double.NaN} is considered greater than any
     * other value and all {@code Double.NaN} values are considered equal.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     */
    public static void sort(double[] a, int fromIndex, int toIndex) {
<span class="nc" id="L438">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L439">        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="nc" id="L440">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
     * execute any parallel tasks.
     *
     * @param a the array to be sorted
     *
     * @since 1.8
     */
    public static void parallelSort(byte[] a) {
<span class="nc" id="L461">        int n = a.length, p, g;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L464">            DualPivotQuicksort.sort(a, 0, n - 1);</span>
        else
<span class="nc bnc" id="L466" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJByte.Sorter</span>
                (null, a, new byte[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L469">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L470">    }</span>

    /**
     * Sorts the specified range of the array into ascending numerical order.
     * The range to be sorted extends from the index {@code fromIndex},
     * inclusive, to the index {@code toIndex}, exclusive. If
     * {@code fromIndex == toIndex}, the range to be sorted is empty.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
     * used to execute any parallel tasks.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     *
     * @since 1.8
     */
    public static void parallelSort(byte[] a, int fromIndex, int toIndex) {
<span class="nc" id="L500">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L501">        int n = toIndex - fromIndex, p, g;</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L504">            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);</span>
        else
<span class="nc bnc" id="L506" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJByte.Sorter</span>
                (null, a, new byte[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L509">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L510">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(char[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(char[]) Arrays.sort} method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
     * execute any parallel tasks.
     *
     * @param a the array to be sorted
     *
     * @since 1.8
     */
    public static void parallelSort(char[] a) {
<span class="nc" id="L531">        int n = a.length, p, g;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L534">            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L536" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJChar.Sorter</span>
                (null, a, new char[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L539">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L540">    }</span>

    /**
     * Sorts the specified range of the array into ascending numerical order.
     * The range to be sorted extends from the index {@code fromIndex},
     * inclusive, to the index {@code toIndex}, exclusive. If
     * {@code fromIndex == toIndex}, the range to be sorted is empty.
     *
      @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(char[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(char[]) Arrays.sort} method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
     * used to execute any parallel tasks.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     *
     * @since 1.8
     */
    public static void parallelSort(char[] a, int fromIndex, int toIndex) {
<span class="nc" id="L570">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L571">        int n = toIndex - fromIndex, p, g;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L574">            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L576" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJChar.Sorter</span>
                (null, a, new char[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L579">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L580">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(short[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(short[]) Arrays.sort} method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
     * execute any parallel tasks.
     *
     * @param a the array to be sorted
     *
     * @since 1.8
     */
    public static void parallelSort(short[] a) {
<span class="nc" id="L601">        int n = a.length, p, g;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L604">            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L606" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJShort.Sorter</span>
                (null, a, new short[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L609">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L610">    }</span>

    /**
     * Sorts the specified range of the array into ascending numerical order.
     * The range to be sorted extends from the index {@code fromIndex},
     * inclusive, to the index {@code toIndex}, exclusive. If
     * {@code fromIndex == toIndex}, the range to be sorted is empty.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(short[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(short[]) Arrays.sort} method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
     * used to execute any parallel tasks.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     *
     * @since 1.8
     */
    public static void parallelSort(short[] a, int fromIndex, int toIndex) {
<span class="nc" id="L640">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L641">        int n = toIndex - fromIndex, p, g;</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L644">            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L646" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJShort.Sorter</span>
                (null, a, new short[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L649">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L650">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(int[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(int[]) Arrays.sort} method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
     * execute any parallel tasks.
     *
     * @param a the array to be sorted
     *
     * @since 1.8
     */
    public static void parallelSort(int[] a) {
<span class="nc" id="L671">        int n = a.length, p, g;</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L674">            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L676" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJInt.Sorter</span>
                (null, a, new int[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L679">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L680">    }</span>

    /**
     * Sorts the specified range of the array into ascending numerical order.
     * The range to be sorted extends from the index {@code fromIndex},
     * inclusive, to the index {@code toIndex}, exclusive. If
     * {@code fromIndex == toIndex}, the range to be sorted is empty.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(int[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(int[]) Arrays.sort} method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
     * used to execute any parallel tasks.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     *
     * @since 1.8
     */
    public static void parallelSort(int[] a, int fromIndex, int toIndex) {
<span class="nc" id="L710">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L711">        int n = toIndex - fromIndex, p, g;</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L714">            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L716" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJInt.Sorter</span>
                (null, a, new int[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L719">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L720">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(long[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(long[]) Arrays.sort} method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
     * execute any parallel tasks.
     *
     * @param a the array to be sorted
     *
     * @since 1.8
     */
    public static void parallelSort(long[] a) {
<span class="nc" id="L741">        int n = a.length, p, g;</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L744">            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L746" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJLong.Sorter</span>
                (null, a, new long[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L749">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L750">    }</span>

    /**
     * Sorts the specified range of the array into ascending numerical order.
     * The range to be sorted extends from the index {@code fromIndex},
     * inclusive, to the index {@code toIndex}, exclusive. If
     * {@code fromIndex == toIndex}, the range to be sorted is empty.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(long[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(long[]) Arrays.sort} method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
     * used to execute any parallel tasks.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     *
     * @since 1.8
     */
    public static void parallelSort(long[] a, int fromIndex, int toIndex) {
<span class="nc" id="L780">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L781">        int n = toIndex - fromIndex, p, g;</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L784">            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L786" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJLong.Sorter</span>
                (null, a, new long[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L789">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L790">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
     * value compares neither less than, greater than, nor equal to any value,
     * even itself. This method uses the total order imposed by the method
     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
     * {@code 0.0f} and {@code Float.NaN} is considered greater than any
     * other value and all {@code Float.NaN} values are considered equal.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(float[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(float[]) Arrays.sort} method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
     * execute any parallel tasks.
     *
     * @param a the array to be sorted
     *
     * @since 1.8
     */
    public static void parallelSort(float[] a) {
<span class="nc" id="L819">        int n = a.length, p, g;</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L822">            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L824" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJFloat.Sorter</span>
                (null, a, new float[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L827">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L828">    }</span>

    /**
     * Sorts the specified range of the array into ascending numerical order.
     * The range to be sorted extends from the index {@code fromIndex},
     * inclusive, to the index {@code toIndex}, exclusive. If
     * {@code fromIndex == toIndex}, the range to be sorted is empty.
     *
     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
     * value compares neither less than, greater than, nor equal to any value,
     * even itself. This method uses the total order imposed by the method
     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
     * {@code 0.0f} and {@code Float.NaN} is considered greater than any
     * other value and all {@code Float.NaN} values are considered equal.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(float[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(float[]) Arrays.sort} method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
     * used to execute any parallel tasks.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     *
     * @since 1.8
     */
    public static void parallelSort(float[] a, int fromIndex, int toIndex) {
<span class="nc" id="L866">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L867">        int n = toIndex - fromIndex, p, g;</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L870">            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L872" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJFloat.Sorter</span>
                (null, a, new float[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L875">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L876">    }</span>

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
     * value compares neither less than, greater than, nor equal to any value,
     * even itself. This method uses the total order imposed by the method
     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
     * {@code 0.0d} and {@code Double.NaN} is considered greater than any
     * other value and all {@code Double.NaN} values are considered equal.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(double[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(double[]) Arrays.sort} method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
     * execute any parallel tasks.
     *
     * @param a the array to be sorted
     *
     * @since 1.8
     */
    public static void parallelSort(double[] a) {
<span class="nc" id="L905">        int n = a.length, p, g;</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L908">            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L910" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJDouble.Sorter</span>
                (null, a, new double[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L913">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L914">    }</span>

    /**
     * Sorts the specified range of the array into ascending numerical order.
     * The range to be sorted extends from the index {@code fromIndex},
     * inclusive, to the index {@code toIndex}, exclusive. If
     * {@code fromIndex == toIndex}, the range to be sorted is empty.
     *
     * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
     * value compares neither less than, greater than, nor equal to any value,
     * even itself. This method uses the total order imposed by the method
     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
     * {@code 0.0d} and {@code Double.NaN} is considered greater than any
     * other value and all {@code Double.NaN} values are considered equal.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(double[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(double[]) Arrays.sort} method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
     * used to execute any parallel tasks.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     *
     * @since 1.8
     */
    public static void parallelSort(double[] a, int fromIndex, int toIndex) {
<span class="nc" id="L952">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L953">        int n = toIndex - fromIndex, p, g;</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L956">            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
        else
<span class="nc bnc" id="L958" title="All 2 branches missed.">            new ArraysParallelSortHelpers.FJDouble.Sorter</span>
                (null, a, new double[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L961">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="nc" id="L962">    }</span>

    /**
     * Sorts the specified array of objects into ascending order, according
     * to the {@linkplain Comparable natural ordering} of its elements.
     * All elements in the array must implement the {@link Comparable}
     * interface.  Furthermore, all elements in the array must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must
     * not throw a {@code ClassCastException} for any elements {@code e1}
     * and {@code e2} in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
     * execute any parallel tasks.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     *
     * @throws ClassCastException if the array contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and integers)
     * @throws IllegalArgumentException (optional) if the natural
     *         ordering of the array elements is found to violate the
     *         {@link Comparable} contract
     *
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void parallelSort(T[] a) {
<span class="nc" id="L1000">        int n = a.length, p, g;</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L1003">            TimSort.sort(a, 0, n, NaturalOrder.INSTANCE, null, 0, 0);</span>
        else
<span class="nc" id="L1005">            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span>
                (null, a,
<span class="nc bnc" id="L1007" title="All 2 branches missed.">                 (T[])Array.newInstance(a.getClass().getComponentType(), n),</span>
                 0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L1009">                 MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();</span>
<span class="nc" id="L1010">    }</span>

    /**
     * Sorts the specified range of the specified array of objects into
     * ascending order, according to the
     * {@linkplain Comparable natural ordering} of its
     * elements.  The range to be sorted extends from index
     * {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.
     * (If {@code fromIndex==toIndex}, the range to be sorted is empty.)  All
     * elements in this range must implement the {@link Comparable}
     * interface.  Furthermore, all elements in this range must be &lt;i&gt;mutually
     * comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must not throw a
     * {@code ClassCastException} for any elements {@code e1} and
     * {@code e2} in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
     * used to execute any parallel tasks.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be
     *        sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or
     *         (optional) if the natural ordering of the array elements is
     *         found to violate the {@link Comparable} contract
     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
     *         {@code toIndex &gt; a.length}
     * @throws ClassCastException if the array contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
     *         integers).
     *
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T extends Comparable&lt;? super T&gt;&gt;
    void parallelSort(T[] a, int fromIndex, int toIndex) {
<span class="nc" id="L1058">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L1059">        int n = toIndex - fromIndex, p, g;</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L1062">            TimSort.sort(a, fromIndex, toIndex, NaturalOrder.INSTANCE, null, 0, 0);</span>
        else
<span class="nc" id="L1064">            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span>
                (null, a,
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                 (T[])Array.newInstance(a.getClass().getComponentType(), n),</span>
                 fromIndex, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L1068">                 MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();</span>
<span class="nc" id="L1069">    }</span>

    /**
     * Sorts the specified array of objects according to the order induced by
     * the specified comparator.  All elements in the array must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}
     * for any elements {@code e1} and {@code e2} in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
     * execute any parallel tasks.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     * @param cmp the comparator to determine the order of the array.  A
     *        {@code null} value indicates that the elements'
     *        {@linkplain Comparable natural ordering} should be used.
     * @throws ClassCastException if the array contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator
     * @throws IllegalArgumentException (optional) if the comparator is
     *         found to violate the {@link java.util.Comparator} contract
     *
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; void parallelSort(T[] a, Comparator&lt;? super T&gt; cmp) {
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (cmp == null)</span>
<span class="nc" id="L1107">            cmp = NaturalOrder.INSTANCE;</span>
<span class="nc" id="L1108">        int n = a.length, p, g;</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L1111">            TimSort.sort(a, 0, n, cmp, null, 0, 0);</span>
        else
<span class="nc" id="L1113">            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span>
                (null, a,
<span class="nc bnc" id="L1115" title="All 2 branches missed.">                 (T[])Array.newInstance(a.getClass().getComponentType(), n),</span>
                 0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L1117">                 MIN_ARRAY_SORT_GRAN : g, cmp).invoke();</span>
<span class="nc" id="L1118">    }</span>

    /**
     * Sorts the specified range of the specified array of objects according
     * to the order induced by the specified comparator.  The range to be
     * sorted extends from index {@code fromIndex}, inclusive, to index
     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
     * range to be sorted is empty.)  All elements in the range must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}
     * for any elements {@code e1} and {@code e2} in the range).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
     * used to execute any parallel tasks.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be
     *        sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @param cmp the comparator to determine the order of the array.  A
     *        {@code null} value indicates that the elements'
     *        {@linkplain Comparable natural ordering} should be used.
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or
     *         (optional) if the natural ordering of the array elements is
     *         found to violate the {@link Comparable} contract
     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
     *         {@code toIndex &gt; a.length}
     * @throws ClassCastException if the array contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
     *         integers).
     *
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; void parallelSort(T[] a, int fromIndex, int toIndex,
                                        Comparator&lt;? super T&gt; cmp) {
<span class="nc" id="L1166">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">        if (cmp == null)</span>
<span class="nc" id="L1168">            cmp = NaturalOrder.INSTANCE;</span>
<span class="nc" id="L1169">        int n = toIndex - fromIndex, p, g;</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">        if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="nc" id="L1172">            TimSort.sort(a, fromIndex, toIndex, cmp, null, 0, 0);</span>
        else
<span class="nc" id="L1174">            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span>
                (null, a,
<span class="nc bnc" id="L1176" title="All 2 branches missed.">                 (T[])Array.newInstance(a.getClass().getComponentType(), n),</span>
                 fromIndex, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
<span class="nc" id="L1178">                 MIN_ARRAY_SORT_GRAN : g, cmp).invoke();</span>
<span class="nc" id="L1179">    }</span>

    /*
     * Sorting of complex type arrays.
     */

    /**
     * Old merge sort implementation can be selected (for
     * compatibility with broken comparators) using a system property.
     * Cannot be a static boolean in the enclosing class due to
     * circular dependencies. To be removed in a future release.
     */
<span class="nc" id="L1191">    static final class LegacyMergeSort {</span>
<span class="fc" id="L1192">        private static final boolean userRequested =</span>
<span class="fc" id="L1193">            java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetBooleanAction(
<span class="fc" id="L1195">                    &quot;java.util.Arrays.useLegacyMergeSort&quot;)).booleanValue();</span>
    }

    /**
     * Sorts the specified array of objects into ascending order, according
     * to the {@linkplain Comparable natural ordering} of its elements.
     * All elements in the array must implement the {@link Comparable}
     * interface.  Furthermore, all elements in the array must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must
     * not throw a {@code ClassCastException} for any elements {@code e1}
     * and {@code e2} in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
     * iterative mergesort that requires far fewer than n lg(n) comparisons
     * when the input array is partially sorted, while offering the
     * performance of a traditional mergesort when the input array is
     * randomly ordered.  If the input array is nearly sorted, the
     * implementation requires approximately n comparisons.  Temporary
     * storage requirements vary from a small constant for nearly sorted
     * input arrays to n/2 object references for randomly ordered input
     * arrays.
     *
     * &lt;p&gt;The implementation takes equal advantage of ascending and
     * descending order in its input array, and can take advantage of
     * ascending and descending order in different parts of the the same
     * input array.  It is well-suited to merging two or more sorted arrays:
     * simply concatenate the arrays and sort the resulting array.
     *
     * &lt;p&gt;The implementation was adapted from Tim Peters's list sort for Python
     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy's &quot;Optimistic
     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
     * January 1993.
     *
     * @param a the array to be sorted
     * @throws ClassCastException if the array contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and integers)
     * @throws IllegalArgumentException (optional) if the natural
     *         ordering of the array elements is found to violate the
     *         {@link Comparable} contract
     */
    public static void sort(Object[] a) {
<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">        if (LegacyMergeSort.userRequested)</span>
<span class="nc" id="L1242">            legacyMergeSort(a);</span>
        else
<span class="fc" id="L1244">            ComparableTimSort.sort(a, 0, a.length, null, 0, 0);</span>
<span class="fc" id="L1245">    }</span>

    /** To be removed in a future release. */
    private static void legacyMergeSort(Object[] a) {
<span class="nc" id="L1249">        Object[] aux = a.clone();</span>
<span class="nc" id="L1250">        mergeSort(aux, a, 0, a.length, 0);</span>
<span class="nc" id="L1251">    }</span>

    /**
     * Sorts the specified range of the specified array of objects into
     * ascending order, according to the
     * {@linkplain Comparable natural ordering} of its
     * elements.  The range to be sorted extends from index
     * {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.
     * (If {@code fromIndex==toIndex}, the range to be sorted is empty.)  All
     * elements in this range must implement the {@link Comparable}
     * interface.  Furthermore, all elements in this range must be &lt;i&gt;mutually
     * comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must not throw a
     * {@code ClassCastException} for any elements {@code e1} and
     * {@code e2} in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
     * iterative mergesort that requires far fewer than n lg(n) comparisons
     * when the input array is partially sorted, while offering the
     * performance of a traditional mergesort when the input array is
     * randomly ordered.  If the input array is nearly sorted, the
     * implementation requires approximately n comparisons.  Temporary
     * storage requirements vary from a small constant for nearly sorted
     * input arrays to n/2 object references for randomly ordered input
     * arrays.
     *
     * &lt;p&gt;The implementation takes equal advantage of ascending and
     * descending order in its input array, and can take advantage of
     * ascending and descending order in different parts of the the same
     * input array.  It is well-suited to merging two or more sorted arrays:
     * simply concatenate the arrays and sort the resulting array.
     *
     * &lt;p&gt;The implementation was adapted from Tim Peters's list sort for Python
     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy's &quot;Optimistic
     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
     * January 1993.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be
     *        sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or
     *         (optional) if the natural ordering of the array elements is
     *         found to violate the {@link Comparable} contract
     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
     *         {@code toIndex &gt; a.length}
     * @throws ClassCastException if the array contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
     *         integers).
     */
    public static void sort(Object[] a, int fromIndex, int toIndex) {
<span class="fc" id="L1306">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="pc bpc" id="L1307" title="1 of 2 branches missed.">        if (LegacyMergeSort.userRequested)</span>
<span class="nc" id="L1308">            legacyMergeSort(a, fromIndex, toIndex);</span>
        else
<span class="fc" id="L1310">            ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);</span>
<span class="fc" id="L1311">    }</span>

    /** To be removed in a future release. */
    private static void legacyMergeSort(Object[] a,
                                        int fromIndex, int toIndex) {
<span class="nc" id="L1316">        Object[] aux = copyOfRange(a, fromIndex, toIndex);</span>
<span class="nc" id="L1317">        mergeSort(aux, a, fromIndex, toIndex, -fromIndex);</span>
<span class="nc" id="L1318">    }</span>

    /**
     * Tuning parameter: list size at or below which insertion sort will be
     * used in preference to mergesort.
     * To be removed in a future release.
     */
    private static final int INSERTIONSORT_THRESHOLD = 7;

    /**
     * Src is the source array that starts at index 0
     * Dest is the (possibly larger) array destination with a possible offset
     * low is the index in dest to start sorting
     * high is the end index in dest to end sorting
     * off is the offset to generate corresponding low, high in src
     * To be removed in a future release.
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    private static void mergeSort(Object[] src,
                                  Object[] dest,
                                  int low,
                                  int high,
                                  int off) {
<span class="nc" id="L1341">        int length = high - low;</span>

        // Insertion sort on smallest arrays
<span class="nc bnc" id="L1344" title="All 2 branches missed.">        if (length &lt; INSERTIONSORT_THRESHOLD) {</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">            for (int i=low; i&lt;high; i++)</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">                for (int j=i; j&gt;low &amp;&amp;</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">                         ((Comparable) dest[j-1]).compareTo(dest[j])&gt;0; j--)</span>
<span class="nc" id="L1348">                    swap(dest, j, j-1);</span>
<span class="nc" id="L1349">            return;</span>
        }

        // Recursively sort halves of dest into src
<span class="nc" id="L1353">        int destLow  = low;</span>
<span class="nc" id="L1354">        int destHigh = high;</span>
<span class="nc" id="L1355">        low  += off;</span>
<span class="nc" id="L1356">        high += off;</span>
<span class="nc" id="L1357">        int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L1358">        mergeSort(dest, src, low, mid, -off);</span>
<span class="nc" id="L1359">        mergeSort(dest, src, mid, high, -off);</span>

        // If list is already sorted, just copy from src to dest.  This is an
        // optimization that results in faster sorts for nearly ordered lists.
<span class="nc bnc" id="L1363" title="All 2 branches missed.">        if (((Comparable)src[mid-1]).compareTo(src[mid]) &lt;= 0) {</span>
<span class="nc" id="L1364">            System.arraycopy(src, low, dest, destLow, length);</span>
<span class="nc" id="L1365">            return;</span>
        }

        // Merge sorted halves (now in src) into dest
<span class="nc bnc" id="L1369" title="All 2 branches missed.">        for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) {</span>
<span class="nc bnc" id="L1370" title="All 6 branches missed.">            if (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=0)</span>
<span class="nc" id="L1371">                dest[i] = src[p++];</span>
            else
<span class="nc" id="L1373">                dest[i] = src[q++];</span>
        }
<span class="nc" id="L1375">    }</span>

    /**
     * Swaps x[a] with x[b].
     */
    private static void swap(Object[] x, int a, int b) {
<span class="nc" id="L1381">        Object t = x[a];</span>
<span class="nc" id="L1382">        x[a] = x[b];</span>
<span class="nc" id="L1383">        x[b] = t;</span>
<span class="nc" id="L1384">    }</span>

    /**
     * Sorts the specified array of objects according to the order induced by
     * the specified comparator.  All elements in the array must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}
     * for any elements {@code e1} and {@code e2} in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
     * iterative mergesort that requires far fewer than n lg(n) comparisons
     * when the input array is partially sorted, while offering the
     * performance of a traditional mergesort when the input array is
     * randomly ordered.  If the input array is nearly sorted, the
     * implementation requires approximately n comparisons.  Temporary
     * storage requirements vary from a small constant for nearly sorted
     * input arrays to n/2 object references for randomly ordered input
     * arrays.
     *
     * &lt;p&gt;The implementation takes equal advantage of ascending and
     * descending order in its input array, and can take advantage of
     * ascending and descending order in different parts of the the same
     * input array.  It is well-suited to merging two or more sorted arrays:
     * simply concatenate the arrays and sort the resulting array.
     *
     * &lt;p&gt;The implementation was adapted from Tim Peters's list sort for Python
     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy's &quot;Optimistic
     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
     * January 1993.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     * @param c the comparator to determine the order of the array.  A
     *        {@code null} value indicates that the elements'
     *        {@linkplain Comparable natural ordering} should be used.
     * @throws ClassCastException if the array contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator
     * @throws IllegalArgumentException (optional) if the comparator is
     *         found to violate the {@link Comparator} contract
     */
    public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) {
<span class="pc bpc" id="L1430" title="1 of 2 branches missed.">        if (c == null)</span>
<span class="nc" id="L1431">            c = NaturalOrder.INSTANCE;</span>
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">        if (LegacyMergeSort.userRequested)</span>
<span class="nc" id="L1433">            legacyMergeSort(a, c);</span>
        else
<span class="fc" id="L1435">            TimSort.sort(a, 0, a.length, c, null, 0, 0);</span>
<span class="fc" id="L1436">    }</span>

    /** To be removed in a future release. */
    private static &lt;T&gt; void legacyMergeSort(T[] a, Comparator&lt;? super T&gt; c) {
<span class="nc" id="L1440">        T[] aux = a.clone();</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">        if (c==null)</span>
<span class="nc" id="L1442">            mergeSort(aux, a, 0, a.length, 0);</span>
        else
<span class="nc" id="L1444">            mergeSort(aux, a, 0, a.length, 0, c);</span>
<span class="nc" id="L1445">    }</span>

    /**
     * Sorts the specified range of the specified array of objects according
     * to the order induced by the specified comparator.  The range to be
     * sorted extends from index {@code fromIndex}, inclusive, to index
     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
     * range to be sorted is empty.)  All elements in the range must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}
     * for any elements {@code e1} and {@code e2} in the range).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
     * iterative mergesort that requires far fewer than n lg(n) comparisons
     * when the input array is partially sorted, while offering the
     * performance of a traditional mergesort when the input array is
     * randomly ordered.  If the input array is nearly sorted, the
     * implementation requires approximately n comparisons.  Temporary
     * storage requirements vary from a small constant for nearly sorted
     * input arrays to n/2 object references for randomly ordered input
     * arrays.
     *
     * &lt;p&gt;The implementation takes equal advantage of ascending and
     * descending order in its input array, and can take advantage of
     * ascending and descending order in different parts of the the same
     * input array.  It is well-suited to merging two or more sorted arrays:
     * simply concatenate the arrays and sort the resulting array.
     *
     * &lt;p&gt;The implementation was adapted from Tim Peters's list sort for Python
     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy's &quot;Optimistic
     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
     * January 1993.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be
     *        sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @param c the comparator to determine the order of the array.  A
     *        {@code null} value indicates that the elements'
     *        {@linkplain Comparable natural ordering} should be used.
     * @throws ClassCastException if the array contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or
     *         (optional) if the comparator is found to violate the
     *         {@link Comparator} contract
     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
     *         {@code toIndex &gt; a.length}
     */
    public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex,
                                Comparator&lt;? super T&gt; c) {
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">        if (c == null)</span>
<span class="nc" id="L1502">            c = NaturalOrder.INSTANCE;</span>
<span class="fc" id="L1503">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">        if (LegacyMergeSort.userRequested)</span>
<span class="nc" id="L1505">            legacyMergeSort(a, fromIndex, toIndex, c);</span>
        else
<span class="fc" id="L1507">            TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0);</span>
<span class="fc" id="L1508">    }</span>

    /** To be removed in a future release. */
    private static &lt;T&gt; void legacyMergeSort(T[] a, int fromIndex, int toIndex,
                                            Comparator&lt;? super T&gt; c) {
<span class="nc" id="L1513">        T[] aux = copyOfRange(a, fromIndex, toIndex);</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">        if (c==null)</span>
<span class="nc" id="L1515">            mergeSort(aux, a, fromIndex, toIndex, -fromIndex);</span>
        else
<span class="nc" id="L1517">            mergeSort(aux, a, fromIndex, toIndex, -fromIndex, c);</span>
<span class="nc" id="L1518">    }</span>

    /**
     * Src is the source array that starts at index 0
     * Dest is the (possibly larger) array destination with a possible offset
     * low is the index in dest to start sorting
     * high is the end index in dest to end sorting
     * off is the offset into src corresponding to low in dest
     * To be removed in a future release.
     */
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    private static void mergeSort(Object[] src,
                                  Object[] dest,
                                  int low, int high, int off,
                                  Comparator c) {
<span class="nc" id="L1533">        int length = high - low;</span>

        // Insertion sort on smallest arrays
<span class="nc bnc" id="L1536" title="All 2 branches missed.">        if (length &lt; INSERTIONSORT_THRESHOLD) {</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">            for (int i=low; i&lt;high; i++)</span>
<span class="nc bnc" id="L1538" title="All 4 branches missed.">                for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--)</span>
<span class="nc" id="L1539">                    swap(dest, j, j-1);</span>
<span class="nc" id="L1540">            return;</span>
        }

        // Recursively sort halves of dest into src
<span class="nc" id="L1544">        int destLow  = low;</span>
<span class="nc" id="L1545">        int destHigh = high;</span>
<span class="nc" id="L1546">        low  += off;</span>
<span class="nc" id="L1547">        high += off;</span>
<span class="nc" id="L1548">        int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L1549">        mergeSort(dest, src, low, mid, -off, c);</span>
<span class="nc" id="L1550">        mergeSort(dest, src, mid, high, -off, c);</span>

        // If list is already sorted, just copy from src to dest.  This is an
        // optimization that results in faster sorts for nearly ordered lists.
<span class="nc bnc" id="L1554" title="All 2 branches missed.">        if (c.compare(src[mid-1], src[mid]) &lt;= 0) {</span>
<span class="nc" id="L1555">           System.arraycopy(src, low, dest, destLow, length);</span>
<span class="nc" id="L1556">           return;</span>
        }

        // Merge sorted halves (now in src) into dest
<span class="nc bnc" id="L1560" title="All 2 branches missed.">        for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) {</span>
<span class="nc bnc" id="L1561" title="All 6 branches missed.">            if (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= 0)</span>
<span class="nc" id="L1562">                dest[i] = src[p++];</span>
            else
<span class="nc" id="L1564">                dest[i] = src[q++];</span>
        }
<span class="nc" id="L1566">    }</span>

    // Parallel prefix

    /**
     * Cumulates, in parallel, each element of the given array in place,
     * using the supplied function. For example if the array initially
     * holds {@code [2, 1, 0, 3]} and the operation performs addition,
     * then upon return the array holds {@code [2, 3, 3, 6]}.
     * Parallel prefix computation is usually more efficient than
     * sequential loops for large arrays.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param array the array, which is modified in-place by this method
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static &lt;T&gt; void parallelPrefix(T[] array, BinaryOperator&lt;T&gt; op) {
<span class="nc" id="L1586">        Objects.requireNonNull(op);</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">        if (array.length &gt; 0)</span>
<span class="nc" id="L1588">            new ArrayPrefixHelpers.CumulateTask&lt;&gt;</span>
<span class="nc" id="L1589">                    (null, op, array, 0, array.length).invoke();</span>
<span class="nc" id="L1590">    }</span>

    /**
     * Performs {@link #parallelPrefix(Object[], BinaryOperator)}
     * for the given subrange of the array.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param array the array
     * @param fromIndex the index of the first element, inclusive
     * @param toIndex the index of the last element, exclusive
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static &lt;T&gt; void parallelPrefix(T[] array, int fromIndex,
                                          int toIndex, BinaryOperator&lt;T&gt; op) {
<span class="nc" id="L1610">        Objects.requireNonNull(op);</span>
<span class="nc" id="L1611">        rangeCheck(array.length, fromIndex, toIndex);</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">        if (fromIndex &lt; toIndex)</span>
<span class="nc" id="L1613">            new ArrayPrefixHelpers.CumulateTask&lt;&gt;</span>
<span class="nc" id="L1614">                    (null, op, array, fromIndex, toIndex).invoke();</span>
<span class="nc" id="L1615">    }</span>

    /**
     * Cumulates, in parallel, each element of the given array in place,
     * using the supplied function. For example if the array initially
     * holds {@code [2, 1, 0, 3]} and the operation performs addition,
     * then upon return the array holds {@code [2, 3, 3, 6]}.
     * Parallel prefix computation is usually more efficient than
     * sequential loops for large arrays.
     *
     * @param array the array, which is modified in-place by this method
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(long[] array, LongBinaryOperator op) {
<span class="nc" id="L1632">        Objects.requireNonNull(op);</span>
<span class="nc bnc" id="L1633" title="All 2 branches missed.">        if (array.length &gt; 0)</span>
<span class="nc" id="L1634">            new ArrayPrefixHelpers.LongCumulateTask</span>
<span class="nc" id="L1635">                    (null, op, array, 0, array.length).invoke();</span>
<span class="nc" id="L1636">    }</span>

    /**
     * Performs {@link #parallelPrefix(long[], LongBinaryOperator)}
     * for the given subrange of the array.
     *
     * @param array the array
     * @param fromIndex the index of the first element, inclusive
     * @param toIndex the index of the last element, exclusive
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(long[] array, int fromIndex,
                                      int toIndex, LongBinaryOperator op) {
<span class="nc" id="L1655">        Objects.requireNonNull(op);</span>
<span class="nc" id="L1656">        rangeCheck(array.length, fromIndex, toIndex);</span>
<span class="nc bnc" id="L1657" title="All 2 branches missed.">        if (fromIndex &lt; toIndex)</span>
<span class="nc" id="L1658">            new ArrayPrefixHelpers.LongCumulateTask</span>
<span class="nc" id="L1659">                    (null, op, array, fromIndex, toIndex).invoke();</span>
<span class="nc" id="L1660">    }</span>

    /**
     * Cumulates, in parallel, each element of the given array in place,
     * using the supplied function. For example if the array initially
     * holds {@code [2.0, 1.0, 0.0, 3.0]} and the operation performs addition,
     * then upon return the array holds {@code [2.0, 3.0, 3.0, 6.0]}.
     * Parallel prefix computation is usually more efficient than
     * sequential loops for large arrays.
     *
     * &lt;p&gt; Because floating-point operations may not be strictly associative,
     * the returned result may not be identical to the value that would be
     * obtained if the operation was performed sequentially.
     *
     * @param array the array, which is modified in-place by this method
     * @param op a side-effect-free function to perform the cumulation
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(double[] array, DoubleBinaryOperator op) {
<span class="nc" id="L1680">        Objects.requireNonNull(op);</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">        if (array.length &gt; 0)</span>
<span class="nc" id="L1682">            new ArrayPrefixHelpers.DoubleCumulateTask</span>
<span class="nc" id="L1683">                    (null, op, array, 0, array.length).invoke();</span>
<span class="nc" id="L1684">    }</span>

    /**
     * Performs {@link #parallelPrefix(double[], DoubleBinaryOperator)}
     * for the given subrange of the array.
     *
     * @param array the array
     * @param fromIndex the index of the first element, inclusive
     * @param toIndex the index of the last element, exclusive
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(double[] array, int fromIndex,
                                      int toIndex, DoubleBinaryOperator op) {
<span class="nc" id="L1703">        Objects.requireNonNull(op);</span>
<span class="nc" id="L1704">        rangeCheck(array.length, fromIndex, toIndex);</span>
<span class="nc bnc" id="L1705" title="All 2 branches missed.">        if (fromIndex &lt; toIndex)</span>
<span class="nc" id="L1706">            new ArrayPrefixHelpers.DoubleCumulateTask</span>
<span class="nc" id="L1707">                    (null, op, array, fromIndex, toIndex).invoke();</span>
<span class="nc" id="L1708">    }</span>

    /**
     * Cumulates, in parallel, each element of the given array in place,
     * using the supplied function. For example if the array initially
     * holds {@code [2, 1, 0, 3]} and the operation performs addition,
     * then upon return the array holds {@code [2, 3, 3, 6]}.
     * Parallel prefix computation is usually more efficient than
     * sequential loops for large arrays.
     *
     * @param array the array, which is modified in-place by this method
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(int[] array, IntBinaryOperator op) {
<span class="nc" id="L1725">        Objects.requireNonNull(op);</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">        if (array.length &gt; 0)</span>
<span class="nc" id="L1727">            new ArrayPrefixHelpers.IntCumulateTask</span>
<span class="nc" id="L1728">                    (null, op, array, 0, array.length).invoke();</span>
<span class="nc" id="L1729">    }</span>

    /**
     * Performs {@link #parallelPrefix(int[], IntBinaryOperator)}
     * for the given subrange of the array.
     *
     * @param array the array
     * @param fromIndex the index of the first element, inclusive
     * @param toIndex the index of the last element, exclusive
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(int[] array, int fromIndex,
                                      int toIndex, IntBinaryOperator op) {
<span class="nc" id="L1748">        Objects.requireNonNull(op);</span>
<span class="nc" id="L1749">        rangeCheck(array.length, fromIndex, toIndex);</span>
<span class="nc bnc" id="L1750" title="All 2 branches missed.">        if (fromIndex &lt; toIndex)</span>
<span class="nc" id="L1751">            new ArrayPrefixHelpers.IntCumulateTask</span>
<span class="nc" id="L1752">                    (null, op, array, fromIndex, toIndex).invoke();</span>
<span class="nc" id="L1753">    }</span>

    // Searching

    /**
     * Searches the specified array of longs for the specified value using the
     * binary search algorithm.  The array must be sorted (as
     * by the {@link #sort(long[])} method) prior to making this call.  If it
     * is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(long[] a, long key) {
<span class="nc" id="L1777">        return binarySearch0(a, 0, a.length, key);</span>
    }

    /**
     * Searches a range of
     * the specified array of longs for the specified value using the
     * binary search algorithm.
     * The range must be sorted (as
     * by the {@link #sort(long[], int, int)} method)
     * prior to making this call.  If it
     * is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
     * @since 1.6
     */
    public static int binarySearch(long[] a, int fromIndex, int toIndex,
                                   long key) {
<span class="nc" id="L1814">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L1815">        return binarySearch0(a, fromIndex, toIndex, key);</span>
    }

    // Like public version, but without range checks.
    private static int binarySearch0(long[] a, int fromIndex, int toIndex,
                                     long key) {
<span class="nc" id="L1821">        int low = fromIndex;</span>
<span class="nc" id="L1822">        int high = toIndex - 1;</span>

<span class="nc bnc" id="L1824" title="All 2 branches missed.">        while (low &lt;= high) {</span>
<span class="nc" id="L1825">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L1826">            long midVal = a[mid];</span>

<span class="nc bnc" id="L1828" title="All 2 branches missed.">            if (midVal &lt; key)</span>
<span class="nc" id="L1829">                low = mid + 1;</span>
<span class="nc bnc" id="L1830" title="All 2 branches missed.">            else if (midVal &gt; key)</span>
<span class="nc" id="L1831">                high = mid - 1;</span>
            else
<span class="nc" id="L1833">                return mid; // key found</span>
<span class="nc" id="L1834">        }</span>
<span class="nc" id="L1835">        return -(low + 1);  // key not found.</span>
    }

    /**
     * Searches the specified array of ints for the specified value using the
     * binary search algorithm.  The array must be sorted (as
     * by the {@link #sort(int[])} method) prior to making this call.  If it
     * is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(int[] a, int key) {
<span class="fc" id="L1858">        return binarySearch0(a, 0, a.length, key);</span>
    }

    /**
     * Searches a range of
     * the specified array of ints for the specified value using the
     * binary search algorithm.
     * The range must be sorted (as
     * by the {@link #sort(int[], int, int)} method)
     * prior to making this call.  If it
     * is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
     * @since 1.6
     */
    public static int binarySearch(int[] a, int fromIndex, int toIndex,
                                   int key) {
<span class="fc" id="L1895">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="fc" id="L1896">        return binarySearch0(a, fromIndex, toIndex, key);</span>
    }

    // Like public version, but without range checks.
    private static int binarySearch0(int[] a, int fromIndex, int toIndex,
                                     int key) {
<span class="fc" id="L1902">        int low = fromIndex;</span>
<span class="fc" id="L1903">        int high = toIndex - 1;</span>

<span class="fc bfc" id="L1905" title="All 2 branches covered.">        while (low &lt;= high) {</span>
<span class="fc" id="L1906">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="fc" id="L1907">            int midVal = a[mid];</span>

<span class="fc bfc" id="L1909" title="All 2 branches covered.">            if (midVal &lt; key)</span>
<span class="fc" id="L1910">                low = mid + 1;</span>
<span class="fc bfc" id="L1911" title="All 2 branches covered.">            else if (midVal &gt; key)</span>
<span class="fc" id="L1912">                high = mid - 1;</span>
            else
<span class="fc" id="L1914">                return mid; // key found</span>
<span class="fc" id="L1915">        }</span>
<span class="fc" id="L1916">        return -(low + 1);  // key not found.</span>
    }

    /**
     * Searches the specified array of shorts for the specified value using
     * the binary search algorithm.  The array must be sorted
     * (as by the {@link #sort(short[])} method) prior to making this call.  If
     * it is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(short[] a, short key) {
<span class="nc" id="L1939">        return binarySearch0(a, 0, a.length, key);</span>
    }

    /**
     * Searches a range of
     * the specified array of shorts for the specified value using
     * the binary search algorithm.
     * The range must be sorted
     * (as by the {@link #sort(short[], int, int)} method)
     * prior to making this call.  If
     * it is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
     * @since 1.6
     */
    public static int binarySearch(short[] a, int fromIndex, int toIndex,
                                   short key) {
<span class="nc" id="L1976">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L1977">        return binarySearch0(a, fromIndex, toIndex, key);</span>
    }

    // Like public version, but without range checks.
    private static int binarySearch0(short[] a, int fromIndex, int toIndex,
                                     short key) {
<span class="nc" id="L1983">        int low = fromIndex;</span>
<span class="nc" id="L1984">        int high = toIndex - 1;</span>

<span class="nc bnc" id="L1986" title="All 2 branches missed.">        while (low &lt;= high) {</span>
<span class="nc" id="L1987">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L1988">            short midVal = a[mid];</span>

<span class="nc bnc" id="L1990" title="All 2 branches missed.">            if (midVal &lt; key)</span>
<span class="nc" id="L1991">                low = mid + 1;</span>
<span class="nc bnc" id="L1992" title="All 2 branches missed.">            else if (midVal &gt; key)</span>
<span class="nc" id="L1993">                high = mid - 1;</span>
            else
<span class="nc" id="L1995">                return mid; // key found</span>
<span class="nc" id="L1996">        }</span>
<span class="nc" id="L1997">        return -(low + 1);  // key not found.</span>
    }

    /**
     * Searches the specified array of chars for the specified value using the
     * binary search algorithm.  The array must be sorted (as
     * by the {@link #sort(char[])} method) prior to making this call.  If it
     * is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(char[] a, char key) {
<span class="nc" id="L2020">        return binarySearch0(a, 0, a.length, key);</span>
    }

    /**
     * Searches a range of
     * the specified array of chars for the specified value using the
     * binary search algorithm.
     * The range must be sorted (as
     * by the {@link #sort(char[], int, int)} method)
     * prior to making this call.  If it
     * is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
     * @since 1.6
     */
    public static int binarySearch(char[] a, int fromIndex, int toIndex,
                                   char key) {
<span class="nc" id="L2057">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L2058">        return binarySearch0(a, fromIndex, toIndex, key);</span>
    }

    // Like public version, but without range checks.
    private static int binarySearch0(char[] a, int fromIndex, int toIndex,
                                     char key) {
<span class="nc" id="L2064">        int low = fromIndex;</span>
<span class="nc" id="L2065">        int high = toIndex - 1;</span>

<span class="nc bnc" id="L2067" title="All 2 branches missed.">        while (low &lt;= high) {</span>
<span class="nc" id="L2068">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L2069">            char midVal = a[mid];</span>

<span class="nc bnc" id="L2071" title="All 2 branches missed.">            if (midVal &lt; key)</span>
<span class="nc" id="L2072">                low = mid + 1;</span>
<span class="nc bnc" id="L2073" title="All 2 branches missed.">            else if (midVal &gt; key)</span>
<span class="nc" id="L2074">                high = mid - 1;</span>
            else
<span class="nc" id="L2076">                return mid; // key found</span>
<span class="nc" id="L2077">        }</span>
<span class="nc" id="L2078">        return -(low + 1);  // key not found.</span>
    }

    /**
     * Searches the specified array of bytes for the specified value using the
     * binary search algorithm.  The array must be sorted (as
     * by the {@link #sort(byte[])} method) prior to making this call.  If it
     * is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(byte[] a, byte key) {
<span class="fc" id="L2101">        return binarySearch0(a, 0, a.length, key);</span>
    }

    /**
     * Searches a range of
     * the specified array of bytes for the specified value using the
     * binary search algorithm.
     * The range must be sorted (as
     * by the {@link #sort(byte[], int, int)} method)
     * prior to making this call.  If it
     * is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
     * @since 1.6
     */
    public static int binarySearch(byte[] a, int fromIndex, int toIndex,
                                   byte key) {
<span class="fc" id="L2138">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="fc" id="L2139">        return binarySearch0(a, fromIndex, toIndex, key);</span>
    }

    // Like public version, but without range checks.
    private static int binarySearch0(byte[] a, int fromIndex, int toIndex,
                                     byte key) {
<span class="fc" id="L2145">        int low = fromIndex;</span>
<span class="fc" id="L2146">        int high = toIndex - 1;</span>

<span class="pc bpc" id="L2148" title="1 of 2 branches missed.">        while (low &lt;= high) {</span>
<span class="fc" id="L2149">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="fc" id="L2150">            byte midVal = a[mid];</span>

<span class="fc bfc" id="L2152" title="All 2 branches covered.">            if (midVal &lt; key)</span>
<span class="fc" id="L2153">                low = mid + 1;</span>
<span class="fc bfc" id="L2154" title="All 2 branches covered.">            else if (midVal &gt; key)</span>
<span class="fc" id="L2155">                high = mid - 1;</span>
            else
<span class="fc" id="L2157">                return mid; // key found</span>
<span class="fc" id="L2158">        }</span>
<span class="nc" id="L2159">        return -(low + 1);  // key not found.</span>
    }

    /**
     * Searches the specified array of doubles for the specified value using
     * the binary search algorithm.  The array must be sorted
     * (as by the {@link #sort(double[])} method) prior to making this call.
     * If it is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.  This method considers all NaN values to be
     * equivalent and equal.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(double[] a, double key) {
<span class="nc" id="L2183">        return binarySearch0(a, 0, a.length, key);</span>
    }

    /**
     * Searches a range of
     * the specified array of doubles for the specified value using
     * the binary search algorithm.
     * The range must be sorted
     * (as by the {@link #sort(double[], int, int)} method)
     * prior to making this call.
     * If it is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.  This method considers all NaN values to be
     * equivalent and equal.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
     * @since 1.6
     */
    public static int binarySearch(double[] a, int fromIndex, int toIndex,
                                   double key) {
<span class="nc" id="L2221">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L2222">        return binarySearch0(a, fromIndex, toIndex, key);</span>
    }

    // Like public version, but without range checks.
    private static int binarySearch0(double[] a, int fromIndex, int toIndex,
                                     double key) {
<span class="nc" id="L2228">        int low = fromIndex;</span>
<span class="nc" id="L2229">        int high = toIndex - 1;</span>

<span class="nc bnc" id="L2231" title="All 2 branches missed.">        while (low &lt;= high) {</span>
<span class="nc" id="L2232">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L2233">            double midVal = a[mid];</span>

<span class="nc bnc" id="L2235" title="All 2 branches missed.">            if (midVal &lt; key)</span>
<span class="nc" id="L2236">                low = mid + 1;  // Neither val is NaN, thisVal is smaller</span>
<span class="nc bnc" id="L2237" title="All 2 branches missed.">            else if (midVal &gt; key)</span>
<span class="nc" id="L2238">                high = mid - 1; // Neither val is NaN, thisVal is larger</span>
            else {
<span class="nc" id="L2240">                long midBits = Double.doubleToLongBits(midVal);</span>
<span class="nc" id="L2241">                long keyBits = Double.doubleToLongBits(key);</span>
<span class="nc bnc" id="L2242" title="All 2 branches missed.">                if (midBits == keyBits)     // Values are equal</span>
<span class="nc" id="L2243">                    return mid;             // Key found</span>
<span class="nc bnc" id="L2244" title="All 2 branches missed.">                else if (midBits &lt; keyBits) // (-0.0, 0.0) or (!NaN, NaN)</span>
<span class="nc" id="L2245">                    low = mid + 1;</span>
                else                        // (0.0, -0.0) or (NaN, !NaN)
<span class="nc" id="L2247">                    high = mid - 1;</span>
            }
<span class="nc" id="L2249">        }</span>
<span class="nc" id="L2250">        return -(low + 1);  // key not found.</span>
    }

    /**
     * Searches the specified array of floats for the specified value using
     * the binary search algorithm. The array must be sorted
     * (as by the {@link #sort(float[])} method) prior to making this call. If
     * it is not sorted, the results are undefined. If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found. This method considers all NaN values to be
     * equivalent and equal.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;. The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key. Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(float[] a, float key) {
<span class="nc" id="L2274">        return binarySearch0(a, 0, a.length, key);</span>
    }

    /**
     * Searches a range of
     * the specified array of floats for the specified value using
     * the binary search algorithm.
     * The range must be sorted
     * (as by the {@link #sort(float[], int, int)} method)
     * prior to making this call. If
     * it is not sorted, the results are undefined. If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found. This method considers all NaN values to be
     * equivalent and equal.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;. The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key. Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
     * @since 1.6
     */
    public static int binarySearch(float[] a, int fromIndex, int toIndex,
                                   float key) {
<span class="nc" id="L2312">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L2313">        return binarySearch0(a, fromIndex, toIndex, key);</span>
    }

    // Like public version, but without range checks.
    private static int binarySearch0(float[] a, int fromIndex, int toIndex,
                                     float key) {
<span class="nc" id="L2319">        int low = fromIndex;</span>
<span class="nc" id="L2320">        int high = toIndex - 1;</span>

<span class="nc bnc" id="L2322" title="All 2 branches missed.">        while (low &lt;= high) {</span>
<span class="nc" id="L2323">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L2324">            float midVal = a[mid];</span>

<span class="nc bnc" id="L2326" title="All 2 branches missed.">            if (midVal &lt; key)</span>
<span class="nc" id="L2327">                low = mid + 1;  // Neither val is NaN, thisVal is smaller</span>
<span class="nc bnc" id="L2328" title="All 2 branches missed.">            else if (midVal &gt; key)</span>
<span class="nc" id="L2329">                high = mid - 1; // Neither val is NaN, thisVal is larger</span>
            else {
<span class="nc" id="L2331">                int midBits = Float.floatToIntBits(midVal);</span>
<span class="nc" id="L2332">                int keyBits = Float.floatToIntBits(key);</span>
<span class="nc bnc" id="L2333" title="All 2 branches missed.">                if (midBits == keyBits)     // Values are equal</span>
<span class="nc" id="L2334">                    return mid;             // Key found</span>
<span class="nc bnc" id="L2335" title="All 2 branches missed.">                else if (midBits &lt; keyBits) // (-0.0, 0.0) or (!NaN, NaN)</span>
<span class="nc" id="L2336">                    low = mid + 1;</span>
                else                        // (0.0, -0.0) or (NaN, !NaN)
<span class="nc" id="L2338">                    high = mid - 1;</span>
            }
<span class="nc" id="L2340">        }</span>
<span class="nc" id="L2341">        return -(low + 1);  // key not found.</span>
    }

    /**
     * Searches the specified array for the specified object using the binary
     * search algorithm. The array must be sorted into ascending order
     * according to the
     * {@linkplain Comparable natural ordering}
     * of its elements (as by the
     * {@link #sort(Object[])} method) prior to making this call.
     * If it is not sorted, the results are undefined.
     * (If the array contains elements that are not mutually comparable (for
     * example, strings and integers), it &lt;i&gt;cannot&lt;/i&gt; be sorted according
     * to the natural ordering of its elements, hence results are undefined.)
     * If the array contains multiple
     * elements equal to the specified object, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws ClassCastException if the search key is not comparable to the
     *         elements of the array.
     */
    public static int binarySearch(Object[] a, Object key) {
<span class="fc" id="L2373">        return binarySearch0(a, 0, a.length, key);</span>
    }

    /**
     * Searches a range of
     * the specified array for the specified object using the binary
     * search algorithm.
     * The range must be sorted into ascending order
     * according to the
     * {@linkplain Comparable natural ordering}
     * of its elements (as by the
     * {@link #sort(Object[], int, int)} method) prior to making this
     * call.  If it is not sorted, the results are undefined.
     * (If the range contains elements that are not mutually comparable (for
     * example, strings and integers), it &lt;i&gt;cannot&lt;/i&gt; be sorted according
     * to the natural ordering of its elements, hence results are undefined.)
     * If the range contains multiple
     * elements equal to the specified object, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws ClassCastException if the search key is not comparable to the
     *         elements of the array within the specified range.
     * @throws IllegalArgumentException
     *         if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
     * @since 1.6
     */
    public static int binarySearch(Object[] a, int fromIndex, int toIndex,
                                   Object key) {
<span class="fc" id="L2418">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="fc" id="L2419">        return binarySearch0(a, fromIndex, toIndex, key);</span>
    }

    // Like public version, but without range checks.
    private static int binarySearch0(Object[] a, int fromIndex, int toIndex,
                                     Object key) {
<span class="fc" id="L2425">        int low = fromIndex;</span>
<span class="fc" id="L2426">        int high = toIndex - 1;</span>

<span class="fc bfc" id="L2428" title="All 2 branches covered.">        while (low &lt;= high) {</span>
<span class="fc" id="L2429">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
            @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L2431">            Comparable midVal = (Comparable)a[mid];</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L2433">            int cmp = midVal.compareTo(key);</span>

<span class="fc bfc" id="L2435" title="All 2 branches covered.">            if (cmp &lt; 0)</span>
<span class="fc" id="L2436">                low = mid + 1;</span>
<span class="fc bfc" id="L2437" title="All 2 branches covered.">            else if (cmp &gt; 0)</span>
<span class="fc" id="L2438">                high = mid - 1;</span>
            else
<span class="fc" id="L2440">                return mid; // key found</span>
<span class="fc" id="L2441">        }</span>
<span class="fc" id="L2442">        return -(low + 1);  // key not found.</span>
    }

    /**
     * Searches the specified array for the specified object using the binary
     * search algorithm.  The array must be sorted into ascending order
     * according to the specified comparator (as by the
     * {@link #sort(Object[], Comparator) sort(T[], Comparator)}
     * method) prior to making this call.  If it is
     * not sorted, the results are undefined.
     * If the array contains multiple
     * elements equal to the specified object, there is no guarantee which one
     * will be found.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param a the array to be searched
     * @param key the value to be searched for
     * @param c the comparator by which the array is ordered.  A
     *        &lt;tt&gt;null&lt;/tt&gt; value indicates that the elements'
     *        {@linkplain Comparable natural ordering} should be used.
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws ClassCastException if the array contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator,
     *         or the search key is not comparable to the
     *         elements of the array using this comparator.
     */
    public static &lt;T&gt; int binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c) {
<span class="nc" id="L2476">        return binarySearch0(a, 0, a.length, key, c);</span>
    }

    /**
     * Searches a range of
     * the specified array for the specified object using the binary
     * search algorithm.
     * The range must be sorted into ascending order
     * according to the specified comparator (as by the
     * {@link #sort(Object[], int, int, Comparator)
     * sort(T[], int, int, Comparator)}
     * method) prior to making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements equal to the specified object,
     * there is no guarantee which one will be found.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @param c the comparator by which the array is ordered.  A
     *        &lt;tt&gt;null&lt;/tt&gt; value indicates that the elements'
     *        {@linkplain Comparable natural ordering} should be used.
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws ClassCastException if the range contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator,
     *         or the search key is not comparable to the
     *         elements in the range using this comparator.
     * @throws IllegalArgumentException
     *         if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
     * @since 1.6
     */
    public static &lt;T&gt; int binarySearch(T[] a, int fromIndex, int toIndex,
                                       T key, Comparator&lt;? super T&gt; c) {
<span class="nc" id="L2523">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc" id="L2524">        return binarySearch0(a, fromIndex, toIndex, key, c);</span>
    }

    // Like public version, but without range checks.
    private static &lt;T&gt; int binarySearch0(T[] a, int fromIndex, int toIndex,
                                         T key, Comparator&lt;? super T&gt; c) {
<span class="nc bnc" id="L2530" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2531">            return binarySearch0(a, fromIndex, toIndex, key);</span>
        }
<span class="nc" id="L2533">        int low = fromIndex;</span>
<span class="nc" id="L2534">        int high = toIndex - 1;</span>

<span class="nc bnc" id="L2536" title="All 2 branches missed.">        while (low &lt;= high) {</span>
<span class="nc" id="L2537">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L2538">            T midVal = a[mid];</span>
<span class="nc" id="L2539">            int cmp = c.compare(midVal, key);</span>
<span class="nc bnc" id="L2540" title="All 2 branches missed.">            if (cmp &lt; 0)</span>
<span class="nc" id="L2541">                low = mid + 1;</span>
<span class="nc bnc" id="L2542" title="All 2 branches missed.">            else if (cmp &gt; 0)</span>
<span class="nc" id="L2543">                high = mid - 1;</span>
            else
<span class="nc" id="L2545">                return mid; // key found</span>
<span class="nc" id="L2546">        }</span>
<span class="nc" id="L2547">        return -(low + 1);  // key not found.</span>
    }

    // Equality Testing

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of longs are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(long[] a, long[] a2) {
<span class="pc bpc" id="L2565" title="1 of 2 branches missed.">        if (a==a2)</span>
<span class="nc" id="L2566">            return true;</span>
<span class="pc bpc" id="L2567" title="2 of 4 branches missed.">        if (a==null || a2==null)</span>
<span class="nc" id="L2568">            return false;</span>

<span class="fc" id="L2570">        int length = a.length;</span>
<span class="pc bpc" id="L2571" title="1 of 2 branches missed.">        if (a2.length != length)</span>
<span class="nc" id="L2572">            return false;</span>

<span class="fc bfc" id="L2574" title="All 2 branches covered.">        for (int i=0; i&lt;length; i++)</span>
<span class="pc bpc" id="L2575" title="1 of 2 branches missed.">            if (a[i] != a2[i])</span>
<span class="nc" id="L2576">                return false;</span>

<span class="fc" id="L2578">        return true;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of ints are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(int[] a, int[] a2) {
<span class="fc bfc" id="L2594" title="All 2 branches covered.">        if (a==a2)</span>
<span class="fc" id="L2595">            return true;</span>
<span class="pc bpc" id="L2596" title="2 of 4 branches missed.">        if (a==null || a2==null)</span>
<span class="nc" id="L2597">            return false;</span>

<span class="fc" id="L2599">        int length = a.length;</span>
<span class="pc bpc" id="L2600" title="1 of 2 branches missed.">        if (a2.length != length)</span>
<span class="nc" id="L2601">            return false;</span>

<span class="fc bfc" id="L2603" title="All 2 branches covered.">        for (int i=0; i&lt;length; i++)</span>
<span class="pc bpc" id="L2604" title="1 of 2 branches missed.">            if (a[i] != a2[i])</span>
<span class="nc" id="L2605">                return false;</span>

<span class="fc" id="L2607">        return true;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of shorts are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(short[] a, short a2[]) {
<span class="nc bnc" id="L2623" title="All 2 branches missed.">        if (a==a2)</span>
<span class="nc" id="L2624">            return true;</span>
<span class="nc bnc" id="L2625" title="All 4 branches missed.">        if (a==null || a2==null)</span>
<span class="nc" id="L2626">            return false;</span>

<span class="nc" id="L2628">        int length = a.length;</span>
<span class="nc bnc" id="L2629" title="All 2 branches missed.">        if (a2.length != length)</span>
<span class="nc" id="L2630">            return false;</span>

<span class="nc bnc" id="L2632" title="All 2 branches missed.">        for (int i=0; i&lt;length; i++)</span>
<span class="nc bnc" id="L2633" title="All 2 branches missed.">            if (a[i] != a2[i])</span>
<span class="nc" id="L2634">                return false;</span>

<span class="nc" id="L2636">        return true;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of chars are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(char[] a, char[] a2) {
<span class="pc bpc" id="L2652" title="1 of 2 branches missed.">        if (a==a2)</span>
<span class="nc" id="L2653">            return true;</span>
<span class="pc bpc" id="L2654" title="2 of 4 branches missed.">        if (a==null || a2==null)</span>
<span class="nc" id="L2655">            return false;</span>

<span class="fc" id="L2657">        int length = a.length;</span>
<span class="pc bpc" id="L2658" title="1 of 2 branches missed.">        if (a2.length != length)</span>
<span class="nc" id="L2659">            return false;</span>

<span class="fc bfc" id="L2661" title="All 2 branches covered.">        for (int i=0; i&lt;length; i++)</span>
<span class="fc bfc" id="L2662" title="All 2 branches covered.">            if (a[i] != a2[i])</span>
<span class="fc" id="L2663">                return false;</span>

<span class="fc" id="L2665">        return true;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of bytes are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(byte[] a, byte[] a2) {
<span class="fc bfc" id="L2681" title="All 2 branches covered.">        if (a==a2)</span>
<span class="fc" id="L2682">            return true;</span>
<span class="pc bpc" id="L2683" title="1 of 4 branches missed.">        if (a==null || a2==null)</span>
<span class="fc" id="L2684">            return false;</span>

<span class="fc" id="L2686">        int length = a.length;</span>
<span class="fc bfc" id="L2687" title="All 2 branches covered.">        if (a2.length != length)</span>
<span class="fc" id="L2688">            return false;</span>

<span class="fc bfc" id="L2690" title="All 2 branches covered.">        for (int i=0; i&lt;length; i++)</span>
<span class="fc bfc" id="L2691" title="All 2 branches covered.">            if (a[i] != a2[i])</span>
<span class="fc" id="L2692">                return false;</span>

<span class="fc" id="L2694">        return true;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of booleans are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(boolean[] a, boolean[] a2) {
<span class="pc bpc" id="L2710" title="1 of 2 branches missed.">        if (a==a2)</span>
<span class="nc" id="L2711">            return true;</span>
<span class="pc bpc" id="L2712" title="2 of 4 branches missed.">        if (a==null || a2==null)</span>
<span class="nc" id="L2713">            return false;</span>

<span class="fc" id="L2715">        int length = a.length;</span>
<span class="pc bpc" id="L2716" title="1 of 2 branches missed.">        if (a2.length != length)</span>
<span class="nc" id="L2717">            return false;</span>

<span class="fc bfc" id="L2719" title="All 2 branches covered.">        for (int i=0; i&lt;length; i++)</span>
<span class="fc bfc" id="L2720" title="All 2 branches covered.">            if (a[i] != a2[i])</span>
<span class="fc" id="L2721">                return false;</span>

<span class="fc" id="L2723">        return true;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of doubles are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * Two doubles &lt;tt&gt;d1&lt;/tt&gt; and &lt;tt&gt;d2&lt;/tt&gt; are considered equal if:
     * &lt;pre&gt;    &lt;tt&gt;new Double(d1).equals(new Double(d2))&lt;/tt&gt;&lt;/pre&gt;
     * (Unlike the &lt;tt&gt;==&lt;/tt&gt; operator, this method considers
     * &lt;tt&gt;NaN&lt;/tt&gt; equals to itself, and 0.0d unequal to -0.0d.)
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     * @see Double#equals(Object)
     */
    public static boolean equals(double[] a, double[] a2) {
<span class="nc bnc" id="L2745" title="All 2 branches missed.">        if (a==a2)</span>
<span class="nc" id="L2746">            return true;</span>
<span class="nc bnc" id="L2747" title="All 4 branches missed.">        if (a==null || a2==null)</span>
<span class="nc" id="L2748">            return false;</span>

<span class="nc" id="L2750">        int length = a.length;</span>
<span class="nc bnc" id="L2751" title="All 2 branches missed.">        if (a2.length != length)</span>
<span class="nc" id="L2752">            return false;</span>

<span class="nc bnc" id="L2754" title="All 2 branches missed.">        for (int i=0; i&lt;length; i++)</span>
<span class="nc bnc" id="L2755" title="All 2 branches missed.">            if (Double.doubleToLongBits(a[i])!=Double.doubleToLongBits(a2[i]))</span>
<span class="nc" id="L2756">                return false;</span>

<span class="nc" id="L2758">        return true;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of floats are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * Two floats &lt;tt&gt;f1&lt;/tt&gt; and &lt;tt&gt;f2&lt;/tt&gt; are considered equal if:
     * &lt;pre&gt;    &lt;tt&gt;new Float(f1).equals(new Float(f2))&lt;/tt&gt;&lt;/pre&gt;
     * (Unlike the &lt;tt&gt;==&lt;/tt&gt; operator, this method considers
     * &lt;tt&gt;NaN&lt;/tt&gt; equals to itself, and 0.0f unequal to -0.0f.)
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     * @see Float#equals(Object)
     */
    public static boolean equals(float[] a, float[] a2) {
<span class="pc bpc" id="L2780" title="1 of 2 branches missed.">        if (a==a2)</span>
<span class="nc" id="L2781">            return true;</span>
<span class="pc bpc" id="L2782" title="2 of 4 branches missed.">        if (a==null || a2==null)</span>
<span class="nc" id="L2783">            return false;</span>

<span class="fc" id="L2785">        int length = a.length;</span>
<span class="pc bpc" id="L2786" title="1 of 2 branches missed.">        if (a2.length != length)</span>
<span class="nc" id="L2787">            return false;</span>

<span class="fc bfc" id="L2789" title="All 2 branches covered.">        for (int i=0; i&lt;length; i++)</span>
<span class="pc bpc" id="L2790" title="1 of 2 branches missed.">            if (Float.floatToIntBits(a[i])!=Float.floatToIntBits(a2[i]))</span>
<span class="nc" id="L2791">                return false;</span>

<span class="fc" id="L2793">        return true;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of Objects are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  The two arrays are considered equal if
     * both arrays contain the same number of elements, and all corresponding
     * pairs of elements in the two arrays are equal.  Two objects &lt;tt&gt;e1&lt;/tt&gt;
     * and &lt;tt&gt;e2&lt;/tt&gt; are considered &lt;i&gt;equal&lt;/i&gt; if &lt;tt&gt;(e1==null ? e2==null
     * : e1.equals(e2))&lt;/tt&gt;.  In other words, the two arrays are equal if
     * they contain the same elements in the same order.  Also, two array
     * references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(Object[] a, Object[] a2) {
<span class="fc bfc" id="L2811" title="All 2 branches covered.">        if (a==a2)</span>
<span class="fc" id="L2812">            return true;</span>
<span class="pc bpc" id="L2813" title="1 of 4 branches missed.">        if (a==null || a2==null)</span>
<span class="fc" id="L2814">            return false;</span>

<span class="fc" id="L2816">        int length = a.length;</span>
<span class="fc bfc" id="L2817" title="All 2 branches covered.">        if (a2.length != length)</span>
<span class="fc" id="L2818">            return false;</span>

<span class="fc bfc" id="L2820" title="All 2 branches covered.">        for (int i=0; i&lt;length; i++) {</span>
<span class="fc" id="L2821">            Object o1 = a[i];</span>
<span class="fc" id="L2822">            Object o2 = a2[i];</span>
<span class="pc bpc" id="L2823" title="3 of 6 branches missed.">            if (!(o1==null ? o2==null : o1.equals(o2)))</span>
<span class="fc" id="L2824">                return false;</span>
        }

<span class="fc" id="L2827">        return true;</span>
    }

    // Filling

    /**
     * Assigns the specified long value to each element of the specified array
     * of longs.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(long[] a, long val) {
<span class="fc bfc" id="L2840" title="All 2 branches covered.">        for (int i = 0, len = a.length; i &lt; len; i++)</span>
<span class="fc" id="L2841">            a[i] = val;</span>
<span class="fc" id="L2842">    }</span>

    /**
     * Assigns the specified long value to each element of the specified
     * range of the specified array of longs.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(long[] a, int fromIndex, int toIndex, long val) {
<span class="nc" id="L2862">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc bnc" id="L2863" title="All 2 branches missed.">        for (int i = fromIndex; i &lt; toIndex; i++)</span>
<span class="nc" id="L2864">            a[i] = val;</span>
<span class="nc" id="L2865">    }</span>

    /**
     * Assigns the specified int value to each element of the specified array
     * of ints.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(int[] a, int val) {
<span class="fc bfc" id="L2875" title="All 2 branches covered.">        for (int i = 0, len = a.length; i &lt; len; i++)</span>
<span class="fc" id="L2876">            a[i] = val;</span>
<span class="fc" id="L2877">    }</span>

    /**
     * Assigns the specified int value to each element of the specified
     * range of the specified array of ints.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(int[] a, int fromIndex, int toIndex, int val) {
<span class="fc" id="L2897">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="fc bfc" id="L2898" title="All 2 branches covered.">        for (int i = fromIndex; i &lt; toIndex; i++)</span>
<span class="fc" id="L2899">            a[i] = val;</span>
<span class="fc" id="L2900">    }</span>

    /**
     * Assigns the specified short value to each element of the specified array
     * of shorts.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(short[] a, short val) {
<span class="nc bnc" id="L2910" title="All 2 branches missed.">        for (int i = 0, len = a.length; i &lt; len; i++)</span>
<span class="nc" id="L2911">            a[i] = val;</span>
<span class="nc" id="L2912">    }</span>

    /**
     * Assigns the specified short value to each element of the specified
     * range of the specified array of shorts.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(short[] a, int fromIndex, int toIndex, short val) {
<span class="nc" id="L2932">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc bnc" id="L2933" title="All 2 branches missed.">        for (int i = fromIndex; i &lt; toIndex; i++)</span>
<span class="nc" id="L2934">            a[i] = val;</span>
<span class="nc" id="L2935">    }</span>

    /**
     * Assigns the specified char value to each element of the specified array
     * of chars.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(char[] a, char val) {
<span class="fc bfc" id="L2945" title="All 2 branches covered.">        for (int i = 0, len = a.length; i &lt; len; i++)</span>
<span class="fc" id="L2946">            a[i] = val;</span>
<span class="fc" id="L2947">    }</span>

    /**
     * Assigns the specified char value to each element of the specified
     * range of the specified array of chars.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(char[] a, int fromIndex, int toIndex, char val) {
<span class="fc" id="L2967">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="fc bfc" id="L2968" title="All 2 branches covered.">        for (int i = fromIndex; i &lt; toIndex; i++)</span>
<span class="fc" id="L2969">            a[i] = val;</span>
<span class="fc" id="L2970">    }</span>

    /**
     * Assigns the specified byte value to each element of the specified array
     * of bytes.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(byte[] a, byte val) {
<span class="fc bfc" id="L2980" title="All 2 branches covered.">        for (int i = 0, len = a.length; i &lt; len; i++)</span>
<span class="fc" id="L2981">            a[i] = val;</span>
<span class="fc" id="L2982">    }</span>

    /**
     * Assigns the specified byte value to each element of the specified
     * range of the specified array of bytes.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(byte[] a, int fromIndex, int toIndex, byte val) {
<span class="fc" id="L3002">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="fc bfc" id="L3003" title="All 2 branches covered.">        for (int i = fromIndex; i &lt; toIndex; i++)</span>
<span class="fc" id="L3004">            a[i] = val;</span>
<span class="fc" id="L3005">    }</span>

    /**
     * Assigns the specified boolean value to each element of the specified
     * array of booleans.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(boolean[] a, boolean val) {
<span class="fc bfc" id="L3015" title="All 2 branches covered.">        for (int i = 0, len = a.length; i &lt; len; i++)</span>
<span class="fc" id="L3016">            a[i] = val;</span>
<span class="fc" id="L3017">    }</span>

    /**
     * Assigns the specified boolean value to each element of the specified
     * range of the specified array of booleans.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(boolean[] a, int fromIndex, int toIndex,
                            boolean val) {
<span class="nc" id="L3038">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc bnc" id="L3039" title="All 2 branches missed.">        for (int i = fromIndex; i &lt; toIndex; i++)</span>
<span class="nc" id="L3040">            a[i] = val;</span>
<span class="nc" id="L3041">    }</span>

    /**
     * Assigns the specified double value to each element of the specified
     * array of doubles.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(double[] a, double val) {
<span class="nc bnc" id="L3051" title="All 2 branches missed.">        for (int i = 0, len = a.length; i &lt; len; i++)</span>
<span class="nc" id="L3052">            a[i] = val;</span>
<span class="nc" id="L3053">    }</span>

    /**
     * Assigns the specified double value to each element of the specified
     * range of the specified array of doubles.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(double[] a, int fromIndex, int toIndex,double val){
<span class="nc" id="L3073">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc bnc" id="L3074" title="All 2 branches missed.">        for (int i = fromIndex; i &lt; toIndex; i++)</span>
<span class="nc" id="L3075">            a[i] = val;</span>
<span class="nc" id="L3076">    }</span>

    /**
     * Assigns the specified float value to each element of the specified array
     * of floats.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(float[] a, float val) {
<span class="nc bnc" id="L3086" title="All 2 branches missed.">        for (int i = 0, len = a.length; i &lt; len; i++)</span>
<span class="nc" id="L3087">            a[i] = val;</span>
<span class="nc" id="L3088">    }</span>

    /**
     * Assigns the specified float value to each element of the specified
     * range of the specified array of floats.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(float[] a, int fromIndex, int toIndex, float val) {
<span class="nc" id="L3108">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="nc bnc" id="L3109" title="All 2 branches missed.">        for (int i = fromIndex; i &lt; toIndex; i++)</span>
<span class="nc" id="L3110">            a[i] = val;</span>
<span class="nc" id="L3111">    }</span>

    /**
     * Assigns the specified Object reference to each element of the specified
     * array of Objects.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     * @throws ArrayStoreException if the specified value is not of a
     *         runtime type that can be stored in the specified array
     */
    public static void fill(Object[] a, Object val) {
<span class="fc bfc" id="L3123" title="All 2 branches covered.">        for (int i = 0, len = a.length; i &lt; len; i++)</span>
<span class="fc" id="L3124">            a[i] = val;</span>
<span class="fc" id="L3125">    }</span>

    /**
     * Assigns the specified Object reference to each element of the specified
     * range of the specified array of Objects.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     * @throws ArrayStoreException if the specified value is not of a
     *         runtime type that can be stored in the specified array
     */
    public static void fill(Object[] a, int fromIndex, int toIndex, Object val) {
<span class="fc" id="L3147">        rangeCheck(a.length, fromIndex, toIndex);</span>
<span class="fc bfc" id="L3148" title="All 2 branches covered.">        for (int i = fromIndex; i &lt; toIndex; i++)</span>
<span class="fc" id="L3149">            a[i] = val;</span>
<span class="fc" id="L3150">    }</span>

    // Cloning

    /**
     * Copies the specified array, truncating or padding with nulls (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     * The resulting array is of exactly the same class as the original array.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with nulls
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T[] copyOf(T[] original, int newLength) {
<span class="fc" id="L3175">        return (T[]) copyOf(original, newLength, original.getClass());</span>
    }

    /**
     * Copies the specified array, truncating or padding with nulls (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     * The resulting array is of the class &lt;tt&gt;newType&lt;/tt&gt;.
     *
     * @param &lt;U&gt; the class of the objects in the original array
     * @param &lt;T&gt; the class of the objects in the returned array
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @param newType the class of the copy to be returned
     * @return a copy of the original array, truncated or padded with nulls
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @throws ArrayStoreException if an element copied from
     *     &lt;tt&gt;original&lt;/tt&gt; is not of a runtime type that can be stored in
     *     an array of class &lt;tt&gt;newType&lt;/tt&gt;
     * @since 1.6
     */
    public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc bfc" id="L3204" title="All 2 branches covered.">        T[] copy = ((Object)newType == (Object)Object[].class)</span>
            ? (T[]) new Object[newLength]
<span class="fc" id="L3206">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span>
<span class="fc" id="L3207">        System.arraycopy(original, 0, copy, 0,</span>
<span class="fc" id="L3208">                         Math.min(original.length, newLength));</span>
<span class="fc" id="L3209">        return copy;</span>
    }

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;(byte)0&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static byte[] copyOf(byte[] original, int newLength) {
<span class="fc" id="L3230">        byte[] copy = new byte[newLength];</span>
<span class="fc" id="L3231">        System.arraycopy(original, 0, copy, 0,</span>
<span class="fc" id="L3232">                         Math.min(original.length, newLength));</span>
<span class="fc" id="L3233">        return copy;</span>
    }

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;(short)0&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static short[] copyOf(short[] original, int newLength) {
<span class="fc" id="L3254">        short[] copy = new short[newLength];</span>
<span class="fc" id="L3255">        System.arraycopy(original, 0, copy, 0,</span>
<span class="fc" id="L3256">                         Math.min(original.length, newLength));</span>
<span class="fc" id="L3257">        return copy;</span>
    }

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;0&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static int[] copyOf(int[] original, int newLength) {
<span class="fc" id="L3278">        int[] copy = new int[newLength];</span>
<span class="fc" id="L3279">        System.arraycopy(original, 0, copy, 0,</span>
<span class="fc" id="L3280">                         Math.min(original.length, newLength));</span>
<span class="fc" id="L3281">        return copy;</span>
    }

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;0L&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static long[] copyOf(long[] original, int newLength) {
<span class="fc" id="L3302">        long[] copy = new long[newLength];</span>
<span class="fc" id="L3303">        System.arraycopy(original, 0, copy, 0,</span>
<span class="fc" id="L3304">                         Math.min(original.length, newLength));</span>
<span class="fc" id="L3305">        return copy;</span>
    }

    /**
     * Copies the specified array, truncating or padding with null characters (if necessary)
     * so the copy has the specified length.  For all indices that are valid
     * in both the original array and the copy, the two arrays will contain
     * identical values.  For any indices that are valid in the copy but not
     * the original, the copy will contain &lt;tt&gt;'\\u000'&lt;/tt&gt;.  Such indices
     * will exist if and only if the specified length is greater than that of
     * the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with null characters
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static char[] copyOf(char[] original, int newLength) {
<span class="fc" id="L3326">        char[] copy = new char[newLength];</span>
<span class="fc" id="L3327">        System.arraycopy(original, 0, copy, 0,</span>
<span class="fc" id="L3328">                         Math.min(original.length, newLength));</span>
<span class="fc" id="L3329">        return copy;</span>
    }

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;0f&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static float[] copyOf(float[] original, int newLength) {
<span class="fc" id="L3350">        float[] copy = new float[newLength];</span>
<span class="fc" id="L3351">        System.arraycopy(original, 0, copy, 0,</span>
<span class="fc" id="L3352">                         Math.min(original.length, newLength));</span>
<span class="fc" id="L3353">        return copy;</span>
    }

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;0d&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static double[] copyOf(double[] original, int newLength) {
<span class="fc" id="L3374">        double[] copy = new double[newLength];</span>
<span class="fc" id="L3375">        System.arraycopy(original, 0, copy, 0,</span>
<span class="fc" id="L3376">                         Math.min(original.length, newLength));</span>
<span class="fc" id="L3377">        return copy;</span>
    }

    /**
     * Copies the specified array, truncating or padding with &lt;tt&gt;false&lt;/tt&gt; (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;false&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with false elements
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static boolean[] copyOf(boolean[] original, int newLength) {
<span class="fc" id="L3398">        boolean[] copy = new boolean[newLength];</span>
<span class="fc" id="L3399">        System.arraycopy(original, 0, copy, 0,</span>
<span class="fc" id="L3400">                         Math.min(original.length, newLength));</span>
<span class="fc" id="L3401">        return copy;</span>
    }

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;null&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     * &lt;p&gt;
     * The resulting array is of exactly the same class as the original array.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with nulls to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
     *     or {@code from &gt; original.length}
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to) {
<span class="fc" id="L3435">        return copyOfRange(original, from, to, (Class&lt;? extends T[]&gt;) original.getClass());</span>
    }

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;null&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     * The resulting array is of the class &lt;tt&gt;newType&lt;/tt&gt;.
     *
     * @param &lt;U&gt; the class of the objects in the original array
     * @param &lt;T&gt; the class of the objects in the returned array
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @param newType the class of the copy to be returned
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with nulls to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
     *     or {@code from &gt; original.length}
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @throws ArrayStoreException if an element copied from
     *     &lt;tt&gt;original&lt;/tt&gt; is not of a runtime type that can be stored in
     *     an array of class &lt;tt&gt;newType&lt;/tt&gt;.
     * @since 1.6
     */
    public static &lt;T,U&gt; T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]&gt; newType) {
<span class="fc" id="L3472">        int newLength = to - from;</span>
<span class="pc bpc" id="L3473" title="1 of 2 branches missed.">        if (newLength &lt; 0)</span>
<span class="nc" id="L3474">            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc bfc" id="L3476" title="All 2 branches covered.">        T[] copy = ((Object)newType == (Object)Object[].class)</span>
            ? (T[]) new Object[newLength]
<span class="fc" id="L3478">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span>
<span class="fc" id="L3479">        System.arraycopy(original, from, copy, 0,</span>
<span class="fc" id="L3480">                         Math.min(original.length - from, newLength));</span>
<span class="fc" id="L3481">        return copy;</span>
    }

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;(byte)0&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
     *     or {@code from &gt; original.length}
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static byte[] copyOfRange(byte[] original, int from, int to) {
<span class="fc" id="L3511">        int newLength = to - from;</span>
<span class="pc bpc" id="L3512" title="1 of 2 branches missed.">        if (newLength &lt; 0)</span>
<span class="nc" id="L3513">            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</span>
<span class="fc" id="L3514">        byte[] copy = new byte[newLength];</span>
<span class="fc" id="L3515">        System.arraycopy(original, from, copy, 0,</span>
<span class="fc" id="L3516">                         Math.min(original.length - from, newLength));</span>
<span class="fc" id="L3517">        return copy;</span>
    }

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;(short)0&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
     *     or {@code from &gt; original.length}
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static short[] copyOfRange(short[] original, int from, int to) {
<span class="fc" id="L3547">        int newLength = to - from;</span>
<span class="pc bpc" id="L3548" title="1 of 2 branches missed.">        if (newLength &lt; 0)</span>
<span class="nc" id="L3549">            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</span>
<span class="fc" id="L3550">        short[] copy = new short[newLength];</span>
<span class="fc" id="L3551">        System.arraycopy(original, from, copy, 0,</span>
<span class="fc" id="L3552">                         Math.min(original.length - from, newLength));</span>
<span class="fc" id="L3553">        return copy;</span>
    }

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;0&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
     *     or {@code from &gt; original.length}
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static int[] copyOfRange(int[] original, int from, int to) {
<span class="fc" id="L3583">        int newLength = to - from;</span>
<span class="pc bpc" id="L3584" title="1 of 2 branches missed.">        if (newLength &lt; 0)</span>
<span class="nc" id="L3585">            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</span>
<span class="fc" id="L3586">        int[] copy = new int[newLength];</span>
<span class="fc" id="L3587">        System.arraycopy(original, from, copy, 0,</span>
<span class="fc" id="L3588">                         Math.min(original.length - from, newLength));</span>
<span class="fc" id="L3589">        return copy;</span>
    }

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;0L&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
     *     or {@code from &gt; original.length}
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static long[] copyOfRange(long[] original, int from, int to) {
<span class="fc" id="L3619">        int newLength = to - from;</span>
<span class="pc bpc" id="L3620" title="1 of 2 branches missed.">        if (newLength &lt; 0)</span>
<span class="nc" id="L3621">            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</span>
<span class="fc" id="L3622">        long[] copy = new long[newLength];</span>
<span class="fc" id="L3623">        System.arraycopy(original, from, copy, 0,</span>
<span class="fc" id="L3624">                         Math.min(original.length - from, newLength));</span>
<span class="fc" id="L3625">        return copy;</span>
    }

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;'\\u000'&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with null characters to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
     *     or {@code from &gt; original.length}
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static char[] copyOfRange(char[] original, int from, int to) {
<span class="fc" id="L3655">        int newLength = to - from;</span>
<span class="pc bpc" id="L3656" title="1 of 2 branches missed.">        if (newLength &lt; 0)</span>
<span class="nc" id="L3657">            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</span>
<span class="fc" id="L3658">        char[] copy = new char[newLength];</span>
<span class="fc" id="L3659">        System.arraycopy(original, from, copy, 0,</span>
<span class="fc" id="L3660">                         Math.min(original.length - from, newLength));</span>
<span class="fc" id="L3661">        return copy;</span>
    }

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;0f&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
     *     or {@code from &gt; original.length}
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static float[] copyOfRange(float[] original, int from, int to) {
<span class="fc" id="L3691">        int newLength = to - from;</span>
<span class="pc bpc" id="L3692" title="1 of 2 branches missed.">        if (newLength &lt; 0)</span>
<span class="nc" id="L3693">            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</span>
<span class="fc" id="L3694">        float[] copy = new float[newLength];</span>
<span class="fc" id="L3695">        System.arraycopy(original, from, copy, 0,</span>
<span class="fc" id="L3696">                         Math.min(original.length - from, newLength));</span>
<span class="fc" id="L3697">        return copy;</span>
    }

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;0d&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
     *     or {@code from &gt; original.length}
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static double[] copyOfRange(double[] original, int from, int to) {
<span class="fc" id="L3727">        int newLength = to - from;</span>
<span class="pc bpc" id="L3728" title="1 of 2 branches missed.">        if (newLength &lt; 0)</span>
<span class="nc" id="L3729">            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</span>
<span class="fc" id="L3730">        double[] copy = new double[newLength];</span>
<span class="fc" id="L3731">        System.arraycopy(original, from, copy, 0,</span>
<span class="fc" id="L3732">                         Math.min(original.length - from, newLength));</span>
<span class="fc" id="L3733">        return copy;</span>
    }

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;false&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with false elements to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
     *     or {@code from &gt; original.length}
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static boolean[] copyOfRange(boolean[] original, int from, int to) {
<span class="fc" id="L3763">        int newLength = to - from;</span>
<span class="pc bpc" id="L3764" title="1 of 2 branches missed.">        if (newLength &lt; 0)</span>
<span class="nc" id="L3765">            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</span>
<span class="fc" id="L3766">        boolean[] copy = new boolean[newLength];</span>
<span class="fc" id="L3767">        System.arraycopy(original, from, copy, 0,</span>
<span class="fc" id="L3768">                         Math.min(original.length - from, newLength));</span>
<span class="fc" id="L3769">        return copy;</span>
    }

    // Misc

    /**
     * Returns a fixed-size list backed by the specified array.  (Changes to
     * the returned list &quot;write through&quot; to the array.)  This method acts
     * as bridge between array-based and collection-based APIs, in
     * combination with {@link Collection#toArray}.  The returned list is
     * serializable and implements {@link RandomAccess}.
     *
     * &lt;p&gt;This method also provides a convenient way to create a fixed-size
     * list initialized to contain several elements:
     * &lt;pre&gt;
     *     List&amp;lt;String&amp;gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param a the array by which the list will be backed
     * @return a list view of the specified array
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
<span class="fc" id="L3794">        return new ArrayList&lt;&gt;(a);</span>
    }

    /**
     * @serial include
     */
    private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements RandomAccess, java.io.Serializable
    {
        private static final long serialVersionUID = -2764017481108945198L;
        private final E[] a;

<span class="fc" id="L3806">        ArrayList(E[] array) {</span>
<span class="fc" id="L3807">            a = Objects.requireNonNull(array);</span>
<span class="fc" id="L3808">        }</span>

        @Override
        public int size() {
<span class="fc" id="L3812">            return a.length;</span>
        }

        @Override
        public Object[] toArray() {
<span class="fc" id="L3817">            return a.clone();</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;T&gt; T[] toArray(T[] a) {
<span class="fc" id="L3823">            int size = size();</span>
<span class="fc bfc" id="L3824" title="All 2 branches covered.">            if (a.length &lt; size)</span>
<span class="fc" id="L3825">                return Arrays.copyOf(this.a, size,</span>
<span class="fc" id="L3826">                                     (Class&lt;? extends T[]&gt;) a.getClass());</span>
<span class="fc" id="L3827">            System.arraycopy(this.a, 0, a, 0, size);</span>
<span class="fc bfc" id="L3828" title="All 2 branches covered.">            if (a.length &gt; size)</span>
<span class="fc" id="L3829">                a[size] = null;</span>
<span class="fc" id="L3830">            return a;</span>
        }

        @Override
        public E get(int index) {
<span class="fc" id="L3835">            return a[index];</span>
        }

        @Override
        public E set(int index, E element) {
<span class="fc" id="L3840">            E oldValue = a[index];</span>
<span class="fc" id="L3841">            a[index] = element;</span>
<span class="fc" id="L3842">            return oldValue;</span>
        }

        @Override
        public int indexOf(Object o) {
<span class="pc bpc" id="L3847" title="1 of 2 branches missed.">            if (o==null) {</span>
<span class="nc bnc" id="L3848" title="All 2 branches missed.">                for (int i=0; i&lt;a.length; i++)</span>
<span class="nc bnc" id="L3849" title="All 2 branches missed.">                    if (a[i]==null)</span>
<span class="nc" id="L3850">                        return i;</span>
            } else {
<span class="fc bfc" id="L3852" title="All 2 branches covered.">                for (int i=0; i&lt;a.length; i++)</span>
<span class="fc bfc" id="L3853" title="All 2 branches covered.">                    if (o.equals(a[i]))</span>
<span class="fc" id="L3854">                        return i;</span>
            }
<span class="fc" id="L3856">            return -1;</span>
        }

        @Override
        public boolean contains(Object o) {
<span class="fc bfc" id="L3861" title="All 2 branches covered.">            return indexOf(o) != -1;</span>
        }

        @Override
        public Spliterator&lt;E&gt; spliterator() {
<span class="fc" id="L3866">            return Spliterators.spliterator(a, Spliterator.ORDERED);</span>
        }
    }

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;long&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}
     * method on a {@link List} containing a sequence of {@link Long}
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(long a[]) {
<span class="nc bnc" id="L3887" title="All 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L3888">            return 0;</span>

<span class="nc" id="L3890">        int result = 1;</span>
<span class="nc bnc" id="L3891" title="All 2 branches missed.">        for (long element : a) {</span>
<span class="nc" id="L3892">            int elementHash = (int)(element ^ (element &gt;&gt;&gt; 32));</span>
<span class="nc" id="L3893">            result = 31 * result + elementHash;</span>
        }

<span class="nc" id="L3896">        return result;</span>
    }

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two non-null &lt;tt&gt;int&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}
     * method on a {@link List} containing a sequence of {@link Integer}
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(int a[]) {
<span class="pc bpc" id="L3916" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L3917">            return 0;</span>

<span class="fc" id="L3919">        int result = 1;</span>
<span class="pc bpc" id="L3920" title="1 of 2 branches missed.">        for (int element : a)</span>
<span class="nc" id="L3921">            result = 31 * result + element;</span>

<span class="fc" id="L3923">        return result;</span>
    }

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;short&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}
     * method on a {@link List} containing a sequence of {@link Short}
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(short a[]) {
<span class="nc bnc" id="L3943" title="All 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L3944">            return 0;</span>

<span class="nc" id="L3946">        int result = 1;</span>
<span class="nc bnc" id="L3947" title="All 2 branches missed.">        for (short element : a)</span>
<span class="nc" id="L3948">            result = 31 * result + element;</span>

<span class="nc" id="L3950">        return result;</span>
    }

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;char&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}
     * method on a {@link List} containing a sequence of {@link Character}
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(char a[]) {
<span class="pc bpc" id="L3970" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L3971">            return 0;</span>

<span class="fc" id="L3973">        int result = 1;</span>
<span class="fc bfc" id="L3974" title="All 2 branches covered.">        for (char element : a)</span>
<span class="fc" id="L3975">            result = 31 * result + element;</span>

<span class="fc" id="L3977">        return result;</span>
    }

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;byte&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}
     * method on a {@link List} containing a sequence of {@link Byte}
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(byte a[]) {
<span class="fc bfc" id="L3997" title="All 2 branches covered.">        if (a == null)</span>
<span class="fc" id="L3998">            return 0;</span>

<span class="fc" id="L4000">        int result = 1;</span>
<span class="fc bfc" id="L4001" title="All 2 branches covered.">        for (byte element : a)</span>
<span class="fc" id="L4002">            result = 31 * result + element;</span>

<span class="fc" id="L4004">        return result;</span>
    }

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;boolean&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}
     * method on a {@link List} containing a sequence of {@link Boolean}
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(boolean a[]) {
<span class="pc bpc" id="L4024" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4025">            return 0;</span>

<span class="fc" id="L4027">        int result = 1;</span>
<span class="fc bfc" id="L4028" title="All 2 branches covered.">        for (boolean element : a)</span>
<span class="fc bfc" id="L4029" title="All 2 branches covered.">            result = 31 * result + (element ? 1231 : 1237);</span>

<span class="fc" id="L4031">        return result;</span>
    }

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;float&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}
     * method on a {@link List} containing a sequence of {@link Float}
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(float a[]) {
<span class="nc bnc" id="L4051" title="All 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4052">            return 0;</span>

<span class="nc" id="L4054">        int result = 1;</span>
<span class="nc bnc" id="L4055" title="All 2 branches missed.">        for (float element : a)</span>
<span class="nc" id="L4056">            result = 31 * result + Float.floatToIntBits(element);</span>

<span class="nc" id="L4058">        return result;</span>
    }

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;double&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}
     * method on a {@link List} containing a sequence of {@link Double}
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(double a[]) {
<span class="nc bnc" id="L4078" title="All 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4079">            return 0;</span>

<span class="nc" id="L4081">        int result = 1;</span>
<span class="nc bnc" id="L4082" title="All 2 branches missed.">        for (double element : a) {</span>
<span class="nc" id="L4083">            long bits = Double.doubleToLongBits(element);</span>
<span class="nc" id="L4084">            result = 31 * result + (int)(bits ^ (bits &gt;&gt;&gt; 32));</span>
        }
<span class="nc" id="L4086">        return result;</span>
    }

    /**
     * Returns a hash code based on the contents of the specified array.  If
     * the array contains other arrays as elements, the hash code is based on
     * their identities rather than their contents.  It is therefore
     * acceptable to invoke this method on an array that contains itself as an
     * element,  either directly or indirectly through one or more levels of
     * arrays.
     *
     * &lt;p&gt;For any two arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; such that
     * &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is equal to the value that would
     * be returned by &lt;tt&gt;Arrays.asList(a).hashCode()&lt;/tt&gt;, unless &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;, in which case &lt;tt&gt;0&lt;/tt&gt; is returned.
     *
     * @param a the array whose content-based hash code to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @see #deepHashCode(Object[])
     * @since 1.5
     */
    public static int hashCode(Object a[]) {
<span class="fc bfc" id="L4111" title="All 2 branches covered.">        if (a == null)</span>
<span class="fc" id="L4112">            return 0;</span>

<span class="fc" id="L4114">        int result = 1;</span>

<span class="fc bfc" id="L4116" title="All 2 branches covered.">        for (Object element : a)</span>
<span class="fc bfc" id="L4117" title="All 2 branches covered.">            result = 31 * result + (element == null ? 0 : element.hashCode());</span>

<span class="fc" id="L4119">        return result;</span>
    }

    /**
     * Returns a hash code based on the &quot;deep contents&quot; of the specified
     * array.  If the array contains other arrays as elements, the
     * hash code is based on their contents and so on, ad infinitum.
     * It is therefore unacceptable to invoke this method on an array that
     * contains itself as an element, either directly or indirectly through
     * one or more levels of arrays.  The behavior of such an invocation is
     * undefined.
     *
     * &lt;p&gt;For any two arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; such that
     * &lt;tt&gt;Arrays.deepEquals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.deepHashCode(a) == Arrays.deepHashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The computation of the value returned by this method is similar to
     * that of the value returned by {@link List#hashCode()} on a list
     * containing the same elements as &lt;tt&gt;a&lt;/tt&gt; in the same order, with one
     * difference: If an element &lt;tt&gt;e&lt;/tt&gt; of &lt;tt&gt;a&lt;/tt&gt; is itself an array,
     * its hash code is computed not by calling &lt;tt&gt;e.hashCode()&lt;/tt&gt;, but as
     * by calling the appropriate overloading of &lt;tt&gt;Arrays.hashCode(e)&lt;/tt&gt;
     * if &lt;tt&gt;e&lt;/tt&gt; is an array of a primitive type, or as by calling
     * &lt;tt&gt;Arrays.deepHashCode(e)&lt;/tt&gt; recursively if &lt;tt&gt;e&lt;/tt&gt; is an array
     * of a reference type.  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method
     * returns 0.
     *
     * @param a the array whose deep-content-based hash code to compute
     * @return a deep-content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @see #hashCode(Object[])
     * @since 1.5
     */
    public static int deepHashCode(Object a[]) {
<span class="pc bpc" id="L4152" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4153">            return 0;</span>

<span class="fc" id="L4155">        int result = 1;</span>

<span class="pc bpc" id="L4157" title="1 of 2 branches missed.">        for (Object element : a) {</span>
<span class="nc" id="L4158">            int elementHash = 0;</span>
<span class="nc bnc" id="L4159" title="All 2 branches missed.">            if (element instanceof Object[])</span>
<span class="nc" id="L4160">                elementHash = deepHashCode((Object[]) element);</span>
<span class="nc bnc" id="L4161" title="All 2 branches missed.">            else if (element instanceof byte[])</span>
<span class="nc" id="L4162">                elementHash = hashCode((byte[]) element);</span>
<span class="nc bnc" id="L4163" title="All 2 branches missed.">            else if (element instanceof short[])</span>
<span class="nc" id="L4164">                elementHash = hashCode((short[]) element);</span>
<span class="nc bnc" id="L4165" title="All 2 branches missed.">            else if (element instanceof int[])</span>
<span class="nc" id="L4166">                elementHash = hashCode((int[]) element);</span>
<span class="nc bnc" id="L4167" title="All 2 branches missed.">            else if (element instanceof long[])</span>
<span class="nc" id="L4168">                elementHash = hashCode((long[]) element);</span>
<span class="nc bnc" id="L4169" title="All 2 branches missed.">            else if (element instanceof char[])</span>
<span class="nc" id="L4170">                elementHash = hashCode((char[]) element);</span>
<span class="nc bnc" id="L4171" title="All 2 branches missed.">            else if (element instanceof float[])</span>
<span class="nc" id="L4172">                elementHash = hashCode((float[]) element);</span>
<span class="nc bnc" id="L4173" title="All 2 branches missed.">            else if (element instanceof double[])</span>
<span class="nc" id="L4174">                elementHash = hashCode((double[]) element);</span>
<span class="nc bnc" id="L4175" title="All 2 branches missed.">            else if (element instanceof boolean[])</span>
<span class="nc" id="L4176">                elementHash = hashCode((boolean[]) element);</span>
<span class="nc bnc" id="L4177" title="All 2 branches missed.">            else if (element != null)</span>
<span class="nc" id="L4178">                elementHash = element.hashCode();</span>

<span class="nc" id="L4180">            result = 31 * result + elementHash;</span>
        }

<span class="fc" id="L4183">        return result;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays are &lt;i&gt;deeply
     * equal&lt;/i&gt; to one another.  Unlike the {@link #equals(Object[],Object[])}
     * method, this method is appropriate for use with nested arrays of
     * arbitrary depth.
     *
     * &lt;p&gt;Two array references are considered deeply equal if both
     * are &lt;tt&gt;null&lt;/tt&gt;, or if they refer to arrays that contain the same
     * number of elements and all corresponding pairs of elements in the two
     * arrays are deeply equal.
     *
     * &lt;p&gt;Two possibly &lt;tt&gt;null&lt;/tt&gt; elements &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are
     * deeply equal if any of the following conditions hold:
     * &lt;ul&gt;
     *    &lt;li&gt; &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are both arrays of object reference
     *         types, and &lt;tt&gt;Arrays.deepEquals(e1, e2) would return true&lt;/tt&gt;
     *    &lt;li&gt; &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are arrays of the same primitive
     *         type, and the appropriate overloading of
     *         &lt;tt&gt;Arrays.equals(e1, e2)&lt;/tt&gt; would return true.
     *    &lt;li&gt; &lt;tt&gt;e1 == e2&lt;/tt&gt;
     *    &lt;li&gt; &lt;tt&gt;e1.equals(e2)&lt;/tt&gt; would return true.
     * &lt;/ul&gt;
     * Note that this definition permits &lt;tt&gt;null&lt;/tt&gt; elements at any depth.
     *
     * &lt;p&gt;If either of the specified arrays contain themselves as elements
     * either directly or indirectly through one or more levels of arrays,
     * the behavior of this method is undefined.
     *
     * @param a1 one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     * @see #equals(Object[],Object[])
     * @see Objects#deepEquals(Object, Object)
     * @since 1.5
     */
    public static boolean deepEquals(Object[] a1, Object[] a2) {
<span class="fc bfc" id="L4222" title="All 2 branches covered.">        if (a1 == a2)</span>
<span class="fc" id="L4223">            return true;</span>
<span class="pc bpc" id="L4224" title="2 of 4 branches missed.">        if (a1 == null || a2==null)</span>
<span class="nc" id="L4225">            return false;</span>
<span class="fc" id="L4226">        int length = a1.length;</span>
<span class="fc bfc" id="L4227" title="All 2 branches covered.">        if (a2.length != length)</span>
<span class="fc" id="L4228">            return false;</span>

<span class="fc bfc" id="L4230" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L4231">            Object e1 = a1[i];</span>
<span class="fc" id="L4232">            Object e2 = a2[i];</span>

<span class="fc bfc" id="L4234" title="All 2 branches covered.">            if (e1 == e2)</span>
<span class="fc" id="L4235">                continue;</span>
<span class="pc bpc" id="L4236" title="1 of 2 branches missed.">            if (e1 == null)</span>
<span class="nc" id="L4237">                return false;</span>

            // Figure out whether the two elements are equal
<span class="fc" id="L4240">            boolean eq = deepEquals0(e1, e2);</span>

<span class="pc bpc" id="L4242" title="1 of 2 branches missed.">            if (!eq)</span>
<span class="nc" id="L4243">                return false;</span>
        }
<span class="fc" id="L4245">        return true;</span>
    }

    static boolean deepEquals0(Object e1, Object e2) {
<span class="pc bpc" id="L4249" title="2 of 4 branches missed.">        assert e1 != null;</span>
        boolean eq;
<span class="fc bfc" id="L4251" title="All 4 branches covered.">        if (e1 instanceof Object[] &amp;&amp; e2 instanceof Object[])</span>
<span class="fc" id="L4252">            eq = deepEquals ((Object[]) e1, (Object[]) e2);</span>
<span class="fc bfc" id="L4253" title="All 4 branches covered.">        else if (e1 instanceof byte[] &amp;&amp; e2 instanceof byte[])</span>
<span class="fc" id="L4254">            eq = equals((byte[]) e1, (byte[]) e2);</span>
<span class="pc bpc" id="L4255" title="1 of 4 branches missed.">        else if (e1 instanceof short[] &amp;&amp; e2 instanceof short[])</span>
<span class="nc" id="L4256">            eq = equals((short[]) e1, (short[]) e2);</span>
<span class="fc bfc" id="L4257" title="All 4 branches covered.">        else if (e1 instanceof int[] &amp;&amp; e2 instanceof int[])</span>
<span class="fc" id="L4258">            eq = equals((int[]) e1, (int[]) e2);</span>
<span class="fc bfc" id="L4259" title="All 4 branches covered.">        else if (e1 instanceof long[] &amp;&amp; e2 instanceof long[])</span>
<span class="fc" id="L4260">            eq = equals((long[]) e1, (long[]) e2);</span>
<span class="fc bfc" id="L4261" title="All 4 branches covered.">        else if (e1 instanceof char[] &amp;&amp; e2 instanceof char[])</span>
<span class="fc" id="L4262">            eq = equals((char[]) e1, (char[]) e2);</span>
<span class="fc bfc" id="L4263" title="All 4 branches covered.">        else if (e1 instanceof float[] &amp;&amp; e2 instanceof float[])</span>
<span class="fc" id="L4264">            eq = equals((float[]) e1, (float[]) e2);</span>
<span class="pc bpc" id="L4265" title="1 of 4 branches missed.">        else if (e1 instanceof double[] &amp;&amp; e2 instanceof double[])</span>
<span class="nc" id="L4266">            eq = equals((double[]) e1, (double[]) e2);</span>
<span class="pc bpc" id="L4267" title="1 of 4 branches missed.">        else if (e1 instanceof boolean[] &amp;&amp; e2 instanceof boolean[])</span>
<span class="fc" id="L4268">            eq = equals((boolean[]) e1, (boolean[]) e2);</span>
        else
<span class="fc" id="L4270">            eq = e1.equals(e2);</span>
<span class="fc" id="L4271">        return eq;</span>
    }

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array's elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(long)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(long[] a) {
<span class="pc bpc" id="L4288" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4289">            return &quot;null&quot;;</span>
<span class="fc" id="L4290">        int iMax = a.length - 1;</span>
<span class="fc bfc" id="L4291" title="All 2 branches covered.">        if (iMax == -1)</span>
<span class="fc" id="L4292">            return &quot;[]&quot;;</span>

<span class="fc" id="L4294">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L4295">        b.append('[');</span>
<span class="fc" id="L4296">        for (int i = 0; ; i++) {</span>
<span class="fc" id="L4297">            b.append(a[i]);</span>
<span class="fc bfc" id="L4298" title="All 2 branches covered.">            if (i == iMax)</span>
<span class="fc" id="L4299">                return b.append(']').toString();</span>
<span class="fc" id="L4300">            b.append(&quot;, &quot;);</span>
        }
    }

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array's elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(int)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt; is
     * &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(int[] a) {
<span class="pc bpc" id="L4318" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4319">            return &quot;null&quot;;</span>
<span class="fc" id="L4320">        int iMax = a.length - 1;</span>
<span class="fc bfc" id="L4321" title="All 2 branches covered.">        if (iMax == -1)</span>
<span class="fc" id="L4322">            return &quot;[]&quot;;</span>

<span class="fc" id="L4324">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L4325">        b.append('[');</span>
<span class="fc" id="L4326">        for (int i = 0; ; i++) {</span>
<span class="fc" id="L4327">            b.append(a[i]);</span>
<span class="fc bfc" id="L4328" title="All 2 branches covered.">            if (i == iMax)</span>
<span class="fc" id="L4329">                return b.append(']').toString();</span>
<span class="fc" id="L4330">            b.append(&quot;, &quot;);</span>
        }
    }

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array's elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(short)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(short[] a) {
<span class="pc bpc" id="L4348" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4349">            return &quot;null&quot;;</span>
<span class="fc" id="L4350">        int iMax = a.length - 1;</span>
<span class="fc bfc" id="L4351" title="All 2 branches covered.">        if (iMax == -1)</span>
<span class="fc" id="L4352">            return &quot;[]&quot;;</span>

<span class="fc" id="L4354">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L4355">        b.append('[');</span>
<span class="fc" id="L4356">        for (int i = 0; ; i++) {</span>
<span class="fc" id="L4357">            b.append(a[i]);</span>
<span class="fc bfc" id="L4358" title="All 2 branches covered.">            if (i == iMax)</span>
<span class="fc" id="L4359">                return b.append(']').toString();</span>
<span class="fc" id="L4360">            b.append(&quot;, &quot;);</span>
        }
    }

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array's elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(char)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(char[] a) {
<span class="pc bpc" id="L4378" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4379">            return &quot;null&quot;;</span>
<span class="fc" id="L4380">        int iMax = a.length - 1;</span>
<span class="fc bfc" id="L4381" title="All 2 branches covered.">        if (iMax == -1)</span>
<span class="fc" id="L4382">            return &quot;[]&quot;;</span>

<span class="fc" id="L4384">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L4385">        b.append('[');</span>
<span class="fc" id="L4386">        for (int i = 0; ; i++) {</span>
<span class="fc" id="L4387">            b.append(a[i]);</span>
<span class="fc bfc" id="L4388" title="All 2 branches covered.">            if (i == iMax)</span>
<span class="fc" id="L4389">                return b.append(']').toString();</span>
<span class="fc" id="L4390">            b.append(&quot;, &quot;);</span>
        }
    }

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array's elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements
     * are separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed
     * by a space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(byte)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if
     * &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(byte[] a) {
<span class="fc bfc" id="L4408" title="All 2 branches covered.">        if (a == null)</span>
<span class="fc" id="L4409">            return &quot;null&quot;;</span>
<span class="fc" id="L4410">        int iMax = a.length - 1;</span>
<span class="fc bfc" id="L4411" title="All 2 branches covered.">        if (iMax == -1)</span>
<span class="fc" id="L4412">            return &quot;[]&quot;;</span>

<span class="fc" id="L4414">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L4415">        b.append('[');</span>
<span class="fc" id="L4416">        for (int i = 0; ; i++) {</span>
<span class="fc" id="L4417">            b.append(a[i]);</span>
<span class="fc bfc" id="L4418" title="All 2 branches covered.">            if (i == iMax)</span>
<span class="fc" id="L4419">                return b.append(']').toString();</span>
<span class="fc" id="L4420">            b.append(&quot;, &quot;);</span>
        }
    }

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array's elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(boolean)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if
     * &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(boolean[] a) {
<span class="pc bpc" id="L4438" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4439">            return &quot;null&quot;;</span>
<span class="fc" id="L4440">        int iMax = a.length - 1;</span>
<span class="fc bfc" id="L4441" title="All 2 branches covered.">        if (iMax == -1)</span>
<span class="fc" id="L4442">            return &quot;[]&quot;;</span>

<span class="fc" id="L4444">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L4445">        b.append('[');</span>
<span class="fc" id="L4446">        for (int i = 0; ; i++) {</span>
<span class="fc" id="L4447">            b.append(a[i]);</span>
<span class="fc bfc" id="L4448" title="All 2 branches covered.">            if (i == iMax)</span>
<span class="fc" id="L4449">                return b.append(']').toString();</span>
<span class="fc" id="L4450">            b.append(&quot;, &quot;);</span>
        }
    }

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array's elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(float)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(float[] a) {
<span class="pc bpc" id="L4468" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4469">            return &quot;null&quot;;</span>

<span class="fc" id="L4471">        int iMax = a.length - 1;</span>
<span class="fc bfc" id="L4472" title="All 2 branches covered.">        if (iMax == -1)</span>
<span class="fc" id="L4473">            return &quot;[]&quot;;</span>

<span class="fc" id="L4475">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L4476">        b.append('[');</span>
<span class="fc" id="L4477">        for (int i = 0; ; i++) {</span>
<span class="fc" id="L4478">            b.append(a[i]);</span>
<span class="fc bfc" id="L4479" title="All 2 branches covered.">            if (i == iMax)</span>
<span class="fc" id="L4480">                return b.append(']').toString();</span>
<span class="fc" id="L4481">            b.append(&quot;, &quot;);</span>
        }
    }

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array's elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(double)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(double[] a) {
<span class="pc bpc" id="L4499" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4500">            return &quot;null&quot;;</span>
<span class="fc" id="L4501">        int iMax = a.length - 1;</span>
<span class="fc bfc" id="L4502" title="All 2 branches covered.">        if (iMax == -1)</span>
<span class="fc" id="L4503">            return &quot;[]&quot;;</span>

<span class="fc" id="L4505">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L4506">        b.append('[');</span>
<span class="fc" id="L4507">        for (int i = 0; ; i++) {</span>
<span class="fc" id="L4508">            b.append(a[i]);</span>
<span class="fc bfc" id="L4509" title="All 2 branches covered.">            if (i == iMax)</span>
<span class="fc" id="L4510">                return b.append(']').toString();</span>
<span class="fc" id="L4511">            b.append(&quot;, &quot;);</span>
        }
    }

    /**
     * Returns a string representation of the contents of the specified array.
     * If the array contains other arrays as elements, they are converted to
     * strings by the {@link Object#toString} method inherited from
     * &lt;tt&gt;Object&lt;/tt&gt;, which describes their &lt;i&gt;identities&lt;/i&gt; rather than
     * their contents.
     *
     * &lt;p&gt;The value returned by this method is equal to the value that would
     * be returned by &lt;tt&gt;Arrays.asList(a).toString()&lt;/tt&gt;, unless &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;, in which case &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; is returned.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @see #deepToString(Object[])
     * @since 1.5
     */
    public static String toString(Object[] a) {
<span class="pc bpc" id="L4532" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4533">            return &quot;null&quot;;</span>

<span class="fc" id="L4535">        int iMax = a.length - 1;</span>
<span class="fc bfc" id="L4536" title="All 2 branches covered.">        if (iMax == -1)</span>
<span class="fc" id="L4537">            return &quot;[]&quot;;</span>

<span class="fc" id="L4539">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L4540">        b.append('[');</span>
<span class="fc" id="L4541">        for (int i = 0; ; i++) {</span>
<span class="fc" id="L4542">            b.append(String.valueOf(a[i]));</span>
<span class="fc bfc" id="L4543" title="All 2 branches covered.">            if (i == iMax)</span>
<span class="fc" id="L4544">                return b.append(']').toString();</span>
<span class="fc" id="L4545">            b.append(&quot;, &quot;);</span>
        }
    }

    /**
     * Returns a string representation of the &quot;deep contents&quot; of the specified
     * array.  If the array contains other arrays as elements, the string
     * representation contains their contents and so on.  This method is
     * designed for converting multidimensional arrays to strings.
     *
     * &lt;p&gt;The string representation consists of a list of the array's
     * elements, enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent
     * elements are separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma
     * followed by a space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(Object)&lt;/tt&gt;, unless they are themselves
     * arrays.
     *
     * &lt;p&gt;If an element &lt;tt&gt;e&lt;/tt&gt; is an array of a primitive type, it is
     * converted to a string as by invoking the appropriate overloading of
     * &lt;tt&gt;Arrays.toString(e)&lt;/tt&gt;.  If an element &lt;tt&gt;e&lt;/tt&gt; is an array of a
     * reference type, it is converted to a string as by invoking
     * this method recursively.
     *
     * &lt;p&gt;To avoid infinite recursion, if the specified array contains itself
     * as an element, or contains an indirect reference to itself through one
     * or more levels of arrays, the self-reference is converted to the string
     * &lt;tt&gt;&quot;[...]&quot;&lt;/tt&gt;.  For example, an array containing only a reference
     * to itself would be rendered as &lt;tt&gt;&quot;[[...]]&quot;&lt;/tt&gt;.
     *
     * &lt;p&gt;This method returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if the specified array
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @see #toString(Object[])
     * @since 1.5
     */
    public static String deepToString(Object[] a) {
<span class="pc bpc" id="L4583" title="1 of 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L4584">            return &quot;null&quot;;</span>

<span class="fc" id="L4586">        int bufLen = 20 * a.length;</span>
<span class="pc bpc" id="L4587" title="1 of 4 branches missed.">        if (a.length != 0 &amp;&amp; bufLen &lt;= 0)</span>
<span class="nc" id="L4588">            bufLen = Integer.MAX_VALUE;</span>
<span class="fc" id="L4589">        StringBuilder buf = new StringBuilder(bufLen);</span>
<span class="fc" id="L4590">        deepToString(a, buf, new HashSet&lt;Object[]&gt;());</span>
<span class="fc" id="L4591">        return buf.toString();</span>
    }

    private static void deepToString(Object[] a, StringBuilder buf,
                                     Set&lt;Object[]&gt; dejaVu) {
<span class="pc bpc" id="L4596" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L4597">            buf.append(&quot;null&quot;);</span>
<span class="nc" id="L4598">            return;</span>
        }
<span class="fc" id="L4600">        int iMax = a.length - 1;</span>
<span class="fc bfc" id="L4601" title="All 2 branches covered.">        if (iMax == -1) {</span>
<span class="fc" id="L4602">            buf.append(&quot;[]&quot;);</span>
<span class="fc" id="L4603">            return;</span>
        }

<span class="fc" id="L4606">        dejaVu.add(a);</span>
<span class="fc" id="L4607">        buf.append('[');</span>
<span class="fc" id="L4608">        for (int i = 0; ; i++) {</span>

<span class="fc" id="L4610">            Object element = a[i];</span>
<span class="pc bpc" id="L4611" title="1 of 2 branches missed.">            if (element == null) {</span>
<span class="nc" id="L4612">                buf.append(&quot;null&quot;);</span>
            } else {
<span class="fc" id="L4614">                Class&lt;?&gt; eClass = element.getClass();</span>

<span class="pc bpc" id="L4616" title="1 of 2 branches missed.">                if (eClass.isArray()) {</span>
<span class="nc bnc" id="L4617" title="All 2 branches missed.">                    if (eClass == byte[].class)</span>
<span class="nc" id="L4618">                        buf.append(toString((byte[]) element));</span>
<span class="nc bnc" id="L4619" title="All 2 branches missed.">                    else if (eClass == short[].class)</span>
<span class="nc" id="L4620">                        buf.append(toString((short[]) element));</span>
<span class="nc bnc" id="L4621" title="All 2 branches missed.">                    else if (eClass == int[].class)</span>
<span class="nc" id="L4622">                        buf.append(toString((int[]) element));</span>
<span class="nc bnc" id="L4623" title="All 2 branches missed.">                    else if (eClass == long[].class)</span>
<span class="nc" id="L4624">                        buf.append(toString((long[]) element));</span>
<span class="nc bnc" id="L4625" title="All 2 branches missed.">                    else if (eClass == char[].class)</span>
<span class="nc" id="L4626">                        buf.append(toString((char[]) element));</span>
<span class="nc bnc" id="L4627" title="All 2 branches missed.">                    else if (eClass == float[].class)</span>
<span class="nc" id="L4628">                        buf.append(toString((float[]) element));</span>
<span class="nc bnc" id="L4629" title="All 2 branches missed.">                    else if (eClass == double[].class)</span>
<span class="nc" id="L4630">                        buf.append(toString((double[]) element));</span>
<span class="nc bnc" id="L4631" title="All 2 branches missed.">                    else if (eClass == boolean[].class)</span>
<span class="nc" id="L4632">                        buf.append(toString((boolean[]) element));</span>
                    else { // element is an array of object references
<span class="nc bnc" id="L4634" title="All 2 branches missed.">                        if (dejaVu.contains(element))</span>
<span class="nc" id="L4635">                            buf.append(&quot;[...]&quot;);</span>
                        else
<span class="nc" id="L4637">                            deepToString((Object[])element, buf, dejaVu);</span>
                    }
                } else {  // element is non-null and not an array
<span class="fc" id="L4640">                    buf.append(element.toString());</span>
                }
            }
<span class="fc bfc" id="L4643" title="All 2 branches covered.">            if (i == iMax)</span>
<span class="fc" id="L4644">                break;</span>
<span class="fc" id="L4645">            buf.append(&quot;, &quot;);</span>
        }
<span class="fc" id="L4647">        buf.append(']');</span>
<span class="fc" id="L4648">        dejaVu.remove(a);</span>
<span class="fc" id="L4649">    }</span>


    /**
     * Set all elements of the specified array, using the provided
     * generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, it is relayed to
     * the caller and the array is left in an indeterminate state.
     *
     * @param &lt;T&gt; type of elements of the array
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static &lt;T&gt; void setAll(T[] array, IntFunction&lt;? extends T&gt; generator) {
<span class="nc" id="L4667">        Objects.requireNonNull(generator);</span>
<span class="nc bnc" id="L4668" title="All 2 branches missed.">        for (int i = 0; i &lt; array.length; i++)</span>
<span class="nc" id="L4669">            array[i] = generator.apply(i);</span>
<span class="nc" id="L4670">    }</span>

    /**
     * Set all elements of the specified array, in parallel, using the
     * provided generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, an unchecked exception
     * is thrown from {@code parallelSetAll} and the array is left in an
     * indeterminate state.
     *
     * @param &lt;T&gt; type of elements of the array
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static &lt;T&gt; void parallelSetAll(T[] array, IntFunction&lt;? extends T&gt; generator) {
<span class="nc" id="L4688">        Objects.requireNonNull(generator);</span>
<span class="nc" id="L4689">        IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.apply(i); });</span>
<span class="nc" id="L4690">    }</span>

    /**
     * Set all elements of the specified array, using the provided
     * generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, it is relayed to
     * the caller and the array is left in an indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void setAll(int[] array, IntUnaryOperator generator) {
<span class="nc" id="L4706">        Objects.requireNonNull(generator);</span>
<span class="nc bnc" id="L4707" title="All 2 branches missed.">        for (int i = 0; i &lt; array.length; i++)</span>
<span class="nc" id="L4708">            array[i] = generator.applyAsInt(i);</span>
<span class="nc" id="L4709">    }</span>

    /**
     * Set all elements of the specified array, in parallel, using the
     * provided generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, an unchecked exception
     * is thrown from {@code parallelSetAll} and the array is left in an
     * indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     * value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void parallelSetAll(int[] array, IntUnaryOperator generator) {
<span class="nc" id="L4726">        Objects.requireNonNull(generator);</span>
<span class="nc" id="L4727">        IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.applyAsInt(i); });</span>
<span class="nc" id="L4728">    }</span>

    /**
     * Set all elements of the specified array, using the provided
     * generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, it is relayed to
     * the caller and the array is left in an indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void setAll(long[] array, IntToLongFunction generator) {
<span class="nc" id="L4744">        Objects.requireNonNull(generator);</span>
<span class="nc bnc" id="L4745" title="All 2 branches missed.">        for (int i = 0; i &lt; array.length; i++)</span>
<span class="nc" id="L4746">            array[i] = generator.applyAsLong(i);</span>
<span class="nc" id="L4747">    }</span>

    /**
     * Set all elements of the specified array, in parallel, using the
     * provided generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, an unchecked exception
     * is thrown from {@code parallelSetAll} and the array is left in an
     * indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void parallelSetAll(long[] array, IntToLongFunction generator) {
<span class="nc" id="L4764">        Objects.requireNonNull(generator);</span>
<span class="nc" id="L4765">        IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.applyAsLong(i); });</span>
<span class="nc" id="L4766">    }</span>

    /**
     * Set all elements of the specified array, using the provided
     * generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, it is relayed to
     * the caller and the array is left in an indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void setAll(double[] array, IntToDoubleFunction generator) {
<span class="nc" id="L4782">        Objects.requireNonNull(generator);</span>
<span class="nc bnc" id="L4783" title="All 2 branches missed.">        for (int i = 0; i &lt; array.length; i++)</span>
<span class="nc" id="L4784">            array[i] = generator.applyAsDouble(i);</span>
<span class="nc" id="L4785">    }</span>

    /**
     * Set all elements of the specified array, in parallel, using the
     * provided generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, an unchecked exception
     * is thrown from {@code parallelSetAll} and the array is left in an
     * indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void parallelSetAll(double[] array, IntToDoubleFunction generator) {
<span class="nc" id="L4802">        Objects.requireNonNull(generator);</span>
<span class="nc" id="L4803">        IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.applyAsDouble(i); });</span>
<span class="nc" id="L4804">    }</span>

    /**
     * Returns a {@link Spliterator} covering all of the specified array.
     *
     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
     * {@link Spliterator#IMMUTABLE}.
     *
     * @param &lt;T&gt; type of elements
     * @param array the array, assumed to be unmodified during use
     * @return a spliterator for the array elements
     * @since 1.8
     */
    public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(T[] array) {
<span class="fc" id="L4819">        return Spliterators.spliterator(array,</span>
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    }

    /**
     * Returns a {@link Spliterator} covering the specified range of the
     * specified array.
     *
     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
     * {@link Spliterator#IMMUTABLE}.
     *
     * @param &lt;T&gt; type of elements
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a spliterator for the array elements
     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
     *         negative, {@code endExclusive} is less than
     *         {@code startInclusive}, or {@code endExclusive} is greater than
     *         the array size
     * @since 1.8
     */
    public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(T[] array, int startInclusive, int endExclusive) {
<span class="fc" id="L4843">        return Spliterators.spliterator(array, startInclusive, endExclusive,</span>
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    }

    /**
     * Returns a {@link Spliterator.OfInt} covering all of the specified array.
     *
     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
     * {@link Spliterator#IMMUTABLE}.
     *
     * @param array the array, assumed to be unmodified during use
     * @return a spliterator for the array elements
     * @since 1.8
     */
    public static Spliterator.OfInt spliterator(int[] array) {
<span class="fc" id="L4859">        return Spliterators.spliterator(array,</span>
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    }

    /**
     * Returns a {@link Spliterator.OfInt} covering the specified range of the
     * specified array.
     *
     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
     * {@link Spliterator#IMMUTABLE}.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a spliterator for the array elements
     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
     *         negative, {@code endExclusive} is less than
     *         {@code startInclusive}, or {@code endExclusive} is greater than
     *         the array size
     * @since 1.8
     */
    public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive) {
<span class="fc" id="L4882">        return Spliterators.spliterator(array, startInclusive, endExclusive,</span>
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    }

    /**
     * Returns a {@link Spliterator.OfLong} covering all of the specified array.
     *
     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
     * {@link Spliterator#IMMUTABLE}.
     *
     * @param array the array, assumed to be unmodified during use
     * @return the spliterator for the array elements
     * @since 1.8
     */
    public static Spliterator.OfLong spliterator(long[] array) {
<span class="fc" id="L4898">        return Spliterators.spliterator(array,</span>
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    }

    /**
     * Returns a {@link Spliterator.OfLong} covering the specified range of the
     * specified array.
     *
     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
     * {@link Spliterator#IMMUTABLE}.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a spliterator for the array elements
     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
     *         negative, {@code endExclusive} is less than
     *         {@code startInclusive}, or {@code endExclusive} is greater than
     *         the array size
     * @since 1.8
     */
    public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive) {
<span class="fc" id="L4921">        return Spliterators.spliterator(array, startInclusive, endExclusive,</span>
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    }

    /**
     * Returns a {@link Spliterator.OfDouble} covering all of the specified
     * array.
     *
     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
     * {@link Spliterator#IMMUTABLE}.
     *
     * @param array the array, assumed to be unmodified during use
     * @return a spliterator for the array elements
     * @since 1.8
     */
    public static Spliterator.OfDouble spliterator(double[] array) {
<span class="fc" id="L4938">        return Spliterators.spliterator(array,</span>
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    }

    /**
     * Returns a {@link Spliterator.OfDouble} covering the specified range of
     * the specified array.
     *
     * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
     * {@link Spliterator#IMMUTABLE}.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a spliterator for the array elements
     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
     *         negative, {@code endExclusive} is less than
     *         {@code startInclusive}, or {@code endExclusive} is greater than
     *         the array size
     * @since 1.8
     */
    public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive) {
<span class="fc" id="L4961">        return Spliterators.spliterator(array, startInclusive, endExclusive,</span>
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    }

    /**
     * Returns a sequential {@link Stream} with the specified array as its
     * source.
     *
     * @param &lt;T&gt; The type of the array elements
     * @param array The array, assumed to be unmodified during use
     * @return a {@code Stream} for the array
     * @since 1.8
     */
    public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) {
<span class="fc" id="L4975">        return stream(array, 0, array.length);</span>
    }

    /**
     * Returns a sequential {@link Stream} with the specified range of the
     * specified array as its source.
     *
     * @param &lt;T&gt; the type of the array elements
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a {@code Stream} for the array range
     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
     *         negative, {@code endExclusive} is less than
     *         {@code startInclusive}, or {@code endExclusive} is greater than
     *         the array size
     * @since 1.8
     */
    public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array, int startInclusive, int endExclusive) {
<span class="fc" id="L4994">        return StreamSupport.stream(spliterator(array, startInclusive, endExclusive), false);</span>
    }

    /**
     * Returns a sequential {@link IntStream} with the specified array as its
     * source.
     *
     * @param array the array, assumed to be unmodified during use
     * @return an {@code IntStream} for the array
     * @since 1.8
     */
    public static IntStream stream(int[] array) {
<span class="fc" id="L5006">        return stream(array, 0, array.length);</span>
    }

    /**
     * Returns a sequential {@link IntStream} with the specified range of the
     * specified array as its source.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return an {@code IntStream} for the array range
     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
     *         negative, {@code endExclusive} is less than
     *         {@code startInclusive}, or {@code endExclusive} is greater than
     *         the array size
     * @since 1.8
     */
    public static IntStream stream(int[] array, int startInclusive, int endExclusive) {
<span class="fc" id="L5024">        return StreamSupport.intStream(spliterator(array, startInclusive, endExclusive), false);</span>
    }

    /**
     * Returns a sequential {@link LongStream} with the specified array as its
     * source.
     *
     * @param array the array, assumed to be unmodified during use
     * @return a {@code LongStream} for the array
     * @since 1.8
     */
    public static LongStream stream(long[] array) {
<span class="fc" id="L5036">        return stream(array, 0, array.length);</span>
    }

    /**
     * Returns a sequential {@link LongStream} with the specified range of the
     * specified array as its source.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a {@code LongStream} for the array range
     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
     *         negative, {@code endExclusive} is less than
     *         {@code startInclusive}, or {@code endExclusive} is greater than
     *         the array size
     * @since 1.8
     */
    public static LongStream stream(long[] array, int startInclusive, int endExclusive) {
<span class="fc" id="L5054">        return StreamSupport.longStream(spliterator(array, startInclusive, endExclusive), false);</span>
    }

    /**
     * Returns a sequential {@link DoubleStream} with the specified array as its
     * source.
     *
     * @param array the array, assumed to be unmodified during use
     * @return a {@code DoubleStream} for the array
     * @since 1.8
     */
    public static DoubleStream stream(double[] array) {
<span class="fc" id="L5066">        return stream(array, 0, array.length);</span>
    }

    /**
     * Returns a sequential {@link DoubleStream} with the specified range of the
     * specified array as its source.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a {@code DoubleStream} for the array range
     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
     *         negative, {@code endExclusive} is less than
     *         {@code startInclusive}, or {@code endExclusive} is greater than
     *         the array size
     * @since 1.8
     */
    public static DoubleStream stream(double[] array, int startInclusive, int endExclusive) {
<span class="fc" id="L5084">        return StreamSupport.doubleStream(spliterator(array, startInclusive, endExclusive), false);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>