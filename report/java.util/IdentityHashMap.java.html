<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>IdentityHashMap.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">IdentityHashMap.java</span></div><h1>IdentityHashMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.io.*;
import java.lang.reflect.Array;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;

/**
 * This class implements the &lt;tt&gt;Map&lt;/tt&gt; interface with a hash table, using
 * reference-equality in place of object-equality when comparing keys (and
 * values).  In other words, in an &lt;tt&gt;IdentityHashMap&lt;/tt&gt;, two keys
 * &lt;tt&gt;k1&lt;/tt&gt; and &lt;tt&gt;k2&lt;/tt&gt; are considered equal if and only if
 * &lt;tt&gt;(k1==k2)&lt;/tt&gt;.  (In normal &lt;tt&gt;Map&lt;/tt&gt; implementations (like
 * &lt;tt&gt;HashMap&lt;/tt&gt;) two keys &lt;tt&gt;k1&lt;/tt&gt; and &lt;tt&gt;k2&lt;/tt&gt; are considered equal
 * if and only if &lt;tt&gt;(k1==null ? k2==null : k1.equals(k2))&lt;/tt&gt;.)
 *
 * &lt;p&gt;&lt;b&gt;This class is &lt;i&gt;not&lt;/i&gt; a general-purpose &lt;tt&gt;Map&lt;/tt&gt;
 * implementation!  While this class implements the &lt;tt&gt;Map&lt;/tt&gt; interface, it
 * intentionally violates &lt;tt&gt;Map's&lt;/tt&gt; general contract, which mandates the
 * use of the &lt;tt&gt;equals&lt;/tt&gt; method when comparing objects.  This class is
 * designed for use only in the rare cases wherein reference-equality
 * semantics are required.&lt;/b&gt;
 *
 * &lt;p&gt;A typical use of this class is &lt;i&gt;topology-preserving object graph
 * transformations&lt;/i&gt;, such as serialization or deep-copying.  To perform such
 * a transformation, a program must maintain a &quot;node table&quot; that keeps track
 * of all the object references that have already been processed.  The node
 * table must not equate distinct objects even if they happen to be equal.
 * Another typical use of this class is to maintain &lt;i&gt;proxy objects&lt;/i&gt;.  For
 * example, a debugging facility might wish to maintain a proxy object for
 * each object in the program being debugged.
 *
 * &lt;p&gt;This class provides all of the optional map operations, and permits
 * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  This class makes no
 * guarantees as to the order of the map; in particular, it does not guarantee
 * that the order will remain constant over time.
 *
 * &lt;p&gt;This class provides constant-time performance for the basic
 * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the system
 * identity hash function ({@link System#identityHashCode(Object)})
 * disperses elements properly among the buckets.
 *
 * &lt;p&gt;This class has one tuning parameter (which affects performance but not
 * semantics): &lt;i&gt;expected maximum size&lt;/i&gt;.  This parameter is the maximum
 * number of key-value mappings that the map is expected to hold.  Internally,
 * this parameter is used to determine the number of buckets initially
 * comprising the hash table.  The precise relationship between the expected
 * maximum size and the number of buckets is unspecified.
 *
 * &lt;p&gt;If the size of the map (the number of key-value mappings) sufficiently
 * exceeds the expected maximum size, the number of buckets is increased
 * Increasing the number of buckets (&quot;rehashing&quot;) may be fairly expensive, so
 * it pays to create identity hash maps with a sufficiently large expected
 * maximum size.  On the other hand, iteration over collection views requires
 * time proportional to the number of buckets in the hash table, so it
 * pays not to set the expected maximum size too high if you are especially
 * concerned with iteration performance or memory usage.
 *
 * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
 * If multiple threads access an identity hash map concurrently, and at
 * least one of the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt;
 * be synchronized externally.  (A structural modification is any operation
 * that adds or deletes one or more mappings; merely changing the value
 * associated with a key that an instance already contains is not a
 * structural modification.)  This is typically accomplished by
 * synchronizing on some object that naturally encapsulates the map.
 *
 * If no such object exists, the map should be &quot;wrapped&quot; using the
 * {@link Collections#synchronizedMap Collections.synchronizedMap}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access to the map:&lt;pre&gt;
 *   Map m = Collections.synchronizedMap(new IdentityHashMap(...));&lt;/pre&gt;
 *
 * &lt;p&gt;The iterators returned by the &lt;tt&gt;iterator&lt;/tt&gt; method of the
 * collections returned by all of this class's &quot;collection view
 * methods&quot; are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified
 * at any time after the iterator is created, in any way except
 * through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; method, the iterator
 * will throw a {@link ConcurrentModificationException}.  Thus, in the
 * face of concurrent modification, the iterator fails quickly and
 * cleanly, rather than risking arbitrary, non-deterministic behavior
 * at an undetermined time in the future.
 *
 * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness: &lt;i&gt;fail-fast iterators should be used only
 * to detect bugs.&lt;/i&gt;
 *
 * &lt;p&gt;Implementation note: This is a simple &lt;i&gt;linear-probe&lt;/i&gt; hash table,
 * as described for example in texts by Sedgewick and Knuth.  The array
 * alternates holding keys and values.  (This has better locality for large
 * tables than does using separate arrays.)  For many JRE implementations
 * and operation mixes, this class will yield better performance than
 * {@link HashMap} (which uses &lt;i&gt;chaining&lt;/i&gt; rather than linear-probing).
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @see     System#identityHashCode(Object)
 * @see     Object#hashCode()
 * @see     Collection
 * @see     Map
 * @see     HashMap
 * @see     TreeMap
 * @author  Doug Lea and Josh Bloch
 * @since   1.4
 */

public class IdentityHashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, java.io.Serializable, Cloneable
{
    /**
     * The initial capacity used by the no-args constructor.
     * MUST be a power of two.  The value 32 corresponds to the
     * (specified) expected maximum size of 21, given a load factor
     * of 2/3.
     */
    private static final int DEFAULT_CAPACITY = 32;

    /**
     * The minimum capacity, used if a lower value is implicitly specified
     * by either of the constructors with arguments.  The value 4 corresponds
     * to an expected maximum size of 2, given a load factor of 2/3.
     * MUST be a power of two.
     */
    private static final int MINIMUM_CAPACITY = 4;

    /**
     * The maximum capacity, used if a higher value is implicitly specified
     * by either of the constructors with arguments.
     * MUST be a power of two &lt;= 1&lt;&lt;29.
     */
    private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 29;

    /**
     * The table, resized as necessary. Length MUST always be a power of two.
     */
    transient Object[] table; // non-private to simplify nested class access

    /**
     * The number of key-value mappings contained in this identity hash map.
     *
     * @serial
     */
    int size;

    /**
     * The number of modifications, to support fast-fail iterators
     */
    transient int modCount;

    /**
     * The next size value at which to resize (capacity * load factor).
     */
    private transient int threshold;

    /**
     * Value representing null keys inside tables.
     */
<span class="fc" id="L191">    static final Object NULL_KEY = new Object();</span>

    /**
     * Use NULL_KEY for key if it is null.
     */
    private static Object maskNull(Object key) {
<span class="fc bfc" id="L197" title="All 2 branches covered.">        return (key == null ? NULL_KEY : key);</span>
    }

    /**
     * Returns internal representation of null key back to caller as null.
     */
    static final Object unmaskNull(Object key) {
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        return (key == NULL_KEY ? null : key);</span>
    }

    /**
     * Constructs a new, empty identity hash map with a default expected
     * maximum size (21).
     */
<span class="fc" id="L211">    public IdentityHashMap() {</span>
<span class="fc" id="L212">        init(DEFAULT_CAPACITY);</span>
<span class="fc" id="L213">    }</span>

    /**
     * Constructs a new, empty map with the specified expected maximum size.
     * Putting more than the expected number of key-value mappings into
     * the map may cause the internal data structure to grow, which may be
     * somewhat time-consuming.
     *
     * @param expectedMaxSize the expected maximum size of the map
     * @throws IllegalArgumentException if &lt;tt&gt;expectedMaxSize&lt;/tt&gt; is negative
     */
<span class="fc" id="L224">    public IdentityHashMap(int expectedMaxSize) {</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if (expectedMaxSize &lt; 0)</span>
<span class="nc" id="L226">            throw new IllegalArgumentException(&quot;expectedMaxSize is negative: &quot;</span>
                                               + expectedMaxSize);
<span class="fc" id="L228">        init(capacity(expectedMaxSize));</span>
<span class="fc" id="L229">    }</span>

    /**
     * Returns the appropriate capacity for the specified expected maximum
     * size.  Returns the smallest power of two between MINIMUM_CAPACITY
     * and MAXIMUM_CAPACITY, inclusive, that is greater than
     * (3 * expectedMaxSize)/2, if such a number exists.  Otherwise
     * returns MAXIMUM_CAPACITY.  If (3 * expectedMaxSize)/2 is negative, it
     * is assumed that overflow has occurred, and MAXIMUM_CAPACITY is returned.
     */
    private int capacity(int expectedMaxSize) {
        // Compute min capacity for expectedMaxSize given a load factor of 2/3
<span class="fc" id="L241">        int minCapacity = (3 * expectedMaxSize)/2;</span>

        // Compute the appropriate capacity
        int result;
<span class="pc bpc" id="L245" title="2 of 4 branches missed.">        if (minCapacity &gt; MAXIMUM_CAPACITY || minCapacity &lt; 0) {</span>
<span class="nc" id="L246">            result = MAXIMUM_CAPACITY;</span>
        } else {
<span class="fc" id="L248">            result = MINIMUM_CAPACITY;</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">            while (result &lt; minCapacity)</span>
<span class="fc" id="L250">                result &lt;&lt;= 1;</span>
        }
<span class="fc" id="L252">        return result;</span>
    }

    /**
     * Initializes object to be an empty map with the specified initial
     * capacity, which is assumed to be a power of two between
     * MINIMUM_CAPACITY and MAXIMUM_CAPACITY inclusive.
     */
    private void init(int initCapacity) {
        // assert (initCapacity &amp; -initCapacity) == initCapacity; // power of 2
        // assert initCapacity &gt;= MINIMUM_CAPACITY;
        // assert initCapacity &lt;= MAXIMUM_CAPACITY;

<span class="fc" id="L265">        threshold = (initCapacity * 2)/3;</span>
<span class="fc" id="L266">        table = new Object[2 * initCapacity];</span>
<span class="fc" id="L267">    }</span>

    /**
     * Constructs a new identity hash map containing the keys-value mappings
     * in the specified map.
     *
     * @param m the map whose mappings are to be placed into this map
     * @throws NullPointerException if the specified map is null
     */
    public IdentityHashMap(Map&lt;? extends K, ? extends V&gt; m) {
        // Allow for a bit of growth
<span class="fc" id="L278">        this((int) ((1 + m.size()) * 1.1));</span>
<span class="fc" id="L279">        putAll(m);</span>
<span class="fc" id="L280">    }</span>

    /**
     * Returns the number of key-value mappings in this identity hash map.
     *
     * @return the number of key-value mappings in this map
     */
    public int size() {
<span class="fc" id="L288">        return size;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this identity hash map contains no key-value
     * mappings.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if this identity hash map contains no key-value
     *         mappings
     */
    public boolean isEmpty() {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        return size == 0;</span>
    }

    /**
     * Returns index for Object x.
     */
    private static int hash(Object x, int length) {
<span class="fc" id="L306">        int h = System.identityHashCode(x);</span>
        // Multiply by -127, and left-shift to use least bit as part of hash
<span class="fc" id="L308">        return ((h &lt;&lt; 1) - (h &lt;&lt; 8)) &amp; (length - 1);</span>
    }

    /**
     * Circularly traverses table of size len.
     */
    private static int nextKeyIndex(int i, int len) {
<span class="fc bfc" id="L315" title="All 2 branches covered.">        return (i + 2 &lt; len ? i + 2 : 0);</span>
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * &lt;p&gt;More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code (key == k)},
     * then this method returns {@code v}; otherwise it returns
     * {@code null}.  (There can be at most one such mapping.)
     *
     * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
     * indicate that the map contains no mapping for the key; it's also
     * possible that the map explicitly maps the key to {@code null}.
     * The {@link #containsKey containsKey} operation may be used to
     * distinguish these two cases.
     *
     * @see #put(Object, Object)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public V get(Object key) {
<span class="fc" id="L337">        Object k = maskNull(key);</span>
<span class="fc" id="L338">        Object[] tab = table;</span>
<span class="fc" id="L339">        int len = tab.length;</span>
<span class="fc" id="L340">        int i = hash(k, len);</span>
        while (true) {
<span class="fc" id="L342">            Object item = tab[i];</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            if (item == k)</span>
<span class="fc" id="L344">                return (V) tab[i + 1];</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">            if (item == null)</span>
<span class="fc" id="L346">                return null;</span>
<span class="fc" id="L347">            i = nextKeyIndex(i, len);</span>
<span class="fc" id="L348">        }</span>
    }

    /**
     * Tests whether the specified object reference is a key in this identity
     * hash map.
     *
     * @param   key   possible key
     * @return  &lt;code&gt;true&lt;/code&gt; if the specified object reference is a key
     *          in this map
     * @see     #containsValue(Object)
     */
    public boolean containsKey(Object key) {
<span class="fc" id="L361">        Object k = maskNull(key);</span>
<span class="fc" id="L362">        Object[] tab = table;</span>
<span class="fc" id="L363">        int len = tab.length;</span>
<span class="fc" id="L364">        int i = hash(k, len);</span>
        while (true) {
<span class="fc" id="L366">            Object item = tab[i];</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            if (item == k)</span>
<span class="fc" id="L368">                return true;</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">            if (item == null)</span>
<span class="fc" id="L370">                return false;</span>
<span class="fc" id="L371">            i = nextKeyIndex(i, len);</span>
<span class="fc" id="L372">        }</span>
    }

    /**
     * Tests whether the specified object reference is a value in this identity
     * hash map.
     *
     * @param value value whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
     *         specified object reference
     * @see     #containsKey(Object)
     */
    public boolean containsValue(Object value) {
<span class="fc" id="L385">        Object[] tab = table;</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        for (int i = 1; i &lt; tab.length; i += 2)</span>
<span class="pc bpc" id="L387" title="1 of 4 branches missed.">            if (tab[i] == value &amp;&amp; tab[i - 1] != null)</span>
<span class="nc" id="L388">                return true;</span>

<span class="fc" id="L390">        return false;</span>
    }

    /**
     * Tests if the specified key-value mapping is in the map.
     *
     * @param   key   possible key
     * @param   value possible value
     * @return  &lt;code&gt;true&lt;/code&gt; if and only if the specified key-value
     *          mapping is in the map
     */
    private boolean containsMapping(Object key, Object value) {
<span class="nc" id="L402">        Object k = maskNull(key);</span>
<span class="nc" id="L403">        Object[] tab = table;</span>
<span class="nc" id="L404">        int len = tab.length;</span>
<span class="nc" id="L405">        int i = hash(k, len);</span>
        while (true) {
<span class="nc" id="L407">            Object item = tab[i];</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if (item == k)</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">                return tab[i + 1] == value;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (item == null)</span>
<span class="nc" id="L411">                return false;</span>
<span class="nc" id="L412">            i = nextKeyIndex(i, len);</span>
<span class="nc" id="L413">        }</span>
    }

    /**
     * Associates the specified value with the specified key in this identity
     * hash map.  If the map previously contained a mapping for the key, the
     * old value is replaced.
     *
     * @param key the key with which the specified value is to be associated
     * @param value the value to be associated with the specified key
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     * @see     Object#equals(Object)
     * @see     #get(Object)
     * @see     #containsKey(Object)
     */
    public V put(K key, V value) {
<span class="fc" id="L432">        Object k = maskNull(key);</span>
<span class="fc" id="L433">        Object[] tab = table;</span>
<span class="fc" id="L434">        int len = tab.length;</span>
<span class="fc" id="L435">        int i = hash(k, len);</span>

        Object item;
<span class="fc bfc" id="L438" title="All 2 branches covered.">        while ( (item = tab[i]) != null) {</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">            if (item == k) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L441">                    V oldValue = (V) tab[i + 1];</span>
<span class="fc" id="L442">                tab[i + 1] = value;</span>
<span class="fc" id="L443">                return oldValue;</span>
            }
<span class="fc" id="L445">            i = nextKeyIndex(i, len);</span>
        }

<span class="fc" id="L448">        modCount++;</span>
<span class="fc" id="L449">        tab[i] = k;</span>
<span class="fc" id="L450">        tab[i + 1] = value;</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (++size &gt;= threshold)</span>
<span class="fc" id="L452">            resize(len); // len == 2 * current capacity.</span>
<span class="fc" id="L453">        return null;</span>
    }

    /**
     * Resize the table to hold given capacity.
     *
     * @param newCapacity the new capacity, must be a power of two.
     */
    private void resize(int newCapacity) {
        // assert (newCapacity &amp; -newCapacity) == newCapacity; // power of 2
<span class="fc" id="L463">        int newLength = newCapacity * 2;</span>

<span class="fc" id="L465">        Object[] oldTable = table;</span>
<span class="fc" id="L466">        int oldLength = oldTable.length;</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (oldLength == 2*MAXIMUM_CAPACITY) { // can't expand any further</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (threshold == MAXIMUM_CAPACITY-1)</span>
<span class="nc" id="L469">                throw new IllegalStateException(&quot;Capacity exhausted.&quot;);</span>
<span class="nc" id="L470">            threshold = MAXIMUM_CAPACITY-1;  // Gigantic map!</span>
<span class="nc" id="L471">            return;</span>
        }
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        if (oldLength &gt;= newLength)</span>
<span class="nc" id="L474">            return;</span>

<span class="fc" id="L476">        Object[] newTable = new Object[newLength];</span>
<span class="fc" id="L477">        threshold = newLength / 3;</span>

<span class="fc bfc" id="L479" title="All 2 branches covered.">        for (int j = 0; j &lt; oldLength; j += 2) {</span>
<span class="fc" id="L480">            Object key = oldTable[j];</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">            if (key != null) {</span>
<span class="fc" id="L482">                Object value = oldTable[j+1];</span>
<span class="fc" id="L483">                oldTable[j] = null;</span>
<span class="fc" id="L484">                oldTable[j+1] = null;</span>
<span class="fc" id="L485">                int i = hash(key, newLength);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">                while (newTable[i] != null)</span>
<span class="fc" id="L487">                    i = nextKeyIndex(i, newLength);</span>
<span class="fc" id="L488">                newTable[i] = key;</span>
<span class="fc" id="L489">                newTable[i + 1] = value;</span>
            }
        }
<span class="fc" id="L492">        table = newTable;</span>
<span class="fc" id="L493">    }</span>

    /**
     * Copies all of the mappings from the specified map to this map.
     * These mappings will replace any mappings that this map had for
     * any of the keys currently in the specified map.
     *
     * @param m mappings to be stored in this map
     * @throws NullPointerException if the specified map is null
     */
    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
<span class="fc" id="L504">        int n = m.size();</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">        if (n == 0)</span>
<span class="nc" id="L506">            return;</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">        if (n &gt; threshold) // conservatively pre-expand</span>
<span class="nc" id="L508">            resize(capacity(n));</span>

<span class="fc bfc" id="L510" title="All 2 branches covered.">        for (Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span>
<span class="fc" id="L511">            put(e.getKey(), e.getValue());</span>
<span class="fc" id="L512">    }</span>

    /**
     * Removes the mapping for this key from this map if present.
     *
     * @param key key whose mapping is to be removed from the map
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */
    public V remove(Object key) {
<span class="fc" id="L524">        Object k = maskNull(key);</span>
<span class="fc" id="L525">        Object[] tab = table;</span>
<span class="fc" id="L526">        int len = tab.length;</span>
<span class="fc" id="L527">        int i = hash(k, len);</span>

        while (true) {
<span class="fc" id="L530">            Object item = tab[i];</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">            if (item == k) {</span>
<span class="fc" id="L532">                modCount++;</span>
<span class="fc" id="L533">                size--;</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L535">                    V oldValue = (V) tab[i + 1];</span>
<span class="fc" id="L536">                tab[i + 1] = null;</span>
<span class="fc" id="L537">                tab[i] = null;</span>
<span class="fc" id="L538">                closeDeletion(i);</span>
<span class="fc" id="L539">                return oldValue;</span>
            }
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">            if (item == null)</span>
<span class="nc" id="L542">                return null;</span>
<span class="fc" id="L543">            i = nextKeyIndex(i, len);</span>
<span class="fc" id="L544">        }</span>

    }

    /**
     * Removes the specified key-value mapping from the map if it is present.
     *
     * @param   key   possible key
     * @param   value possible value
     * @return  &lt;code&gt;true&lt;/code&gt; if and only if the specified key-value
     *          mapping was in the map
     */
    private boolean removeMapping(Object key, Object value) {
<span class="fc" id="L557">        Object k = maskNull(key);</span>
<span class="fc" id="L558">        Object[] tab = table;</span>
<span class="fc" id="L559">        int len = tab.length;</span>
<span class="fc" id="L560">        int i = hash(k, len);</span>

        while (true) {
<span class="fc" id="L563">            Object item = tab[i];</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            if (item == k) {</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">                if (tab[i + 1] != value)</span>
<span class="nc" id="L566">                    return false;</span>
<span class="fc" id="L567">                modCount++;</span>
<span class="fc" id="L568">                size--;</span>
<span class="fc" id="L569">                tab[i] = null;</span>
<span class="fc" id="L570">                tab[i + 1] = null;</span>
<span class="fc" id="L571">                closeDeletion(i);</span>
<span class="fc" id="L572">                return true;</span>
            }
<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (item == null)</span>
<span class="nc" id="L575">                return false;</span>
<span class="nc" id="L576">            i = nextKeyIndex(i, len);</span>
<span class="nc" id="L577">        }</span>
    }

    /**
     * Rehash all possibly-colliding entries following a
     * deletion. This preserves the linear-probe
     * collision properties required by get, put, etc.
     *
     * @param d the index of a newly empty deleted slot
     */
    private void closeDeletion(int d) {
        // Adapted from Knuth Section 6.4 Algorithm R
<span class="fc" id="L589">        Object[] tab = table;</span>
<span class="fc" id="L590">        int len = tab.length;</span>

        // Look for items to swap into newly vacated slot
        // starting at index immediately following deletion,
        // and continuing until a null slot is seen, indicating
        // the end of a run of possibly-colliding keys.
        Object item;
<span class="fc bfc" id="L597" title="All 2 branches covered.">        for (int i = nextKeyIndex(d, len); (item = tab[i]) != null;</span>
<span class="fc" id="L598">             i = nextKeyIndex(i, len) ) {</span>
            // The following test triggers if the item at slot i (which
            // hashes to be at slot r) should take the spot vacated by d.
            // If so, we swap it in, and then continue with d now at the
            // newly vacated i.  This process will terminate when we hit
            // the null slot at the end of this run.
            // The test is messy because we are using a circular table.
<span class="fc" id="L605">            int r = hash(item, len);</span>
<span class="pc bpc" id="L606" title="6 of 10 branches missed.">            if ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) || (r &lt;= d &amp;&amp; d &lt;= i)) {</span>
<span class="fc" id="L607">                tab[d] = item;</span>
<span class="fc" id="L608">                tab[d + 1] = tab[i + 1];</span>
<span class="fc" id="L609">                tab[i] = null;</span>
<span class="fc" id="L610">                tab[i + 1] = null;</span>
<span class="fc" id="L611">                d = i;</span>
            }
        }
<span class="fc" id="L614">    }</span>

    /**
     * Removes all of the mappings from this map.
     * The map will be empty after this call returns.
     */
    public void clear() {
<span class="fc" id="L621">        modCount++;</span>
<span class="fc" id="L622">        Object[] tab = table;</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">        for (int i = 0; i &lt; tab.length; i++)</span>
<span class="fc" id="L624">            tab[i] = null;</span>
<span class="fc" id="L625">        size = 0;</span>
<span class="fc" id="L626">    }</span>

    /**
     * Compares the specified object with this map for equality.  Returns
     * &lt;tt&gt;true&lt;/tt&gt; if the given object is also a map and the two maps
     * represent identical object-reference mappings.  More formally, this
     * map is equal to another map &lt;tt&gt;m&lt;/tt&gt; if and only if
     * &lt;tt&gt;this.entrySet().equals(m.entrySet())&lt;/tt&gt;.
     *
     * &lt;p&gt;&lt;b&gt;Owing to the reference-equality-based semantics of this map it is
     * possible that the symmetry and transitivity requirements of the
     * &lt;tt&gt;Object.equals&lt;/tt&gt; contract may be violated if this map is compared
     * to a normal map.  However, the &lt;tt&gt;Object.equals&lt;/tt&gt; contract is
     * guaranteed to hold among &lt;tt&gt;IdentityHashMap&lt;/tt&gt; instances.&lt;/b&gt;
     *
     * @param  o object to be compared for equality with this map
     * @return &lt;tt&gt;true&lt;/tt&gt; if the specified object is equal to this map
     * @see Object#equals(Object)
     */
    public boolean equals(Object o) {
<span class="nc bnc" id="L646" title="All 2 branches missed.">        if (o == this) {</span>
<span class="nc" id="L647">            return true;</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">        } else if (o instanceof IdentityHashMap) {</span>
<span class="nc" id="L649">            IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) o;</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">            if (m.size() != size)</span>
<span class="nc" id="L651">                return false;</span>

<span class="nc" id="L653">            Object[] tab = m.table;</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">            for (int i = 0; i &lt; tab.length; i+=2) {</span>
<span class="nc" id="L655">                Object k = tab[i];</span>
<span class="nc bnc" id="L656" title="All 4 branches missed.">                if (k != null &amp;&amp; !containsMapping(k, tab[i + 1]))</span>
<span class="nc" id="L657">                    return false;</span>
            }
<span class="nc" id="L659">            return true;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">        } else if (o instanceof Map) {</span>
<span class="nc" id="L661">            Map&lt;?,?&gt; m = (Map&lt;?,?&gt;)o;</span>
<span class="nc" id="L662">            return entrySet().equals(m.entrySet());</span>
        } else {
<span class="nc" id="L664">            return false;  // o is not a Map</span>
        }
    }

    /**
     * Returns the hash code value for this map.  The hash code of a map is
     * defined to be the sum of the hash codes of each entry in the map's
     * &lt;tt&gt;entrySet()&lt;/tt&gt; view.  This ensures that &lt;tt&gt;m1.equals(m2)&lt;/tt&gt;
     * implies that &lt;tt&gt;m1.hashCode()==m2.hashCode()&lt;/tt&gt; for any two
     * &lt;tt&gt;IdentityHashMap&lt;/tt&gt; instances &lt;tt&gt;m1&lt;/tt&gt; and &lt;tt&gt;m2&lt;/tt&gt;, as
     * required by the general contract of {@link Object#hashCode}.
     *
     * &lt;p&gt;&lt;b&gt;Owing to the reference-equality-based semantics of the
     * &lt;tt&gt;Map.Entry&lt;/tt&gt; instances in the set returned by this map's
     * &lt;tt&gt;entrySet&lt;/tt&gt; method, it is possible that the contractual
     * requirement of &lt;tt&gt;Object.hashCode&lt;/tt&gt; mentioned in the previous
     * paragraph will be violated if one of the two objects being compared is
     * an &lt;tt&gt;IdentityHashMap&lt;/tt&gt; instance and the other is a normal map.&lt;/b&gt;
     *
     * @return the hash code value for this map
     * @see Object#equals(Object)
     * @see #equals(Object)
     */
    public int hashCode() {
<span class="nc" id="L688">        int result = 0;</span>
<span class="nc" id="L689">        Object[] tab = table;</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        for (int i = 0; i &lt; tab.length; i +=2) {</span>
<span class="nc" id="L691">            Object key = tab[i];</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">            if (key != null) {</span>
<span class="nc" id="L693">                Object k = unmaskNull(key);</span>
<span class="nc" id="L694">                result += System.identityHashCode(k) ^</span>
<span class="nc" id="L695">                          System.identityHashCode(tab[i + 1]);</span>
            }
        }
<span class="nc" id="L698">        return result;</span>
    }

    /**
     * Returns a shallow copy of this identity hash map: the keys and values
     * themselves are not cloned.
     *
     * @return a shallow copy of this map
     */
    public Object clone() {
        try {
<span class="nc" id="L709">            IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) super.clone();</span>
<span class="nc" id="L710">            m.entrySet = null;</span>
<span class="nc" id="L711">            m.table = table.clone();</span>
<span class="nc" id="L712">            return m;</span>
<span class="nc" id="L713">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L714">            throw new InternalError(e);</span>
        }
    }

<span class="fc" id="L718">    private abstract class IdentityHashMapIterator&lt;T&gt; implements Iterator&lt;T&gt; {</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">        int index = (size != 0 ? 0 : table.length); // current slot.</span>
<span class="fc" id="L720">        int expectedModCount = modCount; // to support fast-fail</span>
<span class="fc" id="L721">        int lastReturnedIndex = -1;      // to allow remove()</span>
        boolean indexValid; // To avoid unnecessary next computation
<span class="fc" id="L723">        Object[] traversalTable = table; // reference to main table or copy</span>

        public boolean hasNext() {
<span class="fc" id="L726">            Object[] tab = traversalTable;</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">            for (int i = index; i &lt; tab.length; i+=2) {</span>
<span class="fc" id="L728">                Object key = tab[i];</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">                if (key != null) {</span>
<span class="fc" id="L730">                    index = i;</span>
<span class="fc" id="L731">                    return indexValid = true;</span>
                }
            }
<span class="fc" id="L734">            index = tab.length;</span>
<span class="fc" id="L735">            return false;</span>
        }

        protected int nextIndex() {
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">            if (modCount != expectedModCount)</span>
<span class="nc" id="L740">                throw new ConcurrentModificationException();</span>
<span class="fc bfc" id="L741" title="All 4 branches covered.">            if (!indexValid &amp;&amp; !hasNext())</span>
<span class="fc" id="L742">                throw new NoSuchElementException();</span>

<span class="fc" id="L744">            indexValid = false;</span>
<span class="fc" id="L745">            lastReturnedIndex = index;</span>
<span class="fc" id="L746">            index += 2;</span>
<span class="fc" id="L747">            return lastReturnedIndex;</span>
        }

        public void remove() {
<span class="fc bfc" id="L751" title="All 2 branches covered.">            if (lastReturnedIndex == -1)</span>
<span class="fc" id="L752">                throw new IllegalStateException();</span>
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">            if (modCount != expectedModCount)</span>
<span class="nc" id="L754">                throw new ConcurrentModificationException();</span>

<span class="fc" id="L756">            expectedModCount = ++modCount;</span>
<span class="fc" id="L757">            int deletedSlot = lastReturnedIndex;</span>
<span class="fc" id="L758">            lastReturnedIndex = -1;</span>
            // back up index to revisit new contents after deletion
<span class="fc" id="L760">            index = deletedSlot;</span>
<span class="fc" id="L761">            indexValid = false;</span>

            // Removal code proceeds as in closeDeletion except that
            // it must catch the rare case where an element already
            // seen is swapped into a vacant slot that will be later
            // traversed by this iterator. We cannot allow future
            // next() calls to return it again.  The likelihood of
            // this occurring under 2/3 load factor is very slim, but
            // when it does happen, we must make a copy of the rest of
            // the table to use for the rest of the traversal. Since
            // this can only happen when we are near the end of the table,
            // even in these rare cases, this is not very expensive in
            // time or space.

<span class="fc" id="L775">            Object[] tab = traversalTable;</span>
<span class="fc" id="L776">            int len = tab.length;</span>

<span class="fc" id="L778">            int d = deletedSlot;</span>
<span class="fc" id="L779">            Object key = tab[d];</span>
<span class="fc" id="L780">            tab[d] = null;        // vacate the slot</span>
<span class="fc" id="L781">            tab[d + 1] = null;</span>

            // If traversing a copy, remove in real table.
            // We can skip gap-closure on copy.
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">            if (tab != IdentityHashMap.this.table) {</span>
<span class="nc" id="L786">                IdentityHashMap.this.remove(key);</span>
<span class="nc" id="L787">                expectedModCount = modCount;</span>
<span class="nc" id="L788">                return;</span>
            }

<span class="fc" id="L791">            size--;</span>

            Object item;
<span class="fc bfc" id="L794" title="All 2 branches covered.">            for (int i = nextKeyIndex(d, len); (item = tab[i]) != null;</span>
<span class="fc" id="L795">                 i = nextKeyIndex(i, len)) {</span>
<span class="fc" id="L796">                int r = hash(item, len);</span>
                // See closeDeletion for explanation of this conditional
<span class="pc bpc" id="L798" title="6 of 10 branches missed.">                if ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) ||</span>
                    (r &lt;= d &amp;&amp; d &lt;= i)) {

                    // If we are about to swap an already-seen element
                    // into a slot that may later be returned by next(),
                    // then clone the rest of table for use in future
                    // next() calls. It is OK that our copy will have
                    // a gap in the &quot;wrong&quot; place, since it will never
                    // be used for searching anyway.

<span class="pc bpc" id="L808" title="5 of 6 branches missed.">                    if (i &lt; deletedSlot &amp;&amp; d &gt;= deletedSlot &amp;&amp;</span>
                        traversalTable == IdentityHashMap.this.table) {
<span class="nc" id="L810">                        int remaining = len - deletedSlot;</span>
<span class="nc" id="L811">                        Object[] newTable = new Object[remaining];</span>
<span class="nc" id="L812">                        System.arraycopy(tab, deletedSlot,</span>
                                         newTable, 0, remaining);
<span class="nc" id="L814">                        traversalTable = newTable;</span>
<span class="nc" id="L815">                        index = 0;</span>
                    }

<span class="fc" id="L818">                    tab[d] = item;</span>
<span class="fc" id="L819">                    tab[d + 1] = tab[i + 1];</span>
<span class="fc" id="L820">                    tab[i] = null;</span>
<span class="fc" id="L821">                    tab[i + 1] = null;</span>
<span class="fc" id="L822">                    d = i;</span>
                }
            }
<span class="fc" id="L825">        }</span>
    }

<span class="fc" id="L828">    private class KeyIterator extends IdentityHashMapIterator&lt;K&gt; {</span>
        @SuppressWarnings(&quot;unchecked&quot;)
        public K next() {
<span class="fc" id="L831">            return (K) unmaskNull(traversalTable[nextIndex()]);</span>
        }
    }

<span class="fc" id="L835">    private class ValueIterator extends IdentityHashMapIterator&lt;V&gt; {</span>
        @SuppressWarnings(&quot;unchecked&quot;)
        public V next() {
<span class="fc" id="L838">            return (V) traversalTable[nextIndex() + 1];</span>
        }
    }

<span class="fc" id="L842">    private class EntryIterator</span>
        extends IdentityHashMapIterator&lt;Map.Entry&lt;K,V&gt;&gt;
    {
<span class="fc" id="L845">        private Entry lastReturnedEntry = null;</span>

        public Map.Entry&lt;K,V&gt; next() {
<span class="fc" id="L848">            lastReturnedEntry = new Entry(nextIndex());</span>
<span class="fc" id="L849">            return lastReturnedEntry;</span>
        }

        public void remove() {
<span class="fc bfc" id="L853" title="All 2 branches covered.">            lastReturnedIndex =</span>
<span class="fc" id="L854">                ((null == lastReturnedEntry) ? -1 : lastReturnedEntry.index);</span>
<span class="fc" id="L855">            super.remove();</span>
<span class="fc" id="L856">            lastReturnedEntry.index = lastReturnedIndex;</span>
<span class="fc" id="L857">            lastReturnedEntry = null;</span>
<span class="fc" id="L858">        }</span>

<span class="fc" id="L860">        private class Entry implements Map.Entry&lt;K,V&gt; {</span>
            private int index;

<span class="fc" id="L863">            private Entry(int index) {</span>
<span class="fc" id="L864">                this.index = index;</span>
<span class="fc" id="L865">            }</span>

            @SuppressWarnings(&quot;unchecked&quot;)
            public K getKey() {
<span class="fc" id="L869">                checkIndexForEntryUse();</span>
<span class="fc" id="L870">                return (K) unmaskNull(traversalTable[index]);</span>
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public V getValue() {
<span class="fc" id="L875">                checkIndexForEntryUse();</span>
<span class="fc" id="L876">                return (V) traversalTable[index+1];</span>
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public V setValue(V value) {
<span class="nc" id="L881">                checkIndexForEntryUse();</span>
<span class="nc" id="L882">                V oldValue = (V) traversalTable[index+1];</span>
<span class="nc" id="L883">                traversalTable[index+1] = value;</span>
                // if shadowing, force into main table
<span class="nc bnc" id="L885" title="All 2 branches missed.">                if (traversalTable != IdentityHashMap.this.table)</span>
<span class="nc" id="L886">                    put((K) traversalTable[index], value);</span>
<span class="nc" id="L887">                return oldValue;</span>
            }

            public boolean equals(Object o) {
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">                if (index &lt; 0)</span>
<span class="nc" id="L892">                    return super.equals(o);</span>

<span class="pc bpc" id="L894" title="1 of 2 branches missed.">                if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L895">                    return false;</span>
<span class="fc" id="L896">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span>
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">                return (e.getKey() == unmaskNull(traversalTable[index]) &amp;&amp;</span>
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">                       e.getValue() == traversalTable[index+1]);</span>
            }

            public int hashCode() {
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">                if (lastReturnedIndex &lt; 0)</span>
<span class="nc" id="L903">                    return super.hashCode();</span>

<span class="fc" id="L905">                return (System.identityHashCode(unmaskNull(traversalTable[index])) ^</span>
<span class="fc" id="L906">                       System.identityHashCode(traversalTable[index+1]));</span>
            }

            public String toString() {
<span class="nc bnc" id="L910" title="All 2 branches missed.">                if (index &lt; 0)</span>
<span class="nc" id="L911">                    return super.toString();</span>

<span class="nc" id="L913">                return (unmaskNull(traversalTable[index]) + &quot;=&quot;</span>
                        + traversalTable[index+1]);
            }

            private void checkIndexForEntryUse() {
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">                if (index &lt; 0)</span>
<span class="nc" id="L919">                    throw new IllegalStateException(&quot;Entry was removed&quot;);</span>
<span class="fc" id="L920">            }</span>
        }
    }

    // Views

    /**
     * This field is initialized to contain an instance of the entry set
     * view the first time this view is requested.  The view is stateless,
     * so there's no reason to create more than one.
     */
<span class="fc" id="L931">    private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;</span>

    /**
     * Returns an identity-based set view of the keys contained in this map.
     * The set is backed by the map, so changes to the map are reflected in
     * the set, and vice-versa.  If the map is modified while an iteration
     * over the set is in progress, the results of the iteration are
     * undefined.  The set supports element removal, which removes the
     * corresponding mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and
     * &lt;tt&gt;clear&lt;/tt&gt; methods.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or
     * &lt;tt&gt;addAll&lt;/tt&gt; methods.
     *
     * &lt;p&gt;&lt;b&gt;While the object returned by this method implements the
     * &lt;tt&gt;Set&lt;/tt&gt; interface, it does &lt;i&gt;not&lt;/i&gt; obey &lt;tt&gt;Set's&lt;/tt&gt; general
     * contract.  Like its backing map, the set returned by this method
     * defines element equality as reference-equality rather than
     * object-equality.  This affects the behavior of its &lt;tt&gt;contains&lt;/tt&gt;,
     * &lt;tt&gt;remove&lt;/tt&gt;, &lt;tt&gt;containsAll&lt;/tt&gt;, &lt;tt&gt;equals&lt;/tt&gt;, and
     * &lt;tt&gt;hashCode&lt;/tt&gt; methods.&lt;/b&gt;
     *
     * &lt;p&gt;&lt;b&gt;The &lt;tt&gt;equals&lt;/tt&gt; method of the returned set returns &lt;tt&gt;true&lt;/tt&gt;
     * only if the specified object is a set containing exactly the same
     * object references as the returned set.  The symmetry and transitivity
     * requirements of the &lt;tt&gt;Object.equals&lt;/tt&gt; contract may be violated if
     * the set returned by this method is compared to a normal set.  However,
     * the &lt;tt&gt;Object.equals&lt;/tt&gt; contract is guaranteed to hold among sets
     * returned by this method.&lt;/b&gt;
     *
     * &lt;p&gt;The &lt;tt&gt;hashCode&lt;/tt&gt; method of the returned set returns the sum of
     * the &lt;i&gt;identity hashcodes&lt;/i&gt; of the elements in the set, rather than
     * the sum of their hashcodes.  This is mandated by the change in the
     * semantics of the &lt;tt&gt;equals&lt;/tt&gt; method, in order to enforce the
     * general contract of the &lt;tt&gt;Object.hashCode&lt;/tt&gt; method among sets
     * returned by this method.
     *
     * @return an identity-based set view of the keys contained in this map
     * @see Object#equals(Object)
     * @see System#identityHashCode(Object)
     */
    public Set&lt;K&gt; keySet() {
<span class="fc" id="L972">        Set&lt;K&gt; ks = keySet;</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">        if (ks != null)</span>
<span class="fc" id="L974">            return ks;</span>
        else
<span class="fc" id="L976">            return keySet = new KeySet();</span>
    }

<span class="fc" id="L979">    private class KeySet extends AbstractSet&lt;K&gt; {</span>
        public Iterator&lt;K&gt; iterator() {
<span class="fc" id="L981">            return new KeyIterator();</span>
        }
        public int size() {
<span class="fc" id="L984">            return size;</span>
        }
        public boolean contains(Object o) {
<span class="fc" id="L987">            return containsKey(o);</span>
        }
        public boolean remove(Object o) {
<span class="fc" id="L990">            int oldSize = size;</span>
<span class="fc" id="L991">            IdentityHashMap.this.remove(o);</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">            return size != oldSize;</span>
        }
        /*
         * Must revert from AbstractSet's impl to AbstractCollection's, as
         * the former contains an optimization that results in incorrect
         * behavior when c is a smaller &quot;normal&quot; (non-identity-based) Set.
         */
        public boolean removeAll(Collection&lt;?&gt; c) {
<span class="nc" id="L1000">            Objects.requireNonNull(c);</span>
<span class="nc" id="L1001">            boolean modified = false;</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">            for (Iterator&lt;K&gt; i = iterator(); i.hasNext(); ) {</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">                if (c.contains(i.next())) {</span>
<span class="nc" id="L1004">                    i.remove();</span>
<span class="nc" id="L1005">                    modified = true;</span>
                }
            }
<span class="nc" id="L1008">            return modified;</span>
        }
        public void clear() {
<span class="nc" id="L1011">            IdentityHashMap.this.clear();</span>
<span class="nc" id="L1012">        }</span>
        public int hashCode() {
<span class="fc" id="L1014">            int result = 0;</span>
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">            for (K key : this)</span>
<span class="nc" id="L1016">                result += System.identityHashCode(key);</span>
<span class="fc" id="L1017">            return result;</span>
        }
        public Object[] toArray() {
<span class="fc" id="L1020">            return toArray(new Object[0]);</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;T&gt; T[] toArray(T[] a) {
<span class="fc" id="L1024">            int expectedModCount = modCount;</span>
<span class="fc" id="L1025">            int size = size();</span>
<span class="pc bpc" id="L1026" title="1 of 2 branches missed.">            if (a.length &lt; size)</span>
<span class="nc" id="L1027">                a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span>
<span class="fc" id="L1028">            Object[] tab = table;</span>
<span class="fc" id="L1029">            int ti = 0;</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">            for (int si = 0; si &lt; tab.length; si += 2) {</span>
                Object key;
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">                if ((key = tab[si]) != null) { // key present ?</span>
                    // more elements than expected -&gt; concurrent modification from other thread
<span class="nc bnc" id="L1034" title="All 2 branches missed.">                    if (ti &gt;= size) {</span>
<span class="nc" id="L1035">                        throw new ConcurrentModificationException();</span>
                    }
<span class="nc" id="L1037">                    a[ti++] = (T) unmaskNull(key); // unmask key</span>
                }
            }
            // fewer elements than expected or concurrent modification from other thread detected
<span class="pc bpc" id="L1041" title="2 of 4 branches missed.">            if (ti &lt; size || expectedModCount != modCount) {</span>
<span class="nc" id="L1042">                throw new ConcurrentModificationException();</span>
            }
            // final null marker as per spec
<span class="fc bfc" id="L1045" title="All 2 branches covered.">            if (ti &lt; a.length) {</span>
<span class="fc" id="L1046">                a[ti] = null;</span>
            }
<span class="fc" id="L1048">            return a;</span>
        }

        public Spliterator&lt;K&gt; spliterator() {
<span class="fc" id="L1052">            return new KeySpliterator&lt;&gt;(IdentityHashMap.this, 0, -1, 0, 0);</span>
        }
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.  If the map is
     * modified while an iteration over the collection is in progress,
     * the results of the iteration are undefined.  The collection
     * supports element removal, which removes the corresponding
     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; methods.  It does not
     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; methods.
     *
     * &lt;p&gt;&lt;b&gt;While the object returned by this method implements the
     * &lt;tt&gt;Collection&lt;/tt&gt; interface, it does &lt;i&gt;not&lt;/i&gt; obey
     * &lt;tt&gt;Collection's&lt;/tt&gt; general contract.  Like its backing map,
     * the collection returned by this method defines element equality as
     * reference-equality rather than object-equality.  This affects the
     * behavior of its &lt;tt&gt;contains&lt;/tt&gt;, &lt;tt&gt;remove&lt;/tt&gt; and
     * &lt;tt&gt;containsAll&lt;/tt&gt; methods.&lt;/b&gt;
     */
    public Collection&lt;V&gt; values() {
<span class="fc" id="L1077">        Collection&lt;V&gt; vs = values;</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">        if (vs != null)</span>
<span class="fc" id="L1079">            return vs;</span>
        else
<span class="fc" id="L1081">            return values = new Values();</span>
    }

<span class="fc" id="L1084">    private class Values extends AbstractCollection&lt;V&gt; {</span>
        public Iterator&lt;V&gt; iterator() {
<span class="fc" id="L1086">            return new ValueIterator();</span>
        }
        public int size() {
<span class="fc" id="L1089">            return size;</span>
        }
        public boolean contains(Object o) {
<span class="nc" id="L1092">            return containsValue(o);</span>
        }
        public boolean remove(Object o) {
<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">            for (Iterator&lt;V&gt; i = iterator(); i.hasNext(); ) {</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">                if (i.next() == o) {</span>
<span class="fc" id="L1097">                    i.remove();</span>
<span class="fc" id="L1098">                    return true;</span>
                }
            }
<span class="nc" id="L1101">            return false;</span>
        }
        public void clear() {
<span class="nc" id="L1104">            IdentityHashMap.this.clear();</span>
<span class="nc" id="L1105">        }</span>
        public Object[] toArray() {
<span class="fc" id="L1107">            return toArray(new Object[0]);</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;T&gt; T[] toArray(T[] a) {
<span class="fc" id="L1111">            int expectedModCount = modCount;</span>
<span class="fc" id="L1112">            int size = size();</span>
<span class="pc bpc" id="L1113" title="1 of 2 branches missed.">            if (a.length &lt; size)</span>
<span class="nc" id="L1114">                a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span>
<span class="fc" id="L1115">            Object[] tab = table;</span>
<span class="fc" id="L1116">            int ti = 0;</span>
<span class="fc bfc" id="L1117" title="All 2 branches covered.">            for (int si = 0; si &lt; tab.length; si += 2) {</span>
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">                if (tab[si] != null) { // key present ?</span>
                    // more elements than expected -&gt; concurrent modification from other thread
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                    if (ti &gt;= size) {</span>
<span class="nc" id="L1121">                        throw new ConcurrentModificationException();</span>
                    }
<span class="nc" id="L1123">                    a[ti++] = (T) tab[si+1]; // copy value</span>
                }
            }
            // fewer elements than expected or concurrent modification from other thread detected
<span class="pc bpc" id="L1127" title="2 of 4 branches missed.">            if (ti &lt; size || expectedModCount != modCount) {</span>
<span class="nc" id="L1128">                throw new ConcurrentModificationException();</span>
            }
            // final null marker as per spec
<span class="fc bfc" id="L1131" title="All 2 branches covered.">            if (ti &lt; a.length) {</span>
<span class="fc" id="L1132">                a[ti] = null;</span>
            }
<span class="fc" id="L1134">            return a;</span>
        }

        public Spliterator&lt;V&gt; spliterator() {
<span class="fc" id="L1138">            return new ValueSpliterator&lt;&gt;(IdentityHashMap.this, 0, -1, 0, 0);</span>
        }
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * Each element in the returned set is a reference-equality-based
     * &lt;tt&gt;Map.Entry&lt;/tt&gt;.  The set is backed by the map, so changes
     * to the map are reflected in the set, and vice-versa.  If the
     * map is modified while an iteration over the set is in progress,
     * the results of the iteration are undefined.  The set supports
     * element removal, which removes the corresponding mapping from
     * the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt;
     * methods.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or
     * &lt;tt&gt;addAll&lt;/tt&gt; methods.
     *
     * &lt;p&gt;Like the backing map, the &lt;tt&gt;Map.Entry&lt;/tt&gt; objects in the set
     * returned by this method define key and value equality as
     * reference-equality rather than object-equality.  This affects the
     * behavior of the &lt;tt&gt;equals&lt;/tt&gt; and &lt;tt&gt;hashCode&lt;/tt&gt; methods of these
     * &lt;tt&gt;Map.Entry&lt;/tt&gt; objects.  A reference-equality based &lt;tt&gt;Map.Entry
     * e&lt;/tt&gt; is equal to an object &lt;tt&gt;o&lt;/tt&gt; if and only if &lt;tt&gt;o&lt;/tt&gt; is a
     * &lt;tt&gt;Map.Entry&lt;/tt&gt; and &lt;tt&gt;e.getKey()==o.getKey() &amp;amp;&amp;amp;
     * e.getValue()==o.getValue()&lt;/tt&gt;.  To accommodate these equals
     * semantics, the &lt;tt&gt;hashCode&lt;/tt&gt; method returns
     * &lt;tt&gt;System.identityHashCode(e.getKey()) ^
     * System.identityHashCode(e.getValue())&lt;/tt&gt;.
     *
     * &lt;p&gt;&lt;b&gt;Owing to the reference-equality-based semantics of the
     * &lt;tt&gt;Map.Entry&lt;/tt&gt; instances in the set returned by this method,
     * it is possible that the symmetry and transitivity requirements of
     * the {@link Object#equals(Object)} contract may be violated if any of
     * the entries in the set is compared to a normal map entry, or if
     * the set returned by this method is compared to a set of normal map
     * entries (such as would be returned by a call to this method on a normal
     * map).  However, the &lt;tt&gt;Object.equals&lt;/tt&gt; contract is guaranteed to
     * hold among identity-based map entries, and among sets of such entries.
     * &lt;/b&gt;
     *
     * @return a set view of the identity-mappings contained in this map
     */
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<span class="fc" id="L1181">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span>
<span class="fc bfc" id="L1182" title="All 2 branches covered.">        if (es != null)</span>
<span class="fc" id="L1183">            return es;</span>
        else
<span class="fc" id="L1185">            return entrySet = new EntrySet();</span>
    }

<span class="fc" id="L1188">    private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {</span>
        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
<span class="fc" id="L1190">            return new EntryIterator();</span>
        }
        public boolean contains(Object o) {
<span class="nc bnc" id="L1193" title="All 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L1194">                return false;</span>
<span class="nc" id="L1195">            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span>
<span class="nc" id="L1196">            return containsMapping(entry.getKey(), entry.getValue());</span>
        }
        public boolean remove(Object o) {
<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L1200">                return false;</span>
<span class="fc" id="L1201">            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span>
<span class="fc" id="L1202">            return removeMapping(entry.getKey(), entry.getValue());</span>
        }
        public int size() {
<span class="fc" id="L1205">            return size;</span>
        }
        public void clear() {
<span class="nc" id="L1208">            IdentityHashMap.this.clear();</span>
<span class="nc" id="L1209">        }</span>
        /*
         * Must revert from AbstractSet's impl to AbstractCollection's, as
         * the former contains an optimization that results in incorrect
         * behavior when c is a smaller &quot;normal&quot; (non-identity-based) Set.
         */
        public boolean removeAll(Collection&lt;?&gt; c) {
<span class="nc" id="L1216">            Objects.requireNonNull(c);</span>
<span class="nc" id="L1217">            boolean modified = false;</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">            for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = iterator(); i.hasNext(); ) {</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">                if (c.contains(i.next())) {</span>
<span class="nc" id="L1220">                    i.remove();</span>
<span class="nc" id="L1221">                    modified = true;</span>
                }
            }
<span class="nc" id="L1224">            return modified;</span>
        }

        public Object[] toArray() {
<span class="fc" id="L1228">            return toArray(new Object[0]);</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;T&gt; T[] toArray(T[] a) {
<span class="fc" id="L1233">            int expectedModCount = modCount;</span>
<span class="fc" id="L1234">            int size = size();</span>
<span class="pc bpc" id="L1235" title="1 of 2 branches missed.">            if (a.length &lt; size)</span>
<span class="nc" id="L1236">                a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span>
<span class="fc" id="L1237">            Object[] tab = table;</span>
<span class="fc" id="L1238">            int ti = 0;</span>
<span class="fc bfc" id="L1239" title="All 2 branches covered.">            for (int si = 0; si &lt; tab.length; si += 2) {</span>
                Object key;
<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">                if ((key = tab[si]) != null) { // key present ?</span>
                    // more elements than expected -&gt; concurrent modification from other thread
<span class="nc bnc" id="L1243" title="All 2 branches missed.">                    if (ti &gt;= size) {</span>
<span class="nc" id="L1244">                        throw new ConcurrentModificationException();</span>
                    }
<span class="nc" id="L1246">                    a[ti++] = (T) new AbstractMap.SimpleEntry&lt;&gt;(unmaskNull(key), tab[si + 1]);</span>
                }
            }
            // fewer elements than expected or concurrent modification from other thread detected
<span class="pc bpc" id="L1250" title="2 of 4 branches missed.">            if (ti &lt; size || expectedModCount != modCount) {</span>
<span class="nc" id="L1251">                throw new ConcurrentModificationException();</span>
            }
            // final null marker as per spec
<span class="fc bfc" id="L1254" title="All 2 branches covered.">            if (ti &lt; a.length) {</span>
<span class="fc" id="L1255">                a[ti] = null;</span>
            }
<span class="fc" id="L1257">            return a;</span>
        }

        public Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
<span class="fc" id="L1261">            return new EntrySpliterator&lt;&gt;(IdentityHashMap.this, 0, -1, 0, 0);</span>
        }
    }


    private static final long serialVersionUID = 8188218128353913216L;

    /**
     * Save the state of the &lt;tt&gt;IdentityHashMap&lt;/tt&gt; instance to a stream
     * (i.e., serialize it).
     *
     * @serialData The &lt;i&gt;size&lt;/i&gt; of the HashMap (the number of key-value
     *          mappings) (&lt;tt&gt;int&lt;/tt&gt;), followed by the key (Object) and
     *          value (Object) for each key-value mapping represented by the
     *          IdentityHashMap.  The key-value mappings are emitted in no
     *          particular order.
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException  {
        // Write out and any hidden stuff
<span class="nc" id="L1281">        s.defaultWriteObject();</span>

        // Write out size (number of Mappings)
<span class="nc" id="L1284">        s.writeInt(size);</span>

        // Write out keys and values (alternating)
<span class="nc" id="L1287">        Object[] tab = table;</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">        for (int i = 0; i &lt; tab.length; i += 2) {</span>
<span class="nc" id="L1289">            Object key = tab[i];</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">            if (key != null) {</span>
<span class="nc" id="L1291">                s.writeObject(unmaskNull(key));</span>
<span class="nc" id="L1292">                s.writeObject(tab[i + 1]);</span>
            }
        }
<span class="nc" id="L1295">    }</span>

    /**
     * Reconstitute the &lt;tt&gt;IdentityHashMap&lt;/tt&gt; instance from a stream (i.e.,
     * deserialize it).
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException  {
        // Read in any hidden stuff
<span class="nc" id="L1304">        s.defaultReadObject();</span>

        // Read in size (number of Mappings)
<span class="nc" id="L1307">        int size = s.readInt();</span>

        // Allow for 33% growth (i.e., capacity is &gt;= 2* size()).
<span class="nc" id="L1310">        init(capacity((size*4)/3));</span>

        // Read the keys and values, and put the mappings in the table
<span class="nc bnc" id="L1313" title="All 2 branches missed.">        for (int i=0; i&lt;size; i++) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1315">                K key = (K) s.readObject();</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1317">                V value = (V) s.readObject();</span>
<span class="nc" id="L1318">            putForCreate(key, value);</span>
        }
<span class="nc" id="L1320">    }</span>

    /**
     * The put method for readObject.  It does not resize the table,
     * update modCount, etc.
     */
    private void putForCreate(K key, V value)
        throws IOException
    {
<span class="nc" id="L1329">        Object k = maskNull(key);</span>
<span class="nc" id="L1330">        Object[] tab = table;</span>
<span class="nc" id="L1331">        int len = tab.length;</span>
<span class="nc" id="L1332">        int i = hash(k, len);</span>

        Object item;
<span class="nc bnc" id="L1335" title="All 2 branches missed.">        while ( (item = tab[i]) != null) {</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">            if (item == k)</span>
<span class="nc" id="L1337">                throw new java.io.StreamCorruptedException();</span>
<span class="nc" id="L1338">            i = nextKeyIndex(i, len);</span>
        }
<span class="nc" id="L1340">        tab[i] = k;</span>
<span class="nc" id="L1341">        tab[i + 1] = value;</span>
<span class="nc" id="L1342">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<span class="nc" id="L1347">        Objects.requireNonNull(action);</span>
<span class="nc" id="L1348">        int expectedModCount = modCount;</span>

<span class="nc" id="L1350">        Object[] t = table;</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">        for (int index = 0; index &lt; t.length; index += 2) {</span>
<span class="nc" id="L1352">            Object k = t[index];</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">            if (k != null) {</span>
<span class="nc" id="L1354">                action.accept((K) unmaskNull(k), (V) t[index + 1]);</span>
            }

<span class="nc bnc" id="L1357" title="All 2 branches missed.">            if (modCount != expectedModCount) {</span>
<span class="nc" id="L1358">                throw new ConcurrentModificationException();</span>
            }
        }
<span class="nc" id="L1361">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
<span class="nc" id="L1366">        Objects.requireNonNull(function);</span>
<span class="nc" id="L1367">        int expectedModCount = modCount;</span>

<span class="nc" id="L1369">        Object[] t = table;</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">        for (int index = 0; index &lt; t.length; index += 2) {</span>
<span class="nc" id="L1371">            Object k = t[index];</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">            if (k != null) {</span>
<span class="nc" id="L1373">                t[index + 1] = function.apply((K) unmaskNull(k), (V) t[index + 1]);</span>
            }

<span class="nc bnc" id="L1376" title="All 2 branches missed.">            if (modCount != expectedModCount) {</span>
<span class="nc" id="L1377">                throw new ConcurrentModificationException();</span>
            }
        }
<span class="nc" id="L1380">    }</span>

    /**
     * Similar form as array-based Spliterators, but skips blank elements,
     * and guestimates size as decreasing by half per split.
     */
    static class IdentityHashMapSpliterator&lt;K,V&gt; {
        final IdentityHashMap&lt;K,V&gt; map;
        int index;             // current index, modified on advance/split
        int fence;             // -1 until first use; then one past last index
        int est;               // size estimate
        int expectedModCount;  // initialized when fence set

        IdentityHashMapSpliterator(IdentityHashMap&lt;K,V&gt; map, int origin,
<span class="fc" id="L1394">                                   int fence, int est, int expectedModCount) {</span>
<span class="fc" id="L1395">            this.map = map;</span>
<span class="fc" id="L1396">            this.index = origin;</span>
<span class="fc" id="L1397">            this.fence = fence;</span>
<span class="fc" id="L1398">            this.est = est;</span>
<span class="fc" id="L1399">            this.expectedModCount = expectedModCount;</span>
<span class="fc" id="L1400">        }</span>

        final int getFence() { // initialize fence and size on first use
            int hi;
<span class="nc bnc" id="L1404" title="All 2 branches missed.">            if ((hi = fence) &lt; 0) {</span>
<span class="nc" id="L1405">                est = map.size;</span>
<span class="nc" id="L1406">                expectedModCount = map.modCount;</span>
<span class="nc" id="L1407">                hi = fence = map.table.length;</span>
            }
<span class="nc" id="L1409">            return hi;</span>
        }

        public final long estimateSize() {
<span class="nc" id="L1413">            getFence(); // force init</span>
<span class="nc" id="L1414">            return (long) est;</span>
        }
    }

    static final class KeySpliterator&lt;K,V&gt;
        extends IdentityHashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;K&gt; {
        KeySpliterator(IdentityHashMap&lt;K,V&gt; map, int origin, int fence, int est,
                       int expectedModCount) {
<span class="fc" id="L1423">            super(map, origin, fence, est, expectedModCount);</span>
<span class="fc" id="L1424">        }</span>

        public KeySpliterator&lt;K,V&gt; trySplit() {
<span class="nc" id="L1427">            int hi = getFence(), lo = index, mid = ((lo + hi) &gt;&gt;&gt; 1) &amp; ~1;</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">            return (lo &gt;= mid) ? null :</span>
                new KeySpliterator&lt;K,V&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                        expectedModCount);
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void forEachRemaining(Consumer&lt;? super K&gt; action) {
<span class="nc bnc" id="L1435" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1436">                throw new NullPointerException();</span>
            int i, hi, mc; Object key;
            IdentityHashMap&lt;K,V&gt; m; Object[] a;
<span class="nc bnc" id="L1439" title="All 6 branches missed.">            if ((m = map) != null &amp;&amp; (a = m.table) != null &amp;&amp;</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">                (i = index) &gt;= 0 &amp;&amp; (index = hi = getFence()) &lt;= a.length) {</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">                for (; i &lt; hi; i += 2) {</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">                    if ((key = a[i]) != null)</span>
<span class="nc" id="L1443">                        action.accept((K)unmaskNull(key));</span>
                }
<span class="nc bnc" id="L1445" title="All 2 branches missed.">                if (m.modCount == expectedModCount)</span>
<span class="nc" id="L1446">                    return;</span>
            }
<span class="nc" id="L1448">            throw new ConcurrentModificationException();</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
<span class="nc bnc" id="L1453" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1454">                throw new NullPointerException();</span>
<span class="nc" id="L1455">            Object[] a = map.table;</span>
<span class="nc" id="L1456">            int hi = getFence();</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">            while (index &lt; hi) {</span>
<span class="nc" id="L1458">                Object key = a[index];</span>
<span class="nc" id="L1459">                index += 2;</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">                if (key != null) {</span>
<span class="nc" id="L1461">                    action.accept((K)unmaskNull(key));</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">                    if (map.modCount != expectedModCount)</span>
<span class="nc" id="L1463">                        throw new ConcurrentModificationException();</span>
<span class="nc" id="L1464">                    return true;</span>
                }
<span class="nc" id="L1466">            }</span>
<span class="nc" id="L1467">            return false;</span>
        }

        public int characteristics() {
<span class="pc bpc" id="L1471" title="3 of 4 branches missed.">            return (fence &lt; 0 || est == map.size ? SIZED : 0) | Spliterator.DISTINCT;</span>
        }
    }

    static final class ValueSpliterator&lt;K,V&gt;
        extends IdentityHashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;V&gt; {
        ValueSpliterator(IdentityHashMap&lt;K,V&gt; m, int origin, int fence, int est,
                         int expectedModCount) {
<span class="fc" id="L1480">            super(m, origin, fence, est, expectedModCount);</span>
<span class="fc" id="L1481">        }</span>

        public ValueSpliterator&lt;K,V&gt; trySplit() {
<span class="nc" id="L1484">            int hi = getFence(), lo = index, mid = ((lo + hi) &gt;&gt;&gt; 1) &amp; ~1;</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">            return (lo &gt;= mid) ? null :</span>
                new ValueSpliterator&lt;K,V&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                          expectedModCount);
        }

        public void forEachRemaining(Consumer&lt;? super V&gt; action) {
<span class="nc bnc" id="L1491" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1492">                throw new NullPointerException();</span>
            int i, hi, mc;
            IdentityHashMap&lt;K,V&gt; m; Object[] a;
<span class="nc bnc" id="L1495" title="All 6 branches missed.">            if ((m = map) != null &amp;&amp; (a = m.table) != null &amp;&amp;</span>
<span class="nc bnc" id="L1496" title="All 2 branches missed.">                (i = index) &gt;= 0 &amp;&amp; (index = hi = getFence()) &lt;= a.length) {</span>
<span class="nc bnc" id="L1497" title="All 2 branches missed.">                for (; i &lt; hi; i += 2) {</span>
<span class="nc bnc" id="L1498" title="All 2 branches missed.">                    if (a[i] != null) {</span>
<span class="nc" id="L1499">                        @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[i+1];</span>
<span class="nc" id="L1500">                        action.accept(v);</span>
                    }
                }
<span class="nc bnc" id="L1503" title="All 2 branches missed.">                if (m.modCount == expectedModCount)</span>
<span class="nc" id="L1504">                    return;</span>
            }
<span class="nc" id="L1506">            throw new ConcurrentModificationException();</span>
        }

        public boolean tryAdvance(Consumer&lt;? super V&gt; action) {
<span class="nc bnc" id="L1510" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1511">                throw new NullPointerException();</span>
<span class="nc" id="L1512">            Object[] a = map.table;</span>
<span class="nc" id="L1513">            int hi = getFence();</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">            while (index &lt; hi) {</span>
<span class="nc" id="L1515">                Object key = a[index];</span>
<span class="nc" id="L1516">                @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[index+1];</span>
<span class="nc" id="L1517">                index += 2;</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">                if (key != null) {</span>
<span class="nc" id="L1519">                    action.accept(v);</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">                    if (map.modCount != expectedModCount)</span>
<span class="nc" id="L1521">                        throw new ConcurrentModificationException();</span>
<span class="nc" id="L1522">                    return true;</span>
                }
<span class="nc" id="L1524">            }</span>
<span class="nc" id="L1525">            return false;</span>
        }

        public int characteristics() {
<span class="pc bpc" id="L1529" title="3 of 4 branches missed.">            return (fence &lt; 0 || est == map.size ? SIZED : 0);</span>
        }

    }

    static final class EntrySpliterator&lt;K,V&gt;
        extends IdentityHashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        EntrySpliterator(IdentityHashMap&lt;K,V&gt; m, int origin, int fence, int est,
                         int expectedModCount) {
<span class="fc" id="L1539">            super(m, origin, fence, est, expectedModCount);</span>
<span class="fc" id="L1540">        }</span>

        public EntrySpliterator&lt;K,V&gt; trySplit() {
<span class="nc" id="L1543">            int hi = getFence(), lo = index, mid = ((lo + hi) &gt;&gt;&gt; 1) &amp; ~1;</span>
<span class="nc bnc" id="L1544" title="All 2 branches missed.">            return (lo &gt;= mid) ? null :</span>
                new EntrySpliterator&lt;K,V&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                          expectedModCount);
        }

        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K, V&gt;&gt; action) {
<span class="nc bnc" id="L1550" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1551">                throw new NullPointerException();</span>
            int i, hi, mc;
            IdentityHashMap&lt;K,V&gt; m; Object[] a;
<span class="nc bnc" id="L1554" title="All 6 branches missed.">            if ((m = map) != null &amp;&amp; (a = m.table) != null &amp;&amp;</span>
<span class="nc bnc" id="L1555" title="All 2 branches missed.">                (i = index) &gt;= 0 &amp;&amp; (index = hi = getFence()) &lt;= a.length) {</span>
<span class="nc bnc" id="L1556" title="All 2 branches missed.">                for (; i &lt; hi; i += 2) {</span>
<span class="nc" id="L1557">                    Object key = a[i];</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">                    if (key != null) {</span>
<span class="nc" id="L1559">                        @SuppressWarnings(&quot;unchecked&quot;) K k =</span>
<span class="nc" id="L1560">                            (K)unmaskNull(key);</span>
<span class="nc" id="L1561">                        @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[i+1];</span>
<span class="nc" id="L1562">                        action.accept</span>
<span class="nc" id="L1563">                            (new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v));</span>

                    }
                }
<span class="nc bnc" id="L1567" title="All 2 branches missed.">                if (m.modCount == expectedModCount)</span>
<span class="nc" id="L1568">                    return;</span>
            }
<span class="nc" id="L1570">            throw new ConcurrentModificationException();</span>
        }

        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
<span class="nc bnc" id="L1574" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1575">                throw new NullPointerException();</span>
<span class="nc" id="L1576">            Object[] a = map.table;</span>
<span class="nc" id="L1577">            int hi = getFence();</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">            while (index &lt; hi) {</span>
<span class="nc" id="L1579">                Object key = a[index];</span>
<span class="nc" id="L1580">                @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[index+1];</span>
<span class="nc" id="L1581">                index += 2;</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">                if (key != null) {</span>
<span class="nc" id="L1583">                    @SuppressWarnings(&quot;unchecked&quot;) K k =</span>
<span class="nc" id="L1584">                        (K)unmaskNull(key);</span>
<span class="nc" id="L1585">                    action.accept</span>
<span class="nc" id="L1586">                        (new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v));</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">                    if (map.modCount != expectedModCount)</span>
<span class="nc" id="L1588">                        throw new ConcurrentModificationException();</span>
<span class="nc" id="L1589">                    return true;</span>
                }
<span class="nc" id="L1591">            }</span>
<span class="nc" id="L1592">            return false;</span>
        }

        public int characteristics() {
<span class="pc bpc" id="L1596" title="3 of 4 branches missed.">            return (fence &lt; 0 || est == map.size ? SIZED : 0) | Spliterator.DISTINCT;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>