<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Properties.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">Properties.java</span></div><h1>Properties.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.BufferedWriter;
import java.security.AccessController;
import java.security.PrivilegedAction;

import sun.util.spi.XmlPropertiesProvider;

/**
 * The {@code Properties} class represents a persistent set of
 * properties. The {@code Properties} can be saved to a stream
 * or loaded from a stream. Each key and its corresponding value in
 * the property list is a string.
 * &lt;p&gt;
 * A property list can contain another property list as its
 * &quot;defaults&quot;; this second property list is searched if
 * the property key is not found in the original property list.
 * &lt;p&gt;
 * Because {@code Properties} inherits from {@code Hashtable}, the
 * {@code put} and {@code putAll} methods can be applied to a
 * {@code Properties} object.  Their use is strongly discouraged as they
 * allow the caller to insert entries whose keys or values are not
 * {@code Strings}.  The {@code setProperty} method should be used
 * instead.  If the {@code store} or {@code save} method is called
 * on a &quot;compromised&quot; {@code Properties} object that contains a
 * non-{@code String} key or value, the call will fail. Similarly,
 * the call to the {@code propertyNames} or {@code list} method
 * will fail if it is called on a &quot;compromised&quot; {@code Properties}
 * object that contains a non-{@code String} key.
 *
 * &lt;p&gt;
 * The {@link #load(java.io.Reader) load(Reader)} &lt;tt&gt;/&lt;/tt&gt;
 * {@link #store(java.io.Writer, java.lang.String) store(Writer, String)}
 * methods load and store properties from and to a character based stream
 * in a simple line-oriented format specified below.
 *
 * The {@link #load(java.io.InputStream) load(InputStream)} &lt;tt&gt;/&lt;/tt&gt;
 * {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)}
 * methods work the same way as the load(Reader)/store(Writer, String) pair, except
 * the input/output stream is encoded in ISO 8859-1 character encoding.
 * Characters that cannot be directly represented in this encoding can be written using
 * Unicode escapes as defined in section 3.3 of
 * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;;
 * only a single 'u' character is allowed in an escape
 * sequence. The native2ascii tool can be used to convert property files to and
 * from other character encodings.
 *
 * &lt;p&gt; The {@link #loadFromXML(InputStream)} and {@link
 * #storeToXML(OutputStream, String, String)} methods load and store properties
 * in a simple XML format.  By default the UTF-8 character encoding is used,
 * however a specific encoding may be specified if required. Implementations
 * are required to support UTF-8 and UTF-16 and may support other encodings.
 * An XML properties document has the following DOCTYPE declaration:
 *
 * &lt;pre&gt;
 * &amp;lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&amp;gt;
 * &lt;/pre&gt;
 * Note that the system URI (http://java.sun.com/dtd/properties.dtd) is
 * &lt;i&gt;not&lt;/i&gt; accessed when exporting or importing properties; it merely
 * serves as a string to uniquely identify the DTD, which is:
 * &lt;pre&gt;
 *    &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
 *
 *    &amp;lt;!-- DTD for properties --&amp;gt;
 *
 *    &amp;lt;!ELEMENT properties ( comment?, entry* ) &amp;gt;
 *
 *    &amp;lt;!ATTLIST properties version CDATA #FIXED &quot;1.0&quot;&amp;gt;
 *
 *    &amp;lt;!ELEMENT comment (#PCDATA) &amp;gt;
 *
 *    &amp;lt;!ELEMENT entry (#PCDATA) &amp;gt;
 *
 *    &amp;lt;!ATTLIST entry key CDATA #REQUIRED&amp;gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;This class is thread-safe: multiple threads can share a single
 * &lt;tt&gt;Properties&lt;/tt&gt; object without the need for external synchronization.
 *
 * @see &lt;a href=&quot;../../../technotes/tools/solaris/native2ascii.html&quot;&gt;native2ascii tool for Solaris&lt;/a&gt;
 * @see &lt;a href=&quot;../../../technotes/tools/windows/native2ascii.html&quot;&gt;native2ascii tool for Windows&lt;/a&gt;
 *
 * @author  Arthur van Hoff
 * @author  Michael McCloskey
 * @author  Xueming Shen
 * @since   JDK1.0
 */
public
class Properties extends Hashtable&lt;Object,Object&gt; {
    /**
     * use serialVersionUID from JDK 1.1.X for interoperability
     */
     private static final long serialVersionUID = 4112578634029874840L;

    /**
     * A property list that contains default values for any keys not
     * found in this property list.
     *
     * @serial
     */
    protected Properties defaults;

    /**
     * Creates an empty property list with no default values.
     */
    public Properties() {
<span class="nc" id="L140">        this(null);</span>
<span class="nc" id="L141">    }</span>

    /**
     * Creates an empty property list with the specified defaults.
     *
     * @param   defaults   the defaults.
     */
<span class="nc" id="L148">    public Properties(Properties defaults) {</span>
<span class="nc" id="L149">        this.defaults = defaults;</span>
<span class="nc" id="L150">    }</span>

    /**
     * Calls the &lt;tt&gt;Hashtable&lt;/tt&gt; method {@code put}. Provided for
     * parallelism with the &lt;tt&gt;getProperty&lt;/tt&gt; method. Enforces use of
     * strings for property keys and values. The value returned is the
     * result of the &lt;tt&gt;Hashtable&lt;/tt&gt; call to {@code put}.
     *
     * @param key the key to be placed into this property list.
     * @param value the value corresponding to &lt;tt&gt;key&lt;/tt&gt;.
     * @return     the previous value of the specified key in this property
     *             list, or {@code null} if it did not have one.
     * @see #getProperty
     * @since    1.2
     */
    public synchronized Object setProperty(String key, String value) {
<span class="nc" id="L166">        return put(key, value);</span>
    }


    /**
     * Reads a property list (key and element pairs) from the input
     * character stream in a simple line-oriented format.
     * &lt;p&gt;
     * Properties are processed in terms of lines. There are two
     * kinds of line, &lt;i&gt;natural lines&lt;/i&gt; and &lt;i&gt;logical lines&lt;/i&gt;.
     * A natural line is defined as a line of
     * characters that is terminated either by a set of line terminator
     * characters ({@code \n} or {@code \r} or {@code \r\n})
     * or by the end of the stream. A natural line may be either a blank line,
     * a comment line, or hold all or some of a key-element pair. A logical
     * line holds all the data of a key-element pair, which may be spread
     * out across several adjacent natural lines by escaping
     * the line terminator sequence with a backslash character
     * {@code \}.  Note that a comment line cannot be extended
     * in this manner; every natural line that is a comment must have
     * its own comment indicator, as described below. Lines are read from
     * input until the end of the stream is reached.
     *
     * &lt;p&gt;
     * A natural line that contains only white space characters is
     * considered blank and is ignored.  A comment line has an ASCII
     * {@code '#'} or {@code '!'} as its first non-white
     * space character; comment lines are also ignored and do not
     * encode key-element information.  In addition to line
     * terminators, this format considers the characters space
     * ({@code ' '}, {@code '\u005Cu0020'}), tab
     * ({@code '\t'}, {@code '\u005Cu0009'}), and form feed
     * ({@code '\f'}, {@code '\u005Cu000C'}) to be white
     * space.
     *
     * &lt;p&gt;
     * If a logical line is spread across several natural lines, the
     * backslash escaping the line terminator sequence, the line
     * terminator sequence, and any white space at the start of the
     * following line have no affect on the key or element values.
     * The remainder of the discussion of key and element parsing
     * (when loading) will assume all the characters constituting
     * the key and element appear on a single natural line after
     * line continuation characters have been removed.  Note that
     * it is &lt;i&gt;not&lt;/i&gt; sufficient to only examine the character
     * preceding a line terminator sequence to decide if the line
     * terminator is escaped; there must be an odd number of
     * contiguous backslashes for the line terminator to be escaped.
     * Since the input is processed from left to right, a
     * non-zero even number of 2&lt;i&gt;n&lt;/i&gt; contiguous backslashes
     * before a line terminator (or elsewhere) encodes &lt;i&gt;n&lt;/i&gt;
     * backslashes after escape processing.
     *
     * &lt;p&gt;
     * The key contains all of the characters in the line starting
     * with the first non-white space character and up to, but not
     * including, the first unescaped {@code '='},
     * {@code ':'}, or white space character other than a line
     * terminator. All of these key termination characters may be
     * included in the key by escaping them with a preceding backslash
     * character; for example,&lt;p&gt;
     *
     * {@code \:\=}&lt;p&gt;
     *
     * would be the two-character key {@code &quot;:=&quot;}.  Line
     * terminator characters can be included using {@code \r} and
     * {@code \n} escape sequences.  Any white space after the
     * key is skipped; if the first non-white space character after
     * the key is {@code '='} or {@code ':'}, then it is
     * ignored and any white space characters after it are also
     * skipped.  All remaining characters on the line become part of
     * the associated element string; if there are no remaining
     * characters, the element is the empty string
     * {@code &quot;&quot;}.  Once the raw character sequences
     * constituting the key and element are identified, escape
     * processing is performed as described above.
     *
     * &lt;p&gt;
     * As an example, each of the following three lines specifies the key
     * {@code &quot;Truth&quot;} and the associated element value
     * {@code &quot;Beauty&quot;}:
     * &lt;pre&gt;
     * Truth = Beauty
     *  Truth:Beauty
     * Truth                    :Beauty
     * &lt;/pre&gt;
     * As another example, the following three lines specify a single
     * property:
     * &lt;pre&gt;
     * fruits                           apple, banana, pear, \
     *                                  cantaloupe, watermelon, \
     *                                  kiwi, mango
     * &lt;/pre&gt;
     * The key is {@code &quot;fruits&quot;} and the associated element is:
     * &lt;pre&gt;&quot;apple, banana, pear, cantaloupe, watermelon, kiwi, mango&quot;&lt;/pre&gt;
     * Note that a space appears before each {@code \} so that a space
     * will appear after each comma in the final result; the {@code \},
     * line terminator, and leading white space on the continuation line are
     * merely discarded and are &lt;i&gt;not&lt;/i&gt; replaced by one or more other
     * characters.
     * &lt;p&gt;
     * As a third example, the line:
     * &lt;pre&gt;cheeses
     * &lt;/pre&gt;
     * specifies that the key is {@code &quot;cheeses&quot;} and the associated
     * element is the empty string {@code &quot;&quot;}.
     * &lt;p&gt;
     * &lt;a name=&quot;unicodeescapes&quot;&gt;&lt;/a&gt;
     * Characters in keys and elements can be represented in escape
     * sequences similar to those used for character and string literals
     * (see sections 3.3 and 3.10.6 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;).
     *
     * The differences from the character escape sequences and Unicode
     * escapes used for characters and strings are:
     *
     * &lt;ul&gt;
     * &lt;li&gt; Octal escapes are not recognized.
     *
     * &lt;li&gt; The character sequence {@code \b} does &lt;i&gt;not&lt;/i&gt;
     * represent a backspace character.
     *
     * &lt;li&gt; The method does not treat a backslash character,
     * {@code \}, before a non-valid escape character as an
     * error; the backslash is silently dropped.  For example, in a
     * Java string the sequence {@code &quot;\z&quot;} would cause a
     * compile time error.  In contrast, this method silently drops
     * the backslash.  Therefore, this method treats the two character
     * sequence {@code &quot;\b&quot;} as equivalent to the single
     * character {@code 'b'}.
     *
     * &lt;li&gt; Escapes are not necessary for single and double quotes;
     * however, by the rule above, single and double quote characters
     * preceded by a backslash still yield single and double quote
     * characters, respectively.
     *
     * &lt;li&gt; Only a single 'u' character is allowed in a Unicode escape
     * sequence.
     *
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The specified stream remains open after this method returns.
     *
     * @param   reader   the input character stream.
     * @throws  IOException  if an error occurred when reading from the
     *          input stream.
     * @throws  IllegalArgumentException if a malformed Unicode escape
     *          appears in the input.
     * @since   1.6
     */
    public synchronized void load(Reader reader) throws IOException {
<span class="nc" id="L317">        load0(new LineReader(reader));</span>
<span class="nc" id="L318">    }</span>

    /**
     * Reads a property list (key and element pairs) from the input
     * byte stream. The input stream is in a simple line-oriented
     * format as specified in
     * {@link #load(java.io.Reader) load(Reader)} and is assumed to use
     * the ISO 8859-1 character encoding; that is each byte is one Latin1
     * character. Characters not in Latin1, and certain special characters,
     * are represented in keys and elements using Unicode escapes as defined in
     * section 3.3 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
     * &lt;p&gt;
     * The specified stream remains open after this method returns.
     *
     * @param      inStream   the input stream.
     * @exception  IOException  if an error occurred when reading from the
     *             input stream.
     * @throws     IllegalArgumentException if the input stream contains a
     *             malformed Unicode escape sequence.
     * @since 1.2
     */
    public synchronized void load(InputStream inStream) throws IOException {
<span class="nc" id="L341">        load0(new LineReader(inStream));</span>
<span class="nc" id="L342">    }</span>

    private void load0 (LineReader lr) throws IOException {
<span class="nc" id="L345">        char[] convtBuf = new char[1024];</span>
        int limit;
        int keyLen;
        int valueStart;
        char c;
        boolean hasSep;
        boolean precedingBackslash;

<span class="nc bnc" id="L353" title="All 2 branches missed.">        while ((limit = lr.readLine()) &gt;= 0) {</span>
<span class="nc" id="L354">            c = 0;</span>
<span class="nc" id="L355">            keyLen = 0;</span>
<span class="nc" id="L356">            valueStart = limit;</span>
<span class="nc" id="L357">            hasSep = false;</span>

            //System.out.println(&quot;line=&lt;&quot; + new String(lineBuf, 0, limit) + &quot;&gt;&quot;);
<span class="nc" id="L360">            precedingBackslash = false;</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">            while (keyLen &lt; limit) {</span>
<span class="nc" id="L362">                c = lr.lineBuf[keyLen];</span>
                //need check if escaped.
<span class="nc bnc" id="L364" title="All 6 branches missed.">                if ((c == '=' ||  c == ':') &amp;&amp; !precedingBackslash) {</span>
<span class="nc" id="L365">                    valueStart = keyLen + 1;</span>
<span class="nc" id="L366">                    hasSep = true;</span>
<span class="nc" id="L367">                    break;</span>
<span class="nc bnc" id="L368" title="All 8 branches missed.">                } else if ((c == ' ' || c == '\t' ||  c == '\f') &amp;&amp; !precedingBackslash) {</span>
<span class="nc" id="L369">                    valueStart = keyLen + 1;</span>
<span class="nc" id="L370">                    break;</span>
                }
<span class="nc bnc" id="L372" title="All 2 branches missed.">                if (c == '\\') {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">                    precedingBackslash = !precedingBackslash;</span>
                } else {
<span class="nc" id="L375">                    precedingBackslash = false;</span>
                }
<span class="nc" id="L377">                keyLen++;</span>
            }
<span class="nc bnc" id="L379" title="All 2 branches missed.">            while (valueStart &lt; limit) {</span>
<span class="nc" id="L380">                c = lr.lineBuf[valueStart];</span>
<span class="nc bnc" id="L381" title="All 6 branches missed.">                if (c != ' ' &amp;&amp; c != '\t' &amp;&amp;  c != '\f') {</span>
<span class="nc bnc" id="L382" title="All 6 branches missed.">                    if (!hasSep &amp;&amp; (c == '=' ||  c == ':')) {</span>
<span class="nc" id="L383">                        hasSep = true;</span>
                    } else {
                        break;
                    }
                }
<span class="nc" id="L388">                valueStart++;</span>
            }
<span class="nc" id="L390">            String key = loadConvert(lr.lineBuf, 0, keyLen, convtBuf);</span>
<span class="nc" id="L391">            String value = loadConvert(lr.lineBuf, valueStart, limit - valueStart, convtBuf);</span>
<span class="nc" id="L392">            put(key, value);</span>
<span class="nc" id="L393">        }</span>
<span class="nc" id="L394">    }</span>

    /* Read in a &quot;logical line&quot; from an InputStream/Reader, skip all comment
     * and blank lines and filter out those leading whitespace characters
     * (\u0020, \u0009 and \u000c) from the beginning of a &quot;natural line&quot;.
     * Method returns the char length of the &quot;logical line&quot; and stores
     * the line in &quot;lineBuf&quot;.
     */
    class LineReader {
<span class="nc" id="L403">        public LineReader(InputStream inStream) {</span>
<span class="nc" id="L404">            this.inStream = inStream;</span>
<span class="nc" id="L405">            inByteBuf = new byte[8192];</span>
<span class="nc" id="L406">        }</span>

<span class="nc" id="L408">        public LineReader(Reader reader) {</span>
<span class="nc" id="L409">            this.reader = reader;</span>
<span class="nc" id="L410">            inCharBuf = new char[8192];</span>
<span class="nc" id="L411">        }</span>

        byte[] inByteBuf;
        char[] inCharBuf;
<span class="nc" id="L415">        char[] lineBuf = new char[1024];</span>
<span class="nc" id="L416">        int inLimit = 0;</span>
<span class="nc" id="L417">        int inOff = 0;</span>
        InputStream inStream;
        Reader reader;

        int readLine() throws IOException {
<span class="nc" id="L422">            int len = 0;</span>
<span class="nc" id="L423">            char c = 0;</span>

<span class="nc" id="L425">            boolean skipWhiteSpace = true;</span>
<span class="nc" id="L426">            boolean isCommentLine = false;</span>
<span class="nc" id="L427">            boolean isNewLine = true;</span>
<span class="nc" id="L428">            boolean appendedLineBegin = false;</span>
<span class="nc" id="L429">            boolean precedingBackslash = false;</span>
<span class="nc" id="L430">            boolean skipLF = false;</span>

            while (true) {
<span class="nc bnc" id="L433" title="All 2 branches missed.">                if (inOff &gt;= inLimit) {</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                    inLimit = (inStream==null)?reader.read(inCharBuf)</span>
<span class="nc" id="L435">                                              :inStream.read(inByteBuf);</span>
<span class="nc" id="L436">                    inOff = 0;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                    if (inLimit &lt;= 0) {</span>
<span class="nc bnc" id="L438" title="All 4 branches missed.">                        if (len == 0 || isCommentLine) {</span>
<span class="nc" id="L439">                            return -1;</span>
                        }
<span class="nc bnc" id="L441" title="All 2 branches missed.">                        if (precedingBackslash) {</span>
<span class="nc" id="L442">                            len--;</span>
                        }
<span class="nc" id="L444">                        return len;</span>
                    }
                }
<span class="nc bnc" id="L447" title="All 2 branches missed.">                if (inStream != null) {</span>
                    //The line below is equivalent to calling a
                    //ISO8859-1 decoder.
<span class="nc" id="L450">                    c = (char) (0xff &amp; inByteBuf[inOff++]);</span>
                } else {
<span class="nc" id="L452">                    c = inCharBuf[inOff++];</span>
                }
<span class="nc bnc" id="L454" title="All 2 branches missed.">                if (skipLF) {</span>
<span class="nc" id="L455">                    skipLF = false;</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                    if (c == '\n') {</span>
<span class="nc" id="L457">                        continue;</span>
                    }
                }
<span class="nc bnc" id="L460" title="All 2 branches missed.">                if (skipWhiteSpace) {</span>
<span class="nc bnc" id="L461" title="All 6 branches missed.">                    if (c == ' ' || c == '\t' || c == '\f') {</span>
<span class="nc" id="L462">                        continue;</span>
                    }
<span class="nc bnc" id="L464" title="All 6 branches missed.">                    if (!appendedLineBegin &amp;&amp; (c == '\r' || c == '\n')) {</span>
<span class="nc" id="L465">                        continue;</span>
                    }
<span class="nc" id="L467">                    skipWhiteSpace = false;</span>
<span class="nc" id="L468">                    appendedLineBegin = false;</span>
                }
<span class="nc bnc" id="L470" title="All 2 branches missed.">                if (isNewLine) {</span>
<span class="nc" id="L471">                    isNewLine = false;</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">                    if (c == '#' || c == '!') {</span>
<span class="nc" id="L473">                        isCommentLine = true;</span>
<span class="nc" id="L474">                        continue;</span>
                    }
                }

<span class="nc bnc" id="L478" title="All 4 branches missed.">                if (c != '\n' &amp;&amp; c != '\r') {</span>
<span class="nc" id="L479">                    lineBuf[len++] = c;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">                    if (len == lineBuf.length) {</span>
<span class="nc" id="L481">                        int newLength = lineBuf.length * 2;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">                        if (newLength &lt; 0) {</span>
<span class="nc" id="L483">                            newLength = Integer.MAX_VALUE;</span>
                        }
<span class="nc" id="L485">                        char[] buf = new char[newLength];</span>
<span class="nc" id="L486">                        System.arraycopy(lineBuf, 0, buf, 0, lineBuf.length);</span>
<span class="nc" id="L487">                        lineBuf = buf;</span>
                    }
                    //flip the preceding backslash flag
<span class="nc bnc" id="L490" title="All 2 branches missed.">                    if (c == '\\') {</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">                        precedingBackslash = !precedingBackslash;</span>
                    } else {
<span class="nc" id="L493">                        precedingBackslash = false;</span>
                    }
                }
                else {
                    // reached EOL
<span class="nc bnc" id="L498" title="All 4 branches missed.">                    if (isCommentLine || len == 0) {</span>
<span class="nc" id="L499">                        isCommentLine = false;</span>
<span class="nc" id="L500">                        isNewLine = true;</span>
<span class="nc" id="L501">                        skipWhiteSpace = true;</span>
<span class="nc" id="L502">                        len = 0;</span>
<span class="nc" id="L503">                        continue;</span>
                    }
<span class="nc bnc" id="L505" title="All 2 branches missed.">                    if (inOff &gt;= inLimit) {</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                        inLimit = (inStream==null)</span>
<span class="nc" id="L507">                                  ?reader.read(inCharBuf)</span>
<span class="nc" id="L508">                                  :inStream.read(inByteBuf);</span>
<span class="nc" id="L509">                        inOff = 0;</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                        if (inLimit &lt;= 0) {</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">                            if (precedingBackslash) {</span>
<span class="nc" id="L512">                                len--;</span>
                            }
<span class="nc" id="L514">                            return len;</span>
                        }
                    }
<span class="nc bnc" id="L517" title="All 2 branches missed.">                    if (precedingBackslash) {</span>
<span class="nc" id="L518">                        len -= 1;</span>
                        //skip the leading whitespace characters in following line
<span class="nc" id="L520">                        skipWhiteSpace = true;</span>
<span class="nc" id="L521">                        appendedLineBegin = true;</span>
<span class="nc" id="L522">                        precedingBackslash = false;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">                        if (c == '\r') {</span>
<span class="nc" id="L524">                            skipLF = true;</span>
                        }
                    } else {
<span class="nc" id="L527">                        return len;</span>
                    }
                }
            }
        }
    }

    /*
     * Converts encoded &amp;#92;uxxxx to unicode chars
     * and changes special saved chars to their original forms
     */
    private String loadConvert (char[] in, int off, int len, char[] convtBuf) {
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (convtBuf.length &lt; len) {</span>
<span class="nc" id="L540">            int newLen = len * 2;</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">            if (newLen &lt; 0) {</span>
<span class="nc" id="L542">                newLen = Integer.MAX_VALUE;</span>
            }
<span class="nc" id="L544">            convtBuf = new char[newLen];</span>
        }
        char aChar;
<span class="nc" id="L547">        char[] out = convtBuf;</span>
<span class="nc" id="L548">        int outLen = 0;</span>
<span class="nc" id="L549">        int end = off + len;</span>

<span class="nc bnc" id="L551" title="All 2 branches missed.">        while (off &lt; end) {</span>
<span class="nc" id="L552">            aChar = in[off++];</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">            if (aChar == '\\') {</span>
<span class="nc" id="L554">                aChar = in[off++];</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">                if(aChar == 'u') {</span>
                    // Read the xxxx
<span class="nc" id="L557">                    int value=0;</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">                    for (int i=0; i&lt;4; i++) {</span>
<span class="nc" id="L559">                        aChar = in[off++];</span>
<span class="nc bnc" id="L560" title="All 4 branches missed.">                        switch (aChar) {</span>
                          case '0': case '1': case '2': case '3': case '4':
                          case '5': case '6': case '7': case '8': case '9':
<span class="nc" id="L563">                             value = (value &lt;&lt; 4) + aChar - '0';</span>
<span class="nc" id="L564">                             break;</span>
                          case 'a': case 'b': case 'c':
                          case 'd': case 'e': case 'f':
<span class="nc" id="L567">                             value = (value &lt;&lt; 4) + 10 + aChar - 'a';</span>
<span class="nc" id="L568">                             break;</span>
                          case 'A': case 'B': case 'C':
                          case 'D': case 'E': case 'F':
<span class="nc" id="L571">                             value = (value &lt;&lt; 4) + 10 + aChar - 'A';</span>
<span class="nc" id="L572">                             break;</span>
                          default:
<span class="nc" id="L574">                              throw new IllegalArgumentException(</span>
                                           &quot;Malformed \\uxxxx encoding.&quot;);
                        }
                     }
<span class="nc" id="L578">                    out[outLen++] = (char)value;</span>
<span class="nc" id="L579">                } else {</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                    if (aChar == 't') aChar = '\t';</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">                    else if (aChar == 'r') aChar = '\r';</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                    else if (aChar == 'n') aChar = '\n';</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">                    else if (aChar == 'f') aChar = '\f';</span>
<span class="nc" id="L584">                    out[outLen++] = aChar;</span>
                }
            } else {
<span class="nc" id="L587">                out[outLen++] = aChar;</span>
            }
        }
<span class="nc" id="L590">        return new String (out, 0, outLen);</span>
    }

    /*
     * Converts unicodes to encoded &amp;#92;uxxxx and escapes
     * special characters with a preceding slash
     */
    private String saveConvert(String theString,
                               boolean escapeSpace,
                               boolean escapeUnicode) {
<span class="nc" id="L600">        int len = theString.length();</span>
<span class="nc" id="L601">        int bufLen = len * 2;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (bufLen &lt; 0) {</span>
<span class="nc" id="L603">            bufLen = Integer.MAX_VALUE;</span>
        }
<span class="nc" id="L605">        StringBuffer outBuffer = new StringBuffer(bufLen);</span>

<span class="nc bnc" id="L607" title="All 2 branches missed.">        for(int x=0; x&lt;len; x++) {</span>
<span class="nc" id="L608">            char aChar = theString.charAt(x);</span>
            // Handle common case first, selecting largest block that
            // avoids the specials below
<span class="nc bnc" id="L611" title="All 4 branches missed.">            if ((aChar &gt; 61) &amp;&amp; (aChar &lt; 127)) {</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                if (aChar == '\\') {</span>
<span class="nc" id="L613">                    outBuffer.append('\\'); outBuffer.append('\\');</span>
<span class="nc" id="L614">                    continue;</span>
                }
<span class="nc" id="L616">                outBuffer.append(aChar);</span>
<span class="nc" id="L617">                continue;</span>
            }
<span class="nc bnc" id="L619" title="All 7 branches missed.">            switch(aChar) {</span>
                case ' ':
<span class="nc bnc" id="L621" title="All 4 branches missed.">                    if (x == 0 || escapeSpace)</span>
<span class="nc" id="L622">                        outBuffer.append('\\');</span>
<span class="nc" id="L623">                    outBuffer.append(' ');</span>
<span class="nc" id="L624">                    break;</span>
<span class="nc" id="L625">                case '\t':outBuffer.append('\\'); outBuffer.append('t');</span>
<span class="nc" id="L626">                          break;</span>
<span class="nc" id="L627">                case '\n':outBuffer.append('\\'); outBuffer.append('n');</span>
<span class="nc" id="L628">                          break;</span>
<span class="nc" id="L629">                case '\r':outBuffer.append('\\'); outBuffer.append('r');</span>
<span class="nc" id="L630">                          break;</span>
<span class="nc" id="L631">                case '\f':outBuffer.append('\\'); outBuffer.append('f');</span>
<span class="nc" id="L632">                          break;</span>
                case '=': // Fall through
                case ':': // Fall through
                case '#': // Fall through
                case '!':
<span class="nc" id="L637">                    outBuffer.append('\\'); outBuffer.append(aChar);</span>
<span class="nc" id="L638">                    break;</span>
                default:
<span class="nc bnc" id="L640" title="All 6 branches missed.">                    if (((aChar &lt; 0x0020) || (aChar &gt; 0x007e)) &amp; escapeUnicode ) {</span>
<span class="nc" id="L641">                        outBuffer.append('\\');</span>
<span class="nc" id="L642">                        outBuffer.append('u');</span>
<span class="nc" id="L643">                        outBuffer.append(toHex((aChar &gt;&gt; 12) &amp; 0xF));</span>
<span class="nc" id="L644">                        outBuffer.append(toHex((aChar &gt;&gt;  8) &amp; 0xF));</span>
<span class="nc" id="L645">                        outBuffer.append(toHex((aChar &gt;&gt;  4) &amp; 0xF));</span>
<span class="nc" id="L646">                        outBuffer.append(toHex( aChar        &amp; 0xF));</span>
                    } else {
<span class="nc" id="L648">                        outBuffer.append(aChar);</span>
                    }
            }
        }
<span class="nc" id="L652">        return outBuffer.toString();</span>
    }

    private static void writeComments(BufferedWriter bw, String comments)
        throws IOException {
<span class="nc" id="L657">        bw.write(&quot;#&quot;);</span>
<span class="nc" id="L658">        int len = comments.length();</span>
<span class="nc" id="L659">        int current = 0;</span>
<span class="nc" id="L660">        int last = 0;</span>
<span class="nc" id="L661">        char[] uu = new char[6];</span>
<span class="nc" id="L662">        uu[0] = '\\';</span>
<span class="nc" id="L663">        uu[1] = 'u';</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">        while (current &lt; len) {</span>
<span class="nc" id="L665">            char c = comments.charAt(current);</span>
<span class="nc bnc" id="L666" title="All 6 branches missed.">            if (c &gt; '\u00ff' || c == '\n' || c == '\r') {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                if (last != current)</span>
<span class="nc" id="L668">                    bw.write(comments.substring(last, current));</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">                if (c &gt; '\u00ff') {</span>
<span class="nc" id="L670">                    uu[2] = toHex((c &gt;&gt; 12) &amp; 0xf);</span>
<span class="nc" id="L671">                    uu[3] = toHex((c &gt;&gt;  8) &amp; 0xf);</span>
<span class="nc" id="L672">                    uu[4] = toHex((c &gt;&gt;  4) &amp; 0xf);</span>
<span class="nc" id="L673">                    uu[5] = toHex( c        &amp; 0xf);</span>
<span class="nc" id="L674">                    bw.write(new String(uu));</span>
                } else {
<span class="nc" id="L676">                    bw.newLine();</span>
<span class="nc bnc" id="L677" title="All 4 branches missed.">                    if (c == '\r' &amp;&amp;</span>
                        current != len - 1 &amp;&amp;
<span class="nc bnc" id="L679" title="All 2 branches missed.">                        comments.charAt(current + 1) == '\n') {</span>
<span class="nc" id="L680">                        current++;</span>
                    }
<span class="nc bnc" id="L682" title="All 2 branches missed.">                    if (current == len - 1 ||</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">                        (comments.charAt(current + 1) != '#' &amp;&amp;</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                        comments.charAt(current + 1) != '!'))</span>
<span class="nc" id="L685">                        bw.write(&quot;#&quot;);</span>
                }
<span class="nc" id="L687">                last = current + 1;</span>
            }
<span class="nc" id="L689">            current++;</span>
<span class="nc" id="L690">        }</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (last != current)</span>
<span class="nc" id="L692">            bw.write(comments.substring(last, current));</span>
<span class="nc" id="L693">        bw.newLine();</span>
<span class="nc" id="L694">    }</span>

    /**
     * Calls the {@code store(OutputStream out, String comments)} method
     * and suppresses IOExceptions that were thrown.
     *
     * @deprecated This method does not throw an IOException if an I/O error
     * occurs while saving the property list.  The preferred way to save a
     * properties list is via the {@code store(OutputStream out,
     * String comments)} method or the
     * {@code storeToXML(OutputStream os, String comment)} method.
     *
     * @param   out      an output stream.
     * @param   comments   a description of the property list.
     * @exception  ClassCastException  if this {@code Properties} object
     *             contains any keys or values that are not
     *             {@code Strings}.
     */
    @Deprecated
    public void save(OutputStream out, String comments)  {
        try {
<span class="nc" id="L715">            store(out, comments);</span>
<span class="nc" id="L716">        } catch (IOException e) {</span>
<span class="nc" id="L717">        }</span>
<span class="nc" id="L718">    }</span>

    /**
     * Writes this property list (key and element pairs) in this
     * {@code Properties} table to the output character stream in a
     * format suitable for using the {@link #load(java.io.Reader) load(Reader)}
     * method.
     * &lt;p&gt;
     * Properties from the defaults table of this {@code Properties}
     * table (if any) are &lt;i&gt;not&lt;/i&gt; written out by this method.
     * &lt;p&gt;
     * If the comments argument is not null, then an ASCII {@code #}
     * character, the comments string, and a line separator are first written
     * to the output stream. Thus, the {@code comments} can serve as an
     * identifying comment. Any one of a line feed ('\n'), a carriage
     * return ('\r'), or a carriage return followed immediately by a line feed
     * in comments is replaced by a line separator generated by the {@code Writer}
     * and if the next character in comments is not character {@code #} or
     * character {@code !} then an ASCII {@code #} is written out
     * after that line separator.
     * &lt;p&gt;
     * Next, a comment line is always written, consisting of an ASCII
     * {@code #} character, the current date and time (as if produced
     * by the {@code toString} method of {@code Date} for the
     * current time), and a line separator as generated by the {@code Writer}.
     * &lt;p&gt;
     * Then every entry in this {@code Properties} table is
     * written out, one per line. For each entry the key string is
     * written, then an ASCII {@code =}, then the associated
     * element string. For the key, all space characters are
     * written with a preceding {@code \} character.  For the
     * element, leading space characters, but not embedded or trailing
     * space characters, are written with a preceding {@code \}
     * character. The key and element characters {@code #},
     * {@code !}, {@code =}, and {@code :} are written
     * with a preceding backslash to ensure that they are properly loaded.
     * &lt;p&gt;
     * After the entries have been written, the output stream is flushed.
     * The output stream remains open after this method returns.
     * &lt;p&gt;
     *
     * @param   writer      an output character stream writer.
     * @param   comments   a description of the property list.
     * @exception  IOException if writing this property list to the specified
     *             output stream throws an &lt;tt&gt;IOException&lt;/tt&gt;.
     * @exception  ClassCastException  if this {@code Properties} object
     *             contains any keys or values that are not {@code Strings}.
     * @exception  NullPointerException  if {@code writer} is null.
     * @since 1.6
     */
    public void store(Writer writer, String comments)
        throws IOException
    {
<span class="nc bnc" id="L771" title="All 2 branches missed.">        store0((writer instanceof BufferedWriter)?(BufferedWriter)writer</span>
                                                 : new BufferedWriter(writer),
               comments,
               false);
<span class="nc" id="L775">    }</span>

    /**
     * Writes this property list (key and element pairs) in this
     * {@code Properties} table to the output stream in a format suitable
     * for loading into a {@code Properties} table using the
     * {@link #load(InputStream) load(InputStream)} method.
     * &lt;p&gt;
     * Properties from the defaults table of this {@code Properties}
     * table (if any) are &lt;i&gt;not&lt;/i&gt; written out by this method.
     * &lt;p&gt;
     * This method outputs the comments, properties keys and values in
     * the same format as specified in
     * {@link #store(java.io.Writer, java.lang.String) store(Writer)},
     * with the following differences:
     * &lt;ul&gt;
     * &lt;li&gt;The stream is written using the ISO 8859-1 character encoding.
     *
     * &lt;li&gt;Characters not in Latin-1 in the comments are written as
     * {@code \u005Cu}&lt;i&gt;xxxx&lt;/i&gt; for their appropriate unicode
     * hexadecimal value &lt;i&gt;xxxx&lt;/i&gt;.
     *
     * &lt;li&gt;Characters less than {@code \u005Cu0020} and characters greater
     * than {@code \u005Cu007E} in property keys or values are written
     * as {@code \u005Cu}&lt;i&gt;xxxx&lt;/i&gt; for the appropriate hexadecimal
     * value &lt;i&gt;xxxx&lt;/i&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * After the entries have been written, the output stream is flushed.
     * The output stream remains open after this method returns.
     * &lt;p&gt;
     * @param   out      an output stream.
     * @param   comments   a description of the property list.
     * @exception  IOException if writing this property list to the specified
     *             output stream throws an &lt;tt&gt;IOException&lt;/tt&gt;.
     * @exception  ClassCastException  if this {@code Properties} object
     *             contains any keys or values that are not {@code Strings}.
     * @exception  NullPointerException  if {@code out} is null.
     * @since 1.2
     */
    public void store(OutputStream out, String comments)
        throws IOException
    {
<span class="nc" id="L818">        store0(new BufferedWriter(new OutputStreamWriter(out, &quot;8859_1&quot;)),</span>
               comments,
               true);
<span class="nc" id="L821">    }</span>

    private void store0(BufferedWriter bw, String comments, boolean escUnicode)
        throws IOException
    {
<span class="nc bnc" id="L826" title="All 2 branches missed.">        if (comments != null) {</span>
<span class="nc" id="L827">            writeComments(bw, comments);</span>
        }
<span class="nc" id="L829">        bw.write(&quot;#&quot; + new Date().toString());</span>
<span class="nc" id="L830">        bw.newLine();</span>
<span class="nc" id="L831">        synchronized (this) {</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">            for (Enumeration&lt;?&gt; e = keys(); e.hasMoreElements();) {</span>
<span class="nc" id="L833">                String key = (String)e.nextElement();</span>
<span class="nc" id="L834">                String val = (String)get(key);</span>
<span class="nc" id="L835">                key = saveConvert(key, true, escUnicode);</span>
                /* No need to escape embedded and trailing spaces for value, hence
                 * pass false to flag.
                 */
<span class="nc" id="L839">                val = saveConvert(val, false, escUnicode);</span>
<span class="nc" id="L840">                bw.write(key + &quot;=&quot; + val);</span>
<span class="nc" id="L841">                bw.newLine();</span>
<span class="nc" id="L842">            }</span>
<span class="nc" id="L843">        }</span>
<span class="nc" id="L844">        bw.flush();</span>
<span class="nc" id="L845">    }</span>

    /**
     * Loads all of the properties represented by the XML document on the
     * specified input stream into this properties table.
     *
     * &lt;p&gt;The XML document must have the following DOCTYPE declaration:
     * &lt;pre&gt;
     * &amp;lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&amp;gt;
     * &lt;/pre&gt;
     * Furthermore, the document must satisfy the properties DTD described
     * above.
     *
     * &lt;p&gt; An implementation is required to read XML documents that use the
     * &quot;{@code UTF-8}&quot; or &quot;{@code UTF-16}&quot; encoding. An implementation may
     * support additional encodings.
     *
     * &lt;p&gt;The specified stream is closed after this method returns.
     *
     * @param in the input stream from which to read the XML document.
     * @throws IOException if reading from the specified input stream
     *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.
     * @throws java.io.UnsupportedEncodingException if the document's encoding
     *         declaration can be read and it specifies an encoding that is not
     *         supported
     * @throws InvalidPropertiesFormatException Data on input stream does not
     *         constitute a valid XML document with the mandated document type.
     * @throws NullPointerException if {@code in} is null.
     * @see    #storeToXML(OutputStream, String, String)
     * @see    &lt;a href=&quot;http://www.w3.org/TR/REC-xml/#charencoding&quot;&gt;Character
     *         Encoding in Entities&lt;/a&gt;
     * @since 1.5
     */
    public synchronized void loadFromXML(InputStream in)
        throws IOException, InvalidPropertiesFormatException
    {
<span class="nc" id="L881">        XmlSupport.load(this, Objects.requireNonNull(in));</span>
<span class="nc" id="L882">        in.close();</span>
<span class="nc" id="L883">    }</span>

    /**
     * Emits an XML document representing all of the properties contained
     * in this table.
     *
     * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;props.storeToXML(os,
     * comment)&lt;/tt&gt; behaves in exactly the same way as the invocation
     * &lt;tt&gt;props.storeToXML(os, comment, &quot;UTF-8&quot;);&lt;/tt&gt;.
     *
     * @param os the output stream on which to emit the XML document.
     * @param comment a description of the property list, or {@code null}
     *        if no comment is desired.
     * @throws IOException if writing to the specified output stream
     *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.
     * @throws NullPointerException if {@code os} is null.
     * @throws ClassCastException  if this {@code Properties} object
     *         contains any keys or values that are not
     *         {@code Strings}.
     * @see    #loadFromXML(InputStream)
     * @since 1.5
     */
    public void storeToXML(OutputStream os, String comment)
        throws IOException
    {
<span class="nc" id="L908">        storeToXML(os, comment, &quot;UTF-8&quot;);</span>
<span class="nc" id="L909">    }</span>

    /**
     * Emits an XML document representing all of the properties contained
     * in this table, using the specified encoding.
     *
     * &lt;p&gt;The XML document will have the following DOCTYPE declaration:
     * &lt;pre&gt;
     * &amp;lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;If the specified comment is {@code null} then no comment
     * will be stored in the document.
     *
     * &lt;p&gt; An implementation is required to support writing of XML documents
     * that use the &quot;{@code UTF-8}&quot; or &quot;{@code UTF-16}&quot; encoding. An
     * implementation may support additional encodings.
     *
     * &lt;p&gt;The specified stream remains open after this method returns.
     *
     * @param os        the output stream on which to emit the XML document.
     * @param comment   a description of the property list, or {@code null}
     *                  if no comment is desired.
     * @param  encoding the name of a supported
     *                  &lt;a href=&quot;../lang/package-summary.html#charenc&quot;&gt;
     *                  character encoding&lt;/a&gt;
     *
     * @throws IOException if writing to the specified output stream
     *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.
     * @throws java.io.UnsupportedEncodingException if the encoding is not
     *         supported by the implementation.
     * @throws NullPointerException if {@code os} is {@code null},
     *         or if {@code encoding} is {@code null}.
     * @throws ClassCastException  if this {@code Properties} object
     *         contains any keys or values that are not
     *         {@code Strings}.
     * @see    #loadFromXML(InputStream)
     * @see    &lt;a href=&quot;http://www.w3.org/TR/REC-xml/#charencoding&quot;&gt;Character
     *         Encoding in Entities&lt;/a&gt;
     * @since 1.5
     */
    public void storeToXML(OutputStream os, String comment, String encoding)
        throws IOException
    {
<span class="nc" id="L953">        XmlSupport.save(this, Objects.requireNonNull(os), comment,</span>
<span class="nc" id="L954">                        Objects.requireNonNull(encoding));</span>
<span class="nc" id="L955">    }</span>

    /**
     * Searches for the property with the specified key in this property list.
     * If the key is not found in this property list, the default property list,
     * and its defaults, recursively, are then checked. The method returns
     * {@code null} if the property is not found.
     *
     * @param   key   the property key.
     * @return  the value in this property list with the specified key value.
     * @see     #setProperty
     * @see     #defaults
     */
    public String getProperty(String key) {
<span class="nc" id="L969">        Object oval = super.get(key);</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">        String sval = (oval instanceof String) ? (String)oval : null;</span>
<span class="nc bnc" id="L971" title="All 4 branches missed.">        return ((sval == null) &amp;&amp; (defaults != null)) ? defaults.getProperty(key) : sval;</span>
    }

    /**
     * Searches for the property with the specified key in this property list.
     * If the key is not found in this property list, the default property list,
     * and its defaults, recursively, are then checked. The method returns the
     * default value argument if the property is not found.
     *
     * @param   key            the hashtable key.
     * @param   defaultValue   a default value.
     *
     * @return  the value in this property list with the specified key value.
     * @see     #setProperty
     * @see     #defaults
     */
    public String getProperty(String key, String defaultValue) {
<span class="nc" id="L988">        String val = getProperty(key);</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">        return (val == null) ? defaultValue : val;</span>
    }

    /**
     * Returns an enumeration of all the keys in this property list,
     * including distinct keys in the default property list if a key
     * of the same name has not already been found from the main
     * properties list.
     *
     * @return  an enumeration of all the keys in this property list, including
     *          the keys in the default property list.
     * @throws  ClassCastException if any key in this property list
     *          is not a string.
     * @see     java.util.Enumeration
     * @see     java.util.Properties#defaults
     * @see     #stringPropertyNames
     */
    public Enumeration&lt;?&gt; propertyNames() {
<span class="nc" id="L1007">        Hashtable&lt;String,Object&gt; h = new Hashtable&lt;&gt;();</span>
<span class="nc" id="L1008">        enumerate(h);</span>
<span class="nc" id="L1009">        return h.keys();</span>
    }

    /**
     * Returns a set of keys in this property list where
     * the key and its corresponding value are strings,
     * including distinct keys in the default property list if a key
     * of the same name has not already been found from the main
     * properties list.  Properties whose key or value is not
     * of type &lt;tt&gt;String&lt;/tt&gt; are omitted.
     * &lt;p&gt;
     * The returned set is not backed by the &lt;tt&gt;Properties&lt;/tt&gt; object.
     * Changes to this &lt;tt&gt;Properties&lt;/tt&gt; are not reflected in the set,
     * or vice versa.
     *
     * @return  a set of keys in this property list where
     *          the key and its corresponding value are strings,
     *          including the keys in the default property list.
     * @see     java.util.Properties#defaults
     * @since   1.6
     */
    public Set&lt;String&gt; stringPropertyNames() {
<span class="nc" id="L1031">        Hashtable&lt;String, String&gt; h = new Hashtable&lt;&gt;();</span>
<span class="nc" id="L1032">        enumerateStringProperties(h);</span>
<span class="nc" id="L1033">        return h.keySet();</span>
    }

    /**
     * Prints this property list out to the specified output stream.
     * This method is useful for debugging.
     *
     * @param   out   an output stream.
     * @throws  ClassCastException if any key in this property list
     *          is not a string.
     */
    public void list(PrintStream out) {
<span class="nc" id="L1045">        out.println(&quot;-- listing properties --&quot;);</span>
<span class="nc" id="L1046">        Hashtable&lt;String,Object&gt; h = new Hashtable&lt;&gt;();</span>
<span class="nc" id="L1047">        enumerate(h);</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">        for (Enumeration&lt;String&gt; e = h.keys() ; e.hasMoreElements() ;) {</span>
<span class="nc" id="L1049">            String key = e.nextElement();</span>
<span class="nc" id="L1050">            String val = (String)h.get(key);</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">            if (val.length() &gt; 40) {</span>
<span class="nc" id="L1052">                val = val.substring(0, 37) + &quot;...&quot;;</span>
            }
<span class="nc" id="L1054">            out.println(key + &quot;=&quot; + val);</span>
<span class="nc" id="L1055">        }</span>
<span class="nc" id="L1056">    }</span>

    /**
     * Prints this property list out to the specified output stream.
     * This method is useful for debugging.
     *
     * @param   out   an output stream.
     * @throws  ClassCastException if any key in this property list
     *          is not a string.
     * @since   JDK1.1
     */
    /*
     * Rather than use an anonymous inner class to share common code, this
     * method is duplicated in order to ensure that a non-1.1 compiler can
     * compile this file.
     */
    public void list(PrintWriter out) {
<span class="nc" id="L1073">        out.println(&quot;-- listing properties --&quot;);</span>
<span class="nc" id="L1074">        Hashtable&lt;String,Object&gt; h = new Hashtable&lt;&gt;();</span>
<span class="nc" id="L1075">        enumerate(h);</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">        for (Enumeration&lt;String&gt; e = h.keys() ; e.hasMoreElements() ;) {</span>
<span class="nc" id="L1077">            String key = e.nextElement();</span>
<span class="nc" id="L1078">            String val = (String)h.get(key);</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">            if (val.length() &gt; 40) {</span>
<span class="nc" id="L1080">                val = val.substring(0, 37) + &quot;...&quot;;</span>
            }
<span class="nc" id="L1082">            out.println(key + &quot;=&quot; + val);</span>
<span class="nc" id="L1083">        }</span>
<span class="nc" id="L1084">    }</span>

    /**
     * Enumerates all key/value pairs in the specified hashtable.
     * @param h the hashtable
     * @throws ClassCastException if any of the property keys
     *         is not of String type.
     */
    private synchronized void enumerate(Hashtable&lt;String,Object&gt; h) {
<span class="nc bnc" id="L1093" title="All 2 branches missed.">        if (defaults != null) {</span>
<span class="nc" id="L1094">            defaults.enumerate(h);</span>
        }
<span class="nc bnc" id="L1096" title="All 2 branches missed.">        for (Enumeration&lt;?&gt; e = keys() ; e.hasMoreElements() ;) {</span>
<span class="nc" id="L1097">            String key = (String)e.nextElement();</span>
<span class="nc" id="L1098">            h.put(key, get(key));</span>
<span class="nc" id="L1099">        }</span>
<span class="nc" id="L1100">    }</span>

    /**
     * Enumerates all key/value pairs in the specified hashtable
     * and omits the property if the key or value is not a string.
     * @param h the hashtable
     */
    private synchronized void enumerateStringProperties(Hashtable&lt;String, String&gt; h) {
<span class="nc bnc" id="L1108" title="All 2 branches missed.">        if (defaults != null) {</span>
<span class="nc" id="L1109">            defaults.enumerateStringProperties(h);</span>
        }
<span class="nc bnc" id="L1111" title="All 2 branches missed.">        for (Enumeration&lt;?&gt; e = keys() ; e.hasMoreElements() ;) {</span>
<span class="nc" id="L1112">            Object k = e.nextElement();</span>
<span class="nc" id="L1113">            Object v = get(k);</span>
<span class="nc bnc" id="L1114" title="All 4 branches missed.">            if (k instanceof String &amp;&amp; v instanceof String) {</span>
<span class="nc" id="L1115">                h.put((String) k, (String) v);</span>
            }
<span class="nc" id="L1117">        }</span>
<span class="nc" id="L1118">    }</span>

    /**
     * Convert a nibble to a hex character
     * @param   nibble  the nibble to convert.
     */
    private static char toHex(int nibble) {
<span class="nc" id="L1125">        return hexDigit[(nibble &amp; 0xF)];</span>
    }

    /** A table of hex digits */
<span class="nc" id="L1129">    private static final char[] hexDigit = {</span>
        '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
    };

    /**
     * Supporting class for loading/storing properties in XML format.
     *
     * &lt;p&gt; The {@code load} and {@code store} methods defined here delegate to a
     * system-wide {@code XmlPropertiesProvider}. On first invocation of either
     * method then the system-wide provider is located as follows: &lt;/p&gt;
     *
     * &lt;ol&gt;
     *   &lt;li&gt; If the system property {@code sun.util.spi.XmlPropertiesProvider}
     *   is defined then it is taken to be the full-qualified name of a concrete
     *   provider class. The class is loaded with the system class loader as the
     *   initiating loader. If it cannot be loaded or instantiated using a zero
     *   argument constructor then an unspecified error is thrown. &lt;/li&gt;
     *
     *   &lt;li&gt; If the system property is not defined then the service-provider
     *   loading facility defined by the {@link ServiceLoader} class is used to
     *   locate a provider with the system class loader as the initiating
     *   loader and {@code sun.util.spi.XmlPropertiesProvider} as the service
     *   type. If this process fails then an unspecified error is thrown. If
     *   there is more than one service provider installed then it is
     *   not specified as to which provider will be used. &lt;/li&gt;
     *
     *   &lt;li&gt; If the provider is not found by the above means then a system
     *   default provider will be instantiated and used. &lt;/li&gt;
     * &lt;/ol&gt;
     */
<span class="nc" id="L1159">    private static class XmlSupport {</span>

        private static XmlPropertiesProvider loadProviderFromProperty(ClassLoader cl) {
<span class="fc" id="L1162">            String cn = System.getProperty(&quot;sun.util.spi.XmlPropertiesProvider&quot;);</span>
<span class="fc bfc" id="L1163" title="All 2 branches covered.">            if (cn == null)</span>
<span class="fc" id="L1164">                return null;</span>
            try {
<span class="fc" id="L1166">                Class&lt;?&gt; c = Class.forName(cn, true, cl);</span>
<span class="fc" id="L1167">                return (XmlPropertiesProvider)c.newInstance();</span>
<span class="nc" id="L1168">            } catch (ClassNotFoundException |</span>
                     IllegalAccessException |
                     InstantiationException x) {
<span class="nc" id="L1171">                throw new ServiceConfigurationError(null, x);</span>
            }
        }

        private static XmlPropertiesProvider loadProviderAsService(ClassLoader cl) {
<span class="fc" id="L1176">            Iterator&lt;XmlPropertiesProvider&gt; iterator =</span>
<span class="fc" id="L1177">                 ServiceLoader.load(XmlPropertiesProvider.class, cl).iterator();</span>
<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">            return iterator.hasNext() ? iterator.next() : null;</span>
        }

        private static XmlPropertiesProvider loadProvider() {
<span class="fc" id="L1182">            return AccessController.doPrivileged(</span>
<span class="fc" id="L1183">                new PrivilegedAction&lt;XmlPropertiesProvider&gt;() {</span>
                    public XmlPropertiesProvider run() {
<span class="fc" id="L1185">                        ClassLoader cl = ClassLoader.getSystemClassLoader();</span>
<span class="fc" id="L1186">                        XmlPropertiesProvider provider = loadProviderFromProperty(cl);</span>
<span class="fc bfc" id="L1187" title="All 2 branches covered.">                        if (provider != null)</span>
<span class="fc" id="L1188">                            return provider;</span>
<span class="fc" id="L1189">                        provider = loadProviderAsService(cl);</span>
<span class="pc bpc" id="L1190" title="1 of 2 branches missed.">                        if (provider != null)</span>
<span class="nc" id="L1191">                            return provider;</span>
<span class="fc" id="L1192">                        return new jdk.internal.util.xml.BasicXmlPropertiesProvider();</span>
                }});
        }

<span class="fc" id="L1196">        private static final XmlPropertiesProvider PROVIDER = loadProvider();</span>

        static void load(Properties props, InputStream in)
            throws IOException, InvalidPropertiesFormatException
        {
<span class="fc" id="L1201">            PROVIDER.load(props, in);</span>
<span class="fc" id="L1202">        }</span>

        static void save(Properties props, OutputStream os, String comment,
                         String encoding)
            throws IOException
        {
<span class="fc" id="L1208">            PROVIDER.store(props, os, comment, encoding);</span>
<span class="fc" id="L1209">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>