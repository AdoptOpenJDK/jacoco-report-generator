<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Formatter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">Formatter.java</span></div><h1>Formatter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.io.BufferedWriter;
import java.io.Closeable;
import java.io.IOException;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.Flushable;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.math.RoundingMode;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;
import java.nio.charset.UnsupportedCharsetException;
import java.text.DateFormatSymbols;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import java.time.DateTimeException;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.temporal.ChronoField;
import java.time.temporal.TemporalAccessor;
import java.time.temporal.TemporalQueries;

import sun.misc.DoubleConsts;
import sun.misc.FormattedFloatingDecimal;

/**
 * An interpreter for printf-style format strings.  This class provides support
 * for layout justification and alignment, common formats for numeric, string,
 * and date/time data, and locale-specific output.  Common Java types such as
 * {@code byte}, {@link java.math.BigDecimal BigDecimal}, and {@link Calendar}
 * are supported.  Limited formatting customization for arbitrary user types is
 * provided through the {@link Formattable} interface.
 *
 * &lt;p&gt; Formatters are not necessarily safe for multithreaded access.  Thread
 * safety is optional and is the responsibility of users of methods in this
 * class.
 *
 * &lt;p&gt; Formatted printing for the Java language is heavily inspired by C's
 * {@code printf}.  Although the format strings are similar to C, some
 * customizations have been made to accommodate the Java language and exploit
 * some of its features.  Also, Java formatting is more strict than C's; for
 * example, if a conversion is incompatible with a flag, an exception will be
 * thrown.  In C inapplicable flags are silently ignored.  The format strings
 * are thus intended to be recognizable to C programmers but not necessarily
 * completely compatible with those in C.
 *
 * &lt;p&gt; Examples of expected usage:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   StringBuilder sb = new StringBuilder();
 *   // Send all output to the Appendable object sb
 *   Formatter formatter = new Formatter(sb, Locale.US);
 *
 *   // Explicit argument indices may be used to re-order output.
 *   formatter.format(&quot;%4$2s %3$2s %2$2s %1$2s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
 *   // -&amp;gt; &quot; d  c  b  a&quot;
 *
 *   // Optional locale as the first argument can be used to get
 *   // locale-specific formatting of numbers.  The precision and width can be
 *   // given to round and align the value.
 *   formatter.format(Locale.FRANCE, &quot;e = %+10.4f&quot;, Math.E);
 *   // -&amp;gt; &quot;e =    +2,7183&quot;
 *
 *   // The '(' numeric flag may be used to format negative numbers with
 *   // parentheses rather than a minus sign.  Group separators are
 *   // automatically inserted.
 *   formatter.format(&quot;Amount gained or lost since last statement: $ %(,.2f&quot;,
 *                    balanceDelta);
 *   // -&amp;gt; &quot;Amount gained or lost since last statement: $ (6,217.58)&quot;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; Convenience methods for common formatting requests exist as illustrated
 * by the following invocations:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   // Writes a formatted string to System.out.
 *   System.out.format(&quot;Local time: %tT&quot;, Calendar.getInstance());
 *   // -&amp;gt; &quot;Local time: 13:34:18&quot;
 *
 *   // Writes formatted output to System.err.
 *   System.err.printf(&quot;Unable to open file '%1$s': %2$s&quot;,
 *                     fileName, exception.getMessage());
 *   // -&amp;gt; &quot;Unable to open file 'food': No such file or directory&quot;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; Like C's {@code sprintf(3)}, Strings may be formatted using the static
 * method {@link String#format(String,Object...) String.format}:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   // Format a string containing a date.
 *   import java.util.Calendar;
 *   import java.util.GregorianCalendar;
 *   import static java.util.Calendar.*;
 *
 *   Calendar c = new GregorianCalendar(1995, MAY, 23);
 *   String s = String.format(&quot;Duke's Birthday: %1$tb %1$te, %1$tY&quot;, c);
 *   // -&amp;gt; s == &quot;Duke's Birthday: May 23, 1995&quot;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;h3&gt;&lt;a name=&quot;org&quot;&gt;Organization&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;p&gt; This specification is divided into two sections.  The first section, &lt;a
 * href=&quot;#summary&quot;&gt;Summary&lt;/a&gt;, covers the basic formatting concepts.  This
 * section is intended for users who want to get started quickly and are
 * familiar with formatted printing in other programming languages.  The second
 * section, &lt;a href=&quot;#detail&quot;&gt;Details&lt;/a&gt;, covers the specific implementation
 * details.  It is intended for users who want more precise specification of
 * formatting behavior.
 *
 * &lt;h3&gt;&lt;a name=&quot;summary&quot;&gt;Summary&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;p&gt; This section is intended to provide a brief overview of formatting
 * concepts.  For precise behavioral details, refer to the &lt;a
 * href=&quot;#detail&quot;&gt;Details&lt;/a&gt; section.
 *
 * &lt;h4&gt;&lt;a name=&quot;syntax&quot;&gt;Format String Syntax&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt; Every method which produces formatted output requires a &lt;i&gt;format
 * string&lt;/i&gt; and an &lt;i&gt;argument list&lt;/i&gt;.  The format string is a {@link
 * String} which may contain fixed text and one or more embedded &lt;i&gt;format
 * specifiers&lt;/i&gt;.  Consider the following example:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   Calendar c = ...;
 *   String s = String.format(&quot;Duke's Birthday: %1$tm %1$te,%1$tY&quot;, c);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * This format string is the first argument to the {@code format} method.  It
 * contains three format specifiers &quot;{@code %1$tm}&quot;, &quot;{@code %1$te}&quot;, and
 * &quot;{@code %1$tY}&quot; which indicate how the arguments should be processed and
 * where they should be inserted in the text.  The remaining portions of the
 * format string are fixed text including {@code &quot;Dukes Birthday: &quot;} and any
 * other spaces or punctuation.
 *
 * The argument list consists of all arguments passed to the method after the
 * format string.  In the above example, the argument list is of size one and
 * consists of the {@link java.util.Calendar Calendar} object {@code c}.
 *
 * &lt;ul&gt;
 *
 * &lt;li&gt; The format specifiers for general, character, and numeric types have
 * the following syntax:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   %[argument_index$][flags][width][.precision]conversion
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; The optional &lt;i&gt;argument_index&lt;/i&gt; is a decimal integer indicating the
 * position of the argument in the argument list.  The first argument is
 * referenced by &quot;{@code 1$}&quot;, the second by &quot;{@code 2$}&quot;, etc.
 *
 * &lt;p&gt; The optional &lt;i&gt;flags&lt;/i&gt; is a set of characters that modify the output
 * format.  The set of valid flags depends on the conversion.
 *
 * &lt;p&gt; The optional &lt;i&gt;width&lt;/i&gt; is a positive decimal integer indicating
 * the minimum number of characters to be written to the output.
 *
 * &lt;p&gt; The optional &lt;i&gt;precision&lt;/i&gt; is a non-negative decimal integer usually
 * used to restrict the number of characters.  The specific behavior depends on
 * the conversion.
 *
 * &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a character indicating how the
 * argument should be formatted.  The set of valid conversions for a given
 * argument depends on the argument's data type.
 *
 * &lt;li&gt; The format specifiers for types which are used to represents dates and
 * times have the following syntax:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   %[argument_index$][flags][width]conversion
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; The optional &lt;i&gt;argument_index&lt;/i&gt;, &lt;i&gt;flags&lt;/i&gt; and &lt;i&gt;width&lt;/i&gt; are
 * defined as above.
 *
 * &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a two character sequence.  The first
 * character is {@code 't'} or {@code 'T'}.  The second character indicates
 * the format to be used.  These characters are similar to but not completely
 * identical to those defined by GNU {@code date} and POSIX
 * {@code strftime(3c)}.
 *
 * &lt;li&gt; The format specifiers which do not correspond to arguments have the
 * following syntax:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   %[flags][width]conversion
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; The optional &lt;i&gt;flags&lt;/i&gt; and &lt;i&gt;width&lt;/i&gt; is defined as above.
 *
 * &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a character indicating content to be
 * inserted in the output.
 *
 * &lt;/ul&gt;
 *
 * &lt;h4&gt; Conversions &lt;/h4&gt;
 *
 * &lt;p&gt; Conversions are divided into the following categories:
 *
 * &lt;ol&gt;
 *
 * &lt;li&gt; &lt;b&gt;General&lt;/b&gt; - may be applied to any argument
 * type
 *
 * &lt;li&gt; &lt;b&gt;Character&lt;/b&gt; - may be applied to basic types which represent
 * Unicode characters: {@code char}, {@link Character}, {@code byte}, {@link
 * Byte}, {@code short}, and {@link Short}. This conversion may also be
 * applied to the types {@code int} and {@link Integer} when {@link
 * Character#isValidCodePoint} returns {@code true}
 *
 * &lt;li&gt; &lt;b&gt;Numeric&lt;/b&gt;
 *
 * &lt;ol&gt;
 *
 * &lt;li&gt; &lt;b&gt;Integral&lt;/b&gt; - may be applied to Java integral types: {@code byte},
 * {@link Byte}, {@code short}, {@link Short}, {@code int} and {@link
 * Integer}, {@code long}, {@link Long}, and {@link java.math.BigInteger
 * BigInteger} (but not {@code char} or {@link Character})
 *
 * &lt;li&gt;&lt;b&gt;Floating Point&lt;/b&gt; - may be applied to Java floating-point types:
 * {@code float}, {@link Float}, {@code double}, {@link Double}, and {@link
 * java.math.BigDecimal BigDecimal}
 *
 * &lt;/ol&gt;
 *
 * &lt;li&gt; &lt;b&gt;Date/Time&lt;/b&gt; - may be applied to Java types which are capable of
 * encoding a date or time: {@code long}, {@link Long}, {@link Calendar},
 * {@link Date} and {@link TemporalAccessor TemporalAccessor}
 *
 * &lt;li&gt; &lt;b&gt;Percent&lt;/b&gt; - produces a literal {@code '%'}
 * (&lt;tt&gt;'&amp;#92;u0025'&lt;/tt&gt;)
 *
 * &lt;li&gt; &lt;b&gt;Line Separator&lt;/b&gt; - produces the platform-specific line separator
 *
 * &lt;/ol&gt;
 *
 * &lt;p&gt; The following table summarizes the supported conversions.  Conversions
 * denoted by an upper-case character (i.e. {@code 'B'}, {@code 'H'},
 * {@code 'S'}, {@code 'C'}, {@code 'X'}, {@code 'E'}, {@code 'G'},
 * {@code 'A'}, and {@code 'T'}) are the same as those for the corresponding
 * lower-case conversion characters except that the result is converted to
 * upper case according to the rules of the prevailing {@link java.util.Locale
 * Locale}.  The result is equivalent to the following invocation of {@link
 * String#toUpperCase()}
 *
 * &lt;pre&gt;
 *    out.toUpperCase() &lt;/pre&gt;
 *
 * &lt;table cellpadding=5 summary=&quot;genConv&quot;&gt;
 *
 * &lt;tr&gt;&lt;th valign=&quot;bottom&quot;&gt; Conversion
 *     &lt;th valign=&quot;bottom&quot;&gt; Argument Category
 *     &lt;th valign=&quot;bottom&quot;&gt; Description
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'b'}, {@code 'B'}
 *     &lt;td valign=&quot;top&quot;&gt; general
 *     &lt;td&gt; If the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is
 *     &quot;{@code false}&quot;.  If &lt;i&gt;arg&lt;/i&gt; is a {@code boolean} or {@link
 *     Boolean}, then the result is the string returned by {@link
 *     String#valueOf(boolean) String.valueOf(arg)}.  Otherwise, the result is
 *     &quot;true&quot;.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'h'}, {@code 'H'}
 *     &lt;td valign=&quot;top&quot;&gt; general
 *     &lt;td&gt; If the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is
 *     &quot;{@code null}&quot;.  Otherwise, the result is obtained by invoking
 *     {@code Integer.toHexString(arg.hashCode())}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 's'}, {@code 'S'}
 *     &lt;td valign=&quot;top&quot;&gt; general
 *     &lt;td&gt; If the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is
 *     &quot;{@code null}&quot;.  If &lt;i&gt;arg&lt;/i&gt; implements {@link Formattable}, then
 *     {@link Formattable#formatTo arg.formatTo} is invoked. Otherwise, the
 *     result is obtained by invoking {@code arg.toString()}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'c'}, {@code 'C'}
 *     &lt;td valign=&quot;top&quot;&gt; character
 *     &lt;td&gt; The result is a Unicode character
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'd'}
 *     &lt;td valign=&quot;top&quot;&gt; integral
 *     &lt;td&gt; The result is formatted as a decimal integer
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'o'}
 *     &lt;td valign=&quot;top&quot;&gt; integral
 *     &lt;td&gt; The result is formatted as an octal integer
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'x'}, {@code 'X'}
 *     &lt;td valign=&quot;top&quot;&gt; integral
 *     &lt;td&gt; The result is formatted as a hexadecimal integer
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'e'}, {@code 'E'}
 *     &lt;td valign=&quot;top&quot;&gt; floating point
 *     &lt;td&gt; The result is formatted as a decimal number in computerized
 *     scientific notation
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'f'}
 *     &lt;td valign=&quot;top&quot;&gt; floating point
 *     &lt;td&gt; The result is formatted as a decimal number
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'g'}, {@code 'G'}
 *     &lt;td valign=&quot;top&quot;&gt; floating point
 *     &lt;td&gt; The result is formatted using computerized scientific notation or
 *     decimal format, depending on the precision and the value after rounding.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'a'}, {@code 'A'}
 *     &lt;td valign=&quot;top&quot;&gt; floating point
 *     &lt;td&gt; The result is formatted as a hexadecimal floating-point number with
 *     a significand and an exponent. This conversion is &lt;b&gt;not&lt;/b&gt; supported
 *     for the {@code BigDecimal} type despite the latter's being in the
 *     &lt;i&gt;floating point&lt;/i&gt; argument category.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 't'}, {@code 'T'}
 *     &lt;td valign=&quot;top&quot;&gt; date/time
 *     &lt;td&gt; Prefix for date and time conversion characters.  See &lt;a
 *     href=&quot;#dt&quot;&gt;Date/Time Conversions&lt;/a&gt;.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code '%'}
 *     &lt;td valign=&quot;top&quot;&gt; percent
 *     &lt;td&gt; The result is a literal {@code '%'} (&lt;tt&gt;'&amp;#92;u0025'&lt;/tt&gt;)
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'n'}
 *     &lt;td valign=&quot;top&quot;&gt; line separator
 *     &lt;td&gt; The result is the platform-specific line separator
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; Any characters not explicitly defined as conversions are illegal and are
 * reserved for future extensions.
 *
 * &lt;h4&gt;&lt;a name=&quot;dt&quot;&gt;Date/Time Conversions&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt; The following date and time conversion suffix characters are defined for
 * the {@code 't'} and {@code 'T'} conversions.  The types are similar to but
 * not completely identical to those defined by GNU {@code date} and POSIX
 * {@code strftime(3c)}.  Additional conversion types are provided to access
 * Java-specific functionality (e.g. {@code 'L'} for milliseconds within the
 * second).
 *
 * &lt;p&gt; The following conversion characters are used for formatting times:
 *
 * &lt;table cellpadding=5 summary=&quot;time&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'H'}
 *     &lt;td&gt; Hour of the day for the 24-hour clock, formatted as two digits with
 *     a leading zero as necessary i.e. {@code 00 - 23}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'I'}
 *     &lt;td&gt; Hour for the 12-hour clock, formatted as two digits with a leading
 *     zero as necessary, i.e.  {@code 01 - 12}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'k'}
 *     &lt;td&gt; Hour of the day for the 24-hour clock, i.e. {@code 0 - 23}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'l'}
 *     &lt;td&gt; Hour for the 12-hour clock, i.e. {@code 1 - 12}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'M'}
 *     &lt;td&gt; Minute within the hour formatted as two digits with a leading zero
 *     as necessary, i.e.  {@code 00 - 59}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'S'}
 *     &lt;td&gt; Seconds within the minute, formatted as two digits with a leading
 *     zero as necessary, i.e. {@code 00 - 60} (&quot;{@code 60}&quot; is a special
 *     value required to support leap seconds).
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'L'}
 *     &lt;td&gt; Millisecond within the second formatted as three digits with
 *     leading zeros as necessary, i.e. {@code 000 - 999}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'N'}
 *     &lt;td&gt; Nanosecond within the second, formatted as nine digits with leading
 *     zeros as necessary, i.e. {@code 000000000 - 999999999}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'p'}
 *     &lt;td&gt; Locale-specific {@linkplain
 *     java.text.DateFormatSymbols#getAmPmStrings morning or afternoon} marker
 *     in lower case, e.g.&quot;{@code am}&quot; or &quot;{@code pm}&quot;. Use of the conversion
 *     prefix {@code 'T'} forces this output to upper case.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'z'}
 *     &lt;td&gt; &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC&amp;nbsp;822&lt;/a&gt;
 *     style numeric time zone offset from GMT, e.g. {@code -0800}.  This
 *     value will be adjusted as necessary for Daylight Saving Time.  For
 *     {@code long}, {@link Long}, and {@link Date} the time zone used is
 *     the {@linkplain TimeZone#getDefault() default time zone} for this
 *     instance of the Java virtual machine.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'Z'}
 *     &lt;td&gt; A string representing the abbreviation for the time zone.  This
 *     value will be adjusted as necessary for Daylight Saving Time.  For
 *     {@code long}, {@link Long}, and {@link Date} the  time zone used is
 *     the {@linkplain TimeZone#getDefault() default time zone} for this
 *     instance of the Java virtual machine.  The Formatter's locale will
 *     supersede the locale of the argument (if any).
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 's'}
 *     &lt;td&gt; Seconds since the beginning of the epoch starting at 1 January 1970
 *     {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE/1000} to
 *     {@code Long.MAX_VALUE/1000}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'Q'}
 *     &lt;td&gt; Milliseconds since the beginning of the epoch starting at 1 January
 *     1970 {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE} to
 *     {@code Long.MAX_VALUE}.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; The following conversion characters are used for formatting dates:
 *
 * &lt;table cellpadding=5 summary=&quot;date&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'B'}
 *     &lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getMonths
 *     full month name}, e.g. {@code &quot;January&quot;}, {@code &quot;February&quot;}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'b'}
 *     &lt;td&gt; Locale-specific {@linkplain
 *     java.text.DateFormatSymbols#getShortMonths abbreviated month name},
 *     e.g. {@code &quot;Jan&quot;}, {@code &quot;Feb&quot;}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'h'}
 *     &lt;td&gt; Same as {@code 'b'}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'A'}
 *     &lt;td&gt; Locale-specific full name of the {@linkplain
 *     java.text.DateFormatSymbols#getWeekdays day of the week},
 *     e.g. {@code &quot;Sunday&quot;}, {@code &quot;Monday&quot;}
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'a'}
 *     &lt;td&gt; Locale-specific short name of the {@linkplain
 *     java.text.DateFormatSymbols#getShortWeekdays day of the week},
 *     e.g. {@code &quot;Sun&quot;}, {@code &quot;Mon&quot;}
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'C'}
 *     &lt;td&gt; Four-digit year divided by {@code 100}, formatted as two digits
 *     with leading zero as necessary, i.e. {@code 00 - 99}
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'Y'}
 *     &lt;td&gt; Year, formatted as at least four digits with leading zeros as
 *     necessary, e.g. {@code 0092} equals {@code 92} CE for the Gregorian
 *     calendar.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'y'}
 *     &lt;td&gt; Last two digits of the year, formatted with leading zeros as
 *     necessary, i.e. {@code 00 - 99}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'j'}
 *     &lt;td&gt; Day of year, formatted as three digits with leading zeros as
 *     necessary, e.g. {@code 001 - 366} for the Gregorian calendar.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'm'}
 *     &lt;td&gt; Month, formatted as two digits with leading zeros as necessary,
 *     i.e. {@code 01 - 13}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'd'}
 *     &lt;td&gt; Day of month, formatted as two digits with leading zeros as
 *     necessary, i.e. {@code 01 - 31}
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'e'}
 *     &lt;td&gt; Day of month, formatted as two digits, i.e. {@code 1 - 31}.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; The following conversion characters are used for formatting common
 * date/time compositions.
 *
 * &lt;table cellpadding=5 summary=&quot;composites&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'R'}
 *     &lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM&quot;}
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'T'}
 *     &lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM:%tS&quot;}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'r'}
 *     &lt;td&gt; Time formatted for the 12-hour clock as {@code &quot;%tI:%tM:%tS %Tp&quot;}.
 *     The location of the morning or afternoon marker ({@code '%Tp'}) may be
 *     locale-dependent.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'D'}
 *     &lt;td&gt; Date formatted as {@code &quot;%tm/%td/%ty&quot;}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'F'}
 *     &lt;td&gt; &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO&amp;nbsp;8601&lt;/a&gt;
 *     complete date formatted as {@code &quot;%tY-%tm-%td&quot;}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'c'}
 *     &lt;td&gt; Date and time formatted as {@code &quot;%ta %tb %td %tT %tZ %tY&quot;},
 *     e.g. {@code &quot;Sun Jul 20 16:17:00 EDT 1969&quot;}.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; Any characters not explicitly defined as date/time conversion suffixes
 * are illegal and are reserved for future extensions.
 *
 * &lt;h4&gt; Flags &lt;/h4&gt;
 *
 * &lt;p&gt; The following table summarizes the supported flags.  &lt;i&gt;y&lt;/i&gt; means the
 * flag is supported for the indicated argument types.
 *
 * &lt;table cellpadding=5 summary=&quot;genConv&quot;&gt;
 *
 * &lt;tr&gt;&lt;th valign=&quot;bottom&quot;&gt; Flag &lt;th valign=&quot;bottom&quot;&gt; General
 *     &lt;th valign=&quot;bottom&quot;&gt; Character &lt;th valign=&quot;bottom&quot;&gt; Integral
 *     &lt;th valign=&quot;bottom&quot;&gt; Floating Point
 *     &lt;th valign=&quot;bottom&quot;&gt; Date/Time
 *     &lt;th valign=&quot;bottom&quot;&gt; Description
 *
 * &lt;tr&gt;&lt;td&gt; '-' &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
 *     &lt;td&gt; The result will be left-justified.
 *
 * &lt;tr&gt;&lt;td&gt; '#' &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;1&lt;/sup&gt;
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;3&lt;/sup&gt;
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td&gt; The result should use a conversion-dependent alternate form
 *
 * &lt;tr&gt;&lt;td&gt; '+' &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;4&lt;/sup&gt;
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td&gt; The result will always include a sign
 *
 * &lt;tr&gt;&lt;td&gt; '&amp;nbsp;&amp;nbsp;' &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;4&lt;/sup&gt;
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td&gt; The result will include a leading space for positive values
 *
 * &lt;tr&gt;&lt;td&gt; '0' &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td&gt; The result will be zero-padded
 *
 * &lt;tr&gt;&lt;td&gt; ',' &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;2&lt;/sup&gt;
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;5&lt;/sup&gt;
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td&gt; The result will include locale-specific {@linkplain
 *     java.text.DecimalFormatSymbols#getGroupingSeparator grouping separators}
 *
 * &lt;tr&gt;&lt;td&gt; '(' &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;4&lt;/sup&gt;
 *     &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;5&lt;/sup&gt;
 *     &lt;td align=&quot;center&quot;&gt; -
 *     &lt;td&gt; The result will enclose negative numbers in parentheses
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; &lt;sup&gt;1&lt;/sup&gt; Depends on the definition of {@link Formattable}.
 *
 * &lt;p&gt; &lt;sup&gt;2&lt;/sup&gt; For {@code 'd'} conversion only.
 *
 * &lt;p&gt; &lt;sup&gt;3&lt;/sup&gt; For {@code 'o'}, {@code 'x'}, and {@code 'X'}
 * conversions only.
 *
 * &lt;p&gt; &lt;sup&gt;4&lt;/sup&gt; For {@code 'd'}, {@code 'o'}, {@code 'x'}, and
 * {@code 'X'} conversions applied to {@link java.math.BigInteger BigInteger}
 * or {@code 'd'} applied to {@code byte}, {@link Byte}, {@code short}, {@link
 * Short}, {@code int} and {@link Integer}, {@code long}, and {@link Long}.
 *
 * &lt;p&gt; &lt;sup&gt;5&lt;/sup&gt; For {@code 'e'}, {@code 'E'}, {@code 'f'},
 * {@code 'g'}, and {@code 'G'} conversions only.
 *
 * &lt;p&gt; Any characters not explicitly defined as flags are illegal and are
 * reserved for future extensions.
 *
 * &lt;h4&gt; Width &lt;/h4&gt;
 *
 * &lt;p&gt; The width is the minimum number of characters to be written to the
 * output.  For the line separator conversion, width is not applicable; if it
 * is provided, an exception will be thrown.
 *
 * &lt;h4&gt; Precision &lt;/h4&gt;
 *
 * &lt;p&gt; For general argument types, the precision is the maximum number of
 * characters to be written to the output.
 *
 * &lt;p&gt; For the floating-point conversions {@code 'a'}, {@code 'A'}, {@code 'e'},
 * {@code 'E'}, and {@code 'f'} the precision is the number of digits after the
 * radix point.  If the conversion is {@code 'g'} or {@code 'G'}, then the
 * precision is the total number of digits in the resulting magnitude after
 * rounding.
 *
 * &lt;p&gt; For character, integral, and date/time argument types and the percent
 * and line separator conversions, the precision is not applicable; if a
 * precision is provided, an exception will be thrown.
 *
 * &lt;h4&gt; Argument Index &lt;/h4&gt;
 *
 * &lt;p&gt; The argument index is a decimal integer indicating the position of the
 * argument in the argument list.  The first argument is referenced by
 * &quot;{@code 1$}&quot;, the second by &quot;{@code 2$}&quot;, etc.
 *
 * &lt;p&gt; Another way to reference arguments by position is to use the
 * {@code '&lt;'} (&lt;tt&gt;'&amp;#92;u003c'&lt;/tt&gt;) flag, which causes the argument for
 * the previous format specifier to be re-used.  For example, the following two
 * statements would produce identical strings:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   Calendar c = ...;
 *   String s1 = String.format(&quot;Duke's Birthday: %1$tm %1$te,%1$tY&quot;, c);
 *
 *   String s2 = String.format(&quot;Duke's Birthday: %1$tm %&amp;lt;te,%&amp;lt;tY&quot;, c);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;hr&gt;
 * &lt;h3&gt;&lt;a name=&quot;detail&quot;&gt;Details&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;p&gt; This section is intended to provide behavioral details for formatting,
 * including conditions and exceptions, supported data types, localization, and
 * interactions between flags, conversions, and data types.  For an overview of
 * formatting concepts, refer to the &lt;a href=&quot;#summary&quot;&gt;Summary&lt;/a&gt;
 *
 * &lt;p&gt; Any characters not explicitly defined as conversions, date/time
 * conversion suffixes, or flags are illegal and are reserved for
 * future extensions.  Use of such a character in a format string will
 * cause an {@link UnknownFormatConversionException} or {@link
 * UnknownFormatFlagsException} to be thrown.
 *
 * &lt;p&gt; If the format specifier contains a width or precision with an invalid
 * value or which is otherwise unsupported, then a {@link
 * IllegalFormatWidthException} or {@link IllegalFormatPrecisionException}
 * respectively will be thrown.
 *
 * &lt;p&gt; If a format specifier contains a conversion character that is not
 * applicable to the corresponding argument, then an {@link
 * IllegalFormatConversionException} will be thrown.
 *
 * &lt;p&gt; All specified exceptions may be thrown by any of the {@code format}
 * methods of {@code Formatter} as well as by any {@code format} convenience
 * methods such as {@link String#format(String,Object...) String.format} and
 * {@link java.io.PrintStream#printf(String,Object...) PrintStream.printf}.
 *
 * &lt;p&gt; Conversions denoted by an upper-case character (i.e. {@code 'B'},
 * {@code 'H'}, {@code 'S'}, {@code 'C'}, {@code 'X'}, {@code 'E'},
 * {@code 'G'}, {@code 'A'}, and {@code 'T'}) are the same as those for the
 * corresponding lower-case conversion characters except that the result is
 * converted to upper case according to the rules of the prevailing {@link
 * java.util.Locale Locale}.  The result is equivalent to the following
 * invocation of {@link String#toUpperCase()}
 *
 * &lt;pre&gt;
 *    out.toUpperCase() &lt;/pre&gt;
 *
 * &lt;h4&gt;&lt;a name=&quot;dgen&quot;&gt;General&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt; The following general conversions may be applied to any argument type:
 *
 * &lt;table cellpadding=5 summary=&quot;dgConv&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'b'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0062'&lt;/tt&gt;
 *     &lt;td&gt; Produces either &quot;{@code true}&quot; or &quot;{@code false}&quot; as returned by
 *     {@link Boolean#toString(boolean)}.
 *
 *     &lt;p&gt; If the argument is {@code null}, then the result is
 *     &quot;{@code false}&quot;.  If the argument is a {@code boolean} or {@link
 *     Boolean}, then the result is the string returned by {@link
 *     String#valueOf(boolean) String.valueOf()}.  Otherwise, the result is
 *     &quot;{@code true}&quot;.
 *
 *     &lt;p&gt; If the {@code '#'} flag is given, then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'B'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0042'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 'b'}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'h'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0068'&lt;/tt&gt;
 *     &lt;td&gt; Produces a string representing the hash code value of the object.
 *
 *     &lt;p&gt; If the argument, &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the
 *     result is &quot;{@code null}&quot;.  Otherwise, the result is obtained
 *     by invoking {@code Integer.toHexString(arg.hashCode())}.
 *
 *     &lt;p&gt; If the {@code '#'} flag is given, then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'H'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0048'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 'h'}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 's'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0073'&lt;/tt&gt;
 *     &lt;td&gt; Produces a string.
 *
 *     &lt;p&gt; If the argument is {@code null}, then the result is
 *     &quot;{@code null}&quot;.  If the argument implements {@link Formattable}, then
 *     its {@link Formattable#formatTo formatTo} method is invoked.
 *     Otherwise, the result is obtained by invoking the argument's
 *     {@code toString()} method.
 *
 *     &lt;p&gt; If the {@code '#'} flag is given and the argument is not a {@link
 *     Formattable} , then a {@link FormatFlagsConversionMismatchException}
 *     will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'S'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0053'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 's'}.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; The following &lt;a name=&quot;dFlags&quot;&gt;flags&lt;/a&gt; apply to general conversions:
 *
 * &lt;table cellpadding=5 summary=&quot;dFlags&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code '-'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u002d'&lt;/tt&gt;
 *     &lt;td&gt; Left justifies the output.  Spaces (&lt;tt&gt;'&amp;#92;u0020'&lt;/tt&gt;) will be
 *     added at the end of the converted value as required to fill the minimum
 *     width of the field.  If the width is not provided, then a {@link
 *     MissingFormatWidthException} will be thrown.  If this flag is not given
 *     then the output will be right-justified.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code '#'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0023'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output use an alternate form.  The definition of the
 *     form is specified by the conversion.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; The &lt;a name=&quot;genWidth&quot;&gt;width&lt;/a&gt; is the minimum number of characters to
 * be written to the
 * output.  If the length of the converted value is less than the width then
 * the output will be padded by &lt;tt&gt;'&amp;nbsp;&amp;nbsp;'&lt;/tt&gt; (&lt;tt&gt;'&amp;#92;u0020'&lt;/tt&gt;)
 * until the total number of characters equals the width.  The padding is on
 * the left by default.  If the {@code '-'} flag is given, then the padding
 * will be on the right.  If the width is not specified then there is no
 * minimum.
 *
 * &lt;p&gt; The precision is the maximum number of characters to be written to the
 * output.  The precision is applied before the width, thus the output will be
 * truncated to {@code precision} characters even if the width is greater than
 * the precision.  If the precision is not specified then there is no explicit
 * limit on the number of characters.
 *
 * &lt;h4&gt;&lt;a name=&quot;dchar&quot;&gt;Character&lt;/a&gt;&lt;/h4&gt;
 *
 * This conversion may be applied to {@code char} and {@link Character}.  It
 * may also be applied to the types {@code byte}, {@link Byte},
 * {@code short}, and {@link Short}, {@code int} and {@link Integer} when
 * {@link Character#isValidCodePoint} returns {@code true}.  If it returns
 * {@code false} then an {@link IllegalFormatCodePointException} will be
 * thrown.
 *
 * &lt;table cellpadding=5 summary=&quot;charConv&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'c'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0063'&lt;/tt&gt;
 *     &lt;td&gt; Formats the argument as a Unicode character as described in &lt;a
 *     href=&quot;../lang/Character.html#unicode&quot;&gt;Unicode Character
 *     Representation&lt;/a&gt;.  This may be more than one 16-bit {@code char} in
 *     the case where the argument represents a supplementary character.
 *
 *     &lt;p&gt; If the {@code '#'} flag is given, then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'C'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0043'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 'c'}.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; The {@code '-'} flag defined for &lt;a href=&quot;#dFlags&quot;&gt;General
 * conversions&lt;/a&gt; applies.  If the {@code '#'} flag is given, then a {@link
 * FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;p&gt; The width is defined as for &lt;a href=&quot;#genWidth&quot;&gt;General conversions&lt;/a&gt;.
 *
 * &lt;p&gt; The precision is not applicable.  If the precision is specified then an
 * {@link IllegalFormatPrecisionException} will be thrown.
 *
 * &lt;h4&gt;&lt;a name=&quot;dnum&quot;&gt;Numeric&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt; Numeric conversions are divided into the following categories:
 *
 * &lt;ol&gt;
 *
 * &lt;li&gt; &lt;a href=&quot;#dnint&quot;&gt;&lt;b&gt;Byte, Short, Integer, and Long&lt;/b&gt;&lt;/a&gt;
 *
 * &lt;li&gt; &lt;a href=&quot;#dnbint&quot;&gt;&lt;b&gt;BigInteger&lt;/b&gt;&lt;/a&gt;
 *
 * &lt;li&gt; &lt;a href=&quot;#dndec&quot;&gt;&lt;b&gt;Float and Double&lt;/b&gt;&lt;/a&gt;
 *
 * &lt;li&gt; &lt;a href=&quot;#dnbdec&quot;&gt;&lt;b&gt;BigDecimal&lt;/b&gt;&lt;/a&gt;
 *
 * &lt;/ol&gt;
 *
 * &lt;p&gt; Numeric types will be formatted according to the following algorithm:
 *
 * &lt;p&gt;&lt;b&gt;&lt;a name=&quot;L10nAlgorithm&quot;&gt; Number Localization Algorithm&lt;/a&gt;&lt;/b&gt;
 *
 * &lt;p&gt; After digits are obtained for the integer part, fractional part, and
 * exponent (as appropriate for the data type), the following transformation
 * is applied:
 *
 * &lt;ol&gt;
 *
 * &lt;li&gt; Each digit character &lt;i&gt;d&lt;/i&gt; in the string is replaced by a
 * locale-specific digit computed relative to the current locale's
 * {@linkplain java.text.DecimalFormatSymbols#getZeroDigit() zero digit}
 * &lt;i&gt;z&lt;/i&gt;; that is &lt;i&gt;d&amp;nbsp;-&amp;nbsp;&lt;/i&gt; {@code '0'}
 * &lt;i&gt;&amp;nbsp;+&amp;nbsp;z&lt;/i&gt;.
 *
 * &lt;li&gt; If a decimal separator is present, a locale-specific {@linkplain
 * java.text.DecimalFormatSymbols#getDecimalSeparator decimal separator} is
 * substituted.
 *
 * &lt;li&gt; If the {@code ','} (&lt;tt&gt;'&amp;#92;u002c'&lt;/tt&gt;)
 * &lt;a name=&quot;L10nGroup&quot;&gt;flag&lt;/a&gt; is given, then the locale-specific {@linkplain
 * java.text.DecimalFormatSymbols#getGroupingSeparator grouping separator} is
 * inserted by scanning the integer part of the string from least significant
 * to most significant digits and inserting a separator at intervals defined by
 * the locale's {@linkplain java.text.DecimalFormat#getGroupingSize() grouping
 * size}.
 *
 * &lt;li&gt; If the {@code '0'} flag is given, then the locale-specific {@linkplain
 * java.text.DecimalFormatSymbols#getZeroDigit() zero digits} are inserted
 * after the sign character, if any, and before the first non-zero digit, until
 * the length of the string is equal to the requested field width.
 *
 * &lt;li&gt; If the value is negative and the {@code '('} flag is given, then a
 * {@code '('} (&lt;tt&gt;'&amp;#92;u0028'&lt;/tt&gt;) is prepended and a {@code ')'}
 * (&lt;tt&gt;'&amp;#92;u0029'&lt;/tt&gt;) is appended.
 *
 * &lt;li&gt; If the value is negative (or floating-point negative zero) and
 * {@code '('} flag is not given, then a {@code '-'} (&lt;tt&gt;'&amp;#92;u002d'&lt;/tt&gt;)
 * is prepended.
 *
 * &lt;li&gt; If the {@code '+'} flag is given and the value is positive or zero (or
 * floating-point positive zero), then a {@code '+'} (&lt;tt&gt;'&amp;#92;u002b'&lt;/tt&gt;)
 * will be prepended.
 *
 * &lt;/ol&gt;
 *
 * &lt;p&gt; If the value is NaN or positive infinity the literal strings &quot;NaN&quot; or
 * &quot;Infinity&quot; respectively, will be output.  If the value is negative infinity,
 * then the output will be &quot;(Infinity)&quot; if the {@code '('} flag is given
 * otherwise the output will be &quot;-Infinity&quot;.  These values are not localized.
 *
 * &lt;p&gt;&lt;a name=&quot;dnint&quot;&gt;&lt;b&gt; Byte, Short, Integer, and Long &lt;/b&gt;&lt;/a&gt;
 *
 * &lt;p&gt; The following conversions may be applied to {@code byte}, {@link Byte},
 * {@code short}, {@link Short}, {@code int} and {@link Integer},
 * {@code long}, and {@link Long}.
 *
 * &lt;table cellpadding=5 summary=&quot;IntConv&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'd'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0064'&lt;/tt&gt;
 *     &lt;td&gt; Formats the argument as a decimal integer. The &lt;a
 *     href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
 *
 *     &lt;p&gt; If the {@code '0'} flag is given and the value is negative, then
 *     the zero padding will occur after the sign.
 *
 *     &lt;p&gt; If the {@code '#'} flag is given then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'o'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u006f'&lt;/tt&gt;
 *     &lt;td&gt; Formats the argument as an integer in base eight.  No localization
 *     is applied.
 *
 *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be an unsigned value
 *     generated by adding 2&lt;sup&gt;n&lt;/sup&gt; to the value where {@code n} is the
 *     number of bits in the type as returned by the static {@code SIZE} field
 *     in the {@linkplain Byte#SIZE Byte}, {@linkplain Short#SIZE Short},
 *     {@linkplain Integer#SIZE Integer}, or {@linkplain Long#SIZE Long}
 *     classes as appropriate.
 *
 *     &lt;p&gt; If the {@code '#'} flag is given then the output will always begin
 *     with the radix indicator {@code '0'}.
 *
 *     &lt;p&gt; If the {@code '0'} flag is given then the output will be padded
 *     with leading zeros to the field width following any indication of sign.
 *
 *     &lt;p&gt; If {@code '('}, {@code '+'}, '&amp;nbsp;&amp;nbsp;', or {@code ','} flags
 *     are given then a {@link FormatFlagsConversionMismatchException} will be
 *     thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'x'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0078'&lt;/tt&gt;
 *     &lt;td&gt; Formats the argument as an integer in base sixteen. No
 *     localization is applied.
 *
 *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be an unsigned value
 *     generated by adding 2&lt;sup&gt;n&lt;/sup&gt; to the value where {@code n} is the
 *     number of bits in the type as returned by the static {@code SIZE} field
 *     in the {@linkplain Byte#SIZE Byte}, {@linkplain Short#SIZE Short},
 *     {@linkplain Integer#SIZE Integer}, or {@linkplain Long#SIZE Long}
 *     classes as appropriate.
 *
 *     &lt;p&gt; If the {@code '#'} flag is given then the output will always begin
 *     with the radix indicator {@code &quot;0x&quot;}.
 *
 *     &lt;p&gt; If the {@code '0'} flag is given then the output will be padded to
 *     the field width with leading zeros after the radix indicator or sign (if
 *     present).
 *
 *     &lt;p&gt; If {@code '('}, &lt;tt&gt;'&amp;nbsp;&amp;nbsp;'&lt;/tt&gt;, {@code '+'}, or
 *     {@code ','} flags are given then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'X'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0058'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 'x'}.  The entire string
 *     representing the number will be converted to {@linkplain
 *     String#toUpperCase upper case} including the {@code 'x'} (if any) and
 *     all hexadecimal digits {@code 'a'} - {@code 'f'}
 *     (&lt;tt&gt;'&amp;#92;u0061'&lt;/tt&gt; -  &lt;tt&gt;'&amp;#92;u0066'&lt;/tt&gt;).
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; If the conversion is {@code 'o'}, {@code 'x'}, or {@code 'X'} and
 * both the {@code '#'} and the {@code '0'} flags are given, then result will
 * contain the radix indicator ({@code '0'} for octal and {@code &quot;0x&quot;} or
 * {@code &quot;0X&quot;} for hexadecimal), some number of zeros (based on the width),
 * and the value.
 *
 * &lt;p&gt; If the {@code '-'} flag is not given, then the space padding will occur
 * before the sign.
 *
 * &lt;p&gt; The following &lt;a name=&quot;intFlags&quot;&gt;flags&lt;/a&gt; apply to numeric integral
 * conversions:
 *
 * &lt;table cellpadding=5 summary=&quot;intFlags&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code '+'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u002b'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to include a positive sign for all positive
 *     numbers.  If this flag is not given then only negative values will
 *     include a sign.
 *
 *     &lt;p&gt; If both the {@code '+'} and &lt;tt&gt;'&amp;nbsp;&amp;nbsp;'&lt;/tt&gt; flags are given
 *     then an {@link IllegalFormatFlagsException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;nbsp;&amp;nbsp;'&lt;/tt&gt;
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0020'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to include a single extra space
 *     (&lt;tt&gt;'&amp;#92;u0020'&lt;/tt&gt;) for non-negative values.
 *
 *     &lt;p&gt; If both the {@code '+'} and &lt;tt&gt;'&amp;nbsp;&amp;nbsp;'&lt;/tt&gt; flags are given
 *     then an {@link IllegalFormatFlagsException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code '0'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0030'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to be padded with leading {@linkplain
 *     java.text.DecimalFormatSymbols#getZeroDigit zeros} to the minimum field
 *     width following any sign or radix indicator except when converting NaN
 *     or infinity.  If the width is not provided, then a {@link
 *     MissingFormatWidthException} will be thrown.
 *
 *     &lt;p&gt; If both the {@code '-'} and {@code '0'} flags are given then an
 *     {@link IllegalFormatFlagsException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code ','}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u002c'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to include the locale-specific {@linkplain
 *     java.text.DecimalFormatSymbols#getGroupingSeparator group separators} as
 *     described in the &lt;a href=&quot;#L10nGroup&quot;&gt;&quot;group&quot; section&lt;/a&gt; of the
 *     localization algorithm.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code '('}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0028'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to prepend a {@code '('}
 *     (&lt;tt&gt;'&amp;#92;u0028'&lt;/tt&gt;) and append a {@code ')'}
 *     (&lt;tt&gt;'&amp;#92;u0029'&lt;/tt&gt;) to negative values.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; If no &lt;a name=&quot;intdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is
 * as follows:
 *
 * &lt;ul&gt;
 *
 * &lt;li&gt; The output is right-justified within the {@code width}
 *
 * &lt;li&gt; Negative numbers begin with a {@code '-'} (&lt;tt&gt;'&amp;#92;u002d'&lt;/tt&gt;)
 *
 * &lt;li&gt; Positive numbers and zero do not include a sign or extra leading
 * space
 *
 * &lt;li&gt; No grouping separators are included
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt; The &lt;a name=&quot;intWidth&quot;&gt;width&lt;/a&gt; is the minimum number of characters to
 * be written to the output.  This includes any signs, digits, grouping
 * separators, radix indicator, and parentheses.  If the length of the
 * converted value is less than the width then the output will be padded by
 * spaces (&lt;tt&gt;'&amp;#92;u0020'&lt;/tt&gt;) until the total number of characters equals
 * width.  The padding is on the left by default.  If {@code '-'} flag is
 * given then the padding will be on the right.  If width is not specified then
 * there is no minimum.
 *
 * &lt;p&gt; The precision is not applicable.  If precision is specified then an
 * {@link IllegalFormatPrecisionException} will be thrown.
 *
 * &lt;p&gt;&lt;a name=&quot;dnbint&quot;&gt;&lt;b&gt; BigInteger &lt;/b&gt;&lt;/a&gt;
 *
 * &lt;p&gt; The following conversions may be applied to {@link
 * java.math.BigInteger}.
 *
 * &lt;table cellpadding=5 summary=&quot;BIntConv&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'd'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0064'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to be formatted as a decimal integer. The &lt;a
 *     href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
 *
 *     &lt;p&gt; If the {@code '#'} flag is given {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'o'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u006f'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to be formatted as an integer in base eight.
 *     No localization is applied.
 *
 *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be a signed value
 *     beginning with {@code '-'} (&lt;tt&gt;'&amp;#92;u002d'&lt;/tt&gt;).  Signed output is
 *     allowed for this type because unlike the primitive types it is not
 *     possible to create an unsigned equivalent without assuming an explicit
 *     data-type size.
 *
 *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or zero and the {@code '+'} flag is given
 *     then the result will begin with {@code '+'} (&lt;tt&gt;'&amp;#92;u002b'&lt;/tt&gt;).
 *
 *     &lt;p&gt; If the {@code '#'} flag is given then the output will always begin
 *     with {@code '0'} prefix.
 *
 *     &lt;p&gt; If the {@code '0'} flag is given then the output will be padded
 *     with leading zeros to the field width following any indication of sign.
 *
 *     &lt;p&gt; If the {@code ','} flag is given then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'x'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0078'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to be formatted as an integer in base
 *     sixteen.  No localization is applied.
 *
 *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be a signed value
 *     beginning with {@code '-'} (&lt;tt&gt;'&amp;#92;u002d'&lt;/tt&gt;).  Signed output is
 *     allowed for this type because unlike the primitive types it is not
 *     possible to create an unsigned equivalent without assuming an explicit
 *     data-type size.
 *
 *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or zero and the {@code '+'} flag is given
 *     then the result will begin with {@code '+'} (&lt;tt&gt;'&amp;#92;u002b'&lt;/tt&gt;).
 *
 *     &lt;p&gt; If the {@code '#'} flag is given then the output will always begin
 *     with the radix indicator {@code &quot;0x&quot;}.
 *
 *     &lt;p&gt; If the {@code '0'} flag is given then the output will be padded to
 *     the field width with leading zeros after the radix indicator or sign (if
 *     present).
 *
 *     &lt;p&gt; If the {@code ','} flag is given then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'X'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0058'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 'x'}.  The entire string
 *     representing the number will be converted to {@linkplain
 *     String#toUpperCase upper case} including the {@code 'x'} (if any) and
 *     all hexadecimal digits {@code 'a'} - {@code 'f'}
 *     (&lt;tt&gt;'&amp;#92;u0061'&lt;/tt&gt; - &lt;tt&gt;'&amp;#92;u0066'&lt;/tt&gt;).
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; If the conversion is {@code 'o'}, {@code 'x'}, or {@code 'X'} and
 * both the {@code '#'} and the {@code '0'} flags are given, then result will
 * contain the base indicator ({@code '0'} for octal and {@code &quot;0x&quot;} or
 * {@code &quot;0X&quot;} for hexadecimal), some number of zeros (based on the width),
 * and the value.
 *
 * &lt;p&gt; If the {@code '0'} flag is given and the value is negative, then the
 * zero padding will occur after the sign.
 *
 * &lt;p&gt; If the {@code '-'} flag is not given, then the space padding will occur
 * before the sign.
 *
 * &lt;p&gt; All &lt;a href=&quot;#intFlags&quot;&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
 * Long apply.  The &lt;a href=&quot;#intdFlags&quot;&gt;default behavior&lt;/a&gt; when no flags are
 * given is the same as for Byte, Short, Integer, and Long.
 *
 * &lt;p&gt; The specification of &lt;a href=&quot;#intWidth&quot;&gt;width&lt;/a&gt; is the same as
 * defined for Byte, Short, Integer, and Long.
 *
 * &lt;p&gt; The precision is not applicable.  If precision is specified then an
 * {@link IllegalFormatPrecisionException} will be thrown.
 *
 * &lt;p&gt;&lt;a name=&quot;dndec&quot;&gt;&lt;b&gt; Float and Double&lt;/b&gt;&lt;/a&gt;
 *
 * &lt;p&gt; The following conversions may be applied to {@code float}, {@link
 * Float}, {@code double} and {@link Double}.
 *
 * &lt;table cellpadding=5 summary=&quot;floatConv&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'e'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0065'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to be formatted using &lt;a
 *     name=&quot;scientific&quot;&gt;computerized scientific notation&lt;/a&gt;.  The &lt;a
 *     href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
 *
 *     &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
 *
 *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is NaN or infinite, the literal strings &quot;NaN&quot; or
 *     &quot;Infinity&quot;, respectively, will be output.  These values are not
 *     localized.
 *
 *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is positive-zero or negative-zero, then the exponent
 *     will be {@code &quot;+00&quot;}.
 *
 *     &lt;p&gt; Otherwise, the result is a string that represents the sign and
 *     magnitude (absolute value) of the argument.  The formatting of the sign
 *     is described in the &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
 *     algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
 *     value.
 *
 *     &lt;p&gt; Let &lt;i&gt;n&lt;/i&gt; be the unique integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;
 *     &amp;lt;= &lt;i&gt;m&lt;/i&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt; be the
 *     mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so
 *     that 1 &amp;lt;= &lt;i&gt;a&lt;/i&gt; &amp;lt; 10. The magnitude is then represented as the
 *     integer part of &lt;i&gt;a&lt;/i&gt;, as a single decimal digit, followed by the
 *     decimal separator followed by decimal digits representing the fractional
 *     part of &lt;i&gt;a&lt;/i&gt;, followed by the exponent symbol {@code 'e'}
 *     (&lt;tt&gt;'&amp;#92;u0065'&lt;/tt&gt;), followed by the sign of the exponent, followed
 *     by a representation of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as produced by the
 *     method {@link Long#toString(long, int)}, and zero-padded to include at
 *     least two digits.
 *
 *     &lt;p&gt; The number of digits in the result for the fractional part of
 *     &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
 *     specified then the default value is {@code 6}. If the precision is less
 *     than the number of digits which would appear after the decimal point in
 *     the string returned by {@link Float#toString(float)} or {@link
 *     Double#toString(double)} respectively, then the value will be rounded
 *     using the {@linkplain java.math.BigDecimal#ROUND_HALF_UP round half up
 *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
 *     For a canonical representation of the value, use {@link
 *     Float#toString(float)} or {@link Double#toString(double)} as
 *     appropriate.
 *
 *     &lt;p&gt;If the {@code ','} flag is given, then an {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'E'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0045'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 'e'}.  The exponent symbol
 *     will be {@code 'E'} (&lt;tt&gt;'&amp;#92;u0045'&lt;/tt&gt;).
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'g'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0067'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to be formatted in general scientific notation
 *     as described below. The &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
 *     algorithm&lt;/a&gt; is applied.
 *
 *     &lt;p&gt; After rounding for the precision, the formatting of the resulting
 *     magnitude &lt;i&gt;m&lt;/i&gt; depends on its value.
 *
 *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-4&lt;/sup&gt; but less
 *     than 10&lt;sup&gt;precision&lt;/sup&gt; then it is represented in &lt;i&gt;&lt;a
 *     href=&quot;#decimal&quot;&gt;decimal format&lt;/a&gt;&lt;/i&gt;.
 *
 *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-4&lt;/sup&gt; or greater than or equal to
 *     10&lt;sup&gt;precision&lt;/sup&gt;, then it is represented in &lt;i&gt;&lt;a
 *     href=&quot;#scientific&quot;&gt;computerized scientific notation&lt;/a&gt;&lt;/i&gt;.
 *
 *     &lt;p&gt; The total number of significant digits in &lt;i&gt;m&lt;/i&gt; is equal to the
 *     precision.  If the precision is not specified, then the default value is
 *     {@code 6}.  If the precision is {@code 0}, then it is taken to be
 *     {@code 1}.
 *
 *     &lt;p&gt; If the {@code '#'} flag is given then an {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'G'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0047'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 'g'}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'f'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0066'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to be formatted using &lt;a name=&quot;decimal&quot;&gt;decimal
 *     format&lt;/a&gt;.  The &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is
 *     applied.
 *
 *     &lt;p&gt; The result is a string that represents the sign and magnitude
 *     (absolute value) of the argument.  The formatting of the sign is
 *     described in the &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
 *     algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
 *     value.
 *
 *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; NaN or infinite, the literal strings &quot;NaN&quot; or
 *     &quot;Infinity&quot;, respectively, will be output.  These values are not
 *     localized.
 *
 *     &lt;p&gt; The magnitude is formatted as the integer part of &lt;i&gt;m&lt;/i&gt;, with no
 *     leading zeroes, followed by the decimal separator followed by one or
 *     more decimal digits representing the fractional part of &lt;i&gt;m&lt;/i&gt;.
 *
 *     &lt;p&gt; The number of digits in the result for the fractional part of
 *     &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
 *     specified then the default value is {@code 6}. If the precision is less
 *     than the number of digits which would appear after the decimal point in
 *     the string returned by {@link Float#toString(float)} or {@link
 *     Double#toString(double)} respectively, then the value will be rounded
 *     using the {@linkplain java.math.BigDecimal#ROUND_HALF_UP round half up
 *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
 *     For a canonical representation of the value, use {@link
 *     Float#toString(float)} or {@link Double#toString(double)} as
 *     appropriate.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'a'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0061'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to be formatted in hexadecimal exponential
 *     form.  No localization is applied.
 *
 *     &lt;p&gt; The result is a string that represents the sign and magnitude
 *     (absolute value) of the argument &lt;i&gt;x&lt;/i&gt;.
 *
 *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative or a negative-zero value then the result
 *     will begin with {@code '-'} (&lt;tt&gt;'&amp;#92;u002d'&lt;/tt&gt;).
 *
 *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or a positive-zero value and the
 *     {@code '+'} flag is given then the result will begin with {@code '+'}
 *     (&lt;tt&gt;'&amp;#92;u002b'&lt;/tt&gt;).
 *
 *     &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
 *
 *     &lt;ul&gt;
 *
 *     &lt;li&gt; If the value is NaN or infinite, the literal strings &quot;NaN&quot; or
 *     &quot;Infinity&quot;, respectively, will be output.
 *
 *     &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is zero then it is represented by the string
 *     {@code &quot;0x0.0p0&quot;}.
 *
 *     &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a normalized
 *     representation then substrings are used to represent the significand and
 *     exponent fields.  The significand is represented by the characters
 *     {@code &quot;0x1.&quot;} followed by the hexadecimal representation of the rest
 *     of the significand as a fraction.  The exponent is represented by
 *     {@code 'p'} (&lt;tt&gt;'&amp;#92;u0070'&lt;/tt&gt;) followed by a decimal string of the
 *     unbiased exponent as if produced by invoking {@link
 *     Integer#toString(int) Integer.toString} on the exponent value.  If the
 *     precision is specified, the value is rounded to the given number of
 *     hexadecimal digits.
 *
 *     &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a subnormal
 *     representation then, unless the precision is specified to be in the range
 *     1 through 12, inclusive, the significand is represented by the characters
 *     {@code '0x0.'} followed by the hexadecimal representation of the rest of
 *     the significand as a fraction, and the exponent represented by
 *     {@code 'p-1022'}.  If the precision is in the interval
 *     [1,&amp;nbsp;12], the subnormal value is normalized such that it
 *     begins with the characters {@code '0x1.'}, rounded to the number of
 *     hexadecimal digits of precision, and the exponent adjusted
 *     accordingly.  Note that there must be at least one nonzero digit in a
 *     subnormal significand.
 *
 *     &lt;/ul&gt;
 *
 *     &lt;p&gt; If the {@code '('} or {@code ','} flags are given, then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'A'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0041'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 'a'}.  The entire string
 *     representing the number will be converted to upper case including the
 *     {@code 'x'} (&lt;tt&gt;'&amp;#92;u0078'&lt;/tt&gt;) and {@code 'p'}
 *     (&lt;tt&gt;'&amp;#92;u0070'&lt;/tt&gt; and all hexadecimal digits {@code 'a'} -
 *     {@code 'f'} (&lt;tt&gt;'&amp;#92;u0061'&lt;/tt&gt; - &lt;tt&gt;'&amp;#92;u0066'&lt;/tt&gt;).
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; All &lt;a href=&quot;#intFlags&quot;&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
 * Long apply.
 *
 * &lt;p&gt; If the {@code '#'} flag is given, then the decimal separator will
 * always be present.
 *
 * &lt;p&gt; If no &lt;a name=&quot;floatdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting
 * is as follows:
 *
 * &lt;ul&gt;
 *
 * &lt;li&gt; The output is right-justified within the {@code width}
 *
 * &lt;li&gt; Negative numbers begin with a {@code '-'}
 *
 * &lt;li&gt; Positive numbers and positive zero do not include a sign or extra
 * leading space
 *
 * &lt;li&gt; No grouping separators are included
 *
 * &lt;li&gt; The decimal separator will only appear if a digit follows it
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt; The &lt;a name=&quot;floatDWidth&quot;&gt;width&lt;/a&gt; is the minimum number of characters
 * to be written to the output.  This includes any signs, digits, grouping
 * separators, decimal separators, exponential symbol, radix indicator,
 * parentheses, and strings representing infinity and NaN as applicable.  If
 * the length of the converted value is less than the width then the output
 * will be padded by spaces (&lt;tt&gt;'&amp;#92;u0020'&lt;/tt&gt;) until the total number of
 * characters equals width.  The padding is on the left by default.  If the
 * {@code '-'} flag is given then the padding will be on the right.  If width
 * is not specified then there is no minimum.
 *
 * &lt;p&gt; If the &lt;a name=&quot;floatDPrec&quot;&gt;conversion&lt;/a&gt; is {@code 'e'},
 * {@code 'E'} or {@code 'f'}, then the precision is the number of digits
 * after the decimal separator.  If the precision is not specified, then it is
 * assumed to be {@code 6}.
 *
 * &lt;p&gt; If the conversion is {@code 'g'} or {@code 'G'}, then the precision is
 * the total number of significant digits in the resulting magnitude after
 * rounding.  If the precision is not specified, then the default value is
 * {@code 6}.  If the precision is {@code 0}, then it is taken to be
 * {@code 1}.
 *
 * &lt;p&gt; If the conversion is {@code 'a'} or {@code 'A'}, then the precision
 * is the number of hexadecimal digits after the radix point.  If the
 * precision is not provided, then all of the digits as returned by {@link
 * Double#toHexString(double)} will be output.
 *
 * &lt;p&gt;&lt;a name=&quot;dnbdec&quot;&gt;&lt;b&gt; BigDecimal &lt;/b&gt;&lt;/a&gt;
 *
 * &lt;p&gt; The following conversions may be applied {@link java.math.BigDecimal
 * BigDecimal}.
 *
 * &lt;table cellpadding=5 summary=&quot;floatConv&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'e'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0065'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to be formatted using &lt;a
 *     name=&quot;bscientific&quot;&gt;computerized scientific notation&lt;/a&gt;.  The &lt;a
 *     href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
 *
 *     &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
 *
 *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is positive-zero or negative-zero, then the exponent
 *     will be {@code &quot;+00&quot;}.
 *
 *     &lt;p&gt; Otherwise, the result is a string that represents the sign and
 *     magnitude (absolute value) of the argument.  The formatting of the sign
 *     is described in the &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
 *     algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
 *     value.
 *
 *     &lt;p&gt; Let &lt;i&gt;n&lt;/i&gt; be the unique integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;
 *     &amp;lt;= &lt;i&gt;m&lt;/i&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt; be the
 *     mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so
 *     that 1 &amp;lt;= &lt;i&gt;a&lt;/i&gt; &amp;lt; 10. The magnitude is then represented as the
 *     integer part of &lt;i&gt;a&lt;/i&gt;, as a single decimal digit, followed by the
 *     decimal separator followed by decimal digits representing the fractional
 *     part of &lt;i&gt;a&lt;/i&gt;, followed by the exponent symbol {@code 'e'}
 *     (&lt;tt&gt;'&amp;#92;u0065'&lt;/tt&gt;), followed by the sign of the exponent, followed
 *     by a representation of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as produced by the
 *     method {@link Long#toString(long, int)}, and zero-padded to include at
 *     least two digits.
 *
 *     &lt;p&gt; The number of digits in the result for the fractional part of
 *     &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
 *     specified then the default value is {@code 6}.  If the precision is
 *     less than the number of digits to the right of the decimal point then
 *     the value will be rounded using the
 *     {@linkplain java.math.BigDecimal#ROUND_HALF_UP round half up
 *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
 *     For a canonical representation of the value, use {@link
 *     BigDecimal#toString()}.
 *
 *     &lt;p&gt; If the {@code ','} flag is given, then an {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'E'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0045'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 'e'}.  The exponent symbol
 *     will be {@code 'E'} (&lt;tt&gt;'&amp;#92;u0045'&lt;/tt&gt;).
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'g'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0067'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to be formatted in general scientific notation
 *     as described below. The &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
 *     algorithm&lt;/a&gt; is applied.
 *
 *     &lt;p&gt; After rounding for the precision, the formatting of the resulting
 *     magnitude &lt;i&gt;m&lt;/i&gt; depends on its value.
 *
 *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-4&lt;/sup&gt; but less
 *     than 10&lt;sup&gt;precision&lt;/sup&gt; then it is represented in &lt;i&gt;&lt;a
 *     href=&quot;#bdecimal&quot;&gt;decimal format&lt;/a&gt;&lt;/i&gt;.
 *
 *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-4&lt;/sup&gt; or greater than or equal to
 *     10&lt;sup&gt;precision&lt;/sup&gt;, then it is represented in &lt;i&gt;&lt;a
 *     href=&quot;#bscientific&quot;&gt;computerized scientific notation&lt;/a&gt;&lt;/i&gt;.
 *
 *     &lt;p&gt; The total number of significant digits in &lt;i&gt;m&lt;/i&gt; is equal to the
 *     precision.  If the precision is not specified, then the default value is
 *     {@code 6}.  If the precision is {@code 0}, then it is taken to be
 *     {@code 1}.
 *
 *     &lt;p&gt; If the {@code '#'} flag is given then an {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'G'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0047'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 'g'}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'f'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0066'&lt;/tt&gt;
 *     &lt;td&gt; Requires the output to be formatted using &lt;a name=&quot;bdecimal&quot;&gt;decimal
 *     format&lt;/a&gt;.  The &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is
 *     applied.
 *
 *     &lt;p&gt; The result is a string that represents the sign and magnitude
 *     (absolute value) of the argument.  The formatting of the sign is
 *     described in the &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
 *     algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
 *     value.
 *
 *     &lt;p&gt; The magnitude is formatted as the integer part of &lt;i&gt;m&lt;/i&gt;, with no
 *     leading zeroes, followed by the decimal separator followed by one or
 *     more decimal digits representing the fractional part of &lt;i&gt;m&lt;/i&gt;.
 *
 *     &lt;p&gt; The number of digits in the result for the fractional part of
 *     &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision. If the precision is not
 *     specified then the default value is {@code 6}.  If the precision is
 *     less than the number of digits to the right of the decimal point
 *     then the value will be rounded using the
 *     {@linkplain java.math.BigDecimal#ROUND_HALF_UP round half up
 *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
 *     For a canonical representation of the value, use {@link
 *     BigDecimal#toString()}.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; All &lt;a href=&quot;#intFlags&quot;&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
 * Long apply.
 *
 * &lt;p&gt; If the {@code '#'} flag is given, then the decimal separator will
 * always be present.
 *
 * &lt;p&gt; The &lt;a href=&quot;#floatdFlags&quot;&gt;default behavior&lt;/a&gt; when no flags are
 * given is the same as for Float and Double.
 *
 * &lt;p&gt; The specification of &lt;a href=&quot;#floatDWidth&quot;&gt;width&lt;/a&gt; and &lt;a
 * href=&quot;#floatDPrec&quot;&gt;precision&lt;/a&gt; is the same as defined for Float and
 * Double.
 *
 * &lt;h4&gt;&lt;a name=&quot;ddt&quot;&gt;Date/Time&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt; This conversion may be applied to {@code long}, {@link Long}, {@link
 * Calendar}, {@link Date} and {@link TemporalAccessor TemporalAccessor}
 *
 * &lt;table cellpadding=5 summary=&quot;DTConv&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 't'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0074'&lt;/tt&gt;
 *     &lt;td&gt; Prefix for date and time conversion characters.
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'T'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0054'&lt;/tt&gt;
 *     &lt;td&gt; The upper-case variant of {@code 't'}.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; The following date and time conversion character suffixes are defined
 * for the {@code 't'} and {@code 'T'} conversions.  The types are similar to
 * but not completely identical to those defined by GNU {@code date} and
 * POSIX {@code strftime(3c)}.  Additional conversion types are provided to
 * access Java-specific functionality (e.g. {@code 'L'} for milliseconds
 * within the second).
 *
 * &lt;p&gt; The following conversion characters are used for formatting times:
 *
 * &lt;table cellpadding=5 summary=&quot;time&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code 'H'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0048'&lt;/tt&gt;
 *     &lt;td&gt; Hour of the day for the 24-hour clock, formatted as two digits with
 *     a leading zero as necessary i.e. {@code 00 - 23}. {@code 00}
 *     corresponds to midnight.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'I'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0049'&lt;/tt&gt;
 *     &lt;td&gt; Hour for the 12-hour clock, formatted as two digits with a leading
 *     zero as necessary, i.e.  {@code 01 - 12}.  {@code 01} corresponds to
 *     one o'clock (either morning or afternoon).
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'k'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u006b'&lt;/tt&gt;
 *     &lt;td&gt; Hour of the day for the 24-hour clock, i.e. {@code 0 - 23}.
 *     {@code 0} corresponds to midnight.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'l'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u006c'&lt;/tt&gt;
 *     &lt;td&gt; Hour for the 12-hour clock, i.e. {@code 1 - 12}.  {@code 1}
 *     corresponds to one o'clock (either morning or afternoon).
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'M'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u004d'&lt;/tt&gt;
 *     &lt;td&gt; Minute within the hour formatted as two digits with a leading zero
 *     as necessary, i.e.  {@code 00 - 59}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'S'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0053'&lt;/tt&gt;
 *     &lt;td&gt; Seconds within the minute, formatted as two digits with a leading
 *     zero as necessary, i.e. {@code 00 - 60} (&quot;{@code 60}&quot; is a special
 *     value required to support leap seconds).
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'L'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u004c'&lt;/tt&gt;
 *     &lt;td&gt; Millisecond within the second formatted as three digits with
 *     leading zeros as necessary, i.e. {@code 000 - 999}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'N'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u004e'&lt;/tt&gt;
 *     &lt;td&gt; Nanosecond within the second, formatted as nine digits with leading
 *     zeros as necessary, i.e. {@code 000000000 - 999999999}.  The precision
 *     of this value is limited by the resolution of the underlying operating
 *     system or hardware.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'p'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0070'&lt;/tt&gt;
 *     &lt;td&gt; Locale-specific {@linkplain
 *     java.text.DateFormatSymbols#getAmPmStrings morning or afternoon} marker
 *     in lower case, e.g.&quot;{@code am}&quot; or &quot;{@code pm}&quot;.  Use of the
 *     conversion prefix {@code 'T'} forces this output to upper case.  (Note
 *     that {@code 'p'} produces lower-case output.  This is different from
 *     GNU {@code date} and POSIX {@code strftime(3c)} which produce
 *     upper-case output.)
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'z'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u007a'&lt;/tt&gt;
 *     &lt;td&gt; &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC&amp;nbsp;822&lt;/a&gt;
 *     style numeric time zone offset from GMT, e.g. {@code -0800}.  This
 *     value will be adjusted as necessary for Daylight Saving Time.  For
 *     {@code long}, {@link Long}, and {@link Date} the time zone used is
 *     the {@linkplain TimeZone#getDefault() default time zone} for this
 *     instance of the Java virtual machine.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'Z'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u005a'&lt;/tt&gt;
 *     &lt;td&gt; A string representing the abbreviation for the time zone.  This
 *     value will be adjusted as necessary for Daylight Saving Time.  For
 *     {@code long}, {@link Long}, and {@link Date} the time zone used is
 *     the {@linkplain TimeZone#getDefault() default time zone} for this
 *     instance of the Java virtual machine.  The Formatter's locale will
 *     supersede the locale of the argument (if any).
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 's'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0073'&lt;/tt&gt;
 *     &lt;td&gt; Seconds since the beginning of the epoch starting at 1 January 1970
 *     {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE/1000} to
 *     {@code Long.MAX_VALUE/1000}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'Q'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u004f'&lt;/tt&gt;
 *     &lt;td&gt; Milliseconds since the beginning of the epoch starting at 1 January
 *     1970 {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE} to
 *     {@code Long.MAX_VALUE}. The precision of this value is limited by
 *     the resolution of the underlying operating system or hardware.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; The following conversion characters are used for formatting dates:
 *
 * &lt;table cellpadding=5 summary=&quot;date&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'B'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0042'&lt;/tt&gt;
 *     &lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getMonths
 *     full month name}, e.g. {@code &quot;January&quot;}, {@code &quot;February&quot;}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'b'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0062'&lt;/tt&gt;
 *     &lt;td&gt; Locale-specific {@linkplain
 *     java.text.DateFormatSymbols#getShortMonths abbreviated month name},
 *     e.g. {@code &quot;Jan&quot;}, {@code &quot;Feb&quot;}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'h'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0068'&lt;/tt&gt;
 *     &lt;td&gt; Same as {@code 'b'}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'A'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0041'&lt;/tt&gt;
 *     &lt;td&gt; Locale-specific full name of the {@linkplain
 *     java.text.DateFormatSymbols#getWeekdays day of the week},
 *     e.g. {@code &quot;Sunday&quot;}, {@code &quot;Monday&quot;}
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'a'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0061'&lt;/tt&gt;
 *     &lt;td&gt; Locale-specific short name of the {@linkplain
 *     java.text.DateFormatSymbols#getShortWeekdays day of the week},
 *     e.g. {@code &quot;Sun&quot;}, {@code &quot;Mon&quot;}
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'C'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0043'&lt;/tt&gt;
 *     &lt;td&gt; Four-digit year divided by {@code 100}, formatted as two digits
 *     with leading zero as necessary, i.e. {@code 00 - 99}
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'Y'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0059'&lt;/tt&gt; &lt;td&gt; Year, formatted to at least
 *     four digits with leading zeros as necessary, e.g. {@code 0092} equals
 *     {@code 92} CE for the Gregorian calendar.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'y'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0079'&lt;/tt&gt;
 *     &lt;td&gt; Last two digits of the year, formatted with leading zeros as
 *     necessary, i.e. {@code 00 - 99}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'j'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u006a'&lt;/tt&gt;
 *     &lt;td&gt; Day of year, formatted as three digits with leading zeros as
 *     necessary, e.g. {@code 001 - 366} for the Gregorian calendar.
 *     {@code 001} corresponds to the first day of the year.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'm'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u006d'&lt;/tt&gt;
 *     &lt;td&gt; Month, formatted as two digits with leading zeros as necessary,
 *     i.e. {@code 01 - 13}, where &quot;{@code 01}&quot; is the first month of the
 *     year and (&quot;{@code 13}&quot; is a special value required to support lunar
 *     calendars).
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'd'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0064'&lt;/tt&gt;
 *     &lt;td&gt; Day of month, formatted as two digits with leading zeros as
 *     necessary, i.e. {@code 01 - 31}, where &quot;{@code 01}&quot; is the first day
 *     of the month.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'e'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0065'&lt;/tt&gt;
 *     &lt;td&gt; Day of month, formatted as two digits, i.e. {@code 1 - 31} where
 *     &quot;{@code 1}&quot; is the first day of the month.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; The following conversion characters are used for formatting common
 * date/time compositions.
 *
 * &lt;table cellpadding=5 summary=&quot;composites&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'R'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0052'&lt;/tt&gt;
 *     &lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM&quot;}
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'T'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0054'&lt;/tt&gt;
 *     &lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM:%tS&quot;}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'r'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0072'&lt;/tt&gt;
 *     &lt;td&gt; Time formatted for the 12-hour clock as {@code &quot;%tI:%tM:%tS
 *     %Tp&quot;}.  The location of the morning or afternoon marker
 *     ({@code '%Tp'}) may be locale-dependent.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'D'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0044'&lt;/tt&gt;
 *     &lt;td&gt; Date formatted as {@code &quot;%tm/%td/%ty&quot;}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'F'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0046'&lt;/tt&gt;
 *     &lt;td&gt; &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO&amp;nbsp;8601&lt;/a&gt;
 *     complete date formatted as {@code &quot;%tY-%tm-%td&quot;}.
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'c'}
 *     &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;'&amp;#92;u0063'&lt;/tt&gt;
 *     &lt;td&gt; Date and time formatted as {@code &quot;%ta %tb %td %tT %tZ %tY&quot;},
 *     e.g. {@code &quot;Sun Jul 20 16:17:00 EDT 1969&quot;}.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; The {@code '-'} flag defined for &lt;a href=&quot;#dFlags&quot;&gt;General
 * conversions&lt;/a&gt; applies.  If the {@code '#'} flag is given, then a {@link
 * FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;p&gt; The width is the minimum number of characters to
 * be written to the output.  If the length of the converted value is less than
 * the {@code width} then the output will be padded by spaces
 * (&lt;tt&gt;'&amp;#92;u0020'&lt;/tt&gt;) until the total number of characters equals width.
 * The padding is on the left by default.  If the {@code '-'} flag is given
 * then the padding will be on the right.  If width is not specified then there
 * is no minimum.
 *
 * &lt;p&gt; The precision is not applicable.  If the precision is specified then an
 * {@link IllegalFormatPrecisionException} will be thrown.
 *
 * &lt;h4&gt;&lt;a name=&quot;dper&quot;&gt;Percent&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt; The conversion does not correspond to any argument.
 *
 * &lt;table cellpadding=5 summary=&quot;DTConv&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code '%'}
 *     &lt;td&gt; The result is a literal {@code '%'} (&lt;tt&gt;'&amp;#92;u0025'&lt;/tt&gt;)
 *
 * &lt;p&gt; The width is the minimum number of characters to
 * be written to the output including the {@code '%'}.  If the length of the
 * converted value is less than the {@code width} then the output will be
 * padded by spaces (&lt;tt&gt;'&amp;#92;u0020'&lt;/tt&gt;) until the total number of
 * characters equals width.  The padding is on the left.  If width is not
 * specified then just the {@code '%'} is output.
 *
 * &lt;p&gt; The {@code '-'} flag defined for &lt;a href=&quot;#dFlags&quot;&gt;General
 * conversions&lt;/a&gt; applies.  If any other flags are provided, then a
 * {@link FormatFlagsConversionMismatchException} will be thrown.
 *
 * &lt;p&gt; The precision is not applicable.  If the precision is specified an
 * {@link IllegalFormatPrecisionException} will be thrown.
 *
 * &lt;/table&gt;
 *
 * &lt;h4&gt;&lt;a name=&quot;dls&quot;&gt;Line Separator&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt; The conversion does not correspond to any argument.
 *
 * &lt;table cellpadding=5 summary=&quot;DTConv&quot;&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code 'n'}
 *     &lt;td&gt; the platform-specific line separator as returned by {@link
 *     System#getProperty System.getProperty(&quot;line.separator&quot;)}.
 *
 * &lt;/table&gt;
 *
 * &lt;p&gt; Flags, width, and precision are not applicable.  If any are provided an
 * {@link IllegalFormatFlagsException}, {@link IllegalFormatWidthException},
 * and {@link IllegalFormatPrecisionException}, respectively will be thrown.
 *
 * &lt;h4&gt;&lt;a name=&quot;dpos&quot;&gt;Argument Index&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt; Format specifiers can reference arguments in three ways:
 *
 * &lt;ul&gt;
 *
 * &lt;li&gt; &lt;i&gt;Explicit indexing&lt;/i&gt; is used when the format specifier contains an
 * argument index.  The argument index is a decimal integer indicating the
 * position of the argument in the argument list.  The first argument is
 * referenced by &quot;{@code 1$}&quot;, the second by &quot;{@code 2$}&quot;, etc.  An argument
 * may be referenced more than once.
 *
 * &lt;p&gt; For example:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   formatter.format(&quot;%4$s %3$s %2$s %1$s %4$s %3$s %2$s %1$s&quot;,
 *                    &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
 *   // -&amp;gt; &quot;d c b a d c b a&quot;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;li&gt; &lt;i&gt;Relative indexing&lt;/i&gt; is used when the format specifier contains a
 * {@code '&lt;'} (&lt;tt&gt;'&amp;#92;u003c'&lt;/tt&gt;) flag which causes the argument for
 * the previous format specifier to be re-used.  If there is no previous
 * argument, then a {@link MissingFormatArgumentException} is thrown.
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *    formatter.format(&quot;%s %s %&amp;lt;s %&amp;lt;s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
 *    // -&amp;gt; &quot;a b b b&quot;
 *    // &quot;c&quot; and &quot;d&quot; are ignored because they are not referenced
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;li&gt; &lt;i&gt;Ordinary indexing&lt;/i&gt; is used when the format specifier contains
 * neither an argument index nor a {@code '&lt;'} flag.  Each format specifier
 * which uses ordinary indexing is assigned a sequential implicit index into
 * argument list which is independent of the indices used by explicit or
 * relative indexing.
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   formatter.format(&quot;%s %s %s %s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
 *   // -&amp;gt; &quot;a b c d&quot;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt; It is possible to have a format string which uses all forms of indexing,
 * for example:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   formatter.format(&quot;%2$s %s %&amp;lt;s %s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
 *   // -&amp;gt; &quot;b a a b&quot;
 *   // &quot;c&quot; and &quot;d&quot; are ignored because they are not referenced
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; The maximum number of arguments is limited by the maximum dimension of a
 * Java array as defined by
 * &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
 * If the argument index is does not correspond to an
 * available argument, then a {@link MissingFormatArgumentException} is thrown.
 *
 * &lt;p&gt; If there are more arguments than format specifiers, the extra arguments
 * are ignored.
 *
 * &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
 * method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @author  Iris Clark
 * @since 1.5
 */
public final class Formatter implements Closeable, Flushable {
    private Appendable a;
    private final Locale l;

    private IOException lastException;

    private final char zero;
    private static double scaleUp;

    // 1 (sign) + 19 (max # sig digits) + 1 ('.') + 1 ('e') + 1 (sign)
    // + 3 (max # exp digits) + 4 (error) = 30
    private static final int MAX_FD_CHARS = 30;

    /**
     * Returns a charset object for the given charset name.
     * @throws NullPointerException          is csn is null
     * @throws UnsupportedEncodingException  if the charset is not supported
     */
    private static Charset toCharset(String csn)
        throws UnsupportedEncodingException
    {
<span class="fc" id="L1872">        Objects.requireNonNull(csn, &quot;charsetName&quot;);</span>
        try {
<span class="fc" id="L1874">            return Charset.forName(csn);</span>
<span class="fc" id="L1875">        } catch (IllegalCharsetNameException|UnsupportedCharsetException unused) {</span>
            // UnsupportedEncodingException should be thrown
<span class="fc" id="L1877">            throw new UnsupportedEncodingException(csn);</span>
        }
    }

    private static final Appendable nonNullAppendable(Appendable a) {
<span class="fc bfc" id="L1882" title="All 2 branches covered.">        if (a == null)</span>
<span class="fc" id="L1883">            return new StringBuilder();</span>

<span class="fc" id="L1885">        return a;</span>
    }

    /* Private constructors */
<span class="fc" id="L1889">    private Formatter(Locale l, Appendable a) {</span>
<span class="fc" id="L1890">        this.a = a;</span>
<span class="fc" id="L1891">        this.l = l;</span>
<span class="fc" id="L1892">        this.zero = getZero(l);</span>
<span class="fc" id="L1893">    }</span>

    private Formatter(Charset charset, Locale l, File file)
        throws FileNotFoundException
    {
<span class="fc" id="L1898">        this(l,</span>
             new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset)));
<span class="fc" id="L1900">    }</span>

    /**
     * Constructs a new formatter.
     *
     * &lt;p&gt; The destination of the formatted output is a {@link StringBuilder}
     * which may be retrieved by invoking {@link #out out()} and whose
     * current content may be converted into a string by invoking {@link
     * #toString toString()}.  The locale used is the {@linkplain
     * Locale#getDefault(Locale.Category) default locale} for
     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
     * virtual machine.
     */
    public Formatter() {
<span class="fc" id="L1914">        this(Locale.getDefault(Locale.Category.FORMAT), new StringBuilder());</span>
<span class="fc" id="L1915">    }</span>

    /**
     * Constructs a new formatter with the specified destination.
     *
     * &lt;p&gt; The locale used is the {@linkplain
     * Locale#getDefault(Locale.Category) default locale} for
     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
     * virtual machine.
     *
     * @param  a
     *         Destination for the formatted output.  If {@code a} is
     *         {@code null} then a {@link StringBuilder} will be created.
     */
    public Formatter(Appendable a) {
<span class="fc" id="L1930">        this(Locale.getDefault(Locale.Category.FORMAT), nonNullAppendable(a));</span>
<span class="fc" id="L1931">    }</span>

    /**
     * Constructs a new formatter with the specified locale.
     *
     * &lt;p&gt; The destination of the formatted output is a {@link StringBuilder}
     * which may be retrieved by invoking {@link #out out()} and whose current
     * content may be converted into a string by invoking {@link #toString
     * toString()}.
     *
     * @param  l
     *         The {@linkplain java.util.Locale locale} to apply during
     *         formatting.  If {@code l} is {@code null} then no localization
     *         is applied.
     */
    public Formatter(Locale l) {
<span class="fc" id="L1947">        this(l, new StringBuilder());</span>
<span class="fc" id="L1948">    }</span>

    /**
     * Constructs a new formatter with the specified destination and locale.
     *
     * @param  a
     *         Destination for the formatted output.  If {@code a} is
     *         {@code null} then a {@link StringBuilder} will be created.
     *
     * @param  l
     *         The {@linkplain java.util.Locale locale} to apply during
     *         formatting.  If {@code l} is {@code null} then no localization
     *         is applied.
     */
    public Formatter(Appendable a, Locale l) {
<span class="fc" id="L1963">        this(l, nonNullAppendable(a));</span>
<span class="fc" id="L1964">    }</span>

    /**
     * Constructs a new formatter with the specified file name.
     *
     * &lt;p&gt; The charset used is the {@linkplain
     * java.nio.charset.Charset#defaultCharset() default charset} for this
     * instance of the Java virtual machine.
     *
     * &lt;p&gt; The locale used is the {@linkplain
     * Locale#getDefault(Locale.Category) default locale} for
     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
     * virtual machine.
     *
     * @param  fileName
     *         The name of the file to use as the destination of this
     *         formatter.  If the file exists then it will be truncated to
     *         zero size; otherwise, a new file will be created.  The output
     *         will be written to the file and is buffered.
     *
     * @throws  SecurityException
     *          If a security manager is present and {@link
     *          SecurityManager#checkWrite checkWrite(fileName)} denies write
     *          access to the file
     *
     * @throws  FileNotFoundException
     *          If the given file name does not denote an existing, writable
     *          regular file and a new regular file of that name cannot be
     *          created, or if some other error occurs while opening or
     *          creating the file
     */
    public Formatter(String fileName) throws FileNotFoundException {
<span class="fc" id="L1996">        this(Locale.getDefault(Locale.Category.FORMAT),</span>
             new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName))));
<span class="fc" id="L1998">    }</span>

    /**
     * Constructs a new formatter with the specified file name and charset.
     *
     * &lt;p&gt; The locale used is the {@linkplain
     * Locale#getDefault(Locale.Category) default locale} for
     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
     * virtual machine.
     *
     * @param  fileName
     *         The name of the file to use as the destination of this
     *         formatter.  If the file exists then it will be truncated to
     *         zero size; otherwise, a new file will be created.  The output
     *         will be written to the file and is buffered.
     *
     * @param  csn
     *         The name of a supported {@linkplain java.nio.charset.Charset
     *         charset}
     *
     * @throws  FileNotFoundException
     *          If the given file name does not denote an existing, writable
     *          regular file and a new regular file of that name cannot be
     *          created, or if some other error occurs while opening or
     *          creating the file
     *
     * @throws  SecurityException
     *          If a security manager is present and {@link
     *          SecurityManager#checkWrite checkWrite(fileName)} denies write
     *          access to the file
     *
     * @throws  UnsupportedEncodingException
     *          If the named charset is not supported
     */
    public Formatter(String fileName, String csn)
        throws FileNotFoundException, UnsupportedEncodingException
    {
<span class="fc" id="L2035">        this(fileName, csn, Locale.getDefault(Locale.Category.FORMAT));</span>
<span class="fc" id="L2036">    }</span>

    /**
     * Constructs a new formatter with the specified file name, charset, and
     * locale.
     *
     * @param  fileName
     *         The name of the file to use as the destination of this
     *         formatter.  If the file exists then it will be truncated to
     *         zero size; otherwise, a new file will be created.  The output
     *         will be written to the file and is buffered.
     *
     * @param  csn
     *         The name of a supported {@linkplain java.nio.charset.Charset
     *         charset}
     *
     * @param  l
     *         The {@linkplain java.util.Locale locale} to apply during
     *         formatting.  If {@code l} is {@code null} then no localization
     *         is applied.
     *
     * @throws  FileNotFoundException
     *          If the given file name does not denote an existing, writable
     *          regular file and a new regular file of that name cannot be
     *          created, or if some other error occurs while opening or
     *          creating the file
     *
     * @throws  SecurityException
     *          If a security manager is present and {@link
     *          SecurityManager#checkWrite checkWrite(fileName)} denies write
     *          access to the file
     *
     * @throws  UnsupportedEncodingException
     *          If the named charset is not supported
     */
    public Formatter(String fileName, String csn, Locale l)
        throws FileNotFoundException, UnsupportedEncodingException
    {
<span class="fc" id="L2074">        this(toCharset(csn), l, new File(fileName));</span>
<span class="fc" id="L2075">    }</span>

    /**
     * Constructs a new formatter with the specified file.
     *
     * &lt;p&gt; The charset used is the {@linkplain
     * java.nio.charset.Charset#defaultCharset() default charset} for this
     * instance of the Java virtual machine.
     *
     * &lt;p&gt; The locale used is the {@linkplain
     * Locale#getDefault(Locale.Category) default locale} for
     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
     * virtual machine.
     *
     * @param  file
     *         The file to use as the destination of this formatter.  If the
     *         file exists then it will be truncated to zero size; otherwise,
     *         a new file will be created.  The output will be written to the
     *         file and is buffered.
     *
     * @throws  SecurityException
     *          If a security manager is present and {@link
     *          SecurityManager#checkWrite checkWrite(file.getPath())} denies
     *          write access to the file
     *
     * @throws  FileNotFoundException
     *          If the given file object does not denote an existing, writable
     *          regular file and a new regular file of that name cannot be
     *          created, or if some other error occurs while opening or
     *          creating the file
     */
    public Formatter(File file) throws FileNotFoundException {
<span class="fc" id="L2107">        this(Locale.getDefault(Locale.Category.FORMAT),</span>
             new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file))));
<span class="fc" id="L2109">    }</span>

    /**
     * Constructs a new formatter with the specified file and charset.
     *
     * &lt;p&gt; The locale used is the {@linkplain
     * Locale#getDefault(Locale.Category) default locale} for
     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
     * virtual machine.
     *
     * @param  file
     *         The file to use as the destination of this formatter.  If the
     *         file exists then it will be truncated to zero size; otherwise,
     *         a new file will be created.  The output will be written to the
     *         file and is buffered.
     *
     * @param  csn
     *         The name of a supported {@linkplain java.nio.charset.Charset
     *         charset}
     *
     * @throws  FileNotFoundException
     *          If the given file object does not denote an existing, writable
     *          regular file and a new regular file of that name cannot be
     *          created, or if some other error occurs while opening or
     *          creating the file
     *
     * @throws  SecurityException
     *          If a security manager is present and {@link
     *          SecurityManager#checkWrite checkWrite(file.getPath())} denies
     *          write access to the file
     *
     * @throws  UnsupportedEncodingException
     *          If the named charset is not supported
     */
    public Formatter(File file, String csn)
        throws FileNotFoundException, UnsupportedEncodingException
    {
<span class="nc" id="L2146">        this(file, csn, Locale.getDefault(Locale.Category.FORMAT));</span>
<span class="nc" id="L2147">    }</span>

    /**
     * Constructs a new formatter with the specified file, charset, and
     * locale.
     *
     * @param  file
     *         The file to use as the destination of this formatter.  If the
     *         file exists then it will be truncated to zero size; otherwise,
     *         a new file will be created.  The output will be written to the
     *         file and is buffered.
     *
     * @param  csn
     *         The name of a supported {@linkplain java.nio.charset.Charset
     *         charset}
     *
     * @param  l
     *         The {@linkplain java.util.Locale locale} to apply during
     *         formatting.  If {@code l} is {@code null} then no localization
     *         is applied.
     *
     * @throws  FileNotFoundException
     *          If the given file object does not denote an existing, writable
     *          regular file and a new regular file of that name cannot be
     *          created, or if some other error occurs while opening or
     *          creating the file
     *
     * @throws  SecurityException
     *          If a security manager is present and {@link
     *          SecurityManager#checkWrite checkWrite(file.getPath())} denies
     *          write access to the file
     *
     * @throws  UnsupportedEncodingException
     *          If the named charset is not supported
     */
    public Formatter(File file, String csn, Locale l)
        throws FileNotFoundException, UnsupportedEncodingException
    {
<span class="nc" id="L2185">        this(toCharset(csn), l, file);</span>
<span class="nc" id="L2186">    }</span>

    /**
     * Constructs a new formatter with the specified print stream.
     *
     * &lt;p&gt; The locale used is the {@linkplain
     * Locale#getDefault(Locale.Category) default locale} for
     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
     * virtual machine.
     *
     * &lt;p&gt; Characters are written to the given {@link java.io.PrintStream
     * PrintStream} object and are therefore encoded using that object's
     * charset.
     *
     * @param  ps
     *         The stream to use as the destination of this formatter.
     */
    public Formatter(PrintStream ps) {
<span class="fc" id="L2204">        this(Locale.getDefault(Locale.Category.FORMAT),</span>
<span class="fc" id="L2205">             (Appendable)Objects.requireNonNull(ps));</span>
<span class="fc" id="L2206">    }</span>

    /**
     * Constructs a new formatter with the specified output stream.
     *
     * &lt;p&gt; The charset used is the {@linkplain
     * java.nio.charset.Charset#defaultCharset() default charset} for this
     * instance of the Java virtual machine.
     *
     * &lt;p&gt; The locale used is the {@linkplain
     * Locale#getDefault(Locale.Category) default locale} for
     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
     * virtual machine.
     *
     * @param  os
     *         The output stream to use as the destination of this formatter.
     *         The output will be buffered.
     */
    public Formatter(OutputStream os) {
<span class="fc" id="L2225">        this(Locale.getDefault(Locale.Category.FORMAT),</span>
             new BufferedWriter(new OutputStreamWriter(os)));
<span class="fc" id="L2227">    }</span>

    /**
     * Constructs a new formatter with the specified output stream and
     * charset.
     *
     * &lt;p&gt; The locale used is the {@linkplain
     * Locale#getDefault(Locale.Category) default locale} for
     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
     * virtual machine.
     *
     * @param  os
     *         The output stream to use as the destination of this formatter.
     *         The output will be buffered.
     *
     * @param  csn
     *         The name of a supported {@linkplain java.nio.charset.Charset
     *         charset}
     *
     * @throws  UnsupportedEncodingException
     *          If the named charset is not supported
     */
    public Formatter(OutputStream os, String csn)
        throws UnsupportedEncodingException
    {
<span class="fc" id="L2252">        this(os, csn, Locale.getDefault(Locale.Category.FORMAT));</span>
<span class="fc" id="L2253">    }</span>

    /**
     * Constructs a new formatter with the specified output stream, charset,
     * and locale.
     *
     * @param  os
     *         The output stream to use as the destination of this formatter.
     *         The output will be buffered.
     *
     * @param  csn
     *         The name of a supported {@linkplain java.nio.charset.Charset
     *         charset}
     *
     * @param  l
     *         The {@linkplain java.util.Locale locale} to apply during
     *         formatting.  If {@code l} is {@code null} then no localization
     *         is applied.
     *
     * @throws  UnsupportedEncodingException
     *          If the named charset is not supported
     */
    public Formatter(OutputStream os, String csn, Locale l)
        throws UnsupportedEncodingException
    {
<span class="fc" id="L2278">        this(l, new BufferedWriter(new OutputStreamWriter(os, csn)));</span>
<span class="fc" id="L2279">    }</span>

    private static char getZero(Locale l) {
<span class="fc bfc" id="L2282" title="All 4 branches covered.">        if ((l != null) &amp;&amp; !l.equals(Locale.US)) {</span>
<span class="fc" id="L2283">            DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(l);</span>
<span class="fc" id="L2284">            return dfs.getZeroDigit();</span>
        } else {
<span class="fc" id="L2286">            return '0';</span>
        }
    }

    /**
     * Returns the locale set by the construction of this formatter.
     *
     * &lt;p&gt; The {@link #format(java.util.Locale,String,Object...) format} method
     * for this object which has a locale argument does not change this value.
     *
     * @return  {@code null} if no localization is applied, otherwise a
     *          locale
     *
     * @throws  FormatterClosedException
     *          If this formatter has been closed by invoking its {@link
     *          #close()} method
     */
    public Locale locale() {
<span class="fc" id="L2304">        ensureOpen();</span>
<span class="fc" id="L2305">        return l;</span>
    }

    /**
     * Returns the destination for the output.
     *
     * @return  The destination for the output
     *
     * @throws  FormatterClosedException
     *          If this formatter has been closed by invoking its {@link
     *          #close()} method
     */
    public Appendable out() {
<span class="fc" id="L2318">        ensureOpen();</span>
<span class="fc" id="L2319">        return a;</span>
    }

    /**
     * Returns the result of invoking {@code toString()} on the destination
     * for the output.  For example, the following code formats text into a
     * {@link StringBuilder} then retrieves the resultant string:
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     *   Formatter f = new Formatter();
     *   f.format(&quot;Last reboot at %tc&quot;, lastRebootDate);
     *   String s = f.toString();
     *   // -&amp;gt; s == &quot;Last reboot at Sat Jan 01 00:00:00 PST 2000&quot;
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt; An invocation of this method behaves in exactly the same way as the
     * invocation
     *
     * &lt;pre&gt;
     *     out().toString() &lt;/pre&gt;
     *
     * &lt;p&gt; Depending on the specification of {@code toString} for the {@link
     * Appendable}, the returned string may or may not contain the characters
     * written to the destination.  For instance, buffers typically return
     * their contents in {@code toString()}, but streams cannot since the
     * data is discarded.
     *
     * @return  The result of invoking {@code toString()} on the destination
     *          for the output
     *
     * @throws  FormatterClosedException
     *          If this formatter has been closed by invoking its {@link
     *          #close()} method
     */
    public String toString() {
<span class="fc" id="L2354">        ensureOpen();</span>
<span class="fc" id="L2355">        return a.toString();</span>
    }

    /**
     * Flushes this formatter.  If the destination implements the {@link
     * java.io.Flushable} interface, its {@code flush} method will be invoked.
     *
     * &lt;p&gt; Flushing a formatter writes any buffered output in the destination
     * to the underlying stream.
     *
     * @throws  FormatterClosedException
     *          If this formatter has been closed by invoking its {@link
     *          #close()} method
     */
    public void flush() {
<span class="fc" id="L2370">        ensureOpen();</span>
<span class="fc bfc" id="L2371" title="All 2 branches covered.">        if (a instanceof Flushable) {</span>
            try {
<span class="nc" id="L2373">                ((Flushable)a).flush();</span>
<span class="nc" id="L2374">            } catch (IOException ioe) {</span>
<span class="nc" id="L2375">                lastException = ioe;</span>
<span class="nc" id="L2376">            }</span>
        }
<span class="fc" id="L2378">    }</span>

    /**
     * Closes this formatter.  If the destination implements the {@link
     * java.io.Closeable} interface, its {@code close} method will be invoked.
     *
     * &lt;p&gt; Closing a formatter allows it to release resources it may be holding
     * (such as open files).  If the formatter is already closed, then invoking
     * this method has no effect.
     *
     * &lt;p&gt; Attempting to invoke any methods except {@link #ioException()} in
     * this formatter after it has been closed will result in a {@link
     * FormatterClosedException}.
     */
    public void close() {
<span class="fc bfc" id="L2393" title="All 2 branches covered.">        if (a == null)</span>
<span class="fc" id="L2394">            return;</span>
        try {
<span class="fc bfc" id="L2396" title="All 2 branches covered.">            if (a instanceof Closeable)</span>
<span class="fc" id="L2397">                ((Closeable)a).close();</span>
<span class="nc" id="L2398">        } catch (IOException ioe) {</span>
<span class="nc" id="L2399">            lastException = ioe;</span>
        } finally {
<span class="pc" id="L2401">            a = null;</span>
<span class="pc" id="L2402">        }</span>
<span class="fc" id="L2403">    }</span>

    private void ensureOpen() {
<span class="fc bfc" id="L2406" title="All 2 branches covered.">        if (a == null)</span>
<span class="fc" id="L2407">            throw new FormatterClosedException();</span>
<span class="fc" id="L2408">    }</span>

    /**
     * Returns the {@code IOException} last thrown by this formatter's {@link
     * Appendable}.
     *
     * &lt;p&gt; If the destination's {@code append()} method never throws
     * {@code IOException}, then this method will always return {@code null}.
     *
     * @return  The last exception thrown by the Appendable or {@code null} if
     *          no such exception exists.
     */
    public IOException ioException() {
<span class="nc" id="L2421">        return lastException;</span>
    }

    /**
     * Writes a formatted string to this object's destination using the
     * specified format string and arguments.  The locale used is the one
     * defined during the construction of this formatter.
     *
     * @param  format
     *         A format string as described in &lt;a href=&quot;#syntax&quot;&gt;Format string
     *         syntax&lt;/a&gt;.
     *
     * @param  args
     *         Arguments referenced by the format specifiers in the format
     *         string.  If there are more arguments than format specifiers, the
     *         extra arguments are ignored.  The maximum number of arguments is
     *         limited by the maximum dimension of a Java array as defined by
     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
     *
     * @throws  IllegalFormatException
     *          If a format string contains an illegal syntax, a format
     *          specifier that is incompatible with the given arguments,
     *          insufficient arguments given the format string, or other
     *          illegal conditions.  For specification of all possible
     *          formatting errors, see the &lt;a href=&quot;#detail&quot;&gt;Details&lt;/a&gt;
     *          section of the formatter class specification.
     *
     * @throws  FormatterClosedException
     *          If this formatter has been closed by invoking its {@link
     *          #close()} method
     *
     * @return  This formatter
     */
    public Formatter format(String format, Object ... args) {
<span class="fc" id="L2455">        return format(l, format, args);</span>
    }

    /**
     * Writes a formatted string to this object's destination using the
     * specified locale, format string, and arguments.
     *
     * @param  l
     *         The {@linkplain java.util.Locale locale} to apply during
     *         formatting.  If {@code l} is {@code null} then no localization
     *         is applied.  This does not change this object's locale that was
     *         set during construction.
     *
     * @param  format
     *         A format string as described in &lt;a href=&quot;#syntax&quot;&gt;Format string
     *         syntax&lt;/a&gt;
     *
     * @param  args
     *         Arguments referenced by the format specifiers in the format
     *         string.  If there are more arguments than format specifiers, the
     *         extra arguments are ignored.  The maximum number of arguments is
     *         limited by the maximum dimension of a Java array as defined by
     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
     *
     * @throws  IllegalFormatException
     *          If a format string contains an illegal syntax, a format
     *          specifier that is incompatible with the given arguments,
     *          insufficient arguments given the format string, or other
     *          illegal conditions.  For specification of all possible
     *          formatting errors, see the &lt;a href=&quot;#detail&quot;&gt;Details&lt;/a&gt;
     *          section of the formatter class specification.
     *
     * @throws  FormatterClosedException
     *          If this formatter has been closed by invoking its {@link
     *          #close()} method
     *
     * @return  This formatter
     */
    public Formatter format(Locale l, String format, Object ... args) {
<span class="fc" id="L2494">        ensureOpen();</span>

        // index of last argument referenced
<span class="fc" id="L2497">        int last = -1;</span>
        // last ordinary index
<span class="fc" id="L2499">        int lasto = -1;</span>

<span class="fc" id="L2501">        FormatString[] fsa = parse(format);</span>
<span class="fc bfc" id="L2502" title="All 2 branches covered.">        for (int i = 0; i &lt; fsa.length; i++) {</span>
<span class="fc" id="L2503">            FormatString fs = fsa[i];</span>
<span class="fc" id="L2504">            int index = fs.index();</span>
            try {
<span class="fc bfc" id="L2506" title="All 4 branches covered.">                switch (index) {</span>
                case -2:  // fixed string, &quot;%n&quot;, or &quot;%%&quot;
<span class="fc" id="L2508">                    fs.print(null, l);</span>
<span class="fc" id="L2509">                    break;</span>
                case -1:  // relative index
<span class="pc bpc" id="L2511" title="3 of 6 branches missed.">                    if (last &lt; 0 || (args != null &amp;&amp; last &gt; args.length - 1))</span>
<span class="nc" id="L2512">                        throw new MissingFormatArgumentException(fs.toString());</span>
<span class="pc bpc" id="L2513" title="1 of 2 branches missed.">                    fs.print((args == null ? null : args[last]), l);</span>
<span class="fc" id="L2514">                    break;</span>
                case 0:  // ordinary index
<span class="fc" id="L2516">                    lasto++;</span>
<span class="fc" id="L2517">                    last = lasto;</span>
<span class="pc bpc" id="L2518" title="1 of 4 branches missed.">                    if (args != null &amp;&amp; lasto &gt; args.length - 1)</span>
<span class="nc" id="L2519">                        throw new MissingFormatArgumentException(fs.toString());</span>
<span class="fc bfc" id="L2520" title="All 2 branches covered.">                    fs.print((args == null ? null : args[lasto]), l);</span>
<span class="fc" id="L2521">                    break;</span>
                default:  // explicit index
<span class="fc" id="L2523">                    last = index - 1;</span>
<span class="pc bpc" id="L2524" title="2 of 4 branches missed.">                    if (args != null &amp;&amp; last &gt; args.length - 1)</span>
<span class="nc" id="L2525">                        throw new MissingFormatArgumentException(fs.toString());</span>
<span class="pc bpc" id="L2526" title="1 of 2 branches missed.">                    fs.print((args == null ? null : args[last]), l);</span>
                    break;
                }
<span class="nc" id="L2529">            } catch (IOException x) {</span>
<span class="nc" id="L2530">                lastException = x;</span>
<span class="fc" id="L2531">            }</span>
        }
<span class="fc" id="L2533">        return this;</span>
    }

    // %[argument_index$][flags][width][.precision][t]conversion
    private static final String formatSpecifier
        = &quot;%(\\d+\\$)?([-#+ 0,(\\&lt;]*)?(\\d+)?(\\.\\d+)?([tT])?([a-zA-Z%])&quot;;

<span class="fc" id="L2540">    private static Pattern fsPattern = Pattern.compile(formatSpecifier);</span>

    /**
     * Finds format specifiers in the format string.
     */
    private FormatString[] parse(String s) {
<span class="fc" id="L2546">        ArrayList&lt;FormatString&gt; al = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2547">        Matcher m = fsPattern.matcher(s);</span>
<span class="fc bfc" id="L2548" title="All 2 branches covered.">        for (int i = 0, len = s.length(); i &lt; len; ) {</span>
<span class="fc bfc" id="L2549" title="All 2 branches covered.">            if (m.find(i)) {</span>
                // Anything between the start of the string and the beginning
                // of the format specifier is either fixed text or contains
                // an invalid format string.
<span class="fc bfc" id="L2553" title="All 2 branches covered.">                if (m.start() != i) {</span>
                    // Make sure we didn't miss any invalid format specifiers
<span class="fc" id="L2555">                    checkText(s, i, m.start());</span>
                    // Assume previous characters were fixed text
<span class="fc" id="L2557">                    al.add(new FixedString(s.substring(i, m.start())));</span>
                }

<span class="fc" id="L2560">                al.add(new FormatSpecifier(m));</span>
<span class="fc" id="L2561">                i = m.end();</span>
            } else {
                // No more valid format specifiers.  Check for possible invalid
                // format specifiers.
<span class="fc" id="L2565">                checkText(s, i, len);</span>
                // The rest of the string is fixed text
<span class="fc" id="L2567">                al.add(new FixedString(s.substring(i)));</span>
<span class="fc" id="L2568">                break;</span>
            }
        }
<span class="fc" id="L2571">        return al.toArray(new FormatString[al.size()]);</span>
    }

    private static void checkText(String s, int start, int end) {
<span class="fc bfc" id="L2575" title="All 2 branches covered.">        for (int i = start; i &lt; end; i++) {</span>
            // Any '%' found in the region starts an invalid format specifier.
<span class="fc bfc" id="L2577" title="All 2 branches covered.">            if (s.charAt(i) == '%') {</span>
<span class="fc bfc" id="L2578" title="All 2 branches covered.">                char c = (i == end - 1) ? '%' : s.charAt(i + 1);</span>
<span class="fc" id="L2579">                throw new UnknownFormatConversionException(String.valueOf(c));</span>
            }
        }
<span class="fc" id="L2582">    }</span>

    private interface FormatString {
        int index();
        void print(Object arg, Locale l) throws IOException;
        String toString();
    }

    private class FixedString implements FormatString {
        private String s;
<span class="fc" id="L2592">        FixedString(String s) { this.s = s; }</span>
<span class="fc" id="L2593">        public int index() { return -2; }</span>
        public void print(Object arg, Locale l)
<span class="fc" id="L2595">            throws IOException { a.append(s); }</span>
<span class="nc" id="L2596">        public String toString() { return s; }</span>
    }

    /**
     * Enum for {@code BigDecimal} formatting.
     */
<span class="pc" id="L2602">    public enum BigDecimalLayoutForm {</span>
        /**
         * Format the {@code BigDecimal} in computerized scientific notation.
         */
<span class="fc" id="L2606">        SCIENTIFIC,</span>

        /**
         * Format the {@code BigDecimal} as a decimal number.
         */
<span class="fc" id="L2611">        DECIMAL_FLOAT</span>
    };

<span class="fc bfc" id="L2614" title="All 2 branches covered.">    private class FormatSpecifier implements FormatString {</span>
<span class="fc" id="L2615">        private int index = -1;</span>
<span class="fc" id="L2616">        private Flags f = Flags.NONE;</span>
        private int width;
        private int precision;
<span class="fc" id="L2619">        private boolean dt = false;</span>
        private char c;

        private int index(String s) {
<span class="fc bfc" id="L2623" title="All 2 branches covered.">            if (s != null) {</span>
                try {
<span class="fc" id="L2625">                    index = Integer.parseInt(s.substring(0, s.length() - 1));</span>
<span class="nc" id="L2626">                } catch (NumberFormatException x) {</span>
<span class="nc bnc" id="L2627" title="All 2 branches missed.">                    assert(false);</span>
<span class="pc" id="L2628">                }</span>
            } else {
<span class="fc" id="L2630">                index = 0;</span>
            }
<span class="fc" id="L2632">            return index;</span>
        }

        public int index() {
<span class="fc" id="L2636">            return index;</span>
        }

        private Flags flags(String s) {
<span class="fc" id="L2640">            f = Flags.parse(s);</span>
<span class="fc bfc" id="L2641" title="All 2 branches covered.">            if (f.contains(Flags.PREVIOUS))</span>
<span class="fc" id="L2642">                index = -1;</span>
<span class="fc" id="L2643">            return f;</span>
        }

        Flags flags() {
<span class="nc" id="L2647">            return f;</span>
        }

        private int width(String s) {
<span class="fc" id="L2651">            width = -1;</span>
<span class="fc bfc" id="L2652" title="All 2 branches covered.">            if (s != null) {</span>
                try {
<span class="fc" id="L2654">                    width  = Integer.parseInt(s);</span>
<span class="pc bpc" id="L2655" title="1 of 2 branches missed.">                    if (width &lt; 0)</span>
<span class="nc" id="L2656">                        throw new IllegalFormatWidthException(width);</span>
<span class="nc" id="L2657">                } catch (NumberFormatException x) {</span>
<span class="nc bnc" id="L2658" title="All 2 branches missed.">                    assert(false);</span>
<span class="fc" id="L2659">                }</span>
            }
<span class="fc" id="L2661">            return width;</span>
        }

        int width() {
<span class="nc" id="L2665">            return width;</span>
        }

        private int precision(String s) {
<span class="fc" id="L2669">            precision = -1;</span>
<span class="fc bfc" id="L2670" title="All 2 branches covered.">            if (s != null) {</span>
                try {
                    // remove the '.'
<span class="fc" id="L2673">                    precision = Integer.parseInt(s.substring(1));</span>
<span class="pc bpc" id="L2674" title="1 of 2 branches missed.">                    if (precision &lt; 0)</span>
<span class="nc" id="L2675">                        throw new IllegalFormatPrecisionException(precision);</span>
<span class="nc" id="L2676">                } catch (NumberFormatException x) {</span>
<span class="nc bnc" id="L2677" title="All 2 branches missed.">                    assert(false);</span>
<span class="fc" id="L2678">                }</span>
            }
<span class="fc" id="L2680">            return precision;</span>
        }

        int precision() {
<span class="nc" id="L2684">            return precision;</span>
        }

        private char conversion(String s) {
<span class="fc" id="L2688">            c = s.charAt(0);</span>
<span class="fc bfc" id="L2689" title="All 2 branches covered.">            if (!dt) {</span>
<span class="fc bfc" id="L2690" title="All 2 branches covered.">                if (!Conversion.isValid(c))</span>
<span class="fc" id="L2691">                    throw new UnknownFormatConversionException(String.valueOf(c));</span>
<span class="fc bfc" id="L2692" title="All 2 branches covered.">                if (Character.isUpperCase(c))</span>
<span class="fc" id="L2693">                    f.add(Flags.UPPERCASE);</span>
<span class="fc" id="L2694">                c = Character.toLowerCase(c);</span>
<span class="fc bfc" id="L2695" title="All 2 branches covered.">                if (Conversion.isText(c))</span>
<span class="fc" id="L2696">                    index = -2;</span>
            }
<span class="fc" id="L2698">            return c;</span>
        }

        private char conversion() {
<span class="nc" id="L2702">            return c;</span>
        }

<span class="fc" id="L2705">        FormatSpecifier(Matcher m) {</span>
<span class="fc" id="L2706">            int idx = 1;</span>

<span class="fc" id="L2708">            index(m.group(idx++));</span>
<span class="fc" id="L2709">            flags(m.group(idx++));</span>
<span class="fc" id="L2710">            width(m.group(idx++));</span>
<span class="fc" id="L2711">            precision(m.group(idx++));</span>

<span class="fc" id="L2713">            String tT = m.group(idx++);</span>
<span class="fc bfc" id="L2714" title="All 2 branches covered.">            if (tT != null) {</span>
<span class="fc" id="L2715">                dt = true;</span>
<span class="fc bfc" id="L2716" title="All 2 branches covered.">                if (tT.equals(&quot;T&quot;))</span>
<span class="fc" id="L2717">                    f.add(Flags.UPPERCASE);</span>
            }

<span class="fc" id="L2720">            conversion(m.group(idx));</span>

<span class="fc bfc" id="L2722" title="All 2 branches covered.">            if (dt)</span>
<span class="fc" id="L2723">                checkDateTime();</span>
<span class="fc bfc" id="L2724" title="All 2 branches covered.">            else if (Conversion.isGeneral(c))</span>
<span class="fc" id="L2725">                checkGeneral();</span>
<span class="fc bfc" id="L2726" title="All 2 branches covered.">            else if (Conversion.isCharacter(c))</span>
<span class="fc" id="L2727">                checkCharacter();</span>
<span class="fc bfc" id="L2728" title="All 2 branches covered.">            else if (Conversion.isInteger(c))</span>
<span class="fc" id="L2729">                checkInteger();</span>
<span class="fc bfc" id="L2730" title="All 2 branches covered.">            else if (Conversion.isFloat(c))</span>
<span class="fc" id="L2731">                checkFloat();</span>
<span class="fc bfc" id="L2732" title="All 2 branches covered.">            else if (Conversion.isText(c))</span>
<span class="fc" id="L2733">                checkText();</span>
            else
<span class="fc" id="L2735">                throw new UnknownFormatConversionException(String.valueOf(c));</span>
<span class="fc" id="L2736">        }</span>

        public void print(Object arg, Locale l) throws IOException {
<span class="fc bfc" id="L2739" title="All 2 branches covered.">            if (dt) {</span>
<span class="fc" id="L2740">                printDateTime(arg, l);</span>
<span class="fc" id="L2741">                return;</span>
            }
<span class="pc bpc" id="L2743" title="1 of 9 branches missed.">            switch(c) {</span>
            case Conversion.DECIMAL_INTEGER:
            case Conversion.OCTAL_INTEGER:
            case Conversion.HEXADECIMAL_INTEGER:
<span class="fc" id="L2747">                printInteger(arg, l);</span>
<span class="fc" id="L2748">                break;</span>
            case Conversion.SCIENTIFIC:
            case Conversion.GENERAL:
            case Conversion.DECIMAL_FLOAT:
            case Conversion.HEXADECIMAL_FLOAT:
<span class="fc" id="L2753">                printFloat(arg, l);</span>
<span class="fc" id="L2754">                break;</span>
            case Conversion.CHARACTER:
            case Conversion.CHARACTER_UPPER:
<span class="fc" id="L2757">                printCharacter(arg);</span>
<span class="fc" id="L2758">                break;</span>
            case Conversion.BOOLEAN:
<span class="fc" id="L2760">                printBoolean(arg);</span>
<span class="fc" id="L2761">                break;</span>
            case Conversion.STRING:
<span class="fc" id="L2763">                printString(arg, l);</span>
<span class="fc" id="L2764">                break;</span>
            case Conversion.HASHCODE:
<span class="fc" id="L2766">                printHashCode(arg);</span>
<span class="fc" id="L2767">                break;</span>
            case Conversion.LINE_SEPARATOR:
<span class="fc" id="L2769">                a.append(System.lineSeparator());</span>
<span class="fc" id="L2770">                break;</span>
            case Conversion.PERCENT_SIGN:
<span class="fc" id="L2772">                a.append('%');</span>
<span class="fc" id="L2773">                break;</span>
            default:
<span class="nc bnc" id="L2775" title="All 2 branches missed.">                assert false;</span>
            }
<span class="fc" id="L2777">        }</span>

        private void printInteger(Object arg, Locale l) throws IOException {
<span class="fc bfc" id="L2780" title="All 2 branches covered.">            if (arg == null)</span>
<span class="fc" id="L2781">                print(&quot;null&quot;);</span>
<span class="fc bfc" id="L2782" title="All 2 branches covered.">            else if (arg instanceof Byte)</span>
<span class="fc" id="L2783">                print(((Byte)arg).byteValue(), l);</span>
<span class="fc bfc" id="L2784" title="All 2 branches covered.">            else if (arg instanceof Short)</span>
<span class="fc" id="L2785">                print(((Short)arg).shortValue(), l);</span>
<span class="fc bfc" id="L2786" title="All 2 branches covered.">            else if (arg instanceof Integer)</span>
<span class="fc" id="L2787">                print(((Integer)arg).intValue(), l);</span>
<span class="fc bfc" id="L2788" title="All 2 branches covered.">            else if (arg instanceof Long)</span>
<span class="fc" id="L2789">                print(((Long)arg).longValue(), l);</span>
<span class="pc bpc" id="L2790" title="1 of 2 branches missed.">            else if (arg instanceof BigInteger)</span>
<span class="fc" id="L2791">                print(((BigInteger)arg), l);</span>
            else
<span class="nc" id="L2793">                failConversion(c, arg);</span>
<span class="fc" id="L2794">        }</span>

        private void printFloat(Object arg, Locale l) throws IOException {
<span class="fc bfc" id="L2797" title="All 2 branches covered.">            if (arg == null)</span>
<span class="fc" id="L2798">                print(&quot;null&quot;);</span>
<span class="fc bfc" id="L2799" title="All 2 branches covered.">            else if (arg instanceof Float)</span>
<span class="fc" id="L2800">                print(((Float)arg).floatValue(), l);</span>
<span class="fc bfc" id="L2801" title="All 2 branches covered.">            else if (arg instanceof Double)</span>
<span class="fc" id="L2802">                print(((Double)arg).doubleValue(), l);</span>
<span class="pc bpc" id="L2803" title="1 of 2 branches missed.">            else if (arg instanceof BigDecimal)</span>
<span class="fc" id="L2804">                print(((BigDecimal)arg), l);</span>
            else
<span class="nc" id="L2806">                failConversion(c, arg);</span>
<span class="fc" id="L2807">        }</span>

        private void printDateTime(Object arg, Locale l) throws IOException {
<span class="fc bfc" id="L2810" title="All 2 branches covered.">            if (arg == null) {</span>
<span class="fc" id="L2811">                print(&quot;null&quot;);</span>
<span class="fc" id="L2812">                return;</span>
            }
<span class="fc" id="L2814">            Calendar cal = null;</span>

            // Instead of Calendar.setLenient(true), perhaps we should
            // wrap the IllegalArgumentException that might be thrown?
<span class="fc bfc" id="L2818" title="All 2 branches covered.">            if (arg instanceof Long) {</span>
                // Note that the following method uses an instance of the
                // default time zone (TimeZone.getDefaultRef().
<span class="fc bfc" id="L2821" title="All 2 branches covered.">                cal = Calendar.getInstance(l == null ? Locale.US : l);</span>
<span class="fc" id="L2822">                cal.setTimeInMillis((Long)arg);</span>
<span class="fc bfc" id="L2823" title="All 2 branches covered.">            } else if (arg instanceof Date) {</span>
                // Note that the following method uses an instance of the
                // default time zone (TimeZone.getDefaultRef().
<span class="fc bfc" id="L2826" title="All 2 branches covered.">                cal = Calendar.getInstance(l == null ? Locale.US : l);</span>
<span class="fc" id="L2827">                cal.setTime((Date)arg);</span>
<span class="pc bpc" id="L2828" title="1 of 2 branches missed.">            } else if (arg instanceof Calendar) {</span>
<span class="fc" id="L2829">                cal = (Calendar) ((Calendar) arg).clone();</span>
<span class="fc" id="L2830">                cal.setLenient(true);</span>
<span class="nc bnc" id="L2831" title="All 2 branches missed.">            } else if (arg instanceof TemporalAccessor) {</span>
<span class="nc" id="L2832">                print((TemporalAccessor) arg, c, l);</span>
<span class="nc" id="L2833">                return;</span>
            } else {
<span class="nc" id="L2835">                failConversion(c, arg);</span>
            }
            // Use the provided locale so that invocations of
            // localizedMagnitude() use optimizations for null.
<span class="fc" id="L2839">            print(cal, c, l);</span>
<span class="fc" id="L2840">        }</span>

        private void printCharacter(Object arg) throws IOException {
<span class="fc bfc" id="L2843" title="All 2 branches covered.">            if (arg == null) {</span>
<span class="fc" id="L2844">                print(&quot;null&quot;);</span>
<span class="fc" id="L2845">                return;</span>
            }
<span class="fc" id="L2847">            String s = null;</span>
<span class="fc bfc" id="L2848" title="All 2 branches covered.">            if (arg instanceof Character) {</span>
<span class="fc" id="L2849">                s = ((Character)arg).toString();</span>
<span class="fc bfc" id="L2850" title="All 2 branches covered.">            } else if (arg instanceof Byte) {</span>
<span class="fc" id="L2851">                byte i = ((Byte)arg).byteValue();</span>
<span class="fc bfc" id="L2852" title="All 2 branches covered.">                if (Character.isValidCodePoint(i))</span>
<span class="fc" id="L2853">                    s = new String(Character.toChars(i));</span>
                else
<span class="fc" id="L2855">                    throw new IllegalFormatCodePointException(i);</span>
<span class="fc bfc" id="L2856" title="All 2 branches covered.">            } else if (arg instanceof Short) {</span>
<span class="fc" id="L2857">                short i = ((Short)arg).shortValue();</span>
<span class="fc bfc" id="L2858" title="All 2 branches covered.">                if (Character.isValidCodePoint(i))</span>
<span class="fc" id="L2859">                    s = new String(Character.toChars(i));</span>
                else
<span class="fc" id="L2861">                    throw new IllegalFormatCodePointException(i);</span>
<span class="pc bpc" id="L2862" title="1 of 2 branches missed.">            } else if (arg instanceof Integer) {</span>
<span class="fc" id="L2863">                int i = ((Integer)arg).intValue();</span>
<span class="fc bfc" id="L2864" title="All 2 branches covered.">                if (Character.isValidCodePoint(i))</span>
<span class="fc" id="L2865">                    s = new String(Character.toChars(i));</span>
                else
<span class="fc" id="L2867">                    throw new IllegalFormatCodePointException(i);</span>
<span class="fc" id="L2868">            } else {</span>
<span class="nc" id="L2869">                failConversion(c, arg);</span>
            }
<span class="fc" id="L2871">            print(s);</span>
<span class="fc" id="L2872">        }</span>

        private void printString(Object arg, Locale l) throws IOException {
<span class="fc bfc" id="L2875" title="All 2 branches covered.">            if (arg instanceof Formattable) {</span>
<span class="fc" id="L2876">                Formatter fmt = Formatter.this;</span>
<span class="fc bfc" id="L2877" title="All 2 branches covered.">                if (fmt.locale() != l)</span>
<span class="fc" id="L2878">                    fmt = new Formatter(fmt.out(), l);</span>
<span class="fc" id="L2879">                ((Formattable)arg).formatTo(fmt, f.valueOf(), width, precision);</span>
<span class="fc" id="L2880">            } else {</span>
<span class="pc bpc" id="L2881" title="1 of 2 branches missed.">                if (f.contains(Flags.ALTERNATE))</span>
<span class="nc" id="L2882">                    failMismatch(Flags.ALTERNATE, 's');</span>
<span class="fc bfc" id="L2883" title="All 2 branches covered.">                if (arg == null)</span>
<span class="fc" id="L2884">                    print(&quot;null&quot;);</span>
                else
<span class="fc" id="L2886">                    print(arg.toString());</span>
            }
<span class="fc" id="L2888">        }</span>

        private void printBoolean(Object arg) throws IOException {
            String s;
<span class="fc bfc" id="L2892" title="All 2 branches covered.">            if (arg != null)</span>
<span class="fc bfc" id="L2893" title="All 2 branches covered.">                s = ((arg instanceof Boolean)</span>
<span class="fc" id="L2894">                     ? ((Boolean)arg).toString()</span>
<span class="fc" id="L2895">                     : Boolean.toString(true));</span>
            else
<span class="fc" id="L2897">                s = Boolean.toString(false);</span>
<span class="fc" id="L2898">            print(s);</span>
<span class="fc" id="L2899">        }</span>

        private void printHashCode(Object arg) throws IOException {
<span class="pc bpc" id="L2902" title="1 of 2 branches missed.">            String s = (arg == null</span>
                        ? &quot;null&quot;
<span class="fc" id="L2904">                        : Integer.toHexString(arg.hashCode()));</span>
<span class="fc" id="L2905">            print(s);</span>
<span class="fc" id="L2906">        }</span>

        private void print(String s) throws IOException {
<span class="pc bpc" id="L2909" title="1 of 4 branches missed.">            if (precision != -1 &amp;&amp; precision &lt; s.length())</span>
<span class="fc" id="L2910">                s = s.substring(0, precision);</span>
<span class="fc bfc" id="L2911" title="All 2 branches covered.">            if (f.contains(Flags.UPPERCASE))</span>
<span class="fc" id="L2912">                s = s.toUpperCase();</span>
<span class="fc" id="L2913">            a.append(justify(s));</span>
<span class="fc" id="L2914">        }</span>

        private String justify(String s) {
<span class="fc bfc" id="L2917" title="All 2 branches covered.">            if (width == -1)</span>
<span class="fc" id="L2918">                return s;</span>
<span class="fc" id="L2919">            StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L2920">            boolean pad = f.contains(Flags.LEFT_JUSTIFY);</span>
<span class="fc" id="L2921">            int sp = width - s.length();</span>
<span class="fc bfc" id="L2922" title="All 2 branches covered.">            if (!pad)</span>
<span class="fc bfc" id="L2923" title="All 2 branches covered.">                for (int i = 0; i &lt; sp; i++) sb.append(' ');</span>
<span class="fc" id="L2924">            sb.append(s);</span>
<span class="fc bfc" id="L2925" title="All 2 branches covered.">            if (pad)</span>
<span class="fc bfc" id="L2926" title="All 2 branches covered.">                for (int i = 0; i &lt; sp; i++) sb.append(' ');</span>
<span class="fc" id="L2927">            return sb.toString();</span>
        }

        public String toString() {
<span class="fc" id="L2931">            StringBuilder sb = new StringBuilder(&quot;%&quot;);</span>
            // Flags.UPPERCASE is set internally for legal conversions.
<span class="fc" id="L2933">            Flags dupf = f.dup().remove(Flags.UPPERCASE);</span>
<span class="fc" id="L2934">            sb.append(dupf.toString());</span>
<span class="pc bpc" id="L2935" title="1 of 2 branches missed.">            if (index &gt; 0)</span>
<span class="nc" id="L2936">                sb.append(index).append('$');</span>
<span class="pc bpc" id="L2937" title="1 of 2 branches missed.">            if (width != -1)</span>
<span class="nc" id="L2938">                sb.append(width);</span>
<span class="pc bpc" id="L2939" title="1 of 2 branches missed.">            if (precision != -1)</span>
<span class="nc" id="L2940">                sb.append('.').append(precision);</span>
<span class="fc bfc" id="L2941" title="All 2 branches covered.">            if (dt)</span>
<span class="pc bpc" id="L2942" title="1 of 2 branches missed.">                sb.append(f.contains(Flags.UPPERCASE) ? 'T' : 't');</span>
<span class="pc bpc" id="L2943" title="1 of 2 branches missed.">            sb.append(f.contains(Flags.UPPERCASE)</span>
<span class="pc" id="L2944">                      ? Character.toUpperCase(c) : c);</span>
<span class="fc" id="L2945">            return sb.toString();</span>
        }

        private void checkGeneral() {
<span class="fc bfc" id="L2949" title="All 4 branches covered.">            if ((c == Conversion.BOOLEAN || c == Conversion.HASHCODE)</span>
<span class="pc bpc" id="L2950" title="1 of 2 branches missed.">                &amp;&amp; f.contains(Flags.ALTERNATE))</span>
<span class="nc" id="L2951">                failMismatch(Flags.ALTERNATE, c);</span>
            // '-' requires a width
<span class="fc bfc" id="L2953" title="All 4 branches covered.">            if (width == -1 &amp;&amp; f.contains(Flags.LEFT_JUSTIFY))</span>
<span class="fc" id="L2954">                throw new MissingFormatWidthException(toString());</span>
<span class="fc" id="L2955">            checkBadFlags(Flags.PLUS, Flags.LEADING_SPACE, Flags.ZERO_PAD,</span>
                          Flags.GROUP, Flags.PARENTHESES);
<span class="fc" id="L2957">        }</span>

        private void checkDateTime() {
<span class="fc bfc" id="L2960" title="All 2 branches covered.">            if (precision != -1)</span>
<span class="fc" id="L2961">                throw new IllegalFormatPrecisionException(precision);</span>
<span class="fc bfc" id="L2962" title="All 2 branches covered.">            if (!DateTime.isValid(c))</span>
<span class="fc" id="L2963">                throw new UnknownFormatConversionException(&quot;t&quot; + c);</span>
<span class="fc" id="L2964">            checkBadFlags(Flags.ALTERNATE, Flags.PLUS, Flags.LEADING_SPACE,</span>
                          Flags.ZERO_PAD, Flags.GROUP, Flags.PARENTHESES);
            // '-' requires a width
<span class="fc bfc" id="L2967" title="All 4 branches covered.">            if (width == -1 &amp;&amp; f.contains(Flags.LEFT_JUSTIFY))</span>
<span class="fc" id="L2968">                throw new MissingFormatWidthException(toString());</span>
<span class="fc" id="L2969">        }</span>

        private void checkCharacter() {
<span class="fc bfc" id="L2972" title="All 2 branches covered.">            if (precision != -1)</span>
<span class="fc" id="L2973">                throw new IllegalFormatPrecisionException(precision);</span>
<span class="fc" id="L2974">            checkBadFlags(Flags.ALTERNATE, Flags.PLUS, Flags.LEADING_SPACE,</span>
                          Flags.ZERO_PAD, Flags.GROUP, Flags.PARENTHESES);
            // '-' requires a width
<span class="pc bpc" id="L2977" title="1 of 4 branches missed.">            if (width == -1 &amp;&amp; f.contains(Flags.LEFT_JUSTIFY))</span>
<span class="nc" id="L2978">                throw new MissingFormatWidthException(toString());</span>
<span class="fc" id="L2979">        }</span>

        private void checkInteger() {
<span class="fc" id="L2982">            checkNumeric();</span>
<span class="fc bfc" id="L2983" title="All 2 branches covered.">            if (precision != -1)</span>
<span class="fc" id="L2984">                throw new IllegalFormatPrecisionException(precision);</span>

<span class="fc bfc" id="L2986" title="All 2 branches covered.">            if (c == Conversion.DECIMAL_INTEGER)</span>
<span class="fc" id="L2987">                checkBadFlags(Flags.ALTERNATE);</span>
<span class="fc bfc" id="L2988" title="All 2 branches covered.">            else if (c == Conversion.OCTAL_INTEGER)</span>
<span class="fc" id="L2989">                checkBadFlags(Flags.GROUP);</span>
            else
<span class="fc" id="L2991">                checkBadFlags(Flags.GROUP);</span>
<span class="fc" id="L2992">        }</span>

        private void checkBadFlags(Flags ... badFlags) {
<span class="fc bfc" id="L2995" title="All 2 branches covered.">            for (int i = 0; i &lt; badFlags.length; i++)</span>
<span class="pc bpc" id="L2996" title="1 of 2 branches missed.">                if (f.contains(badFlags[i]))</span>
<span class="nc" id="L2997">                    failMismatch(badFlags[i], c);</span>
<span class="fc" id="L2998">        }</span>

        private void checkFloat() {
<span class="fc" id="L3001">            checkNumeric();</span>
<span class="fc bfc" id="L3002" title="All 2 branches covered.">            if (c == Conversion.DECIMAL_FLOAT) {</span>
<span class="fc bfc" id="L3003" title="All 2 branches covered.">            } else if (c == Conversion.HEXADECIMAL_FLOAT) {</span>
<span class="fc" id="L3004">                checkBadFlags(Flags.PARENTHESES, Flags.GROUP);</span>
<span class="fc bfc" id="L3005" title="All 2 branches covered.">            } else if (c == Conversion.SCIENTIFIC) {</span>
<span class="fc" id="L3006">                checkBadFlags(Flags.GROUP);</span>
<span class="pc bpc" id="L3007" title="1 of 2 branches missed.">            } else if (c == Conversion.GENERAL) {</span>
<span class="fc" id="L3008">                checkBadFlags(Flags.ALTERNATE);</span>
            }
<span class="fc" id="L3010">        }</span>

        private void checkNumeric() {
<span class="pc bpc" id="L3013" title="1 of 4 branches missed.">            if (width != -1 &amp;&amp; width &lt; 0)</span>
<span class="nc" id="L3014">                throw new IllegalFormatWidthException(width);</span>

<span class="pc bpc" id="L3016" title="1 of 4 branches missed.">            if (precision != -1 &amp;&amp; precision &lt; 0)</span>
<span class="nc" id="L3017">                throw new IllegalFormatPrecisionException(precision);</span>

            // '-' and '0' require a width
<span class="fc bfc" id="L3020" title="All 2 branches covered.">            if (width == -1</span>
<span class="fc bfc" id="L3021" title="All 4 branches covered.">                &amp;&amp; (f.contains(Flags.LEFT_JUSTIFY) || f.contains(Flags.ZERO_PAD)))</span>
<span class="fc" id="L3022">                throw new MissingFormatWidthException(toString());</span>

            // bad combination
<span class="pc bpc" id="L3025" title="1 of 4 branches missed.">            if ((f.contains(Flags.PLUS) &amp;&amp; f.contains(Flags.LEADING_SPACE))</span>
<span class="pc bpc" id="L3026" title="1 of 4 branches missed.">                || (f.contains(Flags.LEFT_JUSTIFY) &amp;&amp; f.contains(Flags.ZERO_PAD)))</span>
<span class="nc" id="L3027">                throw new IllegalFormatFlagsException(f.toString());</span>
<span class="fc" id="L3028">        }</span>

        private void checkText() {
<span class="fc bfc" id="L3031" title="All 2 branches covered.">            if (precision != -1)</span>
<span class="fc" id="L3032">                throw new IllegalFormatPrecisionException(precision);</span>
<span class="pc bpc" id="L3033" title="1 of 3 branches missed.">            switch (c) {</span>
            case Conversion.PERCENT_SIGN:
<span class="pc bpc" id="L3035" title="1 of 2 branches missed.">                if (f.valueOf() != Flags.LEFT_JUSTIFY.valueOf()</span>
<span class="fc bfc" id="L3036" title="All 2 branches covered.">                    &amp;&amp; f.valueOf() != Flags.NONE.valueOf())</span>
<span class="fc" id="L3037">                    throw new IllegalFormatFlagsException(f.toString());</span>
                // '-' requires a width
<span class="pc bpc" id="L3039" title="2 of 4 branches missed.">                if (width == -1 &amp;&amp; f.contains(Flags.LEFT_JUSTIFY))</span>
<span class="nc" id="L3040">                    throw new MissingFormatWidthException(toString());</span>
                break;
            case Conversion.LINE_SEPARATOR:
<span class="fc bfc" id="L3043" title="All 2 branches covered.">                if (width != -1)</span>
<span class="fc" id="L3044">                    throw new IllegalFormatWidthException(width);</span>
<span class="fc bfc" id="L3045" title="All 2 branches covered.">                if (f.valueOf() != Flags.NONE.valueOf())</span>
<span class="fc" id="L3046">                    throw new IllegalFormatFlagsException(f.toString());</span>
                break;
            default:
<span class="nc bnc" id="L3049" title="All 2 branches missed.">                assert false;</span>
            }
<span class="fc" id="L3051">        }</span>

        private void print(byte value, Locale l) throws IOException {
<span class="fc" id="L3054">            long v = value;</span>
<span class="fc bfc" id="L3055" title="All 6 branches covered.">            if (value &lt; 0</span>
                &amp;&amp; (c == Conversion.OCTAL_INTEGER
                    || c == Conversion.HEXADECIMAL_INTEGER)) {
<span class="fc" id="L3058">                v += (1L &lt;&lt; 8);</span>
<span class="pc bpc" id="L3059" title="2 of 4 branches missed.">                assert v &gt;= 0 : v;</span>
            }
<span class="fc" id="L3061">            print(v, l);</span>
<span class="fc" id="L3062">        }</span>

        private void print(short value, Locale l) throws IOException {
<span class="fc" id="L3065">            long v = value;</span>
<span class="fc bfc" id="L3066" title="All 6 branches covered.">            if (value &lt; 0</span>
                &amp;&amp; (c == Conversion.OCTAL_INTEGER
                    || c == Conversion.HEXADECIMAL_INTEGER)) {
<span class="fc" id="L3069">                v += (1L &lt;&lt; 16);</span>
<span class="pc bpc" id="L3070" title="2 of 4 branches missed.">                assert v &gt;= 0 : v;</span>
            }
<span class="fc" id="L3072">            print(v, l);</span>
<span class="fc" id="L3073">        }</span>

        private void print(int value, Locale l) throws IOException {
<span class="fc" id="L3076">            long v = value;</span>
<span class="fc bfc" id="L3077" title="All 6 branches covered.">            if (value &lt; 0</span>
                &amp;&amp; (c == Conversion.OCTAL_INTEGER
                    || c == Conversion.HEXADECIMAL_INTEGER)) {
<span class="fc" id="L3080">                v += (1L &lt;&lt; 32);</span>
<span class="pc bpc" id="L3081" title="2 of 4 branches missed.">                assert v &gt;= 0 : v;</span>
            }
<span class="fc" id="L3083">            print(v, l);</span>
<span class="fc" id="L3084">        }</span>

        private void print(long value, Locale l) throws IOException {

<span class="fc" id="L3088">            StringBuilder sb = new StringBuilder();</span>

<span class="fc bfc" id="L3090" title="All 2 branches covered.">            if (c == Conversion.DECIMAL_INTEGER) {</span>
<span class="fc bfc" id="L3091" title="All 2 branches covered.">                boolean neg = value &lt; 0;</span>
                char[] va;
<span class="fc bfc" id="L3093" title="All 2 branches covered.">                if (value &lt; 0)</span>
<span class="fc" id="L3094">                    va = Long.toString(value, 10).substring(1).toCharArray();</span>
                else
<span class="fc" id="L3096">                    va = Long.toString(value, 10).toCharArray();</span>

                // leading sign indicator
<span class="fc" id="L3099">                leadingSign(sb, neg);</span>

                // the value
<span class="fc" id="L3102">                localizedMagnitude(sb, va, f, adjustWidth(width, f, neg), l);</span>

                // trailing sign indicator
<span class="fc" id="L3105">                trailingSign(sb, neg);</span>
<span class="fc bfc" id="L3106" title="All 2 branches covered.">            } else if (c == Conversion.OCTAL_INTEGER) {</span>
<span class="fc" id="L3107">                checkBadFlags(Flags.PARENTHESES, Flags.LEADING_SPACE,</span>
                              Flags.PLUS);
<span class="fc" id="L3109">                String s = Long.toOctalString(value);</span>
<span class="fc bfc" id="L3110" title="All 2 branches covered.">                int len = (f.contains(Flags.ALTERNATE)</span>
<span class="fc" id="L3111">                           ? s.length() + 1</span>
<span class="fc" id="L3112">                           : s.length());</span>

                // apply ALTERNATE (radix indicator for octal) before ZERO_PAD
<span class="fc bfc" id="L3115" title="All 2 branches covered.">                if (f.contains(Flags.ALTERNATE))</span>
<span class="fc" id="L3116">                    sb.append('0');</span>
<span class="fc bfc" id="L3117" title="All 2 branches covered.">                if (f.contains(Flags.ZERO_PAD))</span>
<span class="fc bfc" id="L3118" title="All 2 branches covered.">                    for (int i = 0; i &lt; width - len; i++) sb.append('0');</span>
<span class="fc" id="L3119">                sb.append(s);</span>
<span class="pc bpc" id="L3120" title="1 of 2 branches missed.">            } else if (c == Conversion.HEXADECIMAL_INTEGER) {</span>
<span class="fc" id="L3121">                checkBadFlags(Flags.PARENTHESES, Flags.LEADING_SPACE,</span>
                              Flags.PLUS);
<span class="fc" id="L3123">                String s = Long.toHexString(value);</span>
<span class="fc bfc" id="L3124" title="All 2 branches covered.">                int len = (f.contains(Flags.ALTERNATE)</span>
<span class="fc" id="L3125">                           ? s.length() + 2</span>
<span class="fc" id="L3126">                           : s.length());</span>

                // apply ALTERNATE (radix indicator for hex) before ZERO_PAD
<span class="fc bfc" id="L3129" title="All 2 branches covered.">                if (f.contains(Flags.ALTERNATE))</span>
<span class="fc bfc" id="L3130" title="All 2 branches covered.">                    sb.append(f.contains(Flags.UPPERCASE) ? &quot;0X&quot; : &quot;0x&quot;);</span>
<span class="fc bfc" id="L3131" title="All 2 branches covered.">                if (f.contains(Flags.ZERO_PAD))</span>
<span class="fc bfc" id="L3132" title="All 2 branches covered.">                    for (int i = 0; i &lt; width - len; i++) sb.append('0');</span>
<span class="fc bfc" id="L3133" title="All 2 branches covered.">                if (f.contains(Flags.UPPERCASE))</span>
<span class="fc" id="L3134">                    s = s.toUpperCase();</span>
<span class="fc" id="L3135">                sb.append(s);</span>
            }

            // justify based on width
<span class="fc" id="L3139">            a.append(justify(sb.toString()));</span>
<span class="fc" id="L3140">        }</span>

        // neg := val &lt; 0
        private StringBuilder leadingSign(StringBuilder sb, boolean neg) {
<span class="fc bfc" id="L3144" title="All 2 branches covered.">            if (!neg) {</span>
<span class="fc bfc" id="L3145" title="All 2 branches covered.">                if (f.contains(Flags.PLUS)) {</span>
<span class="fc" id="L3146">                    sb.append('+');</span>
<span class="fc bfc" id="L3147" title="All 2 branches covered.">                } else if (f.contains(Flags.LEADING_SPACE)) {</span>
<span class="fc" id="L3148">                    sb.append(' ');</span>
                }
            } else {
<span class="fc bfc" id="L3151" title="All 2 branches covered.">                if (f.contains(Flags.PARENTHESES))</span>
<span class="fc" id="L3152">                    sb.append('(');</span>
                else
<span class="fc" id="L3154">                    sb.append('-');</span>
            }
<span class="fc" id="L3156">            return sb;</span>
        }

        // neg := val &lt; 0
        private StringBuilder trailingSign(StringBuilder sb, boolean neg) {
<span class="fc bfc" id="L3161" title="All 4 branches covered.">            if (neg &amp;&amp; f.contains(Flags.PARENTHESES))</span>
<span class="fc" id="L3162">                sb.append(')');</span>
<span class="fc" id="L3163">            return sb;</span>
        }

        private void print(BigInteger value, Locale l) throws IOException {
<span class="fc" id="L3167">            StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L3168" title="All 2 branches covered.">            boolean neg = value.signum() == -1;</span>
<span class="fc" id="L3169">            BigInteger v = value.abs();</span>

            // leading sign indicator
<span class="fc" id="L3172">            leadingSign(sb, neg);</span>

            // the value
<span class="fc bfc" id="L3175" title="All 2 branches covered.">            if (c == Conversion.DECIMAL_INTEGER) {</span>
<span class="fc" id="L3176">                char[] va = v.toString().toCharArray();</span>
<span class="fc" id="L3177">                localizedMagnitude(sb, va, f, adjustWidth(width, f, neg), l);</span>
<span class="fc bfc" id="L3178" title="All 2 branches covered.">            } else if (c == Conversion.OCTAL_INTEGER) {</span>
<span class="fc" id="L3179">                String s = v.toString(8);</span>

<span class="fc" id="L3181">                int len = s.length() + sb.length();</span>
<span class="fc bfc" id="L3182" title="All 4 branches covered.">                if (neg &amp;&amp; f.contains(Flags.PARENTHESES))</span>
<span class="fc" id="L3183">                    len++;</span>

                // apply ALTERNATE (radix indicator for octal) before ZERO_PAD
<span class="fc bfc" id="L3186" title="All 2 branches covered.">                if (f.contains(Flags.ALTERNATE)) {</span>
<span class="fc" id="L3187">                    len++;</span>
<span class="fc" id="L3188">                    sb.append('0');</span>
                }
<span class="fc bfc" id="L3190" title="All 2 branches covered.">                if (f.contains(Flags.ZERO_PAD)) {</span>
<span class="fc bfc" id="L3191" title="All 2 branches covered.">                    for (int i = 0; i &lt; width - len; i++)</span>
<span class="fc" id="L3192">                        sb.append('0');</span>
                }
<span class="fc" id="L3194">                sb.append(s);</span>
<span class="pc bpc" id="L3195" title="1 of 2 branches missed.">            } else if (c == Conversion.HEXADECIMAL_INTEGER) {</span>
<span class="fc" id="L3196">                String s = v.toString(16);</span>

<span class="fc" id="L3198">                int len = s.length() + sb.length();</span>
<span class="fc bfc" id="L3199" title="All 4 branches covered.">                if (neg &amp;&amp; f.contains(Flags.PARENTHESES))</span>
<span class="fc" id="L3200">                    len++;</span>

                // apply ALTERNATE (radix indicator for hex) before ZERO_PAD
<span class="fc bfc" id="L3203" title="All 2 branches covered.">                if (f.contains(Flags.ALTERNATE)) {</span>
<span class="fc" id="L3204">                    len += 2;</span>
<span class="fc bfc" id="L3205" title="All 2 branches covered.">                    sb.append(f.contains(Flags.UPPERCASE) ? &quot;0X&quot; : &quot;0x&quot;);</span>
                }
<span class="fc bfc" id="L3207" title="All 2 branches covered.">                if (f.contains(Flags.ZERO_PAD))</span>
<span class="fc bfc" id="L3208" title="All 2 branches covered.">                    for (int i = 0; i &lt; width - len; i++)</span>
<span class="fc" id="L3209">                        sb.append('0');</span>
<span class="fc bfc" id="L3210" title="All 2 branches covered.">                if (f.contains(Flags.UPPERCASE))</span>
<span class="fc" id="L3211">                    s = s.toUpperCase();</span>
<span class="fc" id="L3212">                sb.append(s);</span>
            }

            // trailing sign indicator
<span class="fc bfc" id="L3216" title="All 2 branches covered.">            trailingSign(sb, (value.signum() == -1));</span>

            // justify based on width
<span class="fc" id="L3219">            a.append(justify(sb.toString()));</span>
<span class="fc" id="L3220">        }</span>

        private void print(float value, Locale l) throws IOException {
<span class="fc" id="L3223">            print((double) value, l);</span>
<span class="fc" id="L3224">        }</span>

        private void print(double value, Locale l) throws IOException {
<span class="fc" id="L3227">            StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L3228" title="All 2 branches covered.">            boolean neg = Double.compare(value, 0.0) == -1;</span>

<span class="fc bfc" id="L3230" title="All 2 branches covered.">            if (!Double.isNaN(value)) {</span>
<span class="fc" id="L3231">                double v = Math.abs(value);</span>

                // leading sign indicator
<span class="fc" id="L3234">                leadingSign(sb, neg);</span>

                // the value
<span class="fc bfc" id="L3237" title="All 2 branches covered.">                if (!Double.isInfinite(v))</span>
<span class="fc" id="L3238">                    print(sb, v, l, f, c, precision, neg);</span>
                else
<span class="fc bfc" id="L3240" title="All 2 branches covered.">                    sb.append(f.contains(Flags.UPPERCASE)</span>
                              ? &quot;INFINITY&quot; : &quot;Infinity&quot;);

                // trailing sign indicator
<span class="fc" id="L3244">                trailingSign(sb, neg);</span>
<span class="fc" id="L3245">            } else {</span>
<span class="fc bfc" id="L3246" title="All 2 branches covered.">                sb.append(f.contains(Flags.UPPERCASE) ? &quot;NAN&quot; : &quot;NaN&quot;);</span>
            }

            // justify based on width
<span class="fc" id="L3250">            a.append(justify(sb.toString()));</span>
<span class="fc" id="L3251">        }</span>

        // !Double.isInfinite(value) &amp;&amp; !Double.isNaN(value)
        private void print(StringBuilder sb, double value, Locale l,
                           Flags f, char c, int precision, boolean neg)
            throws IOException
        {
<span class="fc bfc" id="L3258" title="All 2 branches covered.">            if (c == Conversion.SCIENTIFIC) {</span>
                // Create a new FormattedFloatingDecimal with the desired
                // precision.
<span class="fc bfc" id="L3261" title="All 2 branches covered.">                int prec = (precision == -1 ? 6 : precision);</span>

<span class="fc" id="L3263">                FormattedFloatingDecimal fd</span>
<span class="fc" id="L3264">                        = FormattedFloatingDecimal.valueOf(value, prec,</span>
                          FormattedFloatingDecimal.Form.SCIENTIFIC);

<span class="fc" id="L3267">                char[] mant = addZeros(fd.getMantissa(), prec);</span>

                // If the precision is zero and the '#' flag is set, add the
                // requested decimal point.
<span class="pc bpc" id="L3271" title="1 of 4 branches missed.">                if (f.contains(Flags.ALTERNATE) &amp;&amp; (prec == 0))</span>
<span class="fc" id="L3272">                    mant = addDot(mant);</span>

<span class="fc bfc" id="L3274" title="All 2 branches covered.">                char[] exp = (value == 0.0)</span>
<span class="fc" id="L3275">                    ? new char[] {'+','0','0'} : fd.getExponent();</span>

<span class="fc" id="L3277">                int newW = width;</span>
<span class="fc bfc" id="L3278" title="All 2 branches covered.">                if (width != -1)</span>
<span class="fc" id="L3279">                    newW = adjustWidth(width - exp.length - 1, f, neg);</span>
<span class="fc" id="L3280">                localizedMagnitude(sb, mant, f, newW, l);</span>

<span class="fc bfc" id="L3282" title="All 2 branches covered.">                sb.append(f.contains(Flags.UPPERCASE) ? 'E' : 'e');</span>

<span class="fc" id="L3284">                Flags flags = f.dup().remove(Flags.GROUP);</span>
<span class="fc" id="L3285">                char sign = exp[0];</span>
<span class="pc bpc" id="L3286" title="2 of 6 branches missed.">                assert(sign == '+' || sign == '-');</span>
<span class="fc" id="L3287">                sb.append(sign);</span>

<span class="fc" id="L3289">                char[] tmp = new char[exp.length - 1];</span>
<span class="fc" id="L3290">                System.arraycopy(exp, 1, tmp, 0, exp.length - 1);</span>
<span class="fc" id="L3291">                sb.append(localizedMagnitude(null, tmp, flags, -1, l));</span>
<span class="fc bfc" id="L3292" title="All 2 branches covered.">            } else if (c == Conversion.DECIMAL_FLOAT) {</span>
                // Create a new FormattedFloatingDecimal with the desired
                // precision.
<span class="fc bfc" id="L3295" title="All 2 branches covered.">                int prec = (precision == -1 ? 6 : precision);</span>

<span class="fc" id="L3297">                FormattedFloatingDecimal fd</span>
<span class="fc" id="L3298">                        = FormattedFloatingDecimal.valueOf(value, prec,</span>
                          FormattedFloatingDecimal.Form.DECIMAL_FLOAT);

<span class="fc" id="L3301">                char[] mant = addZeros(fd.getMantissa(), prec);</span>

                // If the precision is zero and the '#' flag is set, add the
                // requested decimal point.
<span class="pc bpc" id="L3305" title="1 of 4 branches missed.">                if (f.contains(Flags.ALTERNATE) &amp;&amp; (prec == 0))</span>
<span class="fc" id="L3306">                    mant = addDot(mant);</span>

<span class="fc" id="L3308">                int newW = width;</span>
<span class="fc bfc" id="L3309" title="All 2 branches covered.">                if (width != -1)</span>
<span class="fc" id="L3310">                    newW = adjustWidth(width, f, neg);</span>
<span class="fc" id="L3311">                localizedMagnitude(sb, mant, f, newW, l);</span>
<span class="fc bfc" id="L3312" title="All 2 branches covered.">            } else if (c == Conversion.GENERAL) {</span>
<span class="fc" id="L3313">                int prec = precision;</span>
<span class="fc bfc" id="L3314" title="All 2 branches covered.">                if (precision == -1)</span>
<span class="fc" id="L3315">                    prec = 6;</span>
<span class="fc bfc" id="L3316" title="All 2 branches covered.">                else if (precision == 0)</span>
<span class="fc" id="L3317">                    prec = 1;</span>

                char[] exp;
                char[] mant;
                int expRounded;
<span class="fc bfc" id="L3322" title="All 2 branches covered.">                if (value == 0.0) {</span>
<span class="fc" id="L3323">                    exp = null;</span>
<span class="fc" id="L3324">                    mant = new char[] {'0'};</span>
<span class="fc" id="L3325">                    expRounded = 0;</span>
                } else {
<span class="fc" id="L3327">                    FormattedFloatingDecimal fd</span>
<span class="fc" id="L3328">                        = FormattedFloatingDecimal.valueOf(value, prec,</span>
                          FormattedFloatingDecimal.Form.GENERAL);
<span class="fc" id="L3330">                    exp = fd.getExponent();</span>
<span class="fc" id="L3331">                    mant = fd.getMantissa();</span>
<span class="fc" id="L3332">                    expRounded = fd.getExponentRounded();</span>
                }

<span class="fc bfc" id="L3335" title="All 2 branches covered.">                if (exp != null) {</span>
<span class="fc" id="L3336">                    prec -= 1;</span>
                } else {
<span class="fc" id="L3338">                    prec -= expRounded + 1;</span>
                }

<span class="fc" id="L3341">                mant = addZeros(mant, prec);</span>
                // If the precision is zero and the '#' flag is set, add the
                // requested decimal point.
<span class="pc bpc" id="L3344" title="3 of 4 branches missed.">                if (f.contains(Flags.ALTERNATE) &amp;&amp; (prec == 0))</span>
<span class="nc" id="L3345">                    mant = addDot(mant);</span>

<span class="fc" id="L3347">                int newW = width;</span>
<span class="fc bfc" id="L3348" title="All 2 branches covered.">                if (width != -1) {</span>
<span class="fc bfc" id="L3349" title="All 2 branches covered.">                    if (exp != null)</span>
<span class="fc" id="L3350">                        newW = adjustWidth(width - exp.length - 1, f, neg);</span>
                    else
<span class="fc" id="L3352">                        newW = adjustWidth(width, f, neg);</span>
                }
<span class="fc" id="L3354">                localizedMagnitude(sb, mant, f, newW, l);</span>

<span class="fc bfc" id="L3356" title="All 2 branches covered.">                if (exp != null) {</span>
<span class="fc bfc" id="L3357" title="All 2 branches covered.">                    sb.append(f.contains(Flags.UPPERCASE) ? 'E' : 'e');</span>

<span class="fc" id="L3359">                    Flags flags = f.dup().remove(Flags.GROUP);</span>
<span class="fc" id="L3360">                    char sign = exp[0];</span>
<span class="pc bpc" id="L3361" title="2 of 6 branches missed.">                    assert(sign == '+' || sign == '-');</span>
<span class="fc" id="L3362">                    sb.append(sign);</span>

<span class="fc" id="L3364">                    char[] tmp = new char[exp.length - 1];</span>
<span class="fc" id="L3365">                    System.arraycopy(exp, 1, tmp, 0, exp.length - 1);</span>
<span class="fc" id="L3366">                    sb.append(localizedMagnitude(null, tmp, flags, -1, l));</span>
                }
<span class="pc bpc" id="L3368" title="1 of 2 branches missed.">            } else if (c == Conversion.HEXADECIMAL_FLOAT) {</span>
<span class="fc" id="L3369">                int prec = precision;</span>
<span class="fc bfc" id="L3370" title="All 2 branches covered.">                if (precision == -1)</span>
                    // assume that we want all of the digits
<span class="fc" id="L3372">                    prec = 0;</span>
<span class="pc bpc" id="L3373" title="1 of 2 branches missed.">                else if (precision == 0)</span>
<span class="nc" id="L3374">                    prec = 1;</span>

<span class="fc" id="L3376">                String s = hexDouble(value, prec);</span>

                char[] va;
<span class="fc" id="L3379">                boolean upper = f.contains(Flags.UPPERCASE);</span>
<span class="fc bfc" id="L3380" title="All 2 branches covered.">                sb.append(upper ? &quot;0X&quot; : &quot;0x&quot;);</span>

<span class="pc bpc" id="L3382" title="1 of 2 branches missed.">                if (f.contains(Flags.ZERO_PAD))</span>
<span class="nc bnc" id="L3383" title="All 2 branches missed.">                    for (int i = 0; i &lt; width - s.length() - 2; i++)</span>
<span class="nc" id="L3384">                        sb.append('0');</span>

<span class="fc" id="L3386">                int idx = s.indexOf('p');</span>
<span class="fc" id="L3387">                va = s.substring(0, idx).toCharArray();</span>
<span class="fc bfc" id="L3388" title="All 2 branches covered.">                if (upper) {</span>
<span class="fc" id="L3389">                    String tmp = new String(va);</span>
                    // don't localize hex
<span class="fc" id="L3391">                    tmp = tmp.toUpperCase(Locale.US);</span>
<span class="fc" id="L3392">                    va = tmp.toCharArray();</span>
                }
<span class="fc bfc" id="L3394" title="All 2 branches covered.">                sb.append(prec != 0 ? addZeros(va, prec) : va);</span>
<span class="fc bfc" id="L3395" title="All 2 branches covered.">                sb.append(upper ? 'P' : 'p');</span>
<span class="fc" id="L3396">                sb.append(s.substring(idx+1));</span>
            }
<span class="fc" id="L3398">        }</span>

        // Add zeros to the requested precision.
        private char[] addZeros(char[] v, int prec) {
            // Look for the dot.  If we don't find one, the we'll need to add
            // it before we add the zeros.
            int i;
<span class="fc bfc" id="L3405" title="All 2 branches covered.">            for (i = 0; i &lt; v.length; i++) {</span>
<span class="fc bfc" id="L3406" title="All 2 branches covered.">                if (v[i] == '.')</span>
<span class="fc" id="L3407">                    break;</span>
            }
<span class="fc" id="L3409">            boolean needDot = false;</span>
<span class="fc bfc" id="L3410" title="All 2 branches covered.">            if (i == v.length) {</span>
<span class="fc" id="L3411">                needDot = true;</span>
            }

            // Determine existing precision.
<span class="fc bfc" id="L3415" title="All 2 branches covered.">            int outPrec = v.length - i - (needDot ? 0 : 1);</span>
<span class="pc bpc" id="L3416" title="2 of 4 branches missed.">            assert (outPrec &lt;= prec);</span>
<span class="fc bfc" id="L3417" title="All 2 branches covered.">            if (outPrec == prec)</span>
<span class="fc" id="L3418">                return v;</span>

            // Create new array with existing contents.
<span class="fc bfc" id="L3421" title="All 2 branches covered.">            char[] tmp</span>
                = new char[v.length + prec - outPrec + (needDot ? 1 : 0)];
<span class="fc" id="L3423">            System.arraycopy(v, 0, tmp, 0, v.length);</span>

            // Add dot if previously determined to be necessary.
<span class="fc" id="L3426">            int start = v.length;</span>
<span class="fc bfc" id="L3427" title="All 2 branches covered.">            if (needDot) {</span>
<span class="fc" id="L3428">                tmp[v.length] = '.';</span>
<span class="fc" id="L3429">                start++;</span>
            }

            // Add zeros.
<span class="fc bfc" id="L3433" title="All 2 branches covered.">            for (int j = start; j &lt; tmp.length; j++)</span>
<span class="fc" id="L3434">                tmp[j] = '0';</span>

<span class="fc" id="L3436">            return tmp;</span>
        }

        // Method assumes that d &gt; 0.
        private String hexDouble(double d, int prec) {
            // Let Double.toHexString handle simple cases
<span class="pc bpc" id="L3442" title="1 of 8 branches missed.">            if(!Double.isFinite(d) || d == 0.0 || prec == 0 || prec &gt;= 13)</span>
                // remove &quot;0x&quot;
<span class="fc" id="L3444">                return Double.toHexString(d).substring(2);</span>
            else {
<span class="pc bpc" id="L3446" title="3 of 6 branches missed.">                assert(prec &gt;= 1 &amp;&amp; prec &lt;= 12);</span>

<span class="fc" id="L3448">                int exponent  = Math.getExponent(d);</span>
<span class="fc bfc" id="L3449" title="All 2 branches covered.">                boolean subnormal</span>
                    = (exponent == DoubleConsts.MIN_EXPONENT - 1);

                // If this is subnormal input so normalize (could be faster to
                // do as integer operation).
<span class="fc bfc" id="L3454" title="All 2 branches covered.">                if (subnormal) {</span>
<span class="fc" id="L3455">                    scaleUp = Math.scalb(1.0, 54);</span>
<span class="fc" id="L3456">                    d *= scaleUp;</span>
                    // Calculate the exponent.  This is not just exponent + 54
                    // since the former is not the normalized exponent.
<span class="fc" id="L3459">                    exponent = Math.getExponent(d);</span>
<span class="pc bpc" id="L3460" title="3 of 6 branches missed.">                    assert exponent &gt;= DoubleConsts.MIN_EXPONENT &amp;&amp;</span>
                        exponent &lt;= DoubleConsts.MAX_EXPONENT: exponent;
                }

<span class="fc" id="L3464">                int precision = 1 + prec*4;</span>
<span class="fc" id="L3465">                int shiftDistance</span>
                    =  DoubleConsts.SIGNIFICAND_WIDTH - precision;
<span class="pc bpc" id="L3467" title="3 of 6 branches missed.">                assert(shiftDistance &gt;= 1 &amp;&amp; shiftDistance &lt; DoubleConsts.SIGNIFICAND_WIDTH);</span>

<span class="fc" id="L3469">                long doppel = Double.doubleToLongBits(d);</span>
                // Deterime the number of bits to keep.
<span class="fc" id="L3471">                long newSignif</span>
                    = (doppel &amp; (DoubleConsts.EXP_BIT_MASK
                                 | DoubleConsts.SIGNIF_BIT_MASK))
                                     &gt;&gt; shiftDistance;
                // Bits to round away.
<span class="fc" id="L3476">                long roundingBits = doppel &amp; ~(~0L &lt;&lt; shiftDistance);</span>

                // To decide how to round, look at the low-order bit of the
                // working significand, the highest order discarded bit (the
                // round bit) and whether any of the lower order discarded bits
                // are nonzero (the sticky bit).

<span class="fc bfc" id="L3483" title="All 2 branches covered.">                boolean leastZero = (newSignif &amp; 0x1L) == 0L;</span>
<span class="fc bfc" id="L3484" title="All 2 branches covered.">                boolean round</span>
                    = ((1L &lt;&lt; (shiftDistance - 1) ) &amp; roundingBits) != 0L;
<span class="pc bpc" id="L3486" title="1 of 4 branches missed.">                boolean sticky  = shiftDistance &gt; 1 &amp;&amp;</span>
                    (~(1L&lt;&lt; (shiftDistance - 1)) &amp; roundingBits) != 0;
<span class="fc bfc" id="L3488" title="All 10 branches covered.">                if((leastZero &amp;&amp; round &amp;&amp; sticky) || (!leastZero &amp;&amp; round)) {</span>
<span class="fc" id="L3489">                    newSignif++;</span>
                }

<span class="fc" id="L3492">                long signBit = doppel &amp; DoubleConsts.SIGN_BIT_MASK;</span>
<span class="fc" id="L3493">                newSignif = signBit | (newSignif &lt;&lt; shiftDistance);</span>
<span class="fc" id="L3494">                double result = Double.longBitsToDouble(newSignif);</span>

<span class="fc bfc" id="L3496" title="All 2 branches covered.">                if (Double.isInfinite(result) ) {</span>
                    // Infinite result generated by rounding
<span class="fc" id="L3498">                    return &quot;1.0p1024&quot;;</span>
                } else {
<span class="fc" id="L3500">                    String res = Double.toHexString(result).substring(2);</span>
<span class="fc bfc" id="L3501" title="All 2 branches covered.">                    if (!subnormal)</span>
<span class="fc" id="L3502">                        return res;</span>
                    else {
                        // Create a normalized subnormal string.
<span class="fc" id="L3505">                        int idx = res.indexOf('p');</span>
<span class="pc bpc" id="L3506" title="1 of 2 branches missed.">                        if (idx == -1) {</span>
                            // No 'p' character in hex string.
<span class="nc bnc" id="L3508" title="All 2 branches missed.">                            assert false;</span>
<span class="nc" id="L3509">                            return null;</span>
                        } else {
                            // Get exponent and append at the end.
<span class="fc" id="L3512">                            String exp = res.substring(idx + 1);</span>
<span class="fc" id="L3513">                            int iexp = Integer.parseInt(exp) -54;</span>
<span class="fc" id="L3514">                            return res.substring(0, idx) + &quot;p&quot;</span>
<span class="fc" id="L3515">                                + Integer.toString(iexp);</span>
                        }
                    }
                }
            }
        }

        private void print(BigDecimal value, Locale l) throws IOException {
<span class="pc bpc" id="L3523" title="1 of 2 branches missed.">            if (c == Conversion.HEXADECIMAL_FLOAT)</span>
<span class="nc" id="L3524">                failConversion(c, value);</span>
<span class="fc" id="L3525">            StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L3526" title="All 2 branches covered.">            boolean neg = value.signum() == -1;</span>
<span class="fc" id="L3527">            BigDecimal v = value.abs();</span>
            // leading sign indicator
<span class="fc" id="L3529">            leadingSign(sb, neg);</span>

            // the value
<span class="fc" id="L3532">            print(sb, v, l, f, c, precision, neg);</span>

            // trailing sign indicator
<span class="fc" id="L3535">            trailingSign(sb, neg);</span>

            // justify based on width
<span class="fc" id="L3538">            a.append(justify(sb.toString()));</span>
<span class="fc" id="L3539">        }</span>

        // value &gt; 0
        private void print(StringBuilder sb, BigDecimal value, Locale l,
                           Flags f, char c, int precision, boolean neg)
            throws IOException
        {
<span class="fc bfc" id="L3546" title="All 2 branches covered.">            if (c == Conversion.SCIENTIFIC) {</span>
                // Create a new BigDecimal with the desired precision.
<span class="fc bfc" id="L3548" title="All 2 branches covered.">                int prec = (precision == -1 ? 6 : precision);</span>
<span class="fc" id="L3549">                int scale = value.scale();</span>
<span class="fc" id="L3550">                int origPrec = value.precision();</span>
<span class="fc" id="L3551">                int nzeros = 0;</span>
                int compPrec;

<span class="fc bfc" id="L3554" title="All 2 branches covered.">                if (prec &gt; origPrec - 1) {</span>
<span class="fc" id="L3555">                    compPrec = origPrec;</span>
<span class="fc" id="L3556">                    nzeros = prec - (origPrec - 1);</span>
                } else {
<span class="fc" id="L3558">                    compPrec = prec + 1;</span>
                }

<span class="fc" id="L3561">                MathContext mc = new MathContext(compPrec);</span>
<span class="fc" id="L3562">                BigDecimal v</span>
<span class="fc" id="L3563">                    = new BigDecimal(value.unscaledValue(), scale, mc);</span>

<span class="fc" id="L3565">                BigDecimalLayout bdl</span>
<span class="fc" id="L3566">                    = new BigDecimalLayout(v.unscaledValue(), v.scale(),</span>
                                           BigDecimalLayoutForm.SCIENTIFIC);

<span class="fc" id="L3569">                char[] mant = bdl.mantissa();</span>

                // Add a decimal point if necessary.  The mantissa may not
                // contain a decimal point if the scale is zero (the internal
                // representation has no fractional part) or the original
                // precision is one. Append a decimal point if '#' is set or if
                // we require zero padding to get to the requested precision.
<span class="fc bfc" id="L3576" title="All 6 branches covered.">                if ((origPrec == 1 || !bdl.hasDot())</span>
<span class="fc bfc" id="L3577" title="All 2 branches covered.">                    &amp;&amp; (nzeros &gt; 0 || (f.contains(Flags.ALTERNATE))))</span>
<span class="fc" id="L3578">                    mant = addDot(mant);</span>

                // Add trailing zeros in the case precision is greater than
                // the number of available digits after the decimal separator.
<span class="fc" id="L3582">                mant = trailingZeros(mant, nzeros);</span>

<span class="fc" id="L3584">                char[] exp = bdl.exponent();</span>
<span class="fc" id="L3585">                int newW = width;</span>
<span class="fc bfc" id="L3586" title="All 2 branches covered.">                if (width != -1)</span>
<span class="fc" id="L3587">                    newW = adjustWidth(width - exp.length - 1, f, neg);</span>
<span class="fc" id="L3588">                localizedMagnitude(sb, mant, f, newW, l);</span>

<span class="fc bfc" id="L3590" title="All 2 branches covered.">                sb.append(f.contains(Flags.UPPERCASE) ? 'E' : 'e');</span>

<span class="fc" id="L3592">                Flags flags = f.dup().remove(Flags.GROUP);</span>
<span class="fc" id="L3593">                char sign = exp[0];</span>
<span class="pc bpc" id="L3594" title="2 of 6 branches missed.">                assert(sign == '+' || sign == '-');</span>
<span class="fc" id="L3595">                sb.append(exp[0]);</span>

<span class="fc" id="L3597">                char[] tmp = new char[exp.length - 1];</span>
<span class="fc" id="L3598">                System.arraycopy(exp, 1, tmp, 0, exp.length - 1);</span>
<span class="fc" id="L3599">                sb.append(localizedMagnitude(null, tmp, flags, -1, l));</span>
<span class="fc bfc" id="L3600" title="All 2 branches covered.">            } else if (c == Conversion.DECIMAL_FLOAT) {</span>
                // Create a new BigDecimal with the desired precision.
<span class="fc bfc" id="L3602" title="All 2 branches covered.">                int prec = (precision == -1 ? 6 : precision);</span>
<span class="fc" id="L3603">                int scale = value.scale();</span>

<span class="fc bfc" id="L3605" title="All 2 branches covered.">                if (scale &gt; prec) {</span>
                    // more &quot;scale&quot; digits than the requested &quot;precision&quot;
<span class="fc" id="L3607">                    int compPrec = value.precision();</span>
<span class="fc bfc" id="L3608" title="All 2 branches covered.">                    if (compPrec &lt;= scale) {</span>
                        // case of 0.xxxxxx
<span class="fc" id="L3610">                        value = value.setScale(prec, RoundingMode.HALF_UP);</span>
                    } else {
<span class="fc" id="L3612">                        compPrec -= (scale - prec);</span>
<span class="fc" id="L3613">                        value = new BigDecimal(value.unscaledValue(),</span>
                                               scale,
                                               new MathContext(compPrec));
                    }
                }
<span class="fc" id="L3618">                BigDecimalLayout bdl = new BigDecimalLayout(</span>
<span class="fc" id="L3619">                                           value.unscaledValue(),</span>
<span class="fc" id="L3620">                                           value.scale(),</span>
                                           BigDecimalLayoutForm.DECIMAL_FLOAT);

<span class="fc" id="L3623">                char mant[] = bdl.mantissa();</span>
<span class="fc bfc" id="L3624" title="All 2 branches covered.">                int nzeros = (bdl.scale() &lt; prec ? prec - bdl.scale() : 0);</span>

                // Add a decimal point if necessary.  The mantissa may not
                // contain a decimal point if the scale is zero (the internal
                // representation has no fractional part).  Append a decimal
                // point if '#' is set or we require zero padding to get to the
                // requested precision.
<span class="fc bfc" id="L3631" title="All 6 branches covered.">                if (bdl.scale() == 0 &amp;&amp; (f.contains(Flags.ALTERNATE) || nzeros &gt; 0))</span>
<span class="fc" id="L3632">                    mant = addDot(bdl.mantissa());</span>

                // Add trailing zeros if the precision is greater than the
                // number of available digits after the decimal separator.
<span class="fc" id="L3636">                mant = trailingZeros(mant, nzeros);</span>

<span class="fc" id="L3638">                localizedMagnitude(sb, mant, f, adjustWidth(width, f, neg), l);</span>
<span class="pc bpc" id="L3639" title="1 of 2 branches missed.">            } else if (c == Conversion.GENERAL) {</span>
<span class="fc" id="L3640">                int prec = precision;</span>
<span class="fc bfc" id="L3641" title="All 2 branches covered.">                if (precision == -1)</span>
<span class="fc" id="L3642">                    prec = 6;</span>
<span class="fc bfc" id="L3643" title="All 2 branches covered.">                else if (precision == 0)</span>
<span class="fc" id="L3644">                    prec = 1;</span>

<span class="fc" id="L3646">                BigDecimal tenToTheNegFour = BigDecimal.valueOf(1, 4);</span>
<span class="fc" id="L3647">                BigDecimal tenToThePrec = BigDecimal.valueOf(1, -prec);</span>
<span class="pc bpc" id="L3648" title="1 of 2 branches missed.">                if ((value.equals(BigDecimal.ZERO))</span>
<span class="fc bfc" id="L3649" title="All 2 branches covered.">                    || ((value.compareTo(tenToTheNegFour) != -1)</span>
<span class="fc bfc" id="L3650" title="All 2 branches covered.">                        &amp;&amp; (value.compareTo(tenToThePrec) == -1))) {</span>

<span class="fc" id="L3652">                    int e = - value.scale()</span>
<span class="fc" id="L3653">                        + (value.unscaledValue().toString().length() - 1);</span>

                    // xxx.yyy
                    //   g precision (# sig digits) = #x + #y
                    //   f precision = #y
                    //   exponent = #x - 1
                    // =&gt; f precision = g precision - exponent - 1
                    // 0.000zzz
                    //   g precision (# sig digits) = #z
                    //   f precision = #0 (after '.') + #z
                    //   exponent = - #0 (after '.') - 1
                    // =&gt; f precision = g precision - exponent - 1
<span class="fc" id="L3665">                    prec = prec - e - 1;</span>

<span class="fc" id="L3667">                    print(sb, value, l, f, Conversion.DECIMAL_FLOAT, prec,</span>
                          neg);
<span class="fc" id="L3669">                } else {</span>
<span class="fc" id="L3670">                    print(sb, value, l, f, Conversion.SCIENTIFIC, prec - 1, neg);</span>
                }
<span class="pc bnc" id="L3672" title="All 2 branches missed.">            } else if (c == Conversion.HEXADECIMAL_FLOAT) {</span>
                // This conversion isn't supported.  The error should be
                // reported earlier.
<span class="nc bnc" id="L3675" title="All 2 branches missed.">                assert false;</span>
            }
<span class="fc" id="L3677">        }</span>

        private class BigDecimalLayout {
            private StringBuilder mant;
            private StringBuilder exp;
<span class="fc" id="L3682">            private boolean dot = false;</span>
            private int scale;

<span class="fc" id="L3685">            public BigDecimalLayout(BigInteger intVal, int scale, BigDecimalLayoutForm form) {</span>
<span class="fc" id="L3686">                layout(intVal, scale, form);</span>
<span class="fc" id="L3687">            }</span>

            public boolean hasDot() {
<span class="fc" id="L3690">                return dot;</span>
            }

            public int scale() {
<span class="fc" id="L3694">                return scale;</span>
            }

            // char[] with canonical string representation
            public char[] layoutChars() {
<span class="nc" id="L3699">                StringBuilder sb = new StringBuilder(mant);</span>
<span class="nc bnc" id="L3700" title="All 2 branches missed.">                if (exp != null) {</span>
<span class="nc" id="L3701">                    sb.append('E');</span>
<span class="nc" id="L3702">                    sb.append(exp);</span>
                }
<span class="nc" id="L3704">                return toCharArray(sb);</span>
            }

            public char[] mantissa() {
<span class="fc" id="L3708">                return toCharArray(mant);</span>
            }

            // The exponent will be formatted as a sign ('+' or '-') followed
            // by the exponent zero-padded to include at least two digits.
            public char[] exponent() {
<span class="fc" id="L3714">                return toCharArray(exp);</span>
            }

            private char[] toCharArray(StringBuilder sb) {
<span class="pc bpc" id="L3718" title="1 of 2 branches missed.">                if (sb == null)</span>
<span class="nc" id="L3719">                    return null;</span>
<span class="fc" id="L3720">                char[] result = new char[sb.length()];</span>
<span class="fc" id="L3721">                sb.getChars(0, result.length, result, 0);</span>
<span class="fc" id="L3722">                return result;</span>
            }

            private void layout(BigInteger intVal, int scale, BigDecimalLayoutForm form) {
<span class="fc" id="L3726">                char coeff[] = intVal.toString().toCharArray();</span>
<span class="fc" id="L3727">                this.scale = scale;</span>

                // Construct a buffer, with sufficient capacity for all cases.
                // If E-notation is needed, length will be: +1 if negative, +1
                // if '.' needed, +2 for &quot;E+&quot;, + up to 10 for adjusted
                // exponent.  Otherwise it could have +1 if negative, plus
                // leading &quot;0.00000&quot;
<span class="fc" id="L3734">                mant = new StringBuilder(coeff.length + 14);</span>

<span class="fc bfc" id="L3736" title="All 2 branches covered.">                if (scale == 0) {</span>
<span class="fc" id="L3737">                    int len = coeff.length;</span>
<span class="fc bfc" id="L3738" title="All 2 branches covered.">                    if (len &gt; 1) {</span>
<span class="fc" id="L3739">                        mant.append(coeff[0]);</span>
<span class="fc bfc" id="L3740" title="All 2 branches covered.">                        if (form == BigDecimalLayoutForm.SCIENTIFIC) {</span>
<span class="fc" id="L3741">                            mant.append('.');</span>
<span class="fc" id="L3742">                            dot = true;</span>
<span class="fc" id="L3743">                            mant.append(coeff, 1, len - 1);</span>
<span class="fc" id="L3744">                            exp = new StringBuilder(&quot;+&quot;);</span>
<span class="pc bpc" id="L3745" title="1 of 2 branches missed.">                            if (len &lt; 10)</span>
<span class="fc" id="L3746">                                exp.append(&quot;0&quot;).append(len - 1);</span>
                            else
<span class="nc" id="L3748">                                exp.append(len - 1);</span>
                        } else {
<span class="fc" id="L3750">                            mant.append(coeff, 1, len - 1);</span>
                        }
                    } else {
<span class="fc" id="L3753">                        mant.append(coeff);</span>
<span class="fc bfc" id="L3754" title="All 2 branches covered.">                        if (form == BigDecimalLayoutForm.SCIENTIFIC)</span>
<span class="fc" id="L3755">                            exp = new StringBuilder(&quot;+00&quot;);</span>
                    }
<span class="fc" id="L3757">                    return;</span>
                }
<span class="fc" id="L3759">                long adjusted = -(long) scale + (coeff.length - 1);</span>
<span class="fc bfc" id="L3760" title="All 2 branches covered.">                if (form == BigDecimalLayoutForm.DECIMAL_FLOAT) {</span>
                    // count of padding zeros
<span class="fc" id="L3762">                    int pad = scale - coeff.length;</span>
<span class="fc bfc" id="L3763" title="All 2 branches covered.">                    if (pad &gt;= 0) {</span>
                        // 0.xxx form
<span class="fc" id="L3765">                        mant.append(&quot;0.&quot;);</span>
<span class="fc" id="L3766">                        dot = true;</span>
<span class="fc bfc" id="L3767" title="All 2 branches covered.">                        for (; pad &gt; 0 ; pad--) mant.append('0');</span>
<span class="fc" id="L3768">                        mant.append(coeff);</span>
                    } else {
<span class="fc bfc" id="L3770" title="All 2 branches covered.">                        if (-pad &lt; coeff.length) {</span>
                            // xx.xx form
<span class="fc" id="L3772">                            mant.append(coeff, 0, -pad);</span>
<span class="fc" id="L3773">                            mant.append('.');</span>
<span class="fc" id="L3774">                            dot = true;</span>
<span class="fc" id="L3775">                            mant.append(coeff, -pad, scale);</span>
                        } else {
                            // xx form
<span class="fc" id="L3778">                            mant.append(coeff, 0, coeff.length);</span>
<span class="fc bfc" id="L3779" title="All 2 branches covered.">                            for (int i = 0; i &lt; -scale; i++)</span>
<span class="fc" id="L3780">                                mant.append('0');</span>
<span class="fc" id="L3781">                            this.scale = 0;</span>
                        }
                    }
<span class="fc" id="L3784">                } else {</span>
                    // x.xxx form
<span class="fc" id="L3786">                    mant.append(coeff[0]);</span>
<span class="fc bfc" id="L3787" title="All 2 branches covered.">                    if (coeff.length &gt; 1) {</span>
<span class="fc" id="L3788">                        mant.append('.');</span>
<span class="fc" id="L3789">                        dot = true;</span>
<span class="fc" id="L3790">                        mant.append(coeff, 1, coeff.length-1);</span>
                    }
<span class="fc" id="L3792">                    exp = new StringBuilder();</span>
<span class="fc bfc" id="L3793" title="All 2 branches covered.">                    if (adjusted != 0) {</span>
<span class="fc" id="L3794">                        long abs = Math.abs(adjusted);</span>
                        // require sign
<span class="fc bfc" id="L3796" title="All 2 branches covered.">                        exp.append(adjusted &lt; 0 ? '-' : '+');</span>
<span class="fc bfc" id="L3797" title="All 2 branches covered.">                        if (abs &lt; 10)</span>
<span class="fc" id="L3798">                            exp.append('0');</span>
<span class="fc" id="L3799">                        exp.append(abs);</span>
<span class="fc" id="L3800">                    } else {</span>
<span class="fc" id="L3801">                        exp.append(&quot;+00&quot;);</span>
                    }
                }
<span class="fc" id="L3804">            }</span>
        }

        private int adjustWidth(int width, Flags f, boolean neg) {
<span class="fc" id="L3808">            int newW = width;</span>
<span class="fc bfc" id="L3809" title="All 6 branches covered.">            if (newW != -1 &amp;&amp; neg &amp;&amp; f.contains(Flags.PARENTHESES))</span>
<span class="fc" id="L3810">                newW--;</span>
<span class="fc" id="L3811">            return newW;</span>
        }

        // Add a '.' to th mantissa if required
        private char[] addDot(char[] mant) {
<span class="fc" id="L3816">            char[] tmp = mant;</span>
<span class="fc" id="L3817">            tmp = new char[mant.length + 1];</span>
<span class="fc" id="L3818">            System.arraycopy(mant, 0, tmp, 0, mant.length);</span>
<span class="fc" id="L3819">            tmp[tmp.length - 1] = '.';</span>
<span class="fc" id="L3820">            return tmp;</span>
        }

        // Add trailing zeros in the case precision is greater than the number
        // of available digits after the decimal separator.
        private char[] trailingZeros(char[] mant, int nzeros) {
<span class="fc" id="L3826">            char[] tmp = mant;</span>
<span class="fc bfc" id="L3827" title="All 2 branches covered.">            if (nzeros &gt; 0) {</span>
<span class="fc" id="L3828">                tmp = new char[mant.length + nzeros];</span>
<span class="fc" id="L3829">                System.arraycopy(mant, 0, tmp, 0, mant.length);</span>
<span class="fc bfc" id="L3830" title="All 2 branches covered.">                for (int i = mant.length; i &lt; tmp.length; i++)</span>
<span class="fc" id="L3831">                    tmp[i] = '0';</span>
            }
<span class="fc" id="L3833">            return tmp;</span>
        }

        private void print(Calendar t, char c, Locale l)  throws IOException
        {
<span class="fc" id="L3838">            StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L3839">            print(sb, t, c, l);</span>

            // justify based on width
<span class="fc" id="L3842">            String s = justify(sb.toString());</span>
<span class="fc bfc" id="L3843" title="All 2 branches covered.">            if (f.contains(Flags.UPPERCASE))</span>
<span class="fc" id="L3844">                s = s.toUpperCase();</span>

<span class="fc" id="L3846">            a.append(s);</span>
<span class="fc" id="L3847">        }</span>

        private Appendable print(StringBuilder sb, Calendar t, char c,
                                 Locale l)
            throws IOException
        {
<span class="pc bpc" id="L3853" title="1 of 2 branches missed.">            if (sb == null)</span>
<span class="nc" id="L3854">                sb = new StringBuilder();</span>
<span class="pc bpc" id="L3855" title="2 of 22 branches missed.">            switch (c) {</span>
            case DateTime.HOUR_OF_DAY_0: // 'H' (00 - 23)
            case DateTime.HOUR_0:        // 'I' (01 - 12)
            case DateTime.HOUR_OF_DAY:   // 'k' (0 - 23) -- like H
            case DateTime.HOUR:        { // 'l' (1 - 12) -- like I
<span class="fc" id="L3860">                int i = t.get(Calendar.HOUR_OF_DAY);</span>
<span class="fc bfc" id="L3861" title="All 4 branches covered.">                if (c == DateTime.HOUR_0 || c == DateTime.HOUR)</span>
<span class="fc bfc" id="L3862" title="All 4 branches covered.">                    i = (i == 0 || i == 12 ? 12 : i % 12);</span>
<span class="fc bfc" id="L3863" title="All 4 branches covered.">                Flags flags = (c == DateTime.HOUR_OF_DAY_0</span>
                               || c == DateTime.HOUR_0
                               ? Flags.ZERO_PAD
                               : Flags.NONE);
<span class="fc" id="L3867">                sb.append(localizedMagnitude(null, i, flags, 2, l));</span>
<span class="fc" id="L3868">                break;</span>
            }
            case DateTime.MINUTE:      { // 'M' (00 - 59)
<span class="fc" id="L3871">                int i = t.get(Calendar.MINUTE);</span>
<span class="fc" id="L3872">                Flags flags = Flags.ZERO_PAD;</span>
<span class="fc" id="L3873">                sb.append(localizedMagnitude(null, i, flags, 2, l));</span>
<span class="fc" id="L3874">                break;</span>
            }
            case DateTime.NANOSECOND:  { // 'N' (000000000 - 999999999)
<span class="fc" id="L3877">                int i = t.get(Calendar.MILLISECOND) * 1000000;</span>
<span class="fc" id="L3878">                Flags flags = Flags.ZERO_PAD;</span>
<span class="fc" id="L3879">                sb.append(localizedMagnitude(null, i, flags, 9, l));</span>
<span class="fc" id="L3880">                break;</span>
            }
            case DateTime.MILLISECOND: { // 'L' (000 - 999)
<span class="fc" id="L3883">                int i = t.get(Calendar.MILLISECOND);</span>
<span class="fc" id="L3884">                Flags flags = Flags.ZERO_PAD;</span>
<span class="fc" id="L3885">                sb.append(localizedMagnitude(null, i, flags, 3, l));</span>
<span class="fc" id="L3886">                break;</span>
            }
            case DateTime.MILLISECOND_SINCE_EPOCH: { // 'Q' (0 - 99...?)
<span class="nc" id="L3889">                long i = t.getTimeInMillis();</span>
<span class="nc" id="L3890">                Flags flags = Flags.NONE;</span>
<span class="nc" id="L3891">                sb.append(localizedMagnitude(null, i, flags, width, l));</span>
<span class="nc" id="L3892">                break;</span>
            }
            case DateTime.AM_PM:       { // 'p' (am or pm)
                // Calendar.AM = 0, Calendar.PM = 1, LocaleElements defines upper
<span class="fc" id="L3896">                String[] ampm = { &quot;AM&quot;, &quot;PM&quot; };</span>
<span class="pc bpc" id="L3897" title="1 of 4 branches missed.">                if (l != null &amp;&amp; l != Locale.US) {</span>
<span class="nc" id="L3898">                    DateFormatSymbols dfs = DateFormatSymbols.getInstance(l);</span>
<span class="nc" id="L3899">                    ampm = dfs.getAmPmStrings();</span>
                }
<span class="fc" id="L3901">                String s = ampm[t.get(Calendar.AM_PM)];</span>
<span class="fc bfc" id="L3902" title="All 2 branches covered.">                sb.append(s.toLowerCase(l != null ? l : Locale.US));</span>
<span class="fc" id="L3903">                break;</span>
            }
            case DateTime.SECONDS_SINCE_EPOCH: { // 's' (0 - 99...?)
<span class="fc" id="L3906">                long i = t.getTimeInMillis() / 1000;</span>
<span class="fc" id="L3907">                Flags flags = Flags.NONE;</span>
<span class="fc" id="L3908">                sb.append(localizedMagnitude(null, i, flags, width, l));</span>
<span class="fc" id="L3909">                break;</span>
            }
            case DateTime.SECOND:      { // 'S' (00 - 60 - leap second)
<span class="fc" id="L3912">                int i = t.get(Calendar.SECOND);</span>
<span class="fc" id="L3913">                Flags flags = Flags.ZERO_PAD;</span>
<span class="fc" id="L3914">                sb.append(localizedMagnitude(null, i, flags, 2, l));</span>
<span class="fc" id="L3915">                break;</span>
            }
            case DateTime.ZONE_NUMERIC: { // 'z' ({-|+}####) - ls minus?
<span class="fc" id="L3918">                int i = t.get(Calendar.ZONE_OFFSET) + t.get(Calendar.DST_OFFSET);</span>
<span class="pc bpc" id="L3919" title="1 of 2 branches missed.">                boolean neg = i &lt; 0;</span>
<span class="pc bpc" id="L3920" title="1 of 2 branches missed.">                sb.append(neg ? '-' : '+');</span>
<span class="pc bpc" id="L3921" title="1 of 2 branches missed.">                if (neg)</span>
<span class="fc" id="L3922">                    i = -i;</span>
<span class="fc" id="L3923">                int min = i / 60000;</span>
                // combine minute and hour into a single integer
<span class="fc" id="L3925">                int offset = (min / 60) * 100 + (min % 60);</span>
<span class="fc" id="L3926">                Flags flags = Flags.ZERO_PAD;</span>

<span class="fc" id="L3928">                sb.append(localizedMagnitude(null, offset, flags, 4, l));</span>
<span class="fc" id="L3929">                break;</span>
            }
            case DateTime.ZONE:        { // 'Z' (symbol)
<span class="fc" id="L3932">                TimeZone tz = t.getTimeZone();</span>
<span class="pc bpc" id="L3933" title="1 of 4 branches missed.">                sb.append(tz.getDisplayName((t.get(Calendar.DST_OFFSET) != 0),</span>
                                           TimeZone.SHORT,
                                            (l == null) ? Locale.US : l));
<span class="fc" id="L3936">                break;</span>
            }

            // Date
            case DateTime.NAME_OF_DAY_ABBREV:     // 'a'
            case DateTime.NAME_OF_DAY:          { // 'A'
<span class="fc" id="L3942">                int i = t.get(Calendar.DAY_OF_WEEK);</span>
<span class="fc bfc" id="L3943" title="All 2 branches covered.">                Locale lt = ((l == null) ? Locale.US : l);</span>
<span class="fc" id="L3944">                DateFormatSymbols dfs = DateFormatSymbols.getInstance(lt);</span>
<span class="fc bfc" id="L3945" title="All 2 branches covered.">                if (c == DateTime.NAME_OF_DAY)</span>
<span class="fc" id="L3946">                    sb.append(dfs.getWeekdays()[i]);</span>
                else
<span class="fc" id="L3948">                    sb.append(dfs.getShortWeekdays()[i]);</span>
<span class="fc" id="L3949">                break;</span>
            }
            case DateTime.NAME_OF_MONTH_ABBREV:   // 'b'
            case DateTime.NAME_OF_MONTH_ABBREV_X: // 'h' -- same b
            case DateTime.NAME_OF_MONTH:        { // 'B'
<span class="fc" id="L3954">                int i = t.get(Calendar.MONTH);</span>
<span class="fc bfc" id="L3955" title="All 2 branches covered.">                Locale lt = ((l == null) ? Locale.US : l);</span>
<span class="fc" id="L3956">                DateFormatSymbols dfs = DateFormatSymbols.getInstance(lt);</span>
<span class="fc bfc" id="L3957" title="All 2 branches covered.">                if (c == DateTime.NAME_OF_MONTH)</span>
<span class="fc" id="L3958">                    sb.append(dfs.getMonths()[i]);</span>
                else
<span class="fc" id="L3960">                    sb.append(dfs.getShortMonths()[i]);</span>
<span class="fc" id="L3961">                break;</span>
            }
            case DateTime.CENTURY:                // 'C' (00 - 99)
            case DateTime.YEAR_2:                 // 'y' (00 - 99)
            case DateTime.YEAR_4:               { // 'Y' (0000 - 9999)
<span class="fc" id="L3966">                int i = t.get(Calendar.YEAR);</span>
<span class="fc" id="L3967">                int size = 2;</span>
<span class="pc bpc" id="L3968" title="1 of 4 branches missed.">                switch (c) {</span>
                case DateTime.CENTURY:
<span class="fc" id="L3970">                    i /= 100;</span>
<span class="fc" id="L3971">                    break;</span>
                case DateTime.YEAR_2:
<span class="fc" id="L3973">                    i %= 100;</span>
<span class="fc" id="L3974">                    break;</span>
                case DateTime.YEAR_4:
<span class="fc" id="L3976">                    size = 4;</span>
                    break;
                }
<span class="fc" id="L3979">                Flags flags = Flags.ZERO_PAD;</span>
<span class="fc" id="L3980">                sb.append(localizedMagnitude(null, i, flags, size, l));</span>
<span class="fc" id="L3981">                break;</span>
            }
            case DateTime.DAY_OF_MONTH_0:         // 'd' (01 - 31)
            case DateTime.DAY_OF_MONTH:         { // 'e' (1 - 31) -- like d
<span class="fc" id="L3985">                int i = t.get(Calendar.DATE);</span>
<span class="fc bfc" id="L3986" title="All 2 branches covered.">                Flags flags = (c == DateTime.DAY_OF_MONTH_0</span>
                               ? Flags.ZERO_PAD
                               : Flags.NONE);
<span class="fc" id="L3989">                sb.append(localizedMagnitude(null, i, flags, 2, l));</span>
<span class="fc" id="L3990">                break;</span>
            }
            case DateTime.DAY_OF_YEAR:          { // 'j' (001 - 366)
<span class="fc" id="L3993">                int i = t.get(Calendar.DAY_OF_YEAR);</span>
<span class="fc" id="L3994">                Flags flags = Flags.ZERO_PAD;</span>
<span class="fc" id="L3995">                sb.append(localizedMagnitude(null, i, flags, 3, l));</span>
<span class="fc" id="L3996">                break;</span>
            }
            case DateTime.MONTH:                { // 'm' (01 - 12)
<span class="fc" id="L3999">                int i = t.get(Calendar.MONTH) + 1;</span>
<span class="fc" id="L4000">                Flags flags = Flags.ZERO_PAD;</span>
<span class="fc" id="L4001">                sb.append(localizedMagnitude(null, i, flags, 2, l));</span>
<span class="fc" id="L4002">                break;</span>
            }

            // Composites
            case DateTime.TIME:         // 'T' (24 hour hh:mm:ss - %tH:%tM:%tS)
            case DateTime.TIME_24_HOUR:    { // 'R' (hh:mm same as %H:%M)
<span class="fc" id="L4008">                char sep = ':';</span>
<span class="fc" id="L4009">                print(sb, t, DateTime.HOUR_OF_DAY_0, l).append(sep);</span>
<span class="fc" id="L4010">                print(sb, t, DateTime.MINUTE, l);</span>
<span class="fc bfc" id="L4011" title="All 2 branches covered.">                if (c == DateTime.TIME) {</span>
<span class="fc" id="L4012">                    sb.append(sep);</span>
<span class="fc" id="L4013">                    print(sb, t, DateTime.SECOND, l);</span>
                }
                break;
            }
            case DateTime.TIME_12_HOUR:    { // 'r' (hh:mm:ss [AP]M)
<span class="fc" id="L4018">                char sep = ':';</span>
<span class="fc" id="L4019">                print(sb, t, DateTime.HOUR_0, l).append(sep);</span>
<span class="fc" id="L4020">                print(sb, t, DateTime.MINUTE, l).append(sep);</span>
<span class="fc" id="L4021">                print(sb, t, DateTime.SECOND, l).append(' ');</span>
                // this may be in wrong place for some locales
<span class="fc" id="L4023">                StringBuilder tsb = new StringBuilder();</span>
<span class="fc" id="L4024">                print(tsb, t, DateTime.AM_PM, l);</span>
<span class="fc bfc" id="L4025" title="All 2 branches covered.">                sb.append(tsb.toString().toUpperCase(l != null ? l : Locale.US));</span>
<span class="fc" id="L4026">                break;</span>
            }
            case DateTime.DATE_TIME:    { // 'c' (Sat Nov 04 12:02:33 EST 1999)
<span class="fc" id="L4029">                char sep = ' ';</span>
<span class="fc" id="L4030">                print(sb, t, DateTime.NAME_OF_DAY_ABBREV, l).append(sep);</span>
<span class="fc" id="L4031">                print(sb, t, DateTime.NAME_OF_MONTH_ABBREV, l).append(sep);</span>
<span class="fc" id="L4032">                print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);</span>
<span class="fc" id="L4033">                print(sb, t, DateTime.TIME, l).append(sep);</span>
<span class="fc" id="L4034">                print(sb, t, DateTime.ZONE, l).append(sep);</span>
<span class="fc" id="L4035">                print(sb, t, DateTime.YEAR_4, l);</span>
<span class="fc" id="L4036">                break;</span>
            }
            case DateTime.DATE:            { // 'D' (mm/dd/yy)
<span class="fc" id="L4039">                char sep = '/';</span>
<span class="fc" id="L4040">                print(sb, t, DateTime.MONTH, l).append(sep);</span>
<span class="fc" id="L4041">                print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);</span>
<span class="fc" id="L4042">                print(sb, t, DateTime.YEAR_2, l);</span>
<span class="fc" id="L4043">                break;</span>
            }
            case DateTime.ISO_STANDARD_DATE: { // 'F' (%Y-%m-%d)
<span class="fc" id="L4046">                char sep = '-';</span>
<span class="fc" id="L4047">                print(sb, t, DateTime.YEAR_4, l).append(sep);</span>
<span class="fc" id="L4048">                print(sb, t, DateTime.MONTH, l).append(sep);</span>
<span class="fc" id="L4049">                print(sb, t, DateTime.DAY_OF_MONTH_0, l);</span>
<span class="fc" id="L4050">                break;</span>
            }
            default:
<span class="nc bnc" id="L4053" title="All 2 branches missed.">                assert false;</span>
            }
<span class="fc" id="L4055">            return sb;</span>
        }

        private void print(TemporalAccessor t, char c, Locale l)  throws IOException {
<span class="nc" id="L4059">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L4060">            print(sb, t, c, l);</span>
            // justify based on width
<span class="nc" id="L4062">            String s = justify(sb.toString());</span>
<span class="nc bnc" id="L4063" title="All 2 branches missed.">            if (f.contains(Flags.UPPERCASE))</span>
<span class="nc" id="L4064">                s = s.toUpperCase();</span>
<span class="nc" id="L4065">            a.append(s);</span>
<span class="nc" id="L4066">        }</span>

        private Appendable print(StringBuilder sb, TemporalAccessor t, char c,
                                 Locale l) throws IOException {
<span class="nc bnc" id="L4070" title="All 2 branches missed.">            if (sb == null)</span>
<span class="nc" id="L4071">                sb = new StringBuilder();</span>
            try {
<span class="nc bnc" id="L4073" title="All 25 branches missed.">                switch (c) {</span>
                case DateTime.HOUR_OF_DAY_0: {  // 'H' (00 - 23)
<span class="nc" id="L4075">                    int i = t.get(ChronoField.HOUR_OF_DAY);</span>
<span class="nc" id="L4076">                    sb.append(localizedMagnitude(null, i, Flags.ZERO_PAD, 2, l));</span>
<span class="nc" id="L4077">                    break;</span>
                }
                case DateTime.HOUR_OF_DAY: {   // 'k' (0 - 23) -- like H
<span class="nc" id="L4080">                    int i = t.get(ChronoField.HOUR_OF_DAY);</span>
<span class="nc" id="L4081">                    sb.append(localizedMagnitude(null, i, Flags.NONE, 2, l));</span>
<span class="nc" id="L4082">                    break;</span>
                }
                case DateTime.HOUR_0:      {  // 'I' (01 - 12)
<span class="nc" id="L4085">                    int i = t.get(ChronoField.CLOCK_HOUR_OF_AMPM);</span>
<span class="nc" id="L4086">                    sb.append(localizedMagnitude(null, i, Flags.ZERO_PAD, 2, l));</span>
<span class="nc" id="L4087">                    break;</span>
                }
                case DateTime.HOUR:        { // 'l' (1 - 12) -- like I
<span class="nc" id="L4090">                    int i = t.get(ChronoField.CLOCK_HOUR_OF_AMPM);</span>
<span class="nc" id="L4091">                    sb.append(localizedMagnitude(null, i, Flags.NONE, 2, l));</span>
<span class="nc" id="L4092">                    break;</span>
                }
                case DateTime.MINUTE:      { // 'M' (00 - 59)
<span class="nc" id="L4095">                    int i = t.get(ChronoField.MINUTE_OF_HOUR);</span>
<span class="nc" id="L4096">                    Flags flags = Flags.ZERO_PAD;</span>
<span class="nc" id="L4097">                    sb.append(localizedMagnitude(null, i, flags, 2, l));</span>
<span class="nc" id="L4098">                    break;</span>
                }
                case DateTime.NANOSECOND:  { // 'N' (000000000 - 999999999)
<span class="nc" id="L4101">                    int i = t.get(ChronoField.MILLI_OF_SECOND) * 1000000;</span>
<span class="nc" id="L4102">                    Flags flags = Flags.ZERO_PAD;</span>
<span class="nc" id="L4103">                    sb.append(localizedMagnitude(null, i, flags, 9, l));</span>
<span class="nc" id="L4104">                    break;</span>
                }
                case DateTime.MILLISECOND: { // 'L' (000 - 999)
<span class="nc" id="L4107">                    int i = t.get(ChronoField.MILLI_OF_SECOND);</span>
<span class="nc" id="L4108">                    Flags flags = Flags.ZERO_PAD;</span>
<span class="nc" id="L4109">                    sb.append(localizedMagnitude(null, i, flags, 3, l));</span>
<span class="nc" id="L4110">                    break;</span>
                }
                case DateTime.MILLISECOND_SINCE_EPOCH: { // 'Q' (0 - 99...?)
<span class="nc" id="L4113">                    long i = t.getLong(ChronoField.INSTANT_SECONDS) * 1000L +</span>
<span class="nc" id="L4114">                             t.getLong(ChronoField.MILLI_OF_SECOND);</span>
<span class="nc" id="L4115">                    Flags flags = Flags.NONE;</span>
<span class="nc" id="L4116">                    sb.append(localizedMagnitude(null, i, flags, width, l));</span>
<span class="nc" id="L4117">                    break;</span>
                }
                case DateTime.AM_PM:       { // 'p' (am or pm)
                    // Calendar.AM = 0, Calendar.PM = 1, LocaleElements defines upper
<span class="nc" id="L4121">                    String[] ampm = { &quot;AM&quot;, &quot;PM&quot; };</span>
<span class="nc bnc" id="L4122" title="All 4 branches missed.">                    if (l != null &amp;&amp; l != Locale.US) {</span>
<span class="nc" id="L4123">                        DateFormatSymbols dfs = DateFormatSymbols.getInstance(l);</span>
<span class="nc" id="L4124">                        ampm = dfs.getAmPmStrings();</span>
                    }
<span class="nc" id="L4126">                    String s = ampm[t.get(ChronoField.AMPM_OF_DAY)];</span>
<span class="nc bnc" id="L4127" title="All 2 branches missed.">                    sb.append(s.toLowerCase(l != null ? l : Locale.US));</span>
<span class="nc" id="L4128">                    break;</span>
                }
                case DateTime.SECONDS_SINCE_EPOCH: { // 's' (0 - 99...?)
<span class="nc" id="L4131">                    long i = t.getLong(ChronoField.INSTANT_SECONDS);</span>
<span class="nc" id="L4132">                    Flags flags = Flags.NONE;</span>
<span class="nc" id="L4133">                    sb.append(localizedMagnitude(null, i, flags, width, l));</span>
<span class="nc" id="L4134">                    break;</span>
                }
                case DateTime.SECOND:      { // 'S' (00 - 60 - leap second)
<span class="nc" id="L4137">                    int i = t.get(ChronoField.SECOND_OF_MINUTE);</span>
<span class="nc" id="L4138">                    Flags flags = Flags.ZERO_PAD;</span>
<span class="nc" id="L4139">                    sb.append(localizedMagnitude(null, i, flags, 2, l));</span>
<span class="nc" id="L4140">                    break;</span>
                }
                case DateTime.ZONE_NUMERIC: { // 'z' ({-|+}####) - ls minus?
<span class="nc" id="L4143">                    int i = t.get(ChronoField.OFFSET_SECONDS);</span>
<span class="nc bnc" id="L4144" title="All 2 branches missed.">                    boolean neg = i &lt; 0;</span>
<span class="nc bnc" id="L4145" title="All 2 branches missed.">                    sb.append(neg ? '-' : '+');</span>
<span class="nc bnc" id="L4146" title="All 2 branches missed.">                    if (neg)</span>
<span class="nc" id="L4147">                        i = -i;</span>
<span class="nc" id="L4148">                    int min = i / 60;</span>
                    // combine minute and hour into a single integer
<span class="nc" id="L4150">                    int offset = (min / 60) * 100 + (min % 60);</span>
<span class="nc" id="L4151">                    Flags flags = Flags.ZERO_PAD;</span>
<span class="nc" id="L4152">                    sb.append(localizedMagnitude(null, offset, flags, 4, l));</span>
<span class="nc" id="L4153">                    break;</span>
                }
                case DateTime.ZONE:        { // 'Z' (symbol)
<span class="nc" id="L4156">                    ZoneId zid = t.query(TemporalQueries.zone());</span>
<span class="nc bnc" id="L4157" title="All 2 branches missed.">                    if (zid == null) {</span>
<span class="nc" id="L4158">                        throw new IllegalFormatConversionException(c, t.getClass());</span>
                    }
<span class="nc bnc" id="L4160" title="All 2 branches missed.">                    if (!(zid instanceof ZoneOffset) &amp;&amp;</span>
<span class="nc bnc" id="L4161" title="All 2 branches missed.">                        t.isSupported(ChronoField.INSTANT_SECONDS)) {</span>
<span class="nc" id="L4162">                        Instant instant = Instant.from(t);</span>
<span class="nc" id="L4163">                        sb.append(TimeZone.getTimeZone(zid.getId())</span>
<span class="nc bnc" id="L4164" title="All 2 branches missed.">                                          .getDisplayName(zid.getRules().isDaylightSavings(instant),</span>
                                                          TimeZone.SHORT,
                                                          (l == null) ? Locale.US : l));
<span class="nc" id="L4167">                        break;</span>
                    }
<span class="nc" id="L4169">                    sb.append(zid.getId());</span>
<span class="nc" id="L4170">                    break;</span>
                }
                // Date
                case DateTime.NAME_OF_DAY_ABBREV:     // 'a'
                case DateTime.NAME_OF_DAY:          { // 'A'
<span class="nc" id="L4175">                    int i = t.get(ChronoField.DAY_OF_WEEK) % 7 + 1;</span>
<span class="nc bnc" id="L4176" title="All 2 branches missed.">                    Locale lt = ((l == null) ? Locale.US : l);</span>
<span class="nc" id="L4177">                    DateFormatSymbols dfs = DateFormatSymbols.getInstance(lt);</span>
<span class="nc bnc" id="L4178" title="All 2 branches missed.">                    if (c == DateTime.NAME_OF_DAY)</span>
<span class="nc" id="L4179">                        sb.append(dfs.getWeekdays()[i]);</span>
                    else
<span class="nc" id="L4181">                        sb.append(dfs.getShortWeekdays()[i]);</span>
<span class="nc" id="L4182">                    break;</span>
                }
                case DateTime.NAME_OF_MONTH_ABBREV:   // 'b'
                case DateTime.NAME_OF_MONTH_ABBREV_X: // 'h' -- same b
                case DateTime.NAME_OF_MONTH:        { // 'B'
<span class="nc" id="L4187">                    int i = t.get(ChronoField.MONTH_OF_YEAR) - 1;</span>
<span class="nc bnc" id="L4188" title="All 2 branches missed.">                    Locale lt = ((l == null) ? Locale.US : l);</span>
<span class="nc" id="L4189">                    DateFormatSymbols dfs = DateFormatSymbols.getInstance(lt);</span>
<span class="nc bnc" id="L4190" title="All 2 branches missed.">                    if (c == DateTime.NAME_OF_MONTH)</span>
<span class="nc" id="L4191">                        sb.append(dfs.getMonths()[i]);</span>
                    else
<span class="nc" id="L4193">                        sb.append(dfs.getShortMonths()[i]);</span>
<span class="nc" id="L4194">                    break;</span>
                }
                case DateTime.CENTURY:                // 'C' (00 - 99)
                case DateTime.YEAR_2:                 // 'y' (00 - 99)
                case DateTime.YEAR_4:               { // 'Y' (0000 - 9999)
<span class="nc" id="L4199">                    int i = t.get(ChronoField.YEAR_OF_ERA);</span>
<span class="nc" id="L4200">                    int size = 2;</span>
<span class="nc bnc" id="L4201" title="All 4 branches missed.">                    switch (c) {</span>
                    case DateTime.CENTURY:
<span class="nc" id="L4203">                        i /= 100;</span>
<span class="nc" id="L4204">                        break;</span>
                    case DateTime.YEAR_2:
<span class="nc" id="L4206">                        i %= 100;</span>
<span class="nc" id="L4207">                        break;</span>
                    case DateTime.YEAR_4:
<span class="nc" id="L4209">                        size = 4;</span>
                        break;
                    }
<span class="nc" id="L4212">                    Flags flags = Flags.ZERO_PAD;</span>
<span class="nc" id="L4213">                    sb.append(localizedMagnitude(null, i, flags, size, l));</span>
<span class="nc" id="L4214">                    break;</span>
                }
                case DateTime.DAY_OF_MONTH_0:         // 'd' (01 - 31)
                case DateTime.DAY_OF_MONTH:         { // 'e' (1 - 31) -- like d
<span class="nc" id="L4218">                    int i = t.get(ChronoField.DAY_OF_MONTH);</span>
<span class="nc bnc" id="L4219" title="All 2 branches missed.">                    Flags flags = (c == DateTime.DAY_OF_MONTH_0</span>
                                   ? Flags.ZERO_PAD
                                   : Flags.NONE);
<span class="nc" id="L4222">                    sb.append(localizedMagnitude(null, i, flags, 2, l));</span>
<span class="nc" id="L4223">                    break;</span>
                }
                case DateTime.DAY_OF_YEAR:          { // 'j' (001 - 366)
<span class="nc" id="L4226">                    int i = t.get(ChronoField.DAY_OF_YEAR);</span>
<span class="nc" id="L4227">                    Flags flags = Flags.ZERO_PAD;</span>
<span class="nc" id="L4228">                    sb.append(localizedMagnitude(null, i, flags, 3, l));</span>
<span class="nc" id="L4229">                    break;</span>
                }
                case DateTime.MONTH:                { // 'm' (01 - 12)
<span class="nc" id="L4232">                    int i = t.get(ChronoField.MONTH_OF_YEAR);</span>
<span class="nc" id="L4233">                    Flags flags = Flags.ZERO_PAD;</span>
<span class="nc" id="L4234">                    sb.append(localizedMagnitude(null, i, flags, 2, l));</span>
<span class="nc" id="L4235">                    break;</span>
                }

                // Composites
                case DateTime.TIME:         // 'T' (24 hour hh:mm:ss - %tH:%tM:%tS)
                case DateTime.TIME_24_HOUR:    { // 'R' (hh:mm same as %H:%M)
<span class="nc" id="L4241">                    char sep = ':';</span>
<span class="nc" id="L4242">                    print(sb, t, DateTime.HOUR_OF_DAY_0, l).append(sep);</span>
<span class="nc" id="L4243">                    print(sb, t, DateTime.MINUTE, l);</span>
<span class="nc bnc" id="L4244" title="All 2 branches missed.">                    if (c == DateTime.TIME) {</span>
<span class="nc" id="L4245">                        sb.append(sep);</span>
<span class="nc" id="L4246">                        print(sb, t, DateTime.SECOND, l);</span>
                    }
                    break;
                }
                case DateTime.TIME_12_HOUR:    { // 'r' (hh:mm:ss [AP]M)
<span class="nc" id="L4251">                    char sep = ':';</span>
<span class="nc" id="L4252">                    print(sb, t, DateTime.HOUR_0, l).append(sep);</span>
<span class="nc" id="L4253">                    print(sb, t, DateTime.MINUTE, l).append(sep);</span>
<span class="nc" id="L4254">                    print(sb, t, DateTime.SECOND, l).append(' ');</span>
                    // this may be in wrong place for some locales
<span class="nc" id="L4256">                    StringBuilder tsb = new StringBuilder();</span>
<span class="nc" id="L4257">                    print(tsb, t, DateTime.AM_PM, l);</span>
<span class="nc bnc" id="L4258" title="All 2 branches missed.">                    sb.append(tsb.toString().toUpperCase(l != null ? l : Locale.US));</span>
<span class="nc" id="L4259">                    break;</span>
                }
                case DateTime.DATE_TIME:    { // 'c' (Sat Nov 04 12:02:33 EST 1999)
<span class="nc" id="L4262">                    char sep = ' ';</span>
<span class="nc" id="L4263">                    print(sb, t, DateTime.NAME_OF_DAY_ABBREV, l).append(sep);</span>
<span class="nc" id="L4264">                    print(sb, t, DateTime.NAME_OF_MONTH_ABBREV, l).append(sep);</span>
<span class="nc" id="L4265">                    print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);</span>
<span class="nc" id="L4266">                    print(sb, t, DateTime.TIME, l).append(sep);</span>
<span class="nc" id="L4267">                    print(sb, t, DateTime.ZONE, l).append(sep);</span>
<span class="nc" id="L4268">                    print(sb, t, DateTime.YEAR_4, l);</span>
<span class="nc" id="L4269">                    break;</span>
                }
                case DateTime.DATE:            { // 'D' (mm/dd/yy)
<span class="nc" id="L4272">                    char sep = '/';</span>
<span class="nc" id="L4273">                    print(sb, t, DateTime.MONTH, l).append(sep);</span>
<span class="nc" id="L4274">                    print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);</span>
<span class="nc" id="L4275">                    print(sb, t, DateTime.YEAR_2, l);</span>
<span class="nc" id="L4276">                    break;</span>
                }
                case DateTime.ISO_STANDARD_DATE: { // 'F' (%Y-%m-%d)
<span class="nc" id="L4279">                    char sep = '-';</span>
<span class="nc" id="L4280">                    print(sb, t, DateTime.YEAR_4, l).append(sep);</span>
<span class="nc" id="L4281">                    print(sb, t, DateTime.MONTH, l).append(sep);</span>
<span class="nc" id="L4282">                    print(sb, t, DateTime.DAY_OF_MONTH_0, l);</span>
<span class="nc" id="L4283">                    break;</span>
                }
                default:
<span class="nc bnc" id="L4286" title="All 2 branches missed.">                    assert false;</span>
                }
<span class="nc" id="L4288">            } catch (DateTimeException x) {</span>
<span class="nc" id="L4289">                throw new IllegalFormatConversionException(c, t.getClass());</span>
<span class="nc" id="L4290">            }</span>
<span class="nc" id="L4291">            return sb;</span>
        }

        // -- Methods to support throwing exceptions --

        private void failMismatch(Flags f, char c) {
<span class="fc" id="L4297">            String fs = f.toString();</span>
<span class="fc" id="L4298">            throw new FormatFlagsConversionMismatchException(fs, c);</span>
        }

        private void failConversion(char c, Object arg) {
<span class="fc" id="L4302">            throw new IllegalFormatConversionException(c, arg.getClass());</span>
        }

        private char getZero(Locale l) {
<span class="pc bpc" id="L4306" title="1 of 4 branches missed.">            if ((l != null) &amp;&amp;  !l.equals(locale())) {</span>
<span class="nc" id="L4307">                DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(l);</span>
<span class="nc" id="L4308">                return dfs.getZeroDigit();</span>
            }
<span class="fc" id="L4310">            return zero;</span>
        }

        private StringBuilder
            localizedMagnitude(StringBuilder sb, long value, Flags f,
                               int width, Locale l)
        {
<span class="fc" id="L4317">            char[] va = Long.toString(value, 10).toCharArray();</span>
<span class="fc" id="L4318">            return localizedMagnitude(sb, va, f, width, l);</span>
        }

        private StringBuilder
            localizedMagnitude(StringBuilder sb, char[] value, Flags f,
                               int width, Locale l)
        {
<span class="fc bfc" id="L4325" title="All 2 branches covered.">            if (sb == null)</span>
<span class="fc" id="L4326">                sb = new StringBuilder();</span>
<span class="fc" id="L4327">            int begin = sb.length();</span>

<span class="fc" id="L4329">            char zero = getZero(l);</span>

            // determine localized grouping separator and size
<span class="fc" id="L4332">            char grpSep = '\0';</span>
<span class="fc" id="L4333">            int  grpSize = -1;</span>
<span class="fc" id="L4334">            char decSep = '\0';</span>

<span class="fc" id="L4336">            int len = value.length;</span>
<span class="fc" id="L4337">            int dot = len;</span>
<span class="fc bfc" id="L4338" title="All 2 branches covered.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="fc bfc" id="L4339" title="All 2 branches covered.">                if (value[j] == '.') {</span>
<span class="fc" id="L4340">                    dot = j;</span>
<span class="fc" id="L4341">                    break;</span>
                }
            }

<span class="fc bfc" id="L4345" title="All 2 branches covered.">            if (dot &lt; len) {</span>
<span class="pc bpc" id="L4346" title="1 of 4 branches missed.">                if (l == null || l.equals(Locale.US)) {</span>
<span class="fc" id="L4347">                    decSep  = '.';</span>
                } else {
<span class="fc" id="L4349">                    DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(l);</span>
<span class="fc" id="L4350">                    decSep  = dfs.getDecimalSeparator();</span>
                }
            }

<span class="fc bfc" id="L4354" title="All 2 branches covered.">            if (f.contains(Flags.GROUP)) {</span>
<span class="pc bpc" id="L4355" title="1 of 4 branches missed.">                if (l == null || l.equals(Locale.US)) {</span>
<span class="fc" id="L4356">                    grpSep = ',';</span>
<span class="fc" id="L4357">                    grpSize = 3;</span>
                } else {
<span class="fc" id="L4359">                    DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(l);</span>
<span class="fc" id="L4360">                    grpSep = dfs.getGroupingSeparator();</span>
<span class="fc" id="L4361">                    DecimalFormat df = (DecimalFormat) NumberFormat.getIntegerInstance(l);</span>
<span class="fc" id="L4362">                    grpSize = df.getGroupingSize();</span>
                }
            }

            // localize the digits inserting group separators as necessary
<span class="fc bfc" id="L4367" title="All 2 branches covered.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="fc bfc" id="L4368" title="All 2 branches covered.">                if (j == dot) {</span>
<span class="fc" id="L4369">                    sb.append(decSep);</span>
                    // no more group separators after the decimal separator
<span class="fc" id="L4371">                    grpSep = '\0';</span>
<span class="fc" id="L4372">                    continue;</span>
                }

<span class="fc" id="L4375">                char c = value[j];</span>
<span class="fc" id="L4376">                sb.append((char) ((c - '0') + zero));</span>
<span class="fc bfc" id="L4377" title="All 6 branches covered.">                if (grpSep != '\0' &amp;&amp; j != dot - 1 &amp;&amp; ((dot - j) % grpSize == 1))</span>
<span class="fc" id="L4378">                    sb.append(grpSep);</span>
            }

            // apply zero padding
<span class="fc" id="L4382">            len = sb.length();</span>
<span class="fc bfc" id="L4383" title="All 4 branches covered.">            if (width != -1 &amp;&amp; f.contains(Flags.ZERO_PAD))</span>
<span class="fc bfc" id="L4384" title="All 2 branches covered.">                for (int k = 0; k &lt; width - len; k++)</span>
<span class="fc" id="L4385">                    sb.insert(begin, zero);</span>

<span class="fc" id="L4387">            return sb;</span>
        }
    }

    private static class Flags {
        private int flags;

<span class="fc" id="L4394">        static final Flags NONE          = new Flags(0);      // ''</span>

        // duplicate declarations from Formattable.java
<span class="fc" id="L4397">        static final Flags LEFT_JUSTIFY  = new Flags(1&lt;&lt;0);   // '-'</span>
<span class="fc" id="L4398">        static final Flags UPPERCASE     = new Flags(1&lt;&lt;1);   // '^'</span>
<span class="fc" id="L4399">        static final Flags ALTERNATE     = new Flags(1&lt;&lt;2);   // '#'</span>

        // numerics
<span class="fc" id="L4402">        static final Flags PLUS          = new Flags(1&lt;&lt;3);   // '+'</span>
<span class="fc" id="L4403">        static final Flags LEADING_SPACE = new Flags(1&lt;&lt;4);   // ' '</span>
<span class="fc" id="L4404">        static final Flags ZERO_PAD      = new Flags(1&lt;&lt;5);   // '0'</span>
<span class="fc" id="L4405">        static final Flags GROUP         = new Flags(1&lt;&lt;6);   // ','</span>
<span class="fc" id="L4406">        static final Flags PARENTHESES   = new Flags(1&lt;&lt;7);   // '('</span>

        // indexing
<span class="fc" id="L4409">        static final Flags PREVIOUS      = new Flags(1&lt;&lt;8);   // '&lt;'</span>

<span class="fc" id="L4411">        private Flags(int f) {</span>
<span class="fc" id="L4412">            flags = f;</span>
<span class="fc" id="L4413">        }</span>

        public int valueOf() {
<span class="fc" id="L4416">            return flags;</span>
        }

        public boolean contains(Flags f) {
<span class="fc bfc" id="L4420" title="All 2 branches covered.">            return (flags &amp; f.valueOf()) == f.valueOf();</span>
        }

        public Flags dup() {
<span class="fc" id="L4424">            return new Flags(flags);</span>
        }

        private Flags add(Flags f) {
<span class="fc" id="L4428">            flags |= f.valueOf();</span>
<span class="fc" id="L4429">            return this;</span>
        }

        public Flags remove(Flags f) {
<span class="fc" id="L4433">            flags &amp;= ~f.valueOf();</span>
<span class="fc" id="L4434">            return this;</span>
        }

        public static Flags parse(String s) {
<span class="fc" id="L4438">            char[] ca = s.toCharArray();</span>
<span class="fc" id="L4439">            Flags f = new Flags(0);</span>
<span class="fc bfc" id="L4440" title="All 2 branches covered.">            for (int i = 0; i &lt; ca.length; i++) {</span>
<span class="fc" id="L4441">                Flags v = parse(ca[i]);</span>
<span class="fc bfc" id="L4442" title="All 2 branches covered.">                if (f.contains(v))</span>
<span class="fc" id="L4443">                    throw new DuplicateFormatFlagsException(v.toString());</span>
<span class="fc" id="L4444">                f.add(v);</span>
            }
<span class="fc" id="L4446">            return f;</span>
        }

        // parse those flags which may be provided by users
        private static Flags parse(char c) {
<span class="pc bpc" id="L4451" title="1 of 9 branches missed.">            switch (c) {</span>
<span class="fc" id="L4452">            case '-': return LEFT_JUSTIFY;</span>
<span class="fc" id="L4453">            case '#': return ALTERNATE;</span>
<span class="fc" id="L4454">            case '+': return PLUS;</span>
<span class="fc" id="L4455">            case ' ': return LEADING_SPACE;</span>
<span class="fc" id="L4456">            case '0': return ZERO_PAD;</span>
<span class="fc" id="L4457">            case ',': return GROUP;</span>
<span class="fc" id="L4458">            case '(': return PARENTHESES;</span>
<span class="fc" id="L4459">            case '&lt;': return PREVIOUS;</span>
            default:
<span class="nc" id="L4461">                throw new UnknownFormatFlagsException(String.valueOf(c));</span>
            }
        }

        // Returns a string representation of the current {@code Flags}.
        public static String toString(Flags f) {
<span class="nc" id="L4467">            return f.toString();</span>
        }

        public String toString() {
<span class="fc" id="L4471">            StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L4472" title="All 2 branches covered.">            if (contains(LEFT_JUSTIFY))  sb.append('-');</span>
<span class="pc bpc" id="L4473" title="1 of 2 branches missed.">            if (contains(UPPERCASE))     sb.append('^');</span>
<span class="fc bfc" id="L4474" title="All 2 branches covered.">            if (contains(ALTERNATE))     sb.append('#');</span>
<span class="fc bfc" id="L4475" title="All 2 branches covered.">            if (contains(PLUS))          sb.append('+');</span>
<span class="fc bfc" id="L4476" title="All 2 branches covered.">            if (contains(LEADING_SPACE)) sb.append(' ');</span>
<span class="fc bfc" id="L4477" title="All 2 branches covered.">            if (contains(ZERO_PAD))      sb.append('0');</span>
<span class="fc bfc" id="L4478" title="All 2 branches covered.">            if (contains(GROUP))         sb.append(',');</span>
<span class="fc bfc" id="L4479" title="All 2 branches covered.">            if (contains(PARENTHESES))   sb.append('(');</span>
<span class="fc bfc" id="L4480" title="All 2 branches covered.">            if (contains(PREVIOUS))      sb.append('&lt;');</span>
<span class="fc" id="L4481">            return sb.toString();</span>
        }
    }

<span class="nc" id="L4485">    private static class Conversion {</span>
        // Byte, Short, Integer, Long, BigInteger
        // (and associated primitives due to autoboxing)
        static final char DECIMAL_INTEGER     = 'd';
        static final char OCTAL_INTEGER       = 'o';
        static final char HEXADECIMAL_INTEGER = 'x';
        static final char HEXADECIMAL_INTEGER_UPPER = 'X';

        // Float, Double, BigDecimal
        // (and associated primitives due to autoboxing)
        static final char SCIENTIFIC          = 'e';
        static final char SCIENTIFIC_UPPER    = 'E';
        static final char GENERAL             = 'g';
        static final char GENERAL_UPPER       = 'G';
        static final char DECIMAL_FLOAT       = 'f';
        static final char HEXADECIMAL_FLOAT   = 'a';
        static final char HEXADECIMAL_FLOAT_UPPER = 'A';

        // Character, Byte, Short, Integer
        // (and associated primitives due to autoboxing)
        static final char CHARACTER           = 'c';
        static final char CHARACTER_UPPER     = 'C';

        // java.util.Date, java.util.Calendar, long
        static final char DATE_TIME           = 't';
        static final char DATE_TIME_UPPER     = 'T';

        // if (arg.TYPE != boolean) return boolean
        // if (arg != null) return true; else return false;
        static final char BOOLEAN             = 'b';
        static final char BOOLEAN_UPPER       = 'B';
        // if (arg instanceof Formattable) arg.formatTo()
        // else arg.toString();
        static final char STRING              = 's';
        static final char STRING_UPPER        = 'S';
        // arg.hashCode()
        static final char HASHCODE            = 'h';
        static final char HASHCODE_UPPER      = 'H';

        static final char LINE_SEPARATOR      = 'n';
        static final char PERCENT_SIGN        = '%';

        static boolean isValid(char c) {
<span class="fc bfc" id="L4528" title="All 10 branches covered.">            return (isGeneral(c) || isInteger(c) || isFloat(c) || isText(c)</span>
<span class="fc bfc" id="L4529" title="All 2 branches covered.">                    || c == 't' || isCharacter(c));</span>
        }

        // Returns true iff the Conversion is applicable to all objects.
        static boolean isGeneral(char c) {
<span class="fc bfc" id="L4534" title="All 2 branches covered.">            switch (c) {</span>
            case BOOLEAN:
            case BOOLEAN_UPPER:
            case STRING:
            case STRING_UPPER:
            case HASHCODE:
            case HASHCODE_UPPER:
<span class="fc" id="L4541">                return true;</span>
            default:
<span class="fc" id="L4543">                return false;</span>
            }
        }

        // Returns true iff the Conversion is applicable to character.
        static boolean isCharacter(char c) {
<span class="fc bfc" id="L4549" title="All 2 branches covered.">            switch (c) {</span>
            case CHARACTER:
            case CHARACTER_UPPER:
<span class="fc" id="L4552">                return true;</span>
            default:
<span class="fc" id="L4554">                return false;</span>
            }
        }

        // Returns true iff the Conversion is an integer type.
        static boolean isInteger(char c) {
<span class="fc bfc" id="L4560" title="All 2 branches covered.">            switch (c) {</span>
            case DECIMAL_INTEGER:
            case OCTAL_INTEGER:
            case HEXADECIMAL_INTEGER:
            case HEXADECIMAL_INTEGER_UPPER:
<span class="fc" id="L4565">                return true;</span>
            default:
<span class="fc" id="L4567">                return false;</span>
            }
        }

        // Returns true iff the Conversion is a floating-point type.
        static boolean isFloat(char c) {
<span class="fc bfc" id="L4573" title="All 2 branches covered.">            switch (c) {</span>
            case SCIENTIFIC:
            case SCIENTIFIC_UPPER:
            case GENERAL:
            case GENERAL_UPPER:
            case DECIMAL_FLOAT:
            case HEXADECIMAL_FLOAT:
            case HEXADECIMAL_FLOAT_UPPER:
<span class="fc" id="L4581">                return true;</span>
            default:
<span class="fc" id="L4583">                return false;</span>
            }
        }

        // Returns true iff the Conversion does not require an argument
        static boolean isText(char c) {
<span class="fc bfc" id="L4589" title="All 2 branches covered.">            switch (c) {</span>
            case LINE_SEPARATOR:
            case PERCENT_SIGN:
<span class="fc" id="L4592">                return true;</span>
            default:
<span class="fc" id="L4594">                return false;</span>
            }
        }
    }

<span class="nc" id="L4599">    private static class DateTime {</span>
        static final char HOUR_OF_DAY_0 = 'H'; // (00 - 23)
        static final char HOUR_0        = 'I'; // (01 - 12)
        static final char HOUR_OF_DAY   = 'k'; // (0 - 23) -- like H
        static final char HOUR          = 'l'; // (1 - 12) -- like I
        static final char MINUTE        = 'M'; // (00 - 59)
        static final char NANOSECOND    = 'N'; // (000000000 - 999999999)
        static final char MILLISECOND   = 'L'; // jdk, not in gnu (000 - 999)
        static final char MILLISECOND_SINCE_EPOCH = 'Q'; // (0 - 99...?)
        static final char AM_PM         = 'p'; // (am or pm)
        static final char SECONDS_SINCE_EPOCH = 's'; // (0 - 99...?)
        static final char SECOND        = 'S'; // (00 - 60 - leap second)
        static final char TIME          = 'T'; // (24 hour hh:mm:ss)
        static final char ZONE_NUMERIC  = 'z'; // (-1200 - +1200) - ls minus?
        static final char ZONE          = 'Z'; // (symbol)

        // Date
        static final char NAME_OF_DAY_ABBREV    = 'a'; // 'a'
        static final char NAME_OF_DAY           = 'A'; // 'A'
        static final char NAME_OF_MONTH_ABBREV  = 'b'; // 'b'
        static final char NAME_OF_MONTH         = 'B'; // 'B'
        static final char CENTURY               = 'C'; // (00 - 99)
        static final char DAY_OF_MONTH_0        = 'd'; // (01 - 31)
        static final char DAY_OF_MONTH          = 'e'; // (1 - 31) -- like d
// *    static final char ISO_WEEK_OF_YEAR_2    = 'g'; // cross %y %V
// *    static final char ISO_WEEK_OF_YEAR_4    = 'G'; // cross %Y %V
        static final char NAME_OF_MONTH_ABBREV_X  = 'h'; // -- same b
        static final char DAY_OF_YEAR           = 'j'; // (001 - 366)
        static final char MONTH                 = 'm'; // (01 - 12)
// *    static final char DAY_OF_WEEK_1         = 'u'; // (1 - 7) Monday
// *    static final char WEEK_OF_YEAR_SUNDAY   = 'U'; // (0 - 53) Sunday+
// *    static final char WEEK_OF_YEAR_MONDAY_01 = 'V'; // (01 - 53) Monday+
// *    static final char DAY_OF_WEEK_0         = 'w'; // (0 - 6) Sunday
// *    static final char WEEK_OF_YEAR_MONDAY   = 'W'; // (00 - 53) Monday
        static final char YEAR_2                = 'y'; // (00 - 99)
        static final char YEAR_4                = 'Y'; // (0000 - 9999)

        // Composites
        static final char TIME_12_HOUR  = 'r'; // (hh:mm:ss [AP]M)
        static final char TIME_24_HOUR  = 'R'; // (hh:mm same as %H:%M)
// *    static final char LOCALE_TIME   = 'X'; // (%H:%M:%S) - parse format?
        static final char DATE_TIME             = 'c';
                                            // (Sat Nov 04 12:02:33 EST 1999)
        static final char DATE                  = 'D'; // (mm/dd/yy)
        static final char ISO_STANDARD_DATE     = 'F'; // (%Y-%m-%d)
// *    static final char LOCALE_DATE           = 'x'; // (mm/dd/yy)

        static boolean isValid(char c) {
<span class="fc bfc" id="L4647" title="All 2 branches covered.">            switch (c) {</span>
            case HOUR_OF_DAY_0:
            case HOUR_0:
            case HOUR_OF_DAY:
            case HOUR:
            case MINUTE:
            case NANOSECOND:
            case MILLISECOND:
            case MILLISECOND_SINCE_EPOCH:
            case AM_PM:
            case SECONDS_SINCE_EPOCH:
            case SECOND:
            case TIME:
            case ZONE_NUMERIC:
            case ZONE:

            // Date
            case NAME_OF_DAY_ABBREV:
            case NAME_OF_DAY:
            case NAME_OF_MONTH_ABBREV:
            case NAME_OF_MONTH:
            case CENTURY:
            case DAY_OF_MONTH_0:
            case DAY_OF_MONTH:
// *        case ISO_WEEK_OF_YEAR_2:
// *        case ISO_WEEK_OF_YEAR_4:
            case NAME_OF_MONTH_ABBREV_X:
            case DAY_OF_YEAR:
            case MONTH:
// *        case DAY_OF_WEEK_1:
// *        case WEEK_OF_YEAR_SUNDAY:
// *        case WEEK_OF_YEAR_MONDAY_01:
// *        case DAY_OF_WEEK_0:
// *        case WEEK_OF_YEAR_MONDAY:
            case YEAR_2:
            case YEAR_4:

            // Composites
            case TIME_12_HOUR:
            case TIME_24_HOUR:
// *        case LOCALE_TIME:
            case DATE_TIME:
            case DATE:
            case ISO_STANDARD_DATE:
// *        case LOCALE_DATE:
<span class="fc" id="L4692">                return true;</span>
            default:
<span class="fc" id="L4694">                return false;</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>