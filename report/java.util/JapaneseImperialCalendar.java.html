<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JapaneseImperialCalendar.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">JapaneseImperialCalendar.java</span></div><h1>JapaneseImperialCalendar.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.io.IOException;
import java.io.ObjectInputStream;
import sun.util.locale.provider.CalendarDataUtility;
import sun.util.calendar.BaseCalendar;
import sun.util.calendar.CalendarDate;
import sun.util.calendar.CalendarSystem;
import sun.util.calendar.CalendarUtils;
import sun.util.calendar.Era;
import sun.util.calendar.Gregorian;
import sun.util.calendar.LocalGregorianCalendar;
import sun.util.calendar.ZoneInfo;

/**
 * &lt;code&gt;JapaneseImperialCalendar&lt;/code&gt; implements a Japanese
 * calendar system in which the imperial era-based year numbering is
 * supported from the Meiji era. The following are the eras supported
 * by this calendar system.
 * &lt;pre&gt;&lt;tt&gt;
 * ERA value   Era name    Since (in Gregorian)
 * ------------------------------------------------------
 *     0       N/A         N/A
 *     1       Meiji       1868-01-01 midnight local time
 *     2       Taisho      1912-07-30 midnight local time
 *     3       Showa       1926-12-25 midnight local time
 *     4       Heisei      1989-01-08 midnight local time
 * ------------------------------------------------------
 * &lt;/tt&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;code&gt;ERA&lt;/code&gt; value 0 specifies the years before Meiji and
 * the Gregorian year values are used. Unlike {@link
 * GregorianCalendar}, the Julian to Gregorian transition is not
 * supported because it doesn't make any sense to the Japanese
 * calendar systems used before Meiji. To represent the years before
 * Gregorian year 1, 0 and negative values are used. The Japanese
 * Imperial rescripts and government decrees don't specify how to deal
 * with time differences for applying the era transitions. This
 * calendar implementation assumes local time for all transitions.
 *
 * @author Masayoshi Okutsu
 * @since 1.6
 */
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">class JapaneseImperialCalendar extends Calendar {</span>
    /*
     * Implementation Notes
     *
     * This implementation uses
     * sun.util.calendar.LocalGregorianCalendar to perform most of the
     * calendar calculations. LocalGregorianCalendar is configurable
     * and reads &lt;JRE_HOME&gt;/lib/calendars.properties at the start-up.
     */

    /**
     * The ERA constant designating the era before Meiji.
     */
    public static final int BEFORE_MEIJI = 0;

    /**
     * The ERA constant designating the Meiji era.
     */
    public static final int MEIJI = 1;

    /**
     * The ERA constant designating the Taisho era.
     */
    public static final int TAISHO = 2;

    /**
     * The ERA constant designating the Showa era.
     */
    public static final int SHOWA = 3;

    /**
     * The ERA constant designating the Heisei era.
     */
    public static final int HEISEI = 4;

    private static final int EPOCH_OFFSET   = 719163; // Fixed date of January 1, 1970 (Gregorian)
    private static final int EPOCH_YEAR     = 1970;

    // Useful millisecond constants.  Although ONE_DAY and ONE_WEEK can fit
    // into ints, they must be longs in order to prevent arithmetic overflow
    // when performing (bug 4173516).
    private static final int  ONE_SECOND = 1000;
    private static final int  ONE_MINUTE = 60*ONE_SECOND;
    private static final int  ONE_HOUR   = 60*ONE_MINUTE;
    private static final long ONE_DAY    = 24*ONE_HOUR;
    private static final long ONE_WEEK   = 7*ONE_DAY;

    // Reference to the sun.util.calendar.LocalGregorianCalendar instance (singleton).
<span class="fc" id="L117">    private static final LocalGregorianCalendar jcal</span>
<span class="fc" id="L118">        = (LocalGregorianCalendar) CalendarSystem.forName(&quot;japanese&quot;);</span>

    // Gregorian calendar instance. This is required because era
    // transition dates are given in Gregorian dates.
<span class="fc" id="L122">    private static final Gregorian gcal = CalendarSystem.getGregorianCalendar();</span>

    // The Era instance representing &quot;before Meiji&quot;.
<span class="fc" id="L125">    private static final Era BEFORE_MEIJI_ERA = new Era(&quot;BeforeMeiji&quot;, &quot;BM&quot;, Long.MIN_VALUE, false);</span>

    // Imperial eras. The sun.util.calendar.LocalGregorianCalendar
    // doesn't have an Era representing before Meiji, which is
    // inconvenient for a Calendar. So, era[0] is a reference to
    // BEFORE_MEIJI_ERA.
    private static final Era[] eras;

    // Fixed date of the first date of each era.
    private static final long[] sinceFixedDates;

    /*
     * &lt;pre&gt;
     *                                 Greatest       Least
     * Field name             Minimum   Minimum     Maximum     Maximum
     * ----------             -------   -------     -------     -------
     * ERA                          0         0           1           1
     * YEAR                -292275055         1           ?           ?
     * MONTH                        0         0          11          11
     * WEEK_OF_YEAR                 1         1          52*         53
     * WEEK_OF_MONTH                0         0           4*          6
     * DAY_OF_MONTH                 1         1          28*         31
     * DAY_OF_YEAR                  1         1         365*        366
     * DAY_OF_WEEK                  1         1           7           7
     * DAY_OF_WEEK_IN_MONTH        -1        -1           4*          6
     * AM_PM                        0         0           1           1
     * HOUR                         0         0          11          11
     * HOUR_OF_DAY                  0         0          23          23
     * MINUTE                       0         0          59          59
     * SECOND                       0         0          59          59
     * MILLISECOND                  0         0         999         999
     * ZONE_OFFSET             -13:00    -13:00       14:00       14:00
     * DST_OFFSET                0:00      0:00        0:20        2:00
     * &lt;/pre&gt;
     * *: depends on eras
     */
<span class="fc" id="L161">    static final int MIN_VALUES[] = {</span>
        0,              // ERA
        -292275055,     // YEAR
        JANUARY,        // MONTH
        1,              // WEEK_OF_YEAR
        0,              // WEEK_OF_MONTH
        1,              // DAY_OF_MONTH
        1,              // DAY_OF_YEAR
        SUNDAY,         // DAY_OF_WEEK
        1,              // DAY_OF_WEEK_IN_MONTH
        AM,             // AM_PM
        0,              // HOUR
        0,              // HOUR_OF_DAY
        0,              // MINUTE
        0,              // SECOND
        0,              // MILLISECOND
        -13*ONE_HOUR,   // ZONE_OFFSET (UNIX compatibility)
        0               // DST_OFFSET
    };
<span class="fc" id="L180">    static final int LEAST_MAX_VALUES[] = {</span>
        0,              // ERA (initialized later)
        0,              // YEAR (initialized later)
        JANUARY,        // MONTH (Showa 64 ended in January.)
        0,              // WEEK_OF_YEAR (Showa 1 has only 6 days which could be 0 weeks.)
        4,              // WEEK_OF_MONTH
        28,             // DAY_OF_MONTH
        0,              // DAY_OF_YEAR (initialized later)
        SATURDAY,       // DAY_OF_WEEK
        4,              // DAY_OF_WEEK_IN
        PM,             // AM_PM
        11,             // HOUR
        23,             // HOUR_OF_DAY
        59,             // MINUTE
        59,             // SECOND
        999,            // MILLISECOND
        14*ONE_HOUR,    // ZONE_OFFSET
        20*ONE_MINUTE   // DST_OFFSET (historical least maximum)
    };
<span class="fc" id="L199">    static final int MAX_VALUES[] = {</span>
        0,              // ERA
        292278994,      // YEAR
        DECEMBER,       // MONTH
        53,             // WEEK_OF_YEAR
        6,              // WEEK_OF_MONTH
        31,             // DAY_OF_MONTH
        366,            // DAY_OF_YEAR
        SATURDAY,       // DAY_OF_WEEK
        6,              // DAY_OF_WEEK_IN
        PM,             // AM_PM
        11,             // HOUR
        23,             // HOUR_OF_DAY
        59,             // MINUTE
        59,             // SECOND
        999,            // MILLISECOND
        14*ONE_HOUR,    // ZONE_OFFSET
        2*ONE_HOUR      // DST_OFFSET (double summer time)
    };

    // Proclaim serialization compatibility with JDK 1.6
    private static final long serialVersionUID = -3364572813905467929L;

    static {
<span class="fc" id="L223">        Era[] es = jcal.getEras();</span>
<span class="fc" id="L224">        int length = es.length + 1;</span>
<span class="fc" id="L225">        eras = new Era[length];</span>
<span class="fc" id="L226">        sinceFixedDates = new long[length];</span>

        // eras[BEFORE_MEIJI] and sinceFixedDate[BEFORE_MEIJI] are the
        // same as Gregorian.
<span class="fc" id="L230">        int index = BEFORE_MEIJI;</span>
<span class="fc" id="L231">        sinceFixedDates[index] = gcal.getFixedDate(BEFORE_MEIJI_ERA.getSinceDate());</span>
<span class="fc" id="L232">        eras[index++] = BEFORE_MEIJI_ERA;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        for (Era e : es) {</span>
<span class="fc" id="L234">            CalendarDate d = e.getSinceDate();</span>
<span class="fc" id="L235">            sinceFixedDates[index] = gcal.getFixedDate(d);</span>
<span class="fc" id="L236">            eras[index++] = e;</span>
        }

<span class="fc" id="L239">        LEAST_MAX_VALUES[ERA] = MAX_VALUES[ERA] = eras.length - 1;</span>

        // Calculate the least maximum year and least day of Year
        // values. The following code assumes that there's at most one
        // era transition in a Gregorian year.
<span class="fc" id="L244">        int year = Integer.MAX_VALUE;</span>
<span class="fc" id="L245">        int dayOfYear = Integer.MAX_VALUE;</span>
<span class="fc" id="L246">        CalendarDate date = gcal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        for (int i = 1; i &lt; eras.length; i++) {</span>
<span class="fc" id="L248">            long fd = sinceFixedDates[i];</span>
<span class="fc" id="L249">            CalendarDate transitionDate = eras[i].getSinceDate();</span>
<span class="fc" id="L250">            date.setDate(transitionDate.getYear(), BaseCalendar.JANUARY, 1);</span>
<span class="fc" id="L251">            long fdd = gcal.getFixedDate(date);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">            if (fd != fdd) {</span>
<span class="fc" id="L253">                dayOfYear = Math.min((int)(fd - fdd) + 1, dayOfYear);</span>
            }
<span class="fc" id="L255">            date.setDate(transitionDate.getYear(), BaseCalendar.DECEMBER, 31);</span>
<span class="fc" id="L256">            fdd = gcal.getFixedDate(date);</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">            if (fd != fdd) {</span>
<span class="fc" id="L258">                dayOfYear = Math.min((int)(fdd - fd) + 1, dayOfYear);</span>
            }
<span class="fc" id="L260">            LocalGregorianCalendar.Date lgd = getCalendarDate(fd - 1);</span>
<span class="fc" id="L261">            int y = lgd.getYear();</span>
            // Unless the first year starts from January 1, the actual
            // max value could be one year short. For example, if it's
            // Showa 63 January 8, 63 is the actual max value since
            // Showa 64 January 8 doesn't exist.
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">            if (!(lgd.getMonth() == BaseCalendar.JANUARY &amp;&amp; lgd.getDayOfMonth() == 1)) {</span>
<span class="fc" id="L267">                y--;</span>
            }
<span class="fc" id="L269">            year = Math.min(y, year);</span>
        }
<span class="fc" id="L271">        LEAST_MAX_VALUES[YEAR] = year; // Max year could be smaller than this value.</span>
<span class="fc" id="L272">        LEAST_MAX_VALUES[DAY_OF_YEAR] = dayOfYear;</span>
<span class="fc" id="L273">    }</span>

    /**
     * jdate always has a sun.util.calendar.LocalGregorianCalendar.Date instance to
     * avoid overhead of creating it for each calculation.
     */
    private transient LocalGregorianCalendar.Date jdate;

    /**
     * Temporary int[2] to get time zone offsets. zoneOffsets[0] gets
     * the GMT offset value and zoneOffsets[1] gets the daylight saving
     * value.
     */
    private transient int[] zoneOffsets;

    /**
     * Temporary storage for saving original fields[] values in
     * non-lenient mode.
     */
    private transient int[] originalFields;

    /**
     * Constructs a &lt;code&gt;JapaneseImperialCalendar&lt;/code&gt; based on the current time
     * in the given time zone with the given locale.
     *
     * @param zone the given time zone.
     * @param aLocale the given locale.
     */
    JapaneseImperialCalendar(TimeZone zone, Locale aLocale) {
<span class="nc" id="L302">        super(zone, aLocale);</span>
<span class="nc" id="L303">        jdate = jcal.newCalendarDate(zone);</span>
<span class="nc" id="L304">        setTimeInMillis(System.currentTimeMillis());</span>
<span class="nc" id="L305">    }</span>

    /**
     * Constructs an &quot;empty&quot; {@code JapaneseImperialCalendar}.
     *
     * @param zone    the given time zone
     * @param aLocale the given locale
     * @param flag    the flag requesting an empty instance
     */
    JapaneseImperialCalendar(TimeZone zone, Locale aLocale, boolean flag) {
<span class="fc" id="L315">        super(zone, aLocale);</span>
<span class="fc" id="L316">        jdate = jcal.newCalendarDate(zone);</span>
<span class="fc" id="L317">    }</span>

    /**
     * Returns {@code &quot;japanese&quot;} as the calendar type of this {@code
     * JapaneseImperialCalendar}.
     *
     * @return {@code &quot;japanese&quot;}
     */
    @Override
    public String getCalendarType() {
<span class="fc" id="L327">        return &quot;japanese&quot;;</span>
    }

    /**
     * Compares this &lt;code&gt;JapaneseImperialCalendar&lt;/code&gt; to the specified
     * &lt;code&gt;Object&lt;/code&gt;. The result is &lt;code&gt;true&lt;/code&gt; if and
     * only if the argument is a &lt;code&gt;JapaneseImperialCalendar&lt;/code&gt; object
     * that represents the same time value (millisecond offset from
     * the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;) under the same
     * &lt;code&gt;Calendar&lt;/code&gt; parameters.
     *
     * @param obj the object to compare with.
     * @return &lt;code&gt;true&lt;/code&gt; if this object is equal to &lt;code&gt;obj&lt;/code&gt;;
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see Calendar#compareTo(Calendar)
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L344" title="All 2 branches missed.">        return obj instanceof JapaneseImperialCalendar &amp;&amp;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            super.equals(obj);</span>
    }

    /**
     * Generates the hash code for this
     * &lt;code&gt;JapaneseImperialCalendar&lt;/code&gt; object.
     */
    public int hashCode() {
<span class="nc" id="L353">        return super.hashCode() ^ jdate.hashCode();</span>
    }

    /**
     * Adds the specified (signed) amount of time to the given calendar field,
     * based on the calendar's rules.
     *
     * &lt;p&gt;&lt;em&gt;Add rule 1&lt;/em&gt;. The value of &lt;code&gt;field&lt;/code&gt;
     * after the call minus the value of &lt;code&gt;field&lt;/code&gt; before the
     * call is &lt;code&gt;amount&lt;/code&gt;, modulo any overflow that has occurred in
     * &lt;code&gt;field&lt;/code&gt;. Overflow occurs when a field value exceeds its
     * range and, as a result, the next larger field is incremented or
     * decremented and the field value is adjusted back into its range.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;em&gt;Add rule 2&lt;/em&gt;. If a smaller field is expected to be
     * invariant, but it is impossible for it to be equal to its
     * prior value because of changes in its minimum or maximum after
     * &lt;code&gt;field&lt;/code&gt; is changed, then its value is adjusted to be as close
     * as possible to its expected value. A smaller field represents a
     * smaller unit of time. &lt;code&gt;HOUR&lt;/code&gt; is a smaller field than
     * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;. No adjustment is made to smaller fields
     * that are not expected to be invariant. The calendar system
     * determines what fields are expected to be invariant.&lt;/p&gt;
     *
     * @param field the calendar field.
     * @param amount the amount of date or time to be added to the field.
     * @exception IllegalArgumentException if &lt;code&gt;field&lt;/code&gt; is
     * &lt;code&gt;ZONE_OFFSET&lt;/code&gt;, &lt;code&gt;DST_OFFSET&lt;/code&gt;, or unknown,
     * or if any calendar fields have out-of-range values in
     * non-lenient mode.
     */
    public void add(int field, int amount) {
        // If amount == 0, do nothing even the given field is out of
        // range. This is tested by JCK.
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (amount == 0) {</span>
<span class="nc" id="L388">            return;   // Do nothing!</span>
        }

<span class="pc bpc" id="L391" title="2 of 4 branches missed.">        if (field &lt; 0 || field &gt;= ZONE_OFFSET) {</span>
<span class="nc" id="L392">            throw new IllegalArgumentException();</span>
        }

        // Sync the time and calendar fields.
<span class="fc" id="L396">        complete();</span>

<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (field == YEAR) {</span>
<span class="fc" id="L399">            LocalGregorianCalendar.Date d = (LocalGregorianCalendar.Date) jdate.clone();</span>
<span class="fc" id="L400">            d.addYear(amount);</span>
<span class="fc" id="L401">            pinDayOfMonth(d);</span>
<span class="fc" id="L402">            set(ERA, getEraIndex(d));</span>
<span class="fc" id="L403">            set(YEAR, d.getYear());</span>
<span class="fc" id="L404">            set(MONTH, d.getMonth() - 1);</span>
<span class="fc" id="L405">            set(DAY_OF_MONTH, d.getDayOfMonth());</span>
<span class="pc bnc" id="L406" title="All 2 branches missed.">        } else if (field == MONTH) {</span>
<span class="nc" id="L407">            LocalGregorianCalendar.Date d = (LocalGregorianCalendar.Date) jdate.clone();</span>
<span class="nc" id="L408">            d.addMonth(amount);</span>
<span class="nc" id="L409">            pinDayOfMonth(d);</span>
<span class="nc" id="L410">            set(ERA, getEraIndex(d));</span>
<span class="nc" id="L411">            set(YEAR, d.getYear());</span>
<span class="nc" id="L412">            set(MONTH, d.getMonth() - 1);</span>
<span class="nc" id="L413">            set(DAY_OF_MONTH, d.getDayOfMonth());</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">        } else if (field == ERA) {</span>
<span class="nc" id="L415">            int era = internalGet(ERA) + amount;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">            if (era &lt; 0) {</span>
<span class="nc" id="L417">                era = 0;</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">            } else if (era &gt; eras.length - 1) {</span>
<span class="nc" id="L419">                era = eras.length - 1;</span>
            }
<span class="nc" id="L421">            set(ERA, era);</span>
<span class="nc" id="L422">        } else {</span>
<span class="nc" id="L423">            long delta = amount;</span>
<span class="nc" id="L424">            long timeOfDay = 0;</span>
<span class="nc bnc" id="L425" title="All 8 branches missed.">            switch (field) {</span>
            // Handle the time fields here. Convert the given
            // amount to milliseconds and call setTimeInMillis.
            case HOUR:
            case HOUR_OF_DAY:
<span class="nc" id="L430">                delta *= 60 * 60 * 1000;        // hours to milliseconds</span>
<span class="nc" id="L431">                break;</span>

            case MINUTE:
<span class="nc" id="L434">                delta *= 60 * 1000;             // minutes to milliseconds</span>
<span class="nc" id="L435">                break;</span>

            case SECOND:
<span class="nc" id="L438">                delta *= 1000;                  // seconds to milliseconds</span>
<span class="nc" id="L439">                break;</span>

            case MILLISECOND:
<span class="nc" id="L442">                break;</span>

            // Handle week, day and AM_PM fields which involves
            // time zone offset change adjustment. Convert the
            // given amount to the number of days.
            case WEEK_OF_YEAR:
            case WEEK_OF_MONTH:
            case DAY_OF_WEEK_IN_MONTH:
<span class="nc" id="L450">                delta *= 7;</span>
<span class="nc" id="L451">                break;</span>

            case DAY_OF_MONTH: // synonym of DATE
            case DAY_OF_YEAR:
            case DAY_OF_WEEK:
<span class="nc" id="L456">                break;</span>

            case AM_PM:
                // Convert the amount to the number of days (delta)
                // and +12 or -12 hours (timeOfDay).
<span class="nc" id="L461">                delta = amount / 2;</span>
<span class="nc" id="L462">                timeOfDay = 12 * (amount % 2);</span>
                break;
            }

            // The time fields don't require time zone offset change
            // adjustment.
<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (field &gt;= HOUR) {</span>
<span class="nc" id="L469">                setTimeInMillis(time + delta);</span>
<span class="nc" id="L470">                return;</span>
            }

            // The rest of the fields (week, day or AM_PM fields)
            // require time zone offset (both GMT and DST) change
            // adjustment.

            // Translate the current time to the fixed date and time
            // of the day.
<span class="nc" id="L479">            long fd = cachedFixedDate;</span>
<span class="nc" id="L480">            timeOfDay += internalGet(HOUR_OF_DAY);</span>
<span class="nc" id="L481">            timeOfDay *= 60;</span>
<span class="nc" id="L482">            timeOfDay += internalGet(MINUTE);</span>
<span class="nc" id="L483">            timeOfDay *= 60;</span>
<span class="nc" id="L484">            timeOfDay += internalGet(SECOND);</span>
<span class="nc" id="L485">            timeOfDay *= 1000;</span>
<span class="nc" id="L486">            timeOfDay += internalGet(MILLISECOND);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">            if (timeOfDay &gt;= ONE_DAY) {</span>
<span class="nc" id="L488">                fd++;</span>
<span class="nc" id="L489">                timeOfDay -= ONE_DAY;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">            } else if (timeOfDay &lt; 0) {</span>
<span class="nc" id="L491">                fd--;</span>
<span class="nc" id="L492">                timeOfDay += ONE_DAY;</span>
            }

<span class="nc" id="L495">            fd += delta; // fd is the expected fixed date after the calculation</span>
<span class="nc" id="L496">            int zoneOffset = internalGet(ZONE_OFFSET) + internalGet(DST_OFFSET);</span>
<span class="nc" id="L497">            setTimeInMillis((fd - EPOCH_OFFSET) * ONE_DAY + timeOfDay - zoneOffset);</span>
<span class="nc" id="L498">            zoneOffset -= internalGet(ZONE_OFFSET) + internalGet(DST_OFFSET);</span>
            // If the time zone offset has changed, then adjust the difference.
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (zoneOffset != 0) {</span>
<span class="nc" id="L501">                setTimeInMillis(time + zoneOffset);</span>
<span class="nc" id="L502">                long fd2 = cachedFixedDate;</span>
                // If the adjustment has changed the date, then take
                // the previous one.
<span class="nc bnc" id="L505" title="All 2 branches missed.">                if (fd2 != fd) {</span>
<span class="nc" id="L506">                    setTimeInMillis(time - zoneOffset);</span>
                }
            }
        }
<span class="fc" id="L510">    }</span>

    public void roll(int field, boolean up) {
<span class="nc bnc" id="L513" title="All 2 branches missed.">        roll(field, up ? +1 : -1);</span>
<span class="nc" id="L514">    }</span>

    /**
     * Adds a signed amount to the specified calendar field without changing larger fields.
     * A negative roll amount means to subtract from field without changing
     * larger fields. If the specified amount is 0, this method performs nothing.
     *
     * &lt;p&gt;This method calls {@link #complete()} before adding the
     * amount so that all the calendar fields are normalized. If there
     * is any calendar field having an out-of-range value in non-lenient mode, then an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     *
     * @param field the calendar field.
     * @param amount the signed amount to add to &lt;code&gt;field&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;field&lt;/code&gt; is
     * &lt;code&gt;ZONE_OFFSET&lt;/code&gt;, &lt;code&gt;DST_OFFSET&lt;/code&gt;, or unknown,
     * or if any calendar fields have out-of-range values in
     * non-lenient mode.
     * @see #roll(int,boolean)
     * @see #add(int,int)
     * @see #set(int,int)
     */
    public void roll(int field, int amount) {
        // If amount == 0, do nothing even the given field is out of
        // range. This is tested by JCK.
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (amount == 0) {</span>
<span class="nc" id="L540">            return;</span>
        }

<span class="nc bnc" id="L543" title="All 4 branches missed.">        if (field &lt; 0 || field &gt;= ZONE_OFFSET) {</span>
<span class="nc" id="L544">            throw new IllegalArgumentException();</span>
        }

        // Sync the time and calendar fields.
<span class="nc" id="L548">        complete();</span>

<span class="nc" id="L550">        int min = getMinimum(field);</span>
<span class="nc" id="L551">        int max = getMaximum(field);</span>

<span class="nc bnc" id="L553" title="All 11 branches missed.">        switch (field) {</span>
        case ERA:
        case AM_PM:
        case MINUTE:
        case SECOND:
        case MILLISECOND:
            // These fields are handled simply, since they have fixed
            // minima and maxima. Other fields are complicated, since
            // the range within they must roll varies depending on the
            // date, a time zone and the era transitions.
<span class="nc" id="L563">            break;</span>

        case HOUR:
        case HOUR_OF_DAY:
            {
<span class="nc" id="L568">                int unit = max + 1; // 12 or 24 hours</span>
<span class="nc" id="L569">                int h = internalGet(field);</span>
<span class="nc" id="L570">                int nh = (h + amount) % unit;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">                if (nh &lt; 0) {</span>
<span class="nc" id="L572">                    nh += unit;</span>
                }
<span class="nc" id="L574">                time += ONE_HOUR * (nh - h);</span>

                // The day might have changed, which could happen if
                // the daylight saving time transition brings it to
                // the next day, although it's very unlikely. But we
                // have to make sure not to change the larger fields.
<span class="nc" id="L580">                CalendarDate d = jcal.getCalendarDate(time, getZone());</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">                if (internalGet(DAY_OF_MONTH) != d.getDayOfMonth()) {</span>
<span class="nc" id="L582">                    d.setEra(jdate.getEra());</span>
<span class="nc" id="L583">                    d.setDate(internalGet(YEAR),</span>
<span class="nc" id="L584">                              internalGet(MONTH) + 1,</span>
<span class="nc" id="L585">                              internalGet(DAY_OF_MONTH));</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">                    if (field == HOUR) {</span>
<span class="nc bnc" id="L587" title="All 4 branches missed.">                        assert (internalGet(AM_PM) == PM);</span>
<span class="nc" id="L588">                        d.addHours(+12); // restore PM</span>
                    }
<span class="nc" id="L590">                    time = jcal.getTime(d);</span>
                }
<span class="nc" id="L592">                int hourOfDay = d.getHours();</span>
<span class="nc" id="L593">                internalSet(field, hourOfDay % unit);</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">                if (field == HOUR) {</span>
<span class="nc" id="L595">                    internalSet(HOUR_OF_DAY, hourOfDay);</span>
                } else {
<span class="nc" id="L597">                    internalSet(AM_PM, hourOfDay / 12);</span>
<span class="nc" id="L598">                    internalSet(HOUR, hourOfDay % 12);</span>
                }

                // Time zone offset and/or daylight saving might have changed.
<span class="nc" id="L602">                int zoneOffset = d.getZoneOffset();</span>
<span class="nc" id="L603">                int saving = d.getDaylightSaving();</span>
<span class="nc" id="L604">                internalSet(ZONE_OFFSET, zoneOffset - saving);</span>
<span class="nc" id="L605">                internalSet(DST_OFFSET, saving);</span>
<span class="nc" id="L606">                return;</span>
            }

        case YEAR:
<span class="nc" id="L610">            min = getActualMinimum(field);</span>
<span class="nc" id="L611">            max = getActualMaximum(field);</span>
<span class="nc" id="L612">            break;</span>

        case MONTH:
            // Rolling the month involves both pinning the final value to [0, 11]
            // and adjusting the DAY_OF_MONTH if necessary.  We only adjust the
            // DAY_OF_MONTH if, after updating the MONTH field, it is illegal.
            // E.g., &lt;jan31&gt;.roll(MONTH, 1) -&gt; &lt;feb28&gt; or &lt;feb29&gt;.
            {
<span class="nc bnc" id="L620" title="All 2 branches missed.">                if (!isTransitionYear(jdate.getNormalizedYear())) {</span>
<span class="nc" id="L621">                    int year = jdate.getYear();</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                    if (year == getMaximum(YEAR)) {</span>
<span class="nc" id="L623">                        CalendarDate jd = jcal.getCalendarDate(time, getZone());</span>
<span class="nc" id="L624">                        CalendarDate d = jcal.getCalendarDate(Long.MAX_VALUE, getZone());</span>
<span class="nc" id="L625">                        max = d.getMonth() - 1;</span>
<span class="nc" id="L626">                        int n = getRolledValue(internalGet(field), amount, min, max);</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">                        if (n == max) {</span>
                            // To avoid overflow, use an equivalent year.
<span class="nc" id="L629">                            jd.addYear(-400);</span>
<span class="nc" id="L630">                            jd.setMonth(n + 1);</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                            if (jd.getDayOfMonth() &gt; d.getDayOfMonth()) {</span>
<span class="nc" id="L632">                                jd.setDayOfMonth(d.getDayOfMonth());</span>
<span class="nc" id="L633">                                jcal.normalize(jd);</span>
                            }
<span class="nc bnc" id="L635" title="All 2 branches missed.">                            if (jd.getDayOfMonth() == d.getDayOfMonth()</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">                                &amp;&amp; jd.getTimeOfDay() &gt; d.getTimeOfDay()) {</span>
<span class="nc" id="L637">                                jd.setMonth(n + 1);</span>
<span class="nc" id="L638">                                jd.setDayOfMonth(d.getDayOfMonth() - 1);</span>
<span class="nc" id="L639">                                jcal.normalize(jd);</span>
                                // Month may have changed by the normalization.
<span class="nc" id="L641">                                n = jd.getMonth() - 1;</span>
                            }
<span class="nc" id="L643">                            set(DAY_OF_MONTH, jd.getDayOfMonth());</span>
                        }
<span class="nc" id="L645">                        set(MONTH, n);</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">                    } else if (year == getMinimum(YEAR)) {</span>
<span class="nc" id="L647">                        CalendarDate jd = jcal.getCalendarDate(time, getZone());</span>
<span class="nc" id="L648">                        CalendarDate d = jcal.getCalendarDate(Long.MIN_VALUE, getZone());</span>
<span class="nc" id="L649">                        min = d.getMonth() - 1;</span>
<span class="nc" id="L650">                        int n = getRolledValue(internalGet(field), amount, min, max);</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">                        if (n == min) {</span>
                            // To avoid underflow, use an equivalent year.
<span class="nc" id="L653">                            jd.addYear(+400);</span>
<span class="nc" id="L654">                            jd.setMonth(n + 1);</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">                            if (jd.getDayOfMonth() &lt; d.getDayOfMonth()) {</span>
<span class="nc" id="L656">                                jd.setDayOfMonth(d.getDayOfMonth());</span>
<span class="nc" id="L657">                                jcal.normalize(jd);</span>
                            }
<span class="nc bnc" id="L659" title="All 2 branches missed.">                            if (jd.getDayOfMonth() == d.getDayOfMonth()</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">                                &amp;&amp; jd.getTimeOfDay() &lt; d.getTimeOfDay()) {</span>
<span class="nc" id="L661">                                jd.setMonth(n + 1);</span>
<span class="nc" id="L662">                                jd.setDayOfMonth(d.getDayOfMonth() + 1);</span>
<span class="nc" id="L663">                                jcal.normalize(jd);</span>
                                // Month may have changed by the normalization.
<span class="nc" id="L665">                                n = jd.getMonth() - 1;</span>
                            }
<span class="nc" id="L667">                            set(DAY_OF_MONTH, jd.getDayOfMonth());</span>
                        }
<span class="nc" id="L669">                        set(MONTH, n);</span>
<span class="nc" id="L670">                    } else {</span>
<span class="nc" id="L671">                        int mon = (internalGet(MONTH) + amount) % 12;</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">                        if (mon &lt; 0) {</span>
<span class="nc" id="L673">                            mon += 12;</span>
                        }
<span class="nc" id="L675">                        set(MONTH, mon);</span>

                        // Keep the day of month in the range.  We
                        // don't want to spill over into the next
                        // month; e.g., we don't want jan31 + 1 mo -&gt;
                        // feb31 -&gt; mar3.
<span class="nc" id="L681">                        int monthLen = monthLength(mon);</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                        if (internalGet(DAY_OF_MONTH) &gt; monthLen) {</span>
<span class="nc" id="L683">                            set(DAY_OF_MONTH, monthLen);</span>
                        }
                    }
<span class="nc" id="L686">                } else {</span>
<span class="nc" id="L687">                    int eraIndex = getEraIndex(jdate);</span>
<span class="nc" id="L688">                    CalendarDate transition = null;</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">                    if (jdate.getYear() == 1) {</span>
<span class="nc" id="L690">                        transition = eras[eraIndex].getSinceDate();</span>
<span class="nc" id="L691">                        min = transition.getMonth() - 1;</span>
                    } else {
<span class="nc bnc" id="L693" title="All 2 branches missed.">                        if (eraIndex &lt; eras.length - 1) {</span>
<span class="nc" id="L694">                            transition = eras[eraIndex + 1].getSinceDate();</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">                            if (transition.getYear() == jdate.getNormalizedYear()) {</span>
<span class="nc" id="L696">                                max = transition.getMonth() - 1;</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">                                if (transition.getDayOfMonth() == 1) {</span>
<span class="nc" id="L698">                                    max--;</span>
                                }
                            }
                        }
                    }

<span class="nc bnc" id="L704" title="All 2 branches missed.">                    if (min == max) {</span>
                        // The year has only one month. No need to
                        // process further. (Showa Gan-nen (year 1)
                        // and the last year have only one month.)
<span class="nc" id="L708">                        return;</span>
                    }
<span class="nc" id="L710">                    int n = getRolledValue(internalGet(field), amount, min, max);</span>
<span class="nc" id="L711">                    set(MONTH, n);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                    if (n == min) {</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">                        if (!(transition.getMonth() == BaseCalendar.JANUARY</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">                              &amp;&amp; transition.getDayOfMonth() == 1)) {</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                            if (jdate.getDayOfMonth() &lt; transition.getDayOfMonth()) {</span>
<span class="nc" id="L716">                                set(DAY_OF_MONTH, transition.getDayOfMonth());</span>
                            }
                        }
<span class="nc bnc" id="L719" title="All 4 branches missed.">                    } else if (n == max &amp;&amp; (transition.getMonth() - 1 == n)) {</span>
<span class="nc" id="L720">                        int dom = transition.getDayOfMonth();</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                        if (jdate.getDayOfMonth() &gt;= dom) {</span>
<span class="nc" id="L722">                            set(DAY_OF_MONTH, dom - 1);</span>
                        }
                    }
                }
<span class="nc" id="L726">                return;</span>
            }

        case WEEK_OF_YEAR:
            {
<span class="nc" id="L731">                int y = jdate.getNormalizedYear();</span>
<span class="nc" id="L732">                max = getActualMaximum(WEEK_OF_YEAR);</span>
<span class="nc" id="L733">                set(DAY_OF_WEEK, internalGet(DAY_OF_WEEK)); // update stamp[field]</span>
<span class="nc" id="L734">                int woy = internalGet(WEEK_OF_YEAR);</span>
<span class="nc" id="L735">                int value = woy + amount;</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">                if (!isTransitionYear(jdate.getNormalizedYear())) {</span>
<span class="nc" id="L737">                    int year = jdate.getYear();</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">                    if (year == getMaximum(YEAR)) {</span>
<span class="nc" id="L739">                        max = getActualMaximum(WEEK_OF_YEAR);</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">                    } else if (year == getMinimum(YEAR)) {</span>
<span class="nc" id="L741">                        min = getActualMinimum(WEEK_OF_YEAR);</span>
<span class="nc" id="L742">                        max = getActualMaximum(WEEK_OF_YEAR);</span>
<span class="nc bnc" id="L743" title="All 4 branches missed.">                        if (value &gt; min &amp;&amp; value &lt; max) {</span>
<span class="nc" id="L744">                            set(WEEK_OF_YEAR, value);</span>
<span class="nc" id="L745">                            return;</span>
                        }

                    }
                    // If the new value is in between min and max
                    // (exclusive), then we can use the value.
<span class="nc bnc" id="L751" title="All 4 branches missed.">                    if (value &gt; min &amp;&amp; value &lt; max) {</span>
<span class="nc" id="L752">                        set(WEEK_OF_YEAR, value);</span>
<span class="nc" id="L753">                        return;</span>
                    }
<span class="nc" id="L755">                    long fd = cachedFixedDate;</span>
                    // Make sure that the min week has the current DAY_OF_WEEK
<span class="nc" id="L757">                    long day1 = fd - (7 * (woy - min));</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">                    if (year != getMinimum(YEAR)) {</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">                        if (gcal.getYearFromFixedDate(day1) != y) {</span>
<span class="nc" id="L760">                            min++;</span>
                        }
                    } else {
<span class="nc" id="L763">                        CalendarDate d = jcal.getCalendarDate(Long.MIN_VALUE, getZone());</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">                        if (day1 &lt; jcal.getFixedDate(d)) {</span>
<span class="nc" id="L765">                            min++;</span>
                        }
                    }

                    // Make sure the same thing for the max week
<span class="nc" id="L770">                    fd += 7 * (max - internalGet(WEEK_OF_YEAR));</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">                    if (gcal.getYearFromFixedDate(fd) != y) {</span>
<span class="nc" id="L772">                        max--;</span>
                    }
                    break;
                }

                // Handle transition here.
<span class="nc" id="L778">                long fd = cachedFixedDate;</span>
<span class="nc" id="L779">                long day1 = fd - (7 * (woy - min));</span>
                // Make sure that the min week has the current DAY_OF_WEEK
<span class="nc" id="L781">                LocalGregorianCalendar.Date d = getCalendarDate(day1);</span>
<span class="nc bnc" id="L782" title="All 4 branches missed.">                if (!(d.getEra() == jdate.getEra() &amp;&amp; d.getYear() == jdate.getYear())) {</span>
<span class="nc" id="L783">                    min++;</span>
                }

                // Make sure the same thing for the max week
<span class="nc" id="L787">                fd += 7 * (max - woy);</span>
<span class="nc" id="L788">                jcal.getCalendarDateFromFixedDate(d, fd);</span>
<span class="nc bnc" id="L789" title="All 4 branches missed.">                if (!(d.getEra() == jdate.getEra() &amp;&amp; d.getYear() == jdate.getYear())) {</span>
<span class="nc" id="L790">                    max--;</span>
                }
                // value: the new WEEK_OF_YEAR which must be converted
                // to month and day of month.
<span class="nc" id="L794">                value = getRolledValue(woy, amount, min, max) - 1;</span>
<span class="nc" id="L795">                d = getCalendarDate(day1 + value * 7);</span>
<span class="nc" id="L796">                set(MONTH, d.getMonth() - 1);</span>
<span class="nc" id="L797">                set(DAY_OF_MONTH, d.getDayOfMonth());</span>
<span class="nc" id="L798">                return;</span>
            }

        case WEEK_OF_MONTH:
            {
<span class="nc" id="L803">                boolean isTransitionYear = isTransitionYear(jdate.getNormalizedYear());</span>
                // dow: relative day of week from the first day of week
<span class="nc" id="L805">                int dow = internalGet(DAY_OF_WEEK) - getFirstDayOfWeek();</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">                if (dow &lt; 0) {</span>
<span class="nc" id="L807">                    dow += 7;</span>
                }

<span class="nc" id="L810">                long fd = cachedFixedDate;</span>
                long month1;     // fixed date of the first day (usually 1) of the month
                int monthLength; // actual month length
<span class="nc bnc" id="L813" title="All 2 branches missed.">                if (isTransitionYear) {</span>
<span class="nc" id="L814">                    month1 = getFixedDateMonth1(jdate, fd);</span>
<span class="nc" id="L815">                    monthLength = actualMonthLength();</span>
                } else {
<span class="nc" id="L817">                    month1 = fd - internalGet(DAY_OF_MONTH) + 1;</span>
<span class="nc" id="L818">                    monthLength = jcal.getMonthLength(jdate);</span>
                }

                // the first day of week of the month.
<span class="nc" id="L822">                long monthDay1st = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(month1 + 6,</span>
<span class="nc" id="L823">                                                                                     getFirstDayOfWeek());</span>
                // if the week has enough days to form a week, the
                // week starts from the previous month.
<span class="nc bnc" id="L826" title="All 2 branches missed.">                if ((int)(monthDay1st - month1) &gt;= getMinimalDaysInFirstWeek()) {</span>
<span class="nc" id="L827">                    monthDay1st -= 7;</span>
                }
<span class="nc" id="L829">                max = getActualMaximum(field);</span>

                // value: the new WEEK_OF_MONTH value
<span class="nc" id="L832">                int value = getRolledValue(internalGet(field), amount, 1, max) - 1;</span>

                // nfd: fixed date of the rolled date
<span class="nc" id="L835">                long nfd = monthDay1st + value * 7 + dow;</span>

                // Unlike WEEK_OF_YEAR, we need to change day of week if the
                // nfd is out of the month.
<span class="nc bnc" id="L839" title="All 2 branches missed.">                if (nfd &lt; month1) {</span>
<span class="nc" id="L840">                    nfd = month1;</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">                } else if (nfd &gt;= (month1 + monthLength)) {</span>
<span class="nc" id="L842">                    nfd = month1 + monthLength - 1;</span>
                }
<span class="nc" id="L844">                set(DAY_OF_MONTH, (int)(nfd - month1) + 1);</span>
<span class="nc" id="L845">                return;</span>
            }

        case DAY_OF_MONTH:
            {
<span class="nc bnc" id="L850" title="All 2 branches missed.">                if (!isTransitionYear(jdate.getNormalizedYear())) {</span>
<span class="nc" id="L851">                    max = jcal.getMonthLength(jdate);</span>
<span class="nc" id="L852">                    break;</span>
                }

                // TODO: Need to change the spec to be usable DAY_OF_MONTH rolling...

                // Transition handling. We can't change year and era
                // values here due to the Calendar roll spec!
<span class="nc" id="L859">                long month1 = getFixedDateMonth1(jdate, cachedFixedDate);</span>

                // It may not be a regular month. Convert the date and range to
                // the relative values, perform the roll, and
                // convert the result back to the rolled date.
<span class="nc" id="L864">                int value = getRolledValue((int)(cachedFixedDate - month1), amount,</span>
<span class="nc" id="L865">                                           0, actualMonthLength() - 1);</span>
<span class="nc" id="L866">                LocalGregorianCalendar.Date d = getCalendarDate(month1 + value);</span>
<span class="nc bnc" id="L867" title="All 4 branches missed.">                assert getEraIndex(d) == internalGetEra()</span>
<span class="nc bnc" id="L868" title="All 4 branches missed.">                    &amp;&amp; d.getYear() == internalGet(YEAR) &amp;&amp; d.getMonth()-1 == internalGet(MONTH);</span>
<span class="nc" id="L869">                set(DAY_OF_MONTH, d.getDayOfMonth());</span>
<span class="nc" id="L870">                return;</span>
            }

        case DAY_OF_YEAR:
            {
<span class="nc" id="L875">                max = getActualMaximum(field);</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">                if (!isTransitionYear(jdate.getNormalizedYear())) {</span>
<span class="nc" id="L877">                    break;</span>
                }

                // Handle transition. We can't change year and era values
                // here due to the Calendar roll spec.
<span class="nc" id="L882">                int value = getRolledValue(internalGet(DAY_OF_YEAR), amount, min, max);</span>
<span class="nc" id="L883">                long jan0 = cachedFixedDate - internalGet(DAY_OF_YEAR);</span>
<span class="nc" id="L884">                LocalGregorianCalendar.Date d = getCalendarDate(jan0 + value);</span>
<span class="nc bnc" id="L885" title="All 6 branches missed.">                assert getEraIndex(d) == internalGetEra() &amp;&amp; d.getYear() == internalGet(YEAR);</span>
<span class="nc" id="L886">                set(MONTH, d.getMonth() - 1);</span>
<span class="nc" id="L887">                set(DAY_OF_MONTH, d.getDayOfMonth());</span>
<span class="nc" id="L888">                return;</span>
            }

        case DAY_OF_WEEK:
            {
<span class="nc" id="L893">                int normalizedYear = jdate.getNormalizedYear();</span>
<span class="nc bnc" id="L894" title="All 4 branches missed.">                if (!isTransitionYear(normalizedYear) &amp;&amp; !isTransitionYear(normalizedYear - 1)) {</span>
                    // If the week of year is in the same year, we can
                    // just change DAY_OF_WEEK.
<span class="nc" id="L897">                    int weekOfYear = internalGet(WEEK_OF_YEAR);</span>
<span class="nc bnc" id="L898" title="All 4 branches missed.">                    if (weekOfYear &gt; 1 &amp;&amp; weekOfYear &lt; 52) {</span>
<span class="nc" id="L899">                        set(WEEK_OF_YEAR, internalGet(WEEK_OF_YEAR));</span>
<span class="nc" id="L900">                        max = SATURDAY;</span>
<span class="nc" id="L901">                        break;</span>
                    }
                }

                // We need to handle it in a different way around year
                // boundaries and in the transition year. Note that
                // changing era and year values violates the roll
                // rule: not changing larger calendar fields...
<span class="nc" id="L909">                amount %= 7;</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">                if (amount == 0) {</span>
<span class="nc" id="L911">                    return;</span>
                }
<span class="nc" id="L913">                long fd = cachedFixedDate;</span>
<span class="nc" id="L914">                long dowFirst = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(fd, getFirstDayOfWeek());</span>
<span class="nc" id="L915">                fd += amount;</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">                if (fd &lt; dowFirst) {</span>
<span class="nc" id="L917">                    fd += 7;</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">                } else if (fd &gt;= dowFirst + 7) {</span>
<span class="nc" id="L919">                    fd -= 7;</span>
                }
<span class="nc" id="L921">                LocalGregorianCalendar.Date d = getCalendarDate(fd);</span>
<span class="nc" id="L922">                set(ERA, getEraIndex(d));</span>
<span class="nc" id="L923">                set(d.getYear(), d.getMonth() - 1, d.getDayOfMonth());</span>
<span class="nc" id="L924">                return;</span>
            }

        case DAY_OF_WEEK_IN_MONTH:
            {
<span class="nc" id="L929">                min = 1; // after having normalized, min should be 1.</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">                if (!isTransitionYear(jdate.getNormalizedYear())) {</span>
<span class="nc" id="L931">                    int dom = internalGet(DAY_OF_MONTH);</span>
<span class="nc" id="L932">                    int monthLength = jcal.getMonthLength(jdate);</span>
<span class="nc" id="L933">                    int lastDays = monthLength % 7;</span>
<span class="nc" id="L934">                    max = monthLength / 7;</span>
<span class="nc" id="L935">                    int x = (dom - 1) % 7;</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">                    if (x &lt; lastDays) {</span>
<span class="nc" id="L937">                        max++;</span>
                    }
<span class="nc" id="L939">                    set(DAY_OF_WEEK, internalGet(DAY_OF_WEEK));</span>
<span class="nc" id="L940">                    break;</span>
                }

                // Transition year handling.
<span class="nc" id="L944">                long fd = cachedFixedDate;</span>
<span class="nc" id="L945">                long month1 = getFixedDateMonth1(jdate, fd);</span>
<span class="nc" id="L946">                int monthLength = actualMonthLength();</span>
<span class="nc" id="L947">                int lastDays = monthLength % 7;</span>
<span class="nc" id="L948">                max = monthLength / 7;</span>
<span class="nc" id="L949">                int x = (int)(fd - month1) % 7;</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">                if (x &lt; lastDays) {</span>
<span class="nc" id="L951">                    max++;</span>
                }
<span class="nc" id="L953">                int value = getRolledValue(internalGet(field), amount, min, max) - 1;</span>
<span class="nc" id="L954">                fd = month1 + value * 7 + x;</span>
<span class="nc" id="L955">                LocalGregorianCalendar.Date d = getCalendarDate(fd);</span>
<span class="nc" id="L956">                set(DAY_OF_MONTH, d.getDayOfMonth());</span>
<span class="nc" id="L957">                return;</span>
            }
        }

<span class="nc" id="L961">        set(field, getRolledValue(internalGet(field), amount, min, max));</span>
<span class="nc" id="L962">    }</span>

    @Override
    public String getDisplayName(int field, int style, Locale locale) {
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">        if (!checkDisplayNameParams(field, style, SHORT, NARROW_FORMAT, locale,</span>
                                    ERA_MASK|YEAR_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {
<span class="nc" id="L968">            return null;</span>
        }

<span class="fc" id="L971">        int fieldValue = get(field);</span>

        // &quot;GanNen&quot; is supported only in the LONG style.
<span class="pc bpc" id="L974" title="1 of 2 branches missed.">        if (field == YEAR</span>
<span class="nc bnc" id="L975" title="All 6 branches missed.">            &amp;&amp; (getBaseStyle(style) != LONG || fieldValue != 1 || get(ERA) == 0)) {</span>
<span class="nc" id="L976">            return null;</span>
        }

<span class="fc" id="L979">        String name = CalendarDataUtility.retrieveFieldValueName(getCalendarType(), field,</span>
                                                                 fieldValue, style, locale);
        // If the ERA value is null, then
        // try to get its name or abbreviation from the Era instance.
<span class="pc bpc" id="L983" title="5 of 6 branches missed.">        if (name == null &amp;&amp; field == ERA &amp;&amp; fieldValue &lt; eras.length) {</span>
<span class="nc" id="L984">            Era era = eras[fieldValue];</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">            name = (style == SHORT) ? era.getAbbreviation() : era.getName();</span>
        }
<span class="fc" id="L987">        return name;</span>
    }

    @Override
    public Map&lt;String,Integer&gt; getDisplayNames(int field, int style, Locale locale) {
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">        if (!checkDisplayNameParams(field, style, ALL_STYLES, NARROW_FORMAT, locale,</span>
                                    ERA_MASK|YEAR_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {
<span class="nc" id="L994">            return null;</span>
        }
        Map&lt;String, Integer&gt; names;
<span class="fc" id="L997">        names = CalendarDataUtility.retrieveFieldValueNames(getCalendarType(), field, style, locale);</span>
        // If strings[] has fewer than eras[], get more names from eras[].
<span class="fc bfc" id="L999" title="All 2 branches covered.">        if (names != null) {</span>
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">            if (field == ERA) {</span>
<span class="nc" id="L1001">                int size = names.size();</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">                if (style == ALL_STYLES) {</span>
<span class="nc" id="L1003">                    Set&lt;Integer&gt; values = new HashSet&lt;&gt;();</span>
                    // count unique era values
<span class="nc bnc" id="L1005" title="All 2 branches missed.">                    for (String key : names.keySet()) {</span>
<span class="nc" id="L1006">                        values.add(names.get(key));</span>
<span class="nc" id="L1007">                    }</span>
<span class="nc" id="L1008">                    size = values.size();</span>
                }
<span class="nc bnc" id="L1010" title="All 2 branches missed.">                if (size &lt; eras.length) {</span>
<span class="nc" id="L1011">                    int baseStyle = getBaseStyle(style);</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                    for (int i = size; i &lt; eras.length; i++) {</span>
<span class="nc" id="L1013">                        Era era = eras[i];</span>
<span class="nc bnc" id="L1014" title="All 6 branches missed.">                        if (baseStyle == ALL_STYLES || baseStyle == SHORT</span>
                                || baseStyle == NARROW_FORMAT) {
<span class="nc" id="L1016">                            names.put(era.getAbbreviation(), i);</span>
                        }
<span class="nc bnc" id="L1018" title="All 4 branches missed.">                        if (baseStyle == ALL_STYLES || baseStyle == LONG) {</span>
<span class="nc" id="L1019">                            names.put(era.getName(), i);</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L1025">        return names;</span>
    }

    /**
     * Returns the minimum value for the given calendar field of this
     * &lt;code&gt;Calendar&lt;/code&gt; instance. The minimum value is
     * defined as the smallest value returned by the {@link
     * Calendar#get(int) get} method for any possible time value,
     * taking into consideration the current values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * and {@link Calendar#getTimeZone() getTimeZone} methods.
     *
     * @param field the calendar field.
     * @return the minimum value for the given calendar field.
     * @see #getMaximum(int)
     * @see #getGreatestMinimum(int)
     * @see #getLeastMaximum(int)
     * @see #getActualMinimum(int)
     * @see #getActualMaximum(int)
     */
    public int getMinimum(int field) {
<span class="fc" id="L1047">        return MIN_VALUES[field];</span>
    }

    /**
     * Returns the maximum value for the given calendar field of this
     * &lt;code&gt;GregorianCalendar&lt;/code&gt; instance. The maximum value is
     * defined as the largest value returned by the {@link
     * Calendar#get(int) get} method for any possible time value,
     * taking into consideration the current values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * and {@link Calendar#getTimeZone() getTimeZone} methods.
     *
     * @param field the calendar field.
     * @return the maximum value for the given calendar field.
     * @see #getMinimum(int)
     * @see #getGreatestMinimum(int)
     * @see #getLeastMaximum(int)
     * @see #getActualMinimum(int)
     * @see #getActualMaximum(int)
     */
    public int getMaximum(int field) {
<span class="nc bnc" id="L1069" title="All 2 branches missed.">        switch (field) {</span>
        case YEAR:
            {
                // The value should depend on the time zone of this calendar.
<span class="nc" id="L1073">                LocalGregorianCalendar.Date d = jcal.getCalendarDate(Long.MAX_VALUE,</span>
<span class="nc" id="L1074">                                                                     getZone());</span>
<span class="nc" id="L1075">                return Math.max(LEAST_MAX_VALUES[YEAR], d.getYear());</span>
            }
        }
<span class="nc" id="L1078">        return MAX_VALUES[field];</span>
    }

    /**
     * Returns the highest minimum value for the given calendar field
     * of this &lt;code&gt;GregorianCalendar&lt;/code&gt; instance. The highest
     * minimum value is defined as the largest value returned by
     * {@link #getActualMinimum(int)} for any possible time value,
     * taking into consideration the current values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * and {@link Calendar#getTimeZone() getTimeZone} methods.
     *
     * @param field the calendar field.
     * @return the highest minimum value for the given calendar field.
     * @see #getMinimum(int)
     * @see #getMaximum(int)
     * @see #getLeastMaximum(int)
     * @see #getActualMinimum(int)
     * @see #getActualMaximum(int)
     */
    public int getGreatestMinimum(int field) {
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        return field == YEAR ? 1 : MIN_VALUES[field];</span>
    }

    /**
     * Returns the lowest maximum value for the given calendar field
     * of this &lt;code&gt;GregorianCalendar&lt;/code&gt; instance. The lowest
     * maximum value is defined as the smallest value returned by
     * {@link #getActualMaximum(int)} for any possible time value,
     * taking into consideration the current values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * and {@link Calendar#getTimeZone() getTimeZone} methods.
     *
     * @param field the calendar field
     * @return the lowest maximum value for the given calendar field.
     * @see #getMinimum(int)
     * @see #getMaximum(int)
     * @see #getGreatestMinimum(int)
     * @see #getActualMinimum(int)
     * @see #getActualMaximum(int)
     */
    public int getLeastMaximum(int field) {
<span class="nc bnc" id="L1122" title="All 2 branches missed.">        switch (field) {</span>
        case YEAR:
            {
<span class="nc" id="L1125">                return Math.min(LEAST_MAX_VALUES[YEAR], getMaximum(YEAR));</span>
            }
        }
<span class="nc" id="L1128">        return LEAST_MAX_VALUES[field];</span>
    }

    /**
     * Returns the minimum value that this calendar field could have,
     * taking into consideration the given time value and the current
     * values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * and {@link Calendar#getTimeZone() getTimeZone} methods.
     *
     * @param field the calendar field
     * @return the minimum of the given field for the time value of
     * this &lt;code&gt;JapaneseImperialCalendar&lt;/code&gt;
     * @see #getMinimum(int)
     * @see #getMaximum(int)
     * @see #getGreatestMinimum(int)
     * @see #getLeastMaximum(int)
     * @see #getActualMaximum(int)
     */
    public int getActualMinimum(int field) {
<span class="nc bnc" id="L1149" title="All 2 branches missed.">        if (!isFieldSet(YEAR_MASK|MONTH_MASK|WEEK_OF_YEAR_MASK, field)) {</span>
<span class="nc" id="L1150">            return getMinimum(field);</span>
        }

<span class="nc" id="L1153">        int value = 0;</span>
<span class="nc" id="L1154">        JapaneseImperialCalendar jc = getNormalizedCalendar();</span>
        // Get a local date which includes time of day and time zone,
        // which are missing in jc.jdate.
<span class="nc" id="L1157">        LocalGregorianCalendar.Date jd = jcal.getCalendarDate(jc.getTimeInMillis(),</span>
<span class="nc" id="L1158">                                                              getZone());</span>
<span class="nc" id="L1159">        int eraIndex = getEraIndex(jd);</span>
<span class="nc bnc" id="L1160" title="All 4 branches missed.">        switch (field) {</span>
        case YEAR:
            {
<span class="nc bnc" id="L1163" title="All 2 branches missed.">                if (eraIndex &gt; BEFORE_MEIJI) {</span>
<span class="nc" id="L1164">                    value = 1;</span>
<span class="nc" id="L1165">                    long since = eras[eraIndex].getSince(getZone());</span>
<span class="nc" id="L1166">                    CalendarDate d = jcal.getCalendarDate(since, getZone());</span>
                    // Use the same year in jd to take care of leap
                    // years. i.e., both jd and d must agree on leap
                    // or common years.
<span class="nc" id="L1170">                    jd.setYear(d.getYear());</span>
<span class="nc" id="L1171">                    jcal.normalize(jd);</span>
<span class="nc bnc" id="L1172" title="All 4 branches missed.">                    assert jd.isLeapYear() == d.isLeapYear();</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">                    if (getYearOffsetInMillis(jd) &lt; getYearOffsetInMillis(d)) {</span>
<span class="nc" id="L1174">                        value++;</span>
                    }
<span class="nc" id="L1176">                } else {</span>
<span class="nc" id="L1177">                    value = getMinimum(field);</span>
<span class="nc" id="L1178">                    CalendarDate d = jcal.getCalendarDate(Long.MIN_VALUE, getZone());</span>
                    // Use an equvalent year of d.getYear() if
                    // possible. Otherwise, ignore the leap year and
                    // common year difference.
<span class="nc" id="L1182">                    int y = d.getYear();</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">                    if (y &gt; 400) {</span>
<span class="nc" id="L1184">                        y -= 400;</span>
                    }
<span class="nc" id="L1186">                    jd.setYear(y);</span>
<span class="nc" id="L1187">                    jcal.normalize(jd);</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">                    if (getYearOffsetInMillis(jd) &lt; getYearOffsetInMillis(d)) {</span>
<span class="nc" id="L1189">                        value++;</span>
                    }
                }
            }
<span class="nc" id="L1193">            break;</span>

        case MONTH:
            {
                // In Before Meiji and Meiji, January is the first month.
<span class="nc bnc" id="L1198" title="All 4 branches missed.">                if (eraIndex &gt; MEIJI &amp;&amp; jd.getYear() == 1) {</span>
<span class="nc" id="L1199">                    long since = eras[eraIndex].getSince(getZone());</span>
<span class="nc" id="L1200">                    CalendarDate d = jcal.getCalendarDate(since, getZone());</span>
<span class="nc" id="L1201">                    value = d.getMonth() - 1;</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">                    if (jd.getDayOfMonth() &lt; d.getDayOfMonth()) {</span>
<span class="nc" id="L1203">                        value++;</span>
                    }
<span class="nc" id="L1205">                }</span>
            }
            break;

        case WEEK_OF_YEAR:
            {
<span class="nc" id="L1211">                value = 1;</span>
<span class="nc" id="L1212">                CalendarDate d = jcal.getCalendarDate(Long.MIN_VALUE, getZone());</span>
                // shift 400 years to avoid underflow
<span class="nc" id="L1214">                d.addYear(+400);</span>
<span class="nc" id="L1215">                jcal.normalize(d);</span>
<span class="nc" id="L1216">                jd.setEra(d.getEra());</span>
<span class="nc" id="L1217">                jd.setYear(d.getYear());</span>
<span class="nc" id="L1218">                jcal.normalize(jd);</span>

<span class="nc" id="L1220">                long jan1 = jcal.getFixedDate(d);</span>
<span class="nc" id="L1221">                long fd = jcal.getFixedDate(jd);</span>
<span class="nc" id="L1222">                int woy = getWeekNumber(jan1, fd);</span>
<span class="nc" id="L1223">                long day1 = fd - (7 * (woy - 1));</span>
<span class="nc bnc" id="L1224" title="All 4 branches missed.">                if ((day1 &lt; jan1) ||</span>
                    (day1 == jan1 &amp;&amp;
<span class="nc bnc" id="L1226" title="All 2 branches missed.">                     jd.getTimeOfDay() &lt; d.getTimeOfDay())) {</span>
<span class="nc" id="L1227">                    value++;</span>
                }
            }
            break;
        }
<span class="nc" id="L1232">        return value;</span>
    }

    /**
     * Returns the maximum value that this calendar field could have,
     * taking into consideration the given time value and the current
     * values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * and
     * {@link Calendar#getTimeZone() getTimeZone} methods.
     * For example, if the date of this instance is Heisei 16February 1,
     * the actual maximum value of the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; field
     * is 29 because Heisei 16 is a leap year, and if the date of this
     * instance is Heisei 17 February 1, it's 28.
     *
     * @param field the calendar field
     * @return the maximum of the given field for the time value of
     * this &lt;code&gt;JapaneseImperialCalendar&lt;/code&gt;
     * @see #getMinimum(int)
     * @see #getMaximum(int)
     * @see #getGreatestMinimum(int)
     * @see #getLeastMaximum(int)
     * @see #getActualMinimum(int)
     */
    public int getActualMaximum(int field) {
        final int fieldsForFixedMax = ERA_MASK|DAY_OF_WEEK_MASK|HOUR_MASK|AM_PM_MASK|
            HOUR_OF_DAY_MASK|MINUTE_MASK|SECOND_MASK|MILLISECOND_MASK|
            ZONE_OFFSET_MASK|DST_OFFSET_MASK;
<span class="nc bnc" id="L1261" title="All 2 branches missed.">        if ((fieldsForFixedMax &amp; (1&lt;&lt;field)) != 0) {</span>
<span class="nc" id="L1262">            return getMaximum(field);</span>
        }

<span class="nc" id="L1265">        JapaneseImperialCalendar jc = getNormalizedCalendar();</span>
<span class="nc" id="L1266">        LocalGregorianCalendar.Date date = jc.jdate;</span>
<span class="nc" id="L1267">        int normalizedYear = date.getNormalizedYear();</span>

<span class="nc" id="L1269">        int value = -1;</span>
<span class="nc bnc" id="L1270" title="All 8 branches missed.">        switch (field) {</span>
        case MONTH:
            {
<span class="nc" id="L1273">                value = DECEMBER;</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">                if (isTransitionYear(date.getNormalizedYear())) {</span>
                    // TODO: there may be multiple transitions in a year.
<span class="nc" id="L1276">                    int eraIndex = getEraIndex(date);</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">                    if (date.getYear() != 1) {</span>
<span class="nc" id="L1278">                        eraIndex++;</span>
<span class="nc bnc" id="L1279" title="All 4 branches missed.">                        assert eraIndex &lt; eras.length;</span>
                    }
<span class="nc" id="L1281">                    long transition = sinceFixedDates[eraIndex];</span>
<span class="nc" id="L1282">                    long fd = jc.cachedFixedDate;</span>
<span class="nc bnc" id="L1283" title="All 2 branches missed.">                    if (fd &lt; transition) {</span>
<span class="nc" id="L1284">                        LocalGregorianCalendar.Date ldate</span>
<span class="nc" id="L1285">                            = (LocalGregorianCalendar.Date) date.clone();</span>
<span class="nc" id="L1286">                        jcal.getCalendarDateFromFixedDate(ldate, transition - 1);</span>
<span class="nc" id="L1287">                        value = ldate.getMonth() - 1;</span>
                    }
<span class="nc" id="L1289">                } else {</span>
<span class="nc" id="L1290">                    LocalGregorianCalendar.Date d = jcal.getCalendarDate(Long.MAX_VALUE,</span>
<span class="nc" id="L1291">                                                                         getZone());</span>
<span class="nc bnc" id="L1292" title="All 4 branches missed.">                    if (date.getEra() == d.getEra() &amp;&amp; date.getYear() == d.getYear()) {</span>
<span class="nc" id="L1293">                        value = d.getMonth() - 1;</span>
                    }
                }
            }
<span class="nc" id="L1297">            break;</span>

        case DAY_OF_MONTH:
<span class="nc" id="L1300">            value = jcal.getMonthLength(date);</span>
<span class="nc" id="L1301">            break;</span>

        case DAY_OF_YEAR:
            {
<span class="nc bnc" id="L1305" title="All 2 branches missed.">                if (isTransitionYear(date.getNormalizedYear())) {</span>
                    // Handle transition year.
                    // TODO: there may be multiple transitions in a year.
<span class="nc" id="L1308">                    int eraIndex = getEraIndex(date);</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">                    if (date.getYear() != 1) {</span>
<span class="nc" id="L1310">                        eraIndex++;</span>
<span class="nc bnc" id="L1311" title="All 4 branches missed.">                        assert eraIndex &lt; eras.length;</span>
                    }
<span class="nc" id="L1313">                    long transition = sinceFixedDates[eraIndex];</span>
<span class="nc" id="L1314">                    long fd = jc.cachedFixedDate;</span>
<span class="nc" id="L1315">                    CalendarDate d = gcal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="nc" id="L1316">                    d.setDate(date.getNormalizedYear(), BaseCalendar.JANUARY, 1);</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">                    if (fd &lt; transition) {</span>
<span class="nc" id="L1318">                        value = (int)(transition - gcal.getFixedDate(d));</span>
                    } else {
<span class="nc" id="L1320">                        d.addYear(+1);</span>
<span class="nc" id="L1321">                        value = (int)(gcal.getFixedDate(d) - transition);</span>
                    }
<span class="nc" id="L1323">                } else {</span>
<span class="nc" id="L1324">                    LocalGregorianCalendar.Date d = jcal.getCalendarDate(Long.MAX_VALUE,</span>
<span class="nc" id="L1325">                                                                         getZone());</span>
<span class="nc bnc" id="L1326" title="All 4 branches missed.">                    if (date.getEra() == d.getEra() &amp;&amp; date.getYear() == d.getYear()) {</span>
<span class="nc" id="L1327">                        long fd = jcal.getFixedDate(d);</span>
<span class="nc" id="L1328">                        long jan1 = getFixedDateJan1(d, fd);</span>
<span class="nc" id="L1329">                        value = (int)(fd - jan1) + 1;</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">                    } else if (date.getYear() == getMinimum(YEAR)) {</span>
<span class="nc" id="L1331">                        CalendarDate d1 = jcal.getCalendarDate(Long.MIN_VALUE, getZone());</span>
<span class="nc" id="L1332">                        long fd1 = jcal.getFixedDate(d1);</span>
<span class="nc" id="L1333">                        d1.addYear(1);</span>
<span class="nc" id="L1334">                        d1.setMonth(BaseCalendar.JANUARY).setDayOfMonth(1);</span>
<span class="nc" id="L1335">                        jcal.normalize(d1);</span>
<span class="nc" id="L1336">                        long fd2 = jcal.getFixedDate(d1);</span>
<span class="nc" id="L1337">                        value = (int)(fd2 - fd1);</span>
<span class="nc" id="L1338">                    } else {</span>
<span class="nc" id="L1339">                        value = jcal.getYearLength(date);</span>
                    }
                }
            }
<span class="nc" id="L1343">            break;</span>

        case WEEK_OF_YEAR:
            {
<span class="nc bnc" id="L1347" title="All 2 branches missed.">                if (!isTransitionYear(date.getNormalizedYear())) {</span>
<span class="nc" id="L1348">                    LocalGregorianCalendar.Date jd = jcal.getCalendarDate(Long.MAX_VALUE,</span>
<span class="nc" id="L1349">                                                                          getZone());</span>
<span class="nc bnc" id="L1350" title="All 4 branches missed.">                    if (date.getEra() == jd.getEra() &amp;&amp; date.getYear() == jd.getYear()) {</span>
<span class="nc" id="L1351">                        long fd = jcal.getFixedDate(jd);</span>
<span class="nc" id="L1352">                        long jan1 = getFixedDateJan1(jd, fd);</span>
<span class="nc" id="L1353">                        value = getWeekNumber(jan1, fd);</span>
<span class="nc bnc" id="L1354" title="All 4 branches missed.">                    } else if (date.getEra() == null &amp;&amp; date.getYear() == getMinimum(YEAR)) {</span>
<span class="nc" id="L1355">                        CalendarDate d = jcal.getCalendarDate(Long.MIN_VALUE, getZone());</span>
                        // shift 400 years to avoid underflow
<span class="nc" id="L1357">                        d.addYear(+400);</span>
<span class="nc" id="L1358">                        jcal.normalize(d);</span>
<span class="nc" id="L1359">                        jd.setEra(d.getEra());</span>
<span class="nc" id="L1360">                        jd.setDate(d.getYear() + 1, BaseCalendar.JANUARY, 1);</span>
<span class="nc" id="L1361">                        jcal.normalize(jd);</span>
<span class="nc" id="L1362">                        long jan1 = jcal.getFixedDate(d);</span>
<span class="nc" id="L1363">                        long nextJan1 = jcal.getFixedDate(jd);</span>
<span class="nc" id="L1364">                        long nextJan1st = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(nextJan1 + 6,</span>
<span class="nc" id="L1365">                                                                                            getFirstDayOfWeek());</span>
<span class="nc" id="L1366">                        int ndays = (int)(nextJan1st - nextJan1);</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">                        if (ndays &gt;= getMinimalDaysInFirstWeek()) {</span>
<span class="nc" id="L1368">                            nextJan1st -= 7;</span>
                        }
<span class="nc" id="L1370">                        value = getWeekNumber(jan1, nextJan1st);</span>
<span class="nc" id="L1371">                    } else {</span>
                        // Get the day of week of January 1 of the year
<span class="nc" id="L1373">                        CalendarDate d = gcal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="nc" id="L1374">                        d.setDate(date.getNormalizedYear(), BaseCalendar.JANUARY, 1);</span>
<span class="nc" id="L1375">                        int dayOfWeek = gcal.getDayOfWeek(d);</span>
                        // Normalize the day of week with the firstDayOfWeek value
<span class="nc" id="L1377">                        dayOfWeek -= getFirstDayOfWeek();</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">                        if (dayOfWeek &lt; 0) {</span>
<span class="nc" id="L1379">                            dayOfWeek += 7;</span>
                        }
<span class="nc" id="L1381">                        value = 52;</span>
<span class="nc" id="L1382">                        int magic = dayOfWeek + getMinimalDaysInFirstWeek() - 1;</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">                        if ((magic == 6) ||</span>
<span class="nc bnc" id="L1384" title="All 6 branches missed.">                            (date.isLeapYear() &amp;&amp; (magic == 5 || magic == 12))) {</span>
<span class="nc" id="L1385">                            value++;</span>
                        }
                    }
<span class="nc" id="L1388">                    break;</span>
                }

<span class="nc bnc" id="L1391" title="All 2 branches missed.">                if (jc == this) {</span>
<span class="nc" id="L1392">                    jc = (JapaneseImperialCalendar) jc.clone();</span>
                }
<span class="nc" id="L1394">                int max = getActualMaximum(DAY_OF_YEAR);</span>
<span class="nc" id="L1395">                jc.set(DAY_OF_YEAR, max);</span>
<span class="nc" id="L1396">                value = jc.get(WEEK_OF_YEAR);</span>
<span class="nc bnc" id="L1397" title="All 4 branches missed.">                if (value == 1 &amp;&amp; max &gt; 7) {</span>
<span class="nc" id="L1398">                    jc.add(WEEK_OF_YEAR, -1);</span>
<span class="nc" id="L1399">                    value = jc.get(WEEK_OF_YEAR);</span>
                }
            }
<span class="nc" id="L1402">            break;</span>

        case WEEK_OF_MONTH:
            {
<span class="nc" id="L1406">                LocalGregorianCalendar.Date jd = jcal.getCalendarDate(Long.MAX_VALUE,</span>
<span class="nc" id="L1407">                                                                      getZone());</span>
<span class="nc bnc" id="L1408" title="All 4 branches missed.">                if (!(date.getEra() == jd.getEra() &amp;&amp; date.getYear() == jd.getYear())) {</span>
<span class="nc" id="L1409">                    CalendarDate d = gcal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="nc" id="L1410">                    d.setDate(date.getNormalizedYear(), date.getMonth(), 1);</span>
<span class="nc" id="L1411">                    int dayOfWeek = gcal.getDayOfWeek(d);</span>
<span class="nc" id="L1412">                    int monthLength = gcal.getMonthLength(d);</span>
<span class="nc" id="L1413">                    dayOfWeek -= getFirstDayOfWeek();</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">                    if (dayOfWeek &lt; 0) {</span>
<span class="nc" id="L1415">                        dayOfWeek += 7;</span>
                    }
<span class="nc" id="L1417">                    int nDaysFirstWeek = 7 - dayOfWeek; // # of days in the first week</span>
<span class="nc" id="L1418">                    value = 3;</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">                    if (nDaysFirstWeek &gt;= getMinimalDaysInFirstWeek()) {</span>
<span class="nc" id="L1420">                        value++;</span>
                    }
<span class="nc" id="L1422">                    monthLength -= nDaysFirstWeek + 7 * 3;</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">                    if (monthLength &gt; 0) {</span>
<span class="nc" id="L1424">                        value++;</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">                        if (monthLength &gt; 7) {</span>
<span class="nc" id="L1426">                            value++;</span>
                        }
                    }
<span class="nc" id="L1429">                } else {</span>
<span class="nc" id="L1430">                    long fd = jcal.getFixedDate(jd);</span>
<span class="nc" id="L1431">                    long month1 = fd - jd.getDayOfMonth() + 1;</span>
<span class="nc" id="L1432">                    value = getWeekNumber(month1, fd);</span>
                }
            }
<span class="nc" id="L1435">            break;</span>

        case DAY_OF_WEEK_IN_MONTH:
            {
                int ndays, dow1;
<span class="nc" id="L1440">                int dow = date.getDayOfWeek();</span>
<span class="nc" id="L1441">                BaseCalendar.Date d = (BaseCalendar.Date) date.clone();</span>
<span class="nc" id="L1442">                ndays = jcal.getMonthLength(d);</span>
<span class="nc" id="L1443">                d.setDayOfMonth(1);</span>
<span class="nc" id="L1444">                jcal.normalize(d);</span>
<span class="nc" id="L1445">                dow1 = d.getDayOfWeek();</span>
<span class="nc" id="L1446">                int x = dow - dow1;</span>
<span class="nc bnc" id="L1447" title="All 2 branches missed.">                if (x &lt; 0) {</span>
<span class="nc" id="L1448">                    x += 7;</span>
                }
<span class="nc" id="L1450">                ndays -= x;</span>
<span class="nc" id="L1451">                value = (ndays + 6) / 7;</span>
            }
<span class="nc" id="L1453">            break;</span>

        case YEAR:
            {
<span class="nc" id="L1457">                CalendarDate jd = jcal.getCalendarDate(jc.getTimeInMillis(), getZone());</span>
                CalendarDate d;
<span class="nc" id="L1459">                int eraIndex = getEraIndex(date);</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">                if (eraIndex == eras.length - 1) {</span>
<span class="nc" id="L1461">                    d = jcal.getCalendarDate(Long.MAX_VALUE, getZone());</span>
<span class="nc" id="L1462">                    value = d.getYear();</span>
                    // Use an equivalent year for the
                    // getYearOffsetInMillis call to avoid overflow.
<span class="nc bnc" id="L1465" title="All 2 branches missed.">                    if (value &gt; 400) {</span>
<span class="nc" id="L1466">                        jd.setYear(value - 400);</span>
                    }
                } else {
<span class="nc" id="L1469">                    d = jcal.getCalendarDate(eras[eraIndex + 1].getSince(getZone()) - 1,</span>
<span class="nc" id="L1470">                                             getZone());</span>
<span class="nc" id="L1471">                    value = d.getYear();</span>
                    // Use the same year as d.getYear() to be
                    // consistent with leap and common years.
<span class="nc" id="L1474">                    jd.setYear(value);</span>
                }
<span class="nc" id="L1476">                jcal.normalize(jd);</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">                if (getYearOffsetInMillis(jd) &gt; getYearOffsetInMillis(d)) {</span>
<span class="nc" id="L1478">                    value--;</span>
                }
            }
<span class="nc" id="L1481">            break;</span>

        default:
<span class="nc" id="L1484">            throw new ArrayIndexOutOfBoundsException(field);</span>
        }
<span class="nc" id="L1486">        return value;</span>
    }

    /**
     * Returns the millisecond offset from the beginning of the
     * year. In the year for Long.MIN_VALUE, it's a pseudo value
     * beyond the limit. The given CalendarDate object must have been
     * normalized before calling this method.
     */
    private long getYearOffsetInMillis(CalendarDate date) {
<span class="nc" id="L1496">        long t = (jcal.getDayOfYear(date) - 1) * ONE_DAY;</span>
<span class="nc" id="L1497">        return t + date.getTimeOfDay() - date.getZoneOffset();</span>
    }

    public Object clone() {
<span class="fc" id="L1501">        JapaneseImperialCalendar other = (JapaneseImperialCalendar) super.clone();</span>

<span class="fc" id="L1503">        other.jdate = (LocalGregorianCalendar.Date) jdate.clone();</span>
<span class="fc" id="L1504">        other.originalFields = null;</span>
<span class="fc" id="L1505">        other.zoneOffsets = null;</span>
<span class="fc" id="L1506">        return other;</span>
    }

    public TimeZone getTimeZone() {
<span class="nc" id="L1510">        TimeZone zone = super.getTimeZone();</span>
        // To share the zone by the CalendarDate
<span class="nc" id="L1512">        jdate.setZone(zone);</span>
<span class="nc" id="L1513">        return zone;</span>
    }

    public void setTimeZone(TimeZone zone) {
<span class="nc" id="L1517">        super.setTimeZone(zone);</span>
        // To share the zone by the CalendarDate
<span class="nc" id="L1519">        jdate.setZone(zone);</span>
<span class="nc" id="L1520">    }</span>

    /**
     * The fixed date corresponding to jdate. If the value is
     * Long.MIN_VALUE, the fixed date value is unknown.
     */
<span class="pc" id="L1526">    transient private long cachedFixedDate = Long.MIN_VALUE;</span>

    /**
     * Converts the time value (millisecond offset from the &lt;a
     * href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;) to calendar field values.
     * The time is &lt;em&gt;not&lt;/em&gt;
     * recomputed first; to recompute the time, then the fields, call the
     * &lt;code&gt;complete&lt;/code&gt; method.
     *
     * @see Calendar#complete
     */
    protected void computeFields() {
<span class="fc" id="L1538">        int mask = 0;</span>
<span class="fc bfc" id="L1539" title="All 2 branches covered.">        if (isPartiallyNormalized()) {</span>
            // Determine which calendar fields need to be computed.
<span class="fc" id="L1541">            mask = getSetStateFields();</span>
<span class="fc" id="L1542">            int fieldMask = ~mask &amp; ALL_FIELDS;</span>
<span class="pc bpc" id="L1543" title="3 of 4 branches missed.">            if (fieldMask != 0 || cachedFixedDate == Long.MIN_VALUE) {</span>
<span class="fc" id="L1544">                mask |= computeFields(fieldMask,</span>
                                      mask &amp; (ZONE_OFFSET_MASK|DST_OFFSET_MASK));
<span class="pc bpc" id="L1546" title="2 of 4 branches missed.">                assert mask == ALL_FIELDS;</span>
            }
<span class="fc" id="L1548">        } else {</span>
            // Specify all fields
<span class="fc" id="L1550">            mask = ALL_FIELDS;</span>
<span class="fc" id="L1551">            computeFields(mask, 0);</span>
        }
        // After computing all the fields, set the field state to `COMPUTED'.
<span class="fc" id="L1554">        setFieldsComputed(mask);</span>
<span class="fc" id="L1555">    }</span>

    /**
     * This computeFields implements the conversion from UTC
     * (millisecond offset from the Epoch) to calendar
     * field values. fieldMask specifies which fields to change the
     * setting state to COMPUTED, although all fields are set to
     * the correct values. This is required to fix 4685354.
     *
     * @param fieldMask a bit mask to specify which fields to change
     * the setting state.
     * @param tzMask a bit mask to specify which time zone offset
     * fields to be used for time calculations
     * @return a new field mask that indicates what field values have
     * actually been set.
     */
    private int computeFields(int fieldMask, int tzMask) {
<span class="fc" id="L1572">        int zoneOffset = 0;</span>
<span class="fc" id="L1573">        TimeZone tz = getZone();</span>
<span class="fc bfc" id="L1574" title="All 2 branches covered.">        if (zoneOffsets == null) {</span>
<span class="fc" id="L1575">            zoneOffsets = new int[2];</span>
        }
<span class="fc bfc" id="L1577" title="All 2 branches covered.">        if (tzMask != (ZONE_OFFSET_MASK|DST_OFFSET_MASK)) {</span>
<span class="pc bpc" id="L1578" title="1 of 2 branches missed.">            if (tz instanceof ZoneInfo) {</span>
<span class="fc" id="L1579">                zoneOffset = ((ZoneInfo)tz).getOffsets(time, zoneOffsets);</span>
            } else {
<span class="nc" id="L1581">                zoneOffset = tz.getOffset(time);</span>
<span class="nc" id="L1582">                zoneOffsets[0] = tz.getRawOffset();</span>
<span class="nc" id="L1583">                zoneOffsets[1] = zoneOffset - zoneOffsets[0];</span>
            }
        }
<span class="fc bfc" id="L1586" title="All 2 branches covered.">        if (tzMask != 0) {</span>
<span class="pc bpc" id="L1587" title="1 of 2 branches missed.">            if (isFieldSet(tzMask, ZONE_OFFSET)) {</span>
<span class="fc" id="L1588">                zoneOffsets[0] = internalGet(ZONE_OFFSET);</span>
            }
<span class="pc bpc" id="L1590" title="1 of 2 branches missed.">            if (isFieldSet(tzMask, DST_OFFSET)) {</span>
<span class="fc" id="L1591">                zoneOffsets[1] = internalGet(DST_OFFSET);</span>
            }
<span class="fc" id="L1593">            zoneOffset = zoneOffsets[0] + zoneOffsets[1];</span>
        }

        // By computing time and zoneOffset separately, we can take
        // the wider range of time+zoneOffset than the previous
        // implementation.
<span class="fc" id="L1599">        long fixedDate = zoneOffset / ONE_DAY;</span>
<span class="fc" id="L1600">        int timeOfDay = zoneOffset % (int)ONE_DAY;</span>
<span class="fc" id="L1601">        fixedDate += time / ONE_DAY;</span>
<span class="fc" id="L1602">        timeOfDay += (int) (time % ONE_DAY);</span>
<span class="pc bpc" id="L1603" title="1 of 2 branches missed.">        if (timeOfDay &gt;= ONE_DAY) {</span>
<span class="nc" id="L1604">            timeOfDay -= ONE_DAY;</span>
<span class="nc" id="L1605">            ++fixedDate;</span>
        } else {
<span class="fc bfc" id="L1607" title="All 2 branches covered.">            while (timeOfDay &lt; 0) {</span>
<span class="fc" id="L1608">                timeOfDay += ONE_DAY;</span>
<span class="fc" id="L1609">                --fixedDate;</span>
            }
        }
<span class="fc" id="L1612">        fixedDate += EPOCH_OFFSET;</span>

        // See if we can use jdate to avoid date calculation.
<span class="pc bpc" id="L1615" title="1 of 4 branches missed.">        if (fixedDate != cachedFixedDate || fixedDate &lt; 0) {</span>
<span class="fc" id="L1616">            jcal.getCalendarDateFromFixedDate(jdate, fixedDate);</span>
<span class="fc" id="L1617">            cachedFixedDate = fixedDate;</span>
        }
<span class="fc" id="L1619">        int era = getEraIndex(jdate);</span>
<span class="fc" id="L1620">        int year = jdate.getYear();</span>

        // Always set the ERA and YEAR values.
<span class="fc" id="L1623">        internalSet(ERA, era);</span>
<span class="fc" id="L1624">        internalSet(YEAR, year);</span>
<span class="fc" id="L1625">        int mask = fieldMask | (ERA_MASK|YEAR_MASK);</span>

<span class="fc" id="L1627">        int month =  jdate.getMonth() - 1; // 0-based</span>
<span class="fc" id="L1628">        int dayOfMonth = jdate.getDayOfMonth();</span>

        // Set the basic date fields.
<span class="fc bfc" id="L1631" title="All 2 branches covered.">        if ((fieldMask &amp; (MONTH_MASK|DAY_OF_MONTH_MASK|DAY_OF_WEEK_MASK))</span>
            != 0) {
<span class="fc" id="L1633">            internalSet(MONTH, month);</span>
<span class="fc" id="L1634">            internalSet(DAY_OF_MONTH, dayOfMonth);</span>
<span class="fc" id="L1635">            internalSet(DAY_OF_WEEK, jdate.getDayOfWeek());</span>
<span class="fc" id="L1636">            mask |= MONTH_MASK|DAY_OF_MONTH_MASK|DAY_OF_WEEK_MASK;</span>
        }

<span class="fc bfc" id="L1639" title="All 2 branches covered.">        if ((fieldMask &amp; (HOUR_OF_DAY_MASK|AM_PM_MASK|HOUR_MASK</span>
                          |MINUTE_MASK|SECOND_MASK|MILLISECOND_MASK)) != 0) {
<span class="fc bfc" id="L1641" title="All 2 branches covered.">            if (timeOfDay != 0) {</span>
<span class="fc" id="L1642">                int hours = timeOfDay / ONE_HOUR;</span>
<span class="fc" id="L1643">                internalSet(HOUR_OF_DAY, hours);</span>
<span class="fc" id="L1644">                internalSet(AM_PM, hours / 12); // Assume AM == 0</span>
<span class="fc" id="L1645">                internalSet(HOUR, hours % 12);</span>
<span class="fc" id="L1646">                int r = timeOfDay % ONE_HOUR;</span>
<span class="fc" id="L1647">                internalSet(MINUTE, r / ONE_MINUTE);</span>
<span class="fc" id="L1648">                r %= ONE_MINUTE;</span>
<span class="fc" id="L1649">                internalSet(SECOND, r / ONE_SECOND);</span>
<span class="fc" id="L1650">                internalSet(MILLISECOND, r % ONE_SECOND);</span>
<span class="fc" id="L1651">            } else {</span>
<span class="fc" id="L1652">                internalSet(HOUR_OF_DAY, 0);</span>
<span class="fc" id="L1653">                internalSet(AM_PM, AM);</span>
<span class="fc" id="L1654">                internalSet(HOUR, 0);</span>
<span class="fc" id="L1655">                internalSet(MINUTE, 0);</span>
<span class="fc" id="L1656">                internalSet(SECOND, 0);</span>
<span class="fc" id="L1657">                internalSet(MILLISECOND, 0);</span>
            }
<span class="fc" id="L1659">            mask |= (HOUR_OF_DAY_MASK|AM_PM_MASK|HOUR_MASK</span>
                     |MINUTE_MASK|SECOND_MASK|MILLISECOND_MASK);
        }

<span class="fc bfc" id="L1663" title="All 2 branches covered.">        if ((fieldMask &amp; (ZONE_OFFSET_MASK|DST_OFFSET_MASK)) != 0) {</span>
<span class="fc" id="L1664">            internalSet(ZONE_OFFSET, zoneOffsets[0]);</span>
<span class="fc" id="L1665">            internalSet(DST_OFFSET, zoneOffsets[1]);</span>
<span class="fc" id="L1666">            mask |= (ZONE_OFFSET_MASK|DST_OFFSET_MASK);</span>
        }

<span class="fc bfc" id="L1669" title="All 2 branches covered.">        if ((fieldMask &amp; (DAY_OF_YEAR_MASK|WEEK_OF_YEAR_MASK</span>
                          |WEEK_OF_MONTH_MASK|DAY_OF_WEEK_IN_MONTH_MASK)) != 0) {
<span class="fc" id="L1671">            int normalizedYear = jdate.getNormalizedYear();</span>
            // If it's a year of an era transition, we need to handle
            // irregular year boundaries.
<span class="fc" id="L1674">            boolean transitionYear = isTransitionYear(jdate.getNormalizedYear());</span>
            int dayOfYear;
            long fixedDateJan1;
<span class="pc bpc" id="L1677" title="1 of 2 branches missed.">            if (transitionYear) {</span>
<span class="nc" id="L1678">                fixedDateJan1 = getFixedDateJan1(jdate, fixedDate);</span>
<span class="nc" id="L1679">                dayOfYear = (int)(fixedDate - fixedDateJan1) + 1;</span>
<span class="pc bpc" id="L1680" title="1 of 2 branches missed.">            } else if (normalizedYear == MIN_VALUES[YEAR]) {</span>
<span class="nc" id="L1681">                CalendarDate dx = jcal.getCalendarDate(Long.MIN_VALUE, getZone());</span>
<span class="nc" id="L1682">                fixedDateJan1 = jcal.getFixedDate(dx);</span>
<span class="nc" id="L1683">                dayOfYear = (int)(fixedDate - fixedDateJan1) + 1;</span>
<span class="nc" id="L1684">            } else {</span>
<span class="fc" id="L1685">                dayOfYear = (int) jcal.getDayOfYear(jdate);</span>
<span class="fc" id="L1686">                fixedDateJan1 = fixedDate - dayOfYear + 1;</span>
            }
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">            long fixedDateMonth1 = transitionYear ?</span>
<span class="pc" id="L1689">                getFixedDateMonth1(jdate, fixedDate) : fixedDate - dayOfMonth + 1;</span>

<span class="fc" id="L1691">            internalSet(DAY_OF_YEAR, dayOfYear);</span>
<span class="fc" id="L1692">            internalSet(DAY_OF_WEEK_IN_MONTH, (dayOfMonth - 1) / 7 + 1);</span>

<span class="fc" id="L1694">            int weekOfYear = getWeekNumber(fixedDateJan1, fixedDate);</span>

            // The spec is to calculate WEEK_OF_YEAR in the
            // ISO8601-style. This creates problems, though.
<span class="pc bpc" id="L1698" title="1 of 2 branches missed.">            if (weekOfYear == 0) {</span>
                // If the date belongs to the last week of the
                // previous year, use the week number of &quot;12/31&quot; of
                // the &quot;previous&quot; year. Again, if the previous year is
                // a transition year, we need to take care of it.
                // Usually the previous day of the first day of a year
                // is December 31, which is not always true in the
                // Japanese imperial calendar system.
<span class="nc" id="L1706">                long fixedDec31 = fixedDateJan1 - 1;</span>
                long prevJan1;
<span class="nc" id="L1708">                LocalGregorianCalendar.Date d = getCalendarDate(fixedDec31);</span>
<span class="nc bnc" id="L1709" title="All 4 branches missed.">                if (!(transitionYear || isTransitionYear(d.getNormalizedYear()))) {</span>
<span class="nc" id="L1710">                    prevJan1 = fixedDateJan1 - 365;</span>
<span class="nc bnc" id="L1711" title="All 2 branches missed.">                    if (d.isLeapYear()) {</span>
<span class="nc" id="L1712">                        --prevJan1;</span>
                    }
<span class="nc bnc" id="L1714" title="All 2 branches missed.">                } else if (transitionYear) {</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">                    if (jdate.getYear() == 1) {</span>
                        // As of Heisei (since Meiji) there's no case
                        // that there are multiple transitions in a
                        // year.  Historically there was such
                        // case. There might be such case again in the
                        // future.
<span class="nc bnc" id="L1721" title="All 2 branches missed.">                        if (era &gt; HEISEI) {</span>
<span class="nc" id="L1722">                            CalendarDate pd = eras[era - 1].getSinceDate();</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">                            if (normalizedYear == pd.getYear()) {</span>
<span class="nc" id="L1724">                                d.setMonth(pd.getMonth()).setDayOfMonth(pd.getDayOfMonth());</span>
                            }
<span class="nc" id="L1726">                        } else {</span>
<span class="nc" id="L1727">                            d.setMonth(LocalGregorianCalendar.JANUARY).setDayOfMonth(1);</span>
                        }
<span class="nc" id="L1729">                        jcal.normalize(d);</span>
<span class="nc" id="L1730">                        prevJan1 = jcal.getFixedDate(d);</span>
                    } else {
<span class="nc" id="L1732">                        prevJan1 = fixedDateJan1 - 365;</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">                        if (d.isLeapYear()) {</span>
<span class="nc" id="L1734">                            --prevJan1;</span>
                        }
                    }
                } else {
<span class="nc" id="L1738">                    CalendarDate cd = eras[getEraIndex(jdate)].getSinceDate();</span>
<span class="nc" id="L1739">                    d.setMonth(cd.getMonth()).setDayOfMonth(cd.getDayOfMonth());</span>
<span class="nc" id="L1740">                    jcal.normalize(d);</span>
<span class="nc" id="L1741">                    prevJan1 = jcal.getFixedDate(d);</span>
                }
<span class="nc" id="L1743">                weekOfYear = getWeekNumber(prevJan1, fixedDec31);</span>
<span class="nc" id="L1744">            } else {</span>
<span class="pc bpc" id="L1745" title="1 of 2 branches missed.">                if (!transitionYear) {</span>
                    // Regular years
<span class="fc bfc" id="L1747" title="All 2 branches covered.">                    if (weekOfYear &gt;= 52) {</span>
<span class="fc" id="L1748">                        long nextJan1 = fixedDateJan1 + 365;</span>
<span class="pc bpc" id="L1749" title="1 of 2 branches missed.">                        if (jdate.isLeapYear()) {</span>
<span class="fc" id="L1750">                            nextJan1++;</span>
                        }
<span class="fc" id="L1752">                        long nextJan1st = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(nextJan1 + 6,</span>
<span class="fc" id="L1753">                                                                                            getFirstDayOfWeek());</span>
<span class="fc" id="L1754">                        int ndays = (int)(nextJan1st - nextJan1);</span>
<span class="pc bpc" id="L1755" title="1 of 4 branches missed.">                        if (ndays &gt;= getMinimalDaysInFirstWeek() &amp;&amp; fixedDate &gt;= (nextJan1st - 7)) {</span>
                            // The first days forms a week in which the date is included.
<span class="fc" id="L1757">                            weekOfYear = 1;</span>
                        }
<span class="fc" id="L1759">                    }</span>
                } else {
<span class="nc" id="L1761">                    LocalGregorianCalendar.Date d = (LocalGregorianCalendar.Date) jdate.clone();</span>
                    long nextJan1;
<span class="nc bnc" id="L1763" title="All 2 branches missed.">                    if (jdate.getYear() == 1) {</span>
<span class="nc" id="L1764">                        d.addYear(+1);</span>
<span class="nc" id="L1765">                        d.setMonth(LocalGregorianCalendar.JANUARY).setDayOfMonth(1);</span>
<span class="nc" id="L1766">                        nextJan1 = jcal.getFixedDate(d);</span>
                    } else {
<span class="nc" id="L1768">                        int nextEraIndex = getEraIndex(d) + 1;</span>
<span class="nc" id="L1769">                        CalendarDate cd = eras[nextEraIndex].getSinceDate();</span>
<span class="nc" id="L1770">                        d.setEra(eras[nextEraIndex]);</span>
<span class="nc" id="L1771">                        d.setDate(1, cd.getMonth(), cd.getDayOfMonth());</span>
<span class="nc" id="L1772">                        jcal.normalize(d);</span>
<span class="nc" id="L1773">                        nextJan1 = jcal.getFixedDate(d);</span>
                    }
<span class="nc" id="L1775">                    long nextJan1st = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(nextJan1 + 6,</span>
<span class="nc" id="L1776">                                                                                        getFirstDayOfWeek());</span>
<span class="nc" id="L1777">                    int ndays = (int)(nextJan1st - nextJan1);</span>
<span class="nc bnc" id="L1778" title="All 4 branches missed.">                    if (ndays &gt;= getMinimalDaysInFirstWeek() &amp;&amp; fixedDate &gt;= (nextJan1st - 7)) {</span>
                        // The first days forms a week in which the date is included.
<span class="nc" id="L1780">                        weekOfYear = 1;</span>
                    }
                }
            }
<span class="fc" id="L1784">            internalSet(WEEK_OF_YEAR, weekOfYear);</span>
<span class="fc" id="L1785">            internalSet(WEEK_OF_MONTH, getWeekNumber(fixedDateMonth1, fixedDate));</span>
<span class="fc" id="L1786">            mask |= (DAY_OF_YEAR_MASK|WEEK_OF_YEAR_MASK|WEEK_OF_MONTH_MASK|DAY_OF_WEEK_IN_MONTH_MASK);</span>
        }
<span class="fc" id="L1788">        return mask;</span>
    }

    /**
     * Returns the number of weeks in a period between fixedDay1 and
     * fixedDate. The getFirstDayOfWeek-getMinimalDaysInFirstWeek rule
     * is applied to calculate the number of weeks.
     *
     * @param fixedDay1 the fixed date of the first day of the period
     * @param fixedDate the fixed date of the last day of the period
     * @return the number of weeks of the given period
     */
    private int getWeekNumber(long fixedDay1, long fixedDate) {
        // We can always use `jcal' since Julian and Gregorian are the
        // same thing for this calculation.
<span class="fc" id="L1803">        long fixedDay1st = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(fixedDay1 + 6,</span>
<span class="fc" id="L1804">                                                                             getFirstDayOfWeek());</span>
<span class="fc" id="L1805">        int ndays = (int)(fixedDay1st - fixedDay1);</span>
<span class="pc bpc" id="L1806" title="2 of 4 branches missed.">        assert ndays &lt;= 7;</span>
<span class="fc bfc" id="L1807" title="All 2 branches covered.">        if (ndays &gt;= getMinimalDaysInFirstWeek()) {</span>
<span class="fc" id="L1808">            fixedDay1st -= 7;</span>
        }
<span class="fc" id="L1810">        int normalizedDayOfPeriod = (int)(fixedDate - fixedDay1st);</span>
<span class="pc bpc" id="L1811" title="1 of 2 branches missed.">        if (normalizedDayOfPeriod &gt;= 0) {</span>
<span class="fc" id="L1812">            return normalizedDayOfPeriod / 7 + 1;</span>
        }
<span class="nc" id="L1814">        return CalendarUtils.floorDivide(normalizedDayOfPeriod, 7) + 1;</span>
    }

    /**
     * Converts calendar field values to the time value (millisecond
     * offset from the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;).
     *
     * @exception IllegalArgumentException if any calendar fields are invalid.
     */
    protected void computeTime() {
        // In non-lenient mode, perform brief checking of calendar
        // fields which have been set externally. Through this
        // checking, the field values are stored in originalFields[]
        // to see if any of them are normalized later.
<span class="pc bpc" id="L1828" title="1 of 2 branches missed.">        if (!isLenient()) {</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">            if (originalFields == null) {</span>
<span class="nc" id="L1830">                originalFields = new int[FIELD_COUNT];</span>
            }
<span class="nc bnc" id="L1832" title="All 2 branches missed.">            for (int field = 0; field &lt; FIELD_COUNT; field++) {</span>
<span class="nc" id="L1833">                int value = internalGet(field);</span>
<span class="nc bnc" id="L1834" title="All 2 branches missed.">                if (isExternallySet(field)) {</span>
                    // Quick validation for any out of range values
<span class="nc bnc" id="L1836" title="All 4 branches missed.">                    if (value &lt; getMinimum(field) || value &gt; getMaximum(field)) {</span>
<span class="nc" id="L1837">                        throw new IllegalArgumentException(getFieldName(field));</span>
                    }
                }
<span class="nc" id="L1840">                originalFields[field] = value;</span>
            }
        }

        // Let the super class determine which calendar fields to be
        // used to calculate the time.
<span class="fc" id="L1846">        int fieldMask = selectFields();</span>

        int year;
        int era;

<span class="fc bfc" id="L1851" title="All 2 branches covered.">        if (isSet(ERA)) {</span>
<span class="fc" id="L1852">            era = internalGet(ERA);</span>
<span class="pc bpc" id="L1853" title="1 of 2 branches missed.">            year = isSet(YEAR) ? internalGet(YEAR) : 1;</span>
        } else {
<span class="pc bpc" id="L1855" title="1 of 2 branches missed.">            if (isSet(YEAR)) {</span>
<span class="fc" id="L1856">                era = eras.length - 1;</span>
<span class="fc" id="L1857">                year = internalGet(YEAR);</span>
            } else {
                // Equivalent to 1970 (Gregorian)
<span class="nc" id="L1860">                era = SHOWA;</span>
<span class="nc" id="L1861">                year = 45;</span>
            }
        }

        // Calculate the time of day. We rely on the convention that
        // an UNSET field has 0.
<span class="fc" id="L1867">        long timeOfDay = 0;</span>
<span class="fc bfc" id="L1868" title="All 2 branches covered.">        if (isFieldSet(fieldMask, HOUR_OF_DAY)) {</span>
<span class="fc" id="L1869">            timeOfDay += (long) internalGet(HOUR_OF_DAY);</span>
        } else {
<span class="fc" id="L1871">            timeOfDay += internalGet(HOUR);</span>
            // The default value of AM_PM is 0 which designates AM.
<span class="pc bpc" id="L1873" title="1 of 2 branches missed.">            if (isFieldSet(fieldMask, AM_PM)) {</span>
<span class="nc" id="L1874">                timeOfDay += 12 * internalGet(AM_PM);</span>
            }
        }
<span class="fc" id="L1877">        timeOfDay *= 60;</span>
<span class="fc" id="L1878">        timeOfDay += internalGet(MINUTE);</span>
<span class="fc" id="L1879">        timeOfDay *= 60;</span>
<span class="fc" id="L1880">        timeOfDay += internalGet(SECOND);</span>
<span class="fc" id="L1881">        timeOfDay *= 1000;</span>
<span class="fc" id="L1882">        timeOfDay += internalGet(MILLISECOND);</span>

        // Convert the time of day to the number of days and the
        // millisecond offset from midnight.
<span class="fc" id="L1886">        long fixedDate = timeOfDay / ONE_DAY;</span>
<span class="fc" id="L1887">        timeOfDay %= ONE_DAY;</span>
<span class="pc bpc" id="L1888" title="1 of 2 branches missed.">        while (timeOfDay &lt; 0) {</span>
<span class="nc" id="L1889">            timeOfDay += ONE_DAY;</span>
<span class="nc" id="L1890">            --fixedDate;</span>
        }

        // Calculate the fixed date since January 1, 1 (Gregorian).
<span class="fc" id="L1894">        fixedDate += getFixedDate(era, year, fieldMask);</span>

        // millis represents local wall-clock time in milliseconds.
<span class="fc" id="L1897">        long millis = (fixedDate - EPOCH_OFFSET) * ONE_DAY + timeOfDay;</span>

        // Compute the time zone offset and DST offset.  There are two potential
        // ambiguities here.  We'll assume a 2:00 am (wall time) switchover time
        // for discussion purposes here.
        // 1. The transition into DST.  Here, a designated time of 2:00 am - 2:59 am
        //    can be in standard or in DST depending.  However, 2:00 am is an invalid
        //    representation (the representation jumps from 1:59:59 am Std to 3:00:00 am DST).
        //    We assume standard time.
        // 2. The transition out of DST.  Here, a designated time of 1:00 am - 1:59 am
        //    can be in standard or DST.  Both are valid representations (the rep
        //    jumps from 1:59:59 DST to 1:00:00 Std).
        //    Again, we assume standard time.
        // We use the TimeZone object, unless the user has explicitly set the ZONE_OFFSET
        // or DST_OFFSET fields; then we use those fields.
<span class="fc" id="L1912">        TimeZone zone = getZone();</span>
<span class="fc bfc" id="L1913" title="All 2 branches covered.">        if (zoneOffsets == null) {</span>
<span class="fc" id="L1914">            zoneOffsets = new int[2];</span>
        }
<span class="fc" id="L1916">        int tzMask = fieldMask &amp; (ZONE_OFFSET_MASK|DST_OFFSET_MASK);</span>
<span class="pc bpc" id="L1917" title="1 of 2 branches missed.">        if (tzMask != (ZONE_OFFSET_MASK|DST_OFFSET_MASK)) {</span>
<span class="pc bpc" id="L1918" title="1 of 2 branches missed.">            if (zone instanceof ZoneInfo) {</span>
<span class="fc" id="L1919">                ((ZoneInfo)zone).getOffsetsByWall(millis, zoneOffsets);</span>
            } else {
<span class="nc" id="L1921">                zone.getOffsets(millis - zone.getRawOffset(), zoneOffsets);</span>
            }
        }
<span class="pc bpc" id="L1924" title="1 of 2 branches missed.">        if (tzMask != 0) {</span>
<span class="nc bnc" id="L1925" title="All 2 branches missed.">            if (isFieldSet(tzMask, ZONE_OFFSET)) {</span>
<span class="nc" id="L1926">                zoneOffsets[0] = internalGet(ZONE_OFFSET);</span>
            }
<span class="nc bnc" id="L1928" title="All 2 branches missed.">            if (isFieldSet(tzMask, DST_OFFSET)) {</span>
<span class="nc" id="L1929">                zoneOffsets[1] = internalGet(DST_OFFSET);</span>
            }
        }

        // Adjust the time zone offset values to get the UTC time.
<span class="fc" id="L1934">        millis -= zoneOffsets[0] + zoneOffsets[1];</span>

        // Set this calendar's time in milliseconds
<span class="fc" id="L1937">        time = millis;</span>

<span class="fc" id="L1939">        int mask = computeFields(fieldMask | getSetStateFields(), tzMask);</span>

<span class="pc bpc" id="L1941" title="1 of 2 branches missed.">        if (!isLenient()) {</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">            for (int field = 0; field &lt; FIELD_COUNT; field++) {</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">                if (!isExternallySet(field)) {</span>
<span class="nc" id="L1944">                    continue;</span>
                }
<span class="nc bnc" id="L1946" title="All 2 branches missed.">                if (originalFields[field] != internalGet(field)) {</span>
<span class="nc" id="L1947">                    int wrongValue = internalGet(field);</span>
                    // Restore the original field values
<span class="nc" id="L1949">                    System.arraycopy(originalFields, 0, fields, 0, fields.length);</span>
<span class="nc" id="L1950">                    throw new IllegalArgumentException(getFieldName(field) + &quot;=&quot; + wrongValue</span>
                                                       + &quot;, expected &quot; + originalFields[field]);
                }
            }
        }
<span class="fc" id="L1955">        setFieldsNormalized(mask);</span>
<span class="fc" id="L1956">    }</span>

    /**
     * Computes the fixed date under either the Gregorian or the
     * Julian calendar, using the given year and the specified calendar fields.
     *
     * @param era era index
     * @param year the normalized year number, with 0 indicating the
     * year 1 BCE, -1 indicating 2 BCE, etc.
     * @param fieldMask the calendar fields to be used for the date calculation
     * @return the fixed date
     * @see Calendar#selectFields
     */
    private long getFixedDate(int era, int year, int fieldMask) {
<span class="fc" id="L1970">        int month = JANUARY;</span>
<span class="fc" id="L1971">        int firstDayOfMonth = 1;</span>
<span class="fc bfc" id="L1972" title="All 2 branches covered.">        if (isFieldSet(fieldMask, MONTH)) {</span>
            // No need to check if MONTH has been set (no isSet(MONTH)
            // call) since its unset value happens to be JANUARY (0).
<span class="fc" id="L1975">            month = internalGet(MONTH);</span>

            // If the month is out of range, adjust it into range.
<span class="pc bpc" id="L1978" title="1 of 2 branches missed.">            if (month &gt; DECEMBER) {</span>
<span class="nc" id="L1979">                year += month / 12;</span>
<span class="nc" id="L1980">                month %= 12;</span>
<span class="pc bpc" id="L1981" title="1 of 2 branches missed.">            } else if (month &lt; JANUARY) {</span>
<span class="nc" id="L1982">                int[] rem = new int[1];</span>
<span class="nc" id="L1983">                year += CalendarUtils.floorDivide(month, 12, rem);</span>
<span class="nc" id="L1984">                month = rem[0];</span>
<span class="nc" id="L1985">            }</span>
        } else {
<span class="pc bpc" id="L1987" title="3 of 4 branches missed.">            if (year == 1 &amp;&amp; era != 0) {</span>
<span class="nc" id="L1988">                CalendarDate d = eras[era].getSinceDate();</span>
<span class="nc" id="L1989">                month = d.getMonth() - 1;</span>
<span class="nc" id="L1990">                firstDayOfMonth = d.getDayOfMonth();</span>
            }
        }

        // Adjust the base date if year is the minimum value.
<span class="pc bpc" id="L1995" title="1 of 2 branches missed.">        if (year == MIN_VALUES[YEAR]) {</span>
<span class="nc" id="L1996">            CalendarDate dx = jcal.getCalendarDate(Long.MIN_VALUE, getZone());</span>
<span class="nc" id="L1997">            int m = dx.getMonth() - 1;</span>
<span class="nc bnc" id="L1998" title="All 2 branches missed.">            if (month &lt; m) {</span>
<span class="nc" id="L1999">                month = m;</span>
            }
<span class="nc bnc" id="L2001" title="All 2 branches missed.">            if (month == m) {</span>
<span class="nc" id="L2002">                firstDayOfMonth = dx.getDayOfMonth();</span>
            }
        }

<span class="fc" id="L2006">        LocalGregorianCalendar.Date date = jcal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="pc bpc" id="L2007" title="1 of 2 branches missed.">        date.setEra(era &gt; 0 ? eras[era] : null);</span>
<span class="fc" id="L2008">        date.setDate(year, month + 1, firstDayOfMonth);</span>
<span class="fc" id="L2009">        jcal.normalize(date);</span>

        // Get the fixed date since Jan 1, 1 (Gregorian). We are on
        // the first day of either `month' or January in 'year'.
<span class="fc" id="L2013">        long fixedDate = jcal.getFixedDate(date);</span>

<span class="fc bfc" id="L2015" title="All 2 branches covered.">        if (isFieldSet(fieldMask, MONTH)) {</span>
            // Month-based calculations
<span class="pc bpc" id="L2017" title="1 of 2 branches missed.">            if (isFieldSet(fieldMask, DAY_OF_MONTH)) {</span>
                // We are on the &quot;first day&quot; of the month (which may
                // not be 1). Just add the offset if DAY_OF_MONTH is
                // set. If the isSet call returns false, that means
                // DAY_OF_MONTH has been selected just because of the
                // selected combination. We don't need to add any
                // since the default value is the &quot;first day&quot;.
<span class="pc bpc" id="L2024" title="1 of 2 branches missed.">                if (isSet(DAY_OF_MONTH)) {</span>
                    // To avoid underflow with DAY_OF_MONTH-firstDayOfMonth, add
                    // DAY_OF_MONTH, then subtract firstDayOfMonth.
<span class="fc" id="L2027">                    fixedDate += internalGet(DAY_OF_MONTH);</span>
<span class="fc" id="L2028">                    fixedDate -= firstDayOfMonth;</span>
                }
            } else {
<span class="nc bnc" id="L2031" title="All 2 branches missed.">                if (isFieldSet(fieldMask, WEEK_OF_MONTH)) {</span>
<span class="nc" id="L2032">                    long firstDayOfWeek = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(fixedDate + 6,</span>
<span class="nc" id="L2033">                                                                                            getFirstDayOfWeek());</span>
                    // If we have enough days in the first week, then
                    // move to the previous week.
<span class="nc bnc" id="L2036" title="All 2 branches missed.">                    if ((firstDayOfWeek - fixedDate) &gt;= getMinimalDaysInFirstWeek()) {</span>
<span class="nc" id="L2037">                        firstDayOfWeek -= 7;</span>
                    }
<span class="nc bnc" id="L2039" title="All 2 branches missed.">                    if (isFieldSet(fieldMask, DAY_OF_WEEK)) {</span>
<span class="nc" id="L2040">                        firstDayOfWeek = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6,</span>
<span class="nc" id="L2041">                                                                                           internalGet(DAY_OF_WEEK));</span>
                    }
                    // In lenient mode, we treat days of the previous
                    // months as a part of the specified
                    // WEEK_OF_MONTH. See 4633646.
<span class="nc" id="L2046">                    fixedDate = firstDayOfWeek + 7 * (internalGet(WEEK_OF_MONTH) - 1);</span>
<span class="nc" id="L2047">                } else {</span>
                    int dayOfWeek;
<span class="nc bnc" id="L2049" title="All 2 branches missed.">                    if (isFieldSet(fieldMask, DAY_OF_WEEK)) {</span>
<span class="nc" id="L2050">                        dayOfWeek = internalGet(DAY_OF_WEEK);</span>
                    } else {
<span class="nc" id="L2052">                        dayOfWeek = getFirstDayOfWeek();</span>
                    }
                    // We are basing this on the day-of-week-in-month.  The only
                    // trickiness occurs if the day-of-week-in-month is
                    // negative.
                    int dowim;
<span class="nc bnc" id="L2058" title="All 2 branches missed.">                    if (isFieldSet(fieldMask, DAY_OF_WEEK_IN_MONTH)) {</span>
<span class="nc" id="L2059">                        dowim = internalGet(DAY_OF_WEEK_IN_MONTH);</span>
                    } else {
<span class="nc" id="L2061">                        dowim = 1;</span>
                    }
<span class="nc bnc" id="L2063" title="All 2 branches missed.">                    if (dowim &gt;= 0) {</span>
<span class="nc" id="L2064">                        fixedDate = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(fixedDate + (7 * dowim) - 1,</span>
                                                                                      dayOfWeek);
                    } else {
                        // Go to the first day of the next week of
                        // the specified week boundary.
<span class="nc" id="L2069">                        int lastDate = monthLength(month, year) + (7 * (dowim + 1));</span>
                        // Then, get the day of week date on or before the last date.
<span class="nc" id="L2071">                        fixedDate = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(fixedDate + lastDate - 1,</span>
                                                                                      dayOfWeek);
                    }
<span class="nc" id="L2074">                }</span>
            }
        } else {
            // We are on the first day of the year.
<span class="pc bpc" id="L2078" title="1 of 2 branches missed.">            if (isFieldSet(fieldMask, DAY_OF_YEAR)) {</span>
<span class="nc bnc" id="L2079" title="All 2 branches missed.">                if (isTransitionYear(date.getNormalizedYear())) {</span>
<span class="nc" id="L2080">                    fixedDate = getFixedDateJan1(date, fixedDate);</span>
                }
                // Add the offset, then subtract 1. (Make sure to avoid underflow.)
<span class="nc" id="L2083">                fixedDate += internalGet(DAY_OF_YEAR);</span>
<span class="nc" id="L2084">                fixedDate--;</span>
            } else {
<span class="fc" id="L2086">                long firstDayOfWeek = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(fixedDate + 6,</span>
<span class="fc" id="L2087">                                                                                        getFirstDayOfWeek());</span>
                // If we have enough days in the first week, then move
                // to the previous week.
<span class="pc bpc" id="L2090" title="1 of 2 branches missed.">                if ((firstDayOfWeek - fixedDate) &gt;= getMinimalDaysInFirstWeek()) {</span>
<span class="fc" id="L2091">                    firstDayOfWeek -= 7;</span>
                }
<span class="pc bpc" id="L2093" title="1 of 2 branches missed.">                if (isFieldSet(fieldMask, DAY_OF_WEEK)) {</span>
<span class="fc" id="L2094">                    int dayOfWeek = internalGet(DAY_OF_WEEK);</span>
<span class="pc bpc" id="L2095" title="1 of 2 branches missed.">                    if (dayOfWeek != getFirstDayOfWeek()) {</span>
<span class="fc" id="L2096">                        firstDayOfWeek = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6,</span>
                                                                                           dayOfWeek);
                    }
                }
<span class="fc" id="L2100">                fixedDate = firstDayOfWeek + 7 * ((long)internalGet(WEEK_OF_YEAR) - 1);</span>
            }
        }
<span class="fc" id="L2103">        return fixedDate;</span>
    }

    /**
     * Returns the fixed date of the first day of the year (usually
     * January 1) before the specified date.
     *
     * @param date the date for which the first day of the year is
     * calculated. The date has to be in the cut-over year.
     * @param fixedDate the fixed date representation of the date
     */
    private long getFixedDateJan1(LocalGregorianCalendar.Date date, long fixedDate) {
<span class="nc" id="L2115">        Era era = date.getEra();</span>
<span class="nc bnc" id="L2116" title="All 4 branches missed.">        if (date.getEra() != null &amp;&amp; date.getYear() == 1) {</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">            for (int eraIndex = getEraIndex(date); eraIndex &gt; 0; eraIndex--) {</span>
<span class="nc" id="L2118">                CalendarDate d = eras[eraIndex].getSinceDate();</span>
<span class="nc" id="L2119">                long fd = gcal.getFixedDate(d);</span>
                // There might be multiple era transitions in a year.
<span class="nc bnc" id="L2121" title="All 2 branches missed.">                if (fd &gt; fixedDate) {</span>
<span class="nc" id="L2122">                    continue;</span>
                }
<span class="nc" id="L2124">                return fd;</span>
            }
        }
<span class="nc" id="L2127">        CalendarDate d = gcal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="nc" id="L2128">        d.setDate(date.getNormalizedYear(), Gregorian.JANUARY, 1);</span>
<span class="nc" id="L2129">        return gcal.getFixedDate(d);</span>
    }

    /**
     * Returns the fixed date of the first date of the month (usually
     * the 1st of the month) before the specified date.
     *
     * @param date the date for which the first day of the month is
     * calculated. The date must be in the era transition year.
     * @param fixedDate the fixed date representation of the date
     */
    private long getFixedDateMonth1(LocalGregorianCalendar.Date date,
                                          long fixedDate) {
<span class="nc" id="L2142">        int eraIndex = getTransitionEraIndex(date);</span>
<span class="nc bnc" id="L2143" title="All 2 branches missed.">        if (eraIndex != -1) {</span>
<span class="nc" id="L2144">            long transition = sinceFixedDates[eraIndex];</span>
            // If the given date is on or after the transition date, then
            // return the transition date.
<span class="nc bnc" id="L2147" title="All 2 branches missed.">            if (transition &lt;= fixedDate) {</span>
<span class="nc" id="L2148">                return transition;</span>
            }
        }

        // Otherwise, we can use the 1st day of the month.
<span class="nc" id="L2153">        return fixedDate - date.getDayOfMonth() + 1;</span>
    }

    /**
     * Returns a LocalGregorianCalendar.Date produced from the specified fixed date.
     *
     * @param fd the fixed date
     */
    private static LocalGregorianCalendar.Date getCalendarDate(long fd) {
<span class="fc" id="L2162">        LocalGregorianCalendar.Date d = jcal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="fc" id="L2163">        jcal.getCalendarDateFromFixedDate(d, fd);</span>
<span class="fc" id="L2164">        return d;</span>
    }

    /**
     * Returns the length of the specified month in the specified
     * Gregorian year. The year number must be normalized.
     *
     * @see GregorianCalendar#isLeapYear(int)
     */
    private int monthLength(int month, int gregorianYear) {
<span class="nc bnc" id="L2174" title="All 2 branches missed.">        return CalendarUtils.isGregorianLeapYear(gregorianYear) ?</span>
            GregorianCalendar.LEAP_MONTH_LENGTH[month] : GregorianCalendar.MONTH_LENGTH[month];
    }

    /**
     * Returns the length of the specified month in the year provided
     * by internalGet(YEAR).
     *
     * @see GregorianCalendar#isLeapYear(int)
     */
    private int monthLength(int month) {
<span class="nc bnc" id="L2185" title="All 4 branches missed.">        assert jdate.isNormalized();</span>
<span class="nc bnc" id="L2186" title="All 2 branches missed.">        return jdate.isLeapYear() ?</span>
            GregorianCalendar.LEAP_MONTH_LENGTH[month] : GregorianCalendar.MONTH_LENGTH[month];
    }

    private int actualMonthLength() {
<span class="nc" id="L2191">        int length = jcal.getMonthLength(jdate);</span>
<span class="nc" id="L2192">        int eraIndex = getTransitionEraIndex(jdate);</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">        if (eraIndex == -1) {</span>
<span class="nc" id="L2194">            long transitionFixedDate = sinceFixedDates[eraIndex];</span>
<span class="nc" id="L2195">            CalendarDate d = eras[eraIndex].getSinceDate();</span>
<span class="nc bnc" id="L2196" title="All 2 branches missed.">            if (transitionFixedDate &lt;= cachedFixedDate) {</span>
<span class="nc" id="L2197">                length -= d.getDayOfMonth() - 1;</span>
            } else {
<span class="nc" id="L2199">                length = d.getDayOfMonth() - 1;</span>
            }
        }
<span class="nc" id="L2202">        return length;</span>
    }

    /**
     * Returns the index to the new era if the given date is in a
     * transition month.  For example, if the give date is Heisei 1
     * (1989) January 20, then the era index for Heisei is
     * returned. Likewise, if the given date is Showa 64 (1989)
     * January 3, then the era index for Heisei is returned. If the
     * given date is not in any transition month, then -1 is returned.
     */
    private static int getTransitionEraIndex(LocalGregorianCalendar.Date date) {
<span class="nc" id="L2214">        int eraIndex = getEraIndex(date);</span>
<span class="nc" id="L2215">        CalendarDate transitionDate = eras[eraIndex].getSinceDate();</span>
<span class="nc bnc" id="L2216" title="All 2 branches missed.">        if (transitionDate.getYear() == date.getNormalizedYear() &amp;&amp;</span>
<span class="nc bnc" id="L2217" title="All 2 branches missed.">            transitionDate.getMonth() == date.getMonth()) {</span>
<span class="nc" id="L2218">            return eraIndex;</span>
        }
<span class="nc bnc" id="L2220" title="All 2 branches missed.">        if (eraIndex &lt; eras.length - 1) {</span>
<span class="nc" id="L2221">            transitionDate = eras[++eraIndex].getSinceDate();</span>
<span class="nc bnc" id="L2222" title="All 2 branches missed.">            if (transitionDate.getYear() == date.getNormalizedYear() &amp;&amp;</span>
<span class="nc bnc" id="L2223" title="All 2 branches missed.">                transitionDate.getMonth() == date.getMonth()) {</span>
<span class="nc" id="L2224">                return eraIndex;</span>
            }
        }
<span class="nc" id="L2227">        return -1;</span>
    }

    private boolean isTransitionYear(int normalizedYear) {
<span class="pc bpc" id="L2231" title="1 of 2 branches missed.">        for (int i = eras.length - 1; i &gt; 0; i--) {</span>
<span class="fc" id="L2232">            int transitionYear = eras[i].getSinceDate().getYear();</span>
<span class="pc bpc" id="L2233" title="1 of 2 branches missed.">            if (normalizedYear == transitionYear) {</span>
<span class="nc" id="L2234">                return true;</span>
            }
<span class="fc bfc" id="L2236" title="All 2 branches covered.">            if (normalizedYear &gt; transitionYear) {</span>
<span class="fc" id="L2237">                break;</span>
            }
        }
<span class="fc" id="L2240">        return false;</span>
    }

    private static int getEraIndex(LocalGregorianCalendar.Date date) {
<span class="fc" id="L2244">        Era era = date.getEra();</span>
<span class="pc bpc" id="L2245" title="1 of 2 branches missed.">        for (int i = eras.length - 1; i &gt; 0; i--) {</span>
<span class="fc bfc" id="L2246" title="All 2 branches covered.">            if (eras[i] == era) {</span>
<span class="fc" id="L2247">                return i;</span>
            }
        }
<span class="nc" id="L2250">        return 0;</span>
    }

    /**
     * Returns this object if it's normalized (all fields and time are
     * in sync). Otherwise, a cloned object is returned after calling
     * complete() in lenient mode.
     */
    private JapaneseImperialCalendar getNormalizedCalendar() {
        JapaneseImperialCalendar jc;
<span class="nc bnc" id="L2260" title="All 2 branches missed.">        if (isFullyNormalized()) {</span>
<span class="nc" id="L2261">            jc = this;</span>
        } else {
            // Create a clone and normalize the calendar fields
<span class="nc" id="L2264">            jc = (JapaneseImperialCalendar) this.clone();</span>
<span class="nc" id="L2265">            jc.setLenient(true);</span>
<span class="nc" id="L2266">            jc.complete();</span>
        }
<span class="nc" id="L2268">        return jc;</span>
    }

    /**
     * After adjustments such as add(MONTH), add(YEAR), we don't want the
     * month to jump around.  E.g., we don't want Jan 31 + 1 month to go to Mar
     * 3, we want it to go to Feb 28.  Adjustments which might run into this
     * problem call this method to retain the proper month.
     */
    private void pinDayOfMonth(LocalGregorianCalendar.Date date) {
<span class="fc" id="L2278">        int year = date.getYear();</span>
<span class="fc" id="L2279">        int dom = date.getDayOfMonth();</span>
<span class="pc bpc" id="L2280" title="1 of 2 branches missed.">        if (year != getMinimum(YEAR)) {</span>
<span class="fc" id="L2281">            date.setDayOfMonth(1);</span>
<span class="fc" id="L2282">            jcal.normalize(date);</span>
<span class="fc" id="L2283">            int monthLength = jcal.getMonthLength(date);</span>
<span class="pc bpc" id="L2284" title="1 of 2 branches missed.">            if (dom &gt; monthLength) {</span>
<span class="nc" id="L2285">                date.setDayOfMonth(monthLength);</span>
            } else {
<span class="fc" id="L2287">                date.setDayOfMonth(dom);</span>
            }
<span class="fc" id="L2289">            jcal.normalize(date);</span>
<span class="fc" id="L2290">        } else {</span>
<span class="nc" id="L2291">            LocalGregorianCalendar.Date d = jcal.getCalendarDate(Long.MIN_VALUE, getZone());</span>
<span class="nc" id="L2292">            LocalGregorianCalendar.Date realDate = jcal.getCalendarDate(time, getZone());</span>
<span class="nc" id="L2293">            long tod = realDate.getTimeOfDay();</span>
            // Use an equivalent year.
<span class="nc" id="L2295">            realDate.addYear(+400);</span>
<span class="nc" id="L2296">            realDate.setMonth(date.getMonth());</span>
<span class="nc" id="L2297">            realDate.setDayOfMonth(1);</span>
<span class="nc" id="L2298">            jcal.normalize(realDate);</span>
<span class="nc" id="L2299">            int monthLength = jcal.getMonthLength(realDate);</span>
<span class="nc bnc" id="L2300" title="All 2 branches missed.">            if (dom &gt; monthLength) {</span>
<span class="nc" id="L2301">                realDate.setDayOfMonth(monthLength);</span>
            } else {
<span class="nc bnc" id="L2303" title="All 2 branches missed.">                if (dom &lt; d.getDayOfMonth()) {</span>
<span class="nc" id="L2304">                    realDate.setDayOfMonth(d.getDayOfMonth());</span>
                } else {
<span class="nc" id="L2306">                    realDate.setDayOfMonth(dom);</span>
                }
            }
<span class="nc bnc" id="L2309" title="All 4 branches missed.">            if (realDate.getDayOfMonth() == d.getDayOfMonth() &amp;&amp; tod &lt; d.getTimeOfDay()) {</span>
<span class="nc" id="L2310">                realDate.setDayOfMonth(Math.min(dom + 1, monthLength));</span>
            }
            // restore the year.
<span class="nc" id="L2313">            date.setDate(year, realDate.getMonth(), realDate.getDayOfMonth());</span>
            // Don't normalize date here so as not to cause underflow.
        }
<span class="fc" id="L2316">    }</span>

    /**
     * Returns the new value after 'roll'ing the specified value and amount.
     */
    private static int getRolledValue(int value, int amount, int min, int max) {
<span class="nc bnc" id="L2322" title="All 6 branches missed.">        assert value &gt;= min &amp;&amp; value &lt;= max;</span>
<span class="nc" id="L2323">        int range = max - min + 1;</span>
<span class="nc" id="L2324">        amount %= range;</span>
<span class="nc" id="L2325">        int n = value + amount;</span>
<span class="nc bnc" id="L2326" title="All 2 branches missed.">        if (n &gt; max) {</span>
<span class="nc" id="L2327">            n -= range;</span>
<span class="nc bnc" id="L2328" title="All 2 branches missed.">        } else if (n &lt; min) {</span>
<span class="nc" id="L2329">            n += range;</span>
        }
<span class="nc bnc" id="L2331" title="All 6 branches missed.">        assert n &gt;= min &amp;&amp; n &lt;= max;</span>
<span class="nc" id="L2332">        return n;</span>
    }

    /**
     * Returns the ERA.  We need a special method for this because the
     * default ERA is the current era, but a zero (unset) ERA means before Meiji.
     */
    private int internalGetEra() {
<span class="nc bnc" id="L2340" title="All 2 branches missed.">        return isSet(ERA) ? internalGet(ERA) : eras.length - 1;</span>
    }

    /**
     * Updates internal state.
     */
    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
<span class="nc" id="L2348">        stream.defaultReadObject();</span>
<span class="nc bnc" id="L2349" title="All 2 branches missed.">        if (jdate == null) {</span>
<span class="nc" id="L2350">            jdate = jcal.newCalendarDate(getZone());</span>
<span class="nc" id="L2351">            cachedFixedDate = Long.MIN_VALUE;</span>
        }
<span class="nc" id="L2353">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>