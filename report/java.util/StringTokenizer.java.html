<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>StringTokenizer.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">StringTokenizer.java</span></div><h1>StringTokenizer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.lang.*;

/**
 * The string tokenizer class allows an application to break a
 * string into tokens. The tokenization method is much simpler than
 * the one used by the &lt;code&gt;StreamTokenizer&lt;/code&gt; class. The
 * &lt;code&gt;StringTokenizer&lt;/code&gt; methods do not distinguish among
 * identifiers, numbers, and quoted strings, nor do they recognize
 * and skip comments.
 * &lt;p&gt;
 * The set of delimiters (the characters that separate tokens) may
 * be specified either at creation time or on a per-token basis.
 * &lt;p&gt;
 * An instance of &lt;code&gt;StringTokenizer&lt;/code&gt; behaves in one of two
 * ways, depending on whether it was created with the
 * &lt;code&gt;returnDelims&lt;/code&gt; flag having the value &lt;code&gt;true&lt;/code&gt;
 * or &lt;code&gt;false&lt;/code&gt;:
 * &lt;ul&gt;
 * &lt;li&gt;If the flag is &lt;code&gt;false&lt;/code&gt;, delimiter characters serve to
 *     separate tokens. A token is a maximal sequence of consecutive
 *     characters that are not delimiters.
 * &lt;li&gt;If the flag is &lt;code&gt;true&lt;/code&gt;, delimiter characters are themselves
 *     considered to be tokens. A token is thus either one delimiter
 *     character, or a maximal sequence of consecutive characters that are
 *     not delimiters.
 * &lt;/ul&gt;&lt;p&gt;
 * A &lt;tt&gt;StringTokenizer&lt;/tt&gt; object internally maintains a current
 * position within the string to be tokenized. Some operations advance this
 * current position past the characters processed.&lt;p&gt;
 * A token is returned by taking a substring of the string that was used to
 * create the &lt;tt&gt;StringTokenizer&lt;/tt&gt; object.
 * &lt;p&gt;
 * The following is one example of the use of the tokenizer. The code:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     StringTokenizer st = new StringTokenizer(&quot;this is a test&quot;);
 *     while (st.hasMoreTokens()) {
 *         System.out.println(st.nextToken());
 *     }
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;
 * prints the following output:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     this
 *     is
 *     a
 *     test
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * &lt;tt&gt;StringTokenizer&lt;/tt&gt; is a legacy class that is retained for
 * compatibility reasons although its use is discouraged in new code. It is
 * recommended that anyone seeking this functionality use the &lt;tt&gt;split&lt;/tt&gt;
 * method of &lt;tt&gt;String&lt;/tt&gt; or the java.util.regex package instead.
 * &lt;p&gt;
 * The following example illustrates how the &lt;tt&gt;String.split&lt;/tt&gt;
 * method can be used to break up a string into its basic tokens:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     String[] result = &quot;this is a test&quot;.split(&quot;\\s&quot;);
 *     for (int x=0; x&amp;lt;result.length; x++)
 *         System.out.println(result[x]);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;
 * prints the following output:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     this
 *     is
 *     a
 *     test
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * @author  unascribed
 * @see     java.io.StreamTokenizer
 * @since   JDK1.0
 */
public
class StringTokenizer implements Enumeration&lt;Object&gt; {
    private int currentPosition;
    private int newPosition;
    private int maxPosition;
    private String str;
    private String delimiters;
    private boolean retDelims;
    private boolean delimsChanged;

    /**
     * maxDelimCodePoint stores the value of the delimiter character with the
     * highest value. It is used to optimize the detection of delimiter
     * characters.
     *
     * It is unlikely to provide any optimization benefit in the
     * hasSurrogates case because most string characters will be
     * smaller than the limit, but we keep it so that the two code
     * paths remain similar.
     */
    private int maxDelimCodePoint;

    /**
     * If delimiters include any surrogates (including surrogate
     * pairs), hasSurrogates is true and the tokenizer uses the
     * different code path. This is because String.indexOf(int)
     * doesn't handle unpaired surrogates as a single character.
     */
<span class="fc" id="L130">    private boolean hasSurrogates = false;</span>

    /**
     * When hasSurrogates is true, delimiters are converted to code
     * points and isDelimiter(int) is used to determine if the given
     * codepoint is a delimiter.
     */
    private int[] delimiterCodePoints;

    /**
     * Set maxDelimCodePoint to the highest char in the delimiter set.
     */
    private void setMaxDelimCodePoint() {
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (delimiters == null) {</span>
<span class="nc" id="L144">            maxDelimCodePoint = 0;</span>
<span class="nc" id="L145">            return;</span>
        }

<span class="fc" id="L148">        int m = 0;</span>
        int c;
<span class="fc" id="L150">        int count = 0;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (int i = 0; i &lt; delimiters.length(); i += Character.charCount(c)) {</span>
<span class="fc" id="L152">            c = delimiters.charAt(i);</span>
<span class="pc bpc" id="L153" title="3 of 4 branches missed.">            if (c &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp; c &lt;= Character.MAX_LOW_SURROGATE) {</span>
<span class="nc" id="L154">                c = delimiters.codePointAt(i);</span>
<span class="nc" id="L155">                hasSurrogates = true;</span>
            }
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (m &lt; c)</span>
<span class="fc" id="L158">                m = c;</span>
<span class="fc" id="L159">            count++;</span>
        }
<span class="fc" id="L161">        maxDelimCodePoint = m;</span>

<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (hasSurrogates) {</span>
<span class="nc" id="L164">            delimiterCodePoints = new int[count];</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">            for (int i = 0, j = 0; i &lt; count; i++, j += Character.charCount(c)) {</span>
<span class="nc" id="L166">                c = delimiters.codePointAt(j);</span>
<span class="nc" id="L167">                delimiterCodePoints[i] = c;</span>
            }
        }
<span class="fc" id="L170">    }</span>

    /**
     * Constructs a string tokenizer for the specified string. All
     * characters in the &lt;code&gt;delim&lt;/code&gt; argument are the delimiters
     * for separating tokens.
     * &lt;p&gt;
     * If the &lt;code&gt;returnDelims&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, then
     * the delimiter characters are also returned as tokens. Each
     * delimiter is returned as a string of length one. If the flag is
     * &lt;code&gt;false&lt;/code&gt;, the delimiter characters are skipped and only
     * serve as separators between tokens.
     * &lt;p&gt;
     * Note that if &lt;tt&gt;delim&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this constructor does
     * not throw an exception. However, trying to invoke other methods on the
     * resulting &lt;tt&gt;StringTokenizer&lt;/tt&gt; may result in a
     * &lt;tt&gt;NullPointerException&lt;/tt&gt;.
     *
     * @param   str            a string to be parsed.
     * @param   delim          the delimiters.
     * @param   returnDelims   flag indicating whether to return the delimiters
     *                         as tokens.
     * @exception NullPointerException if str is &lt;CODE&gt;null&lt;/CODE&gt;
     */
<span class="fc" id="L194">    public StringTokenizer(String str, String delim, boolean returnDelims) {</span>
<span class="fc" id="L195">        currentPosition = 0;</span>
<span class="fc" id="L196">        newPosition = -1;</span>
<span class="fc" id="L197">        delimsChanged = false;</span>
<span class="fc" id="L198">        this.str = str;</span>
<span class="fc" id="L199">        maxPosition = str.length();</span>
<span class="fc" id="L200">        delimiters = delim;</span>
<span class="fc" id="L201">        retDelims = returnDelims;</span>
<span class="fc" id="L202">        setMaxDelimCodePoint();</span>
<span class="fc" id="L203">    }</span>

    /**
     * Constructs a string tokenizer for the specified string. The
     * characters in the &lt;code&gt;delim&lt;/code&gt; argument are the delimiters
     * for separating tokens. Delimiter characters themselves will not
     * be treated as tokens.
     * &lt;p&gt;
     * Note that if &lt;tt&gt;delim&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this constructor does
     * not throw an exception. However, trying to invoke other methods on the
     * resulting &lt;tt&gt;StringTokenizer&lt;/tt&gt; may result in a
     * &lt;tt&gt;NullPointerException&lt;/tt&gt;.
     *
     * @param   str     a string to be parsed.
     * @param   delim   the delimiters.
     * @exception NullPointerException if str is &lt;CODE&gt;null&lt;/CODE&gt;
     */
    public StringTokenizer(String str, String delim) {
<span class="fc" id="L221">        this(str, delim, false);</span>
<span class="fc" id="L222">    }</span>

    /**
     * Constructs a string tokenizer for the specified string. The
     * tokenizer uses the default delimiter set, which is
     * &lt;code&gt;&quot;&amp;nbsp;&amp;#92;t&amp;#92;n&amp;#92;r&amp;#92;f&quot;&lt;/code&gt;: the space character,
     * the tab character, the newline character, the carriage-return character,
     * and the form-feed character. Delimiter characters themselves will
     * not be treated as tokens.
     *
     * @param   str   a string to be parsed.
     * @exception NullPointerException if str is &lt;CODE&gt;null&lt;/CODE&gt;
     */
    public StringTokenizer(String str) {
<span class="fc" id="L236">        this(str, &quot; \t\n\r\f&quot;, false);</span>
<span class="fc" id="L237">    }</span>

    /**
     * Skips delimiters starting from the specified position. If retDelims
     * is false, returns the index of the first non-delimiter character at or
     * after startPos. If retDelims is true, startPos is returned.
     */
    private int skipDelimiters(int startPos) {
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (delimiters == null)</span>
<span class="nc" id="L246">            throw new NullPointerException();</span>

<span class="fc" id="L248">        int position = startPos;</span>
<span class="fc bfc" id="L249" title="All 4 branches covered.">        while (!retDelims &amp;&amp; position &lt; maxPosition) {</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">            if (!hasSurrogates) {</span>
<span class="fc" id="L251">                char c = str.charAt(position);</span>
<span class="fc bfc" id="L252" title="All 4 branches covered.">                if ((c &gt; maxDelimCodePoint) || (delimiters.indexOf(c) &lt; 0))</span>
<span class="fc" id="L253">                    break;</span>
<span class="fc" id="L254">                position++;</span>
<span class="fc" id="L255">            } else {</span>
<span class="nc" id="L256">                int c = str.codePointAt(position);</span>
<span class="nc bnc" id="L257" title="All 4 branches missed.">                if ((c &gt; maxDelimCodePoint) || !isDelimiter(c)) {</span>
<span class="nc" id="L258">                    break;</span>
                }
<span class="nc" id="L260">                position += Character.charCount(c);</span>
<span class="nc" id="L261">            }</span>
        }
<span class="fc" id="L263">        return position;</span>
    }

    /**
     * Skips ahead from startPos and returns the index of the next delimiter
     * character encountered, or maxPosition if no such delimiter is found.
     */
    private int scanToken(int startPos) {
<span class="fc" id="L271">        int position = startPos;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        while (position &lt; maxPosition) {</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">            if (!hasSurrogates) {</span>
<span class="fc" id="L274">                char c = str.charAt(position);</span>
<span class="fc bfc" id="L275" title="All 4 branches covered.">                if ((c &lt;= maxDelimCodePoint) &amp;&amp; (delimiters.indexOf(c) &gt;= 0))</span>
<span class="fc" id="L276">                    break;</span>
<span class="fc" id="L277">                position++;</span>
<span class="fc" id="L278">            } else {</span>
<span class="nc" id="L279">                int c = str.codePointAt(position);</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">                if ((c &lt;= maxDelimCodePoint) &amp;&amp; isDelimiter(c))</span>
<span class="nc" id="L281">                    break;</span>
<span class="nc" id="L282">                position += Character.charCount(c);</span>
<span class="nc" id="L283">            }</span>
        }
<span class="fc bfc" id="L285" title="All 4 branches covered.">        if (retDelims &amp;&amp; (startPos == position)) {</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">            if (!hasSurrogates) {</span>
<span class="fc" id="L287">                char c = str.charAt(position);</span>
<span class="pc bpc" id="L288" title="2 of 4 branches missed.">                if ((c &lt;= maxDelimCodePoint) &amp;&amp; (delimiters.indexOf(c) &gt;= 0))</span>
<span class="fc" id="L289">                    position++;</span>
<span class="fc" id="L290">            } else {</span>
<span class="nc" id="L291">                int c = str.codePointAt(position);</span>
<span class="nc bnc" id="L292" title="All 4 branches missed.">                if ((c &lt;= maxDelimCodePoint) &amp;&amp; isDelimiter(c))</span>
<span class="nc" id="L293">                    position += Character.charCount(c);</span>
            }
        }
<span class="fc" id="L296">        return position;</span>
    }

    private boolean isDelimiter(int codePoint) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        for (int i = 0; i &lt; delimiterCodePoints.length; i++) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (delimiterCodePoints[i] == codePoint) {</span>
<span class="nc" id="L302">                return true;</span>
            }
        }
<span class="nc" id="L305">        return false;</span>
    }

    /**
     * Tests if there are more tokens available from this tokenizer's string.
     * If this method returns &lt;tt&gt;true&lt;/tt&gt;, then a subsequent call to
     * &lt;tt&gt;nextToken&lt;/tt&gt; with no argument will successfully return a token.
     *
     * @return  &lt;code&gt;true&lt;/code&gt; if and only if there is at least one token
     *          in the string after the current position; &lt;code&gt;false&lt;/code&gt;
     *          otherwise.
     */
    public boolean hasMoreTokens() {
        /*
         * Temporarily store this position and use it in the following
         * nextToken() method only if the delimiters haven't been changed in
         * that nextToken() invocation.
         */
<span class="fc" id="L323">        newPosition = skipDelimiters(currentPosition);</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">        return (newPosition &lt; maxPosition);</span>
    }

    /**
     * Returns the next token from this string tokenizer.
     *
     * @return     the next token from this string tokenizer.
     * @exception  NoSuchElementException  if there are no more tokens in this
     *               tokenizer's string.
     */
    public String nextToken() {
        /*
         * If next position already computed in hasMoreElements() and
         * delimiters have changed between the computation and this invocation,
         * then use the computed value.
         */

<span class="pc bpc" id="L341" title="1 of 4 branches missed.">        currentPosition = (newPosition &gt;= 0 &amp;&amp; !delimsChanged) ?</span>
<span class="fc" id="L342">            newPosition : skipDelimiters(currentPosition);</span>

        /* Reset these anyway */
<span class="fc" id="L345">        delimsChanged = false;</span>
<span class="fc" id="L346">        newPosition = -1;</span>

<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (currentPosition &gt;= maxPosition)</span>
<span class="fc" id="L349">            throw new NoSuchElementException();</span>
<span class="fc" id="L350">        int start = currentPosition;</span>
<span class="fc" id="L351">        currentPosition = scanToken(currentPosition);</span>
<span class="fc" id="L352">        return str.substring(start, currentPosition);</span>
    }

    /**
     * Returns the next token in this string tokenizer's string. First,
     * the set of characters considered to be delimiters by this
     * &lt;tt&gt;StringTokenizer&lt;/tt&gt; object is changed to be the characters in
     * the string &lt;tt&gt;delim&lt;/tt&gt;. Then the next token in the string
     * after the current position is returned. The current position is
     * advanced beyond the recognized token.  The new delimiter set
     * remains the default after this call.
     *
     * @param      delim   the new delimiters.
     * @return     the next token, after switching to the new delimiter set.
     * @exception  NoSuchElementException  if there are no more tokens in this
     *               tokenizer's string.
     * @exception NullPointerException if delim is &lt;CODE&gt;null&lt;/CODE&gt;
     */
    public String nextToken(String delim) {
<span class="fc" id="L371">        delimiters = delim;</span>

        /* delimiter string specified, so set the appropriate flag. */
<span class="fc" id="L374">        delimsChanged = true;</span>

<span class="fc" id="L376">        setMaxDelimCodePoint();</span>
<span class="fc" id="L377">        return nextToken();</span>
    }

    /**
     * Returns the same value as the &lt;code&gt;hasMoreTokens&lt;/code&gt;
     * method. It exists so that this class can implement the
     * &lt;code&gt;Enumeration&lt;/code&gt; interface.
     *
     * @return  &lt;code&gt;true&lt;/code&gt; if there are more tokens;
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see     java.util.Enumeration
     * @see     java.util.StringTokenizer#hasMoreTokens()
     */
    public boolean hasMoreElements() {
<span class="fc" id="L391">        return hasMoreTokens();</span>
    }

    /**
     * Returns the same value as the &lt;code&gt;nextToken&lt;/code&gt; method,
     * except that its declared return value is &lt;code&gt;Object&lt;/code&gt; rather than
     * &lt;code&gt;String&lt;/code&gt;. It exists so that this class can implement the
     * &lt;code&gt;Enumeration&lt;/code&gt; interface.
     *
     * @return     the next token in the string.
     * @exception  NoSuchElementException  if there are no more tokens in this
     *               tokenizer's string.
     * @see        java.util.Enumeration
     * @see        java.util.StringTokenizer#nextToken()
     */
    public Object nextElement() {
<span class="fc" id="L407">        return nextToken();</span>
    }

    /**
     * Calculates the number of times that this tokenizer's
     * &lt;code&gt;nextToken&lt;/code&gt; method can be called before it generates an
     * exception. The current position is not advanced.
     *
     * @return  the number of tokens remaining in the string using the current
     *          delimiter set.
     * @see     java.util.StringTokenizer#nextToken()
     */
    public int countTokens() {
<span class="fc" id="L420">        int count = 0;</span>
<span class="fc" id="L421">        int currpos = currentPosition;</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">        while (currpos &lt; maxPosition) {</span>
<span class="fc" id="L423">            currpos = skipDelimiters(currpos);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">            if (currpos &gt;= maxPosition)</span>
<span class="fc" id="L425">                break;</span>
<span class="fc" id="L426">            currpos = scanToken(currpos);</span>
<span class="fc" id="L427">            count++;</span>
        }
<span class="fc" id="L429">        return count;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>