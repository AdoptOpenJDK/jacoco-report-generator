<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>TreeMap.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">TreeMap.java</span></div><h1>TreeMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.io.Serializable;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;

/**
 * A Red-Black tree based {@link NavigableMap} implementation.
 * The map is sorted according to the {@linkplain Comparable natural
 * ordering} of its keys, or by a {@link Comparator} provided at map
 * creation time, depending on which constructor is used.
 *
 * &lt;p&gt;This implementation provides guaranteed log(n) time cost for the
 * {@code containsKey}, {@code get}, {@code put} and {@code remove}
 * operations.  Algorithms are adaptations of those in Cormen, Leiserson, and
 * Rivest's &lt;em&gt;Introduction to Algorithms&lt;/em&gt;.
 *
 * &lt;p&gt;Note that the ordering maintained by a tree map, like any sorted map, and
 * whether or not an explicit comparator is provided, must be &lt;em&gt;consistent
 * with {@code equals}&lt;/em&gt; if this sorted map is to correctly implement the
 * {@code Map} interface.  (See {@code Comparable} or {@code Comparator} for a
 * precise definition of &lt;em&gt;consistent with equals&lt;/em&gt;.)  This is so because
 * the {@code Map} interface is defined in terms of the {@code equals}
 * operation, but a sorted map performs all key comparisons using its {@code
 * compareTo} (or {@code compare}) method, so two keys that are deemed equal by
 * this method are, from the standpoint of the sorted map, equal.  The behavior
 * of a sorted map &lt;em&gt;is&lt;/em&gt; well-defined even if its ordering is
 * inconsistent with {@code equals}; it just fails to obey the general contract
 * of the {@code Map} interface.
 *
 * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
 * If multiple threads access a map concurrently, and at least one of the
 * threads modifies the map structurally, it &lt;em&gt;must&lt;/em&gt; be synchronized
 * externally.  (A structural modification is any operation that adds or
 * deletes one or more mappings; merely changing the value associated
 * with an existing key is not a structural modification.)  This is
 * typically accomplished by synchronizing on some object that naturally
 * encapsulates the map.
 * If no such object exists, the map should be &quot;wrapped&quot; using the
 * {@link Collections#synchronizedSortedMap Collections.synchronizedSortedMap}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access to the map: &lt;pre&gt;
 *   SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));&lt;/pre&gt;
 *
 * &lt;p&gt;The iterators returned by the {@code iterator} method of the collections
 * returned by all of this class's &quot;collection view methods&quot; are
 * &lt;em&gt;fail-fast&lt;/em&gt;: if the map is structurally modified at any time after
 * the iterator is created, in any way except through the iterator's own
 * {@code remove} method, the iterator will throw a {@link
 * ConcurrentModificationException}.  Thus, in the face of concurrent
 * modification, the iterator fails quickly and cleanly, rather than risking
 * arbitrary, non-deterministic behavior at an undetermined time in the future.
 *
 * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw {@code ConcurrentModificationException} on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness:   &lt;em&gt;the fail-fast behavior of iterators
 * should be used only to detect bugs.&lt;/em&gt;
 *
 * &lt;p&gt;All {@code Map.Entry} pairs returned by methods in this class
 * and its views represent snapshots of mappings at the time they were
 * produced. They do &lt;strong&gt;not&lt;/strong&gt; support the {@code Entry.setValue}
 * method. (Note however that it is possible to change mappings in the
 * associated map using {@code put}.)
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @param &lt;K&gt; the type of keys maintained by this map
 * @param &lt;V&gt; the type of mapped values
 *
 * @author  Josh Bloch and Doug Lea
 * @see Map
 * @see HashMap
 * @see Hashtable
 * @see Comparable
 * @see Comparator
 * @see Collection
 * @since 1.2
 */

public class TreeMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable
{
    /**
     * The comparator used to maintain order in this tree map, or
     * null if it uses the natural ordering of its keys.
     *
     * @serial
     */
    private final Comparator&lt;? super K&gt; comparator;

<span class="pc" id="L123">    private transient Entry&lt;K,V&gt; root = null;</span>

    /**
     * The number of entries in the tree
     */
<span class="pc" id="L128">    private transient int size = 0;</span>

    /**
     * The number of structural modifications to the tree.
     */
<span class="pc" id="L133">    private transient int modCount = 0;</span>

    /**
     * Constructs a new, empty tree map, using the natural ordering of its
     * keys.  All keys inserted into the map must implement the {@link
     * Comparable} interface.  Furthermore, all such keys must be
     * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw
     * a {@code ClassCastException} for any keys {@code k1} and
     * {@code k2} in the map.  If the user attempts to put a key into the
     * map that violates this constraint (for example, the user attempts to
     * put a string key into a map whose keys are integers), the
     * {@code put(Object key, Object value)} call will throw a
     * {@code ClassCastException}.
     */
<span class="fc" id="L147">    public TreeMap() {</span>
<span class="fc" id="L148">        comparator = null;</span>
<span class="fc" id="L149">    }</span>

    /**
     * Constructs a new, empty tree map, ordered according to the given
     * comparator.  All keys inserted into the map must be &lt;em&gt;mutually
     * comparable&lt;/em&gt; by the given comparator: {@code comparator.compare(k1,
     * k2)} must not throw a {@code ClassCastException} for any keys
     * {@code k1} and {@code k2} in the map.  If the user attempts to put
     * a key into the map that violates this constraint, the {@code put(Object
     * key, Object value)} call will throw a
     * {@code ClassCastException}.
     *
     * @param comparator the comparator that will be used to order this map.
     *        If {@code null}, the {@linkplain Comparable natural
     *        ordering} of the keys will be used.
     */
<span class="fc" id="L165">    public TreeMap(Comparator&lt;? super K&gt; comparator) {</span>
<span class="fc" id="L166">        this.comparator = comparator;</span>
<span class="fc" id="L167">    }</span>

    /**
     * Constructs a new tree map containing the same mappings as the given
     * map, ordered according to the &lt;em&gt;natural ordering&lt;/em&gt; of its keys.
     * All keys inserted into the new map must implement the {@link
     * Comparable} interface.  Furthermore, all such keys must be
     * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw
     * a {@code ClassCastException} for any keys {@code k1} and
     * {@code k2} in the map.  This method runs in n*log(n) time.
     *
     * @param  m the map whose mappings are to be placed in this map
     * @throws ClassCastException if the keys in m are not {@link Comparable},
     *         or are not mutually comparable
     * @throws NullPointerException if the specified map is null
     */
<span class="fc" id="L183">    public TreeMap(Map&lt;? extends K, ? extends V&gt; m) {</span>
<span class="fc" id="L184">        comparator = null;</span>
<span class="fc" id="L185">        putAll(m);</span>
<span class="fc" id="L186">    }</span>

    /**
     * Constructs a new tree map containing the same mappings and
     * using the same ordering as the specified sorted map.  This
     * method runs in linear time.
     *
     * @param  m the sorted map whose mappings are to be placed in this map,
     *         and whose comparator is to be used to sort this map
     * @throws NullPointerException if the specified map is null
     */
<span class="nc" id="L197">    public TreeMap(SortedMap&lt;K, ? extends V&gt; m) {</span>
<span class="nc" id="L198">        comparator = m.comparator();</span>
        try {
<span class="nc" id="L200">            buildFromSorted(m.size(), m.entrySet().iterator(), null, null);</span>
<span class="nc" id="L201">        } catch (java.io.IOException cannotHappen) {</span>
<span class="nc" id="L202">        } catch (ClassNotFoundException cannotHappen) {</span>
<span class="nc" id="L203">        }</span>
<span class="nc" id="L204">    }</span>


    // Query Operations

    /**
     * Returns the number of key-value mappings in this map.
     *
     * @return the number of key-value mappings in this map
     */
    public int size() {
<span class="fc" id="L215">        return size;</span>
    }

    /**
     * Returns {@code true} if this map contains a mapping for the specified
     * key.
     *
     * @param key key whose presence in this map is to be tested
     * @return {@code true} if this map contains a mapping for the
     *         specified key
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     */
    public boolean containsKey(Object key) {
<span class="fc bfc" id="L232" title="All 2 branches covered.">        return getEntry(key) != null;</span>
    }

    /**
     * Returns {@code true} if this map maps one or more keys to the
     * specified value.  More formally, returns {@code true} if and only if
     * this map contains at least one mapping to a value {@code v} such
     * that {@code (value==null ? v==null : value.equals(v))}.  This
     * operation will probably require time linear in the map size for
     * most implementations.
     *
     * @param value value whose presence in this map is to be tested
     * @return {@code true} if a mapping to {@code value} exists;
     *         {@code false} otherwise
     * @since 1.2
     */
    public boolean containsValue(Object value) {
<span class="fc bfc" id="L249" title="All 2 branches covered.">        for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e))</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (valEquals(value, e.value))</span>
<span class="fc" id="L251">                return true;</span>
<span class="fc" id="L252">        return false;</span>
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * &lt;p&gt;More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code key} compares
     * equal to {@code k} according to the map's ordering, then this
     * method returns {@code v}; otherwise it returns {@code null}.
     * (There can be at most one such mapping.)
     *
     * &lt;p&gt;A return value of {@code null} does not &lt;em&gt;necessarily&lt;/em&gt;
     * indicate that the map contains no mapping for the key; it's also
     * possible that the map explicitly maps the key to {@code null}.
     * The {@link #containsKey containsKey} operation may be used to
     * distinguish these two cases.
     *
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     */
    public V get(Object key) {
<span class="fc" id="L278">        Entry&lt;K,V&gt; p = getEntry(key);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        return (p==null ? null : p.value);</span>
    }

    public Comparator&lt;? super K&gt; comparator() {
<span class="fc" id="L283">        return comparator;</span>
    }

    /**
     * @throws NoSuchElementException {@inheritDoc}
     */
    public K firstKey() {
<span class="fc" id="L290">        return key(getFirstEntry());</span>
    }

    /**
     * @throws NoSuchElementException {@inheritDoc}
     */
    public K lastKey() {
<span class="fc" id="L297">        return key(getLastEntry());</span>
    }

    /**
     * Copies all of the mappings from the specified map to this map.
     * These mappings replace any mappings that this map had for any
     * of the keys currently in the specified map.
     *
     * @param  map mappings to be stored in this map
     * @throws ClassCastException if the class of a key or value in
     *         the specified map prevents it from being stored in this map
     * @throws NullPointerException if the specified map is null or
     *         the specified map contains a null key and this map does not
     *         permit null keys
     */
    public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
<span class="fc" id="L313">        int mapSize = map.size();</span>
<span class="pc bpc" id="L314" title="2 of 6 branches missed.">        if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) {</span>
<span class="nc" id="L315">            Comparator&lt;?&gt; c = ((SortedMap&lt;?,?&gt;)map).comparator();</span>
<span class="nc bnc" id="L316" title="All 6 branches missed.">            if (c == comparator || (c != null &amp;&amp; c.equals(comparator))) {</span>
<span class="nc" id="L317">                ++modCount;</span>
                try {
<span class="nc" id="L319">                    buildFromSorted(mapSize, map.entrySet().iterator(),</span>
                                    null, null);
<span class="nc" id="L321">                } catch (java.io.IOException cannotHappen) {</span>
<span class="nc" id="L322">                } catch (ClassNotFoundException cannotHappen) {</span>
<span class="nc" id="L323">                }</span>
<span class="nc" id="L324">                return;</span>
            }
        }
<span class="fc" id="L327">        super.putAll(map);</span>
<span class="fc" id="L328">    }</span>

    /**
     * Returns this map's entry for the given key, or {@code null} if the map
     * does not contain an entry for the key.
     *
     * @return this map's entry for the given key, or {@code null} if the map
     *         does not contain an entry for the key
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     */
    final Entry&lt;K,V&gt; getEntry(Object key) {
        // Offload comparator-based version for sake of performance
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (comparator != null)</span>
<span class="fc" id="L345">            return getEntryUsingComparator(key);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (key == null)</span>
<span class="fc" id="L347">            throw new NullPointerException();</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L349">            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span>
<span class="fc" id="L350">        Entry&lt;K,V&gt; p = root;</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">        while (p != null) {</span>
<span class="fc" id="L352">            int cmp = k.compareTo(p.key);</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">            if (cmp &lt; 0)</span>
<span class="fc" id="L354">                p = p.left;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">            else if (cmp &gt; 0)</span>
<span class="fc" id="L356">                p = p.right;</span>
            else
<span class="fc" id="L358">                return p;</span>
<span class="fc" id="L359">        }</span>
<span class="fc" id="L360">        return null;</span>
    }

    /**
     * Version of getEntry using comparator. Split off from getEntry
     * for performance. (This is not worth doing for most methods,
     * that are less dependent on comparator performance, but is
     * worthwhile here.)
     */
    final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L371">            K k = (K) key;</span>
<span class="fc" id="L372">        Comparator&lt;? super K&gt; cpr = comparator;</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">        if (cpr != null) {</span>
<span class="fc" id="L374">            Entry&lt;K,V&gt; p = root;</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">            while (p != null) {</span>
<span class="fc" id="L376">                int cmp = cpr.compare(k, p.key);</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">                if (cmp &lt; 0)</span>
<span class="fc" id="L378">                    p = p.left;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                else if (cmp &gt; 0)</span>
<span class="fc" id="L380">                    p = p.right;</span>
                else
<span class="fc" id="L382">                    return p;</span>
<span class="fc" id="L383">            }</span>
        }
<span class="fc" id="L385">        return null;</span>
    }

    /**
     * Gets the entry corresponding to the specified key; if no such entry
     * exists, returns the entry for the least key greater than the specified
     * key; if no such entry exists (i.e., the greatest key in the Tree is less
     * than the specified key), returns {@code null}.
     */
    final Entry&lt;K,V&gt; getCeilingEntry(K key) {
<span class="fc" id="L395">        Entry&lt;K,V&gt; p = root;</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        while (p != null) {</span>
<span class="fc" id="L397">            int cmp = compare(key, p.key);</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            if (cmp &lt; 0) {</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">                if (p.left != null)</span>
<span class="fc" id="L400">                    p = p.left;</span>
                else
<span class="fc" id="L402">                    return p;</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            } else if (cmp &gt; 0) {</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">                if (p.right != null) {</span>
<span class="fc" id="L405">                    p = p.right;</span>
                } else {
<span class="fc" id="L407">                    Entry&lt;K,V&gt; parent = p.parent;</span>
<span class="fc" id="L408">                    Entry&lt;K,V&gt; ch = p;</span>
<span class="fc bfc" id="L409" title="All 4 branches covered.">                    while (parent != null &amp;&amp; ch == parent.right) {</span>
<span class="fc" id="L410">                        ch = parent;</span>
<span class="fc" id="L411">                        parent = parent.parent;</span>
                    }
<span class="fc" id="L413">                    return parent;</span>
                }
            } else
<span class="fc" id="L416">                return p;</span>
<span class="fc" id="L417">        }</span>
<span class="fc" id="L418">        return null;</span>
    }

    /**
     * Gets the entry corresponding to the specified key; if no such entry
     * exists, returns the entry for the greatest key less than the specified
     * key; if no such entry exists, returns {@code null}.
     */
    final Entry&lt;K,V&gt; getFloorEntry(K key) {
<span class="fc" id="L427">        Entry&lt;K,V&gt; p = root;</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">        while (p != null) {</span>
<span class="fc" id="L429">            int cmp = compare(key, p.key);</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">            if (cmp &gt; 0) {</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">                if (p.right != null)</span>
<span class="fc" id="L432">                    p = p.right;</span>
                else
<span class="fc" id="L434">                    return p;</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">            } else if (cmp &lt; 0) {</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">                if (p.left != null) {</span>
<span class="fc" id="L437">                    p = p.left;</span>
                } else {
<span class="fc" id="L439">                    Entry&lt;K,V&gt; parent = p.parent;</span>
<span class="fc" id="L440">                    Entry&lt;K,V&gt; ch = p;</span>
<span class="fc bfc" id="L441" title="All 4 branches covered.">                    while (parent != null &amp;&amp; ch == parent.left) {</span>
<span class="fc" id="L442">                        ch = parent;</span>
<span class="fc" id="L443">                        parent = parent.parent;</span>
                    }
<span class="fc" id="L445">                    return parent;</span>
                }
            } else
<span class="fc" id="L448">                return p;</span>

<span class="fc" id="L450">        }</span>
<span class="fc" id="L451">        return null;</span>
    }

    /**
     * Gets the entry for the least key greater than the specified
     * key; if no such entry exists, returns the entry for the least
     * key greater than the specified key; if no such entry exists
     * returns {@code null}.
     */
    final Entry&lt;K,V&gt; getHigherEntry(K key) {
<span class="fc" id="L461">        Entry&lt;K,V&gt; p = root;</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">        while (p != null) {</span>
<span class="fc" id="L463">            int cmp = compare(key, p.key);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">            if (cmp &lt; 0) {</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">                if (p.left != null)</span>
<span class="fc" id="L466">                    p = p.left;</span>
                else
<span class="fc" id="L468">                    return p;</span>
            } else {
<span class="fc bfc" id="L470" title="All 2 branches covered.">                if (p.right != null) {</span>
<span class="fc" id="L471">                    p = p.right;</span>
                } else {
<span class="fc" id="L473">                    Entry&lt;K,V&gt; parent = p.parent;</span>
<span class="fc" id="L474">                    Entry&lt;K,V&gt; ch = p;</span>
<span class="fc bfc" id="L475" title="All 4 branches covered.">                    while (parent != null &amp;&amp; ch == parent.right) {</span>
<span class="fc" id="L476">                        ch = parent;</span>
<span class="fc" id="L477">                        parent = parent.parent;</span>
                    }
<span class="fc" id="L479">                    return parent;</span>
                }
            }
<span class="fc" id="L482">        }</span>
<span class="fc" id="L483">        return null;</span>
    }

    /**
     * Returns the entry for the greatest key less than the specified key; if
     * no such entry exists (i.e., the least key in the Tree is greater than
     * the specified key), returns {@code null}.
     */
    final Entry&lt;K,V&gt; getLowerEntry(K key) {
<span class="fc" id="L492">        Entry&lt;K,V&gt; p = root;</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">        while (p != null) {</span>
<span class="fc" id="L494">            int cmp = compare(key, p.key);</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">            if (cmp &gt; 0) {</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">                if (p.right != null)</span>
<span class="fc" id="L497">                    p = p.right;</span>
                else
<span class="fc" id="L499">                    return p;</span>
            } else {
<span class="fc bfc" id="L501" title="All 2 branches covered.">                if (p.left != null) {</span>
<span class="fc" id="L502">                    p = p.left;</span>
                } else {
<span class="fc" id="L504">                    Entry&lt;K,V&gt; parent = p.parent;</span>
<span class="fc" id="L505">                    Entry&lt;K,V&gt; ch = p;</span>
<span class="fc bfc" id="L506" title="All 4 branches covered.">                    while (parent != null &amp;&amp; ch == parent.left) {</span>
<span class="fc" id="L507">                        ch = parent;</span>
<span class="fc" id="L508">                        parent = parent.parent;</span>
                    }
<span class="fc" id="L510">                    return parent;</span>
                }
            }
<span class="fc" id="L513">        }</span>
<span class="fc" id="L514">        return null;</span>
    }

    /**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for the key, the old
     * value is replaced.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     *
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}.
     *         (A {@code null} return can also indicate that the map
     *         previously associated {@code null} with {@code key}.)
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     */
    public V put(K key, V value) {
<span class="fc" id="L536">        Entry&lt;K,V&gt; t = root;</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">        if (t == null) {</span>
<span class="fc" id="L538">            compare(key, key); // type (and possibly null) check</span>

<span class="fc" id="L540">            root = new Entry&lt;&gt;(key, value, null);</span>
<span class="fc" id="L541">            size = 1;</span>
<span class="fc" id="L542">            modCount++;</span>
<span class="fc" id="L543">            return null;</span>
        }
        int cmp;
        Entry&lt;K,V&gt; parent;
        // split comparator and comparable paths
<span class="fc" id="L548">        Comparator&lt;? super K&gt; cpr = comparator;</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">        if (cpr != null) {</span>
            do {
<span class="fc" id="L551">                parent = t;</span>
<span class="fc" id="L552">                cmp = cpr.compare(key, t.key);</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">                if (cmp &lt; 0)</span>
<span class="fc" id="L554">                    t = t.left;</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">                else if (cmp &gt; 0)</span>
<span class="fc" id="L556">                    t = t.right;</span>
                else
<span class="fc" id="L558">                    return t.setValue(value);</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">            } while (t != null);</span>
        }
        else {
<span class="fc bfc" id="L562" title="All 2 branches covered.">            if (key == null)</span>
<span class="fc" id="L563">                throw new NullPointerException();</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L565">                Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span>
            do {
<span class="fc" id="L567">                parent = t;</span>
<span class="fc" id="L568">                cmp = k.compareTo(t.key);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">                if (cmp &lt; 0)</span>
<span class="fc" id="L570">                    t = t.left;</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                else if (cmp &gt; 0)</span>
<span class="fc" id="L572">                    t = t.right;</span>
                else
<span class="fc" id="L574">                    return t.setValue(value);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">            } while (t != null);</span>
        }
<span class="fc" id="L577">        Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">        if (cmp &lt; 0)</span>
<span class="fc" id="L579">            parent.left = e;</span>
        else
<span class="fc" id="L581">            parent.right = e;</span>
<span class="fc" id="L582">        fixAfterInsertion(e);</span>
<span class="fc" id="L583">        size++;</span>
<span class="fc" id="L584">        modCount++;</span>
<span class="fc" id="L585">        return null;</span>
    }

    /**
     * Removes the mapping for this key from this TreeMap if present.
     *
     * @param  key key for which mapping should be removed
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}.
     *         (A {@code null} return can also indicate that the map
     *         previously associated {@code null} with {@code key}.)
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     */
    public V remove(Object key) {
<span class="fc" id="L603">        Entry&lt;K,V&gt; p = getEntry(key);</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">        if (p == null)</span>
<span class="fc" id="L605">            return null;</span>

<span class="fc" id="L607">        V oldValue = p.value;</span>
<span class="fc" id="L608">        deleteEntry(p);</span>
<span class="fc" id="L609">        return oldValue;</span>
    }

    /**
     * Removes all of the mappings from this map.
     * The map will be empty after this call returns.
     */
    public void clear() {
<span class="fc" id="L617">        modCount++;</span>
<span class="fc" id="L618">        size = 0;</span>
<span class="fc" id="L619">        root = null;</span>
<span class="fc" id="L620">    }</span>

    /**
     * Returns a shallow copy of this {@code TreeMap} instance. (The keys and
     * values themselves are not cloned.)
     *
     * @return a shallow copy of this map
     */
    public Object clone() {
        TreeMap&lt;?,?&gt; clone;
        try {
<span class="fc" id="L631">            clone = (TreeMap&lt;?,?&gt;) super.clone();</span>
<span class="nc" id="L632">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L633">            throw new InternalError(e);</span>
<span class="fc" id="L634">        }</span>

        // Put clone into &quot;virgin&quot; state (except for comparator)
<span class="fc" id="L637">        clone.root = null;</span>
<span class="fc" id="L638">        clone.size = 0;</span>
<span class="fc" id="L639">        clone.modCount = 0;</span>
<span class="fc" id="L640">        clone.entrySet = null;</span>
<span class="fc" id="L641">        clone.navigableKeySet = null;</span>
<span class="fc" id="L642">        clone.descendingMap = null;</span>

        // Initialize clone with our mappings
        try {
<span class="fc" id="L646">            clone.buildFromSorted(size, entrySet().iterator(), null, null);</span>
<span class="nc" id="L647">        } catch (java.io.IOException cannotHappen) {</span>
<span class="nc" id="L648">        } catch (ClassNotFoundException cannotHappen) {</span>
<span class="pc" id="L649">        }</span>

<span class="fc" id="L651">        return clone;</span>
    }

    // NavigableMap API methods

    /**
     * @since 1.6
     */
    public Map.Entry&lt;K,V&gt; firstEntry() {
<span class="fc" id="L660">        return exportEntry(getFirstEntry());</span>
    }

    /**
     * @since 1.6
     */
    public Map.Entry&lt;K,V&gt; lastEntry() {
<span class="fc" id="L667">        return exportEntry(getLastEntry());</span>
    }

    /**
     * @since 1.6
     */
    public Map.Entry&lt;K,V&gt; pollFirstEntry() {
<span class="fc" id="L674">        Entry&lt;K,V&gt; p = getFirstEntry();</span>
<span class="fc" id="L675">        Map.Entry&lt;K,V&gt; result = exportEntry(p);</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">        if (p != null)</span>
<span class="fc" id="L677">            deleteEntry(p);</span>
<span class="fc" id="L678">        return result;</span>
    }

    /**
     * @since 1.6
     */
    public Map.Entry&lt;K,V&gt; pollLastEntry() {
<span class="fc" id="L685">        Entry&lt;K,V&gt; p = getLastEntry();</span>
<span class="fc" id="L686">        Map.Entry&lt;K,V&gt; result = exportEntry(p);</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">        if (p != null)</span>
<span class="fc" id="L688">            deleteEntry(p);</span>
<span class="fc" id="L689">        return result;</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @since 1.6
     */
    public Map.Entry&lt;K,V&gt; lowerEntry(K key) {
<span class="fc" id="L700">        return exportEntry(getLowerEntry(key));</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @since 1.6
     */
    public K lowerKey(K key) {
<span class="fc" id="L711">        return keyOrNull(getLowerEntry(key));</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @since 1.6
     */
    public Map.Entry&lt;K,V&gt; floorEntry(K key) {
<span class="fc" id="L722">        return exportEntry(getFloorEntry(key));</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @since 1.6
     */
    public K floorKey(K key) {
<span class="fc" id="L733">        return keyOrNull(getFloorEntry(key));</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @since 1.6
     */
    public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
<span class="fc" id="L744">        return exportEntry(getCeilingEntry(key));</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @since 1.6
     */
    public K ceilingKey(K key) {
<span class="fc" id="L755">        return keyOrNull(getCeilingEntry(key));</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @since 1.6
     */
    public Map.Entry&lt;K,V&gt; higherEntry(K key) {
<span class="fc" id="L766">        return exportEntry(getHigherEntry(key));</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @since 1.6
     */
    public K higherKey(K key) {
<span class="fc" id="L777">        return keyOrNull(getHigherEntry(key));</span>
    }

    // Views

    /**
     * Fields initialized to contain an instance of the entry set view
     * the first time this view is requested.  Views are stateless, so
     * there's no reason to create more than one.
     */
<span class="pc" id="L787">    private transient EntrySet entrySet = null;</span>
<span class="pc" id="L788">    private transient KeySet&lt;K&gt; navigableKeySet = null;</span>
<span class="pc" id="L789">    private transient NavigableMap&lt;K,V&gt; descendingMap = null;</span>

    /**
     * Returns a {@link Set} view of the keys contained in this map.
     *
     * &lt;p&gt;The set's iterator returns the keys in ascending order.
     * The set's spliterator is
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;,
     * &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports {@link Spliterator#SORTED}
     * and {@link Spliterator#ORDERED} with an encounter order that is ascending
     * key order.  The spliterator's comparator (see
     * {@link java.util.Spliterator#getComparator()}) is {@code null} if
     * the tree map's comparator (see {@link #comparator()}) is {@code null}.
     * Otherwise, the spliterator's comparator is the same as or imposes the
     * same total ordering as the tree map's comparator.
     *
     * &lt;p&gt;The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator's own {@code remove} operation), the results of
     * the iteration are undefined.  The set supports element removal,
     * which removes the corresponding mapping from the map, via the
     * {@code Iterator.remove}, {@code Set.remove},
     * {@code removeAll}, {@code retainAll}, and {@code clear}
     * operations.  It does not support the {@code add} or {@code addAll}
     * operations.
     */
    public Set&lt;K&gt; keySet() {
<span class="fc" id="L817">        return navigableKeySet();</span>
    }

    /**
     * @since 1.6
     */
    public NavigableSet&lt;K&gt; navigableKeySet() {
<span class="fc" id="L824">        KeySet&lt;K&gt; nks = navigableKeySet;</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">        return (nks != null) ? nks : (navigableKeySet = new KeySet&lt;&gt;(this));</span>
    }

    /**
     * @since 1.6
     */
    public NavigableSet&lt;K&gt; descendingKeySet() {
<span class="fc" id="L832">        return descendingMap().navigableKeySet();</span>
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     *
     * &lt;p&gt;The collection's iterator returns the values in ascending order
     * of the corresponding keys. The collection's spliterator is
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;,
     * &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports {@link Spliterator#ORDERED}
     * with an encounter order that is ascending order of the corresponding
     * keys.
     *
     * &lt;p&gt;The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.  If the map is
     * modified while an iteration over the collection is in progress
     * (except through the iterator's own {@code remove} operation),
     * the results of the iteration are undefined.  The collection
     * supports element removal, which removes the corresponding
     * mapping from the map, via the {@code Iterator.remove},
     * {@code Collection.remove}, {@code removeAll},
     * {@code retainAll} and {@code clear} operations.  It does not
     * support the {@code add} or {@code addAll} operations.
     */
    public Collection&lt;V&gt; values() {
<span class="fc" id="L857">        Collection&lt;V&gt; vs = values;</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">        return (vs != null) ? vs : (values = new Values());</span>
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     *
     * &lt;p&gt;The set's iterator returns the entries in ascending key order. The
     * sets's spliterator is
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;,
     * &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports {@link Spliterator#SORTED} and
     * {@link Spliterator#ORDERED} with an encounter order that is ascending key
     * order.
     *
     * &lt;p&gt;The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator's own {@code remove} operation, or through the
     * {@code setValue} operation on a map entry returned by the
     * iterator) the results of the iteration are undefined.  The set
     * supports element removal, which removes the corresponding
     * mapping from the map, via the {@code Iterator.remove},
     * {@code Set.remove}, {@code removeAll}, {@code retainAll} and
     * {@code clear} operations.  It does not support the
     * {@code add} or {@code addAll} operations.
     */
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<span class="fc" id="L884">        EntrySet es = entrySet;</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">        return (es != null) ? es : (entrySet = new EntrySet());</span>
    }

    /**
     * @since 1.6
     */
    public NavigableMap&lt;K, V&gt; descendingMap() {
<span class="fc" id="L892">        NavigableMap&lt;K, V&gt; km = descendingMap;</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">        return (km != null) ? km :</span>
            (descendingMap = new DescendingSubMap&lt;&gt;(this,
                                                    true, null, true,
                                                    true, null, true));
    }

    /**
     * @throws ClassCastException       {@inheritDoc}
     * @throws NullPointerException if {@code fromKey} or {@code toKey} is
     *         null and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @throws IllegalArgumentException {@inheritDoc}
     * @since 1.6
     */
    public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
                                    K toKey,   boolean toInclusive) {
<span class="fc" id="L909">        return new AscendingSubMap&lt;&gt;(this,</span>
                                     false, fromKey, fromInclusive,
                                     false, toKey,   toInclusive);
    }

    /**
     * @throws ClassCastException       {@inheritDoc}
     * @throws NullPointerException if {@code toKey} is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @throws IllegalArgumentException {@inheritDoc}
     * @since 1.6
     */
    public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
<span class="fc" id="L923">        return new AscendingSubMap&lt;&gt;(this,</span>
                                     true,  null,  true,
                                     false, toKey, inclusive);
    }

    /**
     * @throws ClassCastException       {@inheritDoc}
     * @throws NullPointerException if {@code fromKey} is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @throws IllegalArgumentException {@inheritDoc}
     * @since 1.6
     */
    public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {
<span class="fc" id="L937">        return new AscendingSubMap&lt;&gt;(this,</span>
                                     false, fromKey, inclusive,
                                     true,  null,    true);
    }

    /**
     * @throws ClassCastException       {@inheritDoc}
     * @throws NullPointerException if {@code fromKey} or {@code toKey} is
     *         null and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @throws IllegalArgumentException {@inheritDoc}
     */
    public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
<span class="fc" id="L950">        return subMap(fromKey, true, toKey, false);</span>
    }

    /**
     * @throws ClassCastException       {@inheritDoc}
     * @throws NullPointerException if {@code toKey} is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @throws IllegalArgumentException {@inheritDoc}
     */
    public SortedMap&lt;K,V&gt; headMap(K toKey) {
<span class="fc" id="L961">        return headMap(toKey, false);</span>
    }

    /**
     * @throws ClassCastException       {@inheritDoc}
     * @throws NullPointerException if {@code fromKey} is null
     *         and this map uses natural ordering, or its comparator
     *         does not permit null keys
     * @throws IllegalArgumentException {@inheritDoc}
     */
    public SortedMap&lt;K,V&gt; tailMap(K fromKey) {
<span class="fc" id="L972">        return tailMap(fromKey, true);</span>
    }

    @Override
    public boolean replace(K key, V oldValue, V newValue) {
<span class="nc" id="L977">        Entry&lt;K,V&gt; p = getEntry(key);</span>
<span class="nc bnc" id="L978" title="All 4 branches missed.">        if (p!=null &amp;&amp; Objects.equals(oldValue, p.value)) {</span>
<span class="nc" id="L979">            p.value = newValue;</span>
<span class="nc" id="L980">            return true;</span>
        }
<span class="nc" id="L982">        return false;</span>
    }

    @Override
    public V replace(K key, V value) {
<span class="nc" id="L987">        Entry&lt;K,V&gt; p = getEntry(key);</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">        if (p!=null) {</span>
<span class="nc" id="L989">            V oldValue = p.value;</span>
<span class="nc" id="L990">            p.value = value;</span>
<span class="nc" id="L991">            return oldValue;</span>
        }
<span class="nc" id="L993">        return null;</span>
    }

    @Override
    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<span class="nc" id="L998">        Objects.requireNonNull(action);</span>
<span class="nc" id="L999">        int expectedModCount = modCount;</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">        for (Entry&lt;K, V&gt; e = getFirstEntry(); e != null; e = successor(e)) {</span>
<span class="nc" id="L1001">            action.accept(e.key, e.value);</span>

<span class="nc bnc" id="L1003" title="All 2 branches missed.">            if (expectedModCount != modCount) {</span>
<span class="nc" id="L1004">                throw new ConcurrentModificationException();</span>
            }
        }
<span class="nc" id="L1007">    }</span>

    @Override
    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
<span class="nc" id="L1011">        Objects.requireNonNull(function);</span>
<span class="nc" id="L1012">        int expectedModCount = modCount;</span>

<span class="nc bnc" id="L1014" title="All 2 branches missed.">        for (Entry&lt;K, V&gt; e = getFirstEntry(); e != null; e = successor(e)) {</span>
<span class="nc" id="L1015">            e.value = function.apply(e.key, e.value);</span>

<span class="nc bnc" id="L1017" title="All 2 branches missed.">            if (expectedModCount != modCount) {</span>
<span class="nc" id="L1018">                throw new ConcurrentModificationException();</span>
            }
        }
<span class="nc" id="L1021">    }</span>

    // View class support

<span class="fc" id="L1025">    class Values extends AbstractCollection&lt;V&gt; {</span>
        public Iterator&lt;V&gt; iterator() {
<span class="fc" id="L1027">            return new ValueIterator(getFirstEntry());</span>
        }

        public int size() {
<span class="fc" id="L1031">            return TreeMap.this.size();</span>
        }

        public boolean contains(Object o) {
<span class="fc" id="L1035">            return TreeMap.this.containsValue(o);</span>
        }

        public boolean remove(Object o) {
<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">            for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) {</span>
<span class="fc bfc" id="L1040" title="All 2 branches covered.">                if (valEquals(e.getValue(), o)) {</span>
<span class="fc" id="L1041">                    deleteEntry(e);</span>
<span class="fc" id="L1042">                    return true;</span>
                }
            }
<span class="nc" id="L1045">            return false;</span>
        }

        public void clear() {
<span class="nc" id="L1049">            TreeMap.this.clear();</span>
<span class="nc" id="L1050">        }</span>

        public Spliterator&lt;V&gt; spliterator() {
<span class="fc" id="L1053">            return new ValueSpliterator&lt;K,V&gt;(TreeMap.this, null, null, 0, -1, 0);</span>
        }
    }

<span class="fc" id="L1057">    class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {</span>
        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
<span class="fc" id="L1059">            return new EntryIterator(getFirstEntry());</span>
        }

        public boolean contains(Object o) {
<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L1064">                return false;</span>
<span class="fc" id="L1065">            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;</span>
<span class="fc" id="L1066">            Object value = entry.getValue();</span>
<span class="fc" id="L1067">            Entry&lt;K,V&gt; p = getEntry(entry.getKey());</span>
<span class="pc bpc" id="L1068" title="1 of 4 branches missed.">            return p != null &amp;&amp; valEquals(p.getValue(), value);</span>
        }

        public boolean remove(Object o) {
<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L1073">                return false;</span>
<span class="fc" id="L1074">            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;</span>
<span class="fc" id="L1075">            Object value = entry.getValue();</span>
<span class="fc" id="L1076">            Entry&lt;K,V&gt; p = getEntry(entry.getKey());</span>
<span class="pc bpc" id="L1077" title="2 of 4 branches missed.">            if (p != null &amp;&amp; valEquals(p.getValue(), value)) {</span>
<span class="fc" id="L1078">                deleteEntry(p);</span>
<span class="fc" id="L1079">                return true;</span>
            }
<span class="nc" id="L1081">            return false;</span>
        }

        public int size() {
<span class="fc" id="L1085">            return TreeMap.this.size();</span>
        }

        public void clear() {
<span class="nc" id="L1089">            TreeMap.this.clear();</span>
<span class="nc" id="L1090">        }</span>

        public Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
<span class="fc" id="L1093">            return new EntrySpliterator&lt;K,V&gt;(TreeMap.this, null, null, 0, -1, 0);</span>
        }
    }

    /*
     * Unlike Values and EntrySet, the KeySet class is static,
     * delegating to a NavigableMap to allow use by SubMaps, which
     * outweighs the ugliness of needing type-tests for the following
     * Iterator methods that are defined appropriately in main versus
     * submap classes.
     */

    Iterator&lt;K&gt; keyIterator() {
<span class="fc" id="L1106">        return new KeyIterator(getFirstEntry());</span>
    }

    Iterator&lt;K&gt; descendingKeyIterator() {
<span class="fc" id="L1110">        return new DescendingKeyIterator(getLastEntry());</span>
    }

    static final class KeySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; {
        private final NavigableMap&lt;E, ?&gt; m;
<span class="fc" id="L1115">        KeySet(NavigableMap&lt;E,?&gt; map) { m = map; }</span>

        public Iterator&lt;E&gt; iterator() {
<span class="fc bfc" id="L1118" title="All 2 branches covered.">            if (m instanceof TreeMap)</span>
<span class="fc" id="L1119">                return ((TreeMap&lt;E,?&gt;)m).keyIterator();</span>
            else
<span class="fc" id="L1121">                return ((TreeMap.NavigableSubMap&lt;E,?&gt;)m).keyIterator();</span>
        }

        public Iterator&lt;E&gt; descendingIterator() {
<span class="fc bfc" id="L1125" title="All 2 branches covered.">            if (m instanceof TreeMap)</span>
<span class="fc" id="L1126">                return ((TreeMap&lt;E,?&gt;)m).descendingKeyIterator();</span>
            else
<span class="fc" id="L1128">                return ((TreeMap.NavigableSubMap&lt;E,?&gt;)m).descendingKeyIterator();</span>
        }

<span class="fc" id="L1131">        public int size() { return m.size(); }</span>
<span class="fc" id="L1132">        public boolean isEmpty() { return m.isEmpty(); }</span>
<span class="fc" id="L1133">        public boolean contains(Object o) { return m.containsKey(o); }</span>
<span class="nc" id="L1134">        public void clear() { m.clear(); }</span>
<span class="fc" id="L1135">        public E lower(E e) { return m.lowerKey(e); }</span>
<span class="fc" id="L1136">        public E floor(E e) { return m.floorKey(e); }</span>
<span class="fc" id="L1137">        public E ceiling(E e) { return m.ceilingKey(e); }</span>
<span class="fc" id="L1138">        public E higher(E e) { return m.higherKey(e); }</span>
<span class="fc" id="L1139">        public E first() { return m.firstKey(); }</span>
<span class="fc" id="L1140">        public E last() { return m.lastKey(); }</span>
<span class="fc" id="L1141">        public Comparator&lt;? super E&gt; comparator() { return m.comparator(); }</span>
        public E pollFirst() {
<span class="nc" id="L1143">            Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">            return (e == null) ? null : e.getKey();</span>
        }
        public E pollLast() {
<span class="nc" id="L1147">            Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">            return (e == null) ? null : e.getKey();</span>
        }
        public boolean remove(Object o) {
<span class="fc" id="L1151">            int oldSize = size();</span>
<span class="fc" id="L1152">            m.remove(o);</span>
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">            return size() != oldSize;</span>
        }
        public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive,
                                      E toElement,   boolean toInclusive) {
<span class="fc" id="L1157">            return new KeySet&lt;&gt;(m.subMap(fromElement, fromInclusive,</span>
                                          toElement,   toInclusive));
        }
        public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
<span class="fc" id="L1161">            return new KeySet&lt;&gt;(m.headMap(toElement, inclusive));</span>
        }
        public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
<span class="fc" id="L1164">            return new KeySet&lt;&gt;(m.tailMap(fromElement, inclusive));</span>
        }
        public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
<span class="fc" id="L1167">            return subSet(fromElement, true, toElement, false);</span>
        }
        public SortedSet&lt;E&gt; headSet(E toElement) {
<span class="fc" id="L1170">            return headSet(toElement, false);</span>
        }
        public SortedSet&lt;E&gt; tailSet(E fromElement) {
<span class="fc" id="L1173">            return tailSet(fromElement, true);</span>
        }
        public NavigableSet&lt;E&gt; descendingSet() {
<span class="fc" id="L1176">            return new KeySet&lt;&gt;(m.descendingMap());</span>
        }

        public Spliterator&lt;E&gt; spliterator() {
<span class="fc" id="L1180">            return keySpliteratorFor(m);</span>
        }
    }

    /**
     * Base class for TreeMap Iterators
     */
    abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; {
        Entry&lt;K,V&gt; next;
        Entry&lt;K,V&gt; lastReturned;
        int expectedModCount;

<span class="fc" id="L1192">        PrivateEntryIterator(Entry&lt;K,V&gt; first) {</span>
<span class="fc" id="L1193">            expectedModCount = modCount;</span>
<span class="fc" id="L1194">            lastReturned = null;</span>
<span class="fc" id="L1195">            next = first;</span>
<span class="fc" id="L1196">        }</span>

        public final boolean hasNext() {
<span class="fc bfc" id="L1199" title="All 2 branches covered.">            return next != null;</span>
        }

        final Entry&lt;K,V&gt; nextEntry() {
<span class="fc" id="L1203">            Entry&lt;K,V&gt; e = next;</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">            if (e == null)</span>
<span class="fc" id="L1205">                throw new NoSuchElementException();</span>
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">            if (modCount != expectedModCount)</span>
<span class="nc" id="L1207">                throw new ConcurrentModificationException();</span>
<span class="fc" id="L1208">            next = successor(e);</span>
<span class="fc" id="L1209">            lastReturned = e;</span>
<span class="fc" id="L1210">            return e;</span>
        }

        final Entry&lt;K,V&gt; prevEntry() {
<span class="fc" id="L1214">            Entry&lt;K,V&gt; e = next;</span>
<span class="fc bfc" id="L1215" title="All 2 branches covered.">            if (e == null)</span>
<span class="fc" id="L1216">                throw new NoSuchElementException();</span>
<span class="pc bpc" id="L1217" title="1 of 2 branches missed.">            if (modCount != expectedModCount)</span>
<span class="nc" id="L1218">                throw new ConcurrentModificationException();</span>
<span class="fc" id="L1219">            next = predecessor(e);</span>
<span class="fc" id="L1220">            lastReturned = e;</span>
<span class="fc" id="L1221">            return e;</span>
        }

        public void remove() {
<span class="fc bfc" id="L1225" title="All 2 branches covered.">            if (lastReturned == null)</span>
<span class="fc" id="L1226">                throw new IllegalStateException();</span>
<span class="pc bpc" id="L1227" title="1 of 2 branches missed.">            if (modCount != expectedModCount)</span>
<span class="nc" id="L1228">                throw new ConcurrentModificationException();</span>
            // deleted entries are replaced by their successors
<span class="fc bfc" id="L1230" title="All 4 branches covered.">            if (lastReturned.left != null &amp;&amp; lastReturned.right != null)</span>
<span class="fc" id="L1231">                next = lastReturned;</span>
<span class="fc" id="L1232">            deleteEntry(lastReturned);</span>
<span class="fc" id="L1233">            expectedModCount = modCount;</span>
<span class="fc" id="L1234">            lastReturned = null;</span>
<span class="fc" id="L1235">        }</span>
    }

    final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
<span class="fc" id="L1239">        EntryIterator(Entry&lt;K,V&gt; first) {</span>
<span class="fc" id="L1240">            super(first);</span>
<span class="fc" id="L1241">        }</span>
        public Map.Entry&lt;K,V&gt; next() {
<span class="fc" id="L1243">            return nextEntry();</span>
        }
    }

    final class ValueIterator extends PrivateEntryIterator&lt;V&gt; {
<span class="fc" id="L1248">        ValueIterator(Entry&lt;K,V&gt; first) {</span>
<span class="fc" id="L1249">            super(first);</span>
<span class="fc" id="L1250">        }</span>
        public V next() {
<span class="fc" id="L1252">            return nextEntry().value;</span>
        }
    }

    final class KeyIterator extends PrivateEntryIterator&lt;K&gt; {
<span class="fc" id="L1257">        KeyIterator(Entry&lt;K,V&gt; first) {</span>
<span class="fc" id="L1258">            super(first);</span>
<span class="fc" id="L1259">        }</span>
        public K next() {
<span class="fc" id="L1261">            return nextEntry().key;</span>
        }
    }

    final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; {
<span class="fc" id="L1266">        DescendingKeyIterator(Entry&lt;K,V&gt; first) {</span>
<span class="fc" id="L1267">            super(first);</span>
<span class="fc" id="L1268">        }</span>
        public K next() {
<span class="fc" id="L1270">            return prevEntry().key;</span>
        }
        public void remove() {
<span class="fc bfc" id="L1273" title="All 2 branches covered.">            if (lastReturned == null)</span>
<span class="fc" id="L1274">                throw new IllegalStateException();</span>
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">            if (modCount != expectedModCount)</span>
<span class="nc" id="L1276">                throw new ConcurrentModificationException();</span>
<span class="fc" id="L1277">            deleteEntry(lastReturned);</span>
<span class="fc" id="L1278">            lastReturned = null;</span>
<span class="fc" id="L1279">            expectedModCount = modCount;</span>
<span class="fc" id="L1280">        }</span>
    }

    // Little utilities

    /**
     * Compares two keys using the correct comparison method for this TreeMap.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    final int compare(Object k1, Object k2) {
<span class="fc bfc" id="L1290" title="All 2 branches covered.">        return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)</span>
<span class="fc" id="L1291">            : comparator.compare((K)k1, (K)k2);</span>
    }

    /**
     * Test two values for equality.  Differs from o1.equals(o2) only in
     * that it copes with {@code null} o1 properly.
     */
    static final boolean valEquals(Object o1, Object o2) {
<span class="pc bpc" id="L1299" title="3 of 4 branches missed.">        return (o1==null ? o2==null : o1.equals(o2));</span>
    }

    /**
     * Return SimpleImmutableEntry for entry, or null if null
     */
    static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) {
<span class="fc bfc" id="L1306" title="All 2 branches covered.">        return (e == null) ? null :</span>
            new AbstractMap.SimpleImmutableEntry&lt;&gt;(e);
    }

    /**
     * Return key for entry, or null if null
     */
    static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) {
<span class="fc bfc" id="L1314" title="All 2 branches covered.">        return (e == null) ? null : e.key;</span>
    }

    /**
     * Returns the key corresponding to the specified Entry.
     * @throws NoSuchElementException if the Entry is null
     */
    static &lt;K&gt; K key(Entry&lt;K,?&gt; e) {
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        if (e==null)</span>
<span class="fc" id="L1323">            throw new NoSuchElementException();</span>
<span class="fc" id="L1324">        return e.key;</span>
    }


    // SubMaps

    /**
     * Dummy value serving as unmatchable fence key for unbounded
     * SubMapIterators
     */
<span class="fc" id="L1334">    private static final Object UNBOUNDED = new Object();</span>

    /**
     * @serial include
     */
    abstract static class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
        implements NavigableMap&lt;K,V&gt;, java.io.Serializable {
        /**
         * The backing map.
         */
        final TreeMap&lt;K,V&gt; m;

        /**
         * Endpoints are represented as triples (fromStart, lo,
         * loInclusive) and (toEnd, hi, hiInclusive). If fromStart is
         * true, then the low (absolute) bound is the start of the
         * backing map, and the other values are ignored. Otherwise,
         * if loInclusive is true, lo is the inclusive bound, else lo
         * is the exclusive bound. Similarly for the upper bound.
         */
        final K lo, hi;
        final boolean fromStart, toEnd;
        final boolean loInclusive, hiInclusive;

        NavigableSubMap(TreeMap&lt;K,V&gt; m,
                        boolean fromStart, K lo, boolean loInclusive,
<span class="fc" id="L1360">                        boolean toEnd,     K hi, boolean hiInclusive) {</span>
<span class="fc bfc" id="L1361" title="All 4 branches covered.">            if (!fromStart &amp;&amp; !toEnd) {</span>
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">                if (m.compare(lo, hi) &gt; 0)</span>
<span class="nc" id="L1363">                    throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;);</span>
            } else {
<span class="fc bfc" id="L1365" title="All 2 branches covered.">                if (!fromStart) // type check</span>
<span class="fc" id="L1366">                    m.compare(lo, lo);</span>
<span class="fc bfc" id="L1367" title="All 2 branches covered.">                if (!toEnd)</span>
<span class="fc" id="L1368">                    m.compare(hi, hi);</span>
            }

<span class="fc" id="L1371">            this.m = m;</span>
<span class="fc" id="L1372">            this.fromStart = fromStart;</span>
<span class="fc" id="L1373">            this.lo = lo;</span>
<span class="fc" id="L1374">            this.loInclusive = loInclusive;</span>
<span class="fc" id="L1375">            this.toEnd = toEnd;</span>
<span class="fc" id="L1376">            this.hi = hi;</span>
<span class="fc" id="L1377">            this.hiInclusive = hiInclusive;</span>
<span class="fc" id="L1378">        }</span>

        // internal utilities

        final boolean tooLow(Object key) {
<span class="fc bfc" id="L1383" title="All 2 branches covered.">            if (!fromStart) {</span>
<span class="fc" id="L1384">                int c = m.compare(key, lo);</span>
<span class="fc bfc" id="L1385" title="All 6 branches covered.">                if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive))</span>
<span class="fc" id="L1386">                    return true;</span>
            }
<span class="fc" id="L1388">            return false;</span>
        }

        final boolean tooHigh(Object key) {
<span class="fc bfc" id="L1392" title="All 2 branches covered.">            if (!toEnd) {</span>
<span class="fc" id="L1393">                int c = m.compare(key, hi);</span>
<span class="fc bfc" id="L1394" title="All 6 branches covered.">                if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive))</span>
<span class="fc" id="L1395">                    return true;</span>
            }
<span class="fc" id="L1397">            return false;</span>
        }

        final boolean inRange(Object key) {
<span class="fc bfc" id="L1401" title="All 4 branches covered.">            return !tooLow(key) &amp;&amp; !tooHigh(key);</span>
        }

        final boolean inClosedRange(Object key) {
<span class="pc bpc" id="L1405" title="1 of 6 branches missed.">            return (fromStart || m.compare(key, lo) &gt;= 0)</span>
<span class="pc bpc" id="L1406" title="1 of 2 branches missed.">                &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0);</span>
        }

        final boolean inRange(Object key, boolean inclusive) {
<span class="fc bfc" id="L1410" title="All 2 branches covered.">            return inclusive ? inRange(key) : inClosedRange(key);</span>
        }

        /*
         * Absolute versions of relation operations.
         * Subclasses map to these using like-named &quot;sub&quot;
         * versions that invert senses for descending maps
         */

        final TreeMap.Entry&lt;K,V&gt; absLowest() {
<span class="fc bfc" id="L1420" title="All 2 branches covered.">            TreeMap.Entry&lt;K,V&gt; e =</span>
<span class="fc bfc" id="L1421" title="All 2 branches covered.">                (fromStart ?  m.getFirstEntry() :</span>
<span class="fc" id="L1422">                 (loInclusive ? m.getCeilingEntry(lo) :</span>
<span class="fc" id="L1423">                                m.getHigherEntry(lo)));</span>
<span class="fc bfc" id="L1424" title="All 4 branches covered.">            return (e == null || tooHigh(e.key)) ? null : e;</span>
        }

        final TreeMap.Entry&lt;K,V&gt; absHighest() {
<span class="fc bfc" id="L1428" title="All 2 branches covered.">            TreeMap.Entry&lt;K,V&gt; e =</span>
<span class="fc bfc" id="L1429" title="All 2 branches covered.">                (toEnd ?  m.getLastEntry() :</span>
<span class="fc" id="L1430">                 (hiInclusive ?  m.getFloorEntry(hi) :</span>
<span class="fc" id="L1431">                                 m.getLowerEntry(hi)));</span>
<span class="fc bfc" id="L1432" title="All 4 branches covered.">            return (e == null || tooLow(e.key)) ? null : e;</span>
        }

        final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) {
<span class="fc bfc" id="L1436" title="All 2 branches covered.">            if (tooLow(key))</span>
<span class="fc" id="L1437">                return absLowest();</span>
<span class="fc" id="L1438">            TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key);</span>
<span class="fc bfc" id="L1439" title="All 4 branches covered.">            return (e == null || tooHigh(e.key)) ? null : e;</span>
        }

        final TreeMap.Entry&lt;K,V&gt; absHigher(K key) {
<span class="fc bfc" id="L1443" title="All 2 branches covered.">            if (tooLow(key))</span>
<span class="fc" id="L1444">                return absLowest();</span>
<span class="fc" id="L1445">            TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key);</span>
<span class="fc bfc" id="L1446" title="All 4 branches covered.">            return (e == null || tooHigh(e.key)) ? null : e;</span>
        }

        final TreeMap.Entry&lt;K,V&gt; absFloor(K key) {
<span class="fc bfc" id="L1450" title="All 2 branches covered.">            if (tooHigh(key))</span>
<span class="fc" id="L1451">                return absHighest();</span>
<span class="fc" id="L1452">            TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key);</span>
<span class="fc bfc" id="L1453" title="All 4 branches covered.">            return (e == null || tooLow(e.key)) ? null : e;</span>
        }

        final TreeMap.Entry&lt;K,V&gt; absLower(K key) {
<span class="fc bfc" id="L1457" title="All 2 branches covered.">            if (tooHigh(key))</span>
<span class="fc" id="L1458">                return absHighest();</span>
<span class="fc" id="L1459">            TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key);</span>
<span class="fc bfc" id="L1460" title="All 4 branches covered.">            return (e == null || tooLow(e.key)) ? null : e;</span>
        }

        /** Returns the absolute high fence for ascending traversal */
        final TreeMap.Entry&lt;K,V&gt; absHighFence() {
<span class="fc bfc" id="L1465" title="All 4 branches covered.">            return (toEnd ? null : (hiInclusive ?</span>
<span class="fc" id="L1466">                                    m.getHigherEntry(hi) :</span>
<span class="fc" id="L1467">                                    m.getCeilingEntry(hi)));</span>
        }

        /** Return the absolute low fence for descending traversal  */
        final TreeMap.Entry&lt;K,V&gt; absLowFence() {
<span class="fc bfc" id="L1472" title="All 4 branches covered.">            return (fromStart ? null : (loInclusive ?</span>
<span class="fc" id="L1473">                                        m.getLowerEntry(lo) :</span>
<span class="fc" id="L1474">                                        m.getFloorEntry(lo)));</span>
        }

        // Abstract methods defined in ascending vs descending classes
        // These relay to the appropriate absolute versions

        abstract TreeMap.Entry&lt;K,V&gt; subLowest();
        abstract TreeMap.Entry&lt;K,V&gt; subHighest();
        abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key);
        abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key);
        abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key);
        abstract TreeMap.Entry&lt;K,V&gt; subLower(K key);

        /** Returns ascending iterator from the perspective of this submap */
        abstract Iterator&lt;K&gt; keyIterator();

        abstract Spliterator&lt;K&gt; keySpliterator();

        /** Returns descending iterator from the perspective of this submap */
        abstract Iterator&lt;K&gt; descendingKeyIterator();

        // public methods

        public boolean isEmpty() {
<span class="fc bfc" id="L1498" title="All 4 branches covered.">            return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty();</span>
        }

        public int size() {
<span class="fc bfc" id="L1502" title="All 4 branches covered.">            return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size();</span>
        }

        public final boolean containsKey(Object key) {
<span class="pc bpc" id="L1506" title="1 of 4 branches missed.">            return inRange(key) &amp;&amp; m.containsKey(key);</span>
        }

        public final V put(K key, V value) {
<span class="pc bpc" id="L1510" title="1 of 2 branches missed.">            if (!inRange(key))</span>
<span class="nc" id="L1511">                throw new IllegalArgumentException(&quot;key out of range&quot;);</span>
<span class="fc" id="L1512">            return m.put(key, value);</span>
        }

        public final V get(Object key) {
<span class="pc bpc" id="L1516" title="1 of 2 branches missed.">            return !inRange(key) ? null :  m.get(key);</span>
        }

        public final V remove(Object key) {
<span class="pc bpc" id="L1520" title="1 of 2 branches missed.">            return !inRange(key) ? null : m.remove(key);</span>
        }

        public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
<span class="fc" id="L1524">            return exportEntry(subCeiling(key));</span>
        }

        public final K ceilingKey(K key) {
<span class="fc" id="L1528">            return keyOrNull(subCeiling(key));</span>
        }

        public final Map.Entry&lt;K,V&gt; higherEntry(K key) {
<span class="fc" id="L1532">            return exportEntry(subHigher(key));</span>
        }

        public final K higherKey(K key) {
<span class="fc" id="L1536">            return keyOrNull(subHigher(key));</span>
        }

        public final Map.Entry&lt;K,V&gt; floorEntry(K key) {
<span class="fc" id="L1540">            return exportEntry(subFloor(key));</span>
        }

        public final K floorKey(K key) {
<span class="fc" id="L1544">            return keyOrNull(subFloor(key));</span>
        }

        public final Map.Entry&lt;K,V&gt; lowerEntry(K key) {
<span class="fc" id="L1548">            return exportEntry(subLower(key));</span>
        }

        public final K lowerKey(K key) {
<span class="fc" id="L1552">            return keyOrNull(subLower(key));</span>
        }

        public final K firstKey() {
<span class="fc" id="L1556">            return key(subLowest());</span>
        }

        public final K lastKey() {
<span class="fc" id="L1560">            return key(subHighest());</span>
        }

        public final Map.Entry&lt;K,V&gt; firstEntry() {
<span class="fc" id="L1564">            return exportEntry(subLowest());</span>
        }

        public final Map.Entry&lt;K,V&gt; lastEntry() {
<span class="fc" id="L1568">            return exportEntry(subHighest());</span>
        }

        public final Map.Entry&lt;K,V&gt; pollFirstEntry() {
<span class="fc" id="L1572">            TreeMap.Entry&lt;K,V&gt; e = subLowest();</span>
<span class="fc" id="L1573">            Map.Entry&lt;K,V&gt; result = exportEntry(e);</span>
<span class="fc bfc" id="L1574" title="All 2 branches covered.">            if (e != null)</span>
<span class="fc" id="L1575">                m.deleteEntry(e);</span>
<span class="fc" id="L1576">            return result;</span>
        }

        public final Map.Entry&lt;K,V&gt; pollLastEntry() {
<span class="fc" id="L1580">            TreeMap.Entry&lt;K,V&gt; e = subHighest();</span>
<span class="fc" id="L1581">            Map.Entry&lt;K,V&gt; result = exportEntry(e);</span>
<span class="fc bfc" id="L1582" title="All 2 branches covered.">            if (e != null)</span>
<span class="fc" id="L1583">                m.deleteEntry(e);</span>
<span class="fc" id="L1584">            return result;</span>
        }

        // Views
<span class="fc" id="L1588">        transient NavigableMap&lt;K,V&gt; descendingMapView = null;</span>
<span class="fc" id="L1589">        transient EntrySetView entrySetView = null;</span>
<span class="fc" id="L1590">        transient KeySet&lt;K&gt; navigableKeySetView = null;</span>

        public final NavigableSet&lt;K&gt; navigableKeySet() {
<span class="fc" id="L1593">            KeySet&lt;K&gt; nksv = navigableKeySetView;</span>
<span class="fc bfc" id="L1594" title="All 2 branches covered.">            return (nksv != null) ? nksv :</span>
                (navigableKeySetView = new TreeMap.KeySet&lt;&gt;(this));
        }

        public final Set&lt;K&gt; keySet() {
<span class="fc" id="L1599">            return navigableKeySet();</span>
        }

        public NavigableSet&lt;K&gt; descendingKeySet() {
<span class="fc" id="L1603">            return descendingMap().navigableKeySet();</span>
        }

        public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
<span class="fc" id="L1607">            return subMap(fromKey, true, toKey, false);</span>
        }

        public final SortedMap&lt;K,V&gt; headMap(K toKey) {
<span class="fc" id="L1611">            return headMap(toKey, false);</span>
        }

        public final SortedMap&lt;K,V&gt; tailMap(K fromKey) {
<span class="fc" id="L1615">            return tailMap(fromKey, true);</span>
        }

        // View classes

<span class="fc" id="L1620">        abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {</span>
<span class="fc" id="L1621">            private transient int size = -1, sizeModCount;</span>

            public int size() {
<span class="fc bfc" id="L1624" title="All 4 branches covered.">                if (fromStart &amp;&amp; toEnd)</span>
<span class="fc" id="L1625">                    return m.size();</span>
<span class="fc bfc" id="L1626" title="All 4 branches covered.">                if (size == -1 || sizeModCount != m.modCount) {</span>
<span class="fc" id="L1627">                    sizeModCount = m.modCount;</span>
<span class="fc" id="L1628">                    size = 0;</span>
<span class="fc" id="L1629">                    Iterator&lt;?&gt; i = iterator();</span>
<span class="fc bfc" id="L1630" title="All 2 branches covered.">                    while (i.hasNext()) {</span>
<span class="fc" id="L1631">                        size++;</span>
<span class="fc" id="L1632">                        i.next();</span>
                    }
                }
<span class="fc" id="L1635">                return size;</span>
            }

            public boolean isEmpty() {
<span class="fc" id="L1639">                TreeMap.Entry&lt;K,V&gt; n = absLowest();</span>
<span class="pc bpc" id="L1640" title="1 of 4 branches missed.">                return n == null || tooHigh(n.key);</span>
            }

            public boolean contains(Object o) {
<span class="pc bpc" id="L1644" title="1 of 2 branches missed.">                if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L1645">                    return false;</span>
<span class="fc" id="L1646">                Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;</span>
<span class="fc" id="L1647">                Object key = entry.getKey();</span>
<span class="pc bpc" id="L1648" title="1 of 2 branches missed.">                if (!inRange(key))</span>
<span class="nc" id="L1649">                    return false;</span>
<span class="fc" id="L1650">                TreeMap.Entry&lt;?,?&gt; node = m.getEntry(key);</span>
<span class="fc bfc" id="L1651" title="All 2 branches covered.">                return node != null &amp;&amp;</span>
<span class="pc bpc" id="L1652" title="1 of 2 branches missed.">                    valEquals(node.getValue(), entry.getValue());</span>
            }

            public boolean remove(Object o) {
<span class="pc bpc" id="L1656" title="1 of 2 branches missed.">                if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L1657">                    return false;</span>
<span class="fc" id="L1658">                Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;</span>
<span class="fc" id="L1659">                Object key = entry.getKey();</span>
<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">                if (!inRange(key))</span>
<span class="nc" id="L1661">                    return false;</span>
<span class="fc" id="L1662">                TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key);</span>
<span class="pc bpc" id="L1663" title="2 of 4 branches missed.">                if (node!=null &amp;&amp; valEquals(node.getValue(),</span>
<span class="fc" id="L1664">                                            entry.getValue())) {</span>
<span class="fc" id="L1665">                    m.deleteEntry(node);</span>
<span class="fc" id="L1666">                    return true;</span>
                }
<span class="nc" id="L1668">                return false;</span>
            }
        }

        /**
         * Iterators for SubMaps
         */
        abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; {
            TreeMap.Entry&lt;K,V&gt; lastReturned;
            TreeMap.Entry&lt;K,V&gt; next;
            final Object fenceKey;
            int expectedModCount;

            SubMapIterator(TreeMap.Entry&lt;K,V&gt; first,
<span class="fc" id="L1682">                           TreeMap.Entry&lt;K,V&gt; fence) {</span>
<span class="fc" id="L1683">                expectedModCount = m.modCount;</span>
<span class="fc" id="L1684">                lastReturned = null;</span>
<span class="fc" id="L1685">                next = first;</span>
<span class="fc bfc" id="L1686" title="All 2 branches covered.">                fenceKey = fence == null ? UNBOUNDED : fence.key;</span>
<span class="fc" id="L1687">            }</span>

            public final boolean hasNext() {
<span class="fc bfc" id="L1690" title="All 4 branches covered.">                return next != null &amp;&amp; next.key != fenceKey;</span>
            }

            final TreeMap.Entry&lt;K,V&gt; nextEntry() {
<span class="fc" id="L1694">                TreeMap.Entry&lt;K,V&gt; e = next;</span>
<span class="fc bfc" id="L1695" title="All 4 branches covered.">                if (e == null || e.key == fenceKey)</span>
<span class="fc" id="L1696">                    throw new NoSuchElementException();</span>
<span class="pc bpc" id="L1697" title="1 of 2 branches missed.">                if (m.modCount != expectedModCount)</span>
<span class="nc" id="L1698">                    throw new ConcurrentModificationException();</span>
<span class="fc" id="L1699">                next = successor(e);</span>
<span class="fc" id="L1700">                lastReturned = e;</span>
<span class="fc" id="L1701">                return e;</span>
            }

            final TreeMap.Entry&lt;K,V&gt; prevEntry() {
<span class="fc" id="L1705">                TreeMap.Entry&lt;K,V&gt; e = next;</span>
<span class="fc bfc" id="L1706" title="All 4 branches covered.">                if (e == null || e.key == fenceKey)</span>
<span class="fc" id="L1707">                    throw new NoSuchElementException();</span>
<span class="pc bpc" id="L1708" title="1 of 2 branches missed.">                if (m.modCount != expectedModCount)</span>
<span class="nc" id="L1709">                    throw new ConcurrentModificationException();</span>
<span class="fc" id="L1710">                next = predecessor(e);</span>
<span class="fc" id="L1711">                lastReturned = e;</span>
<span class="fc" id="L1712">                return e;</span>
            }

            final void removeAscending() {
<span class="fc bfc" id="L1716" title="All 2 branches covered.">                if (lastReturned == null)</span>
<span class="fc" id="L1717">                    throw new IllegalStateException();</span>
<span class="pc bpc" id="L1718" title="1 of 2 branches missed.">                if (m.modCount != expectedModCount)</span>
<span class="nc" id="L1719">                    throw new ConcurrentModificationException();</span>
                // deleted entries are replaced by their successors
<span class="fc bfc" id="L1721" title="All 4 branches covered.">                if (lastReturned.left != null &amp;&amp; lastReturned.right != null)</span>
<span class="fc" id="L1722">                    next = lastReturned;</span>
<span class="fc" id="L1723">                m.deleteEntry(lastReturned);</span>
<span class="fc" id="L1724">                lastReturned = null;</span>
<span class="fc" id="L1725">                expectedModCount = m.modCount;</span>
<span class="fc" id="L1726">            }</span>

            final void removeDescending() {
<span class="fc bfc" id="L1729" title="All 2 branches covered.">                if (lastReturned == null)</span>
<span class="fc" id="L1730">                    throw new IllegalStateException();</span>
<span class="pc bpc" id="L1731" title="1 of 2 branches missed.">                if (m.modCount != expectedModCount)</span>
<span class="nc" id="L1732">                    throw new ConcurrentModificationException();</span>
<span class="fc" id="L1733">                m.deleteEntry(lastReturned);</span>
<span class="fc" id="L1734">                lastReturned = null;</span>
<span class="fc" id="L1735">                expectedModCount = m.modCount;</span>
<span class="fc" id="L1736">            }</span>

        }

        final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
            SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first,
<span class="fc" id="L1742">                                TreeMap.Entry&lt;K,V&gt; fence) {</span>
<span class="fc" id="L1743">                super(first, fence);</span>
<span class="fc" id="L1744">            }</span>
            public Map.Entry&lt;K,V&gt; next() {
<span class="fc" id="L1746">                return nextEntry();</span>
            }
            public void remove() {
<span class="fc" id="L1749">                removeAscending();</span>
<span class="fc" id="L1750">            }</span>
        }

        final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
            DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last,
<span class="fc" id="L1755">                                          TreeMap.Entry&lt;K,V&gt; fence) {</span>
<span class="fc" id="L1756">                super(last, fence);</span>
<span class="fc" id="L1757">            }</span>

            public Map.Entry&lt;K,V&gt; next() {
<span class="fc" id="L1760">                return prevEntry();</span>
            }
            public void remove() {
<span class="fc" id="L1763">                removeDescending();</span>
<span class="fc" id="L1764">            }</span>
        }

        // Implement minimal Spliterator as KeySpliterator backup
        final class SubMapKeyIterator extends SubMapIterator&lt;K&gt;
            implements Spliterator&lt;K&gt; {
            SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first,
<span class="fc" id="L1771">                              TreeMap.Entry&lt;K,V&gt; fence) {</span>
<span class="fc" id="L1772">                super(first, fence);</span>
<span class="fc" id="L1773">            }</span>
            public K next() {
<span class="fc" id="L1775">                return nextEntry().key;</span>
            }
            public void remove() {
<span class="fc" id="L1778">                removeAscending();</span>
<span class="fc" id="L1779">            }</span>
            public Spliterator&lt;K&gt; trySplit() {
<span class="nc" id="L1781">                return null;</span>
            }
            public void forEachRemaining(Consumer&lt;? super K&gt; action) {
<span class="nc bnc" id="L1784" title="All 2 branches missed.">                while (hasNext())</span>
<span class="nc" id="L1785">                    action.accept(next());</span>
<span class="nc" id="L1786">            }</span>
            public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
<span class="nc bnc" id="L1788" title="All 2 branches missed.">                if (hasNext()) {</span>
<span class="nc" id="L1789">                    action.accept(next());</span>
<span class="nc" id="L1790">                    return true;</span>
                }
<span class="nc" id="L1792">                return false;</span>
            }
            public long estimateSize() {
<span class="nc" id="L1795">                return Long.MAX_VALUE;</span>
            }
            public int characteristics() {
<span class="nc" id="L1798">                return Spliterator.DISTINCT | Spliterator.ORDERED |</span>
                    Spliterator.SORTED;
            }
            public final Comparator&lt;? super K&gt;  getComparator() {
<span class="nc" id="L1802">                return NavigableSubMap.this.comparator();</span>
            }
        }

        final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt;
            implements Spliterator&lt;K&gt; {
            DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last,
<span class="fc" id="L1809">                                        TreeMap.Entry&lt;K,V&gt; fence) {</span>
<span class="fc" id="L1810">                super(last, fence);</span>
<span class="fc" id="L1811">            }</span>
            public K next() {
<span class="fc" id="L1813">                return prevEntry().key;</span>
            }
            public void remove() {
<span class="fc" id="L1816">                removeDescending();</span>
<span class="fc" id="L1817">            }</span>
            public Spliterator&lt;K&gt; trySplit() {
<span class="nc" id="L1819">                return null;</span>
            }
            public void forEachRemaining(Consumer&lt;? super K&gt; action) {
<span class="nc bnc" id="L1822" title="All 2 branches missed.">                while (hasNext())</span>
<span class="nc" id="L1823">                    action.accept(next());</span>
<span class="nc" id="L1824">            }</span>
            public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
<span class="nc bnc" id="L1826" title="All 2 branches missed.">                if (hasNext()) {</span>
<span class="nc" id="L1827">                    action.accept(next());</span>
<span class="nc" id="L1828">                    return true;</span>
                }
<span class="nc" id="L1830">                return false;</span>
            }
            public long estimateSize() {
<span class="nc" id="L1833">                return Long.MAX_VALUE;</span>
            }
            public int characteristics() {
<span class="nc" id="L1836">                return Spliterator.DISTINCT | Spliterator.ORDERED;</span>
            }
        }
    }

    /**
     * @serial include
     */
    static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; {
        private static final long serialVersionUID = 912986545866124060L;

        AscendingSubMap(TreeMap&lt;K,V&gt; m,
                        boolean fromStart, K lo, boolean loInclusive,
                        boolean toEnd,     K hi, boolean hiInclusive) {
<span class="fc" id="L1850">            super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);</span>
<span class="fc" id="L1851">        }</span>

        public Comparator&lt;? super K&gt; comparator() {
<span class="fc" id="L1854">            return m.comparator();</span>
        }

        public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
                                        K toKey,   boolean toInclusive) {
<span class="fc bfc" id="L1859" title="All 2 branches covered.">            if (!inRange(fromKey, fromInclusive))</span>
<span class="fc" id="L1860">                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);</span>
<span class="pc bpc" id="L1861" title="1 of 2 branches missed.">            if (!inRange(toKey, toInclusive))</span>
<span class="nc" id="L1862">                throw new IllegalArgumentException(&quot;toKey out of range&quot;);</span>
<span class="fc" id="L1863">            return new AscendingSubMap&lt;&gt;(m,</span>
                                         false, fromKey, fromInclusive,
                                         false, toKey,   toInclusive);
        }

        public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
<span class="fc bfc" id="L1869" title="All 2 branches covered.">            if (!inRange(toKey, inclusive))</span>
<span class="fc" id="L1870">                throw new IllegalArgumentException(&quot;toKey out of range&quot;);</span>
<span class="fc" id="L1871">            return new AscendingSubMap&lt;&gt;(m,</span>
                                         fromStart, lo,    loInclusive,
                                         false,     toKey, inclusive);
        }

        public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {
<span class="fc bfc" id="L1877" title="All 2 branches covered.">            if (!inRange(fromKey, inclusive))</span>
<span class="fc" id="L1878">                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);</span>
<span class="fc" id="L1879">            return new AscendingSubMap&lt;&gt;(m,</span>
                                         false, fromKey, inclusive,
                                         toEnd, hi,      hiInclusive);
        }

        public NavigableMap&lt;K,V&gt; descendingMap() {
<span class="fc" id="L1885">            NavigableMap&lt;K,V&gt; mv = descendingMapView;</span>
<span class="fc bfc" id="L1886" title="All 2 branches covered.">            return (mv != null) ? mv :</span>
                (descendingMapView =
                 new DescendingSubMap&lt;&gt;(m,
                                        fromStart, lo, loInclusive,
                                        toEnd,     hi, hiInclusive));
        }

        Iterator&lt;K&gt; keyIterator() {
<span class="fc" id="L1894">            return new SubMapKeyIterator(absLowest(), absHighFence());</span>
        }

        Spliterator&lt;K&gt; keySpliterator() {
<span class="nc" id="L1898">            return new SubMapKeyIterator(absLowest(), absHighFence());</span>
        }

        Iterator&lt;K&gt; descendingKeyIterator() {
<span class="fc" id="L1902">            return new DescendingSubMapKeyIterator(absHighest(), absLowFence());</span>
        }

<span class="fc" id="L1905">        final class AscendingEntrySetView extends EntrySetView {</span>
            public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
<span class="fc" id="L1907">                return new SubMapEntryIterator(absLowest(), absHighFence());</span>
            }
        }

        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<span class="fc" id="L1912">            EntrySetView es = entrySetView;</span>
<span class="fc bfc" id="L1913" title="All 2 branches covered.">            return (es != null) ? es : (entrySetView = new AscendingEntrySetView());</span>
        }

<span class="fc" id="L1916">        TreeMap.Entry&lt;K,V&gt; subLowest()       { return absLowest(); }</span>
<span class="fc" id="L1917">        TreeMap.Entry&lt;K,V&gt; subHighest()      { return absHighest(); }</span>
<span class="fc" id="L1918">        TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absCeiling(key); }</span>
<span class="fc" id="L1919">        TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absHigher(key); }</span>
<span class="fc" id="L1920">        TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absFloor(key); }</span>
<span class="fc" id="L1921">        TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absLower(key); }</span>
    }

    /**
     * @serial include
     */
    static final class DescendingSubMap&lt;K,V&gt;  extends NavigableSubMap&lt;K,V&gt; {
        private static final long serialVersionUID = 912986545866120460L;
        DescendingSubMap(TreeMap&lt;K,V&gt; m,
                        boolean fromStart, K lo, boolean loInclusive,
                        boolean toEnd,     K hi, boolean hiInclusive) {
<span class="fc" id="L1932">            super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);</span>
<span class="fc" id="L1933">        }</span>

<span class="fc" id="L1935">        private final Comparator&lt;? super K&gt; reverseComparator =</span>
<span class="fc" id="L1936">            Collections.reverseOrder(m.comparator);</span>

        public Comparator&lt;? super K&gt; comparator() {
<span class="fc" id="L1939">            return reverseComparator;</span>
        }

        public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
                                        K toKey,   boolean toInclusive) {
<span class="fc bfc" id="L1944" title="All 2 branches covered.">            if (!inRange(fromKey, fromInclusive))</span>
<span class="fc" id="L1945">                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);</span>
<span class="pc bpc" id="L1946" title="1 of 2 branches missed.">            if (!inRange(toKey, toInclusive))</span>
<span class="nc" id="L1947">                throw new IllegalArgumentException(&quot;toKey out of range&quot;);</span>
<span class="fc" id="L1948">            return new DescendingSubMap&lt;&gt;(m,</span>
                                          false, toKey,   toInclusive,
                                          false, fromKey, fromInclusive);
        }

        public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
<span class="fc bfc" id="L1954" title="All 2 branches covered.">            if (!inRange(toKey, inclusive))</span>
<span class="fc" id="L1955">                throw new IllegalArgumentException(&quot;toKey out of range&quot;);</span>
<span class="fc" id="L1956">            return new DescendingSubMap&lt;&gt;(m,</span>
                                          false, toKey, inclusive,
                                          toEnd, hi,    hiInclusive);
        }

        public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {
<span class="fc bfc" id="L1962" title="All 2 branches covered.">            if (!inRange(fromKey, inclusive))</span>
<span class="fc" id="L1963">                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);</span>
<span class="fc" id="L1964">            return new DescendingSubMap&lt;&gt;(m,</span>
                                          fromStart, lo, loInclusive,
                                          false, fromKey, inclusive);
        }

        public NavigableMap&lt;K,V&gt; descendingMap() {
<span class="fc" id="L1970">            NavigableMap&lt;K,V&gt; mv = descendingMapView;</span>
<span class="fc bfc" id="L1971" title="All 2 branches covered.">            return (mv != null) ? mv :</span>
                (descendingMapView =
                 new AscendingSubMap&lt;&gt;(m,
                                       fromStart, lo, loInclusive,
                                       toEnd,     hi, hiInclusive));
        }

        Iterator&lt;K&gt; keyIterator() {
<span class="fc" id="L1979">            return new DescendingSubMapKeyIterator(absHighest(), absLowFence());</span>
        }

        Spliterator&lt;K&gt; keySpliterator() {
<span class="nc" id="L1983">            return new DescendingSubMapKeyIterator(absHighest(), absLowFence());</span>
        }

        Iterator&lt;K&gt; descendingKeyIterator() {
<span class="fc" id="L1987">            return new SubMapKeyIterator(absLowest(), absHighFence());</span>
        }

<span class="fc" id="L1990">        final class DescendingEntrySetView extends EntrySetView {</span>
            public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
<span class="fc" id="L1992">                return new DescendingSubMapEntryIterator(absHighest(), absLowFence());</span>
            }
        }

        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<span class="fc" id="L1997">            EntrySetView es = entrySetView;</span>
<span class="fc bfc" id="L1998" title="All 2 branches covered.">            return (es != null) ? es : (entrySetView = new DescendingEntrySetView());</span>
        }

<span class="fc" id="L2001">        TreeMap.Entry&lt;K,V&gt; subLowest()       { return absHighest(); }</span>
<span class="fc" id="L2002">        TreeMap.Entry&lt;K,V&gt; subHighest()      { return absLowest(); }</span>
<span class="fc" id="L2003">        TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absFloor(key); }</span>
<span class="fc" id="L2004">        TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absLower(key); }</span>
<span class="fc" id="L2005">        TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absCeiling(key); }</span>
<span class="fc" id="L2006">        TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absHigher(key); }</span>
    }

    /**
     * This class exists solely for the sake of serialization
     * compatibility with previous releases of TreeMap that did not
     * support NavigableMap.  It translates an old-version SubMap into
     * a new-version AscendingSubMap. This class is never otherwise
     * used.
     *
     * @serial include
     */
<span class="nc" id="L2018">    private class SubMap extends AbstractMap&lt;K,V&gt;</span>
        implements SortedMap&lt;K,V&gt;, java.io.Serializable {
        private static final long serialVersionUID = -6520786458950516097L;
<span class="nc" id="L2021">        private boolean fromStart = false, toEnd = false;</span>
        private K fromKey, toKey;
        private Object readResolve() {
<span class="nc" id="L2024">            return new AscendingSubMap&lt;&gt;(TreeMap.this,</span>
                                         fromStart, fromKey, true,
                                         toEnd, toKey, false);
        }
<span class="nc" id="L2028">        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { throw new InternalError(); }</span>
<span class="nc" id="L2029">        public K lastKey() { throw new InternalError(); }</span>
<span class="nc" id="L2030">        public K firstKey() { throw new InternalError(); }</span>
<span class="nc" id="L2031">        public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) { throw new InternalError(); }</span>
<span class="nc" id="L2032">        public SortedMap&lt;K,V&gt; headMap(K toKey) { throw new InternalError(); }</span>
<span class="nc" id="L2033">        public SortedMap&lt;K,V&gt; tailMap(K fromKey) { throw new InternalError(); }</span>
<span class="nc" id="L2034">        public Comparator&lt;? super K&gt; comparator() { throw new InternalError(); }</span>
    }


    // Red-black mechanics

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    /**
     * Node in the Tree.  Doubles as a means to pass key-value pairs back to
     * user (see Map.Entry).
     */

    static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        K key;
        V value;
<span class="fc" id="L2051">        Entry&lt;K,V&gt; left = null;</span>
<span class="fc" id="L2052">        Entry&lt;K,V&gt; right = null;</span>
        Entry&lt;K,V&gt; parent;
<span class="fc" id="L2054">        boolean color = BLACK;</span>

        /**
         * Make a new cell with given key, value, and parent, and with
         * {@code null} child links, and BLACK color.
         */
<span class="fc" id="L2060">        Entry(K key, V value, Entry&lt;K,V&gt; parent) {</span>
<span class="fc" id="L2061">            this.key = key;</span>
<span class="fc" id="L2062">            this.value = value;</span>
<span class="fc" id="L2063">            this.parent = parent;</span>
<span class="fc" id="L2064">        }</span>

        /**
         * Returns the key.
         *
         * @return the key
         */
        public K getKey() {
<span class="fc" id="L2072">            return key;</span>
        }

        /**
         * Returns the value associated with the key.
         *
         * @return the value associated with the key
         */
        public V getValue() {
<span class="fc" id="L2081">            return value;</span>
        }

        /**
         * Replaces the value currently associated with the key with the given
         * value.
         *
         * @return the value associated with the key before this method was
         *         called
         */
        public V setValue(V value) {
<span class="fc" id="L2092">            V oldValue = this.value;</span>
<span class="fc" id="L2093">            this.value = value;</span>
<span class="fc" id="L2094">            return oldValue;</span>
        }

        public boolean equals(Object o) {
<span class="pc bpc" id="L2098" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L2099">                return false;</span>
<span class="fc" id="L2100">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span>

<span class="pc bpc" id="L2102" title="2 of 4 branches missed.">            return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span>
        }

        public int hashCode() {
<span class="pc bpc" id="L2106" title="1 of 2 branches missed.">            int keyHash = (key==null ? 0 : key.hashCode());</span>
<span class="pc bpc" id="L2107" title="1 of 2 branches missed.">            int valueHash = (value==null ? 0 : value.hashCode());</span>
<span class="fc" id="L2108">            return keyHash ^ valueHash;</span>
        }

        public String toString() {
<span class="nc" id="L2112">            return key + &quot;=&quot; + value;</span>
        }
    }

    /**
     * Returns the first Entry in the TreeMap (according to the TreeMap's
     * key-sort function).  Returns null if the TreeMap is empty.
     */
    final Entry&lt;K,V&gt; getFirstEntry() {
<span class="fc" id="L2121">        Entry&lt;K,V&gt; p = root;</span>
<span class="fc bfc" id="L2122" title="All 2 branches covered.">        if (p != null)</span>
<span class="fc bfc" id="L2123" title="All 2 branches covered.">            while (p.left != null)</span>
<span class="fc" id="L2124">                p = p.left;</span>
<span class="fc" id="L2125">        return p;</span>
    }

    /**
     * Returns the last Entry in the TreeMap (according to the TreeMap's
     * key-sort function).  Returns null if the TreeMap is empty.
     */
    final Entry&lt;K,V&gt; getLastEntry() {
<span class="fc" id="L2133">        Entry&lt;K,V&gt; p = root;</span>
<span class="fc bfc" id="L2134" title="All 2 branches covered.">        if (p != null)</span>
<span class="fc bfc" id="L2135" title="All 2 branches covered.">            while (p.right != null)</span>
<span class="fc" id="L2136">                p = p.right;</span>
<span class="fc" id="L2137">        return p;</span>
    }

    /**
     * Returns the successor of the specified Entry, or null if no such.
     */
    static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {
<span class="pc bpc" id="L2144" title="1 of 2 branches missed.">        if (t == null)</span>
<span class="nc" id="L2145">            return null;</span>
<span class="fc bfc" id="L2146" title="All 2 branches covered.">        else if (t.right != null) {</span>
<span class="fc" id="L2147">            Entry&lt;K,V&gt; p = t.right;</span>
<span class="fc bfc" id="L2148" title="All 2 branches covered.">            while (p.left != null)</span>
<span class="fc" id="L2149">                p = p.left;</span>
<span class="fc" id="L2150">            return p;</span>
        } else {
<span class="fc" id="L2152">            Entry&lt;K,V&gt; p = t.parent;</span>
<span class="fc" id="L2153">            Entry&lt;K,V&gt; ch = t;</span>
<span class="fc bfc" id="L2154" title="All 4 branches covered.">            while (p != null &amp;&amp; ch == p.right) {</span>
<span class="fc" id="L2155">                ch = p;</span>
<span class="fc" id="L2156">                p = p.parent;</span>
            }
<span class="fc" id="L2158">            return p;</span>
        }
    }

    /**
     * Returns the predecessor of the specified Entry, or null if no such.
     */
    static &lt;K,V&gt; Entry&lt;K,V&gt; predecessor(Entry&lt;K,V&gt; t) {
<span class="pc bpc" id="L2166" title="1 of 2 branches missed.">        if (t == null)</span>
<span class="nc" id="L2167">            return null;</span>
<span class="fc bfc" id="L2168" title="All 2 branches covered.">        else if (t.left != null) {</span>
<span class="fc" id="L2169">            Entry&lt;K,V&gt; p = t.left;</span>
<span class="fc bfc" id="L2170" title="All 2 branches covered.">            while (p.right != null)</span>
<span class="fc" id="L2171">                p = p.right;</span>
<span class="fc" id="L2172">            return p;</span>
        } else {
<span class="fc" id="L2174">            Entry&lt;K,V&gt; p = t.parent;</span>
<span class="fc" id="L2175">            Entry&lt;K,V&gt; ch = t;</span>
<span class="fc bfc" id="L2176" title="All 4 branches covered.">            while (p != null &amp;&amp; ch == p.left) {</span>
<span class="fc" id="L2177">                ch = p;</span>
<span class="fc" id="L2178">                p = p.parent;</span>
            }
<span class="fc" id="L2180">            return p;</span>
        }
    }

    /**
     * Balancing operations.
     *
     * Implementations of rebalancings during insertion and deletion are
     * slightly different than the CLR version.  Rather than using dummy
     * nilnodes, we use a set of accessors that deal properly with null.  They
     * are used to avoid messiness surrounding nullness checks in the main
     * algorithms.
     */

    private static &lt;K,V&gt; boolean colorOf(Entry&lt;K,V&gt; p) {
<span class="fc bfc" id="L2195" title="All 2 branches covered.">        return (p == null ? BLACK : p.color);</span>
    }

    private static &lt;K,V&gt; Entry&lt;K,V&gt; parentOf(Entry&lt;K,V&gt; p) {
<span class="pc bpc" id="L2199" title="1 of 2 branches missed.">        return (p == null ? null: p.parent);</span>
    }

    private static &lt;K,V&gt; void setColor(Entry&lt;K,V&gt; p, boolean c) {
<span class="pc bpc" id="L2203" title="1 of 2 branches missed.">        if (p != null)</span>
<span class="fc" id="L2204">            p.color = c;</span>
<span class="fc" id="L2205">    }</span>

    private static &lt;K,V&gt; Entry&lt;K,V&gt; leftOf(Entry&lt;K,V&gt; p) {
<span class="pc bpc" id="L2208" title="1 of 2 branches missed.">        return (p == null) ? null: p.left;</span>
    }

    private static &lt;K,V&gt; Entry&lt;K,V&gt; rightOf(Entry&lt;K,V&gt; p) {
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">        return (p == null) ? null: p.right;</span>
    }

    /** From CLR */
    private void rotateLeft(Entry&lt;K,V&gt; p) {
<span class="pc bpc" id="L2217" title="1 of 2 branches missed.">        if (p != null) {</span>
<span class="fc" id="L2218">            Entry&lt;K,V&gt; r = p.right;</span>
<span class="fc" id="L2219">            p.right = r.left;</span>
<span class="fc bfc" id="L2220" title="All 2 branches covered.">            if (r.left != null)</span>
<span class="fc" id="L2221">                r.left.parent = p;</span>
<span class="fc" id="L2222">            r.parent = p.parent;</span>
<span class="fc bfc" id="L2223" title="All 2 branches covered.">            if (p.parent == null)</span>
<span class="fc" id="L2224">                root = r;</span>
<span class="fc bfc" id="L2225" title="All 2 branches covered.">            else if (p.parent.left == p)</span>
<span class="fc" id="L2226">                p.parent.left = r;</span>
            else
<span class="fc" id="L2228">                p.parent.right = r;</span>
<span class="fc" id="L2229">            r.left = p;</span>
<span class="fc" id="L2230">            p.parent = r;</span>
        }
<span class="fc" id="L2232">    }</span>

    /** From CLR */
    private void rotateRight(Entry&lt;K,V&gt; p) {
<span class="pc bpc" id="L2236" title="1 of 2 branches missed.">        if (p != null) {</span>
<span class="fc" id="L2237">            Entry&lt;K,V&gt; l = p.left;</span>
<span class="fc" id="L2238">            p.left = l.right;</span>
<span class="fc bfc" id="L2239" title="All 2 branches covered.">            if (l.right != null) l.right.parent = p;</span>
<span class="fc" id="L2240">            l.parent = p.parent;</span>
<span class="fc bfc" id="L2241" title="All 2 branches covered.">            if (p.parent == null)</span>
<span class="fc" id="L2242">                root = l;</span>
<span class="fc bfc" id="L2243" title="All 2 branches covered.">            else if (p.parent.right == p)</span>
<span class="fc" id="L2244">                p.parent.right = l;</span>
<span class="fc" id="L2245">            else p.parent.left = l;</span>
<span class="fc" id="L2246">            l.right = p;</span>
<span class="fc" id="L2247">            p.parent = l;</span>
        }
<span class="fc" id="L2249">    }</span>

    /** From CLR */
    private void fixAfterInsertion(Entry&lt;K,V&gt; x) {
<span class="fc" id="L2253">        x.color = RED;</span>

<span class="pc bpc" id="L2255" title="1 of 6 branches missed.">        while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {</span>
<span class="fc bfc" id="L2256" title="All 2 branches covered.">            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {</span>
<span class="fc" id="L2257">                Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span>
<span class="fc bfc" id="L2258" title="All 2 branches covered.">                if (colorOf(y) == RED) {</span>
<span class="fc" id="L2259">                    setColor(parentOf(x), BLACK);</span>
<span class="fc" id="L2260">                    setColor(y, BLACK);</span>
<span class="fc" id="L2261">                    setColor(parentOf(parentOf(x)), RED);</span>
<span class="fc" id="L2262">                    x = parentOf(parentOf(x));</span>
                } else {
<span class="fc bfc" id="L2264" title="All 2 branches covered.">                    if (x == rightOf(parentOf(x))) {</span>
<span class="fc" id="L2265">                        x = parentOf(x);</span>
<span class="fc" id="L2266">                        rotateLeft(x);</span>
                    }
<span class="fc" id="L2268">                    setColor(parentOf(x), BLACK);</span>
<span class="fc" id="L2269">                    setColor(parentOf(parentOf(x)), RED);</span>
<span class="fc" id="L2270">                    rotateRight(parentOf(parentOf(x)));</span>
                }
<span class="fc" id="L2272">            } else {</span>
<span class="fc" id="L2273">                Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span>
<span class="fc bfc" id="L2274" title="All 2 branches covered.">                if (colorOf(y) == RED) {</span>
<span class="fc" id="L2275">                    setColor(parentOf(x), BLACK);</span>
<span class="fc" id="L2276">                    setColor(y, BLACK);</span>
<span class="fc" id="L2277">                    setColor(parentOf(parentOf(x)), RED);</span>
<span class="fc" id="L2278">                    x = parentOf(parentOf(x));</span>
                } else {
<span class="fc bfc" id="L2280" title="All 2 branches covered.">                    if (x == leftOf(parentOf(x))) {</span>
<span class="fc" id="L2281">                        x = parentOf(x);</span>
<span class="fc" id="L2282">                        rotateRight(x);</span>
                    }
<span class="fc" id="L2284">                    setColor(parentOf(x), BLACK);</span>
<span class="fc" id="L2285">                    setColor(parentOf(parentOf(x)), RED);</span>
<span class="fc" id="L2286">                    rotateLeft(parentOf(parentOf(x)));</span>
                }
<span class="fc" id="L2288">            }</span>
        }
<span class="fc" id="L2290">        root.color = BLACK;</span>
<span class="fc" id="L2291">    }</span>

    /**
     * Delete node p, and then rebalance the tree.
     */
    private void deleteEntry(Entry&lt;K,V&gt; p) {
<span class="fc" id="L2297">        modCount++;</span>
<span class="fc" id="L2298">        size--;</span>

        // If strictly internal, copy successor's element to p and then make p
        // point to successor.
<span class="fc bfc" id="L2302" title="All 4 branches covered.">        if (p.left != null &amp;&amp; p.right != null) {</span>
<span class="fc" id="L2303">            Entry&lt;K,V&gt; s = successor(p);</span>
<span class="fc" id="L2304">            p.key = s.key;</span>
<span class="fc" id="L2305">            p.value = s.value;</span>
<span class="fc" id="L2306">            p = s;</span>
        } // p has 2 children

        // Start fixup at replacement node, if it exists.
<span class="fc bfc" id="L2310" title="All 2 branches covered.">        Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);</span>

<span class="fc bfc" id="L2312" title="All 2 branches covered.">        if (replacement != null) {</span>
            // Link replacement to parent
<span class="fc" id="L2314">            replacement.parent = p.parent;</span>
<span class="fc bfc" id="L2315" title="All 2 branches covered.">            if (p.parent == null)</span>
<span class="fc" id="L2316">                root = replacement;</span>
<span class="fc bfc" id="L2317" title="All 2 branches covered.">            else if (p == p.parent.left)</span>
<span class="fc" id="L2318">                p.parent.left  = replacement;</span>
            else
<span class="fc" id="L2320">                p.parent.right = replacement;</span>

            // Null out links so they are OK to use by fixAfterDeletion.
<span class="fc" id="L2323">            p.left = p.right = p.parent = null;</span>

            // Fix replacement
<span class="pc bpc" id="L2326" title="1 of 2 branches missed.">            if (p.color == BLACK)</span>
<span class="fc" id="L2327">                fixAfterDeletion(replacement);</span>
<span class="fc bfc" id="L2328" title="All 2 branches covered.">        } else if (p.parent == null) { // return if we are the only node.</span>
<span class="fc" id="L2329">            root = null;</span>
        } else { //  No children. Use self as phantom replacement and unlink.
<span class="fc bfc" id="L2331" title="All 2 branches covered.">            if (p.color == BLACK)</span>
<span class="fc" id="L2332">                fixAfterDeletion(p);</span>

<span class="pc bpc" id="L2334" title="1 of 2 branches missed.">            if (p.parent != null) {</span>
<span class="fc bfc" id="L2335" title="All 2 branches covered.">                if (p == p.parent.left)</span>
<span class="fc" id="L2336">                    p.parent.left = null;</span>
<span class="pc bpc" id="L2337" title="1 of 2 branches missed.">                else if (p == p.parent.right)</span>
<span class="fc" id="L2338">                    p.parent.right = null;</span>
<span class="fc" id="L2339">                p.parent = null;</span>
            }
        }
<span class="fc" id="L2342">    }</span>

    /** From CLR */
    private void fixAfterDeletion(Entry&lt;K,V&gt; x) {
<span class="fc bfc" id="L2346" title="All 4 branches covered.">        while (x != root &amp;&amp; colorOf(x) == BLACK) {</span>
<span class="fc bfc" id="L2347" title="All 2 branches covered.">            if (x == leftOf(parentOf(x))) {</span>
<span class="fc" id="L2348">                Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span>

<span class="fc bfc" id="L2350" title="All 2 branches covered.">                if (colorOf(sib) == RED) {</span>
<span class="fc" id="L2351">                    setColor(sib, BLACK);</span>
<span class="fc" id="L2352">                    setColor(parentOf(x), RED);</span>
<span class="fc" id="L2353">                    rotateLeft(parentOf(x));</span>
<span class="fc" id="L2354">                    sib = rightOf(parentOf(x));</span>
                }

<span class="fc bfc" id="L2357" title="All 2 branches covered.">                if (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span>
<span class="fc bfc" id="L2358" title="All 2 branches covered.">                    colorOf(rightOf(sib)) == BLACK) {</span>
<span class="fc" id="L2359">                    setColor(sib, RED);</span>
<span class="fc" id="L2360">                    x = parentOf(x);</span>
                } else {
<span class="fc bfc" id="L2362" title="All 2 branches covered.">                    if (colorOf(rightOf(sib)) == BLACK) {</span>
<span class="fc" id="L2363">                        setColor(leftOf(sib), BLACK);</span>
<span class="fc" id="L2364">                        setColor(sib, RED);</span>
<span class="fc" id="L2365">                        rotateRight(sib);</span>
<span class="fc" id="L2366">                        sib = rightOf(parentOf(x));</span>
                    }
<span class="fc" id="L2368">                    setColor(sib, colorOf(parentOf(x)));</span>
<span class="fc" id="L2369">                    setColor(parentOf(x), BLACK);</span>
<span class="fc" id="L2370">                    setColor(rightOf(sib), BLACK);</span>
<span class="fc" id="L2371">                    rotateLeft(parentOf(x));</span>
<span class="fc" id="L2372">                    x = root;</span>
                }
<span class="fc" id="L2374">            } else { // symmetric</span>
<span class="fc" id="L2375">                Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span>

<span class="fc bfc" id="L2377" title="All 2 branches covered.">                if (colorOf(sib) == RED) {</span>
<span class="fc" id="L2378">                    setColor(sib, BLACK);</span>
<span class="fc" id="L2379">                    setColor(parentOf(x), RED);</span>
<span class="fc" id="L2380">                    rotateRight(parentOf(x));</span>
<span class="fc" id="L2381">                    sib = leftOf(parentOf(x));</span>
                }

<span class="fc bfc" id="L2384" title="All 2 branches covered.">                if (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span>
<span class="fc bfc" id="L2385" title="All 2 branches covered.">                    colorOf(leftOf(sib)) == BLACK) {</span>
<span class="fc" id="L2386">                    setColor(sib, RED);</span>
<span class="fc" id="L2387">                    x = parentOf(x);</span>
                } else {
<span class="fc bfc" id="L2389" title="All 2 branches covered.">                    if (colorOf(leftOf(sib)) == BLACK) {</span>
<span class="fc" id="L2390">                        setColor(rightOf(sib), BLACK);</span>
<span class="fc" id="L2391">                        setColor(sib, RED);</span>
<span class="fc" id="L2392">                        rotateLeft(sib);</span>
<span class="fc" id="L2393">                        sib = leftOf(parentOf(x));</span>
                    }
<span class="fc" id="L2395">                    setColor(sib, colorOf(parentOf(x)));</span>
<span class="fc" id="L2396">                    setColor(parentOf(x), BLACK);</span>
<span class="fc" id="L2397">                    setColor(leftOf(sib), BLACK);</span>
<span class="fc" id="L2398">                    rotateRight(parentOf(x));</span>
<span class="fc" id="L2399">                    x = root;</span>
                }
<span class="fc" id="L2401">            }</span>
        }

<span class="fc" id="L2404">        setColor(x, BLACK);</span>
<span class="fc" id="L2405">    }</span>

    private static final long serialVersionUID = 919286545866124006L;

    /**
     * Save the state of the {@code TreeMap} instance to a stream (i.e.,
     * serialize it).
     *
     * @serialData The &lt;em&gt;size&lt;/em&gt; of the TreeMap (the number of key-value
     *             mappings) is emitted (int), followed by the key (Object)
     *             and value (Object) for each key-value mapping represented
     *             by the TreeMap. The key-value mappings are emitted in
     *             key-order (as determined by the TreeMap's Comparator,
     *             or by the keys' natural ordering if the TreeMap has no
     *             Comparator).
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out the Comparator and any hidden stuff
<span class="fc" id="L2424">        s.defaultWriteObject();</span>

        // Write out size (number of Mappings)
<span class="fc" id="L2427">        s.writeInt(size);</span>

        // Write out keys and values (alternating)
<span class="fc bfc" id="L2430" title="All 2 branches covered.">        for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L2431">            Map.Entry&lt;K,V&gt; e = i.next();</span>
<span class="fc" id="L2432">            s.writeObject(e.getKey());</span>
<span class="fc" id="L2433">            s.writeObject(e.getValue());</span>
<span class="fc" id="L2434">        }</span>
<span class="fc" id="L2435">    }</span>

    /**
     * Reconstitute the {@code TreeMap} instance from a stream (i.e.,
     * deserialize it).
     */
    private void readObject(final java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in the Comparator and any hidden stuff
<span class="fc" id="L2444">        s.defaultReadObject();</span>

        // Read in size
<span class="fc" id="L2447">        int size = s.readInt();</span>

<span class="fc" id="L2449">        buildFromSorted(size, null, s, null);</span>
<span class="fc" id="L2450">    }</span>

    /** Intended to be called only from TreeSet.readObject */
    void readTreeSet(int size, java.io.ObjectInputStream s, V defaultVal)
        throws java.io.IOException, ClassNotFoundException {
<span class="fc" id="L2455">        buildFromSorted(size, null, s, defaultVal);</span>
<span class="fc" id="L2456">    }</span>

    /** Intended to be called only from TreeSet.addAll */
    void addAllForTreeSet(SortedSet&lt;? extends K&gt; set, V defaultVal) {
        try {
<span class="nc" id="L2461">            buildFromSorted(set.size(), set.iterator(), null, defaultVal);</span>
<span class="nc" id="L2462">        } catch (java.io.IOException cannotHappen) {</span>
<span class="nc" id="L2463">        } catch (ClassNotFoundException cannotHappen) {</span>
<span class="nc" id="L2464">        }</span>
<span class="nc" id="L2465">    }</span>


    /**
     * Linear time tree building algorithm from sorted data.  Can accept keys
     * and/or values from iterator or stream. This leads to too many
     * parameters, but seems better than alternatives.  The four formats
     * that this method accepts are:
     *
     *    1) An iterator of Map.Entries.  (it != null, defaultVal == null).
     *    2) An iterator of keys.         (it != null, defaultVal != null).
     *    3) A stream of alternating serialized keys and values.
     *                                   (it == null, defaultVal == null).
     *    4) A stream of serialized keys. (it == null, defaultVal != null).
     *
     * It is assumed that the comparator of the TreeMap is already set prior
     * to calling this method.
     *
     * @param size the number of keys (or key-value pairs) to be read from
     *        the iterator or stream
     * @param it If non-null, new entries are created from entries
     *        or keys read from this iterator.
     * @param str If non-null, new entries are created from keys and
     *        possibly values read from this stream in serialized form.
     *        Exactly one of it and str should be non-null.
     * @param defaultVal if non-null, this default value is used for
     *        each value in the map.  If null, each value is read from
     *        iterator or stream, as described above.
     * @throws java.io.IOException propagated from stream reads. This cannot
     *         occur if str is null.
     * @throws ClassNotFoundException propagated from readObject.
     *         This cannot occur if str is null.
     */
    private void buildFromSorted(int size, Iterator&lt;?&gt; it,
                                 java.io.ObjectInputStream str,
                                 V defaultVal)
        throws  java.io.IOException, ClassNotFoundException {
<span class="fc" id="L2502">        this.size = size;</span>
<span class="fc" id="L2503">        root = buildFromSorted(0, 0, size-1, computeRedLevel(size),</span>
                               it, str, defaultVal);
<span class="fc" id="L2505">    }</span>

    /**
     * Recursive &quot;helper method&quot; that does the real work of the
     * previous method.  Identically named parameters have
     * identical definitions.  Additional parameters are documented below.
     * It is assumed that the comparator and size fields of the TreeMap are
     * already set prior to calling this method.  (It ignores both fields.)
     *
     * @param level the current level of tree. Initial call should be 0.
     * @param lo the first element index of this subtree. Initial should be 0.
     * @param hi the last element index of this subtree.  Initial should be
     *        size-1.
     * @param redLevel the level at which nodes should be red.
     *        Must be equal to computeRedLevel for tree of this size.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi,
                                             int redLevel,
                                             Iterator&lt;?&gt; it,
                                             java.io.ObjectInputStream str,
                                             V defaultVal)
        throws  java.io.IOException, ClassNotFoundException {
        /*
         * Strategy: The root is the middlemost element. To get to it, we
         * have to first recursively construct the entire left subtree,
         * so as to grab all of its elements. We can then proceed with right
         * subtree.
         *
         * The lo and hi arguments are the minimum and maximum
         * indices to pull out of the iterator or stream for current subtree.
         * They are not actually indexed, we just proceed sequentially,
         * ensuring that items are extracted in corresponding order.
         */

<span class="fc bfc" id="L2540" title="All 2 branches covered.">        if (hi &lt; lo) return null;</span>

<span class="fc" id="L2542">        int mid = (lo + hi) &gt;&gt;&gt; 1;</span>

<span class="fc" id="L2544">        Entry&lt;K,V&gt; left  = null;</span>
<span class="fc bfc" id="L2545" title="All 2 branches covered.">        if (lo &lt; mid)</span>
<span class="fc" id="L2546">            left = buildFromSorted(level+1, lo, mid - 1, redLevel,</span>
                                   it, str, defaultVal);

        // extract key and/or value from iterator or stream
        K key;
        V value;
<span class="fc bfc" id="L2552" title="All 2 branches covered.">        if (it != null) {</span>
<span class="pc bpc" id="L2553" title="1 of 2 branches missed.">            if (defaultVal==null) {</span>
<span class="fc" id="L2554">                Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)it.next();</span>
<span class="fc" id="L2555">                key = (K)entry.getKey();</span>
<span class="fc" id="L2556">                value = (V)entry.getValue();</span>
<span class="fc" id="L2557">            } else {</span>
<span class="nc" id="L2558">                key = (K)it.next();</span>
<span class="nc" id="L2559">                value = defaultVal;</span>
            }
        } else { // use stream
<span class="fc" id="L2562">            key = (K) str.readObject();</span>
<span class="fc bfc" id="L2563" title="All 2 branches covered.">            value = (defaultVal != null ? defaultVal : (V) str.readObject());</span>
        }

<span class="fc" id="L2566">        Entry&lt;K,V&gt; middle =  new Entry&lt;&gt;(key, value, null);</span>

        // color nodes in non-full bottommost level red
<span class="fc bfc" id="L2569" title="All 2 branches covered.">        if (level == redLevel)</span>
<span class="fc" id="L2570">            middle.color = RED;</span>

<span class="fc bfc" id="L2572" title="All 2 branches covered.">        if (left != null) {</span>
<span class="fc" id="L2573">            middle.left = left;</span>
<span class="fc" id="L2574">            left.parent = middle;</span>
        }

<span class="fc bfc" id="L2577" title="All 2 branches covered.">        if (mid &lt; hi) {</span>
<span class="fc" id="L2578">            Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel,</span>
                                               it, str, defaultVal);
<span class="fc" id="L2580">            middle.right = right;</span>
<span class="fc" id="L2581">            right.parent = middle;</span>
        }

<span class="fc" id="L2584">        return middle;</span>
    }

    /**
     * Find the level down to which to assign all nodes BLACK.  This is the
     * last `full' level of the complete binary tree produced by
     * buildTree. The remaining nodes are colored RED. (This makes a `nice'
     * set of color assignments wrt future insertions.) This level number is
     * computed by finding the number of splits needed to reach the zeroeth
     * node.  (The answer is ~lg(N), but in any case must be computed by same
     * quick O(lg(N)) loop.)
     */
    private static int computeRedLevel(int sz) {
<span class="fc" id="L2597">        int level = 0;</span>
<span class="fc bfc" id="L2598" title="All 2 branches covered.">        for (int m = sz - 1; m &gt;= 0; m = m / 2 - 1)</span>
<span class="fc" id="L2599">            level++;</span>
<span class="fc" id="L2600">        return level;</span>
    }

    /**
     * Currently, we support Spliterator-based versions only for the
     * full map, in either plain of descending form, otherwise relying
     * on defaults because size estimation for submaps would dominate
     * costs. The type tests needed to check these for key views are
     * not very nice but avoid disrupting existing class
     * structures. Callers must use plain default spliterators if this
     * returns null.
     */
    static &lt;K&gt; Spliterator&lt;K&gt; keySpliteratorFor(NavigableMap&lt;K,?&gt; m) {
<span class="fc bfc" id="L2613" title="All 2 branches covered.">        if (m instanceof TreeMap) {</span>
<span class="fc" id="L2614">            @SuppressWarnings(&quot;unchecked&quot;) TreeMap&lt;K,Object&gt; t =</span>
                (TreeMap&lt;K,Object&gt;) m;
<span class="fc" id="L2616">            return t.keySpliterator();</span>
        }
<span class="pc bpc" id="L2618" title="1 of 2 branches missed.">        if (m instanceof DescendingSubMap) {</span>
<span class="fc" id="L2619">            @SuppressWarnings(&quot;unchecked&quot;) DescendingSubMap&lt;K,?&gt; dm =</span>
                (DescendingSubMap&lt;K,?&gt;) m;
<span class="fc" id="L2621">            TreeMap&lt;K,?&gt; tm = dm.m;</span>
<span class="pc bpc" id="L2622" title="1 of 2 branches missed.">            if (dm == tm.descendingMap) {</span>
<span class="fc" id="L2623">                @SuppressWarnings(&quot;unchecked&quot;) TreeMap&lt;K,Object&gt; t =</span>
                    (TreeMap&lt;K,Object&gt;) tm;
<span class="fc" id="L2625">                return t.descendingKeySpliterator();</span>
            }
        }
<span class="nc" id="L2628">        @SuppressWarnings(&quot;unchecked&quot;) NavigableSubMap&lt;K,?&gt; sm =</span>
            (NavigableSubMap&lt;K,?&gt;) m;
<span class="nc" id="L2630">        return sm.keySpliterator();</span>
    }

    final Spliterator&lt;K&gt; keySpliterator() {
<span class="fc" id="L2634">        return new KeySpliterator&lt;K,V&gt;(this, null, null, 0, -1, 0);</span>
    }

    final Spliterator&lt;K&gt; descendingKeySpliterator() {
<span class="fc" id="L2638">        return new DescendingKeySpliterator&lt;K,V&gt;(this, null, null, 0, -2, 0);</span>
    }

    /**
     * Base class for spliterators.  Iteration starts at a given
     * origin and continues up to but not including a given fence (or
     * null for end).  At top-level, for ascending cases, the first
     * split uses the root as left-fence/right-origin. From there,
     * right-hand splits replace the current fence with its left
     * child, also serving as origin for the split-off spliterator.
     * Left-hands are symmetric. Descending versions place the origin
     * at the end and invert ascending split rules.  This base class
     * is non-commital about directionality, or whether the top-level
     * spliterator covers the whole tree. This means that the actual
     * split mechanics are located in subclasses. Some of the subclass
     * trySplit methods are identical (except for return types), but
     * not nicely factorable.
     *
     * Currently, subclass versions exist only for the full map
     * (including descending keys via its descendingMap).  Others are
     * possible but currently not worthwhile because submaps require
     * O(n) computations to determine size, which substantially limits
     * potential speed-ups of using custom Spliterators versus default
     * mechanics.
     *
     * To boostrap initialization, external constructors use
     * negative size estimates: -1 for ascend, -2 for descend.
     */
    static class TreeMapSpliterator&lt;K,V&gt; {
        final TreeMap&lt;K,V&gt; tree;
        TreeMap.Entry&lt;K,V&gt; current; // traverser; initially first node in range
        TreeMap.Entry&lt;K,V&gt; fence;   // one past last, or null
        int side;                   // 0: top, -1: is a left split, +1: right
        int est;                    // size estimate (exact only for top-level)
        int expectedModCount;       // for CME checks

        TreeMapSpliterator(TreeMap&lt;K,V&gt; tree,
                           TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,
<span class="fc" id="L2676">                           int side, int est, int expectedModCount) {</span>
<span class="fc" id="L2677">            this.tree = tree;</span>
<span class="fc" id="L2678">            this.current = origin;</span>
<span class="fc" id="L2679">            this.fence = fence;</span>
<span class="fc" id="L2680">            this.side = side;</span>
<span class="fc" id="L2681">            this.est = est;</span>
<span class="fc" id="L2682">            this.expectedModCount = expectedModCount;</span>
<span class="fc" id="L2683">        }</span>

        final int getEstimate() { // force initialization
            int s; TreeMap&lt;K,V&gt; t;
<span class="pc bpc" id="L2687" title="1 of 2 branches missed.">            if ((s = est) &lt; 0) {</span>
<span class="pc bpc" id="L2688" title="1 of 2 branches missed.">                if ((t = tree) != null) {</span>
<span class="pc bpc" id="L2689" title="1 of 2 branches missed.">                    current = (s == -1) ? t.getFirstEntry() : t.getLastEntry();</span>
<span class="fc" id="L2690">                    s = est = t.size;</span>
<span class="fc" id="L2691">                    expectedModCount = t.modCount;</span>
                }
                else
<span class="nc" id="L2694">                    s = est = 0;</span>
            }
<span class="fc" id="L2696">            return s;</span>
        }

        public final long estimateSize() {
<span class="nc" id="L2700">            return (long)getEstimate();</span>
        }
    }

    static final class KeySpliterator&lt;K,V&gt;
        extends TreeMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;K&gt; {
        KeySpliterator(TreeMap&lt;K,V&gt; tree,
                       TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,
                       int side, int est, int expectedModCount) {
<span class="fc" id="L2710">            super(tree, origin, fence, side, est, expectedModCount);</span>
<span class="fc" id="L2711">        }</span>

        public KeySpliterator&lt;K,V&gt; trySplit() {
<span class="nc bnc" id="L2714" title="All 2 branches missed.">            if (est &lt; 0)</span>
<span class="nc" id="L2715">                getEstimate(); // force initialization</span>
<span class="nc" id="L2716">            int d = side;</span>
<span class="nc" id="L2717">            TreeMap.Entry&lt;K,V&gt; e = current, f = fence,</span>
<span class="nc bnc" id="L2718" title="All 6 branches missed.">                s = ((e == null || e == f) ? null :      // empty</span>
<span class="nc bnc" id="L2719" title="All 6 branches missed.">                     (d == 0)              ? tree.root : // was top</span>
                     (d &gt;  0)              ? e.right :   // was right
                     (d &lt;  0 &amp;&amp; f != null) ? f.left :    // was left
                     null);
<span class="nc bnc" id="L2723" title="All 6 branches missed.">            if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;</span>
<span class="nc bnc" id="L2724" title="All 2 branches missed.">                tree.compare(e.key, s.key) &lt; 0) {        // e not already past s</span>
<span class="nc" id="L2725">                side = 1;</span>
<span class="nc" id="L2726">                return new KeySpliterator&lt;&gt;</span>
                    (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);
            }
<span class="nc" id="L2729">            return null;</span>
        }

        public void forEachRemaining(Consumer&lt;? super K&gt; action) {
<span class="pc bpc" id="L2733" title="1 of 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L2734">                throw new NullPointerException();</span>
<span class="pc bpc" id="L2735" title="1 of 2 branches missed.">            if (est &lt; 0)</span>
<span class="fc" id="L2736">                getEstimate(); // force initialization</span>
<span class="fc" id="L2737">            TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pl;</span>
<span class="pc bpc" id="L2738" title="1 of 4 branches missed.">            if ((e = current) != null &amp;&amp; e != f) {</span>
<span class="fc" id="L2739">                current = f; // exhaust</span>
                do {
<span class="fc" id="L2741">                    action.accept(e.key);</span>
<span class="fc bfc" id="L2742" title="All 2 branches covered.">                    if ((p = e.right) != null) {</span>
<span class="fc bfc" id="L2743" title="All 2 branches covered.">                        while ((pl = p.left) != null)</span>
<span class="fc" id="L2744">                            p = pl;</span>
                    }
                    else {
<span class="fc bfc" id="L2747" title="All 4 branches covered.">                        while ((p = e.parent) != null &amp;&amp; e == p.right)</span>
<span class="fc" id="L2748">                            e = p;</span>
                    }
<span class="pc bpc" id="L2750" title="1 of 4 branches missed.">                } while ((e = p) != null &amp;&amp; e != f);</span>
<span class="pc bpc" id="L2751" title="1 of 2 branches missed.">                if (tree.modCount != expectedModCount)</span>
<span class="nc" id="L2752">                    throw new ConcurrentModificationException();</span>
            }
<span class="fc" id="L2754">        }</span>

        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
            TreeMap.Entry&lt;K,V&gt; e;
<span class="pc bpc" id="L2758" title="1 of 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L2759">                throw new NullPointerException();</span>
<span class="fc bfc" id="L2760" title="All 2 branches covered.">            if (est &lt; 0)</span>
<span class="fc" id="L2761">                getEstimate(); // force initialization</span>
<span class="pc bpc" id="L2762" title="1 of 4 branches missed.">            if ((e = current) == null || e == fence)</span>
<span class="fc" id="L2763">                return false;</span>
<span class="fc" id="L2764">            current = successor(e);</span>
<span class="fc" id="L2765">            action.accept(e.key);</span>
<span class="pc bpc" id="L2766" title="1 of 2 branches missed.">            if (tree.modCount != expectedModCount)</span>
<span class="nc" id="L2767">                throw new ConcurrentModificationException();</span>
<span class="fc" id="L2768">            return true;</span>
        }

        public int characteristics() {
<span class="pc bpc" id="L2772" title="1 of 2 branches missed.">            return (side == 0 ? Spliterator.SIZED : 0) |</span>
                Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED;
        }

        public final Comparator&lt;? super K&gt;  getComparator() {
<span class="fc" id="L2777">            return tree.comparator;</span>
        }

    }

    static final class DescendingKeySpliterator&lt;K,V&gt;
        extends TreeMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;K&gt; {
        DescendingKeySpliterator(TreeMap&lt;K,V&gt; tree,
                                 TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,
                                 int side, int est, int expectedModCount) {
<span class="fc" id="L2788">            super(tree, origin, fence, side, est, expectedModCount);</span>
<span class="fc" id="L2789">        }</span>

        public DescendingKeySpliterator&lt;K,V&gt; trySplit() {
<span class="nc bnc" id="L2792" title="All 2 branches missed.">            if (est &lt; 0)</span>
<span class="nc" id="L2793">                getEstimate(); // force initialization</span>
<span class="nc" id="L2794">            int d = side;</span>
<span class="nc" id="L2795">            TreeMap.Entry&lt;K,V&gt; e = current, f = fence,</span>
<span class="nc bnc" id="L2796" title="All 6 branches missed.">                    s = ((e == null || e == f) ? null :      // empty</span>
<span class="nc bnc" id="L2797" title="All 6 branches missed.">                         (d == 0)              ? tree.root : // was top</span>
                         (d &lt;  0)              ? e.left :    // was left
                         (d &gt;  0 &amp;&amp; f != null) ? f.right :   // was right
                         null);
<span class="nc bnc" id="L2801" title="All 6 branches missed.">            if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;</span>
<span class="nc bnc" id="L2802" title="All 2 branches missed.">                tree.compare(e.key, s.key) &gt; 0) {       // e not already past s</span>
<span class="nc" id="L2803">                side = 1;</span>
<span class="nc" id="L2804">                return new DescendingKeySpliterator&lt;&gt;</span>
                        (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);
            }
<span class="nc" id="L2807">            return null;</span>
        }

        public void forEachRemaining(Consumer&lt;? super K&gt; action) {
<span class="nc bnc" id="L2811" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L2812">                throw new NullPointerException();</span>
<span class="nc bnc" id="L2813" title="All 2 branches missed.">            if (est &lt; 0)</span>
<span class="nc" id="L2814">                getEstimate(); // force initialization</span>
<span class="nc" id="L2815">            TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pr;</span>
<span class="nc bnc" id="L2816" title="All 4 branches missed.">            if ((e = current) != null &amp;&amp; e != f) {</span>
<span class="nc" id="L2817">                current = f; // exhaust</span>
                do {
<span class="nc" id="L2819">                    action.accept(e.key);</span>
<span class="nc bnc" id="L2820" title="All 2 branches missed.">                    if ((p = e.left) != null) {</span>
<span class="nc bnc" id="L2821" title="All 2 branches missed.">                        while ((pr = p.right) != null)</span>
<span class="nc" id="L2822">                            p = pr;</span>
                    }
                    else {
<span class="nc bnc" id="L2825" title="All 4 branches missed.">                        while ((p = e.parent) != null &amp;&amp; e == p.left)</span>
<span class="nc" id="L2826">                            e = p;</span>
                    }
<span class="nc bnc" id="L2828" title="All 4 branches missed.">                } while ((e = p) != null &amp;&amp; e != f);</span>
<span class="nc bnc" id="L2829" title="All 2 branches missed.">                if (tree.modCount != expectedModCount)</span>
<span class="nc" id="L2830">                    throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L2832">        }</span>

        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
            TreeMap.Entry&lt;K,V&gt; e;
<span class="nc bnc" id="L2836" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L2837">                throw new NullPointerException();</span>
<span class="nc bnc" id="L2838" title="All 2 branches missed.">            if (est &lt; 0)</span>
<span class="nc" id="L2839">                getEstimate(); // force initialization</span>
<span class="nc bnc" id="L2840" title="All 4 branches missed.">            if ((e = current) == null || e == fence)</span>
<span class="nc" id="L2841">                return false;</span>
<span class="nc" id="L2842">            current = predecessor(e);</span>
<span class="nc" id="L2843">            action.accept(e.key);</span>
<span class="nc bnc" id="L2844" title="All 2 branches missed.">            if (tree.modCount != expectedModCount)</span>
<span class="nc" id="L2845">                throw new ConcurrentModificationException();</span>
<span class="nc" id="L2846">            return true;</span>
        }

        public int characteristics() {
<span class="pc bpc" id="L2850" title="1 of 2 branches missed.">            return (side == 0 ? Spliterator.SIZED : 0) |</span>
                Spliterator.DISTINCT | Spliterator.ORDERED;
        }
    }

    static final class ValueSpliterator&lt;K,V&gt;
            extends TreeMapSpliterator&lt;K,V&gt;
            implements Spliterator&lt;V&gt; {
        ValueSpliterator(TreeMap&lt;K,V&gt; tree,
                         TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,
                         int side, int est, int expectedModCount) {
<span class="fc" id="L2861">            super(tree, origin, fence, side, est, expectedModCount);</span>
<span class="fc" id="L2862">        }</span>

        public ValueSpliterator&lt;K,V&gt; trySplit() {
<span class="nc bnc" id="L2865" title="All 2 branches missed.">            if (est &lt; 0)</span>
<span class="nc" id="L2866">                getEstimate(); // force initialization</span>
<span class="nc" id="L2867">            int d = side;</span>
<span class="nc" id="L2868">            TreeMap.Entry&lt;K,V&gt; e = current, f = fence,</span>
<span class="nc bnc" id="L2869" title="All 6 branches missed.">                    s = ((e == null || e == f) ? null :      // empty</span>
<span class="nc bnc" id="L2870" title="All 6 branches missed.">                         (d == 0)              ? tree.root : // was top</span>
                         (d &gt;  0)              ? e.right :   // was right
                         (d &lt;  0 &amp;&amp; f != null) ? f.left :    // was left
                         null);
<span class="nc bnc" id="L2874" title="All 6 branches missed.">            if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;</span>
<span class="nc bnc" id="L2875" title="All 2 branches missed.">                tree.compare(e.key, s.key) &lt; 0) {        // e not already past s</span>
<span class="nc" id="L2876">                side = 1;</span>
<span class="nc" id="L2877">                return new ValueSpliterator&lt;&gt;</span>
                        (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);
            }
<span class="nc" id="L2880">            return null;</span>
        }

        public void forEachRemaining(Consumer&lt;? super V&gt; action) {
<span class="nc bnc" id="L2884" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L2885">                throw new NullPointerException();</span>
<span class="nc bnc" id="L2886" title="All 2 branches missed.">            if (est &lt; 0)</span>
<span class="nc" id="L2887">                getEstimate(); // force initialization</span>
<span class="nc" id="L2888">            TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pl;</span>
<span class="nc bnc" id="L2889" title="All 4 branches missed.">            if ((e = current) != null &amp;&amp; e != f) {</span>
<span class="nc" id="L2890">                current = f; // exhaust</span>
                do {
<span class="nc" id="L2892">                    action.accept(e.value);</span>
<span class="nc bnc" id="L2893" title="All 2 branches missed.">                    if ((p = e.right) != null) {</span>
<span class="nc bnc" id="L2894" title="All 2 branches missed.">                        while ((pl = p.left) != null)</span>
<span class="nc" id="L2895">                            p = pl;</span>
                    }
                    else {
<span class="nc bnc" id="L2898" title="All 4 branches missed.">                        while ((p = e.parent) != null &amp;&amp; e == p.right)</span>
<span class="nc" id="L2899">                            e = p;</span>
                    }
<span class="nc bnc" id="L2901" title="All 4 branches missed.">                } while ((e = p) != null &amp;&amp; e != f);</span>
<span class="nc bnc" id="L2902" title="All 2 branches missed.">                if (tree.modCount != expectedModCount)</span>
<span class="nc" id="L2903">                    throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L2905">        }</span>

        public boolean tryAdvance(Consumer&lt;? super V&gt; action) {
            TreeMap.Entry&lt;K,V&gt; e;
<span class="nc bnc" id="L2909" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L2910">                throw new NullPointerException();</span>
<span class="nc bnc" id="L2911" title="All 2 branches missed.">            if (est &lt; 0)</span>
<span class="nc" id="L2912">                getEstimate(); // force initialization</span>
<span class="nc bnc" id="L2913" title="All 4 branches missed.">            if ((e = current) == null || e == fence)</span>
<span class="nc" id="L2914">                return false;</span>
<span class="nc" id="L2915">            current = successor(e);</span>
<span class="nc" id="L2916">            action.accept(e.value);</span>
<span class="nc bnc" id="L2917" title="All 2 branches missed.">            if (tree.modCount != expectedModCount)</span>
<span class="nc" id="L2918">                throw new ConcurrentModificationException();</span>
<span class="nc" id="L2919">            return true;</span>
        }

        public int characteristics() {
<span class="pc bpc" id="L2923" title="1 of 2 branches missed.">            return (side == 0 ? Spliterator.SIZED : 0) | Spliterator.ORDERED;</span>
        }
    }

    static final class EntrySpliterator&lt;K,V&gt;
        extends TreeMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        EntrySpliterator(TreeMap&lt;K,V&gt; tree,
                         TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,
                         int side, int est, int expectedModCount) {
<span class="fc" id="L2933">            super(tree, origin, fence, side, est, expectedModCount);</span>
<span class="fc" id="L2934">        }</span>

        public EntrySpliterator&lt;K,V&gt; trySplit() {
<span class="nc bnc" id="L2937" title="All 2 branches missed.">            if (est &lt; 0)</span>
<span class="nc" id="L2938">                getEstimate(); // force initialization</span>
<span class="nc" id="L2939">            int d = side;</span>
<span class="nc" id="L2940">            TreeMap.Entry&lt;K,V&gt; e = current, f = fence,</span>
<span class="nc bnc" id="L2941" title="All 6 branches missed.">                    s = ((e == null || e == f) ? null :      // empty</span>
<span class="nc bnc" id="L2942" title="All 6 branches missed.">                         (d == 0)              ? tree.root : // was top</span>
                         (d &gt;  0)              ? e.right :   // was right
                         (d &lt;  0 &amp;&amp; f != null) ? f.left :    // was left
                         null);
<span class="nc bnc" id="L2946" title="All 6 branches missed.">            if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;</span>
<span class="nc bnc" id="L2947" title="All 2 branches missed.">                tree.compare(e.key, s.key) &lt; 0) {        // e not already past s</span>
<span class="nc" id="L2948">                side = 1;</span>
<span class="nc" id="L2949">                return new EntrySpliterator&lt;&gt;</span>
                        (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);
            }
<span class="nc" id="L2952">            return null;</span>
        }

        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K, V&gt;&gt; action) {
<span class="nc bnc" id="L2956" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L2957">                throw new NullPointerException();</span>
<span class="nc bnc" id="L2958" title="All 2 branches missed.">            if (est &lt; 0)</span>
<span class="nc" id="L2959">                getEstimate(); // force initialization</span>
<span class="nc" id="L2960">            TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pl;</span>
<span class="nc bnc" id="L2961" title="All 4 branches missed.">            if ((e = current) != null &amp;&amp; e != f) {</span>
<span class="nc" id="L2962">                current = f; // exhaust</span>
                do {
<span class="nc" id="L2964">                    action.accept(e);</span>
<span class="nc bnc" id="L2965" title="All 2 branches missed.">                    if ((p = e.right) != null) {</span>
<span class="nc bnc" id="L2966" title="All 2 branches missed.">                        while ((pl = p.left) != null)</span>
<span class="nc" id="L2967">                            p = pl;</span>
                    }
                    else {
<span class="nc bnc" id="L2970" title="All 4 branches missed.">                        while ((p = e.parent) != null &amp;&amp; e == p.right)</span>
<span class="nc" id="L2971">                            e = p;</span>
                    }
<span class="nc bnc" id="L2973" title="All 4 branches missed.">                } while ((e = p) != null &amp;&amp; e != f);</span>
<span class="nc bnc" id="L2974" title="All 2 branches missed.">                if (tree.modCount != expectedModCount)</span>
<span class="nc" id="L2975">                    throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L2977">        }</span>

        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
            TreeMap.Entry&lt;K,V&gt; e;
<span class="nc bnc" id="L2981" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L2982">                throw new NullPointerException();</span>
<span class="nc bnc" id="L2983" title="All 2 branches missed.">            if (est &lt; 0)</span>
<span class="nc" id="L2984">                getEstimate(); // force initialization</span>
<span class="nc bnc" id="L2985" title="All 4 branches missed.">            if ((e = current) == null || e == fence)</span>
<span class="nc" id="L2986">                return false;</span>
<span class="nc" id="L2987">            current = successor(e);</span>
<span class="nc" id="L2988">            action.accept(e);</span>
<span class="nc bnc" id="L2989" title="All 2 branches missed.">            if (tree.modCount != expectedModCount)</span>
<span class="nc" id="L2990">                throw new ConcurrentModificationException();</span>
<span class="nc" id="L2991">            return true;</span>
        }

        public int characteristics() {
<span class="pc bpc" id="L2995" title="1 of 2 branches missed.">            return (side == 0 ? Spliterator.SIZED : 0) |</span>
                    Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED;
        }

        @Override
        public Comparator&lt;Map.Entry&lt;K, V&gt;&gt; getComparator() {
            // Adapt or create a key-based comparator
<span class="pc bpc" id="L3002" title="1 of 2 branches missed.">            if (tree.comparator != null) {</span>
<span class="nc" id="L3003">                return Map.Entry.comparingByKey(tree.comparator);</span>
            }
            else {
<span class="fc" id="L3006">                return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (e1, e2) -&gt; {</span>
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Comparable&lt;? super K&gt; k1 = (Comparable&lt;? super K&gt;) e1.getKey();
                    return k1.compareTo(e2.getKey());
                };
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>