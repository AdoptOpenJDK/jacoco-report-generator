<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ComparableTimSort.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">ComparableTimSort.java</span></div><h1>ComparableTimSort.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2009 Google Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

/**
 * This is a near duplicate of {@link TimSort}, modified for use with
 * arrays of objects that implement {@link Comparable}, instead of using
 * explicit comparators.
 *
 * &lt;p&gt;If you are using an optimizing VM, you may find that ComparableTimSort
 * offers no performance benefit over TimSort in conjunction with a
 * comparator that simply returns {@code ((Comparable)first).compareTo(Second)}.
 * If this is the case, you are better off deleting ComparableTimSort to
 * eliminate the code duplication.  (See Arrays.java for details.)
 *
 * @author Josh Bloch
 */
<span class="fc bfc" id="L42" title="All 2 branches covered.">class ComparableTimSort {</span>
    /**
     * This is the minimum sized sequence that will be merged.  Shorter
     * sequences will be lengthened by calling binarySort.  If the entire
     * array is less than this length, no merges will be performed.
     *
     * This constant should be a power of two.  It was 64 in Tim Peter's C
     * implementation, but 32 was empirically determined to work better in
     * this implementation.  In the unlikely event that you set this constant
     * to be a number that's not a power of two, you'll need to change the
     * {@link #minRunLength} computation.
     *
     * If you decrease this constant, you must change the stackLen
     * computation in the TimSort constructor, or you risk an
     * ArrayOutOfBounds exception.  See listsort.txt for a discussion
     * of the minimum stack length required as a function of the length
     * of the array being sorted and the minimum merge sequence length.
     */
    private static final int MIN_MERGE = 32;

    /**
     * The array being sorted.
     */
    private final Object[] a;

    /**
     * When we get into galloping mode, we stay there until both runs win less
     * often than MIN_GALLOP consecutive times.
     */
    private static final int  MIN_GALLOP = 7;

    /**
     * This controls when we get *into* galloping mode.  It is initialized
     * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
     * random data, and lower for highly structured data.
     */
<span class="fc" id="L78">    private int minGallop = MIN_GALLOP;</span>

    /**
     * Maximum initial size of tmp array, which is used for merging.  The array
     * can grow to accommodate demand.
     *
     * Unlike Tim's original C version, we do not allocate this much storage
     * when sorting smaller arrays.  This change was required for performance.
     */
    private static final int INITIAL_TMP_STORAGE_LENGTH = 256;

    /**
     * Temp storage for merges. A workspace array may optionally be
     * provided in constructor, and if so will be used as long as it
     * is big enough.
     */
    private Object[] tmp;
    private int tmpBase; // base of tmp array slice
    private int tmpLen;  // length of tmp array slice

    /**
     * A stack of pending runs yet to be merged.  Run i starts at
     * address base[i] and extends for len[i] elements.  It's always
     * true (so long as the indices are in bounds) that:
     *
     *     runBase[i] + runLen[i] == runBase[i + 1]
     *
     * so we could cut the storage for this, but it's a minor amount,
     * and keeping all the info explicit simplifies the code.
     */
<span class="fc" id="L108">    private int stackSize = 0;  // Number of pending runs on stack</span>
    private final int[] runBase;
    private final int[] runLen;

    /**
     * Creates a TimSort instance to maintain the state of an ongoing sort.
     *
     * @param a the array to be sorted
     * @param work a workspace array (slice)
     * @param workBase origin of usable space in work array
     * @param workLen usable size of work array
     */
<span class="fc" id="L120">    private ComparableTimSort(Object[] a, Object[] work, int workBase, int workLen) {</span>
<span class="fc" id="L121">        this.a = a;</span>

        // Allocate temp storage (which may be increased later if necessary)
<span class="fc" id="L124">        int len = a.length;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        int tlen = (len &lt; 2 * INITIAL_TMP_STORAGE_LENGTH) ?</span>
            len &gt;&gt;&gt; 1 : INITIAL_TMP_STORAGE_LENGTH;
<span class="pc bpc" id="L127" title="5 of 6 branches missed.">        if (work == null || workLen &lt; tlen || workBase + tlen &gt; work.length) {</span>
<span class="fc" id="L128">            tmp = new Object[tlen];</span>
<span class="fc" id="L129">            tmpBase = 0;</span>
<span class="fc" id="L130">            tmpLen = tlen;</span>
        }
        else {
<span class="nc" id="L133">            tmp = work;</span>
<span class="nc" id="L134">            tmpBase = workBase;</span>
<span class="nc" id="L135">            tmpLen = workLen;</span>
        }

        /*
         * Allocate runs-to-be-merged stack (which cannot be expanded).  The
         * stack length requirements are described in listsort.txt.  The C
         * version always uses the same stack length (85), but this was
         * measured to be too expensive when sorting &quot;mid-sized&quot; arrays (e.g.,
         * 100 elements) in Java.  Therefore, we use smaller (but sufficiently
         * large) stack lengths for smaller arrays.  The &quot;magic numbers&quot; in the
         * computation below must be changed if MIN_MERGE is decreased.  See
         * the MIN_MERGE declaration above for more information.
         */
<span class="pc bpc" id="L148" title="1 of 6 branches missed.">        int stackLen = (len &lt;    120  ?  5 :</span>
                        len &lt;   1542  ? 10 :
                        len &lt; 119151  ? 24 : 40);
<span class="fc" id="L151">        runBase = new int[stackLen];</span>
<span class="fc" id="L152">        runLen = new int[stackLen];</span>
<span class="fc" id="L153">    }</span>

    /*
     * The next method (package private and static) constitutes the
     * entire API of this class.
     */

    /**
     * Sorts the given range, using the given workspace array slice
     * for temp storage when possible. This method is designed to be
     * invoked from public methods (in class Arrays) after performing
     * any necessary array bounds checks and expanding parameters into
     * the required forms.
     *
     * @param a the array to be sorted
     * @param lo the index of the first element, inclusive, to be sorted
     * @param hi the index of the last element, exclusive, to be sorted
     * @param work a workspace array (slice)
     * @param workBase origin of usable space in work array
     * @param workLen usable size of work array
     * @since 1.8
     */
    static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) {
<span class="pc bpc" id="L176" title="4 of 10 branches missed.">        assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span>

<span class="fc" id="L178">        int nRemaining  = hi - lo;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (nRemaining &lt; 2)</span>
<span class="fc" id="L180">            return;  // Arrays of size 0 and 1 are always sorted</span>

        // If array is small, do a &quot;mini-TimSort&quot; with no merges
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (nRemaining &lt; MIN_MERGE) {</span>
<span class="fc" id="L184">            int initRunLen = countRunAndMakeAscending(a, lo, hi);</span>
<span class="fc" id="L185">            binarySort(a, lo, hi, lo + initRunLen);</span>
<span class="fc" id="L186">            return;</span>
        }

        /**
         * March over the array once, left to right, finding natural runs,
         * extending short natural runs to minRun elements, and merging runs
         * to maintain stack invariant.
         */
<span class="fc" id="L194">        ComparableTimSort ts = new ComparableTimSort(a, work, workBase, workLen);</span>
<span class="fc" id="L195">        int minRun = minRunLength(nRemaining);</span>
        do {
            // Identify next run
<span class="fc" id="L198">            int runLen = countRunAndMakeAscending(a, lo, hi);</span>

            // If run is short, extend to min(minRun, nRemaining)
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (runLen &lt; minRun) {</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                int force = nRemaining &lt;= minRun ? nRemaining : minRun;</span>
<span class="fc" id="L203">                binarySort(a, lo, lo + force, lo + runLen);</span>
<span class="fc" id="L204">                runLen = force;</span>
            }

            // Push run onto pending-run stack, and maybe merge
<span class="fc" id="L208">            ts.pushRun(lo, runLen);</span>
<span class="fc" id="L209">            ts.mergeCollapse();</span>

            // Advance to find next run
<span class="fc" id="L212">            lo += runLen;</span>
<span class="fc" id="L213">            nRemaining -= runLen;</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">        } while (nRemaining != 0);</span>

        // Merge all remaining runs to complete sort
<span class="pc bpc" id="L217" title="1 of 4 branches missed.">        assert lo == hi;</span>
<span class="fc" id="L218">        ts.mergeForceCollapse();</span>
<span class="pc bpc" id="L219" title="1 of 4 branches missed.">        assert ts.stackSize == 1;</span>
<span class="fc" id="L220">    }</span>

    /**
     * Sorts the specified portion of the specified array using a binary
     * insertion sort.  This is the best method for sorting small numbers
     * of elements.  It requires O(n log n) compares, but O(n^2) data
     * movement (worst case).
     *
     * If the initial part of the specified range is already sorted,
     * this method can take advantage of it: the method assumes that the
     * elements from index {@code lo}, inclusive, to {@code start},
     * exclusive are already sorted.
     *
     * @param a the array in which a range is to be sorted
     * @param lo the index of the first element in the range to be sorted
     * @param hi the index after the last element in the range to be sorted
     * @param start the index of the first element in the range that is
     *        not already known to be sorted ({@code lo &lt;= start &lt;= hi})
     */
    @SuppressWarnings({&quot;fallthrough&quot;, &quot;rawtypes&quot;, &quot;unchecked&quot;})
    private static void binarySort(Object[] a, int lo, int hi, int start) {
<span class="pc bpc" id="L241" title="2 of 6 branches missed.">        assert lo &lt;= start &amp;&amp; start &lt;= hi;</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        if (start == lo)</span>
<span class="nc" id="L243">            start++;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for ( ; start &lt; hi; start++) {</span>
<span class="fc" id="L245">            Comparable pivot = (Comparable) a[start];</span>

            // Set left (and right) to the index where a[start] (pivot) belongs
<span class="fc" id="L248">            int left = lo;</span>
<span class="fc" id="L249">            int right = start;</span>
<span class="pc bpc" id="L250" title="1 of 4 branches missed.">            assert left &lt;= right;</span>
            /*
             * Invariants:
             *   pivot &gt;= all in [lo, left).
             *   pivot &lt;  all in [right, start).
             */
<span class="fc bfc" id="L256" title="All 2 branches covered.">            while (left &lt; right) {</span>
<span class="fc" id="L257">                int mid = (left + right) &gt;&gt;&gt; 1;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">                if (pivot.compareTo(a[mid]) &lt; 0)</span>
<span class="fc" id="L259">                    right = mid;</span>
                else
<span class="fc" id="L261">                    left = mid + 1;</span>
<span class="fc" id="L262">            }</span>
<span class="pc bpc" id="L263" title="1 of 4 branches missed.">            assert left == right;</span>

            /*
             * The invariants still hold: pivot &gt;= all in [lo, left) and
             * pivot &lt; all in [left, start), so pivot belongs at left.  Note
             * that if there are elements equal to pivot, left points to the
             * first slot after them -- that's why this sort is stable.
             * Slide elements over to make room for pivot.
             */
<span class="fc" id="L272">            int n = start - left;  // The number of elements to move</span>
            // Switch is just an optimization for arraycopy in default case
<span class="fc bfc" id="L274" title="All 3 branches covered.">            switch (n) {</span>
<span class="fc" id="L275">                case 2:  a[left + 2] = a[left + 1];</span>
<span class="fc" id="L276">                case 1:  a[left + 1] = a[left];</span>
<span class="fc" id="L277">                         break;</span>
<span class="fc" id="L278">                default: System.arraycopy(a, left, a, left + 1, n);</span>
            }
<span class="fc" id="L280">            a[left] = pivot;</span>
        }
<span class="fc" id="L282">    }</span>

    /**
     * Returns the length of the run beginning at the specified position in
     * the specified array and reverses the run if it is descending (ensuring
     * that the run will always be ascending when the method returns).
     *
     * A run is the longest ascending sequence with:
     *
     *    a[lo] &lt;= a[lo + 1] &lt;= a[lo + 2] &lt;= ...
     *
     * or the longest descending sequence with:
     *
     *    a[lo] &gt;  a[lo + 1] &gt;  a[lo + 2] &gt;  ...
     *
     * For its intended use in a stable mergesort, the strictness of the
     * definition of &quot;descending&quot; is needed so that the call can safely
     * reverse a descending sequence without violating stability.
     *
     * @param a the array in which a run is to be counted and possibly reversed
     * @param lo index of the first element in the run
     * @param hi index after the last element that may be contained in the run.
              It is required that {@code lo &lt; hi}.
     * @return  the length of the run beginning at the specified position in
     *          the specified array
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    private static int countRunAndMakeAscending(Object[] a, int lo, int hi) {
<span class="pc bpc" id="L310" title="1 of 4 branches missed.">        assert lo &lt; hi;</span>
<span class="fc" id="L311">        int runHi = lo + 1;</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (runHi == hi)</span>
<span class="nc" id="L313">            return 1;</span>

        // Find end of run, and reverse range if descending
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (((Comparable) a[runHi++]).compareTo(a[lo]) &lt; 0) { // Descending</span>
<span class="fc bfc" id="L317" title="All 4 branches covered.">            while (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &lt; 0)</span>
<span class="fc" id="L318">                runHi++;</span>
<span class="fc" id="L319">            reverseRange(a, lo, runHi);</span>
        } else {                              // Ascending
<span class="fc bfc" id="L321" title="All 4 branches covered.">            while (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &gt;= 0)</span>
<span class="fc" id="L322">                runHi++;</span>
        }

<span class="fc" id="L325">        return runHi - lo;</span>
    }

    /**
     * Reverse the specified range of the specified array.
     *
     * @param a the array in which a range is to be reversed
     * @param lo the index of the first element in the range to be reversed
     * @param hi the index after the last element in the range to be reversed
     */
    private static void reverseRange(Object[] a, int lo, int hi) {
<span class="fc" id="L336">        hi--;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">        while (lo &lt; hi) {</span>
<span class="fc" id="L338">            Object t = a[lo];</span>
<span class="fc" id="L339">            a[lo++] = a[hi];</span>
<span class="fc" id="L340">            a[hi--] = t;</span>
<span class="fc" id="L341">        }</span>
<span class="fc" id="L342">    }</span>

    /**
     * Returns the minimum acceptable run length for an array of the specified
     * length. Natural runs shorter than this will be extended with
     * {@link #binarySort}.
     *
     * Roughly speaking, the computation is:
     *
     *  If n &lt; MIN_MERGE, return n (it's too small to bother with fancy stuff).
     *  Else if n is an exact power of 2, return MIN_MERGE/2.
     *  Else return an int k, MIN_MERGE/2 &lt;= k &lt;= MIN_MERGE, such that n/k
     *   is close to, but strictly less than, an exact power of 2.
     *
     * For the rationale, see listsort.txt.
     *
     * @param n the length of the array to be sorted
     * @return the length of the minimum run to be merged
     */
    private static int minRunLength(int n) {
<span class="pc bpc" id="L362" title="1 of 4 branches missed.">        assert n &gt;= 0;</span>
<span class="fc" id="L363">        int r = 0;      // Becomes 1 if any 1 bits are shifted off</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        while (n &gt;= MIN_MERGE) {</span>
<span class="fc" id="L365">            r |= (n &amp; 1);</span>
<span class="fc" id="L366">            n &gt;&gt;= 1;</span>
        }
<span class="fc" id="L368">        return n + r;</span>
    }

    /**
     * Pushes the specified run onto the pending-run stack.
     *
     * @param runBase index of the first element in the run
     * @param runLen  the number of elements in the run
     */
    private void pushRun(int runBase, int runLen) {
<span class="fc" id="L378">        this.runBase[stackSize] = runBase;</span>
<span class="fc" id="L379">        this.runLen[stackSize] = runLen;</span>
<span class="fc" id="L380">        stackSize++;</span>
<span class="fc" id="L381">    }</span>

    /**
     * Examines the stack of runs waiting to be merged and merges adjacent runs
     * until the stack invariants are reestablished:
     *
     *     1. runLen[i - 3] &gt; runLen[i - 2] + runLen[i - 1]
     *     2. runLen[i - 2] &gt; runLen[i - 1]
     *
     * This method is called each time a new run is pushed onto the stack,
     * so the invariants are guaranteed to hold for i &lt; stackSize upon
     * entry to the method.
     */
    private void mergeCollapse() {
<span class="fc bfc" id="L395" title="All 2 branches covered.">        while (stackSize &gt; 1) {</span>
<span class="fc" id="L396">            int n = stackSize - 2;</span>
<span class="fc bfc" id="L397" title="All 4 branches covered.">            if (n &gt; 0 &amp;&amp; runLen[n-1] &lt;= runLen[n] + runLen[n+1]) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">                if (runLen[n - 1] &lt; runLen[n + 1])</span>
<span class="fc" id="L399">                    n--;</span>
<span class="fc" id="L400">                mergeAt(n);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            } else if (runLen[n] &lt;= runLen[n + 1]) {</span>
<span class="fc" id="L402">                mergeAt(n);</span>
            } else {
                break; // Invariant is established
            }
<span class="fc" id="L406">        }</span>
<span class="fc" id="L407">    }</span>

    /**
     * Merges all runs on the stack until only one remains.  This method is
     * called once, to complete the sort.
     */
    private void mergeForceCollapse() {
<span class="fc bfc" id="L414" title="All 2 branches covered.">        while (stackSize &gt; 1) {</span>
<span class="fc" id="L415">            int n = stackSize - 2;</span>
<span class="pc bpc" id="L416" title="1 of 4 branches missed.">            if (n &gt; 0 &amp;&amp; runLen[n - 1] &lt; runLen[n + 1])</span>
<span class="nc" id="L417">                n--;</span>
<span class="fc" id="L418">            mergeAt(n);</span>
<span class="fc" id="L419">        }</span>
<span class="fc" id="L420">    }</span>

    /**
     * Merges the two runs at stack indices i and i+1.  Run i must be
     * the penultimate or antepenultimate run on the stack.  In other words,
     * i must be equal to stackSize-2 or stackSize-3.
     *
     * @param i stack index of the first of the two runs to merge
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void mergeAt(int i) {
<span class="pc bpc" id="L431" title="1 of 4 branches missed.">        assert stackSize &gt;= 2;</span>
<span class="pc bpc" id="L432" title="1 of 4 branches missed.">        assert i &gt;= 0;</span>
<span class="pc bpc" id="L433" title="1 of 6 branches missed.">        assert i == stackSize - 2 || i == stackSize - 3;</span>

<span class="fc" id="L435">        int base1 = runBase[i];</span>
<span class="fc" id="L436">        int len1 = runLen[i];</span>
<span class="fc" id="L437">        int base2 = runBase[i + 1];</span>
<span class="fc" id="L438">        int len2 = runLen[i + 1];</span>
<span class="pc bpc" id="L439" title="2 of 6 branches missed.">        assert len1 &gt; 0 &amp;&amp; len2 &gt; 0;</span>
<span class="pc bpc" id="L440" title="1 of 4 branches missed.">        assert base1 + len1 == base2;</span>

        /*
         * Record the length of the combined runs; if i is the 3rd-last
         * run now, also slide over the last run (which isn't involved
         * in this merge).  The current run (i+1) goes away in any case.
         */
<span class="fc" id="L447">        runLen[i] = len1 + len2;</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">        if (i == stackSize - 3) {</span>
<span class="fc" id="L449">            runBase[i + 1] = runBase[i + 2];</span>
<span class="fc" id="L450">            runLen[i + 1] = runLen[i + 2];</span>
        }
<span class="fc" id="L452">        stackSize--;</span>

        /*
         * Find where the first element of run2 goes in run1. Prior elements
         * in run1 can be ignored (because they're already in place).
         */
<span class="fc" id="L458">        int k = gallopRight((Comparable&lt;Object&gt;) a[base2], a, base1, len1, 0);</span>
<span class="pc bpc" id="L459" title="1 of 4 branches missed.">        assert k &gt;= 0;</span>
<span class="fc" id="L460">        base1 += k;</span>
<span class="fc" id="L461">        len1 -= k;</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (len1 == 0)</span>
<span class="fc" id="L463">            return;</span>

        /*
         * Find where the last element of run1 goes in run2. Subsequent elements
         * in run2 can be ignored (because they're already in place).
         */
<span class="fc" id="L469">        len2 = gallopLeft((Comparable&lt;Object&gt;) a[base1 + len1 - 1], a,</span>
                base2, len2, len2 - 1);
<span class="pc bpc" id="L471" title="1 of 4 branches missed.">        assert len2 &gt;= 0;</span>
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (len2 == 0)</span>
<span class="nc" id="L473">            return;</span>

        // Merge remaining runs, using tmp array with min(len1, len2) elements
<span class="fc bfc" id="L476" title="All 2 branches covered.">        if (len1 &lt;= len2)</span>
<span class="fc" id="L477">            mergeLo(base1, len1, base2, len2);</span>
        else
<span class="fc" id="L479">            mergeHi(base1, len1, base2, len2);</span>
<span class="fc" id="L480">    }</span>

    /**
     * Locates the position at which to insert the specified key into the
     * specified sorted range; if the range contains an element equal to key,
     * returns the index of the leftmost equal element.
     *
     * @param key the key whose insertion point to search for
     * @param a the array in which to search
     * @param base the index of the first element in the range
     * @param len the length of the range; must be &gt; 0
     * @param hint the index at which to begin the search, 0 &lt;= hint &lt; n.
     *     The closer hint is to the result, the faster this method will run.
     * @return the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k],
     *    pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
     *    In other words, key belongs at index b + k; or in other words,
     *    the first k elements of a should precede key, and the last n - k
     *    should follow it.
     */
    private static int gallopLeft(Comparable&lt;Object&gt; key, Object[] a,
            int base, int len, int hint) {
<span class="pc bpc" id="L501" title="3 of 8 branches missed.">        assert len &gt; 0 &amp;&amp; hint &gt;= 0 &amp;&amp; hint &lt; len;</span>

<span class="fc" id="L503">        int lastOfs = 0;</span>
<span class="fc" id="L504">        int ofs = 1;</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">        if (key.compareTo(a[base + hint]) &gt; 0) {</span>
            // Gallop right until a[base+hint+lastOfs] &lt; key &lt;= a[base+hint+ofs]
<span class="fc" id="L507">            int maxOfs = len - hint;</span>
<span class="fc bfc" id="L508" title="All 4 branches covered.">            while (ofs &lt; maxOfs &amp;&amp; key.compareTo(a[base + hint + ofs]) &gt; 0) {</span>
<span class="fc" id="L509">                lastOfs = ofs;</span>
<span class="fc" id="L510">                ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">                if (ofs &lt;= 0)   // int overflow</span>
<span class="nc" id="L512">                    ofs = maxOfs;</span>
            }
<span class="fc bfc" id="L514" title="All 2 branches covered.">            if (ofs &gt; maxOfs)</span>
<span class="fc" id="L515">                ofs = maxOfs;</span>

            // Make offsets relative to base
<span class="fc" id="L518">            lastOfs += hint;</span>
<span class="fc" id="L519">            ofs += hint;</span>
<span class="fc" id="L520">        } else { // key &lt;= a[base + hint]</span>
            // Gallop left until a[base+hint-ofs] &lt; key &lt;= a[base+hint-lastOfs]
<span class="fc" id="L522">            final int maxOfs = hint + 1;</span>
<span class="fc bfc" id="L523" title="All 4 branches covered.">            while (ofs &lt; maxOfs &amp;&amp; key.compareTo(a[base + hint - ofs]) &lt;= 0) {</span>
<span class="fc" id="L524">                lastOfs = ofs;</span>
<span class="fc" id="L525">                ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">                if (ofs &lt;= 0)   // int overflow</span>
<span class="nc" id="L527">                    ofs = maxOfs;</span>
            }
<span class="fc bfc" id="L529" title="All 2 branches covered.">            if (ofs &gt; maxOfs)</span>
<span class="fc" id="L530">                ofs = maxOfs;</span>

            // Make offsets relative to base
<span class="fc" id="L533">            int tmp = lastOfs;</span>
<span class="fc" id="L534">            lastOfs = hint - ofs;</span>
<span class="fc" id="L535">            ofs = hint - tmp;</span>
        }
<span class="pc bpc" id="L537" title="3 of 8 branches missed.">        assert -1 &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;</span>

        /*
         * Now a[base+lastOfs] &lt; key &lt;= a[base+ofs], so key belongs somewhere
         * to the right of lastOfs but no farther right than ofs.  Do a binary
         * search, with invariant a[base + lastOfs - 1] &lt; key &lt;= a[base + ofs].
         */
<span class="fc" id="L544">        lastOfs++;</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">        while (lastOfs &lt; ofs) {</span>
<span class="fc" id="L546">            int m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; 1);</span>

<span class="fc bfc" id="L548" title="All 2 branches covered.">            if (key.compareTo(a[base + m]) &gt; 0)</span>
<span class="fc" id="L549">                lastOfs = m + 1;  // a[base + m] &lt; key</span>
            else
<span class="fc" id="L551">                ofs = m;          // key &lt;= a[base + m]</span>
<span class="fc" id="L552">        }</span>
<span class="pc bpc" id="L553" title="1 of 4 branches missed.">        assert lastOfs == ofs;    // so a[base + ofs - 1] &lt; key &lt;= a[base + ofs]</span>
<span class="fc" id="L554">        return ofs;</span>
    }

    /**
     * Like gallopLeft, except that if the range contains an element equal to
     * key, gallopRight returns the index after the rightmost equal element.
     *
     * @param key the key whose insertion point to search for
     * @param a the array in which to search
     * @param base the index of the first element in the range
     * @param len the length of the range; must be &gt; 0
     * @param hint the index at which to begin the search, 0 &lt;= hint &lt; n.
     *     The closer hint is to the result, the faster this method will run.
     * @return the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]
     */
    private static int gallopRight(Comparable&lt;Object&gt; key, Object[] a,
            int base, int len, int hint) {
<span class="pc bpc" id="L571" title="3 of 8 branches missed.">        assert len &gt; 0 &amp;&amp; hint &gt;= 0 &amp;&amp; hint &lt; len;</span>

<span class="fc" id="L573">        int ofs = 1;</span>
<span class="fc" id="L574">        int lastOfs = 0;</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (key.compareTo(a[base + hint]) &lt; 0) {</span>
            // Gallop left until a[b+hint - ofs] &lt;= key &lt; a[b+hint - lastOfs]
<span class="fc" id="L577">            int maxOfs = hint + 1;</span>
<span class="fc bfc" id="L578" title="All 4 branches covered.">            while (ofs &lt; maxOfs &amp;&amp; key.compareTo(a[base + hint - ofs]) &lt; 0) {</span>
<span class="fc" id="L579">                lastOfs = ofs;</span>
<span class="fc" id="L580">                ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">                if (ofs &lt;= 0)   // int overflow</span>
<span class="nc" id="L582">                    ofs = maxOfs;</span>
            }
<span class="fc bfc" id="L584" title="All 2 branches covered.">            if (ofs &gt; maxOfs)</span>
<span class="fc" id="L585">                ofs = maxOfs;</span>

            // Make offsets relative to b
<span class="fc" id="L588">            int tmp = lastOfs;</span>
<span class="fc" id="L589">            lastOfs = hint - ofs;</span>
<span class="fc" id="L590">            ofs = hint - tmp;</span>
<span class="fc" id="L591">        } else { // a[b + hint] &lt;= key</span>
            // Gallop right until a[b+hint + lastOfs] &lt;= key &lt; a[b+hint + ofs]
<span class="fc" id="L593">            int maxOfs = len - hint;</span>
<span class="fc bfc" id="L594" title="All 4 branches covered.">            while (ofs &lt; maxOfs &amp;&amp; key.compareTo(a[base + hint + ofs]) &gt;= 0) {</span>
<span class="fc" id="L595">                lastOfs = ofs;</span>
<span class="fc" id="L596">                ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">                if (ofs &lt;= 0)   // int overflow</span>
<span class="nc" id="L598">                    ofs = maxOfs;</span>
            }
<span class="fc bfc" id="L600" title="All 2 branches covered.">            if (ofs &gt; maxOfs)</span>
<span class="fc" id="L601">                ofs = maxOfs;</span>

            // Make offsets relative to b
<span class="fc" id="L604">            lastOfs += hint;</span>
<span class="fc" id="L605">            ofs += hint;</span>
        }
<span class="pc bpc" id="L607" title="3 of 8 branches missed.">        assert -1 &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;</span>

        /*
         * Now a[b + lastOfs] &lt;= key &lt; a[b + ofs], so key belongs somewhere to
         * the right of lastOfs but no farther right than ofs.  Do a binary
         * search, with invariant a[b + lastOfs - 1] &lt;= key &lt; a[b + ofs].
         */
<span class="fc" id="L614">        lastOfs++;</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">        while (lastOfs &lt; ofs) {</span>
<span class="fc" id="L616">            int m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; 1);</span>

<span class="fc bfc" id="L618" title="All 2 branches covered.">            if (key.compareTo(a[base + m]) &lt; 0)</span>
<span class="fc" id="L619">                ofs = m;          // key &lt; a[b + m]</span>
            else
<span class="fc" id="L621">                lastOfs = m + 1;  // a[b + m] &lt;= key</span>
<span class="fc" id="L622">        }</span>
<span class="pc bpc" id="L623" title="1 of 4 branches missed.">        assert lastOfs == ofs;    // so a[b + ofs - 1] &lt;= key &lt; a[b + ofs]</span>
<span class="fc" id="L624">        return ofs;</span>
    }

    /**
     * Merges two adjacent runs in place, in a stable fashion.  The first
     * element of the first run must be greater than the first element of the
     * second run (a[base1] &gt; a[base2]), and the last element of the first run
     * (a[base1 + len1-1]) must be greater than all elements of the second run.
     *
     * For performance, this method should be called only when len1 &lt;= len2;
     * its twin, mergeHi should be called if len1 &gt;= len2.  (Either method
     * may be called if len1 == len2.)
     *
     * @param base1 index of first element in first run to be merged
     * @param len1  length of first run to be merged (must be &gt; 0)
     * @param base2 index of first element in second run to be merged
     *        (must be aBase + aLen)
     * @param len2  length of second run to be merged (must be &gt; 0)
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    private void mergeLo(int base1, int len1, int base2, int len2) {
<span class="pc bpc" id="L645" title="3 of 8 branches missed.">        assert len1 &gt; 0 &amp;&amp; len2 &gt; 0 &amp;&amp; base1 + len1 == base2;</span>

        // Copy first run into temp array
<span class="fc" id="L648">        Object[] a = this.a; // For performance</span>
<span class="fc" id="L649">        Object[] tmp = ensureCapacity(len1);</span>

<span class="fc" id="L651">        int cursor1 = tmpBase; // Indexes into tmp array</span>
<span class="fc" id="L652">        int cursor2 = base2;   // Indexes int a</span>
<span class="fc" id="L653">        int dest = base1;      // Indexes int a</span>
<span class="fc" id="L654">        System.arraycopy(a, base1, tmp, cursor1, len1);</span>

        // Move first element of second run and deal with degenerate cases
<span class="fc" id="L657">        a[dest++] = a[cursor2++];</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">        if (--len2 == 0) {</span>
<span class="nc" id="L659">            System.arraycopy(tmp, cursor1, a, dest, len1);</span>
<span class="nc" id="L660">            return;</span>
        }
<span class="fc bfc" id="L662" title="All 2 branches covered.">        if (len1 == 1) {</span>
<span class="fc" id="L663">            System.arraycopy(a, cursor2, a, dest, len2);</span>
<span class="fc" id="L664">            a[dest + len2] = tmp[cursor1]; // Last elt of run 1 to end of merge</span>
<span class="fc" id="L665">            return;</span>
        }

<span class="fc" id="L668">        int minGallop = this.minGallop;  // Use local variable for performance</span>
    outer:
        while (true) {
<span class="fc" id="L671">            int count1 = 0; // Number of times in a row that first run won</span>
<span class="fc" id="L672">            int count2 = 0; // Number of times in a row that second run won</span>

            /*
             * Do the straightforward thing until (if ever) one run starts
             * winning consistently.
             */
            do {
<span class="pc bpc" id="L679" title="2 of 6 branches missed.">                assert len1 &gt; 1 &amp;&amp; len2 &gt; 0;</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">                if (((Comparable) a[cursor2]).compareTo(tmp[cursor1]) &lt; 0) {</span>
<span class="fc" id="L681">                    a[dest++] = a[cursor2++];</span>
<span class="fc" id="L682">                    count2++;</span>
<span class="fc" id="L683">                    count1 = 0;</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">                    if (--len2 == 0)</span>
<span class="fc" id="L685">                        break outer;</span>
                } else {
<span class="fc" id="L687">                    a[dest++] = tmp[cursor1++];</span>
<span class="fc" id="L688">                    count1++;</span>
<span class="fc" id="L689">                    count2 = 0;</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">                    if (--len1 == 1)</span>
<span class="fc" id="L691">                        break outer;</span>
                }
<span class="fc bfc" id="L693" title="All 2 branches covered.">            } while ((count1 | count2) &lt; minGallop);</span>

            /*
             * One run is winning so consistently that galloping may be a
             * huge win. So try that, and continue galloping until (if ever)
             * neither run appears to be winning consistently anymore.
             */
            do {
<span class="pc bpc" id="L701" title="2 of 6 branches missed.">                assert len1 &gt; 1 &amp;&amp; len2 &gt; 0;</span>
<span class="fc" id="L702">                count1 = gallopRight((Comparable) a[cursor2], tmp, cursor1, len1, 0);</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">                if (count1 != 0) {</span>
<span class="fc" id="L704">                    System.arraycopy(tmp, cursor1, a, dest, count1);</span>
<span class="fc" id="L705">                    dest += count1;</span>
<span class="fc" id="L706">                    cursor1 += count1;</span>
<span class="fc" id="L707">                    len1 -= count1;</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">                    if (len1 &lt;= 1)  // len1 == 1 || len1 == 0</span>
<span class="fc" id="L709">                        break outer;</span>
                }
<span class="fc" id="L711">                a[dest++] = a[cursor2++];</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">                if (--len2 == 0)</span>
<span class="fc" id="L713">                    break outer;</span>

<span class="fc" id="L715">                count2 = gallopLeft((Comparable) tmp[cursor1], a, cursor2, len2, 0);</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">                if (count2 != 0) {</span>
<span class="fc" id="L717">                    System.arraycopy(a, cursor2, a, dest, count2);</span>
<span class="fc" id="L718">                    dest += count2;</span>
<span class="fc" id="L719">                    cursor2 += count2;</span>
<span class="fc" id="L720">                    len2 -= count2;</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">                    if (len2 == 0)</span>
<span class="fc" id="L722">                        break outer;</span>
                }
<span class="fc" id="L724">                a[dest++] = tmp[cursor1++];</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">                if (--len1 == 1)</span>
<span class="fc" id="L726">                    break outer;</span>
<span class="fc" id="L727">                minGallop--;</span>
<span class="fc bfc" id="L728" title="All 6 branches covered.">            } while (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">            if (minGallop &lt; 0)</span>
<span class="fc" id="L730">                minGallop = 0;</span>
<span class="fc" id="L731">            minGallop += 2;  // Penalize for leaving gallop mode</span>
<span class="fc" id="L732">        }  // End of &quot;outer&quot; loop</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">        this.minGallop = minGallop &lt; 1 ? 1 : minGallop;  // Write back to field</span>

<span class="fc bfc" id="L735" title="All 2 branches covered.">        if (len1 == 1) {</span>
<span class="pc bpc" id="L736" title="1 of 4 branches missed.">            assert len2 &gt; 0;</span>
<span class="fc" id="L737">            System.arraycopy(a, cursor2, a, dest, len2);</span>
<span class="fc" id="L738">            a[dest + len2] = tmp[cursor1]; //  Last elt of run 1 to end of merge</span>
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">        } else if (len1 == 0) {</span>
<span class="nc" id="L740">            throw new IllegalArgumentException(</span>
                &quot;Comparison method violates its general contract!&quot;);
        } else {
<span class="pc bpc" id="L743" title="1 of 4 branches missed.">            assert len2 == 0;</span>
<span class="pc bpc" id="L744" title="1 of 4 branches missed.">            assert len1 &gt; 1;</span>
<span class="fc" id="L745">            System.arraycopy(tmp, cursor1, a, dest, len1);</span>
        }
<span class="fc" id="L747">    }</span>

    /**
     * Like mergeLo, except that this method should be called only if
     * len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2.  (Either method
     * may be called if len1 == len2.)
     *
     * @param base1 index of first element in first run to be merged
     * @param len1  length of first run to be merged (must be &gt; 0)
     * @param base2 index of first element in second run to be merged
     *        (must be aBase + aLen)
     * @param len2  length of second run to be merged (must be &gt; 0)
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    private void mergeHi(int base1, int len1, int base2, int len2) {
<span class="pc bpc" id="L762" title="3 of 8 branches missed.">        assert len1 &gt; 0 &amp;&amp; len2 &gt; 0 &amp;&amp; base1 + len1 == base2;</span>

        // Copy second run into temp array
<span class="fc" id="L765">        Object[] a = this.a; // For performance</span>
<span class="fc" id="L766">        Object[] tmp = ensureCapacity(len2);</span>
<span class="fc" id="L767">        int tmpBase = this.tmpBase;</span>
<span class="fc" id="L768">        System.arraycopy(a, base2, tmp, tmpBase, len2);</span>

<span class="fc" id="L770">        int cursor1 = base1 + len1 - 1;  // Indexes into a</span>
<span class="fc" id="L771">        int cursor2 = tmpBase + len2 - 1; // Indexes into tmp array</span>
<span class="fc" id="L772">        int dest = base2 + len2 - 1;     // Indexes into a</span>

        // Move last element of first run and deal with degenerate cases
<span class="fc" id="L775">        a[dest--] = a[cursor1--];</span>
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">        if (--len1 == 0) {</span>
<span class="nc" id="L777">            System.arraycopy(tmp, tmpBase, a, dest - (len2 - 1), len2);</span>
<span class="nc" id="L778">            return;</span>
        }
<span class="fc bfc" id="L780" title="All 2 branches covered.">        if (len2 == 1) {</span>
<span class="fc" id="L781">            dest -= len1;</span>
<span class="fc" id="L782">            cursor1 -= len1;</span>
<span class="fc" id="L783">            System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);</span>
<span class="fc" id="L784">            a[dest] = tmp[cursor2];</span>
<span class="fc" id="L785">            return;</span>
        }

<span class="fc" id="L788">        int minGallop = this.minGallop;  // Use local variable for performance</span>
    outer:
        while (true) {
<span class="fc" id="L791">            int count1 = 0; // Number of times in a row that first run won</span>
<span class="fc" id="L792">            int count2 = 0; // Number of times in a row that second run won</span>

            /*
             * Do the straightforward thing until (if ever) one run
             * appears to win consistently.
             */
            do {
<span class="pc bpc" id="L799" title="2 of 6 branches missed.">                assert len1 &gt; 0 &amp;&amp; len2 &gt; 1;</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">                if (((Comparable) tmp[cursor2]).compareTo(a[cursor1]) &lt; 0) {</span>
<span class="fc" id="L801">                    a[dest--] = a[cursor1--];</span>
<span class="fc" id="L802">                    count1++;</span>
<span class="fc" id="L803">                    count2 = 0;</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">                    if (--len1 == 0)</span>
<span class="fc" id="L805">                        break outer;</span>
                } else {
<span class="fc" id="L807">                    a[dest--] = tmp[cursor2--];</span>
<span class="fc" id="L808">                    count2++;</span>
<span class="fc" id="L809">                    count1 = 0;</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">                    if (--len2 == 1)</span>
<span class="fc" id="L811">                        break outer;</span>
                }
<span class="fc bfc" id="L813" title="All 2 branches covered.">            } while ((count1 | count2) &lt; minGallop);</span>

            /*
             * One run is winning so consistently that galloping may be a
             * huge win. So try that, and continue galloping until (if ever)
             * neither run appears to be winning consistently anymore.
             */
            do {
<span class="pc bpc" id="L821" title="2 of 6 branches missed.">                assert len1 &gt; 0 &amp;&amp; len2 &gt; 1;</span>
<span class="fc" id="L822">                count1 = len1 - gallopRight((Comparable) tmp[cursor2], a, base1, len1, len1 - 1);</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">                if (count1 != 0) {</span>
<span class="fc" id="L824">                    dest -= count1;</span>
<span class="fc" id="L825">                    cursor1 -= count1;</span>
<span class="fc" id="L826">                    len1 -= count1;</span>
<span class="fc" id="L827">                    System.arraycopy(a, cursor1 + 1, a, dest + 1, count1);</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">                    if (len1 == 0)</span>
<span class="fc" id="L829">                        break outer;</span>
                }
<span class="fc" id="L831">                a[dest--] = tmp[cursor2--];</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">                if (--len2 == 1)</span>
<span class="fc" id="L833">                    break outer;</span>

<span class="fc" id="L835">                count2 = len2 - gallopLeft((Comparable) a[cursor1], tmp, tmpBase, len2, len2 - 1);</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">                if (count2 != 0) {</span>
<span class="fc" id="L837">                    dest -= count2;</span>
<span class="fc" id="L838">                    cursor2 -= count2;</span>
<span class="fc" id="L839">                    len2 -= count2;</span>
<span class="fc" id="L840">                    System.arraycopy(tmp, cursor2 + 1, a, dest + 1, count2);</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">                    if (len2 &lt;= 1)</span>
<span class="fc" id="L842">                        break outer; // len2 == 1 || len2 == 0</span>
                }
<span class="fc" id="L844">                a[dest--] = a[cursor1--];</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">                if (--len1 == 0)</span>
<span class="fc" id="L846">                    break outer;</span>
<span class="fc" id="L847">                minGallop--;</span>
<span class="fc bfc" id="L848" title="All 6 branches covered.">            } while (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">            if (minGallop &lt; 0)</span>
<span class="fc" id="L850">                minGallop = 0;</span>
<span class="fc" id="L851">            minGallop += 2;  // Penalize for leaving gallop mode</span>
<span class="fc" id="L852">        }  // End of &quot;outer&quot; loop</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">        this.minGallop = minGallop &lt; 1 ? 1 : minGallop;  // Write back to field</span>

<span class="fc bfc" id="L855" title="All 2 branches covered.">        if (len2 == 1) {</span>
<span class="pc bpc" id="L856" title="1 of 4 branches missed.">            assert len1 &gt; 0;</span>
<span class="fc" id="L857">            dest -= len1;</span>
<span class="fc" id="L858">            cursor1 -= len1;</span>
<span class="fc" id="L859">            System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);</span>
<span class="fc" id="L860">            a[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        } else if (len2 == 0) {</span>
<span class="nc" id="L862">            throw new IllegalArgumentException(</span>
                &quot;Comparison method violates its general contract!&quot;);
        } else {
<span class="pc bpc" id="L865" title="1 of 4 branches missed.">            assert len1 == 0;</span>
<span class="pc bpc" id="L866" title="1 of 4 branches missed.">            assert len2 &gt; 0;</span>
<span class="fc" id="L867">            System.arraycopy(tmp, tmpBase, a, dest - (len2 - 1), len2);</span>
        }
<span class="fc" id="L869">    }</span>

    /**
     * Ensures that the external array tmp has at least the specified
     * number of elements, increasing its size if necessary.  The size
     * increases exponentially to ensure amortized linear time complexity.
     *
     * @param minCapacity the minimum required capacity of the tmp array
     * @return tmp, whether or not it grew
     */
    private Object[]  ensureCapacity(int minCapacity) {
<span class="fc bfc" id="L880" title="All 2 branches covered.">        if (tmpLen &lt; minCapacity) {</span>
            // Compute smallest power of 2 &gt; minCapacity
<span class="fc" id="L882">            int newSize = minCapacity;</span>
<span class="fc" id="L883">            newSize |= newSize &gt;&gt; 1;</span>
<span class="fc" id="L884">            newSize |= newSize &gt;&gt; 2;</span>
<span class="fc" id="L885">            newSize |= newSize &gt;&gt; 4;</span>
<span class="fc" id="L886">            newSize |= newSize &gt;&gt; 8;</span>
<span class="fc" id="L887">            newSize |= newSize &gt;&gt; 16;</span>
<span class="fc" id="L888">            newSize++;</span>

<span class="pc bpc" id="L890" title="1 of 2 branches missed.">            if (newSize &lt; 0) // Not bloody likely!</span>
<span class="nc" id="L891">                newSize = minCapacity;</span>
            else
<span class="fc" id="L893">                newSize = Math.min(newSize, a.length &gt;&gt;&gt; 1);</span>

            @SuppressWarnings({&quot;unchecked&quot;, &quot;UnnecessaryLocalVariable&quot;})
<span class="fc" id="L896">            Object[] newArray = new Object[newSize];</span>
<span class="fc" id="L897">            tmp = newArray;</span>
<span class="fc" id="L898">            tmpLen = newSize;</span>
<span class="fc" id="L899">            tmpBase = 0;</span>
        }
<span class="fc" id="L901">        return tmp;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>