<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>UUID.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">UUID.java</span></div><h1>UUID.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.security.*;

/**
 * A class that represents an immutable universally unique identifier (UUID).
 * A UUID represents a 128-bit value.
 *
 * &lt;p&gt; There exist different variants of these global identifiers.  The methods
 * of this class are for manipulating the Leach-Salz variant, although the
 * constructors allow the creation of any variant of UUID (described below).
 *
 * &lt;p&gt; The layout of a variant 2 (Leach-Salz) UUID is as follows:
 *
 * The most significant long consists of the following unsigned fields:
 * &lt;pre&gt;
 * 0xFFFFFFFF00000000 time_low
 * 0x00000000FFFF0000 time_mid
 * 0x000000000000F000 version
 * 0x0000000000000FFF time_hi
 * &lt;/pre&gt;
 * The least significant long consists of the following unsigned fields:
 * &lt;pre&gt;
 * 0xC000000000000000 variant
 * 0x3FFF000000000000 clock_seq
 * 0x0000FFFFFFFFFFFF node
 * &lt;/pre&gt;
 *
 * &lt;p&gt; The variant field contains a value which identifies the layout of the
 * {@code UUID}.  The bit layout described above is valid only for a {@code
 * UUID} with a variant value of 2, which indicates the Leach-Salz variant.
 *
 * &lt;p&gt; The version field holds a value that describes the type of this {@code
 * UUID}.  There are four different basic types of UUIDs: time-based, DCE
 * security, name-based, and randomly generated UUIDs.  These types have a
 * version value of 1, 2, 3 and 4, respectively.
 *
 * &lt;p&gt; For more information including algorithms used to create {@code UUID}s,
 * see &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt; &lt;i&gt;RFC&amp;nbsp;4122: A
 * Universally Unique IDentifier (UUID) URN Namespace&lt;/i&gt;&lt;/a&gt;, section 4.2
 * &amp;quot;Algorithms for Creating a Time-Based UUID&amp;quot;.
 *
 * @since   1.5
 */
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">public final class UUID implements java.io.Serializable, Comparable&lt;UUID&gt; {</span>

    /**
     * Explicit serialVersionUID for interoperability.
     */
    private static final long serialVersionUID = -4856846361193249489L;

    /*
     * The most significant 64 bits of this UUID.
     *
     * @serial
     */
    private final long mostSigBits;

    /*
     * The least significant 64 bits of this UUID.
     *
     * @serial
     */
    private final long leastSigBits;

    /*
     * The random number generator used by this class to create random
     * based UUIDs. In a holder class to defer initialization until needed.
     */
<span class="nc" id="L95">    private static class Holder {</span>
<span class="fc" id="L96">        static final SecureRandom numberGenerator = new SecureRandom();</span>
    }

    // Constructors and Factories

    /*
     * Private constructor which uses a byte array to construct the new UUID.
     */
<span class="fc" id="L104">    private UUID(byte[] data) {</span>
<span class="fc" id="L105">        long msb = 0;</span>
<span class="fc" id="L106">        long lsb = 0;</span>
<span class="pc bpc" id="L107" title="2 of 4 branches missed.">        assert data.length == 16 : &quot;data must be 16 bytes in length&quot;;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (int i=0; i&lt;8; i++)</span>
<span class="fc" id="L109">            msb = (msb &lt;&lt; 8) | (data[i] &amp; 0xff);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        for (int i=8; i&lt;16; i++)</span>
<span class="fc" id="L111">            lsb = (lsb &lt;&lt; 8) | (data[i] &amp; 0xff);</span>
<span class="fc" id="L112">        this.mostSigBits = msb;</span>
<span class="fc" id="L113">        this.leastSigBits = lsb;</span>
<span class="fc" id="L114">    }</span>

    /**
     * Constructs a new {@code UUID} using the specified data.  {@code
     * mostSigBits} is used for the most significant 64 bits of the {@code
     * UUID} and {@code leastSigBits} becomes the least significant 64 bits of
     * the {@code UUID}.
     *
     * @param  mostSigBits
     *         The most significant bits of the {@code UUID}
     *
     * @param  leastSigBits
     *         The least significant bits of the {@code UUID}
     */
<span class="nc" id="L128">    public UUID(long mostSigBits, long leastSigBits) {</span>
<span class="nc" id="L129">        this.mostSigBits = mostSigBits;</span>
<span class="nc" id="L130">        this.leastSigBits = leastSigBits;</span>
<span class="nc" id="L131">    }</span>

    /**
     * Static factory to retrieve a type 4 (pseudo randomly generated) UUID.
     *
     * The {@code UUID} is generated using a cryptographically strong pseudo
     * random number generator.
     *
     * @return  A randomly generated {@code UUID}
     */
    public static UUID randomUUID() {
<span class="fc" id="L142">        SecureRandom ng = Holder.numberGenerator;</span>

<span class="fc" id="L144">        byte[] randomBytes = new byte[16];</span>
<span class="fc" id="L145">        ng.nextBytes(randomBytes);</span>
<span class="fc" id="L146">        randomBytes[6]  &amp;= 0x0f;  /* clear version        */</span>
<span class="fc" id="L147">        randomBytes[6]  |= 0x40;  /* set to version 4     */</span>
<span class="fc" id="L148">        randomBytes[8]  &amp;= 0x3f;  /* clear variant        */</span>
<span class="fc" id="L149">        randomBytes[8]  |= 0x80;  /* set to IETF variant  */</span>
<span class="fc" id="L150">        return new UUID(randomBytes);</span>
    }

    /**
     * Static factory to retrieve a type 3 (name based) {@code UUID} based on
     * the specified byte array.
     *
     * @param  name
     *         A byte array to be used to construct a {@code UUID}
     *
     * @return  A {@code UUID} generated from the specified array
     */
    public static UUID nameUUIDFromBytes(byte[] name) {
        MessageDigest md;
        try {
<span class="nc" id="L165">            md = MessageDigest.getInstance(&quot;MD5&quot;);</span>
<span class="nc" id="L166">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L167">            throw new InternalError(&quot;MD5 not supported&quot;, nsae);</span>
<span class="nc" id="L168">        }</span>
<span class="nc" id="L169">        byte[] md5Bytes = md.digest(name);</span>
<span class="nc" id="L170">        md5Bytes[6]  &amp;= 0x0f;  /* clear version        */</span>
<span class="nc" id="L171">        md5Bytes[6]  |= 0x30;  /* set to version 3     */</span>
<span class="nc" id="L172">        md5Bytes[8]  &amp;= 0x3f;  /* clear variant        */</span>
<span class="nc" id="L173">        md5Bytes[8]  |= 0x80;  /* set to IETF variant  */</span>
<span class="nc" id="L174">        return new UUID(md5Bytes);</span>
    }

    /**
     * Creates a {@code UUID} from the string standard representation as
     * described in the {@link #toString} method.
     *
     * @param  name
     *         A string that specifies a {@code UUID}
     *
     * @return  A {@code UUID} with the specified value
     *
     * @throws  IllegalArgumentException
     *          If name does not conform to the string representation as
     *          described in {@link #toString}
     *
     */
    public static UUID fromString(String name) {
<span class="nc" id="L192">        String[] components = name.split(&quot;-&quot;);</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (components.length != 5)</span>
<span class="nc" id="L194">            throw new IllegalArgumentException(&quot;Invalid UUID string: &quot;+name);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        for (int i=0; i&lt;5; i++)</span>
<span class="nc" id="L196">            components[i] = &quot;0x&quot;+components[i];</span>

<span class="nc" id="L198">        long mostSigBits = Long.decode(components[0]).longValue();</span>
<span class="nc" id="L199">        mostSigBits &lt;&lt;= 16;</span>
<span class="nc" id="L200">        mostSigBits |= Long.decode(components[1]).longValue();</span>
<span class="nc" id="L201">        mostSigBits &lt;&lt;= 16;</span>
<span class="nc" id="L202">        mostSigBits |= Long.decode(components[2]).longValue();</span>

<span class="nc" id="L204">        long leastSigBits = Long.decode(components[3]).longValue();</span>
<span class="nc" id="L205">        leastSigBits &lt;&lt;= 48;</span>
<span class="nc" id="L206">        leastSigBits |= Long.decode(components[4]).longValue();</span>

<span class="nc" id="L208">        return new UUID(mostSigBits, leastSigBits);</span>
    }

    // Field Accessor Methods

    /**
     * Returns the least significant 64 bits of this UUID's 128 bit value.
     *
     * @return  The least significant 64 bits of this UUID's 128 bit value
     */
    public long getLeastSignificantBits() {
<span class="nc" id="L219">        return leastSigBits;</span>
    }

    /**
     * Returns the most significant 64 bits of this UUID's 128 bit value.
     *
     * @return  The most significant 64 bits of this UUID's 128 bit value
     */
    public long getMostSignificantBits() {
<span class="nc" id="L228">        return mostSigBits;</span>
    }

    /**
     * The version number associated with this {@code UUID}.  The version
     * number describes how this {@code UUID} was generated.
     *
     * The version number has the following meaning:
     * &lt;ul&gt;
     * &lt;li&gt;1    Time-based UUID
     * &lt;li&gt;2    DCE security UUID
     * &lt;li&gt;3    Name-based UUID
     * &lt;li&gt;4    Randomly generated UUID
     * &lt;/ul&gt;
     *
     * @return  The version number of this {@code UUID}
     */
    public int version() {
        // Version is bits masked by 0x000000000000F000 in MS long
<span class="nc" id="L247">        return (int)((mostSigBits &gt;&gt; 12) &amp; 0x0f);</span>
    }

    /**
     * The variant number associated with this {@code UUID}.  The variant
     * number describes the layout of the {@code UUID}.
     *
     * The variant number has the following meaning:
     * &lt;ul&gt;
     * &lt;li&gt;0    Reserved for NCS backward compatibility
     * &lt;li&gt;2    &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;IETF&amp;nbsp;RFC&amp;nbsp;4122&lt;/a&gt;
     * (Leach-Salz), used by this class
     * &lt;li&gt;6    Reserved, Microsoft Corporation backward compatibility
     * &lt;li&gt;7    Reserved for future definition
     * &lt;/ul&gt;
     *
     * @return  The variant number of this {@code UUID}
     */
    public int variant() {
        // This field is composed of a varying number of bits.
        // 0    -    -    Reserved for NCS backward compatibility
        // 1    0    -    The IETF aka Leach-Salz variant (used by this class)
        // 1    1    0    Reserved, Microsoft backward compatibility
        // 1    1    1    Reserved for future definition.
<span class="nc" id="L271">        return (int) ((leastSigBits &gt;&gt;&gt; (64 - (leastSigBits &gt;&gt;&gt; 62)))</span>
                      &amp; (leastSigBits &gt;&gt; 63));
    }

    /**
     * The timestamp value associated with this UUID.
     *
     * &lt;p&gt; The 60 bit timestamp value is constructed from the time_low,
     * time_mid, and time_hi fields of this {@code UUID}.  The resulting
     * timestamp is measured in 100-nanosecond units since midnight,
     * October 15, 1582 UTC.
     *
     * &lt;p&gt; The timestamp value is only meaningful in a time-based UUID, which
     * has version type 1.  If this {@code UUID} is not a time-based UUID then
     * this method throws UnsupportedOperationException.
     *
     * @throws UnsupportedOperationException
     *         If this UUID is not a version 1 UUID
     * @return The timestamp of this {@code UUID}.
     */
    public long timestamp() {
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (version() != 1) {</span>
<span class="nc" id="L293">            throw new UnsupportedOperationException(&quot;Not a time-based UUID&quot;);</span>
        }

<span class="nc" id="L296">        return (mostSigBits &amp; 0x0FFFL) &lt;&lt; 48</span>
             | ((mostSigBits &gt;&gt; 16) &amp; 0x0FFFFL) &lt;&lt; 32
             | mostSigBits &gt;&gt;&gt; 32;
    }

    /**
     * The clock sequence value associated with this UUID.
     *
     * &lt;p&gt; The 14 bit clock sequence value is constructed from the clock
     * sequence field of this UUID.  The clock sequence field is used to
     * guarantee temporal uniqueness in a time-based UUID.
     *
     * &lt;p&gt; The {@code clockSequence} value is only meaningful in a time-based
     * UUID, which has version type 1.  If this UUID is not a time-based UUID
     * then this method throws UnsupportedOperationException.
     *
     * @return  The clock sequence of this {@code UUID}
     *
     * @throws  UnsupportedOperationException
     *          If this UUID is not a version 1 UUID
     */
    public int clockSequence() {
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (version() != 1) {</span>
<span class="nc" id="L319">            throw new UnsupportedOperationException(&quot;Not a time-based UUID&quot;);</span>
        }

<span class="nc" id="L322">        return (int)((leastSigBits &amp; 0x3FFF000000000000L) &gt;&gt;&gt; 48);</span>
    }

    /**
     * The node value associated with this UUID.
     *
     * &lt;p&gt; The 48 bit node value is constructed from the node field of this
     * UUID.  This field is intended to hold the IEEE 802 address of the machine
     * that generated this UUID to guarantee spatial uniqueness.
     *
     * &lt;p&gt; The node value is only meaningful in a time-based UUID, which has
     * version type 1.  If this UUID is not a time-based UUID then this method
     * throws UnsupportedOperationException.
     *
     * @return  The node value of this {@code UUID}
     *
     * @throws  UnsupportedOperationException
     *          If this UUID is not a version 1 UUID
     */
    public long node() {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (version() != 1) {</span>
<span class="nc" id="L343">            throw new UnsupportedOperationException(&quot;Not a time-based UUID&quot;);</span>
        }

<span class="nc" id="L346">        return leastSigBits &amp; 0x0000FFFFFFFFFFFFL;</span>
    }

    // Object Inherited Methods

    /**
     * Returns a {@code String} object representing this {@code UUID}.
     *
     * &lt;p&gt; The UUID string representation is as described by this BNF:
     * &lt;blockquote&gt;&lt;pre&gt;
     * {@code
     * UUID                   = &lt;time_low&gt; &quot;-&quot; &lt;time_mid&gt; &quot;-&quot;
     *                          &lt;time_high_and_version&gt; &quot;-&quot;
     *                          &lt;variant_and_sequence&gt; &quot;-&quot;
     *                          &lt;node&gt;
     * time_low               = 4*&lt;hexOctet&gt;
     * time_mid               = 2*&lt;hexOctet&gt;
     * time_high_and_version  = 2*&lt;hexOctet&gt;
     * variant_and_sequence   = 2*&lt;hexOctet&gt;
     * node                   = 6*&lt;hexOctet&gt;
     * hexOctet               = &lt;hexDigit&gt;&lt;hexDigit&gt;
     * hexDigit               =
     *       &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;
     *       | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
     *       | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;
     * }&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return  A string representation of this {@code UUID}
     */
    public String toString() {
<span class="fc" id="L376">        return (digits(mostSigBits &gt;&gt; 32, 8) + &quot;-&quot; +</span>
<span class="fc" id="L377">                digits(mostSigBits &gt;&gt; 16, 4) + &quot;-&quot; +</span>
<span class="fc" id="L378">                digits(mostSigBits, 4) + &quot;-&quot; +</span>
<span class="fc" id="L379">                digits(leastSigBits &gt;&gt; 48, 4) + &quot;-&quot; +</span>
<span class="fc" id="L380">                digits(leastSigBits, 12));</span>
    }

    /** Returns val represented by the specified number of hex digits. */
    private static String digits(long val, int digits) {
<span class="fc" id="L385">        long hi = 1L &lt;&lt; (digits * 4);</span>
<span class="fc" id="L386">        return Long.toHexString(hi | (val &amp; (hi - 1))).substring(1);</span>
    }

    /**
     * Returns a hash code for this {@code UUID}.
     *
     * @return  A hash code value for this {@code UUID}
     */
    public int hashCode() {
<span class="nc" id="L395">        long hilo = mostSigBits ^ leastSigBits;</span>
<span class="nc" id="L396">        return ((int)(hilo &gt;&gt; 32)) ^ (int) hilo;</span>
    }

    /**
     * Compares this object to the specified object.  The result is {@code
     * true} if and only if the argument is not {@code null}, is a {@code UUID}
     * object, has the same variant, and contains the same value, bit for bit,
     * as this {@code UUID}.
     *
     * @param  obj
     *         The object to be compared
     *
     * @return  {@code true} if the objects are the same; {@code false}
     *          otherwise
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L412" title="All 4 branches missed.">        if ((null == obj) || (obj.getClass() != UUID.class))</span>
<span class="nc" id="L413">            return false;</span>
<span class="nc" id="L414">        UUID id = (UUID)obj;</span>
<span class="nc bnc" id="L415" title="All 4 branches missed.">        return (mostSigBits == id.mostSigBits &amp;&amp;</span>
                leastSigBits == id.leastSigBits);
    }

    // Comparison Operations

    /**
     * Compares this UUID with the specified UUID.
     *
     * &lt;p&gt; The first of two UUIDs is greater than the second if the most
     * significant field in which the UUIDs differ is greater for the first
     * UUID.
     *
     * @param  val
     *         {@code UUID} to which this {@code UUID} is to be compared
     *
     * @return  -1, 0 or 1 as this {@code UUID} is less than, equal to, or
     *          greater than {@code val}
     *
     */
    public int compareTo(UUID val) {
        // The ordering is intentionally set up so that the UUIDs
        // can simply be numerically compared as two numbers
<span class="nc bnc" id="L438" title="All 8 branches missed.">        return (this.mostSigBits &lt; val.mostSigBits ? -1 :</span>
                (this.mostSigBits &gt; val.mostSigBits ? 1 :
                 (this.leastSigBits &lt; val.leastSigBits ? -1 :
                  (this.leastSigBits &gt; val.leastSigBits ? 1 :
                   0))));
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>