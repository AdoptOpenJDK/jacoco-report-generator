<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Spliterators.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">Spliterators.java</span></div><h1>Spliterators.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.util;

import java.util.function.Consumer;
import java.util.function.DoubleConsumer;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;

/**
 * Static classes and methods for operating on or creating instances of
 * {@link Spliterator} and its primitive specializations
 * {@link Spliterator.OfInt}, {@link Spliterator.OfLong}, and
 * {@link Spliterator.OfDouble}.
 *
 * @see Spliterator
 * @since 1.8
 */
public final class Spliterators {

    // Suppresses default constructor, ensuring non-instantiability.
<span class="nc" id="L44">    private Spliterators() {}</span>

    // Empty spliterators

    /**
     * Creates an empty {@code Spliterator}
     *
     * &lt;p&gt;The empty spliterator reports {@link Spliterator#SIZED} and
     * {@link Spliterator#SUBSIZED}.  Calls to
     * {@link java.util.Spliterator#trySplit()} always return {@code null}.
     *
     * @param &lt;T&gt; Type of elements
     * @return An empty spliterator
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Spliterator&lt;T&gt; emptySpliterator() {
<span class="fc" id="L60">        return (Spliterator&lt;T&gt;) EMPTY_SPLITERATOR;</span>
    }

<span class="fc" id="L63">    private static final Spliterator&lt;Object&gt; EMPTY_SPLITERATOR =</span>
            new EmptySpliterator.OfRef&lt;&gt;();

    /**
     * Creates an empty {@code Spliterator.OfInt}
     *
     * &lt;p&gt;The empty spliterator reports {@link Spliterator#SIZED} and
     * {@link Spliterator#SUBSIZED}.  Calls to
     * {@link java.util.Spliterator#trySplit()} always return {@code null}.
     *
     * @return An empty spliterator
     */
    public static Spliterator.OfInt emptyIntSpliterator() {
<span class="fc" id="L76">        return EMPTY_INT_SPLITERATOR;</span>
    }

<span class="fc" id="L79">    private static final Spliterator.OfInt EMPTY_INT_SPLITERATOR =</span>
            new EmptySpliterator.OfInt();

    /**
     * Creates an empty {@code Spliterator.OfLong}
     *
     * &lt;p&gt;The empty spliterator reports {@link Spliterator#SIZED} and
     * {@link Spliterator#SUBSIZED}.  Calls to
     * {@link java.util.Spliterator#trySplit()} always return {@code null}.
     *
     * @return An empty spliterator
     */
    public static Spliterator.OfLong emptyLongSpliterator() {
<span class="fc" id="L92">        return EMPTY_LONG_SPLITERATOR;</span>
    }

<span class="fc" id="L95">    private static final Spliterator.OfLong EMPTY_LONG_SPLITERATOR =</span>
            new EmptySpliterator.OfLong();

    /**
     * Creates an empty {@code Spliterator.OfDouble}
     *
     * &lt;p&gt;The empty spliterator reports {@link Spliterator#SIZED} and
     * {@link Spliterator#SUBSIZED}.  Calls to
     * {@link java.util.Spliterator#trySplit()} always return {@code null}.
     *
     * @return An empty spliterator
     */
    public static Spliterator.OfDouble emptyDoubleSpliterator() {
<span class="fc" id="L108">        return EMPTY_DOUBLE_SPLITERATOR;</span>
    }

<span class="fc" id="L111">    private static final Spliterator.OfDouble EMPTY_DOUBLE_SPLITERATOR =</span>
            new EmptySpliterator.OfDouble();

    // Array-based spliterators

    /**
     * Creates a {@code Spliterator} covering the elements of a given array,
     * using a customized set of spliterator characteristics.
     *
     * &lt;p&gt;This method is provided as an implementation convenience for
     * Spliterators which store portions of their elements in arrays, and need
     * fine control over Spliterator characteristics.  Most other situations in
     * which a Spliterator for an array is needed should use
     * {@link Arrays#spliterator(Object[])}.
     *
     * &lt;p&gt;The returned spliterator always reports the characteristics
     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional
     * characteristics for the spliterator to report; it is common to
     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.
     *
     * @param &lt;T&gt; Type of elements
     * @param array The array, assumed to be unmodified during use
     * @param additionalCharacteristics Additional spliterator characteristics
     *        of this spliterator's source or elements beyond {@code SIZED} and
     *        {@code SUBSIZED} which are are always reported
     * @return A spliterator for an array
     * @throws NullPointerException if the given array is {@code null}
     * @see Arrays#spliterator(Object[])
     */
    public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(Object[] array,
                                                 int additionalCharacteristics) {
<span class="fc" id="L142">        return new ArraySpliterator&lt;&gt;(Objects.requireNonNull(array),</span>
                                      additionalCharacteristics);
    }

    /**
     * Creates a {@code Spliterator} covering a range of elements of a given
     * array, using a customized set of spliterator characteristics.
     *
     * &lt;p&gt;This method is provided as an implementation convenience for
     * Spliterators which store portions of their elements in arrays, and need
     * fine control over Spliterator characteristics.  Most other situations in
     * which a Spliterator for an array is needed should use
     * {@link Arrays#spliterator(Object[])}.
     *
     * &lt;p&gt;The returned spliterator always reports the characteristics
     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional
     * characteristics for the spliterator to report; it is common to
     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.
     *
     * @param &lt;T&gt; Type of elements
     * @param array The array, assumed to be unmodified during use
     * @param fromIndex The least index (inclusive) to cover
     * @param toIndex One past the greatest index to cover
     * @param additionalCharacteristics Additional spliterator characteristics
     *        of this spliterator's source or elements beyond {@code SIZED} and
     *        {@code SUBSIZED} which are are always reported
     * @return A spliterator for an array
     * @throws NullPointerException if the given array is {@code null}
     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex} is negative,
     *         {@code toIndex} is less than {@code fromIndex}, or
     *         {@code toIndex} is greater than the array size
     * @see Arrays#spliterator(Object[], int, int)
     */
    public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(Object[] array, int fromIndex, int toIndex,
                                                 int additionalCharacteristics) {
<span class="fc" id="L177">        checkFromToBounds(Objects.requireNonNull(array).length, fromIndex, toIndex);</span>
<span class="fc" id="L178">        return new ArraySpliterator&lt;&gt;(array, fromIndex, toIndex, additionalCharacteristics);</span>
    }

    /**
     * Creates a {@code Spliterator.OfInt} covering the elements of a given array,
     * using a customized set of spliterator characteristics.
     *
     * &lt;p&gt;This method is provided as an implementation convenience for
     * Spliterators which store portions of their elements in arrays, and need
     * fine control over Spliterator characteristics.  Most other situations in
     * which a Spliterator for an array is needed should use
     * {@link Arrays#spliterator(int[])}.
     *
     * &lt;p&gt;The returned spliterator always reports the characteristics
     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional
     * characteristics for the spliterator to report; it is common to
     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.
     *
     * @param array The array, assumed to be unmodified during use
     * @param additionalCharacteristics Additional spliterator characteristics
     *        of this spliterator's source or elements beyond {@code SIZED} and
     *        {@code SUBSIZED} which are are always reported
     * @return A spliterator for an array
     * @throws NullPointerException if the given array is {@code null}
     * @see Arrays#spliterator(int[])
     */
    public static Spliterator.OfInt spliterator(int[] array,
                                                int additionalCharacteristics) {
<span class="fc" id="L206">        return new IntArraySpliterator(Objects.requireNonNull(array), additionalCharacteristics);</span>
    }

    /**
     * Creates a {@code Spliterator.OfInt} covering a range of elements of a
     * given array, using a customized set of spliterator characteristics.
     *
     * &lt;p&gt;This method is provided as an implementation convenience for
     * Spliterators which store portions of their elements in arrays, and need
     * fine control over Spliterator characteristics.  Most other situations in
     * which a Spliterator for an array is needed should use
     * {@link Arrays#spliterator(int[], int, int)}.
     *
     * &lt;p&gt;The returned spliterator always reports the characteristics
     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional
     * characteristics for the spliterator to report; it is common to
     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.
     *
     * @param array The array, assumed to be unmodified during use
     * @param fromIndex The least index (inclusive) to cover
     * @param toIndex One past the greatest index to cover
     * @param additionalCharacteristics Additional spliterator characteristics
     *        of this spliterator's source or elements beyond {@code SIZED} and
     *        {@code SUBSIZED} which are are always reported
     * @return A spliterator for an array
     * @throws NullPointerException if the given array is {@code null}
     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex} is negative,
     *         {@code toIndex} is less than {@code fromIndex}, or
     *         {@code toIndex} is greater than the array size
     * @see Arrays#spliterator(int[], int, int)
     */
    public static Spliterator.OfInt spliterator(int[] array, int fromIndex, int toIndex,
                                                int additionalCharacteristics) {
<span class="fc" id="L239">        checkFromToBounds(Objects.requireNonNull(array).length, fromIndex, toIndex);</span>
<span class="fc" id="L240">        return new IntArraySpliterator(array, fromIndex, toIndex, additionalCharacteristics);</span>
    }

    /**
     * Creates a {@code Spliterator.OfLong} covering the elements of a given array,
     * using a customized set of spliterator characteristics.
     *
     * &lt;p&gt;This method is provided as an implementation convenience for
     * Spliterators which store portions of their elements in arrays, and need
     * fine control over Spliterator characteristics.  Most other situations in
     * which a Spliterator for an array is needed should use
     * {@link Arrays#spliterator(long[])}.
     *
     * &lt;p&gt;The returned spliterator always reports the characteristics
     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional
     * characteristics for the spliterator to report; it is common to
     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.
     *
     * @param array The array, assumed to be unmodified during use
     * @param additionalCharacteristics Additional spliterator characteristics
     *        of this spliterator's source or elements beyond {@code SIZED} and
     *        {@code SUBSIZED} which are are always reported
     * @return A spliterator for an array
     * @throws NullPointerException if the given array is {@code null}
     * @see Arrays#spliterator(long[])
     */
    public static Spliterator.OfLong spliterator(long[] array,
                                                 int additionalCharacteristics) {
<span class="fc" id="L268">        return new LongArraySpliterator(Objects.requireNonNull(array), additionalCharacteristics);</span>
    }

    /**
     * Creates a {@code Spliterator.OfLong} covering a range of elements of a
     * given array, using a customized set of spliterator characteristics.
     *
     * &lt;p&gt;This method is provided as an implementation convenience for
     * Spliterators which store portions of their elements in arrays, and need
     * fine control over Spliterator characteristics.  Most other situations in
     * which a Spliterator for an array is needed should use
     * {@link Arrays#spliterator(long[], int, int)}.
     *
     * &lt;p&gt;The returned spliterator always reports the characteristics
     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional
     * characteristics for the spliterator to report.  (For example, if it is
     * known the array will not be further modified, specify {@code IMMUTABLE};
     * if the array data is considered to have an an encounter order, specify
     * {@code ORDERED}).  The method {@link Arrays#spliterator(long[], int, int)} can
     * often be used instead, which returns a spliterator that reports
     * {@code SIZED}, {@code SUBSIZED}, {@code IMMUTABLE}, and {@code ORDERED}.
     *
     * @param array The array, assumed to be unmodified during use
     * @param fromIndex The least index (inclusive) to cover
     * @param toIndex One past the greatest index to cover
     * @param additionalCharacteristics Additional spliterator characteristics
     *        of this spliterator's source or elements beyond {@code SIZED} and
     *        {@code SUBSIZED} which are are always reported
     * @return A spliterator for an array
     * @throws NullPointerException if the given array is {@code null}
     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex} is negative,
     *         {@code toIndex} is less than {@code fromIndex}, or
     *         {@code toIndex} is greater than the array size
     * @see Arrays#spliterator(long[], int, int)
     */
    public static Spliterator.OfLong spliterator(long[] array, int fromIndex, int toIndex,
                                                 int additionalCharacteristics) {
<span class="fc" id="L305">        checkFromToBounds(Objects.requireNonNull(array).length, fromIndex, toIndex);</span>
<span class="fc" id="L306">        return new LongArraySpliterator(array, fromIndex, toIndex, additionalCharacteristics);</span>
    }

    /**
     * Creates a {@code Spliterator.OfDouble} covering the elements of a given array,
     * using a customized set of spliterator characteristics.
     *
     * &lt;p&gt;This method is provided as an implementation convenience for
     * Spliterators which store portions of their elements in arrays, and need
     * fine control over Spliterator characteristics.  Most other situations in
     * which a Spliterator for an array is needed should use
     * {@link Arrays#spliterator(double[])}.
     *
     * &lt;p&gt;The returned spliterator always reports the characteristics
     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional
     * characteristics for the spliterator to report; it is common to
     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.
     *
     * @param array The array, assumed to be unmodified during use
     * @param additionalCharacteristics Additional spliterator characteristics
     *        of this spliterator's source or elements beyond {@code SIZED} and
     *        {@code SUBSIZED} which are are always reported
     * @return A spliterator for an array
     * @throws NullPointerException if the given array is {@code null}
     * @see Arrays#spliterator(double[])
     */
    public static Spliterator.OfDouble spliterator(double[] array,
                                                   int additionalCharacteristics) {
<span class="fc" id="L334">        return new DoubleArraySpliterator(Objects.requireNonNull(array), additionalCharacteristics);</span>
    }

    /**
     * Creates a {@code Spliterator.OfDouble} covering a range of elements of a
     * given array, using a customized set of spliterator characteristics.
     *
     * &lt;p&gt;This method is provided as an implementation convenience for
     * Spliterators which store portions of their elements in arrays, and need
     * fine control over Spliterator characteristics.  Most other situations in
     * which a Spliterator for an array is needed should use
     * {@link Arrays#spliterator(double[], int, int)}.
     *
     * &lt;p&gt;The returned spliterator always reports the characteristics
     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional
     * characteristics for the spliterator to report.  (For example, if it is
     * known the array will not be further modified, specify {@code IMMUTABLE};
     * if the array data is considered to have an an encounter order, specify
     * {@code ORDERED}).  The method {@link Arrays#spliterator(long[], int, int)} can
     * often be used instead, which returns a spliterator that reports
     * {@code SIZED}, {@code SUBSIZED}, {@code IMMUTABLE}, and {@code ORDERED}.
     *
     * @param array The array, assumed to be unmodified during use
     * @param fromIndex The least index (inclusive) to cover
     * @param toIndex One past the greatest index to cover
     * @param additionalCharacteristics Additional spliterator characteristics
     *        of this spliterator's source or elements beyond {@code SIZED} and
     *        {@code SUBSIZED} which are are always reported
     * @return A spliterator for an array
     * @throws NullPointerException if the given array is {@code null}
     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex} is negative,
     *         {@code toIndex} is less than {@code fromIndex}, or
     *         {@code toIndex} is greater than the array size
     * @see Arrays#spliterator(double[], int, int)
     */
    public static Spliterator.OfDouble spliterator(double[] array, int fromIndex, int toIndex,
                                                   int additionalCharacteristics) {
<span class="fc" id="L371">        checkFromToBounds(Objects.requireNonNull(array).length, fromIndex, toIndex);</span>
<span class="fc" id="L372">        return new DoubleArraySpliterator(array, fromIndex, toIndex, additionalCharacteristics);</span>
    }

    /**
     * Validate inclusive start index and exclusive end index against the length
     * of an array.
     * @param arrayLength The length of the array
     * @param origin The inclusive start index
     * @param fence The exclusive end index
     * @throws ArrayIndexOutOfBoundsException if the start index is greater than
     * the end index, if the start index is negative, or the end index is
     * greater than the array length
     */
    private static void checkFromToBounds(int arrayLength, int origin, int fence) {
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        if (origin &gt; fence) {</span>
<span class="nc" id="L387">            throw new IllegalArgumentException(</span>
                    &quot;origin(&quot; + origin + &quot;) &gt; fence(&quot; + fence + &quot;)&quot;);
        }
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (origin &lt; 0) {</span>
<span class="nc" id="L391">            throw new ArrayIndexOutOfBoundsException(origin);</span>
        }
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        if (fence &gt; arrayLength) {</span>
<span class="nc" id="L394">            throw new ArrayIndexOutOfBoundsException(fence);</span>
        }
<span class="fc" id="L396">    }</span>

    // Iterator-based spliterators

    /**
     * Creates a {@code Spliterator} using the given collection's
     * {@link java.util.Collection#iterator()} as the source of elements, and
     * reporting its {@link java.util.Collection#size()} as its initial size.
     *
     * &lt;p&gt;The spliterator is
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits
     * the &lt;em&gt;fail-fast&lt;/em&gt; properties of the collection's iterator, and
     * implements {@code trySplit} to permit limited parallelism.
     *
     * @param &lt;T&gt; Type of elements
     * @param c The collection
     * @param characteristics Characteristics of this spliterator's source or
     *        elements.  The characteristics {@code SIZED} and {@code SUBSIZED}
     *        are additionally reported unless {@code CONCURRENT} is supplied.
     * @return A spliterator from an iterator
     * @throws NullPointerException if the given collection is {@code null}
     */
    public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(Collection&lt;? extends T&gt; c,
                                                 int characteristics) {
<span class="fc" id="L420">        return new IteratorSpliterator&lt;&gt;(Objects.requireNonNull(c),</span>
                                         characteristics);
    }

    /**
     * Creates a {@code Spliterator} using a given {@code Iterator}
     * as the source of elements, and with a given initially reported size.
     *
     * &lt;p&gt;The spliterator is not
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits
     * the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements
     * {@code trySplit} to permit limited parallelism.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the spliterator.
     * The behaviour of splitting and traversal is undefined if the iterator is
     * operated on after the spliterator is returned, or the initially reported
     * size is not equal to the actual number of elements in the source.
     *
     * @param &lt;T&gt; Type of elements
     * @param iterator The iterator for the source
     * @param size The number of elements in the source, to be reported as
     *        initial {@code estimateSize}
     * @param characteristics Characteristics of this spliterator's source or
     *        elements.  The characteristics {@code SIZED} and {@code SUBSIZED}
     *        are additionally reported unless {@code CONCURRENT} is supplied.
     * @return A spliterator from an iterator
     * @throws NullPointerException if the given iterator is {@code null}
     */
    public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(Iterator&lt;? extends T&gt; iterator,
                                                 long size,
                                                 int characteristics) {
<span class="fc" id="L451">        return new IteratorSpliterator&lt;&gt;(Objects.requireNonNull(iterator), size,</span>
                                         characteristics);
    }

    /**
     * Creates a {@code Spliterator} using a given {@code Iterator}
     * as the source of elements, with no initial size estimate.
     *
     * &lt;p&gt;The spliterator is not
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits
     * the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements
     * {@code trySplit} to permit limited parallelism.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the spliterator.
     * The behaviour of splitting and traversal is undefined if the iterator is
     * operated on after the spliterator is returned.
     *
     * @param &lt;T&gt; Type of elements
     * @param iterator The iterator for the source
     * @param characteristics Characteristics of this spliterator's source
     *        or elements ({@code SIZED} and {@code SUBSIZED}, if supplied, are
     *        ignored and are not reported.)
     * @return A spliterator from an iterator
     * @throws NullPointerException if the given iterator is {@code null}
     */
    public static &lt;T&gt; Spliterator&lt;T&gt; spliteratorUnknownSize(Iterator&lt;? extends T&gt; iterator,
                                                            int characteristics) {
<span class="fc" id="L478">        return new IteratorSpliterator&lt;&gt;(Objects.requireNonNull(iterator), characteristics);</span>
    }

    /**
     * Creates a {@code Spliterator.OfInt} using a given
     * {@code IntStream.IntIterator} as the source of elements, and with a given
     * initially reported size.
     *
     * &lt;p&gt;The spliterator is not
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits
     * the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements
     * {@code trySplit} to permit limited parallelism.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the spliterator.
     * The behaviour of splitting and traversal is undefined if the iterator is
     * operated on after the spliterator is returned, or the initially reported
     * size is not equal to the actual number of elements in the source.
     *
     * @param iterator The iterator for the source
     * @param size The number of elements in the source, to be reported as
     *        initial {@code estimateSize}.
     * @param characteristics Characteristics of this spliterator's source or
     *        elements.  The characteristics {@code SIZED} and {@code SUBSIZED}
     *        are additionally reported unless {@code CONCURRENT} is supplied.
     * @return A spliterator from an iterator
     * @throws NullPointerException if the given iterator is {@code null}
     */
    public static Spliterator.OfInt spliterator(PrimitiveIterator.OfInt iterator,
                                                long size,
                                                int characteristics) {
<span class="fc" id="L508">        return new IntIteratorSpliterator(Objects.requireNonNull(iterator),</span>
                                          size, characteristics);
    }

    /**
     * Creates a {@code Spliterator.OfInt} using a given
     * {@code IntStream.IntIterator} as the source of elements, with no initial
     * size estimate.
     *
     * &lt;p&gt;The spliterator is not
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits
     * the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements
     * {@code trySplit} to permit limited parallelism.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the spliterator.
     * The behaviour of splitting and traversal is undefined if the iterator is
     * operated on after the spliterator is returned.
     *
     * @param iterator The iterator for the source
     * @param characteristics Characteristics of this spliterator's source
     *        or elements ({@code SIZED} and {@code SUBSIZED}, if supplied, are
     *        ignored and are not reported.)
     * @return A spliterator from an iterator
     * @throws NullPointerException if the given iterator is {@code null}
     */
    public static Spliterator.OfInt spliteratorUnknownSize(PrimitiveIterator.OfInt iterator,
                                                           int characteristics) {
<span class="fc" id="L535">        return new IntIteratorSpliterator(Objects.requireNonNull(iterator), characteristics);</span>
    }

    /**
     * Creates a {@code Spliterator.OfLong} using a given
     * {@code LongStream.LongIterator} as the source of elements, and with a
     * given initially reported size.
     *
     * &lt;p&gt;The spliterator is not
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits
     * the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements
     * {@code trySplit} to permit limited parallelism.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the spliterator.
     * The behaviour of splitting and traversal is undefined if the iterator is
     * operated on after the spliterator is returned, or the initially reported
     * size is not equal to the actual number of elements in the source.
     *
     * @param iterator The iterator for the source
     * @param size The number of elements in the source, to be reported as
     *        initial {@code estimateSize}.
     * @param characteristics Characteristics of this spliterator's source or
     *        elements.  The characteristics {@code SIZED} and {@code SUBSIZED}
     *        are additionally reported unless {@code CONCURRENT} is supplied.
     * @return A spliterator from an iterator
     * @throws NullPointerException if the given iterator is {@code null}
     */
    public static Spliterator.OfLong spliterator(PrimitiveIterator.OfLong iterator,
                                                 long size,
                                                 int characteristics) {
<span class="fc" id="L565">        return new LongIteratorSpliterator(Objects.requireNonNull(iterator),</span>
                                           size, characteristics);
    }

    /**
     * Creates a {@code Spliterator.OfLong} using a given
     * {@code LongStream.LongIterator} as the source of elements, with no
     * initial size estimate.
     *
     * &lt;p&gt;The spliterator is not
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits
     * the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements
     * {@code trySplit} to permit limited parallelism.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the spliterator.
     * The behaviour of splitting and traversal is undefined if the iterator is
     * operated on after the spliterator is returned.
     *
     * @param iterator The iterator for the source
     * @param characteristics Characteristics of this spliterator's source
     *        or elements ({@code SIZED} and {@code SUBSIZED}, if supplied, are
     *        ignored and are not reported.)
     * @return A spliterator from an iterator
     * @throws NullPointerException if the given iterator is {@code null}
     */
    public static Spliterator.OfLong spliteratorUnknownSize(PrimitiveIterator.OfLong iterator,
                                                            int characteristics) {
<span class="fc" id="L592">        return new LongIteratorSpliterator(Objects.requireNonNull(iterator), characteristics);</span>
    }

    /**
     * Creates a {@code Spliterator.OfDouble} using a given
     * {@code DoubleStream.DoubleIterator} as the source of elements, and with a
     * given initially reported size.
     *
     * &lt;p&gt;The spliterator is not
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits
     * the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements
     * {@code trySplit} to permit limited parallelism.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the spliterator.
     * The behaviour of splitting and traversal is undefined if the iterator is
     * operated on after the spliterator is returned, or the initially reported
     * size is not equal to the actual number of elements in the source.
     *
     * @param iterator The iterator for the source
     * @param size The number of elements in the source, to be reported as
     *        initial {@code estimateSize}
     * @param characteristics Characteristics of this spliterator's source or
     *        elements.  The characteristics {@code SIZED} and {@code SUBSIZED}
     *        are additionally reported unless {@code CONCURRENT} is supplied.
     * @return A spliterator from an iterator
     * @throws NullPointerException if the given iterator is {@code null}
     */
    public static Spliterator.OfDouble spliterator(PrimitiveIterator.OfDouble iterator,
                                                   long size,
                                                   int characteristics) {
<span class="fc" id="L622">        return new DoubleIteratorSpliterator(Objects.requireNonNull(iterator),</span>
                                             size, characteristics);
    }

    /**
     * Creates a {@code Spliterator.OfDouble} using a given
     * {@code DoubleStream.DoubleIterator} as the source of elements, with no
     * initial size estimate.
     *
     * &lt;p&gt;The spliterator is not
     * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits
     * the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements
     * {@code trySplit} to permit limited parallelism.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the spliterator.
     * The behaviour of splitting and traversal is undefined if the iterator is
     * operated on after the spliterator is returned.
     *
     * @param iterator The iterator for the source
     * @param characteristics Characteristics of this spliterator's source
     *        or elements ({@code SIZED} and {@code SUBSIZED}, if supplied, are
     *        ignored and are not reported.)
     * @return A spliterator from an iterator
     * @throws NullPointerException if the given iterator is {@code null}
     */
    public static Spliterator.OfDouble spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator,
                                                              int characteristics) {
<span class="fc" id="L649">        return new DoubleIteratorSpliterator(Objects.requireNonNull(iterator), characteristics);</span>
    }

    // Iterators from Spliterators

    /**
     * Creates an {@code Iterator} from a {@code Spliterator}.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the iterator.
     * The behaviour of traversal is undefined if the spliterator is operated
     * after the iterator is returned.
     *
     * @param &lt;T&gt; Type of elements
     * @param spliterator The spliterator
     * @return An iterator
     * @throws NullPointerException if the given spliterator is {@code null}
     */
    public static&lt;T&gt; Iterator&lt;T&gt; iterator(Spliterator&lt;? extends T&gt; spliterator) {
<span class="fc" id="L667">        Objects.requireNonNull(spliterator);</span>
<span class="fc" id="L668">        class Adapter implements Iterator&lt;T&gt;, Consumer&lt;T&gt; {</span>
<span class="fc" id="L669">            boolean valueReady = false;</span>
            T nextElement;

            @Override
            public void accept(T t) {
<span class="fc" id="L674">                valueReady = true;</span>
<span class="fc" id="L675">                nextElement = t;</span>
<span class="fc" id="L676">            }</span>

            @Override
            public boolean hasNext() {
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">                if (!valueReady)</span>
<span class="fc" id="L681">                    spliterator.tryAdvance(this);</span>
<span class="fc" id="L682">                return valueReady;</span>
            }

            @Override
            public T next() {
<span class="pc bpc" id="L687" title="1 of 4 branches missed.">                if (!valueReady &amp;&amp; !hasNext())</span>
<span class="nc" id="L688">                    throw new NoSuchElementException();</span>
                else {
<span class="fc" id="L690">                    valueReady = false;</span>
<span class="fc" id="L691">                    return nextElement;</span>
                }
            }
        }

<span class="fc" id="L696">        return new Adapter();</span>
    }

    /**
     * Creates an {@code PrimitiveIterator.OfInt} from a
     * {@code Spliterator.OfInt}.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the iterator.
     * The behaviour of traversal is undefined if the spliterator is operated
     * after the iterator is returned.
     *
     * @param spliterator The spliterator
     * @return An iterator
     * @throws NullPointerException if the given spliterator is {@code null}
     */
    public static PrimitiveIterator.OfInt iterator(Spliterator.OfInt spliterator) {
<span class="fc" id="L712">        Objects.requireNonNull(spliterator);</span>
<span class="fc" id="L713">        class Adapter implements PrimitiveIterator.OfInt, IntConsumer {</span>
<span class="fc" id="L714">            boolean valueReady = false;</span>
            int nextElement;

            @Override
            public void accept(int t) {
<span class="fc" id="L719">                valueReady = true;</span>
<span class="fc" id="L720">                nextElement = t;</span>
<span class="fc" id="L721">            }</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L725" title="All 2 branches covered.">                if (!valueReady)</span>
<span class="fc" id="L726">                    spliterator.tryAdvance(this);</span>
<span class="fc" id="L727">                return valueReady;</span>
            }

            @Override
            public int nextInt() {
<span class="pc bpc" id="L732" title="1 of 4 branches missed.">                if (!valueReady &amp;&amp; !hasNext())</span>
<span class="nc" id="L733">                    throw new NoSuchElementException();</span>
                else {
<span class="fc" id="L735">                    valueReady = false;</span>
<span class="fc" id="L736">                    return nextElement;</span>
                }
            }
        }

<span class="fc" id="L741">        return new Adapter();</span>
    }

    /**
     * Creates an {@code PrimitiveIterator.OfLong} from a
     * {@code Spliterator.OfLong}.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the iterator.
     * The behaviour of traversal is undefined if the spliterator is operated
     * after the iterator is returned.
     *
     * @param spliterator The spliterator
     * @return An iterator
     * @throws NullPointerException if the given spliterator is {@code null}
     */
    public static PrimitiveIterator.OfLong iterator(Spliterator.OfLong spliterator) {
<span class="fc" id="L757">        Objects.requireNonNull(spliterator);</span>
<span class="fc" id="L758">        class Adapter implements PrimitiveIterator.OfLong, LongConsumer {</span>
<span class="fc" id="L759">            boolean valueReady = false;</span>
            long nextElement;

            @Override
            public void accept(long t) {
<span class="fc" id="L764">                valueReady = true;</span>
<span class="fc" id="L765">                nextElement = t;</span>
<span class="fc" id="L766">            }</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L770" title="All 2 branches covered.">                if (!valueReady)</span>
<span class="fc" id="L771">                    spliterator.tryAdvance(this);</span>
<span class="fc" id="L772">                return valueReady;</span>
            }

            @Override
            public long nextLong() {
<span class="pc bpc" id="L777" title="1 of 4 branches missed.">                if (!valueReady &amp;&amp; !hasNext())</span>
<span class="nc" id="L778">                    throw new NoSuchElementException();</span>
                else {
<span class="fc" id="L780">                    valueReady = false;</span>
<span class="fc" id="L781">                    return nextElement;</span>
                }
            }
        }

<span class="fc" id="L786">        return new Adapter();</span>
    }

    /**
     * Creates an {@code PrimitiveIterator.OfDouble} from a
     * {@code Spliterator.OfDouble}.
     *
     * &lt;p&gt;Traversal of elements should be accomplished through the iterator.
     * The behaviour of traversal is undefined if the spliterator is operated
     * after the iterator is returned.
     *
     * @param spliterator The spliterator
     * @return An iterator
     * @throws NullPointerException if the given spliterator is {@code null}
     */
    public static PrimitiveIterator.OfDouble iterator(Spliterator.OfDouble spliterator) {
<span class="fc" id="L802">        Objects.requireNonNull(spliterator);</span>
<span class="fc" id="L803">        class Adapter implements PrimitiveIterator.OfDouble, DoubleConsumer {</span>
<span class="fc" id="L804">            boolean valueReady = false;</span>
            double nextElement;

            @Override
            public void accept(double t) {
<span class="fc" id="L809">                valueReady = true;</span>
<span class="fc" id="L810">                nextElement = t;</span>
<span class="fc" id="L811">            }</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L815" title="All 2 branches covered.">                if (!valueReady)</span>
<span class="fc" id="L816">                    spliterator.tryAdvance(this);</span>
<span class="fc" id="L817">                return valueReady;</span>
            }

            @Override
            public double nextDouble() {
<span class="pc bpc" id="L822" title="1 of 4 branches missed.">                if (!valueReady &amp;&amp; !hasNext())</span>
<span class="nc" id="L823">                    throw new NoSuchElementException();</span>
                else {
<span class="fc" id="L825">                    valueReady = false;</span>
<span class="fc" id="L826">                    return nextElement;</span>
                }
            }
        }

<span class="fc" id="L831">        return new Adapter();</span>
    }

    // Implementations

    private static abstract class EmptySpliterator&lt;T, S extends Spliterator&lt;T&gt;, C&gt; {

<span class="fc" id="L838">        EmptySpliterator() { }</span>

        public S trySplit() {
<span class="nc" id="L841">            return null;</span>
        }

        public boolean tryAdvance(C consumer) {
<span class="nc" id="L845">            Objects.requireNonNull(consumer);</span>
<span class="nc" id="L846">            return false;</span>
        }

        public void forEachRemaining(C consumer) {
<span class="nc" id="L850">            Objects.requireNonNull(consumer);</span>
<span class="nc" id="L851">        }</span>

        public long estimateSize() {
<span class="nc" id="L854">            return 0;</span>
        }

        public int characteristics() {
<span class="fc" id="L858">            return Spliterator.SIZED | Spliterator.SUBSIZED;</span>
        }

        private static final class OfRef&lt;T&gt;
                extends EmptySpliterator&lt;T, Spliterator&lt;T&gt;, Consumer&lt;? super T&gt;&gt;
                implements Spliterator&lt;T&gt; {
<span class="fc" id="L864">            OfRef() { }</span>
        }

        private static final class OfInt
                extends EmptySpliterator&lt;Integer, Spliterator.OfInt, IntConsumer&gt;
                implements Spliterator.OfInt {
<span class="fc" id="L870">            OfInt() { }</span>
        }

        private static final class OfLong
                extends EmptySpliterator&lt;Long, Spliterator.OfLong, LongConsumer&gt;
                implements Spliterator.OfLong {
<span class="fc" id="L876">            OfLong() { }</span>
        }

        private static final class OfDouble
                extends EmptySpliterator&lt;Double, Spliterator.OfDouble, DoubleConsumer&gt;
                implements Spliterator.OfDouble {
<span class="fc" id="L882">            OfDouble() { }</span>
        }
    }

    // Array-based spliterators

    /**
     * A Spliterator designed for use by sources that traverse and split
     * elements maintained in an unmodifiable {@code Object[]} array.
     */
    static final class ArraySpliterator&lt;T&gt; implements Spliterator&lt;T&gt; {
        /**
         * The array, explicitly typed as Object[]. Unlike in some other
         * classes (see for example CR 6260652), we do not need to
         * screen arguments to ensure they are exactly of type Object[]
         * so long as no methods write into the array or serialize it,
         * which we ensure here by defining this class as final.
         */
        private final Object[] array;
        private int index;        // current index, modified on advance/split
        private final int fence;  // one past last index
        private final int characteristics;

        /**
         * Creates a spliterator covering all of the given array.
         * @param array the array, assumed to be unmodified during use
         * @param additionalCharacteristics Additional spliterator characteristics
         * of this spliterator's source or elements beyond {@code SIZED} and
         * {@code SUBSIZED} which are are always reported
         */
        public ArraySpliterator(Object[] array, int additionalCharacteristics) {
<span class="fc" id="L913">            this(array, 0, array.length, additionalCharacteristics);</span>
<span class="fc" id="L914">        }</span>

        /**
         * Creates a spliterator covering the given array and range
         * @param array the array, assumed to be unmodified during use
         * @param origin the least index (inclusive) to cover
         * @param fence one past the greatest index to cover
         * @param additionalCharacteristics Additional spliterator characteristics
         * of this spliterator's source or elements beyond {@code SIZED} and
         * {@code SUBSIZED} which are are always reported
         */
<span class="fc" id="L925">        public ArraySpliterator(Object[] array, int origin, int fence, int additionalCharacteristics) {</span>
<span class="fc" id="L926">            this.array = array;</span>
<span class="fc" id="L927">            this.index = origin;</span>
<span class="fc" id="L928">            this.fence = fence;</span>
<span class="fc" id="L929">            this.characteristics = additionalCharacteristics | Spliterator.SIZED | Spliterator.SUBSIZED;</span>
<span class="fc" id="L930">        }</span>

        @Override
        public Spliterator&lt;T&gt; trySplit() {
<span class="fc" id="L934">            int lo = index, mid = (lo + fence) &gt;&gt;&gt; 1;</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">            return (lo &gt;= mid)</span>
                   ? null
                   : new ArraySpliterator&lt;&gt;(array, lo, index = mid, characteristics);
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void forEachRemaining(Consumer&lt;? super T&gt; action) {
            Object[] a; int i, hi; // hoist accesses and checks from loop
<span class="fc bfc" id="L944" title="All 2 branches covered.">            if (action == null)</span>
<span class="fc" id="L945">                throw new NullPointerException();</span>
<span class="pc bpc" id="L946" title="2 of 6 branches missed.">            if ((a = array).length &gt;= (hi = fence) &amp;&amp;</span>
                (i = index) &gt;= 0 &amp;&amp; i &lt; (index = hi)) {
<span class="fc bfc" id="L948" title="All 2 branches covered.">                do { action.accept((T)a[i]); } while (++i &lt; hi);</span>
            }
<span class="fc" id="L950">        }</span>

        @Override
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L954" title="All 2 branches covered.">            if (action == null)</span>
<span class="fc" id="L955">                throw new NullPointerException();</span>
<span class="pc bpc" id="L956" title="1 of 4 branches missed.">            if (index &gt;= 0 &amp;&amp; index &lt; fence) {</span>
<span class="fc" id="L957">                @SuppressWarnings(&quot;unchecked&quot;) T e = (T) array[index++];</span>
<span class="fc" id="L958">                action.accept(e);</span>
<span class="fc" id="L959">                return true;</span>
            }
<span class="fc" id="L961">            return false;</span>
        }

        @Override
<span class="fc" id="L965">        public long estimateSize() { return (long)(fence - index); }</span>

        @Override
        public int characteristics() {
<span class="fc" id="L969">            return characteristics;</span>
        }

        @Override
        public Comparator&lt;? super T&gt; getComparator() {
<span class="nc bnc" id="L974" title="All 2 branches missed.">            if (hasCharacteristics(Spliterator.SORTED))</span>
<span class="nc" id="L975">                return null;</span>
<span class="nc" id="L976">            throw new IllegalStateException();</span>
        }
    }

    /**
     * A Spliterator.OfInt designed for use by sources that traverse and split
     * elements maintained in an unmodifiable {@code int[]} array.
     */
    static final class IntArraySpliterator implements Spliterator.OfInt {
        private final int[] array;
        private int index;        // current index, modified on advance/split
        private final int fence;  // one past last index
        private final int characteristics;

        /**
         * Creates a spliterator covering all of the given array.
         * @param array the array, assumed to be unmodified during use
         * @param additionalCharacteristics Additional spliterator characteristics
         *        of this spliterator's source or elements beyond {@code SIZED} and
         *        {@code SUBSIZED} which are are always reported
         */
        public IntArraySpliterator(int[] array, int additionalCharacteristics) {
<span class="fc" id="L998">            this(array, 0, array.length, additionalCharacteristics);</span>
<span class="fc" id="L999">        }</span>

        /**
         * Creates a spliterator covering the given array and range
         * @param array the array, assumed to be unmodified during use
         * @param origin the least index (inclusive) to cover
         * @param fence one past the greatest index to cover
         * @param additionalCharacteristics Additional spliterator characteristics
         *        of this spliterator's source or elements beyond {@code SIZED} and
         *        {@code SUBSIZED} which are are always reported
         */
<span class="fc" id="L1010">        public IntArraySpliterator(int[] array, int origin, int fence, int additionalCharacteristics) {</span>
<span class="fc" id="L1011">            this.array = array;</span>
<span class="fc" id="L1012">            this.index = origin;</span>
<span class="fc" id="L1013">            this.fence = fence;</span>
<span class="fc" id="L1014">            this.characteristics = additionalCharacteristics | Spliterator.SIZED | Spliterator.SUBSIZED;</span>
<span class="fc" id="L1015">        }</span>

        @Override
        public OfInt trySplit() {
<span class="fc" id="L1019">            int lo = index, mid = (lo + fence) &gt;&gt;&gt; 1;</span>
<span class="pc bpc" id="L1020" title="1 of 2 branches missed.">            return (lo &gt;= mid)</span>
                   ? null
                   : new IntArraySpliterator(array, lo, index = mid, characteristics);
        }

        @Override
        public void forEachRemaining(IntConsumer action) {
            int[] a; int i, hi; // hoist accesses and checks from loop
<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1029">                throw new NullPointerException();</span>
<span class="pc bpc" id="L1030" title="2 of 6 branches missed.">            if ((a = array).length &gt;= (hi = fence) &amp;&amp;</span>
                (i = index) &gt;= 0 &amp;&amp; i &lt; (index = hi)) {
<span class="fc bfc" id="L1032" title="All 2 branches covered.">                do { action.accept(a[i]); } while (++i &lt; hi);</span>
            }
<span class="fc" id="L1034">        }</span>

        @Override
        public boolean tryAdvance(IntConsumer action) {
<span class="pc bpc" id="L1038" title="1 of 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1039">                throw new NullPointerException();</span>
<span class="pc bpc" id="L1040" title="1 of 4 branches missed.">            if (index &gt;= 0 &amp;&amp; index &lt; fence) {</span>
<span class="fc" id="L1041">                action.accept(array[index++]);</span>
<span class="fc" id="L1042">                return true;</span>
            }
<span class="fc" id="L1044">            return false;</span>
        }

        @Override
<span class="fc" id="L1048">        public long estimateSize() { return (long)(fence - index); }</span>

        @Override
        public int characteristics() {
<span class="fc" id="L1052">            return characteristics;</span>
        }

        @Override
        public Comparator&lt;? super Integer&gt; getComparator() {
<span class="nc bnc" id="L1057" title="All 2 branches missed.">            if (hasCharacteristics(Spliterator.SORTED))</span>
<span class="nc" id="L1058">                return null;</span>
<span class="nc" id="L1059">            throw new IllegalStateException();</span>
        }
    }

    /**
     * A Spliterator.OfLong designed for use by sources that traverse and split
     * elements maintained in an unmodifiable {@code int[]} array.
     */
    static final class LongArraySpliterator implements Spliterator.OfLong {
        private final long[] array;
        private int index;        // current index, modified on advance/split
        private final int fence;  // one past last index
        private final int characteristics;

        /**
         * Creates a spliterator covering all of the given array.
         * @param array the array, assumed to be unmodified during use
         * @param additionalCharacteristics Additional spliterator characteristics
         *        of this spliterator's source or elements beyond {@code SIZED} and
         *        {@code SUBSIZED} which are are always reported
         */
        public LongArraySpliterator(long[] array, int additionalCharacteristics) {
<span class="fc" id="L1081">            this(array, 0, array.length, additionalCharacteristics);</span>
<span class="fc" id="L1082">        }</span>

        /**
         * Creates a spliterator covering the given array and range
         * @param array the array, assumed to be unmodified during use
         * @param origin the least index (inclusive) to cover
         * @param fence one past the greatest index to cover
         * @param additionalCharacteristics Additional spliterator characteristics
         *        of this spliterator's source or elements beyond {@code SIZED} and
         *        {@code SUBSIZED} which are are always reported
         */
<span class="fc" id="L1093">        public LongArraySpliterator(long[] array, int origin, int fence, int additionalCharacteristics) {</span>
<span class="fc" id="L1094">            this.array = array;</span>
<span class="fc" id="L1095">            this.index = origin;</span>
<span class="fc" id="L1096">            this.fence = fence;</span>
<span class="fc" id="L1097">            this.characteristics = additionalCharacteristics | Spliterator.SIZED | Spliterator.SUBSIZED;</span>
<span class="fc" id="L1098">        }</span>

        @Override
        public OfLong trySplit() {
<span class="fc" id="L1102">            int lo = index, mid = (lo + fence) &gt;&gt;&gt; 1;</span>
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">            return (lo &gt;= mid)</span>
                   ? null
                   : new LongArraySpliterator(array, lo, index = mid, characteristics);
        }

        @Override
        public void forEachRemaining(LongConsumer action) {
            long[] a; int i, hi; // hoist accesses and checks from loop
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1112">                throw new NullPointerException();</span>
<span class="pc bpc" id="L1113" title="2 of 6 branches missed.">            if ((a = array).length &gt;= (hi = fence) &amp;&amp;</span>
                (i = index) &gt;= 0 &amp;&amp; i &lt; (index = hi)) {
<span class="fc bfc" id="L1115" title="All 2 branches covered.">                do { action.accept(a[i]); } while (++i &lt; hi);</span>
            }
<span class="fc" id="L1117">        }</span>

        @Override
        public boolean tryAdvance(LongConsumer action) {
<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1122">                throw new NullPointerException();</span>
<span class="pc bpc" id="L1123" title="1 of 4 branches missed.">            if (index &gt;= 0 &amp;&amp; index &lt; fence) {</span>
<span class="fc" id="L1124">                action.accept(array[index++]);</span>
<span class="fc" id="L1125">                return true;</span>
            }
<span class="fc" id="L1127">            return false;</span>
        }

        @Override
<span class="fc" id="L1131">        public long estimateSize() { return (long)(fence - index); }</span>

        @Override
        public int characteristics() {
<span class="fc" id="L1135">            return characteristics;</span>
        }

        @Override
        public Comparator&lt;? super Long&gt; getComparator() {
<span class="nc bnc" id="L1140" title="All 2 branches missed.">            if (hasCharacteristics(Spliterator.SORTED))</span>
<span class="nc" id="L1141">                return null;</span>
<span class="nc" id="L1142">            throw new IllegalStateException();</span>
        }
    }

    /**
     * A Spliterator.OfDouble designed for use by sources that traverse and split
     * elements maintained in an unmodifiable {@code int[]} array.
     */
    static final class DoubleArraySpliterator implements Spliterator.OfDouble {
        private final double[] array;
        private int index;        // current index, modified on advance/split
        private final int fence;  // one past last index
        private final int characteristics;

        /**
         * Creates a spliterator covering all of the given array.
         * @param array the array, assumed to be unmodified during use
         * @param additionalCharacteristics Additional spliterator characteristics
         *        of this spliterator's source or elements beyond {@code SIZED} and
         *        {@code SUBSIZED} which are are always reported
         */
        public DoubleArraySpliterator(double[] array, int additionalCharacteristics) {
<span class="fc" id="L1164">            this(array, 0, array.length, additionalCharacteristics);</span>
<span class="fc" id="L1165">        }</span>

        /**
         * Creates a spliterator covering the given array and range
         * @param array the array, assumed to be unmodified during use
         * @param origin the least index (inclusive) to cover
         * @param fence one past the greatest index to cover
         * @param additionalCharacteristics Additional spliterator characteristics
         *        of this spliterator's source or elements beyond {@code SIZED} and
         *        {@code SUBSIZED} which are are always reported
         */
<span class="fc" id="L1176">        public DoubleArraySpliterator(double[] array, int origin, int fence, int additionalCharacteristics) {</span>
<span class="fc" id="L1177">            this.array = array;</span>
<span class="fc" id="L1178">            this.index = origin;</span>
<span class="fc" id="L1179">            this.fence = fence;</span>
<span class="fc" id="L1180">            this.characteristics = additionalCharacteristics | Spliterator.SIZED | Spliterator.SUBSIZED;</span>
<span class="fc" id="L1181">        }</span>

        @Override
        public OfDouble trySplit() {
<span class="fc" id="L1185">            int lo = index, mid = (lo + fence) &gt;&gt;&gt; 1;</span>
<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">            return (lo &gt;= mid)</span>
                   ? null
                   : new DoubleArraySpliterator(array, lo, index = mid, characteristics);
        }

        @Override
        public void forEachRemaining(DoubleConsumer action) {
            double[] a; int i, hi; // hoist accesses and checks from loop
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1195">                throw new NullPointerException();</span>
<span class="pc bpc" id="L1196" title="2 of 6 branches missed.">            if ((a = array).length &gt;= (hi = fence) &amp;&amp;</span>
                (i = index) &gt;= 0 &amp;&amp; i &lt; (index = hi)) {
<span class="fc bfc" id="L1198" title="All 2 branches covered.">                do { action.accept(a[i]); } while (++i &lt; hi);</span>
            }
<span class="fc" id="L1200">        }</span>

        @Override
        public boolean tryAdvance(DoubleConsumer action) {
<span class="pc bpc" id="L1204" title="1 of 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1205">                throw new NullPointerException();</span>
<span class="pc bpc" id="L1206" title="1 of 4 branches missed.">            if (index &gt;= 0 &amp;&amp; index &lt; fence) {</span>
<span class="fc" id="L1207">                action.accept(array[index++]);</span>
<span class="fc" id="L1208">                return true;</span>
            }
<span class="fc" id="L1210">            return false;</span>
        }

        @Override
<span class="fc" id="L1214">        public long estimateSize() { return (long)(fence - index); }</span>

        @Override
        public int characteristics() {
<span class="fc" id="L1218">            return characteristics;</span>
        }

        @Override
        public Comparator&lt;? super Double&gt; getComparator() {
<span class="nc bnc" id="L1223" title="All 2 branches missed.">            if (hasCharacteristics(Spliterator.SORTED))</span>
<span class="nc" id="L1224">                return null;</span>
<span class="nc" id="L1225">            throw new IllegalStateException();</span>
        }
    }

    //

    /**
     * An abstract {@code Spliterator} that implements {@code trySplit} to
     * permit limited parallelism.
     *
     * &lt;p&gt;An extending class need only
     * implement {@link #tryAdvance(java.util.function.Consumer) tryAdvance}.
     * The extending class should override
     * {@link #forEachRemaining(java.util.function.Consumer) forEach} if it can
     * provide a more performant implementation.
     *
     * @apiNote
     * This class is a useful aid for creating a spliterator when it is not
     * possible or difficult to efficiently partition elements in a manner
     * allowing balanced parallel computation.
     *
     * &lt;p&gt;An alternative to using this class, that also permits limited
     * parallelism, is to create a spliterator from an iterator
     * (see {@link #spliterator(Iterator, long, int)}.  Depending on the
     * circumstances using an iterator may be easier or more convenient than
     * extending this class, such as when there is already an iterator
     * available to use.
     *
     * @see #spliterator(Iterator, long, int)
     * @since 1.8
     */
    public static abstract class AbstractSpliterator&lt;T&gt; implements Spliterator&lt;T&gt; {
        static final int BATCH_UNIT = 1 &lt;&lt; 10;  // batch array size increment
        static final int MAX_BATCH = 1 &lt;&lt; 25;  // max batch array size;
        private final int characteristics;
        private long est;             // size estimate
        private int batch;            // batch size for splits

        /**
         * Creates a spliterator reporting the given estimated size and
         * additionalCharacteristics.
         *
         * @param est the estimated size of this spliterator if known, otherwise
         *        {@code Long.MAX_VALUE}.
         * @param additionalCharacteristics properties of this spliterator's
         *        source or elements.  If {@code SIZED} is reported then this
         *        spliterator will additionally report {@code SUBSIZED}.
         */
<span class="nc" id="L1273">        protected AbstractSpliterator(long est, int additionalCharacteristics) {</span>
<span class="nc" id="L1274">            this.est = est;</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">            this.characteristics = ((additionalCharacteristics &amp; Spliterator.SIZED) != 0)</span>
                                   ? additionalCharacteristics | Spliterator.SUBSIZED
                                   : additionalCharacteristics;
<span class="nc" id="L1278">        }</span>

<span class="nc" id="L1280">        static final class HoldingConsumer&lt;T&gt; implements Consumer&lt;T&gt; {</span>
            Object value;

            @Override
            public void accept(T value) {
<span class="nc" id="L1285">                this.value = value;</span>
<span class="nc" id="L1286">            }</span>
        }

        /**
         * {@inheritDoc}
         *
         * This implementation permits limited parallelism.
         */
        @Override
        public Spliterator&lt;T&gt; trySplit() {
            /*
             * Split into arrays of arithmetically increasing batch
             * sizes.  This will only improve parallel performance if
             * per-element Consumer actions are more costly than
             * transferring them into an array.  The use of an
             * arithmetic progression in split sizes provides overhead
             * vs parallelism bounds that do not particularly favor or
             * penalize cases of lightweight vs heavyweight element
             * operations, across combinations of #elements vs #cores,
             * whether or not either are known.  We generate
             * O(sqrt(#elements)) splits, allowing O(sqrt(#cores))
             * potential speedup.
             */
<span class="nc" id="L1309">            HoldingConsumer&lt;T&gt; holder = new HoldingConsumer&lt;&gt;();</span>
<span class="nc" id="L1310">            long s = est;</span>
<span class="nc bnc" id="L1311" title="All 4 branches missed.">            if (s &gt; 1 &amp;&amp; tryAdvance(holder)) {</span>
<span class="nc" id="L1312">                int n = batch + BATCH_UNIT;</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">                if (n &gt; s)</span>
<span class="nc" id="L1314">                    n = (int) s;</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">                if (n &gt; MAX_BATCH)</span>
<span class="nc" id="L1316">                    n = MAX_BATCH;</span>
<span class="nc" id="L1317">                Object[] a = new Object[n];</span>
<span class="nc" id="L1318">                int j = 0;</span>
<span class="nc bnc" id="L1319" title="All 4 branches missed.">                do { a[j] = holder.value; } while (++j &lt; n &amp;&amp; tryAdvance(holder));</span>
<span class="nc" id="L1320">                batch = j;</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">                if (est != Long.MAX_VALUE)</span>
<span class="nc" id="L1322">                    est -= j;</span>
<span class="nc" id="L1323">                return new ArraySpliterator&lt;&gt;(a, 0, j, characteristics());</span>
            }
<span class="nc" id="L1325">            return null;</span>
        }

        /**
         * {@inheritDoc}
         *
         * @implSpec
         * This implementation returns the estimated size as reported when
         * created and, if the estimate size is known, decreases in size when
         * split.
         */
        @Override
        public long estimateSize() {
<span class="nc" id="L1338">            return est;</span>
        }

        /**
         * {@inheritDoc}
         *
         * @implSpec
         * This implementation returns the characteristics as reported when
         * created.
         */
        @Override
        public int characteristics() {
<span class="nc" id="L1350">            return characteristics;</span>
        }
    }

    /**
     * An abstract {@code Spliterator.OfInt} that implements {@code trySplit} to
     * permit limited parallelism.
     *
     * &lt;p&gt;To implement a spliterator an extending class need only
     * implement {@link #tryAdvance(java.util.function.IntConsumer)}
     * tryAdvance}.  The extending class should override
     * {@link #forEachRemaining(java.util.function.IntConsumer)} forEach} if it
     * can provide a more performant implementation.
     *
     * @apiNote
     * This class is a useful aid for creating a spliterator when it is not
     * possible or difficult to efficiently partition elements in a manner
     * allowing balanced parallel computation.
     *
     * &lt;p&gt;An alternative to using this class, that also permits limited
     * parallelism, is to create a spliterator from an iterator
     * (see {@link #spliterator(java.util.PrimitiveIterator.OfInt, long, int)}.
     * Depending on the circumstances using an iterator may be easier or more
     * convenient than extending this class. For example, if there is already an
     * iterator available to use then there is no need to extend this class.
     *
     * @see #spliterator(java.util.PrimitiveIterator.OfInt, long, int)
     * @since 1.8
     */
    public static abstract class AbstractIntSpliterator implements Spliterator.OfInt {
        static final int MAX_BATCH = AbstractSpliterator.MAX_BATCH;
        static final int BATCH_UNIT = AbstractSpliterator.BATCH_UNIT;
        private final int characteristics;
        private long est;             // size estimate
        private int batch;            // batch size for splits

        /**
         * Creates a spliterator reporting the given estimated size and
         * characteristics.
         *
         * @param est the estimated size of this spliterator if known, otherwise
         *        {@code Long.MAX_VALUE}.
         * @param additionalCharacteristics properties of this spliterator's
         *        source or elements.  If {@code SIZED} is reported then this
         *        spliterator will additionally report {@code SUBSIZED}.
         */
<span class="nc" id="L1396">        protected AbstractIntSpliterator(long est, int additionalCharacteristics) {</span>
<span class="nc" id="L1397">            this.est = est;</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">            this.characteristics = ((additionalCharacteristics &amp; Spliterator.SIZED) != 0)</span>
                                   ? additionalCharacteristics | Spliterator.SUBSIZED
                                   : additionalCharacteristics;
<span class="nc" id="L1401">        }</span>

<span class="nc" id="L1403">        static final class HoldingIntConsumer implements IntConsumer {</span>
            int value;

            @Override
            public void accept(int value) {
<span class="nc" id="L1408">                this.value = value;</span>
<span class="nc" id="L1409">            }</span>
        }

        /**
         * {@inheritDoc}
         *
         * This implementation permits limited parallelism.
         */
        @Override
        public Spliterator.OfInt trySplit() {
<span class="nc" id="L1419">            HoldingIntConsumer holder = new HoldingIntConsumer();</span>
<span class="nc" id="L1420">            long s = est;</span>
<span class="nc bnc" id="L1421" title="All 4 branches missed.">            if (s &gt; 1 &amp;&amp; tryAdvance(holder)) {</span>
<span class="nc" id="L1422">                int n = batch + BATCH_UNIT;</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">                if (n &gt; s)</span>
<span class="nc" id="L1424">                    n = (int) s;</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">                if (n &gt; MAX_BATCH)</span>
<span class="nc" id="L1426">                    n = MAX_BATCH;</span>
<span class="nc" id="L1427">                int[] a = new int[n];</span>
<span class="nc" id="L1428">                int j = 0;</span>
<span class="nc bnc" id="L1429" title="All 4 branches missed.">                do { a[j] = holder.value; } while (++j &lt; n &amp;&amp; tryAdvance(holder));</span>
<span class="nc" id="L1430">                batch = j;</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">                if (est != Long.MAX_VALUE)</span>
<span class="nc" id="L1432">                    est -= j;</span>
<span class="nc" id="L1433">                return new IntArraySpliterator(a, 0, j, characteristics());</span>
            }
<span class="nc" id="L1435">            return null;</span>
        }

        /**
         * {@inheritDoc}
         *
         * @implSpec
         * This implementation returns the estimated size as reported when
         * created and, if the estimate size is known, decreases in size when
         * split.
         */
        @Override
        public long estimateSize() {
<span class="nc" id="L1448">            return est;</span>
        }

        /**
         * {@inheritDoc}
         *
         * @implSpec
         * This implementation returns the characteristics as reported when
         * created.
         */
        @Override
        public int characteristics() {
<span class="nc" id="L1460">            return characteristics;</span>
        }
    }

    /**
     * An abstract {@code Spliterator.OfLong} that implements {@code trySplit}
     * to permit limited parallelism.
     *
     * &lt;p&gt;To implement a spliterator an extending class need only
     * implement {@link #tryAdvance(java.util.function.LongConsumer)}
     * tryAdvance}.  The extending class should override
     * {@link #forEachRemaining(java.util.function.LongConsumer)} forEach} if it
     * can provide a more performant implementation.
     *
     * @apiNote
     * This class is a useful aid for creating a spliterator when it is not
     * possible or difficult to efficiently partition elements in a manner
     * allowing balanced parallel computation.
     *
     * &lt;p&gt;An alternative to using this class, that also permits limited
     * parallelism, is to create a spliterator from an iterator
     * (see {@link #spliterator(java.util.PrimitiveIterator.OfLong, long, int)}.
     * Depending on the circumstances using an iterator may be easier or more
     * convenient than extending this class. For example, if there is already an
     * iterator available to use then there is no need to extend this class.
     *
     * @see #spliterator(java.util.PrimitiveIterator.OfLong, long, int)
     * @since 1.8
     */
    public static abstract class AbstractLongSpliterator implements Spliterator.OfLong {
        static final int MAX_BATCH = AbstractSpliterator.MAX_BATCH;
        static final int BATCH_UNIT = AbstractSpliterator.BATCH_UNIT;
        private final int characteristics;
        private long est;             // size estimate
        private int batch;            // batch size for splits

        /**
         * Creates a spliterator reporting the given estimated size and
         * characteristics.
         *
         * @param est the estimated size of this spliterator if known, otherwise
         *        {@code Long.MAX_VALUE}.
         * @param additionalCharacteristics properties of this spliterator's
         *        source or elements.  If {@code SIZED} is reported then this
         *        spliterator will additionally report {@code SUBSIZED}.
         */
<span class="nc" id="L1506">        protected AbstractLongSpliterator(long est, int additionalCharacteristics) {</span>
<span class="nc" id="L1507">            this.est = est;</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">            this.characteristics = ((additionalCharacteristics &amp; Spliterator.SIZED) != 0)</span>
                                   ? additionalCharacteristics | Spliterator.SUBSIZED
                                   : additionalCharacteristics;
<span class="nc" id="L1511">        }</span>

<span class="nc" id="L1513">        static final class HoldingLongConsumer implements LongConsumer {</span>
            long value;

            @Override
            public void accept(long value) {
<span class="nc" id="L1518">                this.value = value;</span>
<span class="nc" id="L1519">            }</span>
        }

        /**
         * {@inheritDoc}
         *
         * This implementation permits limited parallelism.
         */
        @Override
        public Spliterator.OfLong trySplit() {
<span class="nc" id="L1529">            HoldingLongConsumer holder = new HoldingLongConsumer();</span>
<span class="nc" id="L1530">            long s = est;</span>
<span class="nc bnc" id="L1531" title="All 4 branches missed.">            if (s &gt; 1 &amp;&amp; tryAdvance(holder)) {</span>
<span class="nc" id="L1532">                int n = batch + BATCH_UNIT;</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">                if (n &gt; s)</span>
<span class="nc" id="L1534">                    n = (int) s;</span>
<span class="nc bnc" id="L1535" title="All 2 branches missed.">                if (n &gt; MAX_BATCH)</span>
<span class="nc" id="L1536">                    n = MAX_BATCH;</span>
<span class="nc" id="L1537">                long[] a = new long[n];</span>
<span class="nc" id="L1538">                int j = 0;</span>
<span class="nc bnc" id="L1539" title="All 4 branches missed.">                do { a[j] = holder.value; } while (++j &lt; n &amp;&amp; tryAdvance(holder));</span>
<span class="nc" id="L1540">                batch = j;</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">                if (est != Long.MAX_VALUE)</span>
<span class="nc" id="L1542">                    est -= j;</span>
<span class="nc" id="L1543">                return new LongArraySpliterator(a, 0, j, characteristics());</span>
            }
<span class="nc" id="L1545">            return null;</span>
        }

        /**
         * {@inheritDoc}
         *
         * @implSpec
         * This implementation returns the estimated size as reported when
         * created and, if the estimate size is known, decreases in size when
         * split.
         */
        @Override
        public long estimateSize() {
<span class="nc" id="L1558">            return est;</span>
        }

        /**
         * {@inheritDoc}
         *
         * @implSpec
         * This implementation returns the characteristics as reported when
         * created.
         */
        @Override
        public int characteristics() {
<span class="nc" id="L1570">            return characteristics;</span>
        }
    }

    /**
     * An abstract {@code Spliterator.OfDouble} that implements
     * {@code trySplit} to permit limited parallelism.
     *
     * &lt;p&gt;To implement a spliterator an extending class need only
     * implement {@link #tryAdvance(java.util.function.DoubleConsumer)}
     * tryAdvance}.  The extending class should override
     * {@link #forEachRemaining(java.util.function.DoubleConsumer)} forEach} if
     * it can provide a more performant implementation.
     *
     * @apiNote
     * This class is a useful aid for creating a spliterator when it is not
     * possible or difficult to efficiently partition elements in a manner
     * allowing balanced parallel computation.
     *
     * &lt;p&gt;An alternative to using this class, that also permits limited
     * parallelism, is to create a spliterator from an iterator
     * (see {@link #spliterator(java.util.PrimitiveIterator.OfDouble, long, int)}.
     * Depending on the circumstances using an iterator may be easier or more
     * convenient than extending this class. For example, if there is already an
     * iterator available to use then there is no need to extend this class.
     *
     * @see #spliterator(java.util.PrimitiveIterator.OfDouble, long, int)
     * @since 1.8
     */
    public static abstract class AbstractDoubleSpliterator implements Spliterator.OfDouble {
        static final int MAX_BATCH = AbstractSpliterator.MAX_BATCH;
        static final int BATCH_UNIT = AbstractSpliterator.BATCH_UNIT;
        private final int characteristics;
        private long est;             // size estimate
        private int batch;            // batch size for splits

        /**
         * Creates a spliterator reporting the given estimated size and
         * characteristics.
         *
         * @param est the estimated size of this spliterator if known, otherwise
         *        {@code Long.MAX_VALUE}.
         * @param additionalCharacteristics properties of this spliterator's
         *        source or elements.  If {@code SIZED} is reported then this
         *        spliterator will additionally report {@code SUBSIZED}.
         */
<span class="nc" id="L1616">        protected AbstractDoubleSpliterator(long est, int additionalCharacteristics) {</span>
<span class="nc" id="L1617">            this.est = est;</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">            this.characteristics = ((additionalCharacteristics &amp; Spliterator.SIZED) != 0)</span>
                                   ? additionalCharacteristics | Spliterator.SUBSIZED
                                   : additionalCharacteristics;
<span class="nc" id="L1621">        }</span>

<span class="nc" id="L1623">        static final class HoldingDoubleConsumer implements DoubleConsumer {</span>
            double value;

            @Override
            public void accept(double value) {
<span class="nc" id="L1628">                this.value = value;</span>
<span class="nc" id="L1629">            }</span>
        }

        /**
         * {@inheritDoc}
         *
         * This implementation permits limited parallelism.
         */
        @Override
        public Spliterator.OfDouble trySplit() {
<span class="nc" id="L1639">            HoldingDoubleConsumer holder = new HoldingDoubleConsumer();</span>
<span class="nc" id="L1640">            long s = est;</span>
<span class="nc bnc" id="L1641" title="All 4 branches missed.">            if (s &gt; 1 &amp;&amp; tryAdvance(holder)) {</span>
<span class="nc" id="L1642">                int n = batch + BATCH_UNIT;</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">                if (n &gt; s)</span>
<span class="nc" id="L1644">                    n = (int) s;</span>
<span class="nc bnc" id="L1645" title="All 2 branches missed.">                if (n &gt; MAX_BATCH)</span>
<span class="nc" id="L1646">                    n = MAX_BATCH;</span>
<span class="nc" id="L1647">                double[] a = new double[n];</span>
<span class="nc" id="L1648">                int j = 0;</span>
<span class="nc bnc" id="L1649" title="All 4 branches missed.">                do { a[j] = holder.value; } while (++j &lt; n &amp;&amp; tryAdvance(holder));</span>
<span class="nc" id="L1650">                batch = j;</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">                if (est != Long.MAX_VALUE)</span>
<span class="nc" id="L1652">                    est -= j;</span>
<span class="nc" id="L1653">                return new DoubleArraySpliterator(a, 0, j, characteristics());</span>
            }
<span class="nc" id="L1655">            return null;</span>
        }

        /**
         * {@inheritDoc}
         *
         * @implSpec
         * This implementation returns the estimated size as reported when
         * created and, if the estimate size is known, decreases in size when
         * split.
         */
        @Override
        public long estimateSize() {
<span class="nc" id="L1668">            return est;</span>
        }

        /**
         * {@inheritDoc}
         *
         * @implSpec
         * This implementation returns the characteristics as reported when
         * created.
         */
        @Override
        public int characteristics() {
<span class="nc" id="L1680">            return characteristics;</span>
        }
    }

    // Iterator-based Spliterators

    /**
     * A Spliterator using a given Iterator for element
     * operations. The spliterator implements {@code trySplit} to
     * permit limited parallelism.
     */
    static class IteratorSpliterator&lt;T&gt; implements Spliterator&lt;T&gt; {
        static final int BATCH_UNIT = 1 &lt;&lt; 10;  // batch array size increment
        static final int MAX_BATCH = 1 &lt;&lt; 25;  // max batch array size;
        private final Collection&lt;? extends T&gt; collection; // null OK
        private Iterator&lt;? extends T&gt; it;
        private final int characteristics;
        private long est;             // size estimate
        private int batch;            // batch size for splits

        /**
         * Creates a spliterator using the given given
         * collection's {@link java.util.Collection#iterator()) for traversal,
         * and reporting its {@link java.util.Collection#size()) as its initial
         * size.
         *
         * @param c the collection
         * @param characteristics properties of this spliterator's
         *        source or elements.
         */
<span class="fc" id="L1710">        public IteratorSpliterator(Collection&lt;? extends T&gt; collection, int characteristics) {</span>
<span class="fc" id="L1711">            this.collection = collection;</span>
<span class="fc" id="L1712">            this.it = null;</span>
<span class="fc bfc" id="L1713" title="All 2 branches covered.">            this.characteristics = (characteristics &amp; Spliterator.CONCURRENT) == 0</span>
                                   ? characteristics | Spliterator.SIZED | Spliterator.SUBSIZED
                                   : characteristics;
<span class="fc" id="L1716">        }</span>

        /**
         * Creates a spliterator using the given iterator
         * for traversal, and reporting the given initial size
         * and characteristics.
         *
         * @param iterator the iterator for the source
         * @param size the number of elements in the source
         * @param characteristics properties of this spliterator's
         * source or elements.
         */
<span class="fc" id="L1728">        public IteratorSpliterator(Iterator&lt;? extends T&gt; iterator, long size, int characteristics) {</span>
<span class="fc" id="L1729">            this.collection = null;</span>
<span class="fc" id="L1730">            this.it = iterator;</span>
<span class="fc" id="L1731">            this.est = size;</span>
<span class="pc bpc" id="L1732" title="1 of 2 branches missed.">            this.characteristics = (characteristics &amp; Spliterator.CONCURRENT) == 0</span>
                                   ? characteristics | Spliterator.SIZED | Spliterator.SUBSIZED
                                   : characteristics;
<span class="fc" id="L1735">        }</span>

        /**
         * Creates a spliterator using the given iterator
         * for traversal, and reporting the given initial size
         * and characteristics.
         *
         * @param iterator the iterator for the source
         * @param characteristics properties of this spliterator's
         * source or elements.
         */
<span class="fc" id="L1746">        public IteratorSpliterator(Iterator&lt;? extends T&gt; iterator, int characteristics) {</span>
<span class="fc" id="L1747">            this.collection = null;</span>
<span class="fc" id="L1748">            this.it = iterator;</span>
<span class="fc" id="L1749">            this.est = Long.MAX_VALUE;</span>
<span class="fc" id="L1750">            this.characteristics = characteristics &amp; ~(Spliterator.SIZED | Spliterator.SUBSIZED);</span>
<span class="fc" id="L1751">        }</span>

        @Override
        public Spliterator&lt;T&gt; trySplit() {
            /*
             * Split into arrays of arithmetically increasing batch
             * sizes.  This will only improve parallel performance if
             * per-element Consumer actions are more costly than
             * transferring them into an array.  The use of an
             * arithmetic progression in split sizes provides overhead
             * vs parallelism bounds that do not particularly favor or
             * penalize cases of lightweight vs heavyweight element
             * operations, across combinations of #elements vs #cores,
             * whether or not either are known.  We generate
             * O(sqrt(#elements)) splits, allowing O(sqrt(#cores))
             * potential speedup.
             */
            Iterator&lt;? extends T&gt; i;
            long s;
<span class="pc bpc" id="L1770" title="1 of 2 branches missed.">            if ((i = it) == null) {</span>
<span class="nc" id="L1771">                i = it = collection.iterator();</span>
<span class="nc" id="L1772">                s = est = (long) collection.size();</span>
            }
            else
<span class="fc" id="L1775">                s = est;</span>
<span class="pc bpc" id="L1776" title="1 of 4 branches missed.">            if (s &gt; 1 &amp;&amp; i.hasNext()) {</span>
<span class="fc" id="L1777">                int n = batch + BATCH_UNIT;</span>
<span class="pc bpc" id="L1778" title="1 of 2 branches missed.">                if (n &gt; s)</span>
<span class="nc" id="L1779">                    n = (int) s;</span>
<span class="pc bpc" id="L1780" title="1 of 2 branches missed.">                if (n &gt; MAX_BATCH)</span>
<span class="nc" id="L1781">                    n = MAX_BATCH;</span>
<span class="fc" id="L1782">                Object[] a = new Object[n];</span>
<span class="fc" id="L1783">                int j = 0;</span>
<span class="pc bpc" id="L1784" title="1 of 4 branches missed.">                do { a[j] = i.next(); } while (++j &lt; n &amp;&amp; i.hasNext());</span>
<span class="fc" id="L1785">                batch = j;</span>
<span class="pc bpc" id="L1786" title="1 of 2 branches missed.">                if (est != Long.MAX_VALUE)</span>
<span class="nc" id="L1787">                    est -= j;</span>
<span class="fc" id="L1788">                return new ArraySpliterator&lt;&gt;(a, 0, j, characteristics);</span>
            }
<span class="fc" id="L1790">            return null;</span>
        }

        @Override
        public void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="pc bpc" id="L1795" title="1 of 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
            Iterator&lt;? extends T&gt; i;
<span class="fc bfc" id="L1797" title="All 2 branches covered.">            if ((i = it) == null) {</span>
<span class="fc" id="L1798">                i = it = collection.iterator();</span>
<span class="fc" id="L1799">                est = (long)collection.size();</span>
            }
<span class="nc" id="L1801">            i.forEachRemaining(action);</span>
<span class="nc" id="L1802">        }</span>

        @Override
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="pc bpc" id="L1806" title="1 of 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="fc bfc" id="L1807" title="All 2 branches covered.">            if (it == null) {</span>
<span class="fc" id="L1808">                it = collection.iterator();</span>
<span class="fc" id="L1809">                est = (long) collection.size();</span>
            }
<span class="fc bfc" id="L1811" title="All 2 branches covered.">            if (it.hasNext()) {</span>
<span class="fc" id="L1812">                action.accept(it.next());</span>
<span class="fc" id="L1813">                return true;</span>
            }
<span class="fc" id="L1815">            return false;</span>
        }

        @Override
        public long estimateSize() {
<span class="pc bpc" id="L1820" title="1 of 2 branches missed.">            if (it == null) {</span>
<span class="nc" id="L1821">                it = collection.iterator();</span>
<span class="nc" id="L1822">                return est = (long)collection.size();</span>
            }
<span class="fc" id="L1824">            return est;</span>
        }

        @Override
<span class="fc" id="L1828">        public int characteristics() { return characteristics; }</span>

        @Override
        public Comparator&lt;? super T&gt; getComparator() {
<span class="nc bnc" id="L1832" title="All 2 branches missed.">            if (hasCharacteristics(Spliterator.SORTED))</span>
<span class="nc" id="L1833">                return null;</span>
<span class="nc" id="L1834">            throw new IllegalStateException();</span>
        }
    }

    /**
     * A Spliterator.OfInt using a given IntStream.IntIterator for element
     * operations. The spliterator implements {@code trySplit} to
     * permit limited parallelism.
     */
    static final class IntIteratorSpliterator implements Spliterator.OfInt {
        static final int BATCH_UNIT = IteratorSpliterator.BATCH_UNIT;
        static final int MAX_BATCH = IteratorSpliterator.MAX_BATCH;
        private PrimitiveIterator.OfInt it;
        private final int characteristics;
        private long est;             // size estimate
        private int batch;            // batch size for splits

        /**
         * Creates a spliterator using the given iterator
         * for traversal, and reporting the given initial size
         * and characteristics.
         *
         * @param iterator the iterator for the source
         * @param size the number of elements in the source
         * @param characteristics properties of this spliterator's
         * source or elements.
         */
<span class="fc" id="L1861">        public IntIteratorSpliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics) {</span>
<span class="fc" id="L1862">            this.it = iterator;</span>
<span class="fc" id="L1863">            this.est = size;</span>
<span class="pc bpc" id="L1864" title="1 of 2 branches missed.">            this.characteristics = (characteristics &amp; Spliterator.CONCURRENT) == 0</span>
                                   ? characteristics | Spliterator.SIZED | Spliterator.SUBSIZED
                                   : characteristics;
<span class="fc" id="L1867">        }</span>

        /**
         * Creates a spliterator using the given iterator for a
         * source of unknown size, reporting the given
         * characteristics.
         *
         * @param iterator the iterator for the source
         * @param characteristics properties of this spliterator's
         * source or elements.
         */
<span class="fc" id="L1878">        public IntIteratorSpliterator(PrimitiveIterator.OfInt iterator, int characteristics) {</span>
<span class="fc" id="L1879">            this.it = iterator;</span>
<span class="fc" id="L1880">            this.est = Long.MAX_VALUE;</span>
<span class="fc" id="L1881">            this.characteristics = characteristics &amp; ~(Spliterator.SIZED | Spliterator.SUBSIZED);</span>
<span class="fc" id="L1882">        }</span>

        @Override
        public OfInt trySplit() {
<span class="nc" id="L1886">            PrimitiveIterator.OfInt i = it;</span>
<span class="nc" id="L1887">            long s = est;</span>
<span class="nc bnc" id="L1888" title="All 4 branches missed.">            if (s &gt; 1 &amp;&amp; i.hasNext()) {</span>
<span class="nc" id="L1889">                int n = batch + BATCH_UNIT;</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">                if (n &gt; s)</span>
<span class="nc" id="L1891">                    n = (int) s;</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">                if (n &gt; MAX_BATCH)</span>
<span class="nc" id="L1893">                    n = MAX_BATCH;</span>
<span class="nc" id="L1894">                int[] a = new int[n];</span>
<span class="nc" id="L1895">                int j = 0;</span>
<span class="nc bnc" id="L1896" title="All 4 branches missed.">                do { a[j] = i.nextInt(); } while (++j &lt; n &amp;&amp; i.hasNext());</span>
<span class="nc" id="L1897">                batch = j;</span>
<span class="nc bnc" id="L1898" title="All 2 branches missed.">                if (est != Long.MAX_VALUE)</span>
<span class="nc" id="L1899">                    est -= j;</span>
<span class="nc" id="L1900">                return new IntArraySpliterator(a, 0, j, characteristics);</span>
            }
<span class="nc" id="L1902">            return null;</span>
        }

        @Override
        public void forEachRemaining(IntConsumer action) {
<span class="pc bpc" id="L1907" title="1 of 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="fc" id="L1908">            it.forEachRemaining(action);</span>
<span class="fc" id="L1909">        }</span>

        @Override
        public boolean tryAdvance(IntConsumer action) {
<span class="nc bnc" id="L1913" title="All 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">            if (it.hasNext()) {</span>
<span class="nc" id="L1915">                action.accept(it.nextInt());</span>
<span class="nc" id="L1916">                return true;</span>
            }
<span class="nc" id="L1918">            return false;</span>
        }

        @Override
        public long estimateSize() {
<span class="nc" id="L1923">            return est;</span>
        }

        @Override
<span class="fc" id="L1927">        public int characteristics() { return characteristics; }</span>

        @Override
        public Comparator&lt;? super Integer&gt; getComparator() {
<span class="nc bnc" id="L1931" title="All 2 branches missed.">            if (hasCharacteristics(Spliterator.SORTED))</span>
<span class="nc" id="L1932">                return null;</span>
<span class="nc" id="L1933">            throw new IllegalStateException();</span>
        }
    }

    static final class LongIteratorSpliterator implements Spliterator.OfLong {
        static final int BATCH_UNIT = IteratorSpliterator.BATCH_UNIT;
        static final int MAX_BATCH = IteratorSpliterator.MAX_BATCH;
        private PrimitiveIterator.OfLong it;
        private final int characteristics;
        private long est;             // size estimate
        private int batch;            // batch size for splits

        /**
         * Creates a spliterator using the given iterator
         * for traversal, and reporting the given initial size
         * and characteristics.
         *
         * @param iterator the iterator for the source
         * @param size the number of elements in the source
         * @param characteristics properties of this spliterator's
         * source or elements.
         */
<span class="fc" id="L1955">        public LongIteratorSpliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics) {</span>
<span class="fc" id="L1956">            this.it = iterator;</span>
<span class="fc" id="L1957">            this.est = size;</span>
<span class="pc bpc" id="L1958" title="1 of 2 branches missed.">            this.characteristics = (characteristics &amp; Spliterator.CONCURRENT) == 0</span>
                                   ? characteristics | Spliterator.SIZED | Spliterator.SUBSIZED
                                   : characteristics;
<span class="fc" id="L1961">        }</span>

        /**
         * Creates a spliterator using the given iterator for a
         * source of unknown size, reporting the given
         * characteristics.
         *
         * @param iterator the iterator for the source
         * @param characteristics properties of this spliterator's
         * source or elements.
         */
<span class="fc" id="L1972">        public LongIteratorSpliterator(PrimitiveIterator.OfLong iterator, int characteristics) {</span>
<span class="fc" id="L1973">            this.it = iterator;</span>
<span class="fc" id="L1974">            this.est = Long.MAX_VALUE;</span>
<span class="fc" id="L1975">            this.characteristics = characteristics &amp; ~(Spliterator.SIZED | Spliterator.SUBSIZED);</span>
<span class="fc" id="L1976">        }</span>

        @Override
        public OfLong trySplit() {
<span class="nc" id="L1980">            PrimitiveIterator.OfLong i = it;</span>
<span class="nc" id="L1981">            long s = est;</span>
<span class="nc bnc" id="L1982" title="All 4 branches missed.">            if (s &gt; 1 &amp;&amp; i.hasNext()) {</span>
<span class="nc" id="L1983">                int n = batch + BATCH_UNIT;</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">                if (n &gt; s)</span>
<span class="nc" id="L1985">                    n = (int) s;</span>
<span class="nc bnc" id="L1986" title="All 2 branches missed.">                if (n &gt; MAX_BATCH)</span>
<span class="nc" id="L1987">                    n = MAX_BATCH;</span>
<span class="nc" id="L1988">                long[] a = new long[n];</span>
<span class="nc" id="L1989">                int j = 0;</span>
<span class="nc bnc" id="L1990" title="All 4 branches missed.">                do { a[j] = i.nextLong(); } while (++j &lt; n &amp;&amp; i.hasNext());</span>
<span class="nc" id="L1991">                batch = j;</span>
<span class="nc bnc" id="L1992" title="All 2 branches missed.">                if (est != Long.MAX_VALUE)</span>
<span class="nc" id="L1993">                    est -= j;</span>
<span class="nc" id="L1994">                return new LongArraySpliterator(a, 0, j, characteristics);</span>
            }
<span class="nc" id="L1996">            return null;</span>
        }

        @Override
        public void forEachRemaining(LongConsumer action) {
<span class="pc bpc" id="L2001" title="1 of 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="fc" id="L2002">            it.forEachRemaining(action);</span>
<span class="fc" id="L2003">        }</span>

        @Override
        public boolean tryAdvance(LongConsumer action) {
<span class="nc bnc" id="L2007" title="All 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="nc bnc" id="L2008" title="All 2 branches missed.">            if (it.hasNext()) {</span>
<span class="nc" id="L2009">                action.accept(it.nextLong());</span>
<span class="nc" id="L2010">                return true;</span>
            }
<span class="nc" id="L2012">            return false;</span>
        }

        @Override
        public long estimateSize() {
<span class="nc" id="L2017">            return est;</span>
        }

        @Override
<span class="fc" id="L2021">        public int characteristics() { return characteristics; }</span>

        @Override
        public Comparator&lt;? super Long&gt; getComparator() {
<span class="nc bnc" id="L2025" title="All 2 branches missed.">            if (hasCharacteristics(Spliterator.SORTED))</span>
<span class="nc" id="L2026">                return null;</span>
<span class="nc" id="L2027">            throw new IllegalStateException();</span>
        }
    }

    static final class DoubleIteratorSpliterator implements Spliterator.OfDouble {
        static final int BATCH_UNIT = IteratorSpliterator.BATCH_UNIT;
        static final int MAX_BATCH = IteratorSpliterator.MAX_BATCH;
        private PrimitiveIterator.OfDouble it;
        private final int characteristics;
        private long est;             // size estimate
        private int batch;            // batch size for splits

        /**
         * Creates a spliterator using the given iterator
         * for traversal, and reporting the given initial size
         * and characteristics.
         *
         * @param iterator the iterator for the source
         * @param size the number of elements in the source
         * @param characteristics properties of this spliterator's
         * source or elements.
         */
<span class="fc" id="L2049">        public DoubleIteratorSpliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics) {</span>
<span class="fc" id="L2050">            this.it = iterator;</span>
<span class="fc" id="L2051">            this.est = size;</span>
<span class="pc bpc" id="L2052" title="1 of 2 branches missed.">            this.characteristics = (characteristics &amp; Spliterator.CONCURRENT) == 0</span>
                                   ? characteristics | Spliterator.SIZED | Spliterator.SUBSIZED
                                   : characteristics;
<span class="fc" id="L2055">        }</span>

        /**
         * Creates a spliterator using the given iterator for a
         * source of unknown size, reporting the given
         * characteristics.
         *
         * @param iterator the iterator for the source
         * @param characteristics properties of this spliterator's
         * source or elements.
         */
<span class="fc" id="L2066">        public DoubleIteratorSpliterator(PrimitiveIterator.OfDouble iterator, int characteristics) {</span>
<span class="fc" id="L2067">            this.it = iterator;</span>
<span class="fc" id="L2068">            this.est = Long.MAX_VALUE;</span>
<span class="fc" id="L2069">            this.characteristics = characteristics &amp; ~(Spliterator.SIZED | Spliterator.SUBSIZED);</span>
<span class="fc" id="L2070">        }</span>

        @Override
        public OfDouble trySplit() {
<span class="nc" id="L2074">            PrimitiveIterator.OfDouble i = it;</span>
<span class="nc" id="L2075">            long s = est;</span>
<span class="nc bnc" id="L2076" title="All 4 branches missed.">            if (s &gt; 1 &amp;&amp; i.hasNext()) {</span>
<span class="nc" id="L2077">                int n = batch + BATCH_UNIT;</span>
<span class="nc bnc" id="L2078" title="All 2 branches missed.">                if (n &gt; s)</span>
<span class="nc" id="L2079">                    n = (int) s;</span>
<span class="nc bnc" id="L2080" title="All 2 branches missed.">                if (n &gt; MAX_BATCH)</span>
<span class="nc" id="L2081">                    n = MAX_BATCH;</span>
<span class="nc" id="L2082">                double[] a = new double[n];</span>
<span class="nc" id="L2083">                int j = 0;</span>
<span class="nc bnc" id="L2084" title="All 4 branches missed.">                do { a[j] = i.nextDouble(); } while (++j &lt; n &amp;&amp; i.hasNext());</span>
<span class="nc" id="L2085">                batch = j;</span>
<span class="nc bnc" id="L2086" title="All 2 branches missed.">                if (est != Long.MAX_VALUE)</span>
<span class="nc" id="L2087">                    est -= j;</span>
<span class="nc" id="L2088">                return new DoubleArraySpliterator(a, 0, j, characteristics);</span>
            }
<span class="nc" id="L2090">            return null;</span>
        }

        @Override
        public void forEachRemaining(DoubleConsumer action) {
<span class="pc bpc" id="L2095" title="1 of 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="fc" id="L2096">            it.forEachRemaining(action);</span>
<span class="fc" id="L2097">        }</span>

        @Override
        public boolean tryAdvance(DoubleConsumer action) {
<span class="nc bnc" id="L2101" title="All 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">            if (it.hasNext()) {</span>
<span class="nc" id="L2103">                action.accept(it.nextDouble());</span>
<span class="nc" id="L2104">                return true;</span>
            }
<span class="nc" id="L2106">            return false;</span>
        }

        @Override
        public long estimateSize() {
<span class="nc" id="L2111">            return est;</span>
        }

        @Override
<span class="fc" id="L2115">        public int characteristics() { return characteristics; }</span>

        @Override
        public Comparator&lt;? super Double&gt; getComparator() {
<span class="nc bnc" id="L2119" title="All 2 branches missed.">            if (hasCharacteristics(Spliterator.SORTED))</span>
<span class="nc" id="L2120">                return null;</span>
<span class="nc" id="L2121">            throw new IllegalStateException();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>