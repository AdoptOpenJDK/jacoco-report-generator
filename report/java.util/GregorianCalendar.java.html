<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GregorianCalendar.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">GregorianCalendar.java</span></div><h1>GregorianCalendar.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996-1998 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996-1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.util;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.time.Instant;
import java.time.ZonedDateTime;
import java.time.temporal.ChronoField;
import sun.util.calendar.BaseCalendar;
import sun.util.calendar.CalendarDate;
import sun.util.calendar.CalendarSystem;
import sun.util.calendar.CalendarUtils;
import sun.util.calendar.Era;
import sun.util.calendar.Gregorian;
import sun.util.calendar.JulianCalendar;
import sun.util.calendar.ZoneInfo;

/**
 * &lt;code&gt;GregorianCalendar&lt;/code&gt; is a concrete subclass of
 * &lt;code&gt;Calendar&lt;/code&gt; and provides the standard calendar system
 * used by most of the world.
 *
 * &lt;p&gt; &lt;code&gt;GregorianCalendar&lt;/code&gt; is a hybrid calendar that
 * supports both the Julian and Gregorian calendar systems with the
 * support of a single discontinuity, which corresponds by default to
 * the Gregorian date when the Gregorian calendar was instituted
 * (October 15, 1582 in some countries, later in others).  The cutover
 * date may be changed by the caller by calling {@link
 * #setGregorianChange(Date) setGregorianChange()}.
 *
 * &lt;p&gt;
 * Historically, in those countries which adopted the Gregorian calendar first,
 * October 4, 1582 (Julian) was thus followed by October 15, 1582 (Gregorian). This calendar models
 * this correctly.  Before the Gregorian cutover, &lt;code&gt;GregorianCalendar&lt;/code&gt;
 * implements the Julian calendar.  The only difference between the Gregorian
 * and the Julian calendar is the leap year rule. The Julian calendar specifies
 * leap years every four years, whereas the Gregorian calendar omits century
 * years which are not divisible by 400.
 *
 * &lt;p&gt;
 * &lt;code&gt;GregorianCalendar&lt;/code&gt; implements &lt;em&gt;proleptic&lt;/em&gt; Gregorian and
 * Julian calendars. That is, dates are computed by extrapolating the current
 * rules indefinitely far backward and forward in time. As a result,
 * &lt;code&gt;GregorianCalendar&lt;/code&gt; may be used for all years to generate
 * meaningful and consistent results. However, dates obtained using
 * &lt;code&gt;GregorianCalendar&lt;/code&gt; are historically accurate only from March 1, 4
 * AD onward, when modern Julian calendar rules were adopted.  Before this date,
 * leap year rules were applied irregularly, and before 45 BC the Julian
 * calendar did not even exist.
 *
 * &lt;p&gt;
 * Prior to the institution of the Gregorian calendar, New Year's Day was
 * March 25. To avoid confusion, this calendar always uses January 1. A manual
 * adjustment may be made if desired for dates that are prior to the Gregorian
 * changeover and which fall between January 1 and March 24.
 *
 * &lt;h3&gt;&lt;a name=&quot;week_and_year&quot;&gt;Week Of Year and Week Year&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;p&gt;Values calculated for the {@link Calendar#WEEK_OF_YEAR
 * WEEK_OF_YEAR} field range from 1 to 53. The first week of a
 * calendar year is the earliest seven day period starting on {@link
 * Calendar#getFirstDayOfWeek() getFirstDayOfWeek()} that contains at
 * least {@link Calendar#getMinimalDaysInFirstWeek()
 * getMinimalDaysInFirstWeek()} days from that year. It thus depends
 * on the values of {@code getMinimalDaysInFirstWeek()}, {@code
 * getFirstDayOfWeek()}, and the day of the week of January 1. Weeks
 * between week 1 of one year and week 1 of the following year
 * (exclusive) are numbered sequentially from 2 to 52 or 53 (except
 * for year(s) involved in the Julian-Gregorian transition).
 *
 * &lt;p&gt;The {@code getFirstDayOfWeek()} and {@code
 * getMinimalDaysInFirstWeek()} values are initialized using
 * locale-dependent resources when constructing a {@code
 * GregorianCalendar}. &lt;a name=&quot;iso8601_compatible_setting&quot;&gt;The week
 * determination is compatible&lt;/a&gt; with the ISO 8601 standard when {@code
 * getFirstDayOfWeek()} is {@code MONDAY} and {@code
 * getMinimalDaysInFirstWeek()} is 4, which values are used in locales
 * where the standard is preferred. These values can explicitly be set by
 * calling {@link Calendar#setFirstDayOfWeek(int) setFirstDayOfWeek()} and
 * {@link Calendar#setMinimalDaysInFirstWeek(int)
 * setMinimalDaysInFirstWeek()}.
 *
 * &lt;p&gt;A &lt;a name=&quot;week_year&quot;&gt;&lt;em&gt;week year&lt;/em&gt;&lt;/a&gt; is in sync with a
 * {@code WEEK_OF_YEAR} cycle. All weeks between the first and last
 * weeks (inclusive) have the same &lt;em&gt;week year&lt;/em&gt; value.
 * Therefore, the first and last days of a week year may have
 * different calendar year values.
 *
 * &lt;p&gt;For example, January 1, 1998 is a Thursday. If {@code
 * getFirstDayOfWeek()} is {@code MONDAY} and {@code
 * getMinimalDaysInFirstWeek()} is 4 (ISO 8601 standard compatible
 * setting), then week 1 of 1998 starts on December 29, 1997, and ends
 * on January 4, 1998. The week year is 1998 for the last three days
 * of calendar year 1997. If, however, {@code getFirstDayOfWeek()} is
 * {@code SUNDAY}, then week 1 of 1998 starts on January 4, 1998, and
 * ends on January 10, 1998; the first three days of 1998 then are
 * part of week 53 of 1997 and their week year is 1997.
 *
 * &lt;h4&gt;Week Of Month&lt;/h4&gt;
 *
 * &lt;p&gt;Values calculated for the &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; field range from 0
 * to 6.  Week 1 of a month (the days with &lt;code&gt;WEEK_OF_MONTH =
 * 1&lt;/code&gt;) is the earliest set of at least
 * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; contiguous days in that month,
 * ending on the day before &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;.  Unlike
 * week 1 of a year, week 1 of a month may be shorter than 7 days, need
 * not start on &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;, and will not include days of
 * the previous month.  Days of a month before week 1 have a
 * &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 0.
 *
 * &lt;p&gt;For example, if &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; is &lt;code&gt;SUNDAY&lt;/code&gt;
 * and &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; is 4, then the first week of
 * January 1998 is Sunday, January 4 through Saturday, January 10.  These days
 * have a &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 1.  Thursday, January 1 through
 * Saturday, January 3 have a &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 0.  If
 * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; is changed to 3, then January 1
 * through January 3 have a &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 1.
 *
 * &lt;h4&gt;Default Fields Values&lt;/h4&gt;
 *
 * &lt;p&gt;The &lt;code&gt;clear&lt;/code&gt; method sets calendar field(s)
 * undefined. &lt;code&gt;GregorianCalendar&lt;/code&gt; uses the following
 * default value for each calendar field if its value is undefined.
 *
 * &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;3&quot; border=&quot;0&quot;
 *        summary=&quot;GregorianCalendar default field values&quot;
 *        style=&quot;text-align: left; width: 66%;&quot;&gt;
 *   &lt;tbody&gt;
 *     &lt;tr&gt;
 *       &lt;th style=&quot;vertical-align: top; background-color: rgb(204, 204, 255);
 *           text-align: center;&quot;&gt;Field&lt;br&gt;
 *       &lt;/th&gt;
 *       &lt;th style=&quot;vertical-align: top; background-color: rgb(204, 204, 255);
 *           text-align: center;&quot;&gt;Default Value&lt;br&gt;
 *       &lt;/th&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td style=&quot;vertical-align: middle;&quot;&gt;
 *              &lt;code&gt;ERA&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *       &lt;td style=&quot;vertical-align: middle;&quot;&gt;
 *              &lt;code&gt;AD&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td style=&quot;vertical-align: middle; background-color: rgb(238, 238, 255);&quot;&gt;
 *              &lt;code&gt;YEAR&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *       &lt;td style=&quot;vertical-align: middle; background-color: rgb(238, 238, 255);&quot;&gt;
 *              &lt;code&gt;1970&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td style=&quot;vertical-align: middle;&quot;&gt;
 *              &lt;code&gt;MONTH&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *       &lt;td style=&quot;vertical-align: middle;&quot;&gt;
 *              &lt;code&gt;JANUARY&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td style=&quot;vertical-align: top; background-color: rgb(238, 238, 255);&quot;&gt;
 *              &lt;code&gt;DAY_OF_MONTH&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *       &lt;td style=&quot;vertical-align: top; background-color: rgb(238, 238, 255);&quot;&gt;
 *              &lt;code&gt;1&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td style=&quot;vertical-align: middle;&quot;&gt;
 *              &lt;code&gt;DAY_OF_WEEK&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *       &lt;td style=&quot;vertical-align: middle;&quot;&gt;
 *              &lt;code&gt;the first day of week&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td style=&quot;vertical-align: top; background-color: rgb(238, 238, 255);&quot;&gt;
 *              &lt;code&gt;WEEK_OF_MONTH&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *       &lt;td style=&quot;vertical-align: top; background-color: rgb(238, 238, 255);&quot;&gt;
 *              &lt;code&gt;0&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td style=&quot;vertical-align: top;&quot;&gt;
 *              &lt;code&gt;DAY_OF_WEEK_IN_MONTH&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *       &lt;td style=&quot;vertical-align: top;&quot;&gt;
 *              &lt;code&gt;1&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td style=&quot;vertical-align: middle; background-color: rgb(238, 238, 255);&quot;&gt;
 *              &lt;code&gt;AM_PM&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *       &lt;td style=&quot;vertical-align: middle; background-color: rgb(238, 238, 255);&quot;&gt;
 *              &lt;code&gt;AM&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td style=&quot;vertical-align: middle;&quot;&gt;
 *              &lt;code&gt;HOUR, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *       &lt;td style=&quot;vertical-align: middle;&quot;&gt;
 *              &lt;code&gt;0&lt;br&gt;&lt;/code&gt;
 *       &lt;/td&gt;
 *     &lt;/tr&gt;
 *   &lt;/tbody&gt;
 * &lt;/table&gt;
 * &lt;br&gt;Default values are not applicable for the fields not listed above.
 *
 * &lt;p&gt;
 * &lt;strong&gt;Example:&lt;/strong&gt;
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * // get the supported ids for GMT-08:00 (Pacific Standard Time)
 * String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);
 * // if no ids were returned, something is wrong. get out.
 * if (ids.length == 0)
 *     System.exit(0);
 *
 *  // begin output
 * System.out.println(&quot;Current Time&quot;);
 *
 * // create a Pacific Standard Time time zone
 * SimpleTimeZone pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]);
 *
 * // set up rules for Daylight Saving Time
 * pdt.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
 * pdt.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
 *
 * // create a GregorianCalendar with the Pacific Daylight time zone
 * // and the current date and time
 * Calendar calendar = new GregorianCalendar(pdt);
 * Date trialTime = new Date();
 * calendar.setTime(trialTime);
 *
 * // print out a bunch of interesting things
 * System.out.println(&quot;ERA: &quot; + calendar.get(Calendar.ERA));
 * System.out.println(&quot;YEAR: &quot; + calendar.get(Calendar.YEAR));
 * System.out.println(&quot;MONTH: &quot; + calendar.get(Calendar.MONTH));
 * System.out.println(&quot;WEEK_OF_YEAR: &quot; + calendar.get(Calendar.WEEK_OF_YEAR));
 * System.out.println(&quot;WEEK_OF_MONTH: &quot; + calendar.get(Calendar.WEEK_OF_MONTH));
 * System.out.println(&quot;DATE: &quot; + calendar.get(Calendar.DATE));
 * System.out.println(&quot;DAY_OF_MONTH: &quot; + calendar.get(Calendar.DAY_OF_MONTH));
 * System.out.println(&quot;DAY_OF_YEAR: &quot; + calendar.get(Calendar.DAY_OF_YEAR));
 * System.out.println(&quot;DAY_OF_WEEK: &quot; + calendar.get(Calendar.DAY_OF_WEEK));
 * System.out.println(&quot;DAY_OF_WEEK_IN_MONTH: &quot;
 *                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
 * System.out.println(&quot;AM_PM: &quot; + calendar.get(Calendar.AM_PM));
 * System.out.println(&quot;HOUR: &quot; + calendar.get(Calendar.HOUR));
 * System.out.println(&quot;HOUR_OF_DAY: &quot; + calendar.get(Calendar.HOUR_OF_DAY));
 * System.out.println(&quot;MINUTE: &quot; + calendar.get(Calendar.MINUTE));
 * System.out.println(&quot;SECOND: &quot; + calendar.get(Calendar.SECOND));
 * System.out.println(&quot;MILLISECOND: &quot; + calendar.get(Calendar.MILLISECOND));
 * System.out.println(&quot;ZONE_OFFSET: &quot;
 *                    + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000)));
 * System.out.println(&quot;DST_OFFSET: &quot;
 *                    + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000)));

 * System.out.println(&quot;Current Time, with hour reset to 3&quot;);
 * calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override
 * calendar.set(Calendar.HOUR, 3);
 * System.out.println(&quot;ERA: &quot; + calendar.get(Calendar.ERA));
 * System.out.println(&quot;YEAR: &quot; + calendar.get(Calendar.YEAR));
 * System.out.println(&quot;MONTH: &quot; + calendar.get(Calendar.MONTH));
 * System.out.println(&quot;WEEK_OF_YEAR: &quot; + calendar.get(Calendar.WEEK_OF_YEAR));
 * System.out.println(&quot;WEEK_OF_MONTH: &quot; + calendar.get(Calendar.WEEK_OF_MONTH));
 * System.out.println(&quot;DATE: &quot; + calendar.get(Calendar.DATE));
 * System.out.println(&quot;DAY_OF_MONTH: &quot; + calendar.get(Calendar.DAY_OF_MONTH));
 * System.out.println(&quot;DAY_OF_YEAR: &quot; + calendar.get(Calendar.DAY_OF_YEAR));
 * System.out.println(&quot;DAY_OF_WEEK: &quot; + calendar.get(Calendar.DAY_OF_WEEK));
 * System.out.println(&quot;DAY_OF_WEEK_IN_MONTH: &quot;
 *                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
 * System.out.println(&quot;AM_PM: &quot; + calendar.get(Calendar.AM_PM));
 * System.out.println(&quot;HOUR: &quot; + calendar.get(Calendar.HOUR));
 * System.out.println(&quot;HOUR_OF_DAY: &quot; + calendar.get(Calendar.HOUR_OF_DAY));
 * System.out.println(&quot;MINUTE: &quot; + calendar.get(Calendar.MINUTE));
 * System.out.println(&quot;SECOND: &quot; + calendar.get(Calendar.SECOND));
 * System.out.println(&quot;MILLISECOND: &quot; + calendar.get(Calendar.MILLISECOND));
 * System.out.println(&quot;ZONE_OFFSET: &quot;
 *        + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours
 * System.out.println(&quot;DST_OFFSET: &quot;
 *        + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * @see          TimeZone
 * @author David Goldsmith, Mark Davis, Chen-Lieh Huang, Alan Liu
 * @since JDK1.1
 */
<span class="fc bfc" id="L330" title="All 2 branches covered.">public class GregorianCalendar extends Calendar {</span>
    /*
     * Implementation Notes
     *
     * The epoch is the number of days or milliseconds from some defined
     * starting point. The epoch for java.util.Date is used here; that is,
     * milliseconds from January 1, 1970 (Gregorian), midnight UTC.  Other
     * epochs which are used are January 1, year 1 (Gregorian), which is day 1
     * of the Gregorian calendar, and December 30, year 0 (Gregorian), which is
     * day 1 of the Julian calendar.
     *
     * We implement the proleptic Julian and Gregorian calendars.  This means we
     * implement the modern definition of the calendar even though the
     * historical usage differs.  For example, if the Gregorian change is set
     * to new Date(Long.MIN_VALUE), we have a pure Gregorian calendar which
     * labels dates preceding the invention of the Gregorian calendar in 1582 as
     * if the calendar existed then.
     *
     * Likewise, with the Julian calendar, we assume a consistent
     * 4-year leap year rule, even though the historical pattern of
     * leap years is irregular, being every 3 years from 45 BCE
     * through 9 BCE, then every 4 years from 8 CE onwards, with no
     * leap years in-between.  Thus date computations and functions
     * such as isLeapYear() are not intended to be historically
     * accurate.
     */

//////////////////
// Class Variables
//////////////////

    /**
     * Value of the &lt;code&gt;ERA&lt;/code&gt; field indicating
     * the period before the common era (before Christ), also known as BCE.
     * The sequence of years at the transition from &lt;code&gt;BC&lt;/code&gt; to &lt;code&gt;AD&lt;/code&gt; is
     * ..., 2 BC, 1 BC, 1 AD, 2 AD,...
     *
     * @see #ERA
     */
    public static final int BC = 0;

    /**
     * Value of the {@link #ERA} field indicating
     * the period before the common era, the same value as {@link #BC}.
     *
     * @see #CE
     */
    static final int BCE = 0;

    /**
     * Value of the &lt;code&gt;ERA&lt;/code&gt; field indicating
     * the common era (Anno Domini), also known as CE.
     * The sequence of years at the transition from &lt;code&gt;BC&lt;/code&gt; to &lt;code&gt;AD&lt;/code&gt; is
     * ..., 2 BC, 1 BC, 1 AD, 2 AD,...
     *
     * @see #ERA
     */
    public static final int AD = 1;

    /**
     * Value of the {@link #ERA} field indicating
     * the common era, the same value as {@link #AD}.
     *
     * @see #BCE
     */
    static final int CE = 1;

    private static final int EPOCH_OFFSET   = 719163; // Fixed date of January 1, 1970 (Gregorian)
    private static final int EPOCH_YEAR     = 1970;

<span class="fc" id="L400">    static final int MONTH_LENGTH[]</span>
        = {31,28,31,30,31,30,31,31,30,31,30,31}; // 0-based
<span class="fc" id="L402">    static final int LEAP_MONTH_LENGTH[]</span>
        = {31,29,31,30,31,30,31,31,30,31,30,31}; // 0-based

    // Useful millisecond constants.  Although ONE_DAY and ONE_WEEK can fit
    // into ints, they must be longs in order to prevent arithmetic overflow
    // when performing (bug 4173516).
    private static final int  ONE_SECOND = 1000;
    private static final int  ONE_MINUTE = 60*ONE_SECOND;
    private static final int  ONE_HOUR   = 60*ONE_MINUTE;
    private static final long ONE_DAY    = 24*ONE_HOUR;
    private static final long ONE_WEEK   = 7*ONE_DAY;

    /*
     * &lt;pre&gt;
     *                            Greatest       Least
     * Field name        Minimum   Minimum     Maximum     Maximum
     * ----------        -------   -------     -------     -------
     * ERA                     0         0           1           1
     * YEAR                    1         1   292269054   292278994
     * MONTH                   0         0          11          11
     * WEEK_OF_YEAR            1         1          52*         53
     * WEEK_OF_MONTH           0         0           4*          6
     * DAY_OF_MONTH            1         1          28*         31
     * DAY_OF_YEAR             1         1         365*        366
     * DAY_OF_WEEK             1         1           7           7
     * DAY_OF_WEEK_IN_MONTH   -1        -1           4*          6
     * AM_PM                   0         0           1           1
     * HOUR                    0         0          11          11
     * HOUR_OF_DAY             0         0          23          23
     * MINUTE                  0         0          59          59
     * SECOND                  0         0          59          59
     * MILLISECOND             0         0         999         999
     * ZONE_OFFSET        -13:00    -13:00       14:00       14:00
     * DST_OFFSET           0:00      0:00        0:20        2:00
     * &lt;/pre&gt;
     * *: depends on the Gregorian change date
     */
<span class="fc" id="L439">    static final int MIN_VALUES[] = {</span>
        BCE,            // ERA
        1,              // YEAR
        JANUARY,        // MONTH
        1,              // WEEK_OF_YEAR
        0,              // WEEK_OF_MONTH
        1,              // DAY_OF_MONTH
        1,              // DAY_OF_YEAR
        SUNDAY,         // DAY_OF_WEEK
        1,              // DAY_OF_WEEK_IN_MONTH
        AM,             // AM_PM
        0,              // HOUR
        0,              // HOUR_OF_DAY
        0,              // MINUTE
        0,              // SECOND
        0,              // MILLISECOND
        -13*ONE_HOUR,   // ZONE_OFFSET (UNIX compatibility)
        0               // DST_OFFSET
    };
<span class="fc" id="L458">    static final int LEAST_MAX_VALUES[] = {</span>
        CE,             // ERA
        292269054,      // YEAR
        DECEMBER,       // MONTH
        52,             // WEEK_OF_YEAR
        4,              // WEEK_OF_MONTH
        28,             // DAY_OF_MONTH
        365,            // DAY_OF_YEAR
        SATURDAY,       // DAY_OF_WEEK
        4,              // DAY_OF_WEEK_IN
        PM,             // AM_PM
        11,             // HOUR
        23,             // HOUR_OF_DAY
        59,             // MINUTE
        59,             // SECOND
        999,            // MILLISECOND
        14*ONE_HOUR,    // ZONE_OFFSET
        20*ONE_MINUTE   // DST_OFFSET (historical least maximum)
    };
<span class="fc" id="L477">    static final int MAX_VALUES[] = {</span>
        CE,             // ERA
        292278994,      // YEAR
        DECEMBER,       // MONTH
        53,             // WEEK_OF_YEAR
        6,              // WEEK_OF_MONTH
        31,             // DAY_OF_MONTH
        366,            // DAY_OF_YEAR
        SATURDAY,       // DAY_OF_WEEK
        6,              // DAY_OF_WEEK_IN
        PM,             // AM_PM
        11,             // HOUR
        23,             // HOUR_OF_DAY
        59,             // MINUTE
        59,             // SECOND
        999,            // MILLISECOND
        14*ONE_HOUR,    // ZONE_OFFSET
        2*ONE_HOUR      // DST_OFFSET (double summer time)
    };

    // Proclaim serialization compatibility with JDK 1.1
    @SuppressWarnings(&quot;FieldNameHidesFieldInSuperclass&quot;)
    static final long serialVersionUID = -8125100834729963327L;

    // Reference to the sun.util.calendar.Gregorian instance (singleton).
<span class="fc" id="L502">    private static final Gregorian gcal =</span>
<span class="fc" id="L503">                                CalendarSystem.getGregorianCalendar();</span>

    // Reference to the JulianCalendar instance (singleton), set as needed. See
    // getJulianCalendarSystem().
    private static JulianCalendar jcal;

    // JulianCalendar eras. See getJulianCalendarSystem().
    private static Era[] jeras;

    // The default value of gregorianCutover.
    static final long DEFAULT_GREGORIAN_CUTOVER = -12219292800000L;

/////////////////////
// Instance Variables
/////////////////////

    /**
     * The point at which the Gregorian calendar rules are used, measured in
     * milliseconds from the standard epoch.  Default is October 15, 1582
     * (Gregorian) 00:00:00 UTC or -12219292800000L.  For this value, October 4,
     * 1582 (Julian) is followed by October 15, 1582 (Gregorian).  This
     * corresponds to Julian day number 2299161.
     * @serial
     */
<span class="fc" id="L527">    private long gregorianCutover = DEFAULT_GREGORIAN_CUTOVER;</span>

    /**
     * The fixed date of the gregorianCutover.
     */
<span class="fc" id="L532">    private transient long gregorianCutoverDate =</span>
        (((DEFAULT_GREGORIAN_CUTOVER + 1)/ONE_DAY) - 1) + EPOCH_OFFSET; // == 577736

    /**
     * The normalized year of the gregorianCutover in Gregorian, with
     * 0 representing 1 BCE, -1 representing 2 BCE, etc.
     */
<span class="fc" id="L539">    private transient int gregorianCutoverYear = 1582;</span>

    /**
     * The normalized year of the gregorianCutover in Julian, with 0
     * representing 1 BCE, -1 representing 2 BCE, etc.
     */
<span class="fc" id="L545">    private transient int gregorianCutoverYearJulian = 1582;</span>

    /**
     * gdate always has a sun.util.calendar.Gregorian.Date instance to
     * avoid overhead of creating it. The assumption is that most
     * applications will need only Gregorian calendar calculations.
     */
    private transient BaseCalendar.Date gdate;

    /**
     * Reference to either gdate or a JulianCalendar.Date
     * instance. After calling complete(), this value is guaranteed to
     * be set.
     */
    private transient BaseCalendar.Date cdate;

    /**
     * The CalendarSystem used to calculate the date in cdate. After
     * calling complete(), this value is guaranteed to be set and
     * consistent with the cdate value.
     */
    private transient BaseCalendar calsys;

    /**
     * Temporary int[2] to get time zone offsets. zoneOffsets[0] gets
     * the GMT offset value and zoneOffsets[1] gets the DST saving
     * value.
     */
    private transient int[] zoneOffsets;

    /**
     * Temporary storage for saving original fields[] values in
     * non-lenient mode.
     */
    private transient int[] originalFields;

///////////////
// Constructors
///////////////

    /**
     * Constructs a default &lt;code&gt;GregorianCalendar&lt;/code&gt; using the current time
     * in the default time zone with the default
     * {@link Locale.Category#FORMAT FORMAT} locale.
     */
    public GregorianCalendar() {
<span class="fc" id="L591">        this(TimeZone.getDefaultRef(), Locale.getDefault(Locale.Category.FORMAT));</span>
<span class="fc" id="L592">        setZoneShared(true);</span>
<span class="fc" id="L593">    }</span>

    /**
     * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; based on the current time
     * in the given time zone with the default
     * {@link Locale.Category#FORMAT FORMAT} locale.
     *
     * @param zone the given time zone.
     */
    public GregorianCalendar(TimeZone zone) {
<span class="fc" id="L603">        this(zone, Locale.getDefault(Locale.Category.FORMAT));</span>
<span class="fc" id="L604">    }</span>

    /**
     * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; based on the current time
     * in the default time zone with the given locale.
     *
     * @param aLocale the given locale.
     */
    public GregorianCalendar(Locale aLocale) {
<span class="nc" id="L613">        this(TimeZone.getDefaultRef(), aLocale);</span>
<span class="nc" id="L614">        setZoneShared(true);</span>
<span class="nc" id="L615">    }</span>

    /**
     * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; based on the current time
     * in the given time zone with the given locale.
     *
     * @param zone the given time zone.
     * @param aLocale the given locale.
     */
    public GregorianCalendar(TimeZone zone, Locale aLocale) {
<span class="fc" id="L625">        super(zone, aLocale);</span>
<span class="fc" id="L626">        gdate = (BaseCalendar.Date) gcal.newCalendarDate(zone);</span>
<span class="fc" id="L627">        setTimeInMillis(System.currentTimeMillis());</span>
<span class="fc" id="L628">    }</span>

    /**
     * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; with the given date set
     * in the default time zone with the default locale.
     *
     * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field in the calendar.
     * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field in the calendar.
     * Month value is 0-based. e.g., 0 for January.
     * @param dayOfMonth the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field in the calendar.
     */
    public GregorianCalendar(int year, int month, int dayOfMonth) {
<span class="fc" id="L640">        this(year, month, dayOfMonth, 0, 0, 0, 0);</span>
<span class="fc" id="L641">    }</span>

    /**
     * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; with the given date
     * and time set for the default time zone with the default locale.
     *
     * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field in the calendar.
     * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field in the calendar.
     * Month value is 0-based. e.g., 0 for January.
     * @param dayOfMonth the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field in the calendar.
     * @param hourOfDay the value used to set the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; calendar field
     * in the calendar.
     * @param minute the value used to set the &lt;code&gt;MINUTE&lt;/code&gt; calendar field
     * in the calendar.
     */
    public GregorianCalendar(int year, int month, int dayOfMonth, int hourOfDay,
                             int minute) {
<span class="nc" id="L658">        this(year, month, dayOfMonth, hourOfDay, minute, 0, 0);</span>
<span class="nc" id="L659">    }</span>

    /**
     * Constructs a GregorianCalendar with the given date
     * and time set for the default time zone with the default locale.
     *
     * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field in the calendar.
     * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field in the calendar.
     * Month value is 0-based. e.g., 0 for January.
     * @param dayOfMonth the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field in the calendar.
     * @param hourOfDay the value used to set the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; calendar field
     * in the calendar.
     * @param minute the value used to set the &lt;code&gt;MINUTE&lt;/code&gt; calendar field
     * in the calendar.
     * @param second the value used to set the &lt;code&gt;SECOND&lt;/code&gt; calendar field
     * in the calendar.
     */
    public GregorianCalendar(int year, int month, int dayOfMonth, int hourOfDay,
                             int minute, int second) {
<span class="fc" id="L678">        this(year, month, dayOfMonth, hourOfDay, minute, second, 0);</span>
<span class="fc" id="L679">    }</span>

    /**
     * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; with the given date
     * and time set for the default time zone with the default locale.
     *
     * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field in the calendar.
     * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field in the calendar.
     * Month value is 0-based. e.g., 0 for January.
     * @param dayOfMonth the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field in the calendar.
     * @param hourOfDay the value used to set the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; calendar field
     * in the calendar.
     * @param minute the value used to set the &lt;code&gt;MINUTE&lt;/code&gt; calendar field
     * in the calendar.
     * @param second the value used to set the &lt;code&gt;SECOND&lt;/code&gt; calendar field
     * in the calendar.
     * @param millis the value used to set the &lt;code&gt;MILLISECOND&lt;/code&gt; calendar field
     */
    GregorianCalendar(int year, int month, int dayOfMonth,
                      int hourOfDay, int minute, int second, int millis) {
<span class="fc" id="L699">        super();</span>
<span class="fc" id="L700">        gdate = (BaseCalendar.Date) gcal.newCalendarDate(getZone());</span>
<span class="fc" id="L701">        this.set(YEAR, year);</span>
<span class="fc" id="L702">        this.set(MONTH, month);</span>
<span class="fc" id="L703">        this.set(DAY_OF_MONTH, dayOfMonth);</span>

        // Set AM_PM and HOUR here to set their stamp values before
        // setting HOUR_OF_DAY (6178071).
<span class="pc bpc" id="L707" title="1 of 4 branches missed.">        if (hourOfDay &gt;= 12 &amp;&amp; hourOfDay &lt;= 23) {</span>
            // If hourOfDay is a valid PM hour, set the correct PM values
            // so that it won't throw an exception in case it's set to
            // non-lenient later.
<span class="fc" id="L711">            this.internalSet(AM_PM, PM);</span>
<span class="fc" id="L712">            this.internalSet(HOUR, hourOfDay - 12);</span>
        } else {
            // The default value for AM_PM is AM.
            // We don't care any out of range value here for leniency.
<span class="fc" id="L716">            this.internalSet(HOUR, hourOfDay);</span>
        }
        // The stamp values of AM_PM and HOUR must be COMPUTED. (6440854)
<span class="fc" id="L719">        setFieldsComputed(HOUR_MASK|AM_PM_MASK);</span>

<span class="fc" id="L721">        this.set(HOUR_OF_DAY, hourOfDay);</span>
<span class="fc" id="L722">        this.set(MINUTE, minute);</span>
<span class="fc" id="L723">        this.set(SECOND, second);</span>
        // should be changed to set() when this constructor is made
        // public.
<span class="fc" id="L726">        this.internalSet(MILLISECOND, millis);</span>
<span class="fc" id="L727">    }</span>

    /**
     * Constructs an empty GregorianCalendar.
     *
     * @param zone    the given time zone
     * @param aLocale the given locale
     * @param flag    the flag requesting an empty instance
     */
    GregorianCalendar(TimeZone zone, Locale locale, boolean flag) {
<span class="fc" id="L737">        super(zone, locale);</span>
<span class="fc" id="L738">        gdate = (BaseCalendar.Date) gcal.newCalendarDate(getZone());</span>
<span class="fc" id="L739">    }</span>

/////////////////
// Public methods
/////////////////

    /**
     * Sets the &lt;code&gt;GregorianCalendar&lt;/code&gt; change date. This is the point when the switch
     * from Julian dates to Gregorian dates occurred. Default is October 15,
     * 1582 (Gregorian). Previous to this, dates will be in the Julian calendar.
     * &lt;p&gt;
     * To obtain a pure Julian calendar, set the change date to
     * &lt;code&gt;Date(Long.MAX_VALUE)&lt;/code&gt;.  To obtain a pure Gregorian calendar,
     * set the change date to &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt;.
     *
     * @param date the given Gregorian cutover date.
     */
    public void setGregorianChange(Date date) {
<span class="nc" id="L757">        long cutoverTime = date.getTime();</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (cutoverTime == gregorianCutover) {</span>
<span class="nc" id="L759">            return;</span>
        }
        // Before changing the cutover date, make sure to have the
        // time of this calendar.
<span class="nc" id="L763">        complete();</span>
<span class="nc" id="L764">        setGregorianChange(cutoverTime);</span>
<span class="nc" id="L765">    }</span>

    private void setGregorianChange(long cutoverTime) {
<span class="nc" id="L768">        gregorianCutover = cutoverTime;</span>
<span class="nc" id="L769">        gregorianCutoverDate = CalendarUtils.floorDivide(cutoverTime, ONE_DAY)</span>
                                + EPOCH_OFFSET;

        // To provide the &quot;pure&quot; Julian calendar as advertised.
        // Strictly speaking, the last millisecond should be a
        // Gregorian date. However, the API doc specifies that setting
        // the cutover date to Long.MAX_VALUE will make this calendar
        // a pure Julian calendar. (See 4167995)
<span class="nc bnc" id="L777" title="All 2 branches missed.">        if (cutoverTime == Long.MAX_VALUE) {</span>
<span class="nc" id="L778">            gregorianCutoverDate++;</span>
        }

<span class="nc" id="L781">        BaseCalendar.Date d = getGregorianCutoverDate();</span>

        // Set the cutover year (in the Gregorian year numbering)
<span class="nc" id="L784">        gregorianCutoverYear = d.getYear();</span>

<span class="nc" id="L786">        BaseCalendar julianCal = getJulianCalendarSystem();</span>
<span class="nc" id="L787">        d = (BaseCalendar.Date) julianCal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="nc" id="L788">        julianCal.getCalendarDateFromFixedDate(d, gregorianCutoverDate - 1);</span>
<span class="nc" id="L789">        gregorianCutoverYearJulian = d.getNormalizedYear();</span>

<span class="nc bnc" id="L791" title="All 2 branches missed.">        if (time &lt; gregorianCutover) {</span>
            // The field values are no longer valid under the new
            // cutover date.
<span class="nc" id="L794">            setUnnormalized();</span>
        }
<span class="nc" id="L796">    }</span>

    /**
     * Gets the Gregorian Calendar change date.  This is the point when the
     * switch from Julian dates to Gregorian dates occurred. Default is
     * October 15, 1582 (Gregorian). Previous to this, dates will be in the Julian
     * calendar.
     *
     * @return the Gregorian cutover date for this &lt;code&gt;GregorianCalendar&lt;/code&gt; object.
     */
    public final Date getGregorianChange() {
<span class="nc" id="L807">        return new Date(gregorianCutover);</span>
    }

    /**
     * Determines if the given year is a leap year. Returns &lt;code&gt;true&lt;/code&gt; if
     * the given year is a leap year. To specify BC year numbers,
     * &lt;code&gt;1 - year number&lt;/code&gt; must be given. For example, year BC 4 is
     * specified as -3.
     *
     * @param year the given year.
     * @return &lt;code&gt;true&lt;/code&gt; if the given year is a leap year; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isLeapYear(int year) {
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">        if ((year &amp; 3) != 0) {</span>
<span class="fc" id="L821">            return false;</span>
        }

<span class="nc bnc" id="L824" title="All 2 branches missed.">        if (year &gt; gregorianCutoverYear) {</span>
<span class="nc bnc" id="L825" title="All 4 branches missed.">            return (year%100 != 0) || (year%400 == 0); // Gregorian</span>
        }
<span class="nc bnc" id="L827" title="All 2 branches missed.">        if (year &lt; gregorianCutoverYearJulian) {</span>
<span class="nc" id="L828">            return true; // Julian</span>
        }
        boolean gregorian;
        // If the given year is the Gregorian cutover year, we need to
        // determine which calendar system to be applied to February in the year.
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (gregorianCutoverYear == gregorianCutoverYearJulian) {</span>
<span class="nc" id="L834">            BaseCalendar.Date d = getCalendarDate(gregorianCutoverDate); // Gregorian</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">            gregorian = d.getMonth() &lt; BaseCalendar.MARCH;</span>
<span class="nc" id="L836">        } else {</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">            gregorian = year == gregorianCutoverYear;</span>
        }
<span class="nc bnc" id="L839" title="All 6 branches missed.">        return gregorian ? (year%100 != 0) || (year%400 == 0) : true;</span>
    }

    /**
     * Returns {@code &quot;gregory&quot;} as the calendar type.
     *
     * @return {@code &quot;gregory&quot;}
     * @since 1.8
     */
    @Override
    public String getCalendarType() {
<span class="fc" id="L850">        return &quot;gregory&quot;;</span>
    }

    /**
     * Compares this &lt;code&gt;GregorianCalendar&lt;/code&gt; to the specified
     * &lt;code&gt;Object&lt;/code&gt;. The result is &lt;code&gt;true&lt;/code&gt; if and
     * only if the argument is a &lt;code&gt;GregorianCalendar&lt;/code&gt; object
     * that represents the same time value (millisecond offset from
     * the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;) under the same
     * &lt;code&gt;Calendar&lt;/code&gt; parameters and Gregorian change date as
     * this object.
     *
     * @param obj the object to compare with.
     * @return &lt;code&gt;true&lt;/code&gt; if this object is equal to &lt;code&gt;obj&lt;/code&gt;;
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see Calendar#compareTo(Calendar)
     */
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L869" title="All 2 branches missed.">        return obj instanceof GregorianCalendar &amp;&amp;</span>
<span class="nc bnc" id="L870" title="All 4 branches missed.">            super.equals(obj) &amp;&amp;</span>
            gregorianCutover == ((GregorianCalendar)obj).gregorianCutover;
    }

    /**
     * Generates the hash code for this &lt;code&gt;GregorianCalendar&lt;/code&gt; object.
     */
    @Override
    public int hashCode() {
<span class="nc" id="L879">        return super.hashCode() ^ (int)gregorianCutoverDate;</span>
    }

    /**
     * Adds the specified (signed) amount of time to the given calendar field,
     * based on the calendar's rules.
     *
     * &lt;p&gt;&lt;em&gt;Add rule 1&lt;/em&gt;. The value of &lt;code&gt;field&lt;/code&gt;
     * after the call minus the value of &lt;code&gt;field&lt;/code&gt; before the
     * call is &lt;code&gt;amount&lt;/code&gt;, modulo any overflow that has occurred in
     * &lt;code&gt;field&lt;/code&gt;. Overflow occurs when a field value exceeds its
     * range and, as a result, the next larger field is incremented or
     * decremented and the field value is adjusted back into its range.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;em&gt;Add rule 2&lt;/em&gt;. If a smaller field is expected to be
     * invariant, but it is impossible for it to be equal to its
     * prior value because of changes in its minimum or maximum after
     * &lt;code&gt;field&lt;/code&gt; is changed, then its value is adjusted to be as close
     * as possible to its expected value. A smaller field represents a
     * smaller unit of time. &lt;code&gt;HOUR&lt;/code&gt; is a smaller field than
     * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;. No adjustment is made to smaller fields
     * that are not expected to be invariant. The calendar system
     * determines what fields are expected to be invariant.&lt;/p&gt;
     *
     * @param field the calendar field.
     * @param amount the amount of date or time to be added to the field.
     * @exception IllegalArgumentException if &lt;code&gt;field&lt;/code&gt; is
     * &lt;code&gt;ZONE_OFFSET&lt;/code&gt;, &lt;code&gt;DST_OFFSET&lt;/code&gt;, or unknown,
     * or if any calendar fields have out-of-range values in
     * non-lenient mode.
     */
    @Override
    public void add(int field, int amount) {
        // If amount == 0, do nothing even the given field is out of
        // range. This is tested by JCK.
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">        if (amount == 0) {</span>
<span class="nc" id="L915">            return;   // Do nothing!</span>
        }

<span class="pc bpc" id="L918" title="2 of 4 branches missed.">        if (field &lt; 0 || field &gt;= ZONE_OFFSET) {</span>
<span class="nc" id="L919">            throw new IllegalArgumentException();</span>
        }

        // Sync the time and calendar fields.
<span class="fc" id="L923">        complete();</span>

<span class="fc bfc" id="L925" title="All 2 branches covered.">        if (field == YEAR) {</span>
<span class="fc" id="L926">            int year = internalGet(YEAR);</span>
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">            if (internalGetEra() == CE) {</span>
<span class="fc" id="L928">                year += amount;</span>
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">                if (year &gt; 0) {</span>
<span class="fc" id="L930">                    set(YEAR, year);</span>
                } else { // year &lt;= 0
<span class="nc" id="L932">                    set(YEAR, 1 - year);</span>
                    // if year == 0, you get 1 BCE.
<span class="nc" id="L934">                    set(ERA, BCE);</span>
                }
            }
            else { // era == BCE
<span class="nc" id="L938">                year -= amount;</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">                if (year &gt; 0) {</span>
<span class="nc" id="L940">                    set(YEAR, year);</span>
                } else { // year &lt;= 0
<span class="nc" id="L942">                    set(YEAR, 1 - year);</span>
                    // if year == 0, you get 1 CE
<span class="nc" id="L944">                    set(ERA, CE);</span>
                }
            }
<span class="fc" id="L947">            pinDayOfMonth();</span>
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">        } else if (field == MONTH) {</span>
<span class="nc" id="L949">            int month = internalGet(MONTH) + amount;</span>
<span class="nc" id="L950">            int year = internalGet(YEAR);</span>
            int y_amount;

<span class="nc bnc" id="L953" title="All 2 branches missed.">            if (month &gt;= 0) {</span>
<span class="nc" id="L954">                y_amount = month/12;</span>
            } else {
<span class="nc" id="L956">                y_amount = (month+1)/12 - 1;</span>
            }
<span class="nc bnc" id="L958" title="All 2 branches missed.">            if (y_amount != 0) {</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">                if (internalGetEra() == CE) {</span>
<span class="nc" id="L960">                    year += y_amount;</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">                    if (year &gt; 0) {</span>
<span class="nc" id="L962">                        set(YEAR, year);</span>
                    } else { // year &lt;= 0
<span class="nc" id="L964">                        set(YEAR, 1 - year);</span>
                        // if year == 0, you get 1 BCE
<span class="nc" id="L966">                        set(ERA, BCE);</span>
                    }
                }
                else { // era == BCE
<span class="nc" id="L970">                    year -= y_amount;</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">                    if (year &gt; 0) {</span>
<span class="nc" id="L972">                        set(YEAR, year);</span>
                    } else { // year &lt;= 0
<span class="nc" id="L974">                        set(YEAR, 1 - year);</span>
                        // if year == 0, you get 1 CE
<span class="nc" id="L976">                        set(ERA, CE);</span>
                    }
                }
            }

<span class="nc bnc" id="L981" title="All 2 branches missed.">            if (month &gt;= 0) {</span>
<span class="nc" id="L982">                set(MONTH,  month % 12);</span>
            } else {
                // month &lt; 0
<span class="nc" id="L985">                month %= 12;</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">                if (month &lt; 0) {</span>
<span class="nc" id="L987">                    month += 12;</span>
                }
<span class="nc" id="L989">                set(MONTH, JANUARY + month);</span>
            }
<span class="nc" id="L991">            pinDayOfMonth();</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">        } else if (field == ERA) {</span>
<span class="nc" id="L993">            int era = internalGet(ERA) + amount;</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">            if (era &lt; 0) {</span>
<span class="nc" id="L995">                era = 0;</span>
            }
<span class="nc bnc" id="L997" title="All 2 branches missed.">            if (era &gt; 1) {</span>
<span class="nc" id="L998">                era = 1;</span>
            }
<span class="nc" id="L1000">            set(ERA, era);</span>
<span class="nc" id="L1001">        } else {</span>
<span class="fc" id="L1002">            long delta = amount;</span>
<span class="fc" id="L1003">            long timeOfDay = 0;</span>
<span class="pc bpc" id="L1004" title="7 of 8 branches missed.">            switch (field) {</span>
            // Handle the time fields here. Convert the given
            // amount to milliseconds and call setTimeInMillis.
            case HOUR:
            case HOUR_OF_DAY:
<span class="nc" id="L1009">                delta *= 60 * 60 * 1000;        // hours to minutes</span>
<span class="nc" id="L1010">                break;</span>

            case MINUTE:
<span class="nc" id="L1013">                delta *= 60 * 1000;             // minutes to seconds</span>
<span class="nc" id="L1014">                break;</span>

            case SECOND:
<span class="nc" id="L1017">                delta *= 1000;                  // seconds to milliseconds</span>
<span class="nc" id="L1018">                break;</span>

            case MILLISECOND:
<span class="nc" id="L1021">                break;</span>

            // Handle week, day and AM_PM fields which involves
            // time zone offset change adjustment. Convert the
            // given amount to the number of days.
            case WEEK_OF_YEAR:
            case WEEK_OF_MONTH:
            case DAY_OF_WEEK_IN_MONTH:
<span class="nc" id="L1029">                delta *= 7;</span>
<span class="nc" id="L1030">                break;</span>

            case DAY_OF_MONTH: // synonym of DATE
            case DAY_OF_YEAR:
            case DAY_OF_WEEK:
<span class="fc" id="L1035">                break;</span>

            case AM_PM:
                // Convert the amount to the number of days (delta)
                // and +12 or -12 hours (timeOfDay).
<span class="nc" id="L1040">                delta = amount / 2;</span>
<span class="nc" id="L1041">                timeOfDay = 12 * (amount % 2);</span>
                break;
            }

            // The time fields don't require time zone offset change
            // adjustment.
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">            if (field &gt;= HOUR) {</span>
<span class="nc" id="L1048">                setTimeInMillis(time + delta);</span>
<span class="nc" id="L1049">                return;</span>
            }

            // The rest of the fields (week, day or AM_PM fields)
            // require time zone offset (both GMT and DST) change
            // adjustment.

            // Translate the current time to the fixed date and time
            // of the day.
<span class="fc" id="L1058">            long fd = getCurrentFixedDate();</span>
<span class="fc" id="L1059">            timeOfDay += internalGet(HOUR_OF_DAY);</span>
<span class="fc" id="L1060">            timeOfDay *= 60;</span>
<span class="fc" id="L1061">            timeOfDay += internalGet(MINUTE);</span>
<span class="fc" id="L1062">            timeOfDay *= 60;</span>
<span class="fc" id="L1063">            timeOfDay += internalGet(SECOND);</span>
<span class="fc" id="L1064">            timeOfDay *= 1000;</span>
<span class="fc" id="L1065">            timeOfDay += internalGet(MILLISECOND);</span>
<span class="pc bpc" id="L1066" title="1 of 2 branches missed.">            if (timeOfDay &gt;= ONE_DAY) {</span>
<span class="nc" id="L1067">                fd++;</span>
<span class="nc" id="L1068">                timeOfDay -= ONE_DAY;</span>
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">            } else if (timeOfDay &lt; 0) {</span>
<span class="nc" id="L1070">                fd--;</span>
<span class="nc" id="L1071">                timeOfDay += ONE_DAY;</span>
            }

<span class="fc" id="L1074">            fd += delta; // fd is the expected fixed date after the calculation</span>
<span class="fc" id="L1075">            int zoneOffset = internalGet(ZONE_OFFSET) + internalGet(DST_OFFSET);</span>
<span class="fc" id="L1076">            setTimeInMillis((fd - EPOCH_OFFSET) * ONE_DAY + timeOfDay - zoneOffset);</span>
<span class="fc" id="L1077">            zoneOffset -= internalGet(ZONE_OFFSET) + internalGet(DST_OFFSET);</span>
            // If the time zone offset has changed, then adjust the difference.
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">            if (zoneOffset != 0) {</span>
<span class="nc" id="L1080">                setTimeInMillis(time + zoneOffset);</span>
<span class="nc" id="L1081">                long fd2 = getCurrentFixedDate();</span>
                // If the adjustment has changed the date, then take
                // the previous one.
<span class="nc bnc" id="L1084" title="All 2 branches missed.">                if (fd2 != fd) {</span>
<span class="nc" id="L1085">                    setTimeInMillis(time - zoneOffset);</span>
                }
            }
        }
<span class="fc" id="L1089">    }</span>

    /**
     * Adds or subtracts (up/down) a single unit of time on the given time
     * field without changing larger fields.
     * &lt;p&gt;
     * &lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;
     * originally set to December 31, 1999. Calling {@link #roll(int,boolean) roll(Calendar.MONTH, true)}
     * sets the calendar to January 31, 1999.  The &lt;code&gt;YEAR&lt;/code&gt; field is unchanged
     * because it is a larger field than &lt;code&gt;MONTH&lt;/code&gt;.&lt;/p&gt;
     *
     * @param up indicates if the value of the specified calendar field is to be
     * rolled up or rolled down. Use &lt;code&gt;true&lt;/code&gt; if rolling up, &lt;code&gt;false&lt;/code&gt; otherwise.
     * @exception IllegalArgumentException if &lt;code&gt;field&lt;/code&gt; is
     * &lt;code&gt;ZONE_OFFSET&lt;/code&gt;, &lt;code&gt;DST_OFFSET&lt;/code&gt;, or unknown,
     * or if any calendar fields have out-of-range values in
     * non-lenient mode.
     * @see #add(int,int)
     * @see #set(int,int)
     */
    @Override
    public void roll(int field, boolean up) {
<span class="nc bnc" id="L1111" title="All 2 branches missed.">        roll(field, up ? +1 : -1);</span>
<span class="nc" id="L1112">    }</span>

    /**
     * Adds a signed amount to the specified calendar field without changing larger fields.
     * A negative roll amount means to subtract from field without changing
     * larger fields. If the specified amount is 0, this method performs nothing.
     *
     * &lt;p&gt;This method calls {@link #complete()} before adding the
     * amount so that all the calendar fields are normalized. If there
     * is any calendar field having an out-of-range value in non-lenient mode, then an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt;
     * &lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;
     * originally set to August 31, 1999. Calling &lt;code&gt;roll(Calendar.MONTH,
     * 8)&lt;/code&gt; sets the calendar to April 30, &lt;strong&gt;1999&lt;/strong&gt;. Using a
     * &lt;code&gt;GregorianCalendar&lt;/code&gt;, the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; field cannot
     * be 31 in the month April. &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; is set to the closest possible
     * value, 30. The &lt;code&gt;YEAR&lt;/code&gt; field maintains the value of 1999 because it
     * is a larger field than &lt;code&gt;MONTH&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;
     * originally set to Sunday June 6, 1999. Calling
     * &lt;code&gt;roll(Calendar.WEEK_OF_MONTH, -1)&lt;/code&gt; sets the calendar to
     * Tuesday June 1, 1999, whereas calling
     * &lt;code&gt;add(Calendar.WEEK_OF_MONTH, -1)&lt;/code&gt; sets the calendar to
     * Sunday May 30, 1999. This is because the roll rule imposes an
     * additional constraint: The &lt;code&gt;MONTH&lt;/code&gt; must not change when the
     * &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; is rolled. Taken together with add rule 1,
     * the resultant date must be between Tuesday June 1 and Saturday June
     * 5. According to add rule 2, the &lt;code&gt;DAY_OF_WEEK&lt;/code&gt;, an invariant
     * when changing the &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt;, is set to Tuesday, the
     * closest possible value to Sunday (where Sunday is the first day of the
     * week).&lt;/p&gt;
     *
     * @param field the calendar field.
     * @param amount the signed amount to add to &lt;code&gt;field&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;field&lt;/code&gt; is
     * &lt;code&gt;ZONE_OFFSET&lt;/code&gt;, &lt;code&gt;DST_OFFSET&lt;/code&gt;, or unknown,
     * or if any calendar fields have out-of-range values in
     * non-lenient mode.
     * @see #roll(int,boolean)
     * @see #add(int,int)
     * @see #set(int,int)
     * @since 1.2
     */
    @Override
    public void roll(int field, int amount) {
        // If amount == 0, do nothing even the given field is out of
        // range. This is tested by JCK.
<span class="nc bnc" id="L1162" title="All 2 branches missed.">        if (amount == 0) {</span>
<span class="nc" id="L1163">            return;</span>
        }

<span class="nc bnc" id="L1166" title="All 4 branches missed.">        if (field &lt; 0 || field &gt;= ZONE_OFFSET) {</span>
<span class="nc" id="L1167">            throw new IllegalArgumentException();</span>
        }

        // Sync the time and calendar fields.
<span class="nc" id="L1171">        complete();</span>

<span class="nc" id="L1173">        int min = getMinimum(field);</span>
<span class="nc" id="L1174">        int max = getMaximum(field);</span>

<span class="nc bnc" id="L1176" title="All 10 branches missed.">        switch (field) {</span>
        case AM_PM:
        case ERA:
        case YEAR:
        case MINUTE:
        case SECOND:
        case MILLISECOND:
            // These fields are handled simply, since they have fixed minima
            // and maxima.  The field DAY_OF_MONTH is almost as simple.  Other
            // fields are complicated, since the range within they must roll
            // varies depending on the date.
<span class="nc" id="L1187">            break;</span>

        case HOUR:
        case HOUR_OF_DAY:
            {
<span class="nc" id="L1192">                int unit = max + 1; // 12 or 24 hours</span>
<span class="nc" id="L1193">                int h = internalGet(field);</span>
<span class="nc" id="L1194">                int nh = (h + amount) % unit;</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">                if (nh &lt; 0) {</span>
<span class="nc" id="L1196">                    nh += unit;</span>
                }
<span class="nc" id="L1198">                time += ONE_HOUR * (nh - h);</span>

                // The day might have changed, which could happen if
                // the daylight saving time transition brings it to
                // the next day, although it's very unlikely. But we
                // have to make sure not to change the larger fields.
<span class="nc" id="L1204">                CalendarDate d = calsys.getCalendarDate(time, getZone());</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">                if (internalGet(DAY_OF_MONTH) != d.getDayOfMonth()) {</span>
<span class="nc" id="L1206">                    d.setDate(internalGet(YEAR),</span>
<span class="nc" id="L1207">                              internalGet(MONTH) + 1,</span>
<span class="nc" id="L1208">                              internalGet(DAY_OF_MONTH));</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">                    if (field == HOUR) {</span>
<span class="nc bnc" id="L1210" title="All 4 branches missed.">                        assert (internalGet(AM_PM) == PM);</span>
<span class="nc" id="L1211">                        d.addHours(+12); // restore PM</span>
                    }
<span class="nc" id="L1213">                    time = calsys.getTime(d);</span>
                }
<span class="nc" id="L1215">                int hourOfDay = d.getHours();</span>
<span class="nc" id="L1216">                internalSet(field, hourOfDay % unit);</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">                if (field == HOUR) {</span>
<span class="nc" id="L1218">                    internalSet(HOUR_OF_DAY, hourOfDay);</span>
                } else {
<span class="nc" id="L1220">                    internalSet(AM_PM, hourOfDay / 12);</span>
<span class="nc" id="L1221">                    internalSet(HOUR, hourOfDay % 12);</span>
                }

                // Time zone offset and/or daylight saving might have changed.
<span class="nc" id="L1225">                int zoneOffset = d.getZoneOffset();</span>
<span class="nc" id="L1226">                int saving = d.getDaylightSaving();</span>
<span class="nc" id="L1227">                internalSet(ZONE_OFFSET, zoneOffset - saving);</span>
<span class="nc" id="L1228">                internalSet(DST_OFFSET, saving);</span>
<span class="nc" id="L1229">                return;</span>
            }

        case MONTH:
            // Rolling the month involves both pinning the final value to [0, 11]
            // and adjusting the DAY_OF_MONTH if necessary.  We only adjust the
            // DAY_OF_MONTH if, after updating the MONTH field, it is illegal.
            // E.g., &lt;jan31&gt;.roll(MONTH, 1) -&gt; &lt;feb28&gt; or &lt;feb29&gt;.
            {
<span class="nc bnc" id="L1238" title="All 2 branches missed.">                if (!isCutoverYear(cdate.getNormalizedYear())) {</span>
<span class="nc" id="L1239">                    int mon = (internalGet(MONTH) + amount) % 12;</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">                    if (mon &lt; 0) {</span>
<span class="nc" id="L1241">                        mon += 12;</span>
                    }
<span class="nc" id="L1243">                    set(MONTH, mon);</span>

                    // Keep the day of month in the range.  We don't want to spill over
                    // into the next month; e.g., we don't want jan31 + 1 mo -&gt; feb31 -&gt;
                    // mar3.
<span class="nc" id="L1248">                    int monthLen = monthLength(mon);</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                    if (internalGet(DAY_OF_MONTH) &gt; monthLen) {</span>
<span class="nc" id="L1250">                        set(DAY_OF_MONTH, monthLen);</span>
                    }
<span class="nc" id="L1252">                } else {</span>
                    // We need to take care of different lengths in
                    // year and month due to the cutover.
<span class="nc" id="L1255">                    int yearLength = getActualMaximum(MONTH) + 1;</span>
<span class="nc" id="L1256">                    int mon = (internalGet(MONTH) + amount) % yearLength;</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">                    if (mon &lt; 0) {</span>
<span class="nc" id="L1258">                        mon += yearLength;</span>
                    }
<span class="nc" id="L1260">                    set(MONTH, mon);</span>
<span class="nc" id="L1261">                    int monthLen = getActualMaximum(DAY_OF_MONTH);</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">                    if (internalGet(DAY_OF_MONTH) &gt; monthLen) {</span>
<span class="nc" id="L1263">                        set(DAY_OF_MONTH, monthLen);</span>
                    }
                }
<span class="nc" id="L1266">                return;</span>
            }

        case WEEK_OF_YEAR:
            {
<span class="nc" id="L1271">                int y = cdate.getNormalizedYear();</span>
<span class="nc" id="L1272">                max = getActualMaximum(WEEK_OF_YEAR);</span>
<span class="nc" id="L1273">                set(DAY_OF_WEEK, internalGet(DAY_OF_WEEK));</span>
<span class="nc" id="L1274">                int woy = internalGet(WEEK_OF_YEAR);</span>
<span class="nc" id="L1275">                int value = woy + amount;</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">                if (!isCutoverYear(y)) {</span>
<span class="nc" id="L1277">                    int weekYear = getWeekYear();</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">                    if (weekYear == y) {</span>
                        // If the new value is in between min and max
                        // (exclusive), then we can use the value.
<span class="nc bnc" id="L1281" title="All 4 branches missed.">                        if (value &gt; min &amp;&amp; value &lt; max) {</span>
<span class="nc" id="L1282">                            set(WEEK_OF_YEAR, value);</span>
<span class="nc" id="L1283">                            return;</span>
                        }
<span class="nc" id="L1285">                        long fd = getCurrentFixedDate();</span>
                        // Make sure that the min week has the current DAY_OF_WEEK
                        // in the calendar year
<span class="nc" id="L1288">                        long day1 = fd - (7 * (woy - min));</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                        if (calsys.getYearFromFixedDate(day1) != y) {</span>
<span class="nc" id="L1290">                            min++;</span>
                        }

                        // Make sure the same thing for the max week
<span class="nc" id="L1294">                        fd += 7 * (max - internalGet(WEEK_OF_YEAR));</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">                        if (calsys.getYearFromFixedDate(fd) != y) {</span>
<span class="nc" id="L1296">                            max--;</span>
                        }
<span class="nc" id="L1298">                    } else {</span>
                        // When WEEK_OF_YEAR and YEAR are out of sync,
                        // adjust woy and amount to stay in the calendar year.
<span class="nc bnc" id="L1301" title="All 2 branches missed.">                        if (weekYear &gt; y) {</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">                            if (amount &lt; 0) {</span>
<span class="nc" id="L1303">                                amount++;</span>
                            }
<span class="nc" id="L1305">                            woy = max;</span>
                        } else {
<span class="nc bnc" id="L1307" title="All 2 branches missed.">                            if (amount &gt; 0) {</span>
<span class="nc" id="L1308">                                amount -= woy - max;</span>
                            }
<span class="nc" id="L1310">                            woy = min;</span>
                        }
                    }
<span class="nc" id="L1313">                    set(field, getRolledValue(woy, amount, min, max));</span>
<span class="nc" id="L1314">                    return;</span>
                }

                // Handle cutover here.
<span class="nc" id="L1318">                long fd = getCurrentFixedDate();</span>
                BaseCalendar cal;
<span class="nc bnc" id="L1320" title="All 2 branches missed.">                if (gregorianCutoverYear == gregorianCutoverYearJulian) {</span>
<span class="nc" id="L1321">                    cal = getCutoverCalendarSystem();</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">                } else if (y == gregorianCutoverYear) {</span>
<span class="nc" id="L1323">                    cal = gcal;</span>
                } else {
<span class="nc" id="L1325">                    cal = getJulianCalendarSystem();</span>
                }
<span class="nc" id="L1327">                long day1 = fd - (7 * (woy - min));</span>
                // Make sure that the min week has the current DAY_OF_WEEK
<span class="nc bnc" id="L1329" title="All 2 branches missed.">                if (cal.getYearFromFixedDate(day1) != y) {</span>
<span class="nc" id="L1330">                    min++;</span>
                }

                // Make sure the same thing for the max week
<span class="nc" id="L1334">                fd += 7 * (max - woy);</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">                cal = (fd &gt;= gregorianCutoverDate) ? gcal : getJulianCalendarSystem();</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">                if (cal.getYearFromFixedDate(fd) != y) {</span>
<span class="nc" id="L1337">                    max--;</span>
                }
                // value: the new WEEK_OF_YEAR which must be converted
                // to month and day of month.
<span class="nc" id="L1341">                value = getRolledValue(woy, amount, min, max) - 1;</span>
<span class="nc" id="L1342">                BaseCalendar.Date d = getCalendarDate(day1 + value * 7);</span>
<span class="nc" id="L1343">                set(MONTH, d.getMonth() - 1);</span>
<span class="nc" id="L1344">                set(DAY_OF_MONTH, d.getDayOfMonth());</span>
<span class="nc" id="L1345">                return;</span>
            }

        case WEEK_OF_MONTH:
            {
<span class="nc" id="L1350">                boolean isCutoverYear = isCutoverYear(cdate.getNormalizedYear());</span>
                // dow: relative day of week from first day of week
<span class="nc" id="L1352">                int dow = internalGet(DAY_OF_WEEK) - getFirstDayOfWeek();</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">                if (dow &lt; 0) {</span>
<span class="nc" id="L1354">                    dow += 7;</span>
                }

<span class="nc" id="L1357">                long fd = getCurrentFixedDate();</span>
                long month1;     // fixed date of the first day (usually 1) of the month
                int monthLength; // actual month length
<span class="nc bnc" id="L1360" title="All 2 branches missed.">                if (isCutoverYear) {</span>
<span class="nc" id="L1361">                    month1 = getFixedDateMonth1(cdate, fd);</span>
<span class="nc" id="L1362">                    monthLength = actualMonthLength();</span>
                } else {
<span class="nc" id="L1364">                    month1 = fd - internalGet(DAY_OF_MONTH) + 1;</span>
<span class="nc" id="L1365">                    monthLength = calsys.getMonthLength(cdate);</span>
                }

                // the first day of week of the month.
<span class="nc" id="L1369">                long monthDay1st = BaseCalendar.getDayOfWeekDateOnOrBefore(month1 + 6,</span>
<span class="nc" id="L1370">                                                                           getFirstDayOfWeek());</span>
                // if the week has enough days to form a week, the
                // week starts from the previous month.
<span class="nc bnc" id="L1373" title="All 2 branches missed.">                if ((int)(monthDay1st - month1) &gt;= getMinimalDaysInFirstWeek()) {</span>
<span class="nc" id="L1374">                    monthDay1st -= 7;</span>
                }
<span class="nc" id="L1376">                max = getActualMaximum(field);</span>

                // value: the new WEEK_OF_MONTH value
<span class="nc" id="L1379">                int value = getRolledValue(internalGet(field), amount, 1, max) - 1;</span>

                // nfd: fixed date of the rolled date
<span class="nc" id="L1382">                long nfd = monthDay1st + value * 7 + dow;</span>

                // Unlike WEEK_OF_YEAR, we need to change day of week if the
                // nfd is out of the month.
<span class="nc bnc" id="L1386" title="All 2 branches missed.">                if (nfd &lt; month1) {</span>
<span class="nc" id="L1387">                    nfd = month1;</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">                } else if (nfd &gt;= (month1 + monthLength)) {</span>
<span class="nc" id="L1389">                    nfd = month1 + monthLength - 1;</span>
                }
                int dayOfMonth;
<span class="nc bnc" id="L1392" title="All 2 branches missed.">                if (isCutoverYear) {</span>
                    // If we are in the cutover year, convert nfd to
                    // its calendar date and use dayOfMonth.
<span class="nc" id="L1395">                    BaseCalendar.Date d = getCalendarDate(nfd);</span>
<span class="nc" id="L1396">                    dayOfMonth = d.getDayOfMonth();</span>
<span class="nc" id="L1397">                } else {</span>
<span class="nc" id="L1398">                    dayOfMonth = (int)(nfd - month1) + 1;</span>
                }
<span class="nc" id="L1400">                set(DAY_OF_MONTH, dayOfMonth);</span>
<span class="nc" id="L1401">                return;</span>
            }

        case DAY_OF_MONTH:
            {
<span class="nc bnc" id="L1406" title="All 2 branches missed.">                if (!isCutoverYear(cdate.getNormalizedYear())) {</span>
<span class="nc" id="L1407">                    max = calsys.getMonthLength(cdate);</span>
<span class="nc" id="L1408">                    break;</span>
                }

                // Cutover year handling
<span class="nc" id="L1412">                long fd = getCurrentFixedDate();</span>
<span class="nc" id="L1413">                long month1 = getFixedDateMonth1(cdate, fd);</span>
                // It may not be a regular month. Convert the date and range to
                // the relative values, perform the roll, and
                // convert the result back to the rolled date.
<span class="nc" id="L1417">                int value = getRolledValue((int)(fd - month1), amount, 0, actualMonthLength() - 1);</span>
<span class="nc" id="L1418">                BaseCalendar.Date d = getCalendarDate(month1 + value);</span>
<span class="nc bnc" id="L1419" title="All 4 branches missed.">                assert d.getMonth()-1 == internalGet(MONTH);</span>
<span class="nc" id="L1420">                set(DAY_OF_MONTH, d.getDayOfMonth());</span>
<span class="nc" id="L1421">                return;</span>
            }

        case DAY_OF_YEAR:
            {
<span class="nc" id="L1426">                max = getActualMaximum(field);</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">                if (!isCutoverYear(cdate.getNormalizedYear())) {</span>
<span class="nc" id="L1428">                    break;</span>
                }

                // Handle cutover here.
<span class="nc" id="L1432">                long fd = getCurrentFixedDate();</span>
<span class="nc" id="L1433">                long jan1 = fd - internalGet(DAY_OF_YEAR) + 1;</span>
<span class="nc" id="L1434">                int value = getRolledValue((int)(fd - jan1) + 1, amount, min, max);</span>
<span class="nc" id="L1435">                BaseCalendar.Date d = getCalendarDate(jan1 + value - 1);</span>
<span class="nc" id="L1436">                set(MONTH, d.getMonth() - 1);</span>
<span class="nc" id="L1437">                set(DAY_OF_MONTH, d.getDayOfMonth());</span>
<span class="nc" id="L1438">                return;</span>
            }

        case DAY_OF_WEEK:
            {
<span class="nc bnc" id="L1443" title="All 2 branches missed.">                if (!isCutoverYear(cdate.getNormalizedYear())) {</span>
                    // If the week of year is in the same year, we can
                    // just change DAY_OF_WEEK.
<span class="nc" id="L1446">                    int weekOfYear = internalGet(WEEK_OF_YEAR);</span>
<span class="nc bnc" id="L1447" title="All 4 branches missed.">                    if (weekOfYear &gt; 1 &amp;&amp; weekOfYear &lt; 52) {</span>
<span class="nc" id="L1448">                        set(WEEK_OF_YEAR, weekOfYear); // update stamp[WEEK_OF_YEAR]</span>
<span class="nc" id="L1449">                        max = SATURDAY;</span>
<span class="nc" id="L1450">                        break;</span>
                    }
                }

                // We need to handle it in a different way around year
                // boundaries and in the cutover year. Note that
                // changing era and year values violates the roll
                // rule: not changing larger calendar fields...
<span class="nc" id="L1458">                amount %= 7;</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">                if (amount == 0) {</span>
<span class="nc" id="L1460">                    return;</span>
                }
<span class="nc" id="L1462">                long fd = getCurrentFixedDate();</span>
<span class="nc" id="L1463">                long dowFirst = BaseCalendar.getDayOfWeekDateOnOrBefore(fd, getFirstDayOfWeek());</span>
<span class="nc" id="L1464">                fd += amount;</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">                if (fd &lt; dowFirst) {</span>
<span class="nc" id="L1466">                    fd += 7;</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">                } else if (fd &gt;= dowFirst + 7) {</span>
<span class="nc" id="L1468">                    fd -= 7;</span>
                }
<span class="nc" id="L1470">                BaseCalendar.Date d = getCalendarDate(fd);</span>
<span class="nc bnc" id="L1471" title="All 2 branches missed.">                set(ERA, (d.getNormalizedYear() &lt;= 0 ? BCE : CE));</span>
<span class="nc" id="L1472">                set(d.getYear(), d.getMonth() - 1, d.getDayOfMonth());</span>
<span class="nc" id="L1473">                return;</span>
            }

        case DAY_OF_WEEK_IN_MONTH:
            {
<span class="nc" id="L1478">                min = 1; // after normalized, min should be 1.</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">                if (!isCutoverYear(cdate.getNormalizedYear())) {</span>
<span class="nc" id="L1480">                    int dom = internalGet(DAY_OF_MONTH);</span>
<span class="nc" id="L1481">                    int monthLength = calsys.getMonthLength(cdate);</span>
<span class="nc" id="L1482">                    int lastDays = monthLength % 7;</span>
<span class="nc" id="L1483">                    max = monthLength / 7;</span>
<span class="nc" id="L1484">                    int x = (dom - 1) % 7;</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">                    if (x &lt; lastDays) {</span>
<span class="nc" id="L1486">                        max++;</span>
                    }
<span class="nc" id="L1488">                    set(DAY_OF_WEEK, internalGet(DAY_OF_WEEK));</span>
<span class="nc" id="L1489">                    break;</span>
                }

                // Cutover year handling
<span class="nc" id="L1493">                long fd = getCurrentFixedDate();</span>
<span class="nc" id="L1494">                long month1 = getFixedDateMonth1(cdate, fd);</span>
<span class="nc" id="L1495">                int monthLength = actualMonthLength();</span>
<span class="nc" id="L1496">                int lastDays = monthLength % 7;</span>
<span class="nc" id="L1497">                max = monthLength / 7;</span>
<span class="nc" id="L1498">                int x = (int)(fd - month1) % 7;</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">                if (x &lt; lastDays) {</span>
<span class="nc" id="L1500">                    max++;</span>
                }
<span class="nc" id="L1502">                int value = getRolledValue(internalGet(field), amount, min, max) - 1;</span>
<span class="nc" id="L1503">                fd = month1 + value * 7 + x;</span>
<span class="nc bnc" id="L1504" title="All 2 branches missed.">                BaseCalendar cal = (fd &gt;= gregorianCutoverDate) ? gcal : getJulianCalendarSystem();</span>
<span class="nc" id="L1505">                BaseCalendar.Date d = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="nc" id="L1506">                cal.getCalendarDateFromFixedDate(d, fd);</span>
<span class="nc" id="L1507">                set(DAY_OF_MONTH, d.getDayOfMonth());</span>
<span class="nc" id="L1508">                return;</span>
            }
        }

<span class="nc" id="L1512">        set(field, getRolledValue(internalGet(field), amount, min, max));</span>
<span class="nc" id="L1513">    }</span>

    /**
     * Returns the minimum value for the given calendar field of this
     * &lt;code&gt;GregorianCalendar&lt;/code&gt; instance. The minimum value is
     * defined as the smallest value returned by the {@link
     * Calendar#get(int) get} method for any possible time value,
     * taking into consideration the current values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * {@link #getGregorianChange() getGregorianChange} and
     * {@link Calendar#getTimeZone() getTimeZone} methods.
     *
     * @param field the calendar field.
     * @return the minimum value for the given calendar field.
     * @see #getMaximum(int)
     * @see #getGreatestMinimum(int)
     * @see #getLeastMaximum(int)
     * @see #getActualMinimum(int)
     * @see #getActualMaximum(int)
     */
    @Override
    public int getMinimum(int field) {
<span class="fc" id="L1536">        return MIN_VALUES[field];</span>
    }

    /**
     * Returns the maximum value for the given calendar field of this
     * &lt;code&gt;GregorianCalendar&lt;/code&gt; instance. The maximum value is
     * defined as the largest value returned by the {@link
     * Calendar#get(int) get} method for any possible time value,
     * taking into consideration the current values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * {@link #getGregorianChange() getGregorianChange} and
     * {@link Calendar#getTimeZone() getTimeZone} methods.
     *
     * @param field the calendar field.
     * @return the maximum value for the given calendar field.
     * @see #getMinimum(int)
     * @see #getGreatestMinimum(int)
     * @see #getLeastMaximum(int)
     * @see #getActualMinimum(int)
     * @see #getActualMaximum(int)
     */
    @Override
    public int getMaximum(int field) {
<span class="fc bfc" id="L1560" title="All 2 branches covered.">        switch (field) {</span>
        case MONTH:
        case DAY_OF_MONTH:
        case DAY_OF_YEAR:
        case WEEK_OF_YEAR:
        case WEEK_OF_MONTH:
        case DAY_OF_WEEK_IN_MONTH:
        case YEAR:
            {
                // On or after Gregorian 200-3-1, Julian and Gregorian
                // calendar dates are the same or Gregorian dates are
                // larger (i.e., there is a &quot;gap&quot;) after 300-3-1.
<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">                if (gregorianCutoverYear &gt; 200) {</span>
<span class="fc" id="L1573">                    break;</span>
                }
                // There might be &quot;overlapping&quot; dates.
<span class="nc" id="L1576">                GregorianCalendar gc = (GregorianCalendar) clone();</span>
<span class="nc" id="L1577">                gc.setLenient(true);</span>
<span class="nc" id="L1578">                gc.setTimeInMillis(gregorianCutover);</span>
<span class="nc" id="L1579">                int v1 = gc.getActualMaximum(field);</span>
<span class="nc" id="L1580">                gc.setTimeInMillis(gregorianCutover-1);</span>
<span class="nc" id="L1581">                int v2 = gc.getActualMaximum(field);</span>
<span class="nc" id="L1582">                return Math.max(MAX_VALUES[field], Math.max(v1, v2));</span>
            }
        }
<span class="fc" id="L1585">        return MAX_VALUES[field];</span>
    }

    /**
     * Returns the highest minimum value for the given calendar field
     * of this &lt;code&gt;GregorianCalendar&lt;/code&gt; instance. The highest
     * minimum value is defined as the largest value returned by
     * {@link #getActualMinimum(int)} for any possible time value,
     * taking into consideration the current values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * {@link #getGregorianChange() getGregorianChange} and
     * {@link Calendar#getTimeZone() getTimeZone} methods.
     *
     * @param field the calendar field.
     * @return the highest minimum value for the given calendar field.
     * @see #getMinimum(int)
     * @see #getMaximum(int)
     * @see #getLeastMaximum(int)
     * @see #getActualMinimum(int)
     * @see #getActualMaximum(int)
     */
    @Override
    public int getGreatestMinimum(int field) {
<span class="nc bnc" id="L1609" title="All 2 branches missed.">        if (field == DAY_OF_MONTH) {</span>
<span class="nc" id="L1610">            BaseCalendar.Date d = getGregorianCutoverDate();</span>
<span class="nc" id="L1611">            long mon1 = getFixedDateMonth1(d, gregorianCutoverDate);</span>
<span class="nc" id="L1612">            d = getCalendarDate(mon1);</span>
<span class="nc" id="L1613">            return Math.max(MIN_VALUES[field], d.getDayOfMonth());</span>
        }
<span class="nc" id="L1615">        return MIN_VALUES[field];</span>
    }

    /**
     * Returns the lowest maximum value for the given calendar field
     * of this &lt;code&gt;GregorianCalendar&lt;/code&gt; instance. The lowest
     * maximum value is defined as the smallest value returned by
     * {@link #getActualMaximum(int)} for any possible time value,
     * taking into consideration the current values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * {@link #getGregorianChange() getGregorianChange} and
     * {@link Calendar#getTimeZone() getTimeZone} methods.
     *
     * @param field the calendar field
     * @return the lowest maximum value for the given calendar field.
     * @see #getMinimum(int)
     * @see #getMaximum(int)
     * @see #getGreatestMinimum(int)
     * @see #getActualMinimum(int)
     * @see #getActualMaximum(int)
     */
    @Override
    public int getLeastMaximum(int field) {
<span class="pc bpc" id="L1639" title="1 of 2 branches missed.">        switch (field) {</span>
        case MONTH:
        case DAY_OF_MONTH:
        case DAY_OF_YEAR:
        case WEEK_OF_YEAR:
        case WEEK_OF_MONTH:
        case DAY_OF_WEEK_IN_MONTH:
        case YEAR:
            {
<span class="nc" id="L1648">                GregorianCalendar gc = (GregorianCalendar) clone();</span>
<span class="nc" id="L1649">                gc.setLenient(true);</span>
<span class="nc" id="L1650">                gc.setTimeInMillis(gregorianCutover);</span>
<span class="nc" id="L1651">                int v1 = gc.getActualMaximum(field);</span>
<span class="nc" id="L1652">                gc.setTimeInMillis(gregorianCutover-1);</span>
<span class="nc" id="L1653">                int v2 = gc.getActualMaximum(field);</span>
<span class="nc" id="L1654">                return Math.min(LEAST_MAX_VALUES[field], Math.min(v1, v2));</span>
            }
        }
<span class="fc" id="L1657">        return LEAST_MAX_VALUES[field];</span>
    }

    /**
     * Returns the minimum value that this calendar field could have,
     * taking into consideration the given time value and the current
     * values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * {@link #getGregorianChange() getGregorianChange} and
     * {@link Calendar#getTimeZone() getTimeZone} methods.
     *
     * &lt;p&gt;For example, if the Gregorian change date is January 10,
     * 1970 and the date of this &lt;code&gt;GregorianCalendar&lt;/code&gt; is
     * January 20, 1970, the actual minimum value of the
     * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; field is 10 because the previous date
     * of January 10, 1970 is December 27, 1996 (in the Julian
     * calendar). Therefore, December 28, 1969 to January 9, 1970
     * don't exist.
     *
     * @param field the calendar field
     * @return the minimum of the given field for the time value of
     * this &lt;code&gt;GregorianCalendar&lt;/code&gt;
     * @see #getMinimum(int)
     * @see #getMaximum(int)
     * @see #getGreatestMinimum(int)
     * @see #getLeastMaximum(int)
     * @see #getActualMaximum(int)
     * @since 1.2
     */
    @Override
    public int getActualMinimum(int field) {
<span class="nc bnc" id="L1689" title="All 2 branches missed.">        if (field == DAY_OF_MONTH) {</span>
<span class="nc" id="L1690">            GregorianCalendar gc = getNormalizedCalendar();</span>
<span class="nc" id="L1691">            int year = gc.cdate.getNormalizedYear();</span>
<span class="nc bnc" id="L1692" title="All 4 branches missed.">            if (year == gregorianCutoverYear || year == gregorianCutoverYearJulian) {</span>
<span class="nc" id="L1693">                long month1 = getFixedDateMonth1(gc.cdate, gc.calsys.getFixedDate(gc.cdate));</span>
<span class="nc" id="L1694">                BaseCalendar.Date d = getCalendarDate(month1);</span>
<span class="nc" id="L1695">                return d.getDayOfMonth();</span>
            }
        }
<span class="nc" id="L1698">        return getMinimum(field);</span>
    }

    /**
     * Returns the maximum value that this calendar field could have,
     * taking into consideration the given time value and the current
     * values of the
     * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
     * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
     * {@link #getGregorianChange() getGregorianChange} and
     * {@link Calendar#getTimeZone() getTimeZone} methods.
     * For example, if the date of this instance is February 1, 2004,
     * the actual maximum value of the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; field
     * is 29 because 2004 is a leap year, and if the date of this
     * instance is February 1, 2005, it's 28.
     *
     * &lt;p&gt;This method calculates the maximum value of {@link
     * Calendar#WEEK_OF_YEAR WEEK_OF_YEAR} based on the {@link
     * Calendar#YEAR YEAR} (calendar year) value, not the &lt;a
     * href=&quot;#week_year&quot;&gt;week year&lt;/a&gt;. Call {@link
     * #getWeeksInWeekYear()} to get the maximum value of {@code
     * WEEK_OF_YEAR} in the week year of this {@code GregorianCalendar}.
     *
     * @param field the calendar field
     * @return the maximum of the given field for the time value of
     * this &lt;code&gt;GregorianCalendar&lt;/code&gt;
     * @see #getMinimum(int)
     * @see #getMaximum(int)
     * @see #getGreatestMinimum(int)
     * @see #getLeastMaximum(int)
     * @see #getActualMinimum(int)
     * @since 1.2
     */
    @Override
    public int getActualMaximum(int field) {
        final int fieldsForFixedMax = ERA_MASK|DAY_OF_WEEK_MASK|HOUR_MASK|AM_PM_MASK|
            HOUR_OF_DAY_MASK|MINUTE_MASK|SECOND_MASK|MILLISECOND_MASK|
            ZONE_OFFSET_MASK|DST_OFFSET_MASK;
<span class="nc bnc" id="L1736" title="All 2 branches missed.">        if ((fieldsForFixedMax &amp; (1&lt;&lt;field)) != 0) {</span>
<span class="nc" id="L1737">            return getMaximum(field);</span>
        }

<span class="nc" id="L1740">        GregorianCalendar gc = getNormalizedCalendar();</span>
<span class="nc" id="L1741">        BaseCalendar.Date date = gc.cdate;</span>
<span class="nc" id="L1742">        BaseCalendar cal = gc.calsys;</span>
<span class="nc" id="L1743">        int normalizedYear = date.getNormalizedYear();</span>

<span class="nc" id="L1745">        int value = -1;</span>
<span class="nc bnc" id="L1746" title="All 8 branches missed.">        switch (field) {</span>
        case MONTH:
            {
<span class="nc bnc" id="L1749" title="All 2 branches missed.">                if (!gc.isCutoverYear(normalizedYear)) {</span>
<span class="nc" id="L1750">                    value = DECEMBER;</span>
<span class="nc" id="L1751">                    break;</span>
                }

                // January 1 of the next year may or may not exist.
                long nextJan1;
                do {
<span class="nc" id="L1757">                    nextJan1 = gcal.getFixedDate(++normalizedYear, BaseCalendar.JANUARY, 1, null);</span>
<span class="nc bnc" id="L1758" title="All 2 branches missed.">                } while (nextJan1 &lt; gregorianCutoverDate);</span>
<span class="nc" id="L1759">                BaseCalendar.Date d = (BaseCalendar.Date) date.clone();</span>
<span class="nc" id="L1760">                cal.getCalendarDateFromFixedDate(d, nextJan1 - 1);</span>
<span class="nc" id="L1761">                value = d.getMonth() - 1;</span>
            }
<span class="nc" id="L1763">            break;</span>

        case DAY_OF_MONTH:
            {
<span class="nc" id="L1767">                value = cal.getMonthLength(date);</span>
<span class="nc bnc" id="L1768" title="All 4 branches missed.">                if (!gc.isCutoverYear(normalizedYear) || date.getDayOfMonth() == value) {</span>
<span class="nc" id="L1769">                    break;</span>
                }

                // Handle cutover year.
<span class="nc" id="L1773">                long fd = gc.getCurrentFixedDate();</span>
<span class="nc bnc" id="L1774" title="All 2 branches missed.">                if (fd &gt;= gregorianCutoverDate) {</span>
<span class="nc" id="L1775">                    break;</span>
                }
<span class="nc" id="L1777">                int monthLength = gc.actualMonthLength();</span>
<span class="nc" id="L1778">                long monthEnd = gc.getFixedDateMonth1(gc.cdate, fd) + monthLength - 1;</span>
                // Convert the fixed date to its calendar date.
<span class="nc" id="L1780">                BaseCalendar.Date d = gc.getCalendarDate(monthEnd);</span>
<span class="nc" id="L1781">                value = d.getDayOfMonth();</span>
            }
<span class="nc" id="L1783">            break;</span>

        case DAY_OF_YEAR:
            {
<span class="nc bnc" id="L1787" title="All 2 branches missed.">                if (!gc.isCutoverYear(normalizedYear)) {</span>
<span class="nc" id="L1788">                    value = cal.getYearLength(date);</span>
<span class="nc" id="L1789">                    break;</span>
                }

                // Handle cutover year.
                long jan1;
<span class="nc bnc" id="L1794" title="All 2 branches missed.">                if (gregorianCutoverYear == gregorianCutoverYearJulian) {</span>
<span class="nc" id="L1795">                    BaseCalendar cocal = gc.getCutoverCalendarSystem();</span>
<span class="nc" id="L1796">                    jan1 = cocal.getFixedDate(normalizedYear, 1, 1, null);</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">                } else if (normalizedYear == gregorianCutoverYearJulian) {</span>
<span class="nc" id="L1798">                    jan1 = cal.getFixedDate(normalizedYear, 1, 1, null);</span>
                } else {
<span class="nc" id="L1800">                    jan1 = gregorianCutoverDate;</span>
                }
                // January 1 of the next year may or may not exist.
<span class="nc" id="L1803">                long nextJan1 = gcal.getFixedDate(++normalizedYear, 1, 1, null);</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">                if (nextJan1 &lt; gregorianCutoverDate) {</span>
<span class="nc" id="L1805">                    nextJan1 = gregorianCutoverDate;</span>
                }
<span class="nc bnc" id="L1807" title="All 4 branches missed.">                assert jan1 &lt;= cal.getFixedDate(date.getNormalizedYear(), date.getMonth(),</span>
<span class="nc" id="L1808">                                                date.getDayOfMonth(), date);</span>
<span class="nc bnc" id="L1809" title="All 4 branches missed.">                assert nextJan1 &gt;= cal.getFixedDate(date.getNormalizedYear(), date.getMonth(),</span>
<span class="nc" id="L1810">                                                date.getDayOfMonth(), date);</span>
<span class="nc" id="L1811">                value = (int)(nextJan1 - jan1);</span>
            }
<span class="nc" id="L1813">            break;</span>

        case WEEK_OF_YEAR:
            {
<span class="nc bnc" id="L1817" title="All 2 branches missed.">                if (!gc.isCutoverYear(normalizedYear)) {</span>
                    // Get the day of week of January 1 of the year
<span class="nc" id="L1819">                    CalendarDate d = cal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="nc" id="L1820">                    d.setDate(date.getYear(), BaseCalendar.JANUARY, 1);</span>
<span class="nc" id="L1821">                    int dayOfWeek = cal.getDayOfWeek(d);</span>
                    // Normalize the day of week with the firstDayOfWeek value
<span class="nc" id="L1823">                    dayOfWeek -= getFirstDayOfWeek();</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">                    if (dayOfWeek &lt; 0) {</span>
<span class="nc" id="L1825">                        dayOfWeek += 7;</span>
                    }
<span class="nc" id="L1827">                    value = 52;</span>
<span class="nc" id="L1828">                    int magic = dayOfWeek + getMinimalDaysInFirstWeek() - 1;</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">                    if ((magic == 6) ||</span>
<span class="nc bnc" id="L1830" title="All 6 branches missed.">                        (date.isLeapYear() &amp;&amp; (magic == 5 || magic == 12))) {</span>
<span class="nc" id="L1831">                        value++;</span>
                    }
                    break;
                }

<span class="nc bnc" id="L1836" title="All 2 branches missed.">                if (gc == this) {</span>
<span class="nc" id="L1837">                    gc = (GregorianCalendar) gc.clone();</span>
                }
<span class="nc" id="L1839">                int maxDayOfYear = getActualMaximum(DAY_OF_YEAR);</span>
<span class="nc" id="L1840">                gc.set(DAY_OF_YEAR, maxDayOfYear);</span>
<span class="nc" id="L1841">                value = gc.get(WEEK_OF_YEAR);</span>
<span class="nc bnc" id="L1842" title="All 2 branches missed.">                if (internalGet(YEAR) != gc.getWeekYear()) {</span>
<span class="nc" id="L1843">                    gc.set(DAY_OF_YEAR, maxDayOfYear - 7);</span>
<span class="nc" id="L1844">                    value = gc.get(WEEK_OF_YEAR);</span>
                }
            }
<span class="nc" id="L1847">            break;</span>

        case WEEK_OF_MONTH:
            {
<span class="nc bnc" id="L1851" title="All 2 branches missed.">                if (!gc.isCutoverYear(normalizedYear)) {</span>
<span class="nc" id="L1852">                    CalendarDate d = cal.newCalendarDate(null);</span>
<span class="nc" id="L1853">                    d.setDate(date.getYear(), date.getMonth(), 1);</span>
<span class="nc" id="L1854">                    int dayOfWeek = cal.getDayOfWeek(d);</span>
<span class="nc" id="L1855">                    int monthLength = cal.getMonthLength(d);</span>
<span class="nc" id="L1856">                    dayOfWeek -= getFirstDayOfWeek();</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">                    if (dayOfWeek &lt; 0) {</span>
<span class="nc" id="L1858">                        dayOfWeek += 7;</span>
                    }
<span class="nc" id="L1860">                    int nDaysFirstWeek = 7 - dayOfWeek; // # of days in the first week</span>
<span class="nc" id="L1861">                    value = 3;</span>
<span class="nc bnc" id="L1862" title="All 2 branches missed.">                    if (nDaysFirstWeek &gt;= getMinimalDaysInFirstWeek()) {</span>
<span class="nc" id="L1863">                        value++;</span>
                    }
<span class="nc" id="L1865">                    monthLength -= nDaysFirstWeek + 7 * 3;</span>
<span class="nc bnc" id="L1866" title="All 2 branches missed.">                    if (monthLength &gt; 0) {</span>
<span class="nc" id="L1867">                        value++;</span>
<span class="nc bnc" id="L1868" title="All 2 branches missed.">                        if (monthLength &gt; 7) {</span>
<span class="nc" id="L1869">                            value++;</span>
                        }
                    }
                    break;
                }

                // Cutover year handling
<span class="nc bnc" id="L1876" title="All 2 branches missed.">                if (gc == this) {</span>
<span class="nc" id="L1877">                    gc = (GregorianCalendar) gc.clone();</span>
                }
<span class="nc" id="L1879">                int y = gc.internalGet(YEAR);</span>
<span class="nc" id="L1880">                int m = gc.internalGet(MONTH);</span>
                do {
<span class="nc" id="L1882">                    value = gc.get(WEEK_OF_MONTH);</span>
<span class="nc" id="L1883">                    gc.add(WEEK_OF_MONTH, +1);</span>
<span class="nc bnc" id="L1884" title="All 4 branches missed.">                } while (gc.get(YEAR) == y &amp;&amp; gc.get(MONTH) == m);</span>
            }
<span class="nc" id="L1886">            break;</span>

        case DAY_OF_WEEK_IN_MONTH:
            {
                // may be in the Gregorian cutover month
                int ndays, dow1;
<span class="nc" id="L1892">                int dow = date.getDayOfWeek();</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">                if (!gc.isCutoverYear(normalizedYear)) {</span>
<span class="nc" id="L1894">                    BaseCalendar.Date d = (BaseCalendar.Date) date.clone();</span>
<span class="nc" id="L1895">                    ndays = cal.getMonthLength(d);</span>
<span class="nc" id="L1896">                    d.setDayOfMonth(1);</span>
<span class="nc" id="L1897">                    cal.normalize(d);</span>
<span class="nc" id="L1898">                    dow1 = d.getDayOfWeek();</span>
<span class="nc" id="L1899">                } else {</span>
                    // Let a cloned GregorianCalendar take care of the cutover cases.
<span class="nc bnc" id="L1901" title="All 2 branches missed.">                    if (gc == this) {</span>
<span class="nc" id="L1902">                        gc = (GregorianCalendar) clone();</span>
                    }
<span class="nc" id="L1904">                    ndays = gc.actualMonthLength();</span>
<span class="nc" id="L1905">                    gc.set(DAY_OF_MONTH, gc.getActualMinimum(DAY_OF_MONTH));</span>
<span class="nc" id="L1906">                    dow1 = gc.get(DAY_OF_WEEK);</span>
                }
<span class="nc" id="L1908">                int x = dow - dow1;</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">                if (x &lt; 0) {</span>
<span class="nc" id="L1910">                    x += 7;</span>
                }
<span class="nc" id="L1912">                ndays -= x;</span>
<span class="nc" id="L1913">                value = (ndays + 6) / 7;</span>
            }
<span class="nc" id="L1915">            break;</span>

        case YEAR:
            /* The year computation is no different, in principle, from the
             * others, however, the range of possible maxima is large.  In
             * addition, the way we know we've exceeded the range is different.
             * For these reasons, we use the special case code below to handle
             * this field.
             *
             * The actual maxima for YEAR depend on the type of calendar:
             *
             *     Gregorian = May 17, 292275056 BCE - Aug 17, 292278994 CE
             *     Julian    = Dec  2, 292269055 BCE - Jan  3, 292272993 CE
             *     Hybrid    = Dec  2, 292269055 BCE - Aug 17, 292278994 CE
             *
             * We know we've exceeded the maximum when either the month, date,
             * time, or era changes in response to setting the year.  We don't
             * check for month, date, and time here because the year and era are
             * sufficient to detect an invalid year setting.  NOTE: If code is
             * added to check the month and date in the future for some reason,
             * Feb 29 must be allowed to shift to Mar 1 when setting the year.
             */
            {
<span class="nc bnc" id="L1938" title="All 2 branches missed.">                if (gc == this) {</span>
<span class="nc" id="L1939">                    gc = (GregorianCalendar) clone();</span>
                }

                // Calculate the millisecond offset from the beginning
                // of the year of this calendar and adjust the max
                // year value if we are beyond the limit in the max
                // year.
<span class="nc" id="L1946">                long current = gc.getYearOffsetInMillis();</span>

<span class="nc bnc" id="L1948" title="All 2 branches missed.">                if (gc.internalGetEra() == CE) {</span>
<span class="nc" id="L1949">                    gc.setTimeInMillis(Long.MAX_VALUE);</span>
<span class="nc" id="L1950">                    value = gc.get(YEAR);</span>
<span class="nc" id="L1951">                    long maxEnd = gc.getYearOffsetInMillis();</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">                    if (current &gt; maxEnd) {</span>
<span class="nc" id="L1953">                        value--;</span>
                    }
<span class="nc" id="L1955">                } else {</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">                    CalendarSystem mincal = gc.getTimeInMillis() &gt;= gregorianCutover ?</span>
<span class="nc" id="L1957">                        gcal : getJulianCalendarSystem();</span>
<span class="nc" id="L1958">                    CalendarDate d = mincal.getCalendarDate(Long.MIN_VALUE, getZone());</span>
<span class="nc" id="L1959">                    long maxEnd = (cal.getDayOfYear(d) - 1) * 24 + d.getHours();</span>
<span class="nc" id="L1960">                    maxEnd *= 60;</span>
<span class="nc" id="L1961">                    maxEnd += d.getMinutes();</span>
<span class="nc" id="L1962">                    maxEnd *= 60;</span>
<span class="nc" id="L1963">                    maxEnd += d.getSeconds();</span>
<span class="nc" id="L1964">                    maxEnd *= 1000;</span>
<span class="nc" id="L1965">                    maxEnd += d.getMillis();</span>
<span class="nc" id="L1966">                    value = d.getYear();</span>
<span class="nc bnc" id="L1967" title="All 2 branches missed.">                    if (value &lt;= 0) {</span>
<span class="nc bnc" id="L1968" title="All 4 branches missed.">                        assert mincal == gcal;</span>
<span class="nc" id="L1969">                        value = 1 - value;</span>
                    }
<span class="nc bnc" id="L1971" title="All 2 branches missed.">                    if (current &lt; maxEnd) {</span>
<span class="nc" id="L1972">                        value--;</span>
                    }
                }
            }
<span class="nc" id="L1976">            break;</span>

        default:
<span class="nc" id="L1979">            throw new ArrayIndexOutOfBoundsException(field);</span>
        }
<span class="nc" id="L1981">        return value;</span>
    }

    /**
     * Returns the millisecond offset from the beginning of this
     * year. This Calendar object must have been normalized.
     */
    private long getYearOffsetInMillis() {
<span class="nc" id="L1989">        long t = (internalGet(DAY_OF_YEAR) - 1) * 24;</span>
<span class="nc" id="L1990">        t += internalGet(HOUR_OF_DAY);</span>
<span class="nc" id="L1991">        t *= 60;</span>
<span class="nc" id="L1992">        t += internalGet(MINUTE);</span>
<span class="nc" id="L1993">        t *= 60;</span>
<span class="nc" id="L1994">        t += internalGet(SECOND);</span>
<span class="nc" id="L1995">        t *= 1000;</span>
<span class="nc" id="L1996">        return t + internalGet(MILLISECOND) -</span>
<span class="nc" id="L1997">            (internalGet(ZONE_OFFSET) + internalGet(DST_OFFSET));</span>
    }

    @Override
    public Object clone()
    {
<span class="fc" id="L2003">        GregorianCalendar other = (GregorianCalendar) super.clone();</span>

<span class="fc" id="L2005">        other.gdate = (BaseCalendar.Date) gdate.clone();</span>
<span class="fc bfc" id="L2006" title="All 2 branches covered.">        if (cdate != null) {</span>
<span class="pc bpc" id="L2007" title="1 of 2 branches missed.">            if (cdate != gdate) {</span>
<span class="nc" id="L2008">                other.cdate = (BaseCalendar.Date) cdate.clone();</span>
            } else {
<span class="fc" id="L2010">                other.cdate = other.gdate;</span>
            }
        }
<span class="fc" id="L2013">        other.originalFields = null;</span>
<span class="fc" id="L2014">        other.zoneOffsets = null;</span>
<span class="fc" id="L2015">        return other;</span>
    }

    @Override
    public TimeZone getTimeZone() {
<span class="fc" id="L2020">        TimeZone zone = super.getTimeZone();</span>
        // To share the zone by CalendarDates
<span class="fc" id="L2022">        gdate.setZone(zone);</span>
<span class="pc bpc" id="L2023" title="2 of 4 branches missed.">        if (cdate != null &amp;&amp; cdate != gdate) {</span>
<span class="nc" id="L2024">            cdate.setZone(zone);</span>
        }
<span class="fc" id="L2026">        return zone;</span>
    }

    @Override
    public void setTimeZone(TimeZone zone) {
<span class="fc" id="L2031">        super.setTimeZone(zone);</span>
        // To share the zone by CalendarDates
<span class="fc" id="L2033">        gdate.setZone(zone);</span>
<span class="pc bpc" id="L2034" title="2 of 4 branches missed.">        if (cdate != null &amp;&amp; cdate != gdate) {</span>
<span class="nc" id="L2035">            cdate.setZone(zone);</span>
        }
<span class="fc" id="L2037">    }</span>

    /**
     * Returns {@code true} indicating this {@code GregorianCalendar}
     * supports week dates.
     *
     * @return {@code true} (always)
     * @see #getWeekYear()
     * @see #setWeekDate(int,int,int)
     * @see #getWeeksInWeekYear()
     * @since 1.7
     */
    @Override
    public final boolean isWeekDateSupported() {
<span class="fc" id="L2051">        return true;</span>
    }

    /**
     * Returns the &lt;a href=&quot;#week_year&quot;&gt;week year&lt;/a&gt; represented by this
     * {@code GregorianCalendar}. The dates in the weeks between 1 and the
     * maximum week number of the week year have the same week year value
     * that may be one year before or after the {@link Calendar#YEAR YEAR}
     * (calendar year) value.
     *
     * &lt;p&gt;This method calls {@link Calendar#complete()} before
     * calculating the week year.
     *
     * @return the week year represented by this {@code GregorianCalendar}.
     *         If the {@link Calendar#ERA ERA} value is {@link #BC}, the year is
     *         represented by 0 or a negative number: BC 1 is 0, BC 2
     *         is -1, BC 3 is -2, and so on.
     * @throws IllegalArgumentException
     *         if any of the calendar fields is invalid in non-lenient mode.
     * @see #isWeekDateSupported()
     * @see #getWeeksInWeekYear()
     * @see Calendar#getFirstDayOfWeek()
     * @see Calendar#getMinimalDaysInFirstWeek()
     * @since 1.7
     */
    @Override
    public int getWeekYear() {
<span class="fc" id="L2078">        int year = get(YEAR); // implicitly calls complete()</span>
<span class="pc bpc" id="L2079" title="1 of 2 branches missed.">        if (internalGetEra() == BCE) {</span>
<span class="nc" id="L2080">            year = 1 - year;</span>
        }

        // Fast path for the Gregorian calendar years that are never
        // affected by the Julian-Gregorian transition
<span class="pc bpc" id="L2085" title="1 of 2 branches missed.">        if (year &gt; gregorianCutoverYear + 1) {</span>
<span class="fc" id="L2086">            int weekOfYear = internalGet(WEEK_OF_YEAR);</span>
<span class="fc bfc" id="L2087" title="All 2 branches covered.">            if (internalGet(MONTH) == JANUARY) {</span>
<span class="fc bfc" id="L2088" title="All 2 branches covered.">                if (weekOfYear &gt;= 52) {</span>
<span class="fc" id="L2089">                    --year;</span>
                }
            } else {
<span class="fc bfc" id="L2092" title="All 2 branches covered.">                if (weekOfYear == 1) {</span>
<span class="fc" id="L2093">                    ++year;</span>
                }
            }
<span class="fc" id="L2096">            return year;</span>
        }

        // General (slow) path
<span class="nc" id="L2100">        int dayOfYear = internalGet(DAY_OF_YEAR);</span>
<span class="nc" id="L2101">        int maxDayOfYear = getActualMaximum(DAY_OF_YEAR);</span>
<span class="nc" id="L2102">        int minimalDays = getMinimalDaysInFirstWeek();</span>

        // Quickly check the possibility of year adjustments before
        // cloning this GregorianCalendar.
<span class="nc bnc" id="L2106" title="All 4 branches missed.">        if (dayOfYear &gt; minimalDays &amp;&amp; dayOfYear &lt; (maxDayOfYear - 6)) {</span>
<span class="nc" id="L2107">            return year;</span>
        }

        // Create a clone to work on the calculation
<span class="nc" id="L2111">        GregorianCalendar cal = (GregorianCalendar) clone();</span>
<span class="nc" id="L2112">        cal.setLenient(true);</span>
        // Use GMT so that intermediate date calculations won't
        // affect the time of day fields.
<span class="nc" id="L2115">        cal.setTimeZone(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
        // Go to the first day of the year, which is usually January 1.
<span class="nc" id="L2117">        cal.set(DAY_OF_YEAR, 1);</span>
<span class="nc" id="L2118">        cal.complete();</span>

        // Get the first day of the first day-of-week in the year.
<span class="nc" id="L2121">        int delta = getFirstDayOfWeek() - cal.get(DAY_OF_WEEK);</span>
<span class="nc bnc" id="L2122" title="All 2 branches missed.">        if (delta != 0) {</span>
<span class="nc bnc" id="L2123" title="All 2 branches missed.">            if (delta &lt; 0) {</span>
<span class="nc" id="L2124">                delta += 7;</span>
            }
<span class="nc" id="L2126">            cal.add(DAY_OF_YEAR, delta);</span>
        }
<span class="nc" id="L2128">        int minDayOfYear = cal.get(DAY_OF_YEAR);</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">        if (dayOfYear &lt; minDayOfYear) {</span>
<span class="nc bnc" id="L2130" title="All 2 branches missed.">            if (minDayOfYear &lt;= minimalDays) {</span>
<span class="nc" id="L2131">                --year;</span>
            }
        } else {
<span class="nc" id="L2134">            cal.set(YEAR, year + 1);</span>
<span class="nc" id="L2135">            cal.set(DAY_OF_YEAR, 1);</span>
<span class="nc" id="L2136">            cal.complete();</span>
<span class="nc" id="L2137">            int del = getFirstDayOfWeek() - cal.get(DAY_OF_WEEK);</span>
<span class="nc bnc" id="L2138" title="All 2 branches missed.">            if (del != 0) {</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">                if (del &lt; 0) {</span>
<span class="nc" id="L2140">                    del += 7;</span>
                }
<span class="nc" id="L2142">                cal.add(DAY_OF_YEAR, del);</span>
            }
<span class="nc" id="L2144">            minDayOfYear = cal.get(DAY_OF_YEAR) - 1;</span>
<span class="nc bnc" id="L2145" title="All 2 branches missed.">            if (minDayOfYear == 0) {</span>
<span class="nc" id="L2146">                minDayOfYear = 7;</span>
            }
<span class="nc bnc" id="L2148" title="All 2 branches missed.">            if (minDayOfYear &gt;= minimalDays) {</span>
<span class="nc" id="L2149">                int days = maxDayOfYear - dayOfYear + 1;</span>
<span class="nc bnc" id="L2150" title="All 2 branches missed.">                if (days &lt;= (7 - minDayOfYear)) {</span>
<span class="nc" id="L2151">                    ++year;</span>
                }
            }
        }
<span class="nc" id="L2155">        return year;</span>
    }

    /**
     * Sets this {@code GregorianCalendar} to the date given by the
     * date specifiers - &lt;a href=&quot;#week_year&quot;&gt;{@code weekYear}&lt;/a&gt;,
     * {@code weekOfYear}, and {@code dayOfWeek}. {@code weekOfYear}
     * follows the &lt;a href=&quot;#week_and_year&quot;&gt;{@code WEEK_OF_YEAR}
     * numbering&lt;/a&gt;.  The {@code dayOfWeek} value must be one of the
     * {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} values: {@link
     * Calendar#SUNDAY SUNDAY} to {@link Calendar#SATURDAY SATURDAY}.
     *
     * &lt;p&gt;Note that the numeric day-of-week representation differs from
     * the ISO 8601 standard, and that the {@code weekOfYear}
     * numbering is compatible with the standard when {@code
     * getFirstDayOfWeek()} is {@code MONDAY} and {@code
     * getMinimalDaysInFirstWeek()} is 4.
     *
     * &lt;p&gt;Unlike the {@code set} method, all of the calendar fields
     * and the instant of time value are calculated upon return.
     *
     * &lt;p&gt;If {@code weekOfYear} is out of the valid week-of-year
     * range in {@code weekYear}, the {@code weekYear}
     * and {@code weekOfYear} values are adjusted in lenient
     * mode, or an {@code IllegalArgumentException} is thrown in
     * non-lenient mode.
     *
     * @param weekYear    the week year
     * @param weekOfYear  the week number based on {@code weekYear}
     * @param dayOfWeek   the day of week value: one of the constants
     *                    for the {@link #DAY_OF_WEEK DAY_OF_WEEK} field:
     *                    {@link Calendar#SUNDAY SUNDAY}, ...,
     *                    {@link Calendar#SATURDAY SATURDAY}.
     * @exception IllegalArgumentException
     *            if any of the given date specifiers is invalid,
     *            or if any of the calendar fields are inconsistent
     *            with the given date specifiers in non-lenient mode
     * @see GregorianCalendar#isWeekDateSupported()
     * @see Calendar#getFirstDayOfWeek()
     * @see Calendar#getMinimalDaysInFirstWeek()
     * @since 1.7
     */
    @Override
    public void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {
<span class="fc bfc" id="L2199" title="All 4 branches covered.">        if (dayOfWeek &lt; SUNDAY || dayOfWeek &gt; SATURDAY) {</span>
<span class="fc" id="L2200">            throw new IllegalArgumentException(&quot;invalid dayOfWeek: &quot; + dayOfWeek);</span>
        }

        // To avoid changing the time of day fields by date
        // calculations, use a clone with the GMT time zone.
<span class="fc" id="L2205">        GregorianCalendar gc = (GregorianCalendar) clone();</span>
<span class="fc" id="L2206">        gc.setLenient(true);</span>
<span class="fc" id="L2207">        int era = gc.get(ERA);</span>
<span class="fc" id="L2208">        gc.clear();</span>
<span class="fc" id="L2209">        gc.setTimeZone(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="fc" id="L2210">        gc.set(ERA, era);</span>
<span class="fc" id="L2211">        gc.set(YEAR, weekYear);</span>
<span class="fc" id="L2212">        gc.set(WEEK_OF_YEAR, 1);</span>
<span class="fc" id="L2213">        gc.set(DAY_OF_WEEK, getFirstDayOfWeek());</span>
<span class="fc" id="L2214">        int days = dayOfWeek - getFirstDayOfWeek();</span>
<span class="fc bfc" id="L2215" title="All 2 branches covered.">        if (days &lt; 0) {</span>
<span class="fc" id="L2216">            days += 7;</span>
        }
<span class="fc" id="L2218">        days += 7 * (weekOfYear - 1);</span>
<span class="fc bfc" id="L2219" title="All 2 branches covered.">        if (days != 0) {</span>
<span class="fc" id="L2220">            gc.add(DAY_OF_YEAR, days);</span>
        } else {
<span class="fc" id="L2222">            gc.complete();</span>
        }

<span class="fc bfc" id="L2225" title="All 2 branches covered.">        if (!isLenient() &amp;&amp;</span>
<span class="pc bpc" id="L2226" title="1 of 2 branches missed.">            (gc.getWeekYear() != weekYear</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">             || gc.internalGet(WEEK_OF_YEAR) != weekOfYear</span>
<span class="nc bnc" id="L2228" title="All 2 branches missed.">             || gc.internalGet(DAY_OF_WEEK) != dayOfWeek)) {</span>
<span class="fc" id="L2229">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L2232">        set(ERA, gc.internalGet(ERA));</span>
<span class="fc" id="L2233">        set(YEAR, gc.internalGet(YEAR));</span>
<span class="fc" id="L2234">        set(MONTH, gc.internalGet(MONTH));</span>
<span class="fc" id="L2235">        set(DAY_OF_MONTH, gc.internalGet(DAY_OF_MONTH));</span>

        // to avoid throwing an IllegalArgumentException in
        // non-lenient, set WEEK_OF_YEAR internally
<span class="fc" id="L2239">        internalSet(WEEK_OF_YEAR, weekOfYear);</span>
<span class="fc" id="L2240">        complete();</span>
<span class="fc" id="L2241">    }</span>

    /**
     * Returns the number of weeks in the &lt;a href=&quot;#week_year&quot;&gt;week year&lt;/a&gt;
     * represented by this {@code GregorianCalendar}.
     *
     * &lt;p&gt;For example, if this {@code GregorianCalendar}'s date is
     * December 31, 2008 with &lt;a href=&quot;#iso8601_compatible_setting&quot;&gt;the ISO
     * 8601 compatible setting&lt;/a&gt;, this method will return 53 for the
     * period: December 29, 2008 to January 3, 2010 while {@link
     * #getActualMaximum(int) getActualMaximum(WEEK_OF_YEAR)} will return
     * 52 for the period: December 31, 2007 to December 28, 2008.
     *
     * @return the number of weeks in the week year.
     * @see Calendar#WEEK_OF_YEAR
     * @see #getWeekYear()
     * @see #getActualMaximum(int)
     * @since 1.7
     */
    @Override
    public int getWeeksInWeekYear() {
<span class="nc" id="L2262">        GregorianCalendar gc = getNormalizedCalendar();</span>
<span class="nc" id="L2263">        int weekYear = gc.getWeekYear();</span>
<span class="nc bnc" id="L2264" title="All 2 branches missed.">        if (weekYear == gc.internalGet(YEAR)) {</span>
<span class="nc" id="L2265">            return gc.getActualMaximum(WEEK_OF_YEAR);</span>
        }

        // Use the 2nd week for calculating the max of WEEK_OF_YEAR
<span class="nc bnc" id="L2269" title="All 2 branches missed.">        if (gc == this) {</span>
<span class="nc" id="L2270">            gc = (GregorianCalendar) gc.clone();</span>
        }
<span class="nc" id="L2272">        gc.setWeekDate(weekYear, 2, internalGet(DAY_OF_WEEK));</span>
<span class="nc" id="L2273">        return gc.getActualMaximum(WEEK_OF_YEAR);</span>
    }

/////////////////////////////
// Time =&gt; Fields computation
/////////////////////////////

    /**
     * The fixed date corresponding to gdate. If the value is
     * Long.MIN_VALUE, the fixed date value is unknown. Currently,
     * Julian calendar dates are not cached.
     */
<span class="fc" id="L2285">    transient private long cachedFixedDate = Long.MIN_VALUE;</span>

    /**
     * Converts the time value (millisecond offset from the &lt;a
     * href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;) to calendar field values.
     * The time is &lt;em&gt;not&lt;/em&gt;
     * recomputed first; to recompute the time, then the fields, call the
     * &lt;code&gt;complete&lt;/code&gt; method.
     *
     * @see Calendar#complete
     */
    @Override
    protected void computeFields() {
        int mask;
<span class="fc bfc" id="L2299" title="All 2 branches covered.">        if (isPartiallyNormalized()) {</span>
            // Determine which calendar fields need to be computed.
<span class="fc" id="L2301">            mask = getSetStateFields();</span>
<span class="fc" id="L2302">            int fieldMask = ~mask &amp; ALL_FIELDS;</span>
            // We have to call computTime in case calsys == null in
            // order to set calsys and cdate. (6263644)
<span class="pc bpc" id="L2305" title="1 of 4 branches missed.">            if (fieldMask != 0 || calsys == null) {</span>
<span class="fc" id="L2306">                mask |= computeFields(fieldMask,</span>
                                      mask &amp; (ZONE_OFFSET_MASK|DST_OFFSET_MASK));
<span class="pc bpc" id="L2308" title="2 of 4 branches missed.">                assert mask == ALL_FIELDS;</span>
            }
<span class="fc" id="L2310">        } else {</span>
<span class="fc" id="L2311">            mask = ALL_FIELDS;</span>
<span class="fc" id="L2312">            computeFields(mask, 0);</span>
        }
        // After computing all the fields, set the field state to `COMPUTED'.
<span class="fc" id="L2315">        setFieldsComputed(mask);</span>
<span class="fc" id="L2316">    }</span>

    /**
     * This computeFields implements the conversion from UTC
     * (millisecond offset from the Epoch) to calendar
     * field values. fieldMask specifies which fields to change the
     * setting state to COMPUTED, although all fields are set to
     * the correct values. This is required to fix 4685354.
     *
     * @param fieldMask a bit mask to specify which fields to change
     * the setting state.
     * @param tzMask a bit mask to specify which time zone offset
     * fields to be used for time calculations
     * @return a new field mask that indicates what field values have
     * actually been set.
     */
    private int computeFields(int fieldMask, int tzMask) {
<span class="fc" id="L2333">        int zoneOffset = 0;</span>
<span class="fc" id="L2334">        TimeZone tz = getZone();</span>
<span class="fc bfc" id="L2335" title="All 2 branches covered.">        if (zoneOffsets == null) {</span>
<span class="fc" id="L2336">            zoneOffsets = new int[2];</span>
        }
<span class="fc bfc" id="L2338" title="All 2 branches covered.">        if (tzMask != (ZONE_OFFSET_MASK|DST_OFFSET_MASK)) {</span>
<span class="fc bfc" id="L2339" title="All 2 branches covered.">            if (tz instanceof ZoneInfo) {</span>
<span class="fc" id="L2340">                zoneOffset = ((ZoneInfo)tz).getOffsets(time, zoneOffsets);</span>
            } else {
<span class="fc" id="L2342">                zoneOffset = tz.getOffset(time);</span>
<span class="fc" id="L2343">                zoneOffsets[0] = tz.getRawOffset();</span>
<span class="fc" id="L2344">                zoneOffsets[1] = zoneOffset - zoneOffsets[0];</span>
            }
        }
<span class="fc bfc" id="L2347" title="All 2 branches covered.">        if (tzMask != 0) {</span>
<span class="fc bfc" id="L2348" title="All 2 branches covered.">            if (isFieldSet(tzMask, ZONE_OFFSET)) {</span>
<span class="fc" id="L2349">                zoneOffsets[0] = internalGet(ZONE_OFFSET);</span>
            }
<span class="pc bpc" id="L2351" title="1 of 2 branches missed.">            if (isFieldSet(tzMask, DST_OFFSET)) {</span>
<span class="fc" id="L2352">                zoneOffsets[1] = internalGet(DST_OFFSET);</span>
            }
<span class="fc" id="L2354">            zoneOffset = zoneOffsets[0] + zoneOffsets[1];</span>
        }

        // By computing time and zoneOffset separately, we can take
        // the wider range of time+zoneOffset than the previous
        // implementation.
<span class="fc" id="L2360">        long fixedDate = zoneOffset / ONE_DAY;</span>
<span class="fc" id="L2361">        int timeOfDay = zoneOffset % (int)ONE_DAY;</span>
<span class="fc" id="L2362">        fixedDate += time / ONE_DAY;</span>
<span class="fc" id="L2363">        timeOfDay += (int) (time % ONE_DAY);</span>
<span class="fc bfc" id="L2364" title="All 2 branches covered.">        if (timeOfDay &gt;= ONE_DAY) {</span>
<span class="fc" id="L2365">            timeOfDay -= ONE_DAY;</span>
<span class="fc" id="L2366">            ++fixedDate;</span>
        } else {
<span class="fc bfc" id="L2368" title="All 2 branches covered.">            while (timeOfDay &lt; 0) {</span>
<span class="fc" id="L2369">                timeOfDay += ONE_DAY;</span>
<span class="fc" id="L2370">                --fixedDate;</span>
            }
        }
<span class="fc" id="L2373">        fixedDate += EPOCH_OFFSET;</span>

<span class="fc" id="L2375">        int era = CE;</span>
        int year;
<span class="fc bfc" id="L2377" title="All 2 branches covered.">        if (fixedDate &gt;= gregorianCutoverDate) {</span>
            // Handle Gregorian dates.
<span class="pc bpc" id="L2379" title="1 of 6 branches missed.">            assert cachedFixedDate == Long.MIN_VALUE || gdate.isNormalized()</span>
                        : &quot;cache control: not normalized&quot;;
<span class="pc bfc" id="L2381" title="All 4 branches covered.">            assert cachedFixedDate == Long.MIN_VALUE ||</span>
<span class="pc bpc" id="L2382" title="1 of 2 branches missed.">                   gcal.getFixedDate(gdate.getNormalizedYear(),</span>
<span class="fc" id="L2383">                                          gdate.getMonth(),</span>
<span class="fc" id="L2384">                                          gdate.getDayOfMonth(), gdate)</span>
                                == cachedFixedDate
                        : &quot;cache control: inconsictency&quot; +
                          &quot;, cachedFixedDate=&quot; + cachedFixedDate +
                          &quot;, computed=&quot; +
<span class="nc" id="L2389">                          gcal.getFixedDate(gdate.getNormalizedYear(),</span>
<span class="nc" id="L2390">                                                 gdate.getMonth(),</span>
<span class="nc" id="L2391">                                                 gdate.getDayOfMonth(),</span>
                                                 gdate) +
                          &quot;, date=&quot; + gdate;

            // See if we can use gdate to avoid date calculation.
<span class="fc bfc" id="L2396" title="All 2 branches covered.">            if (fixedDate != cachedFixedDate) {</span>
<span class="fc" id="L2397">                gcal.getCalendarDateFromFixedDate(gdate, fixedDate);</span>
<span class="fc" id="L2398">                cachedFixedDate = fixedDate;</span>
            }

<span class="fc" id="L2401">            year = gdate.getYear();</span>
<span class="pc bpc" id="L2402" title="1 of 2 branches missed.">            if (year &lt;= 0) {</span>
<span class="nc" id="L2403">                year = 1 - year;</span>
<span class="nc" id="L2404">                era = BCE;</span>
            }
<span class="fc" id="L2406">            calsys = gcal;</span>
<span class="fc" id="L2407">            cdate = gdate;</span>
<span class="pc bpc" id="L2408" title="1 of 4 branches missed.">            assert cdate.getDayOfWeek() &gt; 0 : &quot;dow=&quot;+cdate.getDayOfWeek()+&quot;, date=&quot;+cdate;</span>
        } else {
            // Handle Julian calendar dates.
<span class="fc" id="L2411">            calsys = getJulianCalendarSystem();</span>
<span class="fc" id="L2412">            cdate = (BaseCalendar.Date) jcal.newCalendarDate(getZone());</span>
<span class="fc" id="L2413">            jcal.getCalendarDateFromFixedDate(cdate, fixedDate);</span>
<span class="fc" id="L2414">            Era e = cdate.getEra();</span>
<span class="fc bfc" id="L2415" title="All 2 branches covered.">            if (e == jeras[0]) {</span>
<span class="fc" id="L2416">                era = BCE;</span>
            }
<span class="fc" id="L2418">            year = cdate.getYear();</span>
        }

        // Always set the ERA and YEAR values.
<span class="fc" id="L2422">        internalSet(ERA, era);</span>
<span class="fc" id="L2423">        internalSet(YEAR, year);</span>
<span class="fc" id="L2424">        int mask = fieldMask | (ERA_MASK|YEAR_MASK);</span>

<span class="fc" id="L2426">        int month =  cdate.getMonth() - 1; // 0-based</span>
<span class="fc" id="L2427">        int dayOfMonth = cdate.getDayOfMonth();</span>

        // Set the basic date fields.
<span class="fc bfc" id="L2430" title="All 2 branches covered.">        if ((fieldMask &amp; (MONTH_MASK|DAY_OF_MONTH_MASK|DAY_OF_WEEK_MASK))</span>
            != 0) {
<span class="fc" id="L2432">            internalSet(MONTH, month);</span>
<span class="fc" id="L2433">            internalSet(DAY_OF_MONTH, dayOfMonth);</span>
<span class="fc" id="L2434">            internalSet(DAY_OF_WEEK, cdate.getDayOfWeek());</span>
<span class="fc" id="L2435">            mask |= MONTH_MASK|DAY_OF_MONTH_MASK|DAY_OF_WEEK_MASK;</span>
        }

<span class="fc bfc" id="L2438" title="All 2 branches covered.">        if ((fieldMask &amp; (HOUR_OF_DAY_MASK|AM_PM_MASK|HOUR_MASK</span>
                          |MINUTE_MASK|SECOND_MASK|MILLISECOND_MASK)) != 0) {
<span class="fc bfc" id="L2440" title="All 2 branches covered.">            if (timeOfDay != 0) {</span>
<span class="fc" id="L2441">                int hours = timeOfDay / ONE_HOUR;</span>
<span class="fc" id="L2442">                internalSet(HOUR_OF_DAY, hours);</span>
<span class="fc" id="L2443">                internalSet(AM_PM, hours / 12); // Assume AM == 0</span>
<span class="fc" id="L2444">                internalSet(HOUR, hours % 12);</span>
<span class="fc" id="L2445">                int r = timeOfDay % ONE_HOUR;</span>
<span class="fc" id="L2446">                internalSet(MINUTE, r / ONE_MINUTE);</span>
<span class="fc" id="L2447">                r %= ONE_MINUTE;</span>
<span class="fc" id="L2448">                internalSet(SECOND, r / ONE_SECOND);</span>
<span class="fc" id="L2449">                internalSet(MILLISECOND, r % ONE_SECOND);</span>
<span class="fc" id="L2450">            } else {</span>
<span class="fc" id="L2451">                internalSet(HOUR_OF_DAY, 0);</span>
<span class="fc" id="L2452">                internalSet(AM_PM, AM);</span>
<span class="fc" id="L2453">                internalSet(HOUR, 0);</span>
<span class="fc" id="L2454">                internalSet(MINUTE, 0);</span>
<span class="fc" id="L2455">                internalSet(SECOND, 0);</span>
<span class="fc" id="L2456">                internalSet(MILLISECOND, 0);</span>
            }
<span class="fc" id="L2458">            mask |= (HOUR_OF_DAY_MASK|AM_PM_MASK|HOUR_MASK</span>
                     |MINUTE_MASK|SECOND_MASK|MILLISECOND_MASK);
        }

<span class="fc bfc" id="L2462" title="All 2 branches covered.">        if ((fieldMask &amp; (ZONE_OFFSET_MASK|DST_OFFSET_MASK)) != 0) {</span>
<span class="fc" id="L2463">            internalSet(ZONE_OFFSET, zoneOffsets[0]);</span>
<span class="fc" id="L2464">            internalSet(DST_OFFSET, zoneOffsets[1]);</span>
<span class="fc" id="L2465">            mask |= (ZONE_OFFSET_MASK|DST_OFFSET_MASK);</span>
        }

<span class="fc bfc" id="L2468" title="All 2 branches covered.">        if ((fieldMask &amp; (DAY_OF_YEAR_MASK|WEEK_OF_YEAR_MASK|WEEK_OF_MONTH_MASK|DAY_OF_WEEK_IN_MONTH_MASK)) != 0) {</span>
<span class="fc" id="L2469">            int normalizedYear = cdate.getNormalizedYear();</span>
<span class="fc" id="L2470">            long fixedDateJan1 = calsys.getFixedDate(normalizedYear, 1, 1, cdate);</span>
<span class="fc" id="L2471">            int dayOfYear = (int)(fixedDate - fixedDateJan1) + 1;</span>
<span class="fc" id="L2472">            long fixedDateMonth1 = fixedDate - dayOfMonth + 1;</span>
<span class="fc" id="L2473">            int cutoverGap = 0;</span>
<span class="fc bfc" id="L2474" title="All 2 branches covered.">            int cutoverYear = (calsys == gcal) ? gregorianCutoverYear : gregorianCutoverYearJulian;</span>
<span class="fc" id="L2475">            int relativeDayOfMonth = dayOfMonth - 1;</span>

            // If we are in the cutover year, we need some special handling.
<span class="pc bpc" id="L2478" title="1 of 2 branches missed.">            if (normalizedYear == cutoverYear) {</span>
                // Need to take care of the &quot;missing&quot; days.
<span class="nc bnc" id="L2480" title="All 2 branches missed.">                if (gregorianCutoverYearJulian &lt;= gregorianCutoverYear) {</span>
                    // We need to find out where we are. The cutover
                    // gap could even be more than one year.  (One
                    // year difference in ~48667 years.)
<span class="nc" id="L2484">                    fixedDateJan1 = getFixedDateJan1(cdate, fixedDate);</span>
<span class="nc bnc" id="L2485" title="All 2 branches missed.">                    if (fixedDate &gt;= gregorianCutoverDate) {</span>
<span class="nc" id="L2486">                        fixedDateMonth1 = getFixedDateMonth1(cdate, fixedDate);</span>
                    }
                }
<span class="nc" id="L2489">                int realDayOfYear = (int)(fixedDate - fixedDateJan1) + 1;</span>
<span class="nc" id="L2490">                cutoverGap = dayOfYear - realDayOfYear;</span>
<span class="nc" id="L2491">                dayOfYear = realDayOfYear;</span>
<span class="nc" id="L2492">                relativeDayOfMonth = (int)(fixedDate - fixedDateMonth1);</span>
            }
<span class="fc" id="L2494">            internalSet(DAY_OF_YEAR, dayOfYear);</span>
<span class="fc" id="L2495">            internalSet(DAY_OF_WEEK_IN_MONTH, relativeDayOfMonth / 7 + 1);</span>

<span class="fc" id="L2497">            int weekOfYear = getWeekNumber(fixedDateJan1, fixedDate);</span>

            // The spec is to calculate WEEK_OF_YEAR in the
            // ISO8601-style. This creates problems, though.
<span class="fc bfc" id="L2501" title="All 2 branches covered.">            if (weekOfYear == 0) {</span>
                // If the date belongs to the last week of the
                // previous year, use the week number of &quot;12/31&quot; of
                // the &quot;previous&quot; year. Again, if the previous year is
                // the Gregorian cutover year, we need to take care of
                // it.  Usually the previous day of January 1 is
                // December 31, which is not always true in
                // GregorianCalendar.
<span class="fc" id="L2509">                long fixedDec31 = fixedDateJan1 - 1;</span>
<span class="fc" id="L2510">                long prevJan1  = fixedDateJan1 - 365;</span>
<span class="pc bpc" id="L2511" title="1 of 2 branches missed.">                if (normalizedYear &gt; (cutoverYear + 1)) {</span>
<span class="fc bfc" id="L2512" title="All 2 branches covered.">                    if (CalendarUtils.isGregorianLeapYear(normalizedYear - 1)) {</span>
<span class="fc" id="L2513">                        --prevJan1;</span>
                    }
<span class="nc bnc" id="L2515" title="All 2 branches missed.">                } else if (normalizedYear &lt;= gregorianCutoverYearJulian) {</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">                    if (CalendarUtils.isJulianLeapYear(normalizedYear - 1)) {</span>
<span class="nc" id="L2517">                        --prevJan1;</span>
                    }
                } else {
<span class="nc" id="L2520">                    BaseCalendar calForJan1 = calsys;</span>
                    //int prevYear = normalizedYear - 1;
<span class="nc" id="L2522">                    int prevYear = getCalendarDate(fixedDec31).getNormalizedYear();</span>
<span class="nc bnc" id="L2523" title="All 2 branches missed.">                    if (prevYear == gregorianCutoverYear) {</span>
<span class="nc" id="L2524">                        calForJan1 = getCutoverCalendarSystem();</span>
<span class="nc bnc" id="L2525" title="All 2 branches missed.">                        if (calForJan1 == jcal) {</span>
<span class="nc" id="L2526">                            prevJan1 = calForJan1.getFixedDate(prevYear,</span>
                                                               BaseCalendar.JANUARY,
                                                               1,
                                                               null);
                        } else {
<span class="nc" id="L2531">                            prevJan1 = gregorianCutoverDate;</span>
<span class="nc" id="L2532">                            calForJan1 = gcal;</span>
                        }
<span class="nc bnc" id="L2534" title="All 2 branches missed.">                    } else if (prevYear &lt;= gregorianCutoverYearJulian) {</span>
<span class="nc" id="L2535">                        calForJan1 = getJulianCalendarSystem();</span>
<span class="nc" id="L2536">                        prevJan1 = calForJan1.getFixedDate(prevYear,</span>
                                                           BaseCalendar.JANUARY,
                                                           1,
                                                           null);
                    }
                }
<span class="fc" id="L2542">                weekOfYear = getWeekNumber(prevJan1, fixedDec31);</span>
<span class="fc" id="L2543">            } else {</span>
<span class="pc bpc" id="L2544" title="1 of 4 branches missed.">                if (normalizedYear &gt; gregorianCutoverYear ||</span>
                    normalizedYear &lt; (gregorianCutoverYearJulian - 1)) {
                    // Regular years
<span class="fc bfc" id="L2547" title="All 2 branches covered.">                    if (weekOfYear &gt;= 52) {</span>
<span class="fc" id="L2548">                        long nextJan1 = fixedDateJan1 + 365;</span>
<span class="fc bfc" id="L2549" title="All 2 branches covered.">                        if (cdate.isLeapYear()) {</span>
<span class="fc" id="L2550">                            nextJan1++;</span>
                        }
<span class="fc" id="L2552">                        long nextJan1st = BaseCalendar.getDayOfWeekDateOnOrBefore(nextJan1 + 6,</span>
<span class="fc" id="L2553">                                                                                  getFirstDayOfWeek());</span>
<span class="fc" id="L2554">                        int ndays = (int)(nextJan1st - nextJan1);</span>
<span class="fc bfc" id="L2555" title="All 4 branches covered.">                        if (ndays &gt;= getMinimalDaysInFirstWeek() &amp;&amp; fixedDate &gt;= (nextJan1st - 7)) {</span>
                            // The first days forms a week in which the date is included.
<span class="fc" id="L2557">                            weekOfYear = 1;</span>
                        }
<span class="fc" id="L2559">                    }</span>
                } else {
<span class="nc" id="L2561">                    BaseCalendar calForJan1 = calsys;</span>
<span class="nc" id="L2562">                    int nextYear = normalizedYear + 1;</span>
<span class="nc bnc" id="L2563" title="All 4 branches missed.">                    if (nextYear == (gregorianCutoverYearJulian + 1) &amp;&amp;</span>
                        nextYear &lt; gregorianCutoverYear) {
                        // In case the gap is more than one year.
<span class="nc" id="L2566">                        nextYear = gregorianCutoverYear;</span>
                    }
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                    if (nextYear == gregorianCutoverYear) {</span>
<span class="nc" id="L2569">                        calForJan1 = getCutoverCalendarSystem();</span>
                    }

                    long nextJan1;
<span class="nc bnc" id="L2573" title="All 6 branches missed.">                    if (nextYear &gt; gregorianCutoverYear</span>
                        || gregorianCutoverYearJulian == gregorianCutoverYear
                        || nextYear == gregorianCutoverYearJulian) {
<span class="nc" id="L2576">                        nextJan1 = calForJan1.getFixedDate(nextYear,</span>
                                                           BaseCalendar.JANUARY,
                                                           1,
                                                           null);
                    } else {
<span class="nc" id="L2581">                        nextJan1 = gregorianCutoverDate;</span>
<span class="nc" id="L2582">                        calForJan1 = gcal;</span>
                    }

<span class="nc" id="L2585">                    long nextJan1st = BaseCalendar.getDayOfWeekDateOnOrBefore(nextJan1 + 6,</span>
<span class="nc" id="L2586">                                                                              getFirstDayOfWeek());</span>
<span class="nc" id="L2587">                    int ndays = (int)(nextJan1st - nextJan1);</span>
<span class="nc bnc" id="L2588" title="All 4 branches missed.">                    if (ndays &gt;= getMinimalDaysInFirstWeek() &amp;&amp; fixedDate &gt;= (nextJan1st - 7)) {</span>
                        // The first days forms a week in which the date is included.
<span class="nc" id="L2590">                        weekOfYear = 1;</span>
                    }
                }
            }
<span class="fc" id="L2594">            internalSet(WEEK_OF_YEAR, weekOfYear);</span>
<span class="fc" id="L2595">            internalSet(WEEK_OF_MONTH, getWeekNumber(fixedDateMonth1, fixedDate));</span>
<span class="fc" id="L2596">            mask |= (DAY_OF_YEAR_MASK|WEEK_OF_YEAR_MASK|WEEK_OF_MONTH_MASK|DAY_OF_WEEK_IN_MONTH_MASK);</span>
        }
<span class="fc" id="L2598">        return mask;</span>
    }

    /**
     * Returns the number of weeks in a period between fixedDay1 and
     * fixedDate. The getFirstDayOfWeek-getMinimalDaysInFirstWeek rule
     * is applied to calculate the number of weeks.
     *
     * @param fixedDay1 the fixed date of the first day of the period
     * @param fixedDate the fixed date of the last day of the period
     * @return the number of weeks of the given period
     */
    private int getWeekNumber(long fixedDay1, long fixedDate) {
        // We can always use `gcal' since Julian and Gregorian are the
        // same thing for this calculation.
<span class="fc" id="L2613">        long fixedDay1st = Gregorian.getDayOfWeekDateOnOrBefore(fixedDay1 + 6,</span>
<span class="fc" id="L2614">                                                                getFirstDayOfWeek());</span>
<span class="fc" id="L2615">        int ndays = (int)(fixedDay1st - fixedDay1);</span>
<span class="pc bpc" id="L2616" title="1 of 4 branches missed.">        assert ndays &lt;= 7;</span>
<span class="fc bfc" id="L2617" title="All 2 branches covered.">        if (ndays &gt;= getMinimalDaysInFirstWeek()) {</span>
<span class="fc" id="L2618">            fixedDay1st -= 7;</span>
        }
<span class="fc" id="L2620">        int normalizedDayOfPeriod = (int)(fixedDate - fixedDay1st);</span>
<span class="fc bfc" id="L2621" title="All 2 branches covered.">        if (normalizedDayOfPeriod &gt;= 0) {</span>
<span class="fc" id="L2622">            return normalizedDayOfPeriod / 7 + 1;</span>
        }
<span class="fc" id="L2624">        return CalendarUtils.floorDivide(normalizedDayOfPeriod, 7) + 1;</span>
    }

    /**
     * Converts calendar field values to the time value (millisecond
     * offset from the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;).
     *
     * @exception IllegalArgumentException if any calendar fields are invalid.
     */
    @Override
    protected void computeTime() {
        // In non-lenient mode, perform brief checking of calendar
        // fields which have been set externally. Through this
        // checking, the field values are stored in originalFields[]
        // to see if any of them are normalized later.
<span class="fc bfc" id="L2639" title="All 2 branches covered.">        if (!isLenient()) {</span>
<span class="pc bpc" id="L2640" title="1 of 2 branches missed.">            if (originalFields == null) {</span>
<span class="fc" id="L2641">                originalFields = new int[FIELD_COUNT];</span>
            }
<span class="fc bfc" id="L2643" title="All 2 branches covered.">            for (int field = 0; field &lt; FIELD_COUNT; field++) {</span>
<span class="fc" id="L2644">                int value = internalGet(field);</span>
<span class="fc bfc" id="L2645" title="All 2 branches covered.">                if (isExternallySet(field)) {</span>
                    // Quick validation for any out of range values
<span class="pc bpc" id="L2647" title="1 of 4 branches missed.">                    if (value &lt; getMinimum(field) || value &gt; getMaximum(field)) {</span>
<span class="fc" id="L2648">                        throw new IllegalArgumentException(getFieldName(field));</span>
                    }
                }
<span class="fc" id="L2651">                originalFields[field] = value;</span>
            }
        }

        // Let the super class determine which calendar fields to be
        // used to calculate the time.
<span class="fc" id="L2657">        int fieldMask = selectFields();</span>

        // The year defaults to the epoch start. We don't check
        // fieldMask for YEAR because YEAR is a mandatory field to
        // determine the date.
<span class="fc bfc" id="L2662" title="All 2 branches covered.">        int year = isSet(YEAR) ? internalGet(YEAR) : EPOCH_YEAR;</span>

<span class="fc" id="L2664">        int era = internalGetEra();</span>
<span class="fc bfc" id="L2665" title="All 2 branches covered.">        if (era == BCE) {</span>
<span class="fc" id="L2666">            year = 1 - year;</span>
<span class="pc bpc" id="L2667" title="1 of 2 branches missed.">        } else if (era != CE) {</span>
            // Even in lenient mode we disallow ERA values other than CE &amp; BCE.
            // (The same normalization rule as add()/roll() could be
            // applied here in lenient mode. But this checking is kept
            // unchanged for compatibility as of 1.5.)
<span class="nc" id="L2672">            throw new IllegalArgumentException(&quot;Invalid era&quot;);</span>
        }

        // If year is 0 or negative, we need to set the ERA value later.
<span class="fc bfc" id="L2676" title="All 4 branches covered.">        if (year &lt;= 0 &amp;&amp; !isSet(ERA)) {</span>
<span class="fc" id="L2677">            fieldMask |= ERA_MASK;</span>
<span class="fc" id="L2678">            setFieldsComputed(ERA_MASK);</span>
        }

        // Calculate the time of day. We rely on the convention that
        // an UNSET field has 0.
<span class="fc" id="L2683">        long timeOfDay = 0;</span>
<span class="fc bfc" id="L2684" title="All 2 branches covered.">        if (isFieldSet(fieldMask, HOUR_OF_DAY)) {</span>
<span class="fc" id="L2685">            timeOfDay += (long) internalGet(HOUR_OF_DAY);</span>
        } else {
<span class="fc" id="L2687">            timeOfDay += internalGet(HOUR);</span>
            // The default value of AM_PM is 0 which designates AM.
<span class="pc bpc" id="L2689" title="1 of 2 branches missed.">            if (isFieldSet(fieldMask, AM_PM)) {</span>
<span class="nc" id="L2690">                timeOfDay += 12 * internalGet(AM_PM);</span>
            }
        }
<span class="fc" id="L2693">        timeOfDay *= 60;</span>
<span class="fc" id="L2694">        timeOfDay += internalGet(MINUTE);</span>
<span class="fc" id="L2695">        timeOfDay *= 60;</span>
<span class="fc" id="L2696">        timeOfDay += internalGet(SECOND);</span>
<span class="fc" id="L2697">        timeOfDay *= 1000;</span>
<span class="fc" id="L2698">        timeOfDay += internalGet(MILLISECOND);</span>

        // Convert the time of day to the number of days and the
        // millisecond offset from midnight.
<span class="fc" id="L2702">        long fixedDate = timeOfDay / ONE_DAY;</span>
<span class="fc" id="L2703">        timeOfDay %= ONE_DAY;</span>
<span class="fc bfc" id="L2704" title="All 2 branches covered.">        while (timeOfDay &lt; 0) {</span>
<span class="fc" id="L2705">            timeOfDay += ONE_DAY;</span>
<span class="fc" id="L2706">            --fixedDate;</span>
        }

        // Calculate the fixed date since January 1, 1 (Gregorian).
        calculateFixedDate: {
            long gfd, jfd;
<span class="pc bpc" id="L2712" title="1 of 4 branches missed.">            if (year &gt; gregorianCutoverYear &amp;&amp; year &gt; gregorianCutoverYearJulian) {</span>
<span class="fc" id="L2713">                gfd = fixedDate + getFixedDate(gcal, year, fieldMask);</span>
<span class="pc bpc" id="L2714" title="1 of 2 branches missed.">                if (gfd &gt;= gregorianCutoverDate) {</span>
<span class="fc" id="L2715">                    fixedDate = gfd;</span>
<span class="fc" id="L2716">                    break calculateFixedDate;</span>
                }
<span class="nc" id="L2718">                jfd = fixedDate + getFixedDate(getJulianCalendarSystem(), year, fieldMask);</span>
<span class="pc bpc" id="L2719" title="2 of 4 branches missed.">            } else if (year &lt; gregorianCutoverYear &amp;&amp; year &lt; gregorianCutoverYearJulian) {</span>
<span class="fc" id="L2720">                jfd = fixedDate + getFixedDate(getJulianCalendarSystem(), year, fieldMask);</span>
<span class="pc bpc" id="L2721" title="1 of 2 branches missed.">                if (jfd &lt; gregorianCutoverDate) {</span>
<span class="fc" id="L2722">                    fixedDate = jfd;</span>
<span class="fc" id="L2723">                    break calculateFixedDate;</span>
                }
<span class="nc" id="L2725">                gfd = jfd;</span>
            } else {
<span class="nc" id="L2727">                jfd = fixedDate + getFixedDate(getJulianCalendarSystem(), year, fieldMask);</span>
<span class="nc" id="L2728">                gfd = fixedDate + getFixedDate(gcal, year, fieldMask);</span>
            }

            // Now we have to determine which calendar date it is.

            // If the date is relative from the beginning of the year
            // in the Julian calendar, then use jfd;
<span class="nc bnc" id="L2735" title="All 4 branches missed.">            if (isFieldSet(fieldMask, DAY_OF_YEAR) || isFieldSet(fieldMask, WEEK_OF_YEAR)) {</span>
<span class="nc bnc" id="L2736" title="All 2 branches missed.">                if (gregorianCutoverYear == gregorianCutoverYearJulian) {</span>
<span class="nc" id="L2737">                    fixedDate = jfd;</span>
<span class="nc" id="L2738">                    break calculateFixedDate;</span>
<span class="nc bnc" id="L2739" title="All 2 branches missed.">                } else if (year == gregorianCutoverYear) {</span>
<span class="nc" id="L2740">                    fixedDate = gfd;</span>
<span class="nc" id="L2741">                    break calculateFixedDate;</span>
                }
            }

<span class="nc bnc" id="L2745" title="All 2 branches missed.">            if (gfd &gt;= gregorianCutoverDate) {</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">                if (jfd &gt;= gregorianCutoverDate) {</span>
<span class="nc" id="L2747">                    fixedDate = gfd;</span>
                } else {
                    // The date is in an &quot;overlapping&quot; period. No way
                    // to disambiguate it. Determine it using the
                    // previous date calculation.
<span class="nc bnc" id="L2752" title="All 4 branches missed.">                    if (calsys == gcal || calsys == null) {</span>
<span class="nc" id="L2753">                        fixedDate = gfd;</span>
                    } else {
<span class="nc" id="L2755">                        fixedDate = jfd;</span>
                    }
                }
            } else {
<span class="nc bnc" id="L2759" title="All 2 branches missed.">                if (jfd &lt; gregorianCutoverDate) {</span>
<span class="nc" id="L2760">                    fixedDate = jfd;</span>
                } else {
                    // The date is in a &quot;missing&quot; period.
<span class="nc bnc" id="L2763" title="All 2 branches missed.">                    if (!isLenient()) {</span>
<span class="nc" id="L2764">                        throw new IllegalArgumentException(&quot;the specified date doesn't exist&quot;);</span>
                    }
                    // Take the Julian date for compatibility, which
                    // will produce a Gregorian date.
<span class="nc" id="L2768">                    fixedDate = jfd;</span>
                }
            }
        }

        // millis represents local wall-clock time in milliseconds.
<span class="fc" id="L2774">        long millis = (fixedDate - EPOCH_OFFSET) * ONE_DAY + timeOfDay;</span>

        // Compute the time zone offset and DST offset.  There are two potential
        // ambiguities here.  We'll assume a 2:00 am (wall time) switchover time
        // for discussion purposes here.
        // 1. The transition into DST.  Here, a designated time of 2:00 am - 2:59 am
        //    can be in standard or in DST depending.  However, 2:00 am is an invalid
        //    representation (the representation jumps from 1:59:59 am Std to 3:00:00 am DST).
        //    We assume standard time.
        // 2. The transition out of DST.  Here, a designated time of 1:00 am - 1:59 am
        //    can be in standard or DST.  Both are valid representations (the rep
        //    jumps from 1:59:59 DST to 1:00:00 Std).
        //    Again, we assume standard time.
        // We use the TimeZone object, unless the user has explicitly set the ZONE_OFFSET
        // or DST_OFFSET fields; then we use those fields.
<span class="fc" id="L2789">        TimeZone zone = getZone();</span>
<span class="fc bfc" id="L2790" title="All 2 branches covered.">        if (zoneOffsets == null) {</span>
<span class="fc" id="L2791">            zoneOffsets = new int[2];</span>
        }
<span class="fc" id="L2793">        int tzMask = fieldMask &amp; (ZONE_OFFSET_MASK|DST_OFFSET_MASK);</span>
<span class="fc bfc" id="L2794" title="All 2 branches covered.">        if (tzMask != (ZONE_OFFSET_MASK|DST_OFFSET_MASK)) {</span>
<span class="fc bfc" id="L2795" title="All 2 branches covered.">            if (zone instanceof ZoneInfo) {</span>
<span class="fc" id="L2796">                ((ZoneInfo)zone).getOffsetsByWall(millis, zoneOffsets);</span>
            } else {
<span class="pc bpc" id="L2798" title="1 of 2 branches missed.">                int gmtOffset = isFieldSet(fieldMask, ZONE_OFFSET) ?</span>
<span class="pc" id="L2799">                                    internalGet(ZONE_OFFSET) : zone.getRawOffset();</span>
<span class="fc" id="L2800">                zone.getOffsets(millis - gmtOffset, zoneOffsets);</span>
            }
        }
<span class="fc bfc" id="L2803" title="All 2 branches covered.">        if (tzMask != 0) {</span>
<span class="fc bfc" id="L2804" title="All 2 branches covered.">            if (isFieldSet(tzMask, ZONE_OFFSET)) {</span>
<span class="fc" id="L2805">                zoneOffsets[0] = internalGet(ZONE_OFFSET);</span>
            }
<span class="pc bpc" id="L2807" title="1 of 2 branches missed.">            if (isFieldSet(tzMask, DST_OFFSET)) {</span>
<span class="fc" id="L2808">                zoneOffsets[1] = internalGet(DST_OFFSET);</span>
            }
        }

        // Adjust the time zone offset values to get the UTC time.
<span class="fc" id="L2813">        millis -= zoneOffsets[0] + zoneOffsets[1];</span>

        // Set this calendar's time in milliseconds
<span class="fc" id="L2816">        time = millis;</span>

<span class="fc" id="L2818">        int mask = computeFields(fieldMask | getSetStateFields(), tzMask);</span>

<span class="fc bfc" id="L2820" title="All 2 branches covered.">        if (!isLenient()) {</span>
<span class="fc bfc" id="L2821" title="All 2 branches covered.">            for (int field = 0; field &lt; FIELD_COUNT; field++) {</span>
<span class="fc bfc" id="L2822" title="All 2 branches covered.">                if (!isExternallySet(field)) {</span>
<span class="fc" id="L2823">                    continue;</span>
                }
<span class="pc bpc" id="L2825" title="1 of 2 branches missed.">                if (originalFields[field] != internalGet(field)) {</span>
<span class="nc" id="L2826">                    String s = originalFields[field] + &quot; -&gt; &quot; + internalGet(field);</span>
                    // Restore the original field values
<span class="nc" id="L2828">                    System.arraycopy(originalFields, 0, fields, 0, fields.length);</span>
<span class="nc" id="L2829">                    throw new IllegalArgumentException(getFieldName(field) + &quot;: &quot; + s);</span>
                }
            }
        }
<span class="fc" id="L2833">        setFieldsNormalized(mask);</span>
<span class="fc" id="L2834">    }</span>

    /**
     * Computes the fixed date under either the Gregorian or the
     * Julian calendar, using the given year and the specified calendar fields.
     *
     * @param cal the CalendarSystem to be used for the date calculation
     * @param year the normalized year number, with 0 indicating the
     * year 1 BCE, -1 indicating 2 BCE, etc.
     * @param fieldMask the calendar fields to be used for the date calculation
     * @return the fixed date
     * @see Calendar#selectFields
     */
    private long getFixedDate(BaseCalendar cal, int year, int fieldMask) {
<span class="fc" id="L2848">        int month = JANUARY;</span>
<span class="fc bfc" id="L2849" title="All 2 branches covered.">        if (isFieldSet(fieldMask, MONTH)) {</span>
            // No need to check if MONTH has been set (no isSet(MONTH)
            // call) since its unset value happens to be JANUARY (0).
<span class="fc" id="L2852">            month = internalGet(MONTH);</span>

            // If the month is out of range, adjust it into range
<span class="pc bpc" id="L2855" title="1 of 2 branches missed.">            if (month &gt; DECEMBER) {</span>
<span class="nc" id="L2856">                year += month / 12;</span>
<span class="nc" id="L2857">                month %= 12;</span>
<span class="fc bfc" id="L2858" title="All 2 branches covered.">            } else if (month &lt; JANUARY) {</span>
<span class="fc" id="L2859">                int[] rem = new int[1];</span>
<span class="fc" id="L2860">                year += CalendarUtils.floorDivide(month, 12, rem);</span>
<span class="fc" id="L2861">                month = rem[0];</span>
            }
        }

        // Get the fixed date since Jan 1, 1 (Gregorian). We are on
        // the first day of either `month' or January in 'year'.
<span class="fc bfc" id="L2867" title="All 2 branches covered.">        long fixedDate = cal.getFixedDate(year, month + 1, 1,</span>
                                          cal == gcal ? gdate : null);
<span class="fc bfc" id="L2869" title="All 2 branches covered.">        if (isFieldSet(fieldMask, MONTH)) {</span>
            // Month-based calculations
<span class="fc bfc" id="L2871" title="All 2 branches covered.">            if (isFieldSet(fieldMask, DAY_OF_MONTH)) {</span>
                // We are on the first day of the month. Just add the
                // offset if DAY_OF_MONTH is set. If the isSet call
                // returns false, that means DAY_OF_MONTH has been
                // selected just because of the selected
                // combination. We don't need to add any since the
                // default value is the 1st.
<span class="fc bfc" id="L2878" title="All 2 branches covered.">                if (isSet(DAY_OF_MONTH)) {</span>
                    // To avoid underflow with DAY_OF_MONTH-1, add
                    // DAY_OF_MONTH, then subtract 1.
<span class="fc" id="L2881">                    fixedDate += internalGet(DAY_OF_MONTH);</span>
<span class="fc" id="L2882">                    fixedDate--;</span>
                }
            } else {
<span class="pc bpc" id="L2885" title="1 of 2 branches missed.">                if (isFieldSet(fieldMask, WEEK_OF_MONTH)) {</span>
<span class="fc" id="L2886">                    long firstDayOfWeek = BaseCalendar.getDayOfWeekDateOnOrBefore(fixedDate + 6,</span>
<span class="fc" id="L2887">                                                                                  getFirstDayOfWeek());</span>
                    // If we have enough days in the first week, then
                    // move to the previous week.
<span class="pc bpc" id="L2890" title="1 of 2 branches missed.">                    if ((firstDayOfWeek - fixedDate) &gt;= getMinimalDaysInFirstWeek()) {</span>
<span class="nc" id="L2891">                        firstDayOfWeek -= 7;</span>
                    }
<span class="pc bpc" id="L2893" title="1 of 2 branches missed.">                    if (isFieldSet(fieldMask, DAY_OF_WEEK)) {</span>
<span class="fc" id="L2894">                        firstDayOfWeek = BaseCalendar.getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6,</span>
<span class="fc" id="L2895">                                                                                 internalGet(DAY_OF_WEEK));</span>
                    }
                    // In lenient mode, we treat days of the previous
                    // months as a part of the specified
                    // WEEK_OF_MONTH. See 4633646.
<span class="fc" id="L2900">                    fixedDate = firstDayOfWeek + 7 * (internalGet(WEEK_OF_MONTH) - 1);</span>
<span class="fc" id="L2901">                } else {</span>
                    int dayOfWeek;
<span class="nc bnc" id="L2903" title="All 2 branches missed.">                    if (isFieldSet(fieldMask, DAY_OF_WEEK)) {</span>
<span class="nc" id="L2904">                        dayOfWeek = internalGet(DAY_OF_WEEK);</span>
                    } else {
<span class="nc" id="L2906">                        dayOfWeek = getFirstDayOfWeek();</span>
                    }
                    // We are basing this on the day-of-week-in-month.  The only
                    // trickiness occurs if the day-of-week-in-month is
                    // negative.
                    int dowim;
<span class="nc bnc" id="L2912" title="All 2 branches missed.">                    if (isFieldSet(fieldMask, DAY_OF_WEEK_IN_MONTH)) {</span>
<span class="nc" id="L2913">                        dowim = internalGet(DAY_OF_WEEK_IN_MONTH);</span>
                    } else {
<span class="nc" id="L2915">                        dowim = 1;</span>
                    }
<span class="nc bnc" id="L2917" title="All 2 branches missed.">                    if (dowim &gt;= 0) {</span>
<span class="nc" id="L2918">                        fixedDate = BaseCalendar.getDayOfWeekDateOnOrBefore(fixedDate + (7 * dowim) - 1,</span>
                                                                            dayOfWeek);
                    } else {
                        // Go to the first day of the next week of
                        // the specified week boundary.
<span class="nc" id="L2923">                        int lastDate = monthLength(month, year) + (7 * (dowim + 1));</span>
                        // Then, get the day of week date on or before the last date.
<span class="nc" id="L2925">                        fixedDate = BaseCalendar.getDayOfWeekDateOnOrBefore(fixedDate + lastDate - 1,</span>
                                                                            dayOfWeek);
                    }
<span class="nc" id="L2928">                }</span>
            }
        } else {
<span class="pc bpc" id="L2931" title="7 of 8 branches missed.">            if (year == gregorianCutoverYear &amp;&amp; cal == gcal</span>
                &amp;&amp; fixedDate &lt; gregorianCutoverDate
                &amp;&amp; gregorianCutoverYear != gregorianCutoverYearJulian) {
                // January 1 of the year doesn't exist.  Use
                // gregorianCutoverDate as the first day of the
                // year.
<span class="nc" id="L2937">                fixedDate = gregorianCutoverDate;</span>
            }
            // We are on the first day of the year.
<span class="pc bpc" id="L2940" title="1 of 2 branches missed.">            if (isFieldSet(fieldMask, DAY_OF_YEAR)) {</span>
                // Add the offset, then subtract 1. (Make sure to avoid underflow.)
<span class="nc" id="L2942">                fixedDate += internalGet(DAY_OF_YEAR);</span>
<span class="nc" id="L2943">                fixedDate--;</span>
            } else {
<span class="fc" id="L2945">                long firstDayOfWeek = BaseCalendar.getDayOfWeekDateOnOrBefore(fixedDate + 6,</span>
<span class="fc" id="L2946">                                                                              getFirstDayOfWeek());</span>
                // If we have enough days in the first week, then move
                // to the previous week.
<span class="fc bfc" id="L2949" title="All 2 branches covered.">                if ((firstDayOfWeek - fixedDate) &gt;= getMinimalDaysInFirstWeek()) {</span>
<span class="fc" id="L2950">                    firstDayOfWeek -= 7;</span>
                }
<span class="pc bpc" id="L2952" title="1 of 2 branches missed.">                if (isFieldSet(fieldMask, DAY_OF_WEEK)) {</span>
<span class="fc" id="L2953">                    int dayOfWeek = internalGet(DAY_OF_WEEK);</span>
<span class="fc bfc" id="L2954" title="All 2 branches covered.">                    if (dayOfWeek != getFirstDayOfWeek()) {</span>
<span class="fc" id="L2955">                        firstDayOfWeek = BaseCalendar.getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6,</span>
                                                                                 dayOfWeek);
                    }
                }
<span class="fc" id="L2959">                fixedDate = firstDayOfWeek + 7 * ((long)internalGet(WEEK_OF_YEAR) - 1);</span>
            }
        }

<span class="fc" id="L2963">        return fixedDate;</span>
    }

    /**
     * Returns this object if it's normalized (all fields and time are
     * in sync). Otherwise, a cloned object is returned after calling
     * complete() in lenient mode.
     */
    private GregorianCalendar getNormalizedCalendar() {
        GregorianCalendar gc;
<span class="nc bnc" id="L2973" title="All 2 branches missed.">        if (isFullyNormalized()) {</span>
<span class="nc" id="L2974">            gc = this;</span>
        } else {
            // Create a clone and normalize the calendar fields
<span class="nc" id="L2977">            gc = (GregorianCalendar) this.clone();</span>
<span class="nc" id="L2978">            gc.setLenient(true);</span>
<span class="nc" id="L2979">            gc.complete();</span>
        }
<span class="nc" id="L2981">        return gc;</span>
    }

    /**
     * Returns the Julian calendar system instance (singleton). 'jcal'
     * and 'jeras' are set upon the return.
     */
    private static synchronized BaseCalendar getJulianCalendarSystem() {
<span class="fc bfc" id="L2989" title="All 2 branches covered.">        if (jcal == null) {</span>
<span class="fc" id="L2990">            jcal = (JulianCalendar) CalendarSystem.forName(&quot;julian&quot;);</span>
<span class="fc" id="L2991">            jeras = jcal.getEras();</span>
        }
<span class="fc" id="L2993">        return jcal;</span>
    }

    /**
     * Returns the calendar system for dates before the cutover date
     * in the cutover year. If the cutover date is January 1, the
     * method returns Gregorian. Otherwise, Julian.
     */
    private BaseCalendar getCutoverCalendarSystem() {
<span class="nc bnc" id="L3002" title="All 2 branches missed.">        if (gregorianCutoverYearJulian &lt; gregorianCutoverYear) {</span>
<span class="nc" id="L3003">            return gcal;</span>
        }
<span class="nc" id="L3005">        return getJulianCalendarSystem();</span>
    }

    /**
     * Determines if the specified year (normalized) is the Gregorian
     * cutover year. This object must have been normalized.
     */
    private boolean isCutoverYear(int normalizedYear) {
<span class="nc bnc" id="L3013" title="All 2 branches missed.">        int cutoverYear = (calsys == gcal) ? gregorianCutoverYear : gregorianCutoverYearJulian;</span>
<span class="nc bnc" id="L3014" title="All 2 branches missed.">        return normalizedYear == cutoverYear;</span>
    }

    /**
     * Returns the fixed date of the first day of the year (usually
     * January 1) before the specified date.
     *
     * @param date the date for which the first day of the year is
     * calculated. The date has to be in the cut-over year (Gregorian
     * or Julian).
     * @param fixedDate the fixed date representation of the date
     */
    private long getFixedDateJan1(BaseCalendar.Date date, long fixedDate) {
<span class="nc bnc" id="L3027" title="All 4 branches missed.">        assert date.getNormalizedYear() == gregorianCutoverYear ||</span>
<span class="nc bnc" id="L3028" title="All 2 branches missed.">            date.getNormalizedYear() == gregorianCutoverYearJulian;</span>
<span class="nc bnc" id="L3029" title="All 2 branches missed.">        if (gregorianCutoverYear != gregorianCutoverYearJulian) {</span>
<span class="nc bnc" id="L3030" title="All 2 branches missed.">            if (fixedDate &gt;= gregorianCutoverDate) {</span>
                // Dates before the cutover date don't exist
                // in the same (Gregorian) year. So, no
                // January 1 exists in the year. Use the
                // cutover date as the first day of the year.
<span class="nc" id="L3035">                return gregorianCutoverDate;</span>
            }
        }
        // January 1 of the normalized year should exist.
<span class="nc" id="L3039">        BaseCalendar juliancal = getJulianCalendarSystem();</span>
<span class="nc" id="L3040">        return juliancal.getFixedDate(date.getNormalizedYear(), BaseCalendar.JANUARY, 1, null);</span>
    }

    /**
     * Returns the fixed date of the first date of the month (usually
     * the 1st of the month) before the specified date.
     *
     * @param date the date for which the first day of the month is
     * calculated. The date has to be in the cut-over year (Gregorian
     * or Julian).
     * @param fixedDate the fixed date representation of the date
     */
    private long getFixedDateMonth1(BaseCalendar.Date date, long fixedDate) {
<span class="nc bnc" id="L3053" title="All 4 branches missed.">        assert date.getNormalizedYear() == gregorianCutoverYear ||</span>
<span class="nc bnc" id="L3054" title="All 2 branches missed.">            date.getNormalizedYear() == gregorianCutoverYearJulian;</span>
<span class="nc" id="L3055">        BaseCalendar.Date gCutover = getGregorianCutoverDate();</span>
<span class="nc bnc" id="L3056" title="All 2 branches missed.">        if (gCutover.getMonth() == BaseCalendar.JANUARY</span>
<span class="nc bnc" id="L3057" title="All 2 branches missed.">            &amp;&amp; gCutover.getDayOfMonth() == 1) {</span>
            // The cutover happened on January 1.
<span class="nc" id="L3059">            return fixedDate - date.getDayOfMonth() + 1;</span>
        }

        long fixedDateMonth1;
        // The cutover happened sometime during the year.
<span class="nc bnc" id="L3064" title="All 2 branches missed.">        if (date.getMonth() == gCutover.getMonth()) {</span>
            // The cutover happened in the month.
<span class="nc" id="L3066">            BaseCalendar.Date jLastDate = getLastJulianDate();</span>
<span class="nc bnc" id="L3067" title="All 2 branches missed.">            if (gregorianCutoverYear == gregorianCutoverYearJulian</span>
<span class="nc bnc" id="L3068" title="All 2 branches missed.">                &amp;&amp; gCutover.getMonth() == jLastDate.getMonth()) {</span>
                // The &quot;gap&quot; fits in the same month.
<span class="nc" id="L3070">                fixedDateMonth1 = jcal.getFixedDate(date.getNormalizedYear(),</span>
<span class="nc" id="L3071">                                                    date.getMonth(),</span>
                                                    1,
                                                    null);
            } else {
                // Use the cutover date as the first day of the month.
<span class="nc" id="L3076">                fixedDateMonth1 = gregorianCutoverDate;</span>
            }
<span class="nc" id="L3078">        } else {</span>
            // The cutover happened before the month.
<span class="nc" id="L3080">            fixedDateMonth1 = fixedDate - date.getDayOfMonth() + 1;</span>
        }

<span class="nc" id="L3083">        return fixedDateMonth1;</span>
    }

    /**
     * Returns a CalendarDate produced from the specified fixed date.
     *
     * @param fd the fixed date
     */
    private BaseCalendar.Date getCalendarDate(long fd) {
<span class="nc bnc" id="L3092" title="All 2 branches missed.">        BaseCalendar cal = (fd &gt;= gregorianCutoverDate) ? gcal : getJulianCalendarSystem();</span>
<span class="nc" id="L3093">        BaseCalendar.Date d = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="nc" id="L3094">        cal.getCalendarDateFromFixedDate(d, fd);</span>
<span class="nc" id="L3095">        return d;</span>
    }

    /**
     * Returns the Gregorian cutover date as a BaseCalendar.Date. The
     * date is a Gregorian date.
     */
    private BaseCalendar.Date getGregorianCutoverDate() {
<span class="nc" id="L3103">        return getCalendarDate(gregorianCutoverDate);</span>
    }

    /**
     * Returns the day before the Gregorian cutover date as a
     * BaseCalendar.Date. The date is a Julian date.
     */
    private BaseCalendar.Date getLastJulianDate() {
<span class="nc" id="L3111">        return getCalendarDate(gregorianCutoverDate - 1);</span>
    }

    /**
     * Returns the length of the specified month in the specified
     * year. The year number must be normalized.
     *
     * @see #isLeapYear(int)
     */
    private int monthLength(int month, int year) {
<span class="pc bpc" id="L3121" title="1 of 2 branches missed.">        return isLeapYear(year) ? LEAP_MONTH_LENGTH[month] : MONTH_LENGTH[month];</span>
    }

    /**
     * Returns the length of the specified month in the year provided
     * by internalGet(YEAR).
     *
     * @see #isLeapYear(int)
     */
    private int monthLength(int month) {
<span class="fc" id="L3131">        int year = internalGet(YEAR);</span>
<span class="pc bpc" id="L3132" title="1 of 2 branches missed.">        if (internalGetEra() == BCE) {</span>
<span class="nc" id="L3133">            year = 1 - year;</span>
        }
<span class="fc" id="L3135">        return monthLength(month, year);</span>
    }

    private int actualMonthLength() {
<span class="nc" id="L3139">        int year = cdate.getNormalizedYear();</span>
<span class="nc bnc" id="L3140" title="All 4 branches missed.">        if (year != gregorianCutoverYear &amp;&amp; year != gregorianCutoverYearJulian) {</span>
<span class="nc" id="L3141">            return calsys.getMonthLength(cdate);</span>
        }
<span class="nc" id="L3143">        BaseCalendar.Date date = (BaseCalendar.Date) cdate.clone();</span>
<span class="nc" id="L3144">        long fd = calsys.getFixedDate(date);</span>
<span class="nc" id="L3145">        long month1 = getFixedDateMonth1(date, fd);</span>
<span class="nc" id="L3146">        long next1 = month1 + calsys.getMonthLength(date);</span>
<span class="nc bnc" id="L3147" title="All 2 branches missed.">        if (next1 &lt; gregorianCutoverDate) {</span>
<span class="nc" id="L3148">            return (int)(next1 - month1);</span>
        }
<span class="nc bnc" id="L3150" title="All 2 branches missed.">        if (cdate != gdate) {</span>
<span class="nc" id="L3151">            date = (BaseCalendar.Date) gcal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
        }
<span class="nc" id="L3153">        gcal.getCalendarDateFromFixedDate(date, next1);</span>
<span class="nc" id="L3154">        next1 = getFixedDateMonth1(date, next1);</span>
<span class="nc" id="L3155">        return (int)(next1 - month1);</span>
    }

    /**
     * Returns the length (in days) of the specified year. The year
     * must be normalized.
     */
    private int yearLength(int year) {
<span class="nc bnc" id="L3163" title="All 2 branches missed.">        return isLeapYear(year) ? 366 : 365;</span>
    }

    /**
     * Returns the length (in days) of the year provided by
     * internalGet(YEAR).
     */
    private int yearLength() {
<span class="nc" id="L3171">        int year = internalGet(YEAR);</span>
<span class="nc bnc" id="L3172" title="All 2 branches missed.">        if (internalGetEra() == BCE) {</span>
<span class="nc" id="L3173">            year = 1 - year;</span>
        }
<span class="nc" id="L3175">        return yearLength(year);</span>
    }

    /**
     * After adjustments such as add(MONTH), add(YEAR), we don't want the
     * month to jump around.  E.g., we don't want Jan 31 + 1 month to go to Mar
     * 3, we want it to go to Feb 28.  Adjustments which might run into this
     * problem call this method to retain the proper month.
     */
    private void pinDayOfMonth() {
<span class="fc" id="L3185">        int year = internalGet(YEAR);</span>
        int monthLen;
<span class="pc bpc" id="L3187" title="3 of 4 branches missed.">        if (year &gt; gregorianCutoverYear || year &lt; gregorianCutoverYearJulian) {</span>
<span class="fc" id="L3188">            monthLen = monthLength(internalGet(MONTH));</span>
        } else {
<span class="nc" id="L3190">            GregorianCalendar gc = getNormalizedCalendar();</span>
<span class="nc" id="L3191">            monthLen = gc.getActualMaximum(DAY_OF_MONTH);</span>
        }
<span class="fc" id="L3193">        int dom = internalGet(DAY_OF_MONTH);</span>
<span class="pc bpc" id="L3194" title="1 of 2 branches missed.">        if (dom &gt; monthLen) {</span>
<span class="nc" id="L3195">            set(DAY_OF_MONTH, monthLen);</span>
        }
<span class="fc" id="L3197">    }</span>

    /**
     * Returns the fixed date value of this object. The time value and
     * calendar fields must be in synch.
     */
    private long getCurrentFixedDate() {
<span class="pc bpc" id="L3204" title="1 of 2 branches missed.">        return (calsys == gcal) ? cachedFixedDate : calsys.getFixedDate(cdate);</span>
    }

    /**
     * Returns the new value after 'roll'ing the specified value and amount.
     */
    private static int getRolledValue(int value, int amount, int min, int max) {
<span class="nc bnc" id="L3211" title="All 6 branches missed.">        assert value &gt;= min &amp;&amp; value &lt;= max;</span>
<span class="nc" id="L3212">        int range = max - min + 1;</span>
<span class="nc" id="L3213">        amount %= range;</span>
<span class="nc" id="L3214">        int n = value + amount;</span>
<span class="nc bnc" id="L3215" title="All 2 branches missed.">        if (n &gt; max) {</span>
<span class="nc" id="L3216">            n -= range;</span>
<span class="nc bnc" id="L3217" title="All 2 branches missed.">        } else if (n &lt; min) {</span>
<span class="nc" id="L3218">            n += range;</span>
        }
<span class="nc bnc" id="L3220" title="All 6 branches missed.">        assert n &gt;= min &amp;&amp; n &lt;= max;</span>
<span class="nc" id="L3221">        return n;</span>
    }

    /**
     * Returns the ERA.  We need a special method for this because the
     * default ERA is CE, but a zero (unset) ERA is BCE.
     */
    private int internalGetEra() {
<span class="fc bfc" id="L3229" title="All 2 branches covered.">        return isSet(ERA) ? internalGet(ERA) : CE;</span>
    }

    /**
     * Updates internal state.
     */
    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
<span class="nc" id="L3237">        stream.defaultReadObject();</span>
<span class="nc bnc" id="L3238" title="All 2 branches missed.">        if (gdate == null) {</span>
<span class="nc" id="L3239">            gdate = (BaseCalendar.Date) gcal.newCalendarDate(getZone());</span>
<span class="nc" id="L3240">            cachedFixedDate = Long.MIN_VALUE;</span>
        }
<span class="nc" id="L3242">        setGregorianChange(gregorianCutover);</span>
<span class="nc" id="L3243">    }</span>

    /**
     * Converts this object to a {@code ZonedDateTime} that represents
     * the same point on the time-line as this {@code GregorianCalendar}.
     * &lt;p&gt;
     * Since this object supports a Julian-Gregorian cutover date and
     * {@code ZonedDateTime} does not, it is possible that the resulting year,
     * month and day will have different values.  The result will represent the
     * correct date in the ISO calendar system, which will also be the same value
     * for Modified Julian Days.
     *
     * @return a zoned date-time representing the same point on the time-line
     *  as this gregorian calendar
     * @since 1.8
     */
    public ZonedDateTime toZonedDateTime() {
<span class="nc" id="L3260">        return ZonedDateTime.ofInstant(Instant.ofEpochMilli(getTimeInMillis()),</span>
<span class="nc" id="L3261">                                       getTimeZone().toZoneId());</span>
    }

    /**
     * Obtains an instance of {@code GregorianCalendar} with the default locale
     * from a {@code ZonedDateTime} object.
     * &lt;p&gt;
     * Since {@code ZonedDateTime} does not support a Julian-Gregorian cutover
     * date and uses ISO calendar system, the return GregorianCalendar is a pure
     * Gregorian calendar and uses ISO 8601 standard for week definitions,
     * which has {@code MONDAY} as the {@link Calendar#getFirstDayOfWeek()
     * FirstDayOfWeek} and {@code 4} as the value of the
     * {@link Calendar#getMinimalDaysInFirstWeek() MinimalDaysInFirstWeek}.
     * &lt;p&gt;
     * {@code ZoneDateTime} can store points on the time-line further in the
     * future and further in the past than {@code GregorianCalendar}. In this
     * scenario, this method will throw an {@code IllegalArgumentException}
     * exception.
     *
     * @param zdt  the zoned date-time object to convert
     * @return  the gregorian calendar representing the same point on the
     *  time-line as the zoned date-time provided
     * @exception NullPointerException if {@code zdt} is null
     * @exception IllegalArgumentException if the zoned date-time is too
     * large to represent as a {@code GregorianCalendar}
     * @since 1.8
     */
    public static GregorianCalendar from(ZonedDateTime zdt) {
<span class="nc" id="L3289">        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(zdt.getZone()));</span>
<span class="nc" id="L3290">        cal.setGregorianChange(new Date(Long.MIN_VALUE));</span>
<span class="nc" id="L3291">        cal.setFirstDayOfWeek(MONDAY);</span>
<span class="nc" id="L3292">        cal.setMinimalDaysInFirstWeek(4);</span>
        try {
<span class="nc" id="L3294">            cal.setTimeInMillis(Math.addExact(Math.multiplyExact(zdt.toEpochSecond(), 1000),</span>
<span class="nc" id="L3295">                                              zdt.get(ChronoField.MILLI_OF_SECOND)));</span>
<span class="nc" id="L3296">        } catch (ArithmeticException ex) {</span>
<span class="nc" id="L3297">            throw new IllegalArgumentException(ex);</span>
<span class="nc" id="L3298">        }</span>
<span class="nc" id="L3299">        return cal;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>