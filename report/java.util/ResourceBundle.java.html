<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ResourceBundle.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">ResourceBundle.java</span></div><h1>ResourceBundle.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1999 - All Rights Reserved
 *
 * The original version of this source code and documentation
 * is copyrighted and owned by Taligent, Inc., a wholly-owned
 * subsidiary of IBM. These materials are provided under terms
 * of a License Agreement between Taligent and Sun. This technology
 * is protected by multiple US and International patents.
 *
 * This notice and attribution to Taligent may not be removed.
 * Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.util;

import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.net.JarURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.jar.JarEntry;
import java.util.spi.ResourceBundleControlProvider;

import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;
import sun.util.locale.BaseLocale;
import sun.util.locale.LocaleObjectCache;


/**
 *
 * Resource bundles contain locale-specific objects.  When your program needs a
 * locale-specific resource, a &lt;code&gt;String&lt;/code&gt; for example, your program can
 * load it from the resource bundle that is appropriate for the current user's
 * locale. In this way, you can write program code that is largely independent
 * of the user's locale isolating most, if not all, of the locale-specific
 * information in resource bundles.
 *
 * &lt;p&gt;
 * This allows you to write programs that can:
 * &lt;UL&gt;
 * &lt;LI&gt; be easily localized, or translated, into different languages
 * &lt;LI&gt; handle multiple locales at once
 * &lt;LI&gt; be easily modified later to support even more locales
 * &lt;/UL&gt;
 *
 * &lt;P&gt;
 * Resource bundles belong to families whose members share a common base
 * name, but whose names also have additional components that identify
 * their locales. For example, the base name of a family of resource
 * bundles might be &quot;MyResources&quot;. The family should have a default
 * resource bundle which simply has the same name as its family -
 * &quot;MyResources&quot; - and will be used as the bundle of last resort if a
 * specific locale is not supported. The family can then provide as
 * many locale-specific members as needed, for example a German one
 * named &quot;MyResources_de&quot;.
 *
 * &lt;P&gt;
 * Each resource bundle in a family contains the same items, but the items have
 * been translated for the locale represented by that resource bundle.
 * For example, both &quot;MyResources&quot; and &quot;MyResources_de&quot; may have a
 * &lt;code&gt;String&lt;/code&gt; that's used on a button for canceling operations.
 * In &quot;MyResources&quot; the &lt;code&gt;String&lt;/code&gt; may contain &quot;Cancel&quot; and in
 * &quot;MyResources_de&quot; it may contain &quot;Abbrechen&quot;.
 *
 * &lt;P&gt;
 * If there are different resources for different countries, you
 * can make specializations: for example, &quot;MyResources_de_CH&quot; contains objects for
 * the German language (de) in Switzerland (CH). If you want to only
 * modify some of the resources
 * in the specialization, you can do so.
 *
 * &lt;P&gt;
 * When your program needs a locale-specific object, it loads
 * the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the
 * {@link #getBundle(java.lang.String, java.util.Locale) getBundle}
 * method:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * ResourceBundle myResources =
 *      ResourceBundle.getBundle(&quot;MyResources&quot;, currentLocale);
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;P&gt;
 * Resource bundles contain key/value pairs. The keys uniquely
 * identify a locale-specific object in the bundle. Here's an
 * example of a &lt;code&gt;ListResourceBundle&lt;/code&gt; that contains
 * two key/value pairs:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * public class MyResources extends ListResourceBundle {
 *     protected Object[][] getContents() {
 *         return new Object[][] {
 *             // LOCALIZE THE SECOND STRING OF EACH ARRAY (e.g., &quot;OK&quot;)
 *             {&quot;OkKey&quot;, &quot;OK&quot;},
 *             {&quot;CancelKey&quot;, &quot;Cancel&quot;},
 *             // END OF MATERIAL TO LOCALIZE
 *        };
 *     }
 * }
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 * Keys are always &lt;code&gt;String&lt;/code&gt;s.
 * In this example, the keys are &quot;OkKey&quot; and &quot;CancelKey&quot;.
 * In the above example, the values
 * are also &lt;code&gt;String&lt;/code&gt;s--&quot;OK&quot; and &quot;Cancel&quot;--but
 * they don't have to be. The values can be any type of object.
 *
 * &lt;P&gt;
 * You retrieve an object from resource bundle using the appropriate
 * getter method. Because &quot;OkKey&quot; and &quot;CancelKey&quot;
 * are both strings, you would use &lt;code&gt;getString&lt;/code&gt; to retrieve them:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * button1 = new Button(myResources.getString(&quot;OkKey&quot;));
 * button2 = new Button(myResources.getString(&quot;CancelKey&quot;));
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 * The getter methods all require the key as an argument and return
 * the object if found. If the object is not found, the getter method
 * throws a &lt;code&gt;MissingResourceException&lt;/code&gt;.
 *
 * &lt;P&gt;
 * Besides &lt;code&gt;getString&lt;/code&gt;, &lt;code&gt;ResourceBundle&lt;/code&gt; also provides
 * a method for getting string arrays, &lt;code&gt;getStringArray&lt;/code&gt;,
 * as well as a generic &lt;code&gt;getObject&lt;/code&gt; method for any other
 * type of object. When using &lt;code&gt;getObject&lt;/code&gt;, you'll
 * have to cast the result to the appropriate type. For example:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * int[] myIntegers = (int[]) myResources.getObject(&quot;intList&quot;);
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;P&gt;
 * The Java Platform provides two subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt;,
 * &lt;code&gt;ListResourceBundle&lt;/code&gt; and &lt;code&gt;PropertyResourceBundle&lt;/code&gt;,
 * that provide a fairly simple way to create resources.
 * As you saw briefly in a previous example, &lt;code&gt;ListResourceBundle&lt;/code&gt;
 * manages its resource as a list of key/value pairs.
 * &lt;code&gt;PropertyResourceBundle&lt;/code&gt; uses a properties file to manage
 * its resources.
 *
 * &lt;p&gt;
 * If &lt;code&gt;ListResourceBundle&lt;/code&gt; or &lt;code&gt;PropertyResourceBundle&lt;/code&gt;
 * do not suit your needs, you can write your own &lt;code&gt;ResourceBundle&lt;/code&gt;
 * subclass.  Your subclasses must override two methods: &lt;code&gt;handleGetObject&lt;/code&gt;
 * and &lt;code&gt;getKeys()&lt;/code&gt;.
 *
 * &lt;h3&gt;ResourceBundle.Control&lt;/h3&gt;
 *
 * The {@link ResourceBundle.Control} class provides information necessary
 * to perform the bundle loading process by the &lt;code&gt;getBundle&lt;/code&gt;
 * factory methods that take a &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
 * instance. You can implement your own subclass in order to enable
 * non-standard resource bundle formats, change the search strategy, or
 * define caching parameters. Refer to the descriptions of the class and the
 * {@link #getBundle(String, Locale, ClassLoader, Control) getBundle}
 * factory method for details.
 *
 * &lt;p&gt;&lt;a name=&quot;modify_default_behavior&quot;&gt;For the {@code getBundle} factory&lt;/a&gt;
 * methods that take no {@link Control} instance, their &lt;a
 * href=&quot;#default_behavior&quot;&gt; default behavior&lt;/a&gt; of resource bundle loading
 * can be modified with &lt;em&gt;installed&lt;/em&gt; {@link
 * ResourceBundleControlProvider} implementations. Any installed providers are
 * detected at the {@code ResourceBundle} class loading time. If any of the
 * providers provides a {@link Control} for the given base name, that {@link
 * Control} will be used instead of the default {@link Control}. If there is
 * more than one service provider installed for supporting the same base name,
 * the first one returned from {@link ServiceLoader} will be used.
 *
 * &lt;h3&gt;Cache Management&lt;/h3&gt;
 *
 * Resource bundle instances created by the &lt;code&gt;getBundle&lt;/code&gt; factory
 * methods are cached by default, and the factory methods return the same
 * resource bundle instance multiple times if it has been
 * cached. &lt;code&gt;getBundle&lt;/code&gt; clients may clear the cache, manage the
 * lifetime of cached resource bundle instances using time-to-live values,
 * or specify not to cache resource bundle instances. Refer to the
 * descriptions of the {@linkplain #getBundle(String, Locale, ClassLoader,
 * Control) &lt;code&gt;getBundle&lt;/code&gt; factory method}, {@link
 * #clearCache(ClassLoader) clearCache}, {@link
 * Control#getTimeToLive(String, Locale)
 * ResourceBundle.Control.getTimeToLive}, and {@link
 * Control#needsReload(String, Locale, String, ClassLoader, ResourceBundle,
 * long) ResourceBundle.Control.needsReload} for details.
 *
 * &lt;h3&gt;Example&lt;/h3&gt;
 *
 * The following is a very simple example of a &lt;code&gt;ResourceBundle&lt;/code&gt;
 * subclass, &lt;code&gt;MyResources&lt;/code&gt;, that manages two resources (for a larger number of
 * resources you would probably use a &lt;code&gt;Map&lt;/code&gt;).
 * Notice that you don't need to supply a value if
 * a &quot;parent-level&quot; &lt;code&gt;ResourceBundle&lt;/code&gt; handles the same
 * key with the same value (as for the okKey below).
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * // default (English language, United States)
 * public class MyResources extends ResourceBundle {
 *     public Object handleGetObject(String key) {
 *         if (key.equals(&quot;okKey&quot;)) return &quot;Ok&quot;;
 *         if (key.equals(&quot;cancelKey&quot;)) return &quot;Cancel&quot;;
 *         return null;
 *     }
 *
 *     public Enumeration&amp;lt;String&amp;gt; getKeys() {
 *         return Collections.enumeration(keySet());
 *     }
 *
 *     // Overrides handleKeySet() so that the getKeys() implementation
 *     // can rely on the keySet() value.
 *     protected Set&amp;lt;String&amp;gt; handleKeySet() {
 *         return new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&quot;okKey&quot;, &quot;cancelKey&quot;));
 *     }
 * }
 *
 * // German language
 * public class MyResources_de extends MyResources {
 *     public Object handleGetObject(String key) {
 *         // don't need okKey, since parent level handles it.
 *         if (key.equals(&quot;cancelKey&quot;)) return &quot;Abbrechen&quot;;
 *         return null;
 *     }
 *
 *     protected Set&amp;lt;String&amp;gt; handleKeySet() {
 *         return new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&quot;cancelKey&quot;));
 *     }
 * }
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 * You do not have to restrict yourself to using a single family of
 * &lt;code&gt;ResourceBundle&lt;/code&gt;s. For example, you could have a set of bundles for
 * exception messages, &lt;code&gt;ExceptionResources&lt;/code&gt;
 * (&lt;code&gt;ExceptionResources_fr&lt;/code&gt;, &lt;code&gt;ExceptionResources_de&lt;/code&gt;, ...),
 * and one for widgets, &lt;code&gt;WidgetResource&lt;/code&gt; (&lt;code&gt;WidgetResources_fr&lt;/code&gt;,
 * &lt;code&gt;WidgetResources_de&lt;/code&gt;, ...); breaking up the resources however you like.
 *
 * @see ListResourceBundle
 * @see PropertyResourceBundle
 * @see MissingResourceException
 * @since JDK1.1
 */
<span class="fc bfc" id="L280" title="All 2 branches covered.">public abstract class ResourceBundle {</span>

    /** initial size of the bundle cache */
    private static final int INITIAL_CACHE_SIZE = 32;

    /** constant indicating that no resource bundle exists */
<span class="fc" id="L286">    private static final ResourceBundle NONEXISTENT_BUNDLE = new ResourceBundle() {</span>
<span class="nc" id="L287">            public Enumeration&lt;String&gt; getKeys() { return null; }</span>
<span class="nc" id="L288">            protected Object handleGetObject(String key) { return null; }</span>
<span class="nc" id="L289">            public String toString() { return &quot;NONEXISTENT_BUNDLE&quot;; }</span>
        };


    /**
     * The cache is a map from cache keys (with bundle base name, locale, and
     * class loader) to either a resource bundle or NONEXISTENT_BUNDLE wrapped by a
     * BundleReference.
     *
     * The cache is a ConcurrentMap, allowing the cache to be searched
     * concurrently by multiple threads.  This will also allow the cache keys
     * to be reclaimed along with the ClassLoaders they reference.
     *
     * This variable would be better named &quot;cache&quot;, but we keep the old
     * name for compatibility with some workarounds for bug 4212439.
     */
<span class="fc" id="L305">    private static final ConcurrentMap&lt;CacheKey, BundleReference&gt; cacheList</span>
        = new ConcurrentHashMap&lt;&gt;(INITIAL_CACHE_SIZE);

    /**
     * Queue for reference objects referring to class loaders or bundles.
     */
<span class="fc" id="L311">    private static final ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();</span>

    /**
     * Returns the base name of this bundle, if known, or {@code null} if unknown.
     *
     * If not null, then this is the value of the {@code baseName} parameter
     * that was passed to the {@code ResourceBundle.getBundle(...)} method
     * when the resource bundle was loaded.
     *
     * @return The base name of the resource bundle, as provided to and expected
     * by the {@code ResourceBundle.getBundle(...)} methods.
     *
     * @see #getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)
     *
     * @since 1.8
     */
    public String getBaseBundleName() {
<span class="fc" id="L328">        return name;</span>
    }

    /**
     * The parent bundle of this bundle.
     * The parent bundle is searched by {@link #getObject getObject}
     * when this bundle does not contain a particular resource.
     */
<span class="fc" id="L336">    protected ResourceBundle parent = null;</span>

    /**
     * The locale for this bundle.
     */
<span class="fc" id="L341">    private Locale locale = null;</span>

    /**
     * The base bundle name for this bundle.
     */
    private String name;

    /**
     * The flag indicating this bundle has expired in the cache.
     */
    private volatile boolean expired;

    /**
     * The back link to the cache key. null if this bundle isn't in
     * the cache (yet) or has expired.
     */
    private volatile CacheKey cacheKey;

    /**
     * A Set of the keys contained only in this ResourceBundle.
     */
    private volatile Set&lt;String&gt; keySet;

    private static final List&lt;ResourceBundleControlProvider&gt; providers;

    static {
<span class="fc" id="L367">        List&lt;ResourceBundleControlProvider&gt; list = null;</span>
<span class="fc" id="L368">        ServiceLoader&lt;ResourceBundleControlProvider&gt; serviceLoaders</span>
<span class="fc" id="L369">                = ServiceLoader.loadInstalled(ResourceBundleControlProvider.class);</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">        for (ResourceBundleControlProvider provider : serviceLoaders) {</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">            if (list == null) {</span>
<span class="fc" id="L372">                list = new ArrayList&lt;&gt;();</span>
            }
<span class="fc" id="L374">            list.add(provider);</span>
<span class="fc" id="L375">        }</span>
<span class="fc" id="L376">        providers = list;</span>
<span class="fc" id="L377">    }</span>

    /**
     * Sole constructor.  (For invocation by subclass constructors, typically
     * implicit.)
     */
<span class="fc" id="L383">    public ResourceBundle() {</span>
<span class="fc" id="L384">    }</span>

    /**
     * Gets a string for the given key from this resource bundle or one of its parents.
     * Calling this method is equivalent to calling
     * &lt;blockquote&gt;
     * &lt;code&gt;(String) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
     * &lt;/blockquote&gt;
     *
     * @param key the key for the desired string
     * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @exception MissingResourceException if no object for the given key can be found
     * @exception ClassCastException if the object found for the given key is not a string
     * @return the string for the given key
     */
    public final String getString(String key) {
<span class="fc" id="L400">        return (String) getObject(key);</span>
    }

    /**
     * Gets a string array for the given key from this resource bundle or one of its parents.
     * Calling this method is equivalent to calling
     * &lt;blockquote&gt;
     * &lt;code&gt;(String[]) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
     * &lt;/blockquote&gt;
     *
     * @param key the key for the desired string array
     * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @exception MissingResourceException if no object for the given key can be found
     * @exception ClassCastException if the object found for the given key is not a string array
     * @return the string array for the given key
     */
    public final String[] getStringArray(String key) {
<span class="fc" id="L417">        return (String[]) getObject(key);</span>
    }

    /**
     * Gets an object for the given key from this resource bundle or one of its parents.
     * This method first tries to obtain the object from this resource bundle using
     * {@link #handleGetObject(java.lang.String) handleGetObject}.
     * If not successful, and the parent resource bundle is not null,
     * it calls the parent's &lt;code&gt;getObject&lt;/code&gt; method.
     * If still not successful, it throws a MissingResourceException.
     *
     * @param key the key for the desired object
     * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @exception MissingResourceException if no object for the given key can be found
     * @return the object for the given key
     */
    public final Object getObject(String key) {
<span class="fc" id="L434">        Object obj = handleGetObject(key);</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">        if (obj == null) {</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">            if (parent != null) {</span>
<span class="fc" id="L437">                obj = parent.getObject(key);</span>
            }
<span class="fc bfc" id="L439" title="All 2 branches covered.">            if (obj == null) {</span>
<span class="fc" id="L440">                throw new MissingResourceException(&quot;Can't find resource for bundle &quot;</span>
<span class="fc" id="L441">                                                   +this.getClass().getName()</span>
                                                   +&quot;, key &quot;+key,
<span class="fc" id="L443">                                                   this.getClass().getName(),</span>
                                                   key);
            }
        }
<span class="fc" id="L447">        return obj;</span>
    }

    /**
     * Returns the locale of this resource bundle. This method can be used after a
     * call to getBundle() to determine whether the resource bundle returned really
     * corresponds to the requested locale or is a fallback.
     *
     * @return the locale of this resource bundle
     */
    public Locale getLocale() {
<span class="fc" id="L458">        return locale;</span>
    }

    /*
     * Automatic determination of the ClassLoader to be used to load
     * resources on behalf of the client.
     */
    private static ClassLoader getLoader(Class&lt;?&gt; caller) {
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        ClassLoader cl = caller == null ? null : caller.getClassLoader();</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">        if (cl == null) {</span>
            // When the caller's loader is the boot class loader, cl is null
            // here. In that case, ClassLoader.getSystemClassLoader() may
            // return the same class loader that the application is
            // using. We therefore use a wrapper ClassLoader to create a
            // separate scope for bundles loaded on behalf of the Java
            // runtime so that these bundles cannot be returned from the
            // cache to the application (5048280).
<span class="fc" id="L475">            cl = RBClassLoader.INSTANCE;</span>
        }
<span class="fc" id="L477">        return cl;</span>
    }

    /**
     * A wrapper of ClassLoader.getSystemClassLoader().
     */
    private static class RBClassLoader extends ClassLoader {
<span class="fc" id="L484">        private static final RBClassLoader INSTANCE = AccessController.doPrivileged(</span>
<span class="fc" id="L485">                    new PrivilegedAction&lt;RBClassLoader&gt;() {</span>
                        public RBClassLoader run() {
<span class="fc" id="L487">                            return new RBClassLoader();</span>
                        }
                    });
<span class="fc" id="L490">        private static final ClassLoader loader = ClassLoader.getSystemClassLoader();</span>

<span class="fc" id="L492">        private RBClassLoader() {</span>
<span class="fc" id="L493">        }</span>
        public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">            if (loader != null) {</span>
<span class="fc" id="L496">                return loader.loadClass(name);</span>
            }
<span class="nc" id="L498">            return Class.forName(name);</span>
        }
        public URL getResource(String name) {
<span class="nc bnc" id="L501" title="All 2 branches missed.">            if (loader != null) {</span>
<span class="nc" id="L502">                return loader.getResource(name);</span>
            }
<span class="nc" id="L504">            return ClassLoader.getSystemResource(name);</span>
        }
        public InputStream getResourceAsStream(String name) {
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">            if (loader != null) {</span>
<span class="fc" id="L508">                return loader.getResourceAsStream(name);</span>
            }
<span class="nc" id="L510">            return ClassLoader.getSystemResourceAsStream(name);</span>
        }
    }

    /**
     * Sets the parent bundle of this bundle.
     * The parent bundle is searched by {@link #getObject getObject}
     * when this bundle does not contain a particular resource.
     *
     * @param parent this bundle's parent bundle.
     */
    protected void setParent(ResourceBundle parent) {
<span class="pc bpc" id="L522" title="1 of 4 branches missed.">        assert parent != NONEXISTENT_BUNDLE;</span>
<span class="fc" id="L523">        this.parent = parent;</span>
<span class="fc" id="L524">    }</span>

    /**
     * Key used for cached resource bundles.  The key checks the base
     * name, the locale, and the class loader to determine if the
     * resource is a match to the requested one. The loader may be
     * null, but the base name and the locale must have a non-null
     * value.
     */
    private static class CacheKey implements Cloneable {
        // These three are the actual keys for lookup in Map.
        private String name;
        private Locale locale;
        private LoaderReference loaderRef;

        // bundle format which is necessary for calling
        // Control.needsReload().
        private String format;

        // These time values are in CacheKey so that NONEXISTENT_BUNDLE
        // doesn't need to be cloned for caching.

        // The time when the bundle has been loaded
        private volatile long loadTime;

        // The time when the bundle expires in the cache, or either
        // Control.TTL_DONT_CACHE or Control.TTL_NO_EXPIRATION_CONTROL.
        private volatile long expirationTime;

        // Placeholder for an error report by a Throwable
        private Throwable cause;

        // Hash code value cache to avoid recalculating the hash code
        // of this instance.
        private int hashCodeCache;

<span class="fc" id="L560">        CacheKey(String baseName, Locale locale, ClassLoader loader) {</span>
<span class="fc" id="L561">            this.name = baseName;</span>
<span class="fc" id="L562">            this.locale = locale;</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">            if (loader == null) {</span>
<span class="nc" id="L564">                this.loaderRef = null;</span>
            } else {
<span class="fc" id="L566">                loaderRef = new LoaderReference(loader, referenceQueue, this);</span>
            }
<span class="fc" id="L568">            calculateHashCode();</span>
<span class="fc" id="L569">        }</span>

        String getName() {
<span class="fc" id="L572">            return name;</span>
        }

        CacheKey setName(String baseName) {
<span class="nc bnc" id="L576" title="All 2 branches missed.">            if (!this.name.equals(baseName)) {</span>
<span class="nc" id="L577">                this.name = baseName;</span>
<span class="nc" id="L578">                calculateHashCode();</span>
            }
<span class="nc" id="L580">            return this;</span>
        }

        Locale getLocale() {
<span class="fc" id="L584">            return locale;</span>
        }

        CacheKey setLocale(Locale locale) {
<span class="fc bfc" id="L588" title="All 2 branches covered.">            if (!this.locale.equals(locale)) {</span>
<span class="fc" id="L589">                this.locale = locale;</span>
<span class="fc" id="L590">                calculateHashCode();</span>
            }
<span class="fc" id="L592">            return this;</span>
        }

        ClassLoader getLoader() {
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">            return (loaderRef != null) ? loaderRef.get() : null;</span>
        }

        public boolean equals(Object other) {
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">            if (this == other) {</span>
<span class="nc" id="L601">                return true;</span>
            }
            try {
<span class="fc" id="L604">                final CacheKey otherEntry = (CacheKey)other;</span>
                //quick check to see if they are not equal
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">                if (hashCodeCache != otherEntry.hashCodeCache) {</span>
<span class="nc" id="L607">                    return false;</span>
                }
                //are the names the same?
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">                if (!name.equals(otherEntry.name)) {</span>
<span class="nc" id="L611">                    return false;</span>
                }
                // are the locales the same?
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">                if (!locale.equals(otherEntry.locale)) {</span>
<span class="nc" id="L615">                    return false;</span>
                }
                //are refs (both non-null) or (both null)?
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">                if (loaderRef == null) {</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">                    return otherEntry.loaderRef == null;</span>
                }
<span class="fc" id="L621">                ClassLoader loader = loaderRef.get();</span>
<span class="pc bpc" id="L622" title="2 of 4 branches missed.">                return (otherEntry.loaderRef != null)</span>
                        // with a null reference we can no longer find
                        // out which class loader was referenced; so
                        // treat it as unequal
                        &amp;&amp; (loader != null)
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">                        &amp;&amp; (loader == otherEntry.loaderRef.get());</span>
<span class="nc" id="L628">            } catch (    NullPointerException | ClassCastException e) {</span>
            }
<span class="nc" id="L630">            return false;</span>
        }

        public int hashCode() {
<span class="fc" id="L634">            return hashCodeCache;</span>
        }

        private void calculateHashCode() {
<span class="fc" id="L638">            hashCodeCache = name.hashCode() &lt;&lt; 3;</span>
<span class="fc" id="L639">            hashCodeCache ^= locale.hashCode();</span>
<span class="fc" id="L640">            ClassLoader loader = getLoader();</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">            if (loader != null) {</span>
<span class="fc" id="L642">                hashCodeCache ^= loader.hashCode();</span>
            }
<span class="fc" id="L644">        }</span>

        public Object clone() {
            try {
<span class="fc" id="L648">                CacheKey clone = (CacheKey) super.clone();</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">                if (loaderRef != null) {</span>
<span class="fc" id="L650">                    clone.loaderRef = new LoaderReference(loaderRef.get(),</span>
<span class="fc" id="L651">                                                          referenceQueue, clone);</span>
                }
                // Clear the reference to a Throwable
<span class="fc" id="L654">                clone.cause = null;</span>
<span class="fc" id="L655">                return clone;</span>
<span class="nc" id="L656">            } catch (CloneNotSupportedException e) {</span>
                //this should never happen
<span class="nc" id="L658">                throw new InternalError(e);</span>
            }
        }

        String getFormat() {
<span class="fc" id="L663">            return format;</span>
        }

        void setFormat(String format) {
<span class="fc" id="L667">            this.format = format;</span>
<span class="fc" id="L668">        }</span>

        private void setCause(Throwable cause) {
<span class="fc bfc" id="L671" title="All 2 branches covered.">            if (this.cause == null) {</span>
<span class="fc" id="L672">                this.cause = cause;</span>
            } else {
                // Override the cause if the previous one is
                // ClassNotFoundException.
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">                if (this.cause instanceof ClassNotFoundException) {</span>
<span class="nc" id="L677">                    this.cause = cause;</span>
                }
            }
<span class="fc" id="L680">        }</span>

        private Throwable getCause() {
<span class="fc" id="L683">            return cause;</span>
        }

        public String toString() {
<span class="nc" id="L687">            String l = locale.toString();</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">            if (l.length() == 0) {</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">                if (locale.getVariant().length() != 0) {</span>
<span class="nc" id="L690">                    l = &quot;__&quot; + locale.getVariant();</span>
                } else {
<span class="nc" id="L692">                    l = &quot;\&quot;\&quot;&quot;;</span>
                }
            }
<span class="nc" id="L695">            return &quot;CacheKey[&quot; + name + &quot;, lc=&quot; + l + &quot;, ldr=&quot; + getLoader()</span>
                + &quot;(format=&quot; + format + &quot;)]&quot;;
        }
    }

    /**
     * The common interface to get a CacheKey in LoaderReference and
     * BundleReference.
     */
    private static interface CacheKeyReference {
        public CacheKey getCacheKey();
    }

    /**
     * References to class loaders are weak references, so that they can be
     * garbage collected when nobody else is using them. The ResourceBundle
     * class has no reason to keep class loaders alive.
     */
    private static class LoaderReference extends WeakReference&lt;ClassLoader&gt;
                                         implements CacheKeyReference {
        private CacheKey cacheKey;

        LoaderReference(ClassLoader referent, ReferenceQueue&lt;Object&gt; q, CacheKey key) {
<span class="fc" id="L718">            super(referent, q);</span>
<span class="fc" id="L719">            cacheKey = key;</span>
<span class="fc" id="L720">        }</span>

        public CacheKey getCacheKey() {
<span class="fc" id="L723">            return cacheKey;</span>
        }
    }

    /**
     * References to bundles are soft references so that they can be garbage
     * collected when they have no hard references.
     */
    private static class BundleReference extends SoftReference&lt;ResourceBundle&gt;
                                         implements CacheKeyReference {
        private CacheKey cacheKey;

        BundleReference(ResourceBundle referent, ReferenceQueue&lt;Object&gt; q, CacheKey key) {
<span class="fc" id="L736">            super(referent, q);</span>
<span class="fc" id="L737">            cacheKey = key;</span>
<span class="fc" id="L738">        }</span>

        public CacheKey getCacheKey() {
<span class="fc" id="L741">            return cacheKey;</span>
        }
    }

    /**
     * Gets a resource bundle using the specified base name, the default locale,
     * and the caller's class loader. Calling this method is equivalent to calling
     * &lt;blockquote&gt;
     * &lt;code&gt;getBundle(baseName, Locale.getDefault(), this.getClass().getClassLoader())&lt;/code&gt;,
     * &lt;/blockquote&gt;
     * except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security
     * privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.
     * See {@link #getBundle(String, Locale, ClassLoader) getBundle}
     * for a complete description of the search and instantiation strategy.
     *
     * @param baseName the base name of the resource bundle, a fully qualified class name
     * @exception java.lang.NullPointerException
     *     if &lt;code&gt;baseName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @exception MissingResourceException
     *     if no resource bundle for the specified base name can be found
     * @return a resource bundle for the given base name and the default locale
     */
    @CallerSensitive
    public static final ResourceBundle getBundle(String baseName)
    {
<span class="fc" id="L766">        return getBundleImpl(baseName, Locale.getDefault(),</span>
<span class="fc" id="L767">                             getLoader(Reflection.getCallerClass()),</span>
<span class="fc" id="L768">                             getDefaultControl(baseName));</span>
    }

    /**
     * Returns a resource bundle using the specified base name, the
     * default locale and the specified control. Calling this method
     * is equivalent to calling
     * &lt;pre&gt;
     * getBundle(baseName, Locale.getDefault(),
     *           this.getClass().getClassLoader(), control),
     * &lt;/pre&gt;
     * except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security
     * privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.  See {@link
     * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
     * complete description of the resource bundle loading process with a
     * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;.
     *
     * @param baseName
     *        the base name of the resource bundle, a fully qualified class
     *        name
     * @param control
     *        the control which gives information for the resource bundle
     *        loading process
     * @return a resource bundle for the given base name and the default
     *        locale
     * @exception NullPointerException
     *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;control&lt;/code&gt; is
     *        &lt;code&gt;null&lt;/code&gt;
     * @exception MissingResourceException
     *        if no resource bundle for the specified base name can be found
     * @exception IllegalArgumentException
     *        if the given &lt;code&gt;control&lt;/code&gt; doesn't perform properly
     *        (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)
     *        Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as
     *        needed.
     * @since 1.6
     */
    @CallerSensitive
    public static final ResourceBundle getBundle(String baseName,
                                                 Control control) {
<span class="fc" id="L808">        return getBundleImpl(baseName, Locale.getDefault(),</span>
<span class="fc" id="L809">                             getLoader(Reflection.getCallerClass()),</span>
                             control);
    }

    /**
     * Gets a resource bundle using the specified base name and locale,
     * and the caller's class loader. Calling this method is equivalent to calling
     * &lt;blockquote&gt;
     * &lt;code&gt;getBundle(baseName, locale, this.getClass().getClassLoader())&lt;/code&gt;,
     * &lt;/blockquote&gt;
     * except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security
     * privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.
     * See {@link #getBundle(String, Locale, ClassLoader) getBundle}
     * for a complete description of the search and instantiation strategy.
     *
     * @param baseName
     *        the base name of the resource bundle, a fully qualified class name
     * @param locale
     *        the locale for which a resource bundle is desired
     * @exception NullPointerException
     *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @exception MissingResourceException
     *        if no resource bundle for the specified base name can be found
     * @return a resource bundle for the given base name and locale
     */
    @CallerSensitive
    public static final ResourceBundle getBundle(String baseName,
                                                 Locale locale)
    {
<span class="fc" id="L838">        return getBundleImpl(baseName, locale,</span>
<span class="fc" id="L839">                             getLoader(Reflection.getCallerClass()),</span>
<span class="fc" id="L840">                             getDefaultControl(baseName));</span>
    }

    /**
     * Returns a resource bundle using the specified base name, target
     * locale and control, and the caller's class loader. Calling this
     * method is equivalent to calling
     * &lt;pre&gt;
     * getBundle(baseName, targetLocale, this.getClass().getClassLoader(),
     *           control),
     * &lt;/pre&gt;
     * except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security
     * privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.  See {@link
     * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
     * complete description of the resource bundle loading process with a
     * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;.
     *
     * @param baseName
     *        the base name of the resource bundle, a fully qualified
     *        class name
     * @param targetLocale
     *        the locale for which a resource bundle is desired
     * @param control
     *        the control which gives information for the resource
     *        bundle loading process
     * @return a resource bundle for the given base name and a
     *        &lt;code&gt;Locale&lt;/code&gt; in &lt;code&gt;locales&lt;/code&gt;
     * @exception NullPointerException
     *        if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locales&lt;/code&gt; or
     *        &lt;code&gt;control&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @exception MissingResourceException
     *        if no resource bundle for the specified base name in any
     *        of the &lt;code&gt;locales&lt;/code&gt; can be found.
     * @exception IllegalArgumentException
     *        if the given &lt;code&gt;control&lt;/code&gt; doesn't perform properly
     *        (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)
     *        Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as
     *        needed.
     * @since 1.6
     */
    @CallerSensitive
    public static final ResourceBundle getBundle(String baseName, Locale targetLocale,
                                                 Control control) {
<span class="fc" id="L883">        return getBundleImpl(baseName, targetLocale,</span>
<span class="fc" id="L884">                             getLoader(Reflection.getCallerClass()),</span>
                             control);
    }

    /**
     * Gets a resource bundle using the specified base name, locale, and class
     * loader.
     *
     * &lt;p&gt;This method behaves the same as calling
     * {@link #getBundle(String, Locale, ClassLoader, Control)} passing a
     * default instance of {@link Control} unless another {@link Control} is
     * provided with the {@link ResourceBundleControlProvider} SPI. Refer to the
     * description of &lt;a href=&quot;#modify_default_behavior&quot;&gt;modifying the default
     * behavior&lt;/a&gt;.
     *
     * &lt;p&gt;&lt;a name=&quot;default_behavior&quot;&gt;The following describes the default
     * behavior&lt;/a&gt;.
     *
     * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; uses the base name, the specified locale, and
     * the default locale (obtained from {@link java.util.Locale#getDefault()
     * Locale.getDefault}) to generate a sequence of &lt;a
     * name=&quot;candidates&quot;&gt;&lt;em&gt;candidate bundle names&lt;/em&gt;&lt;/a&gt;.  If the specified
     * locale's language, script, country, and variant are all empty strings,
     * then the base name is the only candidate bundle name.  Otherwise, a list
     * of candidate locales is generated from the attribute values of the
     * specified locale (language, script, country and variant) and appended to
     * the base name.  Typically, this will look like the following:
     *
     * &lt;pre&gt;
     *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
     *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country
     *     baseName + &quot;_&quot; + language + &quot;_&quot; + script
     *     baseName + &quot;_&quot; + language + &quot;_&quot; + country + &quot;_&quot; + variant
     *     baseName + &quot;_&quot; + language + &quot;_&quot; + country
     *     baseName + &quot;_&quot; + language
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Candidate bundle names where the final component is an empty string
     * are omitted, along with the underscore.  For example, if country is an
     * empty string, the second and the fifth candidate bundle names above
     * would be omitted.  Also, if script is an empty string, the candidate names
     * including script are omitted.  For example, a locale with language &quot;de&quot;
     * and variant &quot;JAVA&quot; will produce candidate names with base name
     * &quot;MyResource&quot; below.
     *
     * &lt;pre&gt;
     *     MyResource_de__JAVA
     *     MyResource_de
     * &lt;/pre&gt;
     *
     * In the case that the variant contains one or more underscores ('_'), a
     * sequence of bundle names generated by truncating the last underscore and
     * the part following it is inserted after a candidate bundle name with the
     * original variant.  For example, for a locale with language &quot;en&quot;, script
     * &quot;Latn, country &quot;US&quot; and variant &quot;WINDOWS_VISTA&quot;, and bundle base name
     * &quot;MyResource&quot;, the list of candidate bundle names below is generated:
     *
     * &lt;pre&gt;
     * MyResource_en_Latn_US_WINDOWS_VISTA
     * MyResource_en_Latn_US_WINDOWS
     * MyResource_en_Latn_US
     * MyResource_en_Latn
     * MyResource_en_US_WINDOWS_VISTA
     * MyResource_en_US_WINDOWS
     * MyResource_en_US
     * MyResource_en
     * &lt;/pre&gt;
     *
     * &lt;blockquote&gt;&lt;b&gt;Note:&lt;/b&gt; For some &lt;code&gt;Locale&lt;/code&gt;s, the list of
     * candidate bundle names contains extra names, or the order of bundle names
     * is slightly modified.  See the description of the default implementation
     * of {@link Control#getCandidateLocales(String, Locale)
     * getCandidateLocales} for details.&lt;/blockquote&gt;
     *
     * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; then iterates over the candidate bundle names
     * to find the first one for which it can &lt;em&gt;instantiate&lt;/em&gt; an actual
     * resource bundle. It uses the default controls' {@link Control#getFormats
     * getFormats} method, which generates two bundle names for each generated
     * name, the first a class name and the second a properties file name. For
     * each candidate bundle name, it attempts to create a resource bundle:
     *
     * &lt;ul&gt;&lt;li&gt;First, it attempts to load a class using the generated class name.
     * If such a class can be found and loaded using the specified class
     * loader, is assignment compatible with ResourceBundle, is accessible from
     * ResourceBundle, and can be instantiated, &lt;code&gt;getBundle&lt;/code&gt; creates a
     * new instance of this class and uses it as the &lt;em&gt;result resource
     * bundle&lt;/em&gt;.
     *
     * &lt;li&gt;Otherwise, &lt;code&gt;getBundle&lt;/code&gt; attempts to locate a property
     * resource file using the generated properties file name.  It generates a
     * path name from the candidate bundle name by replacing all &quot;.&quot; characters
     * with &quot;/&quot; and appending the string &quot;.properties&quot;.  It attempts to find a
     * &quot;resource&quot; with this name using {@link
     * java.lang.ClassLoader#getResource(java.lang.String)
     * ClassLoader.getResource}.  (Note that a &quot;resource&quot; in the sense of
     * &lt;code&gt;getResource&lt;/code&gt; has nothing to do with the contents of a
     * resource bundle, it is just a container of data, such as a file.)  If it
     * finds a &quot;resource&quot;, it attempts to create a new {@link
     * PropertyResourceBundle} instance from its contents.  If successful, this
     * instance becomes the &lt;em&gt;result resource bundle&lt;/em&gt;.  &lt;/ul&gt;
     *
     * &lt;p&gt;This continues until a result resource bundle is instantiated or the
     * list of candidate bundle names is exhausted.  If no matching resource
     * bundle is found, the default control's {@link Control#getFallbackLocale
     * getFallbackLocale} method is called, which returns the current default
     * locale.  A new sequence of candidate locale names is generated using this
     * locale and and searched again, as above.
     *
     * &lt;p&gt;If still no result bundle is found, the base name alone is looked up. If
     * this still fails, a &lt;code&gt;MissingResourceException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt;&lt;a name=&quot;parent_chain&quot;&gt; Once a result resource bundle has been found,
     * its &lt;em&gt;parent chain&lt;/em&gt; is instantiated&lt;/a&gt;.  If the result bundle already
     * has a parent (perhaps because it was returned from a cache) the chain is
     * complete.
     *
     * &lt;p&gt;Otherwise, &lt;code&gt;getBundle&lt;/code&gt; examines the remainder of the
     * candidate locale list that was used during the pass that generated the
     * result resource bundle.  (As before, candidate bundle names where the
     * final component is an empty string are omitted.)  When it comes to the
     * end of the candidate list, it tries the plain bundle name.  With each of the
     * candidate bundle names it attempts to instantiate a resource bundle (first
     * looking for a class and then a properties file, as described above).
     *
     * &lt;p&gt;Whenever it succeeds, it calls the previously instantiated resource
     * bundle's {@link #setParent(java.util.ResourceBundle) setParent} method
     * with the new resource bundle.  This continues until the list of names
     * is exhausted or the current bundle already has a non-null parent.
     *
     * &lt;p&gt;Once the parent chain is complete, the bundle is returned.
     *
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; &lt;code&gt;getBundle&lt;/code&gt; caches instantiated resource
     * bundles and might return the same resource bundle instance multiple times.
     *
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;The &lt;code&gt;baseName&lt;/code&gt; argument should be a fully
     * qualified class name. However, for compatibility with earlier versions,
     * Sun's Java SE Runtime Environments do not verify this, and so it is
     * possible to access &lt;code&gt;PropertyResourceBundle&lt;/code&gt;s by specifying a
     * path name (using &quot;/&quot;) instead of a fully qualified class name (using
     * &quot;.&quot;).
     *
     * &lt;p&gt;&lt;a name=&quot;default_behavior_example&quot;&gt;
     * &lt;strong&gt;Example:&lt;/strong&gt;&lt;/a&gt;
     * &lt;p&gt;
     * The following class and property files are provided:
     * &lt;pre&gt;
     *     MyResources.class
     *     MyResources.properties
     *     MyResources_fr.properties
     *     MyResources_fr_CH.class
     *     MyResources_fr_CH.properties
     *     MyResources_en.properties
     *     MyResources_es_ES.class
     * &lt;/pre&gt;
     *
     * The contents of all files are valid (that is, public non-abstract
     * subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt; for the &quot;.class&quot; files,
     * syntactically correct &quot;.properties&quot; files).  The default locale is
     * &lt;code&gt;Locale(&quot;en&quot;, &quot;GB&quot;)&lt;/code&gt;.
     *
     * &lt;p&gt;Calling &lt;code&gt;getBundle&lt;/code&gt; with the locale arguments below will
     * instantiate resource bundles as follows:
     *
     * &lt;table summary=&quot;getBundle() locale to resource bundle mapping&quot;&gt;
     * &lt;tr&gt;&lt;td&gt;Locale(&quot;fr&quot;, &quot;CH&quot;)&lt;/td&gt;&lt;td&gt;MyResources_fr_CH.class, parent MyResources_fr.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;Locale(&quot;fr&quot;, &quot;FR&quot;)&lt;/td&gt;&lt;td&gt;MyResources_fr.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/td&gt;&lt;td&gt;MyResources_en.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;Locale(&quot;en&quot;, &quot;US&quot;)&lt;/td&gt;&lt;td&gt;MyResources_en.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;Locale(&quot;es&quot;, &quot;ES&quot;)&lt;/td&gt;&lt;td&gt;MyResources_es_ES.class, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
     * &lt;/table&gt;
     *
     * &lt;p&gt;The file MyResources_fr_CH.properties is never used because it is
     * hidden by the MyResources_fr_CH.class. Likewise, MyResources.properties
     * is also hidden by MyResources.class.
     *
     * @param baseName the base name of the resource bundle, a fully qualified class name
     * @param locale the locale for which a resource bundle is desired
     * @param loader the class loader from which to load the resource bundle
     * @return a resource bundle for the given base name and locale
     * @exception java.lang.NullPointerException
     *        if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;, or &lt;code&gt;loader&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @exception MissingResourceException
     *        if no resource bundle for the specified base name can be found
     * @since 1.2
     */
    public static ResourceBundle getBundle(String baseName, Locale locale,
                                           ClassLoader loader)
    {
<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">        if (loader == null) {</span>
<span class="nc" id="L1073">            throw new NullPointerException();</span>
        }
<span class="fc" id="L1075">        return getBundleImpl(baseName, locale, loader, getDefaultControl(baseName));</span>
    }

    /**
     * Returns a resource bundle using the specified base name, target
     * locale, class loader and control. Unlike the {@linkplain
     * #getBundle(String, Locale, ClassLoader) &lt;code&gt;getBundle&lt;/code&gt;
     * factory methods with no &lt;code&gt;control&lt;/code&gt; argument}, the given
     * &lt;code&gt;control&lt;/code&gt; specifies how to locate and instantiate resource
     * bundles. Conceptually, the bundle loading process with the given
     * &lt;code&gt;control&lt;/code&gt; is performed in the following steps.
     *
     * &lt;ol&gt;
     * &lt;li&gt;This factory method looks up the resource bundle in the cache for
     * the specified &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;targetLocale&lt;/code&gt; and
     * &lt;code&gt;loader&lt;/code&gt;.  If the requested resource bundle instance is
     * found in the cache and the time-to-live periods of the instance and
     * all of its parent instances have not expired, the instance is returned
     * to the caller. Otherwise, this factory method proceeds with the
     * loading process below.&lt;/li&gt;
     *
     * &lt;li&gt;The {@link ResourceBundle.Control#getFormats(String)
     * control.getFormats} method is called to get resource bundle formats
     * to produce bundle or resource names. The strings
     * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;
     * designate class-based and {@linkplain PropertyResourceBundle
     * property}-based resource bundles, respectively. Other strings
     * starting with &lt;code&gt;&quot;java.&quot;&lt;/code&gt; are reserved for future extensions
     * and must not be used for application-defined formats. Other strings
     * designate application-defined formats.&lt;/li&gt;
     *
     * &lt;li&gt;The {@link ResourceBundle.Control#getCandidateLocales(String,
     * Locale) control.getCandidateLocales} method is called with the target
     * locale to get a list of &lt;em&gt;candidate &lt;code&gt;Locale&lt;/code&gt;s&lt;/em&gt; for
     * which resource bundles are searched.&lt;/li&gt;
     *
     * &lt;li&gt;The {@link ResourceBundle.Control#newBundle(String, Locale,
     * String, ClassLoader, boolean) control.newBundle} method is called to
     * instantiate a &lt;code&gt;ResourceBundle&lt;/code&gt; for the base bundle name, a
     * candidate locale, and a format. (Refer to the note on the cache
     * lookup below.) This step is iterated over all combinations of the
     * candidate locales and formats until the &lt;code&gt;newBundle&lt;/code&gt; method
     * returns a &lt;code&gt;ResourceBundle&lt;/code&gt; instance or the iteration has
     * used up all the combinations. For example, if the candidate locales
     * are &lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;, &lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt; and
     * &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; and the formats are &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;
     * and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, then the following is the
     * sequence of locale-format combinations to be used to call
     * &lt;code&gt;control.newBundle&lt;/code&gt;.
     *
     * &lt;table style=&quot;width: 50%; text-align: left; margin-left: 40px;&quot;
     *  border=&quot;0&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot; summary=&quot;locale-format combinations for newBundle&quot;&gt;
     * &lt;tbody&gt;
     * &lt;tr&gt;
     * &lt;td
     * style=&quot;vertical-align: top; text-align: left; font-weight: bold; width: 50%;&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;br&gt;
     * &lt;/td&gt;
     * &lt;td
     * style=&quot;vertical-align: top; text-align: left; font-weight: bold; width: 50%;&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;br&gt;
     * &lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;&lt;br&gt;
     * &lt;/td&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;br&gt;
     * &lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;&lt;/td&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;br&gt;
     * &lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt;&lt;/td&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt;&lt;/td&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;&lt;br&gt;
     * &lt;/td&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;&lt;/td&gt;
     * &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;/tbody&gt;
     * &lt;/table&gt;
     * &lt;/li&gt;
     *
     * &lt;li&gt;If the previous step has found no resource bundle, proceed to
     * Step 6. If a bundle has been found that is a base bundle (a bundle
     * for &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;), and the candidate locale list only contained
     * &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;, return the bundle to the caller. If a bundle
     * has been found that is a base bundle, but the candidate locale list
     * contained locales other than Locale(&quot;&quot;), put the bundle on hold and
     * proceed to Step 6. If a bundle has been found that is not a base
     * bundle, proceed to Step 7.&lt;/li&gt;
     *
     * &lt;li&gt;The {@link ResourceBundle.Control#getFallbackLocale(String,
     * Locale) control.getFallbackLocale} method is called to get a fallback
     * locale (alternative to the current target locale) to try further
     * finding a resource bundle. If the method returns a non-null locale,
     * it becomes the next target locale and the loading process starts over
     * from Step 3. Otherwise, if a base bundle was found and put on hold in
     * a previous Step 5, it is returned to the caller now. Otherwise, a
     * MissingResourceException is thrown.&lt;/li&gt;
     *
     * &lt;li&gt;At this point, we have found a resource bundle that's not the
     * base bundle. If this bundle set its parent during its instantiation,
     * it is returned to the caller. Otherwise, its &lt;a
     * href=&quot;./ResourceBundle.html#parent_chain&quot;&gt;parent chain&lt;/a&gt; is
     * instantiated based on the list of candidate locales from which it was
     * found. Finally, the bundle is returned to the caller.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;During the resource bundle loading process above, this factory
     * method looks up the cache before calling the {@link
     * Control#newBundle(String, Locale, String, ClassLoader, boolean)
     * control.newBundle} method.  If the time-to-live period of the
     * resource bundle found in the cache has expired, the factory method
     * calls the {@link ResourceBundle.Control#needsReload(String, Locale,
     * String, ClassLoader, ResourceBundle, long) control.needsReload}
     * method to determine whether the resource bundle needs to be reloaded.
     * If reloading is required, the factory method calls
     * &lt;code&gt;control.newBundle&lt;/code&gt; to reload the resource bundle.  If
     * &lt;code&gt;control.newBundle&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, the factory
     * method puts a dummy resource bundle in the cache as a mark of
     * nonexistent resource bundles in order to avoid lookup overhead for
     * subsequent requests. Such dummy resource bundles are under the same
     * expiration control as specified by &lt;code&gt;control&lt;/code&gt;.
     *
     * &lt;p&gt;All resource bundles loaded are cached by default. Refer to
     * {@link Control#getTimeToLive(String,Locale)
     * control.getTimeToLive} for details.
     *
     * &lt;p&gt;The following is an example of the bundle loading process with the
     * default &lt;code&gt;ResourceBundle.Control&lt;/code&gt; implementation.
     *
     * &lt;p&gt;Conditions:
     * &lt;ul&gt;
     * &lt;li&gt;Base bundle name: &lt;code&gt;foo.bar.Messages&lt;/code&gt;
     * &lt;li&gt;Requested &lt;code&gt;Locale&lt;/code&gt;: {@link Locale#ITALY}&lt;/li&gt;
     * &lt;li&gt;Default &lt;code&gt;Locale&lt;/code&gt;: {@link Locale#FRENCH}&lt;/li&gt;
     * &lt;li&gt;Available resource bundles:
     * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt; and
     * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;First, &lt;code&gt;getBundle&lt;/code&gt; tries loading a resource bundle in
     * the following sequence.
     *
     * &lt;ul&gt;
     * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_it_IT&lt;/code&gt;
     * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_it_IT.properties&lt;/code&gt;
     * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_it&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_it.properties&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;class &lt;code&gt;foo.bar.Messages&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;file &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;At this point, &lt;code&gt;getBundle&lt;/code&gt; finds
     * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;, which is put on hold
     * because it's the base bundle.  &lt;code&gt;getBundle&lt;/code&gt; calls {@link
     * Control#getFallbackLocale(String, Locale)
     * control.getFallbackLocale(&quot;foo.bar.Messages&quot;, Locale.ITALY)} which
     * returns &lt;code&gt;Locale.FRENCH&lt;/code&gt;. Next, &lt;code&gt;getBundle&lt;/code&gt;
     * tries loading a bundle in the following sequence.
     *
     * &lt;ul&gt;
     * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_fr&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;class &lt;code&gt;foo.bar.Messages&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;file &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; finds
     * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt; and creates a
     * &lt;code&gt;ResourceBundle&lt;/code&gt; instance. Then, &lt;code&gt;getBundle&lt;/code&gt;
     * sets up its parent chain from the list of the candidate locales.  Only
     * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt; is found in the list and
     * &lt;code&gt;getBundle&lt;/code&gt; creates a &lt;code&gt;ResourceBundle&lt;/code&gt; instance
     * that becomes the parent of the instance for
     * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt;.
     *
     * @param baseName
     *        the base name of the resource bundle, a fully qualified
     *        class name
     * @param targetLocale
     *        the locale for which a resource bundle is desired
     * @param loader
     *        the class loader from which to load the resource bundle
     * @param control
     *        the control which gives information for the resource
     *        bundle loading process
     * @return a resource bundle for the given base name and locale
     * @exception NullPointerException
     *        if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;targetLocale&lt;/code&gt;,
     *        &lt;code&gt;loader&lt;/code&gt;, or &lt;code&gt;control&lt;/code&gt; is
     *        &lt;code&gt;null&lt;/code&gt;
     * @exception MissingResourceException
     *        if no resource bundle for the specified base name can be found
     * @exception IllegalArgumentException
     *        if the given &lt;code&gt;control&lt;/code&gt; doesn't perform properly
     *        (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)
     *        Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as
     *        needed.
     * @since 1.6
     */
    public static ResourceBundle getBundle(String baseName, Locale targetLocale,
                                           ClassLoader loader, Control control) {
<span class="nc bnc" id="L1289" title="All 4 branches missed.">        if (loader == null || control == null) {</span>
<span class="nc" id="L1290">            throw new NullPointerException();</span>
        }
<span class="nc" id="L1292">        return getBundleImpl(baseName, targetLocale, loader, control);</span>
    }

    private static Control getDefaultControl(String baseName) {
<span class="fc bfc" id="L1296" title="All 2 branches covered.">        if (providers != null) {</span>
<span class="fc bfc" id="L1297" title="All 2 branches covered.">            for (ResourceBundleControlProvider provider : providers) {</span>
<span class="fc" id="L1298">                Control control = provider.getControl(baseName);</span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">                if (control != null) {</span>
<span class="fc" id="L1300">                    return control;</span>
                }
<span class="fc" id="L1302">            }</span>
        }
<span class="fc" id="L1304">        return Control.INSTANCE;</span>
    }

    private static ResourceBundle getBundleImpl(String baseName, Locale locale,
                                                ClassLoader loader, Control control) {
<span class="pc bpc" id="L1309" title="2 of 4 branches missed.">        if (locale == null || control == null) {</span>
<span class="nc" id="L1310">            throw new NullPointerException();</span>
        }

        // We create a CacheKey here for use by this call. The base
        // name and loader will never change during the bundle loading
        // process. We have to make sure that the locale is set before
        // using it as a cache key.
<span class="fc" id="L1317">        CacheKey cacheKey = new CacheKey(baseName, locale, loader);</span>
<span class="fc" id="L1318">        ResourceBundle bundle = null;</span>

        // Quick lookup of the cache.
<span class="fc" id="L1321">        BundleReference bundleRef = cacheList.get(cacheKey);</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        if (bundleRef != null) {</span>
<span class="fc" id="L1323">            bundle = bundleRef.get();</span>
<span class="fc" id="L1324">            bundleRef = null;</span>
        }

        // If this bundle and all of its parents are valid (not expired),
        // then return this bundle. If any of the bundles is expired, we
        // don't call control.needsReload here but instead drop into the
        // complete loading process below.
<span class="fc bfc" id="L1331" title="All 4 branches covered.">        if (isValidBundle(bundle) &amp;&amp; hasValidParentChain(bundle)) {</span>
<span class="fc" id="L1332">            return bundle;</span>
        }

        // No valid bundle was found in the cache, so we need to load the
        // resource bundle and its parents.

<span class="pc bpc" id="L1338" title="1 of 4 branches missed.">        boolean isKnownControl = (control == Control.INSTANCE) ||</span>
                                   (control instanceof SingleFormatControl);
<span class="fc" id="L1340">        List&lt;String&gt; formats = control.getFormats(baseName);</span>
<span class="pc bpc" id="L1341" title="1 of 4 branches missed.">        if (!isKnownControl &amp;&amp; !checkList(formats)) {</span>
<span class="nc" id="L1342">            throw new IllegalArgumentException(&quot;Invalid Control: getFormats&quot;);</span>
        }

<span class="fc" id="L1345">        ResourceBundle baseBundle = null;</span>
<span class="fc" id="L1346">        for (Locale targetLocale = locale;</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">             targetLocale != null;</span>
<span class="fc" id="L1348">             targetLocale = control.getFallbackLocale(baseName, targetLocale)) {</span>
<span class="fc" id="L1349">            List&lt;Locale&gt; candidateLocales = control.getCandidateLocales(baseName, targetLocale);</span>
<span class="pc bpc" id="L1350" title="1 of 4 branches missed.">            if (!isKnownControl &amp;&amp; !checkList(candidateLocales)) {</span>
<span class="nc" id="L1351">                throw new IllegalArgumentException(&quot;Invalid Control: getCandidateLocales&quot;);</span>
            }

<span class="fc" id="L1354">            bundle = findBundle(cacheKey, candidateLocales, formats, 0, control, baseBundle);</span>

            // If the loaded bundle is the base bundle and exactly for the
            // requested locale or the only candidate locale, then take the
            // bundle as the resulting one. If the loaded bundle is the base
            // bundle, it's put on hold until we finish processing all
            // fallback locales.
<span class="fc bfc" id="L1361" title="All 2 branches covered.">            if (isValidBundle(bundle)) {</span>
<span class="fc" id="L1362">                boolean isBaseBundle = Locale.ROOT.equals(bundle.locale);</span>
<span class="fc bfc" id="L1363" title="All 4 branches covered.">                if (!isBaseBundle || bundle.locale.equals(locale)</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">                    || (candidateLocales.size() == 1</span>
<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">                        &amp;&amp; bundle.locale.equals(candidateLocales.get(0)))) {</span>
<span class="fc" id="L1366">                    break;</span>
                }

                // If the base bundle has been loaded, keep the reference in
                // baseBundle so that we can avoid any redundant loading in case
                // the control specify not to cache bundles.
<span class="pc bpc" id="L1372" title="1 of 4 branches missed.">                if (isBaseBundle &amp;&amp; baseBundle == null) {</span>
<span class="fc" id="L1373">                    baseBundle = bundle;</span>
                }
            }
        }

<span class="pc bpc" id="L1378" title="1 of 2 branches missed.">        if (bundle == null) {</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">            if (baseBundle == null) {</span>
<span class="nc" id="L1380">                throwMissingResourceException(baseName, locale, cacheKey.getCause());</span>
            }
<span class="nc" id="L1382">            bundle = baseBundle;</span>
        }

<span class="fc" id="L1385">        return bundle;</span>
    }

    /**
     * Checks if the given &lt;code&gt;List&lt;/code&gt; is not null, not empty,
     * not having null in its elements.
     */
    private static boolean checkList(List&lt;?&gt; a) {
<span class="pc bpc" id="L1393" title="2 of 4 branches missed.">        boolean valid = (a != null &amp;&amp; !a.isEmpty());</span>
<span class="pc bpc" id="L1394" title="1 of 2 branches missed.">        if (valid) {</span>
<span class="fc" id="L1395">            int size = a.size();</span>
<span class="pc bpc" id="L1396" title="1 of 4 branches missed.">            for (int i = 0; valid &amp;&amp; i &lt; size; i++) {</span>
<span class="pc bpc" id="L1397" title="1 of 2 branches missed.">                valid = (a.get(i) != null);</span>
            }
        }
<span class="fc" id="L1400">        return valid;</span>
    }

    private static ResourceBundle findBundle(CacheKey cacheKey,
                                             List&lt;Locale&gt; candidateLocales,
                                             List&lt;String&gt; formats,
                                             int index,
                                             Control control,
                                             ResourceBundle baseBundle) {
<span class="fc" id="L1409">        Locale targetLocale = candidateLocales.get(index);</span>
<span class="fc" id="L1410">        ResourceBundle parent = null;</span>
<span class="fc bfc" id="L1411" title="All 2 branches covered.">        if (index != candidateLocales.size() - 1) {</span>
<span class="fc" id="L1412">            parent = findBundle(cacheKey, candidateLocales, formats, index + 1,</span>
                                control, baseBundle);
<span class="pc bpc" id="L1414" title="1 of 4 branches missed.">        } else if (baseBundle != null &amp;&amp; Locale.ROOT.equals(targetLocale)) {</span>
<span class="fc" id="L1415">            return baseBundle;</span>
        }

        // Before we do the real loading work, see whether we need to
        // do some housekeeping: If references to class loaders or
        // resource bundles have been nulled out, remove all related
        // information from the cache.
        Object ref;
<span class="fc bfc" id="L1423" title="All 2 branches covered.">        while ((ref = referenceQueue.poll()) != null) {</span>
<span class="fc" id="L1424">            cacheList.remove(((CacheKeyReference)ref).getCacheKey());</span>
        }

        // flag indicating the resource bundle has expired in the cache
<span class="fc" id="L1428">        boolean expiredBundle = false;</span>

        // First, look up the cache to see if it's in the cache, without
        // attempting to load bundle.
<span class="fc" id="L1432">        cacheKey.setLocale(targetLocale);</span>
<span class="fc" id="L1433">        ResourceBundle bundle = findBundleInCache(cacheKey, control);</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">        if (isValidBundle(bundle)) {</span>
<span class="fc" id="L1435">            expiredBundle = bundle.expired;</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">            if (!expiredBundle) {</span>
                // If its parent is the one asked for by the candidate
                // locales (the runtime lookup path), we can take the cached
                // one. (If it's not identical, then we'd have to check the
                // parent's parents to be consistent with what's been
                // requested.)
<span class="fc bfc" id="L1442" title="All 2 branches covered.">                if (bundle.parent == parent) {</span>
<span class="fc" id="L1443">                    return bundle;</span>
                }
                // Otherwise, remove the cached one since we can't keep
                // the same bundles having different parents.
<span class="fc" id="L1447">                BundleReference bundleRef = cacheList.get(cacheKey);</span>
<span class="pc bpc" id="L1448" title="2 of 4 branches missed.">                if (bundleRef != null &amp;&amp; bundleRef.get() == bundle) {</span>
<span class="fc" id="L1449">                    cacheList.remove(cacheKey, bundleRef);</span>
                }
            }
        }

<span class="fc bfc" id="L1454" title="All 2 branches covered.">        if (bundle != NONEXISTENT_BUNDLE) {</span>
<span class="fc" id="L1455">            CacheKey constKey = (CacheKey) cacheKey.clone();</span>

            try {
<span class="fc" id="L1458">                bundle = loadBundle(cacheKey, formats, control, expiredBundle);</span>
<span class="fc bfc" id="L1459" title="All 2 branches covered.">                if (bundle != null) {</span>
<span class="fc bfc" id="L1460" title="All 2 branches covered.">                    if (bundle.parent == null) {</span>
<span class="fc" id="L1461">                        bundle.setParent(parent);</span>
                    }
<span class="fc" id="L1463">                    bundle.locale = targetLocale;</span>
<span class="fc" id="L1464">                    bundle = putBundleInCache(cacheKey, bundle, control);</span>
<span class="fc" id="L1465">                    return bundle;</span>
                }

                // Put NONEXISTENT_BUNDLE in the cache as a mark that there's no bundle
                // instance for the locale.
<span class="fc" id="L1470">                putBundleInCache(cacheKey, NONEXISTENT_BUNDLE, control);</span>
            } finally {
<span class="pc bpc" id="L1472" title="4 of 6 branches missed.">                if (constKey.getCause() instanceof InterruptedException) {</span>
<span class="pc" id="L1473">                    Thread.currentThread().interrupt();</span>
                }
            }
        }
<span class="fc" id="L1477">        return parent;</span>
    }

    private static ResourceBundle loadBundle(CacheKey cacheKey,
                                             List&lt;String&gt; formats,
                                             Control control,
                                             boolean reload) {

        // Here we actually load the bundle in the order of formats
        // specified by the getFormats() value.
<span class="fc" id="L1487">        Locale targetLocale = cacheKey.getLocale();</span>

<span class="fc" id="L1489">        ResourceBundle bundle = null;</span>
<span class="fc" id="L1490">        int size = formats.size();</span>
<span class="fc bfc" id="L1491" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1492">            String format = formats.get(i);</span>
            try {
<span class="fc" id="L1494">                bundle = control.newBundle(cacheKey.getName(), targetLocale, format,</span>
<span class="fc" id="L1495">                                           cacheKey.getLoader(), reload);</span>
<span class="nc" id="L1496">            } catch (LinkageError error) {</span>
                // We need to handle the LinkageError case due to
                // inconsistent case-sensitivity in ClassLoader.
                // See 6572242 for details.
<span class="nc" id="L1500">                cacheKey.setCause(error);</span>
<span class="fc" id="L1501">            } catch (Exception cause) {</span>
<span class="fc" id="L1502">                cacheKey.setCause(cause);</span>
<span class="pc" id="L1503">            }</span>
<span class="fc bfc" id="L1504" title="All 2 branches covered.">            if (bundle != null) {</span>
                // Set the format in the cache key so that it can be
                // used when calling needsReload later.
<span class="fc" id="L1507">                cacheKey.setFormat(format);</span>
<span class="fc" id="L1508">                bundle.name = cacheKey.getName();</span>
<span class="fc" id="L1509">                bundle.locale = targetLocale;</span>
                // Bundle provider might reuse instances. So we should make
                // sure to clear the expired flag here.
<span class="fc" id="L1512">                bundle.expired = false;</span>
<span class="fc" id="L1513">                break;</span>
            }
        }

<span class="fc" id="L1517">        return bundle;</span>
    }

    private static boolean isValidBundle(ResourceBundle bundle) {
<span class="fc bfc" id="L1521" title="All 4 branches covered.">        return bundle != null &amp;&amp; bundle != NONEXISTENT_BUNDLE;</span>
    }

    /**
     * Determines whether any of resource bundles in the parent chain,
     * including the leaf, have expired.
     */
    private static boolean hasValidParentChain(ResourceBundle bundle) {
<span class="fc" id="L1529">        long now = System.currentTimeMillis();</span>
<span class="fc bfc" id="L1530" title="All 2 branches covered.">        while (bundle != null) {</span>
<span class="fc bfc" id="L1531" title="All 2 branches covered.">            if (bundle.expired) {</span>
<span class="fc" id="L1532">                return false;</span>
            }
<span class="fc" id="L1534">            CacheKey key = bundle.cacheKey;</span>
<span class="pc bpc" id="L1535" title="1 of 2 branches missed.">            if (key != null) {</span>
<span class="fc" id="L1536">                long expirationTime = key.expirationTime;</span>
<span class="fc bfc" id="L1537" title="All 4 branches covered.">                if (expirationTime &gt;= 0 &amp;&amp; expirationTime &lt;= now) {</span>
<span class="fc" id="L1538">                    return false;</span>
                }
            }
<span class="fc" id="L1541">            bundle = bundle.parent;</span>
<span class="fc" id="L1542">        }</span>
<span class="fc" id="L1543">        return true;</span>
    }

    /**
     * Throw a MissingResourceException with proper message
     */
    private static void throwMissingResourceException(String baseName,
                                                      Locale locale,
                                                      Throwable cause) {
        // If the cause is a MissingResourceException, avoid creating
        // a long chain. (6355009)
<span class="pc bpc" id="L1554" title="1 of 2 branches missed.">        if (cause instanceof MissingResourceException) {</span>
<span class="nc" id="L1555">            cause = null;</span>
        }
<span class="fc" id="L1557">        throw new MissingResourceException(&quot;Can't find bundle for base name &quot;</span>
                                           + baseName + &quot;, locale &quot; + locale,
                                           baseName + &quot;_&quot; + locale, // className
                                           &quot;&quot;,                      // key
                                           cause);
    }

    /**
     * Finds a bundle in the cache. Any expired bundles are marked as
     * `expired' and removed from the cache upon return.
     *
     * @param cacheKey the key to look up the cache
     * @param control the Control to be used for the expiration control
     * @return the cached bundle, or null if the bundle is not found in the
     * cache or its parent has expired. &lt;code&gt;bundle.expire&lt;/code&gt; is true
     * upon return if the bundle in the cache has expired.
     */
    private static ResourceBundle findBundleInCache(CacheKey cacheKey,
                                                    Control control) {
<span class="fc" id="L1576">        BundleReference bundleRef = cacheList.get(cacheKey);</span>
<span class="fc bfc" id="L1577" title="All 2 branches covered.">        if (bundleRef == null) {</span>
<span class="fc" id="L1578">            return null;</span>
        }
<span class="fc" id="L1580">        ResourceBundle bundle = bundleRef.get();</span>
<span class="pc bpc" id="L1581" title="1 of 2 branches missed.">        if (bundle == null) {</span>
<span class="nc" id="L1582">            return null;</span>
        }
<span class="fc" id="L1584">        ResourceBundle p = bundle.parent;</span>
<span class="pc bpc" id="L1585" title="1 of 4 branches missed.">        assert p != NONEXISTENT_BUNDLE;</span>
        // If the parent has expired, then this one must also expire. We
        // check only the immediate parent because the actual loading is
        // done from the root (base) to leaf (child) and the purpose of
        // checking is to propagate expiration towards the leaf. For
        // example, if the requested locale is ja_JP_JP and there are
        // bundles for all of the candidates in the cache, we have a list,
        //
        // base &lt;- ja &lt;- ja_JP &lt;- ja_JP_JP
        //
        // If ja has expired, then it will reload ja and the list becomes a
        // tree.
        //
        // base &lt;- ja (new)
        //  &quot;   &lt;- ja (expired) &lt;- ja_JP &lt;- ja_JP_JP
        //
        // When looking up ja_JP in the cache, it finds ja_JP in the cache
        // which references to the expired ja. Then, ja_JP is marked as
        // expired and removed from the cache. This will be propagated to
        // ja_JP_JP.
        //
        // Now, it's possible, for example, that while loading new ja_JP,
        // someone else has started loading the same bundle and finds the
        // base bundle has expired. Then, what we get from the first
        // getBundle call includes the expired base bundle. However, if
        // someone else didn't start its loading, we wouldn't know if the
        // base bundle has expired at the end of the loading process. The
        // expiration control doesn't guarantee that the returned bundle and
        // its parents haven't expired.
        //
        // We could check the entire parent chain to see if there's any in
        // the chain that has expired. But this process may never end. An
        // extreme case would be that getTimeToLive returns 0 and
        // needsReload always returns true.
<span class="fc bfc" id="L1619" title="All 4 branches covered.">        if (p != null &amp;&amp; p.expired) {</span>
<span class="pc bpc" id="L1620" title="2 of 4 branches missed.">            assert bundle != NONEXISTENT_BUNDLE;</span>
<span class="fc" id="L1621">            bundle.expired = true;</span>
<span class="fc" id="L1622">            bundle.cacheKey = null;</span>
<span class="fc" id="L1623">            cacheList.remove(cacheKey, bundleRef);</span>
<span class="fc" id="L1624">            bundle = null;</span>
        } else {
<span class="fc" id="L1626">            CacheKey key = bundleRef.getCacheKey();</span>
<span class="fc" id="L1627">            long expirationTime = key.expirationTime;</span>
<span class="pc bpc" id="L1628" title="1 of 4 branches missed.">            if (!bundle.expired &amp;&amp; expirationTime &gt;= 0 &amp;&amp;</span>
<span class="fc bfc" id="L1629" title="All 2 branches covered.">                expirationTime &lt;= System.currentTimeMillis()) {</span>
                // its TTL period has expired.
<span class="fc bfc" id="L1631" title="All 2 branches covered.">                if (bundle != NONEXISTENT_BUNDLE) {</span>
                    // Synchronize here to call needsReload to avoid
                    // redundant concurrent calls for the same bundle.
<span class="fc" id="L1634">                    synchronized (bundle) {</span>
<span class="fc" id="L1635">                        expirationTime = key.expirationTime;</span>
<span class="pc bpc" id="L1636" title="1 of 4 branches missed.">                        if (!bundle.expired &amp;&amp; expirationTime &gt;= 0 &amp;&amp;</span>
<span class="fc bfc" id="L1637" title="All 2 branches covered.">                            expirationTime &lt;= System.currentTimeMillis()) {</span>
                            try {
<span class="fc" id="L1639">                                bundle.expired = control.needsReload(key.getName(),</span>
<span class="fc" id="L1640">                                                                     key.getLocale(),</span>
<span class="fc" id="L1641">                                                                     key.getFormat(),</span>
<span class="fc" id="L1642">                                                                     key.getLoader(),</span>
                                                                     bundle,
<span class="fc" id="L1644">                                                                     key.loadTime);</span>
<span class="nc" id="L1645">                            } catch (Exception e) {</span>
<span class="nc" id="L1646">                                cacheKey.setCause(e);</span>
<span class="fc" id="L1647">                            }</span>
<span class="fc bfc" id="L1648" title="All 2 branches covered.">                            if (bundle.expired) {</span>
                                // If the bundle needs to be reloaded, then
                                // remove the bundle from the cache, but
                                // return the bundle with the expired flag
                                // on.
<span class="fc" id="L1653">                                bundle.cacheKey = null;</span>
<span class="fc" id="L1654">                                cacheList.remove(cacheKey, bundleRef);</span>
                            } else {
                                // Update the expiration control info. and reuse
                                // the same bundle instance
<span class="fc" id="L1658">                                setExpirationTime(key, control);</span>
                            }
                        }
<span class="pc" id="L1661">                    }</span>
                } else {
                    // We just remove NONEXISTENT_BUNDLE from the cache.
<span class="fc" id="L1664">                    cacheList.remove(cacheKey, bundleRef);</span>
<span class="fc" id="L1665">                    bundle = null;</span>
                }
            }
        }
<span class="fc" id="L1669">        return bundle;</span>
    }

    /**
     * Put a new bundle in the cache.
     *
     * @param cacheKey the key for the resource bundle
     * @param bundle the resource bundle to be put in the cache
     * @return the ResourceBundle for the cacheKey; if someone has put
     * the bundle before this call, the one found in the cache is
     * returned.
     */
    private static ResourceBundle putBundleInCache(CacheKey cacheKey,
                                                   ResourceBundle bundle,
                                                   Control control) {
<span class="fc" id="L1684">        setExpirationTime(cacheKey, control);</span>
<span class="fc bfc" id="L1685" title="All 2 branches covered.">        if (cacheKey.expirationTime != Control.TTL_DONT_CACHE) {</span>
<span class="fc" id="L1686">            CacheKey key = (CacheKey) cacheKey.clone();</span>
<span class="fc" id="L1687">            BundleReference bundleRef = new BundleReference(bundle, referenceQueue, key);</span>
<span class="fc" id="L1688">            bundle.cacheKey = key;</span>

            // Put the bundle in the cache if it's not been in the cache.
<span class="fc" id="L1691">            BundleReference result = cacheList.putIfAbsent(key, bundleRef);</span>

            // If someone else has put the same bundle in the cache before
            // us and it has not expired, we should use the one in the cache.
<span class="fc bfc" id="L1695" title="All 2 branches covered.">            if (result != null) {</span>
<span class="fc" id="L1696">                ResourceBundle rb = result.get();</span>
<span class="pc bpc" id="L1697" title="2 of 4 branches missed.">                if (rb != null &amp;&amp; !rb.expired) {</span>
                    // Clear the back link to the cache key
<span class="fc" id="L1699">                    bundle.cacheKey = null;</span>
<span class="fc" id="L1700">                    bundle = rb;</span>
                    // Clear the reference in the BundleReference so that
                    // it won't be enqueued.
<span class="fc" id="L1703">                    bundleRef.clear();</span>
                } else {
                    // Replace the invalid (garbage collected or expired)
                    // instance with the valid one.
<span class="nc" id="L1707">                    cacheList.put(key, bundleRef);</span>
                }
            }
        }
<span class="fc" id="L1711">        return bundle;</span>
    }

    private static void setExpirationTime(CacheKey cacheKey, Control control) {
<span class="fc" id="L1715">        long ttl = control.getTimeToLive(cacheKey.getName(),</span>
<span class="fc" id="L1716">                                         cacheKey.getLocale());</span>
<span class="fc bfc" id="L1717" title="All 2 branches covered.">        if (ttl &gt;= 0) {</span>
            // If any expiration time is specified, set the time to be
            // expired in the cache.
<span class="fc" id="L1720">            long now = System.currentTimeMillis();</span>
<span class="fc" id="L1721">            cacheKey.loadTime = now;</span>
<span class="fc" id="L1722">            cacheKey.expirationTime = now + ttl;</span>
<span class="pc bpc" id="L1723" title="1 of 2 branches missed.">        } else if (ttl &gt;= Control.TTL_NO_EXPIRATION_CONTROL) {</span>
<span class="fc" id="L1724">            cacheKey.expirationTime = ttl;</span>
        } else {
<span class="nc" id="L1726">            throw new IllegalArgumentException(&quot;Invalid Control: TTL=&quot; + ttl);</span>
        }
<span class="fc" id="L1728">    }</span>

    /**
     * Removes all resource bundles from the cache that have been loaded
     * using the caller's class loader.
     *
     * @since 1.6
     * @see ResourceBundle.Control#getTimeToLive(String,Locale)
     */
    @CallerSensitive
    public static final void clearCache() {
<span class="fc" id="L1739">        clearCache(getLoader(Reflection.getCallerClass()));</span>
<span class="fc" id="L1740">    }</span>

    /**
     * Removes all resource bundles from the cache that have been loaded
     * using the given class loader.
     *
     * @param loader the class loader
     * @exception NullPointerException if &lt;code&gt;loader&lt;/code&gt; is null
     * @since 1.6
     * @see ResourceBundle.Control#getTimeToLive(String,Locale)
     */
    public static final void clearCache(ClassLoader loader) {
<span class="pc bpc" id="L1752" title="1 of 2 branches missed.">        if (loader == null) {</span>
<span class="nc" id="L1753">            throw new NullPointerException();</span>
        }
<span class="fc" id="L1755">        Set&lt;CacheKey&gt; set = cacheList.keySet();</span>
<span class="fc bfc" id="L1756" title="All 2 branches covered.">        for (CacheKey key : set) {</span>
<span class="pc bpc" id="L1757" title="1 of 2 branches missed.">            if (key.getLoader() == loader) {</span>
<span class="fc" id="L1758">                set.remove(key);</span>
            }
<span class="fc" id="L1760">        }</span>
<span class="fc" id="L1761">    }</span>

    /**
     * Gets an object for the given key from this resource bundle.
     * Returns null if this resource bundle does not contain an
     * object for the given key.
     *
     * @param key the key for the desired object
     * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @return the object for the given key, or null
     */
    protected abstract Object handleGetObject(String key);

    /**
     * Returns an enumeration of the keys.
     *
     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of the keys contained in
     *         this &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.
     */
    public abstract Enumeration&lt;String&gt; getKeys();

    /**
     * Determines whether the given &lt;code&gt;key&lt;/code&gt; is contained in
     * this &lt;code&gt;ResourceBundle&lt;/code&gt; or its parent bundles.
     *
     * @param key
     *        the resource &lt;code&gt;key&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;key&lt;/code&gt; is
     *        contained in this &lt;code&gt;ResourceBundle&lt;/code&gt; or its
     *        parent bundles; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @exception NullPointerException
     *         if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @since 1.6
     */
    public boolean containsKey(String key) {
<span class="pc bpc" id="L1796" title="1 of 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L1797">            throw new NullPointerException();</span>
        }
<span class="fc bfc" id="L1799" title="All 2 branches covered.">        for (ResourceBundle rb = this; rb != null; rb = rb.parent) {</span>
<span class="fc bfc" id="L1800" title="All 2 branches covered.">            if (rb.handleKeySet().contains(key)) {</span>
<span class="fc" id="L1801">                return true;</span>
            }
        }
<span class="fc" id="L1804">        return false;</span>
    }

    /**
     * Returns a &lt;code&gt;Set&lt;/code&gt; of all keys contained in this
     * &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.
     *
     * @return a &lt;code&gt;Set&lt;/code&gt; of all keys contained in this
     *         &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.
     * @since 1.6
     */
    public Set&lt;String&gt; keySet() {
<span class="nc" id="L1816">        Set&lt;String&gt; keys = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1817" title="All 2 branches missed.">        for (ResourceBundle rb = this; rb != null; rb = rb.parent) {</span>
<span class="nc" id="L1818">            keys.addAll(rb.handleKeySet());</span>
        }
<span class="nc" id="L1820">        return keys;</span>
    }

    /**
     * Returns a &lt;code&gt;Set&lt;/code&gt; of the keys contained &lt;em&gt;only&lt;/em&gt;
     * in this &lt;code&gt;ResourceBundle&lt;/code&gt;.
     *
     * &lt;p&gt;The default implementation returns a &lt;code&gt;Set&lt;/code&gt; of the
     * keys returned by the {@link #getKeys() getKeys} method except
     * for the ones for which the {@link #handleGetObject(String)
     * handleGetObject} method returns &lt;code&gt;null&lt;/code&gt;. Once the
     * &lt;code&gt;Set&lt;/code&gt; has been created, the value is kept in this
     * &lt;code&gt;ResourceBundle&lt;/code&gt; in order to avoid producing the
     * same &lt;code&gt;Set&lt;/code&gt; in subsequent calls. Subclasses can
     * override this method for faster handling.
     *
     * @return a &lt;code&gt;Set&lt;/code&gt; of the keys contained only in this
     *        &lt;code&gt;ResourceBundle&lt;/code&gt;
     * @since 1.6
     */
    protected Set&lt;String&gt; handleKeySet() {
<span class="nc bnc" id="L1841" title="All 2 branches missed.">        if (keySet == null) {</span>
<span class="nc" id="L1842">            synchronized (this) {</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">                if (keySet == null) {</span>
<span class="nc" id="L1844">                    Set&lt;String&gt; keys = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1845">                    Enumeration&lt;String&gt; enumKeys = getKeys();</span>
<span class="nc bnc" id="L1846" title="All 2 branches missed.">                    while (enumKeys.hasMoreElements()) {</span>
<span class="nc" id="L1847">                        String key = enumKeys.nextElement();</span>
<span class="nc bnc" id="L1848" title="All 2 branches missed.">                        if (handleGetObject(key) != null) {</span>
<span class="nc" id="L1849">                            keys.add(key);</span>
                        }
<span class="nc" id="L1851">                    }</span>
<span class="nc" id="L1852">                    keySet = keys;</span>
                }
<span class="nc" id="L1854">            }</span>
        }
<span class="nc" id="L1856">        return keySet;</span>
    }



    /**
     * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; defines a set of callback methods
     * that are invoked by the {@link ResourceBundle#getBundle(String,
     * Locale, ClassLoader, Control) ResourceBundle.getBundle} factory
     * methods during the bundle loading process. In other words, a
     * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; collaborates with the factory
     * methods for loading resource bundles. The default implementation of
     * the callback methods provides the information necessary for the
     * factory methods to perform the &lt;a
     * href=&quot;./ResourceBundle.html#default_behavior&quot;&gt;default behavior&lt;/a&gt;.
     *
     * &lt;p&gt;In addition to the callback methods, the {@link
     * #toBundleName(String, Locale) toBundleName} and {@link
     * #toResourceName(String, String) toResourceName} methods are defined
     * primarily for convenience in implementing the callback
     * methods. However, the &lt;code&gt;toBundleName&lt;/code&gt; method could be
     * overridden to provide different conventions in the organization and
     * packaging of localized resources.  The &lt;code&gt;toResourceName&lt;/code&gt;
     * method is &lt;code&gt;final&lt;/code&gt; to avoid use of wrong resource and class
     * name separators.
     *
     * &lt;p&gt;Two factory methods, {@link #getControl(List)} and {@link
     * #getNoFallbackControl(List)}, provide
     * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instances that implement common
     * variations of the default bundle loading process.
     *
     * &lt;p&gt;The formats returned by the {@link Control#getFormats(String)
     * getFormats} method and candidate locales returned by the {@link
     * ResourceBundle.Control#getCandidateLocales(String, Locale)
     * getCandidateLocales} method must be consistent in all
     * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; invocations for the same base
     * bundle. Otherwise, the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; methods
     * may return unintended bundles. For example, if only
     * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; is returned by the &lt;code&gt;getFormats&lt;/code&gt;
     * method for the first call to &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;
     * and only &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; for the second call, then the
     * second call will return the class-based one that has been cached
     * during the first call.
     *
     * &lt;p&gt;A &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instance must be thread-safe
     * if it's simultaneously used by multiple threads.
     * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; does not synchronize to call
     * the &lt;code&gt;ResourceBundle.Control&lt;/code&gt; methods. The default
     * implementations of the methods are thread-safe.
     *
     * &lt;p&gt;Applications can specify &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
     * instances returned by the &lt;code&gt;getControl&lt;/code&gt; factory methods or
     * created from a subclass of &lt;code&gt;ResourceBundle.Control&lt;/code&gt; to
     * customize the bundle loading process. The following are examples of
     * changing the default bundle loading process.
     *
     * &lt;p&gt;&lt;b&gt;Example 1&lt;/b&gt;
     *
     * &lt;p&gt;The following code lets &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; look
     * up only properties-based resources.
     *
     * &lt;pre&gt;
     * import java.util.*;
     * import static java.util.ResourceBundle.Control.*;
     * ...
     * ResourceBundle bundle =
     *   ResourceBundle.getBundle(&quot;MyResources&quot;, new Locale(&quot;fr&quot;, &quot;CH&quot;),
     *                            ResourceBundle.Control.getControl(FORMAT_PROPERTIES));
     * &lt;/pre&gt;
     *
     * Given the resource bundles in the &lt;a
     * href=&quot;./ResourceBundle.html#default_behavior_example&quot;&gt;example&lt;/a&gt; in
     * the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; description, this
     * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; call loads
     * &lt;code&gt;MyResources_fr_CH.properties&lt;/code&gt; whose parent is
     * &lt;code&gt;MyResources_fr.properties&lt;/code&gt; whose parent is
     * &lt;code&gt;MyResources.properties&lt;/code&gt;. (&lt;code&gt;MyResources_fr_CH.properties&lt;/code&gt;
     * is not hidden, but &lt;code&gt;MyResources_fr_CH.class&lt;/code&gt; is.)
     *
     * &lt;p&gt;&lt;b&gt;Example 2&lt;/b&gt;
     *
     * &lt;p&gt;The following is an example of loading XML-based bundles
     * using {@link Properties#loadFromXML(java.io.InputStream)
     * Properties.loadFromXML}.
     *
     * &lt;pre&gt;
     * ResourceBundle rb = ResourceBundle.getBundle(&quot;Messages&quot;,
     *     new ResourceBundle.Control() {
     *         public List&amp;lt;String&amp;gt; getFormats(String baseName) {
     *             if (baseName == null)
     *                 throw new NullPointerException();
     *             return Arrays.asList(&quot;xml&quot;);
     *         }
     *         public ResourceBundle newBundle(String baseName,
     *                                         Locale locale,
     *                                         String format,
     *                                         ClassLoader loader,
     *                                         boolean reload)
     *                          throws IllegalAccessException,
     *                                 InstantiationException,
     *                                 IOException {
     *             if (baseName == null || locale == null
     *                   || format == null || loader == null)
     *                 throw new NullPointerException();
     *             ResourceBundle bundle = null;
     *             if (format.equals(&quot;xml&quot;)) {
     *                 String bundleName = toBundleName(baseName, locale);
     *                 String resourceName = toResourceName(bundleName, format);
     *                 InputStream stream = null;
     *                 if (reload) {
     *                     URL url = loader.getResource(resourceName);
     *                     if (url != null) {
     *                         URLConnection connection = url.openConnection();
     *                         if (connection != null) {
     *                             // Disable caches to get fresh data for
     *                             // reloading.
     *                             connection.setUseCaches(false);
     *                             stream = connection.getInputStream();
     *                         }
     *                     }
     *                 } else {
     *                     stream = loader.getResourceAsStream(resourceName);
     *                 }
     *                 if (stream != null) {
     *                     BufferedInputStream bis = new BufferedInputStream(stream);
     *                     bundle = new XMLResourceBundle(bis);
     *                     bis.close();
     *                 }
     *             }
     *             return bundle;
     *         }
     *     });
     *
     * ...
     *
     * private static class XMLResourceBundle extends ResourceBundle {
     *     private Properties props;
     *     XMLResourceBundle(InputStream stream) throws IOException {
     *         props = new Properties();
     *         props.loadFromXML(stream);
     *     }
     *     protected Object handleGetObject(String key) {
     *         return props.getProperty(key);
     *     }
     *     public Enumeration&amp;lt;String&amp;gt; getKeys() {
     *         ...
     *     }
     * }
     * &lt;/pre&gt;
     *
     * @since 1.6
     */
    public static class Control {
        /**
         * The default format &lt;code&gt;List&lt;/code&gt;, which contains the strings
         * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, in
         * this order. This &lt;code&gt;List&lt;/code&gt; is {@linkplain
         * Collections#unmodifiableList(List) unmodifiable}.
         *
         * @see #getFormats(String)
         */
<span class="fc" id="L2017">        public static final List&lt;String&gt; FORMAT_DEFAULT</span>
<span class="fc" id="L2018">            = Collections.unmodifiableList(Arrays.asList(&quot;java.class&quot;,</span>
                                                         &quot;java.properties&quot;));

        /**
         * The class-only format &lt;code&gt;List&lt;/code&gt; containing
         * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is {@linkplain
         * Collections#unmodifiableList(List) unmodifiable}.
         *
         * @see #getFormats(String)
         */
<span class="fc" id="L2028">        public static final List&lt;String&gt; FORMAT_CLASS</span>
<span class="fc" id="L2029">            = Collections.unmodifiableList(Arrays.asList(&quot;java.class&quot;));</span>

        /**
         * The properties-only format &lt;code&gt;List&lt;/code&gt; containing
         * &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is
         * {@linkplain Collections#unmodifiableList(List) unmodifiable}.
         *
         * @see #getFormats(String)
         */
<span class="fc" id="L2038">        public static final List&lt;String&gt; FORMAT_PROPERTIES</span>
<span class="fc" id="L2039">            = Collections.unmodifiableList(Arrays.asList(&quot;java.properties&quot;));</span>

        /**
         * The time-to-live constant for not caching loaded resource bundle
         * instances.
         *
         * @see #getTimeToLive(String, Locale)
         */
        public static final long TTL_DONT_CACHE = -1;

        /**
         * The time-to-live constant for disabling the expiration control
         * for loaded resource bundle instances in the cache.
         *
         * @see #getTimeToLive(String, Locale)
         */
        public static final long TTL_NO_EXPIRATION_CONTROL = -2;

<span class="fc" id="L2057">        private static final Control INSTANCE = new Control();</span>

        /**
         * Sole constructor. (For invocation by subclass constructors,
         * typically implicit.)
         */
<span class="fc" id="L2063">        protected Control() {</span>
<span class="fc" id="L2064">        }</span>

        /**
         * Returns a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; in which the {@link
         * #getFormats(String) getFormats} method returns the specified
         * &lt;code&gt;formats&lt;/code&gt;. The &lt;code&gt;formats&lt;/code&gt; must be equal to
         * one of {@link Control#FORMAT_PROPERTIES}, {@link
         * Control#FORMAT_CLASS} or {@link
         * Control#FORMAT_DEFAULT}. &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
         * instances returned by this method are singletons and thread-safe.
         *
         * &lt;p&gt;Specifying {@link Control#FORMAT_DEFAULT} is equivalent to
         * instantiating the &lt;code&gt;ResourceBundle.Control&lt;/code&gt; class,
         * except that this method returns a singleton.
         *
         * @param formats
         *        the formats to be returned by the
         *        &lt;code&gt;ResourceBundle.Control.getFormats&lt;/code&gt; method
         * @return a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; supporting the
         *        specified &lt;code&gt;formats&lt;/code&gt;
         * @exception NullPointerException
         *        if &lt;code&gt;formats&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
         * @exception IllegalArgumentException
         *        if &lt;code&gt;formats&lt;/code&gt; is unknown
         */
        public static final Control getControl(List&lt;String&gt; formats) {
<span class="pc bpc" id="L2090" title="1 of 2 branches missed.">            if (formats.equals(Control.FORMAT_PROPERTIES)) {</span>
<span class="nc" id="L2091">                return SingleFormatControl.PROPERTIES_ONLY;</span>
            }
<span class="pc bpc" id="L2093" title="1 of 2 branches missed.">            if (formats.equals(Control.FORMAT_CLASS)) {</span>
<span class="nc" id="L2094">                return SingleFormatControl.CLASS_ONLY;</span>
            }
<span class="pc bpc" id="L2096" title="1 of 2 branches missed.">            if (formats.equals(Control.FORMAT_DEFAULT)) {</span>
<span class="fc" id="L2097">                return Control.INSTANCE;</span>
            }
<span class="nc" id="L2099">            throw new IllegalArgumentException();</span>
        }

        /**
         * Returns a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; in which the {@link
         * #getFormats(String) getFormats} method returns the specified
         * &lt;code&gt;formats&lt;/code&gt; and the {@link
         * Control#getFallbackLocale(String, Locale) getFallbackLocale}
         * method returns &lt;code&gt;null&lt;/code&gt;. The &lt;code&gt;formats&lt;/code&gt; must
         * be equal to one of {@link Control#FORMAT_PROPERTIES}, {@link
         * Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}.
         * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instances returned by this
         * method are singletons and thread-safe.
         *
         * @param formats
         *        the formats to be returned by the
         *        &lt;code&gt;ResourceBundle.Control.getFormats&lt;/code&gt; method
         * @return a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; supporting the
         *        specified &lt;code&gt;formats&lt;/code&gt; with no fallback
         *        &lt;code&gt;Locale&lt;/code&gt; support
         * @exception NullPointerException
         *        if &lt;code&gt;formats&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
         * @exception IllegalArgumentException
         *        if &lt;code&gt;formats&lt;/code&gt; is unknown
         */
        public static final Control getNoFallbackControl(List&lt;String&gt; formats) {
<span class="pc bpc" id="L2125" title="1 of 2 branches missed.">            if (formats.equals(Control.FORMAT_DEFAULT)) {</span>
<span class="fc" id="L2126">                return NoFallbackControl.NO_FALLBACK;</span>
            }
<span class="nc bnc" id="L2128" title="All 2 branches missed.">            if (formats.equals(Control.FORMAT_PROPERTIES)) {</span>
<span class="nc" id="L2129">                return NoFallbackControl.PROPERTIES_ONLY_NO_FALLBACK;</span>
            }
<span class="nc bnc" id="L2131" title="All 2 branches missed.">            if (formats.equals(Control.FORMAT_CLASS)) {</span>
<span class="nc" id="L2132">                return NoFallbackControl.CLASS_ONLY_NO_FALLBACK;</span>
            }
<span class="nc" id="L2134">            throw new IllegalArgumentException();</span>
        }

        /**
         * Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s containing
         * formats to be used to load resource bundles for the given
         * &lt;code&gt;baseName&lt;/code&gt;. The &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;
         * factory method tries to load resource bundles with formats in the
         * order specified by the list. The list returned by this method
         * must have at least one &lt;code&gt;String&lt;/code&gt;. The predefined
         * formats are &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; for class-based resource
         * bundles and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; for {@linkplain
         * PropertyResourceBundle properties-based} ones. Strings starting
         * with &lt;code&gt;&quot;java.&quot;&lt;/code&gt; are reserved for future extensions and
         * must not be used by application-defined formats.
         *
         * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
         * &lt;code&gt;List&lt;/code&gt;.  However, the returned &lt;code&gt;List&lt;/code&gt; must
         * not be mutated after it has been returned by
         * &lt;code&gt;getFormats&lt;/code&gt;.
         *
         * &lt;p&gt;The default implementation returns {@link #FORMAT_DEFAULT} so
         * that the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method
         * looks up first class-based resource bundles, then
         * properties-based ones.
         *
         * @param baseName
         *        the base name of the resource bundle, a fully qualified class
         *        name
         * @return a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s containing
         *        formats for loading resource bundles.
         * @exception NullPointerException
         *        if &lt;code&gt;baseName&lt;/code&gt; is null
         * @see #FORMAT_DEFAULT
         * @see #FORMAT_CLASS
         * @see #FORMAT_PROPERTIES
         */
        public List&lt;String&gt; getFormats(String baseName) {
<span class="pc bpc" id="L2172" title="1 of 2 branches missed.">            if (baseName == null) {</span>
<span class="nc" id="L2173">                throw new NullPointerException();</span>
            }
<span class="fc" id="L2175">            return FORMAT_DEFAULT;</span>
        }

        /**
         * Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Locale&lt;/code&gt;s as candidate
         * locales for &lt;code&gt;baseName&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt;. This
         * method is called by the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;
         * factory method each time the factory method tries finding a
         * resource bundle for a target &lt;code&gt;Locale&lt;/code&gt;.
         *
         * &lt;p&gt;The sequence of the candidate locales also corresponds to the
         * runtime resource lookup path (also known as the &lt;I&gt;parent
         * chain&lt;/I&gt;), if the corresponding resource bundles for the
         * candidate locales exist and their parents are not defined by
         * loaded resource bundles themselves.  The last element of the list
         * must be a {@linkplain Locale#ROOT root locale} if it is desired to
         * have the base bundle as the terminal of the parent chain.
         *
         * &lt;p&gt;If the given locale is equal to &lt;code&gt;Locale.ROOT&lt;/code&gt; (the
         * root locale), a &lt;code&gt;List&lt;/code&gt; containing only the root
         * &lt;code&gt;Locale&lt;/code&gt; must be returned. In this case, the
         * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method loads only
         * the base bundle as the resulting resource bundle.
         *
         * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
         * &lt;code&gt;List&lt;/code&gt;. However, the returned &lt;code&gt;List&lt;/code&gt; must not
         * be mutated after it has been returned by
         * &lt;code&gt;getCandidateLocales&lt;/code&gt;.
         *
         * &lt;p&gt;The default implementation returns a &lt;code&gt;List&lt;/code&gt; containing
         * &lt;code&gt;Locale&lt;/code&gt;s using the rules described below.  In the
         * description below, &lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;V&lt;/em&gt;
         * respectively represent non-empty language, script, country, and
         * variant.  For example, [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] represents a
         * &lt;code&gt;Locale&lt;/code&gt; that has non-empty values only for language and
         * country.  The form &lt;em&gt;L&lt;/em&gt;(&quot;xx&quot;) represents the (non-empty)
         * language value is &quot;xx&quot;.  For all cases, &lt;code&gt;Locale&lt;/code&gt;s whose
         * final component values are empty strings are omitted.
         *
         * &lt;ol&gt;&lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with an empty script value,
         * append candidate &lt;code&gt;Locale&lt;/code&gt;s by omitting the final component
         * one by one as below:
         *
         * &lt;ul&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;] &lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] &lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;] &lt;/li&gt;
         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt; &lt;/li&gt;
         * &lt;/ul&gt;&lt;/li&gt;
         *
         * &lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with a non-empty script value,
         * append candidate &lt;code&gt;Locale&lt;/code&gt;s by omitting the final component
         * up to language, then append candidates generated from the
         * &lt;code&gt;Locale&lt;/code&gt; with country and variant restored:
         *
         * &lt;ul&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;
         * &lt;/ul&gt;&lt;/li&gt;
         *
         * &lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with a variant value consisting
         * of multiple subtags separated by underscore, generate candidate
         * &lt;code&gt;Locale&lt;/code&gt;s by omitting the variant subtags one by one, then
         * insert them after every occurrence of &lt;code&gt; Locale&lt;/code&gt;s with the
         * full variant value in the original list.  For example, if the
         * the variant consists of two subtags &lt;em&gt;V1&lt;/em&gt; and &lt;em&gt;V2&lt;/em&gt;:
         *
         * &lt;ul&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;
         * &lt;/ul&gt;&lt;/li&gt;
         *
         * &lt;li&gt;Special cases for Chinese.  When an input &lt;code&gt;Locale&lt;/code&gt; has the
         * language &quot;zh&quot; (Chinese) and an empty script value, either &quot;Hans&quot; (Simplified) or
         * &quot;Hant&quot; (Traditional) might be supplied, depending on the country.
         * When the country is &quot;CN&quot; (China) or &quot;SG&quot; (Singapore), &quot;Hans&quot; is supplied.
         * When the country is &quot;HK&quot; (Hong Kong SAR China), &quot;MO&quot; (Macau SAR China),
         * or &quot;TW&quot; (Taiwan), &quot;Hant&quot; is supplied.  For all other countries or when the country
         * is empty, no script is supplied.  For example, for &lt;code&gt;Locale(&quot;zh&quot;, &quot;CN&quot;)
         * &lt;/code&gt;, the candidate list will be:
         * &lt;ul&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * For &lt;code&gt;Locale(&quot;zh&quot;, &quot;TW&quot;)&lt;/code&gt;, the candidate list will be:
         * &lt;ul&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;
         * &lt;/ul&gt;&lt;/li&gt;
         *
         * &lt;li&gt;Special cases for Norwegian.  Both &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;,
         * &quot;NY&quot;)&lt;/code&gt; and &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; represent Norwegian
         * Nynorsk.  When a locale's language is &quot;nn&quot;, the standard candidate
         * list is generated up to [&lt;em&gt;L&lt;/em&gt;(&quot;nn&quot;)], and then the following
         * candidates are added:
         *
         * &lt;ul&gt;&lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;NY&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * If the locale is exactly &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt;, it is first
         * converted to &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; and then the above procedure is
         * followed.
         *
         * &lt;p&gt;Also, Java treats the language &quot;no&quot; as a synonym of Norwegian
         * Bokm&amp;#xE5;l &quot;nb&quot;.  Except for the single case &lt;code&gt;Locale(&quot;no&quot;,
         * &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; (handled above), when an input &lt;code&gt;Locale&lt;/code&gt;
         * has language &quot;no&quot; or &quot;nb&quot;, candidate &lt;code&gt;Locale&lt;/code&gt;s with
         * language code &quot;no&quot; and &quot;nb&quot; are interleaved, first using the
         * requested language, then using its synonym. For example,
         * &lt;code&gt;Locale(&quot;nb&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; generates the following
         * candidate list:
         *
         * &lt;ul&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;)]&lt;/li&gt;
         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; would generate the same list
         * except that locales with &quot;no&quot; would appear before the corresponding
         * locales with &quot;nb&quot;.&lt;/li&gt;
         * &lt;/ol&gt;
         *
         * &lt;p&gt;The default implementation uses an {@link ArrayList} that
         * overriding implementations may modify before returning it to the
         * caller. However, a subclass must not modify it after it has
         * been returned by &lt;code&gt;getCandidateLocales&lt;/code&gt;.
         *
         * &lt;p&gt;For example, if the given &lt;code&gt;baseName&lt;/code&gt; is &quot;Messages&quot;
         * and the given &lt;code&gt;locale&lt;/code&gt; is
         * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then a
         * &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Locale&lt;/code&gt;s:
         * &lt;pre&gt;
         *     Locale(&quot;ja&quot;, &quot;&quot;, &quot;XX&quot;)
         *     Locale(&quot;ja&quot;)
         *     Locale.ROOT
         * &lt;/pre&gt;
         * is returned. And if the resource bundles for the &quot;ja&quot; and
         * &quot;&quot; &lt;code&gt;Locale&lt;/code&gt;s are found, then the runtime resource
         * lookup path (parent chain) is:
         * &lt;pre&gt;{@code
         *     Messages_ja -&gt; Messages
         * }&lt;/pre&gt;
         *
         * @param baseName
         *        the base name of the resource bundle, a fully
         *        qualified class name
         * @param locale
         *        the locale for which a resource bundle is desired
         * @return a &lt;code&gt;List&lt;/code&gt; of candidate
         *        &lt;code&gt;Locale&lt;/code&gt;s for the given &lt;code&gt;locale&lt;/code&gt;
         * @exception NullPointerException
         *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is
         *        &lt;code&gt;null&lt;/code&gt;
         */
        public List&lt;Locale&gt; getCandidateLocales(String baseName, Locale locale) {
<span class="pc bpc" id="L2357" title="1 of 2 branches missed.">            if (baseName == null) {</span>
<span class="nc" id="L2358">                throw new NullPointerException();</span>
            }
<span class="fc" id="L2360">            return new ArrayList&lt;&gt;(CANDIDATES_CACHE.get(locale.getBaseLocale()));</span>
        }

<span class="fc" id="L2363">        private static final CandidateListCache CANDIDATES_CACHE = new CandidateListCache();</span>

<span class="fc" id="L2365">        private static class CandidateListCache extends LocaleObjectCache&lt;BaseLocale, List&lt;Locale&gt;&gt; {</span>
            protected List&lt;Locale&gt; createObject(BaseLocale base) {
<span class="fc" id="L2367">                String language = base.getLanguage();</span>
<span class="fc" id="L2368">                String script = base.getScript();</span>
<span class="fc" id="L2369">                String region = base.getRegion();</span>
<span class="fc" id="L2370">                String variant = base.getVariant();</span>

                // Special handling for Norwegian
<span class="fc" id="L2373">                boolean isNorwegianBokmal = false;</span>
<span class="fc" id="L2374">                boolean isNorwegianNynorsk = false;</span>
<span class="fc bfc" id="L2375" title="All 2 branches covered.">                if (language.equals(&quot;no&quot;)) {</span>
<span class="fc bfc" id="L2376" title="All 4 branches covered.">                    if (region.equals(&quot;NO&quot;) &amp;&amp; variant.equals(&quot;NY&quot;)) {</span>
<span class="fc" id="L2377">                        variant = &quot;&quot;;</span>
<span class="fc" id="L2378">                        isNorwegianNynorsk = true;</span>
                    } else {
<span class="fc" id="L2380">                        isNorwegianBokmal = true;</span>
                    }
                }
<span class="pc bpc" id="L2383" title="1 of 4 branches missed.">                if (language.equals(&quot;nb&quot;) || isNorwegianBokmal) {</span>
<span class="fc" id="L2384">                    List&lt;Locale&gt; tmpList = getDefaultList(&quot;nb&quot;, script, region, variant);</span>
                    // Insert a locale replacing &quot;nb&quot; with &quot;no&quot; for every list entry
<span class="fc" id="L2386">                    List&lt;Locale&gt; bokmalList = new LinkedList&lt;&gt;();</span>
<span class="pc bpc" id="L2387" title="1 of 2 branches missed.">                    for (Locale l : tmpList) {</span>
<span class="fc" id="L2388">                        bokmalList.add(l);</span>
<span class="fc bfc" id="L2389" title="All 2 branches covered.">                        if (l.getLanguage().length() == 0) {</span>
<span class="fc" id="L2390">                            break;</span>
                        }
<span class="fc" id="L2392">                        bokmalList.add(Locale.getInstance(&quot;no&quot;, l.getScript(), l.getCountry(),</span>
<span class="fc" id="L2393">                                l.getVariant(), null));</span>
<span class="fc" id="L2394">                    }</span>
<span class="fc" id="L2395">                    return bokmalList;</span>
<span class="pc bpc" id="L2396" title="1 of 4 branches missed.">                } else if (language.equals(&quot;nn&quot;) || isNorwegianNynorsk) {</span>
                    // Insert no_NO_NY, no_NO, no after nn
<span class="fc" id="L2398">                    List&lt;Locale&gt; nynorskList = getDefaultList(&quot;nn&quot;, script, region, variant);</span>
<span class="fc" id="L2399">                    int idx = nynorskList.size() - 1;</span>
<span class="fc" id="L2400">                    nynorskList.add(idx++, Locale.getInstance(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;));</span>
<span class="fc" id="L2401">                    nynorskList.add(idx++, Locale.getInstance(&quot;no&quot;, &quot;NO&quot;, &quot;&quot;));</span>
<span class="fc" id="L2402">                    nynorskList.add(idx++, Locale.getInstance(&quot;no&quot;, &quot;&quot;, &quot;&quot;));</span>
<span class="fc" id="L2403">                    return nynorskList;</span>
                }
                // Special handling for Chinese
<span class="fc bfc" id="L2406" title="All 2 branches covered.">                else if (language.equals(&quot;zh&quot;)) {</span>
<span class="fc bfc" id="L2407" title="All 4 branches covered.">                    if (script.length() == 0 &amp;&amp; region.length() &gt; 0) {</span>
                        // Supply script for users who want to use zh_Hans/zh_Hant
                        // as bundle names (recommended for Java7+)
<span class="pc bpc" id="L2410" title="9 of 19 branches missed.">                        switch (region) {</span>
                        case &quot;TW&quot;:
                        case &quot;HK&quot;:
                        case &quot;MO&quot;:
<span class="fc" id="L2414">                            script = &quot;Hant&quot;;</span>
<span class="fc" id="L2415">                            break;</span>
                        case &quot;CN&quot;:
                        case &quot;SG&quot;:
<span class="fc" id="L2418">                            script = &quot;Hans&quot;;</span>
<span class="fc" id="L2419">                            break;</span>
                        }
<span class="fc bfc" id="L2421" title="All 4 branches covered.">                    } else if (script.length() &gt; 0 &amp;&amp; region.length() == 0) {</span>
                        // Supply region(country) for users who still package Chinese
                        // bundles using old convension.
<span class="pc bpc" id="L2424" title="7 of 10 branches missed.">                        switch (script) {</span>
                        case &quot;Hans&quot;:
<span class="nc" id="L2426">                            region = &quot;CN&quot;;</span>
<span class="nc" id="L2427">                            break;</span>
                        case &quot;Hant&quot;:
<span class="fc" id="L2429">                            region = &quot;TW&quot;;</span>
                            break;
                        }
                    }
                }

<span class="fc" id="L2435">                return getDefaultList(language, script, region, variant);</span>
            }

            private static List&lt;Locale&gt; getDefaultList(String language, String script, String region, String variant) {
<span class="fc" id="L2439">                List&lt;String&gt; variants = null;</span>

<span class="fc bfc" id="L2441" title="All 2 branches covered.">                if (variant.length() &gt; 0) {</span>
<span class="fc" id="L2442">                    variants = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L2443">                    int idx = variant.length();</span>
<span class="fc bfc" id="L2444" title="All 2 branches covered.">                    while (idx != -1) {</span>
<span class="fc" id="L2445">                        variants.add(variant.substring(0, idx));</span>
<span class="fc" id="L2446">                        idx = variant.lastIndexOf('_', --idx);</span>
                    }
                }

<span class="fc" id="L2450">                List&lt;Locale&gt; list = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L2452" title="All 2 branches covered.">                if (variants != null) {</span>
<span class="fc bfc" id="L2453" title="All 2 branches covered.">                    for (String v : variants) {</span>
<span class="fc" id="L2454">                        list.add(Locale.getInstance(language, script, region, v, null));</span>
<span class="fc" id="L2455">                    }</span>
                }
<span class="fc bfc" id="L2457" title="All 2 branches covered.">                if (region.length() &gt; 0) {</span>
<span class="fc" id="L2458">                    list.add(Locale.getInstance(language, script, region, &quot;&quot;, null));</span>
                }
<span class="fc bfc" id="L2460" title="All 2 branches covered.">                if (script.length() &gt; 0) {</span>
<span class="fc" id="L2461">                    list.add(Locale.getInstance(language, script, &quot;&quot;, &quot;&quot;, null));</span>

                    // With script, after truncating variant, region and script,
                    // start over without script.
<span class="pc bpc" id="L2465" title="1 of 2 branches missed.">                    if (variants != null) {</span>
<span class="nc bnc" id="L2466" title="All 2 branches missed.">                        for (String v : variants) {</span>
<span class="nc" id="L2467">                            list.add(Locale.getInstance(language, &quot;&quot;, region, v, null));</span>
<span class="nc" id="L2468">                        }</span>
                    }
<span class="fc bfc" id="L2470" title="All 2 branches covered.">                    if (region.length() &gt; 0) {</span>
<span class="fc" id="L2471">                        list.add(Locale.getInstance(language, &quot;&quot;, region, &quot;&quot;, null));</span>
                    }
                }
<span class="fc bfc" id="L2474" title="All 2 branches covered.">                if (language.length() &gt; 0) {</span>
<span class="fc" id="L2475">                    list.add(Locale.getInstance(language, &quot;&quot;, &quot;&quot;, &quot;&quot;, null));</span>
                }
                // Add root locale at the end
<span class="fc" id="L2478">                list.add(Locale.ROOT);</span>

<span class="fc" id="L2480">                return list;</span>
            }
        }

        /**
         * Returns a &lt;code&gt;Locale&lt;/code&gt; to be used as a fallback locale for
         * further resource bundle searches by the
         * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method. This method
         * is called from the factory method every time when no resulting
         * resource bundle has been found for &lt;code&gt;baseName&lt;/code&gt; and
         * &lt;code&gt;locale&lt;/code&gt;, where locale is either the parameter for
         * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; or the previous fallback
         * locale returned by this method.
         *
         * &lt;p&gt;The method returns &lt;code&gt;null&lt;/code&gt; if no further fallback
         * search is desired.
         *
         * &lt;p&gt;The default implementation returns the {@linkplain
         * Locale#getDefault() default &lt;code&gt;Locale&lt;/code&gt;} if the given
         * &lt;code&gt;locale&lt;/code&gt; isn't the default one.  Otherwise,
         * &lt;code&gt;null&lt;/code&gt; is returned.
         *
         * @param baseName
         *        the base name of the resource bundle, a fully
         *        qualified class name for which
         *        &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; has been
         *        unable to find any resource bundles (except for the
         *        base bundle)
         * @param locale
         *        the &lt;code&gt;Locale&lt;/code&gt; for which
         *        &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; has been
         *        unable to find any resource bundles (except for the
         *        base bundle)
         * @return a &lt;code&gt;Locale&lt;/code&gt; for the fallback search,
         *        or &lt;code&gt;null&lt;/code&gt; if no further fallback search
         *        is desired.
         * @exception NullPointerException
         *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt;
         *        is &lt;code&gt;null&lt;/code&gt;
         */
        public Locale getFallbackLocale(String baseName, Locale locale) {
<span class="pc bpc" id="L2521" title="1 of 2 branches missed.">            if (baseName == null) {</span>
<span class="nc" id="L2522">                throw new NullPointerException();</span>
            }
<span class="fc" id="L2524">            Locale defaultLocale = Locale.getDefault();</span>
<span class="fc bfc" id="L2525" title="All 2 branches covered.">            return locale.equals(defaultLocale) ? null : defaultLocale;</span>
        }

        /**
         * Instantiates a resource bundle for the given bundle name of the
         * given format and locale, using the given class loader if
         * necessary. This method returns &lt;code&gt;null&lt;/code&gt; if there is no
         * resource bundle available for the given parameters. If a resource
         * bundle can't be instantiated due to an unexpected error, the
         * error must be reported by throwing an &lt;code&gt;Error&lt;/code&gt; or
         * &lt;code&gt;Exception&lt;/code&gt; rather than simply returning
         * &lt;code&gt;null&lt;/code&gt;.
         *
         * &lt;p&gt;If the &lt;code&gt;reload&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, it
         * indicates that this method is being called because the previously
         * loaded resource bundle has expired.
         *
         * &lt;p&gt;The default implementation instantiates a
         * &lt;code&gt;ResourceBundle&lt;/code&gt; as follows.
         *
         * &lt;ul&gt;
         *
         * &lt;li&gt;The bundle name is obtained by calling {@link
         * #toBundleName(String, Locale) toBundleName(baseName,
         * locale)}.&lt;/li&gt;
         *
         * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;, the
         * {@link Class} specified by the bundle name is loaded by calling
         * {@link ClassLoader#loadClass(String)}. Then, a
         * &lt;code&gt;ResourceBundle&lt;/code&gt; is instantiated by calling {@link
         * Class#newInstance()}.  Note that the &lt;code&gt;reload&lt;/code&gt; flag is
         * ignored for loading class-based resource bundles in this default
         * implementation.&lt;/li&gt;
         *
         * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;,
         * {@link #toResourceName(String, String) toResourceName(bundlename,
         * &quot;properties&quot;)} is called to get the resource name.
         * If &lt;code&gt;reload&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, {@link
         * ClassLoader#getResource(String) load.getResource} is called
         * to get a {@link URL} for creating a {@link
         * URLConnection}. This &lt;code&gt;URLConnection&lt;/code&gt; is used to
         * {@linkplain URLConnection#setUseCaches(boolean) disable the
         * caches} of the underlying resource loading layers,
         * and to {@linkplain URLConnection#getInputStream() get an
         * &lt;code&gt;InputStream&lt;/code&gt;}.
         * Otherwise, {@link ClassLoader#getResourceAsStream(String)
         * loader.getResourceAsStream} is called to get an {@link
         * InputStream}. Then, a {@link
         * PropertyResourceBundle} is constructed with the
         * &lt;code&gt;InputStream&lt;/code&gt;.&lt;/li&gt;
         *
         * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is neither &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;
         * nor &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, an
         * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.&lt;/li&gt;
         *
         * &lt;/ul&gt;
         *
         * @param baseName
         *        the base bundle name of the resource bundle, a fully
         *        qualified class name
         * @param locale
         *        the locale for which the resource bundle should be
         *        instantiated
         * @param format
         *        the resource bundle format to be loaded
         * @param loader
         *        the &lt;code&gt;ClassLoader&lt;/code&gt; to use to load the bundle
         * @param reload
         *        the flag to indicate bundle reloading; &lt;code&gt;true&lt;/code&gt;
         *        if reloading an expired resource bundle,
         *        &lt;code&gt;false&lt;/code&gt; otherwise
         * @return the resource bundle instance,
         *        or &lt;code&gt;null&lt;/code&gt; if none could be found.
         * @exception NullPointerException
         *        if &lt;code&gt;bundleName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;,
         *        &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;loader&lt;/code&gt; is
         *        &lt;code&gt;null&lt;/code&gt;, or if &lt;code&gt;null&lt;/code&gt; is returned by
         *        {@link #toBundleName(String, Locale) toBundleName}
         * @exception IllegalArgumentException
         *        if &lt;code&gt;format&lt;/code&gt; is unknown, or if the resource
         *        found for the given parameters contains malformed data.
         * @exception ClassCastException
         *        if the loaded class cannot be cast to &lt;code&gt;ResourceBundle&lt;/code&gt;
         * @exception IllegalAccessException
         *        if the class or its nullary constructor is not
         *        accessible.
         * @exception InstantiationException
         *        if the instantiation of a class fails for some other
         *        reason.
         * @exception ExceptionInInitializerError
         *        if the initialization provoked by this method fails.
         * @exception SecurityException
         *        If a security manager is present and creation of new
         *        instances is denied. See {@link Class#newInstance()}
         *        for details.
         * @exception IOException
         *        if an error occurred when reading resources using
         *        any I/O operations
         */
        public ResourceBundle newBundle(String baseName, Locale locale, String format,
                                        ClassLoader loader, boolean reload)
                    throws IllegalAccessException, InstantiationException, IOException {
<span class="fc" id="L2627">            String bundleName = toBundleName(baseName, locale);</span>
<span class="fc" id="L2628">            ResourceBundle bundle = null;</span>
<span class="fc bfc" id="L2629" title="All 2 branches covered.">            if (format.equals(&quot;java.class&quot;)) {</span>
                try {
                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L2632">                    Class&lt;? extends ResourceBundle&gt; bundleClass</span>
<span class="fc" id="L2633">                        = (Class&lt;? extends ResourceBundle&gt;)loader.loadClass(bundleName);</span>

                    // If the class isn't a ResourceBundle subclass, throw a
                    // ClassCastException.
<span class="fc bfc" id="L2637" title="All 2 branches covered.">                    if (ResourceBundle.class.isAssignableFrom(bundleClass)) {</span>
<span class="fc" id="L2638">                        bundle = bundleClass.newInstance();</span>
                    } else {
<span class="fc" id="L2640">                        throw new ClassCastException(bundleClass.getName()</span>
                                     + &quot; cannot be cast to ResourceBundle&quot;);
                    }
<span class="fc" id="L2643">                } catch (ClassNotFoundException e) {</span>
<span class="fc" id="L2644">                }</span>
<span class="pc bpc" id="L2645" title="1 of 2 branches missed.">            } else if (format.equals(&quot;java.properties&quot;)) {</span>
<span class="fc" id="L2646">                final String resourceName = toResourceName(bundleName, &quot;properties&quot;);</span>
<span class="fc" id="L2647">                final ClassLoader classLoader = loader;</span>
<span class="fc" id="L2648">                final boolean reloadFlag = reload;</span>
<span class="fc" id="L2649">                InputStream stream = null;</span>
                try {
<span class="fc" id="L2651">                    stream = AccessController.doPrivileged(</span>
<span class="fc" id="L2652">                        new PrivilegedExceptionAction&lt;InputStream&gt;() {</span>
                            public InputStream run() throws IOException {
<span class="fc" id="L2654">                                InputStream is = null;</span>
<span class="fc bfc" id="L2655" title="All 2 branches covered.">                                if (reloadFlag) {</span>
<span class="fc" id="L2656">                                    URL url = classLoader.getResource(resourceName);</span>
<span class="pc bpc" id="L2657" title="1 of 2 branches missed.">                                    if (url != null) {</span>
<span class="fc" id="L2658">                                        URLConnection connection = url.openConnection();</span>
<span class="pc bpc" id="L2659" title="1 of 2 branches missed.">                                        if (connection != null) {</span>
                                            // Disable caches to get fresh data for
                                            // reloading.
<span class="fc" id="L2662">                                            connection.setUseCaches(false);</span>
<span class="fc" id="L2663">                                            is = connection.getInputStream();</span>
                                        }
                                    }
<span class="fc" id="L2666">                                } else {</span>
<span class="fc" id="L2667">                                    is = classLoader.getResourceAsStream(resourceName);</span>
                                }
<span class="fc" id="L2669">                                return is;</span>
                            }
                        });
<span class="nc" id="L2672">                } catch (PrivilegedActionException e) {</span>
<span class="nc" id="L2673">                    throw (IOException) e.getException();</span>
<span class="fc" id="L2674">                }</span>
<span class="fc bfc" id="L2675" title="All 2 branches covered.">                if (stream != null) {</span>
                    try {
<span class="fc" id="L2677">                        bundle = new PropertyResourceBundle(stream);</span>
                    } finally {
<span class="pc" id="L2679">                        stream.close();</span>
<span class="fc" id="L2680">                    }</span>
                }
<span class="fc" id="L2682">            } else {</span>
<span class="nc" id="L2683">                throw new IllegalArgumentException(&quot;unknown format: &quot; + format);</span>
            }
<span class="fc" id="L2685">            return bundle;</span>
        }

        /**
         * Returns the time-to-live (TTL) value for resource bundles that
         * are loaded under this
         * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;. Positive time-to-live values
         * specify the number of milliseconds a bundle can remain in the
         * cache without being validated against the source data from which
         * it was constructed. The value 0 indicates that a bundle must be
         * validated each time it is retrieved from the cache. {@link
         * #TTL_DONT_CACHE} specifies that loaded resource bundles are not
         * put in the cache. {@link #TTL_NO_EXPIRATION_CONTROL} specifies
         * that loaded resource bundles are put in the cache with no
         * expiration control.
         *
         * &lt;p&gt;The expiration affects only the bundle loading process by the
         * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method.  That is,
         * if the factory method finds a resource bundle in the cache that
         * has expired, the factory method calls the {@link
         * #needsReload(String, Locale, String, ClassLoader, ResourceBundle,
         * long) needsReload} method to determine whether the resource
         * bundle needs to be reloaded. If &lt;code&gt;needsReload&lt;/code&gt; returns
         * &lt;code&gt;true&lt;/code&gt;, the cached resource bundle instance is removed
         * from the cache. Otherwise, the instance stays in the cache,
         * updated with the new TTL value returned by this method.
         *
         * &lt;p&gt;All cached resource bundles are subject to removal from the
         * cache due to memory constraints of the runtime environment.
         * Returning a large positive value doesn't mean to lock loaded
         * resource bundles in the cache.
         *
         * &lt;p&gt;The default implementation returns {@link #TTL_NO_EXPIRATION_CONTROL}.
         *
         * @param baseName
         *        the base name of the resource bundle for which the
         *        expiration value is specified.
         * @param locale
         *        the locale of the resource bundle for which the
         *        expiration value is specified.
         * @return the time (0 or a positive millisecond offset from the
         *        cached time) to get loaded bundles expired in the cache,
         *        {@link #TTL_NO_EXPIRATION_CONTROL} to disable the
         *        expiration control, or {@link #TTL_DONT_CACHE} to disable
         *        caching.
         * @exception NullPointerException
         *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is
         *        &lt;code&gt;null&lt;/code&gt;
         */
        public long getTimeToLive(String baseName, Locale locale) {
<span class="pc bpc" id="L2735" title="2 of 4 branches missed.">            if (baseName == null || locale == null) {</span>
<span class="nc" id="L2736">                throw new NullPointerException();</span>
            }
<span class="fc" id="L2738">            return TTL_NO_EXPIRATION_CONTROL;</span>
        }

        /**
         * Determines if the expired &lt;code&gt;bundle&lt;/code&gt; in the cache needs
         * to be reloaded based on the loading time given by
         * &lt;code&gt;loadTime&lt;/code&gt; or some other criteria. The method returns
         * &lt;code&gt;true&lt;/code&gt; if reloading is required; &lt;code&gt;false&lt;/code&gt;
         * otherwise. &lt;code&gt;loadTime&lt;/code&gt; is a millisecond offset since
         * the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt;
         * Epoch&lt;/a&gt;.
         *
         * The calling &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method
         * calls this method on the &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
         * instance used for its current invocation, not on the instance
         * used in the invocation that originally loaded the resource
         * bundle.
         *
         * &lt;p&gt;The default implementation compares &lt;code&gt;loadTime&lt;/code&gt; and
         * the last modified time of the source data of the resource
         * bundle. If it's determined that the source data has been modified
         * since &lt;code&gt;loadTime&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is
         * returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. This
         * implementation assumes that the given &lt;code&gt;format&lt;/code&gt; is the
         * same string as its file suffix if it's not one of the default
         * formats, &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; or
         * &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;.
         *
         * @param baseName
         *        the base bundle name of the resource bundle, a
         *        fully qualified class name
         * @param locale
         *        the locale for which the resource bundle
         *        should be instantiated
         * @param format
         *        the resource bundle format to be loaded
         * @param loader
         *        the &lt;code&gt;ClassLoader&lt;/code&gt; to use to load the bundle
         * @param bundle
         *        the resource bundle instance that has been expired
         *        in the cache
         * @param loadTime
         *        the time when &lt;code&gt;bundle&lt;/code&gt; was loaded and put
         *        in the cache
         * @return &lt;code&gt;true&lt;/code&gt; if the expired bundle needs to be
         *        reloaded; &lt;code&gt;false&lt;/code&gt; otherwise.
         * @exception NullPointerException
         *        if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;,
         *        &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;loader&lt;/code&gt;, or
         *        &lt;code&gt;bundle&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
         */
        public boolean needsReload(String baseName, Locale locale,
                                   String format, ClassLoader loader,
                                   ResourceBundle bundle, long loadTime) {
<span class="nc bnc" id="L2792" title="All 2 branches missed.">            if (bundle == null) {</span>
<span class="nc" id="L2793">                throw new NullPointerException();</span>
            }
<span class="nc bnc" id="L2795" title="All 4 branches missed.">            if (format.equals(&quot;java.class&quot;) || format.equals(&quot;java.properties&quot;)) {</span>
<span class="nc" id="L2796">                format = format.substring(5);</span>
            }
<span class="nc" id="L2798">            boolean result = false;</span>
            try {
<span class="nc" id="L2800">                String resourceName = toResourceName(toBundleName(baseName, locale), format);</span>
<span class="nc" id="L2801">                URL url = loader.getResource(resourceName);</span>
<span class="nc bnc" id="L2802" title="All 2 branches missed.">                if (url != null) {</span>
<span class="nc" id="L2803">                    long lastModified = 0;</span>
<span class="nc" id="L2804">                    URLConnection connection = url.openConnection();</span>
<span class="nc bnc" id="L2805" title="All 2 branches missed.">                    if (connection != null) {</span>
                        // disable caches to get the correct data
<span class="nc" id="L2807">                        connection.setUseCaches(false);</span>
<span class="nc bnc" id="L2808" title="All 2 branches missed.">                        if (connection instanceof JarURLConnection) {</span>
<span class="nc" id="L2809">                            JarEntry ent = ((JarURLConnection)connection).getJarEntry();</span>
<span class="nc bnc" id="L2810" title="All 2 branches missed.">                            if (ent != null) {</span>
<span class="nc" id="L2811">                                lastModified = ent.getTime();</span>
<span class="nc bnc" id="L2812" title="All 2 branches missed.">                                if (lastModified == -1) {</span>
<span class="nc" id="L2813">                                    lastModified = 0;</span>
                                }
                            }
<span class="nc" id="L2816">                        } else {</span>
<span class="nc" id="L2817">                            lastModified = connection.getLastModified();</span>
                        }
                    }
<span class="nc bnc" id="L2820" title="All 2 branches missed.">                    result = lastModified &gt;= loadTime;</span>
                }
<span class="nc" id="L2822">            } catch (NullPointerException npe) {</span>
<span class="nc" id="L2823">                throw npe;</span>
<span class="nc" id="L2824">            } catch (Exception e) {</span>
                // ignore other exceptions
<span class="nc" id="L2826">            }</span>
<span class="nc" id="L2827">            return result;</span>
        }

        /**
         * Converts the given &lt;code&gt;baseName&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt;
         * to the bundle name. This method is called from the default
         * implementation of the {@link #newBundle(String, Locale, String,
         * ClassLoader, boolean) newBundle} and {@link #needsReload(String,
         * Locale, String, ClassLoader, ResourceBundle, long) needsReload}
         * methods.
         *
         * &lt;p&gt;This implementation returns the following value:
         * &lt;pre&gt;
         *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
         * &lt;/pre&gt;
         * where &lt;code&gt;language&lt;/code&gt;, &lt;code&gt;script&lt;/code&gt;, &lt;code&gt;country&lt;/code&gt;,
         * and &lt;code&gt;variant&lt;/code&gt; are the language, script, country, and variant
         * values of &lt;code&gt;locale&lt;/code&gt;, respectively. Final component values that
         * are empty Strings are omitted along with the preceding '_'.  When the
         * script is empty, the script value is omitted along with the preceding '_'.
         * If all of the values are empty strings, then &lt;code&gt;baseName&lt;/code&gt;
         * is returned.
         *
         * &lt;p&gt;For example, if &lt;code&gt;baseName&lt;/code&gt; is
         * &lt;code&gt;&quot;baseName&quot;&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt; is
         * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then
         * &lt;code&gt;&quot;baseName_ja_&amp;thinsp;_XX&quot;&lt;/code&gt; is returned. If the given
         * locale is &lt;code&gt;Locale(&quot;en&quot;)&lt;/code&gt;, then
         * &lt;code&gt;&quot;baseName_en&quot;&lt;/code&gt; is returned.
         *
         * &lt;p&gt;Overriding this method allows applications to use different
         * conventions in the organization and packaging of localized
         * resources.
         *
         * @param baseName
         *        the base name of the resource bundle, a fully
         *        qualified class name
         * @param locale
         *        the locale for which a resource bundle should be
         *        loaded
         * @return the bundle name for the resource bundle
         * @exception NullPointerException
         *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt;
         *        is &lt;code&gt;null&lt;/code&gt;
         */
        public String toBundleName(String baseName, Locale locale) {
<span class="fc bfc" id="L2873" title="All 2 branches covered.">            if (locale == Locale.ROOT) {</span>
<span class="fc" id="L2874">                return baseName;</span>
            }

<span class="fc" id="L2877">            String language = locale.getLanguage();</span>
<span class="fc" id="L2878">            String script = locale.getScript();</span>
<span class="fc" id="L2879">            String country = locale.getCountry();</span>
<span class="fc" id="L2880">            String variant = locale.getVariant();</span>

<span class="pc bpc" id="L2882" title="2 of 6 branches missed.">            if (language == &quot;&quot; &amp;&amp; country == &quot;&quot; &amp;&amp; variant == &quot;&quot;) {</span>
<span class="fc" id="L2883">                return baseName;</span>
            }

<span class="fc" id="L2886">            StringBuilder sb = new StringBuilder(baseName);</span>
<span class="fc" id="L2887">            sb.append('_');</span>
<span class="fc bfc" id="L2888" title="All 2 branches covered.">            if (script != &quot;&quot;) {</span>
<span class="pc bpc" id="L2889" title="1 of 2 branches missed.">                if (variant != &quot;&quot;) {</span>
<span class="nc" id="L2890">                    sb.append(language).append('_').append(script).append('_').append(country).append('_').append(variant);</span>
<span class="fc bfc" id="L2891" title="All 2 branches covered.">                } else if (country != &quot;&quot;) {</span>
<span class="fc" id="L2892">                    sb.append(language).append('_').append(script).append('_').append(country);</span>
                } else {
<span class="fc" id="L2894">                    sb.append(language).append('_').append(script);</span>
                }
            } else {
<span class="fc bfc" id="L2897" title="All 2 branches covered.">                if (variant != &quot;&quot;) {</span>
<span class="fc" id="L2898">                    sb.append(language).append('_').append(country).append('_').append(variant);</span>
<span class="fc bfc" id="L2899" title="All 2 branches covered.">                } else if (country != &quot;&quot;) {</span>
<span class="fc" id="L2900">                    sb.append(language).append('_').append(country);</span>
                } else {
<span class="fc" id="L2902">                    sb.append(language);</span>
                }
            }
<span class="fc" id="L2905">            return sb.toString();</span>

        }

        /**
         * Converts the given &lt;code&gt;bundleName&lt;/code&gt; to the form required
         * by the {@link ClassLoader#getResource ClassLoader.getResource}
         * method by replacing all occurrences of &lt;code&gt;'.'&lt;/code&gt; in
         * &lt;code&gt;bundleName&lt;/code&gt; with &lt;code&gt;'/'&lt;/code&gt; and appending a
         * &lt;code&gt;'.'&lt;/code&gt; and the given file &lt;code&gt;suffix&lt;/code&gt;. For
         * example, if &lt;code&gt;bundleName&lt;/code&gt; is
         * &lt;code&gt;&quot;foo.bar.MyResources_ja_JP&quot;&lt;/code&gt; and &lt;code&gt;suffix&lt;/code&gt;
         * is &lt;code&gt;&quot;properties&quot;&lt;/code&gt;, then
         * &lt;code&gt;&quot;foo/bar/MyResources_ja_JP.properties&quot;&lt;/code&gt; is returned.
         *
         * @param bundleName
         *        the bundle name
         * @param suffix
         *        the file type suffix
         * @return the converted resource name
         * @exception NullPointerException
         *         if &lt;code&gt;bundleName&lt;/code&gt; or &lt;code&gt;suffix&lt;/code&gt;
         *         is &lt;code&gt;null&lt;/code&gt;
         */
        public final String toResourceName(String bundleName, String suffix) {
<span class="fc" id="L2930">            StringBuilder sb = new StringBuilder(bundleName.length() + 1 + suffix.length());</span>
<span class="fc" id="L2931">            sb.append(bundleName.replace('.', '/')).append('.').append(suffix);</span>
<span class="fc" id="L2932">            return sb.toString();</span>
        }
    }

    private static class SingleFormatControl extends Control {
<span class="fc" id="L2937">        private static final Control PROPERTIES_ONLY</span>
            = new SingleFormatControl(FORMAT_PROPERTIES);

<span class="fc" id="L2940">        private static final Control CLASS_ONLY</span>
            = new SingleFormatControl(FORMAT_CLASS);

        private final List&lt;String&gt; formats;

<span class="fc" id="L2945">        protected SingleFormatControl(List&lt;String&gt; formats) {</span>
<span class="fc" id="L2946">            this.formats = formats;</span>
<span class="fc" id="L2947">        }</span>

        public List&lt;String&gt; getFormats(String baseName) {
<span class="nc bnc" id="L2950" title="All 2 branches missed.">            if (baseName == null) {</span>
<span class="nc" id="L2951">                throw new NullPointerException();</span>
            }
<span class="nc" id="L2953">            return formats;</span>
        }
    }

    private static final class NoFallbackControl extends SingleFormatControl {
<span class="fc" id="L2958">        private static final Control NO_FALLBACK</span>
            = new NoFallbackControl(FORMAT_DEFAULT);

<span class="fc" id="L2961">        private static final Control PROPERTIES_ONLY_NO_FALLBACK</span>
            = new NoFallbackControl(FORMAT_PROPERTIES);

<span class="fc" id="L2964">        private static final Control CLASS_ONLY_NO_FALLBACK</span>
            = new NoFallbackControl(FORMAT_CLASS);

        protected NoFallbackControl(List&lt;String&gt; formats) {
<span class="fc" id="L2968">            super(formats);</span>
<span class="fc" id="L2969">        }</span>

        public Locale getFallbackLocale(String baseName, Locale locale) {
<span class="nc bnc" id="L2972" title="All 4 branches missed.">            if (baseName == null || locale == null) {</span>
<span class="nc" id="L2973">                throw new NullPointerException();</span>
            }
<span class="nc" id="L2975">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>