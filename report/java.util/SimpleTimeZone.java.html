<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SimpleTimeZone.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">SimpleTimeZone.java</span></div><h1>SimpleTimeZone.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.util;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.IOException;
import sun.util.calendar.CalendarSystem;
import sun.util.calendar.CalendarUtils;
import sun.util.calendar.BaseCalendar;
import sun.util.calendar.Gregorian;

/**
 * &lt;code&gt;SimpleTimeZone&lt;/code&gt; is a concrete subclass of &lt;code&gt;TimeZone&lt;/code&gt;
 * that represents a time zone for use with a Gregorian calendar.
 * The class holds an offset from GMT, called &lt;em&gt;raw offset&lt;/em&gt;, and start
 * and end rules for a daylight saving time schedule.  Since it only holds
 * single values for each, it cannot handle historical changes in the offset
 * from GMT and the daylight saving schedule, except that the {@link
 * #setStartYear setStartYear} method can specify the year when the daylight
 * saving time schedule starts in effect.
 * &lt;p&gt;
 * To construct a &lt;code&gt;SimpleTimeZone&lt;/code&gt; with a daylight saving time
 * schedule, the schedule can be described with a set of rules,
 * &lt;em&gt;start-rule&lt;/em&gt; and &lt;em&gt;end-rule&lt;/em&gt;. A day when daylight saving time
 * starts or ends is specified by a combination of &lt;em&gt;month&lt;/em&gt;,
 * &lt;em&gt;day-of-month&lt;/em&gt;, and &lt;em&gt;day-of-week&lt;/em&gt; values. The &lt;em&gt;month&lt;/em&gt;
 * value is represented by a Calendar {@link Calendar#MONTH MONTH} field
 * value, such as {@link Calendar#MARCH}. The &lt;em&gt;day-of-week&lt;/em&gt; value is
 * represented by a Calendar {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} value,
 * such as {@link Calendar#SUNDAY SUNDAY}. The meanings of value combinations
 * are as follows.
 *
 * &lt;ul&gt;
 * &lt;li&gt;&lt;b&gt;Exact day of month&lt;/b&gt;&lt;br&gt;
 * To specify an exact day of month, set the &lt;em&gt;month&lt;/em&gt; and
 * &lt;em&gt;day-of-month&lt;/em&gt; to an exact value, and &lt;em&gt;day-of-week&lt;/em&gt; to zero. For
 * example, to specify March 1, set the &lt;em&gt;month&lt;/em&gt; to {@link Calendar#MARCH
 * MARCH}, &lt;em&gt;day-of-month&lt;/em&gt; to 1, and &lt;em&gt;day-of-week&lt;/em&gt; to 0.&lt;/li&gt;
 *
 * &lt;li&gt;&lt;b&gt;Day of week on or after day of month&lt;/b&gt;&lt;br&gt;
 * To specify a day of week on or after an exact day of month, set the
 * &lt;em&gt;month&lt;/em&gt; to an exact month value, &lt;em&gt;day-of-month&lt;/em&gt; to the day on
 * or after which the rule is applied, and &lt;em&gt;day-of-week&lt;/em&gt; to a negative {@link
 * Calendar#DAY_OF_WEEK DAY_OF_WEEK} field value. For example, to specify the
 * second Sunday of April, set &lt;em&gt;month&lt;/em&gt; to {@link Calendar#APRIL APRIL},
 * &lt;em&gt;day-of-month&lt;/em&gt; to 8, and &lt;em&gt;day-of-week&lt;/em&gt; to &lt;code&gt;-&lt;/code&gt;{@link
 * Calendar#SUNDAY SUNDAY}.&lt;/li&gt;
 *
 * &lt;li&gt;&lt;b&gt;Day of week on or before day of month&lt;/b&gt;&lt;br&gt;
 * To specify a day of the week on or before an exact day of the month, set
 * &lt;em&gt;day-of-month&lt;/em&gt; and &lt;em&gt;day-of-week&lt;/em&gt; to a negative value. For
 * example, to specify the last Wednesday on or before the 21st of March, set
 * &lt;em&gt;month&lt;/em&gt; to {@link Calendar#MARCH MARCH}, &lt;em&gt;day-of-month&lt;/em&gt; is -21
 * and &lt;em&gt;day-of-week&lt;/em&gt; is &lt;code&gt;-&lt;/code&gt;{@link Calendar#WEDNESDAY WEDNESDAY}. &lt;/li&gt;
 *
 * &lt;li&gt;&lt;b&gt;Last day-of-week of month&lt;/b&gt;&lt;br&gt;
 * To specify, the last day-of-week of the month, set &lt;em&gt;day-of-week&lt;/em&gt; to a
 * {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} value and &lt;em&gt;day-of-month&lt;/em&gt; to
 * -1. For example, to specify the last Sunday of October, set &lt;em&gt;month&lt;/em&gt;
 * to {@link Calendar#OCTOBER OCTOBER}, &lt;em&gt;day-of-week&lt;/em&gt; to {@link
 * Calendar#SUNDAY SUNDAY} and &lt;em&gt;day-of-month&lt;/em&gt; to -1.  &lt;/li&gt;
 *
 * &lt;/ul&gt;
 * The time of the day at which daylight saving time starts or ends is
 * specified by a millisecond value within the day. There are three kinds of
 * &lt;em&gt;mode&lt;/em&gt;s to specify the time: {@link #WALL_TIME}, {@link
 * #STANDARD_TIME} and {@link #UTC_TIME}. For example, if daylight
 * saving time ends
 * at 2:00 am in the wall clock time, it can be specified by 7200000
 * milliseconds in the {@link #WALL_TIME} mode. In this case, the wall clock time
 * for an &lt;em&gt;end-rule&lt;/em&gt; means the same thing as the daylight time.
 * &lt;p&gt;
 * The following are examples of parameters for constructing time zone objects.
 * &lt;pre&gt;&lt;code&gt;
 *      // Base GMT offset: -8:00
 *      // DST starts:      at 2:00am in standard time
 *      //                  on the first Sunday in April
 *      // DST ends:        at 2:00am in daylight time
 *      //                  on the last Sunday in October
 *      // Save:            1 hour
 *      SimpleTimeZone(-28800000,
 *                     &quot;America/Los_Angeles&quot;,
 *                     Calendar.APRIL, 1, -Calendar.SUNDAY,
 *                     7200000,
 *                     Calendar.OCTOBER, -1, Calendar.SUNDAY,
 *                     7200000,
 *                     3600000)
 *
 *      // Base GMT offset: +1:00
 *      // DST starts:      at 1:00am in UTC time
 *      //                  on the last Sunday in March
 *      // DST ends:        at 1:00am in UTC time
 *      //                  on the last Sunday in October
 *      // Save:            1 hour
 *      SimpleTimeZone(3600000,
 *                     &quot;Europe/Paris&quot;,
 *                     Calendar.MARCH, -1, Calendar.SUNDAY,
 *                     3600000, SimpleTimeZone.UTC_TIME,
 *                     Calendar.OCTOBER, -1, Calendar.SUNDAY,
 *                     3600000, SimpleTimeZone.UTC_TIME,
 *                     3600000)
 * &lt;/code&gt;&lt;/pre&gt;
 * These parameter rules are also applicable to the set rule methods, such as
 * &lt;code&gt;setStartRule&lt;/code&gt;.
 *
 * @since 1.1
 * @see      Calendar
 * @see      GregorianCalendar
 * @see      TimeZone
 * @author   David Goldsmith, Mark Davis, Chen-Lieh Huang, Alan Liu
 */

public class SimpleTimeZone extends TimeZone {
    /**
     * Constructs a SimpleTimeZone with the given base time zone offset from GMT
     * and time zone ID with no daylight saving time schedule.
     *
     * @param rawOffset  The base time zone offset in milliseconds to GMT.
     * @param ID         The time zone name that is given to this instance.
     */
    public SimpleTimeZone(int rawOffset, String ID)
<span class="fc" id="L159">    {</span>
<span class="fc" id="L160">        this.rawOffset = rawOffset;</span>
<span class="fc" id="L161">        setID (ID);</span>
<span class="fc" id="L162">        dstSavings = millisPerHour; // In case user sets rules later</span>
<span class="fc" id="L163">    }</span>

    /**
     * Constructs a SimpleTimeZone with the given base time zone offset from
     * GMT, time zone ID, and rules for starting and ending the daylight
     * time.
     * Both &lt;code&gt;startTime&lt;/code&gt; and &lt;code&gt;endTime&lt;/code&gt; are specified to be
     * represented in the wall clock time. The amount of daylight saving is
     * assumed to be 3600000 milliseconds (i.e., one hour). This constructor is
     * equivalent to:
     * &lt;pre&gt;&lt;code&gt;
     *     SimpleTimeZone(rawOffset,
     *                    ID,
     *                    startMonth,
     *                    startDay,
     *                    startDayOfWeek,
     *                    startTime,
     *                    SimpleTimeZone.{@link #WALL_TIME},
     *                    endMonth,
     *                    endDay,
     *                    endDayOfWeek,
     *                    endTime,
     *                    SimpleTimeZone.{@link #WALL_TIME},
     *                    3600000)
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param rawOffset       The given base time zone offset from GMT.
     * @param ID              The time zone ID which is given to this object.
     * @param startMonth      The daylight saving time starting month. Month is
     *                        a {@link Calendar#MONTH MONTH} field value (0-based. e.g., 0
     *                        for January).
     * @param startDay        The day of the month on which the daylight saving time starts.
     *                        See the class description for the special cases of this parameter.
     * @param startDayOfWeek  The daylight saving time starting day-of-week.
     *                        See the class description for the special cases of this parameter.
     * @param startTime       The daylight saving time starting time in local wall clock
     *                        time (in milliseconds within the day), which is local
     *                        standard time in this case.
     * @param endMonth        The daylight saving time ending month. Month is
     *                        a {@link Calendar#MONTH MONTH} field
     *                        value (0-based. e.g., 9 for October).
     * @param endDay          The day of the month on which the daylight saving time ends.
     *                        See the class description for the special cases of this parameter.
     * @param endDayOfWeek    The daylight saving time ending day-of-week.
     *                        See the class description for the special cases of this parameter.
     * @param endTime         The daylight saving ending time in local wall clock time,
     *                        (in milliseconds within the day) which is local daylight
     *                        time in this case.
     * @exception IllegalArgumentException if the month, day, dayOfWeek, or time
     * parameters are out of range for the start or end rule
     */
    public SimpleTimeZone(int rawOffset, String ID,
                          int startMonth, int startDay, int startDayOfWeek, int startTime,
                          int endMonth, int endDay, int endDayOfWeek, int endTime)
    {
<span class="nc" id="L218">        this(rawOffset, ID,</span>
             startMonth, startDay, startDayOfWeek, startTime, WALL_TIME,
             endMonth, endDay, endDayOfWeek, endTime, WALL_TIME,
             millisPerHour);
<span class="nc" id="L222">    }</span>

    /**
     * Constructs a SimpleTimeZone with the given base time zone offset from
     * GMT, time zone ID, and rules for starting and ending the daylight
     * time.
     * Both &lt;code&gt;startTime&lt;/code&gt; and &lt;code&gt;endTime&lt;/code&gt; are assumed to be
     * represented in the wall clock time. This constructor is equivalent to:
     * &lt;pre&gt;&lt;code&gt;
     *     SimpleTimeZone(rawOffset,
     *                    ID,
     *                    startMonth,
     *                    startDay,
     *                    startDayOfWeek,
     *                    startTime,
     *                    SimpleTimeZone.{@link #WALL_TIME},
     *                    endMonth,
     *                    endDay,
     *                    endDayOfWeek,
     *                    endTime,
     *                    SimpleTimeZone.{@link #WALL_TIME},
     *                    dstSavings)
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param rawOffset       The given base time zone offset from GMT.
     * @param ID              The time zone ID which is given to this object.
     * @param startMonth      The daylight saving time starting month. Month is
     *                        a {@link Calendar#MONTH MONTH} field
     *                        value (0-based. e.g., 0 for January).
     * @param startDay        The day of the month on which the daylight saving time starts.
     *                        See the class description for the special cases of this parameter.
     * @param startDayOfWeek  The daylight saving time starting day-of-week.
     *                        See the class description for the special cases of this parameter.
     * @param startTime       The daylight saving time starting time in local wall clock
     *                        time, which is local standard time in this case.
     * @param endMonth        The daylight saving time ending month. Month is
     *                        a {@link Calendar#MONTH MONTH} field
     *                        value (0-based. e.g., 9 for October).
     * @param endDay          The day of the month on which the daylight saving time ends.
     *                        See the class description for the special cases of this parameter.
     * @param endDayOfWeek    The daylight saving time ending day-of-week.
     *                        See the class description for the special cases of this parameter.
     * @param endTime         The daylight saving ending time in local wall clock time,
     *                        which is local daylight time in this case.
     * @param dstSavings      The amount of time in milliseconds saved during
     *                        daylight saving time.
     * @exception IllegalArgumentException if the month, day, dayOfWeek, or time
     * parameters are out of range for the start or end rule
     * @since 1.2
     */
    public SimpleTimeZone(int rawOffset, String ID,
                          int startMonth, int startDay, int startDayOfWeek, int startTime,
                          int endMonth, int endDay, int endDayOfWeek, int endTime,
                          int dstSavings)
    {
<span class="fc" id="L277">        this(rawOffset, ID,</span>
             startMonth, startDay, startDayOfWeek, startTime, WALL_TIME,
             endMonth, endDay, endDayOfWeek, endTime, WALL_TIME,
             dstSavings);
<span class="fc" id="L281">    }</span>

    /**
     * Constructs a SimpleTimeZone with the given base time zone offset from
     * GMT, time zone ID, and rules for starting and ending the daylight
     * time.
     * This constructor takes the full set of the start and end rules
     * parameters, including modes of &lt;code&gt;startTime&lt;/code&gt; and
     * &lt;code&gt;endTime&lt;/code&gt;. The mode specifies either {@link #WALL_TIME wall
     * time} or {@link #STANDARD_TIME standard time} or {@link #UTC_TIME UTC
     * time}.
     *
     * @param rawOffset       The given base time zone offset from GMT.
     * @param ID              The time zone ID which is given to this object.
     * @param startMonth      The daylight saving time starting month. Month is
     *                        a {@link Calendar#MONTH MONTH} field
     *                        value (0-based. e.g., 0 for January).
     * @param startDay        The day of the month on which the daylight saving time starts.
     *                        See the class description for the special cases of this parameter.
     * @param startDayOfWeek  The daylight saving time starting day-of-week.
     *                        See the class description for the special cases of this parameter.
     * @param startTime       The daylight saving time starting time in the time mode
     *                        specified by &lt;code&gt;startTimeMode&lt;/code&gt;.
     * @param startTimeMode   The mode of the start time specified by startTime.
     * @param endMonth        The daylight saving time ending month. Month is
     *                        a {@link Calendar#MONTH MONTH} field
     *                        value (0-based. e.g., 9 for October).
     * @param endDay          The day of the month on which the daylight saving time ends.
     *                        See the class description for the special cases of this parameter.
     * @param endDayOfWeek    The daylight saving time ending day-of-week.
     *                        See the class description for the special cases of this parameter.
     * @param endTime         The daylight saving ending time in time time mode
     *                        specified by &lt;code&gt;endTimeMode&lt;/code&gt;.
     * @param endTimeMode     The mode of the end time specified by endTime
     * @param dstSavings      The amount of time in milliseconds saved during
     *                        daylight saving time.
     *
     * @exception IllegalArgumentException if the month, day, dayOfWeek, time more, or
     * time parameters are out of range for the start or end rule, or if a time mode
     * value is invalid.
     *
     * @see #WALL_TIME
     * @see #STANDARD_TIME
     * @see #UTC_TIME
     *
     * @since 1.4
     */
    public SimpleTimeZone(int rawOffset, String ID,
                          int startMonth, int startDay, int startDayOfWeek,
                          int startTime, int startTimeMode,
                          int endMonth, int endDay, int endDayOfWeek,
                          int endTime, int endTimeMode,
<span class="fc" id="L333">                          int dstSavings) {</span>

<span class="fc" id="L335">        setID(ID);</span>
<span class="fc" id="L336">        this.rawOffset      = rawOffset;</span>
<span class="fc" id="L337">        this.startMonth     = startMonth;</span>
<span class="fc" id="L338">        this.startDay       = startDay;</span>
<span class="fc" id="L339">        this.startDayOfWeek = startDayOfWeek;</span>
<span class="fc" id="L340">        this.startTime      = startTime;</span>
<span class="fc" id="L341">        this.startTimeMode  = startTimeMode;</span>
<span class="fc" id="L342">        this.endMonth       = endMonth;</span>
<span class="fc" id="L343">        this.endDay         = endDay;</span>
<span class="fc" id="L344">        this.endDayOfWeek   = endDayOfWeek;</span>
<span class="fc" id="L345">        this.endTime        = endTime;</span>
<span class="fc" id="L346">        this.endTimeMode    = endTimeMode;</span>
<span class="fc" id="L347">        this.dstSavings     = dstSavings;</span>

        // this.useDaylight is set by decodeRules
<span class="fc" id="L350">        decodeRules();</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (dstSavings &lt;= 0) {</span>
<span class="nc" id="L352">            throw new IllegalArgumentException(&quot;Illegal daylight saving value: &quot; + dstSavings);</span>
        }
<span class="fc" id="L354">    }</span>

    /**
     * Sets the daylight saving time starting year.
     *
     * @param year  The daylight saving starting year.
     */
    public void setStartYear(int year)
    {
<span class="nc" id="L363">        startYear = year;</span>
<span class="nc" id="L364">        invalidateCache();</span>
<span class="nc" id="L365">    }</span>

    /**
     * Sets the daylight saving time start rule. For example, if daylight saving
     * time starts on the first Sunday in April at 2 am in local wall clock
     * time, you can set the start rule by calling:
     * &lt;pre&gt;&lt;code&gt;setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2*60*60*1000);&lt;/code&gt;&lt;/pre&gt;
     *
     * @param startMonth      The daylight saving time starting month. Month is
     *                        a {@link Calendar#MONTH MONTH} field
     *                        value (0-based. e.g., 0 for January).
     * @param startDay        The day of the month on which the daylight saving time starts.
     *                        See the class description for the special cases of this parameter.
     * @param startDayOfWeek  The daylight saving time starting day-of-week.
     *                        See the class description for the special cases of this parameter.
     * @param startTime       The daylight saving time starting time in local wall clock
     *                        time, which is local standard time in this case.
     * @exception IllegalArgumentException if the &lt;code&gt;startMonth&lt;/code&gt;, &lt;code&gt;startDay&lt;/code&gt;,
     * &lt;code&gt;startDayOfWeek&lt;/code&gt;, or &lt;code&gt;startTime&lt;/code&gt; parameters are out of range
     */
    public void setStartRule(int startMonth, int startDay, int startDayOfWeek, int startTime)
    {
<span class="nc" id="L387">        this.startMonth = startMonth;</span>
<span class="nc" id="L388">        this.startDay = startDay;</span>
<span class="nc" id="L389">        this.startDayOfWeek = startDayOfWeek;</span>
<span class="nc" id="L390">        this.startTime = startTime;</span>
<span class="nc" id="L391">        startTimeMode = WALL_TIME;</span>
<span class="nc" id="L392">        decodeStartRule();</span>
<span class="nc" id="L393">        invalidateCache();</span>
<span class="nc" id="L394">    }</span>

    /**
     * Sets the daylight saving time start rule to a fixed date within a month.
     * This method is equivalent to:
     * &lt;pre&gt;&lt;code&gt;setStartRule(startMonth, startDay, 0, startTime)&lt;/code&gt;&lt;/pre&gt;
     *
     * @param startMonth      The daylight saving time starting month. Month is
     *                        a {@link Calendar#MONTH MONTH} field
     *                        value (0-based. e.g., 0 for January).
     * @param startDay        The day of the month on which the daylight saving time starts.
     * @param startTime       The daylight saving time starting time in local wall clock
     *                        time, which is local standard time in this case.
     *                        See the class description for the special cases of this parameter.
     * @exception IllegalArgumentException if the &lt;code&gt;startMonth&lt;/code&gt;,
     * &lt;code&gt;startDayOfMonth&lt;/code&gt;, or &lt;code&gt;startTime&lt;/code&gt; parameters are out of range
     * @since 1.2
     */
    public void setStartRule(int startMonth, int startDay, int startTime) {
<span class="nc" id="L413">        setStartRule(startMonth, startDay, 0, startTime);</span>
<span class="nc" id="L414">    }</span>

    /**
     * Sets the daylight saving time start rule to a weekday before or after the given date within
     * a month, e.g., the first Monday on or after the 8th.
     *
     * @param startMonth      The daylight saving time starting month. Month is
     *                        a {@link Calendar#MONTH MONTH} field
     *                        value (0-based. e.g., 0 for January).
     * @param startDay        The day of the month on which the daylight saving time starts.
     * @param startDayOfWeek  The daylight saving time starting day-of-week.
     * @param startTime       The daylight saving time starting time in local wall clock
     *                        time, which is local standard time in this case.
     * @param after           If true, this rule selects the first &lt;code&gt;dayOfWeek&lt;/code&gt; on or
     *                        &lt;em&gt;after&lt;/em&gt; &lt;code&gt;dayOfMonth&lt;/code&gt;.  If false, this rule
     *                        selects the last &lt;code&gt;dayOfWeek&lt;/code&gt; on or &lt;em&gt;before&lt;/em&gt;
     *                        &lt;code&gt;dayOfMonth&lt;/code&gt;.
     * @exception IllegalArgumentException if the &lt;code&gt;startMonth&lt;/code&gt;, &lt;code&gt;startDay&lt;/code&gt;,
     * &lt;code&gt;startDayOfWeek&lt;/code&gt;, or &lt;code&gt;startTime&lt;/code&gt; parameters are out of range
     * @since 1.2
     */
    public void setStartRule(int startMonth, int startDay, int startDayOfWeek,
                             int startTime, boolean after)
    {
        // TODO: this method doesn't check the initial values of dayOfMonth or dayOfWeek.
<span class="nc bnc" id="L439" title="All 2 branches missed.">        if (after) {</span>
<span class="nc" id="L440">            setStartRule(startMonth, startDay, -startDayOfWeek, startTime);</span>
        } else {
<span class="nc" id="L442">            setStartRule(startMonth, -startDay, -startDayOfWeek, startTime);</span>
        }
<span class="nc" id="L444">    }</span>

    /**
     * Sets the daylight saving time end rule. For example, if daylight saving time
     * ends on the last Sunday in October at 2 am in wall clock time,
     * you can set the end rule by calling:
     * &lt;code&gt;setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2*60*60*1000);&lt;/code&gt;
     *
     * @param endMonth        The daylight saving time ending month. Month is
     *                        a {@link Calendar#MONTH MONTH} field
     *                        value (0-based. e.g., 9 for October).
     * @param endDay          The day of the month on which the daylight saving time ends.
     *                        See the class description for the special cases of this parameter.
     * @param endDayOfWeek    The daylight saving time ending day-of-week.
     *                        See the class description for the special cases of this parameter.
     * @param endTime         The daylight saving ending time in local wall clock time,
     *                        (in milliseconds within the day) which is local daylight
     *                        time in this case.
     * @exception IllegalArgumentException if the &lt;code&gt;endMonth&lt;/code&gt;, &lt;code&gt;endDay&lt;/code&gt;,
     * &lt;code&gt;endDayOfWeek&lt;/code&gt;, or &lt;code&gt;endTime&lt;/code&gt; parameters are out of range
     */
    public void setEndRule(int endMonth, int endDay, int endDayOfWeek,
                           int endTime)
    {
<span class="nc" id="L468">        this.endMonth = endMonth;</span>
<span class="nc" id="L469">        this.endDay = endDay;</span>
<span class="nc" id="L470">        this.endDayOfWeek = endDayOfWeek;</span>
<span class="nc" id="L471">        this.endTime = endTime;</span>
<span class="nc" id="L472">        this.endTimeMode = WALL_TIME;</span>
<span class="nc" id="L473">        decodeEndRule();</span>
<span class="nc" id="L474">        invalidateCache();</span>
<span class="nc" id="L475">    }</span>

    /**
     * Sets the daylight saving time end rule to a fixed date within a month.
     * This method is equivalent to:
     * &lt;pre&gt;&lt;code&gt;setEndRule(endMonth, endDay, 0, endTime)&lt;/code&gt;&lt;/pre&gt;
     *
     * @param endMonth        The daylight saving time ending month. Month is
     *                        a {@link Calendar#MONTH MONTH} field
     *                        value (0-based. e.g., 9 for October).
     * @param endDay          The day of the month on which the daylight saving time ends.
     * @param endTime         The daylight saving ending time in local wall clock time,
     *                        (in milliseconds within the day) which is local daylight
     *                        time in this case.
     * @exception IllegalArgumentException the &lt;code&gt;endMonth&lt;/code&gt;, &lt;code&gt;endDay&lt;/code&gt;,
     * or &lt;code&gt;endTime&lt;/code&gt; parameters are out of range
     * @since 1.2
     */
    public void setEndRule(int endMonth, int endDay, int endTime)
    {
<span class="nc" id="L495">        setEndRule(endMonth, endDay, 0, endTime);</span>
<span class="nc" id="L496">    }</span>

    /**
     * Sets the daylight saving time end rule to a weekday before or after the given date within
     * a month, e.g., the first Monday on or after the 8th.
     *
     * @param endMonth        The daylight saving time ending month. Month is
     *                        a {@link Calendar#MONTH MONTH} field
     *                        value (0-based. e.g., 9 for October).
     * @param endDay          The day of the month on which the daylight saving time ends.
     * @param endDayOfWeek    The daylight saving time ending day-of-week.
     * @param endTime         The daylight saving ending time in local wall clock time,
     *                        (in milliseconds within the day) which is local daylight
     *                        time in this case.
     * @param after           If true, this rule selects the first &lt;code&gt;endDayOfWeek&lt;/code&gt; on
     *                        or &lt;em&gt;after&lt;/em&gt; &lt;code&gt;endDay&lt;/code&gt;.  If false, this rule
     *                        selects the last &lt;code&gt;endDayOfWeek&lt;/code&gt; on or before
     *                        &lt;code&gt;endDay&lt;/code&gt; of the month.
     * @exception IllegalArgumentException the &lt;code&gt;endMonth&lt;/code&gt;, &lt;code&gt;endDay&lt;/code&gt;,
     * &lt;code&gt;endDayOfWeek&lt;/code&gt;, or &lt;code&gt;endTime&lt;/code&gt; parameters are out of range
     * @since 1.2
     */
    public void setEndRule(int endMonth, int endDay, int endDayOfWeek, int endTime, boolean after)
    {
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (after) {</span>
<span class="nc" id="L521">            setEndRule(endMonth, endDay, -endDayOfWeek, endTime);</span>
        } else {
<span class="nc" id="L523">            setEndRule(endMonth, -endDay, -endDayOfWeek, endTime);</span>
        }
<span class="nc" id="L525">    }</span>

    /**
     * Returns the offset of this time zone from UTC at the given
     * time. If daylight saving time is in effect at the given time,
     * the offset value is adjusted with the amount of daylight
     * saving.
     *
     * @param date the time at which the time zone offset is found
     * @return the amount of time in milliseconds to add to UTC to get
     * local time.
     * @since 1.4
     */
    public int getOffset(long date) {
<span class="fc" id="L539">        return getOffsets(date, null);</span>
    }

    /**
     * @see TimeZone#getOffsets
     */
    int getOffsets(long date, int[] offsets) {
<span class="fc" id="L546">        int offset = rawOffset;</span>

      computeOffset:
<span class="fc bfc" id="L549" title="All 2 branches covered.">        if (useDaylight) {</span>
<span class="fc" id="L550">            synchronized (this) {</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">                if (cacheStart != 0) {</span>
<span class="pc bpc" id="L552" title="1 of 4 branches missed.">                    if (date &gt;= cacheStart &amp;&amp; date &lt; cacheEnd) {</span>
<span class="fc" id="L553">                        offset += dstSavings;</span>
<span class="fc" id="L554">                        break computeOffset;</span>
                    }
                }
<span class="pc" id="L557">            }</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">            BaseCalendar cal = date &gt;= GregorianCalendar.DEFAULT_GREGORIAN_CUTOVER ?</span>
<span class="pc" id="L559">                gcal : (BaseCalendar) CalendarSystem.forName(&quot;julian&quot;);</span>
<span class="fc" id="L560">            BaseCalendar.Date cdate = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
            // Get the year in local time
<span class="fc" id="L562">            cal.getCalendarDate(date + rawOffset, cdate);</span>
<span class="fc" id="L563">            int year = cdate.getNormalizedYear();</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            if (year &gt;= startYear) {</span>
                // Clear time elements for the transition calculations
<span class="fc" id="L566">                cdate.setTimeOfDay(0, 0, 0, 0);</span>
<span class="fc" id="L567">                offset = getOffset(cal, cdate, year, date);</span>
            }
        }

<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (offsets != null) {</span>
<span class="fc" id="L572">            offsets[0] = rawOffset;</span>
<span class="fc" id="L573">            offsets[1] = offset - rawOffset;</span>
        }
<span class="fc" id="L575">        return offset;</span>
    }

   /**
     * Returns the difference in milliseconds between local time and
     * UTC, taking into account both the raw offset and the effect of
     * daylight saving, for the specified date and time.  This method
     * assumes that the start and end month are distinct.  It also
     * uses a default {@link GregorianCalendar} object as its
     * underlying calendar, such as for determining leap years.  Do
     * not use the result of this method with a calendar other than a
     * default &lt;code&gt;GregorianCalendar&lt;/code&gt;.
     *
     * &lt;p&gt;&lt;em&gt;Note:  In general, clients should use
     * &lt;code&gt;Calendar.get(ZONE_OFFSET) + Calendar.get(DST_OFFSET)&lt;/code&gt;
     * instead of calling this method.&lt;/em&gt;
     *
     * @param era       The era of the given date.
     * @param year      The year in the given date.
     * @param month     The month in the given date. Month is 0-based. e.g.,
     *                  0 for January.
     * @param day       The day-in-month of the given date.
     * @param dayOfWeek The day-of-week of the given date.
     * @param millis    The milliseconds in day in &lt;em&gt;standard&lt;/em&gt; local time.
     * @return          The milliseconds to add to UTC to get local time.
     * @exception       IllegalArgumentException the &lt;code&gt;era&lt;/code&gt;,
     *                  &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;dayOfWeek&lt;/code&gt;,
     *                  or &lt;code&gt;millis&lt;/code&gt; parameters are out of range
     */
    public int getOffset(int era, int year, int month, int day, int dayOfWeek,
                         int millis)
    {
<span class="nc bnc" id="L607" title="All 4 branches missed.">        if (era != GregorianCalendar.AD &amp;&amp; era != GregorianCalendar.BC) {</span>
<span class="nc" id="L608">            throw new IllegalArgumentException(&quot;Illegal era &quot; + era);</span>
        }

<span class="nc" id="L611">        int y = year;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (era == GregorianCalendar.BC) {</span>
            // adjust y with the GregorianCalendar-style year numbering.
<span class="nc" id="L614">            y = 1 - y;</span>
        }

        // If the year isn't representable with the 64-bit long
        // integer in milliseconds, convert the year to an
        // equivalent year. This is required to pass some JCK test cases
        // which are actually useless though because the specified years
        // can't be supported by the Java time system.
<span class="nc bnc" id="L622" title="All 2 branches missed.">        if (y &gt;= 292278994) {</span>
<span class="nc" id="L623">            y = 2800 + y % 2800;</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">        } else if (y &lt;= -292269054) {</span>
            // y %= 28 also produces an equivalent year, but positive
            // year numbers would be convenient to use the UNIX cal
            // command.
<span class="nc" id="L628">            y = (int) CalendarUtils.mod((long) y, 28);</span>
        }

        // convert year to its 1-based month value
<span class="nc" id="L632">        int m = month + 1;</span>

        // First, calculate time as a Gregorian date.
<span class="nc" id="L635">        BaseCalendar cal = gcal;</span>
<span class="nc" id="L636">        BaseCalendar.Date cdate = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="nc" id="L637">        cdate.setDate(y, m, day);</span>
<span class="nc" id="L638">        long time = cal.getTime(cdate); // normalize cdate</span>
<span class="nc" id="L639">        time += millis - rawOffset; // UTC time</span>

        // If the time value represents a time before the default
        // Gregorian cutover, recalculate time using the Julian
        // calendar system. For the Julian calendar system, the
        // normalized year numbering is ..., -2 (BCE 2), -1 (BCE 1),
        // 1, 2 ... which is different from the GregorianCalendar
        // style year numbering (..., -1, 0 (BCE 1), 1, 2, ...).
<span class="nc bnc" id="L647" title="All 2 branches missed.">        if (time &lt; GregorianCalendar.DEFAULT_GREGORIAN_CUTOVER) {</span>
<span class="nc" id="L648">            cal = (BaseCalendar) CalendarSystem.forName(&quot;julian&quot;);</span>
<span class="nc" id="L649">            cdate = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);</span>
<span class="nc" id="L650">            cdate.setNormalizedDate(y, m, day);</span>
<span class="nc" id="L651">            time = cal.getTime(cdate) + millis - rawOffset;</span>
        }

<span class="nc bnc" id="L654" title="All 2 branches missed.">        if ((cdate.getNormalizedYear() != y)</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">            || (cdate.getMonth() != m)</span>
<span class="nc bnc" id="L656" title="All 10 branches missed.">            || (cdate.getDayOfMonth() != day)</span>
            // The validation should be cdate.getDayOfWeek() ==
            // dayOfWeek. However, we don't check dayOfWeek for
            // compatibility.
            || (dayOfWeek &lt; Calendar.SUNDAY || dayOfWeek &gt; Calendar.SATURDAY)
            || (millis &lt; 0 || millis &gt;= (24*60*60*1000))) {
<span class="nc" id="L662">            throw new IllegalArgumentException();</span>
        }

<span class="nc bnc" id="L665" title="All 6 branches missed.">        if (!useDaylight || year &lt; startYear || era != GregorianCalendar.CE) {</span>
<span class="nc" id="L666">            return rawOffset;</span>
        }

<span class="nc" id="L669">        return getOffset(cal, cdate, y, time);</span>
    }

    private int getOffset(BaseCalendar cal, BaseCalendar.Date cdate, int year, long time) {
<span class="fc" id="L673">        synchronized (this) {</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">            if (cacheStart != 0) {</span>
<span class="pc bpc" id="L675" title="2 of 4 branches missed.">                if (time &gt;= cacheStart &amp;&amp; time &lt; cacheEnd) {</span>
<span class="nc" id="L676">                    return rawOffset + dstSavings;</span>
                }
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">                if (year == cacheYear) {</span>
<span class="fc" id="L679">                    return rawOffset;</span>
                }
            }
<span class="pc" id="L682">        }</span>

<span class="fc" id="L684">        long start = getStart(cal, cdate, year);</span>
<span class="fc" id="L685">        long end = getEnd(cal, cdate, year);</span>
<span class="fc" id="L686">        int offset = rawOffset;</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">        if (start &lt;= end) {</span>
<span class="pc bpc" id="L688" title="1 of 4 branches missed.">            if (time &gt;= start &amp;&amp; time &lt; end) {</span>
<span class="fc" id="L689">                offset += dstSavings;</span>
            }
<span class="fc" id="L691">            synchronized (this) {</span>
<span class="fc" id="L692">                cacheYear = year;</span>
<span class="fc" id="L693">                cacheStart = start;</span>
<span class="fc" id="L694">                cacheEnd = end;</span>
<span class="pc" id="L695">            }</span>
        } else {
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">            if (time &lt; end) {</span>
                // TODO: support Gregorian cutover. The previous year
                // may be in the other calendar system.
<span class="nc" id="L700">                start = getStart(cal, cdate, year - 1);</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">                if (time &gt;= start) {</span>
<span class="nc" id="L702">                    offset += dstSavings;</span>
                }
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">            } else if (time &gt;= start) {</span>
                // TODO: support Gregorian cutover. The next year
                // may be in the other calendar system.
<span class="fc" id="L707">                end = getEnd(cal, cdate, year + 1);</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">                if (time &lt; end) {</span>
<span class="fc" id="L709">                    offset += dstSavings;</span>
                }
            }
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">            if (start &lt;= end) {</span>
<span class="fc" id="L713">                synchronized (this) {</span>
                    // The start and end transitions are in multiple years.
<span class="fc" id="L715">                    cacheYear = (long) startYear - 1;</span>
<span class="fc" id="L716">                    cacheStart = start;</span>
<span class="fc" id="L717">                    cacheEnd = end;</span>
<span class="pc" id="L718">                }</span>
            }
        }
<span class="fc" id="L721">        return offset;</span>
    }

    private long getStart(BaseCalendar cal, BaseCalendar.Date cdate, int year) {
<span class="fc" id="L725">        int time = startTime;</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">        if (startTimeMode != UTC_TIME) {</span>
<span class="fc" id="L727">            time -= rawOffset;</span>
        }
<span class="fc" id="L729">        return getTransition(cal, cdate, startMode, year, startMonth, startDay,</span>
                             startDayOfWeek, time);
    }

    private long getEnd(BaseCalendar cal, BaseCalendar.Date cdate, int year) {
<span class="fc" id="L734">        int time = endTime;</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">        if (endTimeMode != UTC_TIME) {</span>
<span class="fc" id="L736">            time -= rawOffset;</span>
        }
<span class="fc bfc" id="L738" title="All 2 branches covered.">        if (endTimeMode == WALL_TIME) {</span>
<span class="fc" id="L739">            time -= dstSavings;</span>
        }
<span class="fc" id="L741">        return getTransition(cal, cdate, endMode, year, endMonth, endDay,</span>
                                        endDayOfWeek, time);
    }

    private long getTransition(BaseCalendar cal, BaseCalendar.Date cdate,
                               int mode, int year, int month, int dayOfMonth,
                               int dayOfWeek, int timeOfDay) {
<span class="fc" id="L748">        cdate.setNormalizedYear(year);</span>
<span class="fc" id="L749">        cdate.setMonth(month + 1);</span>
<span class="pc bpc" id="L750" title="2 of 5 branches missed.">        switch (mode) {</span>
        case DOM_MODE:
<span class="fc" id="L752">            cdate.setDayOfMonth(dayOfMonth);</span>
<span class="fc" id="L753">            break;</span>

        case DOW_IN_MONTH_MODE:
<span class="fc" id="L756">            cdate.setDayOfMonth(1);</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">            if (dayOfMonth &lt; 0) {</span>
<span class="fc" id="L758">                cdate.setDayOfMonth(cal.getMonthLength(cdate));</span>
            }
<span class="fc" id="L760">            cdate = (BaseCalendar.Date) cal.getNthDayOfWeek(dayOfMonth, dayOfWeek, cdate);</span>
<span class="fc" id="L761">            break;</span>

        case DOW_GE_DOM_MODE:
<span class="fc" id="L764">            cdate.setDayOfMonth(dayOfMonth);</span>
<span class="fc" id="L765">            cdate = (BaseCalendar.Date) cal.getNthDayOfWeek(1, dayOfWeek, cdate);</span>
<span class="fc" id="L766">            break;</span>

        case DOW_LE_DOM_MODE:
<span class="nc" id="L769">            cdate.setDayOfMonth(dayOfMonth);</span>
<span class="nc" id="L770">            cdate = (BaseCalendar.Date) cal.getNthDayOfWeek(-1, dayOfWeek, cdate);</span>
            break;
        }
<span class="fc" id="L773">        return cal.getTime(cdate) + timeOfDay;</span>
    }

    /**
     * Gets the GMT offset for this time zone.
     * @return the GMT offset value in milliseconds
     * @see #setRawOffset
     */
    public int getRawOffset()
    {
        // The given date will be taken into account while
        // we have the historical time zone data in place.
<span class="fc" id="L785">        return rawOffset;</span>
    }

    /**
     * Sets the base time zone offset to GMT.
     * This is the offset to add to UTC to get local time.
     * @see #getRawOffset
     */
    public void setRawOffset(int offsetMillis)
    {
<span class="nc" id="L795">        this.rawOffset = offsetMillis;</span>
<span class="nc" id="L796">    }</span>

    /**
     * Sets the amount of time in milliseconds that the clock is advanced
     * during daylight saving time.
     * @param millisSavedDuringDST the number of milliseconds the time is
     * advanced with respect to standard time when the daylight saving time rules
     * are in effect. A positive number, typically one hour (3600000).
     * @see #getDSTSavings
     * @since 1.2
     */
    public void setDSTSavings(int millisSavedDuringDST) {
<span class="nc bnc" id="L808" title="All 2 branches missed.">        if (millisSavedDuringDST &lt;= 0) {</span>
<span class="nc" id="L809">            throw new IllegalArgumentException(&quot;Illegal daylight saving value: &quot;</span>
                                               + millisSavedDuringDST);
        }
<span class="nc" id="L812">        dstSavings = millisSavedDuringDST;</span>
<span class="nc" id="L813">    }</span>

    /**
     * Returns the amount of time in milliseconds that the clock is
     * advanced during daylight saving time.
     *
     * @return the number of milliseconds the time is advanced with
     * respect to standard time when the daylight saving rules are in
     * effect, or 0 (zero) if this time zone doesn't observe daylight
     * saving time.
     *
     * @see #setDSTSavings
     * @since 1.2
     */
    public int getDSTSavings() {
<span class="nc bnc" id="L828" title="All 2 branches missed.">        return useDaylight ? dstSavings : 0;</span>
    }

    /**
     * Queries if this time zone uses daylight saving time.
     * @return true if this time zone uses daylight saving time;
     * false otherwise.
     */
    public boolean useDaylightTime()
    {
<span class="fc" id="L838">        return useDaylight;</span>
    }

    /**
     * Returns {@code true} if this {@code SimpleTimeZone} observes
     * Daylight Saving Time. This method is equivalent to {@link
     * #useDaylightTime()}.
     *
     * @return {@code true} if this {@code SimpleTimeZone} observes
     * Daylight Saving Time; {@code false} otherwise.
     * @since 1.7
     */
    @Override
    public boolean observesDaylightTime() {
<span class="fc" id="L852">        return useDaylightTime();</span>
    }

    /**
     * Queries if the given date is in daylight saving time.
     * @return true if daylight saving time is in effective at the
     * given date; false otherwise.
     */
    public boolean inDaylightTime(Date date)
    {
<span class="nc bnc" id="L862" title="All 2 branches missed.">        return (getOffset(date.getTime()) != rawOffset);</span>
    }

    /**
     * Returns a clone of this &lt;code&gt;SimpleTimeZone&lt;/code&gt; instance.
     * @return a clone of this instance.
     */
    public Object clone()
    {
<span class="fc" id="L871">        return super.clone();</span>
    }

    /**
     * Generates the hash code for the SimpleDateFormat object.
     * @return the hash code for this object
     */
    public synchronized int hashCode()
    {
<span class="nc" id="L880">        return startMonth ^ startDay ^ startDayOfWeek ^ startTime ^</span>
            endMonth ^ endDay ^ endDayOfWeek ^ endTime ^ rawOffset;
    }

    /**
     * Compares the equality of two &lt;code&gt;SimpleTimeZone&lt;/code&gt; objects.
     *
     * @param obj  The &lt;code&gt;SimpleTimeZone&lt;/code&gt; object to be compared with.
     * @return     True if the given &lt;code&gt;obj&lt;/code&gt; is the same as this
     *             &lt;code&gt;SimpleTimeZone&lt;/code&gt; object; false otherwise.
     */
    public boolean equals(Object obj)
    {
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L894">            return true;</span>
        }
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">        if (!(obj instanceof SimpleTimeZone)) {</span>
<span class="nc" id="L897">            return false;</span>
        }

<span class="fc" id="L900">        SimpleTimeZone that = (SimpleTimeZone) obj;</span>

<span class="pc bpc" id="L902" title="1 of 2 branches missed.">        return getID().equals(that.getID()) &amp;&amp;</span>
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">            hasSameRules(that);</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this zone has the same rules and offset as another zone.
     * @param other the TimeZone object to be compared with
     * @return &lt;code&gt;true&lt;/code&gt; if the given zone is a SimpleTimeZone and has the
     * same rules and offset as this one
     * @since 1.2
     */
    public boolean hasSameRules(TimeZone other) {
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">        if (this == other) {</span>
<span class="nc" id="L915">            return true;</span>
        }
<span class="fc bfc" id="L917" title="All 2 branches covered.">        if (!(other instanceof SimpleTimeZone)) {</span>
<span class="fc" id="L918">            return false;</span>
        }
<span class="fc" id="L920">        SimpleTimeZone that = (SimpleTimeZone) other;</span>
<span class="pc bpc" id="L921" title="31 of 34 branches missed.">        return rawOffset == that.rawOffset &amp;&amp;</span>
            useDaylight == that.useDaylight &amp;&amp;
            (!useDaylight
             // Only check rules if using DST
             || (dstSavings == that.dstSavings &amp;&amp;
                 startMode == that.startMode &amp;&amp;
                 startMonth == that.startMonth &amp;&amp;
                 startDay == that.startDay &amp;&amp;
                 startDayOfWeek == that.startDayOfWeek &amp;&amp;
                 startTime == that.startTime &amp;&amp;
                 startTimeMode == that.startTimeMode &amp;&amp;
                 endMode == that.endMode &amp;&amp;
                 endMonth == that.endMonth &amp;&amp;
                 endDay == that.endDay &amp;&amp;
                 endDayOfWeek == that.endDayOfWeek &amp;&amp;
                 endTime == that.endTime &amp;&amp;
                 endTimeMode == that.endTimeMode &amp;&amp;
                 startYear == that.startYear));
    }

    /**
     * Returns a string representation of this time zone.
     * @return a string representation of this time zone.
     */
    public String toString() {
<span class="nc" id="L946">        return getClass().getName() +</span>
<span class="nc" id="L947">            &quot;[id=&quot; + getID() +</span>
            &quot;,offset=&quot; + rawOffset +
            &quot;,dstSavings=&quot; + dstSavings +
            &quot;,useDaylight=&quot; + useDaylight +
            &quot;,startYear=&quot; + startYear +
            &quot;,startMode=&quot; + startMode +
            &quot;,startMonth=&quot; + startMonth +
            &quot;,startDay=&quot; + startDay +
            &quot;,startDayOfWeek=&quot; + startDayOfWeek +
            &quot;,startTime=&quot; + startTime +
            &quot;,startTimeMode=&quot; + startTimeMode +
            &quot;,endMode=&quot; + endMode +
            &quot;,endMonth=&quot; + endMonth +
            &quot;,endDay=&quot; + endDay +
            &quot;,endDayOfWeek=&quot; + endDayOfWeek +
            &quot;,endTime=&quot; + endTime +
            &quot;,endTimeMode=&quot; + endTimeMode + ']';
    }

    // =======================privates===============================

    /**
     * The month in which daylight saving time starts.  This value must be
     * between &lt;code&gt;Calendar.JANUARY&lt;/code&gt; and
     * &lt;code&gt;Calendar.DECEMBER&lt;/code&gt; inclusive.  This value must not equal
     * &lt;code&gt;endMonth&lt;/code&gt;.
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false, this value is ignored.
     * @serial
     */
    private int startMonth;

    /**
     * This field has two possible interpretations:
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;code&gt;startMode == DOW_IN_MONTH&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * &lt;code&gt;startDay&lt;/code&gt; indicates the day of the month of
     * &lt;code&gt;startMonth&lt;/code&gt; on which daylight
     * saving time starts, from 1 to 28, 30, or 31, depending on the
     * &lt;code&gt;startMonth&lt;/code&gt;.
     * &lt;/dd&gt;
     * &lt;dt&gt;&lt;code&gt;startMode != DOW_IN_MONTH&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * &lt;code&gt;startDay&lt;/code&gt; indicates which &lt;code&gt;startDayOfWeek&lt;/code&gt; in the
     * month &lt;code&gt;startMonth&lt;/code&gt; daylight
     * saving time starts on.  For example, a value of +1 and a
     * &lt;code&gt;startDayOfWeek&lt;/code&gt; of &lt;code&gt;Calendar.SUNDAY&lt;/code&gt; indicates the
     * first Sunday of &lt;code&gt;startMonth&lt;/code&gt;.  Likewise, +2 would indicate the
     * second Sunday, and -1 the last Sunday.  A value of 0 is illegal.
     * &lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false, this value is ignored.
     * @serial
     */
    private int startDay;

    /**
     * The day of the week on which daylight saving time starts.  This value
     * must be between &lt;code&gt;Calendar.SUNDAY&lt;/code&gt; and
     * &lt;code&gt;Calendar.SATURDAY&lt;/code&gt; inclusive.
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false or
     * &lt;code&gt;startMode == DAY_OF_MONTH&lt;/code&gt;, this value is ignored.
     * @serial
     */
    private int startDayOfWeek;

    /**
     * The time in milliseconds after midnight at which daylight saving
     * time starts.  This value is expressed as wall time, standard time,
     * or UTC time, depending on the setting of &lt;code&gt;startTimeMode&lt;/code&gt;.
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false, this value is ignored.
     * @serial
     */
    private int startTime;

    /**
     * The format of startTime, either WALL_TIME, STANDARD_TIME, or UTC_TIME.
     * @serial
     * @since 1.3
     */
    private int startTimeMode;

    /**
     * The month in which daylight saving time ends.  This value must be
     * between &lt;code&gt;Calendar.JANUARY&lt;/code&gt; and
     * &lt;code&gt;Calendar.UNDECIMBER&lt;/code&gt;.  This value must not equal
     * &lt;code&gt;startMonth&lt;/code&gt;.
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false, this value is ignored.
     * @serial
     */
    private int endMonth;

    /**
     * This field has two possible interpretations:
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;code&gt;endMode == DOW_IN_MONTH&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * &lt;code&gt;endDay&lt;/code&gt; indicates the day of the month of
     * &lt;code&gt;endMonth&lt;/code&gt; on which daylight
     * saving time ends, from 1 to 28, 30, or 31, depending on the
     * &lt;code&gt;endMonth&lt;/code&gt;.
     * &lt;/dd&gt;
     * &lt;dt&gt;&lt;code&gt;endMode != DOW_IN_MONTH&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * &lt;code&gt;endDay&lt;/code&gt; indicates which &lt;code&gt;endDayOfWeek&lt;/code&gt; in th
     * month &lt;code&gt;endMonth&lt;/code&gt; daylight
     * saving time ends on.  For example, a value of +1 and a
     * &lt;code&gt;endDayOfWeek&lt;/code&gt; of &lt;code&gt;Calendar.SUNDAY&lt;/code&gt; indicates the
     * first Sunday of &lt;code&gt;endMonth&lt;/code&gt;.  Likewise, +2 would indicate the
     * second Sunday, and -1 the last Sunday.  A value of 0 is illegal.
     * &lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false, this value is ignored.
     * @serial
     */
    private int endDay;

    /**
     * The day of the week on which daylight saving time ends.  This value
     * must be between &lt;code&gt;Calendar.SUNDAY&lt;/code&gt; and
     * &lt;code&gt;Calendar.SATURDAY&lt;/code&gt; inclusive.
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false or
     * &lt;code&gt;endMode == DAY_OF_MONTH&lt;/code&gt;, this value is ignored.
     * @serial
     */
    private int endDayOfWeek;

    /**
     * The time in milliseconds after midnight at which daylight saving
     * time ends.  This value is expressed as wall time, standard time,
     * or UTC time, depending on the setting of &lt;code&gt;endTimeMode&lt;/code&gt;.
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false, this value is ignored.
     * @serial
     */
    private int endTime;

    /**
     * The format of endTime, either &lt;code&gt;WALL_TIME&lt;/code&gt;,
     * &lt;code&gt;STANDARD_TIME&lt;/code&gt;, or &lt;code&gt;UTC_TIME&lt;/code&gt;.
     * @serial
     * @since 1.3
     */
    private int endTimeMode;

    /**
     * The year in which daylight saving time is first observed.  This is an {@link GregorianCalendar#AD AD}
     * value.  If this value is less than 1 then daylight saving time is observed
     * for all &lt;code&gt;AD&lt;/code&gt; years.
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false, this value is ignored.
     * @serial
     */
    private int startYear;

    /**
     * The offset in milliseconds between this zone and GMT.  Negative offsets
     * are to the west of Greenwich.  To obtain local &lt;em&gt;standard&lt;/em&gt; time,
     * add the offset to GMT time.  To obtain local wall time it may also be
     * necessary to add &lt;code&gt;dstSavings&lt;/code&gt;.
     * @serial
     */
    private int rawOffset;

    /**
     * A boolean value which is true if and only if this zone uses daylight
     * saving time.  If this value is false, several other fields are ignored.
     * @serial
     */
<span class="fc" id="L1114">    private boolean useDaylight=false; // indicate if this time zone uses DST</span>

    private static final int millisPerHour = 60*60*1000;
    private static final int millisPerDay  = 24*millisPerHour;

    /**
     * This field was serialized in JDK 1.1, so we have to keep it that way
     * to maintain serialization compatibility. However, there's no need to
     * recreate the array each time we create a new time zone.
     * @serial An array of bytes containing the values {31, 28, 31, 30, 31, 30,
     * 31, 31, 30, 31, 30, 31}.  This is ignored as of the Java 2 platform v1.2, however, it must
     * be streamed out for compatibility with JDK 1.1.
     */
<span class="fc" id="L1127">    private final byte monthLength[] = staticMonthLength;</span>
<span class="fc" id="L1128">    private final static byte staticMonthLength[] = {31,28,31,30,31,30,31,31,30,31,30,31};</span>
<span class="fc" id="L1129">    private final static byte staticLeapMonthLength[] = {31,29,31,30,31,30,31,31,30,31,30,31};</span>

    /**
     * Variables specifying the mode of the start rule.  Takes the following
     * values:
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;code&gt;DOM_MODE&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * Exact day of week; e.g., March 1.
     * &lt;/dd&gt;
     * &lt;dt&gt;&lt;code&gt;DOW_IN_MONTH_MODE&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * Day of week in month; e.g., last Sunday in March.
     * &lt;/dd&gt;
     * &lt;dt&gt;&lt;code&gt;DOW_GE_DOM_MODE&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * Day of week after day of month; e.g., Sunday on or after March 15.
     * &lt;/dd&gt;
     * &lt;dt&gt;&lt;code&gt;DOW_LE_DOM_MODE&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * Day of week before day of month; e.g., Sunday on or before March 15.
     * &lt;/dd&gt;
     * &lt;/dl&gt;
     * The setting of this field affects the interpretation of the
     * &lt;code&gt;startDay&lt;/code&gt; field.
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false, this value is ignored.
     * @serial
     * @since 1.1.4
     */
    private int startMode;

    /**
     * Variables specifying the mode of the end rule.  Takes the following
     * values:
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;code&gt;DOM_MODE&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * Exact day of week; e.g., March 1.
     * &lt;/dd&gt;
     * &lt;dt&gt;&lt;code&gt;DOW_IN_MONTH_MODE&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * Day of week in month; e.g., last Sunday in March.
     * &lt;/dd&gt;
     * &lt;dt&gt;&lt;code&gt;DOW_GE_DOM_MODE&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * Day of week after day of month; e.g., Sunday on or after March 15.
     * &lt;/dd&gt;
     * &lt;dt&gt;&lt;code&gt;DOW_LE_DOM_MODE&lt;/code&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * Day of week before day of month; e.g., Sunday on or before March 15.
     * &lt;/dd&gt;
     * &lt;/dl&gt;
     * The setting of this field affects the interpretation of the
     * &lt;code&gt;endDay&lt;/code&gt; field.
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false, this value is ignored.
     * @serial
     * @since 1.1.4
     */
    private int endMode;

    /**
     * A positive value indicating the amount of time saved during DST in
     * milliseconds.
     * Typically one hour (3600000); sometimes 30 minutes (1800000).
     * &lt;p&gt;If &lt;code&gt;useDaylight&lt;/code&gt; is false, this value is ignored.
     * @serial
     * @since 1.1.4
     */
    private int dstSavings;

<span class="fc" id="L1199">    private static final Gregorian gcal = CalendarSystem.getGregorianCalendar();</span>

    /**
     * Cache values representing a single period of daylight saving
     * time. When the cache values are valid, cacheStart is the start
     * time (inclusive) of daylight saving time and cacheEnd is the
     * end time (exclusive).
     *
     * cacheYear has a year value if both cacheStart and cacheEnd are
     * in the same year. cacheYear is set to startYear - 1 if
     * cacheStart and cacheEnd are in different years. cacheStart is 0
     * if the cache values are void. cacheYear is a long to support
     * Integer.MIN_VALUE - 1 (JCK requirement).
     */
    private transient long cacheYear;
    private transient long cacheStart;
    private transient long cacheEnd;

    /**
     * Constants specifying values of startMode and endMode.
     */
    private static final int DOM_MODE          = 1; // Exact day of month, &quot;Mar 1&quot;
    private static final int DOW_IN_MONTH_MODE = 2; // Day of week in month, &quot;lastSun&quot;
    private static final int DOW_GE_DOM_MODE   = 3; // Day of week after day of month, &quot;Sun&gt;=15&quot;
    private static final int DOW_LE_DOM_MODE   = 4; // Day of week before day of month, &quot;Sun&lt;=21&quot;

    /**
     * Constant for a mode of start or end time specified as wall clock
     * time.  Wall clock time is standard time for the onset rule, and
     * daylight time for the end rule.
     * @since 1.4
     */
    public static final int WALL_TIME = 0; // Zero for backward compatibility

    /**
     * Constant for a mode of start or end time specified as standard time.
     * @since 1.4
     */
    public static final int STANDARD_TIME = 1;

    /**
     * Constant for a mode of start or end time specified as UTC. European
     * Union rules are specified as UTC time, for example.
     * @since 1.4
     */
    public static final int UTC_TIME = 2;

    // Proclaim compatibility with 1.1
    static final long serialVersionUID = -403250971215465050L;

    // the internal serial version which says which version was written
    // - 0 (default) for version up to JDK 1.1.3
    // - 1 for version from JDK 1.1.4, which includes 3 new fields
    // - 2 for JDK 1.3, which includes 2 new fields
    static final int currentSerialVersion = 2;

    /**
     * The version of the serialized data on the stream.  Possible values:
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;0&lt;/b&gt; or not present on stream&lt;/dt&gt;
     * &lt;dd&gt;
     * JDK 1.1.3 or earlier.
     * &lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;1&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * JDK 1.1.4 or later.  Includes three new fields: &lt;code&gt;startMode&lt;/code&gt;,
     * &lt;code&gt;endMode&lt;/code&gt;, and &lt;code&gt;dstSavings&lt;/code&gt;.
     * &lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;2&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;
     * JDK 1.3 or later.  Includes two new fields: &lt;code&gt;startTimeMode&lt;/code&gt;
     * and &lt;code&gt;endTimeMode&lt;/code&gt;.
     * &lt;/dd&gt;
     * &lt;/dl&gt;
     * When streaming out this class, the most recent format
     * and the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;
     * is written.
     * @serial
     * @since 1.1.4
     */
<span class="fc" id="L1279">    private int serialVersionOnStream = currentSerialVersion;</span>

    synchronized private void invalidateCache() {
<span class="nc" id="L1282">        cacheYear = startYear - 1;</span>
<span class="nc" id="L1283">        cacheStart = cacheEnd = 0;</span>
<span class="nc" id="L1284">    }</span>

    //----------------------------------------------------------------------
    // Rule representation
    //
    // We represent the following flavors of rules:
    //       5        the fifth of the month
    //       lastSun  the last Sunday in the month
    //       lastMon  the last Monday in the month
    //       Sun&gt;=8   first Sunday on or after the eighth
    //       Sun&lt;=25  last Sunday on or before the 25th
    // This is further complicated by the fact that we need to remain
    // backward compatible with the 1.1 FCS.  Finally, we need to minimize
    // API changes.  In order to satisfy these requirements, we support
    // three representation systems, and we translate between them.
    //
    // INTERNAL REPRESENTATION
    // This is the format SimpleTimeZone objects take after construction or
    // streaming in is complete.  Rules are represented directly, using an
    // unencoded format.  We will discuss the start rule only below; the end
    // rule is analogous.
    //   startMode      Takes on enumerated values DAY_OF_MONTH,
    //                  DOW_IN_MONTH, DOW_AFTER_DOM, or DOW_BEFORE_DOM.
    //   startDay       The day of the month, or for DOW_IN_MONTH mode, a
    //                  value indicating which DOW, such as +1 for first,
    //                  +2 for second, -1 for last, etc.
    //   startDayOfWeek The day of the week.  Ignored for DAY_OF_MONTH.
    //
    // ENCODED REPRESENTATION
    // This is the format accepted by the constructor and by setStartRule()
    // and setEndRule().  It uses various combinations of positive, negative,
    // and zero values to encode the different rules.  This representation
    // allows us to specify all the different rule flavors without altering
    // the API.
    //   MODE              startMonth    startDay    startDayOfWeek
    //   DOW_IN_MONTH_MODE &gt;=0           !=0         &gt;0
    //   DOM_MODE          &gt;=0           &gt;0          ==0
    //   DOW_GE_DOM_MODE   &gt;=0           &gt;0          &lt;0
    //   DOW_LE_DOM_MODE   &gt;=0           &lt;0          &lt;0
    //   (no DST)          don't care    ==0         don't care
    //
    // STREAMED REPRESENTATION
    // We must retain binary compatibility with the 1.1 FCS.  The 1.1 code only
    // handles DOW_IN_MONTH_MODE and non-DST mode, the latter indicated by the
    // flag useDaylight.  When we stream an object out, we translate into an
    // approximate DOW_IN_MONTH_MODE representation so the object can be parsed
    // and used by 1.1 code.  Following that, we write out the full
    // representation separately so that contemporary code can recognize and
    // parse it.  The full representation is written in a &quot;packed&quot; format,
    // consisting of a version number, a length, and an array of bytes.  Future
    // versions of this class may specify different versions.  If they wish to
    // include additional data, they should do so by storing them after the
    // packed representation below.
    //----------------------------------------------------------------------

    /**
     * Given a set of encoded rules in startDay and startDayOfMonth, decode
     * them and set the startMode appropriately.  Do the same for endDay and
     * endDayOfMonth.  Upon entry, the day of week variables may be zero or
     * negative, in order to indicate special modes.  The day of month
     * variables may also be negative.  Upon exit, the mode variables will be
     * set, and the day of week and day of month variables will be positive.
     * This method also recognizes a startDay or endDay of zero as indicating
     * no DST.
     */
    private void decodeRules()
    {
<span class="fc" id="L1351">        decodeStartRule();</span>
<span class="fc" id="L1352">        decodeEndRule();</span>
<span class="fc" id="L1353">    }</span>

    /**
     * Decode the start rule and validate the parameters.  The parameters are
     * expected to be in encoded form, which represents the various rule modes
     * by negating or zeroing certain values.  Representation formats are:
     * &lt;p&gt;
     * &lt;pre&gt;
     *            DOW_IN_MONTH  DOM    DOW&gt;=DOM  DOW&lt;=DOM  no DST
     *            ------------  -----  --------  --------  ----------
     * month       0..11        same    same      same     don't care
     * day        -5..5         1..31   1..31    -1..-31   0
     * dayOfWeek   1..7         0      -1..-7    -1..-7    don't care
     * time        0..ONEDAY    same    same      same     don't care
     * &lt;/pre&gt;
     * The range for month does not include UNDECIMBER since this class is
     * really specific to GregorianCalendar, which does not use that month.
     * The range for time includes ONEDAY (vs. ending at ONEDAY-1) because the
     * end rule is an exclusive limit point.  That is, the range of times that
     * are in DST include those &gt;= the start and &lt; the end.  For this reason,
     * it should be possible to specify an end of ONEDAY in order to include the
     * entire day.  Although this is equivalent to time 0 of the following day,
     * it's not always possible to specify that, for example, on December 31.
     * While arguably the start range should still be 0..ONEDAY-1, we keep
     * the start and end ranges the same for consistency.
     */
    private void decodeStartRule() {
<span class="pc bpc" id="L1380" title="2 of 4 branches missed.">        useDaylight = (startDay != 0) &amp;&amp; (endDay != 0);</span>
<span class="pc bpc" id="L1381" title="1 of 2 branches missed.">        if (startDay != 0) {</span>
<span class="pc bpc" id="L1382" title="2 of 4 branches missed.">            if (startMonth &lt; Calendar.JANUARY || startMonth &gt; Calendar.DECEMBER) {</span>
<span class="nc" id="L1383">                throw new IllegalArgumentException(</span>
                        &quot;Illegal start month &quot; + startMonth);
            }
<span class="pc bpc" id="L1386" title="2 of 4 branches missed.">            if (startTime &lt; 0 || startTime &gt; millisPerDay) {</span>
<span class="nc" id="L1387">                throw new IllegalArgumentException(</span>
                        &quot;Illegal start time &quot; + startTime);
            }
<span class="fc bfc" id="L1390" title="All 2 branches covered.">            if (startDayOfWeek == 0) {</span>
<span class="fc" id="L1391">                startMode = DOM_MODE;</span>
            } else {
<span class="fc bfc" id="L1393" title="All 2 branches covered.">                if (startDayOfWeek &gt; 0) {</span>
<span class="fc" id="L1394">                    startMode = DOW_IN_MONTH_MODE;</span>
                } else {
<span class="fc" id="L1396">                    startDayOfWeek = -startDayOfWeek;</span>
<span class="pc bpc" id="L1397" title="1 of 2 branches missed.">                    if (startDay &gt; 0) {</span>
<span class="fc" id="L1398">                        startMode = DOW_GE_DOM_MODE;</span>
                    } else {
<span class="nc" id="L1400">                        startDay = -startDay;</span>
<span class="nc" id="L1401">                        startMode = DOW_LE_DOM_MODE;</span>
                    }
                }
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">                if (startDayOfWeek &gt; Calendar.SATURDAY) {</span>
<span class="nc" id="L1405">                    throw new IllegalArgumentException(</span>
                           &quot;Illegal start day of week &quot; + startDayOfWeek);
                }
            }
<span class="fc bfc" id="L1409" title="All 2 branches covered.">            if (startMode == DOW_IN_MONTH_MODE) {</span>
<span class="pc bpc" id="L1410" title="2 of 4 branches missed.">                if (startDay &lt; -5 || startDay &gt; 5) {</span>
<span class="nc" id="L1411">                    throw new IllegalArgumentException(</span>
                            &quot;Illegal start day of week in month &quot; + startDay);
                }
<span class="pc bpc" id="L1414" title="2 of 4 branches missed.">            } else if (startDay &lt; 1 || startDay &gt; staticMonthLength[startMonth]) {</span>
<span class="nc" id="L1415">                throw new IllegalArgumentException(</span>
                        &quot;Illegal start day &quot; + startDay);
            }
        }
<span class="fc" id="L1419">    }</span>

    /**
     * Decode the end rule and validate the parameters.  This method is exactly
     * analogous to decodeStartRule().
     * @see decodeStartRule
     */
    private void decodeEndRule() {
<span class="pc bpc" id="L1427" title="2 of 4 branches missed.">        useDaylight = (startDay != 0) &amp;&amp; (endDay != 0);</span>
<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">        if (endDay != 0) {</span>
<span class="pc bpc" id="L1429" title="2 of 4 branches missed.">            if (endMonth &lt; Calendar.JANUARY || endMonth &gt; Calendar.DECEMBER) {</span>
<span class="nc" id="L1430">                throw new IllegalArgumentException(</span>
                        &quot;Illegal end month &quot; + endMonth);
            }
<span class="pc bpc" id="L1433" title="2 of 4 branches missed.">            if (endTime &lt; 0 || endTime &gt; millisPerDay) {</span>
<span class="nc" id="L1434">                throw new IllegalArgumentException(</span>
                        &quot;Illegal end time &quot; + endTime);
            }
<span class="fc bfc" id="L1437" title="All 2 branches covered.">            if (endDayOfWeek == 0) {</span>
<span class="fc" id="L1438">                endMode = DOM_MODE;</span>
            } else {
<span class="fc bfc" id="L1440" title="All 2 branches covered.">                if (endDayOfWeek &gt; 0) {</span>
<span class="fc" id="L1441">                    endMode = DOW_IN_MONTH_MODE;</span>
                } else {
<span class="fc" id="L1443">                    endDayOfWeek = -endDayOfWeek;</span>
<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">                    if (endDay &gt; 0) {</span>
<span class="fc" id="L1445">                        endMode = DOW_GE_DOM_MODE;</span>
                    } else {
<span class="nc" id="L1447">                        endDay = -endDay;</span>
<span class="nc" id="L1448">                        endMode = DOW_LE_DOM_MODE;</span>
                    }
                }
<span class="pc bpc" id="L1451" title="1 of 2 branches missed.">                if (endDayOfWeek &gt; Calendar.SATURDAY) {</span>
<span class="nc" id="L1452">                    throw new IllegalArgumentException(</span>
                           &quot;Illegal end day of week &quot; + endDayOfWeek);
                }
            }
<span class="fc bfc" id="L1456" title="All 2 branches covered.">            if (endMode == DOW_IN_MONTH_MODE) {</span>
<span class="pc bpc" id="L1457" title="2 of 4 branches missed.">                if (endDay &lt; -5 || endDay &gt; 5) {</span>
<span class="nc" id="L1458">                    throw new IllegalArgumentException(</span>
                            &quot;Illegal end day of week in month &quot; + endDay);
                }
<span class="pc bpc" id="L1461" title="2 of 4 branches missed.">            } else if (endDay &lt; 1 || endDay &gt; staticMonthLength[endMonth]) {</span>
<span class="nc" id="L1462">                throw new IllegalArgumentException(</span>
                        &quot;Illegal end day &quot; + endDay);
            }
        }
<span class="fc" id="L1466">    }</span>

    /**
     * Make rules compatible to 1.1 FCS code.  Since 1.1 FCS code only understands
     * day-of-week-in-month rules, we must modify other modes of rules to their
     * approximate equivalent in 1.1 FCS terms.  This method is used when streaming
     * out objects of this class.  After it is called, the rules will be modified,
     * with a possible loss of information.  startMode and endMode will NOT be
     * altered, even though semantically they should be set to DOW_IN_MONTH_MODE,
     * since the rule modification is only intended to be temporary.
     */
    private void makeRulesCompatible()
    {
<span class="nc bnc" id="L1479" title="All 4 branches missed.">        switch (startMode) {</span>
        case DOM_MODE:
<span class="nc" id="L1481">            startDay = 1 + (startDay / 7);</span>
<span class="nc" id="L1482">            startDayOfWeek = Calendar.SUNDAY;</span>
<span class="nc" id="L1483">            break;</span>

        case DOW_GE_DOM_MODE:
            // A day-of-month of 1 is equivalent to DOW_IN_MONTH_MODE
            // that is, Sun&gt;=1 == firstSun.
<span class="nc bnc" id="L1488" title="All 2 branches missed.">            if (startDay != 1) {</span>
<span class="nc" id="L1489">                startDay = 1 + (startDay / 7);</span>
            }
            break;

        case DOW_LE_DOM_MODE:
<span class="nc bnc" id="L1494" title="All 2 branches missed.">            if (startDay &gt;= 30) {</span>
<span class="nc" id="L1495">                startDay = -1;</span>
            } else {
<span class="nc" id="L1497">                startDay = 1 + (startDay / 7);</span>
            }
            break;
        }

<span class="nc bnc" id="L1502" title="All 4 branches missed.">        switch (endMode) {</span>
        case DOM_MODE:
<span class="nc" id="L1504">            endDay = 1 + (endDay / 7);</span>
<span class="nc" id="L1505">            endDayOfWeek = Calendar.SUNDAY;</span>
<span class="nc" id="L1506">            break;</span>

        case DOW_GE_DOM_MODE:
            // A day-of-month of 1 is equivalent to DOW_IN_MONTH_MODE
            // that is, Sun&gt;=1 == firstSun.
<span class="nc bnc" id="L1511" title="All 2 branches missed.">            if (endDay != 1) {</span>
<span class="nc" id="L1512">                endDay = 1 + (endDay / 7);</span>
            }
            break;

        case DOW_LE_DOM_MODE:
<span class="nc bnc" id="L1517" title="All 2 branches missed.">            if (endDay &gt;= 30) {</span>
<span class="nc" id="L1518">                endDay = -1;</span>
            } else {
<span class="nc" id="L1520">                endDay = 1 + (endDay / 7);</span>
            }
            break;
        }

        /*
         * Adjust the start and end times to wall time.  This works perfectly
         * well unless it pushes into the next or previous day.  If that
         * happens, we attempt to adjust the day rule somewhat crudely.  The day
         * rules have been forced into DOW_IN_MONTH mode already, so we change
         * the day of week to move forward or back by a day.  It's possible to
         * make a more refined adjustment of the original rules first, but in
         * most cases this extra effort will go to waste once we adjust the day
         * rules anyway.
         */
<span class="nc bnc" id="L1535" title="All 2 branches missed.">        switch (startTimeMode) {</span>
        case UTC_TIME:
<span class="nc" id="L1537">            startTime += rawOffset;</span>
            break;
        }
<span class="nc bnc" id="L1540" title="All 2 branches missed.">        while (startTime &lt; 0) {</span>
<span class="nc" id="L1541">            startTime += millisPerDay;</span>
<span class="nc" id="L1542">            startDayOfWeek = 1 + ((startDayOfWeek+5) % 7); // Back 1 day</span>
        }
<span class="nc bnc" id="L1544" title="All 2 branches missed.">        while (startTime &gt;= millisPerDay) {</span>
<span class="nc" id="L1545">            startTime -= millisPerDay;</span>
<span class="nc" id="L1546">            startDayOfWeek = 1 + (startDayOfWeek % 7); // Forward 1 day</span>
        }

<span class="nc bnc" id="L1549" title="All 3 branches missed.">        switch (endTimeMode) {</span>
        case UTC_TIME:
<span class="nc" id="L1551">            endTime += rawOffset + dstSavings;</span>
<span class="nc" id="L1552">            break;</span>
        case STANDARD_TIME:
<span class="nc" id="L1554">            endTime += dstSavings;</span>
        }
<span class="nc bnc" id="L1556" title="All 2 branches missed.">        while (endTime &lt; 0) {</span>
<span class="nc" id="L1557">            endTime += millisPerDay;</span>
<span class="nc" id="L1558">            endDayOfWeek = 1 + ((endDayOfWeek+5) % 7); // Back 1 day</span>
        }
<span class="nc bnc" id="L1560" title="All 2 branches missed.">        while (endTime &gt;= millisPerDay) {</span>
<span class="nc" id="L1561">            endTime -= millisPerDay;</span>
<span class="nc" id="L1562">            endDayOfWeek = 1 + (endDayOfWeek % 7); // Forward 1 day</span>
        }
<span class="nc" id="L1564">    }</span>

    /**
     * Pack the start and end rules into an array of bytes.  Only pack
     * data which is not preserved by makeRulesCompatible.
     */
    private byte[] packRules()
    {
<span class="nc" id="L1572">        byte[] rules = new byte[6];</span>
<span class="nc" id="L1573">        rules[0] = (byte)startDay;</span>
<span class="nc" id="L1574">        rules[1] = (byte)startDayOfWeek;</span>
<span class="nc" id="L1575">        rules[2] = (byte)endDay;</span>
<span class="nc" id="L1576">        rules[3] = (byte)endDayOfWeek;</span>

        // As of serial version 2, include time modes
<span class="nc" id="L1579">        rules[4] = (byte)startTimeMode;</span>
<span class="nc" id="L1580">        rules[5] = (byte)endTimeMode;</span>

<span class="nc" id="L1582">        return rules;</span>
    }

    /**
     * Given an array of bytes produced by packRules, interpret them
     * as the start and end rules.
     */
    private void unpackRules(byte[] rules)
    {
<span class="nc" id="L1591">        startDay       = rules[0];</span>
<span class="nc" id="L1592">        startDayOfWeek = rules[1];</span>
<span class="nc" id="L1593">        endDay         = rules[2];</span>
<span class="nc" id="L1594">        endDayOfWeek   = rules[3];</span>

        // As of serial version 2, include time modes
<span class="nc bnc" id="L1597" title="All 2 branches missed.">        if (rules.length &gt;= 6) {</span>
<span class="nc" id="L1598">            startTimeMode = rules[4];</span>
<span class="nc" id="L1599">            endTimeMode   = rules[5];</span>
        }
<span class="nc" id="L1601">    }</span>

    /**
     * Pack the start and end times into an array of bytes.  This is required
     * as of serial version 2.
     */
    private int[] packTimes() {
<span class="nc" id="L1608">        int[] times = new int[2];</span>
<span class="nc" id="L1609">        times[0] = startTime;</span>
<span class="nc" id="L1610">        times[1] = endTime;</span>
<span class="nc" id="L1611">        return times;</span>
    }

    /**
     * Unpack the start and end times from an array of bytes.  This is required
     * as of serial version 2.
     */
    private void unpackTimes(int[] times) {
<span class="nc" id="L1619">        startTime = times[0];</span>
<span class="nc" id="L1620">        endTime = times[1];</span>
<span class="nc" id="L1621">    }</span>

    /**
     * Save the state of this object to a stream (i.e., serialize it).
     *
     * @serialData We write out two formats, a JDK 1.1 compatible format, using
     * &lt;code&gt;DOW_IN_MONTH_MODE&lt;/code&gt; rules, in the required section, followed
     * by the full rules, in packed format, in the optional section.  The
     * optional section will be ignored by JDK 1.1 code upon stream in.
     * &lt;p&gt; Contents of the optional section: The length of a byte array is
     * emitted (int); this is 4 as of this release. The byte array of the given
     * length is emitted. The contents of the byte array are the true values of
     * the fields &lt;code&gt;startDay&lt;/code&gt;, &lt;code&gt;startDayOfWeek&lt;/code&gt;,
     * &lt;code&gt;endDay&lt;/code&gt;, and &lt;code&gt;endDayOfWeek&lt;/code&gt;.  The values of these
     * fields in the required section are approximate values suited to the rule
     * mode &lt;code&gt;DOW_IN_MONTH_MODE&lt;/code&gt;, which is the only mode recognized by
     * JDK 1.1.
     */
    private void writeObject(ObjectOutputStream stream)
         throws IOException
    {
        // Construct a binary rule
<span class="nc" id="L1643">        byte[] rules = packRules();</span>
<span class="nc" id="L1644">        int[] times = packTimes();</span>

        // Convert to 1.1 FCS rules.  This step may cause us to lose information.
<span class="nc" id="L1647">        makeRulesCompatible();</span>

        // Write out the 1.1 FCS rules
<span class="nc" id="L1650">        stream.defaultWriteObject();</span>

        // Write out the binary rules in the optional data area of the stream.
<span class="nc" id="L1653">        stream.writeInt(rules.length);</span>
<span class="nc" id="L1654">        stream.write(rules);</span>
<span class="nc" id="L1655">        stream.writeObject(times);</span>

        // Recover the original rules.  This recovers the information lost
        // by makeRulesCompatible.
<span class="nc" id="L1659">        unpackRules(rules);</span>
<span class="nc" id="L1660">        unpackTimes(times);</span>
<span class="nc" id="L1661">    }</span>

    /**
     * Reconstitute this object from a stream (i.e., deserialize it).
     *
     * We handle both JDK 1.1
     * binary formats and full formats with a packed byte array.
     */
    private void readObject(ObjectInputStream stream)
         throws IOException, ClassNotFoundException
    {
<span class="nc" id="L1672">        stream.defaultReadObject();</span>

<span class="nc bnc" id="L1674" title="All 2 branches missed.">        if (serialVersionOnStream &lt; 1) {</span>
            // Fix a bug in the 1.1 SimpleTimeZone code -- namely,
            // startDayOfWeek and endDayOfWeek were usually uninitialized.  We can't do
            // too much, so we assume SUNDAY, which actually works most of the time.
<span class="nc bnc" id="L1678" title="All 2 branches missed.">            if (startDayOfWeek == 0) {</span>
<span class="nc" id="L1679">                startDayOfWeek = Calendar.SUNDAY;</span>
            }
<span class="nc bnc" id="L1681" title="All 2 branches missed.">            if (endDayOfWeek == 0) {</span>
<span class="nc" id="L1682">                endDayOfWeek = Calendar.SUNDAY;</span>
            }

            // The variables dstSavings, startMode, and endMode are post-1.1, so they
            // won't be present if we're reading from a 1.1 stream.  Fix them up.
<span class="nc" id="L1687">            startMode = endMode = DOW_IN_MONTH_MODE;</span>
<span class="nc" id="L1688">            dstSavings = millisPerHour;</span>
        } else {
            // For 1.1.4, in addition to the 3 new instance variables, we also
            // store the actual rules (which have not be made compatible with 1.1)
            // in the optional area.  Read them in here and parse them.
<span class="nc" id="L1693">            int length = stream.readInt();</span>
<span class="nc" id="L1694">            byte[] rules = new byte[length];</span>
<span class="nc" id="L1695">            stream.readFully(rules);</span>
<span class="nc" id="L1696">            unpackRules(rules);</span>
        }

<span class="nc bnc" id="L1699" title="All 2 branches missed.">        if (serialVersionOnStream &gt;= 2) {</span>
<span class="nc" id="L1700">            int[] times = (int[]) stream.readObject();</span>
<span class="nc" id="L1701">            unpackTimes(times);</span>
        }

<span class="nc" id="L1704">        serialVersionOnStream = currentSerialVersion;</span>
<span class="nc" id="L1705">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>