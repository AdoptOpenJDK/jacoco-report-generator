<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>StringJoiner.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">StringJoiner.java</span></div><h1>StringJoiner.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.util;

/**
 * {@code StringJoiner} is used to construct a sequence of characters separated
 * by a delimiter and optionally starting with a supplied prefix
 * and ending with a supplied suffix.
 * &lt;p&gt;
 * Prior to adding something to the {@code StringJoiner}, its
 * {@code sj.toString()} method will, by default, return {@code prefix + suffix}.
 * However, if the {@code setEmptyValue} method is called, the {@code emptyValue}
 * supplied will be returned instead. This can be used, for example, when
 * creating a string using set notation to indicate an empty set, i.e.
 * &lt;code&gt;&quot;{}&quot;&lt;/code&gt;, where the {@code prefix} is &lt;code&gt;&quot;{&quot;&lt;/code&gt;, the
 * {@code suffix} is &lt;code&gt;&quot;}&quot;&lt;/code&gt; and nothing has been added to the
 * {@code StringJoiner}.
 *
 * @apiNote
 * &lt;p&gt;The String {@code &quot;[George:Sally:Fred]&quot;} may be constructed as follows:
 *
 * &lt;pre&gt; {@code
 * StringJoiner sj = new StringJoiner(&quot;:&quot;, &quot;[&quot;, &quot;]&quot;);
 * sj.add(&quot;George&quot;).add(&quot;Sally&quot;).add(&quot;Fred&quot;);
 * String desiredString = sj.toString();
 * }&lt;/pre&gt;
 * &lt;p&gt;
 * A {@code StringJoiner} may be employed to create formatted output from a
 * {@link java.util.stream.Stream} using
 * {@link java.util.stream.Collectors#joining(CharSequence)}. For example:
 *
 * &lt;pre&gt; {@code
 * List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);
 * String commaSeparatedNumbers = numbers.stream()
 *     .map(i -&gt; i.toString())
 *     .collect(Collectors.joining(&quot;, &quot;));
 * }&lt;/pre&gt;
 *
 * @see java.util.stream.Collectors#joining(CharSequence)
 * @see java.util.stream.Collectors#joining(CharSequence, CharSequence, CharSequence)
 * @since  1.8
*/
public final class StringJoiner {
    private final String prefix;
    private final String delimiter;
    private final String suffix;

    /*
     * StringBuilder value -- at any time, the characters constructed from the
     * prefix, the added element separated by the delimiter, but without the
     * suffix, so that we can more easily add elements without having to jigger
     * the suffix each time.
     */
    private StringBuilder value;

    /*
     * By default, the string consisting of prefix+suffix, returned by
     * toString(), or properties of value, when no elements have yet been added,
     * i.e. when it is empty.  This may be overridden by the user to be some
     * other value including the empty String.
     */
    private String emptyValue;

    /**
     * Constructs a {@code StringJoiner} with no characters in it, with no
     * {@code prefix} or {@code suffix}, and a copy of the supplied
     * {@code delimiter}.
     * If no characters are added to the {@code StringJoiner} and methods
     * accessing the value of it are invoked, it will not return a
     * {@code prefix} or {@code suffix} (or properties thereof) in the result,
     * unless {@code setEmptyValue} has first been called.
     *
     * @param  delimiter the sequence of characters to be used between each
     *         element added to the {@code StringJoiner} value
     * @throws NullPointerException if {@code delimiter} is {@code null}
     */
    public StringJoiner(CharSequence delimiter) {
<span class="fc" id="L100">        this(delimiter, &quot;&quot;, &quot;&quot;);</span>
<span class="fc" id="L101">    }</span>

    /**
     * Constructs a {@code StringJoiner} with no characters in it using copies
     * of the supplied {@code prefix}, {@code delimiter} and {@code suffix}.
     * If no characters are added to the {@code StringJoiner} and methods
     * accessing the string value of it are invoked, it will return the
     * {@code prefix + suffix} (or properties thereof) in the result, unless
     * {@code setEmptyValue} has first been called.
     *
     * @param  delimiter the sequence of characters to be used between each
     *         element added to the {@code StringJoiner}
     * @param  prefix the sequence of characters to be used at the beginning
     * @param  suffix the sequence of characters to be used at the end
     * @throws NullPointerException if {@code prefix}, {@code delimiter}, or
     *         {@code suffix} is {@code null}
     */
    public StringJoiner(CharSequence delimiter,
                        CharSequence prefix,
<span class="fc" id="L120">                        CharSequence suffix) {</span>
<span class="fc" id="L121">        Objects.requireNonNull(prefix, &quot;The prefix must not be null&quot;);</span>
<span class="fc" id="L122">        Objects.requireNonNull(delimiter, &quot;The delimiter must not be null&quot;);</span>
<span class="fc" id="L123">        Objects.requireNonNull(suffix, &quot;The suffix must not be null&quot;);</span>
        // make defensive copies of arguments
<span class="fc" id="L125">        this.prefix = prefix.toString();</span>
<span class="fc" id="L126">        this.delimiter = delimiter.toString();</span>
<span class="fc" id="L127">        this.suffix = suffix.toString();</span>
<span class="fc" id="L128">        this.emptyValue = this.prefix + this.suffix;</span>
<span class="fc" id="L129">    }</span>

    /**
     * Sets the sequence of characters to be used when determining the string
     * representation of this {@code StringJoiner} and no elements have been
     * added yet, i.e. when it is empty.  A copy of the {@code emptyValue}
     * parameter is made for this purpose. Note that once an add method has been
     * called, the {@code StringJoiner} is no longer considered empty, even if
     * the element(s) added correspond to the empty {@code String}.
     *
     * @param  emptyValue the characters to return as the value of an empty
     *         {@code StringJoiner}
     * @return this {@code StringJoiner} itself so the calls may be chained
     * @throws NullPointerException when the {@code emptyValue} parameter is
     *         {@code null}
     */
    public StringJoiner setEmptyValue(CharSequence emptyValue) {
<span class="nc" id="L146">        this.emptyValue = Objects.requireNonNull(emptyValue,</span>
<span class="nc" id="L147">            &quot;The empty value must not be null&quot;).toString();</span>
<span class="nc" id="L148">        return this;</span>
    }

    /**
     * Returns the current value, consisting of the {@code prefix}, the values
     * added so far separated by the {@code delimiter}, and the {@code suffix},
     * unless no elements have been added in which case, the
     * {@code prefix + suffix} or the {@code emptyValue} characters are returned
     *
     * @return the string representation of this {@code StringJoiner}
     */
    @Override
    public String toString() {
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L162">            return emptyValue;</span>
        } else {
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            if (suffix.equals(&quot;&quot;)) {</span>
<span class="fc" id="L165">                return value.toString();</span>
            } else {
<span class="nc" id="L167">                int initialLength = value.length();</span>
<span class="nc" id="L168">                String result = value.append(suffix).toString();</span>
                // reset value to pre-append initialLength
<span class="nc" id="L170">                value.setLength(initialLength);</span>
<span class="nc" id="L171">                return result;</span>
            }
        }
    }

    /**
     * Adds a copy of the given {@code CharSequence} value as the next
     * element of the {@code StringJoiner} value. If {@code newElement} is
     * {@code null}, then {@code &quot;null&quot;} is added.
     *
     * @param  newElement The element to add
     * @return a reference to this {@code StringJoiner}
     */
    public StringJoiner add(CharSequence newElement) {
<span class="fc" id="L185">        prepareBuilder().append(newElement);</span>
<span class="fc" id="L186">        return this;</span>
    }

    /**
     * Adds the contents of the given {@code StringJoiner} without prefix and
     * suffix as the next element if it is non-empty. If the given {@code
     * StringJoiner} is empty, the call has no effect.
     *
     * &lt;p&gt;A {@code StringJoiner} is empty if {@link #add(CharSequence) add()}
     * has never been called, and if {@code merge()} has never been called
     * with a non-empty {@code StringJoiner} argument.
     *
     * &lt;p&gt;If the other {@code StringJoiner} is using a different delimiter,
     * then elements from the other {@code StringJoiner} are concatenated with
     * that delimiter and the result is appended to this {@code StringJoiner}
     * as a single element.
     *
     * @param other The {@code StringJoiner} whose contents should be merged
     *              into this one
     * @throws NullPointerException if the other {@code StringJoiner} is null
     * @return This {@code StringJoiner}
     */
    public StringJoiner merge(StringJoiner other) {
<span class="nc" id="L209">        Objects.requireNonNull(other);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (other.value != null) {</span>
<span class="nc" id="L211">            final int length = other.value.length();</span>
            // lock the length so that we can seize the data to be appended
            // before initiate copying to avoid interference, especially when
            // merge 'this'
<span class="nc" id="L215">            StringBuilder builder = prepareBuilder();</span>
<span class="nc" id="L216">            builder.append(other.value, other.prefix.length(), length);</span>
        }
<span class="nc" id="L218">        return this;</span>
    }

    private StringBuilder prepareBuilder() {
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L223">            value.append(delimiter);</span>
        } else {
<span class="fc" id="L225">            value = new StringBuilder().append(prefix);</span>
        }
<span class="fc" id="L227">        return value;</span>
    }

    /**
     * The length of the {@code StringJoiner} value, i.e. the length of
     * {@code String} representation of the {@code StringJoiner}. Note that if
     * no add methods have been called, then the length of the {@code String}
     * representation (either {@code prefix + suffix} or {@code emptyValue})
     * will be returned. The value should be equivalent to
     * {@code toString().length()}.
     *
     * @return the length of the current value of {@code StringJoiner}
     */
    public int length() {
        // Remember that we never actually append the suffix unless we return
        // the full (present) value or some sub-string or length of it, so that
        // we can add on more if we need to.
<span class="nc bnc" id="L244" title="All 2 branches missed.">        return (value != null ? value.length() + suffix.length() :</span>
<span class="nc" id="L245">                emptyValue.length());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>