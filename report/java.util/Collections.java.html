<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Collections.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">Collections.java</span></div><h1>Collections.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;
import java.io.Serializable;
import java.io.ObjectOutputStream;
import java.io.IOException;
import java.lang.reflect.Array;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * This class consists exclusively of static methods that operate on or return
 * collections.  It contains polymorphic algorithms that operate on
 * collections, &quot;wrappers&quot;, which return a new collection backed by a
 * specified collection, and a few other odds and ends.
 *
 * &lt;p&gt;The methods of this class all throw a &lt;tt&gt;NullPointerException&lt;/tt&gt;
 * if the collections or class objects provided to them are null.
 *
 * &lt;p&gt;The documentation for the polymorphic algorithms contained in this class
 * generally includes a brief description of the &lt;i&gt;implementation&lt;/i&gt;.  Such
 * descriptions should be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than
 * parts of the &lt;i&gt;specification&lt;/i&gt;.  Implementors should feel free to
 * substitute other algorithms, so long as the specification itself is adhered
 * to.  (For example, the algorithm used by &lt;tt&gt;sort&lt;/tt&gt; does not have to be
 * a mergesort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)
 *
 * &lt;p&gt;The &quot;destructive&quot; algorithms contained in this class, that is, the
 * algorithms that modify the collection on which they operate, are specified
 * to throw &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; if the collection does not
 * support the appropriate mutation primitive(s), such as the &lt;tt&gt;set&lt;/tt&gt;
 * method.  These algorithms may, but are not required to, throw this
 * exception if an invocation would have no effect on the collection.  For
 * example, invoking the &lt;tt&gt;sort&lt;/tt&gt; method on an unmodifiable list that is
 * already sorted may or may not throw &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @author  Josh Bloch
 * @author  Neal Gafter
 * @see     Collection
 * @see     Set
 * @see     List
 * @see     Map
 * @since   1.2
 */

public class Collections {
    // Suppresses default constructor, ensuring non-instantiability.
<span class="nc" id="L82">    private Collections() {</span>
<span class="nc" id="L83">    }</span>

    // Algorithms

    /*
     * Tuning parameters for algorithms - Many of the List algorithms have
     * two implementations, one of which is appropriate for RandomAccess
     * lists, the other for &quot;sequential.&quot;  Often, the random access variant
     * yields better performance on small sequential access lists.  The
     * tuning parameters below determine the cutoff point for what constitutes
     * a &quot;small&quot; sequential access list for each algorithm.  The values below
     * were empirically determined to work well for LinkedList. Hopefully
     * they should be reasonable for other sequential access List
     * implementations.  Those doing performance work on this code would
     * do well to validate the values of these parameters from time to time.
     * (The first word of each tuning parameter name is the algorithm to which
     * it applies.)
     */
    private static final int BINARYSEARCH_THRESHOLD   = 5000;
    private static final int REVERSE_THRESHOLD        =   18;
    private static final int SHUFFLE_THRESHOLD        =    5;
    private static final int FILL_THRESHOLD           =   25;
    private static final int ROTATE_THRESHOLD         =  100;
    private static final int COPY_THRESHOLD           =   10;
    private static final int REPLACEALL_THRESHOLD     =   11;
    private static final int INDEXOFSUBLIST_THRESHOLD =   35;

    /**
     * Sorts the specified list into ascending order, according to the
     * {@linkplain Comparable natural ordering} of its elements.
     * All elements in the list must implement the {@link Comparable}
     * interface.  Furthermore, all elements in the list must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)}
     * must not throw a {@code ClassCastException} for any elements
     * {@code e1} and {@code e2} in the list).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * &lt;p&gt;The specified list must be modifiable, but need not be resizable.
     *
     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
     * iterative mergesort that requires far fewer than n lg(n) comparisons
     * when the input array is partially sorted, while offering the
     * performance of a traditional mergesort when the input array is
     * randomly ordered.  If the input array is nearly sorted, the
     * implementation requires approximately n comparisons.  Temporary
     * storage requirements vary from a small constant for nearly sorted
     * input arrays to n/2 object references for randomly ordered input
     * arrays.
     *
     * &lt;p&gt;The implementation takes equal advantage of ascending and
     * descending order in its input array, and can take advantage of
     * ascending and descending order in different parts of the same
     * input array.  It is well-suited to merging two or more sorted arrays:
     * simply concatenate the arrays and sort the resulting array.
     *
     * &lt;p&gt;The implementation was adapted from Tim Peters's list sort for Python
     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy's &quot;Optimistic
     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
     * January 1993.
     *
     * &lt;p&gt;This implementation dumps the specified list into an array, sorts
     * the array, and iterates over the list resetting each element
     * from the corresponding position in the array.  This avoids the
     * n&lt;sup&gt;2&lt;/sup&gt; log(n) performance that would result from attempting
     * to sort a linked list in place.
     *
     * @param  &lt;T&gt; the class of the objects in the list
     * @param  list the list to be sorted.
     * @throws ClassCastException if the list contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and integers).
     * @throws UnsupportedOperationException if the specified list's
     *         list-iterator does not support the {@code set} operation.
     * @throws IllegalArgumentException (optional) if the implementation
     *         detects that the natural ordering of the list elements is
     *         found to violate the {@link Comparable} contract
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
<span class="nc" id="L165">        Object[] a = list.toArray();</span>
<span class="nc" id="L166">        Arrays.sort(a);</span>
<span class="nc" id="L167">        ListIterator&lt;T&gt; i = list.listIterator();</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        for (int j=0; j&lt;a.length; j++) {</span>
<span class="nc" id="L169">            i.next();</span>
<span class="nc" id="L170">            i.set((T)a[j]);</span>
        }
<span class="nc" id="L172">    }</span>

    /**
     * Sorts the specified list according to the order induced by the
     * specified comparator.  All elements in the list must be &lt;i&gt;mutually
     * comparable&lt;/i&gt; using the specified comparator (that is,
     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}
     * for any elements {@code e1} and {@code e2} in the list).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * &lt;p&gt;The specified list must be modifiable, but need not be resizable.
     *
     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
     * iterative mergesort that requires far fewer than n lg(n) comparisons
     * when the input array is partially sorted, while offering the
     * performance of a traditional mergesort when the input array is
     * randomly ordered.  If the input array is nearly sorted, the
     * implementation requires approximately n comparisons.  Temporary
     * storage requirements vary from a small constant for nearly sorted
     * input arrays to n/2 object references for randomly ordered input
     * arrays.
     *
     * &lt;p&gt;The implementation takes equal advantage of ascending and
     * descending order in its input array, and can take advantage of
     * ascending and descending order in different parts of the same
     * input array.  It is well-suited to merging two or more sorted arrays:
     * simply concatenate the arrays and sort the resulting array.
     *
     * &lt;p&gt;The implementation was adapted from Tim Peters's list sort for Python
     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy's &quot;Optimistic
     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
     * January 1993.
     *
     * &lt;p&gt;This implementation dumps the specified list into an array, sorts
     * the array, and iterates over the list resetting each element
     * from the corresponding position in the array.  This avoids the
     * n&lt;sup&gt;2&lt;/sup&gt; log(n) performance that would result from attempting
     * to sort a linked list in place.
     *
     * @param  &lt;T&gt; the class of the objects in the list
     * @param  list the list to be sorted.
     * @param  c the comparator to determine the order of the list.  A
     *        {@code null} value indicates that the elements' &lt;i&gt;natural
     *        ordering&lt;/i&gt; should be used.
     * @throws ClassCastException if the list contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.
     * @throws UnsupportedOperationException if the specified list's
     *         list-iterator does not support the {@code set} operation.
     * @throws IllegalArgumentException (optional) if the comparator is
     *         found to violate the {@link Comparator} contract
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) {
<span class="nc" id="L229">        Object[] a = list.toArray();</span>
<span class="nc" id="L230">        Arrays.sort(a, (Comparator)c);</span>
<span class="nc" id="L231">        ListIterator&lt;T&gt; i = list.listIterator();</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        for (int j=0; j&lt;a.length; j++) {</span>
<span class="nc" id="L233">            i.next();</span>
<span class="nc" id="L234">            i.set((T)a[j]);</span>
        }
<span class="nc" id="L236">    }</span>


    /**
     * Searches the specified list for the specified object using the binary
     * search algorithm.  The list must be sorted into ascending order
     * according to the {@linkplain Comparable natural ordering} of its
     * elements (as by the {@link #sort(List)} method) prior to making this
     * call.  If it is not sorted, the results are undefined.  If the list
     * contains multiple elements equal to the specified object, there is no
     * guarantee which one will be found.
     *
     * &lt;p&gt;This method runs in log(n) time for a &quot;random access&quot; list (which
     * provides near-constant-time positional access).  If the specified list
     * does not implement the {@link RandomAccess} interface and is large,
     * this method will do an iterator-based binary search that performs
     * O(n) link traversals and O(log n) element comparisons.
     *
     * @param  &lt;T&gt; the class of the objects in the list
     * @param  list the list to be searched.
     * @param  key the key to be searched for.
     * @return the index of the search key, if it is contained in the list;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the list: the index of the first
     *         element greater than the key, or &lt;tt&gt;list.size()&lt;/tt&gt; if all
     *         elements in the list are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws ClassCastException if the list contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
     *         integers), or the search key is not mutually comparable
     *         with the elements of the list.
     */
    public static &lt;T&gt;
    int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) {
<span class="nc bnc" id="L272" title="All 4 branches missed.">        if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span>
<span class="nc" id="L273">            return Collections.indexedBinarySearch(list, key);</span>
        else
<span class="nc" id="L275">            return Collections.iteratorBinarySearch(list, key);</span>
    }

    private static &lt;T&gt;
    int indexedBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) {
<span class="nc" id="L280">        int low = 0;</span>
<span class="nc" id="L281">        int high = list.size()-1;</span>

<span class="nc bnc" id="L283" title="All 2 branches missed.">        while (low &lt;= high) {</span>
<span class="nc" id="L284">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L285">            Comparable&lt;? super T&gt; midVal = list.get(mid);</span>
<span class="nc" id="L286">            int cmp = midVal.compareTo(key);</span>

<span class="nc bnc" id="L288" title="All 2 branches missed.">            if (cmp &lt; 0)</span>
<span class="nc" id="L289">                low = mid + 1;</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            else if (cmp &gt; 0)</span>
<span class="nc" id="L291">                high = mid - 1;</span>
            else
<span class="nc" id="L293">                return mid; // key found</span>
<span class="nc" id="L294">        }</span>
<span class="nc" id="L295">        return -(low + 1);  // key not found</span>
    }

    private static &lt;T&gt;
    int iteratorBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)
    {
<span class="nc" id="L301">        int low = 0;</span>
<span class="nc" id="L302">        int high = list.size()-1;</span>
<span class="nc" id="L303">        ListIterator&lt;? extends Comparable&lt;? super T&gt;&gt; i = list.listIterator();</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">        while (low &lt;= high) {</span>
<span class="nc" id="L306">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L307">            Comparable&lt;? super T&gt; midVal = get(i, mid);</span>
<span class="nc" id="L308">            int cmp = midVal.compareTo(key);</span>

<span class="nc bnc" id="L310" title="All 2 branches missed.">            if (cmp &lt; 0)</span>
<span class="nc" id="L311">                low = mid + 1;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            else if (cmp &gt; 0)</span>
<span class="nc" id="L313">                high = mid - 1;</span>
            else
<span class="nc" id="L315">                return mid; // key found</span>
<span class="nc" id="L316">        }</span>
<span class="nc" id="L317">        return -(low + 1);  // key not found</span>
    }

    /**
     * Gets the ith element from the given list by repositioning the specified
     * list listIterator.
     */
    private static &lt;T&gt; T get(ListIterator&lt;? extends T&gt; i, int index) {
<span class="nc" id="L325">        T obj = null;</span>
<span class="nc" id="L326">        int pos = i.nextIndex();</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (pos &lt;= index) {</span>
            do {
<span class="nc" id="L329">                obj = i.next();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            } while (pos++ &lt; index);</span>
        } else {
            do {
<span class="nc" id="L333">                obj = i.previous();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            } while (--pos &gt; index);</span>
        }
<span class="nc" id="L336">        return obj;</span>
    }

    /**
     * Searches the specified list for the specified object using the binary
     * search algorithm.  The list must be sorted into ascending order
     * according to the specified comparator (as by the
     * {@link #sort(List, Comparator) sort(List, Comparator)}
     * method), prior to making this call.  If it is
     * not sorted, the results are undefined.  If the list contains multiple
     * elements equal to the specified object, there is no guarantee which one
     * will be found.
     *
     * &lt;p&gt;This method runs in log(n) time for a &quot;random access&quot; list (which
     * provides near-constant-time positional access).  If the specified list
     * does not implement the {@link RandomAccess} interface and is large,
     * this method will do an iterator-based binary search that performs
     * O(n) link traversals and O(log n) element comparisons.
     *
     * @param  &lt;T&gt; the class of the objects in the list
     * @param  list the list to be searched.
     * @param  key the key to be searched for.
     * @param  c the comparator by which the list is ordered.
     *         A &lt;tt&gt;null&lt;/tt&gt; value indicates that the elements'
     *         {@linkplain Comparable natural ordering} should be used.
     * @return the index of the search key, if it is contained in the list;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the list: the index of the first
     *         element greater than the key, or &lt;tt&gt;list.size()&lt;/tt&gt; if all
     *         elements in the list are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws ClassCastException if the list contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator,
     *         or the search key is not mutually comparable with the
     *         elements of the list using this comparator.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) {
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (c==null)</span>
<span class="nc" id="L377">            return binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt;) list, key);</span>

<span class="nc bnc" id="L379" title="All 4 branches missed.">        if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span>
<span class="nc" id="L380">            return Collections.indexedBinarySearch(list, key, c);</span>
        else
<span class="nc" id="L382">            return Collections.iteratorBinarySearch(list, key, c);</span>
    }

    private static &lt;T&gt; int indexedBinarySearch(List&lt;? extends T&gt; l, T key, Comparator&lt;? super T&gt; c) {
<span class="nc" id="L386">        int low = 0;</span>
<span class="nc" id="L387">        int high = l.size()-1;</span>

<span class="nc bnc" id="L389" title="All 2 branches missed.">        while (low &lt;= high) {</span>
<span class="nc" id="L390">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L391">            T midVal = l.get(mid);</span>
<span class="nc" id="L392">            int cmp = c.compare(midVal, key);</span>

<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (cmp &lt; 0)</span>
<span class="nc" id="L395">                low = mid + 1;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            else if (cmp &gt; 0)</span>
<span class="nc" id="L397">                high = mid - 1;</span>
            else
<span class="nc" id="L399">                return mid; // key found</span>
<span class="nc" id="L400">        }</span>
<span class="nc" id="L401">        return -(low + 1);  // key not found</span>
    }

    private static &lt;T&gt; int iteratorBinarySearch(List&lt;? extends T&gt; l, T key, Comparator&lt;? super T&gt; c) {
<span class="nc" id="L405">        int low = 0;</span>
<span class="nc" id="L406">        int high = l.size()-1;</span>
<span class="nc" id="L407">        ListIterator&lt;? extends T&gt; i = l.listIterator();</span>

<span class="nc bnc" id="L409" title="All 2 branches missed.">        while (low &lt;= high) {</span>
<span class="nc" id="L410">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L411">            T midVal = get(i, mid);</span>
<span class="nc" id="L412">            int cmp = c.compare(midVal, key);</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">            if (cmp &lt; 0)</span>
<span class="nc" id="L415">                low = mid + 1;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">            else if (cmp &gt; 0)</span>
<span class="nc" id="L417">                high = mid - 1;</span>
            else
<span class="nc" id="L419">                return mid; // key found</span>
<span class="nc" id="L420">        }</span>
<span class="nc" id="L421">        return -(low + 1);  // key not found</span>
    }

    /**
     * Reverses the order of the elements in the specified list.&lt;p&gt;
     *
     * This method runs in linear time.
     *
     * @param  list the list whose elements are to be reversed.
     * @throws UnsupportedOperationException if the specified list or
     *         its list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.
     */
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public static void reverse(List&lt;?&gt; list) {
<span class="nc" id="L435">        int size = list.size();</span>
<span class="nc bnc" id="L436" title="All 4 branches missed.">        if (size &lt; REVERSE_THRESHOLD || list instanceof RandomAccess) {</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            for (int i=0, mid=size&gt;&gt;1, j=size-1; i&lt;mid; i++, j--)</span>
<span class="nc" id="L438">                swap(list, i, j);</span>
        } else {
            // instead of using a raw type here, it's possible to capture
            // the wildcard but it will require a call to a supplementary
            // private method
<span class="nc" id="L443">            ListIterator fwd = list.listIterator();</span>
<span class="nc" id="L444">            ListIterator rev = list.listIterator(size);</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            for (int i=0, mid=list.size()&gt;&gt;1; i&lt;mid; i++) {</span>
<span class="nc" id="L446">                Object tmp = fwd.next();</span>
<span class="nc" id="L447">                fwd.set(rev.previous());</span>
<span class="nc" id="L448">                rev.set(tmp);</span>
            }
        }
<span class="nc" id="L451">    }</span>

    /**
     * Randomly permutes the specified list using a default source of
     * randomness.  All permutations occur with approximately equal
     * likelihood.
     *
     * &lt;p&gt;The hedge &quot;approximately&quot; is used in the foregoing description because
     * default source of randomness is only approximately an unbiased source
     * of independently chosen bits. If it were a perfect source of randomly
     * chosen bits, then the algorithm would choose permutations with perfect
     * uniformity.
     *
     * &lt;p&gt;This implementation traverses the list backwards, from the last
     * element up to the second, repeatedly swapping a randomly selected element
     * into the &quot;current position&quot;.  Elements are randomly selected from the
     * portion of the list that runs from the first element to the current
     * position, inclusive.
     *
     * &lt;p&gt;This method runs in linear time.  If the specified list does not
     * implement the {@link RandomAccess} interface and is large, this
     * implementation dumps the specified list into an array before shuffling
     * it, and dumps the shuffled array back into the list.  This avoids the
     * quadratic behavior that would result from shuffling a &quot;sequential
     * access&quot; list in place.
     *
     * @param  list the list to be shuffled.
     * @throws UnsupportedOperationException if the specified list or
     *         its list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.
     */
    public static void shuffle(List&lt;?&gt; list) {
<span class="nc" id="L482">        Random rnd = r;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (rnd == null)</span>
<span class="nc" id="L484">            r = rnd = new Random(); // harmless race.</span>
<span class="nc" id="L485">        shuffle(list, rnd);</span>
<span class="nc" id="L486">    }</span>

    private static Random r;

    /**
     * Randomly permute the specified list using the specified source of
     * randomness.  All permutations occur with equal likelihood
     * assuming that the source of randomness is fair.&lt;p&gt;
     *
     * This implementation traverses the list backwards, from the last element
     * up to the second, repeatedly swapping a randomly selected element into
     * the &quot;current position&quot;.  Elements are randomly selected from the
     * portion of the list that runs from the first element to the current
     * position, inclusive.&lt;p&gt;
     *
     * This method runs in linear time.  If the specified list does not
     * implement the {@link RandomAccess} interface and is large, this
     * implementation dumps the specified list into an array before shuffling
     * it, and dumps the shuffled array back into the list.  This avoids the
     * quadratic behavior that would result from shuffling a &quot;sequential
     * access&quot; list in place.
     *
     * @param  list the list to be shuffled.
     * @param  rnd the source of randomness to use to shuffle the list.
     * @throws UnsupportedOperationException if the specified list or its
     *         list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.
     */
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public static void shuffle(List&lt;?&gt; list, Random rnd) {
<span class="nc" id="L515">        int size = list.size();</span>
<span class="nc bnc" id="L516" title="All 4 branches missed.">        if (size &lt; SHUFFLE_THRESHOLD || list instanceof RandomAccess) {</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">            for (int i=size; i&gt;1; i--)</span>
<span class="nc" id="L518">                swap(list, i-1, rnd.nextInt(i));</span>
        } else {
<span class="nc" id="L520">            Object arr[] = list.toArray();</span>

            // Shuffle array
<span class="nc bnc" id="L523" title="All 2 branches missed.">            for (int i=size; i&gt;1; i--)</span>
<span class="nc" id="L524">                swap(arr, i-1, rnd.nextInt(i));</span>

            // Dump array back into list
            // instead of using a raw type here, it's possible to capture
            // the wildcard but it will require a call to a supplementary
            // private method
<span class="nc" id="L530">            ListIterator it = list.listIterator();</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">            for (int i=0; i&lt;arr.length; i++) {</span>
<span class="nc" id="L532">                it.next();</span>
<span class="nc" id="L533">                it.set(arr[i]);</span>
            }
        }
<span class="nc" id="L536">    }</span>

    /**
     * Swaps the elements at the specified positions in the specified list.
     * (If the specified positions are equal, invoking this method leaves
     * the list unchanged.)
     *
     * @param list The list in which to swap elements.
     * @param i the index of one element to be swapped.
     * @param j the index of the other element to be swapped.
     * @throws IndexOutOfBoundsException if either &lt;tt&gt;i&lt;/tt&gt; or &lt;tt&gt;j&lt;/tt&gt;
     *         is out of range (i &amp;lt; 0 || i &amp;gt;= list.size()
     *         || j &amp;lt; 0 || j &amp;gt;= list.size()).
     * @since 1.4
     */
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public static void swap(List&lt;?&gt; list, int i, int j) {
        // instead of using a raw type here, it's possible to capture
        // the wildcard but it will require a call to a supplementary
        // private method
<span class="nc" id="L556">        final List l = list;</span>
<span class="nc" id="L557">        l.set(i, l.set(j, l.get(i)));</span>
<span class="nc" id="L558">    }</span>

    /**
     * Swaps the two specified elements in the specified array.
     */
    private static void swap(Object[] arr, int i, int j) {
<span class="nc" id="L564">        Object tmp = arr[i];</span>
<span class="nc" id="L565">        arr[i] = arr[j];</span>
<span class="nc" id="L566">        arr[j] = tmp;</span>
<span class="nc" id="L567">    }</span>

    /**
     * Replaces all of the elements of the specified list with the specified
     * element. &lt;p&gt;
     *
     * This method runs in linear time.
     *
     * @param  &lt;T&gt; the class of the objects in the list
     * @param  list the list to be filled with the specified element.
     * @param  obj The element with which to fill the specified list.
     * @throws UnsupportedOperationException if the specified list or its
     *         list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.
     */
    public static &lt;T&gt; void fill(List&lt;? super T&gt; list, T obj) {
<span class="nc" id="L582">        int size = list.size();</span>

<span class="nc bnc" id="L584" title="All 4 branches missed.">        if (size &lt; FILL_THRESHOLD || list instanceof RandomAccess) {</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">            for (int i=0; i&lt;size; i++)</span>
<span class="nc" id="L586">                list.set(i, obj);</span>
        } else {
<span class="nc" id="L588">            ListIterator&lt;? super T&gt; itr = list.listIterator();</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">            for (int i=0; i&lt;size; i++) {</span>
<span class="nc" id="L590">                itr.next();</span>
<span class="nc" id="L591">                itr.set(obj);</span>
            }
        }
<span class="nc" id="L594">    }</span>

    /**
     * Copies all of the elements from one list into another.  After the
     * operation, the index of each copied element in the destination list
     * will be identical to its index in the source list.  The destination
     * list must be at least as long as the source list.  If it is longer, the
     * remaining elements in the destination list are unaffected. &lt;p&gt;
     *
     * This method runs in linear time.
     *
     * @param  &lt;T&gt; the class of the objects in the lists
     * @param  dest The destination list.
     * @param  src The source list.
     * @throws IndexOutOfBoundsException if the destination list is too small
     *         to contain the entire source List.
     * @throws UnsupportedOperationException if the destination list's
     *         list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.
     */
    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
<span class="nc" id="L614">        int srcSize = src.size();</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">        if (srcSize &gt; dest.size())</span>
<span class="nc" id="L616">            throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);</span>

<span class="nc bnc" id="L618" title="All 6 branches missed.">        if (srcSize &lt; COPY_THRESHOLD ||</span>
            (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) {
<span class="nc bnc" id="L620" title="All 2 branches missed.">            for (int i=0; i&lt;srcSize; i++)</span>
<span class="nc" id="L621">                dest.set(i, src.get(i));</span>
        } else {
<span class="nc" id="L623">            ListIterator&lt;? super T&gt; di=dest.listIterator();</span>
<span class="nc" id="L624">            ListIterator&lt;? extends T&gt; si=src.listIterator();</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">            for (int i=0; i&lt;srcSize; i++) {</span>
<span class="nc" id="L626">                di.next();</span>
<span class="nc" id="L627">                di.set(si.next());</span>
            }
        }
<span class="nc" id="L630">    }</span>

    /**
     * Returns the minimum element of the given collection, according to the
     * &lt;i&gt;natural ordering&lt;/i&gt; of its elements.  All elements in the
     * collection must implement the &lt;tt&gt;Comparable&lt;/tt&gt; interface.
     * Furthermore, all elements in the collection must be &lt;i&gt;mutually
     * comparable&lt;/i&gt; (that is, &lt;tt&gt;e1.compareTo(e2)&lt;/tt&gt; must not throw a
     * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
     * &lt;tt&gt;e2&lt;/tt&gt; in the collection).&lt;p&gt;
     *
     * This method iterates over the entire collection, hence it requires
     * time proportional to the size of the collection.
     *
     * @param  &lt;T&gt; the class of the objects in the collection
     * @param  coll the collection whose minimum element is to be determined.
     * @return the minimum element of the given collection, according
     *         to the &lt;i&gt;natural ordering&lt;/i&gt; of its elements.
     * @throws ClassCastException if the collection contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
     *         integers).
     * @throws NoSuchElementException if the collection is empty.
     * @see Comparable
     */
    public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll) {
<span class="nc" id="L655">        Iterator&lt;? extends T&gt; i = coll.iterator();</span>
<span class="nc" id="L656">        T candidate = i.next();</span>

<span class="nc bnc" id="L658" title="All 2 branches missed.">        while (i.hasNext()) {</span>
<span class="nc" id="L659">            T next = i.next();</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">            if (next.compareTo(candidate) &lt; 0)</span>
<span class="nc" id="L661">                candidate = next;</span>
<span class="nc" id="L662">        }</span>
<span class="nc" id="L663">        return candidate;</span>
    }

    /**
     * Returns the minimum element of the given collection, according to the
     * order induced by the specified comparator.  All elements in the
     * collection must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified
     * comparator (that is, &lt;tt&gt;comp.compare(e1, e2)&lt;/tt&gt; must not throw a
     * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
     * &lt;tt&gt;e2&lt;/tt&gt; in the collection).&lt;p&gt;
     *
     * This method iterates over the entire collection, hence it requires
     * time proportional to the size of the collection.
     *
     * @param  &lt;T&gt; the class of the objects in the collection
     * @param  coll the collection whose minimum element is to be determined.
     * @param  comp the comparator with which to determine the minimum element.
     *         A &lt;tt&gt;null&lt;/tt&gt; value indicates that the elements' &lt;i&gt;natural
     *         ordering&lt;/i&gt; should be used.
     * @return the minimum element of the given collection, according
     *         to the specified comparator.
     * @throws ClassCastException if the collection contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.
     * @throws NoSuchElementException if the collection is empty.
     * @see Comparable
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    public static &lt;T&gt; T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp) {
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (comp==null)</span>
<span class="nc" id="L692">            return (T)min((Collection) coll);</span>

<span class="nc" id="L694">        Iterator&lt;? extends T&gt; i = coll.iterator();</span>
<span class="nc" id="L695">        T candidate = i.next();</span>

<span class="nc bnc" id="L697" title="All 2 branches missed.">        while (i.hasNext()) {</span>
<span class="nc" id="L698">            T next = i.next();</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">            if (comp.compare(next, candidate) &lt; 0)</span>
<span class="nc" id="L700">                candidate = next;</span>
<span class="nc" id="L701">        }</span>
<span class="nc" id="L702">        return candidate;</span>
    }

    /**
     * Returns the maximum element of the given collection, according to the
     * &lt;i&gt;natural ordering&lt;/i&gt; of its elements.  All elements in the
     * collection must implement the &lt;tt&gt;Comparable&lt;/tt&gt; interface.
     * Furthermore, all elements in the collection must be &lt;i&gt;mutually
     * comparable&lt;/i&gt; (that is, &lt;tt&gt;e1.compareTo(e2)&lt;/tt&gt; must not throw a
     * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
     * &lt;tt&gt;e2&lt;/tt&gt; in the collection).&lt;p&gt;
     *
     * This method iterates over the entire collection, hence it requires
     * time proportional to the size of the collection.
     *
     * @param  &lt;T&gt; the class of the objects in the collection
     * @param  coll the collection whose maximum element is to be determined.
     * @return the maximum element of the given collection, according
     *         to the &lt;i&gt;natural ordering&lt;/i&gt; of its elements.
     * @throws ClassCastException if the collection contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
     *         integers).
     * @throws NoSuchElementException if the collection is empty.
     * @see Comparable
     */
    public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll) {
<span class="nc" id="L728">        Iterator&lt;? extends T&gt; i = coll.iterator();</span>
<span class="nc" id="L729">        T candidate = i.next();</span>

<span class="nc bnc" id="L731" title="All 2 branches missed.">        while (i.hasNext()) {</span>
<span class="nc" id="L732">            T next = i.next();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">            if (next.compareTo(candidate) &gt; 0)</span>
<span class="nc" id="L734">                candidate = next;</span>
<span class="nc" id="L735">        }</span>
<span class="nc" id="L736">        return candidate;</span>
    }

    /**
     * Returns the maximum element of the given collection, according to the
     * order induced by the specified comparator.  All elements in the
     * collection must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified
     * comparator (that is, &lt;tt&gt;comp.compare(e1, e2)&lt;/tt&gt; must not throw a
     * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
     * &lt;tt&gt;e2&lt;/tt&gt; in the collection).&lt;p&gt;
     *
     * This method iterates over the entire collection, hence it requires
     * time proportional to the size of the collection.
     *
     * @param  &lt;T&gt; the class of the objects in the collection
     * @param  coll the collection whose maximum element is to be determined.
     * @param  comp the comparator with which to determine the maximum element.
     *         A &lt;tt&gt;null&lt;/tt&gt; value indicates that the elements' &lt;i&gt;natural
     *        ordering&lt;/i&gt; should be used.
     * @return the maximum element of the given collection, according
     *         to the specified comparator.
     * @throws ClassCastException if the collection contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.
     * @throws NoSuchElementException if the collection is empty.
     * @see Comparable
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp) {
<span class="nc bnc" id="L764" title="All 2 branches missed.">        if (comp==null)</span>
<span class="nc" id="L765">            return (T)max((Collection) coll);</span>

<span class="nc" id="L767">        Iterator&lt;? extends T&gt; i = coll.iterator();</span>
<span class="nc" id="L768">        T candidate = i.next();</span>

<span class="nc bnc" id="L770" title="All 2 branches missed.">        while (i.hasNext()) {</span>
<span class="nc" id="L771">            T next = i.next();</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">            if (comp.compare(next, candidate) &gt; 0)</span>
<span class="nc" id="L773">                candidate = next;</span>
<span class="nc" id="L774">        }</span>
<span class="nc" id="L775">        return candidate;</span>
    }

    /**
     * Rotates the elements in the specified list by the specified distance.
     * After calling this method, the element at index &lt;tt&gt;i&lt;/tt&gt; will be
     * the element previously at index &lt;tt&gt;(i - distance)&lt;/tt&gt; mod
     * &lt;tt&gt;list.size()&lt;/tt&gt;, for all values of &lt;tt&gt;i&lt;/tt&gt; between &lt;tt&gt;0&lt;/tt&gt;
     * and &lt;tt&gt;list.size()-1&lt;/tt&gt;, inclusive.  (This method has no effect on
     * the size of the list.)
     *
     * &lt;p&gt;For example, suppose &lt;tt&gt;list&lt;/tt&gt; comprises&lt;tt&gt; [t, a, n, k, s]&lt;/tt&gt;.
     * After invoking &lt;tt&gt;Collections.rotate(list, 1)&lt;/tt&gt; (or
     * &lt;tt&gt;Collections.rotate(list, -4)&lt;/tt&gt;), &lt;tt&gt;list&lt;/tt&gt; will comprise
     * &lt;tt&gt;[s, t, a, n, k]&lt;/tt&gt;.
     *
     * &lt;p&gt;Note that this method can usefully be applied to sublists to
     * move one or more elements within a list while preserving the
     * order of the remaining elements.  For example, the following idiom
     * moves the element at index &lt;tt&gt;j&lt;/tt&gt; forward to position
     * &lt;tt&gt;k&lt;/tt&gt; (which must be greater than or equal to &lt;tt&gt;j&lt;/tt&gt;):
     * &lt;pre&gt;
     *     Collections.rotate(list.subList(j, k+1), -1);
     * &lt;/pre&gt;
     * To make this concrete, suppose &lt;tt&gt;list&lt;/tt&gt; comprises
     * &lt;tt&gt;[a, b, c, d, e]&lt;/tt&gt;.  To move the element at index &lt;tt&gt;1&lt;/tt&gt;
     * (&lt;tt&gt;b&lt;/tt&gt;) forward two positions, perform the following invocation:
     * &lt;pre&gt;
     *     Collections.rotate(l.subList(1, 4), -1);
     * &lt;/pre&gt;
     * The resulting list is &lt;tt&gt;[a, c, d, b, e]&lt;/tt&gt;.
     *
     * &lt;p&gt;To move more than one element forward, increase the absolute value
     * of the rotation distance.  To move elements backward, use a positive
     * shift distance.
     *
     * &lt;p&gt;If the specified list is small or implements the {@link
     * RandomAccess} interface, this implementation exchanges the first
     * element into the location it should go, and then repeatedly exchanges
     * the displaced element into the location it should go until a displaced
     * element is swapped into the first element.  If necessary, the process
     * is repeated on the second and successive elements, until the rotation
     * is complete.  If the specified list is large and doesn't implement the
     * &lt;tt&gt;RandomAccess&lt;/tt&gt; interface, this implementation breaks the
     * list into two sublist views around index &lt;tt&gt;-distance mod size&lt;/tt&gt;.
     * Then the {@link #reverse(List)} method is invoked on each sublist view,
     * and finally it is invoked on the entire list.  For a more complete
     * description of both algorithms, see Section 2.3 of Jon Bentley's
     * &lt;i&gt;Programming Pearls&lt;/i&gt; (Addison-Wesley, 1986).
     *
     * @param list the list to be rotated.
     * @param distance the distance to rotate the list.  There are no
     *        constraints on this value; it may be zero, negative, or
     *        greater than &lt;tt&gt;list.size()&lt;/tt&gt;.
     * @throws UnsupportedOperationException if the specified list or
     *         its list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.
     * @since 1.4
     */
    public static void rotate(List&lt;?&gt; list, int distance) {
<span class="nc bnc" id="L834" title="All 4 branches missed.">        if (list instanceof RandomAccess || list.size() &lt; ROTATE_THRESHOLD)</span>
<span class="nc" id="L835">            rotate1(list, distance);</span>
        else
<span class="nc" id="L837">            rotate2(list, distance);</span>
<span class="nc" id="L838">    }</span>

    private static &lt;T&gt; void rotate1(List&lt;T&gt; list, int distance) {
<span class="nc" id="L841">        int size = list.size();</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">        if (size == 0)</span>
<span class="nc" id="L843">            return;</span>
<span class="nc" id="L844">        distance = distance % size;</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">        if (distance &lt; 0)</span>
<span class="nc" id="L846">            distance += size;</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">        if (distance == 0)</span>
<span class="nc" id="L848">            return;</span>

<span class="nc bnc" id="L850" title="All 2 branches missed.">        for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {</span>
<span class="nc" id="L851">            T displaced = list.get(cycleStart);</span>
<span class="nc" id="L852">            int i = cycleStart;</span>
            do {
<span class="nc" id="L854">                i += distance;</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">                if (i &gt;= size)</span>
<span class="nc" id="L856">                    i -= size;</span>
<span class="nc" id="L857">                displaced = list.set(i, displaced);</span>
<span class="nc" id="L858">                nMoved ++;</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            } while (i != cycleStart);</span>
        }
<span class="nc" id="L861">    }</span>

    private static void rotate2(List&lt;?&gt; list, int distance) {
<span class="nc" id="L864">        int size = list.size();</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">        if (size == 0)</span>
<span class="nc" id="L866">            return;</span>
<span class="nc" id="L867">        int mid =  -distance % size;</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">        if (mid &lt; 0)</span>
<span class="nc" id="L869">            mid += size;</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (mid == 0)</span>
<span class="nc" id="L871">            return;</span>

<span class="nc" id="L873">        reverse(list.subList(0, mid));</span>
<span class="nc" id="L874">        reverse(list.subList(mid, size));</span>
<span class="nc" id="L875">        reverse(list);</span>
<span class="nc" id="L876">    }</span>

    /**
     * Replaces all occurrences of one specified value in a list with another.
     * More formally, replaces with &lt;tt&gt;newVal&lt;/tt&gt; each element &lt;tt&gt;e&lt;/tt&gt;
     * in &lt;tt&gt;list&lt;/tt&gt; such that
     * &lt;tt&gt;(oldVal==null ? e==null : oldVal.equals(e))&lt;/tt&gt;.
     * (This method has no effect on the size of the list.)
     *
     * @param  &lt;T&gt; the class of the objects in the list
     * @param list the list in which replacement is to occur.
     * @param oldVal the old value to be replaced.
     * @param newVal the new value with which &lt;tt&gt;oldVal&lt;/tt&gt; is to be
     *        replaced.
     * @return &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;list&lt;/tt&gt; contained one or more elements
     *         &lt;tt&gt;e&lt;/tt&gt; such that
     *         &lt;tt&gt;(oldVal==null ?  e==null : oldVal.equals(e))&lt;/tt&gt;.
     * @throws UnsupportedOperationException if the specified list or
     *         its list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.
     * @since  1.4
     */
    public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list, T oldVal, T newVal) {
<span class="nc" id="L898">        boolean result = false;</span>
<span class="nc" id="L899">        int size = list.size();</span>
<span class="nc bnc" id="L900" title="All 4 branches missed.">        if (size &lt; REPLACEALL_THRESHOLD || list instanceof RandomAccess) {</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">            if (oldVal==null) {</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">                for (int i=0; i&lt;size; i++) {</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">                    if (list.get(i)==null) {</span>
<span class="nc" id="L904">                        list.set(i, newVal);</span>
<span class="nc" id="L905">                        result = true;</span>
                    }
                }
            } else {
<span class="nc bnc" id="L909" title="All 2 branches missed.">                for (int i=0; i&lt;size; i++) {</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">                    if (oldVal.equals(list.get(i))) {</span>
<span class="nc" id="L911">                        list.set(i, newVal);</span>
<span class="nc" id="L912">                        result = true;</span>
                    }
                }
            }
        } else {
<span class="nc" id="L917">            ListIterator&lt;T&gt; itr=list.listIterator();</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">            if (oldVal==null) {</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">                for (int i=0; i&lt;size; i++) {</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">                    if (itr.next()==null) {</span>
<span class="nc" id="L921">                        itr.set(newVal);</span>
<span class="nc" id="L922">                        result = true;</span>
                    }
                }
            } else {
<span class="nc bnc" id="L926" title="All 2 branches missed.">                for (int i=0; i&lt;size; i++) {</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">                    if (oldVal.equals(itr.next())) {</span>
<span class="nc" id="L928">                        itr.set(newVal);</span>
<span class="nc" id="L929">                        result = true;</span>
                    }
                }
            }
        }
<span class="nc" id="L934">        return result;</span>
    }

    /**
     * Returns the starting position of the first occurrence of the specified
     * target list within the specified source list, or -1 if there is no
     * such occurrence.  More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt;
     * such that {@code source.subList(i, i+target.size()).equals(target)},
     * or -1 if there is no such index.  (Returns -1 if
     * {@code target.size() &gt; source.size()})
     *
     * &lt;p&gt;This implementation uses the &quot;brute force&quot; technique of scanning
     * over the source list, looking for a match with the target at each
     * location in turn.
     *
     * @param source the list in which to search for the first occurrence
     *        of &lt;tt&gt;target&lt;/tt&gt;.
     * @param target the list to search for as a subList of &lt;tt&gt;source&lt;/tt&gt;.
     * @return the starting position of the first occurrence of the specified
     *         target list within the specified source list, or -1 if there
     *         is no such occurrence.
     * @since  1.4
     */
    public static int indexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target) {
<span class="nc" id="L958">        int sourceSize = source.size();</span>
<span class="nc" id="L959">        int targetSize = target.size();</span>
<span class="nc" id="L960">        int maxCandidate = sourceSize - targetSize;</span>

<span class="nc bnc" id="L962" title="All 6 branches missed.">        if (sourceSize &lt; INDEXOFSUBLIST_THRESHOLD ||</span>
            (source instanceof RandomAccess&amp;&amp;target instanceof RandomAccess)) {
        nextCand:
<span class="nc bnc" id="L965" title="All 2 branches missed.">            for (int candidate = 0; candidate &lt;= maxCandidate; candidate++) {</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">                for (int i=0, j=candidate; i&lt;targetSize; i++, j++)</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">                    if (!eq(target.get(i), source.get(j)))</span>
<span class="nc" id="L968">                        continue nextCand;  // Element mismatch, try next cand</span>
<span class="nc" id="L969">                return candidate;  // All elements of candidate matched target</span>
            }
        } else {  // Iterator version of above algorithm
<span class="nc" id="L972">            ListIterator&lt;?&gt; si = source.listIterator();</span>
        nextCand:
<span class="nc bnc" id="L974" title="All 2 branches missed.">            for (int candidate = 0; candidate &lt;= maxCandidate; candidate++) {</span>
<span class="nc" id="L975">                ListIterator&lt;?&gt; ti = target.listIterator();</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">                for (int i=0; i&lt;targetSize; i++) {</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">                    if (!eq(ti.next(), si.next())) {</span>
                        // Back up source iterator to next candidate
<span class="nc bnc" id="L979" title="All 2 branches missed.">                        for (int j=0; j&lt;i; j++)</span>
<span class="nc" id="L980">                            si.previous();</span>
<span class="nc" id="L981">                        continue nextCand;</span>
                    }
                }
<span class="nc" id="L984">                return candidate;</span>
            }
        }
<span class="nc" id="L987">        return -1;  // No candidate matched the target</span>
    }

    /**
     * Returns the starting position of the last occurrence of the specified
     * target list within the specified source list, or -1 if there is no such
     * occurrence.  More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt;
     * such that {@code source.subList(i, i+target.size()).equals(target)},
     * or -1 if there is no such index.  (Returns -1 if
     * {@code target.size() &gt; source.size()})
     *
     * &lt;p&gt;This implementation uses the &quot;brute force&quot; technique of iterating
     * over the source list, looking for a match with the target at each
     * location in turn.
     *
     * @param source the list in which to search for the last occurrence
     *        of &lt;tt&gt;target&lt;/tt&gt;.
     * @param target the list to search for as a subList of &lt;tt&gt;source&lt;/tt&gt;.
     * @return the starting position of the last occurrence of the specified
     *         target list within the specified source list, or -1 if there
     *         is no such occurrence.
     * @since  1.4
     */
    public static int lastIndexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target) {
<span class="nc" id="L1011">        int sourceSize = source.size();</span>
<span class="nc" id="L1012">        int targetSize = target.size();</span>
<span class="nc" id="L1013">        int maxCandidate = sourceSize - targetSize;</span>

<span class="nc bnc" id="L1015" title="All 4 branches missed.">        if (sourceSize &lt; INDEXOFSUBLIST_THRESHOLD ||</span>
            source instanceof RandomAccess) {   // Index access version
        nextCand:
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            for (int candidate = maxCandidate; candidate &gt;= 0; candidate--) {</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                for (int i=0, j=candidate; i&lt;targetSize; i++, j++)</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">                    if (!eq(target.get(i), source.get(j)))</span>
<span class="nc" id="L1021">                        continue nextCand;  // Element mismatch, try next cand</span>
<span class="nc" id="L1022">                return candidate;  // All elements of candidate matched target</span>
            }
        } else {  // Iterator version of above algorithm
<span class="nc bnc" id="L1025" title="All 2 branches missed.">            if (maxCandidate &lt; 0)</span>
<span class="nc" id="L1026">                return -1;</span>
<span class="nc" id="L1027">            ListIterator&lt;?&gt; si = source.listIterator(maxCandidate);</span>
        nextCand:
<span class="nc bnc" id="L1029" title="All 2 branches missed.">            for (int candidate = maxCandidate; candidate &gt;= 0; candidate--) {</span>
<span class="nc" id="L1030">                ListIterator&lt;?&gt; ti = target.listIterator();</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">                for (int i=0; i&lt;targetSize; i++) {</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                    if (!eq(ti.next(), si.next())) {</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">                        if (candidate != 0) {</span>
                            // Back up source iterator to next candidate
<span class="nc bnc" id="L1035" title="All 2 branches missed.">                            for (int j=0; j&lt;=i+1; j++)</span>
<span class="nc" id="L1036">                                si.previous();</span>
                        }
                        continue nextCand;
                    }
                }
<span class="nc" id="L1041">                return candidate;</span>
            }
        }
<span class="nc" id="L1044">        return -1;  // No candidate matched the target</span>
    }


    // Unmodifiable Wrappers

    /**
     * Returns an unmodifiable view of the specified collection.  This method
     * allows modules to provide users with &quot;read-only&quot; access to internal
     * collections.  Query operations on the returned collection &quot;read through&quot;
     * to the specified collection, and attempts to modify the returned
     * collection, whether direct or via its iterator, result in an
     * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
     *
     * The returned collection does &lt;i&gt;not&lt;/i&gt; pass the hashCode and equals
     * operations through to the backing collection, but relies on
     * &lt;tt&gt;Object&lt;/tt&gt;'s &lt;tt&gt;equals&lt;/tt&gt; and &lt;tt&gt;hashCode&lt;/tt&gt; methods.  This
     * is necessary to preserve the contracts of these operations in the case
     * that the backing collection is a set or a list.&lt;p&gt;
     *
     * The returned collection will be serializable if the specified collection
     * is serializable.
     *
     * @param  &lt;T&gt; the class of the objects in the collection
     * @param  c the collection for which an unmodifiable view is to be
     *         returned.
     * @return an unmodifiable view of the specified collection.
     */
    public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) {
<span class="nc" id="L1073">        return new UnmodifiableCollection&lt;&gt;(c);</span>
    }

    /**
     * @serial include
     */
    static class UnmodifiableCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {
        private static final long serialVersionUID = 1820017752578914078L;

        final Collection&lt;? extends E&gt; c;

<span class="fc" id="L1084">        UnmodifiableCollection(Collection&lt;? extends E&gt; c) {</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">            if (c==null)</span>
<span class="fc" id="L1086">                throw new NullPointerException();</span>
<span class="fc" id="L1087">            this.c = c;</span>
<span class="fc" id="L1088">        }</span>

<span class="fc" id="L1090">        public int size()                   {return c.size();}</span>
<span class="fc" id="L1091">        public boolean isEmpty()            {return c.isEmpty();}</span>
<span class="fc" id="L1092">        public boolean contains(Object o)   {return c.contains(o);}</span>
<span class="fc" id="L1093">        public Object[] toArray()           {return c.toArray();}</span>
<span class="fc" id="L1094">        public &lt;T&gt; T[] toArray(T[] a)       {return c.toArray(a);}</span>
<span class="fc" id="L1095">        public String toString()            {return c.toString();}</span>

        public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L1098">            return new Iterator&lt;E&gt;() {</span>
<span class="fc" id="L1099">                private final Iterator&lt;? extends E&gt; i = c.iterator();</span>

<span class="fc" id="L1101">                public boolean hasNext() {return i.hasNext();}</span>
<span class="fc" id="L1102">                public E next()          {return i.next();}</span>
                public void remove() {
<span class="fc" id="L1104">                    throw new UnsupportedOperationException();</span>
                }
                @Override
                public void forEachRemaining(Consumer&lt;? super E&gt; action) {
                    // Use backing collection version
<span class="nc" id="L1109">                    i.forEachRemaining(action);</span>
<span class="nc" id="L1110">                }</span>
            };
        }

        public boolean add(E e) {
<span class="fc" id="L1115">            throw new UnsupportedOperationException();</span>
        }
        public boolean remove(Object o) {
<span class="fc" id="L1118">            throw new UnsupportedOperationException();</span>
        }

        public boolean containsAll(Collection&lt;?&gt; coll) {
<span class="nc" id="L1122">            return c.containsAll(coll);</span>
        }
        public boolean addAll(Collection&lt;? extends E&gt; coll) {
<span class="fc" id="L1125">            throw new UnsupportedOperationException();</span>
        }
        public boolean removeAll(Collection&lt;?&gt; coll) {
<span class="fc" id="L1128">            throw new UnsupportedOperationException();</span>
        }
        public boolean retainAll(Collection&lt;?&gt; coll) {
<span class="fc" id="L1131">            throw new UnsupportedOperationException();</span>
        }
        public void clear() {
<span class="fc" id="L1134">            throw new UnsupportedOperationException();</span>
        }

        // Override default methods in Collection
        @Override
        public void forEach(Consumer&lt;? super E&gt; action) {
<span class="nc" id="L1140">            c.forEach(action);</span>
<span class="nc" id="L1141">        }</span>
        @Override
        public boolean removeIf(Predicate&lt;? super E&gt; filter) {
<span class="nc" id="L1144">            throw new UnsupportedOperationException();</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Spliterator&lt;E&gt; spliterator() {
<span class="nc" id="L1149">            return (Spliterator&lt;E&gt;)c.spliterator();</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Stream&lt;E&gt; stream() {
<span class="nc" id="L1154">            return (Stream&lt;E&gt;)c.stream();</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Stream&lt;E&gt; parallelStream() {
<span class="nc" id="L1159">            return (Stream&lt;E&gt;)c.parallelStream();</span>
        }
    }

    /**
     * Returns an unmodifiable view of the specified set.  This method allows
     * modules to provide users with &quot;read-only&quot; access to internal sets.
     * Query operations on the returned set &quot;read through&quot; to the specified
     * set, and attempts to modify the returned set, whether direct or via its
     * iterator, result in an &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
     *
     * The returned set will be serializable if the specified set
     * is serializable.
     *
     * @param  &lt;T&gt; the class of the objects in the set
     * @param  s the set for which an unmodifiable view is to be returned.
     * @return an unmodifiable view of the specified set.
     */
    public static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s) {
<span class="nc" id="L1178">        return new UnmodifiableSet&lt;&gt;(s);</span>
    }

    /**
     * @serial include
     */
    static class UnmodifiableSet&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;
                                 implements Set&lt;E&gt;, Serializable {
        private static final long serialVersionUID = -9215047833775013803L;

<span class="fc" id="L1188">        UnmodifiableSet(Set&lt;? extends E&gt; s)     {super(s);}</span>
<span class="pc bpc" id="L1189" title="2 of 4 branches missed.">        public boolean equals(Object o) {return o == this || c.equals(o);}</span>
<span class="fc" id="L1190">        public int hashCode()           {return c.hashCode();}</span>
    }

    /**
     * Returns an unmodifiable view of the specified sorted set.  This method
     * allows modules to provide users with &quot;read-only&quot; access to internal
     * sorted sets.  Query operations on the returned sorted set &quot;read
     * through&quot; to the specified sorted set.  Attempts to modify the returned
     * sorted set, whether direct, via its iterator, or via its
     * &lt;tt&gt;subSet&lt;/tt&gt;, &lt;tt&gt;headSet&lt;/tt&gt;, or &lt;tt&gt;tailSet&lt;/tt&gt; views, result in
     * an &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
     *
     * The returned sorted set will be serializable if the specified sorted set
     * is serializable.
     *
     * @param  &lt;T&gt; the class of the objects in the set
     * @param s the sorted set for which an unmodifiable view is to be
     *        returned.
     * @return an unmodifiable view of the specified sorted set.
     */
    public static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;T&gt; s) {
<span class="nc" id="L1211">        return new UnmodifiableSortedSet&lt;&gt;(s);</span>
    }

    /**
     * @serial include
     */
    static class UnmodifiableSortedSet&lt;E&gt;
                             extends UnmodifiableSet&lt;E&gt;
                             implements SortedSet&lt;E&gt;, Serializable {
        private static final long serialVersionUID = -4929149591599911165L;
        private final SortedSet&lt;E&gt; ss;

<span class="fc" id="L1223">        UnmodifiableSortedSet(SortedSet&lt;E&gt; s) {super(s); ss = s;}</span>

<span class="nc" id="L1225">        public Comparator&lt;? super E&gt; comparator() {return ss.comparator();}</span>

        public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
<span class="nc" id="L1228">            return new UnmodifiableSortedSet&lt;&gt;(ss.subSet(fromElement,toElement));</span>
        }
        public SortedSet&lt;E&gt; headSet(E toElement) {
<span class="nc" id="L1231">            return new UnmodifiableSortedSet&lt;&gt;(ss.headSet(toElement));</span>
        }
        public SortedSet&lt;E&gt; tailSet(E fromElement) {
<span class="nc" id="L1234">            return new UnmodifiableSortedSet&lt;&gt;(ss.tailSet(fromElement));</span>
        }

<span class="nc" id="L1237">        public E first()                   {return ss.first();}</span>
<span class="nc" id="L1238">        public E last()                    {return ss.last();}</span>
    }

    /**
     * Returns an unmodifiable view of the specified navigable set.  This method
     * allows modules to provide users with &quot;read-only&quot; access to internal
     * navigable sets.  Query operations on the returned navigable set &quot;read
     * through&quot; to the specified navigable set.  Attempts to modify the returned
     * navigable set, whether direct, via its iterator, or via its
     * {@code subSet}, {@code headSet}, or {@code tailSet} views, result in
     * an {@code UnsupportedOperationException}.&lt;p&gt;
     *
     * The returned navigable set will be serializable if the specified
     * navigable set is serializable.
     *
     * @param  &lt;T&gt; the class of the objects in the set
     * @param s the navigable set for which an unmodifiable view is to be
     *        returned
     * @return an unmodifiable view of the specified navigable set
     * @since 1.8
     */
    public static &lt;T&gt; NavigableSet&lt;T&gt; unmodifiableNavigableSet(NavigableSet&lt;T&gt; s) {
<span class="nc" id="L1260">        return new UnmodifiableNavigableSet&lt;&gt;(s);</span>
    }

    /**
     * Wraps a navigable set and disables all of the mutative operations.
     *
     * @param &lt;E&gt; type of elements
     * @serial include
     */
    static class UnmodifiableNavigableSet&lt;E&gt;
                             extends UnmodifiableSortedSet&lt;E&gt;
                             implements NavigableSet&lt;E&gt;, Serializable {

        private static final long serialVersionUID = -6027448201786391929L;

        /**
         * A singleton empty unmodifiable navigable set used for
         * {@link #emptyNavigableSet()}.
         *
         * @param &lt;E&gt; type of elements, if there were any, and bounds
         */
        private static class EmptyNavigableSet&lt;E&gt; extends UnmodifiableNavigableSet&lt;E&gt;
            implements Serializable {
            private static final long serialVersionUID = -6291252904449939134L;

            public EmptyNavigableSet() {
<span class="fc" id="L1286">                super(new TreeSet&lt;E&gt;());</span>
<span class="fc" id="L1287">            }</span>

<span class="nc" id="L1289">            private Object readResolve()        { return EMPTY_NAVIGABLE_SET; }</span>
        }

        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L1293">        private static final NavigableSet&lt;?&gt; EMPTY_NAVIGABLE_SET =</span>
                new EmptyNavigableSet&lt;&gt;();

        /**
         * The instance we are protecting.
         */
        private final NavigableSet&lt;E&gt; ns;

<span class="fc" id="L1301">        UnmodifiableNavigableSet(NavigableSet&lt;E&gt; s)         {super(s); ns = s;}</span>

<span class="nc" id="L1303">        public E lower(E e)                             { return ns.lower(e); }</span>
<span class="nc" id="L1304">        public E floor(E e)                             { return ns.floor(e); }</span>
<span class="nc" id="L1305">        public E ceiling(E e)                         { return ns.ceiling(e); }</span>
<span class="nc" id="L1306">        public E higher(E e)                           { return ns.higher(e); }</span>
<span class="nc" id="L1307">        public E pollFirst()     { throw new UnsupportedOperationException(); }</span>
<span class="nc" id="L1308">        public E pollLast()      { throw new UnsupportedOperationException(); }</span>
        public NavigableSet&lt;E&gt; descendingSet()
<span class="fc" id="L1310">                 { return new UnmodifiableNavigableSet&lt;&gt;(ns.descendingSet()); }</span>
        public Iterator&lt;E&gt; descendingIterator()
<span class="fc" id="L1312">                                         { return descendingSet().iterator(); }</span>

        public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
<span class="nc" id="L1315">            return new UnmodifiableNavigableSet&lt;&gt;(</span>
<span class="nc" id="L1316">                ns.subSet(fromElement, fromInclusive, toElement, toInclusive));</span>
        }

        public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
<span class="nc" id="L1320">            return new UnmodifiableNavigableSet&lt;&gt;(</span>
<span class="nc" id="L1321">                ns.headSet(toElement, inclusive));</span>
        }

        public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
<span class="nc" id="L1325">            return new UnmodifiableNavigableSet&lt;&gt;(</span>
<span class="nc" id="L1326">                ns.tailSet(fromElement, inclusive));</span>
        }
    }

    /**
     * Returns an unmodifiable view of the specified list.  This method allows
     * modules to provide users with &quot;read-only&quot; access to internal
     * lists.  Query operations on the returned list &quot;read through&quot; to the
     * specified list, and attempts to modify the returned list, whether
     * direct or via its iterator, result in an
     * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
     *
     * The returned list will be serializable if the specified list
     * is serializable. Similarly, the returned list will implement
     * {@link RandomAccess} if the specified list does.
     *
     * @param  &lt;T&gt; the class of the objects in the list
     * @param  list the list for which an unmodifiable view is to be returned.
     * @return an unmodifiable view of the specified list.
     */
    public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list) {
<span class="nc bnc" id="L1347" title="All 2 branches missed.">        return (list instanceof RandomAccess ?</span>
                new UnmodifiableRandomAccessList&lt;&gt;(list) :
                new UnmodifiableList&lt;&gt;(list));
    }

    /**
     * @serial include
     */
    static class UnmodifiableList&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;
                                  implements List&lt;E&gt; {
        private static final long serialVersionUID = -283967356065247728L;

        final List&lt;? extends E&gt; list;

        UnmodifiableList(List&lt;? extends E&gt; list) {
<span class="fc" id="L1362">            super(list);</span>
<span class="fc" id="L1363">            this.list = list;</span>
<span class="fc" id="L1364">        }</span>

<span class="fc bfc" id="L1366" title="All 4 branches covered.">        public boolean equals(Object o) {return o == this || list.equals(o);}</span>
<span class="nc" id="L1367">        public int hashCode()           {return list.hashCode();}</span>

<span class="fc" id="L1369">        public E get(int index) {return list.get(index);}</span>
        public E set(int index, E element) {
<span class="fc" id="L1371">            throw new UnsupportedOperationException();</span>
        }
        public void add(int index, E element) {
<span class="fc" id="L1374">            throw new UnsupportedOperationException();</span>
        }
        public E remove(int index) {
<span class="nc" id="L1377">            throw new UnsupportedOperationException();</span>
        }
<span class="fc" id="L1379">        public int indexOf(Object o)            {return list.indexOf(o);}</span>
<span class="nc" id="L1380">        public int lastIndexOf(Object o)        {return list.lastIndexOf(o);}</span>
        public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
<span class="fc" id="L1382">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public void replaceAll(UnaryOperator&lt;E&gt; operator) {
<span class="nc" id="L1387">            throw new UnsupportedOperationException();</span>
        }
        @Override
        public void sort(Comparator&lt;? super E&gt; c) {
<span class="nc" id="L1391">            throw new UnsupportedOperationException();</span>
        }

<span class="fc" id="L1394">        public ListIterator&lt;E&gt; listIterator()   {return listIterator(0);}</span>

        public ListIterator&lt;E&gt; listIterator(final int index) {
<span class="fc" id="L1397">            return new ListIterator&lt;E&gt;() {</span>
<span class="fc" id="L1398">                private final ListIterator&lt;? extends E&gt; i</span>
<span class="fc" id="L1399">                    = list.listIterator(index);</span>

<span class="fc" id="L1401">                public boolean hasNext()     {return i.hasNext();}</span>
<span class="fc" id="L1402">                public E next()              {return i.next();}</span>
<span class="fc" id="L1403">                public boolean hasPrevious() {return i.hasPrevious();}</span>
<span class="fc" id="L1404">                public E previous()          {return i.previous();}</span>
<span class="nc" id="L1405">                public int nextIndex()       {return i.nextIndex();}</span>
<span class="nc" id="L1406">                public int previousIndex()   {return i.previousIndex();}</span>

                public void remove() {
<span class="fc" id="L1409">                    throw new UnsupportedOperationException();</span>
                }
                public void set(E e) {
<span class="nc" id="L1412">                    throw new UnsupportedOperationException();</span>
                }
                public void add(E e) {
<span class="nc" id="L1415">                    throw new UnsupportedOperationException();</span>
                }

                @Override
                public void forEachRemaining(Consumer&lt;? super E&gt; action) {
<span class="nc" id="L1420">                    i.forEachRemaining(action);</span>
<span class="nc" id="L1421">                }</span>
            };
        }

        public List&lt;E&gt; subList(int fromIndex, int toIndex) {
<span class="nc" id="L1426">            return new UnmodifiableList&lt;&gt;(list.subList(fromIndex, toIndex));</span>
        }

        /**
         * UnmodifiableRandomAccessList instances are serialized as
         * UnmodifiableList instances to allow them to be deserialized
         * in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList).
         * This method inverts the transformation.  As a beneficial
         * side-effect, it also grafts the RandomAccess marker onto
         * UnmodifiableList instances that were serialized in pre-1.4 JREs.
         *
         * Note: Unfortunately, UnmodifiableRandomAccessList instances
         * serialized in 1.4.1 and deserialized in 1.4 will become
         * UnmodifiableList instances, as this method was missing in 1.4.
         */
        private Object readResolve() {
<span class="pc bpc" id="L1442" title="1 of 2 branches missed.">            return (list instanceof RandomAccess</span>
                    ? new UnmodifiableRandomAccessList&lt;&gt;(list)
                    : this);
        }
    }

    /**
     * @serial include
     */
    static class UnmodifiableRandomAccessList&lt;E&gt; extends UnmodifiableList&lt;E&gt;
                                              implements RandomAccess
    {
        UnmodifiableRandomAccessList(List&lt;? extends E&gt; list) {
<span class="fc" id="L1455">            super(list);</span>
<span class="fc" id="L1456">        }</span>

        public List&lt;E&gt; subList(int fromIndex, int toIndex) {
<span class="fc" id="L1459">            return new UnmodifiableRandomAccessList&lt;&gt;(</span>
<span class="fc" id="L1460">                list.subList(fromIndex, toIndex));</span>
        }

        private static final long serialVersionUID = -2542308836966382001L;

        /**
         * Allows instances to be deserialized in pre-1.4 JREs (which do
         * not have UnmodifiableRandomAccessList).  UnmodifiableList has
         * a readResolve method that inverts this transformation upon
         * deserialization.
         */
        private Object writeReplace() {
<span class="fc" id="L1472">            return new UnmodifiableList&lt;&gt;(list);</span>
        }
    }

    /**
     * Returns an unmodifiable view of the specified map.  This method
     * allows modules to provide users with &quot;read-only&quot; access to internal
     * maps.  Query operations on the returned map &quot;read through&quot;
     * to the specified map, and attempts to modify the returned
     * map, whether direct or via its collection views, result in an
     * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
     *
     * The returned map will be serializable if the specified map
     * is serializable.
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @param  m the map for which an unmodifiable view is to be returned.
     * @return an unmodifiable view of the specified map.
     */
    public static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc" id="L1493">        return new UnmodifiableMap&lt;&gt;(m);</span>
    }

    /**
     * @serial include
     */
    private static class UnmodifiableMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable {
        private static final long serialVersionUID = -1034234728574286014L;

        private final Map&lt;? extends K, ? extends V&gt; m;

<span class="fc" id="L1504">        UnmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) {</span>
<span class="fc bfc" id="L1505" title="All 2 branches covered.">            if (m==null)</span>
<span class="fc" id="L1506">                throw new NullPointerException();</span>
<span class="fc" id="L1507">            this.m = m;</span>
<span class="fc" id="L1508">        }</span>

<span class="fc" id="L1510">        public int size()                        {return m.size();}</span>
<span class="fc" id="L1511">        public boolean isEmpty()                 {return m.isEmpty();}</span>
<span class="fc" id="L1512">        public boolean containsKey(Object key)   {return m.containsKey(key);}</span>
<span class="fc" id="L1513">        public boolean containsValue(Object val) {return m.containsValue(val);}</span>
<span class="fc" id="L1514">        public V get(Object key)                 {return m.get(key);}</span>

        public V put(K key, V value) {
<span class="fc" id="L1517">            throw new UnsupportedOperationException();</span>
        }
        public V remove(Object key) {
<span class="fc" id="L1520">            throw new UnsupportedOperationException();</span>
        }
        public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
<span class="fc" id="L1523">            throw new UnsupportedOperationException();</span>
        }
        public void clear() {
<span class="nc" id="L1526">            throw new UnsupportedOperationException();</span>
        }

<span class="fc" id="L1529">        private transient Set&lt;K&gt; keySet = null;</span>
<span class="fc" id="L1530">        private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;</span>
<span class="fc" id="L1531">        private transient Collection&lt;V&gt; values = null;</span>

        public Set&lt;K&gt; keySet() {
<span class="fc bfc" id="L1534" title="All 2 branches covered.">            if (keySet==null)</span>
<span class="fc" id="L1535">                keySet = unmodifiableSet(m.keySet());</span>
<span class="fc" id="L1536">            return keySet;</span>
        }

        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<span class="fc bfc" id="L1540" title="All 2 branches covered.">            if (entrySet==null)</span>
<span class="fc" id="L1541">                entrySet = new UnmodifiableEntrySet&lt;&gt;(m.entrySet());</span>
<span class="fc" id="L1542">            return entrySet;</span>
        }

        public Collection&lt;V&gt; values() {
<span class="fc bfc" id="L1546" title="All 2 branches covered.">            if (values==null)</span>
<span class="fc" id="L1547">                values = unmodifiableCollection(m.values());</span>
<span class="fc" id="L1548">            return values;</span>
        }

<span class="nc bnc" id="L1551" title="All 4 branches missed.">        public boolean equals(Object o) {return o == this || m.equals(o);}</span>
<span class="nc" id="L1552">        public int hashCode()           {return m.hashCode();}</span>
<span class="fc" id="L1553">        public String toString()        {return m.toString();}</span>

        // Override default methods in Map
        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public V getOrDefault(Object k, V defaultValue) {
            // Safe cast as we don't change the value
<span class="nc" id="L1560">            return ((Map&lt;K, V&gt;)m).getOrDefault(k, defaultValue);</span>
        }

        @Override
        public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<span class="nc" id="L1565">            m.forEach(action);</span>
<span class="nc" id="L1566">        }</span>

        @Override
        public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
<span class="nc" id="L1570">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V putIfAbsent(K key, V value) {
<span class="nc" id="L1575">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean remove(Object key, Object value) {
<span class="nc" id="L1580">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean replace(K key, V oldValue, V newValue) {
<span class="nc" id="L1585">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V replace(K key, V value) {
<span class="nc" id="L1590">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) {
<span class="nc" id="L1595">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V computeIfPresent(K key,
                BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L1601">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V compute(K key,
                BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L1607">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V merge(K key, V value,
                BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L1613">            throw new UnsupportedOperationException();</span>
        }

        /**
         * We need this class in addition to UnmodifiableSet as
         * Map.Entries themselves permit modification of the backing Map
         * via their setValue operation.  This class is subtle: there are
         * many possible attacks that must be thwarted.
         *
         * @serial include
         */
        static class UnmodifiableEntrySet&lt;K,V&gt;
            extends UnmodifiableSet&lt;Map.Entry&lt;K,V&gt;&gt; {
            private static final long serialVersionUID = 7854390611657943733L;

            @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
            UnmodifiableEntrySet(Set&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; s) {
                // Need to cast to raw in order to work around a limitation in the type system
<span class="fc" id="L1631">                super((Set)s);</span>
<span class="fc" id="L1632">            }</span>

            static &lt;K, V&gt; Consumer&lt;Map.Entry&lt;K, V&gt;&gt; entryConsumer(Consumer&lt;? super Entry&lt;K, V&gt;&gt; action) {
<span class="nc" id="L1635">                return e -&gt; action.accept(new UnmodifiableEntry&lt;&gt;(e));</span>
            }

            public void forEach(Consumer&lt;? super Entry&lt;K, V&gt;&gt; action) {
<span class="nc" id="L1639">                Objects.requireNonNull(action);</span>
<span class="nc" id="L1640">                c.forEach(entryConsumer(action));</span>
<span class="nc" id="L1641">            }</span>

            static final class UnmodifiableEntrySetSpliterator&lt;K, V&gt;
                    implements Spliterator&lt;Entry&lt;K,V&gt;&gt; {
                final Spliterator&lt;Map.Entry&lt;K, V&gt;&gt; s;

<span class="nc" id="L1647">                UnmodifiableEntrySetSpliterator(Spliterator&lt;Entry&lt;K, V&gt;&gt; s) {</span>
<span class="nc" id="L1648">                    this.s = s;</span>
<span class="nc" id="L1649">                }</span>

                @Override
                public boolean tryAdvance(Consumer&lt;? super Entry&lt;K, V&gt;&gt; action) {
<span class="nc" id="L1653">                    Objects.requireNonNull(action);</span>
<span class="nc" id="L1654">                    return s.tryAdvance(entryConsumer(action));</span>
                }

                @Override
                public void forEachRemaining(Consumer&lt;? super Entry&lt;K, V&gt;&gt; action) {
<span class="nc" id="L1659">                    Objects.requireNonNull(action);</span>
<span class="nc" id="L1660">                    s.forEachRemaining(entryConsumer(action));</span>
<span class="nc" id="L1661">                }</span>

                @Override
                public Spliterator&lt;Entry&lt;K, V&gt;&gt; trySplit() {
<span class="nc" id="L1665">                    Spliterator&lt;Entry&lt;K, V&gt;&gt; split = s.trySplit();</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">                    return split == null</span>
                           ? null
                           : new UnmodifiableEntrySetSpliterator&lt;&gt;(split);
                }

                @Override
                public long estimateSize() {
<span class="nc" id="L1673">                    return s.estimateSize();</span>
                }

                @Override
                public long getExactSizeIfKnown() {
<span class="nc" id="L1678">                    return s.getExactSizeIfKnown();</span>
                }

                @Override
                public int characteristics() {
<span class="nc" id="L1683">                    return s.characteristics();</span>
                }

                @Override
                public boolean hasCharacteristics(int characteristics) {
<span class="nc" id="L1688">                    return s.hasCharacteristics(characteristics);</span>
                }

                @Override
                public Comparator&lt;? super Entry&lt;K, V&gt;&gt; getComparator() {
<span class="nc" id="L1693">                    return s.getComparator();</span>
                }
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public Spliterator&lt;Entry&lt;K,V&gt;&gt; spliterator() {
<span class="nc" id="L1699">                return new UnmodifiableEntrySetSpliterator&lt;&gt;(</span>
<span class="nc" id="L1700">                        (Spliterator&lt;Map.Entry&lt;K, V&gt;&gt;) c.spliterator());</span>
            }

            @Override
            public Stream&lt;Entry&lt;K,V&gt;&gt; stream() {
<span class="nc" id="L1705">                return StreamSupport.stream(spliterator(), false);</span>
            }

            @Override
            public Stream&lt;Entry&lt;K,V&gt;&gt; parallelStream() {
<span class="nc" id="L1710">                return StreamSupport.stream(spliterator(), true);</span>
            }

            public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
<span class="fc" id="L1714">                return new Iterator&lt;Map.Entry&lt;K,V&gt;&gt;() {</span>
<span class="fc" id="L1715">                    private final Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = c.iterator();</span>

                    public boolean hasNext() {
<span class="fc" id="L1718">                        return i.hasNext();</span>
                    }
                    public Map.Entry&lt;K,V&gt; next() {
<span class="fc" id="L1721">                        return new UnmodifiableEntry&lt;&gt;(i.next());</span>
                    }
                    public void remove() {
<span class="fc" id="L1724">                        throw new UnsupportedOperationException();</span>
                    }
                };
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public Object[] toArray() {
<span class="fc" id="L1731">                Object[] a = c.toArray();</span>
<span class="pc bpc" id="L1732" title="1 of 2 branches missed.">                for (int i=0; i&lt;a.length; i++)</span>
<span class="nc" id="L1733">                    a[i] = new UnmodifiableEntry&lt;&gt;((Map.Entry&lt;? extends K, ? extends V&gt;)a[i]);</span>
<span class="fc" id="L1734">                return a;</span>
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public &lt;T&gt; T[] toArray(T[] a) {
                // We don't pass a to c.toArray, to avoid window of
                // vulnerability wherein an unscrupulous multithreaded client
                // could get his hands on raw (unwrapped) Entries from c.
<span class="fc bfc" id="L1742" title="All 2 branches covered.">                Object[] arr = c.toArray(a.length==0 ? a : Arrays.copyOf(a, 0));</span>

<span class="pc bpc" id="L1744" title="1 of 2 branches missed.">                for (int i=0; i&lt;arr.length; i++)</span>
<span class="nc" id="L1745">                    arr[i] = new UnmodifiableEntry&lt;&gt;((Map.Entry&lt;? extends K, ? extends V&gt;)arr[i]);</span>

<span class="pc bpc" id="L1747" title="1 of 2 branches missed.">                if (arr.length &gt; a.length)</span>
<span class="nc" id="L1748">                    return (T[])arr;</span>

<span class="fc" id="L1750">                System.arraycopy(arr, 0, a, 0, arr.length);</span>
<span class="fc bfc" id="L1751" title="All 2 branches covered.">                if (a.length &gt; arr.length)</span>
<span class="fc" id="L1752">                    a[arr.length] = null;</span>
<span class="fc" id="L1753">                return a;</span>
            }

            /**
             * This method is overridden to protect the backing set against
             * an object with a nefarious equals function that senses
             * that the equality-candidate is Map.Entry and calls its
             * setValue method.
             */
            public boolean contains(Object o) {
<span class="pc bpc" id="L1763" title="1 of 2 branches missed.">                if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L1764">                    return false;</span>
<span class="fc" id="L1765">                return c.contains(</span>
                    new UnmodifiableEntry&lt;&gt;((Map.Entry&lt;?,?&gt;) o));
            }

            /**
             * The next two methods are overridden to protect against
             * an unscrupulous List whose contains(Object o) method senses
             * when o is a Map.Entry, and calls o.setValue.
             */
            public boolean containsAll(Collection&lt;?&gt; coll) {
<span class="pc bpc" id="L1775" title="1 of 2 branches missed.">                for (Object e : coll) {</span>
<span class="nc bnc" id="L1776" title="All 2 branches missed.">                    if (!contains(e)) // Invokes safe contains() above</span>
<span class="nc" id="L1777">                        return false;</span>
<span class="nc" id="L1778">                }</span>
<span class="fc" id="L1779">                return true;</span>
            }
            public boolean equals(Object o) {
<span class="pc bpc" id="L1782" title="1 of 2 branches missed.">                if (o == this)</span>
<span class="nc" id="L1783">                    return true;</span>

<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">                if (!(o instanceof Set))</span>
<span class="nc" id="L1786">                    return false;</span>
<span class="fc" id="L1787">                Set&lt;?&gt; s = (Set&lt;?&gt;) o;</span>
<span class="pc bpc" id="L1788" title="1 of 2 branches missed.">                if (s.size() != c.size())</span>
<span class="nc" id="L1789">                    return false;</span>
<span class="fc" id="L1790">                return containsAll(s); // Invokes safe containsAll() above</span>
            }

            /**
             * This &quot;wrapper class&quot; serves two purposes: it prevents
             * the client from modifying the backing Map, by short-circuiting
             * the setValue method, and it protects the backing Map against
             * an ill-behaved Map.Entry that attempts to modify another
             * Map Entry when asked to perform an equality check.
             */
            private static class UnmodifiableEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
                private Map.Entry&lt;? extends K, ? extends V&gt; e;

                UnmodifiableEntry(Map.Entry&lt;? extends K, ? extends V&gt; e)
<span class="fc" id="L1804">                        {this.e = Objects.requireNonNull(e);}</span>

<span class="fc" id="L1806">                public K getKey()        {return e.getKey();}</span>
<span class="fc" id="L1807">                public V getValue()      {return e.getValue();}</span>
                public V setValue(V value) {
<span class="fc" id="L1809">                    throw new UnsupportedOperationException();</span>
                }
<span class="nc" id="L1811">                public int hashCode()    {return e.hashCode();}</span>
                public boolean equals(Object o) {
<span class="nc bnc" id="L1813" title="All 2 branches missed.">                    if (this == o)</span>
<span class="nc" id="L1814">                        return true;</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">                    if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L1816">                        return false;</span>
<span class="nc" id="L1817">                    Map.Entry&lt;?,?&gt; t = (Map.Entry&lt;?,?&gt;)o;</span>
<span class="nc bnc" id="L1818" title="All 2 branches missed.">                    return eq(e.getKey(),   t.getKey()) &amp;&amp;</span>
<span class="nc bnc" id="L1819" title="All 2 branches missed.">                           eq(e.getValue(), t.getValue());</span>
                }
<span class="nc" id="L1821">                public String toString() {return e.toString();}</span>
            }
        }
    }

    /**
     * Returns an unmodifiable view of the specified sorted map.  This method
     * allows modules to provide users with &quot;read-only&quot; access to internal
     * sorted maps.  Query operations on the returned sorted map &quot;read through&quot;
     * to the specified sorted map.  Attempts to modify the returned
     * sorted map, whether direct, via its collection views, or via its
     * &lt;tt&gt;subMap&lt;/tt&gt;, &lt;tt&gt;headMap&lt;/tt&gt;, or &lt;tt&gt;tailMap&lt;/tt&gt; views, result in
     * an &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
     *
     * The returned sorted map will be serializable if the specified sorted map
     * is serializable.
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @param m the sorted map for which an unmodifiable view is to be
     *        returned.
     * @return an unmodifiable view of the specified sorted map.
     */
    public static &lt;K,V&gt; SortedMap&lt;K,V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m) {
<span class="nc" id="L1845">        return new UnmodifiableSortedMap&lt;&gt;(m);</span>
    }

    /**
     * @serial include
     */
    static class UnmodifiableSortedMap&lt;K,V&gt;
          extends UnmodifiableMap&lt;K,V&gt;
          implements SortedMap&lt;K,V&gt;, Serializable {
        private static final long serialVersionUID = -8806743815996713206L;

        private final SortedMap&lt;K, ? extends V&gt; sm;

<span class="fc" id="L1858">        UnmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m) {super(m); sm = m; }</span>
<span class="nc" id="L1859">        public Comparator&lt;? super K&gt; comparator()   { return sm.comparator(); }</span>
        public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)
<span class="nc" id="L1861">             { return new UnmodifiableSortedMap&lt;&gt;(sm.subMap(fromKey, toKey)); }</span>
        public SortedMap&lt;K,V&gt; headMap(K toKey)
<span class="nc" id="L1863">                     { return new UnmodifiableSortedMap&lt;&gt;(sm.headMap(toKey)); }</span>
        public SortedMap&lt;K,V&gt; tailMap(K fromKey)
<span class="nc" id="L1865">                   { return new UnmodifiableSortedMap&lt;&gt;(sm.tailMap(fromKey)); }</span>
<span class="nc" id="L1866">        public K firstKey()                           { return sm.firstKey(); }</span>
<span class="nc" id="L1867">        public K lastKey()                             { return sm.lastKey(); }</span>
    }

    /**
     * Returns an unmodifiable view of the specified navigable map.  This method
     * allows modules to provide users with &quot;read-only&quot; access to internal
     * navigable maps.  Query operations on the returned navigable map &quot;read
     * through&quot; to the specified navigable map.  Attempts to modify the returned
     * navigable map, whether direct, via its collection views, or via its
     * {@code subMap}, {@code headMap}, or {@code tailMap} views, result in
     * an {@code UnsupportedOperationException}.&lt;p&gt;
     *
     * The returned navigable map will be serializable if the specified
     * navigable map is serializable.
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @param m the navigable map for which an unmodifiable view is to be
     *        returned
     * @return an unmodifiable view of the specified navigable map
     * @since 1.8
     */
    public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m) {
<span class="nc" id="L1890">        return new UnmodifiableNavigableMap&lt;&gt;(m);</span>
    }

    /**
     * @serial include
     */
    static class UnmodifiableNavigableMap&lt;K,V&gt;
          extends UnmodifiableSortedMap&lt;K,V&gt;
          implements NavigableMap&lt;K,V&gt;, Serializable {
        private static final long serialVersionUID = -4858195264774772197L;

        /**
         * A class for the {@link EMPTY_NAVIGABLE_MAP} which needs readResolve
         * to preserve singleton property.
         *
         * @param &lt;K&gt; type of keys, if there were any, and of bounds
         * @param &lt;V&gt; type of values, if there were any
         */
        private static class EmptyNavigableMap&lt;K,V&gt; extends UnmodifiableNavigableMap&lt;K,V&gt;
            implements Serializable {

            private static final long serialVersionUID = -2239321462712562324L;

<span class="fc" id="L1913">            EmptyNavigableMap()                       { super(new TreeMap&lt;K,V&gt;()); }</span>

            @Override
            public NavigableSet&lt;K&gt; navigableKeySet()
<span class="nc" id="L1917">                                                { return emptyNavigableSet(); }</span>

<span class="nc" id="L1919">            private Object readResolve()        { return EMPTY_NAVIGABLE_MAP; }</span>
        }

        /**
         * Singleton for {@link emptyNavigableMap()} which is also immutable.
         */
<span class="fc" id="L1925">        private static final EmptyNavigableMap&lt;?,?&gt; EMPTY_NAVIGABLE_MAP =</span>
            new EmptyNavigableMap&lt;&gt;();

        /**
         * The instance we wrap and protect.
         */
        private final NavigableMap&lt;K, ? extends V&gt; nm;

        UnmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m)
<span class="fc" id="L1934">                                                            {super(m); nm = m;}</span>

<span class="nc" id="L1936">        public K lowerKey(K key)                   { return nm.lowerKey(key); }</span>
<span class="nc" id="L1937">        public K floorKey(K key)                   { return nm.floorKey(key); }</span>
<span class="nc" id="L1938">        public K ceilingKey(K key)               { return nm.ceilingKey(key); }</span>
<span class="nc" id="L1939">        public K higherKey(K key)                 { return nm.higherKey(key); }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        public Entry&lt;K, V&gt; lowerEntry(K key) {
<span class="nc" id="L1943">            Entry&lt;K,V&gt; lower = (Entry&lt;K, V&gt;) nm.lowerEntry(key);</span>
<span class="nc bnc" id="L1944" title="All 2 branches missed.">            return (null != lower)</span>
                ? new UnmodifiableEntrySet.UnmodifiableEntry&lt;&gt;(lower)
                : null;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Entry&lt;K, V&gt; floorEntry(K key) {
<span class="nc" id="L1951">            Entry&lt;K,V&gt; floor = (Entry&lt;K, V&gt;) nm.floorEntry(key);</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">            return (null != floor)</span>
                ? new UnmodifiableEntrySet.UnmodifiableEntry&lt;&gt;(floor)
                : null;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Entry&lt;K, V&gt; ceilingEntry(K key) {
<span class="nc" id="L1959">            Entry&lt;K,V&gt; ceiling = (Entry&lt;K, V&gt;) nm.ceilingEntry(key);</span>
<span class="nc bnc" id="L1960" title="All 2 branches missed.">            return (null != ceiling)</span>
                ? new UnmodifiableEntrySet.UnmodifiableEntry&lt;&gt;(ceiling)
                : null;
        }


        @SuppressWarnings(&quot;unchecked&quot;)
        public Entry&lt;K, V&gt; higherEntry(K key) {
<span class="nc" id="L1968">            Entry&lt;K,V&gt; higher = (Entry&lt;K, V&gt;) nm.higherEntry(key);</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">            return (null != higher)</span>
                ? new UnmodifiableEntrySet.UnmodifiableEntry&lt;&gt;(higher)
                : null;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Entry&lt;K, V&gt; firstEntry() {
<span class="nc" id="L1976">            Entry&lt;K,V&gt; first = (Entry&lt;K, V&gt;) nm.firstEntry();</span>
<span class="nc bnc" id="L1977" title="All 2 branches missed.">            return (null != first)</span>
                ? new UnmodifiableEntrySet.UnmodifiableEntry&lt;&gt;(first)
                : null;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Entry&lt;K, V&gt; lastEntry() {
<span class="nc" id="L1984">            Entry&lt;K,V&gt; last = (Entry&lt;K, V&gt;) nm.lastEntry();</span>
<span class="nc bnc" id="L1985" title="All 2 branches missed.">            return (null != last)</span>
                ? new UnmodifiableEntrySet.UnmodifiableEntry&lt;&gt;(last)
                : null;
        }

        public Entry&lt;K, V&gt; pollFirstEntry()
<span class="nc" id="L1991">                                 { throw new UnsupportedOperationException(); }</span>
        public Entry&lt;K, V&gt; pollLastEntry()
<span class="nc" id="L1993">                                 { throw new UnsupportedOperationException(); }</span>
        public NavigableMap&lt;K, V&gt; descendingMap()
<span class="nc" id="L1995">                       { return unmodifiableNavigableMap(nm.descendingMap()); }</span>
        public NavigableSet&lt;K&gt; navigableKeySet()
<span class="nc" id="L1997">                     { return unmodifiableNavigableSet(nm.navigableKeySet()); }</span>
        public NavigableSet&lt;K&gt; descendingKeySet()
<span class="nc" id="L1999">                    { return unmodifiableNavigableSet(nm.descendingKeySet()); }</span>

        public NavigableMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
<span class="nc" id="L2002">            return unmodifiableNavigableMap(</span>
<span class="nc" id="L2003">                nm.subMap(fromKey, fromInclusive, toKey, toInclusive));</span>
        }

        public NavigableMap&lt;K, V&gt; headMap(K toKey, boolean inclusive)
<span class="nc" id="L2007">             { return unmodifiableNavigableMap(nm.headMap(toKey, inclusive)); }</span>
        public NavigableMap&lt;K, V&gt; tailMap(K fromKey, boolean inclusive)
<span class="nc" id="L2009">           { return unmodifiableNavigableMap(nm.tailMap(fromKey, inclusive)); }</span>
    }

    // Synch Wrappers

    /**
     * Returns a synchronized (thread-safe) collection backed by the specified
     * collection.  In order to guarantee serial access, it is critical that
     * &lt;strong&gt;all&lt;/strong&gt; access to the backing collection is accomplished
     * through the returned collection.&lt;p&gt;
     *
     * It is imperative that the user manually synchronize on the returned
     * collection when traversing it via {@link Iterator}, {@link Spliterator}
     * or {@link Stream}:
     * &lt;pre&gt;
     *  Collection c = Collections.synchronizedCollection(myCollection);
     *     ...
     *  synchronized (c) {
     *      Iterator i = c.iterator(); // Must be in the synchronized block
     *      while (i.hasNext())
     *         foo(i.next());
     *  }
     * &lt;/pre&gt;
     * Failure to follow this advice may result in non-deterministic behavior.
     *
     * &lt;p&gt;The returned collection does &lt;i&gt;not&lt;/i&gt; pass the {@code hashCode}
     * and {@code equals} operations through to the backing collection, but
     * relies on {@code Object}'s equals and hashCode methods.  This is
     * necessary to preserve the contracts of these operations in the case
     * that the backing collection is a set or a list.&lt;p&gt;
     *
     * The returned collection will be serializable if the specified collection
     * is serializable.
     *
     * @param  &lt;T&gt; the class of the objects in the collection
     * @param  c the collection to be &quot;wrapped&quot; in a synchronized collection.
     * @return a synchronized view of the specified collection.
     */
    public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) {
<span class="nc" id="L2048">        return new SynchronizedCollection&lt;&gt;(c);</span>
    }

    static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c, Object mutex) {
<span class="nc" id="L2052">        return new SynchronizedCollection&lt;&gt;(c, mutex);</span>
    }

    /**
     * @serial include
     */
    static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {
        private static final long serialVersionUID = 3053995032091335093L;

        final Collection&lt;E&gt; c;  // Backing Collection
        final Object mutex;     // Object on which to synchronize

<span class="fc" id="L2064">        SynchronizedCollection(Collection&lt;E&gt; c) {</span>
<span class="fc" id="L2065">            this.c = Objects.requireNonNull(c);</span>
<span class="fc" id="L2066">            mutex = this;</span>
<span class="fc" id="L2067">        }</span>

<span class="fc" id="L2069">        SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) {</span>
<span class="fc" id="L2070">            this.c = Objects.requireNonNull(c);</span>
<span class="fc" id="L2071">            this.mutex = Objects.requireNonNull(mutex);</span>
<span class="fc" id="L2072">        }</span>

        public int size() {
<span class="pc" id="L2075">            synchronized (mutex) {return c.size();}</span>
        }
        public boolean isEmpty() {
<span class="pc" id="L2078">            synchronized (mutex) {return c.isEmpty();}</span>
        }
        public boolean contains(Object o) {
<span class="fc" id="L2081">            synchronized (mutex) {return c.contains(o);}</span>
        }
        public Object[] toArray() {
<span class="fc" id="L2084">            synchronized (mutex) {return c.toArray();}</span>
        }
        public &lt;T&gt; T[] toArray(T[] a) {
<span class="pc" id="L2087">            synchronized (mutex) {return c.toArray(a);}</span>
        }

        public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L2091">            return c.iterator(); // Must be manually synched by user!</span>
        }

        public boolean add(E e) {
<span class="fc" id="L2095">            synchronized (mutex) {return c.add(e);}</span>
        }
        public boolean remove(Object o) {
<span class="pc" id="L2098">            synchronized (mutex) {return c.remove(o);}</span>
        }

        public boolean containsAll(Collection&lt;?&gt; coll) {
<span class="fc" id="L2102">            synchronized (mutex) {return c.containsAll(coll);}</span>
        }
        public boolean addAll(Collection&lt;? extends E&gt; coll) {
<span class="fc" id="L2105">            synchronized (mutex) {return c.addAll(coll);}</span>
        }
        public boolean removeAll(Collection&lt;?&gt; coll) {
<span class="fc" id="L2108">            synchronized (mutex) {return c.removeAll(coll);}</span>
        }
        public boolean retainAll(Collection&lt;?&gt; coll) {
<span class="fc" id="L2111">            synchronized (mutex) {return c.retainAll(coll);}</span>
        }
        public void clear() {
<span class="pc" id="L2114">            synchronized (mutex) {c.clear();}</span>
<span class="fc" id="L2115">        }</span>
        public String toString() {
<span class="pc" id="L2117">            synchronized (mutex) {return c.toString();}</span>
        }
        // Override default methods in Collection
        @Override
        public void forEach(Consumer&lt;? super E&gt; consumer) {
<span class="nc" id="L2122">            synchronized (mutex) {c.forEach(consumer);}</span>
<span class="nc" id="L2123">        }</span>
        @Override
        public boolean removeIf(Predicate&lt;? super E&gt; filter) {
<span class="nc" id="L2126">            synchronized (mutex) {return c.removeIf(filter);}</span>
        }
        @Override
        public Spliterator&lt;E&gt; spliterator() {
<span class="nc" id="L2130">            return c.spliterator(); // Must be manually synched by user!</span>
        }
        @Override
        public Stream&lt;E&gt; stream() {
<span class="nc" id="L2134">            return c.stream(); // Must be manually synched by user!</span>
        }
        @Override
        public Stream&lt;E&gt; parallelStream() {
<span class="nc" id="L2138">            return c.parallelStream(); // Must be manually synched by user!</span>
        }
        private void writeObject(ObjectOutputStream s) throws IOException {
<span class="fc" id="L2141">            synchronized (mutex) {s.defaultWriteObject();}</span>
<span class="fc" id="L2142">        }</span>
    }

    /**
     * Returns a synchronized (thread-safe) set backed by the specified
     * set.  In order to guarantee serial access, it is critical that
     * &lt;strong&gt;all&lt;/strong&gt; access to the backing set is accomplished
     * through the returned set.&lt;p&gt;
     *
     * It is imperative that the user manually synchronize on the returned
     * set when iterating over it:
     * &lt;pre&gt;
     *  Set s = Collections.synchronizedSet(new HashSet());
     *      ...
     *  synchronized (s) {
     *      Iterator i = s.iterator(); // Must be in the synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * &lt;/pre&gt;
     * Failure to follow this advice may result in non-deterministic behavior.
     *
     * &lt;p&gt;The returned set will be serializable if the specified set is
     * serializable.
     *
     * @param  &lt;T&gt; the class of the objects in the set
     * @param  s the set to be &quot;wrapped&quot; in a synchronized set.
     * @return a synchronized view of the specified set.
     */
    public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) {
<span class="nc" id="L2172">        return new SynchronizedSet&lt;&gt;(s);</span>
    }

    static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s, Object mutex) {
<span class="nc" id="L2176">        return new SynchronizedSet&lt;&gt;(s, mutex);</span>
    }

    /**
     * @serial include
     */
    static class SynchronizedSet&lt;E&gt;
          extends SynchronizedCollection&lt;E&gt;
          implements Set&lt;E&gt; {
        private static final long serialVersionUID = 487447009682186044L;

        SynchronizedSet(Set&lt;E&gt; s) {
<span class="fc" id="L2188">            super(s);</span>
<span class="fc" id="L2189">        }</span>
        SynchronizedSet(Set&lt;E&gt; s, Object mutex) {
<span class="fc" id="L2191">            super(s, mutex);</span>
<span class="fc" id="L2192">        }</span>

        public boolean equals(Object o) {
<span class="fc bfc" id="L2195" title="All 2 branches covered.">            if (this == o)</span>
<span class="fc" id="L2196">                return true;</span>
<span class="fc" id="L2197">            synchronized (mutex) {return c.equals(o);}</span>
        }
        public int hashCode() {
<span class="fc" id="L2200">            synchronized (mutex) {return c.hashCode();}</span>
        }
    }

    /**
     * Returns a synchronized (thread-safe) sorted set backed by the specified
     * sorted set.  In order to guarantee serial access, it is critical that
     * &lt;strong&gt;all&lt;/strong&gt; access to the backing sorted set is accomplished
     * through the returned sorted set (or its views).&lt;p&gt;
     *
     * It is imperative that the user manually synchronize on the returned
     * sorted set when iterating over it or any of its &lt;tt&gt;subSet&lt;/tt&gt;,
     * &lt;tt&gt;headSet&lt;/tt&gt;, or &lt;tt&gt;tailSet&lt;/tt&gt; views.
     * &lt;pre&gt;
     *  SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
     *      ...
     *  synchronized (s) {
     *      Iterator i = s.iterator(); // Must be in the synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * &lt;/pre&gt;
     * or:
     * &lt;pre&gt;
     *  SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
     *  SortedSet s2 = s.headSet(foo);
     *      ...
     *  synchronized (s) {  // Note: s, not s2!!!
     *      Iterator i = s2.iterator(); // Must be in the synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * &lt;/pre&gt;
     * Failure to follow this advice may result in non-deterministic behavior.
     *
     * &lt;p&gt;The returned sorted set will be serializable if the specified
     * sorted set is serializable.
     *
     * @param  &lt;T&gt; the class of the objects in the set
     * @param  s the sorted set to be &quot;wrapped&quot; in a synchronized sorted set.
     * @return a synchronized view of the specified sorted set.
     */
    public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s) {
<span class="nc" id="L2243">        return new SynchronizedSortedSet&lt;&gt;(s);</span>
    }

    /**
     * @serial include
     */
    static class SynchronizedSortedSet&lt;E&gt;
        extends SynchronizedSet&lt;E&gt;
        implements SortedSet&lt;E&gt;
    {
        private static final long serialVersionUID = 8695801310862127406L;

        private final SortedSet&lt;E&gt; ss;

        SynchronizedSortedSet(SortedSet&lt;E&gt; s) {
<span class="fc" id="L2258">            super(s);</span>
<span class="fc" id="L2259">            ss = s;</span>
<span class="fc" id="L2260">        }</span>
        SynchronizedSortedSet(SortedSet&lt;E&gt; s, Object mutex) {
<span class="fc" id="L2262">            super(s, mutex);</span>
<span class="fc" id="L2263">            ss = s;</span>
<span class="fc" id="L2264">        }</span>

        public Comparator&lt;? super E&gt; comparator() {
<span class="pc" id="L2267">            synchronized (mutex) {return ss.comparator();}</span>
        }

        public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
<span class="nc" id="L2271">            synchronized (mutex) {</span>
<span class="nc" id="L2272">                return new SynchronizedSortedSet&lt;&gt;(</span>
<span class="nc" id="L2273">                    ss.subSet(fromElement, toElement), mutex);</span>
<span class="nc" id="L2274">            }</span>
        }
        public SortedSet&lt;E&gt; headSet(E toElement) {
<span class="nc" id="L2277">            synchronized (mutex) {</span>
<span class="nc" id="L2278">                return new SynchronizedSortedSet&lt;&gt;(ss.headSet(toElement), mutex);</span>
<span class="nc" id="L2279">            }</span>
        }
        public SortedSet&lt;E&gt; tailSet(E fromElement) {
<span class="nc" id="L2282">            synchronized (mutex) {</span>
<span class="nc" id="L2283">               return new SynchronizedSortedSet&lt;&gt;(ss.tailSet(fromElement),mutex);</span>
<span class="nc" id="L2284">            }</span>
        }

        public E first() {
<span class="fc" id="L2288">            synchronized (mutex) {return ss.first();}</span>
        }
        public E last() {
<span class="fc" id="L2291">            synchronized (mutex) {return ss.last();}</span>
        }
    }

    /**
     * Returns a synchronized (thread-safe) navigable set backed by the
     * specified navigable set.  In order to guarantee serial access, it is
     * critical that &lt;strong&gt;all&lt;/strong&gt; access to the backing navigable set is
     * accomplished through the returned navigable set (or its views).&lt;p&gt;
     *
     * It is imperative that the user manually synchronize on the returned
     * navigable set when iterating over it or any of its {@code subSet},
     * {@code headSet}, or {@code tailSet} views.
     * &lt;pre&gt;
     *  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet());
     *      ...
     *  synchronized (s) {
     *      Iterator i = s.iterator(); // Must be in the synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * &lt;/pre&gt;
     * or:
     * &lt;pre&gt;
     *  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet());
     *  NavigableSet s2 = s.headSet(foo, true);
     *      ...
     *  synchronized (s) {  // Note: s, not s2!!!
     *      Iterator i = s2.iterator(); // Must be in the synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * &lt;/pre&gt;
     * Failure to follow this advice may result in non-deterministic behavior.
     *
     * &lt;p&gt;The returned navigable set will be serializable if the specified
     * navigable set is serializable.
     *
     * @param  &lt;T&gt; the class of the objects in the set
     * @param  s the navigable set to be &quot;wrapped&quot; in a synchronized navigable
     * set
     * @return a synchronized view of the specified navigable set
     * @since 1.8
     */
    public static &lt;T&gt; NavigableSet&lt;T&gt; synchronizedNavigableSet(NavigableSet&lt;T&gt; s) {
<span class="nc" id="L2336">        return new SynchronizedNavigableSet&lt;&gt;(s);</span>
    }

    /**
     * @serial include
     */
    static class SynchronizedNavigableSet&lt;E&gt;
        extends SynchronizedSortedSet&lt;E&gt;
        implements NavigableSet&lt;E&gt;
    {
        private static final long serialVersionUID = -5505529816273629798L;

        private final NavigableSet&lt;E&gt; ns;

        SynchronizedNavigableSet(NavigableSet&lt;E&gt; s) {
<span class="fc" id="L2351">            super(s);</span>
<span class="fc" id="L2352">            ns = s;</span>
<span class="fc" id="L2353">        }</span>

        SynchronizedNavigableSet(NavigableSet&lt;E&gt; s, Object mutex) {
<span class="fc" id="L2356">            super(s, mutex);</span>
<span class="fc" id="L2357">            ns = s;</span>
<span class="fc" id="L2358">        }</span>
<span class="pc" id="L2359">        public E lower(E e)      { synchronized (mutex) {return ns.lower(e);} }</span>
<span class="pc" id="L2360">        public E floor(E e)      { synchronized (mutex) {return ns.floor(e);} }</span>
<span class="pc" id="L2361">        public E ceiling(E e)  { synchronized (mutex) {return ns.ceiling(e);} }</span>
<span class="pc" id="L2362">        public E higher(E e)    { synchronized (mutex) {return ns.higher(e);} }</span>
<span class="pc" id="L2363">        public E pollFirst()  { synchronized (mutex) {return ns.pollFirst();} }</span>
<span class="pc" id="L2364">        public E pollLast()    { synchronized (mutex) {return ns.pollLast();} }</span>

        public NavigableSet&lt;E&gt; descendingSet() {
<span class="fc" id="L2367">            synchronized (mutex) {</span>
<span class="fc" id="L2368">                return new SynchronizedNavigableSet&lt;&gt;(ns.descendingSet(), mutex);</span>
<span class="nc" id="L2369">            }</span>
        }

        public Iterator&lt;E&gt; descendingIterator()
<span class="pc" id="L2373">                 { synchronized (mutex) { return descendingSet().iterator(); } }</span>

        public NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) {
<span class="fc" id="L2376">            synchronized (mutex) {</span>
<span class="fc" id="L2377">                return new SynchronizedNavigableSet&lt;&gt;(ns.subSet(fromElement, true, toElement, false), mutex);</span>
<span class="nc" id="L2378">            }</span>
        }
        public NavigableSet&lt;E&gt; headSet(E toElement) {
<span class="fc" id="L2381">            synchronized (mutex) {</span>
<span class="fc" id="L2382">                return new SynchronizedNavigableSet&lt;&gt;(ns.headSet(toElement, false), mutex);</span>
<span class="nc" id="L2383">            }</span>
        }
        public NavigableSet&lt;E&gt; tailSet(E fromElement) {
<span class="fc" id="L2386">            synchronized (mutex) {</span>
<span class="fc" id="L2387">                return new SynchronizedNavigableSet&lt;&gt;(ns.tailSet(fromElement, true), mutex);</span>
<span class="nc" id="L2388">            }</span>
        }

        public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
<span class="fc" id="L2392">            synchronized (mutex) {</span>
<span class="fc" id="L2393">                return new SynchronizedNavigableSet&lt;&gt;(ns.subSet(fromElement, fromInclusive, toElement, toInclusive), mutex);</span>
<span class="fc" id="L2394">            }</span>
        }

        public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
<span class="fc" id="L2398">            synchronized (mutex) {</span>
<span class="fc" id="L2399">                return new SynchronizedNavigableSet&lt;&gt;(ns.headSet(toElement, inclusive), mutex);</span>
<span class="fc" id="L2400">            }</span>
        }

        public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
<span class="fc" id="L2404">            synchronized (mutex) {</span>
<span class="fc" id="L2405">                return new SynchronizedNavigableSet&lt;&gt;(ns.tailSet(fromElement, inclusive));</span>
<span class="fc" id="L2406">            }</span>
        }
    }

    /**
     * Returns a synchronized (thread-safe) list backed by the specified
     * list.  In order to guarantee serial access, it is critical that
     * &lt;strong&gt;all&lt;/strong&gt; access to the backing list is accomplished
     * through the returned list.&lt;p&gt;
     *
     * It is imperative that the user manually synchronize on the returned
     * list when iterating over it:
     * &lt;pre&gt;
     *  List list = Collections.synchronizedList(new ArrayList());
     *      ...
     *  synchronized (list) {
     *      Iterator i = list.iterator(); // Must be in synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * &lt;/pre&gt;
     * Failure to follow this advice may result in non-deterministic behavior.
     *
     * &lt;p&gt;The returned list will be serializable if the specified list is
     * serializable.
     *
     * @param  &lt;T&gt; the class of the objects in the list
     * @param  list the list to be &quot;wrapped&quot; in a synchronized list.
     * @return a synchronized view of the specified list.
     */
    public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) {
<span class="nc bnc" id="L2437" title="All 2 branches missed.">        return (list instanceof RandomAccess ?</span>
                new SynchronizedRandomAccessList&lt;&gt;(list) :
                new SynchronizedList&lt;&gt;(list));
    }

    static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list, Object mutex) {
<span class="nc bnc" id="L2443" title="All 2 branches missed.">        return (list instanceof RandomAccess ?</span>
                new SynchronizedRandomAccessList&lt;&gt;(list, mutex) :
                new SynchronizedList&lt;&gt;(list, mutex));
    }

    /**
     * @serial include
     */
    static class SynchronizedList&lt;E&gt;
        extends SynchronizedCollection&lt;E&gt;
        implements List&lt;E&gt; {
        private static final long serialVersionUID = -7754090372962971524L;

        final List&lt;E&gt; list;

        SynchronizedList(List&lt;E&gt; list) {
<span class="fc" id="L2459">            super(list);</span>
<span class="fc" id="L2460">            this.list = list;</span>
<span class="fc" id="L2461">        }</span>
        SynchronizedList(List&lt;E&gt; list, Object mutex) {
<span class="fc" id="L2463">            super(list, mutex);</span>
<span class="fc" id="L2464">            this.list = list;</span>
<span class="fc" id="L2465">        }</span>

        public boolean equals(Object o) {
<span class="fc bfc" id="L2468" title="All 2 branches covered.">            if (this == o)</span>
<span class="fc" id="L2469">                return true;</span>
<span class="pc" id="L2470">            synchronized (mutex) {return list.equals(o);}</span>
        }
        public int hashCode() {
<span class="nc" id="L2473">            synchronized (mutex) {return list.hashCode();}</span>
        }

        public E get(int index) {
<span class="nc" id="L2477">            synchronized (mutex) {return list.get(index);}</span>
        }
        public E set(int index, E element) {
<span class="nc" id="L2480">            synchronized (mutex) {return list.set(index, element);}</span>
        }
        public void add(int index, E element) {
<span class="nc" id="L2483">            synchronized (mutex) {list.add(index, element);}</span>
<span class="nc" id="L2484">        }</span>
        public E remove(int index) {
<span class="pc" id="L2486">            synchronized (mutex) {return list.remove(index);}</span>
        }

        public int indexOf(Object o) {
<span class="nc" id="L2490">            synchronized (mutex) {return list.indexOf(o);}</span>
        }
        public int lastIndexOf(Object o) {
<span class="nc" id="L2493">            synchronized (mutex) {return list.lastIndexOf(o);}</span>
        }

        public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
<span class="pc" id="L2497">            synchronized (mutex) {return list.addAll(index, c);}</span>
        }

        public ListIterator&lt;E&gt; listIterator() {
<span class="fc" id="L2501">            return list.listIterator(); // Must be manually synched by user</span>
        }

        public ListIterator&lt;E&gt; listIterator(int index) {
<span class="nc" id="L2505">            return list.listIterator(index); // Must be manually synched by user</span>
        }

        public List&lt;E&gt; subList(int fromIndex, int toIndex) {
<span class="nc" id="L2509">            synchronized (mutex) {</span>
<span class="nc" id="L2510">                return new SynchronizedList&lt;&gt;(list.subList(fromIndex, toIndex),</span>
                                            mutex);
<span class="nc" id="L2512">            }</span>
        }

        @Override
        public void replaceAll(UnaryOperator&lt;E&gt; operator) {
<span class="nc" id="L2517">            synchronized (mutex) {list.replaceAll(operator);}</span>
<span class="nc" id="L2518">        }</span>
        @Override
        public void sort(Comparator&lt;? super E&gt; c) {
<span class="nc" id="L2521">            synchronized (mutex) {list.sort(c);}</span>
<span class="nc" id="L2522">        }</span>

        /**
         * SynchronizedRandomAccessList instances are serialized as
         * SynchronizedList instances to allow them to be deserialized
         * in pre-1.4 JREs (which do not have SynchronizedRandomAccessList).
         * This method inverts the transformation.  As a beneficial
         * side-effect, it also grafts the RandomAccess marker onto
         * SynchronizedList instances that were serialized in pre-1.4 JREs.
         *
         * Note: Unfortunately, SynchronizedRandomAccessList instances
         * serialized in 1.4.1 and deserialized in 1.4 will become
         * SynchronizedList instances, as this method was missing in 1.4.
         */
        private Object readResolve() {
<span class="pc bpc" id="L2537" title="1 of 2 branches missed.">            return (list instanceof RandomAccess</span>
                    ? new SynchronizedRandomAccessList&lt;&gt;(list)
                    : this);
        }
    }

    /**
     * @serial include
     */
    static class SynchronizedRandomAccessList&lt;E&gt;
        extends SynchronizedList&lt;E&gt;
        implements RandomAccess {

        SynchronizedRandomAccessList(List&lt;E&gt; list) {
<span class="fc" id="L2551">            super(list);</span>
<span class="fc" id="L2552">        }</span>

        SynchronizedRandomAccessList(List&lt;E&gt; list, Object mutex) {
<span class="fc" id="L2555">            super(list, mutex);</span>
<span class="fc" id="L2556">        }</span>

        public List&lt;E&gt; subList(int fromIndex, int toIndex) {
<span class="fc" id="L2559">            synchronized (mutex) {</span>
<span class="fc" id="L2560">                return new SynchronizedRandomAccessList&lt;&gt;(</span>
<span class="fc" id="L2561">                    list.subList(fromIndex, toIndex), mutex);</span>
<span class="nc" id="L2562">            }</span>
        }

        private static final long serialVersionUID = 1530674583602358482L;

        /**
         * Allows instances to be deserialized in pre-1.4 JREs (which do
         * not have SynchronizedRandomAccessList).  SynchronizedList has
         * a readResolve method that inverts this transformation upon
         * deserialization.
         */
        private Object writeReplace() {
<span class="fc" id="L2574">            return new SynchronizedList&lt;&gt;(list);</span>
        }
    }

    /**
     * Returns a synchronized (thread-safe) map backed by the specified
     * map.  In order to guarantee serial access, it is critical that
     * &lt;strong&gt;all&lt;/strong&gt; access to the backing map is accomplished
     * through the returned map.&lt;p&gt;
     *
     * It is imperative that the user manually synchronize on the returned
     * map when iterating over any of its collection views:
     * &lt;pre&gt;
     *  Map m = Collections.synchronizedMap(new HashMap());
     *      ...
     *  Set s = m.keySet();  // Needn't be in synchronized block
     *      ...
     *  synchronized (m) {  // Synchronizing on m, not s!
     *      Iterator i = s.iterator(); // Must be in synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * &lt;/pre&gt;
     * Failure to follow this advice may result in non-deterministic behavior.
     *
     * &lt;p&gt;The returned map will be serializable if the specified map is
     * serializable.
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @param  m the map to be &quot;wrapped&quot; in a synchronized map.
     * @return a synchronized view of the specified map.
     */
    public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) {
<span class="nc" id="L2608">        return new SynchronizedMap&lt;&gt;(m);</span>
    }

    /**
     * @serial include
     */
    private static class SynchronizedMap&lt;K,V&gt;
        implements Map&lt;K,V&gt;, Serializable {
        private static final long serialVersionUID = 1978198479659022715L;

        private final Map&lt;K,V&gt; m;     // Backing Map
        final Object      mutex;        // Object on which to synchronize

<span class="fc" id="L2621">        SynchronizedMap(Map&lt;K,V&gt; m) {</span>
<span class="fc" id="L2622">            this.m = Objects.requireNonNull(m);</span>
<span class="fc" id="L2623">            mutex = this;</span>
<span class="fc" id="L2624">        }</span>

<span class="fc" id="L2626">        SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) {</span>
<span class="fc" id="L2627">            this.m = m;</span>
<span class="fc" id="L2628">            this.mutex = mutex;</span>
<span class="fc" id="L2629">        }</span>

        public int size() {
<span class="pc" id="L2632">            synchronized (mutex) {return m.size();}</span>
        }
        public boolean isEmpty() {
<span class="pc" id="L2635">            synchronized (mutex) {return m.isEmpty();}</span>
        }
        public boolean containsKey(Object key) {
<span class="fc" id="L2638">            synchronized (mutex) {return m.containsKey(key);}</span>
        }
        public boolean containsValue(Object value) {
<span class="pc" id="L2641">            synchronized (mutex) {return m.containsValue(value);}</span>
        }
        public V get(Object key) {
<span class="fc" id="L2644">            synchronized (mutex) {return m.get(key);}</span>
        }

        public V put(K key, V value) {
<span class="fc" id="L2648">            synchronized (mutex) {return m.put(key, value);}</span>
        }
        public V remove(Object key) {
<span class="fc" id="L2651">            synchronized (mutex) {return m.remove(key);}</span>
        }
        public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
<span class="fc" id="L2654">            synchronized (mutex) {m.putAll(map);}</span>
<span class="fc" id="L2655">        }</span>
        public void clear() {
<span class="pc" id="L2657">            synchronized (mutex) {m.clear();}</span>
<span class="fc" id="L2658">        }</span>

<span class="fc" id="L2660">        private transient Set&lt;K&gt; keySet = null;</span>
<span class="fc" id="L2661">        private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;</span>
<span class="fc" id="L2662">        private transient Collection&lt;V&gt; values = null;</span>

        public Set&lt;K&gt; keySet() {
<span class="fc" id="L2665">            synchronized (mutex) {</span>
<span class="fc bfc" id="L2666" title="All 2 branches covered.">                if (keySet==null)</span>
<span class="fc" id="L2667">                    keySet = new SynchronizedSet&lt;&gt;(m.keySet(), mutex);</span>
<span class="fc" id="L2668">                return keySet;</span>
<span class="nc" id="L2669">            }</span>
        }

        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<span class="fc" id="L2673">            synchronized (mutex) {</span>
<span class="fc bfc" id="L2674" title="All 2 branches covered.">                if (entrySet==null)</span>
<span class="fc" id="L2675">                    entrySet = new SynchronizedSet&lt;&gt;(m.entrySet(), mutex);</span>
<span class="fc" id="L2676">                return entrySet;</span>
<span class="nc" id="L2677">            }</span>
        }

        public Collection&lt;V&gt; values() {
<span class="fc" id="L2681">            synchronized (mutex) {</span>
<span class="fc bfc" id="L2682" title="All 2 branches covered.">                if (values==null)</span>
<span class="fc" id="L2683">                    values = new SynchronizedCollection&lt;&gt;(m.values(), mutex);</span>
<span class="fc" id="L2684">                return values;</span>
<span class="nc" id="L2685">            }</span>
        }

        public boolean equals(Object o) {
<span class="pc bpc" id="L2689" title="1 of 2 branches missed.">            if (this == o)</span>
<span class="nc" id="L2690">                return true;</span>
<span class="pc" id="L2691">            synchronized (mutex) {return m.equals(o);}</span>
        }
        public int hashCode() {
<span class="pc" id="L2694">            synchronized (mutex) {return m.hashCode();}</span>
        }
        public String toString() {
<span class="pc" id="L2697">            synchronized (mutex) {return m.toString();}</span>
        }

        // Override default methods in Map
        @Override
        public V getOrDefault(Object k, V defaultValue) {
<span class="nc" id="L2703">            synchronized (mutex) {return m.getOrDefault(k, defaultValue);}</span>
        }
        @Override
        public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<span class="nc" id="L2707">            synchronized (mutex) {m.forEach(action);}</span>
<span class="nc" id="L2708">        }</span>
        @Override
        public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
<span class="nc" id="L2711">            synchronized (mutex) {m.replaceAll(function);}</span>
<span class="nc" id="L2712">        }</span>
        @Override
        public V putIfAbsent(K key, V value) {
<span class="nc" id="L2715">            synchronized (mutex) {return m.putIfAbsent(key, value);}</span>
        }
        @Override
        public boolean remove(Object key, Object value) {
<span class="nc" id="L2719">            synchronized (mutex) {return m.remove(key, value);}</span>
        }
        @Override
        public boolean replace(K key, V oldValue, V newValue) {
<span class="nc" id="L2723">            synchronized (mutex) {return m.replace(key, oldValue, newValue);}</span>
        }
        @Override
        public V replace(K key, V value) {
<span class="nc" id="L2727">            synchronized (mutex) {return m.replace(key, value);}</span>
        }
        @Override
        public V computeIfAbsent(K key,
                Function&lt;? super K, ? extends V&gt; mappingFunction) {
<span class="nc" id="L2732">            synchronized (mutex) {return m.computeIfAbsent(key, mappingFunction);}</span>
        }
        @Override
        public V computeIfPresent(K key,
                BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L2737">            synchronized (mutex) {return m.computeIfPresent(key, remappingFunction);}</span>
        }
        @Override
        public V compute(K key,
                BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L2742">            synchronized (mutex) {return m.compute(key, remappingFunction);}</span>
        }
        @Override
        public V merge(K key, V value,
                BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L2747">            synchronized (mutex) {return m.merge(key, value, remappingFunction);}</span>
        }

        private void writeObject(ObjectOutputStream s) throws IOException {
<span class="pc" id="L2751">            synchronized (mutex) {s.defaultWriteObject();}</span>
<span class="fc" id="L2752">        }</span>
    }

    /**
     * Returns a synchronized (thread-safe) sorted map backed by the specified
     * sorted map.  In order to guarantee serial access, it is critical that
     * &lt;strong&gt;all&lt;/strong&gt; access to the backing sorted map is accomplished
     * through the returned sorted map (or its views).&lt;p&gt;
     *
     * It is imperative that the user manually synchronize on the returned
     * sorted map when iterating over any of its collection views, or the
     * collections views of any of its &lt;tt&gt;subMap&lt;/tt&gt;, &lt;tt&gt;headMap&lt;/tt&gt; or
     * &lt;tt&gt;tailMap&lt;/tt&gt; views.
     * &lt;pre&gt;
     *  SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
     *      ...
     *  Set s = m.keySet();  // Needn't be in synchronized block
     *      ...
     *  synchronized (m) {  // Synchronizing on m, not s!
     *      Iterator i = s.iterator(); // Must be in synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * &lt;/pre&gt;
     * or:
     * &lt;pre&gt;
     *  SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
     *  SortedMap m2 = m.subMap(foo, bar);
     *      ...
     *  Set s2 = m2.keySet();  // Needn't be in synchronized block
     *      ...
     *  synchronized (m) {  // Synchronizing on m, not m2 or s2!
     *      Iterator i = s.iterator(); // Must be in synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * &lt;/pre&gt;
     * Failure to follow this advice may result in non-deterministic behavior.
     *
     * &lt;p&gt;The returned sorted map will be serializable if the specified
     * sorted map is serializable.
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @param  m the sorted map to be &quot;wrapped&quot; in a synchronized sorted map.
     * @return a synchronized view of the specified sorted map.
     */
    public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m) {
<span class="nc" id="L2800">        return new SynchronizedSortedMap&lt;&gt;(m);</span>
    }

    /**
     * @serial include
     */
    static class SynchronizedSortedMap&lt;K,V&gt;
        extends SynchronizedMap&lt;K,V&gt;
        implements SortedMap&lt;K,V&gt;
    {
        private static final long serialVersionUID = -8798146769416483793L;

        private final SortedMap&lt;K,V&gt; sm;

        SynchronizedSortedMap(SortedMap&lt;K,V&gt; m) {
<span class="fc" id="L2815">            super(m);</span>
<span class="fc" id="L2816">            sm = m;</span>
<span class="fc" id="L2817">        }</span>
        SynchronizedSortedMap(SortedMap&lt;K,V&gt; m, Object mutex) {
<span class="fc" id="L2819">            super(m, mutex);</span>
<span class="fc" id="L2820">            sm = m;</span>
<span class="fc" id="L2821">        }</span>

        public Comparator&lt;? super K&gt; comparator() {
<span class="pc" id="L2824">            synchronized (mutex) {return sm.comparator();}</span>
        }

        public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
<span class="nc" id="L2828">            synchronized (mutex) {</span>
<span class="nc" id="L2829">                return new SynchronizedSortedMap&lt;&gt;(</span>
<span class="nc" id="L2830">                    sm.subMap(fromKey, toKey), mutex);</span>
<span class="nc" id="L2831">            }</span>
        }
        public SortedMap&lt;K,V&gt; headMap(K toKey) {
<span class="nc" id="L2834">            synchronized (mutex) {</span>
<span class="nc" id="L2835">                return new SynchronizedSortedMap&lt;&gt;(sm.headMap(toKey), mutex);</span>
<span class="nc" id="L2836">            }</span>
        }
        public SortedMap&lt;K,V&gt; tailMap(K fromKey) {
<span class="nc" id="L2839">            synchronized (mutex) {</span>
<span class="nc" id="L2840">               return new SynchronizedSortedMap&lt;&gt;(sm.tailMap(fromKey),mutex);</span>
<span class="nc" id="L2841">            }</span>
        }

        public K firstKey() {
<span class="fc" id="L2845">            synchronized (mutex) {return sm.firstKey();}</span>
        }
        public K lastKey() {
<span class="fc" id="L2848">            synchronized (mutex) {return sm.lastKey();}</span>
        }
    }

    /**
     * Returns a synchronized (thread-safe) navigable map backed by the
     * specified navigable map.  In order to guarantee serial access, it is
     * critical that &lt;strong&gt;all&lt;/strong&gt; access to the backing navigable map is
     * accomplished through the returned navigable map (or its views).&lt;p&gt;
     *
     * It is imperative that the user manually synchronize on the returned
     * navigable map when iterating over any of its collection views, or the
     * collections views of any of its {@code subMap}, {@code headMap} or
     * {@code tailMap} views.
     * &lt;pre&gt;
     *  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap());
     *      ...
     *  Set s = m.keySet();  // Needn't be in synchronized block
     *      ...
     *  synchronized (m) {  // Synchronizing on m, not s!
     *      Iterator i = s.iterator(); // Must be in synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * &lt;/pre&gt;
     * or:
     * &lt;pre&gt;
     *  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap());
     *  NavigableMap m2 = m.subMap(foo, true, bar, false);
     *      ...
     *  Set s2 = m2.keySet();  // Needn't be in synchronized block
     *      ...
     *  synchronized (m) {  // Synchronizing on m, not m2 or s2!
     *      Iterator i = s.iterator(); // Must be in synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * &lt;/pre&gt;
     * Failure to follow this advice may result in non-deterministic behavior.
     *
     * &lt;p&gt;The returned navigable map will be serializable if the specified
     * navigable map is serializable.
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @param  m the navigable map to be &quot;wrapped&quot; in a synchronized navigable
     *              map
     * @return a synchronized view of the specified navigable map.
     * @since 1.8
     */
    public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; synchronizedNavigableMap(NavigableMap&lt;K,V&gt; m) {
<span class="nc" id="L2899">        return new SynchronizedNavigableMap&lt;&gt;(m);</span>
    }

    /**
     * A synchronized NavigableMap.
     *
     * @serial include
     */
    static class SynchronizedNavigableMap&lt;K,V&gt;
        extends SynchronizedSortedMap&lt;K,V&gt;
        implements NavigableMap&lt;K,V&gt;
    {
        private static final long serialVersionUID = 699392247599746807L;

        private final NavigableMap&lt;K,V&gt; nm;

        SynchronizedNavigableMap(NavigableMap&lt;K,V&gt; m) {
<span class="fc" id="L2916">            super(m);</span>
<span class="fc" id="L2917">            nm = m;</span>
<span class="fc" id="L2918">        }</span>
        SynchronizedNavigableMap(NavigableMap&lt;K,V&gt; m, Object mutex) {
<span class="fc" id="L2920">            super(m, mutex);</span>
<span class="fc" id="L2921">            nm = m;</span>
<span class="fc" id="L2922">        }</span>

        public Entry&lt;K, V&gt; lowerEntry(K key)
<span class="pc" id="L2925">                        { synchronized (mutex) { return nm.lowerEntry(key); } }</span>
        public K lowerKey(K key)
<span class="pc" id="L2927">                          { synchronized (mutex) { return nm.lowerKey(key); } }</span>
        public Entry&lt;K, V&gt; floorEntry(K key)
<span class="pc" id="L2929">                        { synchronized (mutex) { return nm.floorEntry(key); } }</span>
        public K floorKey(K key)
<span class="pc" id="L2931">                          { synchronized (mutex) { return nm.floorKey(key); } }</span>
        public Entry&lt;K, V&gt; ceilingEntry(K key)
<span class="pc" id="L2933">                      { synchronized (mutex) { return nm.ceilingEntry(key); } }</span>
        public K ceilingKey(K key)
<span class="pc" id="L2935">                        { synchronized (mutex) { return nm.ceilingKey(key); } }</span>
        public Entry&lt;K, V&gt; higherEntry(K key)
<span class="pc" id="L2937">                       { synchronized (mutex) { return nm.higherEntry(key); } }</span>
        public K higherKey(K key)
<span class="pc" id="L2939">                         { synchronized (mutex) { return nm.higherKey(key); } }</span>
        public Entry&lt;K, V&gt; firstEntry()
<span class="pc" id="L2941">                           { synchronized (mutex) { return nm.firstEntry(); } }</span>
        public Entry&lt;K, V&gt; lastEntry()
<span class="pc" id="L2943">                            { synchronized (mutex) { return nm.lastEntry(); } }</span>
        public Entry&lt;K, V&gt; pollFirstEntry()
<span class="pc" id="L2945">                       { synchronized (mutex) { return nm.pollFirstEntry(); } }</span>
        public Entry&lt;K, V&gt; pollLastEntry()
<span class="pc" id="L2947">                        { synchronized (mutex) { return nm.pollLastEntry(); } }</span>

        public NavigableMap&lt;K, V&gt; descendingMap() {
<span class="fc" id="L2950">            synchronized (mutex) {</span>
<span class="fc" id="L2951">                return</span>
<span class="fc" id="L2952">                    new SynchronizedNavigableMap&lt;&gt;(nm.descendingMap(), mutex);</span>
<span class="nc" id="L2953">            }</span>
        }

        public NavigableSet&lt;K&gt; keySet() {
<span class="fc" id="L2957">            return navigableKeySet();</span>
        }

        public NavigableSet&lt;K&gt; navigableKeySet() {
<span class="fc" id="L2961">            synchronized (mutex) {</span>
<span class="fc" id="L2962">                return new SynchronizedNavigableSet&lt;&gt;(nm.navigableKeySet(), mutex);</span>
<span class="nc" id="L2963">            }</span>
        }

        public NavigableSet&lt;K&gt; descendingKeySet() {
<span class="fc" id="L2967">            synchronized (mutex) {</span>
<span class="fc" id="L2968">                return new SynchronizedNavigableSet&lt;&gt;(nm.descendingKeySet(), mutex);</span>
<span class="nc" id="L2969">            }</span>
        }


        public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
<span class="fc" id="L2974">            synchronized (mutex) {</span>
<span class="fc" id="L2975">                return new SynchronizedNavigableMap&lt;&gt;(</span>
<span class="fc" id="L2976">                    nm.subMap(fromKey, true, toKey, false), mutex);</span>
<span class="nc" id="L2977">            }</span>
        }
        public SortedMap&lt;K,V&gt; headMap(K toKey) {
<span class="fc" id="L2980">            synchronized (mutex) {</span>
<span class="fc" id="L2981">                return new SynchronizedNavigableMap&lt;&gt;(nm.headMap(toKey, false), mutex);</span>
<span class="nc" id="L2982">            }</span>
        }
        public SortedMap&lt;K,V&gt; tailMap(K fromKey) {
<span class="fc" id="L2985">            synchronized (mutex) {</span>
<span class="fc" id="L2986">        return new SynchronizedNavigableMap&lt;&gt;(nm.tailMap(fromKey, true),mutex);</span>
<span class="nc" id="L2987">            }</span>
        }

        public NavigableMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
<span class="fc" id="L2991">            synchronized (mutex) {</span>
<span class="fc" id="L2992">                return new SynchronizedNavigableMap&lt;&gt;(</span>
<span class="fc" id="L2993">                    nm.subMap(fromKey, fromInclusive, toKey, toInclusive), mutex);</span>
<span class="fc" id="L2994">            }</span>
        }

        public NavigableMap&lt;K, V&gt; headMap(K toKey, boolean inclusive) {
<span class="fc" id="L2998">            synchronized (mutex) {</span>
<span class="fc" id="L2999">                return new SynchronizedNavigableMap&lt;&gt;(</span>
<span class="fc" id="L3000">                        nm.headMap(toKey, inclusive), mutex);</span>
<span class="fc" id="L3001">            }</span>
        }

        public NavigableMap&lt;K, V&gt; tailMap(K fromKey, boolean inclusive) {
<span class="fc" id="L3005">            synchronized (mutex) {</span>
<span class="fc" id="L3006">                return new SynchronizedNavigableMap&lt;&gt;(</span>
<span class="fc" id="L3007">                    nm.tailMap(fromKey, inclusive), mutex);</span>
<span class="fc" id="L3008">            }</span>
        }
    }

    // Dynamically typesafe collection wrappers

    /**
     * Returns a dynamically typesafe view of the specified collection.
     * Any attempt to insert an element of the wrong type will result in an
     * immediate {@link ClassCastException}.  Assuming a collection
     * contains no incorrectly typed elements prior to the time a
     * dynamically typesafe view is generated, and that all subsequent
     * access to the collection takes place through the view, it is
     * &lt;i&gt;guaranteed&lt;/i&gt; that the collection cannot contain an incorrectly
     * typed element.
     *
     * &lt;p&gt;The generics mechanism in the language provides compile-time
     * (static) type checking, but it is possible to defeat this mechanism
     * with unchecked casts.  Usually this is not a problem, as the compiler
     * issues warnings on all such unchecked operations.  There are, however,
     * times when static type checking alone is not sufficient.  For example,
     * suppose a collection is passed to a third-party library and it is
     * imperative that the library code not corrupt the collection by
     * inserting an element of the wrong type.
     *
     * &lt;p&gt;Another use of dynamically typesafe views is debugging.  Suppose a
     * program fails with a {@code ClassCastException}, indicating that an
     * incorrectly typed element was put into a parameterized collection.
     * Unfortunately, the exception can occur at any time after the erroneous
     * element is inserted, so it typically provides little or no information
     * as to the real source of the problem.  If the problem is reproducible,
     * one can quickly determine its source by temporarily modifying the
     * program to wrap the collection with a dynamically typesafe view.
     * For example, this declaration:
     *  &lt;pre&gt; {@code
     *     Collection&lt;String&gt; c = new HashSet&lt;&gt;();
     * }&lt;/pre&gt;
     * may be replaced temporarily by this one:
     *  &lt;pre&gt; {@code
     *     Collection&lt;String&gt; c = Collections.checkedCollection(
     *         new HashSet&lt;&gt;(), String.class);
     * }&lt;/pre&gt;
     * Running the program again will cause it to fail at the point where
     * an incorrectly typed element is inserted into the collection, clearly
     * identifying the source of the problem.  Once the problem is fixed, the
     * modified declaration may be reverted back to the original.
     *
     * &lt;p&gt;The returned collection does &lt;i&gt;not&lt;/i&gt; pass the hashCode and equals
     * operations through to the backing collection, but relies on
     * {@code Object}'s {@code equals} and {@code hashCode} methods.  This
     * is necessary to preserve the contracts of these operations in the case
     * that the backing collection is a set or a list.
     *
     * &lt;p&gt;The returned collection will be serializable if the specified
     * collection is serializable.
     *
     * &lt;p&gt;Since {@code null} is considered to be a value of any reference
     * type, the returned collection permits insertion of null elements
     * whenever the backing collection does.
     *
     * @param &lt;E&gt; the class of the objects in the collection
     * @param c the collection for which a dynamically typesafe view is to be
     *          returned
     * @param type the type of element that {@code c} is permitted to hold
     * @return a dynamically typesafe view of the specified collection
     * @since 1.5
     */
    public static &lt;E&gt; Collection&lt;E&gt; checkedCollection(Collection&lt;E&gt; c,
                                                      Class&lt;E&gt; type) {
<span class="nc" id="L3077">        return new CheckedCollection&lt;&gt;(c, type);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; T[] zeroLengthArray(Class&lt;T&gt; type) {
<span class="nc" id="L3082">        return (T[]) Array.newInstance(type, 0);</span>
    }

    /**
     * @serial include
     */
    static class CheckedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {
        private static final long serialVersionUID = 1578914078182001775L;

        final Collection&lt;E&gt; c;
        final Class&lt;E&gt; type;

        void typeCheck(Object o) {
<span class="fc bfc" id="L3095" title="All 4 branches covered.">            if (o != null &amp;&amp; !type.isInstance(o))</span>
<span class="fc" id="L3096">                throw new ClassCastException(badElementMsg(o));</span>
<span class="fc" id="L3097">        }</span>

        private String badElementMsg(Object o) {
<span class="fc" id="L3100">            return &quot;Attempt to insert &quot; + o.getClass() +</span>
                &quot; element into collection with element type &quot; + type;
        }

<span class="fc" id="L3104">        CheckedCollection(Collection&lt;E&gt; c, Class&lt;E&gt; type) {</span>
<span class="pc bpc" id="L3105" title="2 of 4 branches missed.">            if (c==null || type == null)</span>
<span class="nc" id="L3106">                throw new NullPointerException();</span>
<span class="fc" id="L3107">            this.c = c;</span>
<span class="fc" id="L3108">            this.type = type;</span>
<span class="fc" id="L3109">        }</span>

<span class="fc" id="L3111">        public int size()                 { return c.size(); }</span>
<span class="fc" id="L3112">        public boolean isEmpty()          { return c.isEmpty(); }</span>
<span class="fc" id="L3113">        public boolean contains(Object o) { return c.contains(o); }</span>
<span class="fc" id="L3114">        public Object[] toArray()         { return c.toArray(); }</span>
<span class="fc" id="L3115">        public &lt;T&gt; T[] toArray(T[] a)     { return c.toArray(a); }</span>
<span class="fc" id="L3116">        public String toString()          { return c.toString(); }</span>
<span class="fc" id="L3117">        public boolean remove(Object o)   { return c.remove(o); }</span>
<span class="fc" id="L3118">        public void clear()               {        c.clear(); }</span>

        public boolean containsAll(Collection&lt;?&gt; coll) {
<span class="fc" id="L3121">            return c.containsAll(coll);</span>
        }
        public boolean removeAll(Collection&lt;?&gt; coll) {
<span class="nc" id="L3124">            return c.removeAll(coll);</span>
        }
        public boolean retainAll(Collection&lt;?&gt; coll) {
<span class="nc" id="L3127">            return c.retainAll(coll);</span>
        }

        public Iterator&lt;E&gt; iterator() {
            // JDK-6363904 - unwrapped iterator could be typecast to
            // ListIterator with unsafe set()
<span class="fc" id="L3133">            final Iterator&lt;E&gt; it = c.iterator();</span>
<span class="fc" id="L3134">            return new Iterator&lt;E&gt;() {</span>
<span class="fc" id="L3135">                public boolean hasNext() { return it.hasNext(); }</span>
<span class="fc" id="L3136">                public E next()          { return it.next(); }</span>
<span class="fc" id="L3137">                public void remove()     {        it.remove(); }};</span>
        }

        public boolean add(E e) {
<span class="fc" id="L3141">            typeCheck(e);</span>
<span class="fc" id="L3142">            return c.add(e);</span>
        }

<span class="fc" id="L3145">        private E[] zeroLengthElementArray = null; // Lazily initialized</span>

        private E[] zeroLengthElementArray() {
<span class="fc bfc" id="L3148" title="All 2 branches covered.">            return zeroLengthElementArray != null ? zeroLengthElementArray :</span>
<span class="fc" id="L3149">                (zeroLengthElementArray = zeroLengthArray(type));</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        Collection&lt;E&gt; checkedCopyOf(Collection&lt;? extends E&gt; coll) {
<span class="fc" id="L3154">            Object[] a = null;</span>
            try {
<span class="fc" id="L3156">                E[] z = zeroLengthElementArray();</span>
<span class="fc" id="L3157">                a = coll.toArray(z);</span>
                // Defend against coll violating the toArray contract
<span class="pc bpc" id="L3159" title="1 of 2 branches missed.">                if (a.getClass() != z.getClass())</span>
<span class="nc" id="L3160">                    a = Arrays.copyOf(a, a.length, z.getClass());</span>
<span class="fc" id="L3161">            } catch (ArrayStoreException ignore) {</span>
                // To get better and consistent diagnostics,
                // we call typeCheck explicitly on each element.
                // We call clone() to defend against coll retaining a
                // reference to the returned array and storing a bad
                // element into it after it has been type checked.
<span class="fc" id="L3167">                a = coll.toArray().clone();</span>
<span class="pc bnc" id="L3168" title="All 2 branches missed.">                for (Object o : a)</span>
<span class="nc" id="L3169">                    typeCheck(o);</span>
<span class="fc" id="L3170">            }</span>
            // A slight abuse of the type system, but safe here.
<span class="fc" id="L3172">            return (Collection&lt;E&gt;) Arrays.asList(a);</span>
        }

        public boolean addAll(Collection&lt;? extends E&gt; coll) {
            // Doing things this way insulates us from concurrent changes
            // in the contents of coll and provides all-or-nothing
            // semantics (which we wouldn't get if we type-checked each
            // element as we added it)
<span class="fc" id="L3180">            return c.addAll(checkedCopyOf(coll));</span>
        }

        // Override default methods in Collection
        @Override
<span class="nc" id="L3185">        public void forEach(Consumer&lt;? super E&gt; action) {c.forEach(action);}</span>
        @Override
        public boolean removeIf(Predicate&lt;? super E&gt; filter) {
<span class="nc" id="L3188">            return c.removeIf(filter);</span>
        }
        @Override
<span class="nc" id="L3191">        public Spliterator&lt;E&gt; spliterator() {return c.spliterator();}</span>
        @Override
<span class="nc" id="L3193">        public Stream&lt;E&gt; stream()           {return c.stream();}</span>
        @Override
<span class="nc" id="L3195">        public Stream&lt;E&gt; parallelStream()   {return c.parallelStream();}</span>
    }

    /**
     * Returns a dynamically typesafe view of the specified queue.
     * Any attempt to insert an element of the wrong type will result in
     * an immediate {@link ClassCastException}.  Assuming a queue contains
     * no incorrectly typed elements prior to the time a dynamically typesafe
     * view is generated, and that all subsequent access to the queue
     * takes place through the view, it is &lt;i&gt;guaranteed&lt;/i&gt; that the
     * queue cannot contain an incorrectly typed element.
     *
     * &lt;p&gt;A discussion of the use of dynamically typesafe views may be
     * found in the documentation for the {@link #checkedCollection
     * checkedCollection} method.
     *
     * &lt;p&gt;The returned queue will be serializable if the specified queue
     * is serializable.
     *
     * &lt;p&gt;Since {@code null} is considered to be a value of any reference
     * type, the returned queue permits insertion of {@code null} elements
     * whenever the backing queue does.
     *
     * @param &lt;E&gt; the class of the objects in the queue
     * @param queue the queue for which a dynamically typesafe view is to be
     *             returned
     * @param type the type of element that {@code queue} is permitted to hold
     * @return a dynamically typesafe view of the specified queue
     * @since 1.8
     */
    public static &lt;E&gt; Queue&lt;E&gt; checkedQueue(Queue&lt;E&gt; queue, Class&lt;E&gt; type) {
<span class="nc" id="L3226">        return new CheckedQueue&lt;&gt;(queue, type);</span>
    }

    /**
     * @serial include
     */
    static class CheckedQueue&lt;E&gt;
        extends CheckedCollection&lt;E&gt;
        implements Queue&lt;E&gt;, Serializable
    {
        private static final long serialVersionUID = 1433151992604707767L;
        final Queue&lt;E&gt; queue;

        CheckedQueue(Queue&lt;E&gt; queue, Class&lt;E&gt; elementType) {
<span class="nc" id="L3240">            super(queue, elementType);</span>
<span class="nc" id="L3241">            this.queue = queue;</span>
<span class="nc" id="L3242">        }</span>

<span class="nc" id="L3244">        public E element()              {return queue.element();}</span>
<span class="nc bnc" id="L3245" title="All 4 branches missed.">        public boolean equals(Object o) {return o == this || c.equals(o);}</span>
<span class="nc" id="L3246">        public int hashCode()           {return c.hashCode();}</span>
<span class="nc" id="L3247">        public E peek()                 {return queue.peek();}</span>
<span class="nc" id="L3248">        public E poll()                 {return queue.poll();}</span>
<span class="nc" id="L3249">        public E remove()               {return queue.remove();}</span>

        public boolean offer(E e) {
<span class="nc" id="L3252">            typeCheck(e);</span>
<span class="nc" id="L3253">            return add(e);</span>
        }
    }

    /**
     * Returns a dynamically typesafe view of the specified set.
     * Any attempt to insert an element of the wrong type will result in
     * an immediate {@link ClassCastException}.  Assuming a set contains
     * no incorrectly typed elements prior to the time a dynamically typesafe
     * view is generated, and that all subsequent access to the set
     * takes place through the view, it is &lt;i&gt;guaranteed&lt;/i&gt; that the
     * set cannot contain an incorrectly typed element.
     *
     * &lt;p&gt;A discussion of the use of dynamically typesafe views may be
     * found in the documentation for the {@link #checkedCollection
     * checkedCollection} method.
     *
     * &lt;p&gt;The returned set will be serializable if the specified set is
     * serializable.
     *
     * &lt;p&gt;Since {@code null} is considered to be a value of any reference
     * type, the returned set permits insertion of null elements whenever
     * the backing set does.
     *
     * @param &lt;E&gt; the class of the objects in the set
     * @param s the set for which a dynamically typesafe view is to be
     *          returned
     * @param type the type of element that {@code s} is permitted to hold
     * @return a dynamically typesafe view of the specified set
     * @since 1.5
     */
    public static &lt;E&gt; Set&lt;E&gt; checkedSet(Set&lt;E&gt; s, Class&lt;E&gt; type) {
<span class="nc" id="L3285">        return new CheckedSet&lt;&gt;(s, type);</span>
    }

    /**
     * @serial include
     */
    static class CheckedSet&lt;E&gt; extends CheckedCollection&lt;E&gt;
                                 implements Set&lt;E&gt;, Serializable
    {
        private static final long serialVersionUID = 4694047833775013803L;

<span class="fc" id="L3296">        CheckedSet(Set&lt;E&gt; s, Class&lt;E&gt; elementType) { super(s, elementType); }</span>

<span class="pc bpc" id="L3298" title="1 of 4 branches missed.">        public boolean equals(Object o) { return o == this || c.equals(o); }</span>
<span class="fc" id="L3299">        public int hashCode()           { return c.hashCode(); }</span>
    }

    /**
     * Returns a dynamically typesafe view of the specified sorted set.
     * Any attempt to insert an element of the wrong type will result in an
     * immediate {@link ClassCastException}.  Assuming a sorted set
     * contains no incorrectly typed elements prior to the time a
     * dynamically typesafe view is generated, and that all subsequent
     * access to the sorted set takes place through the view, it is
     * &lt;i&gt;guaranteed&lt;/i&gt; that the sorted set cannot contain an incorrectly
     * typed element.
     *
     * &lt;p&gt;A discussion of the use of dynamically typesafe views may be
     * found in the documentation for the {@link #checkedCollection
     * checkedCollection} method.
     *
     * &lt;p&gt;The returned sorted set will be serializable if the specified sorted
     * set is serializable.
     *
     * &lt;p&gt;Since {@code null} is considered to be a value of any reference
     * type, the returned sorted set permits insertion of null elements
     * whenever the backing sorted set does.
     *
     * @param &lt;E&gt; the class of the objects in the set
     * @param s the sorted set for which a dynamically typesafe view is to be
     *          returned
     * @param type the type of element that {@code s} is permitted to hold
     * @return a dynamically typesafe view of the specified sorted set
     * @since 1.5
     */
    public static &lt;E&gt; SortedSet&lt;E&gt; checkedSortedSet(SortedSet&lt;E&gt; s,
                                                    Class&lt;E&gt; type) {
<span class="nc" id="L3332">        return new CheckedSortedSet&lt;&gt;(s, type);</span>
    }

    /**
     * @serial include
     */
    static class CheckedSortedSet&lt;E&gt; extends CheckedSet&lt;E&gt;
        implements SortedSet&lt;E&gt;, Serializable
    {
        private static final long serialVersionUID = 1599911165492914959L;

        private final SortedSet&lt;E&gt; ss;

        CheckedSortedSet(SortedSet&lt;E&gt; s, Class&lt;E&gt; type) {
<span class="fc" id="L3346">            super(s, type);</span>
<span class="fc" id="L3347">            ss = s;</span>
<span class="fc" id="L3348">        }</span>

<span class="fc" id="L3350">        public Comparator&lt;? super E&gt; comparator() { return ss.comparator(); }</span>
<span class="fc" id="L3351">        public E first()                   { return ss.first(); }</span>
<span class="fc" id="L3352">        public E last()                    { return ss.last(); }</span>

        public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
<span class="nc" id="L3355">            return checkedSortedSet(ss.subSet(fromElement,toElement), type);</span>
        }
        public SortedSet&lt;E&gt; headSet(E toElement) {
<span class="nc" id="L3358">            return checkedSortedSet(ss.headSet(toElement), type);</span>
        }
        public SortedSet&lt;E&gt; tailSet(E fromElement) {
<span class="nc" id="L3361">            return checkedSortedSet(ss.tailSet(fromElement), type);</span>
        }
    }

/**
     * Returns a dynamically typesafe view of the specified navigable set.
     * Any attempt to insert an element of the wrong type will result in an
     * immediate {@link ClassCastException}.  Assuming a navigable set
     * contains no incorrectly typed elements prior to the time a
     * dynamically typesafe view is generated, and that all subsequent
     * access to the navigable set takes place through the view, it is
     * &lt;em&gt;guaranteed&lt;/em&gt; that the navigable set cannot contain an incorrectly
     * typed element.
     *
     * &lt;p&gt;A discussion of the use of dynamically typesafe views may be
     * found in the documentation for the {@link #checkedCollection
     * checkedCollection} method.
     *
     * &lt;p&gt;The returned navigable set will be serializable if the specified
     * navigable set is serializable.
     *
     * &lt;p&gt;Since {@code null} is considered to be a value of any reference
     * type, the returned navigable set permits insertion of null elements
     * whenever the backing sorted set does.
     *
     * @param &lt;E&gt; the class of the objects in the set
     * @param s the navigable set for which a dynamically typesafe view is to be
     *          returned
     * @param type the type of element that {@code s} is permitted to hold
     * @return a dynamically typesafe view of the specified navigable set
     * @since 1.8
     */
    public static &lt;E&gt; NavigableSet&lt;E&gt; checkedNavigableSet(NavigableSet&lt;E&gt; s,
                                                    Class&lt;E&gt; type) {
<span class="nc" id="L3395">        return new CheckedNavigableSet&lt;&gt;(s, type);</span>
    }

    /**
     * @serial include
     */
    static class CheckedNavigableSet&lt;E&gt; extends CheckedSortedSet&lt;E&gt;
        implements NavigableSet&lt;E&gt;, Serializable
    {
        private static final long serialVersionUID = -5429120189805438922L;

        private final NavigableSet&lt;E&gt; ns;

        CheckedNavigableSet(NavigableSet&lt;E&gt; s, Class&lt;E&gt; type) {
<span class="fc" id="L3409">            super(s, type);</span>
<span class="fc" id="L3410">            ns = s;</span>
<span class="fc" id="L3411">        }</span>

<span class="fc" id="L3413">        public E lower(E e)                             { return ns.lower(e); }</span>
<span class="fc" id="L3414">        public E floor(E e)                             { return ns.floor(e); }</span>
<span class="fc" id="L3415">        public E ceiling(E e)                         { return ns.ceiling(e); }</span>
<span class="fc" id="L3416">        public E higher(E e)                           { return ns.higher(e); }</span>
<span class="fc" id="L3417">        public E pollFirst()                         { return ns.pollFirst(); }</span>
<span class="fc" id="L3418">        public E pollLast()                            {return ns.pollLast(); }</span>
        public NavigableSet&lt;E&gt; descendingSet()
<span class="fc" id="L3420">                      { return checkedNavigableSet(ns.descendingSet(), type); }</span>
        public Iterator&lt;E&gt; descendingIterator()
<span class="fc" id="L3422">            {return checkedNavigableSet(ns.descendingSet(), type).iterator(); }</span>

        public NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) {
<span class="fc" id="L3425">            return checkedNavigableSet(ns.subSet(fromElement, true, toElement, false), type);</span>
        }
        public NavigableSet&lt;E&gt; headSet(E toElement) {
<span class="fc" id="L3428">            return checkedNavigableSet(ns.headSet(toElement, false), type);</span>
        }
        public NavigableSet&lt;E&gt; tailSet(E fromElement) {
<span class="fc" id="L3431">            return checkedNavigableSet(ns.tailSet(fromElement, true), type);</span>
        }

        public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
<span class="fc" id="L3435">            return checkedNavigableSet(ns.subSet(fromElement, fromInclusive, toElement, toInclusive), type);</span>
        }

        public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
<span class="fc" id="L3439">            return checkedNavigableSet(ns.headSet(toElement, inclusive), type);</span>
        }

        public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
<span class="fc" id="L3443">            return checkedNavigableSet(ns.tailSet(fromElement, inclusive), type);</span>
        }
    }

    /**
     * Returns a dynamically typesafe view of the specified list.
     * Any attempt to insert an element of the wrong type will result in
     * an immediate {@link ClassCastException}.  Assuming a list contains
     * no incorrectly typed elements prior to the time a dynamically typesafe
     * view is generated, and that all subsequent access to the list
     * takes place through the view, it is &lt;i&gt;guaranteed&lt;/i&gt; that the
     * list cannot contain an incorrectly typed element.
     *
     * &lt;p&gt;A discussion of the use of dynamically typesafe views may be
     * found in the documentation for the {@link #checkedCollection
     * checkedCollection} method.
     *
     * &lt;p&gt;The returned list will be serializable if the specified list
     * is serializable.
     *
     * &lt;p&gt;Since {@code null} is considered to be a value of any reference
     * type, the returned list permits insertion of null elements whenever
     * the backing list does.
     *
     * @param &lt;E&gt; the class of the objects in the list
     * @param list the list for which a dynamically typesafe view is to be
     *             returned
     * @param type the type of element that {@code list} is permitted to hold
     * @return a dynamically typesafe view of the specified list
     * @since 1.5
     */
    public static &lt;E&gt; List&lt;E&gt; checkedList(List&lt;E&gt; list, Class&lt;E&gt; type) {
<span class="nc bnc" id="L3475" title="All 2 branches missed.">        return (list instanceof RandomAccess ?</span>
                new CheckedRandomAccessList&lt;&gt;(list, type) :
                new CheckedList&lt;&gt;(list, type));
    }

    /**
     * @serial include
     */
    static class CheckedList&lt;E&gt;
        extends CheckedCollection&lt;E&gt;
        implements List&lt;E&gt;
    {
        private static final long serialVersionUID = 65247728283967356L;
        final List&lt;E&gt; list;

        CheckedList(List&lt;E&gt; list, Class&lt;E&gt; type) {
<span class="fc" id="L3491">            super(list, type);</span>
<span class="fc" id="L3492">            this.list = list;</span>
<span class="fc" id="L3493">        }</span>

<span class="pc bpc" id="L3495" title="1 of 4 branches missed.">        public boolean equals(Object o)  { return o == this || list.equals(o); }</span>
<span class="nc" id="L3496">        public int hashCode()            { return list.hashCode(); }</span>
<span class="nc" id="L3497">        public E get(int index)          { return list.get(index); }</span>
<span class="nc" id="L3498">        public E remove(int index)       { return list.remove(index); }</span>
<span class="nc" id="L3499">        public int indexOf(Object o)     { return list.indexOf(o); }</span>
<span class="nc" id="L3500">        public int lastIndexOf(Object o) { return list.lastIndexOf(o); }</span>

        public E set(int index, E element) {
<span class="nc" id="L3503">            typeCheck(element);</span>
<span class="nc" id="L3504">            return list.set(index, element);</span>
        }

        public void add(int index, E element) {
<span class="nc" id="L3508">            typeCheck(element);</span>
<span class="nc" id="L3509">            list.add(index, element);</span>
<span class="nc" id="L3510">        }</span>

        public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
<span class="nc" id="L3513">            return list.addAll(index, checkedCopyOf(c));</span>
        }
<span class="fc" id="L3515">        public ListIterator&lt;E&gt; listIterator()   { return listIterator(0); }</span>

        public ListIterator&lt;E&gt; listIterator(final int index) {
<span class="fc" id="L3518">            final ListIterator&lt;E&gt; i = list.listIterator(index);</span>

<span class="fc" id="L3520">            return new ListIterator&lt;E&gt;() {</span>
<span class="fc" id="L3521">                public boolean hasNext()     { return i.hasNext(); }</span>
<span class="fc" id="L3522">                public E next()              { return i.next(); }</span>
<span class="nc" id="L3523">                public boolean hasPrevious() { return i.hasPrevious(); }</span>
<span class="nc" id="L3524">                public E previous()          { return i.previous(); }</span>
<span class="nc" id="L3525">                public int nextIndex()       { return i.nextIndex(); }</span>
<span class="nc" id="L3526">                public int previousIndex()   { return i.previousIndex(); }</span>
<span class="nc" id="L3527">                public void remove()         {        i.remove(); }</span>

                public void set(E e) {
<span class="nc" id="L3530">                    typeCheck(e);</span>
<span class="nc" id="L3531">                    i.set(e);</span>
<span class="nc" id="L3532">                }</span>

                public void add(E e) {
<span class="nc" id="L3535">                    typeCheck(e);</span>
<span class="nc" id="L3536">                    i.add(e);</span>
<span class="nc" id="L3537">                }</span>

                @Override
                public void forEachRemaining(Consumer&lt;? super E&gt; action) {
<span class="nc" id="L3541">                    i.forEachRemaining(action);</span>
<span class="nc" id="L3542">                }</span>
            };
        }

        public List&lt;E&gt; subList(int fromIndex, int toIndex) {
<span class="nc" id="L3547">            return new CheckedList&lt;&gt;(list.subList(fromIndex, toIndex), type);</span>
        }

        @Override
        public void replaceAll(UnaryOperator&lt;E&gt; operator) {
<span class="nc" id="L3552">            list.replaceAll(operator);</span>
<span class="nc" id="L3553">        }</span>
        @Override
        public void sort(Comparator&lt;? super E&gt; c) {
<span class="nc" id="L3556">            list.sort(c);</span>
<span class="nc" id="L3557">        }</span>
    }

    /**
     * @serial include
     */
    static class CheckedRandomAccessList&lt;E&gt; extends CheckedList&lt;E&gt;
                                            implements RandomAccess
    {
        private static final long serialVersionUID = 1638200125423088369L;

        CheckedRandomAccessList(List&lt;E&gt; list, Class&lt;E&gt; type) {
<span class="fc" id="L3569">            super(list, type);</span>
<span class="fc" id="L3570">        }</span>

        public List&lt;E&gt; subList(int fromIndex, int toIndex) {
<span class="fc" id="L3573">            return new CheckedRandomAccessList&lt;&gt;(</span>
<span class="fc" id="L3574">                    list.subList(fromIndex, toIndex), type);</span>
        }
    }

    /**
     * Returns a dynamically typesafe view of the specified map.
     * Any attempt to insert a mapping whose key or value have the wrong
     * type will result in an immediate {@link ClassCastException}.
     * Similarly, any attempt to modify the value currently associated with
     * a key will result in an immediate {@link ClassCastException},
     * whether the modification is attempted directly through the map
     * itself, or through a {@link Map.Entry} instance obtained from the
     * map's {@link Map#entrySet() entry set} view.
     *
     * &lt;p&gt;Assuming a map contains no incorrectly typed keys or values
     * prior to the time a dynamically typesafe view is generated, and
     * that all subsequent access to the map takes place through the view
     * (or one of its collection views), it is &lt;i&gt;guaranteed&lt;/i&gt; that the
     * map cannot contain an incorrectly typed key or value.
     *
     * &lt;p&gt;A discussion of the use of dynamically typesafe views may be
     * found in the documentation for the {@link #checkedCollection
     * checkedCollection} method.
     *
     * &lt;p&gt;The returned map will be serializable if the specified map is
     * serializable.
     *
     * &lt;p&gt;Since {@code null} is considered to be a value of any reference
     * type, the returned map permits insertion of null keys or values
     * whenever the backing map does.
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @param m the map for which a dynamically typesafe view is to be
     *          returned
     * @param keyType the type of key that {@code m} is permitted to hold
     * @param valueType the type of value that {@code m} is permitted to hold
     * @return a dynamically typesafe view of the specified map
     * @since 1.5
     */
    public static &lt;K, V&gt; Map&lt;K, V&gt; checkedMap(Map&lt;K, V&gt; m,
                                              Class&lt;K&gt; keyType,
                                              Class&lt;V&gt; valueType) {
<span class="nc" id="L3617">        return new CheckedMap&lt;&gt;(m, keyType, valueType);</span>
    }


    /**
     * @serial include
     */
    private static class CheckedMap&lt;K,V&gt;
        implements Map&lt;K,V&gt;, Serializable
    {
        private static final long serialVersionUID = 5742860141034234728L;

        private final Map&lt;K, V&gt; m;
        final Class&lt;K&gt; keyType;
        final Class&lt;V&gt; valueType;

        private void typeCheck(Object key, Object value) {
<span class="fc bfc" id="L3634" title="All 4 branches covered.">            if (key != null &amp;&amp; !keyType.isInstance(key))</span>
<span class="fc" id="L3635">                throw new ClassCastException(badKeyMsg(key));</span>

<span class="fc bfc" id="L3637" title="All 4 branches covered.">            if (value != null &amp;&amp; !valueType.isInstance(value))</span>
<span class="fc" id="L3638">                throw new ClassCastException(badValueMsg(value));</span>
<span class="fc" id="L3639">        }</span>

        private BiFunction&lt;? super K, ? super V, ? extends V&gt; typeCheck(
                BiFunction&lt;? super K, ? super V, ? extends V&gt; func) {
<span class="nc" id="L3643">            Objects.requireNonNull(func);</span>
<span class="nc" id="L3644">            return (k, v) -&gt; {</span>
                V newValue = func.apply(k, v);
                typeCheck(k, newValue);
                return newValue;
            };
        }

        private String badKeyMsg(Object key) {
<span class="fc" id="L3652">            return &quot;Attempt to insert &quot; + key.getClass() +</span>
                    &quot; key into map with key type &quot; + keyType;
        }

        private String badValueMsg(Object value) {
<span class="fc" id="L3657">            return &quot;Attempt to insert &quot; + value.getClass() +</span>
                    &quot; value into map with value type &quot; + valueType;
        }

<span class="fc" id="L3661">        CheckedMap(Map&lt;K, V&gt; m, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {</span>
<span class="fc" id="L3662">            this.m = Objects.requireNonNull(m);</span>
<span class="fc" id="L3663">            this.keyType = Objects.requireNonNull(keyType);</span>
<span class="fc" id="L3664">            this.valueType = Objects.requireNonNull(valueType);</span>
<span class="fc" id="L3665">        }</span>

<span class="fc" id="L3667">        public int size()                      { return m.size(); }</span>
<span class="fc" id="L3668">        public boolean isEmpty()               { return m.isEmpty(); }</span>
<span class="fc" id="L3669">        public boolean containsKey(Object key) { return m.containsKey(key); }</span>
<span class="fc" id="L3670">        public boolean containsValue(Object v) { return m.containsValue(v); }</span>
<span class="fc" id="L3671">        public V get(Object key)               { return m.get(key); }</span>
<span class="fc" id="L3672">        public V remove(Object key)            { return m.remove(key); }</span>
<span class="fc" id="L3673">        public void clear()                    { m.clear(); }</span>
<span class="fc" id="L3674">        public Set&lt;K&gt; keySet()                 { return m.keySet(); }</span>
<span class="fc" id="L3675">        public Collection&lt;V&gt; values()          { return m.values(); }</span>
<span class="pc bpc" id="L3676" title="2 of 4 branches missed.">        public boolean equals(Object o)        { return o == this || m.equals(o); }</span>
<span class="fc" id="L3677">        public int hashCode()                  { return m.hashCode(); }</span>
<span class="fc" id="L3678">        public String toString()               { return m.toString(); }</span>

        public V put(K key, V value) {
<span class="fc" id="L3681">            typeCheck(key, value);</span>
<span class="fc" id="L3682">            return m.put(key, value);</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void putAll(Map&lt;? extends K, ? extends V&gt; t) {
            // Satisfy the following goals:
            // - good diagnostics in case of type mismatch
            // - all-or-nothing semantics
            // - protection from malicious t
            // - correct behavior if t is a concurrent map
<span class="fc" id="L3692">            Object[] entries = t.entrySet().toArray();</span>
<span class="fc" id="L3693">            List&lt;Map.Entry&lt;K,V&gt;&gt; checked = new ArrayList&lt;&gt;(entries.length);</span>
<span class="fc bfc" id="L3694" title="All 2 branches covered.">            for (Object o : entries) {</span>
<span class="fc" id="L3695">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span>
<span class="fc" id="L3696">                Object k = e.getKey();</span>
<span class="fc" id="L3697">                Object v = e.getValue();</span>
<span class="fc" id="L3698">                typeCheck(k, v);</span>
<span class="fc" id="L3699">                checked.add(</span>
                        new AbstractMap.SimpleImmutableEntry&lt;&gt;((K)k, (V)v));
            }
<span class="fc bfc" id="L3702" title="All 2 branches covered.">            for (Map.Entry&lt;K,V&gt; e : checked)</span>
<span class="fc" id="L3703">                m.put(e.getKey(), e.getValue());</span>
<span class="fc" id="L3704">        }</span>

<span class="fc" id="L3706">        private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;</span>

        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<span class="fc bfc" id="L3709" title="All 2 branches covered.">            if (entrySet==null)</span>
<span class="fc" id="L3710">                entrySet = new CheckedEntrySet&lt;&gt;(m.entrySet(), valueType);</span>
<span class="fc" id="L3711">            return entrySet;</span>
        }

        // Override default methods in Map
        @Override
        public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<span class="nc" id="L3717">            m.forEach(action);</span>
<span class="nc" id="L3718">        }</span>

        @Override
        public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
<span class="nc" id="L3722">            m.replaceAll(typeCheck(function));</span>
<span class="nc" id="L3723">        }</span>

        @Override
        public V putIfAbsent(K key, V value) {
<span class="nc" id="L3727">            typeCheck(key, value);</span>
<span class="nc" id="L3728">            return m.putIfAbsent(key, value);</span>
        }

        @Override
        public boolean remove(Object key, Object value) {
<span class="nc" id="L3733">            return m.remove(key, value);</span>
        }

        @Override
        public boolean replace(K key, V oldValue, V newValue) {
<span class="nc" id="L3738">            typeCheck(key, newValue);</span>
<span class="nc" id="L3739">            return m.replace(key, oldValue, newValue);</span>
        }

        @Override
        public V replace(K key, V value) {
<span class="nc" id="L3744">            typeCheck(key, value);</span>
<span class="nc" id="L3745">            return m.replace(key, value);</span>
        }

        @Override
        public V computeIfAbsent(K key,
                Function&lt;? super K, ? extends V&gt; mappingFunction) {
<span class="nc" id="L3751">            Objects.requireNonNull(mappingFunction);</span>
<span class="nc" id="L3752">            return m.computeIfAbsent(key, k -&gt; {</span>
                V value = mappingFunction.apply(k);
                typeCheck(k, value);
                return value;
            });
        }

        @Override
        public V computeIfPresent(K key,
                BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L3762">            return m.computeIfPresent(key, typeCheck(remappingFunction));</span>
        }

        @Override
        public V compute(K key,
                BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L3768">            return m.compute(key, typeCheck(remappingFunction));</span>
        }

        @Override
        public V merge(K key, V value,
                BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L3774">            Objects.requireNonNull(remappingFunction);</span>
<span class="nc" id="L3775">            return m.merge(key, value, (v1, v2) -&gt; {</span>
                V newValue = remappingFunction.apply(v1, v2);
                typeCheck(null, newValue);
                return newValue;
            });
        }

        /**
         * We need this class in addition to CheckedSet as Map.Entry permits
         * modification of the backing Map via the setValue operation.  This
         * class is subtle: there are many possible attacks that must be
         * thwarted.
         *
         * @serial exclude
         */
        static class CheckedEntrySet&lt;K,V&gt; implements Set&lt;Map.Entry&lt;K,V&gt;&gt; {
            private final Set&lt;Map.Entry&lt;K,V&gt;&gt; s;
            private final Class&lt;V&gt; valueType;

<span class="fc" id="L3794">            CheckedEntrySet(Set&lt;Map.Entry&lt;K, V&gt;&gt; s, Class&lt;V&gt; valueType) {</span>
<span class="fc" id="L3795">                this.s = s;</span>
<span class="fc" id="L3796">                this.valueType = valueType;</span>
<span class="fc" id="L3797">            }</span>

<span class="fc" id="L3799">            public int size()        { return s.size(); }</span>
<span class="fc" id="L3800">            public boolean isEmpty() { return s.isEmpty(); }</span>
<span class="fc" id="L3801">            public String toString() { return s.toString(); }</span>
<span class="fc" id="L3802">            public int hashCode()    { return s.hashCode(); }</span>
<span class="nc" id="L3803">            public void clear()      {        s.clear(); }</span>

            public boolean add(Map.Entry&lt;K, V&gt; e) {
<span class="nc" id="L3806">                throw new UnsupportedOperationException();</span>
            }
            public boolean addAll(Collection&lt;? extends Map.Entry&lt;K, V&gt;&gt; coll) {
<span class="nc" id="L3809">                throw new UnsupportedOperationException();</span>
            }

            public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
<span class="fc" id="L3813">                final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; i = s.iterator();</span>
<span class="fc" id="L3814">                final Class&lt;V&gt; valueType = this.valueType;</span>

<span class="fc" id="L3816">                return new Iterator&lt;Map.Entry&lt;K,V&gt;&gt;() {</span>
<span class="fc" id="L3817">                    public boolean hasNext() { return i.hasNext(); }</span>
<span class="fc" id="L3818">                    public void remove()     { i.remove(); }</span>

                    public Map.Entry&lt;K,V&gt; next() {
<span class="fc" id="L3821">                        return checkedEntry(i.next(), valueType);</span>
                    }
                };
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public Object[] toArray() {
<span class="fc" id="L3828">                Object[] source = s.toArray();</span>

                /*
                 * Ensure that we don't get an ArrayStoreException even if
                 * s.toArray returns an array of something other than Object
                 */
<span class="pc bpc" id="L3834" title="1 of 2 branches missed.">                Object[] dest = (CheckedEntry.class.isInstance(</span>
<span class="fc" id="L3835">                    source.getClass().getComponentType()) ? source :</span>
                                 new Object[source.length]);

<span class="fc bfc" id="L3838" title="All 2 branches covered.">                for (int i = 0; i &lt; source.length; i++)</span>
<span class="fc" id="L3839">                    dest[i] = checkedEntry((Map.Entry&lt;K,V&gt;)source[i],</span>
                                           valueType);
<span class="fc" id="L3841">                return dest;</span>
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public &lt;T&gt; T[] toArray(T[] a) {
                // We don't pass a to s.toArray, to avoid window of
                // vulnerability wherein an unscrupulous multithreaded client
                // could get his hands on raw (unwrapped) Entries from s.
<span class="fc bfc" id="L3849" title="All 2 branches covered.">                T[] arr = s.toArray(a.length==0 ? a : Arrays.copyOf(a, 0));</span>

<span class="pc bpc" id="L3851" title="1 of 2 branches missed.">                for (int i=0; i&lt;arr.length; i++)</span>
<span class="nc" id="L3852">                    arr[i] = (T) checkedEntry((Map.Entry&lt;K,V&gt;)arr[i],</span>
                                              valueType);
<span class="pc bpc" id="L3854" title="1 of 2 branches missed.">                if (arr.length &gt; a.length)</span>
<span class="nc" id="L3855">                    return arr;</span>

<span class="fc" id="L3857">                System.arraycopy(arr, 0, a, 0, arr.length);</span>
<span class="fc bfc" id="L3858" title="All 2 branches covered.">                if (a.length &gt; arr.length)</span>
<span class="fc" id="L3859">                    a[arr.length] = null;</span>
<span class="fc" id="L3860">                return a;</span>
            }

            /**
             * This method is overridden to protect the backing set against
             * an object with a nefarious equals function that senses
             * that the equality-candidate is Map.Entry and calls its
             * setValue method.
             */
            public boolean contains(Object o) {
<span class="pc bpc" id="L3870" title="1 of 2 branches missed.">                if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L3871">                    return false;</span>
<span class="fc" id="L3872">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span>
<span class="fc bfc" id="L3873" title="All 2 branches covered.">                return s.contains(</span>
<span class="fc" id="L3874">                    (e instanceof CheckedEntry) ? e : checkedEntry(e, valueType));</span>
            }

            /**
             * The bulk collection methods are overridden to protect
             * against an unscrupulous collection whose contains(Object o)
             * method senses when o is a Map.Entry, and calls o.setValue.
             */
            public boolean containsAll(Collection&lt;?&gt; c) {
<span class="fc bfc" id="L3883" title="All 2 branches covered.">                for (Object o : c)</span>
<span class="pc bpc" id="L3884" title="1 of 2 branches missed.">                    if (!contains(o)) // Invokes safe contains() above</span>
<span class="nc" id="L3885">                        return false;</span>
<span class="fc" id="L3886">                return true;</span>
            }

            public boolean remove(Object o) {
<span class="nc bnc" id="L3890" title="All 2 branches missed.">                if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L3891">                    return false;</span>
<span class="nc" id="L3892">                return s.remove(new AbstractMap.SimpleImmutableEntry</span>
                                &lt;&gt;((Map.Entry&lt;?,?&gt;)o));
            }

            public boolean removeAll(Collection&lt;?&gt; c) {
<span class="nc" id="L3897">                return batchRemove(c, false);</span>
            }
            public boolean retainAll(Collection&lt;?&gt; c) {
<span class="nc" id="L3900">                return batchRemove(c, true);</span>
            }
            private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
<span class="fc" id="L3903">                Objects.requireNonNull(c);</span>
<span class="fc" id="L3904">                boolean modified = false;</span>
<span class="fc" id="L3905">                Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = iterator();</span>
<span class="nc bnc" id="L3906" title="All 2 branches missed.">                while (it.hasNext()) {</span>
<span class="nc bnc" id="L3907" title="All 2 branches missed.">                    if (c.contains(it.next()) != complement) {</span>
<span class="nc" id="L3908">                        it.remove();</span>
<span class="nc" id="L3909">                        modified = true;</span>
                    }
                }
<span class="nc" id="L3912">                return modified;</span>
            }

            public boolean equals(Object o) {
<span class="pc bpc" id="L3916" title="1 of 2 branches missed.">                if (o == this)</span>
<span class="nc" id="L3917">                    return true;</span>
<span class="pc bpc" id="L3918" title="1 of 2 branches missed.">                if (!(o instanceof Set))</span>
<span class="nc" id="L3919">                    return false;</span>
<span class="fc" id="L3920">                Set&lt;?&gt; that = (Set&lt;?&gt;) o;</span>
<span class="pc bpc" id="L3921" title="1 of 2 branches missed.">                return that.size() == s.size()</span>
<span class="pc bpc" id="L3922" title="1 of 2 branches missed.">                    &amp;&amp; containsAll(that); // Invokes safe containsAll() above</span>
            }

            static &lt;K,V,T&gt; CheckedEntry&lt;K,V,T&gt; checkedEntry(Map.Entry&lt;K,V&gt; e,
                                                            Class&lt;T&gt; valueType) {
<span class="fc" id="L3927">                return new CheckedEntry&lt;&gt;(e, valueType);</span>
            }

            /**
             * This &quot;wrapper class&quot; serves two purposes: it prevents
             * the client from modifying the backing Map, by short-circuiting
             * the setValue method, and it protects the backing Map against
             * an ill-behaved Map.Entry that attempts to modify another
             * Map.Entry when asked to perform an equality check.
             */
            private static class CheckedEntry&lt;K,V,T&gt; implements Map.Entry&lt;K,V&gt; {
                private final Map.Entry&lt;K, V&gt; e;
                private final Class&lt;T&gt; valueType;

<span class="fc" id="L3941">                CheckedEntry(Map.Entry&lt;K, V&gt; e, Class&lt;T&gt; valueType) {</span>
<span class="fc" id="L3942">                    this.e = Objects.requireNonNull(e);</span>
<span class="fc" id="L3943">                    this.valueType = Objects.requireNonNull(valueType);</span>
<span class="fc" id="L3944">                }</span>

<span class="fc" id="L3946">                public K getKey()        { return e.getKey(); }</span>
<span class="fc" id="L3947">                public V getValue()      { return e.getValue(); }</span>
<span class="nc" id="L3948">                public int hashCode()    { return e.hashCode(); }</span>
<span class="nc" id="L3949">                public String toString() { return e.toString(); }</span>

                public V setValue(V value) {
<span class="pc bpc" id="L3952" title="2 of 4 branches missed.">                    if (value != null &amp;&amp; !valueType.isInstance(value))</span>
<span class="fc" id="L3953">                        throw new ClassCastException(badValueMsg(value));</span>
<span class="nc" id="L3954">                    return e.setValue(value);</span>
                }

                private String badValueMsg(Object value) {
<span class="fc" id="L3958">                    return &quot;Attempt to insert &quot; + value.getClass() +</span>
                        &quot; value into map with value type &quot; + valueType;
                }

                public boolean equals(Object o) {
<span class="pc bpc" id="L3963" title="1 of 2 branches missed.">                    if (o == this)</span>
<span class="nc" id="L3964">                        return true;</span>
<span class="pc bpc" id="L3965" title="1 of 2 branches missed.">                    if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L3966">                        return false;</span>
<span class="fc" id="L3967">                    return e.equals(new AbstractMap.SimpleImmutableEntry</span>
                                    &lt;&gt;((Map.Entry&lt;?,?&gt;)o));
                }
            }
        }
    }

    /**
     * Returns a dynamically typesafe view of the specified sorted map.
     * Any attempt to insert a mapping whose key or value have the wrong
     * type will result in an immediate {@link ClassCastException}.
     * Similarly, any attempt to modify the value currently associated with
     * a key will result in an immediate {@link ClassCastException},
     * whether the modification is attempted directly through the map
     * itself, or through a {@link Map.Entry} instance obtained from the
     * map's {@link Map#entrySet() entry set} view.
     *
     * &lt;p&gt;Assuming a map contains no incorrectly typed keys or values
     * prior to the time a dynamically typesafe view is generated, and
     * that all subsequent access to the map takes place through the view
     * (or one of its collection views), it is &lt;i&gt;guaranteed&lt;/i&gt; that the
     * map cannot contain an incorrectly typed key or value.
     *
     * &lt;p&gt;A discussion of the use of dynamically typesafe views may be
     * found in the documentation for the {@link #checkedCollection
     * checkedCollection} method.
     *
     * &lt;p&gt;The returned map will be serializable if the specified map is
     * serializable.
     *
     * &lt;p&gt;Since {@code null} is considered to be a value of any reference
     * type, the returned map permits insertion of null keys or values
     * whenever the backing map does.
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @param m the map for which a dynamically typesafe view is to be
     *          returned
     * @param keyType the type of key that {@code m} is permitted to hold
     * @param valueType the type of value that {@code m} is permitted to hold
     * @return a dynamically typesafe view of the specified map
     * @since 1.5
     */
    public static &lt;K,V&gt; SortedMap&lt;K,V&gt; checkedSortedMap(SortedMap&lt;K, V&gt; m,
                                                        Class&lt;K&gt; keyType,
                                                        Class&lt;V&gt; valueType) {
<span class="nc" id="L4013">        return new CheckedSortedMap&lt;&gt;(m, keyType, valueType);</span>
    }

    /**
     * @serial include
     */
    static class CheckedSortedMap&lt;K,V&gt; extends CheckedMap&lt;K,V&gt;
        implements SortedMap&lt;K,V&gt;, Serializable
    {
        private static final long serialVersionUID = 1599671320688067438L;

        private final SortedMap&lt;K, V&gt; sm;

        CheckedSortedMap(SortedMap&lt;K, V&gt; m,
                         Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
<span class="fc" id="L4028">            super(m, keyType, valueType);</span>
<span class="fc" id="L4029">            sm = m;</span>
<span class="fc" id="L4030">        }</span>

<span class="nc" id="L4032">        public Comparator&lt;? super K&gt; comparator() { return sm.comparator(); }</span>
<span class="nc" id="L4033">        public K firstKey()                       { return sm.firstKey(); }</span>
<span class="nc" id="L4034">        public K lastKey()                        { return sm.lastKey(); }</span>

        public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
<span class="nc" id="L4037">            return checkedSortedMap(sm.subMap(fromKey, toKey),</span>
                                    keyType, valueType);
        }
        public SortedMap&lt;K,V&gt; headMap(K toKey) {
<span class="nc" id="L4041">            return checkedSortedMap(sm.headMap(toKey), keyType, valueType);</span>
        }
        public SortedMap&lt;K,V&gt; tailMap(K fromKey) {
<span class="nc" id="L4044">            return checkedSortedMap(sm.tailMap(fromKey), keyType, valueType);</span>
        }
    }

    /**
     * Returns a dynamically typesafe view of the specified navigable map.
     * Any attempt to insert a mapping whose key or value have the wrong
     * type will result in an immediate {@link ClassCastException}.
     * Similarly, any attempt to modify the value currently associated with
     * a key will result in an immediate {@link ClassCastException},
     * whether the modification is attempted directly through the map
     * itself, or through a {@link Map.Entry} instance obtained from the
     * map's {@link Map#entrySet() entry set} view.
     *
     * &lt;p&gt;Assuming a map contains no incorrectly typed keys or values
     * prior to the time a dynamically typesafe view is generated, and
     * that all subsequent access to the map takes place through the view
     * (or one of its collection views), it is &lt;em&gt;guaranteed&lt;/em&gt; that the
     * map cannot contain an incorrectly typed key or value.
     *
     * &lt;p&gt;A discussion of the use of dynamically typesafe views may be
     * found in the documentation for the {@link #checkedCollection
     * checkedCollection} method.
     *
     * &lt;p&gt;The returned map will be serializable if the specified map is
     * serializable.
     *
     * &lt;p&gt;Since {@code null} is considered to be a value of any reference
     * type, the returned map permits insertion of null keys or values
     * whenever the backing map does.
     *
     * @param &lt;K&gt; type of map keys
     * @param &lt;V&gt; type of map values
     * @param m the map for which a dynamically typesafe view is to be
     *          returned
     * @param keyType the type of key that {@code m} is permitted to hold
     * @param valueType the type of value that {@code m} is permitted to hold
     * @return a dynamically typesafe view of the specified map
     * @since 1.8
     */
    public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; checkedNavigableMap(NavigableMap&lt;K, V&gt; m,
                                                        Class&lt;K&gt; keyType,
                                                        Class&lt;V&gt; valueType) {
<span class="nc" id="L4087">        return new CheckedNavigableMap&lt;&gt;(m, keyType, valueType);</span>
    }

    /**
     * @serial include
     */
    static class CheckedNavigableMap&lt;K,V&gt; extends CheckedSortedMap&lt;K,V&gt;
        implements NavigableMap&lt;K,V&gt;, Serializable
    {
        private static final long serialVersionUID = -4852462692372534096L;

        private final NavigableMap&lt;K, V&gt; nm;

        CheckedNavigableMap(NavigableMap&lt;K, V&gt; m,
                         Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
<span class="fc" id="L4102">            super(m, keyType, valueType);</span>
<span class="fc" id="L4103">            nm = m;</span>
<span class="fc" id="L4104">        }</span>

<span class="fc" id="L4106">        public Comparator&lt;? super K&gt; comparator()   { return nm.comparator(); }</span>
<span class="fc" id="L4107">        public K firstKey()                           { return nm.firstKey(); }</span>
<span class="fc" id="L4108">        public K lastKey()                             { return nm.lastKey(); }</span>

        public Entry&lt;K, V&gt; lowerEntry(K key) {
<span class="fc" id="L4111">            Entry&lt;K,V&gt; lower = nm.lowerEntry(key);</span>
<span class="fc bfc" id="L4112" title="All 2 branches covered.">            return (null != lower)</span>
                ? new CheckedMap.CheckedEntrySet.CheckedEntry&lt;&gt;(lower, valueType)
                : null;
        }

<span class="fc" id="L4117">        public K lowerKey(K key)                   { return nm.lowerKey(key); }</span>

        public Entry&lt;K, V&gt; floorEntry(K key) {
<span class="fc" id="L4120">            Entry&lt;K,V&gt; floor = nm.floorEntry(key);</span>
<span class="fc bfc" id="L4121" title="All 2 branches covered.">            return (null != floor)</span>
                ? new CheckedMap.CheckedEntrySet.CheckedEntry&lt;&gt;(floor, valueType)
                : null;
        }

<span class="fc" id="L4126">        public K floorKey(K key)                   { return nm.floorKey(key); }</span>

        public Entry&lt;K, V&gt; ceilingEntry(K key) {
<span class="fc" id="L4129">            Entry&lt;K,V&gt; ceiling = nm.ceilingEntry(key);</span>
<span class="fc bfc" id="L4130" title="All 2 branches covered.">            return (null != ceiling)</span>
                ? new CheckedMap.CheckedEntrySet.CheckedEntry&lt;&gt;(ceiling, valueType)
                : null;
        }

<span class="fc" id="L4135">        public K ceilingKey(K key)               { return nm.ceilingKey(key); }</span>

        public Entry&lt;K, V&gt; higherEntry(K key) {
<span class="fc" id="L4138">            Entry&lt;K,V&gt; higher = nm.higherEntry(key);</span>
<span class="pc bpc" id="L4139" title="1 of 2 branches missed.">            return (null != higher)</span>
                ? new CheckedMap.CheckedEntrySet.CheckedEntry&lt;&gt;(higher, valueType)
                : null;
        }

<span class="fc" id="L4144">        public K higherKey(K key)                 { return nm.higherKey(key); }</span>

        public Entry&lt;K, V&gt; firstEntry() {
<span class="fc" id="L4147">            Entry&lt;K,V&gt; first = nm.firstEntry();</span>
<span class="fc bfc" id="L4148" title="All 2 branches covered.">            return (null != first)</span>
                ? new CheckedMap.CheckedEntrySet.CheckedEntry&lt;&gt;(first, valueType)
                : null;
        }

        public Entry&lt;K, V&gt; lastEntry() {
<span class="fc" id="L4154">            Entry&lt;K,V&gt; last = nm.lastEntry();</span>
<span class="fc bfc" id="L4155" title="All 2 branches covered.">            return (null != last)</span>
                ? new CheckedMap.CheckedEntrySet.CheckedEntry&lt;&gt;(last, valueType)
                : null;
        }

        public Entry&lt;K, V&gt; pollFirstEntry() {
<span class="fc" id="L4161">            Entry&lt;K,V&gt; entry = nm.pollFirstEntry();</span>
<span class="fc bfc" id="L4162" title="All 2 branches covered.">            return (null == entry)</span>
                ? null
                : new CheckedMap.CheckedEntrySet.CheckedEntry&lt;&gt;(entry, valueType);
        }

        public Entry&lt;K, V&gt; pollLastEntry() {
<span class="fc" id="L4168">            Entry&lt;K,V&gt; entry = nm.pollLastEntry();</span>
<span class="fc bfc" id="L4169" title="All 2 branches covered.">            return (null == entry)</span>
                ? null
                : new CheckedMap.CheckedEntrySet.CheckedEntry&lt;&gt;(entry, valueType);
        }

        public NavigableMap&lt;K, V&gt; descendingMap() {
<span class="fc" id="L4175">            return checkedNavigableMap(nm.descendingMap(), keyType, valueType);</span>
        }

        public NavigableSet&lt;K&gt; keySet() {
<span class="fc" id="L4179">            return navigableKeySet();</span>
        }

        public NavigableSet&lt;K&gt; navigableKeySet() {
<span class="fc" id="L4183">            return checkedNavigableSet(nm.navigableKeySet(), keyType);</span>
        }

        public NavigableSet&lt;K&gt; descendingKeySet() {
<span class="fc" id="L4187">            return checkedNavigableSet(nm.descendingKeySet(), keyType);</span>
        }

        @Override
        public NavigableMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
<span class="fc" id="L4192">            return checkedNavigableMap(nm.subMap(fromKey, true, toKey, false),</span>
                                    keyType, valueType);
        }

        @Override
        public NavigableMap&lt;K,V&gt; headMap(K toKey) {
<span class="fc" id="L4198">            return checkedNavigableMap(nm.headMap(toKey, false), keyType, valueType);</span>
        }

        @Override
        public NavigableMap&lt;K,V&gt; tailMap(K fromKey) {
<span class="fc" id="L4203">            return checkedNavigableMap(nm.tailMap(fromKey, true), keyType, valueType);</span>
        }

        public NavigableMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
<span class="fc" id="L4207">            return checkedNavigableMap(nm.subMap(fromKey, fromInclusive, toKey, toInclusive), keyType, valueType);</span>
        }

        public NavigableMap&lt;K, V&gt; headMap(K toKey, boolean inclusive) {
<span class="fc" id="L4211">            return checkedNavigableMap(nm.headMap(toKey, inclusive), keyType, valueType);</span>
        }

        public NavigableMap&lt;K, V&gt; tailMap(K fromKey, boolean inclusive) {
<span class="fc" id="L4215">            return checkedNavigableMap(nm.tailMap(fromKey, inclusive), keyType, valueType);</span>
        }
    }

    // Empty collections

    /**
     * Returns an iterator that has no elements.  More precisely,
     *
     * &lt;ul&gt;
     * &lt;li&gt;{@link Iterator#hasNext hasNext} always returns {@code
     * false}.&lt;/li&gt;
     * &lt;li&gt;{@link Iterator#next next} always throws {@link
     * NoSuchElementException}.&lt;/li&gt;
     * &lt;li&gt;{@link Iterator#remove remove} always throws {@link
     * IllegalStateException}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;Implementations of this method are permitted, but not
     * required, to return the same object from multiple invocations.
     *
     * @param &lt;T&gt; type of elements, if there were any, in the iterator
     * @return an empty iterator
     * @since 1.7
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Iterator&lt;T&gt; emptyIterator() {
<span class="nc" id="L4242">        return (Iterator&lt;T&gt;) EmptyIterator.EMPTY_ITERATOR;</span>
    }

<span class="fc" id="L4245">    private static class EmptyIterator&lt;E&gt; implements Iterator&lt;E&gt; {</span>
<span class="fc" id="L4246">        static final EmptyIterator&lt;Object&gt; EMPTY_ITERATOR</span>
            = new EmptyIterator&lt;&gt;();

<span class="fc" id="L4249">        public boolean hasNext() { return false; }</span>
<span class="fc" id="L4250">        public E next() { throw new NoSuchElementException(); }</span>
<span class="fc" id="L4251">        public void remove() { throw new IllegalStateException(); }</span>
        @Override
        public void forEachRemaining(Consumer&lt;? super E&gt; action) {
<span class="nc" id="L4254">            Objects.requireNonNull(action);</span>
<span class="nc" id="L4255">        }</span>
    }

    /**
     * Returns a list iterator that has no elements.  More precisely,
     *
     * &lt;ul&gt;
     * &lt;li&gt;{@link Iterator#hasNext hasNext} and {@link
     * ListIterator#hasPrevious hasPrevious} always return {@code
     * false}.&lt;/li&gt;
     * &lt;li&gt;{@link Iterator#next next} and {@link ListIterator#previous
     * previous} always throw {@link NoSuchElementException}.&lt;/li&gt;
     * &lt;li&gt;{@link Iterator#remove remove} and {@link ListIterator#set
     * set} always throw {@link IllegalStateException}.&lt;/li&gt;
     * &lt;li&gt;{@link ListIterator#add add} always throws {@link
     * UnsupportedOperationException}.&lt;/li&gt;
     * &lt;li&gt;{@link ListIterator#nextIndex nextIndex} always returns
     * {@code 0}.&lt;/li&gt;
     * &lt;li&gt;{@link ListIterator#previousIndex previousIndex} always
     * returns {@code -1}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;Implementations of this method are permitted, but not
     * required, to return the same object from multiple invocations.
     *
     * @param &lt;T&gt; type of elements, if there were any, in the iterator
     * @return an empty list iterator
     * @since 1.7
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; ListIterator&lt;T&gt; emptyListIterator() {
<span class="nc" id="L4286">        return (ListIterator&lt;T&gt;) EmptyListIterator.EMPTY_ITERATOR;</span>
    }

<span class="fc" id="L4289">    private static class EmptyListIterator&lt;E&gt;</span>
        extends EmptyIterator&lt;E&gt;
        implements ListIterator&lt;E&gt;
    {
<span class="fc" id="L4293">        static final EmptyListIterator&lt;Object&gt; EMPTY_ITERATOR</span>
            = new EmptyListIterator&lt;&gt;();

<span class="nc" id="L4296">        public boolean hasPrevious() { return false; }</span>
<span class="nc" id="L4297">        public E previous() { throw new NoSuchElementException(); }</span>
<span class="nc" id="L4298">        public int nextIndex()     { return 0; }</span>
<span class="nc" id="L4299">        public int previousIndex() { return -1; }</span>
<span class="nc" id="L4300">        public void set(E e) { throw new IllegalStateException(); }</span>
<span class="nc" id="L4301">        public void add(E e) { throw new UnsupportedOperationException(); }</span>
    }

    /**
     * Returns an enumeration that has no elements.  More precisely,
     *
     * &lt;ul&gt;
     * &lt;li&gt;{@link Enumeration#hasMoreElements hasMoreElements} always
     * returns {@code false}.&lt;/li&gt;
     * &lt;li&gt; {@link Enumeration#nextElement nextElement} always throws
     * {@link NoSuchElementException}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;Implementations of this method are permitted, but not
     * required, to return the same object from multiple invocations.
     *
     * @param  &lt;T&gt; the class of the objects in the enumeration
     * @return an empty enumeration
     * @since 1.7
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Enumeration&lt;T&gt; emptyEnumeration() {
<span class="nc" id="L4323">        return (Enumeration&lt;T&gt;) EmptyEnumeration.EMPTY_ENUMERATION;</span>
    }

<span class="fc" id="L4326">    private static class EmptyEnumeration&lt;E&gt; implements Enumeration&lt;E&gt; {</span>
<span class="fc" id="L4327">        static final EmptyEnumeration&lt;Object&gt; EMPTY_ENUMERATION</span>
            = new EmptyEnumeration&lt;&gt;();

<span class="fc" id="L4330">        public boolean hasMoreElements() { return false; }</span>
<span class="fc" id="L4331">        public E nextElement() { throw new NoSuchElementException(); }</span>
    }

    /**
     * The empty set (immutable).  This set is serializable.
     *
     * @see #emptySet()
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="nc" id="L4340">    public static final Set EMPTY_SET = new EmptySet&lt;&gt;();</span>

    /**
     * Returns an empty set (immutable).  This set is serializable.
     * Unlike the like-named field, this method is parameterized.
     *
     * &lt;p&gt;This example illustrates the type-safe way to obtain an empty set:
     * &lt;pre&gt;
     *     Set&amp;lt;String&amp;gt; s = Collections.emptySet();
     * &lt;/pre&gt;
     * @implNote Implementations of this method need not create a separate
     * {@code Set} object for each call.  Using this method is likely to have
     * comparable cost to using the like-named field.  (Unlike this method, the
     * field does not provide type safety.)
     *
     * @param  &lt;T&gt; the class of the objects in the set
     * @return the empty set
     *
     * @see #EMPTY_SET
     * @since 1.5
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static final &lt;T&gt; Set&lt;T&gt; emptySet() {
<span class="nc" id="L4363">        return (Set&lt;T&gt;) EMPTY_SET;</span>
    }

    /**
     * @serial include
     */
<span class="fc" id="L4369">    private static class EmptySet&lt;E&gt;</span>
        extends AbstractSet&lt;E&gt;
        implements Serializable
    {
        private static final long serialVersionUID = 1582296315990362920L;

<span class="fc" id="L4375">        public Iterator&lt;E&gt; iterator() { return emptyIterator(); }</span>

<span class="fc" id="L4377">        public int size() {return 0;}</span>
<span class="fc" id="L4378">        public boolean isEmpty() {return true;}</span>

<span class="fc" id="L4380">        public boolean contains(Object obj) {return false;}</span>
<span class="fc" id="L4381">        public boolean containsAll(Collection&lt;?&gt; c) { return c.isEmpty(); }</span>

<span class="fc" id="L4383">        public Object[] toArray() { return new Object[0]; }</span>

        public &lt;T&gt; T[] toArray(T[] a) {
<span class="fc bfc" id="L4386" title="All 2 branches covered.">            if (a.length &gt; 0)</span>
<span class="fc" id="L4387">                a[0] = null;</span>
<span class="fc" id="L4388">            return a;</span>
        }

        // Override default methods in Collection
        @Override
        public void forEach(Consumer&lt;? super E&gt; action) {
<span class="nc" id="L4394">            Objects.requireNonNull(action);</span>
<span class="nc" id="L4395">        }</span>
        @Override
        public boolean removeIf(Predicate&lt;? super E&gt; filter) {
<span class="nc" id="L4398">            Objects.requireNonNull(filter);</span>
<span class="nc" id="L4399">            return false;</span>
        }
        @Override
<span class="fc" id="L4402">        public Spliterator&lt;E&gt; spliterator() { return Spliterators.emptySpliterator(); }</span>

        // Preserves singleton property
        private Object readResolve() {
<span class="fc" id="L4406">            return EMPTY_SET;</span>
        }
    }

    /**
     * Returns an empty sorted set (immutable).  This set is serializable.
     *
     * &lt;p&gt;This example illustrates the type-safe way to obtain an empty
     * sorted set:
     * &lt;pre&gt; {@code
     *     SortedSet&lt;String&gt; s = Collections.emptySortedSet();
     * }&lt;/pre&gt;
     *
     * @implNote Implementations of this method need not create a separate
     * {@code SortedSet} object for each call.
     *
     * @param &lt;E&gt; type of elements, if there were any, in the set
     * @return the empty sorted set
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;E&gt; SortedSet&lt;E&gt; emptySortedSet() {
<span class="nc" id="L4428">        return (SortedSet&lt;E&gt;) UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;</span>
    }

    /**
     * Returns an empty navigable set (immutable).  This set is serializable.
     *
     * &lt;p&gt;This example illustrates the type-safe way to obtain an empty
     * navigable set:
     * &lt;pre&gt; {@code
     *     NavigableSet&lt;String&gt; s = Collections.emptyNavigableSet();
     * }&lt;/pre&gt;
     *
     * @implNote Implementations of this method need not
     * create a separate {@code NavigableSet} object for each call.
     *
     * @param &lt;E&gt; type of elements, if there were any, in the set
     * @return the empty navigable set
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;E&gt; NavigableSet&lt;E&gt; emptyNavigableSet() {
<span class="nc" id="L4449">        return (NavigableSet&lt;E&gt;) UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;</span>
    }

    /**
     * The empty list (immutable).  This list is serializable.
     *
     * @see #emptyList()
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="nc" id="L4458">    public static final List EMPTY_LIST = new EmptyList&lt;&gt;();</span>

    /**
     * Returns an empty list (immutable).  This list is serializable.
     *
     * &lt;p&gt;This example illustrates the type-safe way to obtain an empty list:
     * &lt;pre&gt;
     *     List&amp;lt;String&amp;gt; s = Collections.emptyList();
     * &lt;/pre&gt;
     * Implementation note:  Implementations of this method need not
     * create a separate &lt;tt&gt;List&lt;/tt&gt; object for each call.   Using this
     * method is likely to have comparable cost to using the like-named
     * field.  (Unlike this method, the field does not provide type safety.)
     *
     * @param &lt;T&gt; type of elements, if there were any, in the list
     * @return an empty immutable list
     *
     * @see #EMPTY_LIST
     * @since 1.5
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static final &lt;T&gt; List&lt;T&gt; emptyList() {
<span class="nc" id="L4480">        return (List&lt;T&gt;) EMPTY_LIST;</span>
    }

    /**
     * @serial include
     */
<span class="fc" id="L4486">    private static class EmptyList&lt;E&gt;</span>
        extends AbstractList&lt;E&gt;
        implements RandomAccess, Serializable {
        private static final long serialVersionUID = 8842843931221139166L;

        public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L4492">            return emptyIterator();</span>
        }
        public ListIterator&lt;E&gt; listIterator() {
<span class="fc" id="L4495">            return emptyListIterator();</span>
        }

<span class="fc" id="L4498">        public int size() {return 0;}</span>
<span class="fc" id="L4499">        public boolean isEmpty() {return true;}</span>

<span class="fc" id="L4501">        public boolean contains(Object obj) {return false;}</span>
<span class="fc" id="L4502">        public boolean containsAll(Collection&lt;?&gt; c) { return c.isEmpty(); }</span>

<span class="fc" id="L4504">        public Object[] toArray() { return new Object[0]; }</span>

        public &lt;T&gt; T[] toArray(T[] a) {
<span class="fc bfc" id="L4507" title="All 2 branches covered.">            if (a.length &gt; 0)</span>
<span class="fc" id="L4508">                a[0] = null;</span>
<span class="fc" id="L4509">            return a;</span>
        }

        public E get(int index) {
<span class="nc" id="L4513">            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);</span>
        }

        public boolean equals(Object o) {
<span class="pc bpc" id="L4517" title="2 of 4 branches missed.">            return (o instanceof List) &amp;&amp; ((List&lt;?&gt;)o).isEmpty();</span>
        }

<span class="fc" id="L4520">        public int hashCode() { return 1; }</span>

        @Override
        public boolean removeIf(Predicate&lt;? super E&gt; filter) {
<span class="nc" id="L4524">            Objects.requireNonNull(filter);</span>
<span class="nc" id="L4525">            return false;</span>
        }
        @Override
        public void replaceAll(UnaryOperator&lt;E&gt; operator) {
<span class="nc" id="L4529">            Objects.requireNonNull(operator);</span>
<span class="nc" id="L4530">        }</span>
        @Override
        public void sort(Comparator&lt;? super E&gt; c) {
<span class="nc" id="L4533">        }</span>

        // Override default methods in Collection
        @Override
        public void forEach(Consumer&lt;? super E&gt; action) {
<span class="fc" id="L4538">            Objects.requireNonNull(action);</span>
<span class="fc" id="L4539">        }</span>

        @Override
<span class="fc" id="L4542">        public Spliterator&lt;E&gt; spliterator() { return Spliterators.emptySpliterator(); }</span>

        // Preserves singleton property
        private Object readResolve() {
<span class="fc" id="L4546">            return EMPTY_LIST;</span>
        }
    }

    /**
     * The empty map (immutable).  This map is serializable.
     *
     * @see #emptyMap()
     * @since 1.3
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="nc" id="L4557">    public static final Map EMPTY_MAP = new EmptyMap&lt;&gt;();</span>

    /**
     * Returns an empty map (immutable).  This map is serializable.
     *
     * &lt;p&gt;This example illustrates the type-safe way to obtain an empty map:
     * &lt;pre&gt;
     *     Map&amp;lt;String, Date&amp;gt; s = Collections.emptyMap();
     * &lt;/pre&gt;
     * @implNote Implementations of this method need not create a separate
     * {@code Map} object for each call.  Using this method is likely to have
     * comparable cost to using the like-named field.  (Unlike this method, the
     * field does not provide type safety.)
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @return an empty map
     * @see #EMPTY_MAP
     * @since 1.5
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static final &lt;K,V&gt; Map&lt;K,V&gt; emptyMap() {
<span class="nc" id="L4579">        return (Map&lt;K,V&gt;) EMPTY_MAP;</span>
    }

    /**
     * Returns an empty sorted map (immutable).  This map is serializable.
     *
     * &lt;p&gt;This example illustrates the type-safe way to obtain an empty map:
     * &lt;pre&gt; {@code
     *     SortedMap&lt;String, Date&gt; s = Collections.emptySortedMap();
     * }&lt;/pre&gt;
     *
     * @implNote Implementations of this method need not create a separate
     * {@code SortedMap} object for each call.
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @return an empty sorted map
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static final &lt;K,V&gt; SortedMap&lt;K,V&gt; emptySortedMap() {
<span class="nc" id="L4600">        return (SortedMap&lt;K,V&gt;) UnmodifiableNavigableMap.EMPTY_NAVIGABLE_MAP;</span>
    }

    /**
     * Returns an empty navigable map (immutable).  This map is serializable.
     *
     * &lt;p&gt;This example illustrates the type-safe way to obtain an empty map:
     * &lt;pre&gt; {@code
     *     NavigableMap&lt;String, Date&gt; s = Collections.emptyNavigableMap();
     * }&lt;/pre&gt;
     *
     * @implNote Implementations of this method need not create a separate
     * {@code NavigableMap} object for each call.
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @return an empty navigable map
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static final &lt;K,V&gt; NavigableMap&lt;K,V&gt; emptyNavigableMap() {
<span class="nc" id="L4621">        return (NavigableMap&lt;K,V&gt;) UnmodifiableNavigableMap.EMPTY_NAVIGABLE_MAP;</span>
    }

    /**
     * @serial include
     */
<span class="fc" id="L4627">    private static class EmptyMap&lt;K,V&gt;</span>
        extends AbstractMap&lt;K,V&gt;
        implements Serializable
    {
        private static final long serialVersionUID = 6428348081105594320L;

<span class="fc" id="L4633">        public int size()                          {return 0;}</span>
<span class="fc" id="L4634">        public boolean isEmpty()                   {return true;}</span>
<span class="fc" id="L4635">        public boolean containsKey(Object key)     {return false;}</span>
<span class="fc" id="L4636">        public boolean containsValue(Object value) {return false;}</span>
<span class="fc" id="L4637">        public V get(Object key)                   {return null;}</span>
<span class="fc" id="L4638">        public Set&lt;K&gt; keySet()                     {return emptySet();}</span>
<span class="fc" id="L4639">        public Collection&lt;V&gt; values()              {return emptySet();}</span>
<span class="fc" id="L4640">        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()      {return emptySet();}</span>

        public boolean equals(Object o) {
<span class="pc bpc" id="L4643" title="2 of 4 branches missed.">            return (o instanceof Map) &amp;&amp; ((Map&lt;?,?&gt;)o).isEmpty();</span>
        }

<span class="nc" id="L4646">        public int hashCode()                      {return 0;}</span>

        // Override default methods in Map
        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public V getOrDefault(Object k, V defaultValue) {
<span class="nc" id="L4652">            return defaultValue;</span>
        }

        @Override
        public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<span class="nc" id="L4657">            Objects.requireNonNull(action);</span>
<span class="nc" id="L4658">        }</span>

        @Override
        public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
<span class="nc" id="L4662">            Objects.requireNonNull(function);</span>
<span class="nc" id="L4663">        }</span>

        @Override
        public V putIfAbsent(K key, V value) {
<span class="nc" id="L4667">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean remove(Object key, Object value) {
<span class="nc" id="L4672">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean replace(K key, V oldValue, V newValue) {
<span class="nc" id="L4677">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V replace(K key, V value) {
<span class="nc" id="L4682">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V computeIfAbsent(K key,
                Function&lt;? super K, ? extends V&gt; mappingFunction) {
<span class="nc" id="L4688">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V computeIfPresent(K key,
                BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L4694">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V compute(K key,
                BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L4700">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V merge(K key, V value,
                BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L4706">            throw new UnsupportedOperationException();</span>
        }

        // Preserves singleton property
        private Object readResolve() {
<span class="nc" id="L4711">            return EMPTY_MAP;</span>
        }
    }

    // Singleton collections

    /**
     * Returns an immutable set containing only the specified object.
     * The returned set is serializable.
     *
     * @param  &lt;T&gt; the class of the objects in the set
     * @param o the sole object to be stored in the returned set.
     * @return an immutable set containing only the specified object.
     */
    public static &lt;T&gt; Set&lt;T&gt; singleton(T o) {
<span class="nc" id="L4726">        return new SingletonSet&lt;&gt;(o);</span>
    }

    static &lt;E&gt; Iterator&lt;E&gt; singletonIterator(final E e) {
<span class="pc" id="L4730">        return new Iterator&lt;E&gt;() {</span>
<span class="fc" id="L4731">            private boolean hasNext = true;</span>
            public boolean hasNext() {
<span class="fc" id="L4733">                return hasNext;</span>
            }
            public E next() {
<span class="pc bpc" id="L4736" title="1 of 2 branches missed.">                if (hasNext) {</span>
<span class="fc" id="L4737">                    hasNext = false;</span>
<span class="fc" id="L4738">                    return e;</span>
                }
<span class="nc" id="L4740">                throw new NoSuchElementException();</span>
            }
            public void remove() {
<span class="fc" id="L4743">                throw new UnsupportedOperationException();</span>
            }
            @Override
            public void forEachRemaining(Consumer&lt;? super E&gt; action) {
<span class="nc" id="L4747">                Objects.requireNonNull(action);</span>
<span class="nc bnc" id="L4748" title="All 2 branches missed.">                if (hasNext) {</span>
<span class="nc" id="L4749">                    action.accept(e);</span>
<span class="nc" id="L4750">                    hasNext = false;</span>
                }
<span class="nc" id="L4752">            }</span>
        };
    }

    /**
     * Creates a {@code Spliterator} with only the specified element
     *
     * @param &lt;T&gt; Type of elements
     * @return A singleton {@code Spliterator}
     */
    static &lt;T&gt; Spliterator&lt;T&gt; singletonSpliterator(final T element) {
<span class="nc" id="L4763">        return new Spliterator&lt;T&gt;() {</span>
<span class="nc" id="L4764">            long est = 1;</span>

            @Override
            public Spliterator&lt;T&gt; trySplit() {
<span class="nc" id="L4768">                return null;</span>
            }

            @Override
            public boolean tryAdvance(Consumer&lt;? super T&gt; consumer) {
<span class="nc" id="L4773">                Objects.requireNonNull(consumer);</span>
<span class="nc bnc" id="L4774" title="All 2 branches missed.">                if (est &gt; 0) {</span>
<span class="nc" id="L4775">                    est--;</span>
<span class="nc" id="L4776">                    consumer.accept(element);</span>
<span class="nc" id="L4777">                    return true;</span>
                }
<span class="nc" id="L4779">                return false;</span>
            }

            @Override
            public void forEachRemaining(Consumer&lt;? super T&gt; consumer) {
<span class="nc" id="L4784">                tryAdvance(consumer);</span>
<span class="nc" id="L4785">            }</span>

            @Override
            public long estimateSize() {
<span class="nc" id="L4789">                return est;</span>
            }

            @Override
            public int characteristics() {
<span class="nc bnc" id="L4794" title="All 2 branches missed.">                int value = (element != null) ? Spliterator.NONNULL : 0;</span>

<span class="nc" id="L4796">                return value | Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.IMMUTABLE |</span>
                       Spliterator.DISTINCT | Spliterator.ORDERED;
            }
        };
    }

    /**
     * @serial include
     */
    private static class SingletonSet&lt;E&gt;
        extends AbstractSet&lt;E&gt;
        implements Serializable
    {
        private static final long serialVersionUID = 3193687207550431679L;

        private final E element;

<span class="fc" id="L4813">        SingletonSet(E e) {element = e;}</span>

        public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L4816">            return singletonIterator(element);</span>
        }

<span class="fc" id="L4819">        public int size() {return 1;}</span>

<span class="fc" id="L4821">        public boolean contains(Object o) {return eq(o, element);}</span>

        // Override default methods for Collection
        @Override
        public void forEach(Consumer&lt;? super E&gt; action) {
<span class="nc" id="L4826">            action.accept(element);</span>
<span class="nc" id="L4827">        }</span>
        @Override
        public Spliterator&lt;E&gt; spliterator() {
<span class="nc" id="L4830">            return singletonSpliterator(element);</span>
        }
        @Override
        public boolean removeIf(Predicate&lt;? super E&gt; filter) {
<span class="nc" id="L4834">            throw new UnsupportedOperationException();</span>
        }
    }

    /**
     * Returns an immutable list containing only the specified object.
     * The returned list is serializable.
     *
     * @param  &lt;T&gt; the class of the objects in the list
     * @param o the sole object to be stored in the returned list.
     * @return an immutable list containing only the specified object.
     * @since 1.3
     */
    public static &lt;T&gt; List&lt;T&gt; singletonList(T o) {
<span class="nc" id="L4848">        return new SingletonList&lt;&gt;(o);</span>
    }

    /**
     * @serial include
     */
    private static class SingletonList&lt;E&gt;
        extends AbstractList&lt;E&gt;
        implements RandomAccess, Serializable {

        private static final long serialVersionUID = 3093736618740652951L;

        private final E element;

<span class="fc" id="L4862">        SingletonList(E obj)                {element = obj;}</span>

        public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L4865">            return singletonIterator(element);</span>
        }

<span class="fc" id="L4868">        public int size()                   {return 1;}</span>

<span class="fc" id="L4870">        public boolean contains(Object obj) {return eq(obj, element);}</span>

        public E get(int index) {
<span class="pc bpc" id="L4873" title="1 of 2 branches missed.">            if (index != 0)</span>
<span class="nc" id="L4874">              throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: 1&quot;);</span>
<span class="fc" id="L4875">            return element;</span>
        }

        // Override default methods for Collection
        @Override
        public void forEach(Consumer&lt;? super E&gt; action) {
<span class="nc" id="L4881">            action.accept(element);</span>
<span class="nc" id="L4882">        }</span>
        @Override
        public boolean removeIf(Predicate&lt;? super E&gt; filter) {
<span class="nc" id="L4885">            throw new UnsupportedOperationException();</span>
        }
        @Override
        public void replaceAll(UnaryOperator&lt;E&gt; operator) {
<span class="nc" id="L4889">            throw new UnsupportedOperationException();</span>
        }
        @Override
        public void sort(Comparator&lt;? super E&gt; c) {
<span class="nc" id="L4893">        }</span>
        @Override
        public Spliterator&lt;E&gt; spliterator() {
<span class="nc" id="L4896">            return singletonSpliterator(element);</span>
        }
    }

    /**
     * Returns an immutable map, mapping only the specified key to the
     * specified value.  The returned map is serializable.
     *
     * @param &lt;K&gt; the class of the map keys
     * @param &lt;V&gt; the class of the map values
     * @param key the sole key to be stored in the returned map.
     * @param value the value to which the returned map maps &lt;tt&gt;key&lt;/tt&gt;.
     * @return an immutable map containing only the specified key-value
     *         mapping.
     * @since 1.3
     */
    public static &lt;K,V&gt; Map&lt;K,V&gt; singletonMap(K key, V value) {
<span class="nc" id="L4913">        return new SingletonMap&lt;&gt;(key, value);</span>
    }

    /**
     * @serial include
     */
    private static class SingletonMap&lt;K,V&gt;
          extends AbstractMap&lt;K,V&gt;
          implements Serializable {
        private static final long serialVersionUID = -6979724477215052911L;

        private final K k;
        private final V v;

<span class="fc" id="L4927">        SingletonMap(K key, V value) {</span>
<span class="fc" id="L4928">            k = key;</span>
<span class="fc" id="L4929">            v = value;</span>
<span class="fc" id="L4930">        }</span>

<span class="fc" id="L4932">        public int size()                                           {return 1;}</span>
<span class="fc" id="L4933">        public boolean isEmpty()                                {return false;}</span>
<span class="nc" id="L4934">        public boolean containsKey(Object key)             {return eq(key, k);}</span>
<span class="nc" id="L4935">        public boolean containsValue(Object value)       {return eq(value, v);}</span>
<span class="fc bfc" id="L4936" title="All 2 branches covered.">        public V get(Object key)              {return (eq(key, k) ? v : null);}</span>

<span class="fc" id="L4938">        private transient Set&lt;K&gt; keySet = null;</span>
<span class="fc" id="L4939">        private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;</span>
<span class="fc" id="L4940">        private transient Collection&lt;V&gt; values = null;</span>

        public Set&lt;K&gt; keySet() {
<span class="fc bfc" id="L4943" title="All 2 branches covered.">            if (keySet==null)</span>
<span class="fc" id="L4944">                keySet = singleton(k);</span>
<span class="fc" id="L4945">            return keySet;</span>
        }

        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<span class="fc bfc" id="L4949" title="All 2 branches covered.">            if (entrySet==null)</span>
<span class="fc" id="L4950">                entrySet = Collections.&lt;Map.Entry&lt;K,V&gt;&gt;singleton(</span>
                    new SimpleImmutableEntry&lt;&gt;(k, v));
<span class="fc" id="L4952">            return entrySet;</span>
        }

        public Collection&lt;V&gt; values() {
<span class="fc bfc" id="L4956" title="All 2 branches covered.">            if (values==null)</span>
<span class="fc" id="L4957">                values = singleton(v);</span>
<span class="fc" id="L4958">            return values;</span>
        }

        // Override default methods in Map
        @Override
        public V getOrDefault(Object key, V defaultValue) {
<span class="nc bnc" id="L4964" title="All 2 branches missed.">            return eq(key, k) ? v : defaultValue;</span>
        }

        @Override
        public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<span class="nc" id="L4969">            action.accept(k, v);</span>
<span class="nc" id="L4970">        }</span>

        @Override
        public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
<span class="nc" id="L4974">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V putIfAbsent(K key, V value) {
<span class="nc" id="L4979">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean remove(Object key, Object value) {
<span class="nc" id="L4984">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean replace(K key, V oldValue, V newValue) {
<span class="nc" id="L4989">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V replace(K key, V value) {
<span class="nc" id="L4994">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V computeIfAbsent(K key,
                Function&lt;? super K, ? extends V&gt; mappingFunction) {
<span class="nc" id="L5000">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V computeIfPresent(K key,
                BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L5006">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V compute(K key,
                BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L5012">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V merge(K key, V value,
                BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L5018">            throw new UnsupportedOperationException();</span>
        }
    }

    // Miscellaneous

    /**
     * Returns an immutable list consisting of &lt;tt&gt;n&lt;/tt&gt; copies of the
     * specified object.  The newly allocated data object is tiny (it contains
     * a single reference to the data object).  This method is useful in
     * combination with the &lt;tt&gt;List.addAll&lt;/tt&gt; method to grow lists.
     * The returned list is serializable.
     *
     * @param  &lt;T&gt; the class of the object to copy and of the objects
     *         in the returned list.
     * @param  n the number of elements in the returned list.
     * @param  o the element to appear repeatedly in the returned list.
     * @return an immutable list consisting of &lt;tt&gt;n&lt;/tt&gt; copies of the
     *         specified object.
     * @throws IllegalArgumentException if {@code n &lt; 0}
     * @see    List#addAll(Collection)
     * @see    List#addAll(int, Collection)
     */
    public static &lt;T&gt; List&lt;T&gt; nCopies(int n, T o) {
<span class="nc bnc" id="L5042" title="All 2 branches missed.">        if (n &lt; 0)</span>
<span class="nc" id="L5043">            throw new IllegalArgumentException(&quot;List length = &quot; + n);</span>
<span class="nc" id="L5044">        return new CopiesList&lt;&gt;(n, o);</span>
    }

    /**
     * @serial include
     */
<span class="pc bpc" id="L5050" title="1 of 2 branches missed.">    private static class CopiesList&lt;E&gt;</span>
        extends AbstractList&lt;E&gt;
        implements RandomAccess, Serializable
    {
        private static final long serialVersionUID = 2739099268398711800L;

        final int n;
        final E element;

<span class="fc" id="L5059">        CopiesList(int n, E e) {</span>
<span class="pc bpc" id="L5060" title="2 of 4 branches missed.">            assert n &gt;= 0;</span>
<span class="fc" id="L5061">            this.n = n;</span>
<span class="fc" id="L5062">            element = e;</span>
<span class="fc" id="L5063">        }</span>

        public int size() {
<span class="fc" id="L5066">            return n;</span>
        }

        public boolean contains(Object obj) {
<span class="pc bpc" id="L5070" title="1 of 4 branches missed.">            return n != 0 &amp;&amp; eq(obj, element);</span>
        }

        public int indexOf(Object o) {
<span class="fc bfc" id="L5074" title="All 2 branches covered.">            return contains(o) ? 0 : -1;</span>
        }

        public int lastIndexOf(Object o) {
<span class="fc bfc" id="L5078" title="All 2 branches covered.">            return contains(o) ? n - 1 : -1;</span>
        }

        public E get(int index) {
<span class="pc bpc" id="L5082" title="1 of 4 branches missed.">            if (index &lt; 0 || index &gt;= n)</span>
<span class="fc" id="L5083">                throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+</span>
                                                    &quot;, Size: &quot;+n);
<span class="fc" id="L5085">            return element;</span>
        }

        public Object[] toArray() {
<span class="fc" id="L5089">            final Object[] a = new Object[n];</span>
<span class="pc bpc" id="L5090" title="1 of 2 branches missed.">            if (element != null)</span>
<span class="fc" id="L5091">                Arrays.fill(a, 0, n, element);</span>
<span class="fc" id="L5092">            return a;</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;T&gt; T[] toArray(T[] a) {
<span class="fc" id="L5097">            final int n = this.n;</span>
<span class="fc bfc" id="L5098" title="All 2 branches covered.">            if (a.length &lt; n) {</span>
<span class="fc" id="L5099">                a = (T[])java.lang.reflect.Array</span>
<span class="fc" id="L5100">                    .newInstance(a.getClass().getComponentType(), n);</span>
<span class="pc bpc" id="L5101" title="1 of 2 branches missed.">                if (element != null)</span>
<span class="fc" id="L5102">                    Arrays.fill(a, 0, n, element);</span>
            } else {
<span class="fc" id="L5104">                Arrays.fill(a, 0, n, element);</span>
<span class="fc bfc" id="L5105" title="All 2 branches covered.">                if (a.length &gt; n)</span>
<span class="fc" id="L5106">                    a[n] = null;</span>
            }
<span class="fc" id="L5108">            return a;</span>
        }

        public List&lt;E&gt; subList(int fromIndex, int toIndex) {
<span class="pc bpc" id="L5112" title="1 of 2 branches missed.">            if (fromIndex &lt; 0)</span>
<span class="nc" id="L5113">                throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);</span>
<span class="pc bpc" id="L5114" title="1 of 2 branches missed.">            if (toIndex &gt; n)</span>
<span class="nc" id="L5115">                throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);</span>
<span class="pc bpc" id="L5116" title="1 of 2 branches missed.">            if (fromIndex &gt; toIndex)</span>
<span class="nc" id="L5117">                throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +</span>
                                                   &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);
<span class="fc" id="L5119">            return new CopiesList&lt;&gt;(toIndex - fromIndex, element);</span>
        }

        // Override default methods in Collection
        @Override
        public Stream&lt;E&gt; stream() {
<span class="nc" id="L5125">            return IntStream.range(0, n).mapToObj(i -&gt; element);</span>
        }

        @Override
        public Stream&lt;E&gt; parallelStream() {
<span class="nc" id="L5130">            return IntStream.range(0, n).parallel().mapToObj(i -&gt; element);</span>
        }

        @Override
        public Spliterator&lt;E&gt; spliterator() {
<span class="nc" id="L5135">            return stream().spliterator();</span>
        }
    }

    /**
     * Returns a comparator that imposes the reverse of the &lt;em&gt;natural
     * ordering&lt;/em&gt; on a collection of objects that implement the
     * {@code Comparable} interface.  (The natural ordering is the ordering
     * imposed by the objects' own {@code compareTo} method.)  This enables a
     * simple idiom for sorting (or maintaining) collections (or arrays) of
     * objects that implement the {@code Comparable} interface in
     * reverse-natural-order.  For example, suppose {@code a} is an array of
     * strings. Then: &lt;pre&gt;
     *          Arrays.sort(a, Collections.reverseOrder());
     * &lt;/pre&gt; sorts the array in reverse-lexicographic (alphabetical) order.&lt;p&gt;
     *
     * The returned comparator is serializable.
     *
     * @param  &lt;T&gt; the class of the objects compared by the comparator
     * @return A comparator that imposes the reverse of the &lt;i&gt;natural
     *         ordering&lt;/i&gt; on a collection of objects that implement
     *         the &lt;tt&gt;Comparable&lt;/tt&gt; interface.
     * @see Comparable
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder() {
<span class="nc" id="L5161">        return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;</span>
    }

    /**
     * @serial include
     */
<span class="fc" id="L5167">    private static class ReverseComparator</span>
        implements Comparator&lt;Comparable&lt;Object&gt;&gt;, Serializable {

        private static final long serialVersionUID = 7207038068494060240L;

<span class="fc" id="L5172">        static final ReverseComparator REVERSE_ORDER</span>
            = new ReverseComparator();

        public int compare(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2) {
<span class="fc" id="L5176">            return c2.compareTo(c1);</span>
        }

<span class="fc" id="L5179">        private Object readResolve() { return Collections.reverseOrder(); }</span>

        @Override
        public Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() {
<span class="nc" id="L5183">            return Comparator.naturalOrder();</span>
        }
    }

    /**
     * Returns a comparator that imposes the reverse ordering of the specified
     * comparator.  If the specified comparator is {@code null}, this method is
     * equivalent to {@link #reverseOrder()} (in other words, it returns a
     * comparator that imposes the reverse of the &lt;em&gt;natural ordering&lt;/em&gt; on
     * a collection of objects that implement the Comparable interface).
     *
     * &lt;p&gt;The returned comparator is serializable (assuming the specified
     * comparator is also serializable or {@code null}).
     *
     * @param &lt;T&gt; the class of the objects compared by the comparator
     * @param cmp a comparator who's ordering is to be reversed by the returned
     * comparator or {@code null}
     * @return A comparator that imposes the reverse ordering of the
     *         specified comparator.
     * @since 1.5
     */
    public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp) {
<span class="nc bnc" id="L5205" title="All 2 branches missed.">        if (cmp == null)</span>
<span class="nc" id="L5206">            return reverseOrder();</span>

<span class="nc bnc" id="L5208" title="All 2 branches missed.">        if (cmp instanceof ReverseComparator2)</span>
<span class="nc" id="L5209">            return ((ReverseComparator2&lt;T&gt;)cmp).cmp;</span>

<span class="nc" id="L5211">        return new ReverseComparator2&lt;&gt;(cmp);</span>
    }

    /**
     * @serial include
     */
<span class="pc bpc" id="L5217" title="1 of 2 branches missed.">    private static class ReverseComparator2&lt;T&gt; implements Comparator&lt;T&gt;,</span>
        Serializable
    {
        private static final long serialVersionUID = 4374092139857L;

        /**
         * The comparator specified in the static factory.  This will never
         * be null, as the static factory returns a ReverseComparator
         * instance if its argument is null.
         *
         * @serial
         */
        final Comparator&lt;T&gt; cmp;

<span class="fc" id="L5231">        ReverseComparator2(Comparator&lt;T&gt; cmp) {</span>
<span class="pc bpc" id="L5232" title="2 of 4 branches missed.">            assert cmp != null;</span>
<span class="fc" id="L5233">            this.cmp = cmp;</span>
<span class="fc" id="L5234">        }</span>

        public int compare(T t1, T t2) {
<span class="fc" id="L5237">            return cmp.compare(t2, t1);</span>
        }

        public boolean equals(Object o) {
<span class="pc bpc" id="L5241" title="2 of 4 branches missed.">            return (o == this) ||</span>
                (o instanceof ReverseComparator2 &amp;&amp;
<span class="pc bpc" id="L5243" title="1 of 2 branches missed.">                 cmp.equals(((ReverseComparator2)o).cmp));</span>
        }

        public int hashCode() {
<span class="fc" id="L5247">            return cmp.hashCode() ^ Integer.MIN_VALUE;</span>
        }

        @Override
        public Comparator&lt;T&gt; reversed() {
<span class="nc" id="L5252">            return cmp;</span>
        }
    }

    /**
     * Returns an enumeration over the specified collection.  This provides
     * interoperability with legacy APIs that require an enumeration
     * as input.
     *
     * @param  &lt;T&gt; the class of the objects in the collection
     * @param c the collection for which an enumeration is to be returned.
     * @return an enumeration over the specified collection.
     * @see Enumeration
     */
    public static &lt;T&gt; Enumeration&lt;T&gt; enumeration(final Collection&lt;T&gt; c) {
<span class="pc" id="L5267">        return new Enumeration&lt;T&gt;() {</span>
<span class="fc" id="L5268">            private final Iterator&lt;T&gt; i = c.iterator();</span>

            public boolean hasMoreElements() {
<span class="fc" id="L5271">                return i.hasNext();</span>
            }

            public T nextElement() {
<span class="fc" id="L5275">                return i.next();</span>
            }
        };
    }

    /**
     * Returns an array list containing the elements returned by the
     * specified enumeration in the order they are returned by the
     * enumeration.  This method provides interoperability between
     * legacy APIs that return enumerations and new APIs that require
     * collections.
     *
     * @param &lt;T&gt; the class of the objects returned by the enumeration
     * @param e enumeration providing elements for the returned
     *          array list
     * @return an array list containing the elements returned
     *         by the specified enumeration.
     * @since 1.4
     * @see Enumeration
     * @see ArrayList
     */
    public static &lt;T&gt; ArrayList&lt;T&gt; list(Enumeration&lt;T&gt; e) {
<span class="nc" id="L5297">        ArrayList&lt;T&gt; l = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L5298" title="All 2 branches missed.">        while (e.hasMoreElements())</span>
<span class="nc" id="L5299">            l.add(e.nextElement());</span>
<span class="nc" id="L5300">        return l;</span>
    }

    /**
     * Returns true if the specified arguments are equal, or both null.
     *
     * NB: Do not replace with Object.equals until JDK-8015417 is resolved.
     */
    static boolean eq(Object o1, Object o2) {
<span class="nc bnc" id="L5309" title="All 4 branches missed.">        return o1==null ? o2==null : o1.equals(o2);</span>
    }

    /**
     * Returns the number of elements in the specified collection equal to the
     * specified object.  More formally, returns the number of elements
     * &lt;tt&gt;e&lt;/tt&gt; in the collection such that
     * &lt;tt&gt;(o == null ? e == null : o.equals(e))&lt;/tt&gt;.
     *
     * @param c the collection in which to determine the frequency
     *     of &lt;tt&gt;o&lt;/tt&gt;
     * @param o the object whose frequency is to be determined
     * @return the number of elements in {@code c} equal to {@code o}
     * @throws NullPointerException if &lt;tt&gt;c&lt;/tt&gt; is null
     * @since 1.5
     */
    public static int frequency(Collection&lt;?&gt; c, Object o) {
<span class="nc" id="L5326">        int result = 0;</span>
<span class="nc bnc" id="L5327" title="All 2 branches missed.">        if (o == null) {</span>
<span class="nc bnc" id="L5328" title="All 2 branches missed.">            for (Object e : c)</span>
<span class="nc bnc" id="L5329" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L5330">                    result++;</span>
        } else {
<span class="nc bnc" id="L5332" title="All 2 branches missed.">            for (Object e : c)</span>
<span class="nc bnc" id="L5333" title="All 2 branches missed.">                if (o.equals(e))</span>
<span class="nc" id="L5334">                    result++;</span>
        }
<span class="nc" id="L5336">        return result;</span>
    }

    /**
     * Returns {@code true} if the two specified collections have no
     * elements in common.
     *
     * &lt;p&gt;Care must be exercised if this method is used on collections that
     * do not comply with the general contract for {@code Collection}.
     * Implementations may elect to iterate over either collection and test
     * for containment in the other collection (or to perform any equivalent
     * computation).  If either collection uses a nonstandard equality test
     * (as does a {@link SortedSet} whose ordering is not &lt;em&gt;compatible with
     * equals&lt;/em&gt;, or the key set of an {@link IdentityHashMap}), both
     * collections must use the same nonstandard equality test, or the
     * result of this method is undefined.
     *
     * &lt;p&gt;Care must also be exercised when using collections that have
     * restrictions on the elements that they may contain. Collection
     * implementations are allowed to throw exceptions for any operation
     * involving elements they deem ineligible. For absolute safety the
     * specified collections should contain only elements which are
     * eligible elements for both collections.
     *
     * &lt;p&gt;Note that it is permissible to pass the same collection in both
     * parameters, in which case the method will return {@code true} if and
     * only if the collection is empty.
     *
     * @param c1 a collection
     * @param c2 a collection
     * @return {@code true} if the two specified collections have no
     * elements in common.
     * @throws NullPointerException if either collection is {@code null}.
     * @throws NullPointerException if one collection contains a {@code null}
     * element and {@code null} is not an eligible element for the other collection.
     * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
     * @throws ClassCastException if one collection contains an element that is
     * of a type which is ineligible for the other collection.
     * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
     * @since 1.5
     */
    public static boolean disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2) {
        // The collection to be used for contains(). Preference is given to
        // the collection who's contains() has lower O() complexity.
<span class="nc" id="L5380">        Collection&lt;?&gt; contains = c2;</span>
        // The collection to be iterated. If the collections' contains() impl
        // are of different O() complexity, the collection with slower
        // contains() will be used for iteration. For collections who's
        // contains() are of the same complexity then best performance is
        // achieved by iterating the smaller collection.
<span class="nc" id="L5386">        Collection&lt;?&gt; iterate = c1;</span>

        // Performance optimization cases. The heuristics:
        //   1. Generally iterate over c1.
        //   2. If c1 is a Set then iterate over c2.
        //   3. If either collection is empty then result is always true.
        //   4. Iterate over the smaller Collection.
<span class="nc bnc" id="L5393" title="All 2 branches missed.">        if (c1 instanceof Set) {</span>
            // Use c1 for contains as a Set's contains() is expected to perform
            // better than O(N/2)
<span class="nc" id="L5396">            iterate = c2;</span>
<span class="nc" id="L5397">            contains = c1;</span>
<span class="nc bnc" id="L5398" title="All 2 branches missed.">        } else if (!(c2 instanceof Set)) {</span>
            // Both are mere Collections. Iterate over smaller collection.
            // Example: If c1 contains 3 elements and c2 contains 50 elements and
            // assuming contains() requires ceiling(N/2) comparisons then
            // checking for all c1 elements in c2 would require 75 comparisons
            // (3 * ceiling(50/2)) vs. checking all c2 elements in c1 requiring
            // 100 comparisons (50 * ceiling(3/2)).
<span class="nc" id="L5405">            int c1size = c1.size();</span>
<span class="nc" id="L5406">            int c2size = c2.size();</span>
<span class="nc bnc" id="L5407" title="All 4 branches missed.">            if (c1size == 0 || c2size == 0) {</span>
                // At least one collection is empty. Nothing will match.
<span class="nc" id="L5409">                return true;</span>
            }

<span class="nc bnc" id="L5412" title="All 2 branches missed.">            if (c1size &gt; c2size) {</span>
<span class="nc" id="L5413">                iterate = c2;</span>
<span class="nc" id="L5414">                contains = c1;</span>
            }
        }

<span class="nc bnc" id="L5418" title="All 2 branches missed.">        for (Object e : iterate) {</span>
<span class="nc bnc" id="L5419" title="All 2 branches missed.">            if (contains.contains(e)) {</span>
               // Found a common element. Collections are not disjoint.
<span class="nc" id="L5421">                return false;</span>
            }
<span class="nc" id="L5423">        }</span>

        // No common elements were found.
<span class="nc" id="L5426">        return true;</span>
    }

    /**
     * Adds all of the specified elements to the specified collection.
     * Elements to be added may be specified individually or as an array.
     * The behavior of this convenience method is identical to that of
     * &lt;tt&gt;c.addAll(Arrays.asList(elements))&lt;/tt&gt;, but this method is likely
     * to run significantly faster under most implementations.
     *
     * &lt;p&gt;When elements are specified individually, this method provides a
     * convenient way to add a few elements to an existing collection:
     * &lt;pre&gt;
     *     Collections.addAll(flavors, &quot;Peaches 'n Plutonium&quot;, &quot;Rocky Racoon&quot;);
     * &lt;/pre&gt;
     *
     * @param  &lt;T&gt; the class of the elements to add and of the collection
     * @param c the collection into which &lt;tt&gt;elements&lt;/tt&gt; are to be inserted
     * @param elements the elements to insert into &lt;tt&gt;c&lt;/tt&gt;
     * @return &lt;tt&gt;true&lt;/tt&gt; if the collection changed as a result of the call
     * @throws UnsupportedOperationException if &lt;tt&gt;c&lt;/tt&gt; does not support
     *         the &lt;tt&gt;add&lt;/tt&gt; operation
     * @throws NullPointerException if &lt;tt&gt;elements&lt;/tt&gt; contains one or more
     *         null values and &lt;tt&gt;c&lt;/tt&gt; does not permit null elements, or
     *         if &lt;tt&gt;c&lt;/tt&gt; or &lt;tt&gt;elements&lt;/tt&gt; are &lt;tt&gt;null&lt;/tt&gt;
     * @throws IllegalArgumentException if some property of a value in
     *         &lt;tt&gt;elements&lt;/tt&gt; prevents it from being added to &lt;tt&gt;c&lt;/tt&gt;
     * @see Collection#addAll(Collection)
     * @since 1.5
     */
    @SafeVarargs
    public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements) {
<span class="nc" id="L5458">        boolean result = false;</span>
<span class="nc bnc" id="L5459" title="All 2 branches missed.">        for (T element : elements)</span>
<span class="nc" id="L5460">            result |= c.add(element);</span>
<span class="nc" id="L5461">        return result;</span>
    }

    /**
     * Returns a set backed by the specified map.  The resulting set displays
     * the same ordering, concurrency, and performance characteristics as the
     * backing map.  In essence, this factory method provides a {@link Set}
     * implementation corresponding to any {@link Map} implementation.  There
     * is no need to use this method on a {@link Map} implementation that
     * already has a corresponding {@link Set} implementation (such as {@link
     * HashMap} or {@link TreeMap}).
     *
     * &lt;p&gt;Each method invocation on the set returned by this method results in
     * exactly one method invocation on the backing map or its &lt;tt&gt;keySet&lt;/tt&gt;
     * view, with one exception.  The &lt;tt&gt;addAll&lt;/tt&gt; method is implemented
     * as a sequence of &lt;tt&gt;put&lt;/tt&gt; invocations on the backing map.
     *
     * &lt;p&gt;The specified map must be empty at the time this method is invoked,
     * and should not be accessed directly after this method returns.  These
     * conditions are ensured if the map is created empty, passed directly
     * to this method, and no reference to the map is retained, as illustrated
     * in the following code fragment:
     * &lt;pre&gt;
     *    Set&amp;lt;Object&amp;gt; weakHashSet = Collections.newSetFromMap(
     *        new WeakHashMap&amp;lt;Object, Boolean&amp;gt;());
     * &lt;/pre&gt;
     *
     * @param &lt;E&gt; the class of the map keys and of the objects in the
     *        returned set
     * @param map the backing map
     * @return the set backed by the map
     * @throws IllegalArgumentException if &lt;tt&gt;map&lt;/tt&gt; is not empty
     * @since 1.6
     */
    public static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map) {
<span class="nc" id="L5496">        return new SetFromMap&lt;&gt;(map);</span>
    }

    /**
     * @serial include
     */
    private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt;
        implements Set&lt;E&gt;, Serializable
    {
        private final Map&lt;E, Boolean&gt; m;  // The backing map
        private transient Set&lt;E&gt; s;       // Its keySet

<span class="fc" id="L5508">        SetFromMap(Map&lt;E, Boolean&gt; map) {</span>
<span class="pc bpc" id="L5509" title="1 of 2 branches missed.">            if (!map.isEmpty())</span>
<span class="nc" id="L5510">                throw new IllegalArgumentException(&quot;Map is non-empty&quot;);</span>
<span class="fc" id="L5511">            m = map;</span>
<span class="fc" id="L5512">            s = map.keySet();</span>
<span class="fc" id="L5513">        }</span>

<span class="nc" id="L5515">        public void clear()               {        m.clear(); }</span>
<span class="fc" id="L5516">        public int size()                 { return m.size(); }</span>
<span class="nc" id="L5517">        public boolean isEmpty()          { return m.isEmpty(); }</span>
<span class="fc" id="L5518">        public boolean contains(Object o) { return m.containsKey(o); }</span>
<span class="nc bnc" id="L5519" title="All 2 branches missed.">        public boolean remove(Object o)   { return m.remove(o) != null; }</span>
<span class="pc bpc" id="L5520" title="1 of 2 branches missed.">        public boolean add(E e) { return m.put(e, Boolean.TRUE) == null; }</span>
<span class="nc" id="L5521">        public Iterator&lt;E&gt; iterator()     { return s.iterator(); }</span>
<span class="nc" id="L5522">        public Object[] toArray()         { return s.toArray(); }</span>
<span class="nc" id="L5523">        public &lt;T&gt; T[] toArray(T[] a)     { return s.toArray(a); }</span>
<span class="nc" id="L5524">        public String toString()          { return s.toString(); }</span>
<span class="nc" id="L5525">        public int hashCode()             { return s.hashCode(); }</span>
<span class="nc bnc" id="L5526" title="All 4 branches missed.">        public boolean equals(Object o)   { return o == this || s.equals(o); }</span>
<span class="nc" id="L5527">        public boolean containsAll(Collection&lt;?&gt; c) {return s.containsAll(c);}</span>
<span class="nc" id="L5528">        public boolean removeAll(Collection&lt;?&gt; c)   {return s.removeAll(c);}</span>
<span class="nc" id="L5529">        public boolean retainAll(Collection&lt;?&gt; c)   {return s.retainAll(c);}</span>
        // addAll is the only inherited implementation

        // Override default methods in Collection
        @Override
        public void forEach(Consumer&lt;? super E&gt; action) {
<span class="nc" id="L5535">            s.forEach(action);</span>
<span class="nc" id="L5536">        }</span>
        @Override
        public boolean removeIf(Predicate&lt;? super E&gt; filter) {
<span class="nc" id="L5539">            return s.removeIf(filter);</span>
        }

        @Override
<span class="nc" id="L5543">        public Spliterator&lt;E&gt; spliterator() {return s.spliterator();}</span>
        @Override
<span class="nc" id="L5545">        public Stream&lt;E&gt; stream()           {return s.stream();}</span>
        @Override
<span class="nc" id="L5547">        public Stream&lt;E&gt; parallelStream()   {return s.parallelStream();}</span>

        private static final long serialVersionUID = 2454657854757543876L;

        private void readObject(java.io.ObjectInputStream stream)
            throws IOException, ClassNotFoundException
        {
<span class="nc" id="L5554">            stream.defaultReadObject();</span>
<span class="nc" id="L5555">            s = m.keySet();</span>
<span class="nc" id="L5556">        }</span>
    }

    /**
     * Returns a view of a {@link Deque} as a Last-in-first-out (Lifo)
     * {@link Queue}. Method &lt;tt&gt;add&lt;/tt&gt; is mapped to &lt;tt&gt;push&lt;/tt&gt;,
     * &lt;tt&gt;remove&lt;/tt&gt; is mapped to &lt;tt&gt;pop&lt;/tt&gt; and so on. This
     * view can be useful when you would like to use a method
     * requiring a &lt;tt&gt;Queue&lt;/tt&gt; but you need Lifo ordering.
     *
     * &lt;p&gt;Each method invocation on the queue returned by this method
     * results in exactly one method invocation on the backing deque, with
     * one exception.  The {@link Queue#addAll addAll} method is
     * implemented as a sequence of {@link Deque#addFirst addFirst}
     * invocations on the backing deque.
     *
     * @param  &lt;T&gt; the class of the objects in the deque
     * @param deque the deque
     * @return the queue
     * @since  1.6
     */
    public static &lt;T&gt; Queue&lt;T&gt; asLifoQueue(Deque&lt;T&gt; deque) {
<span class="nc" id="L5578">        return new AsLIFOQueue&lt;&gt;(deque);</span>
    }

    /**
     * @serial include
     */
    static class AsLIFOQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
        implements Queue&lt;E&gt;, Serializable {
        private static final long serialVersionUID = 1802017725587941708L;
        private final Deque&lt;E&gt; q;
<span class="nc" id="L5588">        AsLIFOQueue(Deque&lt;E&gt; q)           { this.q = q; }</span>
<span class="nc" id="L5589">        public boolean add(E e)           { q.addFirst(e); return true; }</span>
<span class="nc" id="L5590">        public boolean offer(E e)         { return q.offerFirst(e); }</span>
<span class="nc" id="L5591">        public E poll()                   { return q.pollFirst(); }</span>
<span class="nc" id="L5592">        public E remove()                 { return q.removeFirst(); }</span>
<span class="nc" id="L5593">        public E peek()                   { return q.peekFirst(); }</span>
<span class="nc" id="L5594">        public E element()                { return q.getFirst(); }</span>
<span class="nc" id="L5595">        public void clear()               {        q.clear(); }</span>
<span class="nc" id="L5596">        public int size()                 { return q.size(); }</span>
<span class="nc" id="L5597">        public boolean isEmpty()          { return q.isEmpty(); }</span>
<span class="nc" id="L5598">        public boolean contains(Object o) { return q.contains(o); }</span>
<span class="nc" id="L5599">        public boolean remove(Object o)   { return q.remove(o); }</span>
<span class="nc" id="L5600">        public Iterator&lt;E&gt; iterator()     { return q.iterator(); }</span>
<span class="nc" id="L5601">        public Object[] toArray()         { return q.toArray(); }</span>
<span class="nc" id="L5602">        public &lt;T&gt; T[] toArray(T[] a)     { return q.toArray(a); }</span>
<span class="nc" id="L5603">        public String toString()          { return q.toString(); }</span>
<span class="nc" id="L5604">        public boolean containsAll(Collection&lt;?&gt; c) {return q.containsAll(c);}</span>
<span class="nc" id="L5605">        public boolean removeAll(Collection&lt;?&gt; c)   {return q.removeAll(c);}</span>
<span class="nc" id="L5606">        public boolean retainAll(Collection&lt;?&gt; c)   {return q.retainAll(c);}</span>
        // We use inherited addAll; forwarding addAll would be wrong

        // Override default methods in Collection
        @Override
<span class="nc" id="L5611">        public void forEach(Consumer&lt;? super E&gt; action) {q.forEach(action);}</span>
        @Override
        public boolean removeIf(Predicate&lt;? super E&gt; filter) {
<span class="nc" id="L5614">            return q.removeIf(filter);</span>
        }
        @Override
<span class="nc" id="L5617">        public Spliterator&lt;E&gt; spliterator() {return q.spliterator();}</span>
        @Override
<span class="nc" id="L5619">        public Stream&lt;E&gt; stream()           {return q.stream();}</span>
        @Override
<span class="nc" id="L5621">        public Stream&lt;E&gt; parallelStream()   {return q.parallelStream();}</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>