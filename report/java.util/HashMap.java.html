<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>HashMap.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">HashMap.java</span></div><h1>HashMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.Serializable;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This
 * implementation provides all of the optional map operations, and permits
 * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;
 * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is
 * unsynchronized and permits nulls.)  This class makes no guarantees as to
 * the order of the map; in particular, it does not guarantee that the order
 * will remain constant over time.
 *
 * &lt;p&gt;This implementation provides constant-time performance for the basic
 * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function
 * disperses the elements properly among the buckets.  Iteration over
 * collection views requires time proportional to the &quot;capacity&quot; of the
 * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number
 * of key-value mappings).  Thus, it's very important not to set the initial
 * capacity too high (or the load factor too low) if iteration performance is
 * important.
 *
 * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its
 * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The
 * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial
 * capacity is simply the capacity at the time the hash table is created.  The
 * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to
 * get before its capacity is automatically increased.  When the number of
 * entries in the hash table exceeds the product of the load factor and the
 * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data
 * structures are rebuilt) so that the hash table has approximately twice the
 * number of buckets.
 *
 * &lt;p&gt;As a general rule, the default load factor (.75) offers a good
 * tradeoff between time and space costs.  Higher values decrease the
 * space overhead but increase the lookup cost (reflected in most of
 * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including
 * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number of entries in
 * the map and its load factor should be taken into account when
 * setting its initial capacity, so as to minimize the number of
 * rehash operations.  If the initial capacity is greater than the
 * maximum number of entries divided by the load factor, no rehash
 * operations will ever occur.
 *
 * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt;
 * instance, creating it with a sufficiently large capacity will allow
 * the mappings to be stored more efficiently than letting it perform
 * automatic rehashing as needed to grow the table.  Note that using
 * many keys with the same {@code hashCode()} is a sure way to slow
 * down performance of any hash table. To ameliorate impact, when keys
 * are {@link Comparable}, this class may use comparison order among
 * keys to help break ties.
 *
 * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
 * If multiple threads access a hash map concurrently, and at least one of
 * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be
 * synchronized externally.  (A structural modification is any operation
 * that adds or deletes one or more mappings; merely changing the value
 * associated with a key that an instance already contains is not a
 * structural modification.)  This is typically accomplished by
 * synchronizing on some object that naturally encapsulates the map.
 *
 * If no such object exists, the map should be &quot;wrapped&quot; using the
 * {@link Collections#synchronizedMap Collections.synchronizedMap}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access to the map:&lt;pre&gt;
 *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;
 *
 * &lt;p&gt;The iterators returned by all of this class's &quot;collection view methods&quot;
 * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after
 * the iterator is created, in any way except through the iterator's own
 * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a
 * {@link ConcurrentModificationException}.  Thus, in the face of concurrent
 * modification, the iterator fails quickly and cleanly, rather than risking
 * arbitrary, non-deterministic behavior at an undetermined time in the
 * future.
 *
 * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
 * should be used only to detect bugs.&lt;/i&gt;
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @param &lt;K&gt; the type of keys maintained by this map
 * @param &lt;V&gt; the type of mapped values
 *
 * @author  Doug Lea
 * @author  Josh Bloch
 * @author  Arthur van Hoff
 * @author  Neal Gafter
 * @see     Object#hashCode()
 * @see     Collection
 * @see     Map
 * @see     TreeMap
 * @see     Hashtable
 * @since   1.2
 */
public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable {

    private static final long serialVersionUID = 362498820763181265L;

    /*
     * Implementation notes.
     *
     * This map usually acts as a binned (bucketed) hash table, but
     * when bins get too large, they are transformed into bins of
     * TreeNodes, each structured similarly to those in
     * java.util.TreeMap. Most methods try to use normal bins, but
     * relay to TreeNode methods when applicable (simply by checking
     * instanceof a node).  Bins of TreeNodes may be traversed and
     * used like any others, but additionally support faster lookup
     * when overpopulated. However, since the vast majority of bins in
     * normal use are not overpopulated, checking for existence of
     * tree bins may be delayed in the course of table methods.
     *
     * Tree bins (i.e., bins whose elements are all TreeNodes) are
     * ordered primarily by hashCode, but in the case of ties, if two
     * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,
     * type then their compareTo method is used for ordering. (We
     * conservatively check generic types via reflection to validate
     * this -- see method comparableClassFor).  The added complexity
     * of tree bins is worthwhile in providing worst-case O(log n)
     * operations when keys either have distinct hashes or are
     * orderable, Thus, performance degrades gracefully under
     * accidental or malicious usages in which hashCode() methods
     * return values that are poorly distributed, as well as those in
     * which many keys share a hashCode, so long as they are also
     * Comparable. (If neither of these apply, we may waste about a
     * factor of two in time and space compared to taking no
     * precautions. But the only known cases stem from poor user
     * programming practices that are already so slow that this makes
     * little difference.)
     *
     * Because TreeNodes are about twice the size of regular nodes, we
     * use them only when bins contain enough nodes to warrant use
     * (see TREEIFY_THRESHOLD). And when they become too small (due to
     * removal or resizing) they are converted back to plain bins.  In
     * usages with well-distributed user hashCodes, tree bins are
     * rarely used.  Ideally, under random hashCodes, the frequency of
     * nodes in bins follows a Poisson distribution
     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a
     * parameter of about 0.5 on average for the default resizing
     * threshold of 0.75, although with a large variance because of
     * resizing granularity. Ignoring variance, the expected
     * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /
     * factorial(k)). The first values are:
     *
     * 0:    0.60653066
     * 1:    0.30326533
     * 2:    0.07581633
     * 3:    0.01263606
     * 4:    0.00157952
     * 5:    0.00015795
     * 6:    0.00001316
     * 7:    0.00000094
     * 8:    0.00000006
     * more: less than 1 in ten million
     *
     * The root of a tree bin is normally its first node.  However,
     * sometimes (currently only upon Iterator.remove), the root might
     * be elsewhere, but can be recovered following parent links
     * (method TreeNode.root()).
     *
     * All applicable internal methods accept a hash code as an
     * argument (as normally supplied from a public method), allowing
     * them to call each other without recomputing user hashCodes.
     * Most internal methods also accept a &quot;tab&quot; argument, that is
     * normally the current table, but may be a new or old one when
     * resizing or converting.
     *
     * When bin lists are treeified, split, or untreeified, we keep
     * them in the same relative access/traversal order (i.e., field
     * Node.next) to better preserve locality, and to slightly
     * simplify handling of splits and traversals that invoke
     * iterator.remove. When using comparators on insertion, to keep a
     * total ordering (or as close as is required here) across
     * rebalancings, we compare classes and identityHashCodes as
     * tie-breakers.
     *
     * The use and transitions among plain vs tree modes is
     * complicated by the existence of subclass LinkedHashMap. See
     * below for hook methods defined to be invoked upon insertion,
     * removal and access that allow LinkedHashMap internals to
     * otherwise remain independent of these mechanics. (This also
     * requires that a map instance be passed to some utility methods
     * that may create new nodes.)
     *
     * The concurrent-programming-like SSA-based coding style helps
     * avoid aliasing errors amid all of the twisty pointer operations.
     */

    /**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16

    /**
     * The maximum capacity, used if a higher value is implicitly specified
     * by either of the constructors with arguments.
     * MUST be a power of two &lt;= 1&lt;&lt;30.
     */
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

    /**
     * The load factor used when none specified in constructor.
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * The bin count threshold for using a tree rather than list for a
     * bin.  Bins are converted to trees when adding an element to a
     * bin with at least this many nodes. The value must be greater
     * than 2 and should be at least 8 to mesh with assumptions in
     * tree removal about conversion back to plain bins upon
     * shrinkage.
     */
    static final int TREEIFY_THRESHOLD = 8;

    /**
     * The bin count threshold for untreeifying a (split) bin during a
     * resize operation. Should be less than TREEIFY_THRESHOLD, and at
     * most 6 to mesh with shrinkage detection under removal.
     */
    static final int UNTREEIFY_THRESHOLD = 6;

    /**
     * The smallest table capacity for which bins may be treeified.
     * (Otherwise the table is resized if too many nodes in a bin.)
     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts
     * between resizing and treeification thresholds.
     */
    static final int MIN_TREEIFY_CAPACITY = 64;

    /**
     * Basic hash bin node, used for most entries.  (See below for
     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
     */
    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next;

<span class="fc" id="L284">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {</span>
<span class="fc" id="L285">            this.hash = hash;</span>
<span class="fc" id="L286">            this.key = key;</span>
<span class="fc" id="L287">            this.value = value;</span>
<span class="fc" id="L288">            this.next = next;</span>
<span class="fc" id="L289">        }</span>

<span class="fc" id="L291">        public final K getKey()        { return key; }</span>
<span class="fc" id="L292">        public final V getValue()      { return value; }</span>
<span class="fc" id="L293">        public final String toString() { return key + &quot;=&quot; + value; }</span>

        public final int hashCode() {
<span class="fc" id="L296">            return Objects.hashCode(key) ^ Objects.hashCode(value);</span>
        }

        public final V setValue(V newValue) {
<span class="fc" id="L300">            V oldValue = value;</span>
<span class="fc" id="L301">            value = newValue;</span>
<span class="fc" id="L302">            return oldValue;</span>
        }

        public final boolean equals(Object o) {
<span class="fc bfc" id="L306" title="All 2 branches covered.">            if (o == this)</span>
<span class="fc" id="L307">                return true;</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">            if (o instanceof Map.Entry) {</span>
<span class="fc" id="L309">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">                if (Objects.equals(key, e.getKey()) &amp;&amp;</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">                    Objects.equals(value, e.getValue()))</span>
<span class="fc" id="L312">                    return true;</span>
            }
<span class="nc" id="L314">            return false;</span>
        }
    }

    /* ---------------- Static utilities -------------- */

    /**
     * Computes key.hashCode() and spreads (XORs) higher bits of hash
     * to lower.  Because the table uses power-of-two masking, sets of
     * hashes that vary only in bits above the current mask will
     * always collide. (Among known examples are sets of Float keys
     * holding consecutive whole numbers in small tables.)  So we
     * apply a transform that spreads the impact of higher bits
     * downward. There is a tradeoff between speed, utility, and
     * quality of bit-spreading. Because many common sets of hashes
     * are already reasonably distributed (so don't benefit from
     * spreading), and because we use trees to handle large sets of
     * collisions in bins, we just XOR some shifted bits in the
     * cheapest possible way to reduce systematic lossage, as well as
     * to incorporate impact of the highest bits that would otherwise
     * never be used in index calculations because of table bounds.
     */
    static final int hash(Object key) {
        int h;
<span class="fc bfc" id="L338" title="All 2 branches covered.">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span>
    }

    /**
     * Returns x's Class if it is of the form &quot;class C implements
     * Comparable&lt;C&gt;&quot;, else null.
     */
    static Class&lt;?&gt; comparableClassFor(Object x) {
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (x instanceof Comparable) {</span>
            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;
<span class="fc bfc" id="L348" title="All 2 branches covered.">            if ((c = x.getClass()) == String.class) // bypass checks</span>
<span class="fc" id="L349">                return c;</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if ((ts = c.getGenericInterfaces()) != null) {</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">                for (int i = 0; i &lt; ts.length; ++i) {</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">                    if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">                        ((p = (ParameterizedType)t).getRawType() ==</span>
                         Comparable.class) &amp;&amp;
<span class="pc bpc" id="L355" title="3 of 6 branches missed.">                        (as = p.getActualTypeArguments()) != null &amp;&amp;</span>
                        as.length == 1 &amp;&amp; as[0] == c) // type arg is c
<span class="fc" id="L357">                        return c;</span>
                }
            }
        }
<span class="fc" id="L361">        return null;</span>
    }

    /**
     * Returns k.compareTo(x) if x matches kc (k's screened comparable
     * class), else 0.
     */
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) // for cast to Comparable
    static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) {
<span class="pc bpc" id="L370" title="1 of 4 branches missed.">        return (x == null || x.getClass() != kc ? 0 :</span>
<span class="fc" id="L371">                ((Comparable)k).compareTo(x));</span>
    }

    /**
     * Returns a power of two size for the given target capacity.
     */
    static final int tableSizeFor(int cap) {
<span class="fc" id="L378">        int n = cap - 1;</span>
<span class="fc" id="L379">        n |= n &gt;&gt;&gt; 1;</span>
<span class="fc" id="L380">        n |= n &gt;&gt;&gt; 2;</span>
<span class="fc" id="L381">        n |= n &gt;&gt;&gt; 4;</span>
<span class="fc" id="L382">        n |= n &gt;&gt;&gt; 8;</span>
<span class="fc" id="L383">        n |= n &gt;&gt;&gt; 16;</span>
<span class="pc bpc" id="L384" title="1 of 4 branches missed.">        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span>
    }

    /* ---------------- Fields -------------- */

    /**
     * The table, initialized on first use, and resized as
     * necessary. When allocated, length is always a power of two.
     * (We also tolerate length zero in some operations to allow
     * bootstrapping mechanics that are currently not needed.)
     */
    transient Node&lt;K,V&gt;[] table;

    /**
     * Holds cached entrySet(). Note that AbstractMap fields are used
     * for keySet() and values().
     */
    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;

    /**
     * The number of key-value mappings contained in this map.
     */
    transient int size;

    /**
     * The number of times this HashMap has been structurally modified
     * Structural modifications are those that change the number of mappings in
     * the HashMap or otherwise modify its internal structure (e.g.,
     * rehash).  This field is used to make iterators on Collection-views of
     * the HashMap fail-fast.  (See ConcurrentModificationException).
     */
    transient int modCount;

    /**
     * The next size value at which to resize (capacity * load factor).
     *
     * @serial
     */
    // (The javadoc description is true upon serialization.
    // Additionally, if the table array has not been allocated, this
    // field holds the initial array capacity, or zero signifying
    // DEFAULT_INITIAL_CAPACITY.)
    int threshold;

    /**
     * The load factor for the hash table.
     *
     * @serial
     */
    final float loadFactor;

    /* ---------------- Public operations -------------- */

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
     * capacity and load factor.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */
<span class="fc" id="L446">    public HashMap(int initialCapacity, float loadFactor) {</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (initialCapacity &lt; 0)</span>
<span class="nc" id="L448">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span>
                                               initialCapacity);
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span>
<span class="nc" id="L451">            initialCapacity = MAXIMUM_CAPACITY;</span>
<span class="fc bfc" id="L452" title="All 4 branches covered.">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span>
<span class="fc" id="L453">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span>
                                               loadFactor);
<span class="fc" id="L455">        this.loadFactor = loadFactor;</span>
<span class="fc" id="L456">        this.threshold = tableSizeFor(initialCapacity);</span>
<span class="fc" id="L457">    }</span>

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param  initialCapacity the initial capacity.
     * @throws IllegalArgumentException if the initial capacity is negative.
     */
    public HashMap(int initialCapacity) {
<span class="fc" id="L467">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span>
<span class="fc" id="L468">    }</span>

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity
     * (16) and the default load factor (0.75).
     */
<span class="fc" id="L474">    public HashMap() {</span>
<span class="fc" id="L475">        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span>
<span class="fc" id="L476">    }</span>

    /**
     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the
     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with
     * default load factor (0.75) and an initial capacity sufficient to
     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.
     *
     * @param   m the map whose mappings are to be placed in this map
     * @throws  NullPointerException if the specified map is null
     */
<span class="fc" id="L487">    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {</span>
<span class="fc" id="L488">        this.loadFactor = DEFAULT_LOAD_FACTOR;</span>
<span class="fc" id="L489">        putMapEntries(m, false);</span>
<span class="fc" id="L490">    }</span>

    /**
     * Implements Map.putAll and Map constructor
     *
     * @param m the map
     * @param evict false when initially constructing this map, else
     * true (relayed to method afterNodeInsertion).
     */
    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {
<span class="fc" id="L500">        int s = m.size();</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">        if (s &gt; 0) {</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">            if (table == null) { // pre-size</span>
<span class="fc" id="L503">                float ft = ((float)s / loadFactor) + 1.0F;</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span>
                         (int)ft : MAXIMUM_CAPACITY);
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">                if (t &gt; threshold)</span>
<span class="fc" id="L507">                    threshold = tableSizeFor(t);</span>
<span class="fc" id="L508">            }</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            else if (s &gt; threshold)</span>
<span class="fc" id="L510">                resize();</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {</span>
<span class="fc" id="L512">                K key = e.getKey();</span>
<span class="fc" id="L513">                V value = e.getValue();</span>
<span class="fc" id="L514">                putVal(hash(key), key, value, false, evict);</span>
<span class="fc" id="L515">            }</span>
        }
<span class="fc" id="L517">    }</span>

    /**
     * Returns the number of key-value mappings in this map.
     *
     * @return the number of key-value mappings in this map
     */
    public int size() {
<span class="fc" id="L525">        return size;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L534" title="All 2 branches covered.">        return size == 0;</span>
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * &lt;p&gt;More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code (key==null ? k==null :
     * key.equals(k))}, then this method returns {@code v}; otherwise
     * it returns {@code null}.  (There can be at most one such mapping.)
     *
     * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
     * indicate that the map contains no mapping for the key; it's also
     * possible that the map explicitly maps the key to {@code null}.
     * The {@link #containsKey containsKey} operation may be used to
     * distinguish these two cases.
     *
     * @see #put(Object, Object)
     */
    public V get(Object key) {
        Node&lt;K,V&gt; e;
<span class="fc bfc" id="L556" title="All 2 branches covered.">        return (e = getNode(hash(key), key)) == null ? null : e.value;</span>
    }

    /**
     * Implements Map.get and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @return the node, or null if none
     */
    final Node&lt;K,V&gt; getNode(int hash, Object key) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
<span class="pc bpc" id="L568" title="1 of 6 branches missed.">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span>
            (first = tab[(n - 1) &amp; hash]) != null) {
<span class="pc bpc" id="L570" title="1 of 6 branches missed.">            if (first.hash == hash &amp;&amp; // always check first node</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span>
<span class="fc" id="L572">                return first;</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">            if ((e = first.next) != null) {</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">                if (first instanceof TreeNode)</span>
<span class="fc" id="L575">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span>
                do {
<span class="pc bpc" id="L577" title="1 of 6 branches missed.">                    if (e.hash == hash &amp;&amp;</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span>
<span class="fc" id="L579">                        return e;</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">                } while ((e = e.next) != null);</span>
            }
        }
<span class="fc" id="L583">        return null;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the
     * specified key.
     *
     * @param   key   The key whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified
     * key.
     */
    public boolean containsKey(Object key) {
<span class="fc bfc" id="L595" title="All 2 branches covered.">        return getNode(hash(key), key) != null;</span>
    }

    /**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for the key, the old
     * value is replaced.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */
    public V put(K key, V value) {
<span class="fc" id="L611">        return putVal(hash(key), key, value, false, true);</span>
    }

    /**
     * Implements Map.put and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to put
     * @param onlyIfAbsent if true, don't change existing value
     * @param evict if false, the table is in creation mode.
     * @return previous value, or null if none
     */
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
<span class="pc bpc" id="L627" title="1 of 4 branches missed.">        if ((tab = table) == null || (n = tab.length) == 0)</span>
<span class="fc" id="L628">            n = (tab = resize()).length;</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span>
<span class="fc" id="L630">            tab[i] = newNode(hash, key, value, null);</span>
        else {
            Node&lt;K,V&gt; e; K k;
<span class="pc bpc" id="L633" title="1 of 6 branches missed.">            if (p.hash == hash &amp;&amp;</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span>
<span class="fc" id="L635">                e = p;</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">            else if (p instanceof TreeNode)</span>
<span class="fc" id="L637">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span>
            else {
<span class="fc" id="L639">                for (int binCount = 0; ; ++binCount) {</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                    if ((e = p.next) == null) {</span>
<span class="fc" id="L641">                        p.next = newNode(hash, key, value, null);</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span>
<span class="fc" id="L643">                            treeifyBin(tab, hash);</span>
                        break;
                    }
<span class="pc bpc" id="L646" title="1 of 6 branches missed.">                    if (e.hash == hash &amp;&amp;</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span>
<span class="fc" id="L648">                        break;</span>
<span class="fc" id="L649">                    p = e;</span>
                }
            }
<span class="fc bfc" id="L652" title="All 2 branches covered.">            if (e != null) { // existing mapping for key</span>
<span class="fc" id="L653">                V oldValue = e.value;</span>
<span class="pc bpc" id="L654" title="3 of 4 branches missed.">                if (!onlyIfAbsent || oldValue == null)</span>
<span class="fc" id="L655">                    e.value = value;</span>
<span class="fc" id="L656">                afterNodeAccess(e);</span>
<span class="fc" id="L657">                return oldValue;</span>
            }
        }
<span class="fc" id="L660">        ++modCount;</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">        if (++size &gt; threshold)</span>
<span class="fc" id="L662">            resize();</span>
<span class="fc" id="L663">        afterNodeInsertion(evict);</span>
<span class="fc" id="L664">        return null;</span>
    }

    /**
     * Initializes or doubles table size.  If null, allocates in
     * accord with initial capacity target held in field threshold.
     * Otherwise, because we are using power-of-two expansion, the
     * elements from each bin must either stay at same index, or move
     * with a power of two offset in the new table.
     *
     * @return the table
     */
    final Node&lt;K,V&gt;[] resize() {
<span class="fc" id="L677">        Node&lt;K,V&gt;[] oldTab = table;</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span>
<span class="fc" id="L679">        int oldThr = threshold;</span>
<span class="fc" id="L680">        int newCap, newThr = 0;</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">        if (oldCap &gt; 0) {</span>
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">            if (oldCap &gt;= MAXIMUM_CAPACITY) {</span>
<span class="nc" id="L683">                threshold = Integer.MAX_VALUE;</span>
<span class="nc" id="L684">                return oldTab;</span>
            }
<span class="pc bpc" id="L686" title="1 of 4 branches missed.">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span>
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
<span class="fc" id="L688">                newThr = oldThr &lt;&lt; 1; // double threshold</span>
        }
<span class="fc bfc" id="L690" title="All 2 branches covered.">        else if (oldThr &gt; 0) // initial capacity was placed in threshold</span>
<span class="fc" id="L691">            newCap = oldThr;</span>
        else {               // zero initial threshold signifies using defaults
<span class="fc" id="L693">            newCap = DEFAULT_INITIAL_CAPACITY;</span>
<span class="fc" id="L694">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span>
        }
<span class="fc bfc" id="L696" title="All 2 branches covered.">        if (newThr == 0) {</span>
<span class="fc" id="L697">            float ft = (float)newCap * loadFactor;</span>
<span class="pc bpc" id="L698" title="2 of 4 branches missed.">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span>
                      (int)ft : Integer.MAX_VALUE);
        }
<span class="fc" id="L701">        threshold = newThr;</span>
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
<span class="fc" id="L703">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span>
<span class="fc" id="L704">        table = newTab;</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (oldTab != null) {</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">            for (int j = 0; j &lt; oldCap; ++j) {</span>
                Node&lt;K,V&gt; e;
<span class="fc bfc" id="L708" title="All 2 branches covered.">                if ((e = oldTab[j]) != null) {</span>
<span class="fc" id="L709">                    oldTab[j] = null;</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">                    if (e.next == null)</span>
<span class="fc" id="L711">                        newTab[e.hash &amp; (newCap - 1)] = e;</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">                    else if (e instanceof TreeNode)</span>
<span class="fc" id="L713">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span>
                    else { // preserve order
<span class="fc" id="L715">                        Node&lt;K,V&gt; loHead = null, loTail = null;</span>
<span class="fc" id="L716">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</span>
                        Node&lt;K,V&gt; next;
                        do {
<span class="fc" id="L719">                            next = e.next;</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">                            if ((e.hash &amp; oldCap) == 0) {</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">                                if (loTail == null)</span>
<span class="fc" id="L722">                                    loHead = e;</span>
                                else
<span class="fc" id="L724">                                    loTail.next = e;</span>
<span class="fc" id="L725">                                loTail = e;</span>
                            }
                            else {
<span class="fc bfc" id="L728" title="All 2 branches covered.">                                if (hiTail == null)</span>
<span class="fc" id="L729">                                    hiHead = e;</span>
                                else
<span class="fc" id="L731">                                    hiTail.next = e;</span>
<span class="fc" id="L732">                                hiTail = e;</span>
                            }
<span class="fc bfc" id="L734" title="All 2 branches covered.">                        } while ((e = next) != null);</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">                        if (loTail != null) {</span>
<span class="fc" id="L736">                            loTail.next = null;</span>
<span class="fc" id="L737">                            newTab[j] = loHead;</span>
                        }
<span class="fc bfc" id="L739" title="All 2 branches covered.">                        if (hiTail != null) {</span>
<span class="fc" id="L740">                            hiTail.next = null;</span>
<span class="fc" id="L741">                            newTab[j + oldCap] = hiHead;</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L747">        return newTab;</span>
    }

    /**
     * Replaces all linked nodes in bin at index for given hash unless
     * table is too small, in which case resizes instead.
     */
    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
        int n, index; Node&lt;K,V&gt; e;
<span class="pc bpc" id="L756" title="1 of 4 branches missed.">        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span>
<span class="fc" id="L757">            resize();</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">        else if ((e = tab[index = (n - 1) &amp; hash]) != null) {</span>
<span class="fc" id="L759">            TreeNode&lt;K,V&gt; hd = null, tl = null;</span>
            do {
<span class="fc" id="L761">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">                if (tl == null)</span>
<span class="fc" id="L763">                    hd = p;</span>
                else {
<span class="fc" id="L765">                    p.prev = tl;</span>
<span class="fc" id="L766">                    tl.next = p;</span>
                }
<span class="fc" id="L768">                tl = p;</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">            } while ((e = e.next) != null);</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">            if ((tab[index] = hd) != null)</span>
<span class="fc" id="L771">                hd.treeify(tab);</span>
        }
<span class="fc" id="L773">    }</span>

    /**
     * Copies all of the mappings from the specified map to this map.
     * These mappings will replace any mappings that this map had for
     * any of the keys currently in the specified map.
     *
     * @param m mappings to be stored in this map
     * @throws NullPointerException if the specified map is null
     */
    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
<span class="fc" id="L784">        putMapEntries(m, true);</span>
<span class="fc" id="L785">    }</span>

    /**
     * Removes the mapping for the specified key from this map if present.
     *
     * @param  key key whose mapping is to be removed from the map
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */
    public V remove(Object key) {
        Node&lt;K,V&gt; e;
<span class="fc bfc" id="L798" title="All 2 branches covered.">        return (e = removeNode(hash(key), key, null, false, true)) == null ?</span>
            null : e.value;
    }

    /**
     * Implements Map.remove and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to match if matchValue, else ignored
     * @param matchValue if true only remove if value is equal
     * @param movable if false do not move other nodes while removing
     * @return the node, or null if none
     */
    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
<span class="pc bpc" id="L815" title="1 of 6 branches missed.">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span>
            (p = tab[index = (n - 1) &amp; hash]) != null) {
<span class="fc" id="L817">            Node&lt;K,V&gt; node = null, e; K k; V v;</span>
<span class="pc bpc" id="L818" title="1 of 6 branches missed.">            if (p.hash == hash &amp;&amp;</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span>
<span class="fc" id="L820">                node = p;</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">            else if ((e = p.next) != null) {</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">                if (p instanceof TreeNode)</span>
<span class="nc" id="L823">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span>
                else {
                    do {
<span class="pc bpc" id="L826" title="1 of 6 branches missed.">                        if (e.hash == hash &amp;&amp;</span>
                            ((k = e.key) == key ||
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">                             (key != null &amp;&amp; key.equals(k)))) {</span>
<span class="fc" id="L829">                            node = e;</span>
<span class="fc" id="L830">                            break;</span>
                        }
<span class="fc" id="L832">                        p = e;</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">                    } while ((e = e.next) != null);</span>
                }
            }
<span class="pc bpc" id="L836" title="1 of 8 branches missed.">            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span>
<span class="pc bpc" id="L837" title="1 of 2 branches missed.">                                 (value != null &amp;&amp; value.equals(v)))) {</span>
<span class="pc bpc" id="L838" title="1 of 2 branches missed.">                if (node instanceof TreeNode)</span>
<span class="nc" id="L839">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">                else if (node == p)</span>
<span class="fc" id="L841">                    tab[index] = node.next;</span>
                else
<span class="fc" id="L843">                    p.next = node.next;</span>
<span class="fc" id="L844">                ++modCount;</span>
<span class="fc" id="L845">                --size;</span>
<span class="fc" id="L846">                afterNodeRemoval(node);</span>
<span class="fc" id="L847">                return node;</span>
            }
        }
<span class="fc" id="L850">        return null;</span>
    }

    /**
     * Removes all of the mappings from this map.
     * The map will be empty after this call returns.
     */
    public void clear() {
        Node&lt;K,V&gt;[] tab;
<span class="fc" id="L859">        modCount++;</span>
<span class="fc bfc" id="L860" title="All 4 branches covered.">        if ((tab = table) != null &amp;&amp; size &gt; 0) {</span>
<span class="fc" id="L861">            size = 0;</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">            for (int i = 0; i &lt; tab.length; ++i)</span>
<span class="fc" id="L863">                tab[i] = null;</span>
        }
<span class="fc" id="L865">    }</span>

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
     * specified value.
     *
     * @param value value whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
     *         specified value
     */
    public boolean containsValue(Object value) {
        Node&lt;K,V&gt;[] tab; V v;
<span class="fc bfc" id="L877" title="All 4 branches covered.">        if ((tab = table) != null &amp;&amp; size &gt; 0) {</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">            for (int i = 0; i &lt; tab.length; ++i) {</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {</span>
<span class="fc bfc" id="L880" title="All 4 branches covered.">                    if ((v = e.value) == value ||</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">                        (value != null &amp;&amp; value.equals(v)))</span>
<span class="fc" id="L882">                        return true;</span>
                }
            }
        }
<span class="fc" id="L886">        return false;</span>
    }

    /**
     * Returns a {@link Set} view of the keys contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of
     * the iteration are undefined.  The set supports element removal,
     * which removes the corresponding mapping from the map, via the
     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;
     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;
     * operations.
     *
     * @return a set view of the keys contained in this map
     */
    public Set&lt;K&gt; keySet() {
        Set&lt;K&gt; ks;
<span class="fc bfc" id="L906" title="All 2 branches covered.">        return (ks = keySet) == null ? (keySet = new KeySet()) : ks;</span>
    }

<span class="fc" id="L909">    final class KeySet extends AbstractSet&lt;K&gt; {</span>
<span class="fc" id="L910">        public final int size()                 { return size; }</span>
<span class="fc" id="L911">        public final void clear()               { HashMap.this.clear(); }</span>
<span class="fc" id="L912">        public final Iterator&lt;K&gt; iterator()     { return new KeyIterator(); }</span>
<span class="fc" id="L913">        public final boolean contains(Object o) { return containsKey(o); }</span>
        public final boolean remove(Object key) {
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">            return removeNode(hash(key), key, null, false, true) != null;</span>
        }
        public final Spliterator&lt;K&gt; spliterator() {
<span class="nc" id="L918">            return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span>
        }
        public final void forEach(Consumer&lt;? super K&gt; action) {
            Node&lt;K,V&gt;[] tab;
<span class="nc bnc" id="L922" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L923">                throw new NullPointerException();</span>
<span class="nc bnc" id="L924" title="All 4 branches missed.">            if (size &gt; 0 &amp;&amp; (tab = table) != null) {</span>
<span class="nc" id="L925">                int mc = modCount;</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">                for (int i = 0; i &lt; tab.length; ++i) {</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span>
<span class="nc" id="L928">                        action.accept(e.key);</span>
                }
<span class="nc bnc" id="L930" title="All 2 branches missed.">                if (modCount != mc)</span>
<span class="nc" id="L931">                    throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L933">        }</span>
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.  If the map is
     * modified while an iteration over the collection is in progress
     * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation),
     * the results of the iteration are undefined.  The collection
     * supports element removal, which removes the corresponding
     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not
     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     *
     * @return a view of the values contained in this map
     */
    public Collection&lt;V&gt; values() {
        Collection&lt;V&gt; vs;
<span class="fc bfc" id="L953" title="All 2 branches covered.">        return (vs = values) == null ? (values = new Values()) : vs;</span>
    }

<span class="fc" id="L956">    final class Values extends AbstractCollection&lt;V&gt; {</span>
<span class="fc" id="L957">        public final int size()                 { return size; }</span>
<span class="fc" id="L958">        public final void clear()               { HashMap.this.clear(); }</span>
<span class="fc" id="L959">        public final Iterator&lt;V&gt; iterator()     { return new ValueIterator(); }</span>
<span class="fc" id="L960">        public final boolean contains(Object o) { return containsValue(o); }</span>
        public final Spliterator&lt;V&gt; spliterator() {
<span class="nc" id="L962">            return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span>
        }
        public final void forEach(Consumer&lt;? super V&gt; action) {
            Node&lt;K,V&gt;[] tab;
<span class="nc bnc" id="L966" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L967">                throw new NullPointerException();</span>
<span class="nc bnc" id="L968" title="All 4 branches missed.">            if (size &gt; 0 &amp;&amp; (tab = table) != null) {</span>
<span class="nc" id="L969">                int mc = modCount;</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">                for (int i = 0; i &lt; tab.length; ++i) {</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span>
<span class="nc" id="L972">                        action.accept(e.value);</span>
                }
<span class="nc bnc" id="L974" title="All 2 branches missed.">                if (modCount != mc)</span>
<span class="nc" id="L975">                    throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L977">        }</span>
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the
     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the
     * iterator) the results of the iteration are undefined.  The set
     * supports element removal, which removes the corresponding
     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and
     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the
     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     *
     * @return a set view of the mappings contained in this map
     */
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;
<span class="fc bfc" id="L998" title="All 2 branches covered.">        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</span>
    }

<span class="fc" id="L1001">    final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {</span>
<span class="fc" id="L1002">        public final int size()                 { return size; }</span>
<span class="fc" id="L1003">        public final void clear()               { HashMap.this.clear(); }</span>
        public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
<span class="fc" id="L1005">            return new EntryIterator();</span>
        }
        public final boolean contains(Object o) {
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L1009">                return false;</span>
<span class="fc" id="L1010">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span>
<span class="fc" id="L1011">            Object key = e.getKey();</span>
<span class="fc" id="L1012">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span>
<span class="pc bpc" id="L1013" title="1 of 4 branches missed.">            return candidate != null &amp;&amp; candidate.equals(e);</span>
        }
        public final boolean remove(Object o) {
<span class="pc bpc" id="L1016" title="1 of 2 branches missed.">            if (o instanceof Map.Entry) {</span>
<span class="fc" id="L1017">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span>
<span class="fc" id="L1018">                Object key = e.getKey();</span>
<span class="fc" id="L1019">                Object value = e.getValue();</span>
<span class="pc bpc" id="L1020" title="1 of 2 branches missed.">                return removeNode(hash(key), key, value, true, true) != null;</span>
            }
<span class="nc" id="L1022">            return false;</span>
        }
        public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
<span class="nc" id="L1025">            return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span>
        }
        public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
            Node&lt;K,V&gt;[] tab;
<span class="nc bnc" id="L1029" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1030">                throw new NullPointerException();</span>
<span class="nc bnc" id="L1031" title="All 4 branches missed.">            if (size &gt; 0 &amp;&amp; (tab = table) != null) {</span>
<span class="nc" id="L1032">                int mc = modCount;</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">                for (int i = 0; i &lt; tab.length; ++i) {</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span>
<span class="nc" id="L1035">                        action.accept(e);</span>
                }
<span class="nc bnc" id="L1037" title="All 2 branches missed.">                if (modCount != mc)</span>
<span class="nc" id="L1038">                    throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L1040">        }</span>
    }

    // Overrides of JDK8 Map extension methods

    @Override
    public V getOrDefault(Object key, V defaultValue) {
        Node&lt;K,V&gt; e;
<span class="nc bnc" id="L1048" title="All 2 branches missed.">        return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;</span>
    }

    @Override
    public V putIfAbsent(K key, V value) {
<span class="nc" id="L1053">        return putVal(hash(key), key, value, true, true);</span>
    }

    @Override
    public boolean remove(Object key, Object value) {
<span class="nc bnc" id="L1058" title="All 2 branches missed.">        return removeNode(hash(key), key, value, true, true) != null;</span>
    }

    @Override
    public boolean replace(K key, V oldValue, V newValue) {
        Node&lt;K,V&gt; e; V v;
<span class="nc bnc" id="L1064" title="All 6 branches missed.">        if ((e = getNode(hash(key), key)) != null &amp;&amp;</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) {</span>
<span class="nc" id="L1066">            e.value = newValue;</span>
<span class="nc" id="L1067">            afterNodeAccess(e);</span>
<span class="nc" id="L1068">            return true;</span>
        }
<span class="nc" id="L1070">        return false;</span>
    }

    @Override
    public V replace(K key, V value) {
        Node&lt;K,V&gt; e;
<span class="nc bnc" id="L1076" title="All 2 branches missed.">        if ((e = getNode(hash(key), key)) != null) {</span>
<span class="nc" id="L1077">            V oldValue = e.value;</span>
<span class="nc" id="L1078">            e.value = value;</span>
<span class="nc" id="L1079">            afterNodeAccess(e);</span>
<span class="nc" id="L1080">            return oldValue;</span>
        }
<span class="nc" id="L1082">        return null;</span>
    }

    @Override
    public V computeIfAbsent(K key,
                             Function&lt;? super K, ? extends V&gt; mappingFunction) {
<span class="nc bnc" id="L1088" title="All 2 branches missed.">        if (mappingFunction == null)</span>
<span class="nc" id="L1089">            throw new NullPointerException();</span>
<span class="nc" id="L1090">        int hash = hash(key);</span>
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
<span class="nc" id="L1092">        int binCount = 0;</span>
<span class="nc" id="L1093">        TreeNode&lt;K,V&gt; t = null;</span>
<span class="nc" id="L1094">        Node&lt;K,V&gt; old = null;</span>
<span class="nc bnc" id="L1095" title="All 6 branches missed.">        if (size &gt; threshold || (tab = table) == null ||</span>
            (n = tab.length) == 0)
<span class="nc" id="L1097">            n = (tab = resize()).length;</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">        if ((first = tab[i = (n - 1) &amp; hash]) != null) {</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">            if (first instanceof TreeNode)</span>
<span class="nc" id="L1100">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span>
            else {
<span class="nc" id="L1102">                Node&lt;K,V&gt; e = first; K k;</span>
                do {
<span class="nc bnc" id="L1104" title="All 6 branches missed.">                    if (e.hash == hash &amp;&amp;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {</span>
<span class="nc" id="L1106">                        old = e;</span>
<span class="nc" id="L1107">                        break;</span>
                    }
<span class="nc" id="L1109">                    ++binCount;</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                } while ((e = e.next) != null);</span>
            }
            V oldValue;
<span class="nc bnc" id="L1113" title="All 4 branches missed.">            if (old != null &amp;&amp; (oldValue = old.value) != null) {</span>
<span class="nc" id="L1114">                afterNodeAccess(old);</span>
<span class="nc" id="L1115">                return oldValue;</span>
            }
        }
<span class="nc" id="L1118">        V v = mappingFunction.apply(key);</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">        if (old != null) {</span>
<span class="nc" id="L1120">            old.value = v;</span>
<span class="nc" id="L1121">            afterNodeAccess(old);</span>
<span class="nc" id="L1122">            return v;</span>
        }
<span class="nc bnc" id="L1124" title="All 2 branches missed.">        else if (v == null)</span>
<span class="nc" id="L1125">            return null;</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        else if (t != null)</span>
<span class="nc" id="L1127">            t.putTreeVal(this, tab, hash, key, v);</span>
        else {
<span class="nc" id="L1129">            tab[i] = newNode(hash, key, v, first);</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">            if (binCount &gt;= TREEIFY_THRESHOLD - 1)</span>
<span class="nc" id="L1131">                treeifyBin(tab, hash);</span>
        }
<span class="nc" id="L1133">        ++modCount;</span>
<span class="nc" id="L1134">        ++size;</span>
<span class="nc" id="L1135">        afterNodeInsertion(true);</span>
<span class="nc" id="L1136">        return v;</span>
    }

    public V computeIfPresent(K key,
                              BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc bnc" id="L1141" title="All 2 branches missed.">        if (remappingFunction == null)</span>
<span class="nc" id="L1142">            throw new NullPointerException();</span>
        Node&lt;K,V&gt; e; V oldValue;
<span class="nc" id="L1144">        int hash = hash(key);</span>
<span class="nc bnc" id="L1145" title="All 4 branches missed.">        if ((e = getNode(hash, key)) != null &amp;&amp;</span>
            (oldValue = e.value) != null) {
<span class="nc" id="L1147">            V v = remappingFunction.apply(key, oldValue);</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">            if (v != null) {</span>
<span class="nc" id="L1149">                e.value = v;</span>
<span class="nc" id="L1150">                afterNodeAccess(e);</span>
<span class="nc" id="L1151">                return v;</span>
            }
            else
<span class="nc" id="L1154">                removeNode(hash, key, null, false, true);</span>
        }
<span class="nc" id="L1156">        return null;</span>
    }

    @Override
    public V compute(K key,
                     BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc bnc" id="L1162" title="All 2 branches missed.">        if (remappingFunction == null)</span>
<span class="nc" id="L1163">            throw new NullPointerException();</span>
<span class="nc" id="L1164">        int hash = hash(key);</span>
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
<span class="nc" id="L1166">        int binCount = 0;</span>
<span class="nc" id="L1167">        TreeNode&lt;K,V&gt; t = null;</span>
<span class="nc" id="L1168">        Node&lt;K,V&gt; old = null;</span>
<span class="nc bnc" id="L1169" title="All 6 branches missed.">        if (size &gt; threshold || (tab = table) == null ||</span>
            (n = tab.length) == 0)
<span class="nc" id="L1171">            n = (tab = resize()).length;</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">        if ((first = tab[i = (n - 1) &amp; hash]) != null) {</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">            if (first instanceof TreeNode)</span>
<span class="nc" id="L1174">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span>
            else {
<span class="nc" id="L1176">                Node&lt;K,V&gt; e = first; K k;</span>
                do {
<span class="nc bnc" id="L1178" title="All 6 branches missed.">                    if (e.hash == hash &amp;&amp;</span>
<span class="nc bnc" id="L1179" title="All 2 branches missed.">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {</span>
<span class="nc" id="L1180">                        old = e;</span>
<span class="nc" id="L1181">                        break;</span>
                    }
<span class="nc" id="L1183">                    ++binCount;</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">                } while ((e = e.next) != null);</span>
            }
        }
<span class="nc bnc" id="L1187" title="All 2 branches missed.">        V oldValue = (old == null) ? null : old.value;</span>
<span class="nc" id="L1188">        V v = remappingFunction.apply(key, oldValue);</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">        if (old != null) {</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">            if (v != null) {</span>
<span class="nc" id="L1191">                old.value = v;</span>
<span class="nc" id="L1192">                afterNodeAccess(old);</span>
            }
            else
<span class="nc" id="L1195">                removeNode(hash, key, null, false, true);</span>
        }
<span class="nc bnc" id="L1197" title="All 2 branches missed.">        else if (v != null) {</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">            if (t != null)</span>
<span class="nc" id="L1199">                t.putTreeVal(this, tab, hash, key, v);</span>
            else {
<span class="nc" id="L1201">                tab[i] = newNode(hash, key, v, first);</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">                if (binCount &gt;= TREEIFY_THRESHOLD - 1)</span>
<span class="nc" id="L1203">                    treeifyBin(tab, hash);</span>
            }
<span class="nc" id="L1205">            ++modCount;</span>
<span class="nc" id="L1206">            ++size;</span>
<span class="nc" id="L1207">            afterNodeInsertion(true);</span>
        }
<span class="nc" id="L1209">        return v;</span>
    }

    @Override
    public V merge(K key, V value,
                   BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc bnc" id="L1215" title="All 2 branches missed.">        if (remappingFunction == null)</span>
<span class="nc" id="L1216">            throw new NullPointerException();</span>
<span class="nc" id="L1217">        int hash = hash(key);</span>
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
<span class="nc" id="L1219">        int binCount = 0;</span>
<span class="nc" id="L1220">        TreeNode&lt;K,V&gt; t = null;</span>
<span class="nc" id="L1221">        Node&lt;K,V&gt; old = null;</span>
<span class="nc bnc" id="L1222" title="All 6 branches missed.">        if (size &gt; threshold || (tab = table) == null ||</span>
            (n = tab.length) == 0)
<span class="nc" id="L1224">            n = (tab = resize()).length;</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">        if ((first = tab[i = (n - 1) &amp; hash]) != null) {</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">            if (first instanceof TreeNode)</span>
<span class="nc" id="L1227">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span>
            else {
<span class="nc" id="L1229">                Node&lt;K,V&gt; e = first; K k;</span>
                do {
<span class="nc bnc" id="L1231" title="All 6 branches missed.">                    if (e.hash == hash &amp;&amp;</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {</span>
<span class="nc" id="L1233">                        old = e;</span>
<span class="nc" id="L1234">                        break;</span>
                    }
<span class="nc" id="L1236">                    ++binCount;</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">                } while ((e = e.next) != null);</span>
            }
        }
<span class="nc bnc" id="L1240" title="All 2 branches missed.">        if (old != null) {</span>
            V v;
<span class="nc bnc" id="L1242" title="All 2 branches missed.">            if (old.value != null)</span>
<span class="nc" id="L1243">                v = remappingFunction.apply(old.value, value);</span>
            else
<span class="nc" id="L1245">                v = value;</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">            if (v != null) {</span>
<span class="nc" id="L1247">                old.value = v;</span>
<span class="nc" id="L1248">                afterNodeAccess(old);</span>
            }
            else
<span class="nc" id="L1251">                removeNode(hash, key, null, false, true);</span>
<span class="nc" id="L1252">            return v;</span>
        }
<span class="nc bnc" id="L1254" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">            if (t != null)</span>
<span class="nc" id="L1256">                t.putTreeVal(this, tab, hash, key, value);</span>
            else {
<span class="nc" id="L1258">                tab[i] = newNode(hash, key, value, first);</span>
<span class="nc bnc" id="L1259" title="All 2 branches missed.">                if (binCount &gt;= TREEIFY_THRESHOLD - 1)</span>
<span class="nc" id="L1260">                    treeifyBin(tab, hash);</span>
            }
<span class="nc" id="L1262">            ++modCount;</span>
<span class="nc" id="L1263">            ++size;</span>
<span class="nc" id="L1264">            afterNodeInsertion(true);</span>
        }
<span class="nc" id="L1266">        return value;</span>
    }

    @Override
    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
        Node&lt;K,V&gt;[] tab;
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">        if (action == null)</span>
<span class="nc" id="L1273">            throw new NullPointerException();</span>
<span class="pc bpc" id="L1274" title="2 of 4 branches missed.">        if (size &gt; 0 &amp;&amp; (tab = table) != null) {</span>
<span class="fc" id="L1275">            int mc = modCount;</span>
<span class="fc bfc" id="L1276" title="All 2 branches covered.">            for (int i = 0; i &lt; tab.length; ++i) {</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span>
<span class="fc" id="L1278">                    action.accept(e.key, e.value);</span>
            }
<span class="pc bpc" id="L1280" title="1 of 2 branches missed.">            if (modCount != mc)</span>
<span class="nc" id="L1281">                throw new ConcurrentModificationException();</span>
        }
<span class="fc" id="L1283">    }</span>

    @Override
    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
        Node&lt;K,V&gt;[] tab;
<span class="pc bpc" id="L1288" title="1 of 2 branches missed.">        if (function == null)</span>
<span class="nc" id="L1289">            throw new NullPointerException();</span>
<span class="pc bpc" id="L1290" title="2 of 4 branches missed.">        if (size &gt; 0 &amp;&amp; (tab = table) != null) {</span>
<span class="fc" id="L1291">            int mc = modCount;</span>
<span class="fc bfc" id="L1292" title="All 2 branches covered.">            for (int i = 0; i &lt; tab.length; ++i) {</span>
<span class="fc bfc" id="L1293" title="All 2 branches covered.">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {</span>
<span class="fc" id="L1294">                    e.value = function.apply(e.key, e.value);</span>
                }
            }
<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">            if (modCount != mc)</span>
<span class="nc" id="L1298">                throw new ConcurrentModificationException();</span>
        }
<span class="fc" id="L1300">    }</span>

    /* ------------------------------------------------------------ */
    // Cloning and serialization

    /**
     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and
     * values themselves are not cloned.
     *
     * @return a shallow copy of this map
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public Object clone() {
        HashMap&lt;K,V&gt; result;
        try {
<span class="fc" id="L1316">            result = (HashMap&lt;K,V&gt;)super.clone();</span>
<span class="nc" id="L1317">        } catch (CloneNotSupportedException e) {</span>
            // this shouldn't happen, since we are Cloneable
<span class="nc" id="L1319">            throw new InternalError(e);</span>
<span class="fc" id="L1320">        }</span>
<span class="fc" id="L1321">        result.reinitialize();</span>
<span class="fc" id="L1322">        result.putMapEntries(this, false);</span>
<span class="fc" id="L1323">        return result;</span>
    }

    // These methods are also used when serializing HashSets
<span class="fc" id="L1327">    final float loadFactor() { return loadFactor; }</span>
    final int capacity() {
<span class="fc bfc" id="L1329" title="All 4 branches covered.">        return (table != null) ? table.length :</span>
            (threshold &gt; 0) ? threshold :
            DEFAULT_INITIAL_CAPACITY;
    }

    /**
     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,
     * serialize it).
     *
     * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the
     *             bucket array) is emitted (int), followed by the
     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value
     *             mappings), followed by the key (Object) and value (Object)
     *             for each key-value mapping.  The key-value mappings are
     *             emitted in no particular order.
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws IOException {
<span class="fc" id="L1347">        int buckets = capacity();</span>
        // Write out the threshold, loadfactor, and any hidden stuff
<span class="fc" id="L1349">        s.defaultWriteObject();</span>
<span class="fc" id="L1350">        s.writeInt(buckets);</span>
<span class="fc" id="L1351">        s.writeInt(size);</span>
<span class="fc" id="L1352">        internalWriteEntries(s);</span>
<span class="fc" id="L1353">    }</span>

    /**
     * Reconstitute the {@code HashMap} instance from a stream (i.e.,
     * deserialize it).
     */
    private void readObject(java.io.ObjectInputStream s)
        throws IOException, ClassNotFoundException {
        // Read in the threshold (ignored), loadfactor, and any hidden stuff
<span class="fc" id="L1362">        s.defaultReadObject();</span>
<span class="fc" id="L1363">        reinitialize();</span>
<span class="pc bpc" id="L1364" title="2 of 4 branches missed.">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span>
<span class="nc" id="L1365">            throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span>
                                             loadFactor);
<span class="fc" id="L1367">        s.readInt();                // Read and ignore number of buckets</span>
<span class="fc" id="L1368">        int mappings = s.readInt(); // Read number of mappings (size)</span>
<span class="pc bpc" id="L1369" title="1 of 2 branches missed.">        if (mappings &lt; 0)</span>
<span class="nc" id="L1370">            throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span>
                                             mappings);
<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">        else if (mappings &gt; 0) { // (if zero, use defaults)</span>
            // Size the table using given load factor only if within
            // range of 0.25...4.0
<span class="fc" id="L1375">            float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);</span>
<span class="fc" id="L1376">            float fc = (float)mappings / lf + 1.0f;</span>
<span class="pc bpc" id="L1377" title="1 of 4 branches missed.">            int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span>
                       DEFAULT_INITIAL_CAPACITY :
                       (fc &gt;= MAXIMUM_CAPACITY) ?
                       MAXIMUM_CAPACITY :
<span class="fc" id="L1381">                       tableSizeFor((int)fc));</span>
<span class="fc" id="L1382">            float ft = (float)cap * lf;</span>
<span class="pc bpc" id="L1383" title="2 of 4 branches missed.">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span>
                         (int)ft : Integer.MAX_VALUE);
            @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
<span class="fc" id="L1386">                Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];</span>
<span class="fc" id="L1387">            table = tab;</span>

            // Read the keys and values, and put the mappings in the HashMap
<span class="fc bfc" id="L1390" title="All 2 branches covered.">            for (int i = 0; i &lt; mappings; i++) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1392">                    K key = (K) s.readObject();</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1394">                    V value = (V) s.readObject();</span>
<span class="fc" id="L1395">                putVal(hash(key), key, value, false, false);</span>
            }
        }
<span class="fc" id="L1398">    }</span>

    /* ------------------------------------------------------------ */
    // iterators

    abstract class HashIterator {
        Node&lt;K,V&gt; next;        // next entry to return
        Node&lt;K,V&gt; current;     // current entry
        int expectedModCount;  // for fast-fail
        int index;             // current slot

<span class="fc" id="L1409">        HashIterator() {</span>
<span class="fc" id="L1410">            expectedModCount = modCount;</span>
<span class="fc" id="L1411">            Node&lt;K,V&gt;[] t = table;</span>
<span class="fc" id="L1412">            current = next = null;</span>
<span class="fc" id="L1413">            index = 0;</span>
<span class="fc bfc" id="L1414" title="All 4 branches covered.">            if (t != null &amp;&amp; size &gt; 0) { // advance to first entry</span>
<span class="pc bpc" id="L1415" title="1 of 4 branches missed.">                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span>
            }
<span class="fc" id="L1417">        }</span>

        public final boolean hasNext() {
<span class="fc bfc" id="L1420" title="All 2 branches covered.">            return next != null;</span>
        }

        final Node&lt;K,V&gt; nextNode() {
            Node&lt;K,V&gt;[] t;
<span class="fc" id="L1425">            Node&lt;K,V&gt; e = next;</span>
<span class="fc bfc" id="L1426" title="All 2 branches covered.">            if (modCount != expectedModCount)</span>
<span class="fc" id="L1427">                throw new ConcurrentModificationException();</span>
<span class="fc bfc" id="L1428" title="All 2 branches covered.">            if (e == null)</span>
<span class="fc" id="L1429">                throw new NoSuchElementException();</span>
<span class="pc bpc" id="L1430" title="1 of 4 branches missed.">            if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) {</span>
<span class="fc bfc" id="L1431" title="All 4 branches covered.">                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span>
            }
<span class="fc" id="L1433">            return e;</span>
        }

        public final void remove() {
<span class="fc" id="L1437">            Node&lt;K,V&gt; p = current;</span>
<span class="fc bfc" id="L1438" title="All 2 branches covered.">            if (p == null)</span>
<span class="fc" id="L1439">                throw new IllegalStateException();</span>
<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">            if (modCount != expectedModCount)</span>
<span class="nc" id="L1441">                throw new ConcurrentModificationException();</span>
<span class="fc" id="L1442">            current = null;</span>
<span class="fc" id="L1443">            K key = p.key;</span>
<span class="fc" id="L1444">            removeNode(hash(key), key, null, false, false);</span>
<span class="fc" id="L1445">            expectedModCount = modCount;</span>
<span class="fc" id="L1446">        }</span>
    }

<span class="fc" id="L1449">    final class KeyIterator extends HashIterator</span>
        implements Iterator&lt;K&gt; {
<span class="fc" id="L1451">        public final K next() { return nextNode().key; }</span>
    }

<span class="fc" id="L1454">    final class ValueIterator extends HashIterator</span>
        implements Iterator&lt;V&gt; {
<span class="fc" id="L1456">        public final V next() { return nextNode().value; }</span>
    }

<span class="fc" id="L1459">    final class EntryIterator extends HashIterator</span>
        implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {
<span class="fc" id="L1461">        public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }</span>
    }

    /* ------------------------------------------------------------ */
    // spliterators

    static class HashMapSpliterator&lt;K,V&gt; {
        final HashMap&lt;K,V&gt; map;
        Node&lt;K,V&gt; current;          // current node
        int index;                  // current index, modified on advance/split
        int fence;                  // one past last index
        int est;                    // size estimate
        int expectedModCount;       // for comodification checks

        HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin,
                           int fence, int est,
<span class="fc" id="L1477">                           int expectedModCount) {</span>
<span class="fc" id="L1478">            this.map = m;</span>
<span class="fc" id="L1479">            this.index = origin;</span>
<span class="fc" id="L1480">            this.fence = fence;</span>
<span class="fc" id="L1481">            this.est = est;</span>
<span class="fc" id="L1482">            this.expectedModCount = expectedModCount;</span>
<span class="fc" id="L1483">        }</span>

        final int getFence() { // initialize fence and size on first use
            int hi;
<span class="fc bfc" id="L1487" title="All 2 branches covered.">            if ((hi = fence) &lt; 0) {</span>
<span class="fc" id="L1488">                HashMap&lt;K,V&gt; m = map;</span>
<span class="fc" id="L1489">                est = m.size;</span>
<span class="fc" id="L1490">                expectedModCount = m.modCount;</span>
<span class="fc" id="L1491">                Node&lt;K,V&gt;[] tab = m.table;</span>
<span class="pc bpc" id="L1492" title="1 of 2 branches missed.">                hi = fence = (tab == null) ? 0 : tab.length;</span>
            }
<span class="fc" id="L1494">            return hi;</span>
        }

        public final long estimateSize() {
<span class="nc" id="L1498">            getFence(); // force init</span>
<span class="nc" id="L1499">            return (long) est;</span>
        }
    }

    static final class KeySpliterator&lt;K,V&gt;
        extends HashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;K&gt; {
        KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
                       int expectedModCount) {
<span class="fc" id="L1508">            super(m, origin, fence, est, expectedModCount);</span>
<span class="fc" id="L1509">        }</span>

        public KeySpliterator&lt;K,V&gt; trySplit() {
<span class="nc" id="L1512">            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L1513" title="All 4 branches missed.">            return (lo &gt;= mid || current != null) ? null :</span>
                new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                        expectedModCount);
        }

        public void forEachRemaining(Consumer&lt;? super K&gt; action) {
            int i, hi, mc;
<span class="pc bpc" id="L1520" title="1 of 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1521">                throw new NullPointerException();</span>
<span class="fc" id="L1522">            HashMap&lt;K,V&gt; m = map;</span>
<span class="fc" id="L1523">            Node&lt;K,V&gt;[] tab = m.table;</span>
<span class="pc bpc" id="L1524" title="1 of 2 branches missed.">            if ((hi = fence) &lt; 0) {</span>
<span class="fc" id="L1525">                mc = expectedModCount = m.modCount;</span>
<span class="fc bfc" id="L1526" title="All 2 branches covered.">                hi = fence = (tab == null) ? 0 : tab.length;</span>
            }
            else
<span class="nc" id="L1529">                mc = expectedModCount;</span>
<span class="pc bpc" id="L1530" title="5 of 10 branches missed.">            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;</span>
                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
<span class="fc" id="L1532">                Node&lt;K,V&gt; p = current;</span>
<span class="fc" id="L1533">                current = null;</span>
                do {
<span class="fc bfc" id="L1535" title="All 2 branches covered.">                    if (p == null)</span>
<span class="fc" id="L1536">                        p = tab[i++];</span>
                    else {
<span class="fc" id="L1538">                        action.accept(p.key);</span>
<span class="fc" id="L1539">                        p = p.next;</span>
                    }
<span class="fc bfc" id="L1541" title="All 4 branches covered.">                } while (p != null || i &lt; hi);</span>
<span class="pc bpc" id="L1542" title="1 of 2 branches missed.">                if (m.modCount != mc)</span>
<span class="nc" id="L1543">                    throw new ConcurrentModificationException();</span>
            }
<span class="fc" id="L1545">        }</span>

        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
            int hi;
<span class="pc bpc" id="L1549" title="1 of 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1550">                throw new NullPointerException();</span>
<span class="fc" id="L1551">            Node&lt;K,V&gt;[] tab = map.table;</span>
<span class="pc bpc" id="L1552" title="2 of 6 branches missed.">            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {</span>
<span class="fc bfc" id="L1553" title="All 4 branches covered.">                while (current != null || index &lt; hi) {</span>
<span class="fc bfc" id="L1554" title="All 2 branches covered.">                    if (current == null)</span>
<span class="fc" id="L1555">                        current = tab[index++];</span>
                    else {
<span class="fc" id="L1557">                        K k = current.key;</span>
<span class="fc" id="L1558">                        current = current.next;</span>
<span class="fc" id="L1559">                        action.accept(k);</span>
<span class="pc bpc" id="L1560" title="1 of 2 branches missed.">                        if (map.modCount != expectedModCount)</span>
<span class="nc" id="L1561">                            throw new ConcurrentModificationException();</span>
<span class="fc" id="L1562">                        return true;</span>
                    }
                }
            }
<span class="fc" id="L1566">            return false;</span>
        }

        public int characteristics() {
<span class="pc bpc" id="L1570" title="3 of 4 branches missed.">            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |</span>
                Spliterator.DISTINCT;
        }
    }

    static final class ValueSpliterator&lt;K,V&gt;
        extends HashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;V&gt; {
        ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
                         int expectedModCount) {
<span class="nc" id="L1580">            super(m, origin, fence, est, expectedModCount);</span>
<span class="nc" id="L1581">        }</span>

        public ValueSpliterator&lt;K,V&gt; trySplit() {
<span class="nc" id="L1584">            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L1585" title="All 4 branches missed.">            return (lo &gt;= mid || current != null) ? null :</span>
                new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                          expectedModCount);
        }

        public void forEachRemaining(Consumer&lt;? super V&gt; action) {
            int i, hi, mc;
<span class="nc bnc" id="L1592" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1593">                throw new NullPointerException();</span>
<span class="nc" id="L1594">            HashMap&lt;K,V&gt; m = map;</span>
<span class="nc" id="L1595">            Node&lt;K,V&gt;[] tab = m.table;</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">            if ((hi = fence) &lt; 0) {</span>
<span class="nc" id="L1597">                mc = expectedModCount = m.modCount;</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">                hi = fence = (tab == null) ? 0 : tab.length;</span>
            }
            else
<span class="nc" id="L1601">                mc = expectedModCount;</span>
<span class="nc bnc" id="L1602" title="All 10 branches missed.">            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;</span>
                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
<span class="nc" id="L1604">                Node&lt;K,V&gt; p = current;</span>
<span class="nc" id="L1605">                current = null;</span>
                do {
<span class="nc bnc" id="L1607" title="All 2 branches missed.">                    if (p == null)</span>
<span class="nc" id="L1608">                        p = tab[i++];</span>
                    else {
<span class="nc" id="L1610">                        action.accept(p.value);</span>
<span class="nc" id="L1611">                        p = p.next;</span>
                    }
<span class="nc bnc" id="L1613" title="All 4 branches missed.">                } while (p != null || i &lt; hi);</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">                if (m.modCount != mc)</span>
<span class="nc" id="L1615">                    throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L1617">        }</span>

        public boolean tryAdvance(Consumer&lt;? super V&gt; action) {
            int hi;
<span class="nc bnc" id="L1621" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1622">                throw new NullPointerException();</span>
<span class="nc" id="L1623">            Node&lt;K,V&gt;[] tab = map.table;</span>
<span class="nc bnc" id="L1624" title="All 6 branches missed.">            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {</span>
<span class="nc bnc" id="L1625" title="All 4 branches missed.">                while (current != null || index &lt; hi) {</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">                    if (current == null)</span>
<span class="nc" id="L1627">                        current = tab[index++];</span>
                    else {
<span class="nc" id="L1629">                        V v = current.value;</span>
<span class="nc" id="L1630">                        current = current.next;</span>
<span class="nc" id="L1631">                        action.accept(v);</span>
<span class="nc bnc" id="L1632" title="All 2 branches missed.">                        if (map.modCount != expectedModCount)</span>
<span class="nc" id="L1633">                            throw new ConcurrentModificationException();</span>
<span class="nc" id="L1634">                        return true;</span>
                    }
                }
            }
<span class="nc" id="L1638">            return false;</span>
        }

        public int characteristics() {
<span class="nc bnc" id="L1642" title="All 4 branches missed.">            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0);</span>
        }
    }

    static final class EntrySpliterator&lt;K,V&gt;
        extends HashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
                         int expectedModCount) {
<span class="nc" id="L1651">            super(m, origin, fence, est, expectedModCount);</span>
<span class="nc" id="L1652">        }</span>

        public EntrySpliterator&lt;K,V&gt; trySplit() {
<span class="nc" id="L1655">            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L1656" title="All 4 branches missed.">            return (lo &gt;= mid || current != null) ? null :</span>
                new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                          expectedModCount);
        }

        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
            int i, hi, mc;
<span class="nc bnc" id="L1663" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1664">                throw new NullPointerException();</span>
<span class="nc" id="L1665">            HashMap&lt;K,V&gt; m = map;</span>
<span class="nc" id="L1666">            Node&lt;K,V&gt;[] tab = m.table;</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">            if ((hi = fence) &lt; 0) {</span>
<span class="nc" id="L1668">                mc = expectedModCount = m.modCount;</span>
<span class="nc bnc" id="L1669" title="All 2 branches missed.">                hi = fence = (tab == null) ? 0 : tab.length;</span>
            }
            else
<span class="nc" id="L1672">                mc = expectedModCount;</span>
<span class="nc bnc" id="L1673" title="All 10 branches missed.">            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;</span>
                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
<span class="nc" id="L1675">                Node&lt;K,V&gt; p = current;</span>
<span class="nc" id="L1676">                current = null;</span>
                do {
<span class="nc bnc" id="L1678" title="All 2 branches missed.">                    if (p == null)</span>
<span class="nc" id="L1679">                        p = tab[i++];</span>
                    else {
<span class="nc" id="L1681">                        action.accept(p);</span>
<span class="nc" id="L1682">                        p = p.next;</span>
                    }
<span class="nc bnc" id="L1684" title="All 4 branches missed.">                } while (p != null || i &lt; hi);</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">                if (m.modCount != mc)</span>
<span class="nc" id="L1686">                    throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L1688">        }</span>

        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
            int hi;
<span class="nc bnc" id="L1692" title="All 2 branches missed.">            if (action == null)</span>
<span class="nc" id="L1693">                throw new NullPointerException();</span>
<span class="nc" id="L1694">            Node&lt;K,V&gt;[] tab = map.table;</span>
<span class="nc bnc" id="L1695" title="All 6 branches missed.">            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {</span>
<span class="nc bnc" id="L1696" title="All 4 branches missed.">                while (current != null || index &lt; hi) {</span>
<span class="nc bnc" id="L1697" title="All 2 branches missed.">                    if (current == null)</span>
<span class="nc" id="L1698">                        current = tab[index++];</span>
                    else {
<span class="nc" id="L1700">                        Node&lt;K,V&gt; e = current;</span>
<span class="nc" id="L1701">                        current = current.next;</span>
<span class="nc" id="L1702">                        action.accept(e);</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">                        if (map.modCount != expectedModCount)</span>
<span class="nc" id="L1704">                            throw new ConcurrentModificationException();</span>
<span class="nc" id="L1705">                        return true;</span>
                    }
                }
            }
<span class="nc" id="L1709">            return false;</span>
        }

        public int characteristics() {
<span class="nc bnc" id="L1713" title="All 4 branches missed.">            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |</span>
                Spliterator.DISTINCT;
        }
    }

    /* ------------------------------------------------------------ */
    // LinkedHashMap support


    /*
     * The following package-protected methods are designed to be
     * overridden by LinkedHashMap, but not by any other subclass.
     * Nearly all other internal methods are also package-protected
     * but are declared final, so can be used by LinkedHashMap, view
     * classes, and HashSet.
     */

    // Create a regular (non-tree) node
    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {
<span class="fc" id="L1732">        return new Node&lt;&gt;(hash, key, value, next);</span>
    }

    // For conversion from TreeNodes to plain nodes
    Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {
<span class="fc" id="L1737">        return new Node&lt;&gt;(p.hash, p.key, p.value, next);</span>
    }

    // Create a tree bin node
    TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) {
<span class="fc" id="L1742">        return new TreeNode&lt;&gt;(hash, key, value, next);</span>
    }

    // For treeifyBin
    TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {
<span class="fc" id="L1747">        return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span>
    }

    /**
     * Reset to initial default state.  Called by clone and readObject.
     */
    void reinitialize() {
<span class="fc" id="L1754">        table = null;</span>
<span class="fc" id="L1755">        entrySet = null;</span>
<span class="fc" id="L1756">        keySet = null;</span>
<span class="fc" id="L1757">        values = null;</span>
<span class="fc" id="L1758">        modCount = 0;</span>
<span class="fc" id="L1759">        threshold = 0;</span>
<span class="fc" id="L1760">        size = 0;</span>
<span class="fc" id="L1761">    }</span>

    // Callbacks to allow LinkedHashMap post-actions
<span class="fc" id="L1764">    void afterNodeAccess(Node&lt;K,V&gt; p) { }</span>
<span class="fc" id="L1765">    void afterNodeInsertion(boolean evict) { }</span>
<span class="fc" id="L1766">    void afterNodeRemoval(Node&lt;K,V&gt; p) { }</span>

    // Called only from writeObject, to ensure compatible ordering.
    void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException {
        Node&lt;K,V&gt;[] tab;
<span class="pc bpc" id="L1771" title="1 of 4 branches missed.">        if (size &gt; 0 &amp;&amp; (tab = table) != null) {</span>
<span class="fc bfc" id="L1772" title="All 2 branches covered.">            for (int i = 0; i &lt; tab.length; ++i) {</span>
<span class="fc bfc" id="L1773" title="All 2 branches covered.">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {</span>
<span class="fc" id="L1774">                    s.writeObject(e.key);</span>
<span class="fc" id="L1775">                    s.writeObject(e.value);</span>
                }
            }
        }
<span class="fc" id="L1779">    }</span>

    /* ------------------------------------------------------------ */
    // Tree bins

    /**
     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn
     * extends Node) so can be used as extension of either regular or
     * linked node.
     */
<span class="pc bpc" id="L1789" title="1 of 2 branches missed.">    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {</span>
        TreeNode&lt;K,V&gt; parent;  // red-black tree links
        TreeNode&lt;K,V&gt; left;
        TreeNode&lt;K,V&gt; right;
        TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
        boolean red;
        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {
<span class="fc" id="L1796">            super(hash, key, val, next);</span>
<span class="fc" id="L1797">        }</span>

        /**
         * Returns root of tree containing this node.
         */
        final TreeNode&lt;K,V&gt; root() {
<span class="nc" id="L1803">            for (TreeNode&lt;K,V&gt; r = this, p;;) {</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">                if ((p = r.parent) == null)</span>
<span class="nc" id="L1805">                    return r;</span>
<span class="nc" id="L1806">                r = p;</span>
            }
        }

        /**
         * Ensures that the given root is the first node of its bin.
         */
        static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) {
            int n;
<span class="pc bpc" id="L1815" title="3 of 6 branches missed.">            if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) {</span>
<span class="fc" id="L1816">                int index = (n - 1) &amp; root.hash;</span>
<span class="fc" id="L1817">                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span>
<span class="fc bfc" id="L1818" title="All 2 branches covered.">                if (root != first) {</span>
                    Node&lt;K,V&gt; rn;
<span class="fc" id="L1820">                    tab[index] = root;</span>
<span class="fc" id="L1821">                    TreeNode&lt;K,V&gt; rp = root.prev;</span>
<span class="fc bfc" id="L1822" title="All 2 branches covered.">                    if ((rn = root.next) != null)</span>
<span class="fc" id="L1823">                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span>
<span class="pc bpc" id="L1824" title="1 of 2 branches missed.">                    if (rp != null)</span>
<span class="fc" id="L1825">                        rp.next = rn;</span>
<span class="pc bpc" id="L1826" title="1 of 2 branches missed.">                    if (first != null)</span>
<span class="fc" id="L1827">                        first.prev = root;</span>
<span class="fc" id="L1828">                    root.next = first;</span>
<span class="fc" id="L1829">                    root.prev = null;</span>
                }
<span class="pc bpc" id="L1831" title="2 of 4 branches missed.">                assert checkInvariants(root);</span>
            }
<span class="fc" id="L1833">        }</span>

        /**
         * Finds the node starting at root p with the given hash and key.
         * The kc argument caches comparableClassFor(key) upon first use
         * comparing keys.
         */
        final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) {
<span class="fc" id="L1841">            TreeNode&lt;K,V&gt; p = this;</span>
            do {
                int ph, dir; K pk;
<span class="fc" id="L1844">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span>
<span class="fc bfc" id="L1845" title="All 2 branches covered.">                if ((ph = p.hash) &gt; h)</span>
<span class="fc" id="L1846">                    p = pl;</span>
<span class="fc bfc" id="L1847" title="All 2 branches covered.">                else if (ph &lt; h)</span>
<span class="fc" id="L1848">                    p = pr;</span>
<span class="pc bpc" id="L1849" title="1 of 6 branches missed.">                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))</span>
<span class="fc" id="L1850">                    return p;</span>
<span class="fc bfc" id="L1851" title="All 2 branches covered.">                else if (pl == null)</span>
<span class="fc" id="L1852">                    p = pr;</span>
<span class="fc bfc" id="L1853" title="All 2 branches covered.">                else if (pr == null)</span>
<span class="fc" id="L1854">                    p = pl;</span>
<span class="fc bfc" id="L1855" title="All 2 branches covered.">                else if ((kc != null ||</span>
<span class="fc bfc" id="L1856" title="All 2 branches covered.">                          (kc = comparableClassFor(k)) != null) &amp;&amp;</span>
<span class="pc bpc" id="L1857" title="1 of 2 branches missed.">                         (dir = compareComparables(kc, k, pk)) != 0)</span>
<span class="fc bfc" id="L1858" title="All 2 branches covered.">                    p = (dir &lt; 0) ? pl : pr;</span>
<span class="fc bfc" id="L1859" title="All 2 branches covered.">                else if ((q = pr.find(h, k, kc)) != null)</span>
<span class="fc" id="L1860">                    return q;</span>
                else
<span class="fc" id="L1862">                    p = pl;</span>
<span class="fc bfc" id="L1863" title="All 2 branches covered.">            } while (p != null);</span>
<span class="fc" id="L1864">            return null;</span>
        }

        /**
         * Calls find for root node.
         */
        final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) {
<span class="pc bpc" id="L1871" title="1 of 2 branches missed.">            return ((parent != null) ? root() : this).find(h, k, null);</span>
        }

        /**
         * Tie-breaking utility for ordering insertions when equal
         * hashCodes and non-comparable. We don't require a total
         * order, just a consistent insertion rule to maintain
         * equivalence across rebalancings. Tie-breaking further than
         * necessary simplifies testing a bit.
         */
        static int tieBreakOrder(Object a, Object b) {
            int d;
<span class="pc bpc" id="L1883" title="2 of 4 branches missed.">            if (a == null || b == null ||</span>
<span class="fc" id="L1884">                (d = a.getClass().getName().</span>
<span class="fc bfc" id="L1885" title="All 2 branches covered.">                 compareTo(b.getClass().getName())) == 0)</span>
<span class="fc bfc" id="L1886" title="All 2 branches covered.">                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span>
                     -1 : 1);
<span class="fc" id="L1888">            return d;</span>
        }

        /**
         * Forms tree of the nodes linked from this node.
         * @return root of tree
         */
        final void treeify(Node&lt;K,V&gt;[] tab) {
<span class="fc" id="L1896">            TreeNode&lt;K,V&gt; root = null;</span>
<span class="fc bfc" id="L1897" title="All 2 branches covered.">            for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) {</span>
<span class="fc" id="L1898">                next = (TreeNode&lt;K,V&gt;)x.next;</span>
<span class="fc" id="L1899">                x.left = x.right = null;</span>
<span class="fc bfc" id="L1900" title="All 2 branches covered.">                if (root == null) {</span>
<span class="fc" id="L1901">                    x.parent = null;</span>
<span class="fc" id="L1902">                    x.red = false;</span>
<span class="fc" id="L1903">                    root = x;</span>
                }
                else {
<span class="fc" id="L1906">                    K k = x.key;</span>
<span class="fc" id="L1907">                    int h = x.hash;</span>
<span class="fc" id="L1908">                    Class&lt;?&gt; kc = null;</span>
<span class="fc" id="L1909">                    for (TreeNode&lt;K,V&gt; p = root;;) {</span>
                        int dir, ph;
<span class="fc" id="L1911">                        K pk = p.key;</span>
<span class="fc bfc" id="L1912" title="All 2 branches covered.">                        if ((ph = p.hash) &gt; h)</span>
<span class="fc" id="L1913">                            dir = -1;</span>
<span class="fc bfc" id="L1914" title="All 2 branches covered.">                        else if (ph &lt; h)</span>
<span class="fc" id="L1915">                            dir = 1;</span>
<span class="fc bfc" id="L1916" title="All 2 branches covered.">                        else if ((kc == null &amp;&amp;</span>
<span class="fc bfc" id="L1917" title="All 2 branches covered.">                                  (kc = comparableClassFor(k)) == null) ||</span>
<span class="fc bfc" id="L1918" title="All 2 branches covered.">                                 (dir = compareComparables(kc, k, pk)) == 0)</span>
<span class="fc" id="L1919">                            dir = tieBreakOrder(k, pk);</span>

<span class="fc" id="L1921">                        TreeNode&lt;K,V&gt; xp = p;</span>
<span class="fc bfc" id="L1922" title="All 4 branches covered.">                        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {</span>
<span class="fc" id="L1923">                            x.parent = xp;</span>
<span class="fc bfc" id="L1924" title="All 2 branches covered.">                            if (dir &lt;= 0)</span>
<span class="fc" id="L1925">                                xp.left = x;</span>
                            else
<span class="fc" id="L1927">                                xp.right = x;</span>
<span class="fc" id="L1928">                            root = balanceInsertion(root, x);</span>
<span class="fc" id="L1929">                            break;</span>
                        }
<span class="fc" id="L1931">                    }</span>
                }
            }
<span class="fc" id="L1934">            moveRootToFront(tab, root);</span>
<span class="fc" id="L1935">        }</span>

        /**
         * Returns a list of non-TreeNodes replacing those linked from
         * this node.
         */
        final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {
<span class="fc" id="L1942">            Node&lt;K,V&gt; hd = null, tl = null;</span>
<span class="fc bfc" id="L1943" title="All 2 branches covered.">            for (Node&lt;K,V&gt; q = this; q != null; q = q.next) {</span>
<span class="fc" id="L1944">                Node&lt;K,V&gt; p = map.replacementNode(q, null);</span>
<span class="fc bfc" id="L1945" title="All 2 branches covered.">                if (tl == null)</span>
<span class="fc" id="L1946">                    hd = p;</span>
                else
<span class="fc" id="L1948">                    tl.next = p;</span>
<span class="fc" id="L1949">                tl = p;</span>
            }
<span class="fc" id="L1951">            return hd;</span>
        }

        /**
         * Tree version of putVal.
         */
        final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,
                                       int h, K k, V v) {
<span class="fc" id="L1959">            Class&lt;?&gt; kc = null;</span>
<span class="fc" id="L1960">            boolean searched = false;</span>
<span class="pc bpc" id="L1961" title="1 of 2 branches missed.">            TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;</span>
<span class="fc" id="L1962">            for (TreeNode&lt;K,V&gt; p = root;;) {</span>
                int dir, ph; K pk;
<span class="fc bfc" id="L1964" title="All 2 branches covered.">                if ((ph = p.hash) &gt; h)</span>
<span class="fc" id="L1965">                    dir = -1;</span>
<span class="fc bfc" id="L1966" title="All 2 branches covered.">                else if (ph &lt; h)</span>
<span class="fc" id="L1967">                    dir = 1;</span>
<span class="pc bpc" id="L1968" title="2 of 6 branches missed.">                else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))</span>
<span class="fc" id="L1969">                    return p;</span>
<span class="pc bpc" id="L1970" title="1 of 2 branches missed.">                else if ((kc == null &amp;&amp;</span>
<span class="pc bpc" id="L1971" title="1 of 2 branches missed.">                          (kc = comparableClassFor(k)) == null) ||</span>
<span class="nc bnc" id="L1972" title="All 2 branches missed.">                         (dir = compareComparables(kc, k, pk)) == 0) {</span>
<span class="fc bfc" id="L1973" title="All 2 branches covered.">                    if (!searched) {</span>
                        TreeNode&lt;K,V&gt; q, ch;
<span class="fc" id="L1975">                        searched = true;</span>
<span class="fc bfc" id="L1976" title="All 2 branches covered.">                        if (((ch = p.left) != null &amp;&amp;</span>
<span class="fc bfc" id="L1977" title="All 4 branches covered.">                             (q = ch.find(h, k, kc)) != null) ||</span>
                            ((ch = p.right) != null &amp;&amp;
<span class="fc bfc" id="L1979" title="All 2 branches covered.">                             (q = ch.find(h, k, kc)) != null))</span>
<span class="fc" id="L1980">                            return q;</span>
                    }
<span class="fc" id="L1982">                    dir = tieBreakOrder(k, pk);</span>
                }

<span class="fc" id="L1985">                TreeNode&lt;K,V&gt; xp = p;</span>
<span class="fc bfc" id="L1986" title="All 4 branches covered.">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {</span>
<span class="fc" id="L1987">                    Node&lt;K,V&gt; xpn = xp.next;</span>
<span class="fc" id="L1988">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span>
<span class="fc bfc" id="L1989" title="All 2 branches covered.">                    if (dir &lt;= 0)</span>
<span class="fc" id="L1990">                        xp.left = x;</span>
                    else
<span class="fc" id="L1992">                        xp.right = x;</span>
<span class="fc" id="L1993">                    xp.next = x;</span>
<span class="fc" id="L1994">                    x.parent = x.prev = xp;</span>
<span class="fc bfc" id="L1995" title="All 2 branches covered.">                    if (xpn != null)</span>
<span class="fc" id="L1996">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span>
<span class="fc" id="L1997">                    moveRootToFront(tab, balanceInsertion(root, x));</span>
<span class="fc" id="L1998">                    return null;</span>
                }
<span class="fc" id="L2000">            }</span>
        }

        /**
         * Removes the given node, that must be present before this call.
         * This is messier than typical red-black deletion code because we
         * cannot swap the contents of an interior node with a leaf
         * successor that is pinned by &quot;next&quot; pointers that are accessible
         * independently during traversal. So instead we swap the tree
         * linkages. If the current tree appears to have too few nodes,
         * the bin is converted back to a plain bin. (The test triggers
         * somewhere between 2 and 6 nodes, depending on tree structure).
         */
        final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,
                                  boolean movable) {
            int n;
<span class="nc bnc" id="L2016" title="All 4 branches missed.">            if (tab == null || (n = tab.length) == 0)</span>
<span class="nc" id="L2017">                return;</span>
<span class="nc" id="L2018">            int index = (n - 1) &amp; hash;</span>
<span class="nc" id="L2019">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span>
<span class="nc" id="L2020">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span>
<span class="nc bnc" id="L2021" title="All 2 branches missed.">            if (pred == null)</span>
<span class="nc" id="L2022">                tab[index] = first = succ;</span>
            else
<span class="nc" id="L2024">                pred.next = succ;</span>
<span class="nc bnc" id="L2025" title="All 2 branches missed.">            if (succ != null)</span>
<span class="nc" id="L2026">                succ.prev = pred;</span>
<span class="nc bnc" id="L2027" title="All 2 branches missed.">            if (first == null)</span>
<span class="nc" id="L2028">                return;</span>
<span class="nc bnc" id="L2029" title="All 2 branches missed.">            if (root.parent != null)</span>
<span class="nc" id="L2030">                root = root.root();</span>
<span class="nc bnc" id="L2031" title="All 8 branches missed.">            if (root == null || root.right == null ||</span>
                (rl = root.left) == null || rl.left == null) {
<span class="nc" id="L2033">                tab[index] = first.untreeify(map);  // too small</span>
<span class="nc" id="L2034">                return;</span>
            }
<span class="nc" id="L2036">            TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement;</span>
<span class="nc bnc" id="L2037" title="All 4 branches missed.">            if (pl != null &amp;&amp; pr != null) {</span>
<span class="nc" id="L2038">                TreeNode&lt;K,V&gt; s = pr, sl;</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">                while ((sl = s.left) != null) // find successor</span>
<span class="nc" id="L2040">                    s = sl;</span>
<span class="nc" id="L2041">                boolean c = s.red; s.red = p.red; p.red = c; // swap colors</span>
<span class="nc" id="L2042">                TreeNode&lt;K,V&gt; sr = s.right;</span>
<span class="nc" id="L2043">                TreeNode&lt;K,V&gt; pp = p.parent;</span>
<span class="nc bnc" id="L2044" title="All 2 branches missed.">                if (s == pr) { // p was s's direct parent</span>
<span class="nc" id="L2045">                    p.parent = s;</span>
<span class="nc" id="L2046">                    s.right = p;</span>
                }
                else {
<span class="nc" id="L2049">                    TreeNode&lt;K,V&gt; sp = s.parent;</span>
<span class="nc bnc" id="L2050" title="All 2 branches missed.">                    if ((p.parent = sp) != null) {</span>
<span class="nc bnc" id="L2051" title="All 2 branches missed.">                        if (s == sp.left)</span>
<span class="nc" id="L2052">                            sp.left = p;</span>
                        else
<span class="nc" id="L2054">                            sp.right = p;</span>
                    }
<span class="nc bnc" id="L2056" title="All 2 branches missed.">                    if ((s.right = pr) != null)</span>
<span class="nc" id="L2057">                        pr.parent = s;</span>
                }
<span class="nc" id="L2059">                p.left = null;</span>
<span class="nc bnc" id="L2060" title="All 2 branches missed.">                if ((p.right = sr) != null)</span>
<span class="nc" id="L2061">                    sr.parent = p;</span>
<span class="nc bnc" id="L2062" title="All 2 branches missed.">                if ((s.left = pl) != null)</span>
<span class="nc" id="L2063">                    pl.parent = s;</span>
<span class="nc bnc" id="L2064" title="All 2 branches missed.">                if ((s.parent = pp) == null)</span>
<span class="nc" id="L2065">                    root = s;</span>
<span class="nc bnc" id="L2066" title="All 2 branches missed.">                else if (p == pp.left)</span>
<span class="nc" id="L2067">                    pp.left = s;</span>
                else
<span class="nc" id="L2069">                    pp.right = s;</span>
<span class="nc bnc" id="L2070" title="All 2 branches missed.">                if (sr != null)</span>
<span class="nc" id="L2071">                    replacement = sr;</span>
                else
<span class="nc" id="L2073">                    replacement = p;</span>
<span class="nc" id="L2074">            }</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">            else if (pl != null)</span>
<span class="nc" id="L2076">                replacement = pl;</span>
<span class="nc bnc" id="L2077" title="All 2 branches missed.">            else if (pr != null)</span>
<span class="nc" id="L2078">                replacement = pr;</span>
            else
<span class="nc" id="L2080">                replacement = p;</span>
<span class="nc bnc" id="L2081" title="All 2 branches missed.">            if (replacement != p) {</span>
<span class="nc" id="L2082">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">                if (pp == null)</span>
<span class="nc" id="L2084">                    root = replacement;</span>
<span class="nc bnc" id="L2085" title="All 2 branches missed.">                else if (p == pp.left)</span>
<span class="nc" id="L2086">                    pp.left = replacement;</span>
                else
<span class="nc" id="L2088">                    pp.right = replacement;</span>
<span class="nc" id="L2089">                p.left = p.right = p.parent = null;</span>
            }

<span class="nc bnc" id="L2092" title="All 2 branches missed.">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span>

<span class="nc bnc" id="L2094" title="All 2 branches missed.">            if (replacement == p) {  // detach</span>
<span class="nc" id="L2095">                TreeNode&lt;K,V&gt; pp = p.parent;</span>
<span class="nc" id="L2096">                p.parent = null;</span>
<span class="nc bnc" id="L2097" title="All 2 branches missed.">                if (pp != null) {</span>
<span class="nc bnc" id="L2098" title="All 2 branches missed.">                    if (p == pp.left)</span>
<span class="nc" id="L2099">                        pp.left = null;</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">                    else if (p == pp.right)</span>
<span class="nc" id="L2101">                        pp.right = null;</span>
                }
            }
<span class="nc bnc" id="L2104" title="All 2 branches missed.">            if (movable)</span>
<span class="nc" id="L2105">                moveRootToFront(tab, r);</span>
<span class="nc" id="L2106">        }</span>

        /**
         * Splits nodes in a tree bin into lower and upper tree bins,
         * or untreeifies if now too small. Called only from resize;
         * see above discussion about split bits and indices.
         *
         * @param map the map
         * @param tab the table for recording bin heads
         * @param index the index of the table being split
         * @param bit the bit of hash to split on
         */
        final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) {
<span class="fc" id="L2119">            TreeNode&lt;K,V&gt; b = this;</span>
            // Relink into lo and hi lists, preserving order
<span class="fc" id="L2121">            TreeNode&lt;K,V&gt; loHead = null, loTail = null;</span>
<span class="fc" id="L2122">            TreeNode&lt;K,V&gt; hiHead = null, hiTail = null;</span>
<span class="fc" id="L2123">            int lc = 0, hc = 0;</span>
<span class="fc bfc" id="L2124" title="All 2 branches covered.">            for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) {</span>
<span class="fc" id="L2125">                next = (TreeNode&lt;K,V&gt;)e.next;</span>
<span class="fc" id="L2126">                e.next = null;</span>
<span class="fc bfc" id="L2127" title="All 2 branches covered.">                if ((e.hash &amp; bit) == 0) {</span>
<span class="fc bfc" id="L2128" title="All 2 branches covered.">                    if ((e.prev = loTail) == null)</span>
<span class="fc" id="L2129">                        loHead = e;</span>
                    else
<span class="fc" id="L2131">                        loTail.next = e;</span>
<span class="fc" id="L2132">                    loTail = e;</span>
<span class="fc" id="L2133">                    ++lc;</span>
                }
                else {
<span class="fc bfc" id="L2136" title="All 2 branches covered.">                    if ((e.prev = hiTail) == null)</span>
<span class="fc" id="L2137">                        hiHead = e;</span>
                    else
<span class="fc" id="L2139">                        hiTail.next = e;</span>
<span class="fc" id="L2140">                    hiTail = e;</span>
<span class="fc" id="L2141">                    ++hc;</span>
                }
            }

<span class="fc bfc" id="L2145" title="All 2 branches covered.">            if (loHead != null) {</span>
<span class="fc bfc" id="L2146" title="All 2 branches covered.">                if (lc &lt;= UNTREEIFY_THRESHOLD)</span>
<span class="fc" id="L2147">                    tab[index] = loHead.untreeify(map);</span>
                else {
<span class="fc" id="L2149">                    tab[index] = loHead;</span>
<span class="fc bfc" id="L2150" title="All 2 branches covered.">                    if (hiHead != null) // (else is already treeified)</span>
<span class="fc" id="L2151">                        loHead.treeify(tab);</span>
                }
            }
<span class="fc bfc" id="L2154" title="All 2 branches covered.">            if (hiHead != null) {</span>
<span class="fc bfc" id="L2155" title="All 2 branches covered.">                if (hc &lt;= UNTREEIFY_THRESHOLD)</span>
<span class="fc" id="L2156">                    tab[index + bit] = hiHead.untreeify(map);</span>
                else {
<span class="fc" id="L2158">                    tab[index + bit] = hiHead;</span>
<span class="fc bfc" id="L2159" title="All 2 branches covered.">                    if (loHead != null)</span>
<span class="fc" id="L2160">                        hiHead.treeify(tab);</span>
                }
            }
<span class="fc" id="L2163">        }</span>

        /* ------------------------------------------------------------ */
        // Red-black tree methods, all adapted from CLR

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,
                                              TreeNode&lt;K,V&gt; p) {
            TreeNode&lt;K,V&gt; r, pp, rl;
<span class="pc bpc" id="L2171" title="2 of 4 branches missed.">            if (p != null &amp;&amp; (r = p.right) != null) {</span>
<span class="fc bfc" id="L2172" title="All 2 branches covered.">                if ((rl = p.right = r.left) != null)</span>
<span class="fc" id="L2173">                    rl.parent = p;</span>
<span class="fc bfc" id="L2174" title="All 2 branches covered.">                if ((pp = r.parent = p.parent) == null)</span>
<span class="fc" id="L2175">                    (root = r).red = false;</span>
<span class="fc bfc" id="L2176" title="All 2 branches covered.">                else if (pp.left == p)</span>
<span class="fc" id="L2177">                    pp.left = r;</span>
                else
<span class="fc" id="L2179">                    pp.right = r;</span>
<span class="fc" id="L2180">                r.left = p;</span>
<span class="fc" id="L2181">                p.parent = r;</span>
            }
<span class="fc" id="L2183">            return root;</span>
        }

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,
                                               TreeNode&lt;K,V&gt; p) {
            TreeNode&lt;K,V&gt; l, pp, lr;
<span class="pc bpc" id="L2189" title="2 of 4 branches missed.">            if (p != null &amp;&amp; (l = p.left) != null) {</span>
<span class="fc bfc" id="L2190" title="All 2 branches covered.">                if ((lr = p.left = l.right) != null)</span>
<span class="fc" id="L2191">                    lr.parent = p;</span>
<span class="fc bfc" id="L2192" title="All 2 branches covered.">                if ((pp = l.parent = p.parent) == null)</span>
<span class="fc" id="L2193">                    (root = l).red = false;</span>
<span class="fc bfc" id="L2194" title="All 2 branches covered.">                else if (pp.right == p)</span>
<span class="fc" id="L2195">                    pp.right = l;</span>
                else
<span class="fc" id="L2197">                    pp.left = l;</span>
<span class="fc" id="L2198">                l.right = p;</span>
<span class="fc" id="L2199">                p.parent = l;</span>
            }
<span class="fc" id="L2201">            return root;</span>
        }

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,
                                                    TreeNode&lt;K,V&gt; x) {
<span class="fc" id="L2206">            x.red = true;</span>
            for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) {
<span class="fc bfc" id="L2208" title="All 2 branches covered.">                if ((xp = x.parent) == null) {</span>
<span class="fc" id="L2209">                    x.red = false;</span>
<span class="fc" id="L2210">                    return x;</span>
                }
<span class="pc bpc" id="L2212" title="1 of 4 branches missed.">                else if (!xp.red || (xpp = xp.parent) == null)</span>
<span class="fc" id="L2213">                    return root;</span>
<span class="fc bfc" id="L2214" title="All 2 branches covered.">                if (xp == (xppl = xpp.left)) {</span>
<span class="fc bfc" id="L2215" title="All 4 branches covered.">                    if ((xppr = xpp.right) != null &amp;&amp; xppr.red) {</span>
<span class="fc" id="L2216">                        xppr.red = false;</span>
<span class="fc" id="L2217">                        xp.red = false;</span>
<span class="fc" id="L2218">                        xpp.red = true;</span>
<span class="fc" id="L2219">                        x = xpp;</span>
                    }
                    else {
<span class="fc bfc" id="L2222" title="All 2 branches covered.">                        if (x == xp.right) {</span>
<span class="fc" id="L2223">                            root = rotateLeft(root, x = xp);</span>
<span class="pc bpc" id="L2224" title="1 of 2 branches missed.">                            xpp = (xp = x.parent) == null ? null : xp.parent;</span>
                        }
<span class="pc bpc" id="L2226" title="1 of 2 branches missed.">                        if (xp != null) {</span>
<span class="fc" id="L2227">                            xp.red = false;</span>
<span class="pc bpc" id="L2228" title="1 of 2 branches missed.">                            if (xpp != null) {</span>
<span class="fc" id="L2229">                                xpp.red = true;</span>
<span class="fc" id="L2230">                                root = rotateRight(root, xpp);</span>
                            }
                        }
                    }
                }
                else {
<span class="fc bfc" id="L2236" title="All 4 branches covered.">                    if (xppl != null &amp;&amp; xppl.red) {</span>
<span class="fc" id="L2237">                        xppl.red = false;</span>
<span class="fc" id="L2238">                        xp.red = false;</span>
<span class="fc" id="L2239">                        xpp.red = true;</span>
<span class="fc" id="L2240">                        x = xpp;</span>
                    }
                    else {
<span class="fc bfc" id="L2243" title="All 2 branches covered.">                        if (x == xp.left) {</span>
<span class="fc" id="L2244">                            root = rotateRight(root, x = xp);</span>
<span class="pc bpc" id="L2245" title="1 of 2 branches missed.">                            xpp = (xp = x.parent) == null ? null : xp.parent;</span>
                        }
<span class="pc bpc" id="L2247" title="1 of 2 branches missed.">                        if (xp != null) {</span>
<span class="fc" id="L2248">                            xp.red = false;</span>
<span class="pc bpc" id="L2249" title="1 of 2 branches missed.">                            if (xpp != null) {</span>
<span class="fc" id="L2250">                                xpp.red = true;</span>
<span class="fc" id="L2251">                                root = rotateLeft(root, xpp);</span>
                            }
                        }
                    }
                }
            }
        }

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,
                                                   TreeNode&lt;K,V&gt; x) {
            for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  {
<span class="nc bnc" id="L2262" title="All 4 branches missed.">                if (x == null || x == root)</span>
<span class="nc" id="L2263">                    return root;</span>
<span class="nc bnc" id="L2264" title="All 2 branches missed.">                else if ((xp = x.parent) == null) {</span>
<span class="nc" id="L2265">                    x.red = false;</span>
<span class="nc" id="L2266">                    return x;</span>
                }
<span class="nc bnc" id="L2268" title="All 2 branches missed.">                else if (x.red) {</span>
<span class="nc" id="L2269">                    x.red = false;</span>
<span class="nc" id="L2270">                    return root;</span>
                }
<span class="nc bnc" id="L2272" title="All 2 branches missed.">                else if ((xpl = xp.left) == x) {</span>
<span class="nc bnc" id="L2273" title="All 4 branches missed.">                    if ((xpr = xp.right) != null &amp;&amp; xpr.red) {</span>
<span class="nc" id="L2274">                        xpr.red = false;</span>
<span class="nc" id="L2275">                        xp.red = true;</span>
<span class="nc" id="L2276">                        root = rotateLeft(root, xp);</span>
<span class="nc bnc" id="L2277" title="All 2 branches missed.">                        xpr = (xp = x.parent) == null ? null : xp.right;</span>
                    }
<span class="nc bnc" id="L2279" title="All 2 branches missed.">                    if (xpr == null)</span>
<span class="nc" id="L2280">                        x = xp;</span>
                    else {
<span class="nc" id="L2282">                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span>
<span class="nc bnc" id="L2283" title="All 8 branches missed.">                        if ((sr == null || !sr.red) &amp;&amp;</span>
                            (sl == null || !sl.red)) {
<span class="nc" id="L2285">                            xpr.red = true;</span>
<span class="nc" id="L2286">                            x = xp;</span>
                        }
                        else {
<span class="nc bnc" id="L2289" title="All 4 branches missed.">                            if (sr == null || !sr.red) {</span>
<span class="nc bnc" id="L2290" title="All 2 branches missed.">                                if (sl != null)</span>
<span class="nc" id="L2291">                                    sl.red = false;</span>
<span class="nc" id="L2292">                                xpr.red = true;</span>
<span class="nc" id="L2293">                                root = rotateRight(root, xpr);</span>
<span class="nc bnc" id="L2294" title="All 2 branches missed.">                                xpr = (xp = x.parent) == null ?</span>
                                    null : xp.right;
                            }
<span class="nc bnc" id="L2297" title="All 2 branches missed.">                            if (xpr != null) {</span>
<span class="nc bnc" id="L2298" title="All 2 branches missed.">                                xpr.red = (xp == null) ? false : xp.red;</span>
<span class="nc bnc" id="L2299" title="All 2 branches missed.">                                if ((sr = xpr.right) != null)</span>
<span class="nc" id="L2300">                                    sr.red = false;</span>
                            }
<span class="nc bnc" id="L2302" title="All 2 branches missed.">                            if (xp != null) {</span>
<span class="nc" id="L2303">                                xp.red = false;</span>
<span class="nc" id="L2304">                                root = rotateLeft(root, xp);</span>
                            }
<span class="nc" id="L2306">                            x = root;</span>
                        }
<span class="nc" id="L2308">                    }</span>
                }
                else { // symmetric
<span class="nc bnc" id="L2311" title="All 4 branches missed.">                    if (xpl != null &amp;&amp; xpl.red) {</span>
<span class="nc" id="L2312">                        xpl.red = false;</span>
<span class="nc" id="L2313">                        xp.red = true;</span>
<span class="nc" id="L2314">                        root = rotateRight(root, xp);</span>
<span class="nc bnc" id="L2315" title="All 2 branches missed.">                        xpl = (xp = x.parent) == null ? null : xp.left;</span>
                    }
<span class="nc bnc" id="L2317" title="All 2 branches missed.">                    if (xpl == null)</span>
<span class="nc" id="L2318">                        x = xp;</span>
                    else {
<span class="nc" id="L2320">                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span>
<span class="nc bnc" id="L2321" title="All 8 branches missed.">                        if ((sl == null || !sl.red) &amp;&amp;</span>
                            (sr == null || !sr.red)) {
<span class="nc" id="L2323">                            xpl.red = true;</span>
<span class="nc" id="L2324">                            x = xp;</span>
                        }
                        else {
<span class="nc bnc" id="L2327" title="All 4 branches missed.">                            if (sl == null || !sl.red) {</span>
<span class="nc bnc" id="L2328" title="All 2 branches missed.">                                if (sr != null)</span>
<span class="nc" id="L2329">                                    sr.red = false;</span>
<span class="nc" id="L2330">                                xpl.red = true;</span>
<span class="nc" id="L2331">                                root = rotateLeft(root, xpl);</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">                                xpl = (xp = x.parent) == null ?</span>
                                    null : xp.left;
                            }
<span class="nc bnc" id="L2335" title="All 2 branches missed.">                            if (xpl != null) {</span>
<span class="nc bnc" id="L2336" title="All 2 branches missed.">                                xpl.red = (xp == null) ? false : xp.red;</span>
<span class="nc bnc" id="L2337" title="All 2 branches missed.">                                if ((sl = xpl.left) != null)</span>
<span class="nc" id="L2338">                                    sl.red = false;</span>
                            }
<span class="nc bnc" id="L2340" title="All 2 branches missed.">                            if (xp != null) {</span>
<span class="nc" id="L2341">                                xp.red = false;</span>
<span class="nc" id="L2342">                                root = rotateRight(root, xp);</span>
                            }
<span class="nc" id="L2344">                            x = root;</span>
                        }
<span class="nc" id="L2346">                    }</span>
                }
            }
        }

        /**
         * Recursive invariant check
         */
        static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) {
<span class="fc" id="L2355">            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span>
<span class="fc" id="L2356">                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span>
<span class="pc bpc" id="L2357" title="1 of 4 branches missed.">            if (tb != null &amp;&amp; tb.next != t)</span>
<span class="nc" id="L2358">                return false;</span>
<span class="pc bpc" id="L2359" title="1 of 4 branches missed.">            if (tn != null &amp;&amp; tn.prev != t)</span>
<span class="nc" id="L2360">                return false;</span>
<span class="pc bpc" id="L2361" title="1 of 6 branches missed.">            if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span>
<span class="nc" id="L2362">                return false;</span>
<span class="pc bpc" id="L2363" title="2 of 6 branches missed.">            if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span>
<span class="nc" id="L2364">                return false;</span>
<span class="pc bpc" id="L2365" title="2 of 6 branches missed.">            if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span>
<span class="nc" id="L2366">                return false;</span>
<span class="pc bpc" id="L2367" title="5 of 10 branches missed.">            if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)</span>
<span class="nc" id="L2368">                return false;</span>
<span class="pc bpc" id="L2369" title="1 of 4 branches missed.">            if (tl != null &amp;&amp; !checkInvariants(tl))</span>
<span class="nc" id="L2370">                return false;</span>
<span class="pc bpc" id="L2371" title="1 of 4 branches missed.">            if (tr != null &amp;&amp; !checkInvariants(tr))</span>
<span class="nc" id="L2372">                return false;</span>
<span class="fc" id="L2373">            return true;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>