<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SplittableRandom.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">SplittableRandom.java</span></div><h1>SplittableRandom.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.net.NetworkInterface;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.stream.StreamSupport;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.DoubleStream;

/**
 * A generator of uniform pseudorandom values applicable for use in
 * (among other contexts) isolated parallel computations that may
 * generate subtasks. Class {@code SplittableRandom} supports methods for
 * producing pseudorandom numbers of type {@code int}, {@code long},
 * and {@code double} with similar usages as for class
 * {@link java.util.Random} but differs in the following ways:
 *
 * &lt;ul&gt;
 *
 * &lt;li&gt;Series of generated values pass the DieHarder suite testing
 * independence and uniformity properties of random number generators.
 * (Most recently validated with &lt;a
 * href=&quot;http://www.phy.duke.edu/~rgb/General/dieharder.php&quot;&gt; version
 * 3.31.1&lt;/a&gt;.) These tests validate only the methods for certain
 * types and ranges, but similar properties are expected to hold, at
 * least approximately, for others as well. The &lt;em&gt;period&lt;/em&gt;
 * (length of any series of generated values before it repeats) is at
 * least 2&lt;sup&gt;64&lt;/sup&gt;. &lt;/li&gt;
 *
 * &lt;li&gt; Method {@link #split} constructs and returns a new
 * SplittableRandom instance that shares no mutable state with the
 * current instance. However, with very high probability, the
 * values collectively generated by the two objects have the same
 * statistical properties as if the same quantity of values were
 * generated by a single thread using a single {@code
 * SplittableRandom} object.  &lt;/li&gt;
 *
 * &lt;li&gt;Instances of SplittableRandom are &lt;em&gt;not&lt;/em&gt; thread-safe.
 * They are designed to be split, not shared, across threads. For
 * example, a {@link java.util.concurrent.ForkJoinTask
 * fork/join-style} computation using random numbers might include a
 * construction of the form {@code new
 * Subtask(aSplittableRandom.split()).fork()}.
 *
 * &lt;li&gt;This class provides additional methods for generating random
 * streams, that employ the above techniques when used in {@code
 * stream.parallel()} mode.&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Instances of {@code SplittableRandom} are not cryptographically
 * secure.  Consider instead using {@link java.security.SecureRandom}
 * in security-sensitive applications. Additionally,
 * default-constructed instances do not use a cryptographically random
 * seed unless the {@linkplain System#getProperty system property}
 * {@code java.util.secureRandomSeed} is set to {@code true}.
 *
 * @author  Guy Steele
 * @author  Doug Lea
 * @since   1.8
 */
public final class SplittableRandom {

    /*
     * Implementation Overview.
     *
     * This algorithm was inspired by the &quot;DotMix&quot; algorithm by
     * Leiserson, Schardl, and Sukha &quot;Deterministic Parallel
     * Random-Number Generation for Dynamic-Multithreading Platforms&quot;,
     * PPoPP 2012, as well as those in &quot;Parallel random numbers: as
     * easy as 1, 2, 3&quot; by Salmon, Morae, Dror, and Shaw, SC 2011.  It
     * differs mainly in simplifying and cheapening operations.
     *
     * The primary update step (method nextSeed()) is to add a
     * constant (&quot;gamma&quot;) to the current (64 bit) seed, forming a
     * simple sequence.  The seed and the gamma values for any two
     * SplittableRandom instances are highly likely to be different.
     *
     * Methods nextLong, nextInt, and derivatives do not return the
     * sequence (seed) values, but instead a hash-like bit-mix of
     * their bits, producing more independently distributed sequences.
     * For nextLong, the mix64 function is based on David Stafford's
     * (http://zimbry.blogspot.com/2011/09/better-bit-mixing-improving-on.html)
     * &quot;Mix13&quot; variant of the &quot;64-bit finalizer&quot; function in Austin
     * Appleby's MurmurHash3 algorithm (see
     * http://code.google.com/p/smhasher/wiki/MurmurHash3). The mix32
     * function is based on Stafford's Mix04 mix function, but returns
     * the upper 32 bits cast as int.
     *
     * The split operation uses the current generator to form the seed
     * and gamma for another SplittableRandom.  To conservatively
     * avoid potential correlations between seed and value generation,
     * gamma selection (method mixGamma) uses different
     * (Murmurhash3's) mix constants.  To avoid potential weaknesses
     * in bit-mixing transformations, we restrict gammas to odd values
     * with at least 24 0-1 or 1-0 bit transitions.  Rather than
     * rejecting candidates with too few or too many bits set, method
     * mixGamma flips some bits (which has the effect of mapping at
     * most 4 to any given gamma value).  This reduces the effective
     * set of 64bit odd gamma values by about 2%, and serves as an
     * automated screening for sequence constant selection that is
     * left as an empirical decision in some other hashing and crypto
     * algorithms.
     *
     * The resulting generator thus transforms a sequence in which
     * (typically) many bits change on each step, with an inexpensive
     * mixer with good (but less than cryptographically secure)
     * avalanching.
     *
     * The default (no-argument) constructor, in essence, invokes
     * split() for a common &quot;defaultGen&quot; SplittableRandom.  Unlike
     * other cases, this split must be performed in a thread-safe
     * manner, so we use an AtomicLong to represent the seed rather
     * than use an explicit SplittableRandom. To bootstrap the
     * defaultGen, we start off using a seed based on current time and
     * network interface address unless the java.util.secureRandomSeed
     * property is set. This serves as a slimmed-down (and insecure)
     * variant of SecureRandom that also avoids stalls that may occur
     * when using /dev/random.
     *
     * It is a relatively simple matter to apply the basic design here
     * to use 128 bit seeds. However, emulating 128bit arithmetic and
     * carrying around twice the state add more overhead than appears
     * warranted for current usages.
     *
     * File organization: First the non-public methods that constitute
     * the main algorithm, then the main public methods, followed by
     * some custom spliterator classes needed for stream methods.
     */

    /**
     * The golden ratio scaled to 64bits, used as the initial gamma
     * value for (unsplit) SplittableRandoms.
     */
    private static final long GOLDEN_GAMMA = 0x9e3779b97f4a7c15L;

    /**
     * The least non-zero value returned by nextDouble(). This value
     * is scaled by a random value of 53 bits to produce a result.
     */
    private static final double DOUBLE_UNIT = 0x1.0p-53; // 1.0 / (1L &lt;&lt; 53);

    /**
     * The seed. Updated only via method nextSeed.
     */
    private long seed;

    /**
     * The step value.
     */
    private final long gamma;

    /**
     * Internal constructor used by all others except default constructor.
     */
<span class="nc" id="L184">    private SplittableRandom(long seed, long gamma) {</span>
<span class="nc" id="L185">        this.seed = seed;</span>
<span class="nc" id="L186">        this.gamma = gamma;</span>
<span class="nc" id="L187">    }</span>

    /**
     * Computes Stafford variant 13 of 64bit mix function.
     */
    private static long mix64(long z) {
<span class="fc" id="L193">        z = (z ^ (z &gt;&gt;&gt; 30)) * 0xbf58476d1ce4e5b9L;</span>
<span class="fc" id="L194">        z = (z ^ (z &gt;&gt;&gt; 27)) * 0x94d049bb133111ebL;</span>
<span class="fc" id="L195">        return z ^ (z &gt;&gt;&gt; 31);</span>
    }

    /**
     * Returns the 32 high bits of Stafford variant 4 mix64 function as int.
     */
    private static int mix32(long z) {
<span class="nc" id="L202">        z = (z ^ (z &gt;&gt;&gt; 33)) * 0x62a9d9ed799705f5L;</span>
<span class="nc" id="L203">        return (int)(((z ^ (z &gt;&gt;&gt; 28)) * 0xcb24d0a5c88c35b3L) &gt;&gt;&gt; 32);</span>
    }

    /**
     * Returns the gamma value to use for a new split instance.
     */
    private static long mixGamma(long z) {
<span class="fc" id="L210">        z = (z ^ (z &gt;&gt;&gt; 33)) * 0xff51afd7ed558ccdL; // MurmurHash3 mix constants</span>
<span class="fc" id="L211">        z = (z ^ (z &gt;&gt;&gt; 33)) * 0xc4ceb9fe1a85ec53L;</span>
<span class="fc" id="L212">        z = (z ^ (z &gt;&gt;&gt; 33)) | 1L;                  // force to be odd</span>
<span class="fc" id="L213">        int n = Long.bitCount(z ^ (z &gt;&gt;&gt; 1));       // ensure enough transitions</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">        return (n &lt; 24) ? z ^ 0xaaaaaaaaaaaaaaaaL : z;</span>
    }

    /**
     * Adds gamma to seed.
     */
    private long nextSeed() {
<span class="nc" id="L221">        return seed += gamma;</span>
    }

    /**
     * The seed generator for default constructors.
     */
<span class="fc" id="L227">    private static final AtomicLong defaultGen = new AtomicLong(initialSeed());</span>

    private static long initialSeed() {
<span class="fc" id="L230">        String pp = java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetPropertyAction(
                        &quot;java.util.secureRandomSeed&quot;));
<span class="pc bpc" id="L233" title="3 of 4 branches missed.">        if (pp != null &amp;&amp; pp.equalsIgnoreCase(&quot;true&quot;)) {</span>
<span class="nc" id="L234">            byte[] seedBytes = java.security.SecureRandom.getSeed(8);</span>
<span class="nc" id="L235">            long s = (long)(seedBytes[0]) &amp; 0xffL;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            for (int i = 1; i &lt; 8; ++i)</span>
<span class="nc" id="L237">                s = (s &lt;&lt; 8) | ((long)(seedBytes[i]) &amp; 0xffL);</span>
<span class="nc" id="L238">            return s;</span>
        }
<span class="fc" id="L240">        long h = 0L;</span>
        try {
            Enumeration&lt;NetworkInterface&gt; ifcs =
<span class="fc" id="L243">                    NetworkInterface.getNetworkInterfaces();</span>
<span class="fc" id="L244">            boolean retry = false; // retry once if getHardwareAddress is null</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">            while (ifcs.hasMoreElements()) {</span>
<span class="fc" id="L246">                NetworkInterface ifc = ifcs.nextElement();</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">                if (!ifc.isVirtual()) { // skip fake addresses</span>
<span class="fc" id="L248">                    byte[] bs = ifc.getHardwareAddress();</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                    if (bs != null) {</span>
<span class="fc" id="L250">                        int n = bs.length;</span>
<span class="fc" id="L251">                        int m = Math.min(n &gt;&gt;&gt; 1, 4);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">                        for (int i = 0; i &lt; m; ++i)</span>
<span class="fc" id="L253">                            h = (h &lt;&lt; 16) ^ (bs[i] &lt;&lt; 8) ^ bs[n-1-i];</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">                        if (m &lt; 4)</span>
<span class="fc" id="L255">                            h = (h &lt;&lt; 8) ^ bs[n-1-m];</span>
<span class="fc" id="L256">                        h = mix64(h);</span>
<span class="fc" id="L257">                        break;</span>
                    }
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                    else if (!retry)</span>
<span class="fc" id="L260">                        retry = true;</span>
                    else
                        break;
                }
<span class="fc" id="L264">            }</span>
<span class="nc" id="L265">        } catch (Exception ignore) {</span>
<span class="fc" id="L266">        }</span>
<span class="fc" id="L267">        return (h ^ mix64(System.currentTimeMillis()) ^</span>
<span class="fc" id="L268">                mix64(System.nanoTime()));</span>
    }

    // IllegalArgumentException messages
    static final String BadBound = &quot;bound must be positive&quot;;
    static final String BadRange = &quot;bound must be greater than origin&quot;;
    static final String BadSize  = &quot;size must be non-negative&quot;;

    /*
     * Internal versions of nextX methods used by streams, as well as
     * the public nextX(origin, bound) methods.  These exist mainly to
     * avoid the need for multiple versions of stream spliterators
     * across the different exported forms of streams.
     */

    /**
     * The form of nextLong used by LongStream Spliterators.  If
     * origin is greater than bound, acts as unbounded form of
     * nextLong, else as bounded form.
     *
     * @param origin the least value, unless greater than bound
     * @param bound the upper bound (exclusive), must not equal origin
     * @return a pseudorandom value
     */
    final long internalNextLong(long origin, long bound) {
        /*
         * Four Cases:
         *
         * 1. If the arguments indicate unbounded form, act as
         * nextLong().
         *
         * 2. If the range is an exact power of two, apply the
         * associated bit mask.
         *
         * 3. If the range is positive, loop to avoid potential bias
         * when the implicit nextLong() bound (2&lt;sup&gt;64&lt;/sup&gt;) is not
         * evenly divisible by the range. The loop rejects candidates
         * computed from otherwise over-represented values.  The
         * expected number of iterations under an ideal generator
         * varies from 1 to 2, depending on the bound. The loop itself
         * takes an unlovable form. Because the first candidate is
         * already available, we need a break-in-the-middle
         * construction, which is concisely but cryptically performed
         * within the while-condition of a body-less for loop.
         *
         * 4. Otherwise, the range cannot be represented as a positive
         * long.  The loop repeatedly generates unbounded longs until
         * obtaining a candidate meeting constraints (with an expected
         * number of iterations of less than two).
         */

<span class="nc" id="L319">        long r = mix64(nextSeed());</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (origin &lt; bound) {</span>
<span class="nc" id="L321">            long n = bound - origin, m = n - 1;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if ((n &amp; m) == 0L)  // power of two</span>
<span class="nc" id="L323">                r = (r &amp; m) + origin;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">            else if (n &gt; 0L) {  // reject over-represented candidates</span>
<span class="nc" id="L325">                for (long u = r &gt;&gt;&gt; 1;            // ensure nonnegative</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                     u + m - (r = u % n) &lt; 0L;    // rejection check</span>
<span class="nc" id="L327">                     u = mix64(nextSeed()) &gt;&gt;&gt; 1) // retry</span>
                    ;
<span class="nc" id="L329">                r += origin;</span>
            }
            else {              // range not representable as long
<span class="nc bnc" id="L332" title="All 4 branches missed.">                while (r &lt; origin || r &gt;= bound)</span>
<span class="nc" id="L333">                    r = mix64(nextSeed());</span>
            }
        }
<span class="nc" id="L336">        return r;</span>
    }

    /**
     * The form of nextInt used by IntStream Spliterators.
     * Exactly the same as long version, except for types.
     *
     * @param origin the least value, unless greater than bound
     * @param bound the upper bound (exclusive), must not equal origin
     * @return a pseudorandom value
     */
    final int internalNextInt(int origin, int bound) {
<span class="nc" id="L348">        int r = mix32(nextSeed());</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (origin &lt; bound) {</span>
<span class="nc" id="L350">            int n = bound - origin, m = n - 1;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">            if ((n &amp; m) == 0)</span>
<span class="nc" id="L352">                r = (r &amp; m) + origin;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            else if (n &gt; 0) {</span>
<span class="nc" id="L354">                for (int u = r &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">                     u + m - (r = u % n) &lt; 0;</span>
<span class="nc" id="L356">                     u = mix32(nextSeed()) &gt;&gt;&gt; 1)</span>
                    ;
<span class="nc" id="L358">                r += origin;</span>
            }
            else {
<span class="nc bnc" id="L361" title="All 4 branches missed.">                while (r &lt; origin || r &gt;= bound)</span>
<span class="nc" id="L362">                    r = mix32(nextSeed());</span>
            }
        }
<span class="nc" id="L365">        return r;</span>
    }

    /**
     * The form of nextDouble used by DoubleStream Spliterators.
     *
     * @param origin the least value, unless greater than bound
     * @param bound the upper bound (exclusive), must not equal origin
     * @return a pseudorandom value
     */
    final double internalNextDouble(double origin, double bound) {
<span class="nc" id="L376">        double r = (nextLong() &gt;&gt;&gt; 11) * DOUBLE_UNIT;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (origin &lt; bound) {</span>
<span class="nc" id="L378">            r = r * (bound - origin) + origin;</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">            if (r &gt;= bound) // correct for rounding</span>
<span class="nc" id="L380">                r = Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1);</span>
        }
<span class="nc" id="L382">        return r;</span>
    }

    /* ---------------- public methods ---------------- */

    /**
     * Creates a new SplittableRandom instance using the specified
     * initial seed. SplittableRandom instances created with the same
     * seed in the same program generate identical sequences of values.
     *
     * @param seed the initial seed
     */
    public SplittableRandom(long seed) {
<span class="nc" id="L395">        this(seed, GOLDEN_GAMMA);</span>
<span class="nc" id="L396">    }</span>

    /**
     * Creates a new SplittableRandom instance that is likely to
     * generate sequences of values that are statistically independent
     * of those of any other instances in the current program; and
     * may, and typically does, vary across program invocations.
     */
<span class="fc" id="L404">    public SplittableRandom() { // emulate defaultGen.split()</span>
<span class="fc" id="L405">        long s = defaultGen.getAndAdd(2 * GOLDEN_GAMMA);</span>
<span class="fc" id="L406">        this.seed = mix64(s);</span>
<span class="fc" id="L407">        this.gamma = mixGamma(s + GOLDEN_GAMMA);</span>
<span class="fc" id="L408">    }</span>

    /**
     * Constructs and returns a new SplittableRandom instance that
     * shares no mutable state with this instance. However, with very
     * high probability, the set of values collectively generated by
     * the two objects has the same statistical properties as if the
     * same quantity of values were generated by a single thread using
     * a single SplittableRandom object.  Either or both of the two
     * objects may be further split using the {@code split()} method,
     * and the same expected statistical properties apply to the
     * entire set of generators constructed by such recursive
     * splitting.
     *
     * @return the new SplittableRandom instance
     */
    public SplittableRandom split() {
<span class="nc" id="L425">        return new SplittableRandom(nextLong(), mixGamma(nextSeed()));</span>
    }

    /**
     * Returns a pseudorandom {@code int} value.
     *
     * @return a pseudorandom {@code int} value
     */
    public int nextInt() {
<span class="nc" id="L434">        return mix32(nextSeed());</span>
    }

    /**
     * Returns a pseudorandom {@code int} value between zero (inclusive)
     * and the specified bound (exclusive).
     *
     * @param bound the upper bound (exclusive).  Must be positive.
     * @return a pseudorandom {@code int} value between zero
     *         (inclusive) and the bound (exclusive)
     * @throws IllegalArgumentException if {@code bound} is not positive
     */
    public int nextInt(int bound) {
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (bound &lt;= 0)</span>
<span class="nc" id="L448">            throw new IllegalArgumentException(BadBound);</span>
        // Specialize internalNextInt for origin 0
<span class="nc" id="L450">        int r = mix32(nextSeed());</span>
<span class="nc" id="L451">        int m = bound - 1;</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if ((bound &amp; m) == 0) // power of two</span>
<span class="nc" id="L453">            r &amp;= m;</span>
        else { // reject over-represented candidates
<span class="nc" id="L455">            for (int u = r &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                 u + m - (r = u % bound) &lt; 0;</span>
<span class="nc" id="L457">                 u = mix32(nextSeed()) &gt;&gt;&gt; 1)</span>
                ;
        }
<span class="nc" id="L460">        return r;</span>
    }

    /**
     * Returns a pseudorandom {@code int} value between the specified
     * origin (inclusive) and the specified bound (exclusive).
     *
     * @param origin the least value returned
     * @param bound the upper bound (exclusive)
     * @return a pseudorandom {@code int} value between the origin
     *         (inclusive) and the bound (exclusive)
     * @throws IllegalArgumentException if {@code origin} is greater than
     *         or equal to {@code bound}
     */
    public int nextInt(int origin, int bound) {
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (origin &gt;= bound)</span>
<span class="nc" id="L476">            throw new IllegalArgumentException(BadRange);</span>
<span class="nc" id="L477">        return internalNextInt(origin, bound);</span>
    }

    /**
     * Returns a pseudorandom {@code long} value.
     *
     * @return a pseudorandom {@code long} value
     */
    public long nextLong() {
<span class="nc" id="L486">        return mix64(nextSeed());</span>
    }

    /**
     * Returns a pseudorandom {@code long} value between zero (inclusive)
     * and the specified bound (exclusive).
     *
     * @param bound the upper bound (exclusive).  Must be positive.
     * @return a pseudorandom {@code long} value between zero
     *         (inclusive) and the bound (exclusive)
     * @throws IllegalArgumentException if {@code bound} is not positive
     */
    public long nextLong(long bound) {
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (bound &lt;= 0)</span>
<span class="nc" id="L500">            throw new IllegalArgumentException(BadBound);</span>
        // Specialize internalNextLong for origin 0
<span class="nc" id="L502">        long r = mix64(nextSeed());</span>
<span class="nc" id="L503">        long m = bound - 1;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if ((bound &amp; m) == 0L) // power of two</span>
<span class="nc" id="L505">            r &amp;= m;</span>
        else { // reject over-represented candidates
<span class="nc" id="L507">            for (long u = r &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                 u + m - (r = u % bound) &lt; 0L;</span>
<span class="nc" id="L509">                 u = mix64(nextSeed()) &gt;&gt;&gt; 1)</span>
                ;
        }
<span class="nc" id="L512">        return r;</span>
    }

    /**
     * Returns a pseudorandom {@code long} value between the specified
     * origin (inclusive) and the specified bound (exclusive).
     *
     * @param origin the least value returned
     * @param bound the upper bound (exclusive)
     * @return a pseudorandom {@code long} value between the origin
     *         (inclusive) and the bound (exclusive)
     * @throws IllegalArgumentException if {@code origin} is greater than
     *         or equal to {@code bound}
     */
    public long nextLong(long origin, long bound) {
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (origin &gt;= bound)</span>
<span class="nc" id="L528">            throw new IllegalArgumentException(BadRange);</span>
<span class="nc" id="L529">        return internalNextLong(origin, bound);</span>
    }

    /**
     * Returns a pseudorandom {@code double} value between zero
     * (inclusive) and one (exclusive).
     *
     * @return a pseudorandom {@code double} value between zero
     *         (inclusive) and one (exclusive)
     */
    public double nextDouble() {
<span class="nc" id="L540">        return (mix64(nextSeed()) &gt;&gt;&gt; 11) * DOUBLE_UNIT;</span>
    }

    /**
     * Returns a pseudorandom {@code double} value between 0.0
     * (inclusive) and the specified bound (exclusive).
     *
     * @param bound the upper bound (exclusive).  Must be positive.
     * @return a pseudorandom {@code double} value between zero
     *         (inclusive) and the bound (exclusive)
     * @throws IllegalArgumentException if {@code bound} is not positive
     */
    public double nextDouble(double bound) {
<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (!(bound &gt; 0.0))</span>
<span class="nc" id="L554">            throw new IllegalArgumentException(BadBound);</span>
<span class="nc" id="L555">        double result = (mix64(nextSeed()) &gt;&gt;&gt; 11) * DOUBLE_UNIT * bound;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        return (result &lt; bound) ?  result : // correct for rounding</span>
<span class="nc" id="L557">            Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1);</span>
    }

    /**
     * Returns a pseudorandom {@code double} value between the specified
     * origin (inclusive) and bound (exclusive).
     *
     * @param origin the least value returned
     * @param bound the upper bound (exclusive)
     * @return a pseudorandom {@code double} value between the origin
     *         (inclusive) and the bound (exclusive)
     * @throws IllegalArgumentException if {@code origin} is greater than
     *         or equal to {@code bound}
     */
    public double nextDouble(double origin, double bound) {
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (!(origin &lt; bound))</span>
<span class="nc" id="L573">            throw new IllegalArgumentException(BadRange);</span>
<span class="nc" id="L574">        return internalNextDouble(origin, bound);</span>
    }

    /**
     * Returns a pseudorandom {@code boolean} value.
     *
     * @return a pseudorandom {@code boolean} value
     */
    public boolean nextBoolean() {
<span class="nc bnc" id="L583" title="All 2 branches missed.">        return mix32(nextSeed()) &lt; 0;</span>
    }

    // stream methods, coded in a way intended to better isolate for
    // maintenance purposes the small differences across forms.

    /**
     * Returns a stream producing the given {@code streamSize} number
     * of pseudorandom {@code int} values from this generator and/or
     * one split from it.
     *
     * @param streamSize the number of values to generate
     * @return a stream of pseudorandom {@code int} values
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero
     */
    public IntStream ints(long streamSize) {
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L601">            throw new IllegalArgumentException(BadSize);</span>
<span class="fc" id="L602">        return StreamSupport.intStream</span>
<span class="fc" id="L603">            (new RandomIntsSpliterator</span>
             (this, 0L, streamSize, Integer.MAX_VALUE, 0),
             false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code int}
     * values from this generator and/or one split from it.
     *
     * @implNote This method is implemented to be equivalent to {@code
     * ints(Long.MAX_VALUE)}.
     *
     * @return a stream of pseudorandom {@code int} values
     */
    public IntStream ints() {
<span class="fc" id="L618">        return StreamSupport.intStream</span>
<span class="fc" id="L619">            (new RandomIntsSpliterator</span>
             (this, 0L, Long.MAX_VALUE, Integer.MAX_VALUE, 0),
             false);
    }

    /**
     * Returns a stream producing the given {@code streamSize} number
     * of pseudorandom {@code int} values from this generator and/or one split
     * from it; each value conforms to the given origin (inclusive) and bound
     * (exclusive).
     *
     * @param streamSize the number of values to generate
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code int} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero, or {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     */
    public IntStream ints(long streamSize, int randomNumberOrigin,
                          int randomNumberBound) {
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L642">            throw new IllegalArgumentException(BadSize);</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">        if (randomNumberOrigin &gt;= randomNumberBound)</span>
<span class="nc" id="L644">            throw new IllegalArgumentException(BadRange);</span>
<span class="fc" id="L645">        return StreamSupport.intStream</span>
<span class="fc" id="L646">            (new RandomIntsSpliterator</span>
             (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),
             false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code
     * int} values from this generator and/or one split from it; each value
     * conforms to the given origin (inclusive) and bound (exclusive).
     *
     * @implNote This method is implemented to be equivalent to {@code
     * ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
     *
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code int} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     */
    public IntStream ints(int randomNumberOrigin, int randomNumberBound) {
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        if (randomNumberOrigin &gt;= randomNumberBound)</span>
<span class="nc" id="L668">            throw new IllegalArgumentException(BadRange);</span>
<span class="fc" id="L669">        return StreamSupport.intStream</span>
<span class="fc" id="L670">            (new RandomIntsSpliterator</span>
             (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),
             false);
    }

    /**
     * Returns a stream producing the given {@code streamSize} number
     * of pseudorandom {@code long} values from this generator and/or
     * one split from it.
     *
     * @param streamSize the number of values to generate
     * @return a stream of pseudorandom {@code long} values
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero
     */
    public LongStream longs(long streamSize) {
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L687">            throw new IllegalArgumentException(BadSize);</span>
<span class="fc" id="L688">        return StreamSupport.longStream</span>
<span class="fc" id="L689">            (new RandomLongsSpliterator</span>
             (this, 0L, streamSize, Long.MAX_VALUE, 0L),
             false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code
     * long} values from this generator and/or one split from it.
     *
     * @implNote This method is implemented to be equivalent to {@code
     * longs(Long.MAX_VALUE)}.
     *
     * @return a stream of pseudorandom {@code long} values
     */
    public LongStream longs() {
<span class="fc" id="L704">        return StreamSupport.longStream</span>
<span class="fc" id="L705">            (new RandomLongsSpliterator</span>
             (this, 0L, Long.MAX_VALUE, Long.MAX_VALUE, 0L),
             false);
    }

    /**
     * Returns a stream producing the given {@code streamSize} number of
     * pseudorandom {@code long} values from this generator and/or one split
     * from it; each value conforms to the given origin (inclusive) and bound
     * (exclusive).
     *
     * @param streamSize the number of values to generate
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code long} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero, or {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     */
    public LongStream longs(long streamSize, long randomNumberOrigin,
                            long randomNumberBound) {
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L728">            throw new IllegalArgumentException(BadSize);</span>
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">        if (randomNumberOrigin &gt;= randomNumberBound)</span>
<span class="nc" id="L730">            throw new IllegalArgumentException(BadRange);</span>
<span class="fc" id="L731">        return StreamSupport.longStream</span>
<span class="fc" id="L732">            (new RandomLongsSpliterator</span>
             (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),
             false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code
     * long} values from this generator and/or one split from it; each value
     * conforms to the given origin (inclusive) and bound (exclusive).
     *
     * @implNote This method is implemented to be equivalent to {@code
     * longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
     *
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code long} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     */
    public LongStream longs(long randomNumberOrigin, long randomNumberBound) {
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">        if (randomNumberOrigin &gt;= randomNumberBound)</span>
<span class="nc" id="L754">            throw new IllegalArgumentException(BadRange);</span>
<span class="fc" id="L755">        return StreamSupport.longStream</span>
<span class="fc" id="L756">            (new RandomLongsSpliterator</span>
             (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),
             false);
    }

    /**
     * Returns a stream producing the given {@code streamSize} number of
     * pseudorandom {@code double} values from this generator and/or one split
     * from it; each value is between zero (inclusive) and one (exclusive).
     *
     * @param streamSize the number of values to generate
     * @return a stream of {@code double} values
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero
     */
    public DoubleStream doubles(long streamSize) {
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L773">            throw new IllegalArgumentException(BadSize);</span>
<span class="fc" id="L774">        return StreamSupport.doubleStream</span>
<span class="fc" id="L775">            (new RandomDoublesSpliterator</span>
             (this, 0L, streamSize, Double.MAX_VALUE, 0.0),
             false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code
     * double} values from this generator and/or one split from it; each value
     * is between zero (inclusive) and one (exclusive).
     *
     * @implNote This method is implemented to be equivalent to {@code
     * doubles(Long.MAX_VALUE)}.
     *
     * @return a stream of pseudorandom {@code double} values
     */
    public DoubleStream doubles() {
<span class="fc" id="L791">        return StreamSupport.doubleStream</span>
<span class="fc" id="L792">            (new RandomDoublesSpliterator</span>
             (this, 0L, Long.MAX_VALUE, Double.MAX_VALUE, 0.0),
             false);
    }

    /**
     * Returns a stream producing the given {@code streamSize} number of
     * pseudorandom {@code double} values from this generator and/or one split
     * from it; each value conforms to the given origin (inclusive) and bound
     * (exclusive).
     *
     * @param streamSize the number of values to generate
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code double} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code streamSize} is
     *         less than zero
     * @throws IllegalArgumentException if {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     */
    public DoubleStream doubles(long streamSize, double randomNumberOrigin,
                                double randomNumberBound) {
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">        if (streamSize &lt; 0L)</span>
<span class="nc" id="L816">            throw new IllegalArgumentException(BadSize);</span>
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">        if (!(randomNumberOrigin &lt; randomNumberBound))</span>
<span class="nc" id="L818">            throw new IllegalArgumentException(BadRange);</span>
<span class="fc" id="L819">        return StreamSupport.doubleStream</span>
<span class="fc" id="L820">            (new RandomDoublesSpliterator</span>
             (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),
             false);
    }

    /**
     * Returns an effectively unlimited stream of pseudorandom {@code
     * double} values from this generator and/or one split from it; each value
     * conforms to the given origin (inclusive) and bound (exclusive).
     *
     * @implNote This method is implemented to be equivalent to {@code
     * doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
     *
     * @param randomNumberOrigin the origin (inclusive) of each random value
     * @param randomNumberBound the bound (exclusive) of each random value
     * @return a stream of pseudorandom {@code double} values,
     *         each with the given origin (inclusive) and bound (exclusive)
     * @throws IllegalArgumentException if {@code randomNumberOrigin}
     *         is greater than or equal to {@code randomNumberBound}
     */
    public DoubleStream doubles(double randomNumberOrigin, double randomNumberBound) {
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">        if (!(randomNumberOrigin &lt; randomNumberBound))</span>
<span class="nc" id="L842">            throw new IllegalArgumentException(BadRange);</span>
<span class="fc" id="L843">        return StreamSupport.doubleStream</span>
<span class="fc" id="L844">            (new RandomDoublesSpliterator</span>
             (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),
             false);
    }

    /**
     * Spliterator for int streams.  We multiplex the four int
     * versions into one class by treating a bound less than origin as
     * unbounded, and also by treating &quot;infinite&quot; as equivalent to
     * Long.MAX_VALUE. For splits, it uses the standard divide-by-two
     * approach. The long and double versions of this class are
     * identical except for types.
     */
    static final class RandomIntsSpliterator implements Spliterator.OfInt {
        final SplittableRandom rng;
        long index;
        final long fence;
        final int origin;
        final int bound;
        RandomIntsSpliterator(SplittableRandom rng, long index, long fence,
<span class="fc" id="L864">                              int origin, int bound) {</span>
<span class="fc" id="L865">            this.rng = rng; this.index = index; this.fence = fence;</span>
<span class="fc" id="L866">            this.origin = origin; this.bound = bound;</span>
<span class="fc" id="L867">        }</span>

        public RandomIntsSpliterator trySplit() {
<span class="nc" id="L870">            long i = index, m = (i + fence) &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">            return (m &lt;= i) ? null :</span>
<span class="nc" id="L872">                new RandomIntsSpliterator(rng.split(), i, index = m, origin, bound);</span>
        }

        public long estimateSize() {
<span class="fc" id="L876">            return fence - index;</span>
        }

        public int characteristics() {
<span class="fc" id="L880">            return (Spliterator.SIZED | Spliterator.SUBSIZED |</span>
                    Spliterator.NONNULL | Spliterator.IMMUTABLE);
        }

        public boolean tryAdvance(IntConsumer consumer) {
<span class="nc bnc" id="L885" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L886">            long i = index, f = fence;</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L888">                consumer.accept(rng.internalNextInt(origin, bound));</span>
<span class="nc" id="L889">                index = i + 1;</span>
<span class="nc" id="L890">                return true;</span>
            }
<span class="nc" id="L892">            return false;</span>
        }

        public void forEachRemaining(IntConsumer consumer) {
<span class="nc bnc" id="L896" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L897">            long i = index, f = fence;</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L899">                index = f;</span>
<span class="nc" id="L900">                SplittableRandom r = rng;</span>
<span class="nc" id="L901">                int o = origin, b = bound;</span>
                do {
<span class="nc" id="L903">                    consumer.accept(r.internalNextInt(o, b));</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                } while (++i &lt; f);</span>
            }
<span class="nc" id="L906">        }</span>
    }

    /**
     * Spliterator for long streams.
     */
    static final class RandomLongsSpliterator implements Spliterator.OfLong {
        final SplittableRandom rng;
        long index;
        final long fence;
        final long origin;
        final long bound;
        RandomLongsSpliterator(SplittableRandom rng, long index, long fence,
<span class="fc" id="L919">                               long origin, long bound) {</span>
<span class="fc" id="L920">            this.rng = rng; this.index = index; this.fence = fence;</span>
<span class="fc" id="L921">            this.origin = origin; this.bound = bound;</span>
<span class="fc" id="L922">        }</span>

        public RandomLongsSpliterator trySplit() {
<span class="nc" id="L925">            long i = index, m = (i + fence) &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">            return (m &lt;= i) ? null :</span>
<span class="nc" id="L927">                new RandomLongsSpliterator(rng.split(), i, index = m, origin, bound);</span>
        }

        public long estimateSize() {
<span class="fc" id="L931">            return fence - index;</span>
        }

        public int characteristics() {
<span class="fc" id="L935">            return (Spliterator.SIZED | Spliterator.SUBSIZED |</span>
                    Spliterator.NONNULL | Spliterator.IMMUTABLE);
        }

        public boolean tryAdvance(LongConsumer consumer) {
<span class="nc bnc" id="L940" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L941">            long i = index, f = fence;</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L943">                consumer.accept(rng.internalNextLong(origin, bound));</span>
<span class="nc" id="L944">                index = i + 1;</span>
<span class="nc" id="L945">                return true;</span>
            }
<span class="nc" id="L947">            return false;</span>
        }

        public void forEachRemaining(LongConsumer consumer) {
<span class="nc bnc" id="L951" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L952">            long i = index, f = fence;</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L954">                index = f;</span>
<span class="nc" id="L955">                SplittableRandom r = rng;</span>
<span class="nc" id="L956">                long o = origin, b = bound;</span>
                do {
<span class="nc" id="L958">                    consumer.accept(r.internalNextLong(o, b));</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">                } while (++i &lt; f);</span>
            }
<span class="nc" id="L961">        }</span>

    }

    /**
     * Spliterator for double streams.
     */
    static final class RandomDoublesSpliterator implements Spliterator.OfDouble {
        final SplittableRandom rng;
        long index;
        final long fence;
        final double origin;
        final double bound;
        RandomDoublesSpliterator(SplittableRandom rng, long index, long fence,
<span class="fc" id="L975">                                 double origin, double bound) {</span>
<span class="fc" id="L976">            this.rng = rng; this.index = index; this.fence = fence;</span>
<span class="fc" id="L977">            this.origin = origin; this.bound = bound;</span>
<span class="fc" id="L978">        }</span>

        public RandomDoublesSpliterator trySplit() {
<span class="nc" id="L981">            long i = index, m = (i + fence) &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">            return (m &lt;= i) ? null :</span>
<span class="nc" id="L983">                new RandomDoublesSpliterator(rng.split(), i, index = m, origin, bound);</span>
        }

        public long estimateSize() {
<span class="fc" id="L987">            return fence - index;</span>
        }

        public int characteristics() {
<span class="fc" id="L991">            return (Spliterator.SIZED | Spliterator.SUBSIZED |</span>
                    Spliterator.NONNULL | Spliterator.IMMUTABLE);
        }

        public boolean tryAdvance(DoubleConsumer consumer) {
<span class="nc bnc" id="L996" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L997">            long i = index, f = fence;</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L999">                consumer.accept(rng.internalNextDouble(origin, bound));</span>
<span class="nc" id="L1000">                index = i + 1;</span>
<span class="nc" id="L1001">                return true;</span>
            }
<span class="nc" id="L1003">            return false;</span>
        }

        public void forEachRemaining(DoubleConsumer consumer) {
<span class="nc bnc" id="L1007" title="All 2 branches missed.">            if (consumer == null) throw new NullPointerException();</span>
<span class="nc" id="L1008">            long i = index, f = fence;</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            if (i &lt; f) {</span>
<span class="nc" id="L1010">                index = f;</span>
<span class="nc" id="L1011">                SplittableRandom r = rng;</span>
<span class="nc" id="L1012">                double o = origin, b = bound;</span>
                do {
<span class="nc" id="L1014">                    consumer.accept(r.internalNextDouble(o, b));</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">                } while (++i &lt; f);</span>
            }
<span class="nc" id="L1017">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>