<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Timer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">Timer.java</span></div><h1>Timer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;
import java.util.Date;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * A facility for threads to schedule tasks for future execution in a
 * background thread.  Tasks may be scheduled for one-time execution, or for
 * repeated execution at regular intervals.
 *
 * &lt;p&gt;Corresponding to each &lt;tt&gt;Timer&lt;/tt&gt; object is a single background
 * thread that is used to execute all of the timer's tasks, sequentially.
 * Timer tasks should complete quickly.  If a timer task takes excessive time
 * to complete, it &quot;hogs&quot; the timer's task execution thread.  This can, in
 * turn, delay the execution of subsequent tasks, which may &quot;bunch up&quot; and
 * execute in rapid succession when (and if) the offending task finally
 * completes.
 *
 * &lt;p&gt;After the last live reference to a &lt;tt&gt;Timer&lt;/tt&gt; object goes away
 * &lt;i&gt;and&lt;/i&gt; all outstanding tasks have completed execution, the timer's task
 * execution thread terminates gracefully (and becomes subject to garbage
 * collection).  However, this can take arbitrarily long to occur.  By
 * default, the task execution thread does not run as a &lt;i&gt;daemon thread&lt;/i&gt;,
 * so it is capable of keeping an application from terminating.  If a caller
 * wants to terminate a timer's task execution thread rapidly, the caller
 * should invoke the timer's &lt;tt&gt;cancel&lt;/tt&gt; method.
 *
 * &lt;p&gt;If the timer's task execution thread terminates unexpectedly, for
 * example, because its &lt;tt&gt;stop&lt;/tt&gt; method is invoked, any further
 * attempt to schedule a task on the timer will result in an
 * &lt;tt&gt;IllegalStateException&lt;/tt&gt;, as if the timer's &lt;tt&gt;cancel&lt;/tt&gt;
 * method had been invoked.
 *
 * &lt;p&gt;This class is thread-safe: multiple threads can share a single
 * &lt;tt&gt;Timer&lt;/tt&gt; object without the need for external synchronization.
 *
 * &lt;p&gt;This class does &lt;i&gt;not&lt;/i&gt; offer real-time guarantees: it schedules
 * tasks using the &lt;tt&gt;Object.wait(long)&lt;/tt&gt; method.
 *
 * &lt;p&gt;Java 5.0 introduced the {@code java.util.concurrent} package and
 * one of the concurrency utilities therein is the {@link
 * java.util.concurrent.ScheduledThreadPoolExecutor
 * ScheduledThreadPoolExecutor} which is a thread pool for repeatedly
 * executing tasks at a given rate or delay.  It is effectively a more
 * versatile replacement for the {@code Timer}/{@code TimerTask}
 * combination, as it allows multiple service threads, accepts various
 * time units, and doesn't require subclassing {@code TimerTask} (just
 * implement {@code Runnable}).  Configuring {@code
 * ScheduledThreadPoolExecutor} with one thread makes it equivalent to
 * {@code Timer}.
 *
 * &lt;p&gt;Implementation note: This class scales to large numbers of concurrently
 * scheduled tasks (thousands should present no problem).  Internally,
 * it uses a binary heap to represent its task queue, so the cost to schedule
 * a task is O(log n), where n is the number of concurrently scheduled tasks.
 *
 * &lt;p&gt;Implementation note: All constructors start a timer thread.
 *
 * @author  Josh Bloch
 * @see     TimerTask
 * @see     Object#wait(long)
 * @since   1.3
 */

public class Timer {
    /**
     * The timer task queue.  This data structure is shared with the timer
     * thread.  The timer produces tasks, via its various schedule calls,
     * and the timer thread consumes, executing timer tasks as appropriate,
     * and removing them from the queue when they're obsolete.
     */
<span class="pc" id="L96">    private final TaskQueue queue = new TaskQueue();</span>

    /**
     * The timer thread.
     */
<span class="pc" id="L101">    private final TimerThread thread = new TimerThread(queue);</span>

    /**
     * This object causes the timer's task execution thread to exit
     * gracefully when there are no live references to the Timer object and no
     * tasks in the timer queue.  It is used in preference to a finalizer on
     * Timer as such a finalizer would be susceptible to a subclass's
     * finalizer forgetting to call it.
     */
<span class="pc" id="L110">    private final Object threadReaper = new Object() {</span>
        protected void finalize() throws Throwable {
<span class="fc" id="L112">            synchronized(queue) {</span>
<span class="fc" id="L113">                thread.newTasksMayBeScheduled = false;</span>
<span class="fc" id="L114">                queue.notify(); // In case queue is empty.</span>
<span class="pc" id="L115">            }</span>
<span class="fc" id="L116">        }</span>
    };

    /**
     * This ID is used to generate thread names.
     */
<span class="fc" id="L122">    private final static AtomicInteger nextSerialNumber = new AtomicInteger(0);</span>
    private static int serialNumber() {
<span class="fc" id="L124">        return nextSerialNumber.getAndIncrement();</span>
    }

    /**
     * Creates a new timer.  The associated thread does &lt;i&gt;not&lt;/i&gt;
     * {@linkplain Thread#setDaemon run as a daemon}.
     */
    public Timer() {
<span class="nc" id="L132">        this(&quot;Timer-&quot; + serialNumber());</span>
<span class="nc" id="L133">    }</span>

    /**
     * Creates a new timer whose associated thread may be specified to
     * {@linkplain Thread#setDaemon run as a daemon}.
     * A daemon thread is called for if the timer will be used to
     * schedule repeating &quot;maintenance activities&quot;, which must be
     * performed as long as the application is running, but should not
     * prolong the lifetime of the application.
     *
     * @param isDaemon true if the associated thread should run as a daemon.
     */
    public Timer(boolean isDaemon) {
<span class="fc" id="L146">        this(&quot;Timer-&quot; + serialNumber(), isDaemon);</span>
<span class="fc" id="L147">    }</span>

    /**
     * Creates a new timer whose associated thread has the specified name.
     * The associated thread does &lt;i&gt;not&lt;/i&gt;
     * {@linkplain Thread#setDaemon run as a daemon}.
     *
     * @param name the name of the associated thread
     * @throws NullPointerException if {@code name} is null
     * @since 1.5
     */
<span class="nc" id="L158">    public Timer(String name) {</span>
<span class="nc" id="L159">        thread.setName(name);</span>
<span class="nc" id="L160">        thread.start();</span>
<span class="nc" id="L161">    }</span>

    /**
     * Creates a new timer whose associated thread has the specified name,
     * and may be specified to
     * {@linkplain Thread#setDaemon run as a daemon}.
     *
     * @param name the name of the associated thread
     * @param isDaemon true if the associated thread should run as a daemon
     * @throws NullPointerException if {@code name} is null
     * @since 1.5
     */
<span class="fc" id="L173">    public Timer(String name, boolean isDaemon) {</span>
<span class="fc" id="L174">        thread.setName(name);</span>
<span class="fc" id="L175">        thread.setDaemon(isDaemon);</span>
<span class="fc" id="L176">        thread.start();</span>
<span class="fc" id="L177">    }</span>

    /**
     * Schedules the specified task for execution after the specified delay.
     *
     * @param task  task to be scheduled.
     * @param delay delay in milliseconds before task is to be executed.
     * @throws IllegalArgumentException if &lt;tt&gt;delay&lt;/tt&gt; is negative, or
     *         &lt;tt&gt;delay + System.currentTimeMillis()&lt;/tt&gt; is negative.
     * @throws IllegalStateException if task was already scheduled or
     *         cancelled, timer was cancelled, or timer thread terminated.
     * @throws NullPointerException if {@code task} is null
     */
    public void schedule(TimerTask task, long delay) {
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (delay &lt; 0)</span>
<span class="nc" id="L192">            throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span>
<span class="nc" id="L193">        sched(task, System.currentTimeMillis()+delay, 0);</span>
<span class="nc" id="L194">    }</span>

    /**
     * Schedules the specified task for execution at the specified time.  If
     * the time is in the past, the task is scheduled for immediate execution.
     *
     * @param task task to be scheduled.
     * @param time time at which task is to be executed.
     * @throws IllegalArgumentException if &lt;tt&gt;time.getTime()&lt;/tt&gt; is negative.
     * @throws IllegalStateException if task was already scheduled or
     *         cancelled, timer was cancelled, or timer thread terminated.
     * @throws NullPointerException if {@code task} or {@code time} is null
     */
    public void schedule(TimerTask task, Date time) {
<span class="nc" id="L208">        sched(task, time.getTime(), 0);</span>
<span class="nc" id="L209">    }</span>

    /**
     * Schedules the specified task for repeated &lt;i&gt;fixed-delay execution&lt;/i&gt;,
     * beginning after the specified delay.  Subsequent executions take place
     * at approximately regular intervals separated by the specified period.
     *
     * &lt;p&gt;In fixed-delay execution, each execution is scheduled relative to
     * the actual execution time of the previous execution.  If an execution
     * is delayed for any reason (such as garbage collection or other
     * background activity), subsequent executions will be delayed as well.
     * In the long run, the frequency of execution will generally be slightly
     * lower than the reciprocal of the specified period (assuming the system
     * clock underlying &lt;tt&gt;Object.wait(long)&lt;/tt&gt; is accurate).
     *
     * &lt;p&gt;Fixed-delay execution is appropriate for recurring activities
     * that require &quot;smoothness.&quot;  In other words, it is appropriate for
     * activities where it is more important to keep the frequency accurate
     * in the short run than in the long run.  This includes most animation
     * tasks, such as blinking a cursor at regular intervals.  It also includes
     * tasks wherein regular activity is performed in response to human
     * input, such as automatically repeating a character as long as a key
     * is held down.
     *
     * @param task   task to be scheduled.
     * @param delay  delay in milliseconds before task is to be executed.
     * @param period time in milliseconds between successive task executions.
     * @throws IllegalArgumentException if {@code delay &lt; 0}, or
     *         {@code delay + System.currentTimeMillis() &lt; 0}, or
     *         {@code period &lt;= 0}
     * @throws IllegalStateException if task was already scheduled or
     *         cancelled, timer was cancelled, or timer thread terminated.
     * @throws NullPointerException if {@code task} is null
     */
    public void schedule(TimerTask task, long delay, long period) {
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (delay &lt; 0)</span>
<span class="nc" id="L245">            throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        if (period &lt;= 0)</span>
<span class="nc" id="L247">            throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span>
<span class="fc" id="L248">        sched(task, System.currentTimeMillis()+delay, -period);</span>
<span class="fc" id="L249">    }</span>

    /**
     * Schedules the specified task for repeated &lt;i&gt;fixed-delay execution&lt;/i&gt;,
     * beginning at the specified time. Subsequent executions take place at
     * approximately regular intervals, separated by the specified period.
     *
     * &lt;p&gt;In fixed-delay execution, each execution is scheduled relative to
     * the actual execution time of the previous execution.  If an execution
     * is delayed for any reason (such as garbage collection or other
     * background activity), subsequent executions will be delayed as well.
     * In the long run, the frequency of execution will generally be slightly
     * lower than the reciprocal of the specified period (assuming the system
     * clock underlying &lt;tt&gt;Object.wait(long)&lt;/tt&gt; is accurate).  As a
     * consequence of the above, if the scheduled first time is in the past,
     * it is scheduled for immediate execution.
     *
     * &lt;p&gt;Fixed-delay execution is appropriate for recurring activities
     * that require &quot;smoothness.&quot;  In other words, it is appropriate for
     * activities where it is more important to keep the frequency accurate
     * in the short run than in the long run.  This includes most animation
     * tasks, such as blinking a cursor at regular intervals.  It also includes
     * tasks wherein regular activity is performed in response to human
     * input, such as automatically repeating a character as long as a key
     * is held down.
     *
     * @param task   task to be scheduled.
     * @param firstTime First time at which task is to be executed.
     * @param period time in milliseconds between successive task executions.
     * @throws IllegalArgumentException if {@code firstTime.getTime() &lt; 0}, or
     *         {@code period &lt;= 0}
     * @throws IllegalStateException if task was already scheduled or
     *         cancelled, timer was cancelled, or timer thread terminated.
     * @throws NullPointerException if {@code task} or {@code firstTime} is null
     */
    public void schedule(TimerTask task, Date firstTime, long period) {
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (period &lt;= 0)</span>
<span class="nc" id="L286">            throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span>
<span class="nc" id="L287">        sched(task, firstTime.getTime(), -period);</span>
<span class="nc" id="L288">    }</span>

    /**
     * Schedules the specified task for repeated &lt;i&gt;fixed-rate execution&lt;/i&gt;,
     * beginning after the specified delay.  Subsequent executions take place
     * at approximately regular intervals, separated by the specified period.
     *
     * &lt;p&gt;In fixed-rate execution, each execution is scheduled relative to the
     * scheduled execution time of the initial execution.  If an execution is
     * delayed for any reason (such as garbage collection or other background
     * activity), two or more executions will occur in rapid succession to
     * &quot;catch up.&quot;  In the long run, the frequency of execution will be
     * exactly the reciprocal of the specified period (assuming the system
     * clock underlying &lt;tt&gt;Object.wait(long)&lt;/tt&gt; is accurate).
     *
     * &lt;p&gt;Fixed-rate execution is appropriate for recurring activities that
     * are sensitive to &lt;i&gt;absolute&lt;/i&gt; time, such as ringing a chime every
     * hour on the hour, or running scheduled maintenance every day at a
     * particular time.  It is also appropriate for recurring activities
     * where the total time to perform a fixed number of executions is
     * important, such as a countdown timer that ticks once every second for
     * ten seconds.  Finally, fixed-rate execution is appropriate for
     * scheduling multiple repeating timer tasks that must remain synchronized
     * with respect to one another.
     *
     * @param task   task to be scheduled.
     * @param delay  delay in milliseconds before task is to be executed.
     * @param period time in milliseconds between successive task executions.
     * @throws IllegalArgumentException if {@code delay &lt; 0}, or
     *         {@code delay + System.currentTimeMillis() &lt; 0}, or
     *         {@code period &lt;= 0}
     * @throws IllegalStateException if task was already scheduled or
     *         cancelled, timer was cancelled, or timer thread terminated.
     * @throws NullPointerException if {@code task} is null
     */
    public void scheduleAtFixedRate(TimerTask task, long delay, long period) {
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (delay &lt; 0)</span>
<span class="nc" id="L325">            throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (period &lt;= 0)</span>
<span class="nc" id="L327">            throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span>
<span class="nc" id="L328">        sched(task, System.currentTimeMillis()+delay, period);</span>
<span class="nc" id="L329">    }</span>

    /**
     * Schedules the specified task for repeated &lt;i&gt;fixed-rate execution&lt;/i&gt;,
     * beginning at the specified time. Subsequent executions take place at
     * approximately regular intervals, separated by the specified period.
     *
     * &lt;p&gt;In fixed-rate execution, each execution is scheduled relative to the
     * scheduled execution time of the initial execution.  If an execution is
     * delayed for any reason (such as garbage collection or other background
     * activity), two or more executions will occur in rapid succession to
     * &quot;catch up.&quot;  In the long run, the frequency of execution will be
     * exactly the reciprocal of the specified period (assuming the system
     * clock underlying &lt;tt&gt;Object.wait(long)&lt;/tt&gt; is accurate).  As a
     * consequence of the above, if the scheduled first time is in the past,
     * then any &quot;missed&quot; executions will be scheduled for immediate &quot;catch up&quot;
     * execution.
     *
     * &lt;p&gt;Fixed-rate execution is appropriate for recurring activities that
     * are sensitive to &lt;i&gt;absolute&lt;/i&gt; time, such as ringing a chime every
     * hour on the hour, or running scheduled maintenance every day at a
     * particular time.  It is also appropriate for recurring activities
     * where the total time to perform a fixed number of executions is
     * important, such as a countdown timer that ticks once every second for
     * ten seconds.  Finally, fixed-rate execution is appropriate for
     * scheduling multiple repeating timer tasks that must remain synchronized
     * with respect to one another.
     *
     * @param task   task to be scheduled.
     * @param firstTime First time at which task is to be executed.
     * @param period time in milliseconds between successive task executions.
     * @throws IllegalArgumentException if {@code firstTime.getTime() &lt; 0} or
     *         {@code period &lt;= 0}
     * @throws IllegalStateException if task was already scheduled or
     *         cancelled, timer was cancelled, or timer thread terminated.
     * @throws NullPointerException if {@code task} or {@code firstTime} is null
     */
    public void scheduleAtFixedRate(TimerTask task, Date firstTime,
                                    long period) {
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (period &lt;= 0)</span>
<span class="nc" id="L369">            throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span>
<span class="nc" id="L370">        sched(task, firstTime.getTime(), period);</span>
<span class="nc" id="L371">    }</span>

    /**
     * Schedule the specified timer task for execution at the specified
     * time with the specified period, in milliseconds.  If period is
     * positive, the task is scheduled for repeated execution; if period is
     * zero, the task is scheduled for one-time execution. Time is specified
     * in Date.getTime() format.  This method checks timer state, task state,
     * and initial execution time, but not period.
     *
     * @throws IllegalArgumentException if &lt;tt&gt;time&lt;/tt&gt; is negative.
     * @throws IllegalStateException if task was already scheduled or
     *         cancelled, timer was cancelled, or timer thread terminated.
     * @throws NullPointerException if {@code task} is null
     */
    private void sched(TimerTask task, long time, long period) {
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (time &lt; 0)</span>
<span class="nc" id="L388">            throw new IllegalArgumentException(&quot;Illegal execution time.&quot;);</span>

        // Constrain value of period sufficiently to prevent numeric
        // overflow while still being effectively infinitely large.
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1))</span>
<span class="nc" id="L393">            period &gt;&gt;= 1;</span>

<span class="fc" id="L395">        synchronized(queue) {</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">            if (!thread.newTasksMayBeScheduled)</span>
<span class="nc" id="L397">                throw new IllegalStateException(&quot;Timer already cancelled.&quot;);</span>

<span class="fc" id="L399">            synchronized(task.lock) {</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">                if (task.state != TimerTask.VIRGIN)</span>
<span class="nc" id="L401">                    throw new IllegalStateException(</span>
                        &quot;Task already scheduled or cancelled&quot;);
<span class="fc" id="L403">                task.nextExecutionTime = time;</span>
<span class="fc" id="L404">                task.period = period;</span>
<span class="fc" id="L405">                task.state = TimerTask.SCHEDULED;</span>
<span class="pc" id="L406">            }</span>

<span class="fc" id="L408">            queue.add(task);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">            if (queue.getMin() == task)</span>
<span class="fc" id="L410">                queue.notify();</span>
<span class="pc" id="L411">        }</span>
<span class="fc" id="L412">    }</span>

    /**
     * Terminates this timer, discarding any currently scheduled tasks.
     * Does not interfere with a currently executing task (if it exists).
     * Once a timer has been terminated, its execution thread terminates
     * gracefully, and no more tasks may be scheduled on it.
     *
     * &lt;p&gt;Note that calling this method from within the run method of a
     * timer task that was invoked by this timer absolutely guarantees that
     * the ongoing task execution is the last task execution that will ever
     * be performed by this timer.
     *
     * &lt;p&gt;This method may be called repeatedly; the second and subsequent
     * calls have no effect.
     */
    public void cancel() {
<span class="fc" id="L429">        synchronized(queue) {</span>
<span class="fc" id="L430">            thread.newTasksMayBeScheduled = false;</span>
<span class="fc" id="L431">            queue.clear();</span>
<span class="fc" id="L432">            queue.notify();  // In case queue was already empty.</span>
<span class="pc" id="L433">        }</span>
<span class="fc" id="L434">    }</span>

    /**
     * Removes all cancelled tasks from this timer's task queue.  &lt;i&gt;Calling
     * this method has no effect on the behavior of the timer&lt;/i&gt;, but
     * eliminates the references to the cancelled tasks from the queue.
     * If there are no external references to these tasks, they become
     * eligible for garbage collection.
     *
     * &lt;p&gt;Most programs will have no need to call this method.
     * It is designed for use by the rare application that cancels a large
     * number of tasks.  Calling this method trades time for space: the
     * runtime of the method may be proportional to n + c log n, where n
     * is the number of tasks in the queue and c is the number of cancelled
     * tasks.
     *
     * &lt;p&gt;Note that it is permissible to call this method from within a
     * a task scheduled on this timer.
     *
     * @return the number of tasks removed from the queue.
     * @since 1.5
     */
     public int purge() {
<span class="nc" id="L457">         int result = 0;</span>

<span class="nc" id="L459">         synchronized(queue) {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">             for (int i = queue.size(); i &gt; 0; i--) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                 if (queue.get(i).state == TimerTask.CANCELLED) {</span>
<span class="nc" id="L462">                     queue.quickRemove(i);</span>
<span class="nc" id="L463">                     result++;</span>
                 }
             }

<span class="nc bnc" id="L467" title="All 2 branches missed.">             if (result != 0)</span>
<span class="nc" id="L468">                 queue.heapify();</span>
<span class="nc" id="L469">         }</span>

<span class="nc" id="L471">         return result;</span>
     }
}

/**
 * This &quot;helper class&quot; implements the timer's task execution thread, which
 * waits for tasks on the timer queue, executions them when they fire,
 * reschedules repeating tasks, and removes cancelled tasks and spent
 * non-repeating tasks from the queue.
 */
class TimerThread extends Thread {
    /**
     * This flag is set to false by the reaper to inform us that there
     * are no more live references to our Timer object.  Once this flag
     * is true and there are no more tasks in our queue, there is no
     * work left for us to do, so we terminate gracefully.  Note that
     * this field is protected by queue's monitor!
     */
<span class="fc" id="L489">    boolean newTasksMayBeScheduled = true;</span>

    /**
     * Our Timer's queue.  We store this reference in preference to
     * a reference to the Timer so the reference graph remains acyclic.
     * Otherwise, the Timer would never be garbage-collected and this
     * thread would never go away.
     */
    private TaskQueue queue;

<span class="fc" id="L499">    TimerThread(TaskQueue queue) {</span>
<span class="fc" id="L500">        this.queue = queue;</span>
<span class="fc" id="L501">    }</span>

    public void run() {
        try {
<span class="fc" id="L505">            mainLoop();</span>
        } finally {
            // Someone killed this Thread, behave as if Timer cancelled
<span class="pc" id="L508">            synchronized(queue) {</span>
<span class="pc" id="L509">                newTasksMayBeScheduled = false;</span>
<span class="pc" id="L510">                queue.clear();  // Eliminate obsolete references</span>
<span class="pc" id="L511">            }</span>
<span class="fc" id="L512">        }</span>
<span class="fc" id="L513">    }</span>

    /**
     * The main timer loop.  (See class comment.)
     */
    private void mainLoop() {
        while (true) {
            try {
                TimerTask task;
                boolean taskFired;
<span class="fc" id="L523">                synchronized(queue) {</span>
                    // Wait for queue to become non-empty
<span class="fc bfc" id="L525" title="All 4 branches covered.">                    while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span>
<span class="fc" id="L526">                        queue.wait();</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                    if (queue.isEmpty())</span>
<span class="fc" id="L528">                        break; // Queue is empty and will forever remain; die</span>

                    // Queue nonempty; look at first evt and do the right thing
                    long currentTime, executionTime;
<span class="fc" id="L532">                    task = queue.getMin();</span>
<span class="fc" id="L533">                    synchronized(task.lock) {</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">                        if (task.state == TimerTask.CANCELLED) {</span>
<span class="nc" id="L535">                            queue.removeMin();</span>
<span class="nc" id="L536">                            continue;  // No action required, poll queue again</span>
                        }
<span class="fc" id="L538">                        currentTime = System.currentTimeMillis();</span>
<span class="fc" id="L539">                        executionTime = task.nextExecutionTime;</span>
<span class="fc bfc" id="L540" title="All 4 branches covered.">                        if (taskFired = (executionTime&lt;=currentTime)) {</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">                            if (task.period == 0) { // Non-repeating, remove</span>
<span class="nc" id="L542">                                queue.removeMin();</span>
<span class="nc" id="L543">                                task.state = TimerTask.EXECUTED;</span>
                            } else { // Repeating task, reschedule
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">                                queue.rescheduleMin(</span>
                                  task.period&lt;0 ? currentTime   - task.period
                                                : executionTime + task.period);
                            }
                        }
<span class="pc" id="L550">                    }</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">                    if (!taskFired) // Task hasn't yet fired; wait</span>
<span class="fc" id="L552">                        queue.wait(executionTime - currentTime);</span>
<span class="pc" id="L553">                }</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">                if (taskFired)  // Task fired; run it, holding no locks</span>
<span class="fc" id="L555">                    task.run();</span>
<span class="nc" id="L556">            } catch(InterruptedException e) {</span>
<span class="pc" id="L557">            }</span>
        }
<span class="fc" id="L559">    }</span>
}

/**
 * This class represents a timer task queue: a priority queue of TimerTasks,
 * ordered on nextExecutionTime.  Each Timer object has one of these, which it
 * shares with its TimerThread.  Internally this class uses a heap, which
 * offers log(n) performance for the add, removeMin and rescheduleMin
 * operations, and constant time performance for the getMin operation.
 */
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">class TaskQueue {</span>
    /**
     * Priority queue represented as a balanced binary heap: the two children
     * of queue[n] are queue[2*n] and queue[2*n+1].  The priority queue is
     * ordered on the nextExecutionTime field: The TimerTask with the lowest
     * nextExecutionTime is in queue[1] (assuming the queue is nonempty).  For
     * each node n in the heap, and each descendant of n, d,
     * n.nextExecutionTime &lt;= d.nextExecutionTime.
     */
<span class="fc" id="L578">    private TimerTask[] queue = new TimerTask[128];</span>

    /**
     * The number of tasks in the priority queue.  (The tasks are stored in
     * queue[1] up to queue[size]).
     */
<span class="fc" id="L584">    private int size = 0;</span>

    /**
     * Returns the number of tasks currently on the queue.
     */
    int size() {
<span class="nc" id="L590">        return size;</span>
    }

    /**
     * Adds a new task to the priority queue.
     */
    void add(TimerTask task) {
        // Grow backing store if necessary
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">        if (size + 1 == queue.length)</span>
<span class="nc" id="L599">            queue = Arrays.copyOf(queue, 2*queue.length);</span>

<span class="fc" id="L601">        queue[++size] = task;</span>
<span class="fc" id="L602">        fixUp(size);</span>
<span class="fc" id="L603">    }</span>

    /**
     * Return the &quot;head task&quot; of the priority queue.  (The head task is an
     * task with the lowest nextExecutionTime.)
     */
    TimerTask getMin() {
<span class="fc" id="L610">        return queue[1];</span>
    }

    /**
     * Return the ith task in the priority queue, where i ranges from 1 (the
     * head task, which is returned by getMin) to the number of tasks on the
     * queue, inclusive.
     */
    TimerTask get(int i) {
<span class="nc" id="L619">        return queue[i];</span>
    }

    /**
     * Remove the head task from the priority queue.
     */
    void removeMin() {
<span class="nc" id="L626">        queue[1] = queue[size];</span>
<span class="nc" id="L627">        queue[size--] = null;  // Drop extra reference to prevent memory leak</span>
<span class="nc" id="L628">        fixDown(1);</span>
<span class="nc" id="L629">    }</span>

    /**
     * Removes the ith element from queue without regard for maintaining
     * the heap invariant.  Recall that queue is one-based, so
     * 1 &lt;= i &lt;= size.
     */
    void quickRemove(int i) {
<span class="nc bnc" id="L637" title="All 4 branches missed.">        assert i &lt;= size;</span>

<span class="nc" id="L639">        queue[i] = queue[size];</span>
<span class="nc" id="L640">        queue[size--] = null;  // Drop extra ref to prevent memory leak</span>
<span class="nc" id="L641">    }</span>

    /**
     * Sets the nextExecutionTime associated with the head task to the
     * specified value, and adjusts priority queue accordingly.
     */
    void rescheduleMin(long newTime) {
<span class="fc" id="L648">        queue[1].nextExecutionTime = newTime;</span>
<span class="fc" id="L649">        fixDown(1);</span>
<span class="fc" id="L650">    }</span>

    /**
     * Returns true if the priority queue contains no elements.
     */
    boolean isEmpty() {
<span class="fc bfc" id="L656" title="All 2 branches covered.">        return size==0;</span>
    }

    /**
     * Removes all elements from the priority queue.
     */
    void clear() {
        // Null out task references to prevent memory leak
<span class="fc bfc" id="L664" title="All 2 branches covered.">        for (int i=1; i&lt;=size; i++)</span>
<span class="fc" id="L665">            queue[i] = null;</span>

<span class="fc" id="L667">        size = 0;</span>
<span class="fc" id="L668">    }</span>

    /**
     * Establishes the heap invariant (described above) assuming the heap
     * satisfies the invariant except possibly for the leaf-node indexed by k
     * (which may have a nextExecutionTime less than its parent's).
     *
     * This method functions by &quot;promoting&quot; queue[k] up the hierarchy
     * (by swapping it with its parent) repeatedly until queue[k]'s
     * nextExecutionTime is greater than or equal to that of its parent.
     */
    private void fixUp(int k) {
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">        while (k &gt; 1) {</span>
<span class="nc" id="L681">            int j = k &gt;&gt; 1;</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">            if (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime)</span>
<span class="nc" id="L683">                break;</span>
<span class="nc" id="L684">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</span>
<span class="nc" id="L685">            k = j;</span>
<span class="nc" id="L686">        }</span>
<span class="fc" id="L687">    }</span>

    /**
     * Establishes the heap invariant (described above) in the subtree
     * rooted at k, which is assumed to satisfy the heap invariant except
     * possibly for node k itself (which may have a nextExecutionTime greater
     * than its children's).
     *
     * This method functions by &quot;demoting&quot; queue[k] down the hierarchy
     * (by swapping it with its smaller child) repeatedly until queue[k]'s
     * nextExecutionTime is less than or equal to those of its children.
     */
    private void fixDown(int k) {
        int j;
<span class="pc bpc" id="L701" title="3 of 4 branches missed.">        while ((j = k &lt;&lt; 1) &lt;= size &amp;&amp; j &gt; 0) {</span>
<span class="nc bnc" id="L702" title="All 4 branches missed.">            if (j &lt; size &amp;&amp;</span>
                queue[j].nextExecutionTime &gt; queue[j+1].nextExecutionTime)
<span class="nc" id="L704">                j++; // j indexes smallest kid</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">            if (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime)</span>
<span class="nc" id="L706">                break;</span>
<span class="nc" id="L707">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</span>
<span class="nc" id="L708">            k = j;</span>
<span class="nc" id="L709">        }</span>
<span class="fc" id="L710">    }</span>

    /**
     * Establishes the heap invariant (described above) in the entire tree,
     * assuming nothing about the order of the elements prior to the call.
     */
    void heapify() {
<span class="nc bnc" id="L717" title="All 2 branches missed.">        for (int i = size/2; i &gt;= 1; i--)</span>
<span class="nc" id="L718">            fixDown(i);</span>
<span class="nc" id="L719">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>