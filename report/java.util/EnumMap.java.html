<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>EnumMap.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">EnumMap.java</span></div><h1>EnumMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.util.Map.Entry;
import sun.misc.SharedSecrets;

/**
 * A specialized {@link Map} implementation for use with enum type keys.  All
 * of the keys in an enum map must come from a single enum type that is
 * specified, explicitly or implicitly, when the map is created.  Enum maps
 * are represented internally as arrays.  This representation is extremely
 * compact and efficient.
 *
 * &lt;p&gt;Enum maps are maintained in the &lt;i&gt;natural order&lt;/i&gt; of their keys
 * (the order in which the enum constants are declared).  This is reflected
 * in the iterators returned by the collections views ({@link #keySet()},
 * {@link #entrySet()}, and {@link #values()}).
 *
 * &lt;p&gt;Iterators returned by the collection views are &lt;i&gt;weakly consistent&lt;/i&gt;:
 * they will never throw {@link ConcurrentModificationException} and they may
 * or may not show the effects of any modifications to the map that occur while
 * the iteration is in progress.
 *
 * &lt;p&gt;Null keys are not permitted.  Attempts to insert a null key will
 * throw {@link NullPointerException}.  Attempts to test for the
 * presence of a null key or to remove one will, however, function properly.
 * Null values are permitted.

 * &lt;P&gt;Like most collection implementations &lt;tt&gt;EnumMap&lt;/tt&gt; is not
 * synchronized. If multiple threads access an enum map concurrently, and at
 * least one of the threads modifies the map, it should be synchronized
 * externally.  This is typically accomplished by synchronizing on some
 * object that naturally encapsulates the enum map.  If no such object exists,
 * the map should be &quot;wrapped&quot; using the {@link Collections#synchronizedMap}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access:
 *
 * &lt;pre&gt;
 *     Map&amp;lt;EnumKey, V&amp;gt; m
 *         = Collections.synchronizedMap(new EnumMap&amp;lt;EnumKey, V&amp;gt;(...));
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Implementation note: All basic operations execute in constant time.
 * They are likely (though not guaranteed) to be faster than their
 * {@link HashMap} counterparts.
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @author Josh Bloch
 * @see EnumSet
 * @since 1.5
 */
public class EnumMap&lt;K extends Enum&lt;K&gt;, V&gt; extends AbstractMap&lt;K, V&gt;
    implements java.io.Serializable, Cloneable
{
    /**
     * The &lt;tt&gt;Class&lt;/tt&gt; object for the enum type of all the keys of this map.
     *
     * @serial
     */
    private final Class&lt;K&gt; keyType;

    /**
     * All of the values comprising K.  (Cached for performance.)
     */
    private transient K[] keyUniverse;

    /**
     * Array representation of this map.  The ith element is the value
     * to which universe[i] is currently mapped, or null if it isn't
     * mapped to anything, or NULL if it's mapped to null.
     */
    private transient Object[] vals;

    /**
     * The number of mappings in this map.
     */
<span class="pc" id="L104">    private transient int size = 0;</span>

    /**
     * Distinguished non-null value for representing null values.
     */
<span class="fc" id="L109">    private static final Object NULL = new Object() {</span>
        public int hashCode() {
<span class="nc" id="L111">            return 0;</span>
        }

        public String toString() {
<span class="nc" id="L115">            return &quot;java.util.EnumMap.NULL&quot;;</span>
        }
    };

    private Object maskNull(Object value) {
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        return (value == null ? NULL : value);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private V unmaskNull(Object value) {
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        return (V)(value == NULL ? null : value);</span>
    }

<span class="fc" id="L128">    private static final Enum&lt;?&gt;[] ZERO_LENGTH_ENUM_ARRAY = new Enum&lt;?&gt;[0];</span>

    /**
     * Creates an empty enum map with the specified key type.
     *
     * @param keyType the class object of the key type for this enum map
     * @throws NullPointerException if &lt;tt&gt;keyType&lt;/tt&gt; is null
     */
<span class="fc" id="L136">    public EnumMap(Class&lt;K&gt; keyType) {</span>
<span class="fc" id="L137">        this.keyType = keyType;</span>
<span class="fc" id="L138">        keyUniverse = getKeyUniverse(keyType);</span>
<span class="fc" id="L139">        vals = new Object[keyUniverse.length];</span>
<span class="fc" id="L140">    }</span>

    /**
     * Creates an enum map with the same key type as the specified enum
     * map, initially containing the same mappings (if any).
     *
     * @param m the enum map from which to initialize this enum map
     * @throws NullPointerException if &lt;tt&gt;m&lt;/tt&gt; is null
     */
<span class="nc" id="L149">    public EnumMap(EnumMap&lt;K, ? extends V&gt; m) {</span>
<span class="nc" id="L150">        keyType = m.keyType;</span>
<span class="nc" id="L151">        keyUniverse = m.keyUniverse;</span>
<span class="nc" id="L152">        vals = m.vals.clone();</span>
<span class="nc" id="L153">        size = m.size;</span>
<span class="nc" id="L154">    }</span>

    /**
     * Creates an enum map initialized from the specified map.  If the
     * specified map is an &lt;tt&gt;EnumMap&lt;/tt&gt; instance, this constructor behaves
     * identically to {@link #EnumMap(EnumMap)}.  Otherwise, the specified map
     * must contain at least one mapping (in order to determine the new
     * enum map's key type).
     *
     * @param m the map from which to initialize this enum map
     * @throws IllegalArgumentException if &lt;tt&gt;m&lt;/tt&gt; is not an
     *     &lt;tt&gt;EnumMap&lt;/tt&gt; instance and contains no mappings
     * @throws NullPointerException if &lt;tt&gt;m&lt;/tt&gt; is null
     */
<span class="nc" id="L168">    public EnumMap(Map&lt;K, ? extends V&gt; m) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (m instanceof EnumMap) {</span>
<span class="nc" id="L170">            EnumMap&lt;K, ? extends V&gt; em = (EnumMap&lt;K, ? extends V&gt;) m;</span>
<span class="nc" id="L171">            keyType = em.keyType;</span>
<span class="nc" id="L172">            keyUniverse = em.keyUniverse;</span>
<span class="nc" id="L173">            vals = em.vals.clone();</span>
<span class="nc" id="L174">            size = em.size;</span>
<span class="nc" id="L175">        } else {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">            if (m.isEmpty())</span>
<span class="nc" id="L177">                throw new IllegalArgumentException(&quot;Specified map is empty&quot;);</span>
<span class="nc" id="L178">            keyType = m.keySet().iterator().next().getDeclaringClass();</span>
<span class="nc" id="L179">            keyUniverse = getKeyUniverse(keyType);</span>
<span class="nc" id="L180">            vals = new Object[keyUniverse.length];</span>
<span class="nc" id="L181">            putAll(m);</span>
        }
<span class="nc" id="L183">    }</span>

    // Query Operations

    /**
     * Returns the number of key-value mappings in this map.
     *
     * @return the number of key-value mappings in this map
     */
    public int size() {
<span class="nc" id="L193">        return size;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
     * specified value.
     *
     * @param value the value whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to this value
     */
    public boolean containsValue(Object value) {
<span class="nc" id="L204">        value = maskNull(value);</span>

<span class="nc bnc" id="L206" title="All 2 branches missed.">        for (Object val : vals)</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (value.equals(val))</span>
<span class="nc" id="L208">                return true;</span>

<span class="nc" id="L210">        return false;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified
     * key.
     *
     * @param key the key whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified
     *            key
     */
    public boolean containsKey(Object key) {
<span class="nc bnc" id="L222" title="All 4 branches missed.">        return isValidKey(key) &amp;&amp; vals[((Enum&lt;?&gt;)key).ordinal()] != null;</span>
    }

    private boolean containsMapping(Object key, Object value) {
<span class="nc bnc" id="L226" title="All 2 branches missed.">        return isValidKey(key) &amp;&amp;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            maskNull(value).equals(vals[((Enum&lt;?&gt;)key).ordinal()]);</span>
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * &lt;p&gt;More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code (key == k)},
     * then this method returns {@code v}; otherwise it returns
     * {@code null}.  (There can be at most one such mapping.)
     *
     * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
     * indicate that the map contains no mapping for the key; it's also
     * possible that the map explicitly maps the key to {@code null}.
     * The {@link #containsKey containsKey} operation may be used to
     * distinguish these two cases.
     */
    public V get(Object key) {
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        return (isValidKey(key) ?</span>
<span class="pc" id="L247">                unmaskNull(vals[((Enum&lt;?&gt;)key).ordinal()]) : null);</span>
    }

    // Modification Operations

    /**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for this key, the old
     * value is replaced.
     *
     * @param key the key with which the specified value is to be associated
     * @param value the value to be associated with the specified key
     *
     * @return the previous value associated with specified key, or
     *     &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for key.  (A &lt;tt&gt;null&lt;/tt&gt;
     *     return can also indicate that the map previously associated
     *     &lt;tt&gt;null&lt;/tt&gt; with the specified key.)
     * @throws NullPointerException if the specified key is null
     */
    public V put(K key, V value) {
<span class="fc" id="L267">        typeCheck(key);</span>

<span class="fc" id="L269">        int index = key.ordinal();</span>
<span class="fc" id="L270">        Object oldValue = vals[index];</span>
<span class="fc" id="L271">        vals[index] = maskNull(value);</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (oldValue == null)</span>
<span class="fc" id="L273">            size++;</span>
<span class="fc" id="L274">        return unmaskNull(oldValue);</span>
    }

    /**
     * Removes the mapping for this key from this map if present.
     *
     * @param key the key whose mapping is to be removed from the map
     * @return the previous value associated with specified key, or
     *     &lt;tt&gt;null&lt;/tt&gt; if there was no entry for key.  (A &lt;tt&gt;null&lt;/tt&gt;
     *     return can also indicate that the map previously associated
     *     &lt;tt&gt;null&lt;/tt&gt; with the specified key.)
     */
    public V remove(Object key) {
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (!isValidKey(key))</span>
<span class="nc" id="L288">            return null;</span>
<span class="nc" id="L289">        int index = ((Enum&lt;?&gt;)key).ordinal();</span>
<span class="nc" id="L290">        Object oldValue = vals[index];</span>
<span class="nc" id="L291">        vals[index] = null;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (oldValue != null)</span>
<span class="nc" id="L293">            size--;</span>
<span class="nc" id="L294">        return unmaskNull(oldValue);</span>
    }

    private boolean removeMapping(Object key, Object value) {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (!isValidKey(key))</span>
<span class="nc" id="L299">            return false;</span>
<span class="nc" id="L300">        int index = ((Enum&lt;?&gt;)key).ordinal();</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (maskNull(value).equals(vals[index])) {</span>
<span class="nc" id="L302">            vals[index] = null;</span>
<span class="nc" id="L303">            size--;</span>
<span class="nc" id="L304">            return true;</span>
        }
<span class="nc" id="L306">        return false;</span>
    }

    /**
     * Returns true if key is of the proper type to be a key in this
     * enum map.
     */
    private boolean isValidKey(Object key) {
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L315">            return false;</span>

        // Cheaper than instanceof Enum followed by getDeclaringClass
<span class="fc" id="L318">        Class&lt;?&gt; keyClass = key.getClass();</span>
<span class="pc bpc" id="L319" title="1 of 4 branches missed.">        return keyClass == keyType || keyClass.getSuperclass() == keyType;</span>
    }

    // Bulk Operations

    /**
     * Copies all of the mappings from the specified map to this map.
     * These mappings will replace any mappings that this map had for
     * any of the keys currently in the specified map.
     *
     * @param m the mappings to be stored in this map
     * @throws NullPointerException the specified map is null, or if
     *     one or more keys in the specified map are null
     */
    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (m instanceof EnumMap) {</span>
<span class="nc" id="L335">            EnumMap&lt;?, ?&gt; em = (EnumMap&lt;?, ?&gt;)m;</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (em.keyType != keyType) {</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                if (em.isEmpty())</span>
<span class="nc" id="L338">                    return;</span>
<span class="nc" id="L339">                throw new ClassCastException(em.keyType + &quot; != &quot; + keyType);</span>
            }

<span class="nc bnc" id="L342" title="All 2 branches missed.">            for (int i = 0; i &lt; keyUniverse.length; i++) {</span>
<span class="nc" id="L343">                Object emValue = em.vals[i];</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                if (emValue != null) {</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                    if (vals[i] == null)</span>
<span class="nc" id="L346">                        size++;</span>
<span class="nc" id="L347">                    vals[i] = emValue;</span>
                }
            }
<span class="nc" id="L350">        } else {</span>
<span class="nc" id="L351">            super.putAll(m);</span>
        }
<span class="nc" id="L353">    }</span>

    /**
     * Removes all mappings from this map.
     */
    public void clear() {
<span class="fc" id="L359">        Arrays.fill(vals, null);</span>
<span class="fc" id="L360">        size = 0;</span>
<span class="fc" id="L361">    }</span>

    // Views

    /**
     * This field is initialized to contain an instance of the entry set
     * view the first time this view is requested.  The view is stateless,
     * so there's no reason to create more than one.
     */
<span class="pc" id="L370">    private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;</span>

    /**
     * Returns a {@link Set} view of the keys contained in this map.
     * The returned set obeys the general contract outlined in
     * {@link Map#keySet()}.  The set's iterator will return the keys
     * in their natural order (the order in which the enum constants
     * are declared).
     *
     * @return a set view of the keys contained in this enum map
     */
    public Set&lt;K&gt; keySet() {
<span class="nc" id="L382">        Set&lt;K&gt; ks = keySet;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (ks != null)</span>
<span class="nc" id="L384">            return ks;</span>
        else
<span class="nc" id="L386">            return keySet = new KeySet();</span>
    }

<span class="nc" id="L389">    private class KeySet extends AbstractSet&lt;K&gt; {</span>
        public Iterator&lt;K&gt; iterator() {
<span class="nc" id="L391">            return new KeyIterator();</span>
        }
        public int size() {
<span class="nc" id="L394">            return size;</span>
        }
        public boolean contains(Object o) {
<span class="nc" id="L397">            return containsKey(o);</span>
        }
        public boolean remove(Object o) {
<span class="nc" id="L400">            int oldSize = size;</span>
<span class="nc" id="L401">            EnumMap.this.remove(o);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            return size != oldSize;</span>
        }
        public void clear() {
<span class="nc" id="L405">            EnumMap.this.clear();</span>
<span class="nc" id="L406">        }</span>
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * The returned collection obeys the general contract outlined in
     * {@link Map#values()}.  The collection's iterator will return the
     * values in the order their corresponding keys appear in map,
     * which is their natural order (the order in which the enum constants
     * are declared).
     *
     * @return a collection view of the values contained in this map
     */
    public Collection&lt;V&gt; values() {
<span class="fc" id="L420">        Collection&lt;V&gt; vs = values;</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">        if (vs != null)</span>
<span class="fc" id="L422">            return vs;</span>
        else
<span class="fc" id="L424">            return values = new Values();</span>
    }

<span class="fc" id="L427">    private class Values extends AbstractCollection&lt;V&gt; {</span>
        public Iterator&lt;V&gt; iterator() {
<span class="fc" id="L429">            return new ValueIterator();</span>
        }
        public int size() {
<span class="nc" id="L432">            return size;</span>
        }
        public boolean contains(Object o) {
<span class="nc" id="L435">            return containsValue(o);</span>
        }
        public boolean remove(Object o) {
<span class="nc" id="L438">            o = maskNull(o);</span>

<span class="nc bnc" id="L440" title="All 2 branches missed.">            for (int i = 0; i &lt; vals.length; i++) {</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                if (o.equals(vals[i])) {</span>
<span class="nc" id="L442">                    vals[i] = null;</span>
<span class="nc" id="L443">                    size--;</span>
<span class="nc" id="L444">                    return true;</span>
                }
            }
<span class="nc" id="L447">            return false;</span>
        }
        public void clear() {
<span class="nc" id="L450">            EnumMap.this.clear();</span>
<span class="nc" id="L451">        }</span>
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The returned set obeys the general contract outlined in
     * {@link Map#keySet()}.  The set's iterator will return the
     * mappings in the order their keys appear in map, which is their
     * natural order (the order in which the enum constants are declared).
     *
     * @return a set view of the mappings contained in this enum map
     */
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<span class="fc" id="L464">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">        if (es != null)</span>
<span class="fc" id="L466">            return es;</span>
        else
<span class="fc" id="L468">            return entrySet = new EntrySet();</span>
    }

<span class="fc" id="L471">    private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {</span>
        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
<span class="fc" id="L473">            return new EntryIterator();</span>
        }

        public boolean contains(Object o) {
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L478">                return false;</span>
<span class="nc" id="L479">            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span>
<span class="nc" id="L480">            return containsMapping(entry.getKey(), entry.getValue());</span>
        }
        public boolean remove(Object o) {
<span class="nc bnc" id="L483" title="All 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L484">                return false;</span>
<span class="nc" id="L485">            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span>
<span class="nc" id="L486">            return removeMapping(entry.getKey(), entry.getValue());</span>
        }
        public int size() {
<span class="nc" id="L489">            return size;</span>
        }
        public void clear() {
<span class="nc" id="L492">            EnumMap.this.clear();</span>
<span class="nc" id="L493">        }</span>
        public Object[] toArray() {
<span class="nc" id="L495">            return fillEntryArray(new Object[size]);</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;T&gt; T[] toArray(T[] a) {
<span class="nc" id="L499">            int size = size();</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (a.length &lt; size)</span>
<span class="nc" id="L501">                a = (T[])java.lang.reflect.Array</span>
<span class="nc" id="L502">                    .newInstance(a.getClass().getComponentType(), size);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (a.length &gt; size)</span>
<span class="nc" id="L504">                a[size] = null;</span>
<span class="nc" id="L505">            return (T[]) fillEntryArray(a);</span>
        }
        private Object[] fillEntryArray(Object[] a) {
<span class="nc" id="L508">            int j = 0;</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">            for (int i = 0; i &lt; vals.length; i++)</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                if (vals[i] != null)</span>
<span class="nc" id="L511">                    a[j++] = new AbstractMap.SimpleEntry&lt;&gt;(</span>
<span class="nc" id="L512">                        keyUniverse[i], unmaskNull(vals[i]));</span>
<span class="nc" id="L513">            return a;</span>
        }
    }

<span class="fc" id="L517">    private abstract class EnumMapIterator&lt;T&gt; implements Iterator&lt;T&gt; {</span>
        // Lower bound on index of next element to return
<span class="fc" id="L519">        int index = 0;</span>

        // Index of last returned element, or -1 if none
<span class="fc" id="L522">        int lastReturnedIndex = -1;</span>

        public boolean hasNext() {
<span class="pc bpc" id="L525" title="1 of 4 branches missed.">            while (index &lt; vals.length &amp;&amp; vals[index] == null)</span>
<span class="nc" id="L526">                index++;</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">            return index != vals.length;</span>
        }

        public void remove() {
<span class="nc" id="L531">            checkLastReturnedIndex();</span>

<span class="nc bnc" id="L533" title="All 2 branches missed.">            if (vals[lastReturnedIndex] != null) {</span>
<span class="nc" id="L534">                vals[lastReturnedIndex] = null;</span>
<span class="nc" id="L535">                size--;</span>
            }
<span class="nc" id="L537">            lastReturnedIndex = -1;</span>
<span class="nc" id="L538">        }</span>

        private void checkLastReturnedIndex() {
<span class="nc bnc" id="L541" title="All 2 branches missed.">            if (lastReturnedIndex &lt; 0)</span>
<span class="nc" id="L542">                throw new IllegalStateException();</span>
<span class="nc" id="L543">        }</span>
    }

<span class="nc" id="L546">    private class KeyIterator extends EnumMapIterator&lt;K&gt; {</span>
        public K next() {
<span class="nc bnc" id="L548" title="All 2 branches missed.">            if (!hasNext())</span>
<span class="nc" id="L549">                throw new NoSuchElementException();</span>
<span class="nc" id="L550">            lastReturnedIndex = index++;</span>
<span class="nc" id="L551">            return keyUniverse[lastReturnedIndex];</span>
        }
    }

<span class="fc" id="L555">    private class ValueIterator extends EnumMapIterator&lt;V&gt; {</span>
        public V next() {
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">            if (!hasNext())</span>
<span class="nc" id="L558">                throw new NoSuchElementException();</span>
<span class="fc" id="L559">            lastReturnedIndex = index++;</span>
<span class="fc" id="L560">            return unmaskNull(vals[lastReturnedIndex]);</span>
        }
    }

<span class="fc" id="L564">    private class EntryIterator extends EnumMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; {</span>
<span class="fc" id="L565">        private Entry lastReturnedEntry = null;</span>

        public Map.Entry&lt;K,V&gt; next() {
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">            if (!hasNext())</span>
<span class="nc" id="L569">                throw new NoSuchElementException();</span>
<span class="fc" id="L570">            lastReturnedEntry = new Entry(index++);</span>
<span class="fc" id="L571">            return lastReturnedEntry;</span>
        }

        public void remove() {
<span class="nc bnc" id="L575" title="All 2 branches missed.">            lastReturnedIndex =</span>
<span class="nc" id="L576">                ((null == lastReturnedEntry) ? -1 : lastReturnedEntry.index);</span>
<span class="nc" id="L577">            super.remove();</span>
<span class="nc" id="L578">            lastReturnedEntry.index = lastReturnedIndex;</span>
<span class="nc" id="L579">            lastReturnedEntry = null;</span>
<span class="nc" id="L580">        }</span>

<span class="fc" id="L582">        private class Entry implements Map.Entry&lt;K,V&gt; {</span>
            private int index;

<span class="fc" id="L585">            private Entry(int index) {</span>
<span class="fc" id="L586">                this.index = index;</span>
<span class="fc" id="L587">            }</span>

            public K getKey() {
<span class="fc" id="L590">                checkIndexForEntryUse();</span>
<span class="fc" id="L591">                return keyUniverse[index];</span>
            }

            public V getValue() {
<span class="fc" id="L595">                checkIndexForEntryUse();</span>
<span class="fc" id="L596">                return unmaskNull(vals[index]);</span>
            }

            public V setValue(V value) {
<span class="nc" id="L600">                checkIndexForEntryUse();</span>
<span class="nc" id="L601">                V oldValue = unmaskNull(vals[index]);</span>
<span class="nc" id="L602">                vals[index] = maskNull(value);</span>
<span class="nc" id="L603">                return oldValue;</span>
            }

            public boolean equals(Object o) {
<span class="nc bnc" id="L607" title="All 2 branches missed.">                if (index &lt; 0)</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">                    return o == this;</span>

<span class="nc bnc" id="L610" title="All 2 branches missed.">                if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L611">                    return false;</span>

<span class="nc" id="L613">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span>
<span class="nc" id="L614">                V ourValue = unmaskNull(vals[index]);</span>
<span class="nc" id="L615">                Object hisValue = e.getValue();</span>
<span class="nc bnc" id="L616" title="All 6 branches missed.">                return (e.getKey() == keyUniverse[index] &amp;&amp;</span>
                        (ourValue == hisValue ||
<span class="nc bnc" id="L618" title="All 2 branches missed.">                         (ourValue != null &amp;&amp; ourValue.equals(hisValue))));</span>
            }

            public int hashCode() {
<span class="nc bnc" id="L622" title="All 2 branches missed.">                if (index &lt; 0)</span>
<span class="nc" id="L623">                    return super.hashCode();</span>

<span class="nc" id="L625">                return entryHashCode(index);</span>
            }

            public String toString() {
<span class="nc bnc" id="L629" title="All 2 branches missed.">                if (index &lt; 0)</span>
<span class="nc" id="L630">                    return super.toString();</span>

<span class="nc" id="L632">                return keyUniverse[index] + &quot;=&quot;</span>
<span class="nc" id="L633">                    + unmaskNull(vals[index]);</span>
            }

            private void checkIndexForEntryUse() {
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">                if (index &lt; 0)</span>
<span class="nc" id="L638">                    throw new IllegalStateException(&quot;Entry was removed&quot;);</span>
<span class="fc" id="L639">            }</span>
        }
    }

    // Comparison and hashing

    /**
     * Compares the specified object with this map for equality.  Returns
     * &lt;tt&gt;true&lt;/tt&gt; if the given object is also a map and the two maps
     * represent the same mappings, as specified in the {@link
     * Map#equals(Object)} contract.
     *
     * @param o the object to be compared for equality with this map
     * @return &lt;tt&gt;true&lt;/tt&gt; if the specified object is equal to this map
     */
    public boolean equals(Object o) {
<span class="nc bnc" id="L655" title="All 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L656">            return true;</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">        if (o instanceof EnumMap)</span>
<span class="nc" id="L658">            return equals((EnumMap&lt;?,?&gt;)o);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">        if (!(o instanceof Map))</span>
<span class="nc" id="L660">            return false;</span>

<span class="nc" id="L662">        Map&lt;?,?&gt; m = (Map&lt;?,?&gt;)o;</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (size != m.size())</span>
<span class="nc" id="L664">            return false;</span>

<span class="nc bnc" id="L666" title="All 2 branches missed.">        for (int i = 0; i &lt; keyUniverse.length; i++) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">            if (null != vals[i]) {</span>
<span class="nc" id="L668">                K key = keyUniverse[i];</span>
<span class="nc" id="L669">                V value = unmaskNull(vals[i]);</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">                if (null == value) {</span>
<span class="nc bnc" id="L671" title="All 4 branches missed.">                    if (!((null == m.get(key)) &amp;&amp; m.containsKey(key)))</span>
<span class="nc" id="L672">                       return false;</span>
                } else {
<span class="nc bnc" id="L674" title="All 2 branches missed.">                   if (!value.equals(m.get(key)))</span>
<span class="nc" id="L675">                      return false;</span>
                }
            }
        }

<span class="nc" id="L680">        return true;</span>
    }

    private boolean equals(EnumMap&lt;?,?&gt; em) {
<span class="nc bnc" id="L684" title="All 2 branches missed.">        if (em.keyType != keyType)</span>
<span class="nc bnc" id="L685" title="All 4 branches missed.">            return size == 0 &amp;&amp; em.size == 0;</span>

        // Key types match, compare each value
<span class="nc bnc" id="L688" title="All 2 branches missed.">        for (int i = 0; i &lt; keyUniverse.length; i++) {</span>
<span class="nc" id="L689">            Object ourValue =    vals[i];</span>
<span class="nc" id="L690">            Object hisValue = em.vals[i];</span>
<span class="nc bnc" id="L691" title="All 4 branches missed.">            if (hisValue != ourValue &amp;&amp;</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                (hisValue == null || !hisValue.equals(ourValue)))</span>
<span class="nc" id="L693">                return false;</span>
        }
<span class="nc" id="L695">        return true;</span>
    }

    /**
     * Returns the hash code value for this map.  The hash code of a map is
     * defined to be the sum of the hash codes of each entry in the map.
     */
    public int hashCode() {
<span class="nc" id="L703">        int h = 0;</span>

<span class="nc bnc" id="L705" title="All 2 branches missed.">        for (int i = 0; i &lt; keyUniverse.length; i++) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">            if (null != vals[i]) {</span>
<span class="nc" id="L707">                h += entryHashCode(i);</span>
            }
        }

<span class="nc" id="L711">        return h;</span>
    }

    private int entryHashCode(int index) {
<span class="nc" id="L715">        return (keyUniverse[index].hashCode() ^ vals[index].hashCode());</span>
    }

    /**
     * Returns a shallow copy of this enum map.  (The values themselves
     * are not cloned.
     *
     * @return a shallow copy of this enum map
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public EnumMap&lt;K, V&gt; clone() {
<span class="nc" id="L726">        EnumMap&lt;K, V&gt; result = null;</span>
        try {
<span class="nc" id="L728">            result = (EnumMap&lt;K, V&gt;) super.clone();</span>
<span class="nc" id="L729">        } catch(CloneNotSupportedException e) {</span>
<span class="nc" id="L730">            throw new AssertionError();</span>
<span class="nc" id="L731">        }</span>
<span class="nc" id="L732">        result.vals = result.vals.clone();</span>
<span class="nc" id="L733">        result.entrySet = null;</span>
<span class="nc" id="L734">        return result;</span>
    }

    /**
     * Throws an exception if e is not of the correct type for this enum set.
     */
    private void typeCheck(K key) {
<span class="fc" id="L741">        Class&lt;?&gt; keyClass = key.getClass();</span>
<span class="pc bpc" id="L742" title="1 of 4 branches missed.">        if (keyClass != keyType &amp;&amp; keyClass.getSuperclass() != keyType)</span>
<span class="nc" id="L743">            throw new ClassCastException(keyClass + &quot; != &quot; + keyType);</span>
<span class="fc" id="L744">    }</span>

    /**
     * Returns all of the values comprising K.
     * The result is uncloned, cached, and shared by all callers.
     */
    private static &lt;K extends Enum&lt;K&gt;&gt; K[] getKeyUniverse(Class&lt;K&gt; keyType) {
<span class="fc" id="L751">        return SharedSecrets.getJavaLangAccess()</span>
<span class="fc" id="L752">                                        .getEnumConstantsShared(keyType);</span>
    }

    private static final long serialVersionUID = 458661240069192865L;

    /**
     * Save the state of the &lt;tt&gt;EnumMap&lt;/tt&gt; instance to a stream (i.e.,
     * serialize it).
     *
     * @serialData The &lt;i&gt;size&lt;/i&gt; of the enum map (the number of key-value
     *             mappings) is emitted (int), followed by the key (Object)
     *             and value (Object) for each key-value mapping represented
     *             by the enum map.
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException
    {
        // Write out the key type and any hidden stuff
<span class="nc" id="L770">        s.defaultWriteObject();</span>

        // Write out size (number of Mappings)
<span class="nc" id="L773">        s.writeInt(size);</span>

        // Write out keys and values (alternating)
<span class="nc" id="L776">        int entriesToBeWritten = size;</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">        for (int i = 0; entriesToBeWritten &gt; 0; i++) {</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">            if (null != vals[i]) {</span>
<span class="nc" id="L779">                s.writeObject(keyUniverse[i]);</span>
<span class="nc" id="L780">                s.writeObject(unmaskNull(vals[i]));</span>
<span class="nc" id="L781">                entriesToBeWritten--;</span>
            }
        }
<span class="nc" id="L784">    }</span>

    /**
     * Reconstitute the &lt;tt&gt;EnumMap&lt;/tt&gt; instance from a stream (i.e.,
     * deserialize it).
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException
    {
        // Read in the key type and any hidden stuff
<span class="nc" id="L795">        s.defaultReadObject();</span>

<span class="nc" id="L797">        keyUniverse = getKeyUniverse(keyType);</span>
<span class="nc" id="L798">        vals = new Object[keyUniverse.length];</span>

        // Read in size (number of Mappings)
<span class="nc" id="L801">        int size = s.readInt();</span>

        // Read the keys and values, and put the mappings in the HashMap
<span class="nc bnc" id="L804" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L805">            K key = (K) s.readObject();</span>
<span class="nc" id="L806">            V value = (V) s.readObject();</span>
<span class="nc" id="L807">            put(key, value);</span>
        }
<span class="nc" id="L809">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>