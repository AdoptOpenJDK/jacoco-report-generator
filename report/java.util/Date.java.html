<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Date.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">Date.java</span></div><h1>Date.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util;

import java.text.DateFormat;
import java.time.LocalDate;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.lang.ref.SoftReference;
import java.time.Instant;
import sun.util.calendar.BaseCalendar;
import sun.util.calendar.CalendarDate;
import sun.util.calendar.CalendarSystem;
import sun.util.calendar.CalendarUtils;
import sun.util.calendar.Era;
import sun.util.calendar.Gregorian;
import sun.util.calendar.ZoneInfo;

/**
 * The class &lt;code&gt;Date&lt;/code&gt; represents a specific instant
 * in time, with millisecond precision.
 * &lt;p&gt;
 * Prior to JDK&amp;nbsp;1.1, the class &lt;code&gt;Date&lt;/code&gt; had two additional
 * functions.  It allowed the interpretation of dates as year, month, day, hour,
 * minute, and second values.  It also allowed the formatting and parsing
 * of date strings.  Unfortunately, the API for these functions was not
 * amenable to internationalization.  As of JDK&amp;nbsp;1.1, the
 * &lt;code&gt;Calendar&lt;/code&gt; class should be used to convert between dates and time
 * fields and the &lt;code&gt;DateFormat&lt;/code&gt; class should be used to format and
 * parse date strings.
 * The corresponding methods in &lt;code&gt;Date&lt;/code&gt; are deprecated.
 * &lt;p&gt;
 * Although the &lt;code&gt;Date&lt;/code&gt; class is intended to reflect
 * coordinated universal time (UTC), it may not do so exactly,
 * depending on the host environment of the Java Virtual Machine.
 * Nearly all modern operating systems assume that 1&amp;nbsp;day&amp;nbsp;=
 * 24&amp;nbsp;&amp;times;&amp;nbsp;60&amp;nbsp;&amp;times;&amp;nbsp;60&amp;nbsp;= 86400 seconds
 * in all cases. In UTC, however, about once every year or two there
 * is an extra second, called a &quot;leap second.&quot; The leap
 * second is always added as the last second of the day, and always
 * on December 31 or June 30. For example, the last minute of the
 * year 1995 was 61 seconds long, thanks to an added leap second.
 * Most computer clocks are not accurate enough to be able to reflect
 * the leap-second distinction.
 * &lt;p&gt;
 * Some computer standards are defined in terms of Greenwich mean
 * time (GMT), which is equivalent to universal time (UT).  GMT is
 * the &quot;civil&quot; name for the standard; UT is the
 * &quot;scientific&quot; name for the same standard. The
 * distinction between UTC and UT is that UTC is based on an atomic
 * clock and UT is based on astronomical observations, which for all
 * practical purposes is an invisibly fine hair to split. Because the
 * earth's rotation is not uniform (it slows down and speeds up
 * in complicated ways), UT does not always flow uniformly. Leap
 * seconds are introduced as needed into UTC so as to keep UTC within
 * 0.9 seconds of UT1, which is a version of UT with certain
 * corrections applied. There are other time and date systems as
 * well; for example, the time scale used by the satellite-based
 * global positioning system (GPS) is synchronized to UTC but is
 * &lt;i&gt;not&lt;/i&gt; adjusted for leap seconds. An interesting source of
 * further information is the U.S. Naval Observatory, particularly
 * the Directorate of Time at:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     &lt;a href=http://tycho.usno.navy.mil&gt;http://tycho.usno.navy.mil&lt;/a&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;
 * and their definitions of &quot;Systems of Time&quot; at:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     &lt;a href=http://tycho.usno.navy.mil/systime.html&gt;http://tycho.usno.navy.mil/systime.html&lt;/a&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;
 * In all methods of class &lt;code&gt;Date&lt;/code&gt; that accept or return
 * year, month, date, hours, minutes, and seconds values, the
 * following representations are used:
 * &lt;ul&gt;
 * &lt;li&gt;A year &lt;i&gt;y&lt;/i&gt; is represented by the integer
 *     &lt;i&gt;y&lt;/i&gt;&amp;nbsp;&lt;code&gt;-&amp;nbsp;1900&lt;/code&gt;.
 * &lt;li&gt;A month is represented by an integer from 0 to 11; 0 is January,
 *     1 is February, and so forth; thus 11 is December.
 * &lt;li&gt;A date (day of month) is represented by an integer from 1 to 31
 *     in the usual manner.
 * &lt;li&gt;An hour is represented by an integer from 0 to 23. Thus, the hour
 *     from midnight to 1 a.m. is hour 0, and the hour from noon to 1
 *     p.m. is hour 12.
 * &lt;li&gt;A minute is represented by an integer from 0 to 59 in the usual manner.
 * &lt;li&gt;A second is represented by an integer from 0 to 61; the values 60 and
 *     61 occur only for leap seconds and even then only in Java
 *     implementations that actually track leap seconds correctly. Because
 *     of the manner in which leap seconds are currently introduced, it is
 *     extremely unlikely that two leap seconds will occur in the same
 *     minute, but this specification follows the date and time conventions
 *     for ISO C.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * In all cases, arguments given to methods for these purposes need
 * not fall within the indicated ranges; for example, a date may be
 * specified as January 32 and is interpreted as meaning February 1.
 *
 * @author  James Gosling
 * @author  Arthur van Hoff
 * @author  Alan Liu
 * @see     java.text.DateFormat
 * @see     java.util.Calendar
 * @see     java.util.TimeZone
 * @since   JDK1.0
 */
public class Date
    implements java.io.Serializable, Cloneable, Comparable&lt;Date&gt;
{
    private static final BaseCalendar gcal =
<span class="fc" id="L135">                                CalendarSystem.getGregorianCalendar();</span>
    private static BaseCalendar jcal;

    private transient long fastTime;

    /*
     * If cdate is null, then fastTime indicates the time in millis.
     * If cdate.isNormalized() is true, then fastTime and cdate are in
     * synch. Otherwise, fastTime is ignored, and cdate indicates the
     * time.
     */
    private transient BaseCalendar.Date cdate;

    // Initialized just before the value is used. See parse().
    private static int defaultCenturyStart;

    /* use serialVersionUID from modified java.util.Date for
     * interoperability with JDK1.1. The Date was modified to write
     * and read only the UTC time.
     */
    private static final long serialVersionUID = 7523967970034938905L;

    /**
     * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that
     * it represents the time at which it was allocated, measured to the
     * nearest millisecond.
     *
     * @see     java.lang.System#currentTimeMillis()
     */
    public Date() {
<span class="fc" id="L165">        this(System.currentTimeMillis());</span>
<span class="fc" id="L166">    }</span>

    /**
     * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it to
     * represent the specified number of milliseconds since the
     * standard base time known as &quot;the epoch&quot;, namely January 1,
     * 1970, 00:00:00 GMT.
     *
     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.
     * @see     java.lang.System#currentTimeMillis()
     */
<span class="fc" id="L177">    public Date(long date) {</span>
<span class="fc" id="L178">        fastTime = date;</span>
<span class="fc" id="L179">    }</span>

    /**
     * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that
     * it represents midnight, local time, at the beginning of the day
     * specified by the &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, and
     * &lt;code&gt;date&lt;/code&gt; arguments.
     *
     * @param   year    the year minus 1900.
     * @param   month   the month between 0-11.
     * @param   date    the day of the month between 1-31.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.set(year + 1900, month, date)&lt;/code&gt;
     * or &lt;code&gt;GregorianCalendar(year + 1900, month, date)&lt;/code&gt;.
     */
    @Deprecated
    public Date(int year, int month, int date) {
<span class="fc" id="L197">        this(year, month, date, 0, 0, 0);</span>
<span class="fc" id="L198">    }</span>

    /**
     * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that
     * it represents the instant at the start of the minute specified by
     * the &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;,
     * &lt;code&gt;hrs&lt;/code&gt;, and &lt;code&gt;min&lt;/code&gt; arguments, in the local
     * time zone.
     *
     * @param   year    the year minus 1900.
     * @param   month   the month between 0-11.
     * @param   date    the day of the month between 1-31.
     * @param   hrs     the hours between 0-23.
     * @param   min     the minutes between 0-59.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.set(year + 1900, month, date,
     * hrs, min)&lt;/code&gt; or &lt;code&gt;GregorianCalendar(year + 1900,
     * month, date, hrs, min)&lt;/code&gt;.
     */
    @Deprecated
    public Date(int year, int month, int date, int hrs, int min) {
<span class="nc" id="L220">        this(year, month, date, hrs, min, 0);</span>
<span class="nc" id="L221">    }</span>

    /**
     * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that
     * it represents the instant at the start of the second specified
     * by the &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;,
     * &lt;code&gt;hrs&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;code&gt;sec&lt;/code&gt; arguments,
     * in the local time zone.
     *
     * @param   year    the year minus 1900.
     * @param   month   the month between 0-11.
     * @param   date    the day of the month between 1-31.
     * @param   hrs     the hours between 0-23.
     * @param   min     the minutes between 0-59.
     * @param   sec     the seconds between 0-59.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.set(year + 1900, month, date,
     * hrs, min, sec)&lt;/code&gt; or &lt;code&gt;GregorianCalendar(year + 1900,
     * month, date, hrs, min, sec)&lt;/code&gt;.
     */
    @Deprecated
<span class="fc" id="L243">    public Date(int year, int month, int date, int hrs, int min, int sec) {</span>
<span class="fc" id="L244">        int y = year + 1900;</span>
        // month is 0-based. So we have to normalize month to support Long.MAX_VALUE.
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        if (month &gt;= 12) {</span>
<span class="nc" id="L247">            y += month / 12;</span>
<span class="nc" id="L248">            month %= 12;</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        } else if (month &lt; 0) {</span>
<span class="nc" id="L250">            y += CalendarUtils.floorDivide(month, 12);</span>
<span class="nc" id="L251">            month = CalendarUtils.mod(month, 12);</span>
        }
<span class="fc" id="L253">        BaseCalendar cal = getCalendarSystem(y);</span>
<span class="fc" id="L254">        cdate = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.getDefaultRef());</span>
<span class="fc" id="L255">        cdate.setNormalizedDate(y, month + 1, date).setTimeOfDay(hrs, min, sec, 0);</span>
<span class="fc" id="L256">        getTimeImpl();</span>
<span class="fc" id="L257">        cdate = null;</span>
<span class="fc" id="L258">    }</span>

    /**
     * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that
     * it represents the date and time indicated by the string
     * &lt;code&gt;s&lt;/code&gt;, which is interpreted as if by the
     * {@link Date#parse} method.
     *
     * @param   s   a string representation of the date.
     * @see     java.text.DateFormat
     * @see     java.util.Date#parse(java.lang.String)
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;DateFormat.parse(String s)&lt;/code&gt;.
     */
    @Deprecated
    public Date(String s) {
<span class="nc" id="L274">        this(parse(s));</span>
<span class="nc" id="L275">    }</span>

    /**
     * Return a copy of this object.
     */
    public Object clone() {
<span class="fc" id="L281">        Date d = null;</span>
        try {
<span class="fc" id="L283">            d = (Date)super.clone();</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">            if (cdate != null) {</span>
<span class="nc" id="L285">                d.cdate = (BaseCalendar.Date) cdate.clone();</span>
            }
<span class="pc" id="L287">        } catch (CloneNotSupportedException e) {} // Won't happen</span>
<span class="fc" id="L288">        return d;</span>
    }

    /**
     * Determines the date and time based on the arguments. The
     * arguments are interpreted as a year, month, day of the month,
     * hour of the day, minute within the hour, and second within the
     * minute, exactly as for the &lt;tt&gt;Date&lt;/tt&gt; constructor with six
     * arguments, except that the arguments are interpreted relative
     * to UTC rather than to the local time zone. The time indicated is
     * returned represented as the distance, measured in milliseconds,
     * of that time from the epoch (00:00:00 GMT on January 1, 1970).
     *
     * @param   year    the year minus 1900.
     * @param   month   the month between 0-11.
     * @param   date    the day of the month between 1-31.
     * @param   hrs     the hours between 0-23.
     * @param   min     the minutes between 0-59.
     * @param   sec     the seconds between 0-59.
     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT for
     *          the date and time specified by the arguments.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.set(year + 1900, month, date,
     * hrs, min, sec)&lt;/code&gt; or &lt;code&gt;GregorianCalendar(year + 1900,
     * month, date, hrs, min, sec)&lt;/code&gt;, using a UTC
     * &lt;code&gt;TimeZone&lt;/code&gt;, followed by &lt;code&gt;Calendar.getTime().getTime()&lt;/code&gt;.
     */
    @Deprecated
    public static long UTC(int year, int month, int date,
                           int hrs, int min, int sec) {
<span class="nc" id="L319">        int y = year + 1900;</span>
        // month is 0-based. So we have to normalize month to support Long.MAX_VALUE.
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (month &gt;= 12) {</span>
<span class="nc" id="L322">            y += month / 12;</span>
<span class="nc" id="L323">            month %= 12;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">        } else if (month &lt; 0) {</span>
<span class="nc" id="L325">            y += CalendarUtils.floorDivide(month, 12);</span>
<span class="nc" id="L326">            month = CalendarUtils.mod(month, 12);</span>
        }
<span class="nc" id="L328">        int m = month + 1;</span>
<span class="nc" id="L329">        BaseCalendar cal = getCalendarSystem(y);</span>
<span class="nc" id="L330">        BaseCalendar.Date udate = (BaseCalendar.Date) cal.newCalendarDate(null);</span>
<span class="nc" id="L331">        udate.setNormalizedDate(y, m, date).setTimeOfDay(hrs, min, sec, 0);</span>

        // Use a Date instance to perform normalization. Its fastTime
        // is the UTC value after the normalization.
<span class="nc" id="L335">        Date d = new Date(0);</span>
<span class="nc" id="L336">        d.normalize(udate);</span>
<span class="nc" id="L337">        return d.fastTime;</span>
    }

    /**
     * Attempts to interpret the string &lt;tt&gt;s&lt;/tt&gt; as a representation
     * of a date and time. If the attempt is successful, the time
     * indicated is returned represented as the distance, measured in
     * milliseconds, of that time from the epoch (00:00:00 GMT on
     * January 1, 1970). If the attempt fails, an
     * &lt;tt&gt;IllegalArgumentException&lt;/tt&gt; is thrown.
     * &lt;p&gt;
     * It accepts many syntaxes; in particular, it recognizes the IETF
     * standard date syntax: &quot;Sat, 12 Aug 1995 13:30:00 GMT&quot;. It also
     * understands the continental U.S. time-zone abbreviations, but for
     * general use, a time-zone offset should be used: &quot;Sat, 12 Aug 1995
     * 13:30:00 GMT+0430&quot; (4 hours, 30 minutes west of the Greenwich
     * meridian). If no time zone is specified, the local time zone is
     * assumed. GMT and UTC are considered equivalent.
     * &lt;p&gt;
     * The string &lt;tt&gt;s&lt;/tt&gt; is processed from left to right, looking for
     * data of interest. Any material in &lt;tt&gt;s&lt;/tt&gt; that is within the
     * ASCII parenthesis characters &lt;tt&gt;(&lt;/tt&gt; and &lt;tt&gt;)&lt;/tt&gt; is ignored.
     * Parentheses may be nested. Otherwise, the only characters permitted
     * within &lt;tt&gt;s&lt;/tt&gt; are these ASCII characters:
     * &lt;blockquote&gt;&lt;pre&gt;
     * abcdefghijklmnopqrstuvwxyz
     * ABCDEFGHIJKLMNOPQRSTUVWXYZ
     * 0123456789,+-:/&lt;/pre&gt;&lt;/blockquote&gt;
     * and whitespace characters.&lt;p&gt;
     * A consecutive sequence of decimal digits is treated as a decimal
     * number:&lt;ul&gt;
     * &lt;li&gt;If a number is preceded by &lt;tt&gt;+&lt;/tt&gt; or &lt;tt&gt;-&lt;/tt&gt; and a year
     *     has already been recognized, then the number is a time-zone
     *     offset. If the number is less than 24, it is an offset measured
     *     in hours. Otherwise, it is regarded as an offset in minutes,
     *     expressed in 24-hour time format without punctuation. A
     *     preceding &lt;tt&gt;-&lt;/tt&gt; means a westward offset. Time zone offsets
     *     are always relative to UTC (Greenwich). Thus, for example,
     *     &lt;tt&gt;-5&lt;/tt&gt; occurring in the string would mean &quot;five hours west
     *     of Greenwich&quot; and &lt;tt&gt;+0430&lt;/tt&gt; would mean &quot;four hours and
     *     thirty minutes east of Greenwich.&quot; It is permitted for the
     *     string to specify &lt;tt&gt;GMT&lt;/tt&gt;, &lt;tt&gt;UT&lt;/tt&gt;, or &lt;tt&gt;UTC&lt;/tt&gt;
     *     redundantly-for example, &lt;tt&gt;GMT-5&lt;/tt&gt; or &lt;tt&gt;utc+0430&lt;/tt&gt;.
     * &lt;li&gt;The number is regarded as a year number if one of the
     *     following conditions is true:
     * &lt;ul&gt;
     *     &lt;li&gt;The number is equal to or greater than 70 and followed by a
     *         space, comma, slash, or end of string
     *     &lt;li&gt;The number is less than 70, and both a month and a day of
     *         the month have already been recognized&lt;/li&gt;
     * &lt;/ul&gt;
     *     If the recognized year number is less than 100, it is
     *     interpreted as an abbreviated year relative to a century of
     *     which dates are within 80 years before and 19 years after
     *     the time when the Date class is initialized.
     *     After adjusting the year number, 1900 is subtracted from
     *     it. For example, if the current year is 1999 then years in
     *     the range 19 to 99 are assumed to mean 1919 to 1999, while
     *     years from 0 to 18 are assumed to mean 2000 to 2018.  Note
     *     that this is slightly different from the interpretation of
     *     years less than 100 that is used in {@link java.text.SimpleDateFormat}.
     * &lt;li&gt;If the number is followed by a colon, it is regarded as an hour,
     *     unless an hour has already been recognized, in which case it is
     *     regarded as a minute.
     * &lt;li&gt;If the number is followed by a slash, it is regarded as a month
     *     (it is decreased by 1 to produce a number in the range &lt;tt&gt;0&lt;/tt&gt;
     *     to &lt;tt&gt;11&lt;/tt&gt;), unless a month has already been recognized, in
     *     which case it is regarded as a day of the month.
     * &lt;li&gt;If the number is followed by whitespace, a comma, a hyphen, or
     *     end of string, then if an hour has been recognized but not a
     *     minute, it is regarded as a minute; otherwise, if a minute has
     *     been recognized but not a second, it is regarded as a second;
     *     otherwise, it is regarded as a day of the month. &lt;/ul&gt;&lt;p&gt;
     * A consecutive sequence of letters is regarded as a word and treated
     * as follows:&lt;ul&gt;
     * &lt;li&gt;A word that matches &lt;tt&gt;AM&lt;/tt&gt;, ignoring case, is ignored (but
     *     the parse fails if an hour has not been recognized or is less
     *     than &lt;tt&gt;1&lt;/tt&gt; or greater than &lt;tt&gt;12&lt;/tt&gt;).
     * &lt;li&gt;A word that matches &lt;tt&gt;PM&lt;/tt&gt;, ignoring case, adds &lt;tt&gt;12&lt;/tt&gt;
     *     to the hour (but the parse fails if an hour has not been
     *     recognized or is less than &lt;tt&gt;1&lt;/tt&gt; or greater than &lt;tt&gt;12&lt;/tt&gt;).
     * &lt;li&gt;Any word that matches any prefix of &lt;tt&gt;SUNDAY, MONDAY, TUESDAY,
     *     WEDNESDAY, THURSDAY, FRIDAY&lt;/tt&gt;, or &lt;tt&gt;SATURDAY&lt;/tt&gt;, ignoring
     *     case, is ignored. For example, &lt;tt&gt;sat, Friday, TUE&lt;/tt&gt;, and
     *     &lt;tt&gt;Thurs&lt;/tt&gt; are ignored.
     * &lt;li&gt;Otherwise, any word that matches any prefix of &lt;tt&gt;JANUARY,
     *     FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER,
     *     OCTOBER, NOVEMBER&lt;/tt&gt;, or &lt;tt&gt;DECEMBER&lt;/tt&gt;, ignoring case, and
     *     considering them in the order given here, is recognized as
     *     specifying a month and is converted to a number (&lt;tt&gt;0&lt;/tt&gt; to
     *     &lt;tt&gt;11&lt;/tt&gt;). For example, &lt;tt&gt;aug, Sept, april&lt;/tt&gt;, and
     *     &lt;tt&gt;NOV&lt;/tt&gt; are recognized as months. So is &lt;tt&gt;Ma&lt;/tt&gt;, which
     *     is recognized as &lt;tt&gt;MARCH&lt;/tt&gt;, not &lt;tt&gt;MAY&lt;/tt&gt;.
     * &lt;li&gt;Any word that matches &lt;tt&gt;GMT, UT&lt;/tt&gt;, or &lt;tt&gt;UTC&lt;/tt&gt;, ignoring
     *     case, is treated as referring to UTC.
     * &lt;li&gt;Any word that matches &lt;tt&gt;EST, CST, MST&lt;/tt&gt;, or &lt;tt&gt;PST&lt;/tt&gt;,
     *     ignoring case, is recognized as referring to the time zone in
     *     North America that is five, six, seven, or eight hours west of
     *     Greenwich, respectively. Any word that matches &lt;tt&gt;EDT, CDT,
     *     MDT&lt;/tt&gt;, or &lt;tt&gt;PDT&lt;/tt&gt;, ignoring case, is recognized as
     *     referring to the same time zone, respectively, during daylight
     *     saving time.&lt;/ul&gt;&lt;p&gt;
     * Once the entire string s has been scanned, it is converted to a time
     * result in one of two ways. If a time zone or time-zone offset has been
     * recognized, then the year, month, day of month, hour, minute, and
     * second are interpreted in UTC and then the time-zone offset is
     * applied. Otherwise, the year, month, day of month, hour, minute, and
     * second are interpreted in the local time zone.
     *
     * @param   s   a string to be parsed as a date.
     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT
     *          represented by the string argument.
     * @see     java.text.DateFormat
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;DateFormat.parse(String s)&lt;/code&gt;.
     */
    @Deprecated
    public static long parse(String s) {
<span class="fc" id="L455">        int year = Integer.MIN_VALUE;</span>
<span class="fc" id="L456">        int mon = -1;</span>
<span class="fc" id="L457">        int mday = -1;</span>
<span class="fc" id="L458">        int hour = -1;</span>
<span class="fc" id="L459">        int min = -1;</span>
<span class="fc" id="L460">        int sec = -1;</span>
<span class="fc" id="L461">        int millis = -1;</span>
<span class="fc" id="L462">        int c = -1;</span>
<span class="fc" id="L463">        int i = 0;</span>
<span class="fc" id="L464">        int n = -1;</span>
<span class="fc" id="L465">        int wst = -1;</span>
<span class="fc" id="L466">        int tzoffset = -1;</span>
<span class="fc" id="L467">        int prevc = 0;</span>
    syntax:
        {
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">            if (s == null)</span>
<span class="nc" id="L471">                break syntax;</span>
<span class="fc" id="L472">            int limit = s.length();</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">            while (i &lt; limit) {</span>
<span class="fc" id="L474">                c = s.charAt(i);</span>
<span class="fc" id="L475">                i++;</span>
<span class="fc bfc" id="L476" title="All 4 branches covered.">                if (c &lt;= ' ' || c == ',')</span>
<span class="fc" id="L477">                    continue;</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">                if (c == '(') { // skip comments</span>
<span class="nc" id="L479">                    int depth = 1;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">                    while (i &lt; limit) {</span>
<span class="nc" id="L481">                        c = s.charAt(i);</span>
<span class="nc" id="L482">                        i++;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                        if (c == '(') depth++;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                        else if (c == ')')</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">                            if (--depth &lt;= 0)</span>
<span class="nc" id="L486">                                break;</span>
                    }
                    continue;
                }
<span class="pc bpc" id="L490" title="1 of 4 branches missed.">                if ('0' &lt;= c &amp;&amp; c &lt;= '9') {</span>
<span class="fc" id="L491">                    n = c - '0';</span>
<span class="pc bpc" id="L492" title="1 of 6 branches missed.">                    while (i &lt; limit &amp;&amp; '0' &lt;= (c = s.charAt(i)) &amp;&amp; c &lt;= '9') {</span>
<span class="fc" id="L493">                        n = n * 10 + c - '0';</span>
<span class="fc" id="L494">                        i++;</span>
                    }
<span class="pc bpc" id="L496" title="4 of 6 branches missed.">                    if (prevc == '+' || prevc == '-' &amp;&amp; year != Integer.MIN_VALUE) {</span>
                        // timezone offset
<span class="nc bnc" id="L498" title="All 2 branches missed.">                        if (n &lt; 24)</span>
<span class="nc" id="L499">                            n = n * 60; // EG. &quot;GMT-3&quot;</span>
                        else
<span class="nc" id="L501">                            n = n % 100 + n / 100 * 60; // eg &quot;GMT-0430&quot;</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                        if (prevc == '+')   // plus means east of GMT</span>
<span class="nc" id="L503">                            n = -n;</span>
<span class="nc bnc" id="L504" title="All 4 branches missed.">                        if (tzoffset != 0 &amp;&amp; tzoffset != -1)</span>
<span class="nc" id="L505">                            break syntax;</span>
<span class="nc" id="L506">                        tzoffset = n;</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">                    } else if (n &gt;= 70)</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">                        if (year != Integer.MIN_VALUE)</span>
<span class="nc" id="L509">                            break syntax;</span>
<span class="pc bpc" id="L510" title="7 of 8 branches missed.">                        else if (c &lt;= ' ' || c == ',' || c == '/' || i &gt;= limit)</span>
                            // year = n &lt; 1900 ? n : n - 1900;
<span class="fc" id="L512">                            year = n;</span>
                        else
                            break syntax;
<span class="fc bfc" id="L515" title="All 2 branches covered.">                    else if (c == ':')</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                        if (hour &lt; 0)</span>
<span class="fc" id="L517">                            hour = (byte) n;</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">                        else if (min &lt; 0)</span>
<span class="fc" id="L519">                            min = (byte) n;</span>
                        else
                            break syntax;
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">                    else if (c == '/')</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">                        if (mon &lt; 0)</span>
<span class="nc" id="L524">                            mon = (byte) (n - 1);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                        else if (mday &lt; 0)</span>
<span class="nc" id="L526">                            mday = (byte) n;</span>
                        else
                            break syntax;
<span class="pc bpc" id="L529" title="5 of 8 branches missed.">                    else if (i &lt; limit &amp;&amp; c != ',' &amp;&amp; c &gt; ' ' &amp;&amp; c != '-')</span>
<span class="nc" id="L530">                        break syntax;</span>
<span class="pc bpc" id="L531" title="1 of 4 branches missed.">                    else if (hour &gt;= 0 &amp;&amp; min &lt; 0)</span>
<span class="nc" id="L532">                        min = (byte) n;</span>
<span class="pc bpc" id="L533" title="1 of 4 branches missed.">                    else if (min &gt;= 0 &amp;&amp; sec &lt; 0)</span>
<span class="fc" id="L534">                        sec = (byte) n;</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">                    else if (mday &lt; 0)</span>
<span class="fc" id="L536">                        mday = (byte) n;</span>
                    // Handle two-digit years &lt; 70 (70-99 handled above).
<span class="nc bnc" id="L538" title="All 6 branches missed.">                    else if (year == Integer.MIN_VALUE &amp;&amp; mon &gt;= 0 &amp;&amp; mday &gt;= 0)</span>
<span class="nc" id="L539">                        year = n;</span>
                    else
                        break syntax;
<span class="fc" id="L542">                    prevc = 0;</span>
<span class="pc bpc" id="L543" title="3 of 8 branches missed.">                } else if (c == '/' || c == ':' || c == '+' || c == '-')</span>
<span class="fc" id="L544">                    prevc = c;</span>
                else {
<span class="fc" id="L546">                    int st = i - 1;</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">                    while (i &lt; limit) {</span>
<span class="fc" id="L548">                        c = s.charAt(i);</span>
<span class="pc bpc" id="L549" title="1 of 8 branches missed.">                        if (!('A' &lt;= c &amp;&amp; c &lt;= 'Z' || 'a' &lt;= c &amp;&amp; c &lt;= 'z'))</span>
<span class="nc" id="L550">                            break;</span>
<span class="fc" id="L551">                        i++;</span>
                    }
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                    if (i &lt;= st + 1)</span>
<span class="nc" id="L554">                        break syntax;</span>
                    int k;
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">                    for (k = wtb.length; --k &gt;= 0;)</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">                        if (wtb[k].regionMatches(true, 0, s, st, i - st)) {</span>
<span class="fc" id="L558">                            int action = ttb[k];</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">                            if (action != 0) {</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">                                if (action == 1) {  // pm</span>
<span class="nc bnc" id="L561" title="All 4 branches missed.">                                    if (hour &gt; 12 || hour &lt; 1)</span>
<span class="nc" id="L562">                                        break syntax;</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">                                    else if (hour &lt; 12)</span>
<span class="nc" id="L564">                                        hour += 12;</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">                                } else if (action == 14) {  // am</span>
<span class="nc bnc" id="L566" title="All 4 branches missed.">                                    if (hour &gt; 12 || hour &lt; 1)</span>
<span class="nc" id="L567">                                        break syntax;</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">                                    else if (hour == 12)</span>
<span class="nc" id="L569">                                        hour = 0;</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">                                } else if (action &lt;= 13) {  // month!</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">                                    if (mon &lt; 0)</span>
<span class="fc" id="L572">                                        mon = (byte) (action - 2);</span>
                                    else
                                        break syntax;
                                } else {
<span class="fc" id="L576">                                    tzoffset = action - 10000;</span>
                                }
                            }
                            break;
                        }
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">                    if (k &lt; 0)</span>
<span class="nc" id="L582">                        break syntax;</span>
<span class="fc" id="L583">                    prevc = 0;</span>
<span class="fc" id="L584">                }</span>
            }
<span class="pc bpc" id="L586" title="3 of 6 branches missed.">            if (year == Integer.MIN_VALUE || mon &lt; 0 || mday &lt; 0)</span>
<span class="nc" id="L587">                break syntax;</span>
            // Parse 2-digit years within the correct default century.
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">            if (year &lt; 100) {</span>
<span class="nc" id="L590">                synchronized (Date.class) {</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">                    if (defaultCenturyStart == 0) {</span>
<span class="nc" id="L592">                        defaultCenturyStart = gcal.getCalendarDate().getYear() - 80;</span>
                    }
<span class="nc" id="L594">                }</span>
<span class="nc" id="L595">                year += (defaultCenturyStart / 100) * 100;</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                if (year &lt; defaultCenturyStart) year += 100;</span>
            }
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">            if (sec &lt; 0)</span>
<span class="nc" id="L599">                sec = 0;</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">            if (min &lt; 0)</span>
<span class="nc" id="L601">                min = 0;</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">            if (hour &lt; 0)</span>
<span class="nc" id="L603">                hour = 0;</span>
<span class="fc" id="L604">            BaseCalendar cal = getCalendarSystem(year);</span>
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">            if (tzoffset == -1)  { // no time zone specified, have to use local</span>
<span class="nc" id="L606">                BaseCalendar.Date ldate = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.getDefaultRef());</span>
<span class="nc" id="L607">                ldate.setDate(year, mon + 1, mday);</span>
<span class="nc" id="L608">                ldate.setTimeOfDay(hour, min, sec, 0);</span>
<span class="nc" id="L609">                return cal.getTime(ldate);</span>
            }
<span class="fc" id="L611">            BaseCalendar.Date udate = (BaseCalendar.Date) cal.newCalendarDate(null); // no time zone</span>
<span class="fc" id="L612">            udate.setDate(year, mon + 1, mday);</span>
<span class="fc" id="L613">            udate.setTimeOfDay(hour, min, sec, 0);</span>
<span class="fc" id="L614">            return cal.getTime(udate) + tzoffset * (60 * 1000);</span>
        }
        // syntax error
<span class="nc" id="L617">        throw new IllegalArgumentException();</span>
    }
<span class="fc" id="L619">    private final static String wtb[] = {</span>
        &quot;am&quot;, &quot;pm&quot;,
        &quot;monday&quot;, &quot;tuesday&quot;, &quot;wednesday&quot;, &quot;thursday&quot;, &quot;friday&quot;,
        &quot;saturday&quot;, &quot;sunday&quot;,
        &quot;january&quot;, &quot;february&quot;, &quot;march&quot;, &quot;april&quot;, &quot;may&quot;, &quot;june&quot;,
        &quot;july&quot;, &quot;august&quot;, &quot;september&quot;, &quot;october&quot;, &quot;november&quot;, &quot;december&quot;,
        &quot;gmt&quot;, &quot;ut&quot;, &quot;utc&quot;, &quot;est&quot;, &quot;edt&quot;, &quot;cst&quot;, &quot;cdt&quot;,
        &quot;mst&quot;, &quot;mdt&quot;, &quot;pst&quot;, &quot;pdt&quot;
    };
<span class="fc" id="L628">    private final static int ttb[] = {</span>
        14, 1, 0, 0, 0, 0, 0, 0, 0,
        2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
        10000 + 0, 10000 + 0, 10000 + 0,    // GMT/UT/UTC
        10000 + 5 * 60, 10000 + 4 * 60,     // EST/EDT
        10000 + 6 * 60, 10000 + 5 * 60,     // CST/CDT
        10000 + 7 * 60, 10000 + 6 * 60,     // MST/MDT
        10000 + 8 * 60, 10000 + 7 * 60      // PST/PDT
    };

    /**
     * Returns a value that is the result of subtracting 1900 from the
     * year that contains or begins with the instant in time represented
     * by this &lt;code&gt;Date&lt;/code&gt; object, as interpreted in the local
     * time zone.
     *
     * @return  the year represented by this date, minus 1900.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.get(Calendar.YEAR) - 1900&lt;/code&gt;.
     */
    @Deprecated
    public int getYear() {
<span class="fc" id="L651">        return normalize().getYear() - 1900;</span>
    }

    /**
     * Sets the year of this &lt;tt&gt;Date&lt;/tt&gt; object to be the specified
     * value plus 1900. This &lt;code&gt;Date&lt;/code&gt; object is modified so
     * that it represents a point in time within the specified year,
     * with the month, date, hour, minute, and second the same as
     * before, as interpreted in the local time zone. (Of course, if
     * the date was February 29, for example, and the year is set to a
     * non-leap year, then the new date will be treated as if it were
     * on March 1.)
     *
     * @param   year    the year value.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.set(Calendar.YEAR, year + 1900)&lt;/code&gt;.
     */
    @Deprecated
    public void setYear(int year) {
<span class="nc" id="L671">        getCalendarDate().setNormalizedYear(year + 1900);</span>
<span class="nc" id="L672">    }</span>

    /**
     * Returns a number representing the month that contains or begins
     * with the instant in time represented by this &lt;tt&gt;Date&lt;/tt&gt; object.
     * The value returned is between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;11&lt;/code&gt;,
     * with the value &lt;code&gt;0&lt;/code&gt; representing January.
     *
     * @return  the month represented by this date.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.get(Calendar.MONTH)&lt;/code&gt;.
     */
    @Deprecated
    public int getMonth() {
<span class="fc" id="L687">        return normalize().getMonth() - 1; // adjust 1-based to 0-based</span>
    }

    /**
     * Sets the month of this date to the specified value. This
     * &lt;tt&gt;Date&lt;/tt&gt; object is modified so that it represents a point
     * in time within the specified month, with the year, date, hour,
     * minute, and second the same as before, as interpreted in the
     * local time zone. If the date was October 31, for example, and
     * the month is set to June, then the new date will be treated as
     * if it were on July 1, because June has only 30 days.
     *
     * @param   month   the month value between 0-11.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.set(Calendar.MONTH, int month)&lt;/code&gt;.
     */
    @Deprecated
    public void setMonth(int month) {
<span class="nc" id="L706">        int y = 0;</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (month &gt;= 12) {</span>
<span class="nc" id="L708">            y = month / 12;</span>
<span class="nc" id="L709">            month %= 12;</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        } else if (month &lt; 0) {</span>
<span class="nc" id="L711">            y = CalendarUtils.floorDivide(month, 12);</span>
<span class="nc" id="L712">            month = CalendarUtils.mod(month, 12);</span>
        }
<span class="nc" id="L714">        BaseCalendar.Date d = getCalendarDate();</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">        if (y != 0) {</span>
<span class="nc" id="L716">            d.setNormalizedYear(d.getNormalizedYear() + y);</span>
        }
<span class="nc" id="L718">        d.setMonth(month + 1); // adjust 0-based to 1-based month numbering</span>
<span class="nc" id="L719">    }</span>

    /**
     * Returns the day of the month represented by this &lt;tt&gt;Date&lt;/tt&gt; object.
     * The value returned is between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;31&lt;/code&gt;
     * representing the day of the month that contains or begins with the
     * instant in time represented by this &lt;tt&gt;Date&lt;/tt&gt; object, as
     * interpreted in the local time zone.
     *
     * @return  the day of the month represented by this date.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.get(Calendar.DAY_OF_MONTH)&lt;/code&gt;.
     * @deprecated
     */
    @Deprecated
    public int getDate() {
<span class="fc" id="L736">        return normalize().getDayOfMonth();</span>
    }

    /**
     * Sets the day of the month of this &lt;tt&gt;Date&lt;/tt&gt; object to the
     * specified value. This &lt;tt&gt;Date&lt;/tt&gt; object is modified so that
     * it represents a point in time within the specified day of the
     * month, with the year, month, hour, minute, and second the same
     * as before, as interpreted in the local time zone. If the date
     * was April 30, for example, and the date is set to 31, then it
     * will be treated as if it were on May 1, because April has only
     * 30 days.
     *
     * @param   date   the day of the month value between 1-31.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.set(Calendar.DAY_OF_MONTH, int date)&lt;/code&gt;.
     */
    @Deprecated
    public void setDate(int date) {
<span class="nc" id="L756">        getCalendarDate().setDayOfMonth(date);</span>
<span class="nc" id="L757">    }</span>

    /**
     * Returns the day of the week represented by this date. The
     * returned value (&lt;tt&gt;0&lt;/tt&gt; = Sunday, &lt;tt&gt;1&lt;/tt&gt; = Monday,
     * &lt;tt&gt;2&lt;/tt&gt; = Tuesday, &lt;tt&gt;3&lt;/tt&gt; = Wednesday, &lt;tt&gt;4&lt;/tt&gt; =
     * Thursday, &lt;tt&gt;5&lt;/tt&gt; = Friday, &lt;tt&gt;6&lt;/tt&gt; = Saturday)
     * represents the day of the week that contains or begins with
     * the instant in time represented by this &lt;tt&gt;Date&lt;/tt&gt; object,
     * as interpreted in the local time zone.
     *
     * @return  the day of the week represented by this date.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.get(Calendar.DAY_OF_WEEK)&lt;/code&gt;.
     */
    @Deprecated
    public int getDay() {
<span class="nc" id="L775">        return normalize().getDayOfWeek() - BaseCalendar.SUNDAY;</span>
    }

    /**
     * Returns the hour represented by this &lt;tt&gt;Date&lt;/tt&gt; object. The
     * returned value is a number (&lt;tt&gt;0&lt;/tt&gt; through &lt;tt&gt;23&lt;/tt&gt;)
     * representing the hour within the day that contains or begins
     * with the instant in time represented by this &lt;tt&gt;Date&lt;/tt&gt;
     * object, as interpreted in the local time zone.
     *
     * @return  the hour represented by this date.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.get(Calendar.HOUR_OF_DAY)&lt;/code&gt;.
     */
    @Deprecated
    public int getHours() {
<span class="fc" id="L792">        return normalize().getHours();</span>
    }

    /**
     * Sets the hour of this &lt;tt&gt;Date&lt;/tt&gt; object to the specified value.
     * This &lt;tt&gt;Date&lt;/tt&gt; object is modified so that it represents a point
     * in time within the specified hour of the day, with the year, month,
     * date, minute, and second the same as before, as interpreted in the
     * local time zone.
     *
     * @param   hours   the hour value.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.set(Calendar.HOUR_OF_DAY, int hours)&lt;/code&gt;.
     */
    @Deprecated
    public void setHours(int hours) {
<span class="nc" id="L809">        getCalendarDate().setHours(hours);</span>
<span class="nc" id="L810">    }</span>

    /**
     * Returns the number of minutes past the hour represented by this date,
     * as interpreted in the local time zone.
     * The value returned is between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;59&lt;/code&gt;.
     *
     * @return  the number of minutes past the hour represented by this date.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.get(Calendar.MINUTE)&lt;/code&gt;.
     */
    @Deprecated
    public int getMinutes() {
<span class="fc" id="L824">        return normalize().getMinutes();</span>
    }

    /**
     * Sets the minutes of this &lt;tt&gt;Date&lt;/tt&gt; object to the specified value.
     * This &lt;tt&gt;Date&lt;/tt&gt; object is modified so that it represents a point
     * in time within the specified minute of the hour, with the year, month,
     * date, hour, and second the same as before, as interpreted in the
     * local time zone.
     *
     * @param   minutes   the value of the minutes.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.set(Calendar.MINUTE, int minutes)&lt;/code&gt;.
     */
    @Deprecated
    public void setMinutes(int minutes) {
<span class="nc" id="L841">        getCalendarDate().setMinutes(minutes);</span>
<span class="nc" id="L842">    }</span>

    /**
     * Returns the number of seconds past the minute represented by this date.
     * The value returned is between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;61&lt;/code&gt;. The
     * values &lt;code&gt;60&lt;/code&gt; and &lt;code&gt;61&lt;/code&gt; can only occur on those
     * Java Virtual Machines that take leap seconds into account.
     *
     * @return  the number of seconds past the minute represented by this date.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.get(Calendar.SECOND)&lt;/code&gt;.
     */
    @Deprecated
    public int getSeconds() {
<span class="fc" id="L857">        return normalize().getSeconds();</span>
    }

    /**
     * Sets the seconds of this &lt;tt&gt;Date&lt;/tt&gt; to the specified value.
     * This &lt;tt&gt;Date&lt;/tt&gt; object is modified so that it represents a
     * point in time within the specified second of the minute, with
     * the year, month, date, hour, and minute the same as before, as
     * interpreted in the local time zone.
     *
     * @param   seconds   the seconds value.
     * @see     java.util.Calendar
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;Calendar.set(Calendar.SECOND, int seconds)&lt;/code&gt;.
     */
    @Deprecated
    public void setSeconds(int seconds) {
<span class="nc" id="L874">        getCalendarDate().setSeconds(seconds);</span>
<span class="nc" id="L875">    }</span>

    /**
     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT
     * represented by this &lt;tt&gt;Date&lt;/tt&gt; object.
     *
     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT
     *          represented by this date.
     */
    public long getTime() {
<span class="fc" id="L885">        return getTimeImpl();</span>
    }

    private final long getTimeImpl() {
<span class="fc bfc" id="L889" title="All 4 branches covered.">        if (cdate != null &amp;&amp; !cdate.isNormalized()) {</span>
<span class="fc" id="L890">            normalize();</span>
        }
<span class="fc" id="L892">        return fastTime;</span>
    }

    /**
     * Sets this &lt;code&gt;Date&lt;/code&gt; object to represent a point in time that is
     * &lt;code&gt;time&lt;/code&gt; milliseconds after January 1, 1970 00:00:00 GMT.
     *
     * @param   time   the number of milliseconds.
     */
    public void setTime(long time) {
<span class="fc" id="L902">        fastTime = time;</span>
<span class="fc" id="L903">        cdate = null;</span>
<span class="fc" id="L904">    }</span>

    /**
     * Tests if this date is before the specified date.
     *
     * @param   when   a date.
     * @return  &lt;code&gt;true&lt;/code&gt; if and only if the instant of time
     *            represented by this &lt;tt&gt;Date&lt;/tt&gt; object is strictly
     *            earlier than the instant represented by &lt;tt&gt;when&lt;/tt&gt;;
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     * @exception NullPointerException if &lt;code&gt;when&lt;/code&gt; is null.
     */
    public boolean before(Date when) {
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">        return getMillisOf(this) &lt; getMillisOf(when);</span>
    }

    /**
     * Tests if this date is after the specified date.
     *
     * @param   when   a date.
     * @return  &lt;code&gt;true&lt;/code&gt; if and only if the instant represented
     *          by this &lt;tt&gt;Date&lt;/tt&gt; object is strictly later than the
     *          instant represented by &lt;tt&gt;when&lt;/tt&gt;;
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     * @exception NullPointerException if &lt;code&gt;when&lt;/code&gt; is null.
     */
    public boolean after(Date when) {
<span class="fc bfc" id="L931" title="All 2 branches covered.">        return getMillisOf(this) &gt; getMillisOf(when);</span>
    }

    /**
     * Compares two dates for equality.
     * The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is
     * not &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;Date&lt;/code&gt; object that
     * represents the same point in time, to the millisecond, as this object.
     * &lt;p&gt;
     * Thus, two &lt;code&gt;Date&lt;/code&gt; objects are equal if and only if the
     * &lt;code&gt;getTime&lt;/code&gt; method returns the same &lt;code&gt;long&lt;/code&gt;
     * value for both.
     *
     * @param   obj   the object to compare with.
     * @return  &lt;code&gt;true&lt;/code&gt; if the objects are the same;
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see     java.util.Date#getTime()
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L950" title="1 of 4 branches missed.">        return obj instanceof Date &amp;&amp; getTime() == ((Date) obj).getTime();</span>
    }

    /**
     * Returns the millisecond value of this &lt;code&gt;Date&lt;/code&gt; object
     * without affecting its internal state.
     */
    static final long getMillisOf(Date date) {
<span class="pc bpc" id="L958" title="3 of 4 branches missed.">        if (date.cdate == null || date.cdate.isNormalized()) {</span>
<span class="fc" id="L959">            return date.fastTime;</span>
        }
<span class="nc" id="L961">        BaseCalendar.Date d = (BaseCalendar.Date) date.cdate.clone();</span>
<span class="nc" id="L962">        return gcal.getTime(d);</span>
    }

    /**
     * Compares two Dates for ordering.
     *
     * @param   anotherDate   the &lt;code&gt;Date&lt;/code&gt; to be compared.
     * @return  the value &lt;code&gt;0&lt;/code&gt; if the argument Date is equal to
     *          this Date; a value less than &lt;code&gt;0&lt;/code&gt; if this Date
     *          is before the Date argument; and a value greater than
     *      &lt;code&gt;0&lt;/code&gt; if this Date is after the Date argument.
     * @since   1.2
     * @exception NullPointerException if &lt;code&gt;anotherDate&lt;/code&gt; is null.
     */
    public int compareTo(Date anotherDate) {
<span class="nc" id="L977">        long thisTime = getMillisOf(this);</span>
<span class="nc" id="L978">        long anotherTime = getMillisOf(anotherDate);</span>
<span class="nc bnc" id="L979" title="All 4 branches missed.">        return (thisTime&lt;anotherTime ? -1 : (thisTime==anotherTime ? 0 : 1));</span>
    }

    /**
     * Returns a hash code value for this object. The result is the
     * exclusive OR of the two halves of the primitive &lt;tt&gt;long&lt;/tt&gt;
     * value returned by the {@link Date#getTime}
     * method. That is, the hash code is the value of the expression:
     * &lt;blockquote&gt;&lt;pre&gt;{@code
     * (int)(this.getTime()^(this.getTime() &gt;&gt;&gt; 32))
     * }&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return  a hash code value for this object.
     */
    public int hashCode() {
<span class="fc" id="L994">        long ht = this.getTime();</span>
<span class="fc" id="L995">        return (int) ht ^ (int) (ht &gt;&gt; 32);</span>
    }

    /**
     * Converts this &lt;code&gt;Date&lt;/code&gt; object to a &lt;code&gt;String&lt;/code&gt;
     * of the form:
     * &lt;blockquote&gt;&lt;pre&gt;
     * dow mon dd hh:mm:ss zzz yyyy&lt;/pre&gt;&lt;/blockquote&gt;
     * where:&lt;ul&gt;
     * &lt;li&gt;&lt;tt&gt;dow&lt;/tt&gt; is the day of the week (&lt;tt&gt;Sun, Mon, Tue, Wed,
     *     Thu, Fri, Sat&lt;/tt&gt;).
     * &lt;li&gt;&lt;tt&gt;mon&lt;/tt&gt; is the month (&lt;tt&gt;Jan, Feb, Mar, Apr, May, Jun,
     *     Jul, Aug, Sep, Oct, Nov, Dec&lt;/tt&gt;).
     * &lt;li&gt;&lt;tt&gt;dd&lt;/tt&gt; is the day of the month (&lt;tt&gt;01&lt;/tt&gt; through
     *     &lt;tt&gt;31&lt;/tt&gt;), as two decimal digits.
     * &lt;li&gt;&lt;tt&gt;hh&lt;/tt&gt; is the hour of the day (&lt;tt&gt;00&lt;/tt&gt; through
     *     &lt;tt&gt;23&lt;/tt&gt;), as two decimal digits.
     * &lt;li&gt;&lt;tt&gt;mm&lt;/tt&gt; is the minute within the hour (&lt;tt&gt;00&lt;/tt&gt; through
     *     &lt;tt&gt;59&lt;/tt&gt;), as two decimal digits.
     * &lt;li&gt;&lt;tt&gt;ss&lt;/tt&gt; is the second within the minute (&lt;tt&gt;00&lt;/tt&gt; through
     *     &lt;tt&gt;61&lt;/tt&gt;, as two decimal digits.
     * &lt;li&gt;&lt;tt&gt;zzz&lt;/tt&gt; is the time zone (and may reflect daylight saving
     *     time). Standard time zone abbreviations include those
     *     recognized by the method &lt;tt&gt;parse&lt;/tt&gt;. If time zone
     *     information is not available, then &lt;tt&gt;zzz&lt;/tt&gt; is empty -
     *     that is, it consists of no characters at all.
     * &lt;li&gt;&lt;tt&gt;yyyy&lt;/tt&gt; is the year, as four decimal digits.
     * &lt;/ul&gt;
     *
     * @return  a string representation of this date.
     * @see     java.util.Date#toLocaleString()
     * @see     java.util.Date#toGMTString()
     */
    public String toString() {
        // &quot;EEE MMM dd HH:mm:ss zzz yyyy&quot;;
<span class="fc" id="L1030">        BaseCalendar.Date date = normalize();</span>
<span class="fc" id="L1031">        StringBuilder sb = new StringBuilder(28);</span>
<span class="fc" id="L1032">        int index = date.getDayOfWeek();</span>
<span class="fc bfc" id="L1033" title="All 2 branches covered.">        if (index == BaseCalendar.SUNDAY) {</span>
<span class="fc" id="L1034">            index = 8;</span>
        }
<span class="fc" id="L1036">        convertToAbbr(sb, wtb[index]).append(' ');                        // EEE</span>
<span class="fc" id="L1037">        convertToAbbr(sb, wtb[date.getMonth() - 1 + 2 + 7]).append(' ');  // MMM</span>
<span class="fc" id="L1038">        CalendarUtils.sprintf0d(sb, date.getDayOfMonth(), 2).append(' '); // dd</span>

<span class="fc" id="L1040">        CalendarUtils.sprintf0d(sb, date.getHours(), 2).append(':');   // HH</span>
<span class="fc" id="L1041">        CalendarUtils.sprintf0d(sb, date.getMinutes(), 2).append(':'); // mm</span>
<span class="fc" id="L1042">        CalendarUtils.sprintf0d(sb, date.getSeconds(), 2).append(' '); // ss</span>
<span class="fc" id="L1043">        TimeZone zi = date.getZone();</span>
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">        if (zi != null) {</span>
<span class="fc" id="L1045">            sb.append(zi.getDisplayName(date.isDaylightTime(), TimeZone.SHORT, Locale.US)); // zzz</span>
        } else {
<span class="nc" id="L1047">            sb.append(&quot;GMT&quot;);</span>
        }
<span class="fc" id="L1049">        sb.append(' ').append(date.getYear());  // yyyy</span>
<span class="fc" id="L1050">        return sb.toString();</span>
    }

    /**
     * Converts the given name to its 3-letter abbreviation (e.g.,
     * &quot;monday&quot; -&gt; &quot;Mon&quot;) and stored the abbreviation in the given
     * &lt;code&gt;StringBuilder&lt;/code&gt;.
     */
    private static final StringBuilder convertToAbbr(StringBuilder sb, String name) {
<span class="fc" id="L1059">        sb.append(Character.toUpperCase(name.charAt(0)));</span>
<span class="fc" id="L1060">        sb.append(name.charAt(1)).append(name.charAt(2));</span>
<span class="fc" id="L1061">        return sb;</span>
    }

    /**
     * Creates a string representation of this &lt;tt&gt;Date&lt;/tt&gt; object in an
     * implementation-dependent form. The intent is that the form should
     * be familiar to the user of the Java application, wherever it may
     * happen to be running. The intent is comparable to that of the
     * &quot;&lt;code&gt;%c&lt;/code&gt;&quot; format supported by the &lt;code&gt;strftime()&lt;/code&gt;
     * function of ISO&amp;nbsp;C.
     *
     * @return  a string representation of this date, using the locale
     *          conventions.
     * @see     java.text.DateFormat
     * @see     java.util.Date#toString()
     * @see     java.util.Date#toGMTString()
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;DateFormat.format(Date date)&lt;/code&gt;.
     */
    @Deprecated
    public String toLocaleString() {
<span class="nc" id="L1082">        DateFormat formatter = DateFormat.getDateTimeInstance();</span>
<span class="nc" id="L1083">        return formatter.format(this);</span>
    }

    /**
     * Creates a string representation of this &lt;tt&gt;Date&lt;/tt&gt; object of
     * the form:
     * &lt;blockquote&gt;&lt;pre&gt;
     * d mon yyyy hh:mm:ss GMT&lt;/pre&gt;&lt;/blockquote&gt;
     * where:&lt;ul&gt;
     * &lt;li&gt;&lt;i&gt;d&lt;/i&gt; is the day of the month (&lt;tt&gt;1&lt;/tt&gt; through &lt;tt&gt;31&lt;/tt&gt;),
     *     as one or two decimal digits.
     * &lt;li&gt;&lt;i&gt;mon&lt;/i&gt; is the month (&lt;tt&gt;Jan, Feb, Mar, Apr, May, Jun, Jul,
     *     Aug, Sep, Oct, Nov, Dec&lt;/tt&gt;).
     * &lt;li&gt;&lt;i&gt;yyyy&lt;/i&gt; is the year, as four decimal digits.
     * &lt;li&gt;&lt;i&gt;hh&lt;/i&gt; is the hour of the day (&lt;tt&gt;00&lt;/tt&gt; through &lt;tt&gt;23&lt;/tt&gt;),
     *     as two decimal digits.
     * &lt;li&gt;&lt;i&gt;mm&lt;/i&gt; is the minute within the hour (&lt;tt&gt;00&lt;/tt&gt; through
     *     &lt;tt&gt;59&lt;/tt&gt;), as two decimal digits.
     * &lt;li&gt;&lt;i&gt;ss&lt;/i&gt; is the second within the minute (&lt;tt&gt;00&lt;/tt&gt; through
     *     &lt;tt&gt;61&lt;/tt&gt;), as two decimal digits.
     * &lt;li&gt;&lt;i&gt;GMT&lt;/i&gt; is exactly the ASCII letters &quot;&lt;tt&gt;GMT&lt;/tt&gt;&quot; to indicate
     *     Greenwich Mean Time.
     * &lt;/ul&gt;&lt;p&gt;
     * The result does not depend on the local time zone.
     *
     * @return  a string representation of this date, using the Internet GMT
     *          conventions.
     * @see     java.text.DateFormat
     * @see     java.util.Date#toString()
     * @see     java.util.Date#toLocaleString()
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;DateFormat.format(Date date)&lt;/code&gt;, using a
     * GMT &lt;code&gt;TimeZone&lt;/code&gt;.
     */
    @Deprecated
    public String toGMTString() {
        // d MMM yyyy HH:mm:ss 'GMT'
<span class="nc" id="L1120">        long t = getTime();</span>
<span class="nc" id="L1121">        BaseCalendar cal = getCalendarSystem(t);</span>
<span class="nc" id="L1122">        BaseCalendar.Date date =</span>
<span class="nc" id="L1123">            (BaseCalendar.Date) cal.getCalendarDate(getTime(), (TimeZone)null);</span>
<span class="nc" id="L1124">        StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1125">        CalendarUtils.sprintf0d(sb, date.getDayOfMonth(), 1).append(' '); // d</span>
<span class="nc" id="L1126">        convertToAbbr(sb, wtb[date.getMonth() - 1 + 2 + 7]).append(' ');  // MMM</span>
<span class="nc" id="L1127">        sb.append(date.getYear()).append(' ');                            // yyyy</span>
<span class="nc" id="L1128">        CalendarUtils.sprintf0d(sb, date.getHours(), 2).append(':');      // HH</span>
<span class="nc" id="L1129">        CalendarUtils.sprintf0d(sb, date.getMinutes(), 2).append(':');    // mm</span>
<span class="nc" id="L1130">        CalendarUtils.sprintf0d(sb, date.getSeconds(), 2);                // ss</span>
<span class="nc" id="L1131">        sb.append(&quot; GMT&quot;);                                                // ' GMT'</span>
<span class="nc" id="L1132">        return sb.toString();</span>
    }

    /**
     * Returns the offset, measured in minutes, for the local time zone
     * relative to UTC that is appropriate for the time represented by
     * this &lt;code&gt;Date&lt;/code&gt; object.
     * &lt;p&gt;
     * For example, in Massachusetts, five time zones west of Greenwich:
     * &lt;blockquote&gt;&lt;pre&gt;
     * new Date(96, 1, 14).getTimezoneOffset() returns 300&lt;/pre&gt;&lt;/blockquote&gt;
     * because on February 14, 1996, standard time (Eastern Standard Time)
     * is in use, which is offset five hours from UTC; but:
     * &lt;blockquote&gt;&lt;pre&gt;
     * new Date(96, 5, 1).getTimezoneOffset() returns 240&lt;/pre&gt;&lt;/blockquote&gt;
     * because on June 1, 1996, daylight saving time (Eastern Daylight Time)
     * is in use, which is offset only four hours from UTC.&lt;p&gt;
     * This method produces the same result as if it computed:
     * &lt;blockquote&gt;&lt;pre&gt;
     * (this.getTime() - UTC(this.getYear(),
     *                       this.getMonth(),
     *                       this.getDate(),
     *                       this.getHours(),
     *                       this.getMinutes(),
     *                       this.getSeconds())) / (60 * 1000)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return  the time-zone offset, in minutes, for the current time zone.
     * @see     java.util.Calendar#ZONE_OFFSET
     * @see     java.util.Calendar#DST_OFFSET
     * @see     java.util.TimeZone#getDefault
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;-(Calendar.get(Calendar.ZONE_OFFSET) +
     * Calendar.get(Calendar.DST_OFFSET)) / (60 * 1000)&lt;/code&gt;.
     */
    @Deprecated
    public int getTimezoneOffset() {
        int zoneOffset;
<span class="nc bnc" id="L1170" title="All 2 branches missed.">        if (cdate == null) {</span>
<span class="nc" id="L1171">            TimeZone tz = TimeZone.getDefaultRef();</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">            if (tz instanceof ZoneInfo) {</span>
<span class="nc" id="L1173">                zoneOffset = ((ZoneInfo)tz).getOffsets(fastTime, null);</span>
            } else {
<span class="nc" id="L1175">                zoneOffset = tz.getOffset(fastTime);</span>
            }
<span class="nc" id="L1177">        } else {</span>
<span class="nc" id="L1178">            normalize();</span>
<span class="nc" id="L1179">            zoneOffset = cdate.getZoneOffset();</span>
        }
<span class="nc" id="L1181">        return -zoneOffset/60000;  // convert to minutes</span>
    }

    private final BaseCalendar.Date getCalendarDate() {
<span class="nc bnc" id="L1185" title="All 2 branches missed.">        if (cdate == null) {</span>
<span class="nc" id="L1186">            BaseCalendar cal = getCalendarSystem(fastTime);</span>
<span class="nc" id="L1187">            cdate = (BaseCalendar.Date) cal.getCalendarDate(fastTime,</span>
<span class="nc" id="L1188">                                                            TimeZone.getDefaultRef());</span>
        }
<span class="nc" id="L1190">        return cdate;</span>
    }

    private final BaseCalendar.Date normalize() {
<span class="fc bfc" id="L1194" title="All 2 branches covered.">        if (cdate == null) {</span>
<span class="fc" id="L1195">            BaseCalendar cal = getCalendarSystem(fastTime);</span>
<span class="fc" id="L1196">            cdate = (BaseCalendar.Date) cal.getCalendarDate(fastTime,</span>
<span class="fc" id="L1197">                                                            TimeZone.getDefaultRef());</span>
<span class="fc" id="L1198">            return cdate;</span>
        }

        // Normalize cdate with the TimeZone in cdate first. This is
        // required for the compatible behavior.
<span class="fc bfc" id="L1203" title="All 2 branches covered.">        if (!cdate.isNormalized()) {</span>
<span class="fc" id="L1204">            cdate = normalize(cdate);</span>
        }

        // If the default TimeZone has changed, then recalculate the
        // fields with the new TimeZone.
<span class="fc" id="L1209">        TimeZone tz = TimeZone.getDefaultRef();</span>
<span class="pc bpc" id="L1210" title="1 of 2 branches missed.">        if (tz != cdate.getZone()) {</span>
<span class="nc" id="L1211">            cdate.setZone(tz);</span>
<span class="nc" id="L1212">            CalendarSystem cal = getCalendarSystem(cdate);</span>
<span class="nc" id="L1213">            cal.getCalendarDate(fastTime, cdate);</span>
        }
<span class="fc" id="L1215">        return cdate;</span>
    }

    // fastTime and the returned data are in sync upon return.
    private final BaseCalendar.Date normalize(BaseCalendar.Date date) {
<span class="fc" id="L1220">        int y = date.getNormalizedYear();</span>
<span class="fc" id="L1221">        int m = date.getMonth();</span>
<span class="fc" id="L1222">        int d = date.getDayOfMonth();</span>
<span class="fc" id="L1223">        int hh = date.getHours();</span>
<span class="fc" id="L1224">        int mm = date.getMinutes();</span>
<span class="fc" id="L1225">        int ss = date.getSeconds();</span>
<span class="fc" id="L1226">        int ms = date.getMillis();</span>
<span class="fc" id="L1227">        TimeZone tz = date.getZone();</span>

        // If the specified year can't be handled using a long value
        // in milliseconds, GregorianCalendar is used for full
        // compatibility with underflow and overflow. This is required
        // by some JCK tests. The limits are based max year values -
        // years that can be represented by max values of d, hh, mm,
        // ss and ms. Also, let GregorianCalendar handle the default
        // cutover year so that we don't need to worry about the
        // transition here.
<span class="pc bpc" id="L1237" title="3 of 6 branches missed.">        if (y == 1582 || y &gt; 280000000 || y &lt; -280000000) {</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">            if (tz == null) {</span>
<span class="nc" id="L1239">                tz = TimeZone.getTimeZone(&quot;GMT&quot;);</span>
            }
<span class="nc" id="L1241">            GregorianCalendar gc = new GregorianCalendar(tz);</span>
<span class="nc" id="L1242">            gc.clear();</span>
<span class="nc" id="L1243">            gc.set(GregorianCalendar.MILLISECOND, ms);</span>
<span class="nc" id="L1244">            gc.set(y, m-1, d, hh, mm, ss);</span>
<span class="nc" id="L1245">            fastTime = gc.getTimeInMillis();</span>
<span class="nc" id="L1246">            BaseCalendar cal = getCalendarSystem(fastTime);</span>
<span class="nc" id="L1247">            date = (BaseCalendar.Date) cal.getCalendarDate(fastTime, tz);</span>
<span class="nc" id="L1248">            return date;</span>
        }

<span class="fc" id="L1251">        BaseCalendar cal = getCalendarSystem(y);</span>
<span class="pc bpc" id="L1252" title="1 of 2 branches missed.">        if (cal != getCalendarSystem(date)) {</span>
<span class="nc" id="L1253">            date = (BaseCalendar.Date) cal.newCalendarDate(tz);</span>
<span class="nc" id="L1254">            date.setNormalizedDate(y, m, d).setTimeOfDay(hh, mm, ss, ms);</span>
        }
        // Perform the GregorianCalendar-style normalization.
<span class="fc" id="L1257">        fastTime = cal.getTime(date);</span>

        // In case the normalized date requires the other calendar
        // system, we need to recalculate it using the other one.
<span class="fc" id="L1261">        BaseCalendar ncal = getCalendarSystem(fastTime);</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">        if (ncal != cal) {</span>
<span class="nc" id="L1263">            date = (BaseCalendar.Date) ncal.newCalendarDate(tz);</span>
<span class="nc" id="L1264">            date.setNormalizedDate(y, m, d).setTimeOfDay(hh, mm, ss, ms);</span>
<span class="nc" id="L1265">            fastTime = ncal.getTime(date);</span>
        }
<span class="fc" id="L1267">        return date;</span>
    }

    /**
     * Returns the Gregorian or Julian calendar system to use with the
     * given date. Use Gregorian from October 15, 1582.
     *
     * @param year normalized calendar year (not -1900)
     * @return the CalendarSystem to use for the specified date
     */
    private static final BaseCalendar getCalendarSystem(int year) {
<span class="fc bfc" id="L1278" title="All 2 branches covered.">        if (year &gt;= 1582) {</span>
<span class="fc" id="L1279">            return gcal;</span>
        }
<span class="fc" id="L1281">        return getJulianCalendar();</span>
    }

    private static final BaseCalendar getCalendarSystem(long utc) {
        // Quickly check if the time stamp given by `utc' is the Epoch
        // or later. If it's before 1970, we convert the cutover to
        // local time to compare.
<span class="fc bfc" id="L1288" title="All 2 branches covered.">        if (utc &gt;= 0</span>
            || utc &gt;= GregorianCalendar.DEFAULT_GREGORIAN_CUTOVER
<span class="pc bpc" id="L1290" title="1 of 2 branches missed.">                        - TimeZone.getDefaultRef().getOffset(utc)) {</span>
<span class="fc" id="L1291">            return gcal;</span>
        }
<span class="fc" id="L1293">        return getJulianCalendar();</span>
    }

    private static final BaseCalendar getCalendarSystem(BaseCalendar.Date cdate) {
<span class="fc bfc" id="L1297" title="All 2 branches covered.">        if (jcal == null) {</span>
<span class="fc" id="L1298">            return gcal;</span>
        }
<span class="fc bfc" id="L1300" title="All 2 branches covered.">        if (cdate.getEra() != null) {</span>
<span class="fc" id="L1301">            return jcal;</span>
        }
<span class="fc" id="L1303">        return gcal;</span>
    }

    synchronized private static final BaseCalendar getJulianCalendar() {
<span class="fc bfc" id="L1307" title="All 2 branches covered.">        if (jcal == null) {</span>
<span class="fc" id="L1308">            jcal = (BaseCalendar) CalendarSystem.forName(&quot;julian&quot;);</span>
        }
<span class="fc" id="L1310">        return jcal;</span>
    }

    /**
     * Save the state of this object to a stream (i.e., serialize it).
     *
     * @serialData The value returned by &lt;code&gt;getTime()&lt;/code&gt;
     *             is emitted (long).  This represents the offset from
     *             January 1, 1970, 00:00:00 GMT in milliseconds.
     */
    private void writeObject(ObjectOutputStream s)
         throws IOException
    {
<span class="fc" id="L1323">        s.writeLong(getTimeImpl());</span>
<span class="fc" id="L1324">    }</span>

    /**
     * Reconstitute this object from a stream (i.e., deserialize it).
     */
    private void readObject(ObjectInputStream s)
         throws IOException, ClassNotFoundException
    {
<span class="fc" id="L1332">        fastTime = s.readLong();</span>
<span class="fc" id="L1333">    }</span>

    /**
     * Obtains an instance of {@code Date} from an {@code Instant} object.
     * &lt;p&gt;
     * {@code Instant} uses a precision of nanoseconds, whereas {@code Date}
     * uses a precision of milliseconds.  The conversion will trancate any
     * excess precision information as though the amount in nanoseconds was
     * subject to integer division by one million.
     * &lt;p&gt;
     * {@code Instant} can store points on the time-line further in the future
     * and further in the past than {@code Date}. In this scenario, this method
     * will throw an exception.
     *
     * @param instant  the instant to convert
     * @return a {@code Date} representing the same point on the time-line as
     *  the provided instant
     * @exception NullPointerException if {@code instant} is null.
     * @exception IllegalArgumentException if the instant is too large to
     *  represent as a {@code Date}
     * @since 1.8
     */
    public static Date from(Instant instant) {
        try {
<span class="nc" id="L1357">            return new Date(instant.toEpochMilli());</span>
<span class="nc" id="L1358">        } catch (ArithmeticException ex) {</span>
<span class="nc" id="L1359">            throw new IllegalArgumentException(ex);</span>
        }
    }

    /**
     * Converts this {@code Date} object to an {@code Instant}.
     * &lt;p&gt;
     * The conversion creates an {@code Instant} that represents the same
     * point on the time-line as this {@code Date}.
     *
     * @return an instant representing the same point on the time-line as
     *  this {@code Date} object
     * @since 1.8
     */
    public Instant toInstant() {
<span class="nc" id="L1374">        return Instant.ofEpochMilli(getTime());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>