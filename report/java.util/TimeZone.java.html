<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>TimeZone.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util</a> &gt; <span class="el_source">TimeZone.java</span></div><h1>TimeZone.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.util;

import java.io.Serializable;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.time.ZoneId;
import sun.security.action.GetPropertyAction;
import sun.util.calendar.ZoneInfo;
import sun.util.calendar.ZoneInfoFile;
import sun.util.locale.provider.TimeZoneNameUtility;

/**
 * &lt;code&gt;TimeZone&lt;/code&gt; represents a time zone offset, and also figures out daylight
 * savings.
 *
 * &lt;p&gt;
 * Typically, you get a &lt;code&gt;TimeZone&lt;/code&gt; using &lt;code&gt;getDefault&lt;/code&gt;
 * which creates a &lt;code&gt;TimeZone&lt;/code&gt; based on the time zone where the program
 * is running. For example, for a program running in Japan, &lt;code&gt;getDefault&lt;/code&gt;
 * creates a &lt;code&gt;TimeZone&lt;/code&gt; object based on Japanese Standard Time.
 *
 * &lt;p&gt;
 * You can also get a &lt;code&gt;TimeZone&lt;/code&gt; using &lt;code&gt;getTimeZone&lt;/code&gt;
 * along with a time zone ID. For instance, the time zone ID for the
 * U.S. Pacific Time zone is &quot;America/Los_Angeles&quot;. So, you can get a
 * U.S. Pacific Time &lt;code&gt;TimeZone&lt;/code&gt; object with:
 * &lt;blockquote&gt;&lt;pre&gt;
 * TimeZone tz = TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * You can use the &lt;code&gt;getAvailableIDs&lt;/code&gt; method to iterate through
 * all the supported time zone IDs. You can then choose a
 * supported ID to get a &lt;code&gt;TimeZone&lt;/code&gt;.
 * If the time zone you want is not represented by one of the
 * supported IDs, then a custom time zone ID can be specified to
 * produce a TimeZone. The syntax of a custom time zone ID is:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * &lt;a name=&quot;CustomID&quot;&gt;&lt;i&gt;CustomID:&lt;/i&gt;&lt;/a&gt;
 *         &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;
 *         &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;
 *         &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt;
 * &lt;i&gt;Sign:&lt;/i&gt; one of
 *         &lt;code&gt;+ -&lt;/code&gt;
 * &lt;i&gt;Hours:&lt;/i&gt;
 *         &lt;i&gt;Digit&lt;/i&gt;
 *         &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 * &lt;i&gt;Minutes:&lt;/i&gt;
 *         &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 * &lt;i&gt;Digit:&lt;/i&gt; one of
 *         &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;i&gt;Hours&lt;/i&gt; must be between 0 to 23 and &lt;i&gt;Minutes&lt;/i&gt; must be
 * between 00 to 59.  For example, &quot;GMT+10&quot; and &quot;GMT+0010&quot; mean ten
 * hours and ten minutes ahead of GMT, respectively.
 * &lt;p&gt;
 * The format is locale independent and digits must be taken from the
 * Basic Latin block of the Unicode standard. No daylight saving time
 * transition schedule can be specified with a custom time zone ID. If
 * the specified string doesn't match the syntax, &lt;code&gt;&quot;GMT&quot;&lt;/code&gt;
 * is used.
 * &lt;p&gt;
 * When creating a &lt;code&gt;TimeZone&lt;/code&gt;, the specified custom time
 * zone ID is normalized in the following syntax:
 * &lt;blockquote&gt;&lt;pre&gt;
 * &lt;a name=&quot;NormalizedCustomID&quot;&gt;&lt;i&gt;NormalizedCustomID:&lt;/i&gt;&lt;/a&gt;
 *         &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;
 * &lt;i&gt;Sign:&lt;/i&gt; one of
 *         &lt;code&gt;+ -&lt;/code&gt;
 * &lt;i&gt;TwoDigitHours:&lt;/i&gt;
 *         &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 * &lt;i&gt;Minutes:&lt;/i&gt;
 *         &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 * &lt;i&gt;Digit:&lt;/i&gt; one of
 *         &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * For example, TimeZone.getTimeZone(&quot;GMT-8&quot;).getID() returns &quot;GMT-08:00&quot;.
 *
 * &lt;h3&gt;Three-letter time zone IDs&lt;/h3&gt;
 *
 * For compatibility with JDK 1.1.x, some other three-letter time zone IDs
 * (such as &quot;PST&quot;, &quot;CTT&quot;, &quot;AST&quot;) are also supported. However, &lt;strong&gt;their
 * use is deprecated&lt;/strong&gt; because the same abbreviation is often used
 * for multiple time zones (for example, &quot;CST&quot; could be U.S. &quot;Central Standard
 * Time&quot; and &quot;China Standard Time&quot;), and the Java platform can then only
 * recognize one of them.
 *
 *
 * @see          Calendar
 * @see          GregorianCalendar
 * @see          SimpleTimeZone
 * @author       Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu
 * @since        JDK1.1
 */
<span class="fc bfc" id="L133" title="All 2 branches covered.">abstract public class TimeZone implements Serializable, Cloneable {</span>
    /**
     * Sole constructor.  (For invocation by subclass constructors, typically
     * implicit.)
     */
<span class="fc" id="L138">    public TimeZone() {</span>
<span class="fc" id="L139">    }</span>

    /**
     * A style specifier for &lt;code&gt;getDisplayName()&lt;/code&gt; indicating
     * a short name, such as &quot;PST.&quot;
     * @see #LONG
     * @since 1.2
     */
    public static final int SHORT = 0;

    /**
     * A style specifier for &lt;code&gt;getDisplayName()&lt;/code&gt; indicating
     * a long name, such as &quot;Pacific Standard Time.&quot;
     * @see #SHORT
     * @since 1.2
     */
    public static final int LONG  = 1;

    // Constants used internally; unit is milliseconds
    private static final int ONE_MINUTE = 60*1000;
    private static final int ONE_HOUR   = 60*ONE_MINUTE;
    private static final int ONE_DAY    = 24*ONE_HOUR;

    // Proclaim serialization compatibility with JDK 1.1
    static final long serialVersionUID = 3581463369166924961L;

    /**
     * Gets the time zone offset, for current date, modified in case of
     * daylight savings. This is the offset to add to UTC to get local time.
     * &lt;p&gt;
     * This method returns a historically correct offset if an
     * underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass
     * supports historical Daylight Saving Time schedule and GMT
     * offset changes.
     *
     * @param era the era of the given date.
     * @param year the year in the given date.
     * @param month the month in the given date.
     * Month is 0-based. e.g., 0 for January.
     * @param day the day-in-month of the given date.
     * @param dayOfWeek the day-of-week of the given date.
     * @param milliseconds the milliseconds in day in &lt;em&gt;standard&lt;/em&gt;
     * local time.
     *
     * @return the offset in milliseconds to add to GMT to get local time.
     *
     * @see Calendar#ZONE_OFFSET
     * @see Calendar#DST_OFFSET
     */
    public abstract int getOffset(int era, int year, int month, int day,
                                  int dayOfWeek, int milliseconds);

    /**
     * Returns the offset of this time zone from UTC at the specified
     * date. If Daylight Saving Time is in effect at the specified
     * date, the offset value is adjusted with the amount of daylight
     * saving.
     * &lt;p&gt;
     * This method returns a historically correct offset value if an
     * underlying TimeZone implementation subclass supports historical
     * Daylight Saving Time schedule and GMT offset changes.
     *
     * @param date the date represented in milliseconds since January 1, 1970 00:00:00 GMT
     * @return the amount of time in milliseconds to add to UTC to get local time.
     *
     * @see Calendar#ZONE_OFFSET
     * @see Calendar#DST_OFFSET
     * @since 1.4
     */
    public int getOffset(long date) {
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (inDaylightTime(new Date(date))) {</span>
<span class="nc" id="L210">            return getRawOffset() + getDSTSavings();</span>
        }
<span class="nc" id="L212">        return getRawOffset();</span>
    }

    /**
     * Gets the raw GMT offset and the amount of daylight saving of this
     * time zone at the given time.
     * @param date the milliseconds (since January 1, 1970,
     * 00:00:00.000 GMT) at which the time zone offset and daylight
     * saving amount are found
     * @param offsets an array of int where the raw GMT offset
     * (offset[0]) and daylight saving amount (offset[1]) are stored,
     * or null if those values are not needed. The method assumes that
     * the length of the given array is two or larger.
     * @return the total amount of the raw GMT offset and daylight
     * saving at the specified date.
     *
     * @see Calendar#ZONE_OFFSET
     * @see Calendar#DST_OFFSET
     */
    int getOffsets(long date, int[] offsets) {
<span class="nc" id="L232">        int rawoffset = getRawOffset();</span>
<span class="nc" id="L233">        int dstoffset = 0;</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (inDaylightTime(new Date(date))) {</span>
<span class="nc" id="L235">            dstoffset = getDSTSavings();</span>
        }
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (offsets != null) {</span>
<span class="nc" id="L238">            offsets[0] = rawoffset;</span>
<span class="nc" id="L239">            offsets[1] = dstoffset;</span>
        }
<span class="nc" id="L241">        return rawoffset + dstoffset;</span>
    }

    /**
     * Sets the base time zone offset to GMT.
     * This is the offset to add to UTC to get local time.
     * &lt;p&gt;
     * If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass
     * supports historical GMT offset changes, the specified GMT
     * offset is set as the latest GMT offset and the difference from
     * the known latest GMT offset value is used to adjust all
     * historical GMT offset values.
     *
     * @param offsetMillis the given base time zone offset to GMT.
     */
    abstract public void setRawOffset(int offsetMillis);

    /**
     * Returns the amount of time in milliseconds to add to UTC to get
     * standard time in this time zone. Because this value is not
     * affected by daylight saving time, it is called &lt;I&gt;raw
     * offset&lt;/I&gt;.
     * &lt;p&gt;
     * If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass
     * supports historical GMT offset changes, the method returns the
     * raw offset value of the current date. In Honolulu, for example,
     * its raw offset changed from GMT-10:30 to GMT-10:00 in 1947, and
     * this method always returns -36000000 milliseconds (i.e., -10
     * hours).
     *
     * @return the amount of raw offset time in milliseconds to add to UTC.
     * @see Calendar#ZONE_OFFSET
     */
    public abstract int getRawOffset();

    /**
     * Gets the ID of this time zone.
     * @return the ID of this time zone.
     */
    public String getID()
    {
<span class="fc" id="L282">        return ID;</span>
    }

    /**
     * Sets the time zone ID. This does not change any other data in
     * the time zone object.
     * @param ID the new time zone ID.
     */
    public void setID(String ID)
    {
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        if (ID == null) {</span>
<span class="nc" id="L293">            throw new NullPointerException();</span>
        }
<span class="fc" id="L295">        this.ID = ID;</span>
<span class="fc" id="L296">    }</span>

    /**
     * Returns a long standard time name of this {@code TimeZone} suitable for
     * presentation to the user in the default locale.
     *
     * &lt;p&gt;This method is equivalent to:
     * &lt;blockquote&gt;&lt;pre&gt;
     * getDisplayName(false, {@link #LONG},
     *                Locale.getDefault({@link Locale.Category#DISPLAY}))
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return the human-readable name of this time zone in the default locale.
     * @since 1.2
     * @see #getDisplayName(boolean, int, Locale)
     * @see Locale#getDefault(Locale.Category)
     * @see Locale.Category
     */
    public final String getDisplayName() {
<span class="nc" id="L315">        return getDisplayName(false, LONG,</span>
<span class="nc" id="L316">                              Locale.getDefault(Locale.Category.DISPLAY));</span>
    }

    /**
     * Returns a long standard time name of this {@code TimeZone} suitable for
     * presentation to the user in the specified {@code locale}.
     *
     * &lt;p&gt;This method is equivalent to:
     * &lt;blockquote&gt;&lt;pre&gt;
     * getDisplayName(false, {@link #LONG}, locale)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param locale the locale in which to supply the display name.
     * @return the human-readable name of this time zone in the given locale.
     * @exception NullPointerException if {@code locale} is {@code null}.
     * @since 1.2
     * @see #getDisplayName(boolean, int, Locale)
     */
    public final String getDisplayName(Locale locale) {
<span class="fc" id="L335">        return getDisplayName(false, LONG, locale);</span>
    }

    /**
     * Returns a name in the specified {@code style} of this {@code TimeZone}
     * suitable for presentation to the user in the default locale. If the
     * specified {@code daylight} is {@code true}, a Daylight Saving Time name
     * is returned (even if this {@code TimeZone} doesn't observe Daylight Saving
     * Time). Otherwise, a Standard Time name is returned.
     *
     * &lt;p&gt;This method is equivalent to:
     * &lt;blockquote&gt;&lt;pre&gt;
     * getDisplayName(daylight, style,
     *                Locale.getDefault({@link Locale.Category#DISPLAY}))
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param daylight {@code true} specifying a Daylight Saving Time name, or
     *                 {@code false} specifying a Standard Time name
     * @param style either {@link #LONG} or {@link #SHORT}
     * @return the human-readable name of this time zone in the default locale.
     * @exception IllegalArgumentException if {@code style} is invalid.
     * @since 1.2
     * @see #getDisplayName(boolean, int, Locale)
     * @see Locale#getDefault(Locale.Category)
     * @see Locale.Category
     * @see java.text.DateFormatSymbols#getZoneStrings()
     */
    public final String getDisplayName(boolean daylight, int style) {
<span class="nc" id="L363">        return getDisplayName(daylight, style,</span>
<span class="nc" id="L364">                              Locale.getDefault(Locale.Category.DISPLAY));</span>
    }

    /**
     * Returns a name in the specified {@code style} of this {@code TimeZone}
     * suitable for presentation to the user in the specified {@code
     * locale}. If the specified {@code daylight} is {@code true}, a Daylight
     * Saving Time name is returned (even if this {@code TimeZone} doesn't
     * observe Daylight Saving Time). Otherwise, a Standard Time name is
     * returned.
     *
     * &lt;p&gt;When looking up a time zone name, the {@linkplain
     * ResourceBundle.Control#getCandidateLocales(String,Locale) default
     * &lt;code&gt;Locale&lt;/code&gt; search path of &lt;code&gt;ResourceBundle&lt;/code&gt;} derived
     * from the specified {@code locale} is used. (No {@linkplain
     * ResourceBundle.Control#getFallbackLocale(String,Locale) fallback
     * &lt;code&gt;Locale&lt;/code&gt;} search is performed.) If a time zone name in any
     * {@code Locale} of the search path, including {@link Locale#ROOT}, is
     * found, the name is returned. Otherwise, a string in the
     * &lt;a href=&quot;#NormalizedCustomID&quot;&gt;normalized custom ID format&lt;/a&gt; is returned.
     *
     * @param daylight {@code true} specifying a Daylight Saving Time name, or
     *                 {@code false} specifying a Standard Time name
     * @param style either {@link #LONG} or {@link #SHORT}
     * @param locale   the locale in which to supply the display name.
     * @return the human-readable name of this time zone in the given locale.
     * @exception IllegalArgumentException if {@code style} is invalid.
     * @exception NullPointerException if {@code locale} is {@code null}.
     * @since 1.2
     * @see java.text.DateFormatSymbols#getZoneStrings()
     */
    public String getDisplayName(boolean daylight, int style, Locale locale) {
<span class="pc bpc" id="L396" title="1 of 4 branches missed.">        if (style != SHORT &amp;&amp; style != LONG) {</span>
<span class="nc" id="L397">            throw new IllegalArgumentException(&quot;Illegal style: &quot; + style);</span>
        }
<span class="fc" id="L399">        String id = getID();</span>
<span class="fc" id="L400">        String name = TimeZoneNameUtility.retrieveDisplayName(id, daylight, style, locale);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">        if (name != null) {</span>
<span class="fc" id="L402">            return name;</span>
        }

<span class="pc bpc" id="L405" title="1 of 4 branches missed.">        if (id.startsWith(&quot;GMT&quot;) &amp;&amp; id.length() &gt; 3) {</span>
<span class="fc" id="L406">            char sign = id.charAt(3);</span>
<span class="pc bpc" id="L407" title="2 of 4 branches missed.">            if (sign == '+' || sign == '-') {</span>
<span class="fc" id="L408">                return id;</span>
            }
        }
<span class="fc" id="L411">        int offset = getRawOffset();</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if (daylight) {</span>
<span class="nc" id="L413">            offset += getDSTSavings();</span>
        }
<span class="fc" id="L415">        return ZoneInfoFile.toCustomID(offset);</span>
    }

    private static String[] getDisplayNames(String id, Locale locale) {
<span class="nc" id="L419">        return TimeZoneNameUtility.retrieveDisplayNames(id, locale);</span>
    }

    /**
     * Returns the amount of time to be added to local standard time
     * to get local wall clock time.
     *
     * &lt;p&gt;The default implementation returns 3600000 milliseconds
     * (i.e., one hour) if a call to {@link #useDaylightTime()}
     * returns {@code true}. Otherwise, 0 (zero) is returned.
     *
     * &lt;p&gt;If an underlying {@code TimeZone} implementation subclass
     * supports historical and future Daylight Saving Time schedule
     * changes, this method returns the amount of saving time of the
     * last known Daylight Saving Time rule that can be a future
     * prediction.
     *
     * &lt;p&gt;If the amount of saving time at any given time stamp is
     * required, construct a {@link Calendar} with this {@code
     * TimeZone} and the time stamp, and call {@link Calendar#get(int)
     * Calendar.get}{@code (}{@link Calendar#DST_OFFSET}{@code )}.
     *
     * @return the amount of saving time in milliseconds
     * @since 1.4
     * @see #inDaylightTime(Date)
     * @see #getOffset(long)
     * @see #getOffset(int,int,int,int,int,int)
     * @see Calendar#ZONE_OFFSET
     */
    public int getDSTSavings() {
<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (useDaylightTime()) {</span>
<span class="nc" id="L450">            return 3600000;</span>
        }
<span class="nc" id="L452">        return 0;</span>
    }

    /**
     * Queries if this {@code TimeZone} uses Daylight Saving Time.
     *
     * &lt;p&gt;If an underlying {@code TimeZone} implementation subclass
     * supports historical and future Daylight Saving Time schedule
     * changes, this method refers to the last known Daylight Saving Time
     * rule that can be a future prediction and may not be the same as
     * the current rule. Consider calling {@link #observesDaylightTime()}
     * if the current rule should also be taken into account.
     *
     * @return {@code true} if this {@code TimeZone} uses Daylight Saving Time,
     *         {@code false}, otherwise.
     * @see #inDaylightTime(Date)
     * @see Calendar#DST_OFFSET
     */
    public abstract boolean useDaylightTime();

    /**
     * Returns {@code true} if this {@code TimeZone} is currently in
     * Daylight Saving Time, or if a transition from Standard Time to
     * Daylight Saving Time occurs at any future time.
     *
     * &lt;p&gt;The default implementation returns {@code true} if
     * {@code useDaylightTime()} or {@code inDaylightTime(new Date())}
     * returns {@code true}.
     *
     * @return {@code true} if this {@code TimeZone} is currently in
     * Daylight Saving Time, or if a transition from Standard Time to
     * Daylight Saving Time occurs at any future time; {@code false}
     * otherwise.
     * @since 1.7
     * @see #useDaylightTime()
     * @see #inDaylightTime(Date)
     * @see Calendar#DST_OFFSET
     */
    public boolean observesDaylightTime() {
<span class="nc bnc" id="L491" title="All 4 branches missed.">        return useDaylightTime() || inDaylightTime(new Date());</span>
    }

    /**
     * Queries if the given {@code date} is in Daylight Saving Time in
     * this time zone.
     *
     * @param date the given Date.
     * @return {@code true} if the given date is in Daylight Saving Time,
     *         {@code false}, otherwise.
     */
    abstract public boolean inDaylightTime(Date date);

    /**
     * Gets the &lt;code&gt;TimeZone&lt;/code&gt; for the given ID.
     *
     * @param ID the ID for a &lt;code&gt;TimeZone&lt;/code&gt;, either an abbreviation
     * such as &quot;PST&quot;, a full name such as &quot;America/Los_Angeles&quot;, or a custom
     * ID such as &quot;GMT-8:00&quot;. Note that the support of abbreviations is
     * for JDK 1.1.x compatibility only and full names should be used.
     *
     * @return the specified &lt;code&gt;TimeZone&lt;/code&gt;, or the GMT zone if the given ID
     * cannot be understood.
     */
    public static synchronized TimeZone getTimeZone(String ID) {
<span class="fc" id="L516">        return getTimeZone(ID, true);</span>
    }

    /**
     * Gets the {@code TimeZone} for the given {@code zoneId}.
     *
     * @param zoneId a {@link ZoneId} from which the time zone ID is obtained
     * @return the specified {@code TimeZone}, or the GMT zone if the given ID
     *         cannot be understood.
     * @throws NullPointerException if {@code zoneId} is {@code null}
     * @since 1.8
     */
    public static TimeZone getTimeZone(ZoneId zoneId) {
<span class="nc" id="L529">        String tzid = zoneId.getId(); // throws an NPE if null</span>
<span class="nc" id="L530">        char c = tzid.charAt(0);</span>
<span class="nc bnc" id="L531" title="All 4 branches missed.">        if (c == '+' || c == '-') {</span>
<span class="nc" id="L532">            tzid = &quot;GMT&quot; + tzid;</span>
<span class="nc bnc" id="L533" title="All 4 branches missed.">        } else if (c == 'Z' &amp;&amp; tzid.length() == 1) {</span>
<span class="nc" id="L534">            tzid = &quot;UTC&quot;;</span>
        }
<span class="nc" id="L536">        return getTimeZone(tzid, true);</span>
    }

    /**
     * Converts this {@code TimeZone} object to a {@code ZoneId}.
     *
     * @return a {@code ZoneId} representing the same time zone as this
     *         {@code TimeZone}
     * @since 1.8
     */
    public ZoneId toZoneId() {
<span class="nc" id="L547">        String id = getID();</span>
<span class="nc bnc" id="L548" title="All 4 branches missed.">        if (ZoneInfoFile.useOldMapping() &amp;&amp; id.length() == 3) {</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            if (&quot;EST&quot;.equals(id))</span>
<span class="nc" id="L550">                return ZoneId.of(&quot;America/New_York&quot;);</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">            if (&quot;MST&quot;.equals(id))</span>
<span class="nc" id="L552">                return ZoneId.of(&quot;America/Denver&quot;);</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">            if (&quot;HST&quot;.equals(id))</span>
<span class="nc" id="L554">                return ZoneId.of(&quot;America/Honolulu&quot;);</span>
        }
<span class="nc" id="L556">        return ZoneId.of(id, ZoneId.SHORT_IDS);</span>
    }

    private static TimeZone getTimeZone(String ID, boolean fallback) {
<span class="fc" id="L560">        TimeZone tz = ZoneInfo.getTimeZone(ID);</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (tz == null) {</span>
<span class="fc" id="L562">            tz = parseCustomTimeZone(ID);</span>
<span class="pc bpc" id="L563" title="3 of 4 branches missed.">            if (tz == null &amp;&amp; fallback) {</span>
<span class="nc" id="L564">                tz = new ZoneInfo(GMT_ID, 0);</span>
            }
        }
<span class="fc" id="L567">        return tz;</span>
    }

    /**
     * Gets the available IDs according to the given time zone offset in milliseconds.
     *
     * @param rawOffset the given time zone GMT offset in milliseconds.
     * @return an array of IDs, where the time zone for that ID has
     * the specified GMT offset. For example, &quot;America/Phoenix&quot; and &quot;America/Denver&quot;
     * both have GMT-07:00, but differ in daylight saving behavior.
     * @see #getRawOffset()
     */
    public static synchronized String[] getAvailableIDs(int rawOffset) {
<span class="fc" id="L580">        return ZoneInfo.getAvailableIDs(rawOffset);</span>
    }

    /**
     * Gets all the available IDs supported.
     * @return an array of IDs.
     */
    public static synchronized String[] getAvailableIDs() {
<span class="fc" id="L588">        return ZoneInfo.getAvailableIDs();</span>
    }

    /**
     * Gets the platform defined TimeZone ID.
     **/
    private static native String getSystemTimeZoneID(String javaHome,
                                                     String country);

    /**
     * Gets the custom time zone ID based on the GMT offset of the
     * platform. (e.g., &quot;GMT+08:00&quot;)
     */
    private static native String getSystemGMTOffsetID();

    /**
     * Gets the default {@code TimeZone} of the Java virtual machine. If the
     * cached default {@code TimeZone} is available, its clone is returned.
     * Otherwise, the method takes the following steps to determine the default
     * time zone.
     *
     * &lt;ul&gt;
     * &lt;li&gt;Use the {@code user.timezone} property value as the default
     * time zone ID if it's available.&lt;/li&gt;
     * &lt;li&gt;Detect the platform time zone ID. The source of the
     * platform time zone and ID mapping may vary with implementation.&lt;/li&gt;
     * &lt;li&gt;Use {@code GMT} as the last resort if the given or detected
     * time zone ID is unknown.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;The default {@code TimeZone} created from the ID is cached,
     * and its clone is returned. The {@code user.timezone} property
     * value is set to the ID upon return.
     *
     * @return the default {@code TimeZone}
     * @see #setDefault(TimeZone)
     */
    public static TimeZone getDefault() {
<span class="fc" id="L626">        return (TimeZone) getDefaultRef().clone();</span>
    }

    /**
     * Returns the reference to the default TimeZone object. This
     * method doesn't create a clone.
     */
    static TimeZone getDefaultRef() {
<span class="fc" id="L634">        TimeZone defaultZone = defaultTimeZone;</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">        if (defaultZone == null) {</span>
            // Need to initialize the default time zone.
<span class="fc" id="L637">            defaultZone = setDefaultZone();</span>
<span class="pc bpc" id="L638" title="1 of 4 branches missed.">            assert defaultZone != null;</span>
        }
        // Don't clone here.
<span class="fc" id="L641">        return defaultZone;</span>
    }

    private static synchronized TimeZone setDefaultZone() {
        TimeZone tz;
        // get the time zone ID from the system properties
<span class="fc" id="L647">        String zoneID = AccessController.doPrivileged(</span>
                new GetPropertyAction(&quot;user.timezone&quot;));

        // if the time zone ID is not set (yet), perform the
        // platform to Java time zone ID mapping.
<span class="pc bpc" id="L652" title="1 of 4 branches missed.">        if (zoneID == null || zoneID.isEmpty()) {</span>
<span class="fc" id="L653">            String country = AccessController.doPrivileged(</span>
                    new GetPropertyAction(&quot;user.country&quot;));
<span class="fc" id="L655">            String javaHome = AccessController.doPrivileged(</span>
                    new GetPropertyAction(&quot;java.home&quot;));
            try {
<span class="fc" id="L658">                zoneID = getSystemTimeZoneID(javaHome, country);</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">                if (zoneID == null) {</span>
<span class="nc" id="L660">                    zoneID = GMT_ID;</span>
                }
<span class="nc" id="L662">            } catch (NullPointerException e) {</span>
<span class="nc" id="L663">                zoneID = GMT_ID;</span>
<span class="fc" id="L664">            }</span>
        }

        // Get the time zone for zoneID. But not fall back to
        // &quot;GMT&quot; here.
<span class="fc" id="L669">        tz = getTimeZone(zoneID, false);</span>

<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        if (tz == null) {</span>
            // If the given zone ID is unknown in Java, try to
            // get the GMT-offset-based time zone ID,
            // a.k.a. custom time zone ID (e.g., &quot;GMT-08:00&quot;).
<span class="nc" id="L675">            String gmtOffsetID = getSystemGMTOffsetID();</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">            if (gmtOffsetID != null) {</span>
<span class="nc" id="L677">                zoneID = gmtOffsetID;</span>
            }
<span class="nc" id="L679">            tz = getTimeZone(zoneID, true);</span>
        }
<span class="pc bpc" id="L681" title="1 of 4 branches missed.">        assert tz != null;</span>

<span class="fc" id="L683">        final String id = zoneID;</span>
<span class="fc" id="L684">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
            @Override
                public Void run() {
<span class="fc" id="L687">                    System.setProperty(&quot;user.timezone&quot;, id);</span>
<span class="fc" id="L688">                    return null;</span>
                }
            });

<span class="fc" id="L692">        defaultTimeZone = tz;</span>
<span class="fc" id="L693">        return tz;</span>
    }

    /**
     * Sets the {@code TimeZone} that is returned by the {@code getDefault}
     * method. {@code zone} is cached. If {@code zone} is null, the cached
     * default {@code TimeZone} is cleared. This method doesn't change the value
     * of the {@code user.timezone} property.
     *
     * @param zone the new default {@code TimeZone}, or null
     * @throws SecurityException if the security manager's {@code checkPermission}
     *                           denies {@code PropertyPermission(&quot;user.timezone&quot;,
     *                           &quot;write&quot;)}
     * @see #getDefault
     * @see PropertyPermission
     */
    public static void setDefault(TimeZone zone)
    {
<span class="fc" id="L711">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">        if (sm != null) {</span>
<span class="fc" id="L713">            sm.checkPermission(new PropertyPermission</span>
                               (&quot;user.timezone&quot;, &quot;write&quot;));
        }
<span class="fc" id="L716">        defaultTimeZone = zone;</span>
<span class="fc" id="L717">    }</span>

    /**
     * Returns true if this zone has the same rule and offset as another zone.
     * That is, if this zone differs only in ID, if at all.  Returns false
     * if the other zone is null.
     * @param other the &lt;code&gt;TimeZone&lt;/code&gt; object to be compared with
     * @return true if the other zone is not null and is the same as this one,
     * with the possible exception of the ID
     * @since 1.2
     */
    public boolean hasSameRules(TimeZone other) {
<span class="nc bnc" id="L729" title="All 4 branches missed.">        return other != null &amp;&amp; getRawOffset() == other.getRawOffset() &amp;&amp;</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">            useDaylightTime() == other.useDaylightTime();</span>
    }

    /**
     * Creates a copy of this &lt;code&gt;TimeZone&lt;/code&gt;.
     *
     * @return a clone of this &lt;code&gt;TimeZone&lt;/code&gt;
     */
    public Object clone()
    {
        try {
<span class="fc" id="L741">            TimeZone other = (TimeZone) super.clone();</span>
<span class="fc" id="L742">            other.ID = ID;</span>
<span class="fc" id="L743">            return other;</span>
<span class="nc" id="L744">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L745">            throw new InternalError(e);</span>
        }
    }

    /**
     * The null constant as a TimeZone.
     */
<span class="fc" id="L752">    static final TimeZone NO_TIMEZONE = null;</span>

    // =======================privates===============================

    /**
     * The string identifier of this &lt;code&gt;TimeZone&lt;/code&gt;.  This is a
     * programmatic identifier used internally to look up &lt;code&gt;TimeZone&lt;/code&gt;
     * objects from the system table and also to map them to their localized
     * display names.  &lt;code&gt;ID&lt;/code&gt; values are unique in the system
     * table but may not be for dynamically created zones.
     * @serial
     */
    private String           ID;
    private static volatile TimeZone defaultTimeZone;

    static final String         GMT_ID        = &quot;GMT&quot;;
    private static final int    GMT_ID_LENGTH = 3;

    // a static TimeZone we can reference if no AppContext is in place
    private static volatile TimeZone mainAppContextDefault;

    /**
     * Parses a custom time zone identifier and returns a corresponding zone.
     * This method doesn't support the RFC 822 time zone format. (e.g., +hhmm)
     *
     * @param id a string of the &lt;a href=&quot;#CustomID&quot;&gt;custom ID form&lt;/a&gt;.
     * @return a newly created TimeZone with the given offset and
     * no daylight saving time, or null if the id cannot be parsed.
     */
    private static final TimeZone parseCustomTimeZone(String id) {
        int length;

        // Error if the length of id isn't long enough or id doesn't
        // start with &quot;GMT&quot;.
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">        if ((length = id.length()) &lt; (GMT_ID_LENGTH + 2) ||</span>
<span class="pc bpc" id="L787" title="1 of 2 branches missed.">            id.indexOf(GMT_ID) != 0) {</span>
<span class="nc" id="L788">            return null;</span>
        }

        ZoneInfo zi;

        // First, we try to find it in the cache with the given
        // id. Even the id is not normalized, the returned ZoneInfo
        // should have its normalized id.
<span class="fc" id="L796">        zi = ZoneInfoFile.getZoneInfo(id);</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">        if (zi != null) {</span>
<span class="nc" id="L798">            return zi;</span>
        }

<span class="fc" id="L801">        int index = GMT_ID_LENGTH;</span>
<span class="fc" id="L802">        boolean negative = false;</span>
<span class="fc" id="L803">        char c = id.charAt(index++);</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">        if (c == '-') {</span>
<span class="fc" id="L805">            negative = true;</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">        } else if (c != '+') {</span>
<span class="nc" id="L807">            return null;</span>
        }

<span class="fc" id="L810">        int hours = 0;</span>
<span class="fc" id="L811">        int num = 0;</span>
<span class="fc" id="L812">        int countDelim = 0;</span>
<span class="fc" id="L813">        int len = 0;</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">        while (index &lt; length) {</span>
<span class="fc" id="L815">            c = id.charAt(index++);</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">            if (c == ':') {</span>
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">                if (countDelim &gt; 0) {</span>
<span class="nc" id="L818">                    return null;</span>
                }
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">                if (len &gt; 2) {</span>
<span class="nc" id="L821">                    return null;</span>
                }
<span class="fc" id="L823">                hours = num;</span>
<span class="fc" id="L824">                countDelim++;</span>
<span class="fc" id="L825">                num = 0;</span>
<span class="fc" id="L826">                len = 0;</span>
<span class="fc" id="L827">                continue;</span>
            }
<span class="pc bpc" id="L829" title="2 of 4 branches missed.">            if (c &lt; '0' || c &gt; '9') {</span>
<span class="nc" id="L830">                return null;</span>
            }
<span class="fc" id="L832">            num = num * 10 + (c - '0');</span>
<span class="fc" id="L833">            len++;</span>
        }
<span class="pc bpc" id="L835" title="1 of 2 branches missed.">        if (index != length) {</span>
<span class="nc" id="L836">            return null;</span>
        }
<span class="fc bfc" id="L838" title="All 2 branches covered.">        if (countDelim == 0) {</span>
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">            if (len &lt;= 2) {</span>
<span class="nc" id="L840">                hours = num;</span>
<span class="nc" id="L841">                num = 0;</span>
            } else {
<span class="fc" id="L843">                hours = num / 100;</span>
<span class="fc" id="L844">                num %= 100;</span>
            }
        } else {
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">            if (len != 2) {</span>
<span class="nc" id="L848">                return null;</span>
            }
        }
<span class="pc bpc" id="L851" title="2 of 4 branches missed.">        if (hours &gt; 23 || num &gt; 59) {</span>
<span class="nc" id="L852">            return null;</span>
        }
<span class="fc" id="L854">        int gmtOffset =  (hours * 60 + num) * 60 * 1000;</span>

<span class="pc bpc" id="L856" title="1 of 2 branches missed.">        if (gmtOffset == 0) {</span>
<span class="nc" id="L857">            zi = ZoneInfoFile.getZoneInfo(GMT_ID);</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">            if (negative) {</span>
<span class="nc" id="L859">                zi.setID(&quot;GMT-00:00&quot;);</span>
            } else {
<span class="nc" id="L861">                zi.setID(&quot;GMT+00:00&quot;);</span>
            }
        } else {
<span class="fc bfc" id="L864" title="All 2 branches covered.">            zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);</span>
        }
<span class="fc" id="L866">        return zi;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>