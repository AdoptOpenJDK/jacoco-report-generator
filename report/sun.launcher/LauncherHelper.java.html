<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>LauncherHelper.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.launcher</a> &gt; <span class="el_source">LauncherHelper.java</span></div><h1>LauncherHelper.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.launcher;

/*
 *
 *  &lt;p&gt;&lt;b&gt;This is NOT part of any API supported by Sun Microsystems.
 *  If you write code that depends on this, you do so at your own
 *  risk.  This code and its internal interfaces are subject to change
 *  or deletion without notice.&lt;/b&gt;
 *
 */

/**
 * A utility package for the java(1), javaw(1) launchers.
 * The following are helper methods that the native launcher uses
 * to perform checks etc. using JNI, see src/share/bin/java.c
 */
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.charset.Charset;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.Normalizer;
import java.util.ResourceBundle;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Locale.Category;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.jar.Manifest;

<span class="pc" id="L70">public enum LauncherHelper {</span>
<span class="fc" id="L71">    INSTANCE;</span>
    private static final String MAIN_CLASS = &quot;Main-Class&quot;;

<span class="fc" id="L74">    private static StringBuilder outBuf = new StringBuilder();</span>

    private static final String INDENT = &quot;    &quot;;
    private static final String VM_SETTINGS     = &quot;VM settings:&quot;;
    private static final String PROP_SETTINGS   = &quot;Property settings:&quot;;
    private static final String LOCALE_SETTINGS = &quot;Locale settings:&quot;;

    // sync with java.c and sun.misc.VM
    private static final String diagprop = &quot;sun.java.launcher.diag&quot;;
<span class="fc bfc" id="L83" title="All 2 branches covered.">    final static boolean trace = sun.misc.VM.getSavedProperty(diagprop) != null;</span>

    private static final String defaultBundleName =
            &quot;sun.launcher.resources.launcher&quot;;
<span class="nc" id="L87">    private static class ResourceBundleHolder {</span>
<span class="fc" id="L88">        private static final ResourceBundle RB =</span>
<span class="fc" id="L89">                ResourceBundle.getBundle(defaultBundleName);</span>
    }
    private static PrintStream ostream;
<span class="fc" id="L92">    private static final ClassLoader scloader = ClassLoader.getSystemClassLoader();</span>
    private static Class&lt;?&gt; appClass; // application class, for GUI/reporting purposes

    /*
     * A method called by the launcher to print out the standard settings,
     * by default -XshowSettings is equivalent to -XshowSettings:all,
     * Specific information may be gotten by using suboptions with possible
     * values vm, properties and locale.
     *
     * printToStderr: choose between stdout and stderr
     *
     * optionFlag: specifies which options to print default is all other
     *    possible values are vm, properties, locale.
     *
     * initialHeapSize: in bytes, as set by the launcher, a zero-value indicates
     *    this code should determine this value, using a suitable method or
     *    the line could be omitted.
     *
     * maxHeapSize: in bytes, as set by the launcher, a zero-value indicates
     *    this code should determine this value, using a suitable method.
     *
     * stackSize: in bytes, as set by the launcher, a zero-value indicates
     *    this code determine this value, using a suitable method or omit the
     *    line entirely.
     */
    static void showSettings(boolean printToStderr, String optionFlag,
            long initialHeapSize, long maxHeapSize, long stackSize,
            boolean isServer) {

<span class="fc" id="L121">        initOutput(printToStderr);</span>
<span class="fc" id="L122">        String opts[] = optionFlag.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L123" title="1 of 4 branches missed.">        String optStr = (opts.length &gt; 1 &amp;&amp; opts[1] != null)</span>
<span class="fc" id="L124">                ? opts[1].trim()</span>
                : &quot;all&quot;;
<span class="pc bpc" id="L126" title="3 of 14 branches missed.">        switch (optStr) {</span>
            case &quot;vm&quot;:
<span class="fc" id="L128">                printVmSettings(initialHeapSize, maxHeapSize,</span>
                                stackSize, isServer);
<span class="fc" id="L130">                break;</span>
            case &quot;properties&quot;:
<span class="fc" id="L132">                printProperties();</span>
<span class="fc" id="L133">                break;</span>
            case &quot;locale&quot;:
<span class="fc" id="L135">                printLocale();</span>
<span class="fc" id="L136">                break;</span>
            default:
<span class="fc" id="L138">                printVmSettings(initialHeapSize, maxHeapSize, stackSize,</span>
                                isServer);
<span class="fc" id="L140">                printProperties();</span>
<span class="fc" id="L141">                printLocale();</span>
                break;
        }
<span class="fc" id="L144">    }</span>

    /*
     * prints the main vm settings subopt/section
     */
    private static void printVmSettings(
            long initialHeapSize, long maxHeapSize,
            long stackSize, boolean isServer) {

<span class="fc" id="L153">        ostream.println(VM_SETTINGS);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (stackSize != 0L) {</span>
<span class="fc" id="L155">            ostream.println(INDENT + &quot;Stack Size: &quot; +</span>
<span class="fc" id="L156">                    SizePrefix.scaleValue(stackSize));</span>
        }
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (initialHeapSize != 0L) {</span>
<span class="fc" id="L159">             ostream.println(INDENT + &quot;Min. Heap Size: &quot; +</span>
<span class="fc" id="L160">                    SizePrefix.scaleValue(initialHeapSize));</span>
        }
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (maxHeapSize != 0L) {</span>
<span class="fc" id="L163">            ostream.println(INDENT + &quot;Max. Heap Size: &quot; +</span>
<span class="fc" id="L164">                    SizePrefix.scaleValue(maxHeapSize));</span>
        } else {
<span class="fc" id="L166">            ostream.println(INDENT + &quot;Max. Heap Size (Estimated): &quot;</span>
<span class="fc" id="L167">                    + SizePrefix.scaleValue(Runtime.getRuntime().maxMemory()));</span>
        }
<span class="fc bfc" id="L169" title="All 2 branches covered.">        ostream.println(INDENT + &quot;Ergonomics Machine Class: &quot;</span>
                + ((isServer) ? &quot;server&quot; : &quot;client&quot;));
<span class="fc" id="L171">        ostream.println(INDENT + &quot;Using VM: &quot;</span>
<span class="fc" id="L172">                + System.getProperty(&quot;java.vm.name&quot;));</span>
<span class="fc" id="L173">        ostream.println();</span>
<span class="fc" id="L174">    }</span>

    /*
     * prints the properties subopt/section
     */
    private static void printProperties() {
<span class="fc" id="L180">        Properties p = System.getProperties();</span>
<span class="fc" id="L181">        ostream.println(PROP_SETTINGS);</span>
<span class="fc" id="L182">        List&lt;String&gt; sortedPropertyKeys = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L183">        sortedPropertyKeys.addAll(p.stringPropertyNames());</span>
<span class="fc" id="L184">        Collections.sort(sortedPropertyKeys);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (String x : sortedPropertyKeys) {</span>
<span class="fc" id="L186">            printPropertyValue(x, p.getProperty(x));</span>
<span class="fc" id="L187">        }</span>
<span class="fc" id="L188">        ostream.println();</span>
<span class="fc" id="L189">    }</span>

    private static boolean isPath(String key) {
<span class="fc bfc" id="L192" title="All 4 branches covered.">        return key.endsWith(&quot;.dirs&quot;) || key.endsWith(&quot;.path&quot;);</span>
    }

    private static void printPropertyValue(String key, String value) {
<span class="fc" id="L196">        ostream.print(INDENT + key + &quot; = &quot;);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (key.equals(&quot;line.separator&quot;)) {</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">            for (byte b : value.getBytes()) {</span>
<span class="pc bpc" id="L199" title="2 of 3 branches missed.">                switch (b) {</span>
                    case 0xd:
<span class="nc" id="L201">                        ostream.print(&quot;\\r &quot;);</span>
<span class="nc" id="L202">                        break;</span>
                    case 0xa:
<span class="fc" id="L204">                        ostream.print(&quot;\\n &quot;);</span>
<span class="fc" id="L205">                        break;</span>
                    default:
                        // print any bizzare line separators in hex, but really
                        // shouldn't happen.
<span class="nc" id="L209">                        ostream.printf(&quot;0x%02X&quot;, b &amp; 0xff);</span>
                        break;
                }
            }
<span class="fc" id="L213">            ostream.println();</span>
<span class="fc" id="L214">            return;</span>
        }
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (!isPath(key)) {</span>
<span class="fc" id="L217">            ostream.println(value);</span>
<span class="fc" id="L218">            return;</span>
        }
<span class="fc" id="L220">        String[] values = value.split(System.getProperty(&quot;path.separator&quot;));</span>
<span class="fc" id="L221">        boolean first = true;</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (String s : values) {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (first) { // first line treated specially</span>
<span class="fc" id="L224">                ostream.println(s);</span>
<span class="fc" id="L225">                first = false;</span>
            } else { // following lines prefix with indents
<span class="fc" id="L227">                ostream.println(INDENT + INDENT + s);</span>
            }
        }
<span class="fc" id="L230">    }</span>

    /*
     * prints the locale subopt/section
     */
    private static void printLocale() {
<span class="fc" id="L236">        Locale locale = Locale.getDefault();</span>
<span class="fc" id="L237">        ostream.println(LOCALE_SETTINGS);</span>
<span class="fc" id="L238">        ostream.println(INDENT + &quot;default locale = &quot; +</span>
<span class="fc" id="L239">                locale.getDisplayLanguage());</span>
<span class="fc" id="L240">        ostream.println(INDENT + &quot;default display locale = &quot; +</span>
<span class="fc" id="L241">                Locale.getDefault(Category.DISPLAY).getDisplayName());</span>
<span class="fc" id="L242">        ostream.println(INDENT + &quot;default format locale = &quot; +</span>
<span class="fc" id="L243">                Locale.getDefault(Category.FORMAT).getDisplayName());</span>
<span class="fc" id="L244">        printLocales();</span>
<span class="fc" id="L245">        ostream.println();</span>
<span class="fc" id="L246">    }</span>

    private static void printLocales() {
<span class="fc" id="L249">        Locale[] tlocales = Locale.getAvailableLocales();</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        final int len = tlocales == null ? 0 : tlocales.length;</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        if (len &lt; 1 ) {</span>
<span class="nc" id="L252">            return;</span>
        }
        // Locale does not implement Comparable so we convert it to String
        // and sort it for pretty printing.
<span class="fc" id="L256">        Set&lt;String&gt; sortedSet = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        for (Locale l : tlocales) {</span>
<span class="fc" id="L258">            sortedSet.add(l.toString());</span>
        }

<span class="fc" id="L261">        ostream.print(INDENT + &quot;available locales = &quot;);</span>
<span class="fc" id="L262">        Iterator&lt;String&gt; iter = sortedSet.iterator();</span>
<span class="fc" id="L263">        final int last = len - 1;</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        for (int i = 0 ; iter.hasNext() ; i++) {</span>
<span class="fc" id="L265">            String s = iter.next();</span>
<span class="fc" id="L266">            ostream.print(s);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (i != last) {</span>
<span class="fc" id="L268">                ostream.print(&quot;, &quot;);</span>
            }
            // print columns of 8
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if ((i + 1) % 8 == 0) {</span>
<span class="fc" id="L272">                ostream.println();</span>
<span class="fc" id="L273">                ostream.print(INDENT + INDENT);</span>
            }
        }
<span class="fc" id="L276">    }</span>

<span class="pc" id="L278">    private enum SizePrefix {</span>

<span class="fc" id="L280">        KILO(1024, &quot;K&quot;),</span>
<span class="fc" id="L281">        MEGA(1024 * 1024, &quot;M&quot;),</span>
<span class="fc" id="L282">        GIGA(1024 * 1024 * 1024, &quot;G&quot;),</span>
<span class="fc" id="L283">        TERA(1024L * 1024L * 1024L * 1024L, &quot;T&quot;);</span>
        long size;
        String abbrev;

<span class="fc" id="L287">        SizePrefix(long size, String abbrev) {</span>
<span class="fc" id="L288">            this.size = size;</span>
<span class="fc" id="L289">            this.abbrev = abbrev;</span>
<span class="fc" id="L290">        }</span>

        private static String scale(long v, SizePrefix prefix) {
<span class="fc" id="L293">            return BigDecimal.valueOf(v).divide(BigDecimal.valueOf(prefix.size),</span>
<span class="fc" id="L294">                    2, RoundingMode.HALF_EVEN).toPlainString() + prefix.abbrev;</span>
        }
        /*
         * scale the incoming values to a human readable form, represented as
         * K, M, G and T, see java.c parse_size for the scaled values and
         * suffixes. The lowest possible scaled value is Kilo.
         */
        static String scaleValue(long v) {
<span class="fc bfc" id="L302" title="All 2 branches covered.">            if (v &lt; MEGA.size) {</span>
<span class="fc" id="L303">                return scale(v, KILO);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            } else if (v &lt; GIGA.size) {</span>
<span class="fc" id="L305">                return scale(v, MEGA);</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">            } else if (v &lt; TERA.size) {</span>
<span class="fc" id="L307">                return scale(v, GIGA);</span>
            } else {
<span class="nc" id="L309">                return scale(v, TERA);</span>
            }
        }
    }

    /**
     * A private helper method to get a localized message and also
     * apply any arguments that we might pass.
     */
    private static String getLocalizedMessage(String key, Object... args) {
<span class="fc" id="L319">        String msg = ResourceBundleHolder.RB.getString(key);</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        return (args != null) ? MessageFormat.format(msg, args) : msg;</span>
    }

    /**
     * The java -help message is split into 3 parts, an invariant, followed
     * by a set of platform dependent variant messages, finally an invariant
     * set of lines.
     * This method initializes the help message for the first time, and also
     * assembles the invariant header part of the message.
     */
    static void initHelpMessage(String progname) {
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.header&quot;,</span>
                (progname == null) ? &quot;java&quot; : progname ));
<span class="fc" id="L333">        outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.datamodel&quot;,</span>
<span class="fc" id="L334">                32));</span>
<span class="fc" id="L335">        outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.datamodel&quot;,</span>
<span class="fc" id="L336">                64));</span>
<span class="fc" id="L337">    }</span>

    /**
     * Appends the vm selection messages to the header, already created.
     * initHelpSystem must already be called.
     */
    static void appendVmSelectMessage(String vm1, String vm2) {
<span class="fc" id="L344">        outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.vmselect&quot;,</span>
                vm1, vm2));
<span class="fc" id="L346">    }</span>

    /**
     * Appends the vm synoym message to the header, already created.
     * initHelpSystem must be called before using this method.
     */
    static void appendVmSynonymMessage(String vm1, String vm2) {
<span class="nc" id="L353">        outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.hotspot&quot;,</span>
                vm1, vm2));
<span class="nc" id="L355">    }</span>

    /**
     * Appends the vm Ergo message to the header, already created.
     * initHelpSystem must be called before using this method.
     */
    static void appendVmErgoMessage(boolean isServerClass, String vm) {
<span class="fc" id="L362">        outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.ergo.message1&quot;,</span>
                vm));
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        outBuf = (isServerClass)</span>
<span class="pc" id="L365">             ? outBuf.append(&quot;,\n&quot; +</span>
<span class="fc" id="L366">                getLocalizedMessage(&quot;java.launcher.ergo.message2&quot;) + &quot;\n\n&quot;)</span>
<span class="pc" id="L367">             : outBuf.append(&quot;.\n\n&quot;);</span>
<span class="fc" id="L368">    }</span>

    /**
     * Appends the last invariant part to the previously created messages,
     * and finishes up the printing to the desired output stream.
     * initHelpSystem must be called before using this method.
     */
    static void printHelpMessage(boolean printToStderr) {
<span class="fc" id="L376">        initOutput(printToStderr);</span>
<span class="fc" id="L377">        outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.footer&quot;,</span>
                File.pathSeparator));
<span class="fc" id="L379">        ostream.println(outBuf.toString());</span>
<span class="fc" id="L380">    }</span>

    /**
     * Prints the Xusage text to the desired output stream.
     */
    static void printXUsageMessage(boolean printToStderr) {
<span class="fc" id="L386">        initOutput(printToStderr);</span>
<span class="fc" id="L387">        ostream.println(getLocalizedMessage(&quot;java.launcher.X.usage&quot;,</span>
                File.pathSeparator));
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (System.getProperty(&quot;os.name&quot;).contains(&quot;OS X&quot;)) {</span>
<span class="nc" id="L390">            ostream.println(getLocalizedMessage(&quot;java.launcher.X.macosx.usage&quot;,</span>
                        File.pathSeparator));
        }
<span class="fc" id="L393">    }</span>

    static void initOutput(boolean printToStderr) {
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        ostream =  (printToStderr) ? System.err : System.out;</span>
<span class="fc" id="L397">    }</span>

    static String getMainClassFromJar(String jarname) {
<span class="fc" id="L400">        String mainValue = null;</span>
<span class="pc" id="L401">        try (JarFile jarFile = new JarFile(jarname)) {</span>
<span class="fc" id="L402">            Manifest manifest = jarFile.getManifest();</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">            if (manifest == null) {</span>
<span class="nc" id="L404">                abort(null, &quot;java.launcher.jar.error2&quot;, jarname);</span>
            }
<span class="fc" id="L406">            Attributes mainAttrs = manifest.getMainAttributes();</span>
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">            if (mainAttrs == null) {</span>
<span class="nc" id="L408">                abort(null, &quot;java.launcher.jar.error3&quot;, jarname);</span>
            }
<span class="fc" id="L410">            mainValue = mainAttrs.getValue(MAIN_CLASS);</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">            if (mainValue == null) {</span>
<span class="nc" id="L412">                abort(null, &quot;java.launcher.jar.error3&quot;, jarname);</span>
            }

            /*
             * Hand off to FXHelper if it detects a JavaFX application
             * This must be done after ensuring a Main-Class entry
             * exists to enforce compliance with the jar specification
             */
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            if (mainAttrs.containsKey(</span>
                    new Attributes.Name(FXHelper.JAVAFX_APPLICATION_MARKER))) {
<span class="nc" id="L422">                return FXHelper.class.getName();</span>
            }

<span class="fc" id="L425">            return mainValue.trim();</span>
<span class="pc bpc" id="L426" title="10 of 12 branches missed.">        } catch (IOException ioe) {</span>
<span class="nc" id="L427">            abort(ioe, &quot;java.launcher.jar.error1&quot;, jarname);</span>
        }
<span class="nc" id="L429">        return null;</span>
    }

    // From src/share/bin/java.c:
    //   enum LaunchMode { LM_UNKNOWN = 0, LM_CLASS, LM_JAR };

    private static final int LM_UNKNOWN = 0;
    private static final int LM_CLASS   = 1;
    private static final int LM_JAR     = 2;

    static void abort(Throwable t, String msgKey, Object... args) {
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        if (msgKey != null) {</span>
<span class="fc" id="L441">            ostream.println(getLocalizedMessage(msgKey, args));</span>
        }
<span class="fc bfc" id="L443" title="All 2 branches covered.">        if (trace) {</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">            if (t != null) {</span>
<span class="fc" id="L445">                t.printStackTrace();</span>
            } else {
<span class="nc" id="L447">                Thread.dumpStack();</span>
            }
        }
<span class="nc" id="L450">        System.exit(1);</span>
<span class="nc" id="L451">    }</span>

    /**
     * This method does the following:
     * 1. gets the classname from a Jar's manifest, if necessary
     * 2. loads the class using the System ClassLoader
     * 3. ensures the availability and accessibility of the main method,
     *    using signatureDiagnostic method.
     *    a. does the class exist
     *    b. is there a main
     *    c. is the main public
     *    d. is the main static
     *    e. does the main take a String array for args
     * 4. if no main method and if the class extends FX Application, then call
     *    on FXHelper to determine the main class to launch
     * 5. and off we go......
     *
     * @param printToStderr if set, all output will be routed to stderr
     * @param mode LaunchMode as determined by the arguments passed on the
     * command line
     * @param what either the jar file to launch or the main class when using
     * LM_CLASS mode
     * @return the application's main class
     */
    public static Class&lt;?&gt; checkAndLoadMain(boolean printToStderr,
                                            int mode,
                                            String what) {
<span class="fc" id="L478">        initOutput(printToStderr);</span>
        // get the class name
<span class="fc" id="L480">        String cn = null;</span>
<span class="pc bpc" id="L481" title="1 of 3 branches missed.">        switch (mode) {</span>
            case LM_CLASS:
<span class="fc" id="L483">                cn = what;</span>
<span class="fc" id="L484">                break;</span>
            case LM_JAR:
<span class="fc" id="L486">                cn = getMainClassFromJar(what);</span>
<span class="fc" id="L487">                break;</span>
            default:
                // should never happen
<span class="nc" id="L490">                throw new InternalError(&quot;&quot; + mode + &quot;: Unknown launch mode&quot;);</span>
        }
<span class="fc" id="L492">        cn = cn.replace('/', '.');</span>
<span class="fc" id="L493">        Class&lt;?&gt; mainClass = null;</span>
        try {
<span class="fc" id="L495">            mainClass = scloader.loadClass(cn);</span>
<span class="fc" id="L496">        } catch (NoClassDefFoundError | ClassNotFoundException cnfe) {</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">            if (System.getProperty(&quot;os.name&quot;, &quot;&quot;).contains(&quot;OS X&quot;)</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                &amp;&amp; Normalizer.isNormalized(cn, Normalizer.Form.NFD)) {</span>
                try {
                    // On Mac OS X since all names with diacretic symbols are given as decomposed it
                    // is possible that main class name comes incorrectly from the command line
                    // and we have to re-compose it
<span class="nc" id="L503">                    mainClass = scloader.loadClass(Normalizer.normalize(cn, Normalizer.Form.NFC));</span>
<span class="nc" id="L504">                } catch (NoClassDefFoundError | ClassNotFoundException cnfe1) {</span>
<span class="nc" id="L505">                    abort(cnfe, &quot;java.launcher.cls.error1&quot;, cn);</span>
<span class="nc" id="L506">                }</span>
            } else {
<span class="nc" id="L508">                abort(cnfe, &quot;java.launcher.cls.error1&quot;, cn);</span>
            }
<span class="fc" id="L510">        }</span>
        // set to mainClass
<span class="fc" id="L512">        appClass = mainClass;</span>

        /*
         * Check if FXHelper can launch it using the FX launcher. In an FX app,
         * the main class may or may not have a main method, so do this before
         * validating the main class.
         */
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">        if (mainClass.equals(FXHelper.class) ||</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">                FXHelper.doesExtendFXApplication(mainClass)) {</span>
            // Will abort() if there are problems with the FX runtime
<span class="nc" id="L522">            FXHelper.setFXLaunchParameters(what, mode);</span>
<span class="nc" id="L523">            return FXHelper.class;</span>
        }

<span class="fc" id="L526">        validateMainClass(mainClass);</span>
<span class="fc" id="L527">        return mainClass;</span>
    }

    /*
     * Accessor method called by the launcher after getting the main class via
     * checkAndLoadMain(). The &quot;application class&quot; is the class that is finally
     * executed to start the application and in this case is used to report
     * the correct application name, typically for UI purposes.
     */
    public static Class&lt;?&gt; getApplicationClass() {
<span class="fc" id="L537">        return appClass;</span>
    }

    // Check the existence and signature of main and abort if incorrect
    static void validateMainClass(Class&lt;?&gt; mainClass) {
        Method mainMethod;
        try {
<span class="fc" id="L544">            mainMethod = mainClass.getMethod(&quot;main&quot;, String[].class);</span>
<span class="nc" id="L545">        } catch (NoSuchMethodException nsme) {</span>
            // invalid main or not FX application, abort with an error
<span class="nc" id="L547">            abort(null, &quot;java.launcher.cls.error4&quot;, mainClass.getName(),</span>
                  FXHelper.JAVAFX_APPLICATION_CLASS_NAME);
<span class="nc" id="L549">            return; // Avoid compiler issues</span>
<span class="fc" id="L550">        }</span>

        /*
         * getMethod (above) will choose the correct method, based
         * on its name and parameter type, however, we still have to
         * ensure that the method is static and returns a void.
         */
<span class="fc" id="L557">        int mod = mainMethod.getModifiers();</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">        if (!Modifier.isStatic(mod)) {</span>
<span class="nc" id="L559">            abort(null, &quot;java.launcher.cls.error2&quot;, &quot;static&quot;,</span>
<span class="nc" id="L560">                  mainMethod.getDeclaringClass().getName());</span>
        }
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">        if (mainMethod.getReturnType() != java.lang.Void.TYPE) {</span>
<span class="nc" id="L563">            abort(null, &quot;java.launcher.cls.error3&quot;,</span>
<span class="nc" id="L564">                  mainMethod.getDeclaringClass().getName());</span>
        }
<span class="fc" id="L566">    }</span>

    private static final String encprop = &quot;sun.jnu.encoding&quot;;
<span class="fc" id="L569">    private static String encoding = null;</span>
<span class="fc" id="L570">    private static boolean isCharsetSupported = false;</span>

    /*
     * converts a c or a byte array to a platform specific string,
     * previously implemented as a native method in the launcher.
     */
    static String makePlatformString(boolean printToStderr, byte[] inArray) {
<span class="fc" id="L577">        initOutput(printToStderr);</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">        if (encoding == null) {</span>
<span class="fc" id="L579">            encoding = System.getProperty(encprop);</span>
<span class="fc" id="L580">            isCharsetSupported = Charset.isSupported(encoding);</span>
        }
        try {
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">            String out = isCharsetSupported</span>
                    ? new String(inArray, encoding)
                    : new String(inArray);
<span class="fc" id="L586">            return out;</span>
<span class="nc" id="L587">        } catch (UnsupportedEncodingException uee) {</span>
<span class="nc" id="L588">            abort(uee, null);</span>
        }
<span class="nc" id="L590">        return null; // keep the compiler happy</span>
    }

    static String[] expandArgs(String[] argArray) {
<span class="nc" id="L594">        List&lt;StdArg&gt; aList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">        for (String x : argArray) {</span>
<span class="nc" id="L596">            aList.add(new StdArg(x));</span>
        }
<span class="nc" id="L598">        return expandArgs(aList);</span>
    }

    static String[] expandArgs(List&lt;StdArg&gt; argList) {
<span class="nc" id="L602">        ArrayList&lt;String&gt; out = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">        if (trace) {</span>
<span class="nc" id="L604">            System.err.println(&quot;Incoming arguments:&quot;);</span>
        }
<span class="nc bnc" id="L606" title="All 2 branches missed.">        for (StdArg a : argList) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">            if (trace) {</span>
<span class="nc" id="L608">                System.err.println(a);</span>
            }
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (a.needsExpansion) {</span>
<span class="nc" id="L611">                File x = new File(a.arg);</span>
<span class="nc" id="L612">                File parent = x.getParentFile();</span>
<span class="nc" id="L613">                String glob = x.getName();</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">                if (parent == null) {</span>
<span class="nc" id="L615">                    parent = new File(&quot;.&quot;);</span>
                }
<span class="nc" id="L617">                try (DirectoryStream&lt;Path&gt; dstream =</span>
<span class="nc" id="L618">                        Files.newDirectoryStream(parent.toPath(), glob)) {</span>
<span class="nc" id="L619">                    int entries = 0;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">                    for (Path p : dstream) {</span>
<span class="nc" id="L621">                        out.add(p.normalize().toString());</span>
<span class="nc" id="L622">                        entries++;</span>
<span class="nc" id="L623">                    }</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                    if (entries == 0) {</span>
<span class="nc" id="L625">                        out.add(a.arg);</span>
                    }
<span class="nc bnc" id="L627" title="All 8 branches missed.">                } catch (Exception e) {</span>
<span class="nc" id="L628">                    out.add(a.arg);</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">                    if (trace) {</span>
<span class="nc" id="L630">                        System.err.println(&quot;Warning: passing argument as-is &quot; + a);</span>
<span class="nc" id="L631">                        System.err.print(e);</span>
                    }
<span class="nc" id="L633">                }</span>
<span class="nc" id="L634">            } else {</span>
<span class="nc" id="L635">                out.add(a.arg);</span>
            }
<span class="nc" id="L637">        }</span>
<span class="nc" id="L638">        String[] oarray = new String[out.size()];</span>
<span class="nc" id="L639">        out.toArray(oarray);</span>

<span class="nc bnc" id="L641" title="All 2 branches missed.">        if (trace) {</span>
<span class="nc" id="L642">            System.err.println(&quot;Expanded arguments:&quot;);</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">            for (String x : oarray) {</span>
<span class="nc" id="L644">                System.err.println(x);</span>
            }
        }
<span class="nc" id="L647">        return oarray;</span>
    }

    /* duplicate of the native StdArg struct */
    private static class StdArg {
        final String arg;
        final boolean needsExpansion;
<span class="nc" id="L654">        StdArg(String arg, boolean expand) {</span>
<span class="nc" id="L655">            this.arg = arg;</span>
<span class="nc" id="L656">            this.needsExpansion = expand;</span>
<span class="nc" id="L657">        }</span>
        // protocol: first char indicates whether expansion is required
        // 'T' = true ; needs expansion
        // 'F' = false; needs no expansion
<span class="nc" id="L661">        StdArg(String in) {</span>
<span class="nc" id="L662">            this.arg = in.substring(1);</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">            needsExpansion = in.charAt(0) == 'T';</span>
<span class="nc" id="L664">        }</span>
        public String toString() {
<span class="nc" id="L666">            return &quot;StdArg{&quot; + &quot;arg=&quot; + arg + &quot;, needsExpansion=&quot; + needsExpansion + '}';</span>
        }
    }

<span class="pc" id="L670">    static final class FXHelper {</span>
        // Marker entry in jar manifest that designates a JavaFX application jar
        private static final String JAVAFX_APPLICATION_MARKER =
                &quot;JavaFX-Application-Class&quot;;
        private static final String JAVAFX_APPLICATION_CLASS_NAME =
                &quot;javafx.application.Application&quot;;
        private static final String JAVAFX_LAUNCHER_CLASS_NAME =
                &quot;com.sun.javafx.application.LauncherImpl&quot;;

        /*
         * The launch method used to invoke the JavaFX launcher. These must
         * match the strings used in the launchApplication method.
         *
         * Command line                 JavaFX-App-Class  Launch mode  FX Launch mode
         * java -cp fxapp.jar FXClass   N/A               LM_CLASS     &quot;LM_CLASS&quot;
         * java -cp somedir FXClass     N/A               LM_CLASS     &quot;LM_CLASS&quot;
         * java -jar fxapp.jar          Present           LM_JAR       &quot;LM_JAR&quot;
         * java -jar fxapp.jar          Not Present       LM_JAR       &quot;LM_JAR&quot;
         */
        private static final String JAVAFX_LAUNCH_MODE_CLASS = &quot;LM_CLASS&quot;;
        private static final String JAVAFX_LAUNCH_MODE_JAR = &quot;LM_JAR&quot;;

        /*
         * FX application launcher and launch method, so we can launch
         * applications with no main method.
         */
<span class="fc" id="L696">        private static String fxLaunchName = null;</span>
<span class="fc" id="L697">        private static String fxLaunchMode = null;</span>

<span class="fc" id="L699">        private static Class&lt;?&gt; fxLauncherClass    = null;</span>
<span class="fc" id="L700">        private static Method   fxLauncherMethod   = null;</span>

        /*
         * Set the launch params according to what was passed to LauncherHelper
         * so we can use the same launch mode for FX. Abort if there is any
         * issue with loading the FX runtime or with the launcher method.
         */
        private static void setFXLaunchParameters(String what, int mode) {
            // Check for the FX launcher classes
            try {
<span class="nc" id="L710">                fxLauncherClass = scloader.loadClass(JAVAFX_LAUNCHER_CLASS_NAME);</span>
                /*
                 * signature must be:
                 * public static void launchApplication(String launchName,
                 *     String launchMode, String[] args);
                 */
<span class="nc" id="L716">                fxLauncherMethod = fxLauncherClass.getMethod(&quot;launchApplication&quot;,</span>
                        String.class, String.class, String[].class);

                // verify launcher signature as we do when validating the main method
<span class="nc" id="L720">                int mod = fxLauncherMethod.getModifiers();</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                if (!Modifier.isStatic(mod)) {</span>
<span class="nc" id="L722">                    abort(null, &quot;java.launcher.javafx.error1&quot;);</span>
                }
<span class="nc bnc" id="L724" title="All 2 branches missed.">                if (fxLauncherMethod.getReturnType() != java.lang.Void.TYPE) {</span>
<span class="nc" id="L725">                    abort(null, &quot;java.launcher.javafx.error1&quot;);</span>
                }
<span class="nc" id="L727">            } catch (ClassNotFoundException | NoSuchMethodException ex) {</span>
<span class="nc" id="L728">                abort(ex, &quot;java.launcher.cls.error5&quot;, ex);</span>
<span class="nc" id="L729">            }</span>

<span class="nc" id="L731">            fxLaunchName = what;</span>
<span class="nc bnc" id="L732" title="All 3 branches missed.">            switch (mode) {</span>
                case LM_CLASS:
<span class="nc" id="L734">                    fxLaunchMode = JAVAFX_LAUNCH_MODE_CLASS;</span>
<span class="nc" id="L735">                    break;</span>
                case LM_JAR:
<span class="nc" id="L737">                    fxLaunchMode = JAVAFX_LAUNCH_MODE_JAR;</span>
<span class="nc" id="L738">                    break;</span>
                default:
                    // should not have gotten this far...
<span class="nc" id="L741">                    throw new InternalError(mode + &quot;: Unknown launch mode&quot;);</span>
            }
<span class="nc" id="L743">        }</span>

        /*
         * Check if the given class is a JavaFX Application class. This is done
         * in a way that does not cause the Application class to load or throw
         * ClassNotFoundException if the JavaFX runtime is not available.
         */
        private static boolean doesExtendFXApplication(Class&lt;?&gt; mainClass) {
<span class="fc bfc" id="L751" title="All 2 branches covered.">            for (Class&lt;?&gt; sc = mainClass.getSuperclass(); sc != null;</span>
<span class="fc" id="L752">                    sc = sc.getSuperclass()) {</span>
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">                if (sc.getName().equals(JAVAFX_APPLICATION_CLASS_NAME)) {</span>
<span class="nc" id="L754">                    return true;</span>
                }
            }
<span class="fc" id="L757">            return false;</span>
        }

        public static void main(String... args) throws Exception {
<span class="nc bnc" id="L761" title="All 6 branches missed.">            if (fxLauncherMethod == null</span>
                    || fxLaunchMode == null
                    || fxLaunchName == null) {
<span class="nc" id="L764">                throw new RuntimeException(&quot;Invalid JavaFX launch parameters&quot;);</span>
            }
            // launch appClass via fxLauncherMethod
<span class="nc" id="L767">            fxLauncherMethod.invoke(null,</span>
                    new Object[] {fxLaunchName, fxLaunchMode, args});
<span class="nc" id="L769">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>