<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Frame.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">jdk.internal.org.objectweb.asm.tree.analysis</a> &gt; <span class="el_source">Frame.java</span></div><h1>Frame.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm.tree.analysis;

import java.util.ArrayList;
import java.util.List;

import jdk.internal.org.objectweb.asm.Opcodes;
import jdk.internal.org.objectweb.asm.Type;
import jdk.internal.org.objectweb.asm.tree.AbstractInsnNode;
import jdk.internal.org.objectweb.asm.tree.IincInsnNode;
import jdk.internal.org.objectweb.asm.tree.InvokeDynamicInsnNode;
import jdk.internal.org.objectweb.asm.tree.MethodInsnNode;
import jdk.internal.org.objectweb.asm.tree.MultiANewArrayInsnNode;
import jdk.internal.org.objectweb.asm.tree.VarInsnNode;

/**
 * A symbolic execution stack frame. A stack frame contains a set of local
 * variable slots, and an operand stack. Warning: long and double values are
 * represented by &lt;i&gt;two&lt;/i&gt; slots in local variables, and by &lt;i&gt;one&lt;/i&gt; slot in
 * the operand stack.
 *
 * @param &lt;V&gt;
 *            type of the Value used for the analysis.
 *
 * @author Eric Bruneton
 */
public class Frame&lt;V extends Value&gt; {

    /**
     * The expected return type of the analyzed method, or &lt;tt&gt;null&lt;/tt&gt; if the
     * method returns void.
     */
    private V returnValue;

    /**
     * The local variables and operand stack of this frame.
     */
    private V[] values;

    /**
     * The number of local variables of this frame.
     */
    private int locals;

    /**
     * The number of elements in the operand stack.
     */
    private int top;

    /**
     * Constructs a new frame with the given size.
     *
     * @param nLocals
     *            the maximum number of local variables of the frame.
     * @param nStack
     *            the maximum stack size of the frame.
     */
<span class="nc" id="L115">    public Frame(final int nLocals, final int nStack) {</span>
<span class="nc" id="L116">        this.values = (V[]) new Value[nLocals + nStack];</span>
<span class="nc" id="L117">        this.locals = nLocals;</span>
<span class="nc" id="L118">    }</span>

    /**
     * Constructs a new frame that is identical to the given frame.
     *
     * @param src
     *            a frame.
     */
    public Frame(final Frame&lt;? extends V&gt; src) {
<span class="nc" id="L127">        this(src.locals, src.values.length - src.locals);</span>
<span class="nc" id="L128">        init(src);</span>
<span class="nc" id="L129">    }</span>

    /**
     * Copies the state of the given frame into this frame.
     *
     * @param src
     *            a frame.
     * @return this frame.
     */
    public Frame&lt;V&gt; init(final Frame&lt;? extends V&gt; src) {
<span class="nc" id="L139">        returnValue = src.returnValue;</span>
<span class="nc" id="L140">        System.arraycopy(src.values, 0, values, 0, values.length);</span>
<span class="nc" id="L141">        top = src.top;</span>
<span class="nc" id="L142">        return this;</span>
    }

    /**
     * Sets the expected return type of the analyzed method.
     *
     * @param v
     *            the expected return type of the analyzed method, or
     *            &lt;tt&gt;null&lt;/tt&gt; if the method returns void.
     */
    public void setReturn(final V v) {
<span class="nc" id="L153">        returnValue = v;</span>
<span class="nc" id="L154">    }</span>

    /**
     * Returns the maximum number of local variables of this frame.
     *
     * @return the maximum number of local variables of this frame.
     */
    public int getLocals() {
<span class="nc" id="L162">        return locals;</span>
    }

    /**
     * Returns the maximum stack size of this frame.
     *
     * @return the maximum stack size of this frame.
     */
    public int getMaxStackSize() {
<span class="nc" id="L171">        return values.length - locals;</span>
    }

    /**
     * Returns the value of the given local variable.
     *
     * @param i
     *            a local variable index.
     * @return the value of the given local variable.
     * @throws IndexOutOfBoundsException
     *             if the variable does not exist.
     */
    public V getLocal(final int i) throws IndexOutOfBoundsException {
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (i &gt;= locals) {</span>
<span class="nc" id="L185">            throw new IndexOutOfBoundsException(</span>
                    &quot;Trying to access an inexistant local variable&quot;);
        }
<span class="nc" id="L188">        return values[i];</span>
    }

    /**
     * Sets the value of the given local variable.
     *
     * @param i
     *            a local variable index.
     * @param value
     *            the new value of this local variable.
     * @throws IndexOutOfBoundsException
     *             if the variable does not exist.
     */
    public void setLocal(final int i, final V value)
            throws IndexOutOfBoundsException {
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (i &gt;= locals) {</span>
<span class="nc" id="L204">            throw new IndexOutOfBoundsException(</span>
                    &quot;Trying to access an inexistant local variable &quot; + i);
        }
<span class="nc" id="L207">        values[i] = value;</span>
<span class="nc" id="L208">    }</span>

    /**
     * Returns the number of values in the operand stack of this frame. Long and
     * double values are treated as single values.
     *
     * @return the number of values in the operand stack of this frame.
     */
    public int getStackSize() {
<span class="nc" id="L217">        return top;</span>
    }

    /**
     * Returns the value of the given operand stack slot.
     *
     * @param i
     *            the index of an operand stack slot.
     * @return the value of the given operand stack slot.
     * @throws IndexOutOfBoundsException
     *             if the operand stack slot does not exist.
     */
    public V getStack(final int i) throws IndexOutOfBoundsException {
<span class="nc" id="L230">        return values[i + locals];</span>
    }

    /**
     * Clears the operand stack of this frame.
     */
    public void clearStack() {
<span class="nc" id="L237">        top = 0;</span>
<span class="nc" id="L238">    }</span>

    /**
     * Pops a value from the operand stack of this frame.
     *
     * @return the value that has been popped from the stack.
     * @throws IndexOutOfBoundsException
     *             if the operand stack is empty.
     */
    public V pop() throws IndexOutOfBoundsException {
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (top == 0) {</span>
<span class="nc" id="L249">            throw new IndexOutOfBoundsException(</span>
                    &quot;Cannot pop operand off an empty stack.&quot;);
        }
<span class="nc" id="L252">        return values[--top + locals];</span>
    }

    /**
     * Pushes a value into the operand stack of this frame.
     *
     * @param value
     *            the value that must be pushed into the stack.
     * @throws IndexOutOfBoundsException
     *             if the operand stack is full.
     */
    public void push(final V value) throws IndexOutOfBoundsException {
<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (top + locals &gt;= values.length) {</span>
<span class="nc" id="L265">            throw new IndexOutOfBoundsException(</span>
                    &quot;Insufficient maximum stack size.&quot;);
        }
<span class="nc" id="L268">        values[top++ + locals] = value;</span>
<span class="nc" id="L269">    }</span>

    public void execute(final AbstractInsnNode insn,
            final Interpreter&lt;V&gt; interpreter) throws AnalyzerException {
        V value1, value2, value3, value4;
        List&lt;V&gt; values;
        int var;

<span class="nc bnc" id="L277" title="All 43 branches missed.">        switch (insn.getOpcode()) {</span>
        case Opcodes.NOP:
<span class="nc" id="L279">            break;</span>
        case Opcodes.ACONST_NULL:
        case Opcodes.ICONST_M1:
        case Opcodes.ICONST_0:
        case Opcodes.ICONST_1:
        case Opcodes.ICONST_2:
        case Opcodes.ICONST_3:
        case Opcodes.ICONST_4:
        case Opcodes.ICONST_5:
        case Opcodes.LCONST_0:
        case Opcodes.LCONST_1:
        case Opcodes.FCONST_0:
        case Opcodes.FCONST_1:
        case Opcodes.FCONST_2:
        case Opcodes.DCONST_0:
        case Opcodes.DCONST_1:
        case Opcodes.BIPUSH:
        case Opcodes.SIPUSH:
        case Opcodes.LDC:
<span class="nc" id="L298">            push(interpreter.newOperation(insn));</span>
<span class="nc" id="L299">            break;</span>
        case Opcodes.ILOAD:
        case Opcodes.LLOAD:
        case Opcodes.FLOAD:
        case Opcodes.DLOAD:
        case Opcodes.ALOAD:
<span class="nc" id="L305">            push(interpreter.copyOperation(insn,</span>
<span class="nc" id="L306">                    getLocal(((VarInsnNode) insn).var)));</span>
<span class="nc" id="L307">            break;</span>
        case Opcodes.IALOAD:
        case Opcodes.LALOAD:
        case Opcodes.FALOAD:
        case Opcodes.DALOAD:
        case Opcodes.AALOAD:
        case Opcodes.BALOAD:
        case Opcodes.CALOAD:
        case Opcodes.SALOAD:
<span class="nc" id="L316">            value2 = pop();</span>
<span class="nc" id="L317">            value1 = pop();</span>
<span class="nc" id="L318">            push(interpreter.binaryOperation(insn, value1, value2));</span>
<span class="nc" id="L319">            break;</span>
        case Opcodes.ISTORE:
        case Opcodes.LSTORE:
        case Opcodes.FSTORE:
        case Opcodes.DSTORE:
        case Opcodes.ASTORE:
<span class="nc" id="L325">            value1 = interpreter.copyOperation(insn, pop());</span>
<span class="nc" id="L326">            var = ((VarInsnNode) insn).var;</span>
<span class="nc" id="L327">            setLocal(var, value1);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if (value1.getSize() == 2) {</span>
<span class="nc" id="L329">                setLocal(var + 1, interpreter.newValue(null));</span>
            }
<span class="nc bnc" id="L331" title="All 2 branches missed.">            if (var &gt; 0) {</span>
<span class="nc" id="L332">                Value local = getLocal(var - 1);</span>
<span class="nc bnc" id="L333" title="All 4 branches missed.">                if (local != null &amp;&amp; local.getSize() == 2) {</span>
<span class="nc" id="L334">                    setLocal(var - 1, interpreter.newValue(null));</span>
                }
<span class="nc" id="L336">            }</span>
            break;
        case Opcodes.IASTORE:
        case Opcodes.LASTORE:
        case Opcodes.FASTORE:
        case Opcodes.DASTORE:
        case Opcodes.AASTORE:
        case Opcodes.BASTORE:
        case Opcodes.CASTORE:
        case Opcodes.SASTORE:
<span class="nc" id="L346">            value3 = pop();</span>
<span class="nc" id="L347">            value2 = pop();</span>
<span class="nc" id="L348">            value1 = pop();</span>
<span class="nc" id="L349">            interpreter.ternaryOperation(insn, value1, value2, value3);</span>
<span class="nc" id="L350">            break;</span>
        case Opcodes.POP:
<span class="nc bnc" id="L352" title="All 2 branches missed.">            if (pop().getSize() == 2) {</span>
<span class="nc" id="L353">                throw new AnalyzerException(insn, &quot;Illegal use of POP&quot;);</span>
            }
            break;
        case Opcodes.POP2:
<span class="nc bnc" id="L357" title="All 2 branches missed.">            if (pop().getSize() == 1) {</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">                if (pop().getSize() != 1) {</span>
<span class="nc" id="L359">                    throw new AnalyzerException(insn, &quot;Illegal use of POP2&quot;);</span>
                }
            }
            break;
        case Opcodes.DUP:
<span class="nc" id="L364">            value1 = pop();</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">            if (value1.getSize() != 1) {</span>
<span class="nc" id="L366">                throw new AnalyzerException(insn, &quot;Illegal use of DUP&quot;);</span>
            }
<span class="nc" id="L368">            push(value1);</span>
<span class="nc" id="L369">            push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L370">            break;</span>
        case Opcodes.DUP_X1:
<span class="nc" id="L372">            value1 = pop();</span>
<span class="nc" id="L373">            value2 = pop();</span>
<span class="nc bnc" id="L374" title="All 4 branches missed.">            if (value1.getSize() != 1 || value2.getSize() != 1) {</span>
<span class="nc" id="L375">                throw new AnalyzerException(insn, &quot;Illegal use of DUP_X1&quot;);</span>
            }
<span class="nc" id="L377">            push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L378">            push(value2);</span>
<span class="nc" id="L379">            push(value1);</span>
<span class="nc" id="L380">            break;</span>
        case Opcodes.DUP_X2:
<span class="nc" id="L382">            value1 = pop();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">            if (value1.getSize() == 1) {</span>
<span class="nc" id="L384">                value2 = pop();</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">                if (value2.getSize() == 1) {</span>
<span class="nc" id="L386">                    value3 = pop();</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                    if (value3.getSize() == 1) {</span>
<span class="nc" id="L388">                        push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L389">                        push(value3);</span>
<span class="nc" id="L390">                        push(value2);</span>
<span class="nc" id="L391">                        push(value1);</span>
<span class="nc" id="L392">                        break;</span>
                    }
                } else {
<span class="nc" id="L395">                    push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L396">                    push(value2);</span>
<span class="nc" id="L397">                    push(value1);</span>
<span class="nc" id="L398">                    break;</span>
                }
            }
<span class="nc" id="L401">            throw new AnalyzerException(insn, &quot;Illegal use of DUP_X2&quot;);</span>
        case Opcodes.DUP2:
<span class="nc" id="L403">            value1 = pop();</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">            if (value1.getSize() == 1) {</span>
<span class="nc" id="L405">                value2 = pop();</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                if (value2.getSize() == 1) {</span>
<span class="nc" id="L407">                    push(value2);</span>
<span class="nc" id="L408">                    push(value1);</span>
<span class="nc" id="L409">                    push(interpreter.copyOperation(insn, value2));</span>
<span class="nc" id="L410">                    push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L411">                    break;</span>
                }
            } else {
<span class="nc" id="L414">                push(value1);</span>
<span class="nc" id="L415">                push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L416">                break;</span>
            }
<span class="nc" id="L418">            throw new AnalyzerException(insn, &quot;Illegal use of DUP2&quot;);</span>
        case Opcodes.DUP2_X1:
<span class="nc" id="L420">            value1 = pop();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (value1.getSize() == 1) {</span>
<span class="nc" id="L422">                value2 = pop();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                if (value2.getSize() == 1) {</span>
<span class="nc" id="L424">                    value3 = pop();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">                    if (value3.getSize() == 1) {</span>
<span class="nc" id="L426">                        push(interpreter.copyOperation(insn, value2));</span>
<span class="nc" id="L427">                        push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L428">                        push(value3);</span>
<span class="nc" id="L429">                        push(value2);</span>
<span class="nc" id="L430">                        push(value1);</span>
<span class="nc" id="L431">                        break;</span>
                    }
                }
            } else {
<span class="nc" id="L435">                value2 = pop();</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                if (value2.getSize() == 1) {</span>
<span class="nc" id="L437">                    push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L438">                    push(value2);</span>
<span class="nc" id="L439">                    push(value1);</span>
<span class="nc" id="L440">                    break;</span>
                }
            }
<span class="nc" id="L443">            throw new AnalyzerException(insn, &quot;Illegal use of DUP2_X1&quot;);</span>
        case Opcodes.DUP2_X2:
<span class="nc" id="L445">            value1 = pop();</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (value1.getSize() == 1) {</span>
<span class="nc" id="L447">                value2 = pop();</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                if (value2.getSize() == 1) {</span>
<span class="nc" id="L449">                    value3 = pop();</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">                    if (value3.getSize() == 1) {</span>
<span class="nc" id="L451">                        value4 = pop();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">                        if (value4.getSize() == 1) {</span>
<span class="nc" id="L453">                            push(interpreter.copyOperation(insn, value2));</span>
<span class="nc" id="L454">                            push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L455">                            push(value4);</span>
<span class="nc" id="L456">                            push(value3);</span>
<span class="nc" id="L457">                            push(value2);</span>
<span class="nc" id="L458">                            push(value1);</span>
<span class="nc" id="L459">                            break;</span>
                        }
                    } else {
<span class="nc" id="L462">                        push(interpreter.copyOperation(insn, value2));</span>
<span class="nc" id="L463">                        push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L464">                        push(value3);</span>
<span class="nc" id="L465">                        push(value2);</span>
<span class="nc" id="L466">                        push(value1);</span>
<span class="nc" id="L467">                        break;</span>
                    }
                }
            } else {
<span class="nc" id="L471">                value2 = pop();</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (value2.getSize() == 1) {</span>
<span class="nc" id="L473">                    value3 = pop();</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">                    if (value3.getSize() == 1) {</span>
<span class="nc" id="L475">                        push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L476">                        push(value3);</span>
<span class="nc" id="L477">                        push(value2);</span>
<span class="nc" id="L478">                        push(value1);</span>
<span class="nc" id="L479">                        break;</span>
                    }
                } else {
<span class="nc" id="L482">                    push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L483">                    push(value2);</span>
<span class="nc" id="L484">                    push(value1);</span>
<span class="nc" id="L485">                    break;</span>
                }
            }
<span class="nc" id="L488">            throw new AnalyzerException(insn, &quot;Illegal use of DUP2_X2&quot;);</span>
        case Opcodes.SWAP:
<span class="nc" id="L490">            value2 = pop();</span>
<span class="nc" id="L491">            value1 = pop();</span>
<span class="nc bnc" id="L492" title="All 4 branches missed.">            if (value1.getSize() != 1 || value2.getSize() != 1) {</span>
<span class="nc" id="L493">                throw new AnalyzerException(insn, &quot;Illegal use of SWAP&quot;);</span>
            }
<span class="nc" id="L495">            push(interpreter.copyOperation(insn, value2));</span>
<span class="nc" id="L496">            push(interpreter.copyOperation(insn, value1));</span>
<span class="nc" id="L497">            break;</span>
        case Opcodes.IADD:
        case Opcodes.LADD:
        case Opcodes.FADD:
        case Opcodes.DADD:
        case Opcodes.ISUB:
        case Opcodes.LSUB:
        case Opcodes.FSUB:
        case Opcodes.DSUB:
        case Opcodes.IMUL:
        case Opcodes.LMUL:
        case Opcodes.FMUL:
        case Opcodes.DMUL:
        case Opcodes.IDIV:
        case Opcodes.LDIV:
        case Opcodes.FDIV:
        case Opcodes.DDIV:
        case Opcodes.IREM:
        case Opcodes.LREM:
        case Opcodes.FREM:
        case Opcodes.DREM:
<span class="nc" id="L518">            value2 = pop();</span>
<span class="nc" id="L519">            value1 = pop();</span>
<span class="nc" id="L520">            push(interpreter.binaryOperation(insn, value1, value2));</span>
<span class="nc" id="L521">            break;</span>
        case Opcodes.INEG:
        case Opcodes.LNEG:
        case Opcodes.FNEG:
        case Opcodes.DNEG:
<span class="nc" id="L526">            push(interpreter.unaryOperation(insn, pop()));</span>
<span class="nc" id="L527">            break;</span>
        case Opcodes.ISHL:
        case Opcodes.LSHL:
        case Opcodes.ISHR:
        case Opcodes.LSHR:
        case Opcodes.IUSHR:
        case Opcodes.LUSHR:
        case Opcodes.IAND:
        case Opcodes.LAND:
        case Opcodes.IOR:
        case Opcodes.LOR:
        case Opcodes.IXOR:
        case Opcodes.LXOR:
<span class="nc" id="L540">            value2 = pop();</span>
<span class="nc" id="L541">            value1 = pop();</span>
<span class="nc" id="L542">            push(interpreter.binaryOperation(insn, value1, value2));</span>
<span class="nc" id="L543">            break;</span>
        case Opcodes.IINC:
<span class="nc" id="L545">            var = ((IincInsnNode) insn).var;</span>
<span class="nc" id="L546">            setLocal(var, interpreter.unaryOperation(insn, getLocal(var)));</span>
<span class="nc" id="L547">            break;</span>
        case Opcodes.I2L:
        case Opcodes.I2F:
        case Opcodes.I2D:
        case Opcodes.L2I:
        case Opcodes.L2F:
        case Opcodes.L2D:
        case Opcodes.F2I:
        case Opcodes.F2L:
        case Opcodes.F2D:
        case Opcodes.D2I:
        case Opcodes.D2L:
        case Opcodes.D2F:
        case Opcodes.I2B:
        case Opcodes.I2C:
        case Opcodes.I2S:
<span class="nc" id="L563">            push(interpreter.unaryOperation(insn, pop()));</span>
<span class="nc" id="L564">            break;</span>
        case Opcodes.LCMP:
        case Opcodes.FCMPL:
        case Opcodes.FCMPG:
        case Opcodes.DCMPL:
        case Opcodes.DCMPG:
<span class="nc" id="L570">            value2 = pop();</span>
<span class="nc" id="L571">            value1 = pop();</span>
<span class="nc" id="L572">            push(interpreter.binaryOperation(insn, value1, value2));</span>
<span class="nc" id="L573">            break;</span>
        case Opcodes.IFEQ:
        case Opcodes.IFNE:
        case Opcodes.IFLT:
        case Opcodes.IFGE:
        case Opcodes.IFGT:
        case Opcodes.IFLE:
<span class="nc" id="L580">            interpreter.unaryOperation(insn, pop());</span>
<span class="nc" id="L581">            break;</span>
        case Opcodes.IF_ICMPEQ:
        case Opcodes.IF_ICMPNE:
        case Opcodes.IF_ICMPLT:
        case Opcodes.IF_ICMPGE:
        case Opcodes.IF_ICMPGT:
        case Opcodes.IF_ICMPLE:
        case Opcodes.IF_ACMPEQ:
        case Opcodes.IF_ACMPNE:
<span class="nc" id="L590">            value2 = pop();</span>
<span class="nc" id="L591">            value1 = pop();</span>
<span class="nc" id="L592">            interpreter.binaryOperation(insn, value1, value2);</span>
<span class="nc" id="L593">            break;</span>
        case Opcodes.GOTO:
<span class="nc" id="L595">            break;</span>
        case Opcodes.JSR:
<span class="nc" id="L597">            push(interpreter.newOperation(insn));</span>
<span class="nc" id="L598">            break;</span>
        case Opcodes.RET:
<span class="nc" id="L600">            break;</span>
        case Opcodes.TABLESWITCH:
        case Opcodes.LOOKUPSWITCH:
<span class="nc" id="L603">            interpreter.unaryOperation(insn, pop());</span>
<span class="nc" id="L604">            break;</span>
        case Opcodes.IRETURN:
        case Opcodes.LRETURN:
        case Opcodes.FRETURN:
        case Opcodes.DRETURN:
        case Opcodes.ARETURN:
<span class="nc" id="L610">            value1 = pop();</span>
<span class="nc" id="L611">            interpreter.unaryOperation(insn, value1);</span>
<span class="nc" id="L612">            interpreter.returnOperation(insn, value1, returnValue);</span>
<span class="nc" id="L613">            break;</span>
        case Opcodes.RETURN:
<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (returnValue != null) {</span>
<span class="nc" id="L616">                throw new AnalyzerException(insn, &quot;Incompatible return type&quot;);</span>
            }
            break;
        case Opcodes.GETSTATIC:
<span class="nc" id="L620">            push(interpreter.newOperation(insn));</span>
<span class="nc" id="L621">            break;</span>
        case Opcodes.PUTSTATIC:
<span class="nc" id="L623">            interpreter.unaryOperation(insn, pop());</span>
<span class="nc" id="L624">            break;</span>
        case Opcodes.GETFIELD:
<span class="nc" id="L626">            push(interpreter.unaryOperation(insn, pop()));</span>
<span class="nc" id="L627">            break;</span>
        case Opcodes.PUTFIELD:
<span class="nc" id="L629">            value2 = pop();</span>
<span class="nc" id="L630">            value1 = pop();</span>
<span class="nc" id="L631">            interpreter.binaryOperation(insn, value1, value2);</span>
<span class="nc" id="L632">            break;</span>
        case Opcodes.INVOKEVIRTUAL:
        case Opcodes.INVOKESPECIAL:
        case Opcodes.INVOKESTATIC:
        case Opcodes.INVOKEINTERFACE: {
<span class="nc" id="L637">            values = new ArrayList&lt;V&gt;();</span>
<span class="nc" id="L638">            String desc = ((MethodInsnNode) insn).desc;</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">            for (int i = Type.getArgumentTypes(desc).length; i &gt; 0; --i) {</span>
<span class="nc" id="L640">                values.add(0, pop());</span>
            }
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (insn.getOpcode() != Opcodes.INVOKESTATIC) {</span>
<span class="nc" id="L643">                values.add(0, pop());</span>
            }
<span class="nc bnc" id="L645" title="All 2 branches missed.">            if (Type.getReturnType(desc) == Type.VOID_TYPE) {</span>
<span class="nc" id="L646">                interpreter.naryOperation(insn, values);</span>
            } else {
<span class="nc" id="L648">                push(interpreter.naryOperation(insn, values));</span>
            }
<span class="nc" id="L650">            break;</span>
        }
        case Opcodes.INVOKEDYNAMIC: {
<span class="nc" id="L653">            values = new ArrayList&lt;V&gt;();</span>
<span class="nc" id="L654">            String desc = ((InvokeDynamicInsnNode) insn).desc;</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">            for (int i = Type.getArgumentTypes(desc).length; i &gt; 0; --i) {</span>
<span class="nc" id="L656">                values.add(0, pop());</span>
            }
<span class="nc bnc" id="L658" title="All 2 branches missed.">            if (Type.getReturnType(desc) == Type.VOID_TYPE) {</span>
<span class="nc" id="L659">                interpreter.naryOperation(insn, values);</span>
            } else {
<span class="nc" id="L661">                push(interpreter.naryOperation(insn, values));</span>
            }
<span class="nc" id="L663">            break;</span>
        }
        case Opcodes.NEW:
<span class="nc" id="L666">            push(interpreter.newOperation(insn));</span>
<span class="nc" id="L667">            break;</span>
        case Opcodes.NEWARRAY:
        case Opcodes.ANEWARRAY:
        case Opcodes.ARRAYLENGTH:
<span class="nc" id="L671">            push(interpreter.unaryOperation(insn, pop()));</span>
<span class="nc" id="L672">            break;</span>
        case Opcodes.ATHROW:
<span class="nc" id="L674">            interpreter.unaryOperation(insn, pop());</span>
<span class="nc" id="L675">            break;</span>
        case Opcodes.CHECKCAST:
        case Opcodes.INSTANCEOF:
<span class="nc" id="L678">            push(interpreter.unaryOperation(insn, pop()));</span>
<span class="nc" id="L679">            break;</span>
        case Opcodes.MONITORENTER:
        case Opcodes.MONITOREXIT:
<span class="nc" id="L682">            interpreter.unaryOperation(insn, pop());</span>
<span class="nc" id="L683">            break;</span>
        case Opcodes.MULTIANEWARRAY:
<span class="nc" id="L685">            values = new ArrayList&lt;V&gt;();</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">            for (int i = ((MultiANewArrayInsnNode) insn).dims; i &gt; 0; --i) {</span>
<span class="nc" id="L687">                values.add(0, pop());</span>
            }
<span class="nc" id="L689">            push(interpreter.naryOperation(insn, values));</span>
<span class="nc" id="L690">            break;</span>
        case Opcodes.IFNULL:
        case Opcodes.IFNONNULL:
<span class="nc" id="L693">            interpreter.unaryOperation(insn, pop());</span>
<span class="nc" id="L694">            break;</span>
        default:
<span class="nc" id="L696">            throw new RuntimeException(&quot;Illegal opcode &quot; + insn.getOpcode());</span>
        }
<span class="nc" id="L698">    }</span>

    /**
     * Merges this frame with the given frame.
     *
     * @param frame
     *            a frame.
     * @param interpreter
     *            the interpreter used to merge values.
     * @return &lt;tt&gt;true&lt;/tt&gt; if this frame has been changed as a result of the
     *         merge operation, or &lt;tt&gt;false&lt;/tt&gt; otherwise.
     * @throws AnalyzerException
     *             if the frames have incompatible sizes.
     */
    public boolean merge(final Frame&lt;? extends V&gt; frame,
            final Interpreter&lt;V&gt; interpreter) throws AnalyzerException {
<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (top != frame.top) {</span>
<span class="nc" id="L715">            throw new AnalyzerException(null, &quot;Incompatible stack heights&quot;);</span>
        }
<span class="nc" id="L717">        boolean changes = false;</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">        for (int i = 0; i &lt; locals + top; ++i) {</span>
<span class="nc" id="L719">            V v = interpreter.merge(values[i], frame.values[i]);</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">            if (!v.equals(values[i])) {</span>
<span class="nc" id="L721">                values[i] = v;</span>
<span class="nc" id="L722">                changes = true;</span>
            }
        }
<span class="nc" id="L725">        return changes;</span>
    }

    /**
     * Merges this frame with the given frame (case of a RET instruction).
     *
     * @param frame
     *            a frame
     * @param access
     *            the local variables that have been accessed by the subroutine
     *            to which the RET instruction corresponds.
     * @return &lt;tt&gt;true&lt;/tt&gt; if this frame has been changed as a result of the
     *         merge operation, or &lt;tt&gt;false&lt;/tt&gt; otherwise.
     */
    public boolean merge(final Frame&lt;? extends V&gt; frame, final boolean[] access) {
<span class="nc" id="L740">        boolean changes = false;</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">        for (int i = 0; i &lt; locals; ++i) {</span>
<span class="nc bnc" id="L742" title="All 4 branches missed.">            if (!access[i] &amp;&amp; !values[i].equals(frame.values[i])) {</span>
<span class="nc" id="L743">                values[i] = frame.values[i];</span>
<span class="nc" id="L744">                changes = true;</span>
            }
        }
<span class="nc" id="L747">        return changes;</span>
    }

    /**
     * Returns a string representation of this frame.
     *
     * @return a string representation of this frame.
     */
    @Override
    public String toString() {
<span class="nc" id="L757">        StringBuffer b = new StringBuffer();</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">        for (int i = 0; i &lt; getLocals(); ++i) {</span>
<span class="nc" id="L759">            b.append(getLocal(i));</span>
        }
<span class="nc" id="L761">        b.append(' ');</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">        for (int i = 0; i &lt; getStackSize(); ++i) {</span>
<span class="nc" id="L763">            b.append(getStack(i).toString());</span>
        }
<span class="nc" id="L765">        return b.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>