<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Analyzer.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">jdk.internal.org.objectweb.asm.tree.analysis</a> &gt; <span class="el_source">Analyzer.java</span></div><h1>Analyzer.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm.tree.analysis;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import jdk.internal.org.objectweb.asm.Opcodes;
import jdk.internal.org.objectweb.asm.Type;
import jdk.internal.org.objectweb.asm.tree.AbstractInsnNode;
import jdk.internal.org.objectweb.asm.tree.IincInsnNode;
import jdk.internal.org.objectweb.asm.tree.InsnList;
import jdk.internal.org.objectweb.asm.tree.JumpInsnNode;
import jdk.internal.org.objectweb.asm.tree.LabelNode;
import jdk.internal.org.objectweb.asm.tree.LookupSwitchInsnNode;
import jdk.internal.org.objectweb.asm.tree.MethodNode;
import jdk.internal.org.objectweb.asm.tree.TableSwitchInsnNode;
import jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode;
import jdk.internal.org.objectweb.asm.tree.VarInsnNode;

/**
 * A semantic bytecode analyzer. &lt;i&gt;This class does not fully check that JSR and
 * RET instructions are valid.&lt;/i&gt;
 *
 * @param &lt;V&gt;
 *            type of the Value used for the analysis.
 *
 * @author Eric Bruneton
 */
public class Analyzer&lt;V extends Value&gt; implements Opcodes {

    private final Interpreter&lt;V&gt; interpreter;

    private int n;

    private InsnList insns;

    private List&lt;TryCatchBlockNode&gt;[] handlers;

    private Frame&lt;V&gt;[] frames;

    private Subroutine[] subroutines;

    private boolean[] queued;

    private int[] queue;

    private int top;

    /**
     * Constructs a new {@link Analyzer}.
     *
     * @param interpreter
     *            the interpreter to be used to symbolically interpret the
     *            bytecode instructions.
     */
<span class="nc" id="L115">    public Analyzer(final Interpreter&lt;V&gt; interpreter) {</span>
<span class="nc" id="L116">        this.interpreter = interpreter;</span>
<span class="nc" id="L117">    }</span>

    /**
     * Analyzes the given method.
     *
     * @param owner
     *            the internal name of the class to which the method belongs.
     * @param m
     *            the method to be analyzed.
     * @return the symbolic state of the execution stack frame at each bytecode
     *         instruction of the method. The size of the returned array is
     *         equal to the number of instructions (and labels) of the method. A
     *         given frame is &lt;tt&gt;null&lt;/tt&gt; if and only if the corresponding
     *         instruction cannot be reached (dead code).
     * @throws AnalyzerException
     *             if a problem occurs during the analysis.
     */
    public Frame&lt;V&gt;[] analyze(final String owner, final MethodNode m)
            throws AnalyzerException {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if ((m.access &amp; (ACC_ABSTRACT | ACC_NATIVE)) != 0) {</span>
<span class="nc" id="L137">            frames = (Frame&lt;V&gt;[]) new Frame&lt;?&gt;[0];</span>
<span class="nc" id="L138">            return frames;</span>
        }
<span class="nc" id="L140">        n = m.instructions.size();</span>
<span class="nc" id="L141">        insns = m.instructions;</span>
<span class="nc" id="L142">        handlers = (List&lt;TryCatchBlockNode&gt;[]) new List&lt;?&gt;[n];</span>
<span class="nc" id="L143">        frames = (Frame&lt;V&gt;[]) new Frame&lt;?&gt;[n];</span>
<span class="nc" id="L144">        subroutines = new Subroutine[n];</span>
<span class="nc" id="L145">        queued = new boolean[n];</span>
<span class="nc" id="L146">        queue = new int[n];</span>
<span class="nc" id="L147">        top = 0;</span>

        // computes exception handlers for each instruction
<span class="nc bnc" id="L150" title="All 2 branches missed.">        for (int i = 0; i &lt; m.tryCatchBlocks.size(); ++i) {</span>
<span class="nc" id="L151">            TryCatchBlockNode tcb = m.tryCatchBlocks.get(i);</span>
<span class="nc" id="L152">            int begin = insns.indexOf(tcb.start);</span>
<span class="nc" id="L153">            int end = insns.indexOf(tcb.end);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            for (int j = begin; j &lt; end; ++j) {</span>
<span class="nc" id="L155">                List&lt;TryCatchBlockNode&gt; insnHandlers = handlers[j];</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                if (insnHandlers == null) {</span>
<span class="nc" id="L157">                    insnHandlers = new ArrayList&lt;TryCatchBlockNode&gt;();</span>
<span class="nc" id="L158">                    handlers[j] = insnHandlers;</span>
                }
<span class="nc" id="L160">                insnHandlers.add(tcb);</span>
            }
        }

        // computes the subroutine for each instruction:
<span class="nc" id="L165">        Subroutine main = new Subroutine(null, m.maxLocals, null);</span>
<span class="nc" id="L166">        List&lt;AbstractInsnNode&gt; subroutineCalls = new ArrayList&lt;AbstractInsnNode&gt;();</span>
<span class="nc" id="L167">        Map&lt;LabelNode, Subroutine&gt; subroutineHeads = new HashMap&lt;LabelNode, Subroutine&gt;();</span>
<span class="nc" id="L168">        findSubroutine(0, main, subroutineCalls);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        while (!subroutineCalls.isEmpty()) {</span>
<span class="nc" id="L170">            JumpInsnNode jsr = (JumpInsnNode) subroutineCalls.remove(0);</span>
<span class="nc" id="L171">            Subroutine sub = subroutineHeads.get(jsr.label);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">            if (sub == null) {</span>
<span class="nc" id="L173">                sub = new Subroutine(jsr.label, m.maxLocals, jsr);</span>
<span class="nc" id="L174">                subroutineHeads.put(jsr.label, sub);</span>
<span class="nc" id="L175">                findSubroutine(insns.indexOf(jsr.label), sub, subroutineCalls);</span>
            } else {
<span class="nc" id="L177">                sub.callers.add(jsr);</span>
            }
<span class="nc" id="L179">        }</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L181" title="All 4 branches missed.">            if (subroutines[i] != null &amp;&amp; subroutines[i].start == null) {</span>
<span class="nc" id="L182">                subroutines[i] = null;</span>
            }
        }

        // initializes the data structures for the control flow analysis
<span class="nc" id="L187">        Frame&lt;V&gt; current = newFrame(m.maxLocals, m.maxStack);</span>
<span class="nc" id="L188">        Frame&lt;V&gt; handler = newFrame(m.maxLocals, m.maxStack);</span>
<span class="nc" id="L189">        current.setReturn(interpreter.newValue(Type.getReturnType(m.desc)));</span>
<span class="nc" id="L190">        Type[] args = Type.getArgumentTypes(m.desc);</span>
<span class="nc" id="L191">        int local = 0;</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if ((m.access &amp; ACC_STATIC) == 0) {</span>
<span class="nc" id="L193">            Type ctype = Type.getObjectType(owner);</span>
<span class="nc" id="L194">            current.setLocal(local++, interpreter.newValue(ctype));</span>
        }
<span class="nc bnc" id="L196" title="All 2 branches missed.">        for (int i = 0; i &lt; args.length; ++i) {</span>
<span class="nc" id="L197">            current.setLocal(local++, interpreter.newValue(args[i]));</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (args[i].getSize() == 2) {</span>
<span class="nc" id="L199">                current.setLocal(local++, interpreter.newValue(null));</span>
            }
        }
<span class="nc bnc" id="L202" title="All 2 branches missed.">        while (local &lt; m.maxLocals) {</span>
<span class="nc" id="L203">            current.setLocal(local++, interpreter.newValue(null));</span>
        }
<span class="nc" id="L205">        merge(0, current, null);</span>

<span class="nc" id="L207">        init(owner, m);</span>

        // control flow analysis
<span class="nc bnc" id="L210" title="All 2 branches missed.">        while (top &gt; 0) {</span>
<span class="nc" id="L211">            int insn = queue[--top];</span>
<span class="nc" id="L212">            Frame&lt;V&gt; f = frames[insn];</span>
<span class="nc" id="L213">            Subroutine subroutine = subroutines[insn];</span>
<span class="nc" id="L214">            queued[insn] = false;</span>

<span class="nc" id="L216">            AbstractInsnNode insnNode = null;</span>
            try {
<span class="nc" id="L218">                insnNode = m.instructions.get(insn);</span>
<span class="nc" id="L219">                int insnOpcode = insnNode.getOpcode();</span>
<span class="nc" id="L220">                int insnType = insnNode.getType();</span>

<span class="nc bnc" id="L222" title="All 6 branches missed.">                if (insnType == AbstractInsnNode.LABEL</span>
                        || insnType == AbstractInsnNode.LINE
                        || insnType == AbstractInsnNode.FRAME) {
<span class="nc" id="L225">                    merge(insn + 1, f, subroutine);</span>
<span class="nc" id="L226">                    newControlFlowEdge(insn, insn + 1);</span>
                } else {
<span class="nc" id="L228">                    current.init(f).execute(insnNode, interpreter);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">                    subroutine = subroutine == null ? null : subroutine.copy();</span>

<span class="nc bnc" id="L231" title="All 2 branches missed.">                    if (insnNode instanceof JumpInsnNode) {</span>
<span class="nc" id="L232">                        JumpInsnNode j = (JumpInsnNode) insnNode;</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">                        if (insnOpcode != GOTO &amp;&amp; insnOpcode != JSR) {</span>
<span class="nc" id="L234">                            merge(insn + 1, current, subroutine);</span>
<span class="nc" id="L235">                            newControlFlowEdge(insn, insn + 1);</span>
                        }
<span class="nc" id="L237">                        int jump = insns.indexOf(j.label);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                        if (insnOpcode == JSR) {</span>
<span class="nc" id="L239">                            merge(jump, current, new Subroutine(j.label,</span>
                                    m.maxLocals, j));
                        } else {
<span class="nc" id="L242">                            merge(jump, current, subroutine);</span>
                        }
<span class="nc" id="L244">                        newControlFlowEdge(insn, jump);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                    } else if (insnNode instanceof LookupSwitchInsnNode) {</span>
<span class="nc" id="L246">                        LookupSwitchInsnNode lsi = (LookupSwitchInsnNode) insnNode;</span>
<span class="nc" id="L247">                        int jump = insns.indexOf(lsi.dflt);</span>
<span class="nc" id="L248">                        merge(jump, current, subroutine);</span>
<span class="nc" id="L249">                        newControlFlowEdge(insn, jump);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                        for (int j = 0; j &lt; lsi.labels.size(); ++j) {</span>
<span class="nc" id="L251">                            LabelNode label = lsi.labels.get(j);</span>
<span class="nc" id="L252">                            jump = insns.indexOf(label);</span>
<span class="nc" id="L253">                            merge(jump, current, subroutine);</span>
<span class="nc" id="L254">                            newControlFlowEdge(insn, jump);</span>
                        }
<span class="nc bnc" id="L256" title="All 2 branches missed.">                    } else if (insnNode instanceof TableSwitchInsnNode) {</span>
<span class="nc" id="L257">                        TableSwitchInsnNode tsi = (TableSwitchInsnNode) insnNode;</span>
<span class="nc" id="L258">                        int jump = insns.indexOf(tsi.dflt);</span>
<span class="nc" id="L259">                        merge(jump, current, subroutine);</span>
<span class="nc" id="L260">                        newControlFlowEdge(insn, jump);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">                        for (int j = 0; j &lt; tsi.labels.size(); ++j) {</span>
<span class="nc" id="L262">                            LabelNode label = tsi.labels.get(j);</span>
<span class="nc" id="L263">                            jump = insns.indexOf(label);</span>
<span class="nc" id="L264">                            merge(jump, current, subroutine);</span>
<span class="nc" id="L265">                            newControlFlowEdge(insn, jump);</span>
                        }
<span class="nc bnc" id="L267" title="All 2 branches missed.">                    } else if (insnOpcode == RET) {</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">                        if (subroutine == null) {</span>
<span class="nc" id="L269">                            throw new AnalyzerException(insnNode,</span>
                                    &quot;RET instruction outside of a sub routine&quot;);
                        }
<span class="nc bnc" id="L272" title="All 2 branches missed.">                        for (int i = 0; i &lt; subroutine.callers.size(); ++i) {</span>
<span class="nc" id="L273">                            JumpInsnNode caller = subroutine.callers.get(i);</span>
<span class="nc" id="L274">                            int call = insns.indexOf(caller);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">                            if (frames[call] != null) {</span>
<span class="nc" id="L276">                                merge(call + 1, frames[call], current,</span>
                                        subroutines[call], subroutine.access);
<span class="nc" id="L278">                                newControlFlowEdge(insn, call + 1);</span>
                            }
                        }
<span class="nc bnc" id="L281" title="All 6 branches missed.">                    } else if (insnOpcode != ATHROW</span>
                            &amp;&amp; (insnOpcode &lt; IRETURN || insnOpcode &gt; RETURN)) {
<span class="nc bnc" id="L283" title="All 2 branches missed.">                        if (subroutine != null) {</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                            if (insnNode instanceof VarInsnNode) {</span>
<span class="nc" id="L285">                                int var = ((VarInsnNode) insnNode).var;</span>
<span class="nc" id="L286">                                subroutine.access[var] = true;</span>
<span class="nc bnc" id="L287" title="All 8 branches missed.">                                if (insnOpcode == LLOAD || insnOpcode == DLOAD</span>
                                        || insnOpcode == LSTORE
                                        || insnOpcode == DSTORE) {
<span class="nc" id="L290">                                    subroutine.access[var + 1] = true;</span>
                                }
<span class="nc bnc" id="L292" title="All 2 branches missed.">                            } else if (insnNode instanceof IincInsnNode) {</span>
<span class="nc" id="L293">                                int var = ((IincInsnNode) insnNode).var;</span>
<span class="nc" id="L294">                                subroutine.access[var] = true;</span>
                            }
                        }
<span class="nc" id="L297">                        merge(insn + 1, current, subroutine);</span>
<span class="nc" id="L298">                        newControlFlowEdge(insn, insn + 1);</span>
                    }
                }

<span class="nc" id="L302">                List&lt;TryCatchBlockNode&gt; insnHandlers = handlers[insn];</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                if (insnHandlers != null) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                    for (int i = 0; i &lt; insnHandlers.size(); ++i) {</span>
<span class="nc" id="L305">                        TryCatchBlockNode tcb = insnHandlers.get(i);</span>
                        Type type;
<span class="nc bnc" id="L307" title="All 2 branches missed.">                        if (tcb.type == null) {</span>
<span class="nc" id="L308">                            type = Type.getObjectType(&quot;java/lang/Throwable&quot;);</span>
                        } else {
<span class="nc" id="L310">                            type = Type.getObjectType(tcb.type);</span>
                        }
<span class="nc" id="L312">                        int jump = insns.indexOf(tcb.handler);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">                        if (newControlFlowExceptionEdge(insn, tcb)) {</span>
<span class="nc" id="L314">                            handler.init(f);</span>
<span class="nc" id="L315">                            handler.clearStack();</span>
<span class="nc" id="L316">                            handler.push(interpreter.newValue(type));</span>
<span class="nc" id="L317">                            merge(jump, handler, subroutine);</span>
                        }
                    }
                }
<span class="nc" id="L321">            } catch (AnalyzerException e) {</span>
<span class="nc" id="L322">                throw new AnalyzerException(e.node, &quot;Error at instruction &quot;</span>
<span class="nc" id="L323">                        + insn + &quot;: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L324">            } catch (Exception e) {</span>
<span class="nc" id="L325">                throw new AnalyzerException(insnNode, &quot;Error at instruction &quot;</span>
<span class="nc" id="L326">                        + insn + &quot;: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L327">            }</span>
<span class="nc" id="L328">        }</span>

<span class="nc" id="L330">        return frames;</span>
    }

    private void findSubroutine(int insn, final Subroutine sub,
            final List&lt;AbstractInsnNode&gt; calls) throws AnalyzerException {
        while (true) {
<span class="nc bnc" id="L336" title="All 4 branches missed.">            if (insn &lt; 0 || insn &gt;= n) {</span>
<span class="nc" id="L337">                throw new AnalyzerException(null,</span>
                        &quot;Execution can fall off end of the code&quot;);
            }
<span class="nc bnc" id="L340" title="All 2 branches missed.">            if (subroutines[insn] != null) {</span>
<span class="nc" id="L341">                return;</span>
            }
<span class="nc" id="L343">            subroutines[insn] = sub.copy();</span>
<span class="nc" id="L344">            AbstractInsnNode node = insns.get(insn);</span>

            // calls findSubroutine recursively on normal successors
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (node instanceof JumpInsnNode) {</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                if (node.getOpcode() == JSR) {</span>
                    // do not follow a JSR, it leads to another subroutine!
<span class="nc" id="L350">                    calls.add(node);</span>
                } else {
<span class="nc" id="L352">                    JumpInsnNode jnode = (JumpInsnNode) node;</span>
<span class="nc" id="L353">                    findSubroutine(insns.indexOf(jnode.label), sub, calls);</span>
<span class="nc" id="L354">                }</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">            } else if (node instanceof TableSwitchInsnNode) {</span>
<span class="nc" id="L356">                TableSwitchInsnNode tsnode = (TableSwitchInsnNode) node;</span>
<span class="nc" id="L357">                findSubroutine(insns.indexOf(tsnode.dflt), sub, calls);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">                for (int i = tsnode.labels.size() - 1; i &gt;= 0; --i) {</span>
<span class="nc" id="L359">                    LabelNode l = tsnode.labels.get(i);</span>
<span class="nc" id="L360">                    findSubroutine(insns.indexOf(l), sub, calls);</span>
                }
<span class="nc bnc" id="L362" title="All 2 branches missed.">            } else if (node instanceof LookupSwitchInsnNode) {</span>
<span class="nc" id="L363">                LookupSwitchInsnNode lsnode = (LookupSwitchInsnNode) node;</span>
<span class="nc" id="L364">                findSubroutine(insns.indexOf(lsnode.dflt), sub, calls);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                for (int i = lsnode.labels.size() - 1; i &gt;= 0; --i) {</span>
<span class="nc" id="L366">                    LabelNode l = lsnode.labels.get(i);</span>
<span class="nc" id="L367">                    findSubroutine(insns.indexOf(l), sub, calls);</span>
                }
            }

            // calls findSubroutine recursively on exception handler successors
<span class="nc" id="L372">            List&lt;TryCatchBlockNode&gt; insnHandlers = handlers[insn];</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            if (insnHandlers != null) {</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                for (int i = 0; i &lt; insnHandlers.size(); ++i) {</span>
<span class="nc" id="L375">                    TryCatchBlockNode tcb = insnHandlers.get(i);</span>
<span class="nc" id="L376">                    findSubroutine(insns.indexOf(tcb.handler), sub, calls);</span>
                }
            }

            // if insn does not falls through to the next instruction, return.
<span class="nc bnc" id="L381" title="All 2 branches missed.">            switch (node.getOpcode()) {</span>
            case GOTO:
            case RET:
            case TABLESWITCH:
            case LOOKUPSWITCH:
            case IRETURN:
            case LRETURN:
            case FRETURN:
            case DRETURN:
            case ARETURN:
            case RETURN:
            case ATHROW:
<span class="nc" id="L393">                return;</span>
            }
<span class="nc" id="L395">            insn++;</span>
<span class="nc" id="L396">        }</span>
    }

    /**
     * Returns the symbolic stack frame for each instruction of the last
     * recently analyzed method.
     *
     * @return the symbolic state of the execution stack frame at each bytecode
     *         instruction of the method. The size of the returned array is
     *         equal to the number of instructions (and labels) of the method. A
     *         given frame is &lt;tt&gt;null&lt;/tt&gt; if the corresponding instruction
     *         cannot be reached, or if an error occurred during the analysis of
     *         the method.
     */
    public Frame&lt;V&gt;[] getFrames() {
<span class="nc" id="L411">        return frames;</span>
    }

    /**
     * Returns the exception handlers for the given instruction.
     *
     * @param insn
     *            the index of an instruction of the last recently analyzed
     *            method.
     * @return a list of {@link TryCatchBlockNode} objects.
     */
    public List&lt;TryCatchBlockNode&gt; getHandlers(final int insn) {
<span class="nc" id="L423">        return handlers[insn];</span>
    }

    /**
     * Initializes this analyzer. This method is called just before the
     * execution of control flow analysis loop in #analyze. The default
     * implementation of this method does nothing.
     *
     * @param owner
     *            the internal name of the class to which the method belongs.
     * @param m
     *            the method to be analyzed.
     * @throws AnalyzerException
     *             if a problem occurs.
     */
    protected void init(String owner, MethodNode m) throws AnalyzerException {
<span class="nc" id="L439">    }</span>

    /**
     * Constructs a new frame with the given size.
     *
     * @param nLocals
     *            the maximum number of local variables of the frame.
     * @param nStack
     *            the maximum stack size of the frame.
     * @return the created frame.
     */
    protected Frame&lt;V&gt; newFrame(final int nLocals, final int nStack) {
<span class="nc" id="L451">        return new Frame&lt;V&gt;(nLocals, nStack);</span>
    }

    /**
     * Constructs a new frame that is identical to the given frame.
     *
     * @param src
     *            a frame.
     * @return the created frame.
     */
    protected Frame&lt;V&gt; newFrame(final Frame&lt;? extends V&gt; src) {
<span class="nc" id="L462">        return new Frame&lt;V&gt;(src);</span>
    }

    /**
     * Creates a control flow graph edge. The default implementation of this
     * method does nothing. It can be overriden in order to construct the
     * control flow graph of a method (this method is called by the
     * {@link #analyze analyze} method during its visit of the method's code).
     *
     * @param insn
     *            an instruction index.
     * @param successor
     *            index of a successor instruction.
     */
    protected void newControlFlowEdge(final int insn, final int successor) {
<span class="nc" id="L477">    }</span>

    /**
     * Creates a control flow graph edge corresponding to an exception handler.
     * The default implementation of this method does nothing. It can be
     * overridden in order to construct the control flow graph of a method (this
     * method is called by the {@link #analyze analyze} method during its visit
     * of the method's code).
     *
     * @param insn
     *            an instruction index.
     * @param successor
     *            index of a successor instruction.
     * @return true if this edge must be considered in the data flow analysis
     *         performed by this analyzer, or false otherwise. The default
     *         implementation of this method always returns true.
     */
    protected boolean newControlFlowExceptionEdge(final int insn,
            final int successor) {
<span class="nc" id="L496">        return true;</span>
    }

    /**
     * Creates a control flow graph edge corresponding to an exception handler.
     * The default implementation of this method delegates to
     * {@link #newControlFlowExceptionEdge(int, int)
     * newControlFlowExceptionEdge(int, int)}. It can be overridden in order to
     * construct the control flow graph of a method (this method is called by
     * the {@link #analyze analyze} method during its visit of the method's
     * code).
     *
     * @param insn
     *            an instruction index.
     * @param tcb
     *            TryCatchBlockNode corresponding to this edge.
     * @return true if this edge must be considered in the data flow analysis
     *         performed by this analyzer, or false otherwise. The default
     *         implementation of this method delegates to
     *         {@link #newControlFlowExceptionEdge(int, int)
     *         newControlFlowExceptionEdge(int, int)}.
     */
    protected boolean newControlFlowExceptionEdge(final int insn,
            final TryCatchBlockNode tcb) {
<span class="nc" id="L520">        return newControlFlowExceptionEdge(insn, insns.indexOf(tcb.handler));</span>
    }

    // -------------------------------------------------------------------------

    private void merge(final int insn, final Frame&lt;V&gt; frame,
            final Subroutine subroutine) throws AnalyzerException {
<span class="nc" id="L527">        Frame&lt;V&gt; oldFrame = frames[insn];</span>
<span class="nc" id="L528">        Subroutine oldSubroutine = subroutines[insn];</span>
        boolean changes;

<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (oldFrame == null) {</span>
<span class="nc" id="L532">            frames[insn] = newFrame(frame);</span>
<span class="nc" id="L533">            changes = true;</span>
        } else {
<span class="nc" id="L535">            changes = oldFrame.merge(frame, interpreter);</span>
        }

<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (oldSubroutine == null) {</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">            if (subroutine != null) {</span>
<span class="nc" id="L540">                subroutines[insn] = subroutine.copy();</span>
<span class="nc" id="L541">                changes = true;</span>
            }
        } else {
<span class="nc bnc" id="L544" title="All 2 branches missed.">            if (subroutine != null) {</span>
<span class="nc" id="L545">                changes |= oldSubroutine.merge(subroutine);</span>
            }
        }
<span class="nc bnc" id="L548" title="All 4 branches missed.">        if (changes &amp;&amp; !queued[insn]) {</span>
<span class="nc" id="L549">            queued[insn] = true;</span>
<span class="nc" id="L550">            queue[top++] = insn;</span>
        }
<span class="nc" id="L552">    }</span>

    private void merge(final int insn, final Frame&lt;V&gt; beforeJSR,
            final Frame&lt;V&gt; afterRET, final Subroutine subroutineBeforeJSR,
            final boolean[] access) throws AnalyzerException {
<span class="nc" id="L557">        Frame&lt;V&gt; oldFrame = frames[insn];</span>
<span class="nc" id="L558">        Subroutine oldSubroutine = subroutines[insn];</span>
        boolean changes;

<span class="nc" id="L561">        afterRET.merge(beforeJSR, access);</span>

<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (oldFrame == null) {</span>
<span class="nc" id="L564">            frames[insn] = newFrame(afterRET);</span>
<span class="nc" id="L565">            changes = true;</span>
        } else {
<span class="nc" id="L567">            changes = oldFrame.merge(afterRET, interpreter);</span>
        }

<span class="nc bnc" id="L570" title="All 4 branches missed.">        if (oldSubroutine != null &amp;&amp; subroutineBeforeJSR != null) {</span>
<span class="nc" id="L571">            changes |= oldSubroutine.merge(subroutineBeforeJSR);</span>
        }
<span class="nc bnc" id="L573" title="All 4 branches missed.">        if (changes &amp;&amp; !queued[insn]) {</span>
<span class="nc" id="L574">            queued[insn] = true;</span>
<span class="nc" id="L575">            queue[top++] = insn;</span>
        }
<span class="nc" id="L577">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>