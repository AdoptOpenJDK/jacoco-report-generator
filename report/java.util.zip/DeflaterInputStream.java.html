<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DeflaterInputStream.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.zip</a> &gt; <span class="el_source">DeflaterInputStream.java</span></div><h1>DeflaterInputStream.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util.zip;

import java.io.FilterInputStream;
import java.io.InputStream;
import java.io.IOException;

/**
 * Implements an input stream filter for compressing data in the &quot;deflate&quot;
 * compression format.
 *
 * @since       1.6
 * @author      David R Tribble (david@tribble.com)
 *
 * @see DeflaterOutputStream
 * @see InflaterOutputStream
 * @see InflaterInputStream
 */

public class DeflaterInputStream extends FilterInputStream {
    /** Compressor for this stream. */
    protected final Deflater def;

    /** Input buffer for reading compressed data. */
    protected final byte[] buf;

    /** Temporary read buffer. */
<span class="nc" id="L52">    private byte[] rbuf = new byte[1];</span>

    /** Default compressor is used. */
<span class="nc" id="L55">    private boolean usesDefaultDeflater = false;</span>

    /** End of the underlying input stream has been reached. */
<span class="nc" id="L58">    private boolean reachEOF = false;</span>

    /**
     * Check to make sure that this stream has not been closed.
     */
    private void ensureOpen() throws IOException {
<span class="nc bnc" id="L64" title="All 2 branches missed.">        if (in == null) {</span>
<span class="nc" id="L65">            throw new IOException(&quot;Stream closed&quot;);</span>
        }
<span class="nc" id="L67">    }</span>

    /**
     * Creates a new input stream with a default compressor and buffer
     * size.
     *
     * @param in input stream to read the uncompressed data to
     * @throws NullPointerException if {@code in} is null
     */
    public DeflaterInputStream(InputStream in) {
<span class="nc" id="L77">        this(in, new Deflater());</span>
<span class="nc" id="L78">        usesDefaultDeflater = true;</span>
<span class="nc" id="L79">    }</span>

    /**
     * Creates a new input stream with the specified compressor and a
     * default buffer size.
     *
     * @param in input stream to read the uncompressed data to
     * @param defl compressor (&quot;deflater&quot;) for this stream
     * @throws NullPointerException if {@code in} or {@code defl} is null
     */
    public DeflaterInputStream(InputStream in, Deflater defl) {
<span class="nc" id="L90">        this(in, defl, 512);</span>
<span class="nc" id="L91">    }</span>

    /**
     * Creates a new input stream with the specified compressor and buffer
     * size.
     *
     * @param in input stream to read the uncompressed data to
     * @param defl compressor (&quot;deflater&quot;) for this stream
     * @param bufLen compression buffer size
     * @throws IllegalArgumentException if {@code bufLen &lt;= 0}
     * @throws NullPointerException if {@code in} or {@code defl} is null
     */
    public DeflaterInputStream(InputStream in, Deflater defl, int bufLen) {
<span class="nc" id="L104">        super(in);</span>

        // Sanity checks
<span class="nc bnc" id="L107" title="All 2 branches missed.">        if (in == null)</span>
<span class="nc" id="L108">            throw new NullPointerException(&quot;Null input&quot;);</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (defl == null)</span>
<span class="nc" id="L110">            throw new NullPointerException(&quot;Null deflater&quot;);</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (bufLen &lt; 1)</span>
<span class="nc" id="L112">            throw new IllegalArgumentException(&quot;Buffer size &lt; 1&quot;);</span>

        // Initialize
<span class="nc" id="L115">        def = defl;</span>
<span class="nc" id="L116">        buf = new byte[bufLen];</span>
<span class="nc" id="L117">    }</span>

    /**
     * Closes this input stream and its underlying input stream, discarding
     * any pending uncompressed data.
     *
     * @throws IOException if an I/O error occurs
     */
    public void close() throws IOException {
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (in != null) {</span>
            try {
                // Clean up
<span class="nc bnc" id="L129" title="All 2 branches missed.">                if (usesDefaultDeflater) {</span>
<span class="nc" id="L130">                    def.end();</span>
                }

<span class="nc" id="L133">                in.close();</span>
            } finally {
<span class="nc" id="L135">                in = null;</span>
<span class="nc" id="L136">            }</span>
        }
<span class="nc" id="L138">    }</span>

    /**
     * Reads a single byte of compressed data from the input stream.
     * This method will block until some input can be read and compressed.
     *
     * @return a single byte of compressed data, or -1 if the end of the
     * uncompressed input stream is reached
     * @throws IOException if an I/O error occurs or if this stream is
     * already closed
     */
    public int read() throws IOException {
        // Read a single byte of compressed data
<span class="nc" id="L151">        int len = read(rbuf, 0, 1);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (len &lt;= 0)</span>
<span class="nc" id="L153">            return -1;</span>
<span class="nc" id="L154">        return (rbuf[0] &amp; 0xFF);</span>
    }

    /**
     * Reads compressed data into a byte array.
     * This method will block until some input can be read and compressed.
     *
     * @param b buffer into which the data is read
     * @param off starting offset of the data within {@code b}
     * @param len maximum number of compressed bytes to read into {@code b}
     * @return the actual number of bytes read, or -1 if the end of the
     * uncompressed input stream is reached
     * @throws IndexOutOfBoundsException  if {@code len &gt; b.length - off}
     * @throws IOException if an I/O error occurs or if this input stream is
     * already closed
     */
    public int read(byte[] b, int off, int len) throws IOException {
        // Sanity checks
<span class="nc" id="L172">        ensureOpen();</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L174">            throw new NullPointerException(&quot;Null buffer for read&quot;);</span>
<span class="nc bnc" id="L175" title="All 6 branches missed.">        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {</span>
<span class="nc" id="L176">            throw new IndexOutOfBoundsException();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        } else if (len == 0) {</span>
<span class="nc" id="L178">            return 0;</span>
        }

        // Read and compress (deflate) input data bytes
<span class="nc" id="L182">        int cnt = 0;</span>
<span class="nc bnc" id="L183" title="All 4 branches missed.">        while (len &gt; 0 &amp;&amp; !def.finished()) {</span>
            int n;

            // Read data from the input stream
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (def.needsInput()) {</span>
<span class="nc" id="L188">                n = in.read(buf, 0, buf.length);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                if (n &lt; 0) {</span>
                    // End of the input stream reached
<span class="nc" id="L191">                    def.finish();</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                } else if (n &gt; 0) {</span>
<span class="nc" id="L193">                    def.setInput(buf, 0, n);</span>
                }
            }

            // Compress the input data, filling the read buffer
<span class="nc" id="L198">            n = def.deflate(b, off, len);</span>
<span class="nc" id="L199">            cnt += n;</span>
<span class="nc" id="L200">            off += n;</span>
<span class="nc" id="L201">            len -= n;</span>
<span class="nc" id="L202">        }</span>
<span class="nc bnc" id="L203" title="All 4 branches missed.">        if (cnt == 0 &amp;&amp; def.finished()) {</span>
<span class="nc" id="L204">            reachEOF = true;</span>
<span class="nc" id="L205">            cnt = -1;</span>
        }

<span class="nc" id="L208">        return cnt;</span>
    }

    /**
     * Skips over and discards data from the input stream.
     * This method may block until the specified number of bytes are read and
     * skipped. &lt;em&gt;Note:&lt;/em&gt; While {@code n} is given as a {@code long},
     * the maximum number of bytes which can be skipped is
     * {@code Integer.MAX_VALUE}.
     *
     * @param n number of bytes to be skipped
     * @return the actual number of bytes skipped
     * @throws IOException if an I/O error occurs or if this stream is
     * already closed
     */
    public long skip(long n) throws IOException {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (n &lt; 0) {</span>
<span class="nc" id="L225">            throw new IllegalArgumentException(&quot;negative skip length&quot;);</span>
        }
<span class="nc" id="L227">        ensureOpen();</span>

        // Skip bytes by repeatedly decompressing small blocks
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (rbuf.length &lt; 512)</span>
<span class="nc" id="L231">            rbuf = new byte[512];</span>

<span class="nc" id="L233">        int total = (int)Math.min(n, Integer.MAX_VALUE);</span>
<span class="nc" id="L234">        long cnt = 0;</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">        while (total &gt; 0) {</span>
            // Read a small block of uncompressed bytes
<span class="nc bnc" id="L237" title="All 2 branches missed.">            int len = read(rbuf, 0, (total &lt;= rbuf.length ? total : rbuf.length));</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (len &lt; 0) {</span>
<span class="nc" id="L240">                break;</span>
            }
<span class="nc" id="L242">            cnt += len;</span>
<span class="nc" id="L243">            total -= len;</span>
<span class="nc" id="L244">        }</span>
<span class="nc" id="L245">        return cnt;</span>
    }

    /**
     * Returns 0 after EOF has been reached, otherwise always return 1.
     * &lt;p&gt;
     * Programs should not count on this method to return the actual number
     * of bytes that could be read without blocking
     * @return zero after the end of the underlying input stream has been
     * reached, otherwise always returns 1
     * @throws IOException if an I/O error occurs or if this stream is
     * already closed
     */
    public int available() throws IOException {
<span class="nc" id="L259">        ensureOpen();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (reachEOF) {</span>
<span class="nc" id="L261">            return 0;</span>
        }
<span class="nc" id="L263">        return 1;</span>
    }

    /**
     * Always returns {@code false} because this input stream does not support
     * the {@link #mark mark()} and {@link #reset reset()} methods.
     *
     * @return false, always
     */
    public boolean markSupported() {
<span class="nc" id="L273">        return false;</span>
    }

    /**
     * &lt;i&gt;This operation is not supported&lt;/i&gt;.
     *
     * @param limit maximum bytes that can be read before invalidating the position marker
     */
    public void mark(int limit) {
        // Operation not supported
<span class="nc" id="L283">    }</span>

    /**
     * &lt;i&gt;This operation is not supported&lt;/i&gt;.
     *
     * @throws IOException always thrown
     */
    public void reset() throws IOException {
<span class="nc" id="L291">        throw new IOException(&quot;mark/reset not supported&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>