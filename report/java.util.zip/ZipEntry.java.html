<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ZipEntry.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.zip</a> &gt; <span class="el_source">ZipEntry.java</span></div><h1>ZipEntry.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util.zip;

import static java.util.zip.ZipUtils.*;
import java.nio.file.attribute.FileTime;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

import static java.util.zip.ZipConstants64.*;

/**
 * This class is used to represent a ZIP file entry.
 *
 * @author      David Connelly
 */
public
class ZipEntry implements ZipConstants, Cloneable {

    String name;        // entry name
<span class="fc" id="L44">    long time = -1;     // last modification time</span>
    FileTime mtime;     // last modification time, from extra field data
    FileTime atime;     // last access time, from extra field data
    FileTime ctime;     // creation time, from extra field data
<span class="fc" id="L48">    long crc = -1;      // crc-32 of entry data</span>
<span class="fc" id="L49">    long size = -1;     // uncompressed size of entry data</span>
<span class="fc" id="L50">    long csize = -1;    // compressed size of entry data</span>
<span class="fc" id="L51">    int method = -1;    // compression method</span>
<span class="fc" id="L52">    int flag = 0;       // general purpose flag</span>
    byte[] extra;       // optional extra field data for entry
    String comment;     // optional comment string for entry

    /**
     * Compression method for uncompressed entries.
     */
    public static final int STORED = 0;

    /**
     * Compression method for compressed (deflated) entries.
     */
    public static final int DEFLATED = 8;

    /**
     * Creates a new zip entry with the specified name.
     *
     * @param  name
     *         The entry name
     *
     * @throws NullPointerException if the entry name is null
     * @throws IllegalArgumentException if the entry name is longer than
     *         0xFFFF bytes
     */
<span class="fc" id="L76">    public ZipEntry(String name) {</span>
<span class="fc" id="L77">        Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        if (name.length() &gt; 0xFFFF) {</span>
<span class="nc" id="L79">            throw new IllegalArgumentException(&quot;entry name too long&quot;);</span>
        }
<span class="fc" id="L81">        this.name = name;</span>
<span class="fc" id="L82">    }</span>

    /**
     * Creates a new zip entry with fields taken from the specified
     * zip entry.
     *
     * @param  e
     *         A zip Entry object
     *
     * @throws NullPointerException if the entry object is null
     */
<span class="fc" id="L93">    public ZipEntry(ZipEntry e) {</span>
<span class="fc" id="L94">        Objects.requireNonNull(e, &quot;entry&quot;);</span>
<span class="fc" id="L95">        name = e.name;</span>
<span class="fc" id="L96">        time = e.time;</span>
<span class="fc" id="L97">        mtime = e.mtime;</span>
<span class="fc" id="L98">        atime = e.atime;</span>
<span class="fc" id="L99">        ctime = e.ctime;</span>
<span class="fc" id="L100">        crc = e.crc;</span>
<span class="fc" id="L101">        size = e.size;</span>
<span class="fc" id="L102">        csize = e.csize;</span>
<span class="fc" id="L103">        method = e.method;</span>
<span class="fc" id="L104">        flag = e.flag;</span>
<span class="fc" id="L105">        extra = e.extra;</span>
<span class="fc" id="L106">        comment = e.comment;</span>
<span class="fc" id="L107">    }</span>

    /**
     * Creates a new un-initialized zip entry
     */
<span class="fc" id="L112">    ZipEntry() {}</span>

    /**
     * Returns the name of the entry.
     * @return the name of the entry
     */
    public String getName() {
<span class="fc" id="L119">        return name;</span>
    }

    /**
     * Sets the last modification time of the entry.
     *
     * &lt;p&gt; If the entry is output to a ZIP file or ZIP file formatted
     * output stream the last modification time set by this method will
     * be stored into the {@code date and time fields} of the zip file
     * entry and encoded in standard {@code MS-DOS date and time format}.
     * The {@link java.util.TimeZone#getDefault() default TimeZone} is
     * used to convert the epoch time to the MS-DOS data and time.
     *
     * @param  time
     *         The last modification time of the entry in milliseconds
     *         since the epoch
     *
     * @see #getTime()
     * @see #getLastModifiedTime()
     */
    public void setTime(long time) {
<span class="fc" id="L140">        this.time = time;</span>
<span class="fc" id="L141">        this.mtime = null;</span>
<span class="fc" id="L142">    }</span>

    /**
     * Returns the last modification time of the entry.
     *
     * &lt;p&gt; If the entry is read from a ZIP file or ZIP file formatted
     * input stream, this is the last modification time from the {@code
     * date and time fields} of the zip file entry. The
     * {@link java.util.TimeZone#getDefault() default TimeZone} is used
     * to convert the standard MS-DOS formatted date and time to the
     * epoch time.
     *
     * @return  The last modification time of the entry in milliseconds
     *          since the epoch, or -1 if not specified
     *
     * @see #setTime(long)
     * @see #setLastModifiedTime(FileTime)
     */
    public long getTime() {
<span class="fc" id="L161">        return time;</span>
    }

    /**
     * Sets the last modification time of the entry.
     *
     * &lt;p&gt; When output to a ZIP file or ZIP file formatted output stream
     * the last modification time set by this method will be stored into
     * zip file entry's {@code date and time fields} in {@code standard
     * MS-DOS date and time format}), and the extended timestamp fields
     * in {@code optional extra data} in UTC time.
     *
     * @param  time
     *         The last modification time of the entry
     * @return This zip entry
     *
     * @throws NullPointerException if the {@code time} is null
     *
     * @see #getLastModifiedTime()
     * @since 1.8
     */
    public ZipEntry setLastModifiedTime(FileTime time) {
<span class="nc" id="L183">        Objects.requireNonNull(name, &quot;time&quot;);</span>
<span class="nc" id="L184">        this.mtime = time;</span>
<span class="nc" id="L185">        this.time = time.to(TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L186">        return this;</span>
    }

    /**
     * Returns the last modification time of the entry.
     *
     * &lt;p&gt; If the entry is read from a ZIP file or ZIP file formatted
     * input stream, this is the last modification time from the zip
     * file entry's {@code optional extra data} if the extended timestamp
     * fields are present. Otherwise the last modification time is read
     * from the entry's {@code date and time fields}, the {@link
     * java.util.TimeZone#getDefault() default TimeZone} is used to convert
     * the standard MS-DOS formatted date and time to the epoch time.
     *
     * @return The last modification time of the entry, null if not specified
     *
     * @see #setLastModifiedTime(FileTime)
     * @since 1.8
     */
    public FileTime getLastModifiedTime() {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (mtime != null)</span>
<span class="nc" id="L207">            return mtime;</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (time == -1)</span>
<span class="nc" id="L209">            return null;</span>
<span class="nc" id="L210">        return FileTime.from(time, TimeUnit.MILLISECONDS);</span>
    }

    /**
     * Sets the last access time of the entry.
     *
     * &lt;p&gt; If set, the last access time will be stored into the extended
     * timestamp fields of entry's {@code optional extra data}, when output
     * to a ZIP file or ZIP file formatted stream.
     *
     * @param  time
     *         The last access time of the entry
     * @return This zip entry
     *
     * @throws NullPointerException if the {@code time} is null
     *
     * @see #getLastAccessTime()
     * @since 1.8
     */
    public ZipEntry setLastAccessTime(FileTime time) {
<span class="nc" id="L230">        Objects.requireNonNull(name, &quot;time&quot;);</span>
<span class="nc" id="L231">        this.atime = time;</span>
<span class="nc" id="L232">        return this;</span>
    }

    /**
     * Returns the last access time of the entry.
     *
     * &lt;p&gt; The last access time is from the extended timestamp fields
     * of entry's {@code optional extra data} when read from a ZIP file
     * or ZIP file formatted stream.
     *
     * @return The last access time of the entry, null if not specified

     * @see #setLastAccessTime(FileTime)
     * @since 1.8
     */
    public FileTime getLastAccessTime() {
<span class="nc" id="L248">        return atime;</span>
    }

    /**
     * Sets the creation time of the entry.
     *
     * &lt;p&gt; If set, the creation time will be stored into the extended
     * timestamp fields of entry's {@code optional extra data}, when
     * output to a ZIP file or ZIP file formatted stream.
     *
     * @param  time
     *         The creation time of the entry
     * @return This zip entry
     *
     * @throws NullPointerException if the {@code time} is null
     *
     * @see #getCreationTime()
     * @since 1.8
     */
    public ZipEntry setCreationTime(FileTime time) {
<span class="nc" id="L268">        Objects.requireNonNull(name, &quot;time&quot;);</span>
<span class="nc" id="L269">        this.ctime = time;</span>
<span class="nc" id="L270">        return this;</span>
    }

    /**
     * Returns the creation time of the entry.
     *
     * &lt;p&gt; The creation time is from the extended timestamp fields of
     * entry's {@code optional extra data} when read from a ZIP file
     * or ZIP file formatted stream.
     *
     * @return the creation time of the entry, null if not specified
     * @see #setCreationTime(FileTime)
     * @since 1.8
     */
    public FileTime getCreationTime() {
<span class="nc" id="L285">        return ctime;</span>
    }

    /**
     * Sets the uncompressed size of the entry data.
     *
     * @param size the uncompressed size in bytes
     *
     * @throws IllegalArgumentException if the specified size is less
     *         than 0, is greater than 0xFFFFFFFF when
     *         &lt;a href=&quot;package-summary.html#zip64&quot;&gt;ZIP64 format&lt;/a&gt; is not supported,
     *         or is less than 0 when ZIP64 is supported
     * @see #getSize()
     */
    public void setSize(long size) {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if (size &lt; 0) {</span>
<span class="nc" id="L301">            throw new IllegalArgumentException(&quot;invalid entry size&quot;);</span>
        }
<span class="fc" id="L303">        this.size = size;</span>
<span class="fc" id="L304">    }</span>

    /**
     * Returns the uncompressed size of the entry data.
     *
     * @return the uncompressed size of the entry data, or -1 if not known
     * @see #setSize(long)
     */
    public long getSize() {
<span class="fc" id="L313">        return size;</span>
    }

    /**
     * Returns the size of the compressed entry data.
     *
     * &lt;p&gt; In the case of a stored entry, the compressed size will be the same
     * as the uncompressed size of the entry.
     *
     * @return the size of the compressed entry data, or -1 if not known
     * @see #setCompressedSize(long)
     */
    public long getCompressedSize() {
<span class="fc" id="L326">        return csize;</span>
    }

    /**
     * Sets the size of the compressed entry data.
     *
     * @param csize the compressed size to set to
     *
     * @see #getCompressedSize()
     */
    public void setCompressedSize(long csize) {
<span class="fc" id="L337">        this.csize = csize;</span>
<span class="fc" id="L338">    }</span>

    /**
     * Sets the CRC-32 checksum of the uncompressed entry data.
     *
     * @param crc the CRC-32 value
     *
     * @throws IllegalArgumentException if the specified CRC-32 value is
     *         less than 0 or greater than 0xFFFFFFFF
     * @see #getCrc()
     */
    public void setCrc(long crc) {
<span class="pc bpc" id="L350" title="2 of 4 branches missed.">        if (crc &lt; 0 || crc &gt; 0xFFFFFFFFL) {</span>
<span class="nc" id="L351">            throw new IllegalArgumentException(&quot;invalid entry crc-32&quot;);</span>
        }
<span class="fc" id="L353">        this.crc = crc;</span>
<span class="fc" id="L354">    }</span>

    /**
     * Returns the CRC-32 checksum of the uncompressed entry data.
     *
     * @return the CRC-32 checksum of the uncompressed entry data, or -1 if
     * not known
     *
     * @see #setCrc(long)
     */
    public long getCrc() {
<span class="fc" id="L365">        return crc;</span>
    }

    /**
     * Sets the compression method for the entry.
     *
     * @param method the compression method, either STORED or DEFLATED
     *
     * @throws  IllegalArgumentException if the specified compression
     *          method is invalid
     * @see #getMethod()
     */
    public void setMethod(int method) {
<span class="pc bpc" id="L378" title="1 of 4 branches missed.">        if (method != STORED &amp;&amp; method != DEFLATED) {</span>
<span class="nc" id="L379">            throw new IllegalArgumentException(&quot;invalid compression method&quot;);</span>
        }
<span class="fc" id="L381">        this.method = method;</span>
<span class="fc" id="L382">    }</span>

    /**
     * Returns the compression method of the entry.
     *
     * @return the compression method of the entry, or -1 if not specified
     * @see #setMethod(int)
     */
    public int getMethod() {
<span class="fc" id="L391">        return method;</span>
    }

    /**
     * Sets the optional extra field data for the entry.
     *
     * &lt;p&gt; Invoking this method may change this entry's last modification
     * time, last access time and creation time, if the {@code extra} field
     * data includes the extensible timestamp fields, such as {@code NTFS tag
     * 0x0001} or {@code Info-ZIP Extended Timestamp}, as specified in
     * &lt;a href=&quot;http://www.info-zip.org/doc/appnote-19970311-iz.zip&quot;&gt;Info-ZIP
     * Application Note 970311&lt;/a&gt;.
     *
     * @param  extra
     *         The extra field data bytes
     *
     * @throws IllegalArgumentException if the length of the specified
     *         extra field data is greater than 0xFFFF bytes
     *
     * @see #getExtra()
     */
    public void setExtra(byte[] extra) {
<span class="fc" id="L413">        setExtra0(extra, false);</span>
<span class="fc" id="L414">    }</span>

    /**
     * Sets the optional extra field data for the entry.
     *
     * @param extra
     *        the extra field data bytes
     * @param doZIP64
     *        if true, set size and csize from ZIP64 fields if present
     */
    void setExtra0(byte[] extra, boolean doZIP64) {
<span class="fc bfc" id="L425" title="All 2 branches covered.">        if (extra != null) {</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">            if (extra.length &gt; 0xFFFF) {</span>
<span class="nc" id="L427">                throw new IllegalArgumentException(&quot;invalid extra field length&quot;);</span>
            }
            // extra fields are in &quot;HeaderID(2)DataSize(2)Data... format
<span class="fc" id="L430">            int off = 0;</span>
<span class="fc" id="L431">            int len = extra.length;</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">            while (off + 4 &lt; len) {</span>
<span class="fc" id="L433">                int tag = get16(extra, off);</span>
<span class="fc" id="L434">                int sz = get16(extra, off + 2);</span>
<span class="fc" id="L435">                off += 4;</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">                if (off + sz &gt; len)         // invalid data</span>
<span class="nc" id="L437">                    break;</span>
<span class="pc bpc" id="L438" title="2 of 4 branches missed.">                switch (tag) {</span>
                case EXTID_ZIP64:
<span class="nc bnc" id="L440" title="All 2 branches missed.">                    if (doZIP64) {</span>
                        // LOC extra zip64 entry MUST include BOTH original
                        // and compressed file size fields.
                        // If invalid zip64 extra fields, simply skip. Even
                        // it's rare, it's possible the entry size happens to
                        // be the magic value and it &quot;accidently&quot; has some
                        // bytes in extra match the id.
<span class="nc bnc" id="L447" title="All 2 branches missed.">                        if (sz &gt;= 16) {</span>
<span class="nc" id="L448">                            size = get64(extra, off);</span>
<span class="nc" id="L449">                            csize = get64(extra, off + 8);</span>
                        }
                    }
                    break;
                case EXTID_NTFS:
<span class="nc" id="L454">                    int pos = off + 4;               // reserved 4 bytes</span>
<span class="nc bnc" id="L455" title="All 4 branches missed.">                    if (get16(extra, pos) !=  0x0001 || get16(extra, pos + 2) != 24)</span>
<span class="nc" id="L456">                        break;</span>
<span class="nc" id="L457">                    mtime = winTimeToFileTime(get64(extra, pos + 4));</span>
<span class="nc" id="L458">                    atime = winTimeToFileTime(get64(extra, pos + 12));</span>
<span class="nc" id="L459">                    ctime = winTimeToFileTime(get64(extra, pos + 20));</span>
<span class="nc" id="L460">                    break;</span>
                case EXTID_EXTT:
<span class="fc" id="L462">                    int flag = Byte.toUnsignedInt(extra[off]);</span>
<span class="fc" id="L463">                    int sz0 = 1;</span>
                    // The CEN-header extra field contains the modification
                    // time only, or no timestamp at all. 'sz' is used to
                    // flag its presence or absence. But if mtime is present
                    // in LOC it must be present in CEN as well.
<span class="pc bpc" id="L468" title="2 of 4 branches missed.">                    if ((flag &amp; 0x1) != 0 &amp;&amp; (sz0 + 4) &lt;= sz) {</span>
<span class="fc" id="L469">                        mtime = unixTimeToFileTime(get32(extra, off + sz0));</span>
<span class="fc" id="L470">                        sz0 += 4;</span>
                    }
<span class="pc bpc" id="L472" title="1 of 4 branches missed.">                    if ((flag &amp; 0x2) != 0 &amp;&amp; (sz0 + 4) &lt;= sz) {</span>
<span class="fc" id="L473">                        atime = unixTimeToFileTime(get32(extra, off + sz0));</span>
<span class="fc" id="L474">                        sz0 += 4;</span>
                    }
<span class="pc bpc" id="L476" title="3 of 4 branches missed.">                    if ((flag &amp; 0x4) != 0 &amp;&amp; (sz0 + 4) &lt;= sz) {</span>
<span class="nc" id="L477">                        ctime = unixTimeToFileTime(get32(extra, off + sz0));</span>
<span class="nc" id="L478">                        sz0 += 4;</span>
                    }
                    break;
                 default:
                }
<span class="fc" id="L483">                off += sz;</span>
<span class="fc" id="L484">            }</span>
        }
<span class="fc" id="L486">        this.extra = extra;</span>
<span class="fc" id="L487">    }</span>

    /**
     * Returns the extra field data for the entry.
     *
     * @return the extra field data for the entry, or null if none
     *
     * @see #setExtra(byte[])
     */
    public byte[] getExtra() {
<span class="fc" id="L497">        return extra;</span>
    }

    /**
     * Sets the optional comment string for the entry.
     *
     * &lt;p&gt;ZIP entry comments have maximum length of 0xffff. If the length of the
     * specified comment string is greater than 0xFFFF bytes after encoding, only
     * the first 0xFFFF bytes are output to the ZIP file entry.
     *
     * @param comment the comment string
     *
     * @see #getComment()
     */
    public void setComment(String comment) {
<span class="fc" id="L512">        this.comment = comment;</span>
<span class="fc" id="L513">    }</span>

    /**
     * Returns the comment string for the entry.
     *
     * @return the comment string for the entry, or null if none
     *
     * @see #setComment(String)
     */
    public String getComment() {
<span class="fc" id="L523">        return comment;</span>
    }

    /**
     * Returns true if this is a directory entry. A directory entry is
     * defined to be one whose name ends with a '/'.
     * @return true if this is a directory entry
     */
    public boolean isDirectory() {
<span class="fc" id="L532">        return name.endsWith(&quot;/&quot;);</span>
    }

    /**
     * Returns a string representation of the ZIP entry.
     */
    public String toString() {
<span class="fc" id="L539">        return getName();</span>
    }

    /**
     * Returns the hash code value for this entry.
     */
    public int hashCode() {
<span class="fc" id="L546">        return name.hashCode();</span>
    }

    /**
     * Returns a copy of this entry.
     */
    public Object clone() {
        try {
<span class="nc" id="L554">            ZipEntry e = (ZipEntry)super.clone();</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            e.extra = (extra == null) ? null : extra.clone();</span>
<span class="nc" id="L556">            return e;</span>
<span class="nc" id="L557">        } catch (CloneNotSupportedException e) {</span>
            // This should never happen, since we are Cloneable
<span class="nc" id="L559">            throw new InternalError(e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>