<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ZipInputStream.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.zip</a> &gt; <span class="el_source">ZipInputStream.java</span></div><h1>ZipInputStream.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util.zip;

import java.io.InputStream;
import java.io.IOException;
import java.io.EOFException;
import java.io.PushbackInputStream;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import static java.util.zip.ZipConstants64.*;
import static java.util.zip.ZipUtils.*;

/**
 * This class implements an input stream filter for reading files in the
 * ZIP file format. Includes support for both compressed and uncompressed
 * entries.
 *
 * @author      David Connelly
 */
public
class ZipInputStream extends InflaterInputStream implements ZipConstants {
    private ZipEntry entry;
    private int flag;
<span class="fc" id="L48">    private CRC32 crc = new CRC32();</span>
    private long remaining;
<span class="fc" id="L50">    private byte[] tmpbuf = new byte[512];</span>

    private static final int STORED = ZipEntry.STORED;
    private static final int DEFLATED = ZipEntry.DEFLATED;

<span class="fc" id="L55">    private boolean closed = false;</span>
    // this flag is set to true after EOF has reached for
    // one entry
<span class="fc" id="L58">    private boolean entryEOF = false;</span>

    private ZipCoder zc;

    /**
     * Check to make sure that this stream has not been closed
     */
    private void ensureOpen() throws IOException {
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">        if (closed) {</span>
<span class="nc" id="L67">            throw new IOException(&quot;Stream closed&quot;);</span>
        }
<span class="fc" id="L69">    }</span>

    /**
     * Creates a new ZIP input stream.
     *
     * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
     * decode the entry names.
     *
     * @param in the actual input stream
     */
    public ZipInputStream(InputStream in) {
<span class="fc" id="L80">        this(in, StandardCharsets.UTF_8);</span>
<span class="fc" id="L81">    }</span>

    /**
     * Creates a new ZIP input stream.
     *
     * @param in the actual input stream
     *
     * @param charset
     *        The {@linkplain java.nio.charset.Charset charset} to be
     *        used to decode the ZIP entry name (ignored if the
     *        &lt;a href=&quot;package-summary.html#lang_encoding&quot;&gt; language
     *        encoding bit&lt;/a&gt; of the ZIP entry's general purpose bit
     *        flag is set).
     *
     * @since 1.7
     */
    public ZipInputStream(InputStream in, Charset charset) {
<span class="fc" id="L98">        super(new PushbackInputStream(in, 512), new Inflater(true), 512);</span>
<span class="fc" id="L99">        usesDefaultInflater = true;</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if(in == null) {</span>
<span class="nc" id="L101">            throw new NullPointerException(&quot;in is null&quot;);</span>
        }
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        if (charset == null)</span>
<span class="nc" id="L104">            throw new NullPointerException(&quot;charset is null&quot;);</span>
<span class="fc" id="L105">        this.zc = ZipCoder.get(charset);</span>
<span class="fc" id="L106">    }</span>

    /**
     * Reads the next ZIP file entry and positions the stream at the
     * beginning of the entry data.
     * @return the next ZIP file entry, or null if there are no more entries
     * @exception ZipException if a ZIP file error has occurred
     * @exception IOException if an I/O error has occurred
     */
    public ZipEntry getNextEntry() throws IOException {
<span class="fc" id="L116">        ensureOpen();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (entry != null) {</span>
<span class="fc" id="L118">            closeEntry();</span>
        }
<span class="fc" id="L120">        crc.reset();</span>
<span class="fc" id="L121">        inf.reset();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if ((entry = readLOC()) == null) {</span>
<span class="fc" id="L123">            return null;</span>
        }
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (entry.method == STORED) {</span>
<span class="fc" id="L126">            remaining = entry.size;</span>
        }
<span class="fc" id="L128">        entryEOF = false;</span>
<span class="fc" id="L129">        return entry;</span>
    }

    /**
     * Closes the current ZIP entry and positions the stream for reading the
     * next entry.
     * @exception ZipException if a ZIP file error has occurred
     * @exception IOException if an I/O error has occurred
     */
    public void closeEntry() throws IOException {
<span class="fc" id="L139">        ensureOpen();</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">        while (read(tmpbuf, 0, tmpbuf.length) != -1) ;</span>
<span class="fc" id="L141">        entryEOF = true;</span>
<span class="fc" id="L142">    }</span>

    /**
     * Returns 0 after EOF has reached for the current entry data,
     * otherwise always return 1.
     * &lt;p&gt;
     * Programs should not count on this method to return the actual number
     * of bytes that could be read without blocking.
     *
     * @return     1 before EOF and 0 after EOF has reached for current entry.
     * @exception  IOException  if an I/O error occurs.
     *
     */
    public int available() throws IOException {
<span class="fc" id="L156">        ensureOpen();</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (entryEOF) {</span>
<span class="nc" id="L158">            return 0;</span>
        } else {
<span class="fc" id="L160">            return 1;</span>
        }
    }

    /**
     * Reads from the current ZIP entry into an array of bytes.
     * If &lt;code&gt;len&lt;/code&gt; is not zero, the method
     * blocks until some input is available; otherwise, no
     * bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.
     * @param b the buffer into which the data is read
     * @param off the start offset in the destination array &lt;code&gt;b&lt;/code&gt;
     * @param len the maximum number of bytes read
     * @return the actual number of bytes read, or -1 if the end of the
     *         entry is reached
     * @exception  NullPointerException if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @exception  IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is negative,
     * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
     * &lt;code&gt;b.length - off&lt;/code&gt;
     * @exception ZipException if a ZIP file error has occurred
     * @exception IOException if an I/O error has occurred
     */
    public int read(byte[] b, int off, int len) throws IOException {
<span class="fc" id="L182">        ensureOpen();</span>
<span class="pc bpc" id="L183" title="3 of 6 branches missed.">        if (off &lt; 0 || len &lt; 0 || off &gt; b.length - len) {</span>
<span class="nc" id="L184">            throw new IndexOutOfBoundsException();</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        } else if (len == 0) {</span>
<span class="nc" id="L186">            return 0;</span>
        }

<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (entry == null) {</span>
<span class="fc" id="L190">            return -1;</span>
        }
<span class="pc bpc" id="L192" title="1 of 3 branches missed.">        switch (entry.method) {</span>
        case DEFLATED:
<span class="fc" id="L194">            len = super.read(b, off, len);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (len == -1) {</span>
<span class="fc" id="L196">                readEnd(entry);</span>
<span class="fc" id="L197">                entryEOF = true;</span>
<span class="fc" id="L198">                entry = null;</span>
            } else {
<span class="fc" id="L200">                crc.update(b, off, len);</span>
            }
<span class="fc" id="L202">            return len;</span>
        case STORED:
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if (remaining &lt;= 0) {</span>
<span class="fc" id="L205">                entryEOF = true;</span>
<span class="fc" id="L206">                entry = null;</span>
<span class="fc" id="L207">                return -1;</span>
            }
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">            if (len &gt; remaining) {</span>
<span class="fc" id="L210">                len = (int)remaining;</span>
            }
<span class="fc" id="L212">            len = in.read(b, off, len);</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            if (len == -1) {</span>
<span class="nc" id="L214">                throw new ZipException(&quot;unexpected EOF&quot;);</span>
            }
<span class="fc" id="L216">            crc.update(b, off, len);</span>
<span class="fc" id="L217">            remaining -= len;</span>
<span class="pc bpc" id="L218" title="2 of 4 branches missed.">            if (remaining == 0 &amp;&amp; entry.crc != crc.getValue()) {</span>
<span class="nc" id="L219">                throw new ZipException(</span>
<span class="nc" id="L220">                    &quot;invalid entry CRC (expected 0x&quot; + Long.toHexString(entry.crc) +</span>
<span class="nc" id="L221">                    &quot; but got 0x&quot; + Long.toHexString(crc.getValue()) + &quot;)&quot;);</span>
            }
<span class="fc" id="L223">            return len;</span>
        default:
<span class="nc" id="L225">            throw new ZipException(&quot;invalid compression method&quot;);</span>
        }
    }

    /**
     * Skips specified number of bytes in the current ZIP entry.
     * @param n the number of bytes to skip
     * @return the actual number of bytes skipped
     * @exception ZipException if a ZIP file error has occurred
     * @exception IOException if an I/O error has occurred
     * @exception IllegalArgumentException if {@code n &lt; 0}
     */
    public long skip(long n) throws IOException {
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (n &lt; 0) {</span>
<span class="nc" id="L239">            throw new IllegalArgumentException(&quot;negative skip length&quot;);</span>
        }
<span class="nc" id="L241">        ensureOpen();</span>
<span class="nc" id="L242">        int max = (int)Math.min(n, Integer.MAX_VALUE);</span>
<span class="nc" id="L243">        int total = 0;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        while (total &lt; max) {</span>
<span class="nc" id="L245">            int len = max - total;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (len &gt; tmpbuf.length) {</span>
<span class="nc" id="L247">                len = tmpbuf.length;</span>
            }
<span class="nc" id="L249">            len = read(tmpbuf, 0, len);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (len == -1) {</span>
<span class="nc" id="L251">                entryEOF = true;</span>
<span class="nc" id="L252">                break;</span>
            }
<span class="nc" id="L254">            total += len;</span>
<span class="nc" id="L255">        }</span>
<span class="nc" id="L256">        return total;</span>
    }

    /**
     * Closes this input stream and releases any system resources associated
     * with the stream.
     * @exception IOException if an I/O error has occurred
     */
    public void close() throws IOException {
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        if (!closed) {</span>
<span class="fc" id="L266">            super.close();</span>
<span class="fc" id="L267">            closed = true;</span>
        }
<span class="fc" id="L269">    }</span>

<span class="fc" id="L271">    private byte[] b = new byte[256];</span>

    /*
     * Reads local file (LOC) header for next entry.
     */
    private ZipEntry readLOC() throws IOException {
        try {
<span class="fc" id="L278">            readFully(tmpbuf, 0, LOCHDR);</span>
<span class="nc" id="L279">        } catch (EOFException e) {</span>
<span class="nc" id="L280">            return null;</span>
<span class="fc" id="L281">        }</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (get32(tmpbuf, 0) != LOCSIG) {</span>
<span class="fc" id="L283">            return null;</span>
        }
        // get flag first, we need check EFS.
<span class="fc" id="L286">        flag = get16(tmpbuf, LOCFLG);</span>
        // get the entry name and create the ZipEntry first
<span class="fc" id="L288">        int len = get16(tmpbuf, LOCNAM);</span>
<span class="fc" id="L289">        int blen = b.length;</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        if (len &gt; blen) {</span>
            do {
<span class="nc" id="L292">                blen = blen * 2;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            } while (len &gt; blen);</span>
<span class="nc" id="L294">            b = new byte[blen];</span>
        }
<span class="fc" id="L296">        readFully(b, 0, len);</span>
        // Force to use UTF-8 if the EFS bit is ON, even the cs is NOT UTF-8
<span class="fc bfc" id="L298" title="All 2 branches covered.">        ZipEntry e = createZipEntry(((flag &amp; EFS) != 0)</span>
<span class="fc" id="L299">                                    ? zc.toStringUTF8(b, len)</span>
<span class="fc" id="L300">                                    : zc.toString(b, len));</span>
        // now get the remaining fields for the entry
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if ((flag &amp; 1) == 1) {</span>
<span class="nc" id="L303">            throw new ZipException(&quot;encrypted ZIP entry not supported&quot;);</span>
        }
<span class="fc" id="L305">        e.method = get16(tmpbuf, LOCHOW);</span>
<span class="fc" id="L306">        e.time = dosToJavaTime(get32(tmpbuf, LOCTIM));</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">        if ((flag &amp; 8) == 8) {</span>
            /* &quot;Data Descriptor&quot; present */
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">            if (e.method != DEFLATED) {</span>
<span class="nc" id="L310">                throw new ZipException(</span>
                        &quot;only DEFLATED entries can have EXT descriptor&quot;);
            }
        } else {
<span class="fc" id="L314">            e.crc = get32(tmpbuf, LOCCRC);</span>
<span class="fc" id="L315">            e.csize = get32(tmpbuf, LOCSIZ);</span>
<span class="fc" id="L316">            e.size = get32(tmpbuf, LOCLEN);</span>
        }
<span class="fc" id="L318">        len = get16(tmpbuf, LOCEXT);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (len &gt; 0) {</span>
<span class="fc" id="L320">            byte[] extra = new byte[len];</span>
<span class="fc" id="L321">            readFully(extra, 0, len);</span>
<span class="fc" id="L322">            e.setExtra0(extra, true);</span>
        }
<span class="fc" id="L324">        return e;</span>
    }

    /**
     * Creates a new &lt;code&gt;ZipEntry&lt;/code&gt; object for the specified
     * entry name.
     *
     * @param name the ZIP file entry name
     * @return the ZipEntry just created
     */
    protected ZipEntry createZipEntry(String name) {
<span class="fc" id="L335">        return new ZipEntry(name);</span>
    }

    /*
     * Reads end of deflated entry as well as EXT descriptor if present.
     */
    private void readEnd(ZipEntry e) throws IOException {
<span class="fc" id="L342">        int n = inf.getRemaining();</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        if (n &gt; 0) {</span>
<span class="fc" id="L344">            ((PushbackInputStream)in).unread(buf, len - n, n);</span>
        }
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if ((flag &amp; 8) == 8) {</span>
            /* &quot;Data Descriptor&quot; present */
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">            if (inf.getBytesWritten() &gt; ZIP64_MAGICVAL ||</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                inf.getBytesRead() &gt; ZIP64_MAGICVAL) {</span>
                // ZIP64 format
<span class="nc" id="L351">                readFully(tmpbuf, 0, ZIP64_EXTHDR);</span>
<span class="nc" id="L352">                long sig = get32(tmpbuf, 0);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">                if (sig != EXTSIG) { // no EXTSIG present</span>
<span class="nc" id="L354">                    e.crc = sig;</span>
<span class="nc" id="L355">                    e.csize = get64(tmpbuf, ZIP64_EXTSIZ - ZIP64_EXTCRC);</span>
<span class="nc" id="L356">                    e.size = get64(tmpbuf, ZIP64_EXTLEN - ZIP64_EXTCRC);</span>
<span class="nc" id="L357">                    ((PushbackInputStream)in).unread(</span>
                        tmpbuf, ZIP64_EXTHDR - ZIP64_EXTCRC - 1, ZIP64_EXTCRC);
                } else {
<span class="nc" id="L360">                    e.crc = get32(tmpbuf, ZIP64_EXTCRC);</span>
<span class="nc" id="L361">                    e.csize = get64(tmpbuf, ZIP64_EXTSIZ);</span>
<span class="nc" id="L362">                    e.size = get64(tmpbuf, ZIP64_EXTLEN);</span>
                }
<span class="nc" id="L364">            } else {</span>
<span class="fc" id="L365">                readFully(tmpbuf, 0, EXTHDR);</span>
<span class="fc" id="L366">                long sig = get32(tmpbuf, 0);</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">                if (sig != EXTSIG) { // no EXTSIG present</span>
<span class="nc" id="L368">                    e.crc = sig;</span>
<span class="nc" id="L369">                    e.csize = get32(tmpbuf, EXTSIZ - EXTCRC);</span>
<span class="nc" id="L370">                    e.size = get32(tmpbuf, EXTLEN - EXTCRC);</span>
<span class="nc" id="L371">                    ((PushbackInputStream)in).unread(</span>
                                               tmpbuf, EXTHDR - EXTCRC - 1, EXTCRC);
                } else {
<span class="fc" id="L374">                    e.crc = get32(tmpbuf, EXTCRC);</span>
<span class="fc" id="L375">                    e.csize = get32(tmpbuf, EXTSIZ);</span>
<span class="fc" id="L376">                    e.size = get32(tmpbuf, EXTLEN);</span>
                }
            }
        }
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (e.size != inf.getBytesWritten()) {</span>
<span class="nc" id="L381">            throw new ZipException(</span>
                &quot;invalid entry size (expected &quot; + e.size +
<span class="nc" id="L383">                &quot; but got &quot; + inf.getBytesWritten() + &quot; bytes)&quot;);</span>
        }
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">        if (e.csize != inf.getBytesRead()) {</span>
<span class="nc" id="L386">            throw new ZipException(</span>
                &quot;invalid entry compressed size (expected &quot; + e.csize +
<span class="nc" id="L388">                &quot; but got &quot; + inf.getBytesRead() + &quot; bytes)&quot;);</span>
        }
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (e.crc != crc.getValue()) {</span>
<span class="nc" id="L391">            throw new ZipException(</span>
<span class="nc" id="L392">                &quot;invalid entry CRC (expected 0x&quot; + Long.toHexString(e.crc) +</span>
<span class="nc" id="L393">                &quot; but got 0x&quot; + Long.toHexString(crc.getValue()) + &quot;)&quot;);</span>
        }
<span class="fc" id="L395">    }</span>

    /*
     * Reads bytes, blocking until all bytes are read.
     */
    private void readFully(byte[] b, int off, int len) throws IOException {
<span class="fc bfc" id="L401" title="All 2 branches covered.">        while (len &gt; 0) {</span>
<span class="fc" id="L402">            int n = in.read(b, off, len);</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">            if (n == -1) {</span>
<span class="nc" id="L404">                throw new EOFException();</span>
            }
<span class="fc" id="L406">            off += n;</span>
<span class="fc" id="L407">            len -= n;</span>
<span class="fc" id="L408">        }</span>
<span class="fc" id="L409">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>