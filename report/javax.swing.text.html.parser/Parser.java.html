<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Parser.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text.html.parser</a> &gt; <span class="el_source">Parser.java</span></div><h1>Parser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.text.html.parser;

import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.html.HTML;
import javax.swing.text.ChangedCharSetException;
import java.io.*;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Vector;
import java.util.Enumeration;
import java.net.URL;

import sun.misc.MessageUtils;

/**
 * A simple DTD-driven HTML parser. The parser reads an
 * HTML file from an InputStream and calls various methods
 * (which should be overridden in a subclass) when tags and
 * data are encountered.
 * &lt;p&gt;
 * Unfortunately there are many badly implemented HTML parsers
 * out there, and as a result there are many badly formatted
 * HTML files. This parser attempts to parse most HTML files.
 * This means that the implementation sometimes deviates from
 * the SGML specification in favor of HTML.
 * &lt;p&gt;
 * The parser treats \r and \r\n as \n. Newlines after starttags
 * and before end tags are ignored just as specified in the SGML/HTML
 * specification.
 * &lt;p&gt;
 * The html spec does not specify how spaces are to be coalesced very well.
 * Specifically, the following scenarios are not discussed (note that a
 * space should be used here, but I am using &amp;amp;nbsp to force the space to
 * be displayed):
 * &lt;p&gt;
 * '&amp;lt;b&amp;gt;blah&amp;nbsp;&amp;lt;i&amp;gt;&amp;nbsp;&amp;lt;strike&amp;gt;&amp;nbsp;foo' which can be treated as:
 * '&amp;lt;b&amp;gt;blah&amp;nbsp;&amp;lt;i&amp;gt;&amp;lt;strike&amp;gt;foo'
 * &lt;p&gt;as well as:
 * '&amp;lt;p&amp;gt;&amp;lt;a href=&quot;xx&quot;&amp;gt;&amp;nbsp;&amp;lt;em&amp;gt;Using&amp;lt;/em&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;'
 * which appears to be treated as:
 * '&amp;lt;p&amp;gt;&amp;lt;a href=&quot;xx&quot;&amp;gt;&amp;lt;em&amp;gt;Using&amp;lt;/em&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;'
 * &lt;p&gt;
 * If &lt;code&gt;strict&lt;/code&gt; is false, when a tag that breaks flow,
 * (&lt;code&gt;TagElement.breaksFlows&lt;/code&gt;) or trailing whitespace is
 * encountered, all whitespace will be ignored until a non whitespace
 * character is encountered. This appears to give behavior closer to
 * the popular browsers.
 *
 * @see DTD
 * @see TagElement
 * @see SimpleAttributeSet
 * @author Arthur van Hoff
 * @author Sunita Mani
 */
public
class Parser implements DTDConstants {

<span class="nc" id="L83">    private char text[] = new char[1024];</span>
<span class="nc" id="L84">    private int textpos = 0;</span>
    private TagElement last;
    private boolean space;

<span class="nc" id="L88">    private char str[] = new char[128];</span>
<span class="nc" id="L89">    private int strpos = 0;</span>

<span class="nc" id="L91">    protected DTD dtd = null;</span>

    private int ch;
    private int ln;
    private Reader in;

    private Element recent;
    private TagStack stack;
<span class="nc" id="L99">    private boolean skipTag = false;</span>
<span class="nc" id="L100">    private TagElement lastFormSent = null;</span>
<span class="nc" id="L101">    private SimpleAttributeSet attributes = new SimpleAttributeSet();</span>

    // State for &lt;html&gt;, &lt;head&gt; and &lt;body&gt;.  Since people like to slap
    // together HTML documents without thinking, occasionally they
    // have multiple instances of these tags.  These booleans track
    // the first sightings of these tags so they can be safely ignored
    // by the parser if repeated.
<span class="nc" id="L108">    private boolean seenHtml = false;</span>
<span class="nc" id="L109">    private boolean seenHead = false;</span>
<span class="nc" id="L110">    private boolean seenBody = false;</span>

    /**
     * The html spec does not specify how spaces are coalesced very well.
     * If strict == false, ignoreSpace is used to try and mimic the behavior
     * of the popular browsers.
     * &lt;p&gt;
     * The problematic scenarios are:
     * '&amp;lt;b&gt;blah &amp;lt;i&gt; &amp;lt;strike&gt; foo' which can be treated as:
     * '&amp;lt;b&gt;blah &amp;lt;i&gt;&amp;lt;strike&gt;foo'
     * as well as:
     * '&amp;lt;p&gt;&amp;lt;a href=&quot;xx&quot;&gt; &amp;lt;em&gt;Using&amp;lt;/em&gt;&amp;lt;/a&gt;&amp;lt;/p&gt;'
     * which appears to be treated as:
     * '&amp;lt;p&gt;&amp;lt;a href=&quot;xx&quot;&gt;&amp;lt;em&gt;Using&amp;lt;/em&gt;&amp;lt;/a&gt;&amp;lt;/p&gt;'
     * &lt;p&gt;
     * When a tag that breaks flow, or trailing whitespace is encountered
     * ignoreSpace is set to true. From then on, all whitespace will be
     * ignored.
     * ignoreSpace will be set back to false the first time a
     * non whitespace character is encountered. This appears to give
     * behavior closer to the popular browsers.
     */
    private boolean ignoreSpace;

    /**
     * This flag determines whether or not the Parser will be strict
     * in enforcing SGML compatibility.  If false, it will be lenient
     * with certain common classes of erroneous HTML constructs.
     * Strict or not, in either case an error will be recorded.
     *
     */
<span class="nc" id="L141">    protected boolean strict = false;</span>


    /** Number of \r\n's encountered. */
    private int crlfCount;
    /** Number of \r's encountered. A \r\n will not increment this. */
    private int crCount;
    /** Number of \n's encountered. A \r\n will not increment this. */
    private int lfCount;

    //
    // To correctly identify the start of a tag/comment/text we need two
    // ivars. Two are needed as handleText isn't invoked until the tag
    // after the text has been parsed, that is the parser parses the text,
    // then a tag, then invokes handleText followed by handleStart.
    //
    /** The start position of the current block. Block is overloaded here,
     * it really means the current start position for the current comment,
     * tag, text. Use getBlockStartPosition to access this. */
    private int currentBlockStartPos;
    /** Start position of the last block. */
    private int lastBlockStartPos;

    /**
     * array for mapping numeric references in range
     * 130-159 to displayable Unicode characters.
     */
<span class="nc" id="L168">    private static final char[] cp1252Map = {</span>
        8218,  // &amp;#130;
        402,   // &amp;#131;
        8222,  // &amp;#132;
        8230,  // &amp;#133;
        8224,  // &amp;#134;
        8225,  // &amp;#135;
        710,   // &amp;#136;
        8240,  // &amp;#137;
        352,   // &amp;#138;
        8249,  // &amp;#139;
        338,   // &amp;#140;
        141,   // &amp;#141;
        142,   // &amp;#142;
        143,   // &amp;#143;
        144,   // &amp;#144;
        8216,  // &amp;#145;
        8217,  // &amp;#146;
        8220,  // &amp;#147;
        8221,  // &amp;#148;
        8226,  // &amp;#149;
        8211,  // &amp;#150;
        8212,  // &amp;#151;
        732,   // &amp;#152;
        8482,  // &amp;#153;
        353,   // &amp;#154;
        8250,  // &amp;#155;
        339,   // &amp;#156;
        157,   // &amp;#157;
        158,   // &amp;#158;
        376    // &amp;#159;
    };

<span class="nc" id="L201">    public Parser(DTD dtd) {</span>
<span class="nc" id="L202">        this.dtd = dtd;</span>
<span class="nc" id="L203">    }</span>


    /**
     * @return the line number of the line currently being parsed
     */
    protected int getCurrentLine() {
<span class="nc" id="L210">        return ln;</span>
    }

    /**
     * Returns the start position of the current block. Block is
     * overloaded here, it really means the current start position for
     * the current comment tag, text, block.... This is provided for
     * subclassers that wish to know the start of the current block when
     * called with one of the handleXXX methods.
     */
    int getBlockStartPosition() {
<span class="nc" id="L221">        return Math.max(0, lastBlockStartPos - 1);</span>
    }

    /**
     * Makes a TagElement.
     */
    protected TagElement makeTag(Element elem, boolean fictional) {
<span class="nc" id="L228">        return new TagElement(elem, fictional);</span>
    }

    protected TagElement makeTag(Element elem) {
<span class="nc" id="L232">        return makeTag(elem, false);</span>
    }

    protected SimpleAttributeSet getAttributes() {
<span class="nc" id="L236">        return attributes;</span>
    }

    protected void flushAttributes() {
<span class="nc" id="L240">        attributes.removeAttributes(attributes);</span>
<span class="nc" id="L241">    }</span>

    /**
     * Called when PCDATA is encountered.
     */
    protected void handleText(char text[]) {
<span class="nc" id="L247">    }</span>

    /**
     * Called when an HTML title tag is encountered.
     */
    protected void handleTitle(char text[]) {
        // default behavior is to call handleText. Subclasses
        // can override if necessary.
<span class="nc" id="L255">        handleText(text);</span>
<span class="nc" id="L256">    }</span>

    /**
     * Called when an HTML comment is encountered.
     */
    protected void handleComment(char text[]) {
<span class="nc" id="L262">    }</span>

    protected void handleEOFInComment() {
        // We've reached EOF.  Our recovery strategy is to
        // see if we have more than one line in the comment;
        // if so, we pretend that the comment was an unterminated
        // single line comment, and reparse the lines after the
        // first line as normal HTML content.

<span class="nc" id="L271">        int commentEndPos = strIndexOf('\n');</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (commentEndPos &gt;= 0) {</span>
<span class="nc" id="L273">            handleComment(getChars(0, commentEndPos));</span>
            try {
<span class="nc" id="L275">                in.close();</span>
<span class="nc" id="L276">                in = new CharArrayReader(getChars(commentEndPos + 1));</span>
<span class="nc" id="L277">                ch = '&gt;';</span>
<span class="nc" id="L278">            } catch (IOException e) {</span>
<span class="nc" id="L279">                error(&quot;ioexception&quot;);</span>
<span class="nc" id="L280">            }</span>

<span class="nc" id="L282">            resetStrBuffer();</span>
        } else {
            // no newline, so signal an error
<span class="nc" id="L285">            error(&quot;eof.comment&quot;);</span>
        }
<span class="nc" id="L287">    }</span>

    /**
     * Called when an empty tag is encountered.
     */
    protected void handleEmptyTag(TagElement tag) throws ChangedCharSetException {
<span class="nc" id="L293">    }</span>

    /**
     * Called when a start tag is encountered.
     */
    protected void handleStartTag(TagElement tag) {
<span class="nc" id="L299">    }</span>

    /**
     * Called when an end tag is encountered.
     */
    protected void handleEndTag(TagElement tag) {
<span class="nc" id="L305">    }</span>

    /**
     * An error has occurred.
     */
    protected void handleError(int ln, String msg) {
        /*
        Thread.dumpStack();
        System.out.println(&quot;**** &quot; + stack);
        System.out.println(&quot;line &quot; + ln + &quot;: error: &quot; + msg);
        System.out.println();
        */
<span class="nc" id="L317">    }</span>

    /**
     * Output text.
     */
    void handleText(TagElement tag) {
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (tag.breaksFlow()) {</span>
<span class="nc" id="L324">            space = false;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (!strict) {</span>
<span class="nc" id="L326">                ignoreSpace = true;</span>
            }
        }
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (textpos == 0) {</span>
<span class="nc bnc" id="L330" title="All 6 branches missed.">            if ((!space) || (stack == null) || last.breaksFlow() ||</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                !stack.advance(dtd.pcdata)) {</span>
<span class="nc" id="L332">                last = tag;</span>
<span class="nc" id="L333">                space = false;</span>
<span class="nc" id="L334">                lastBlockStartPos = currentBlockStartPos;</span>
<span class="nc" id="L335">                return;</span>
            }
        }
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (space) {</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">            if (!ignoreSpace) {</span>
                // enlarge buffer if needed
<span class="nc bnc" id="L341" title="All 2 branches missed.">                if (textpos + 1 &gt; text.length) {</span>
<span class="nc" id="L342">                    char newtext[] = new char[text.length + 200];</span>
<span class="nc" id="L343">                    System.arraycopy(text, 0, newtext, 0, text.length);</span>
<span class="nc" id="L344">                    text = newtext;</span>
                }

                // output pending space
<span class="nc" id="L348">                text[textpos++] = ' ';</span>
<span class="nc bnc" id="L349" title="All 4 branches missed.">                if (!strict &amp;&amp; !tag.getElement().isEmpty()) {</span>
<span class="nc" id="L350">                    ignoreSpace = true;</span>
                }
            }
<span class="nc" id="L353">            space = false;</span>
        }
<span class="nc" id="L355">        char newtext[] = new char[textpos];</span>
<span class="nc" id="L356">        System.arraycopy(text, 0, newtext, 0, textpos);</span>
        // Handles cases of bad html where the title tag
        // was getting lost when we did error recovery.
<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (tag.getElement().getName().equals(&quot;title&quot;)) {</span>
<span class="nc" id="L360">            handleTitle(newtext);</span>
        } else {
<span class="nc" id="L362">            handleText(newtext);</span>
        }
<span class="nc" id="L364">        lastBlockStartPos = currentBlockStartPos;</span>
<span class="nc" id="L365">        textpos = 0;</span>
<span class="nc" id="L366">        last = tag;</span>
<span class="nc" id="L367">        space = false;</span>
<span class="nc" id="L368">    }</span>

    /**
     * Invoke the error handler.
     */
    protected void error(String err, String arg1, String arg2,
        String arg3) {
<span class="nc" id="L375">        handleError(ln, err + &quot; &quot; + arg1 + &quot; &quot; + arg2 + &quot; &quot; + arg3);</span>
<span class="nc" id="L376">    }</span>

    protected void error(String err, String arg1, String arg2) {
<span class="nc" id="L379">        error(err, arg1, arg2, &quot;?&quot;);</span>
<span class="nc" id="L380">    }</span>
    protected void error(String err, String arg1) {
<span class="nc" id="L382">        error(err, arg1, &quot;?&quot;, &quot;?&quot;);</span>
<span class="nc" id="L383">    }</span>
    protected void error(String err) {
<span class="nc" id="L385">        error(err, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;);</span>
<span class="nc" id="L386">    }</span>


    /**
     * Handle a start tag. The new tag is pushed
     * onto the tag stack. The attribute list is
     * checked for required attributes.
     */
    protected void startTag(TagElement tag) throws ChangedCharSetException {
<span class="nc" id="L395">        Element elem = tag.getElement();</span>

        // If the tag is an empty tag and texpos != 0
        // this implies that there is text before the
        // start tag that needs to be processed before
        // handling the tag.
        //
<span class="nc bnc" id="L402" title="All 4 branches missed.">        if (!elem.isEmpty() ||</span>
<span class="nc bnc" id="L403" title="All 4 branches missed.">                    ((last != null) &amp;&amp; !last.breaksFlow()) ||</span>
                    (textpos != 0)) {
<span class="nc" id="L405">            handleText(tag);</span>
        } else {
            // this variable gets updated in handleText().
            // Since in this case we do not call handleText()
            // we need to update it here.
            //
<span class="nc" id="L411">            last = tag;</span>
            // Note that we should really check last.breakFlows before
            // assuming this should be false.
<span class="nc" id="L414">            space = false;</span>
        }
<span class="nc" id="L416">        lastBlockStartPos = currentBlockStartPos;</span>

        // check required attributes
<span class="nc bnc" id="L419" title="All 2 branches missed.">        for (AttributeList a = elem.atts ; a != null ; a = a.next) {</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">            if ((a.modifier == REQUIRED) &amp;&amp;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                ((attributes.isEmpty()) ||</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                 ((!attributes.isDefined(a.name)) &amp;&amp;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                  (!attributes.isDefined(HTML.getAttributeKey(a.name)))))) {</span>
<span class="nc" id="L424">                error(&quot;req.att &quot;, a.getName(), elem.getName());</span>
            }
        }

<span class="nc bnc" id="L428" title="All 2 branches missed.">        if (elem.isEmpty()) {</span>
<span class="nc" id="L429">            handleEmptyTag(tag);</span>
            /*
        } else if (elem.getName().equals(&quot;form&quot;)) {
            handleStartTag(tag);
            */
        } else {
<span class="nc" id="L435">            recent = elem;</span>
<span class="nc" id="L436">            stack = new TagStack(tag, stack);</span>
<span class="nc" id="L437">            handleStartTag(tag);</span>
        }
<span class="nc" id="L439">    }</span>

    /**
     * Handle an end tag. The end tag is popped
     * from the tag stack.
     */
    protected void endTag(boolean omitted) {
<span class="nc" id="L446">        handleText(stack.tag);</span>

<span class="nc bnc" id="L448" title="All 4 branches missed.">        if (omitted &amp;&amp; !stack.elem.omitEnd()) {</span>
<span class="nc" id="L449">            error(&quot;end.missing&quot;, stack.elem.getName());</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">        } else if (!stack.terminate()) {</span>
<span class="nc" id="L451">            error(&quot;end.unexpected&quot;, stack.elem.getName());</span>
        }

        // handle the tag
<span class="nc" id="L455">        handleEndTag(stack.tag);</span>
<span class="nc" id="L456">        stack = stack.next;</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">        recent = (stack != null) ? stack.elem : null;</span>
<span class="nc" id="L458">    }</span>


    boolean ignoreElement(Element elem) {

<span class="nc" id="L463">        String stackElement = stack.elem.getName();</span>
<span class="nc" id="L464">        String elemName = elem.getName();</span>
        /* We ignore all elements that are not valid in the context of
           a table except &lt;td&gt;, &lt;th&gt; (these we handle in
           legalElementContext()) and #pcdata.  We also ignore the
           &lt;font&gt; tag in the context of &lt;ul&gt; and &lt;ol&gt; We additonally
           ignore the &lt;meta&gt; and the &lt;style&gt; tag if the body tag has
           been seen. **/
<span class="nc bnc" id="L471" title="All 4 branches missed.">        if ((elemName.equals(&quot;html&quot;) &amp;&amp; seenHtml) ||</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">            (elemName.equals(&quot;head&quot;) &amp;&amp; seenHead) ||</span>
<span class="nc bnc" id="L473" title="All 4 branches missed.">            (elemName.equals(&quot;body&quot;) &amp;&amp; seenBody)) {</span>
<span class="nc" id="L474">            return true;</span>
        }
<span class="nc bnc" id="L476" title="All 4 branches missed.">        if (elemName.equals(&quot;dt&quot;) || elemName.equals(&quot;dd&quot;)) {</span>
<span class="nc" id="L477">            TagStack s = stack;</span>
<span class="nc bnc" id="L478" title="All 4 branches missed.">            while (s != null &amp;&amp; !s.elem.getName().equals(&quot;dl&quot;)) {</span>
<span class="nc" id="L479">                s = s.next;</span>
            }
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (s == null) {</span>
<span class="nc" id="L482">                return true;</span>
            }
        }

<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (((stackElement.equals(&quot;table&quot;)) &amp;&amp;</span>
<span class="nc bnc" id="L487" title="All 4 branches missed.">             (!elemName.equals(&quot;#pcdata&quot;)) &amp;&amp; (!elemName.equals(&quot;input&quot;))) ||</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">            ((elemName.equals(&quot;font&quot;)) &amp;&amp;</span>
<span class="nc bnc" id="L489" title="All 4 branches missed.">             (stackElement.equals(&quot;ul&quot;) || stackElement.equals(&quot;ol&quot;))) ||</span>
<span class="nc bnc" id="L490" title="All 4 branches missed.">            (elemName.equals(&quot;meta&quot;) &amp;&amp; stack != null) ||</span>
<span class="nc bnc" id="L491" title="All 4 branches missed.">            (elemName.equals(&quot;style&quot;) &amp;&amp; seenBody) ||</span>
<span class="nc bnc" id="L492" title="All 4 branches missed.">            (stackElement.equals(&quot;table&quot;) &amp;&amp; elemName.equals(&quot;a&quot;))) {</span>
<span class="nc" id="L493">            return true;</span>
        }
<span class="nc" id="L495">        return false;</span>
    }


    /**
     * Marks the first time a tag has been seen in a document
     */

    protected void markFirstTime(Element elem) {
<span class="nc" id="L504">        String elemName = elem.getName();</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (elemName.equals(&quot;html&quot;)) {</span>
<span class="nc" id="L506">            seenHtml = true;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        } else if (elemName.equals(&quot;head&quot;)) {</span>
<span class="nc" id="L508">            seenHead = true;</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        } else if (elemName.equals(&quot;body&quot;)) {</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">            if (buf.length == 1) {</span>
                // Refer to note in definition of buf for details on this.
<span class="nc" id="L512">                char[] newBuf = new char[256];</span>

<span class="nc" id="L514">                newBuf[0] = buf[0];</span>
<span class="nc" id="L515">                buf = newBuf;</span>
            }
<span class="nc" id="L517">            seenBody = true;</span>
        }
<span class="nc" id="L519">    }</span>

    /**
     * Create a legal content for an element.
     */
    boolean legalElementContext(Element elem) throws ChangedCharSetException {

        // System.out.println(&quot;-- legalContext -- &quot; + elem);

        // Deal with the empty stack
<span class="nc bnc" id="L529" title="All 2 branches missed.">        if (stack == null) {</span>
            // System.out.println(&quot;-- stack is empty&quot;);
<span class="nc bnc" id="L531" title="All 2 branches missed.">            if (elem != dtd.html) {</span>
                // System.out.println(&quot;-- pushing html&quot;);
<span class="nc" id="L533">                startTag(makeTag(dtd.html, true));</span>
<span class="nc" id="L534">                return legalElementContext(elem);</span>
            }
<span class="nc" id="L536">            return true;</span>
        }

        // Is it allowed in the current context
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (stack.advance(elem)) {</span>
            // System.out.println(&quot;-- legal context&quot;);
<span class="nc" id="L542">            markFirstTime(elem);</span>
<span class="nc" id="L543">            return true;</span>
        }
<span class="nc" id="L545">        boolean insertTag = false;</span>

        // The use of all error recovery strategies are contingent
        // on the value of the strict property.
        //
        // These are commonly occurring errors.  if insertTag is true,
        // then we want to adopt an error recovery strategy that
        // involves attempting to insert an additional tag to
        // legalize the context.  The two errors addressed here
        // are:
        // 1) when a &lt;td&gt; or &lt;th&gt; is seen soon after a &lt;table&gt; tag.
        //    In this case we insert a &lt;tr&gt;.
        // 2) when any other tag apart from a &lt;tr&gt; is seen
        //    in the context of a &lt;tr&gt;.  In this case we would
        //    like to add a &lt;td&gt;.  If a &lt;tr&gt; is seen within a
        //    &lt;tr&gt; context, then we will close out the current
        //    &lt;tr&gt;.
        //
        // This insertion strategy is handled later in the method.
        // The reason for checking this now, is that in other cases
        // we would like to apply other error recovery strategies for example
        // ignoring tags.
        //
        // In certain cases it is better to ignore a tag than try to
        // fix the situation.  So the first test is to see if this
        // is what we need to do.
        //
<span class="nc" id="L572">        String stackElemName = stack.elem.getName();</span>
<span class="nc" id="L573">        String elemName = elem.getName();</span>


<span class="nc bnc" id="L576" title="All 2 branches missed.">        if (!strict &amp;&amp;</span>
<span class="nc bnc" id="L577" title="All 4 branches missed.">            ((stackElemName.equals(&quot;table&quot;) &amp;&amp; elemName.equals(&quot;td&quot;)) ||</span>
<span class="nc bnc" id="L578" title="All 4 branches missed.">             (stackElemName.equals(&quot;table&quot;) &amp;&amp; elemName.equals(&quot;th&quot;)) ||</span>
<span class="nc bnc" id="L579" title="All 4 branches missed.">             (stackElemName.equals(&quot;tr&quot;) &amp;&amp; !elemName.equals(&quot;tr&quot;)))){</span>
<span class="nc" id="L580">             insertTag = true;</span>
        }


<span class="nc bnc" id="L584" title="All 6 branches missed.">        if (!strict &amp;&amp; !insertTag &amp;&amp; (stack.elem.getName() != elem.getName() ||</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">                                      elem.getName().equals(&quot;body&quot;))) {</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">            if (skipTag = ignoreElement(elem)) {</span>
<span class="nc" id="L587">                error(&quot;tag.ignore&quot;, elem.getName());</span>
<span class="nc" id="L588">                return skipTag;</span>
            }
        }

        // Check for anything after the start of the table besides tr, td, th
        // or caption, and if those aren't there, insert the &lt;tr&gt; and call
        // legalElementContext again.
<span class="nc bnc" id="L595" title="All 4 branches missed.">        if (!strict &amp;&amp; stackElemName.equals(&quot;table&quot;) &amp;&amp;</span>
<span class="nc bnc" id="L596" title="All 4 branches missed.">            !elemName.equals(&quot;tr&quot;) &amp;&amp; !elemName.equals(&quot;td&quot;) &amp;&amp;</span>
<span class="nc bnc" id="L597" title="All 4 branches missed.">            !elemName.equals(&quot;th&quot;) &amp;&amp; !elemName.equals(&quot;caption&quot;)) {</span>
<span class="nc" id="L598">            Element e = dtd.getElement(&quot;tr&quot;);</span>
<span class="nc" id="L599">            TagElement t = makeTag(e, true);</span>
<span class="nc" id="L600">            legalTagContext(t);</span>
<span class="nc" id="L601">            startTag(t);</span>
<span class="nc" id="L602">            error(&quot;start.missing&quot;, elem.getName());</span>
<span class="nc" id="L603">            return legalElementContext(elem);</span>
        }

        // They try to find a legal context by checking if the current
        // tag is valid in an enclosing context.  If so
        // close out the tags by outputing end tags and then
        // insert the current tag.  If the tags that are
        // being closed out do not have an optional end tag
        // specification in the DTD then an html error is
        // reported.
        //
<span class="nc bnc" id="L614" title="All 8 branches missed.">        if (!insertTag &amp;&amp; stack.terminate() &amp;&amp; (!strict || stack.elem.omitEnd())) {</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">            for (TagStack s = stack.next ; s != null ; s = s.next) {</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">                if (s.advance(elem)) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">                    while (stack != s) {</span>
<span class="nc" id="L618">                        endTag(true);</span>
                    }
<span class="nc" id="L620">                    return true;</span>
                }
<span class="nc bnc" id="L622" title="All 6 branches missed.">                if (!s.terminate() || (strict &amp;&amp; !s.elem.omitEnd())) {</span>
<span class="nc" id="L623">                    break;</span>
                }
            }
        }

        // Check if we know what tag is expected next.
        // If so insert the tag.  Report an error if the
        // tag does not have its start tag spec in the DTD as optional.
        //
<span class="nc" id="L632">        Element next = stack.first();</span>
<span class="nc bnc" id="L633" title="All 10 branches missed.">        if (next != null &amp;&amp; (!strict || next.omitStart()) &amp;&amp;</span>
           !(next==dtd.head &amp;&amp; elem==dtd.pcdata) ) {
            // System.out.println(&quot;-- omitting start tag: &quot; + next);
<span class="nc" id="L636">            TagElement t = makeTag(next, true);</span>
<span class="nc" id="L637">            legalTagContext(t);</span>
<span class="nc" id="L638">            startTag(t);</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">            if (!next.omitStart()) {</span>
<span class="nc" id="L640">                error(&quot;start.missing&quot;, elem.getName());</span>
            }
<span class="nc" id="L642">            return legalElementContext(elem);</span>
        }


        // Traverse the list of expected elements and determine if adding
        // any of these elements would make for a legal context.
        //

<span class="nc bnc" id="L650" title="All 2 branches missed.">        if (!strict) {</span>
<span class="nc" id="L651">            ContentModel content = stack.contentModel();</span>
<span class="nc" id="L652">            Vector&lt;Element&gt; elemVec = new Vector&lt;Element&gt;();</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">            if (content != null) {</span>
<span class="nc" id="L654">                content.getElements(elemVec);</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">                for (Element e : elemVec) {</span>
                    // Ensure that this element has not been included as
                    // part of the exclusions in the DTD.
                    //
<span class="nc bnc" id="L659" title="All 2 branches missed.">                    if (stack.excluded(e.getIndex())) {</span>
<span class="nc" id="L660">                        continue;</span>
                    }

<span class="nc" id="L663">                    boolean reqAtts = false;</span>

<span class="nc bnc" id="L665" title="All 2 branches missed.">                    for (AttributeList a = e.getAttributes(); a != null ; a = a.next) {</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                        if (a.modifier == REQUIRED) {</span>
<span class="nc" id="L667">                            reqAtts = true;</span>
<span class="nc" id="L668">                            break;</span>
                        }
                    }
                    // Ensure that no tag that has required attributes
                    // gets inserted.
                    //
<span class="nc bnc" id="L674" title="All 2 branches missed.">                    if (reqAtts) {</span>
<span class="nc" id="L675">                        continue;</span>
                    }

<span class="nc" id="L678">                    ContentModel m = e.getContent();</span>
<span class="nc bnc" id="L679" title="All 4 branches missed.">                    if (m != null &amp;&amp; m.first(elem)) {</span>
                        // System.out.println(&quot;-- adding a legal tag: &quot; + e);
<span class="nc" id="L681">                        TagElement t = makeTag(e, true);</span>
<span class="nc" id="L682">                        legalTagContext(t);</span>
<span class="nc" id="L683">                        startTag(t);</span>
<span class="nc" id="L684">                        error(&quot;start.missing&quot;, e.getName());</span>
<span class="nc" id="L685">                        return legalElementContext(elem);</span>
                    }
<span class="nc" id="L687">                }</span>
            }
        }

        // Check if the stack can be terminated.  If so add the appropriate
        // end tag.  Report an error if the tag being ended does not have its
        // end tag spec in the DTD as optional.
        //
<span class="nc bnc" id="L695" title="All 8 branches missed.">        if (stack.terminate() &amp;&amp; (stack.elem != dtd.body) &amp;&amp; (!strict || stack.elem.omitEnd())) {</span>
            // System.out.println(&quot;-- omitting end tag: &quot; + stack.elem);
<span class="nc bnc" id="L697" title="All 2 branches missed.">            if (!stack.elem.omitEnd()) {</span>
<span class="nc" id="L698">                error(&quot;end.missing&quot;, elem.getName());</span>
            }

<span class="nc" id="L701">            endTag(true);</span>
<span class="nc" id="L702">            return legalElementContext(elem);</span>
        }

        // At this point we know that something is screwed up.
<span class="nc" id="L706">        return false;</span>
    }

    /**
     * Create a legal context for a tag.
     */
    void legalTagContext(TagElement tag) throws ChangedCharSetException {
<span class="nc bnc" id="L713" title="All 2 branches missed.">        if (legalElementContext(tag.getElement())) {</span>
<span class="nc" id="L714">            markFirstTime(tag.getElement());</span>
<span class="nc" id="L715">            return;</span>
        }

        // Avoid putting a block tag in a flow tag.
<span class="nc bnc" id="L719" title="All 6 branches missed.">        if (tag.breaksFlow() &amp;&amp; (stack != null) &amp;&amp; !stack.tag.breaksFlow()) {</span>
<span class="nc" id="L720">            endTag(true);</span>
<span class="nc" id="L721">            legalTagContext(tag);</span>
<span class="nc" id="L722">            return;</span>
        }

        // Avoid putting something wierd in the head of the document.
<span class="nc bnc" id="L726" title="All 2 branches missed.">        for (TagStack s = stack ; s != null ; s = s.next) {</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (s.tag.getElement() == dtd.head) {</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">                while (stack != s) {</span>
<span class="nc" id="L729">                    endTag(true);</span>
                }
<span class="nc" id="L731">                endTag(true);</span>
<span class="nc" id="L732">                legalTagContext(tag);</span>
<span class="nc" id="L733">                return;</span>
            }
        }

        // Everything failed
<span class="nc" id="L738">        error(&quot;tag.unexpected&quot;, tag.getElement().getName());</span>
<span class="nc" id="L739">    }</span>

    /**
     * Error context. Something went wrong, make sure we are in
     * the document's body context
     */
    void errorContext() throws ChangedCharSetException {
<span class="nc bnc" id="L746" title="All 4 branches missed.">        for (; (stack != null) &amp;&amp; (stack.tag.getElement() != dtd.body) ; stack = stack.next) {</span>
<span class="nc" id="L747">            handleEndTag(stack.tag);</span>
        }
<span class="nc bnc" id="L749" title="All 2 branches missed.">        if (stack == null) {</span>
<span class="nc" id="L750">            legalElementContext(dtd.body);</span>
<span class="nc" id="L751">            startTag(makeTag(dtd.body, true));</span>
        }
<span class="nc" id="L753">    }</span>

    /**
     * Add a char to the string buffer.
     */
    void addString(int c) {
<span class="nc bnc" id="L759" title="All 2 branches missed.">        if (strpos  == str.length) {</span>
<span class="nc" id="L760">            char newstr[] = new char[str.length + 128];</span>
<span class="nc" id="L761">            System.arraycopy(str, 0, newstr, 0, str.length);</span>
<span class="nc" id="L762">            str = newstr;</span>
        }
<span class="nc" id="L764">        str[strpos++] = (char)c;</span>
<span class="nc" id="L765">    }</span>

    /**
     * Get the string that's been accumulated.
     */
    String getString(int pos) {
<span class="nc" id="L771">        char newStr[] = new char[strpos - pos];</span>
<span class="nc" id="L772">        System.arraycopy(str, pos, newStr, 0, strpos - pos);</span>
<span class="nc" id="L773">        strpos = pos;</span>
<span class="nc" id="L774">        return new String(newStr);</span>
    }

    char[] getChars(int pos) {
<span class="nc" id="L778">        char newStr[] = new char[strpos - pos];</span>
<span class="nc" id="L779">        System.arraycopy(str, pos, newStr, 0, strpos - pos);</span>
<span class="nc" id="L780">        strpos = pos;</span>
<span class="nc" id="L781">        return newStr;</span>
    }

    char[] getChars(int pos, int endPos) {
<span class="nc" id="L785">        char newStr[] = new char[endPos - pos];</span>
<span class="nc" id="L786">        System.arraycopy(str, pos, newStr, 0, endPos - pos);</span>
        // REMIND: it's not clear whether this version should set strpos or not
        // strpos = pos;
<span class="nc" id="L789">        return newStr;</span>
    }

    void resetStrBuffer() {
<span class="nc" id="L793">        strpos = 0;</span>
<span class="nc" id="L794">    }</span>

    int strIndexOf(char target) {
<span class="nc bnc" id="L797" title="All 2 branches missed.">        for (int i = 0; i &lt; strpos; i++) {</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">            if (str[i] == target) {</span>
<span class="nc" id="L799">                return i;</span>
            }
        }

<span class="nc" id="L803">        return -1;</span>
    }

    /**
     * Skip space.
     * [5] 297:5
     */
    void skipSpace() throws IOException {
        while (true) {
<span class="nc bnc" id="L812" title="All 4 branches missed.">            switch (ch) {</span>
              case '\n':
<span class="nc" id="L814">                ln++;</span>
<span class="nc" id="L815">                ch = readCh();</span>
<span class="nc" id="L816">                lfCount++;</span>
<span class="nc" id="L817">                break;</span>

              case '\r':
<span class="nc" id="L820">                ln++;</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">                if ((ch = readCh()) == '\n') {</span>
<span class="nc" id="L822">                    ch = readCh();</span>
<span class="nc" id="L823">                    crlfCount++;</span>
                }
                else {
<span class="nc" id="L826">                    crCount++;</span>
                }
<span class="nc" id="L828">                break;</span>
              case ' ':
              case '\t':
<span class="nc" id="L831">                ch = readCh();</span>
<span class="nc" id="L832">                break;</span>

              default:
<span class="nc" id="L835">                return;</span>
            }
        }
    }

    /**
     * Parse identifier. Uppercase characters are folded
     * to lowercase when lower is true. Returns falsed if
     * no identifier is found. [55] 346:17
     */
    boolean parseIdentifier(boolean lower) throws IOException {
<span class="nc bnc" id="L846" title="All 3 branches missed.">        switch (ch) {</span>
          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
          case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
          case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
          case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
          case 'Y': case 'Z':
<span class="nc bnc" id="L852" title="All 2 branches missed.">            if (lower) {</span>
<span class="nc" id="L853">                ch = 'a' + (ch - 'A');</span>
            }

          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
          case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
          case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
          case 's': case 't': case 'u': case 'v': case 'w': case 'x':
          case 'y': case 'z':
<span class="nc" id="L861">            break;</span>

          default:
<span class="nc" id="L864">            return false;</span>
        }

        while (true) {
<span class="nc" id="L868">            addString(ch);</span>

<span class="nc bnc" id="L870" title="All 3 branches missed.">            switch (ch = readCh()) {</span>
              case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
              case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
              case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
              case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
              case 'Y': case 'Z':
<span class="nc bnc" id="L876" title="All 2 branches missed.">                if (lower) {</span>
<span class="nc" id="L877">                    ch = 'a' + (ch - 'A');</span>
                }

              case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
              case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
              case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
              case 's': case 't': case 'u': case 'v': case 'w': case 'x':
              case 'y': case 'z':

              case '0': case '1': case '2': case '3': case '4':
              case '5': case '6': case '7': case '8': case '9':

              case '.': case '-':

              case '_': // not officially allowed
<span class="nc" id="L892">                break;</span>

              default:
<span class="nc" id="L895">                return true;</span>
            }
        }
    }

    /**
     * Parse an entity reference. [59] 350:17
     */
    private char[] parseEntityReference() throws IOException {
<span class="nc" id="L904">        int pos = strpos;</span>

<span class="nc bnc" id="L906" title="All 2 branches missed.">        if ((ch = readCh()) == '#') {</span>
<span class="nc" id="L907">            int n = 0;</span>
<span class="nc" id="L908">            ch = readCh();</span>
<span class="nc bnc" id="L909" title="All 8 branches missed.">            if ((ch &gt;= '0') &amp;&amp; (ch &lt;= '9') ||</span>
                    ch == 'x' || ch == 'X') {

<span class="nc bnc" id="L912" title="All 4 branches missed.">                if ((ch &gt;= '0') &amp;&amp; (ch &lt;= '9')) {</span>
                    // parse decimal reference
<span class="nc bnc" id="L914" title="All 4 branches missed.">                    while ((ch &gt;= '0') &amp;&amp; (ch &lt;= '9')) {</span>
<span class="nc" id="L915">                        n = (n * 10) + ch - '0';</span>
<span class="nc" id="L916">                        ch = readCh();</span>
                    }
                } else {
                    // parse hexadecimal reference
<span class="nc" id="L920">                    ch = readCh();</span>
<span class="nc" id="L921">                    char lch = (char) Character.toLowerCase(ch);</span>
<span class="nc bnc" id="L922" title="All 8 branches missed.">                    while ((lch &gt;= '0') &amp;&amp; (lch &lt;= '9') ||</span>
                            (lch &gt;= 'a') &amp;&amp; (lch &lt;= 'f')) {
<span class="nc bnc" id="L924" title="All 4 branches missed.">                        if (lch &gt;= '0' &amp;&amp; lch &lt;= '9') {</span>
<span class="nc" id="L925">                            n = (n * 16) + lch - '0';</span>
                        } else {
<span class="nc" id="L927">                            n = (n * 16) + lch - 'a' + 10;</span>
                        }
<span class="nc" id="L929">                        ch = readCh();</span>
<span class="nc" id="L930">                        lch = (char) Character.toLowerCase(ch);</span>
                    }
                }
<span class="nc bnc" id="L933" title="All 4 branches missed.">                switch (ch) {</span>
                    case '\n':
<span class="nc" id="L935">                        ln++;</span>
<span class="nc" id="L936">                        ch = readCh();</span>
<span class="nc" id="L937">                        lfCount++;</span>
<span class="nc" id="L938">                        break;</span>

                    case '\r':
<span class="nc" id="L941">                        ln++;</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">                        if ((ch = readCh()) == '\n') {</span>
<span class="nc" id="L943">                            ch = readCh();</span>
<span class="nc" id="L944">                            crlfCount++;</span>
                        }
                        else {
<span class="nc" id="L947">                            crCount++;</span>
                        }
<span class="nc" id="L949">                        break;</span>

                    case ';':
<span class="nc" id="L952">                        ch = readCh();</span>
                        break;
                }
<span class="nc" id="L955">                char data[] = mapNumericReference(n);</span>
<span class="nc" id="L956">                return data;</span>
            }
<span class="nc" id="L958">            addString('#');</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">            if (!parseIdentifier(false)) {</span>
<span class="nc" id="L960">                error(&quot;ident.expected&quot;);</span>
<span class="nc" id="L961">                strpos = pos;</span>
<span class="nc" id="L962">                char data[] = {'&amp;', '#'};</span>
<span class="nc" id="L963">                return data;</span>
            }
<span class="nc bnc" id="L965" title="All 2 branches missed.">        } else if (!parseIdentifier(false)) {</span>
<span class="nc" id="L966">            char data[] = {'&amp;'};</span>
<span class="nc" id="L967">            return data;</span>
        }

<span class="nc" id="L970">        boolean semicolon = false;</span>

<span class="nc bnc" id="L972" title="All 4 branches missed.">        switch (ch) {</span>
          case '\n':
<span class="nc" id="L974">            ln++;</span>
<span class="nc" id="L975">            ch = readCh();</span>
<span class="nc" id="L976">            lfCount++;</span>
<span class="nc" id="L977">            break;</span>

          case '\r':
<span class="nc" id="L980">            ln++;</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">            if ((ch = readCh()) == '\n') {</span>
<span class="nc" id="L982">                ch = readCh();</span>
<span class="nc" id="L983">                crlfCount++;</span>
            }
            else {
<span class="nc" id="L986">                crCount++;</span>
            }
<span class="nc" id="L988">            break;</span>

          case ';':
<span class="nc" id="L991">            semicolon = true;</span>

<span class="nc" id="L993">            ch = readCh();</span>
            break;
        }

<span class="nc" id="L997">        String nm = getString(pos);</span>
<span class="nc" id="L998">        Entity ent = dtd.getEntity(nm);</span>

        // entities are case sensitive - however if strict
        // is false then we will try to make a match by
        // converting the string to all lowercase.
        //
<span class="nc bnc" id="L1004" title="All 4 branches missed.">        if (!strict &amp;&amp; (ent == null)) {</span>
<span class="nc" id="L1005">            ent = dtd.getEntity(nm.toLowerCase());</span>
        }
<span class="nc bnc" id="L1007" title="All 4 branches missed.">        if ((ent == null) || !ent.isGeneral()) {</span>

<span class="nc bnc" id="L1009" title="All 2 branches missed.">            if (nm.length() == 0) {</span>
<span class="nc" id="L1010">                error(&quot;invalid.entref&quot;, nm);</span>
<span class="nc" id="L1011">                return new char[0];</span>
            }
            /* given that there is not a match restore the entity reference */
<span class="nc bnc" id="L1014" title="All 2 branches missed.">            String str = &quot;&amp;&quot; + nm + (semicolon ? &quot;;&quot; : &quot;&quot;);</span>

<span class="nc" id="L1016">            char b[] = new char[str.length()];</span>
<span class="nc" id="L1017">            str.getChars(0, b.length, b, 0);</span>
<span class="nc" id="L1018">            return b;</span>
        }
<span class="nc" id="L1020">        return ent.getData();</span>
    }

    /**
     * Converts numeric character reference to char array.
     *
     * Normally the code in a reference should be always converted
     * to the Unicode character with the same code, but due to
     * wide usage of Cp1252 charset most browsers map numeric references
     * in the range 130-159 (which are control chars in Unicode set)
     * to displayable characters with other codes.
     *
     * @param c the code of numeric character reference.
     * @return a char array corresponding to the reference code.
     */
    private char[] mapNumericReference(int c) {
        char[] data;
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        if (c &gt;= 0xffff) { // outside unicode BMP.</span>
            try {
<span class="nc" id="L1039">                data = Character.toChars(c);</span>
<span class="nc" id="L1040">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1041">                data = new char[0];</span>
<span class="nc" id="L1042">            }</span>
        } else {
<span class="nc" id="L1044">            data = new char[1];</span>
<span class="nc bnc" id="L1045" title="All 4 branches missed.">            data[0] = (c &lt; 130 || c &gt; 159) ? (char) c : cp1252Map[c - 130];</span>
        }
<span class="nc" id="L1047">        return data;</span>
    }

    /**
     * Parse a comment. [92] 391:7
     */
    void parseComment() throws IOException {

        while (true) {
<span class="nc" id="L1056">            int c = ch;</span>
<span class="nc bnc" id="L1057" title="All 6 branches missed.">            switch (c) {</span>
              case '-':
                  /** Presuming that the start string of a comment &quot;&lt;!--&quot; has
                      already been parsed, the '-' character is valid only as
                      part of a comment termination and further more it must
                      be present in even numbers. Hence if strict is true, we
                      presume the comment has been terminated and return.
                      However if strict is false, then there is no even number
                      requirement and this character can appear anywhere in the
                      comment.  The parser reads on until it sees the following
                      pattern: &quot;--&gt;&quot; or &quot;--!&gt;&quot;.
                   **/
<span class="nc bnc" id="L1069" title="All 6 branches missed.">                if (!strict &amp;&amp; (strpos != 0) &amp;&amp; (str[strpos - 1] == '-')) {</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                    if ((ch = readCh()) == '&gt;') {</span>
<span class="nc" id="L1071">                        return;</span>
                    }
<span class="nc bnc" id="L1073" title="All 2 branches missed.">                    if (ch == '!') {</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">                        if ((ch = readCh()) == '&gt;') {</span>
<span class="nc" id="L1075">                            return;</span>
                        } else {
                            /* to account for extra read()'s that happened */
<span class="nc" id="L1078">                            addString('-');</span>
<span class="nc" id="L1079">                            addString('!');</span>
<span class="nc" id="L1080">                            continue;</span>
                        }
                    }
                    break;
                }

<span class="nc bnc" id="L1086" title="All 2 branches missed.">                if ((ch = readCh()) == '-') {</span>
<span class="nc" id="L1087">                    ch = readCh();</span>
<span class="nc bnc" id="L1088" title="All 4 branches missed.">                    if (strict || ch == '&gt;') {</span>
<span class="nc" id="L1089">                        return;</span>
                    }
<span class="nc bnc" id="L1091" title="All 2 branches missed.">                    if (ch == '!') {</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">                        if ((ch = readCh()) == '&gt;') {</span>
<span class="nc" id="L1093">                            return;</span>
                        } else {
                            /* to account for extra read()'s that happened */
<span class="nc" id="L1096">                            addString('-');</span>
<span class="nc" id="L1097">                            addString('!');</span>
<span class="nc" id="L1098">                            continue;</span>
                        }
                    }
                    /* to account for the extra read() */
<span class="nc" id="L1102">                    addString('-');</span>
                }
                break;

              case -1:
<span class="nc" id="L1107">                  handleEOFInComment();</span>
<span class="nc" id="L1108">                  return;</span>

              case '\n':
<span class="nc" id="L1111">                ln++;</span>
<span class="nc" id="L1112">                ch = readCh();</span>
<span class="nc" id="L1113">                lfCount++;</span>
<span class="nc" id="L1114">                break;</span>

              case '&gt;':
<span class="nc" id="L1117">                ch = readCh();</span>
<span class="nc" id="L1118">                break;</span>

              case '\r':
<span class="nc" id="L1121">                ln++;</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">                if ((ch = readCh()) == '\n') {</span>
<span class="nc" id="L1123">                    ch = readCh();</span>
<span class="nc" id="L1124">                    crlfCount++;</span>
                }
                else {
<span class="nc" id="L1127">                    crCount++;</span>
                }
<span class="nc" id="L1129">                c = '\n';</span>
<span class="nc" id="L1130">                break;</span>
              default:
<span class="nc" id="L1132">                ch = readCh();</span>
                break;
            }

<span class="nc" id="L1136">            addString(c);</span>
<span class="nc" id="L1137">        }</span>
    }

    /**
     * Parse literal content. [46] 343:1 and [47] 344:1
     */
    void parseLiteral(boolean replace) throws IOException {
        while (true) {
<span class="nc" id="L1145">            int c = ch;</span>
<span class="nc bnc" id="L1146" title="All 6 branches missed.">            switch (c) {</span>
              case -1:
<span class="nc" id="L1148">                error(&quot;eof.literal&quot;, stack.elem.getName());</span>
<span class="nc" id="L1149">                endTag(true);</span>
<span class="nc" id="L1150">                return;</span>

              case '&gt;':
<span class="nc" id="L1153">                ch = readCh();</span>
<span class="nc" id="L1154">                int i = textpos - (stack.elem.name.length() + 2), j = 0;</span>

                // match end tag
<span class="nc bnc" id="L1157" title="All 6 branches missed.">                if ((i &gt;= 0) &amp;&amp; (text[i++] == '&lt;') &amp;&amp; (text[i] == '/')) {</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">                    while ((++i &lt; textpos) &amp;&amp;</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">                           (Character.toLowerCase(text[i]) == stack.elem.name.charAt(j++)));</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">                    if (i == textpos) {</span>
<span class="nc" id="L1161">                        textpos -= (stack.elem.name.length() + 2);</span>
<span class="nc bnc" id="L1162" title="All 4 branches missed.">                        if ((textpos &gt; 0) &amp;&amp; (text[textpos-1] == '\n')) {</span>
<span class="nc" id="L1163">                            textpos--;</span>
                        }
<span class="nc" id="L1165">                        endTag(false);</span>
<span class="nc" id="L1166">                        return;</span>
                    }
                }
                break;

              case '&amp;':
<span class="nc" id="L1172">                char data[] = parseEntityReference();</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">                if (textpos + data.length &gt; text.length) {</span>
<span class="nc" id="L1174">                    char newtext[] = new char[Math.max(textpos + data.length + 128, text.length * 2)];</span>
<span class="nc" id="L1175">                    System.arraycopy(text, 0, newtext, 0, text.length);</span>
<span class="nc" id="L1176">                    text = newtext;</span>
                }
<span class="nc" id="L1178">                System.arraycopy(data, 0, text, textpos, data.length);</span>
<span class="nc" id="L1179">                textpos += data.length;</span>
<span class="nc" id="L1180">                continue;</span>

              case '\n':
<span class="nc" id="L1183">                ln++;</span>
<span class="nc" id="L1184">                ch = readCh();</span>
<span class="nc" id="L1185">                lfCount++;</span>
<span class="nc" id="L1186">                break;</span>

              case '\r':
<span class="nc" id="L1189">                ln++;</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">                if ((ch = readCh()) == '\n') {</span>
<span class="nc" id="L1191">                    ch = readCh();</span>
<span class="nc" id="L1192">                    crlfCount++;</span>
                }
                else {
<span class="nc" id="L1195">                    crCount++;</span>
                }
<span class="nc" id="L1197">                c = '\n';</span>
<span class="nc" id="L1198">                break;</span>
              default:
<span class="nc" id="L1200">                ch = readCh();</span>
                break;
            }

            // output character
<span class="nc bnc" id="L1205" title="All 2 branches missed.">            if (textpos == text.length) {</span>
<span class="nc" id="L1206">                char newtext[] = new char[text.length + 128];</span>
<span class="nc" id="L1207">                System.arraycopy(text, 0, newtext, 0, text.length);</span>
<span class="nc" id="L1208">                text = newtext;</span>
            }
<span class="nc" id="L1210">            text[textpos++] = (char)c;</span>
<span class="nc" id="L1211">        }</span>
    }

    /**
     * Parse attribute value. [33] 331:1
     */
    String parseAttributeValue(boolean lower) throws IOException {
<span class="nc" id="L1218">        int delim = -1;</span>

        // Check for a delimiter
<span class="nc bnc" id="L1221" title="All 2 branches missed.">        switch(ch) {</span>
          case '\'':
          case '&quot;':
<span class="nc" id="L1224">            delim = ch;</span>
<span class="nc" id="L1225">            ch = readCh();</span>
            break;
        }

        // Parse the rest of the value
        while (true) {
<span class="nc" id="L1231">            int c = ch;</span>

<span class="nc bnc" id="L1233" title="All 10 branches missed.">            switch (c) {</span>
              case '\n':
<span class="nc" id="L1235">                ln++;</span>
<span class="nc" id="L1236">                ch = readCh();</span>
<span class="nc" id="L1237">                lfCount++;</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">                if (delim &lt; 0) {</span>
<span class="nc" id="L1239">                    return getString(0);</span>
                }
                break;

              case '\r':
<span class="nc" id="L1244">                ln++;</span>

<span class="nc bnc" id="L1246" title="All 2 branches missed.">                if ((ch = readCh()) == '\n') {</span>
<span class="nc" id="L1247">                    ch = readCh();</span>
<span class="nc" id="L1248">                    crlfCount++;</span>
                }
                else {
<span class="nc" id="L1251">                    crCount++;</span>
                }
<span class="nc bnc" id="L1253" title="All 2 branches missed.">                if (delim &lt; 0) {</span>
<span class="nc" id="L1254">                    return getString(0);</span>
                }
                break;

              case '\t':
<span class="nc bnc" id="L1259" title="All 2 branches missed.">                  if (delim &lt; 0)</span>
<span class="nc" id="L1260">                      c = ' ';</span>
              case ' ':
<span class="nc" id="L1262">                ch = readCh();</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">                if (delim &lt; 0) {</span>
<span class="nc" id="L1264">                    return getString(0);</span>
                }
                break;

              case '&gt;':
              case '&lt;':
<span class="nc bnc" id="L1270" title="All 2 branches missed.">                if (delim &lt; 0) {</span>
<span class="nc" id="L1271">                    return getString(0);</span>
                }
<span class="nc" id="L1273">                ch = readCh();</span>
<span class="nc" id="L1274">                break;</span>

              case '\'':
              case '&quot;':
<span class="nc" id="L1278">                ch = readCh();</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">                if (c == delim) {</span>
<span class="nc" id="L1280">                    return getString(0);</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">                } else if (delim == -1) {</span>
<span class="nc" id="L1282">                    error(&quot;attvalerr&quot;);</span>
<span class="nc bnc" id="L1283" title="All 4 branches missed.">                    if (strict || ch == ' ') {</span>
<span class="nc" id="L1284">                        return getString(0);</span>
                    } else {
                        continue;
                    }
                }
                break;

            case '=':
<span class="nc bnc" id="L1292" title="All 2 branches missed.">                if (delim &lt; 0) {</span>
                    /* In SGML a construct like &lt;img src=/cgi-bin/foo?x=1&gt;
                       is considered invalid since an = sign can only be contained
                       in an attributes value if the string is quoted.
                       */
<span class="nc" id="L1297">                    error(&quot;attvalerr&quot;);</span>
                    /* If strict is true then we return with the string we have thus far.
                       Otherwise we accept the = sign as part of the attribute's value and
                       process the rest of the img tag. */
<span class="nc bnc" id="L1301" title="All 2 branches missed.">                    if (strict) {</span>
<span class="nc" id="L1302">                        return getString(0);</span>
                    }
                }
<span class="nc" id="L1305">                ch = readCh();</span>
<span class="nc" id="L1306">                break;</span>

              case '&amp;':
<span class="nc bnc" id="L1309" title="All 4 branches missed.">                if (strict &amp;&amp; delim &lt; 0) {</span>
<span class="nc" id="L1310">                    ch = readCh();</span>
<span class="nc" id="L1311">                    break;</span>
                }

<span class="nc" id="L1314">                char data[] = parseEntityReference();</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">                for (int i = 0 ; i &lt; data.length ; i++) {</span>
<span class="nc" id="L1316">                    c = data[i];</span>
<span class="nc bnc" id="L1317" title="All 6 branches missed.">                    addString((lower &amp;&amp; (c &gt;= 'A') &amp;&amp; (c &lt;= 'Z')) ? 'a' + c - 'A' : c);</span>
                }
<span class="nc" id="L1319">                continue;</span>

              case -1:
<span class="nc" id="L1322">                return getString(0);</span>

              default:
<span class="nc bnc" id="L1325" title="All 6 branches missed.">                if (lower &amp;&amp; (c &gt;= 'A') &amp;&amp; (c &lt;= 'Z')) {</span>
<span class="nc" id="L1326">                    c = 'a' + c - 'A';</span>
                }
<span class="nc" id="L1328">                ch = readCh();</span>
                break;
            }
<span class="nc" id="L1331">            addString(c);</span>
<span class="nc" id="L1332">        }</span>
    }


    /**
     * Parse attribute specification List. [31] 327:17
     */
    void parseAttributeSpecificationList(Element elem) throws IOException {

        while (true) {
<span class="nc" id="L1342">            skipSpace();</span>

<span class="nc bnc" id="L1344" title="All 3 branches missed.">            switch (ch) {</span>
              case '/':
              case '&gt;':
              case '&lt;':
              case -1:
<span class="nc" id="L1349">                return;</span>

              case '-':
<span class="nc bnc" id="L1352" title="All 2 branches missed.">                if ((ch = readCh()) == '-') {</span>
<span class="nc" id="L1353">                    ch = readCh();</span>
<span class="nc" id="L1354">                    parseComment();</span>
<span class="nc" id="L1355">                    strpos = 0;</span>
                } else {
<span class="nc" id="L1357">                    error(&quot;invalid.tagchar&quot;, &quot;-&quot;, elem.getName());</span>
<span class="nc" id="L1358">                    ch = readCh();</span>
                }
<span class="nc" id="L1360">                continue;</span>
            }

            AttributeList att;
            String attname;
            String attvalue;

<span class="nc bnc" id="L1367" title="All 2 branches missed.">            if (parseIdentifier(true)) {</span>
<span class="nc" id="L1368">                attname = getString(0);</span>
<span class="nc" id="L1369">                skipSpace();</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                if (ch == '=') {</span>
<span class="nc" id="L1371">                    ch = readCh();</span>
<span class="nc" id="L1372">                    skipSpace();</span>
<span class="nc" id="L1373">                    att = elem.getAttribute(attname);</span>
//  Bug ID 4102750
//  Load the NAME of an Attribute Case Sensitive
//  The case of the NAME  must be intact
//  MG 021898
<span class="nc bnc" id="L1378" title="All 8 branches missed.">                    attvalue = parseAttributeValue((att != null) &amp;&amp; (att.type != CDATA) &amp;&amp; (att.type != NOTATION) &amp;&amp; (att.type != NAME));</span>
//                  attvalue = parseAttributeValue((att != null) &amp;&amp; (att.type != CDATA) &amp;&amp; (att.type != NOTATION));
                } else {
<span class="nc" id="L1381">                    attvalue = attname;</span>
<span class="nc" id="L1382">                    att = elem.getAttributeByValue(attvalue);</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">                    if (att == null) {</span>
<span class="nc" id="L1384">                        att = elem.getAttribute(attname);</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">                        if (att != null) {</span>
<span class="nc" id="L1386">                            attvalue = att.getValue();</span>
                        }
                        else {
                            // Make it null so that NULL_ATTRIBUTE_VALUE is
                            // used
<span class="nc" id="L1391">                            attvalue = null;</span>
                        }
                    }
                }
<span class="nc bnc" id="L1395" title="All 4 branches missed.">            } else if (!strict &amp;&amp; ch == ',') { // allows for comma separated attribute-value pairs</span>
<span class="nc" id="L1396">                ch = readCh();</span>
<span class="nc" id="L1397">                continue;</span>
<span class="nc bnc" id="L1398" title="All 4 branches missed.">            } else if (!strict &amp;&amp; ch == '&quot;') { // allows for quoted attributes</span>
<span class="nc" id="L1399">                ch = readCh();</span>
<span class="nc" id="L1400">                skipSpace();</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                if (parseIdentifier(true)) {</span>
<span class="nc" id="L1402">                    attname = getString(0);</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">                    if (ch == '&quot;') {</span>
<span class="nc" id="L1404">                        ch = readCh();</span>
                    }
<span class="nc" id="L1406">                    skipSpace();</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">                    if (ch == '=') {</span>
<span class="nc" id="L1408">                        ch = readCh();</span>
<span class="nc" id="L1409">                        skipSpace();</span>
<span class="nc" id="L1410">                        att = elem.getAttribute(attname);</span>
<span class="nc bnc" id="L1411" title="All 6 branches missed.">                        attvalue = parseAttributeValue((att != null) &amp;&amp;</span>
                                                (att.type != CDATA) &amp;&amp;
                                                (att.type != NOTATION));
                    } else {
<span class="nc" id="L1415">                        attvalue = attname;</span>
<span class="nc" id="L1416">                        att = elem.getAttributeByValue(attvalue);</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">                        if (att == null) {</span>
<span class="nc" id="L1418">                            att = elem.getAttribute(attname);</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">                            if (att != null) {</span>
<span class="nc" id="L1420">                                attvalue = att.getValue();</span>
                            }
                        }
                    }
                } else {
<span class="nc" id="L1425">                    char str[] = {(char)ch};</span>
<span class="nc" id="L1426">                    error(&quot;invalid.tagchar&quot;, new String(str), elem.getName());</span>
<span class="nc" id="L1427">                    ch = readCh();</span>
<span class="nc" id="L1428">                    continue;</span>
                }
<span class="nc bnc" id="L1430" title="All 6 branches missed.">            } else if (!strict &amp;&amp; (attributes.isEmpty()) &amp;&amp; (ch == '=')) {</span>
<span class="nc" id="L1431">                ch = readCh();</span>
<span class="nc" id="L1432">                skipSpace();</span>
<span class="nc" id="L1433">                attname = elem.getName();</span>
<span class="nc" id="L1434">                att = elem.getAttribute(attname);</span>
<span class="nc bnc" id="L1435" title="All 6 branches missed.">                attvalue = parseAttributeValue((att != null) &amp;&amp;</span>
                                               (att.type != CDATA) &amp;&amp;
                                               (att.type != NOTATION));
<span class="nc bnc" id="L1438" title="All 4 branches missed.">            } else if (!strict &amp;&amp; (ch == '=')) {</span>
<span class="nc" id="L1439">                ch = readCh();</span>
<span class="nc" id="L1440">                skipSpace();</span>
<span class="nc" id="L1441">                attvalue = parseAttributeValue(true);</span>
<span class="nc" id="L1442">                error(&quot;attvalerr&quot;);</span>
<span class="nc" id="L1443">                return;</span>
            } else {
<span class="nc" id="L1445">                char str[] = {(char)ch};</span>
<span class="nc" id="L1446">                error(&quot;invalid.tagchar&quot;, new String(str), elem.getName());</span>
<span class="nc bnc" id="L1447" title="All 2 branches missed.">                if (!strict) {</span>
<span class="nc" id="L1448">                    ch = readCh();</span>
<span class="nc" id="L1449">                    continue;</span>
                } else {
<span class="nc" id="L1451">                    return;</span>
                }
            }

<span class="nc bnc" id="L1455" title="All 2 branches missed.">            if (att != null) {</span>
<span class="nc" id="L1456">                attname = att.getName();</span>
            } else {
<span class="nc" id="L1458">                error(&quot;invalid.tagatt&quot;, attname, elem.getName());</span>
            }

            // Check out the value
<span class="nc bnc" id="L1462" title="All 2 branches missed.">            if (attributes.isDefined(attname)) {</span>
<span class="nc" id="L1463">                error(&quot;multi.tagatt&quot;, attname, elem.getName());</span>
            }
<span class="nc bnc" id="L1465" title="All 2 branches missed.">            if (attvalue == null) {</span>
<span class="nc bnc" id="L1466" title="All 4 branches missed.">                attvalue = ((att != null) &amp;&amp; (att.value != null)) ? att.value :</span>
                    HTML.NULL_ATTRIBUTE_VALUE;
<span class="nc bnc" id="L1468" title="All 6 branches missed.">            } else if ((att != null) &amp;&amp; (att.values != null) &amp;&amp; !att.values.contains(attvalue)) {</span>
<span class="nc" id="L1469">                error(&quot;invalid.tagattval&quot;, attname, elem.getName());</span>
            }
<span class="nc" id="L1471">            HTML.Attribute attkey = HTML.getAttributeKey(attname);</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">            if (attkey == null) {</span>
<span class="nc" id="L1473">                attributes.addAttribute(attname, attvalue);</span>
            } else {
<span class="nc" id="L1475">                attributes.addAttribute(attkey, attvalue);</span>
            }
<span class="nc" id="L1477">        }</span>
    }

    /**
     * Parses th Document Declaration Type markup declaration.
     * Currently ignores it.
     */
    public String parseDTDMarkup() throws IOException {

<span class="nc" id="L1486">        StringBuilder strBuff = new StringBuilder();</span>
<span class="nc" id="L1487">        ch = readCh();</span>
        while(true) {
<span class="nc bnc" id="L1489" title="All 6 branches missed.">            switch (ch) {</span>
            case '&gt;':
<span class="nc" id="L1491">                ch = readCh();</span>
<span class="nc" id="L1492">                return strBuff.toString();</span>
            case -1:
<span class="nc" id="L1494">                error(&quot;invalid.markup&quot;);</span>
<span class="nc" id="L1495">                return strBuff.toString();</span>
            case '\n':
<span class="nc" id="L1497">                ln++;</span>
<span class="nc" id="L1498">                ch = readCh();</span>
<span class="nc" id="L1499">                lfCount++;</span>
<span class="nc" id="L1500">                break;</span>
            case '&quot;':
<span class="nc" id="L1502">                ch = readCh();</span>
<span class="nc" id="L1503">                break;</span>
            case '\r':
<span class="nc" id="L1505">                ln++;</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">                if ((ch = readCh()) == '\n') {</span>
<span class="nc" id="L1507">                    ch = readCh();</span>
<span class="nc" id="L1508">                    crlfCount++;</span>
                }
                else {
<span class="nc" id="L1511">                    crCount++;</span>
                }
<span class="nc" id="L1513">                break;</span>
            default:
<span class="nc" id="L1515">                strBuff.append((char)(ch &amp; 0xFF));</span>
<span class="nc" id="L1516">                ch = readCh();</span>
<span class="nc" id="L1517">                break;</span>
            }
        }
    }

    /**
     * Parse markup declarations.
     * Currently only handles the Document Type Declaration markup.
     * Returns true if it is a markup declaration false otherwise.
     */
    protected boolean parseMarkupDeclarations(StringBuffer strBuff) throws IOException {

        /* Currently handles only the DOCTYPE */
<span class="nc bnc" id="L1530" title="All 2 branches missed.">        if ((strBuff.length() == &quot;DOCTYPE&quot;.length()) &amp;&amp;</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">            (strBuff.toString().toUpperCase().equals(&quot;DOCTYPE&quot;))) {</span>
<span class="nc" id="L1532">            parseDTDMarkup();</span>
<span class="nc" id="L1533">            return true;</span>
        }
<span class="nc" id="L1535">        return false;</span>
    }

    /**
     * Parse an invalid tag.
     */
    void parseInvalidTag() throws IOException {
        // ignore all data upto the close bracket '&gt;'
        while (true) {
<span class="nc" id="L1544">            skipSpace();</span>
<span class="nc bnc" id="L1545" title="All 3 branches missed.">            switch (ch) {</span>
              case '&gt;':
              case -1:
<span class="nc" id="L1548">                  ch = readCh();</span>
<span class="nc" id="L1549">                return;</span>
              case '&lt;':
<span class="nc" id="L1551">                  return;</span>
              default:
<span class="nc" id="L1553">                  ch = readCh();</span>

            }
        }
    }

    /**
     * Parse a start or end tag.
     */
    void parseTag() throws IOException {
        Element elem;
<span class="nc" id="L1564">        boolean net = false;</span>
<span class="nc" id="L1565">        boolean warned = false;</span>
<span class="nc" id="L1566">        boolean unknown = false;</span>

<span class="nc bnc" id="L1568" title="All 4 branches missed.">        switch (ch = readCh()) {</span>
          case '!':
<span class="nc bnc" id="L1570" title="All 2 branches missed.">            switch (ch = readCh()) {</span>
              case '-':
                // Parse comment. [92] 391:7
                while (true) {
<span class="nc bnc" id="L1574" title="All 2 branches missed.">                    if (ch == '-') {</span>
<span class="nc bnc" id="L1575" title="All 4 branches missed.">                        if (!strict || ((ch = readCh()) == '-')) {</span>
<span class="nc" id="L1576">                            ch = readCh();</span>
<span class="nc bnc" id="L1577" title="All 4 branches missed.">                            if (!strict &amp;&amp; ch == '-') {</span>
<span class="nc" id="L1578">                                ch = readCh();</span>
                            }
                            // send over any text you might see
                            // before parsing and sending the
                            // comment
<span class="nc bnc" id="L1583" title="All 2 branches missed.">                            if (textpos != 0) {</span>
<span class="nc" id="L1584">                                char newtext[] = new char[textpos];</span>
<span class="nc" id="L1585">                                System.arraycopy(text, 0, newtext, 0, textpos);</span>
<span class="nc" id="L1586">                                handleText(newtext);</span>
<span class="nc" id="L1587">                                lastBlockStartPos = currentBlockStartPos;</span>
<span class="nc" id="L1588">                                textpos = 0;</span>
                            }
<span class="nc" id="L1590">                            parseComment();</span>
<span class="nc" id="L1591">                            last = makeTag(dtd.getElement(&quot;comment&quot;), true);</span>
<span class="nc" id="L1592">                            handleComment(getChars(0));</span>
<span class="nc" id="L1593">                            continue;</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">                        } else if (!warned) {</span>
<span class="nc" id="L1595">                            warned = true;</span>
<span class="nc" id="L1596">                            error(&quot;invalid.commentchar&quot;, &quot;-&quot;);</span>
                        }
                    }
<span class="nc" id="L1599">                    skipSpace();</span>
<span class="nc bnc" id="L1600" title="All 4 branches missed.">                    switch (ch) {</span>
                      case '-':
<span class="nc" id="L1602">                        continue;</span>
                      case '&gt;':
<span class="nc" id="L1604">                        ch = readCh();</span>
                      case -1:
<span class="nc" id="L1606">                        return;</span>
                      default:
<span class="nc" id="L1608">                        ch = readCh();</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">                        if (!warned) {</span>
<span class="nc" id="L1610">                            warned = true;</span>
<span class="nc" id="L1611">                            error(&quot;invalid.commentchar&quot;,</span>
<span class="nc" id="L1612">                                  String.valueOf((char)ch));</span>
                        }
                        break;
                    }
                }

              default:
                // deal with marked sections
<span class="nc" id="L1620">                StringBuffer strBuff = new StringBuffer();</span>
                while (true) {
<span class="nc" id="L1622">                    strBuff.append((char)ch);</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                    if (parseMarkupDeclarations(strBuff)) {</span>
<span class="nc" id="L1624">                        return;</span>
                    }
<span class="nc bnc" id="L1626" title="All 5 branches missed.">                    switch(ch) {</span>
                      case '&gt;':
<span class="nc" id="L1628">                        ch = readCh();</span>
                      case -1:
<span class="nc" id="L1630">                        error(&quot;invalid.markup&quot;);</span>
<span class="nc" id="L1631">                        return;</span>
                      case '\n':
<span class="nc" id="L1633">                        ln++;</span>
<span class="nc" id="L1634">                        ch = readCh();</span>
<span class="nc" id="L1635">                        lfCount++;</span>
<span class="nc" id="L1636">                        break;</span>
                      case '\r':
<span class="nc" id="L1638">                        ln++;</span>
<span class="nc bnc" id="L1639" title="All 2 branches missed.">                        if ((ch = readCh()) == '\n') {</span>
<span class="nc" id="L1640">                            ch = readCh();</span>
<span class="nc" id="L1641">                            crlfCount++;</span>
                        }
                        else {
<span class="nc" id="L1644">                            crCount++;</span>
                        }
<span class="nc" id="L1646">                        break;</span>

                      default:
<span class="nc" id="L1649">                        ch = readCh();</span>
<span class="nc" id="L1650">                        break;</span>
                    }
                }
            }

          case '/':
            // parse end tag [19] 317:4
<span class="nc bnc" id="L1657" title="All 3 branches missed.">            switch (ch = readCh()) {</span>
              case '&gt;':
<span class="nc" id="L1659">                ch = readCh();</span>
              case '&lt;':
                // empty end tag. either &lt;/&gt; or &lt;/&lt;
<span class="nc bnc" id="L1662" title="All 2 branches missed.">                if (recent == null) {</span>
<span class="nc" id="L1663">                    error(&quot;invalid.shortend&quot;);</span>
<span class="nc" id="L1664">                    return;</span>
                }
<span class="nc" id="L1666">                elem = recent;</span>
<span class="nc" id="L1667">                break;</span>

              default:
<span class="nc bnc" id="L1670" title="All 2 branches missed.">                if (!parseIdentifier(true)) {</span>
<span class="nc" id="L1671">                    error(&quot;expected.endtagname&quot;);</span>
<span class="nc" id="L1672">                    return;</span>
                }
<span class="nc" id="L1674">                skipSpace();</span>
<span class="nc bnc" id="L1675" title="All 3 branches missed.">                switch (ch) {</span>
                  case '&gt;':
<span class="nc" id="L1677">                    ch = readCh();</span>
                  case '&lt;':
<span class="nc" id="L1679">                    break;</span>

                  default:
<span class="nc" id="L1682">                    error(&quot;expected&quot;, &quot;'&gt;'&quot;);</span>
<span class="nc bnc" id="L1683" title="All 6 branches missed.">                    while ((ch != -1) &amp;&amp; (ch != '\n') &amp;&amp; (ch != '&gt;')) {</span>
<span class="nc" id="L1684">                        ch = readCh();</span>
                    }
<span class="nc bnc" id="L1686" title="All 2 branches missed.">                    if (ch == '&gt;') {</span>
<span class="nc" id="L1687">                        ch = readCh();</span>
                    }
                    break;
                }
<span class="nc" id="L1691">                String elemStr = getString(0);</span>
<span class="nc bnc" id="L1692" title="All 2 branches missed.">                if (!dtd.elementExists(elemStr)) {</span>
<span class="nc" id="L1693">                    error(&quot;end.unrecognized&quot;, elemStr);</span>
                    // Ignore RE before end tag
<span class="nc bnc" id="L1695" title="All 4 branches missed.">                    if ((textpos &gt; 0) &amp;&amp; (text[textpos-1] == '\n')) {</span>
<span class="nc" id="L1696">                        textpos--;</span>
                    }
<span class="nc" id="L1698">                    elem = dtd.getElement(&quot;unknown&quot;);</span>
<span class="nc" id="L1699">                    elem.name = elemStr;</span>
<span class="nc" id="L1700">                    unknown = true;</span>
                } else {
<span class="nc" id="L1702">                    elem = dtd.getElement(elemStr);</span>
                }
                break;
            }


            // If the stack is null, we're seeing end tags without any begin
            // tags.  Ignore them.

<span class="nc bnc" id="L1711" title="All 2 branches missed.">            if (stack == null) {</span>
<span class="nc" id="L1712">                error(&quot;end.extra.tag&quot;, elem.getName());</span>
<span class="nc" id="L1713">                return;</span>
            }

            // Ignore RE before end tag
<span class="nc bnc" id="L1717" title="All 4 branches missed.">            if ((textpos &gt; 0) &amp;&amp; (text[textpos-1] == '\n')) {</span>
                // In a pre tag, if there are blank lines
                // we do not want to remove the newline
                // before the end tag.  Hence this code.
                //
<span class="nc bnc" id="L1722" title="All 2 branches missed.">                if (stack.pre) {</span>
<span class="nc bnc" id="L1723" title="All 4 branches missed.">                    if ((textpos &gt; 1) &amp;&amp; (text[textpos-2] != '\n')) {</span>
<span class="nc" id="L1724">                        textpos--;</span>
                    }
                } else {
<span class="nc" id="L1727">                    textpos--;</span>
                }
            }

            // If the end tag is a form, since we did not put it
            // on the tag stack, there is no corresponding start
            // start tag to find. Hence do not touch the tag stack.
            //

            /*
            if (!strict &amp;&amp; elem.getName().equals(&quot;form&quot;)) {
                if (lastFormSent != null) {
                    handleEndTag(lastFormSent);
                    return;
                } else {
                    // do nothing.
                    return;
                }
            }
            */

<span class="nc bnc" id="L1748" title="All 2 branches missed.">            if (unknown) {</span>
                // we will not see a corresponding start tag
                // on the the stack.  If we are seeing an
                // end tag, lets send this on as an empty
                // tag with the end tag attribute set to
                // true.
<span class="nc" id="L1754">                TagElement t = makeTag(elem);</span>
<span class="nc" id="L1755">                handleText(t);</span>
<span class="nc" id="L1756">                attributes.addAttribute(HTML.Attribute.ENDTAG, &quot;true&quot;);</span>
<span class="nc" id="L1757">                handleEmptyTag(makeTag(elem));</span>
<span class="nc" id="L1758">                unknown = false;</span>
<span class="nc" id="L1759">                return;</span>
            }

            // find the corresponding start tag

            // A commonly occurring error appears to be the insertion
            // of extra end tags in a table.  The intent here is ignore
            // such extra end tags.
            //
<span class="nc bnc" id="L1768" title="All 2 branches missed.">            if (!strict) {</span>
<span class="nc" id="L1769">                String stackElem = stack.elem.getName();</span>

<span class="nc bnc" id="L1771" title="All 2 branches missed.">                if (stackElem.equals(&quot;table&quot;)) {</span>
                    // If it is not a valid end tag ignore it and return
                    //
<span class="nc bnc" id="L1774" title="All 2 branches missed.">                    if (!elem.getName().equals(stackElem)) {</span>
<span class="nc" id="L1775">                        error(&quot;tag.ignore&quot;, elem.getName());</span>
<span class="nc" id="L1776">                        return;</span>
                    }
                }



<span class="nc bnc" id="L1782" title="All 2 branches missed.">                if (stackElem.equals(&quot;tr&quot;) ||</span>
<span class="nc bnc" id="L1783" title="All 2 branches missed.">                    stackElem.equals(&quot;td&quot;)) {</span>
<span class="nc bnc" id="L1784" title="All 2 branches missed.">                    if ((!elem.getName().equals(&quot;table&quot;)) &amp;&amp;</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">                        (!elem.getName().equals(stackElem))) {</span>
<span class="nc" id="L1786">                        error(&quot;tag.ignore&quot;, elem.getName());</span>
<span class="nc" id="L1787">                        return;</span>
                    }
                }
            }
<span class="nc" id="L1791">            TagStack sp = stack;</span>

<span class="nc bnc" id="L1793" title="All 4 branches missed.">            while ((sp != null) &amp;&amp; (elem != sp.elem)) {</span>
<span class="nc" id="L1794">                sp = sp.next;</span>
            }
<span class="nc bnc" id="L1796" title="All 2 branches missed.">            if (sp == null) {</span>
<span class="nc" id="L1797">                error(&quot;unmatched.endtag&quot;, elem.getName());</span>
<span class="nc" id="L1798">                return;</span>
            }

            // People put font ending tags in the darndest places.
            // Don't close other contexts based on them being between
            // a font tag and the corresponding end tag.  Instead,
            // ignore the end tag like it doesn't exist and allow the end
            // of the document to close us out.
<span class="nc" id="L1806">            String elemName = elem.getName();</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">            if (stack != sp &amp;&amp;</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">                (elemName.equals(&quot;font&quot;) ||</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">                 elemName.equals(&quot;center&quot;))) {</span>

                // Since closing out a center tag can have real wierd
                // effects on the formatting,  make sure that tags
                // for which omitting an end tag is legimitate
                // get closed out.
                //
<span class="nc bnc" id="L1816" title="All 2 branches missed.">                if (elemName.equals(&quot;center&quot;)) {</span>
<span class="nc bnc" id="L1817" title="All 4 branches missed.">                    while(stack.elem.omitEnd() &amp;&amp; stack != sp) {</span>
<span class="nc" id="L1818">                        endTag(true);</span>
                    }
<span class="nc bnc" id="L1820" title="All 2 branches missed.">                    if (stack.elem == elem) {</span>
<span class="nc" id="L1821">                        endTag(false);</span>
                    }
                }
<span class="nc" id="L1824">                return;</span>
            }
            // People do the same thing with center tags.  In this
            // case we would like to close off the center tag but
            // not necessarily all enclosing tags.



            // end tags
<span class="nc bnc" id="L1833" title="All 2 branches missed.">            while (stack != sp) {</span>
<span class="nc" id="L1834">                endTag(true);</span>
            }

<span class="nc" id="L1837">            endTag(false);</span>
<span class="nc" id="L1838">            return;</span>

          case -1:
<span class="nc" id="L1841">            error(&quot;eof&quot;);</span>
<span class="nc" id="L1842">            return;</span>
        }

        // start tag [14] 314:1
<span class="nc bnc" id="L1846" title="All 2 branches missed.">        if (!parseIdentifier(true)) {</span>
<span class="nc" id="L1847">            elem = recent;</span>
<span class="nc bnc" id="L1848" title="All 4 branches missed.">            if ((ch != '&gt;') || (elem == null)) {</span>
<span class="nc" id="L1849">                error(&quot;expected.tagname&quot;);</span>
<span class="nc" id="L1850">                return;</span>
            }
        } else {
<span class="nc" id="L1853">            String elemStr = getString(0);</span>

<span class="nc bnc" id="L1855" title="All 2 branches missed.">            if (elemStr.equals(&quot;image&quot;)) {</span>
<span class="nc" id="L1856">                elemStr = &quot;img&quot;;</span>
            }

            /* determine if this element is part of the dtd. */

<span class="nc bnc" id="L1861" title="All 2 branches missed.">            if (!dtd.elementExists(elemStr)) {</span>
                //              parseInvalidTag();
<span class="nc" id="L1863">                error(&quot;tag.unrecognized &quot;, elemStr);</span>
<span class="nc" id="L1864">                elem = dtd.getElement(&quot;unknown&quot;);</span>
<span class="nc" id="L1865">                elem.name = elemStr;</span>
<span class="nc" id="L1866">                unknown = true;</span>
            } else {
<span class="nc" id="L1868">                elem = dtd.getElement(elemStr);</span>
            }
        }

        // Parse attributes
<span class="nc" id="L1873">        parseAttributeSpecificationList(elem);</span>

<span class="nc bnc" id="L1875" title="All 4 branches missed.">        switch (ch) {</span>
          case '/':
<span class="nc" id="L1877">            net = true;</span>
          case '&gt;':
<span class="nc" id="L1879">            ch = readCh();</span>
<span class="nc bnc" id="L1880" title="All 4 branches missed.">            if (ch == '&gt;' &amp;&amp; net) {</span>
<span class="nc" id="L1881">                ch = readCh();</span>
            }
          case '&lt;':
<span class="nc" id="L1884">            break;</span>

          default:
<span class="nc" id="L1887">            error(&quot;expected&quot;, &quot;'&gt;'&quot;);</span>
            break;
        }

<span class="nc bnc" id="L1891" title="All 2 branches missed.">        if (!strict) {</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">          if (elem.getName().equals(&quot;script&quot;)) {</span>
<span class="nc" id="L1893">            error(&quot;javascript.unsupported&quot;);</span>
          }
        }

        // ignore RE after start tag
        //
<span class="nc bnc" id="L1899" title="All 2 branches missed.">        if (!elem.isEmpty())  {</span>
<span class="nc bnc" id="L1900" title="All 2 branches missed.">            if (ch == '\n') {</span>
<span class="nc" id="L1901">                ln++;</span>
<span class="nc" id="L1902">                lfCount++;</span>
<span class="nc" id="L1903">                ch = readCh();</span>
<span class="nc bnc" id="L1904" title="All 2 branches missed.">            } else if (ch == '\r') {</span>
<span class="nc" id="L1905">                ln++;</span>
<span class="nc bnc" id="L1906" title="All 2 branches missed.">                if ((ch = readCh()) == '\n') {</span>
<span class="nc" id="L1907">                    ch = readCh();</span>
<span class="nc" id="L1908">                    crlfCount++;</span>
                }
                else {
<span class="nc" id="L1911">                    crCount++;</span>
                }
            }
        }

        // ensure a legal context for the tag
<span class="nc" id="L1917">        TagElement tag = makeTag(elem, false);</span>


        /** In dealing with forms, we have decided to treat
            them as legal in any context.  Also, even though
            they do have a start and an end tag, we will
            not put this tag on the stack.  This is to deal
            several pages in the web oasis that choose to
            start and end forms in any possible location. **/

        /*
        if (!strict &amp;&amp; elem.getName().equals(&quot;form&quot;)) {
            if (lastFormSent == null) {
                lastFormSent = tag;
            } else {
                handleEndTag(lastFormSent);
                lastFormSent = tag;
            }
        } else {
        */
            // Smlly, if a tag is unknown, we will apply
            // no legalTagContext logic to it.
            //
<span class="nc bnc" id="L1940" title="All 2 branches missed.">            if (!unknown) {</span>
<span class="nc" id="L1941">                legalTagContext(tag);</span>

                // If skip tag is true,  this implies that
                // the tag was illegal and that the error
                // recovery strategy adopted is to ignore
                // the tag.
<span class="nc bnc" id="L1947" title="All 4 branches missed.">                if (!strict &amp;&amp; skipTag) {</span>
<span class="nc" id="L1948">                    skipTag = false;</span>
<span class="nc" id="L1949">                    return;</span>
                }
            }
            /*
        }
            */

<span class="nc" id="L1956">        startTag(tag);</span>

<span class="nc bnc" id="L1958" title="All 2 branches missed.">        if (!elem.isEmpty()) {</span>
<span class="nc bnc" id="L1959" title="All 3 branches missed.">            switch (elem.getType()) {</span>
              case CDATA:
<span class="nc" id="L1961">                parseLiteral(false);</span>
<span class="nc" id="L1962">                break;</span>
              case RCDATA:
<span class="nc" id="L1964">                parseLiteral(true);</span>
<span class="nc" id="L1965">                break;</span>
              default:
<span class="nc bnc" id="L1967" title="All 2 branches missed.">                if (stack != null) {</span>
<span class="nc" id="L1968">                    stack.net = net;</span>
                }
                break;
            }
        }
<span class="nc" id="L1973">    }</span>

    private static final String START_COMMENT = &quot;&lt;!--&quot;;
    private static final String END_COMMENT = &quot;--&gt;&quot;;
<span class="nc" id="L1977">    private static final char[] SCRIPT_END_TAG = &quot;&lt;/script&gt;&quot;.toCharArray();</span>
<span class="nc" id="L1978">    private static final char[] SCRIPT_END_TAG_UPPER_CASE =</span>
<span class="nc" id="L1979">                                        &quot;&lt;/SCRIPT&gt;&quot;.toCharArray();</span>

    void parseScript() throws IOException {
<span class="nc" id="L1982">        char[] charsToAdd = new char[SCRIPT_END_TAG.length];</span>
<span class="nc" id="L1983">        boolean insideComment = false;</span>

        /* Here, ch should be the first character after &lt;script&gt; */
        while (true) {
<span class="nc" id="L1987">            int i = 0;</span>
<span class="nc bnc" id="L1988" title="All 8 branches missed.">            while (!insideComment &amp;&amp; i &lt; SCRIPT_END_TAG.length</span>
                       &amp;&amp; (SCRIPT_END_TAG[i] == ch
                           || SCRIPT_END_TAG_UPPER_CASE[i] == ch)) {
<span class="nc" id="L1991">                charsToAdd[i] = (char) ch;</span>
<span class="nc" id="L1992">                ch = readCh();</span>
<span class="nc" id="L1993">                i++;</span>
            }
<span class="nc bnc" id="L1995" title="All 2 branches missed.">            if (i == SCRIPT_END_TAG.length) {</span>

                /*  '&lt;/script&gt;' tag detected */
                /* Here, ch == the first character after &lt;/script&gt; */
<span class="nc" id="L1999">                return;</span>
            } else {

                /* To account for extra read()'s that happened */
<span class="nc bnc" id="L2003" title="All 2 branches missed.">                for (int j = 0; j &lt; i; j++) {</span>
<span class="nc" id="L2004">                    addString(charsToAdd[j]);</span>
                }

<span class="nc bnc" id="L2007" title="All 4 branches missed.">                switch (ch) {</span>
                case -1:
<span class="nc" id="L2009">                    error(&quot;eof.script&quot;);</span>
<span class="nc" id="L2010">                    return;</span>
                case '\n':
<span class="nc" id="L2012">                    ln++;</span>
<span class="nc" id="L2013">                    ch = readCh();</span>
<span class="nc" id="L2014">                    lfCount++;</span>
<span class="nc" id="L2015">                    addString('\n');</span>
<span class="nc" id="L2016">                    break;</span>
                case '\r':
<span class="nc" id="L2018">                    ln++;</span>
<span class="nc bnc" id="L2019" title="All 2 branches missed.">                    if ((ch = readCh()) == '\n') {</span>
<span class="nc" id="L2020">                        ch = readCh();</span>
<span class="nc" id="L2021">                        crlfCount++;</span>
                    } else {
<span class="nc" id="L2023">                        crCount++;</span>
                    }
<span class="nc" id="L2025">                    addString('\n');</span>
<span class="nc" id="L2026">                    break;</span>
                default:
<span class="nc" id="L2028">                    addString(ch);</span>
<span class="nc" id="L2029">                    String str = new String(getChars(0, strpos));</span>
<span class="nc bnc" id="L2030" title="All 4 branches missed.">                    if (!insideComment &amp;&amp; str.endsWith(START_COMMENT)) {</span>
<span class="nc" id="L2031">                        insideComment = true;</span>
                    }
<span class="nc bnc" id="L2033" title="All 4 branches missed.">                    if (insideComment &amp;&amp; str.endsWith(END_COMMENT)) {</span>
<span class="nc" id="L2034">                        insideComment = false;</span>
                    }
<span class="nc" id="L2036">                    ch = readCh();</span>
                    break;
                } // switch
            }
<span class="nc" id="L2040">        } // while</span>
    }

    /**
     * Parse Content. [24] 320:1
     */
    void parseContent() throws IOException {
<span class="nc" id="L2047">        Thread curThread = Thread.currentThread();</span>

        for (;;) {
<span class="nc bnc" id="L2050" title="All 2 branches missed.">            if (curThread.isInterrupted()) {</span>
<span class="nc" id="L2051">                curThread.interrupt(); // resignal the interrupt</span>
<span class="nc" id="L2052">                break;</span>
            }

<span class="nc" id="L2055">            int c = ch;</span>
<span class="nc" id="L2056">            currentBlockStartPos = currentPosition;</span>

<span class="nc bnc" id="L2058" title="All 2 branches missed.">            if (recent == dtd.script) { // means: if after starting &lt;script&gt; tag</span>

                /* Here, ch has to be the first character after &lt;script&gt; */
<span class="nc" id="L2061">                parseScript();</span>
<span class="nc" id="L2062">                last = makeTag(dtd.getElement(&quot;comment&quot;), true);</span>

                /* Remove leading and trailing HTML comment declarations */
<span class="nc" id="L2065">                String str = new String(getChars(0)).trim();</span>
<span class="nc" id="L2066">                int minLength = START_COMMENT.length() + END_COMMENT.length();</span>
<span class="nc bnc" id="L2067" title="All 4 branches missed.">                if (str.startsWith(START_COMMENT) &amp;&amp; str.endsWith(END_COMMENT)</span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">                       &amp;&amp; str.length() &gt;= (minLength)) {</span>
<span class="nc" id="L2069">                    str = str.substring(START_COMMENT.length(),</span>
<span class="nc" id="L2070">                                      str.length() - END_COMMENT.length());</span>
                }

                /* Handle resulting chars as comment */
<span class="nc" id="L2074">                handleComment(str.toCharArray());</span>
<span class="nc" id="L2075">                endTag(false);</span>
<span class="nc" id="L2076">                lastBlockStartPos = currentPosition;</span>

<span class="nc" id="L2078">                continue;</span>
            } else {
<span class="nc bnc" id="L2080" title="All 8 branches missed.">                switch (c) {</span>
                  case '&lt;':
<span class="nc" id="L2082">                    parseTag();</span>
<span class="nc" id="L2083">                    lastBlockStartPos = currentPosition;</span>
<span class="nc" id="L2084">                    continue;</span>

                  case '/':
<span class="nc" id="L2087">                    ch = readCh();</span>
<span class="nc bnc" id="L2088" title="All 4 branches missed.">                    if ((stack != null) &amp;&amp; stack.net) {</span>
                        // null end tag.
<span class="nc" id="L2090">                        endTag(false);</span>
<span class="nc" id="L2091">                        continue;</span>
                    }
                    break;

                  case -1:
<span class="nc" id="L2096">                    return;</span>

                  case '&amp;':
<span class="nc bnc" id="L2099" title="All 2 branches missed.">                    if (textpos == 0) {</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">                        if (!legalElementContext(dtd.pcdata)) {</span>
<span class="nc" id="L2101">                            error(&quot;unexpected.pcdata&quot;);</span>
                        }
<span class="nc bnc" id="L2103" title="All 2 branches missed.">                        if (last.breaksFlow()) {</span>
<span class="nc" id="L2104">                            space = false;</span>
                        }
                    }
<span class="nc" id="L2107">                    char data[] = parseEntityReference();</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">                    if (textpos + data.length + 1 &gt; text.length) {</span>
<span class="nc" id="L2109">                        char newtext[] = new char[Math.max(textpos + data.length + 128, text.length * 2)];</span>
<span class="nc" id="L2110">                        System.arraycopy(text, 0, newtext, 0, text.length);</span>
<span class="nc" id="L2111">                        text = newtext;</span>
                    }
<span class="nc bnc" id="L2113" title="All 2 branches missed.">                    if (space) {</span>
<span class="nc" id="L2114">                        space = false;</span>
<span class="nc" id="L2115">                        text[textpos++] = ' ';</span>
                    }
<span class="nc" id="L2117">                    System.arraycopy(data, 0, text, textpos, data.length);</span>
<span class="nc" id="L2118">                    textpos += data.length;</span>
<span class="nc" id="L2119">                    ignoreSpace = false;</span>
<span class="nc" id="L2120">                    continue;</span>

                  case '\n':
<span class="nc" id="L2123">                    ln++;</span>
<span class="nc" id="L2124">                    lfCount++;</span>
<span class="nc" id="L2125">                    ch = readCh();</span>
<span class="nc bnc" id="L2126" title="All 4 branches missed.">                    if ((stack != null) &amp;&amp; stack.pre) {</span>
<span class="nc" id="L2127">                        break;</span>
                    }
<span class="nc bnc" id="L2129" title="All 2 branches missed.">                    if (textpos == 0) {</span>
<span class="nc" id="L2130">                        lastBlockStartPos = currentPosition;</span>
                    }
<span class="nc bnc" id="L2132" title="All 2 branches missed.">                    if (!ignoreSpace) {</span>
<span class="nc" id="L2133">                        space = true;</span>
                    }
                    continue;

                  case '\r':
<span class="nc" id="L2138">                    ln++;</span>
<span class="nc" id="L2139">                    c = '\n';</span>
<span class="nc bnc" id="L2140" title="All 2 branches missed.">                    if ((ch = readCh()) == '\n') {</span>
<span class="nc" id="L2141">                        ch = readCh();</span>
<span class="nc" id="L2142">                        crlfCount++;</span>
                    }
                    else {
<span class="nc" id="L2145">                        crCount++;</span>
                    }
<span class="nc bnc" id="L2147" title="All 4 branches missed.">                    if ((stack != null) &amp;&amp; stack.pre) {</span>
<span class="nc" id="L2148">                        break;</span>
                    }
<span class="nc bnc" id="L2150" title="All 2 branches missed.">                    if (textpos == 0) {</span>
<span class="nc" id="L2151">                        lastBlockStartPos = currentPosition;</span>
                    }
<span class="nc bnc" id="L2153" title="All 2 branches missed.">                    if (!ignoreSpace) {</span>
<span class="nc" id="L2154">                        space = true;</span>
                    }
                    continue;


                  case '\t':
                  case ' ':
<span class="nc" id="L2161">                    ch = readCh();</span>
<span class="nc bnc" id="L2162" title="All 4 branches missed.">                    if ((stack != null) &amp;&amp; stack.pre) {</span>
<span class="nc" id="L2163">                        break;</span>
                    }
<span class="nc bnc" id="L2165" title="All 2 branches missed.">                    if (textpos == 0) {</span>
<span class="nc" id="L2166">                        lastBlockStartPos = currentPosition;</span>
                    }
<span class="nc bnc" id="L2168" title="All 2 branches missed.">                    if (!ignoreSpace) {</span>
<span class="nc" id="L2169">                        space = true;</span>
                    }
                    continue;

                  default:
<span class="nc bnc" id="L2174" title="All 2 branches missed.">                    if (textpos == 0) {</span>
<span class="nc bnc" id="L2175" title="All 2 branches missed.">                        if (!legalElementContext(dtd.pcdata)) {</span>
<span class="nc" id="L2176">                            error(&quot;unexpected.pcdata&quot;);</span>
                        }
<span class="nc bnc" id="L2178" title="All 2 branches missed.">                        if (last.breaksFlow()) {</span>
<span class="nc" id="L2179">                            space = false;</span>
                        }
                    }
<span class="nc" id="L2182">                    ch = readCh();</span>
                    break;
                }
            }

            // enlarge buffer if needed
<span class="nc bnc" id="L2188" title="All 2 branches missed.">            if (textpos + 2 &gt; text.length) {</span>
<span class="nc" id="L2189">                char newtext[] = new char[text.length + 128];</span>
<span class="nc" id="L2190">                System.arraycopy(text, 0, newtext, 0, text.length);</span>
<span class="nc" id="L2191">                text = newtext;</span>
            }

            // output pending space
<span class="nc bnc" id="L2195" title="All 2 branches missed.">            if (space) {</span>
<span class="nc bnc" id="L2196" title="All 2 branches missed.">                if (textpos == 0) {</span>
<span class="nc" id="L2197">                    lastBlockStartPos--;</span>
                }
<span class="nc" id="L2199">                text[textpos++] = ' ';</span>
<span class="nc" id="L2200">                space = false;</span>
            }
<span class="nc" id="L2202">            text[textpos++] = (char)c;</span>
<span class="nc" id="L2203">            ignoreSpace = false;</span>
<span class="nc" id="L2204">        }</span>
<span class="nc" id="L2205">    }</span>

    /**
     * Returns the end of line string. This will return the end of line
     * string that has been encountered the most, one of \r, \n or \r\n.
     */
    String getEndOfLineString() {
<span class="nc bnc" id="L2212" title="All 2 branches missed.">        if (crlfCount &gt;= crCount) {</span>
<span class="nc bnc" id="L2213" title="All 2 branches missed.">            if (lfCount &gt;= crlfCount) {</span>
<span class="nc" id="L2214">                return &quot;\n&quot;;</span>
            }
            else {
<span class="nc" id="L2217">                return &quot;\r\n&quot;;</span>
            }
        }
        else {
<span class="nc bnc" id="L2221" title="All 2 branches missed.">            if (crCount &gt; lfCount) {</span>
<span class="nc" id="L2222">                return &quot;\r&quot;;</span>
            }
            else {
<span class="nc" id="L2225">                return &quot;\n&quot;;</span>
            }
        }
    }

    /**
     * Parse an HTML stream, given a DTD.
     */
    public synchronized void parse(Reader in) throws IOException {
<span class="nc" id="L2234">        this.in = in;</span>

<span class="nc" id="L2236">        this.ln = 1;</span>

<span class="nc" id="L2238">        seenHtml = false;</span>
<span class="nc" id="L2239">        seenHead = false;</span>
<span class="nc" id="L2240">        seenBody = false;</span>

<span class="nc" id="L2242">        crCount = lfCount = crlfCount = 0;</span>

        try {
<span class="nc" id="L2245">            ch = readCh();</span>
<span class="nc" id="L2246">            text = new char[1024];</span>
<span class="nc" id="L2247">            str = new char[128];</span>

<span class="nc" id="L2249">            parseContent();</span>
            // NOTE: interruption may have occurred.  Control flows out
            // of here normally.
<span class="nc bnc" id="L2252" title="All 2 branches missed.">            while (stack != null) {</span>
<span class="nc" id="L2253">                endTag(true);</span>
            }
<span class="nc" id="L2255">            in.close();</span>
<span class="nc" id="L2256">        } catch (IOException e) {</span>
<span class="nc" id="L2257">            errorContext();</span>
<span class="nc" id="L2258">            error(&quot;ioexception&quot;);</span>
<span class="nc" id="L2259">            throw e;</span>
<span class="nc" id="L2260">        } catch (Exception e) {</span>
<span class="nc" id="L2261">            errorContext();</span>
<span class="nc" id="L2262">            error(&quot;exception&quot;, e.getClass().getName(), e.getMessage());</span>
<span class="nc" id="L2263">            e.printStackTrace();</span>
<span class="nc" id="L2264">        } catch (ThreadDeath e) {</span>
<span class="nc" id="L2265">            errorContext();</span>
<span class="nc" id="L2266">            error(&quot;terminated&quot;);</span>
<span class="nc" id="L2267">            e.printStackTrace();</span>
<span class="nc" id="L2268">            throw e;</span>
        } finally {
<span class="nc bnc" id="L2270" title="All 6 branches missed.">            for (; stack != null ; stack = stack.next) {</span>
<span class="nc" id="L2271">                handleEndTag(stack.tag);</span>
            }

<span class="nc" id="L2274">            text = null;</span>
<span class="nc" id="L2275">            str = null;</span>
<span class="nc" id="L2276">        }</span>

<span class="nc" id="L2278">    }</span>


    /*
     * Input cache.  This is much faster than calling down to a synchronized
     * method of BufferedReader for each byte.  Measurements done 5/30/97
     * show that there's no point in having a bigger buffer:  Increasing
     * the buffer to 8192 had no measurable impact for a program discarding
     * one character at a time (reading from an http URL to a local machine).
     * NOTE: If the current encoding is bogus, and we read too much
     * (past the content-type) we may suffer a MalformedInputException. For
     * this reason the initial size is 1 and when the body is encountered the
     * size is adjusted to 256.
     */
<span class="nc" id="L2292">    private char buf[] = new char[1];</span>
    private int pos;
    private int len;
    /*
        tracks position relative to the beginning of the
        document.
    */
    private int currentPosition;


    private final int readCh() throws IOException {

<span class="nc bnc" id="L2304" title="All 2 branches missed.">        if (pos &gt;= len) {</span>

            // This loop allows us to ignore interrupts if the flag
            // says so
            for (;;) {
                try {
<span class="nc" id="L2310">                    len = in.read(buf);</span>
<span class="nc" id="L2311">                    break;</span>
<span class="nc" id="L2312">                } catch (InterruptedIOException ex) {</span>
<span class="nc" id="L2313">                    throw ex;</span>
                }
            }

<span class="nc bnc" id="L2317" title="All 2 branches missed.">            if (len &lt;= 0) {</span>
<span class="nc" id="L2318">                return -1;      // eof</span>
            }
<span class="nc" id="L2320">            pos = 0;</span>
        }
<span class="nc" id="L2322">        ++currentPosition;</span>

<span class="nc" id="L2324">        return buf[pos++];</span>
    }


    protected int getCurrentPos() {
<span class="nc" id="L2329">        return currentPosition;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>