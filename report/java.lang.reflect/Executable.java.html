<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Executable.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.lang.reflect</a> &gt; <span class="el_source">Executable.java</span></div><h1>Executable.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.reflect;

import java.lang.annotation.*;
import java.util.Map;
import java.util.Objects;
import sun.reflect.annotation.AnnotationParser;
import sun.reflect.annotation.AnnotationSupport;
import sun.reflect.annotation.TypeAnnotationParser;
import sun.reflect.annotation.TypeAnnotation;
import sun.reflect.generics.repository.ConstructorRepository;

/**
 * A shared superclass for the common functionality of {@link Method}
 * and {@link Constructor}.
 *
 * @since 1.8
 */
public abstract class Executable extends AccessibleObject
    implements Member, GenericDeclaration {
    /*
     * Only grant package-visibility to the constructor.
     */
<span class="fc" id="L48">    Executable() {}</span>

    /**
     * Accessor method to allow code sharing
     */
    abstract byte[] getAnnotationBytes();

    /**
     * Does the Executable have generic information.
     */
    abstract boolean hasGenericInformation();

    abstract ConstructorRepository getGenericInfo();

    boolean equalParamTypes(Class&lt;?&gt;[] params1, Class&lt;?&gt;[] params2) {
        /* Avoid unnecessary cloning */
<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (params1.length == params2.length) {</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">            for (int i = 0; i &lt; params1.length; i++) {</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">                if (params1[i] != params2[i])</span>
<span class="fc" id="L67">                    return false;</span>
            }
<span class="fc" id="L69">            return true;</span>
        }
<span class="fc" id="L71">        return false;</span>
    }

    Annotation[][] parseParameterAnnotations(byte[] parameterAnnotations) {
<span class="fc" id="L75">        return AnnotationParser.parseParameterAnnotations(</span>
               parameterAnnotations,
<span class="fc" id="L77">               sun.misc.SharedSecrets.getJavaLangAccess().</span>
<span class="fc" id="L78">               getConstantPool(getDeclaringClass()),</span>
<span class="fc" id="L79">               getDeclaringClass());</span>
    }

    void separateWithCommas(Class&lt;?&gt;[] types, StringBuilder sb) {
<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (int j = 0; j &lt; types.length; j++) {</span>
<span class="fc" id="L84">            sb.append(types[j].getTypeName());</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">            if (j &lt; (types.length - 1))</span>
<span class="fc" id="L86">                sb.append(&quot;,&quot;);</span>
        }

<span class="fc" id="L89">    }</span>

    void printModifiersIfNonzero(StringBuilder sb, int mask, boolean isDefault) {
<span class="fc" id="L92">        int mod = getModifiers() &amp; mask;</span>

<span class="fc bfc" id="L94" title="All 4 branches covered.">        if (mod != 0 &amp;&amp; !isDefault) {</span>
<span class="fc" id="L95">            sb.append(Modifier.toString(mod)).append(' ');</span>
        } else {
<span class="fc" id="L97">            int access_mod = mod &amp; Modifier.ACCESS_MODIFIERS;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">            if (access_mod != 0)</span>
<span class="fc" id="L99">                sb.append(Modifier.toString(access_mod)).append(' ');</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">            if (isDefault)</span>
<span class="fc" id="L101">                sb.append(&quot;default &quot;);</span>
<span class="fc" id="L102">            mod = (mod &amp; ~Modifier.ACCESS_MODIFIERS);</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">            if (mod != 0)</span>
<span class="nc" id="L104">                sb.append(Modifier.toString(mod)).append(' ');</span>
        }
<span class="fc" id="L106">    }</span>

    String sharedToString(int modifierMask,
                          boolean isDefault,
                          Class&lt;?&gt;[] parameterTypes,
                          Class&lt;?&gt;[] exceptionTypes) {
        try {
<span class="fc" id="L113">            StringBuilder sb = new StringBuilder();</span>

<span class="fc" id="L115">            printModifiersIfNonzero(sb, modifierMask, isDefault);</span>
<span class="fc" id="L116">            specificToStringHeader(sb);</span>

<span class="fc" id="L118">            sb.append('(');</span>
<span class="fc" id="L119">            separateWithCommas(parameterTypes, sb);</span>
<span class="fc" id="L120">            sb.append(')');</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            if (exceptionTypes.length &gt; 0) {</span>
<span class="fc" id="L122">                sb.append(&quot; throws &quot;);</span>
<span class="fc" id="L123">                separateWithCommas(exceptionTypes, sb);</span>
            }
<span class="fc" id="L125">            return sb.toString();</span>
<span class="nc" id="L126">        } catch (Exception e) {</span>
<span class="nc" id="L127">            return &quot;&lt;&quot; + e + &quot;&gt;&quot;;</span>
        }
    }

    /**
     * Generate toString header information specific to a method or
     * constructor.
     */
    abstract void specificToStringHeader(StringBuilder sb);

    String sharedToGenericString(int modifierMask, boolean isDefault) {
        try {
<span class="fc" id="L139">            StringBuilder sb = new StringBuilder();</span>

<span class="fc" id="L141">            printModifiersIfNonzero(sb, modifierMask, isDefault);</span>

<span class="fc" id="L143">            TypeVariable&lt;?&gt;[] typeparms = getTypeParameters();</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (typeparms.length &gt; 0) {</span>
<span class="fc" id="L145">                boolean first = true;</span>
<span class="fc" id="L146">                sb.append('&lt;');</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">                for(TypeVariable&lt;?&gt; typeparm: typeparms) {</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">                    if (!first)</span>
<span class="fc" id="L149">                        sb.append(',');</span>
                    // Class objects can't occur here; no need to test
                    // and call Class.getName().
<span class="fc" id="L152">                    sb.append(typeparm.toString());</span>
<span class="fc" id="L153">                    first = false;</span>
                }
<span class="fc" id="L155">                sb.append(&quot;&gt; &quot;);</span>
            }

<span class="fc" id="L158">            specificToGenericStringHeader(sb);</span>

<span class="fc" id="L160">            sb.append('(');</span>
<span class="fc" id="L161">            Type[] params = getGenericParameterTypes();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            for (int j = 0; j &lt; params.length; j++) {</span>
<span class="fc" id="L163">                String param = params[j].getTypeName();</span>
<span class="pc bpc" id="L164" title="1 of 4 branches missed.">                if (isVarArgs() &amp;&amp; (j == params.length - 1)) // replace T[] with T...</span>
<span class="fc" id="L165">                    param = param.replaceFirst(&quot;\\[\\]$&quot;, &quot;...&quot;);</span>
<span class="fc" id="L166">                sb.append(param);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                if (j &lt; (params.length - 1))</span>
<span class="fc" id="L168">                    sb.append(',');</span>
            }
<span class="fc" id="L170">            sb.append(')');</span>
<span class="fc" id="L171">            Type[] exceptions = getGenericExceptionTypes();</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (exceptions.length &gt; 0) {</span>
<span class="fc" id="L173">                sb.append(&quot; throws &quot;);</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">                for (int k = 0; k &lt; exceptions.length; k++) {</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">                    sb.append((exceptions[k] instanceof Class)?</span>
<span class="pc" id="L176">                              ((Class)exceptions[k]).getName():</span>
<span class="nc" id="L177">                              exceptions[k].toString());</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">                    if (k &lt; (exceptions.length - 1))</span>
<span class="nc" id="L179">                        sb.append(',');</span>
                }
            }
<span class="fc" id="L182">            return sb.toString();</span>
<span class="nc" id="L183">        } catch (Exception e) {</span>
<span class="nc" id="L184">            return &quot;&lt;&quot; + e + &quot;&gt;&quot;;</span>
        }
    }

    /**
     * Generate toGenericString header information specific to a
     * method or constructor.
     */
    abstract void specificToGenericStringHeader(StringBuilder sb);

    /**
     * Returns the {@code Class} object representing the class or interface
     * that declares the executable represented by this object.
     */
    public abstract Class&lt;?&gt; getDeclaringClass();

    /**
     * Returns the name of the executable represented by this object.
     */
    public abstract String getName();

    /**
     * Returns the Java language {@linkplain Modifier modifiers} for
     * the executable represented by this object.
     */
    public abstract int getModifiers();

    /**
     * Returns an array of {@code TypeVariable} objects that represent the
     * type variables declared by the generic declaration represented by this
     * {@code GenericDeclaration} object, in declaration order.  Returns an
     * array of length 0 if the underlying generic declaration declares no type
     * variables.
     *
     * @return an array of {@code TypeVariable} objects that represent
     *     the type variables declared by this generic declaration
     * @throws GenericSignatureFormatError if the generic
     *     signature of this generic declaration does not conform to
     *     the format specified in
     *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
     */
    public abstract TypeVariable&lt;?&gt;[] getTypeParameters();

    /**
     * Returns an array of {@code Class} objects that represent the formal
     * parameter types, in declaration order, of the executable
     * represented by this object.  Returns an array of length
     * 0 if the underlying executable takes no parameters.
     *
     * @return the parameter types for the executable this object
     * represents
     */
    public abstract Class&lt;?&gt;[] getParameterTypes();

    /**
     * Returns the number of formal parameters (whether explicitly
     * declared or implicitly declared or neither) for the executable
     * represented by this object.
     *
     * @since 1.8
     * @return The number of formal parameters for the executable this
     * object represents
     */
    public int getParameterCount() {
<span class="nc" id="L248">        throw new AbstractMethodError();</span>
    }

    /**
     * Returns an array of {@code Type} objects that represent the formal
     * parameter types, in declaration order, of the executable represented by
     * this object. Returns an array of length 0 if the
     * underlying executable takes no parameters.
     *
     * &lt;p&gt;If a formal parameter type is a parameterized type,
     * the {@code Type} object returned for it must accurately reflect
     * the actual type parameters used in the source code.
     *
     * &lt;p&gt;If a formal parameter type is a type variable or a parameterized
     * type, it is created. Otherwise, it is resolved.
     *
     * @return an array of {@code Type}s that represent the formal
     *     parameter types of the underlying executable, in declaration order
     * @throws GenericSignatureFormatError
     *     if the generic method signature does not conform to the format
     *     specified in
     *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
     * @throws TypeNotPresentException if any of the parameter
     *     types of the underlying executable refers to a non-existent type
     *     declaration
     * @throws MalformedParameterizedTypeException if any of
     *     the underlying executable's parameter types refer to a parameterized
     *     type that cannot be instantiated for any reason
     */
    public Type[] getGenericParameterTypes() {
<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (hasGenericInformation())</span>
<span class="fc" id="L279">            return getGenericInfo().getParameterTypes();</span>
        else
<span class="fc" id="L281">            return getParameterTypes();</span>
    }

    /**
     * Returns an array of {@code Parameter} objects that represent
     * all the parameters to the underlying executable represented by
     * this object.  Returns an array of length 0 if the executable
     * has no parameters.
     *
     * &lt;p&gt;The parameters of the underlying executable do not necessarily
     * have unique names, or names that are legal identifiers in the
     * Java programming language (JLS 3.8).
     *
     * @since 1.8
     * @throws MalformedParametersException if the class file contains
     * a MethodParameters attribute that is improperly formatted.
     * @return an array of {@code Parameter} objects representing all
     * the parameters to the executable this object represents.
     */
    public Parameter[] getParameters() {
        // TODO: This may eventually need to be guarded by security
        // mechanisms similar to those in Field, Method, etc.
        //
        // Need to copy the cached array to prevent users from messing
        // with it.  Since parameters are immutable, we can
        // shallow-copy.
<span class="fc" id="L307">        return privateGetParameters().clone();</span>
    }

    private Parameter[] synthesizeAllParams() {
<span class="fc" id="L311">        final int realparams = getParameterCount();</span>
<span class="fc" id="L312">        final Parameter[] out = new Parameter[realparams];</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">        for (int i = 0; i &lt; realparams; i++)</span>
            // TODO: is there a way to synthetically derive the
            // modifiers?  Probably not in the general case, since
            // we'd have no way of knowing about them, but there
            // may be specific cases.
<span class="fc" id="L318">            out[i] = new Parameter(&quot;arg&quot; + i, 0, this, i);</span>
<span class="fc" id="L319">        return out;</span>
    }

    private void verifyParameters(final Parameter[] parameters) {
        final int mask = Modifier.FINAL | Modifier.SYNTHETIC | Modifier.MANDATED;

<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (getParameterTypes().length != parameters.length)</span>
<span class="nc" id="L326">            throw new MalformedParametersException(&quot;Wrong number of parameters in MethodParameters attribute&quot;);</span>

<span class="nc bnc" id="L328" title="All 2 branches missed.">        for (Parameter parameter : parameters) {</span>
<span class="nc" id="L329">            final String name = parameter.getRealName();</span>
<span class="nc" id="L330">            final int mods = parameter.getModifiers();</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (name != null) {</span>
<span class="nc bnc" id="L333" title="All 4 branches missed.">                if (name.isEmpty() || name.indexOf('.') != -1 ||</span>
<span class="nc bnc" id="L334" title="All 4 branches missed.">                    name.indexOf(';') != -1 || name.indexOf('[') != -1 ||</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                    name.indexOf('/') != -1) {</span>
<span class="nc" id="L336">                    throw new MalformedParametersException(&quot;Invalid parameter name \&quot;&quot; + name + &quot;\&quot;&quot;);</span>
                }
            }

<span class="nc bnc" id="L340" title="All 2 branches missed.">            if (mods != (mods &amp; mask)) {</span>
<span class="nc" id="L341">                throw new MalformedParametersException(&quot;Invalid parameter modifiers&quot;);</span>
            }
        }
<span class="nc" id="L344">    }</span>

    private Parameter[] privateGetParameters() {
        // Use tmp to avoid multiple writes to a volatile.
<span class="fc" id="L348">        Parameter[] tmp = parameters;</span>

<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (tmp == null) {</span>

            // Otherwise, go to the JVM to get them
            try {
<span class="fc" id="L354">                tmp = getParameters0();</span>
<span class="nc" id="L355">            } catch(IllegalArgumentException e) {</span>
                // Rethrow ClassFormatErrors
<span class="nc" id="L357">                throw new MalformedParametersException(&quot;Invalid constant pool index&quot;);</span>
<span class="fc" id="L358">            }</span>

            // If we get back nothing, then synthesize parameters
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">            if (tmp == null) {</span>
<span class="fc" id="L362">                hasRealParameterData = false;</span>
<span class="fc" id="L363">                tmp = synthesizeAllParams();</span>
            } else {
<span class="nc" id="L365">                hasRealParameterData = true;</span>
<span class="nc" id="L366">                verifyParameters(tmp);</span>
            }

<span class="fc" id="L369">            parameters = tmp;</span>
        }

<span class="fc" id="L372">        return tmp;</span>
    }

    boolean hasRealParameterData() {
        // If this somehow gets called before parameters gets
        // initialized, force it into existence.
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">        if (parameters == null) {</span>
<span class="nc" id="L379">            privateGetParameters();</span>
        }
<span class="fc" id="L381">        return hasRealParameterData;</span>
    }

    private transient volatile boolean hasRealParameterData;
    private transient volatile Parameter[] parameters;

    private native Parameter[] getParameters0();
    native byte[] getTypeAnnotationBytes0();

    // Needed by reflectaccess
    byte[] getTypeAnnotationBytes() {
<span class="fc" id="L392">        return getTypeAnnotationBytes0();</span>
    }

    /**
     * Returns an array of {@code Class} objects that represent the
     * types of exceptions declared to be thrown by the underlying
     * executable represented by this object.  Returns an array of
     * length 0 if the executable declares no exceptions in its {@code
     * throws} clause.
     *
     * @return the exception types declared as being thrown by the
     * executable this object represents
     */
    public abstract Class&lt;?&gt;[] getExceptionTypes();

    /**
     * Returns an array of {@code Type} objects that represent the
     * exceptions declared to be thrown by this executable object.
     * Returns an array of length 0 if the underlying executable declares
     * no exceptions in its {@code throws} clause.
     *
     * &lt;p&gt;If an exception type is a type variable or a parameterized
     * type, it is created. Otherwise, it is resolved.
     *
     * @return an array of Types that represent the exception types
     *     thrown by the underlying executable
     * @throws GenericSignatureFormatError
     *     if the generic method signature does not conform to the format
     *     specified in
     *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
     * @throws TypeNotPresentException if the underlying executable's
     *     {@code throws} clause refers to a non-existent type declaration
     * @throws MalformedParameterizedTypeException if
     *     the underlying executable's {@code throws} clause refers to a
     *     parameterized type that cannot be instantiated for any reason
     */
    public Type[] getGenericExceptionTypes() {
        Type[] result;
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (hasGenericInformation() &amp;&amp;</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            ((result = getGenericInfo().getExceptionTypes()).length &gt; 0))</span>
<span class="fc" id="L432">            return result;</span>
        else
<span class="fc" id="L434">            return getExceptionTypes();</span>
    }

    /**
     * Returns a string describing this {@code Executable}, including
     * any type parameters.
     * @return a string describing this {@code Executable}, including
     * any type parameters
     */
    public abstract String toGenericString();

    /**
     * Returns {@code true} if this executable was declared to take a
     * variable number of arguments; returns {@code false} otherwise.
     *
     * @return {@code true} if an only if this executable was declared
     * to take a variable number of arguments.
     */
    public boolean isVarArgs()  {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        return (getModifiers() &amp; Modifier.VARARGS) != 0;</span>
    }

    /**
     * Returns {@code true} if this executable is a synthetic
     * construct; returns {@code false} otherwise.
     *
     * @return true if and only if this executable is a synthetic
     * construct as defined by
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
     * @jls 13.1 The Form of a Binary
     */
    public boolean isSynthetic() {
<span class="fc" id="L466">        return Modifier.isSynthetic(getModifiers());</span>
    }

    /**
     * Returns an array of arrays of {@code Annotation}s that
     * represent the annotations on the formal parameters, in
     * declaration order, of the {@code Executable} represented by
     * this object.  Synthetic and mandated parameters (see
     * explanation below), such as the outer &quot;this&quot; parameter to an
     * inner class constructor will be represented in the returned
     * array.  If the executable has no parameters (meaning no formal,
     * no synthetic, and no mandated parameters), a zero-length array
     * will be returned.  If the {@code Executable} has one or more
     * parameters, a nested array of length zero is returned for each
     * parameter with no annotations. The annotation objects contained
     * in the returned arrays are serializable.  The caller of this
     * method is free to modify the returned arrays; it will have no
     * effect on the arrays returned to other callers.
     *
     * A compiler may add extra parameters that are implicitly
     * declared in source (&quot;mandated&quot;), as well as parameters that
     * are neither implicitly nor explicitly declared in source
     * (&quot;synthetic&quot;) to the parameter list for a method.  See {@link
     * java.lang.reflect.Parameter} for more information.
     *
     * @see java.lang.reflect.Parameter
     * @see java.lang.reflect.Parameter#getAnnotations
     * @return an array of arrays that represent the annotations on
     *    the formal and implicit parameters, in declaration order, of
     *    the executable represented by this object
     */
    public abstract Annotation[][] getParameterAnnotations();

    Annotation[][] sharedGetParameterAnnotations(Class&lt;?&gt;[] parameterTypes,
                                                 byte[] parameterAnnotations) {
<span class="fc" id="L501">        int numParameters = parameterTypes.length;</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (parameterAnnotations == null)</span>
<span class="fc" id="L503">            return new Annotation[numParameters][0];</span>

<span class="fc" id="L505">        Annotation[][] result = parseParameterAnnotations(parameterAnnotations);</span>

<span class="pc bpc" id="L507" title="1 of 2 branches missed.">        if (result.length != numParameters)</span>
<span class="nc" id="L508">            handleParameterNumberMismatch(result.length, numParameters);</span>
<span class="fc" id="L509">        return result;</span>
    }

    abstract void handleParameterNumberMismatch(int resultLength, int numParameters);

    /**
     * {@inheritDoc}
     * @throws NullPointerException  {@inheritDoc}
     */
    public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="fc" id="L519">        Objects.requireNonNull(annotationClass);</span>
<span class="fc" id="L520">        return annotationClass.cast(declaredAnnotations().get(annotationClass));</span>
    }

    /**
     * {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    public &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) {
<span class="fc" id="L530">        Objects.requireNonNull(annotationClass);</span>

<span class="fc" id="L532">        return AnnotationSupport.getDirectlyAndIndirectlyPresent(declaredAnnotations(), annotationClass);</span>
    }

    /**
     * {@inheritDoc}
     */
    public Annotation[] getDeclaredAnnotations()  {
<span class="fc" id="L539">        return AnnotationParser.toArray(declaredAnnotations());</span>
    }

    private transient Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;

    private synchronized  Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations() {
<span class="fc bfc" id="L545" title="All 2 branches covered.">        if (declaredAnnotations == null) {</span>
<span class="fc" id="L546">            declaredAnnotations = AnnotationParser.parseAnnotations(</span>
<span class="fc" id="L547">                getAnnotationBytes(),</span>
<span class="fc" id="L548">                sun.misc.SharedSecrets.getJavaLangAccess().</span>
<span class="fc" id="L549">                getConstantPool(getDeclaringClass()),</span>
<span class="fc" id="L550">                getDeclaringClass());</span>
        }
<span class="fc" id="L552">        return declaredAnnotations;</span>
    }

    /**
     * Returns an {@code AnnotatedType} object that represents the use of a type to
     * specify the return type of the method/constructor represented by this
     * Executable.
     *
     * If this {@code Executable} object represents a constructor, the {@code
     * AnnotatedType} object represents the type of the constructed object.
     *
     * If this {@code Executable} object represents a method, the {@code
     * AnnotatedType} object represents the use of a type to specify the return
     * type of the method.
     *
     * @return an object representing the return type of the method
     * or constructor represented by this {@code Executable}
     *
     * @since 1.8
     */
    public abstract AnnotatedType getAnnotatedReturnType();

    /* Helper for subclasses of Executable.
     *
     * Returns an AnnotatedType object that represents the use of a type to
     * specify the return type of the method/constructor represented by this
     * Executable.
     *
     * @since 1.8
     */
    AnnotatedType getAnnotatedReturnType0(Type returnType) {
<span class="fc" id="L583">        return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),</span>
<span class="fc" id="L584">                sun.misc.SharedSecrets.getJavaLangAccess().</span>
<span class="fc" id="L585">                        getConstantPool(getDeclaringClass()),</span>
                this,
<span class="fc" id="L587">                getDeclaringClass(),</span>
                returnType,
                TypeAnnotation.TypeAnnotationTarget.METHOD_RETURN);
    }

    /**
     * Returns an {@code AnnotatedType} object that represents the use of a
     * type to specify the receiver type of the method/constructor represented
     * by this Executable object. The receiver type of a method/constructor is
     * available only if the method/constructor has a &lt;em&gt;receiver
     * parameter&lt;/em&gt; (JLS 8.4.1).
     *
     * If this {@code Executable} object represents a constructor or instance
     * method that does not have a receiver parameter, or has a receiver
     * parameter with no annotations on its type, then the return value is an
     * {@code AnnotatedType} object representing an element with no
     * annotations.
     *
     * If this {@code Executable} object represents a static method, then the
     * return value is null.
     *
     * @return an object representing the receiver type of the method or
     * constructor represented by this {@code Executable}
     *
     * @since 1.8
     */
    public AnnotatedType getAnnotatedReceiverType() {
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (Modifier.isStatic(this.getModifiers()))</span>
<span class="nc" id="L615">            return null;</span>
<span class="nc" id="L616">        return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),</span>
<span class="nc" id="L617">                sun.misc.SharedSecrets.getJavaLangAccess().</span>
<span class="nc" id="L618">                        getConstantPool(getDeclaringClass()),</span>
                this,
<span class="nc" id="L620">                getDeclaringClass(),</span>
<span class="nc" id="L621">                getDeclaringClass(),</span>
                TypeAnnotation.TypeAnnotationTarget.METHOD_RECEIVER);
    }

    /**
     * Returns an array of {@code AnnotatedType} objects that represent the use
     * of types to specify formal parameter types of the method/constructor
     * represented by this Executable. The order of the objects in the array
     * corresponds to the order of the formal parameter types in the
     * declaration of the method/constructor.
     *
     * Returns an array of length 0 if the method/constructor declares no
     * parameters.
     *
     * @return an array of objects representing the types of the
     * formal parameters of the method or constructor represented by this
     * {@code Executable}
     *
     * @since 1.8
     */
    public AnnotatedType[] getAnnotatedParameterTypes() {
<span class="fc" id="L642">        return TypeAnnotationParser.buildAnnotatedTypes(getTypeAnnotationBytes0(),</span>
<span class="fc" id="L643">                sun.misc.SharedSecrets.getJavaLangAccess().</span>
<span class="fc" id="L644">                        getConstantPool(getDeclaringClass()),</span>
                this,
<span class="fc" id="L646">                getDeclaringClass(),</span>
<span class="fc" id="L647">                getParameterTypes(),</span>
                TypeAnnotation.TypeAnnotationTarget.METHOD_FORMAL_PARAMETER);
    }

    /**
     * Returns an array of {@code AnnotatedType} objects that represent the use
     * of types to specify the declared exceptions of the method/constructor
     * represented by this Executable. The order of the objects in the array
     * corresponds to the order of the exception types in the declaration of
     * the method/constructor.
     *
     * Returns an array of length 0 if the method/constructor declares no
     * exceptions.
     *
     * @return an array of objects representing the declared
     * exceptions of the method or constructor represented by this {@code
     * Executable}
     *
     * @since 1.8
     */
    public AnnotatedType[] getAnnotatedExceptionTypes() {
<span class="fc" id="L668">        return TypeAnnotationParser.buildAnnotatedTypes(getTypeAnnotationBytes0(),</span>
<span class="fc" id="L669">                sun.misc.SharedSecrets.getJavaLangAccess().</span>
<span class="fc" id="L670">                        getConstantPool(getDeclaringClass()),</span>
                this,
<span class="fc" id="L672">                getDeclaringClass(),</span>
<span class="fc" id="L673">                getGenericExceptionTypes(),</span>
                TypeAnnotation.TypeAnnotationTarget.THROWS);
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>