<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Constructor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.lang.reflect</a> &gt; <span class="el_source">Constructor.java</span></div><h1>Constructor.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.reflect;

import sun.reflect.CallerSensitive;
import sun.reflect.ConstructorAccessor;
import sun.reflect.Reflection;
import sun.reflect.annotation.TypeAnnotation;
import sun.reflect.annotation.TypeAnnotationParser;
import sun.reflect.generics.repository.ConstructorRepository;
import sun.reflect.generics.factory.CoreReflectionFactory;
import sun.reflect.generics.factory.GenericsFactory;
import sun.reflect.generics.scope.ConstructorScope;
import java.lang.annotation.Annotation;
import java.lang.annotation.AnnotationFormatError;

/**
 * {@code Constructor} provides information about, and access to, a single
 * constructor for a class.
 *
 * &lt;p&gt;{@code Constructor} permits widening conversions to occur when matching the
 * actual parameters to newInstance() with the underlying
 * constructor's formal parameters, but throws an
 * {@code IllegalArgumentException} if a narrowing conversion would occur.
 *
 * @param &lt;T&gt; the class in which the constructor is declared
 *
 * @see Member
 * @see java.lang.Class
 * @see java.lang.Class#getConstructors()
 * @see java.lang.Class#getConstructor(Class[])
 * @see java.lang.Class#getDeclaredConstructors()
 *
 * @author      Kenneth Russell
 * @author      Nakul Saraiya
 */
public final class Constructor&lt;T&gt; extends Executable {
    private Class&lt;T&gt;            clazz;
    private int                 slot;
    private Class&lt;?&gt;[]          parameterTypes;
    private Class&lt;?&gt;[]          exceptionTypes;
    private int                 modifiers;
    // Generics and annotations support
    private transient String    signature;
    // generic info repository; lazily initialized
    private transient ConstructorRepository genericInfo;
    private byte[]              annotations;
    private byte[]              parameterAnnotations;

    // Generics infrastructure
    // Accessor for factory
    private GenericsFactory getFactory() {
        // create scope and factory
<span class="fc" id="L77">        return CoreReflectionFactory.make(this, ConstructorScope.make(this));</span>
    }

    // Accessor for generic info repository
    @Override
    ConstructorRepository getGenericInfo() {
        // lazily initialize repository if necessary
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (genericInfo == null) {</span>
            // create and cache generic info repository
<span class="fc" id="L86">            genericInfo =</span>
<span class="fc" id="L87">                ConstructorRepository.make(getSignature(),</span>
<span class="fc" id="L88">                                           getFactory());</span>
        }
<span class="fc" id="L90">        return genericInfo; //return cached repository</span>
    }

    private volatile ConstructorAccessor constructorAccessor;
    // For sharing of ConstructorAccessors. This branching structure
    // is currently only two levels deep (i.e., one root Constructor
    // and potentially many Constructor objects pointing to it.)
    private Constructor&lt;T&gt;      root;

    /**
     * Package-private constructor used by ReflectAccess to enable
     * instantiation of these objects in Java code from the java.lang
     * package via sun.reflect.LangReflectAccess.
     */
    Constructor(Class&lt;T&gt; declaringClass,
                Class&lt;?&gt;[] parameterTypes,
                Class&lt;?&gt;[] checkedExceptions,
                int modifiers,
                int slot,
                String signature,
                byte[] annotations,
<span class="fc" id="L111">                byte[] parameterAnnotations) {</span>
<span class="fc" id="L112">        this.clazz = declaringClass;</span>
<span class="fc" id="L113">        this.parameterTypes = parameterTypes;</span>
<span class="fc" id="L114">        this.exceptionTypes = checkedExceptions;</span>
<span class="fc" id="L115">        this.modifiers = modifiers;</span>
<span class="fc" id="L116">        this.slot = slot;</span>
<span class="fc" id="L117">        this.signature = signature;</span>
<span class="fc" id="L118">        this.annotations = annotations;</span>
<span class="fc" id="L119">        this.parameterAnnotations = parameterAnnotations;</span>
<span class="fc" id="L120">    }</span>

    /**
     * Package-private routine (exposed to java.lang.Class via
     * ReflectAccess) which returns a copy of this Constructor. The copy's
     * &quot;root&quot; field points to this Constructor.
     */
    Constructor&lt;T&gt; copy() {
        // This routine enables sharing of ConstructorAccessor objects
        // among Constructor objects which refer to the same underlying
        // method in the VM. (All of this contortion is only necessary
        // because of the &quot;accessibility&quot; bit in AccessibleObject,
        // which implicitly requires that new java.lang.reflect
        // objects be fabricated for each reflective call on Class
        // objects.)
<span class="fc" id="L135">        Constructor&lt;T&gt; res = new Constructor&lt;&gt;(clazz,</span>
                                               parameterTypes,
                                               exceptionTypes, modifiers, slot,
                                               signature,
                                               annotations,
                                               parameterAnnotations);
<span class="fc" id="L141">        res.root = this;</span>
        // Might as well eagerly propagate this if already present
<span class="fc" id="L143">        res.constructorAccessor = constructorAccessor;</span>
<span class="fc" id="L144">        return res;</span>
    }

    @Override
    boolean hasGenericInformation() {
<span class="fc bfc" id="L149" title="All 2 branches covered.">        return (getSignature() != null);</span>
    }

    @Override
    byte[] getAnnotationBytes() {
<span class="fc" id="L154">        return annotations;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Class&lt;T&gt; getDeclaringClass() {
<span class="fc" id="L162">        return clazz;</span>
    }

    /**
     * Returns the name of this constructor, as a string.  This is
     * the binary name of the constructor's declaring class.
     */
    @Override
    public String getName() {
<span class="fc" id="L171">        return getDeclaringClass().getName();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getModifiers() {
<span class="fc" id="L179">        return modifiers;</span>
    }

    /**
     * {@inheritDoc}
     * @throws GenericSignatureFormatError {@inheritDoc}
     * @since 1.5
     */
    @Override
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public TypeVariable&lt;Constructor&lt;T&gt;&gt;[] getTypeParameters() {
<span class="fc bfc" id="L190" title="All 2 branches covered.">      if (getSignature() != null) {</span>
<span class="fc" id="L191">        return (TypeVariable&lt;Constructor&lt;T&gt;&gt;[])getGenericInfo().getTypeParameters();</span>
      } else
<span class="fc" id="L193">          return (TypeVariable&lt;Constructor&lt;T&gt;&gt;[])new TypeVariable[0];</span>
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public Class&lt;?&gt;[] getParameterTypes() {
<span class="fc" id="L202">        return parameterTypes.clone();</span>
    }

    /**
     * {@inheritDoc}
     */
<span class="fc" id="L208">    public int getParameterCount() { return parameterTypes.length; }</span>

    /**
     * {@inheritDoc}
     * @throws GenericSignatureFormatError {@inheritDoc}
     * @throws TypeNotPresentException {@inheritDoc}
     * @throws MalformedParameterizedTypeException {@inheritDoc}
     * @since 1.5
     */
    @Override
    public Type[] getGenericParameterTypes() {
<span class="fc" id="L219">        return super.getGenericParameterTypes();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Class&lt;?&gt;[] getExceptionTypes() {
<span class="fc" id="L227">        return exceptionTypes.clone();</span>
    }


    /**
     * {@inheritDoc}
     * @throws GenericSignatureFormatError {@inheritDoc}
     * @throws TypeNotPresentException {@inheritDoc}
     * @throws MalformedParameterizedTypeException {@inheritDoc}
     * @since 1.5
     */
    @Override
    public Type[] getGenericExceptionTypes() {
<span class="fc" id="L240">        return super.getGenericExceptionTypes();</span>
    }

    /**
     * Compares this {@code Constructor} against the specified object.
     * Returns true if the objects are the same.  Two {@code Constructor} objects are
     * the same if they were declared by the same class and have the
     * same formal parameter types.
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L250" title="1 of 4 branches missed.">        if (obj != null &amp;&amp; obj instanceof Constructor) {</span>
<span class="fc" id="L251">            Constructor&lt;?&gt; other = (Constructor&lt;?&gt;)obj;</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            if (getDeclaringClass() == other.getDeclaringClass()) {</span>
<span class="fc" id="L253">                return equalParamTypes(parameterTypes, other.parameterTypes);</span>
            }
        }
<span class="fc" id="L256">        return false;</span>
    }

    /**
     * Returns a hashcode for this {@code Constructor}. The hashcode is
     * the same as the hashcode for the underlying constructor's
     * declaring class name.
     */
    public int hashCode() {
<span class="fc" id="L265">        return getDeclaringClass().getName().hashCode();</span>
    }

    /**
     * Returns a string describing this {@code Constructor}.  The string is
     * formatted as the constructor access modifiers, if any,
     * followed by the fully-qualified name of the declaring class,
     * followed by a parenthesized, comma-separated list of the
     * constructor's formal parameter types.  For example:
     * &lt;pre&gt;
     *    public java.util.Hashtable(int,float)
     * &lt;/pre&gt;
     *
     * &lt;p&gt;The only possible modifiers for constructors are the access
     * modifiers {@code public}, {@code protected} or
     * {@code private}.  Only one of these may appear, or none if the
     * constructor has default (package) access.
     *
     * @return a string describing this {@code Constructor}
     * @jls 8.8.3. Constructor Modifiers
     */
    public String toString() {
<span class="fc" id="L287">        return sharedToString(Modifier.constructorModifiers(),</span>
                              false,
                              parameterTypes,
                              exceptionTypes);
    }

    @Override
    void specificToStringHeader(StringBuilder sb) {
<span class="fc" id="L295">        sb.append(getDeclaringClass().getTypeName());</span>
<span class="fc" id="L296">    }</span>

    /**
     * Returns a string describing this {@code Constructor},
     * including type parameters.  The string is formatted as the
     * constructor access modifiers, if any, followed by an
     * angle-bracketed comma separated list of the constructor's type
     * parameters, if any, followed by the fully-qualified name of the
     * declaring class, followed by a parenthesized, comma-separated
     * list of the constructor's generic formal parameter types.
     *
     * If this constructor was declared to take a variable number of
     * arguments, instead of denoting the last parameter as
     * &quot;&lt;tt&gt;&lt;i&gt;Type&lt;/i&gt;[]&lt;/tt&gt;&quot;, it is denoted as
     * &quot;&lt;tt&gt;&lt;i&gt;Type&lt;/i&gt;...&lt;/tt&gt;&quot;.
     *
     * A space is used to separate access modifiers from one another
     * and from the type parameters or return type.  If there are no
     * type parameters, the type parameter list is elided; if the type
     * parameter list is present, a space separates the list from the
     * class name.  If the constructor is declared to throw
     * exceptions, the parameter list is followed by a space, followed
     * by the word &quot;{@code throws}&quot; followed by a
     * comma-separated list of the thrown exception types.
     *
     * &lt;p&gt;The only possible modifiers for constructors are the access
     * modifiers {@code public}, {@code protected} or
     * {@code private}.  Only one of these may appear, or none if the
     * constructor has default (package) access.
     *
     * @return a string describing this {@code Constructor},
     * include type parameters
     *
     * @since 1.5
     * @jls 8.8.3. Constructor Modifiers
     */
    @Override
    public String toGenericString() {
<span class="fc" id="L334">        return sharedToGenericString(Modifier.constructorModifiers(), false);</span>
    }

    @Override
    void specificToGenericStringHeader(StringBuilder sb) {
<span class="fc" id="L339">        specificToStringHeader(sb);</span>
<span class="fc" id="L340">    }</span>

    /**
     * Uses the constructor represented by this {@code Constructor} object to
     * create and initialize a new instance of the constructor's
     * declaring class, with the specified initialization parameters.
     * Individual parameters are automatically unwrapped to match
     * primitive formal parameters, and both primitive and reference
     * parameters are subject to method invocation conversions as necessary.
     *
     * &lt;p&gt;If the number of formal parameters required by the underlying constructor
     * is 0, the supplied {@code initargs} array may be of length 0 or null.
     *
     * &lt;p&gt;If the constructor's declaring class is an inner class in a
     * non-static context, the first argument to the constructor needs
     * to be the enclosing instance; see section 15.9.3 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
     *
     * &lt;p&gt;If the required access and argument checks succeed and the
     * instantiation will proceed, the constructor's declaring class
     * is initialized if it has not already been initialized.
     *
     * &lt;p&gt;If the constructor completes normally, returns the newly
     * created and initialized instance.
     *
     * @param initargs array of objects to be passed as arguments to
     * the constructor call; values of primitive types are wrapped in
     * a wrapper object of the appropriate type (e.g. a {@code float}
     * in a {@link java.lang.Float Float})
     *
     * @return a new object created by calling the constructor
     * this object represents
     *
     * @exception IllegalAccessException    if this {@code Constructor} object
     *              is enforcing Java language access control and the underlying
     *              constructor is inaccessible.
     * @exception IllegalArgumentException  if the number of actual
     *              and formal parameters differ; if an unwrapping
     *              conversion for primitive arguments fails; or if,
     *              after possible unwrapping, a parameter value
     *              cannot be converted to the corresponding formal
     *              parameter type by a method invocation conversion; if
     *              this constructor pertains to an enum type.
     * @exception InstantiationException    if the class that declares the
     *              underlying constructor represents an abstract class.
     * @exception InvocationTargetException if the underlying constructor
     *              throws an exception.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     */
    @CallerSensitive
    public T newInstance(Object ... initargs)
        throws InstantiationException, IllegalAccessException,
               IllegalArgumentException, InvocationTargetException
    {
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (!override) {</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="fc" id="L397">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="fc" id="L398">                checkAccess(caller, clazz, null, modifiers);</span>
            }
        }
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)</span>
<span class="nc" id="L402">            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);</span>
<span class="fc" id="L403">        ConstructorAccessor ca = constructorAccessor;   // read volatile</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (ca == null) {</span>
<span class="fc" id="L405">            ca = acquireConstructorAccessor();</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L408">        T inst = (T) ca.newInstance(initargs);</span>
<span class="fc" id="L409">        return inst;</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.5
     */
    @Override
    public boolean isVarArgs() {
<span class="fc" id="L418">        return super.isVarArgs();</span>
    }

    /**
     * {@inheritDoc}
     * @jls 13.1 The Form of a Binary
     * @since 1.5
     */
    @Override
    public boolean isSynthetic() {
<span class="fc" id="L428">        return super.isSynthetic();</span>
    }

    // NOTE that there is no synchronization used here. It is correct
    // (though not efficient) to generate more than one
    // ConstructorAccessor for a given Constructor. However, avoiding
    // synchronization will probably make the implementation more
    // scalable.
    private ConstructorAccessor acquireConstructorAccessor() {
        // First check to see if one has been created yet, and take it
        // if so.
<span class="fc" id="L439">        ConstructorAccessor tmp = null;</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        if (root != null) tmp = root.getConstructorAccessor();</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (tmp != null) {</span>
<span class="fc" id="L442">            constructorAccessor = tmp;</span>
        } else {
            // Otherwise fabricate one and propagate it up to the root
<span class="fc" id="L445">            tmp = reflectionFactory.newConstructorAccessor(this);</span>
<span class="fc" id="L446">            setConstructorAccessor(tmp);</span>
        }

<span class="fc" id="L449">        return tmp;</span>
    }

    // Returns ConstructorAccessor for this Constructor object, not
    // looking up the chain to the root
    ConstructorAccessor getConstructorAccessor() {
<span class="fc" id="L455">        return constructorAccessor;</span>
    }

    // Sets the ConstructorAccessor for this Constructor object and
    // (recursively) its root
    void setConstructorAccessor(ConstructorAccessor accessor) {
<span class="fc" id="L461">        constructorAccessor = accessor;</span>
        // Propagate up
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if (root != null) {</span>
<span class="fc" id="L464">            root.setConstructorAccessor(accessor);</span>
        }
<span class="fc" id="L466">    }</span>

    int getSlot() {
<span class="fc" id="L469">        return slot;</span>
    }

    String getSignature() {
<span class="fc" id="L473">        return signature;</span>
    }

    byte[] getRawAnnotations() {
<span class="fc" id="L477">        return annotations;</span>
    }

    byte[] getRawParameterAnnotations() {
<span class="fc" id="L481">        return parameterAnnotations;</span>
    }


    /**
     * {@inheritDoc}
     * @throws NullPointerException  {@inheritDoc}
     * @since 1.5
     */
    public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="fc" id="L491">        return super.getAnnotation(annotationClass);</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.5
     */
    public Annotation[] getDeclaredAnnotations()  {
<span class="fc" id="L499">        return super.getDeclaredAnnotations();</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.5
     */
    @Override
    public Annotation[][] getParameterAnnotations() {
<span class="nc" id="L508">        return sharedGetParameterAnnotations(parameterTypes, parameterAnnotations);</span>
    }

    @Override
    void handleParameterNumberMismatch(int resultLength, int numParameters) {
<span class="nc" id="L513">        Class&lt;?&gt; declaringClass = getDeclaringClass();</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (declaringClass.isEnum() ||</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            declaringClass.isAnonymousClass() ||</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">            declaringClass.isLocalClass() )</span>
<span class="nc" id="L517">            return ; // Can't do reliable parameter counting</span>
        else {
<span class="nc bnc" id="L519" title="All 2 branches missed.">            if (!declaringClass.isMemberClass() || // top-level</span>
                // Check for the enclosing instance parameter for
                // non-static member classes
<span class="nc bnc" id="L522" title="All 2 branches missed.">                (declaringClass.isMemberClass() &amp;&amp;</span>
<span class="nc bnc" id="L523" title="All 4 branches missed.">                 ((declaringClass.getModifiers() &amp; Modifier.STATIC) == 0)  &amp;&amp;</span>
                 resultLength + 1 != numParameters) ) {
<span class="nc" id="L525">                throw new AnnotationFormatError(</span>
                          &quot;Parameter annotations don't match number of parameters&quot;);
            }
        }
<span class="nc" id="L529">    }</span>

    /**
     * {@inheritDoc}
     * @since 1.8
     */
    @Override
    public AnnotatedType getAnnotatedReturnType() {
<span class="nc" id="L537">        return getAnnotatedReturnType0(getDeclaringClass());</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.8
     */
    @Override
    public AnnotatedType getAnnotatedReceiverType() {
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (getDeclaringClass().getEnclosingClass() == null)</span>
<span class="nc" id="L547">            return super.getAnnotatedReceiverType();</span>

<span class="nc" id="L549">        return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),</span>
<span class="nc" id="L550">                sun.misc.SharedSecrets.getJavaLangAccess().</span>
<span class="nc" id="L551">                        getConstantPool(getDeclaringClass()),</span>
                this,
<span class="nc" id="L553">                getDeclaringClass(),</span>
<span class="nc" id="L554">                getDeclaringClass().getEnclosingClass(),</span>
                TypeAnnotation.TypeAnnotationTarget.METHOD_RECEIVER);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>