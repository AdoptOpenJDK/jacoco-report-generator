<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Field.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang.reflect</a> &gt; <span class="el_source">Field.java</span></div><h1>Field.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.reflect;

import sun.reflect.CallerSensitive;
import sun.reflect.FieldAccessor;
import sun.reflect.Reflection;
import sun.reflect.generics.repository.FieldRepository;
import sun.reflect.generics.factory.CoreReflectionFactory;
import sun.reflect.generics.factory.GenericsFactory;
import sun.reflect.generics.scope.ClassScope;
import java.lang.annotation.Annotation;
import java.util.Map;
import java.util.Objects;
import sun.reflect.annotation.AnnotationParser;
import sun.reflect.annotation.AnnotationSupport;
import sun.reflect.annotation.TypeAnnotation;
import sun.reflect.annotation.TypeAnnotationParser;

/**
 * A {@code Field} provides information about, and dynamic access to, a
 * single field of a class or an interface.  The reflected field may
 * be a class (static) field or an instance field.
 *
 * &lt;p&gt;A {@code Field} permits widening conversions to occur during a get or
 * set access operation, but throws an {@code IllegalArgumentException} if a
 * narrowing conversion would occur.
 *
 * @see Member
 * @see java.lang.Class
 * @see java.lang.Class#getFields()
 * @see java.lang.Class#getField(String)
 * @see java.lang.Class#getDeclaredFields()
 * @see java.lang.Class#getDeclaredField(String)
 *
 * @author Kenneth Russell
 * @author Nakul Saraiya
 */
public final
class Field extends AccessibleObject implements Member {

    private Class&lt;?&gt;            clazz;
    private int                 slot;
    // This is guaranteed to be interned by the VM in the 1.4
    // reflection implementation
    private String              name;
    private Class&lt;?&gt;            type;
    private int                 modifiers;
    // Generics and annotations support
    private transient String    signature;
    // generic info repository; lazily initialized
    private transient FieldRepository genericInfo;
    private byte[]              annotations;
    // Cached field accessor created without override
    private FieldAccessor fieldAccessor;
    // Cached field accessor created with override
    private FieldAccessor overrideFieldAccessor;
    // For sharing of FieldAccessors. This branching structure is
    // currently only two levels deep (i.e., one root Field and
    // potentially many Field objects pointing to it.)
    private Field               root;

    // Generics infrastructure

<span class="fc" id="L88">    private String getGenericSignature() {return signature;}</span>

    // Accessor for factory
    private GenericsFactory getFactory() {
<span class="fc" id="L92">        Class&lt;?&gt; c = getDeclaringClass();</span>
        // create scope and factory
<span class="fc" id="L94">        return CoreReflectionFactory.make(c, ClassScope.make(c));</span>
    }

    // Accessor for generic info repository
    private FieldRepository getGenericInfo() {
        // lazily initialize repository if necessary
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (genericInfo == null) {</span>
            // create and cache generic info repository
<span class="fc" id="L102">            genericInfo = FieldRepository.make(getGenericSignature(),</span>
<span class="fc" id="L103">                                               getFactory());</span>
        }
<span class="fc" id="L105">        return genericInfo; //return cached repository</span>
    }


    /**
     * Package-private constructor used by ReflectAccess to enable
     * instantiation of these objects in Java code from the java.lang
     * package via sun.reflect.LangReflectAccess.
     */
    Field(Class&lt;?&gt; declaringClass,
          String name,
          Class&lt;?&gt; type,
          int modifiers,
          int slot,
          String signature,
          byte[] annotations)
<span class="fc" id="L121">    {</span>
<span class="fc" id="L122">        this.clazz = declaringClass;</span>
<span class="fc" id="L123">        this.name = name;</span>
<span class="fc" id="L124">        this.type = type;</span>
<span class="fc" id="L125">        this.modifiers = modifiers;</span>
<span class="fc" id="L126">        this.slot = slot;</span>
<span class="fc" id="L127">        this.signature = signature;</span>
<span class="fc" id="L128">        this.annotations = annotations;</span>
<span class="fc" id="L129">    }</span>

    /**
     * Package-private routine (exposed to java.lang.Class via
     * ReflectAccess) which returns a copy of this Field. The copy's
     * &quot;root&quot; field points to this Field.
     */
    Field copy() {
        // This routine enables sharing of FieldAccessor objects
        // among Field objects which refer to the same underlying
        // method in the VM. (All of this contortion is only necessary
        // because of the &quot;accessibility&quot; bit in AccessibleObject,
        // which implicitly requires that new java.lang.reflect
        // objects be fabricated for each reflective call on Class
        // objects.)
<span class="fc" id="L144">        Field res = new Field(clazz, name, type, modifiers, slot, signature, annotations);</span>
<span class="fc" id="L145">        res.root = this;</span>
        // Might as well eagerly propagate this if already present
<span class="fc" id="L147">        res.fieldAccessor = fieldAccessor;</span>
<span class="fc" id="L148">        res.overrideFieldAccessor = overrideFieldAccessor;</span>

<span class="fc" id="L150">        return res;</span>
    }

    /**
     * Returns the {@code Class} object representing the class or interface
     * that declares the field represented by this {@code Field} object.
     */
    public Class&lt;?&gt; getDeclaringClass() {
<span class="fc" id="L158">        return clazz;</span>
    }

    /**
     * Returns the name of the field represented by this {@code Field} object.
     */
    public String getName() {
<span class="fc" id="L165">        return name;</span>
    }

    /**
     * Returns the Java language modifiers for the field represented
     * by this {@code Field} object, as an integer. The {@code Modifier} class should
     * be used to decode the modifiers.
     *
     * @see Modifier
     */
    public int getModifiers() {
<span class="fc" id="L176">        return modifiers;</span>
    }

    /**
     * Returns {@code true} if this field represents an element of
     * an enumerated type; returns {@code false} otherwise.
     *
     * @return {@code true} if and only if this field represents an element of
     * an enumerated type.
     * @since 1.5
     */
    public boolean isEnumConstant() {
<span class="nc bnc" id="L188" title="All 2 branches missed.">        return (getModifiers() &amp; Modifier.ENUM) != 0;</span>
    }

    /**
     * Returns {@code true} if this field is a synthetic
     * field; returns {@code false} otherwise.
     *
     * @return true if and only if this field is a synthetic
     * field as defined by the Java Language Specification.
     * @since 1.5
     */
    public boolean isSynthetic() {
<span class="fc" id="L200">        return Modifier.isSynthetic(getModifiers());</span>
    }

    /**
     * Returns a {@code Class} object that identifies the
     * declared type for the field represented by this
     * {@code Field} object.
     *
     * @return a {@code Class} object identifying the declared
     * type of the field represented by this object
     */
    public Class&lt;?&gt; getType() {
<span class="fc" id="L212">        return type;</span>
    }

    /**
     * Returns a {@code Type} object that represents the declared type for
     * the field represented by this {@code Field} object.
     *
     * &lt;p&gt;If the {@code Type} is a parameterized type, the
     * {@code Type} object returned must accurately reflect the
     * actual type parameters used in the source code.
     *
     * &lt;p&gt;If the type of the underlying field is a type variable or a
     * parameterized type, it is created. Otherwise, it is resolved.
     *
     * @return a {@code Type} object that represents the declared type for
     *     the field represented by this {@code Field} object
     * @throws GenericSignatureFormatError if the generic field
     *     signature does not conform to the format specified in
     *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
     * @throws TypeNotPresentException if the generic type
     *     signature of the underlying field refers to a non-existent
     *     type declaration
     * @throws MalformedParameterizedTypeException if the generic
     *     signature of the underlying field refers to a parameterized type
     *     that cannot be instantiated for any reason
     * @since 1.5
     */
    public Type getGenericType() {
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (getGenericSignature() != null)</span>
<span class="fc" id="L241">            return getGenericInfo().getGenericType();</span>
        else
<span class="fc" id="L243">            return getType();</span>
    }


    /**
     * Compares this {@code Field} against the specified object.  Returns
     * true if the objects are the same.  Two {@code Field} objects are the same if
     * they were declared by the same class and have the same name
     * and type.
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L254" title="1 of 4 branches missed.">        if (obj != null &amp;&amp; obj instanceof Field) {</span>
<span class="fc" id="L255">            Field other = (Field)obj;</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            return (getDeclaringClass() == other.getDeclaringClass())</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">                &amp;&amp; (getName() == other.getName())</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">                &amp;&amp; (getType() == other.getType());</span>
        }
<span class="fc" id="L260">        return false;</span>
    }

    /**
     * Returns a hashcode for this {@code Field}.  This is computed as the
     * exclusive-or of the hashcodes for the underlying field's
     * declaring class name and its name.
     */
    public int hashCode() {
<span class="fc" id="L269">        return getDeclaringClass().getName().hashCode() ^ getName().hashCode();</span>
    }

    /**
     * Returns a string describing this {@code Field}.  The format is
     * the access modifiers for the field, if any, followed
     * by the field type, followed by a space, followed by
     * the fully-qualified name of the class declaring the field,
     * followed by a period, followed by the name of the field.
     * For example:
     * &lt;pre&gt;
     *    public static final int java.lang.Thread.MIN_PRIORITY
     *    private int java.io.FileDescriptor.fd
     * &lt;/pre&gt;
     *
     * &lt;p&gt;The modifiers are placed in canonical order as specified by
     * &quot;The Java Language Specification&quot;.  This is {@code public},
     * {@code protected} or {@code private} first, and then other
     * modifiers in the following order: {@code static}, {@code final},
     * {@code transient}, {@code volatile}.
     *
     * @return a string describing this {@code Field}
     * @jls 8.3.1 Field Modifiers
     */
    public String toString() {
<span class="fc" id="L294">        int mod = getModifiers();</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        return (((mod == 0) ? &quot;&quot; : (Modifier.toString(mod) + &quot; &quot;))</span>
<span class="fc" id="L296">            + getType().getTypeName() + &quot; &quot;</span>
<span class="fc" id="L297">            + getDeclaringClass().getTypeName() + &quot;.&quot;</span>
<span class="fc" id="L298">            + getName());</span>
    }

    /**
     * Returns a string describing this {@code Field}, including
     * its generic type.  The format is the access modifiers for the
     * field, if any, followed by the generic field type, followed by
     * a space, followed by the fully-qualified name of the class
     * declaring the field, followed by a period, followed by the name
     * of the field.
     *
     * &lt;p&gt;The modifiers are placed in canonical order as specified by
     * &quot;The Java Language Specification&quot;.  This is {@code public},
     * {@code protected} or {@code private} first, and then other
     * modifiers in the following order: {@code static}, {@code final},
     * {@code transient}, {@code volatile}.
     *
     * @return a string describing this {@code Field}, including
     * its generic type
     *
     * @since 1.5
     * @jls 8.3.1 Field Modifiers
     */
    public String toGenericString() {
<span class="nc" id="L322">        int mod = getModifiers();</span>
<span class="nc" id="L323">        Type fieldType = getGenericType();</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">        return (((mod == 0) ? &quot;&quot; : (Modifier.toString(mod) + &quot; &quot;))</span>
<span class="nc" id="L325">            + fieldType.getTypeName() + &quot; &quot;</span>
<span class="nc" id="L326">            + getDeclaringClass().getTypeName() + &quot;.&quot;</span>
<span class="nc" id="L327">            + getName());</span>
    }

    /**
     * Returns the value of the field represented by this {@code Field}, on
     * the specified object. The value is automatically wrapped in an
     * object if it has a primitive type.
     *
     * &lt;p&gt;The underlying field's value is obtained as follows:
     *
     * &lt;p&gt;If the underlying field is a static field, the {@code obj} argument
     * is ignored; it may be null.
     *
     * &lt;p&gt;Otherwise, the underlying field is an instance field.  If the
     * specified {@code obj} argument is null, the method throws a
     * {@code NullPointerException}. If the specified object is not an
     * instance of the class or interface declaring the underlying
     * field, the method throws an {@code IllegalArgumentException}.
     *
     * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
     * the underlying field is inaccessible, the method throws an
     * {@code IllegalAccessException}.
     * If the underlying field is static, the class that declared the
     * field is initialized if it has not already been initialized.
     *
     * &lt;p&gt;Otherwise, the value is retrieved from the underlying instance
     * or static field.  If the field has a primitive type, the value
     * is wrapped in an object before being returned, otherwise it is
     * returned as is.
     *
     * &lt;p&gt;If the field is hidden in the type of {@code obj},
     * the field's value is obtained according to the preceding rules.
     *
     * @param obj object from which the represented field's value is
     * to be extracted
     * @return the value of the represented field in object
     * {@code obj}; primitive values are wrapped in an appropriate
     * object before being returned
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is inaccessible.
     * @exception IllegalArgumentException  if the specified object is not an
     *              instance of the class or interface declaring the underlying
     *              field (or a subclass or implementor thereof).
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     */
    @CallerSensitive
    public Object get(Object obj)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (!override) {</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="fc" id="L383">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="fc" id="L384">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L387">        return getFieldAccessor(obj).get(obj);</span>
    }

    /**
     * Gets the value of a static or instance {@code boolean} field.
     *
     * @param obj the object to extract the {@code boolean} value
     * from
     * @return the value of the {@code boolean} field
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is inaccessible.
     * @exception IllegalArgumentException  if the specified object is not
     *              an instance of the class or interface declaring the
     *              underlying field (or a subclass or implementor
     *              thereof), or if the field value cannot be
     *              converted to the type {@code boolean} by a
     *              widening conversion.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#get
     */
    @CallerSensitive
    public boolean getBoolean(Object obj)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (!override) {</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L418">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L419">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L422">        return getFieldAccessor(obj).getBoolean(obj);</span>
    }

    /**
     * Gets the value of a static or instance {@code byte} field.
     *
     * @param obj the object to extract the {@code byte} value
     * from
     * @return the value of the {@code byte} field
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is inaccessible.
     * @exception IllegalArgumentException  if the specified object is not
     *              an instance of the class or interface declaring the
     *              underlying field (or a subclass or implementor
     *              thereof), or if the field value cannot be
     *              converted to the type {@code byte} by a
     *              widening conversion.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#get
     */
    @CallerSensitive
    public byte getByte(Object obj)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L453">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L454">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L457">        return getFieldAccessor(obj).getByte(obj);</span>
    }

    /**
     * Gets the value of a static or instance field of type
     * {@code char} or of another primitive type convertible to
     * type {@code char} via a widening conversion.
     *
     * @param obj the object to extract the {@code char} value
     * from
     * @return the value of the field converted to type {@code char}
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is inaccessible.
     * @exception IllegalArgumentException  if the specified object is not
     *              an instance of the class or interface declaring the
     *              underlying field (or a subclass or implementor
     *              thereof), or if the field value cannot be
     *              converted to the type {@code char} by a
     *              widening conversion.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see Field#get
     */
    @CallerSensitive
    public char getChar(Object obj)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L490">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L491">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L494">        return getFieldAccessor(obj).getChar(obj);</span>
    }

    /**
     * Gets the value of a static or instance field of type
     * {@code short} or of another primitive type convertible to
     * type {@code short} via a widening conversion.
     *
     * @param obj the object to extract the {@code short} value
     * from
     * @return the value of the field converted to type {@code short}
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is inaccessible.
     * @exception IllegalArgumentException  if the specified object is not
     *              an instance of the class or interface declaring the
     *              underlying field (or a subclass or implementor
     *              thereof), or if the field value cannot be
     *              converted to the type {@code short} by a
     *              widening conversion.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#get
     */
    @CallerSensitive
    public short getShort(Object obj)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L527">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L528">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L531">        return getFieldAccessor(obj).getShort(obj);</span>
    }

    /**
     * Gets the value of a static or instance field of type
     * {@code int} or of another primitive type convertible to
     * type {@code int} via a widening conversion.
     *
     * @param obj the object to extract the {@code int} value
     * from
     * @return the value of the field converted to type {@code int}
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is inaccessible.
     * @exception IllegalArgumentException  if the specified object is not
     *              an instance of the class or interface declaring the
     *              underlying field (or a subclass or implementor
     *              thereof), or if the field value cannot be
     *              converted to the type {@code int} by a
     *              widening conversion.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#get
     */
    @CallerSensitive
    public int getInt(Object obj)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="fc bfc" id="L562" title="All 2 branches covered.">        if (!override) {</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="fc" id="L564">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="fc" id="L565">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L568">        return getFieldAccessor(obj).getInt(obj);</span>
    }

    /**
     * Gets the value of a static or instance field of type
     * {@code long} or of another primitive type convertible to
     * type {@code long} via a widening conversion.
     *
     * @param obj the object to extract the {@code long} value
     * from
     * @return the value of the field converted to type {@code long}
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is inaccessible.
     * @exception IllegalArgumentException  if the specified object is not
     *              an instance of the class or interface declaring the
     *              underlying field (or a subclass or implementor
     *              thereof), or if the field value cannot be
     *              converted to the type {@code long} by a
     *              widening conversion.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#get
     */
    @CallerSensitive
    public long getLong(Object obj)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L601">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L602">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L605">        return getFieldAccessor(obj).getLong(obj);</span>
    }

    /**
     * Gets the value of a static or instance field of type
     * {@code float} or of another primitive type convertible to
     * type {@code float} via a widening conversion.
     *
     * @param obj the object to extract the {@code float} value
     * from
     * @return the value of the field converted to type {@code float}
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is inaccessible.
     * @exception IllegalArgumentException  if the specified object is not
     *              an instance of the class or interface declaring the
     *              underlying field (or a subclass or implementor
     *              thereof), or if the field value cannot be
     *              converted to the type {@code float} by a
     *              widening conversion.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see Field#get
     */
    @CallerSensitive
    public float getFloat(Object obj)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L638">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L639">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L642">        return getFieldAccessor(obj).getFloat(obj);</span>
    }

    /**
     * Gets the value of a static or instance field of type
     * {@code double} or of another primitive type convertible to
     * type {@code double} via a widening conversion.
     *
     * @param obj the object to extract the {@code double} value
     * from
     * @return the value of the field converted to type {@code double}
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is inaccessible.
     * @exception IllegalArgumentException  if the specified object is not
     *              an instance of the class or interface declaring the
     *              underlying field (or a subclass or implementor
     *              thereof), or if the field value cannot be
     *              converted to the type {@code double} by a
     *              widening conversion.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#get
     */
    @CallerSensitive
    public double getDouble(Object obj)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L675">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L676">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L679">        return getFieldAccessor(obj).getDouble(obj);</span>
    }

    /**
     * Sets the field represented by this {@code Field} object on the
     * specified object argument to the specified new value. The new
     * value is automatically unwrapped if the underlying field has a
     * primitive type.
     *
     * &lt;p&gt;The operation proceeds as follows:
     *
     * &lt;p&gt;If the underlying field is static, the {@code obj} argument is
     * ignored; it may be null.
     *
     * &lt;p&gt;Otherwise the underlying field is an instance field.  If the
     * specified object argument is null, the method throws a
     * {@code NullPointerException}.  If the specified object argument is not
     * an instance of the class or interface declaring the underlying
     * field, the method throws an {@code IllegalArgumentException}.
     *
     * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
     * the underlying field is inaccessible, the method throws an
     * {@code IllegalAccessException}.
     *
     * &lt;p&gt;If the underlying field is final, the method throws an
     * {@code IllegalAccessException} unless {@code setAccessible(true)}
     * has succeeded for this {@code Field} object
     * and the field is non-static. Setting a final field in this way
     * is meaningful only during deserialization or reconstruction of
     * instances of classes with blank final fields, before they are
     * made available for access by other parts of a program. Use in
     * any other context may have unpredictable effects, including cases
     * in which other parts of a program continue to use the original
     * value of this field.
     *
     * &lt;p&gt;If the underlying field is of a primitive type, an unwrapping
     * conversion is attempted to convert the new value to a value of
     * a primitive type.  If this attempt fails, the method throws an
     * {@code IllegalArgumentException}.
     *
     * &lt;p&gt;If, after possible unwrapping, the new value cannot be
     * converted to the type of the underlying field by an identity or
     * widening conversion, the method throws an
     * {@code IllegalArgumentException}.
     *
     * &lt;p&gt;If the underlying field is static, the class that declared the
     * field is initialized if it has not already been initialized.
     *
     * &lt;p&gt;The field is set to the possibly unwrapped and widened new value.
     *
     * &lt;p&gt;If the field is hidden in the type of {@code obj},
     * the field's value is set according to the preceding rules.
     *
     * @param obj the object whose field should be modified
     * @param value the new value for the field of {@code obj}
     * being modified
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is either inaccessible or final.
     * @exception IllegalArgumentException  if the specified object is not an
     *              instance of the class or interface declaring the underlying
     *              field (or a subclass or implementor thereof),
     *              or if an unwrapping conversion fails.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     */
    @CallerSensitive
    public void set(Object obj, Object value)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="fc bfc" id="L752" title="All 2 branches covered.">        if (!override) {</span>
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="fc" id="L754">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="fc" id="L755">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L758">        getFieldAccessor(obj).set(obj, value);</span>
<span class="fc" id="L759">    }</span>

    /**
     * Sets the value of a field as a {@code boolean} on the specified object.
     * This method is equivalent to
     * {@code set(obj, zObj)},
     * where {@code zObj} is a {@code Boolean} object and
     * {@code zObj.booleanValue() == z}.
     *
     * @param obj the object whose field should be modified
     * @param z   the new value for the field of {@code obj}
     * being modified
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is either inaccessible or final.
     * @exception IllegalArgumentException  if the specified object is not an
     *              instance of the class or interface declaring the underlying
     *              field (or a subclass or implementor thereof),
     *              or if an unwrapping conversion fails.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#set
     */
    @CallerSensitive
    public void setBoolean(Object obj, boolean z)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L791">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L792">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L795">        getFieldAccessor(obj).setBoolean(obj, z);</span>
<span class="fc" id="L796">    }</span>

    /**
     * Sets the value of a field as a {@code byte} on the specified object.
     * This method is equivalent to
     * {@code set(obj, bObj)},
     * where {@code bObj} is a {@code Byte} object and
     * {@code bObj.byteValue() == b}.
     *
     * @param obj the object whose field should be modified
     * @param b   the new value for the field of {@code obj}
     * being modified
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is either inaccessible or final.
     * @exception IllegalArgumentException  if the specified object is not an
     *              instance of the class or interface declaring the underlying
     *              field (or a subclass or implementor thereof),
     *              or if an unwrapping conversion fails.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#set
     */
    @CallerSensitive
    public void setByte(Object obj, byte b)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L828">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L829">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L832">        getFieldAccessor(obj).setByte(obj, b);</span>
<span class="fc" id="L833">    }</span>

    /**
     * Sets the value of a field as a {@code char} on the specified object.
     * This method is equivalent to
     * {@code set(obj, cObj)},
     * where {@code cObj} is a {@code Character} object and
     * {@code cObj.charValue() == c}.
     *
     * @param obj the object whose field should be modified
     * @param c   the new value for the field of {@code obj}
     * being modified
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is either inaccessible or final.
     * @exception IllegalArgumentException  if the specified object is not an
     *              instance of the class or interface declaring the underlying
     *              field (or a subclass or implementor thereof),
     *              or if an unwrapping conversion fails.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#set
     */
    @CallerSensitive
    public void setChar(Object obj, char c)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L865">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L866">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L869">        getFieldAccessor(obj).setChar(obj, c);</span>
<span class="fc" id="L870">    }</span>

    /**
     * Sets the value of a field as a {@code short} on the specified object.
     * This method is equivalent to
     * {@code set(obj, sObj)},
     * where {@code sObj} is a {@code Short} object and
     * {@code sObj.shortValue() == s}.
     *
     * @param obj the object whose field should be modified
     * @param s   the new value for the field of {@code obj}
     * being modified
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is either inaccessible or final.
     * @exception IllegalArgumentException  if the specified object is not an
     *              instance of the class or interface declaring the underlying
     *              field (or a subclass or implementor thereof),
     *              or if an unwrapping conversion fails.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#set
     */
    @CallerSensitive
    public void setShort(Object obj, short s)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L902">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L903">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L906">        getFieldAccessor(obj).setShort(obj, s);</span>
<span class="fc" id="L907">    }</span>

    /**
     * Sets the value of a field as an {@code int} on the specified object.
     * This method is equivalent to
     * {@code set(obj, iObj)},
     * where {@code iObj} is a {@code Integer} object and
     * {@code iObj.intValue() == i}.
     *
     * @param obj the object whose field should be modified
     * @param i   the new value for the field of {@code obj}
     * being modified
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is either inaccessible or final.
     * @exception IllegalArgumentException  if the specified object is not an
     *              instance of the class or interface declaring the underlying
     *              field (or a subclass or implementor thereof),
     *              or if an unwrapping conversion fails.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#set
     */
    @CallerSensitive
    public void setInt(Object obj, int i)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L939">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L940">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L943">        getFieldAccessor(obj).setInt(obj, i);</span>
<span class="fc" id="L944">    }</span>

    /**
     * Sets the value of a field as a {@code long} on the specified object.
     * This method is equivalent to
     * {@code set(obj, lObj)},
     * where {@code lObj} is a {@code Long} object and
     * {@code lObj.longValue() == l}.
     *
     * @param obj the object whose field should be modified
     * @param l   the new value for the field of {@code obj}
     * being modified
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is either inaccessible or final.
     * @exception IllegalArgumentException  if the specified object is not an
     *              instance of the class or interface declaring the underlying
     *              field (or a subclass or implementor thereof),
     *              or if an unwrapping conversion fails.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#set
     */
    @CallerSensitive
    public void setLong(Object obj, long l)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L974" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L976">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L977">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L980">        getFieldAccessor(obj).setLong(obj, l);</span>
<span class="fc" id="L981">    }</span>

    /**
     * Sets the value of a field as a {@code float} on the specified object.
     * This method is equivalent to
     * {@code set(obj, fObj)},
     * where {@code fObj} is a {@code Float} object and
     * {@code fObj.floatValue() == f}.
     *
     * @param obj the object whose field should be modified
     * @param f   the new value for the field of {@code obj}
     * being modified
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is either inaccessible or final.
     * @exception IllegalArgumentException  if the specified object is not an
     *              instance of the class or interface declaring the underlying
     *              field (or a subclass or implementor thereof),
     *              or if an unwrapping conversion fails.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#set
     */
    @CallerSensitive
    public void setFloat(Object obj, float f)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L1013">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L1014">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L1017">        getFieldAccessor(obj).setFloat(obj, f);</span>
<span class="fc" id="L1018">    }</span>

    /**
     * Sets the value of a field as a {@code double} on the specified object.
     * This method is equivalent to
     * {@code set(obj, dObj)},
     * where {@code dObj} is a {@code Double} object and
     * {@code dObj.doubleValue() == d}.
     *
     * @param obj the object whose field should be modified
     * @param d   the new value for the field of {@code obj}
     * being modified
     *
     * @exception IllegalAccessException    if this {@code Field} object
     *              is enforcing Java language access control and the underlying
     *              field is either inaccessible or final.
     * @exception IllegalArgumentException  if the specified object is not an
     *              instance of the class or interface declaring the underlying
     *              field (or a subclass or implementor thereof),
     *              or if an unwrapping conversion fails.
     * @exception NullPointerException      if the specified object is null
     *              and the field is an instance field.
     * @exception ExceptionInInitializerError if the initialization provoked
     *              by this method fails.
     * @see       Field#set
     */
    @CallerSensitive
    public void setDouble(Object obj, double d)
        throws IllegalArgumentException, IllegalAccessException
    {
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">        if (!override) {</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="nc" id="L1050">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc" id="L1051">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L1054">        getFieldAccessor(obj).setDouble(obj, d);</span>
<span class="fc" id="L1055">    }</span>

    // security check is done before calling this method
    private FieldAccessor getFieldAccessor(Object obj)
        throws IllegalAccessException
    {
<span class="fc" id="L1061">        boolean ov = override;</span>
<span class="fc bfc" id="L1062" title="All 2 branches covered.">        FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor;</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">        return (a != null) ? a : acquireFieldAccessor(ov);</span>
    }

    // NOTE that there is no synchronization used here. It is correct
    // (though not efficient) to generate more than one FieldAccessor
    // for a given Field. However, avoiding synchronization will
    // probably make the implementation more scalable.
    private FieldAccessor acquireFieldAccessor(boolean overrideFinalCheck) {
        // First check to see if one has been created yet, and take it
        // if so
<span class="fc" id="L1073">        FieldAccessor tmp = null;</span>
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">        if (root != null) tmp = root.getFieldAccessor(overrideFinalCheck);</span>
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">        if (tmp != null) {</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">            if (overrideFinalCheck)</span>
<span class="nc" id="L1077">                overrideFieldAccessor = tmp;</span>
            else
<span class="nc" id="L1079">                fieldAccessor = tmp;</span>
        } else {
            // Otherwise fabricate one and propagate it up to the root
<span class="fc" id="L1082">            tmp = reflectionFactory.newFieldAccessor(this, overrideFinalCheck);</span>
<span class="fc" id="L1083">            setFieldAccessor(tmp, overrideFinalCheck);</span>
        }

<span class="fc" id="L1086">        return tmp;</span>
    }

    // Returns FieldAccessor for this Field object, not looking up
    // the chain to the root
    private FieldAccessor getFieldAccessor(boolean overrideFinalCheck) {
<span class="fc bfc" id="L1092" title="All 2 branches covered.">        return (overrideFinalCheck)? overrideFieldAccessor : fieldAccessor;</span>
    }

    // Sets the FieldAccessor for this Field object and
    // (recursively) its root
    private void setFieldAccessor(FieldAccessor accessor, boolean overrideFinalCheck) {
<span class="fc bfc" id="L1098" title="All 2 branches covered.">        if (overrideFinalCheck)</span>
<span class="fc" id="L1099">            overrideFieldAccessor = accessor;</span>
        else
<span class="fc" id="L1101">            fieldAccessor = accessor;</span>
        // Propagate up
<span class="fc bfc" id="L1103" title="All 2 branches covered.">        if (root != null) {</span>
<span class="fc" id="L1104">            root.setFieldAccessor(accessor, overrideFinalCheck);</span>
        }
<span class="fc" id="L1106">    }</span>

    /**
     * @throws NullPointerException {@inheritDoc}
     * @since 1.5
     */
    public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="fc" id="L1113">        Objects.requireNonNull(annotationClass);</span>
<span class="fc" id="L1114">        return annotationClass.cast(declaredAnnotations().get(annotationClass));</span>
    }

    /**
     * {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    public &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) {
<span class="fc" id="L1124">        Objects.requireNonNull(annotationClass);</span>

<span class="fc" id="L1126">        return AnnotationSupport.getDirectlyAndIndirectlyPresent(declaredAnnotations(), annotationClass);</span>
    }

    /**
     * {@inheritDoc}
     */
    public Annotation[] getDeclaredAnnotations()  {
<span class="fc" id="L1133">        return AnnotationParser.toArray(declaredAnnotations());</span>
    }

    private transient Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;

    private synchronized  Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations() {
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        if (declaredAnnotations == null) {</span>
<span class="fc" id="L1140">            declaredAnnotations = AnnotationParser.parseAnnotations(</span>
<span class="fc" id="L1141">                annotations, sun.misc.SharedSecrets.getJavaLangAccess().</span>
<span class="fc" id="L1142">                getConstantPool(getDeclaringClass()),</span>
<span class="fc" id="L1143">                getDeclaringClass());</span>
        }
<span class="fc" id="L1145">        return declaredAnnotations;</span>
    }

    private native byte[] getTypeAnnotationBytes0();

    /**
     * Returns an AnnotatedType object that represents the use of a type to specify
     * the declared type of the field represented by this Field.
     * @return an object representing the declared type of the field
     * represented by this Field
     *
     * @since 1.8
     */
    public AnnotatedType getAnnotatedType() {
<span class="fc" id="L1159">        return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),</span>
<span class="fc" id="L1160">                                                       sun.misc.SharedSecrets.getJavaLangAccess().</span>
<span class="fc" id="L1161">                                                           getConstantPool(getDeclaringClass()),</span>
                                                       this,
<span class="fc" id="L1163">                                                       getDeclaringClass(),</span>
<span class="fc" id="L1164">                                                       getGenericType(),</span>
                                                       TypeAnnotation.TypeAnnotationTarget.FIELD);
}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>