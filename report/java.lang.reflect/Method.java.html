<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Method.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang.reflect</a> &gt; <span class="el_source">Method.java</span></div><h1>Method.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.reflect;

import sun.reflect.CallerSensitive;
import sun.reflect.MethodAccessor;
import sun.reflect.Reflection;
import sun.reflect.generics.repository.MethodRepository;
import sun.reflect.generics.factory.CoreReflectionFactory;
import sun.reflect.generics.factory.GenericsFactory;
import sun.reflect.generics.scope.MethodScope;
import sun.reflect.annotation.AnnotationType;
import sun.reflect.annotation.AnnotationParser;
import java.lang.annotation.Annotation;
import java.lang.annotation.AnnotationFormatError;
import java.nio.ByteBuffer;

/**
 * A {@code Method} provides information about, and access to, a single method
 * on a class or interface.  The reflected method may be a class method
 * or an instance method (including an abstract method).
 *
 * &lt;p&gt;A {@code Method} permits widening conversions to occur when matching the
 * actual parameters to invoke with the underlying method's formal
 * parameters, but it throws an {@code IllegalArgumentException} if a
 * narrowing conversion would occur.
 *
 * @see Member
 * @see java.lang.Class
 * @see java.lang.Class#getMethods()
 * @see java.lang.Class#getMethod(String, Class[])
 * @see java.lang.Class#getDeclaredMethods()
 * @see java.lang.Class#getDeclaredMethod(String, Class[])
 *
 * @author Kenneth Russell
 * @author Nakul Saraiya
 */
public final class Method extends Executable {
    private Class&lt;?&gt;            clazz;
    private int                 slot;
    // This is guaranteed to be interned by the VM in the 1.4
    // reflection implementation
    private String              name;
    private Class&lt;?&gt;            returnType;
    private Class&lt;?&gt;[]          parameterTypes;
    private Class&lt;?&gt;[]          exceptionTypes;
    private int                 modifiers;
    // Generics and annotations support
    private transient String              signature;
    // generic info repository; lazily initialized
    private transient MethodRepository genericInfo;
    private byte[]              annotations;
    private byte[]              parameterAnnotations;
    private byte[]              annotationDefault;
    private volatile MethodAccessor methodAccessor;
    // For sharing of MethodAccessors. This branching structure is
    // currently only two levels deep (i.e., one root Method and
    // potentially many Method objects pointing to it.)
    private Method              root;

    // Generics infrastructure
<span class="fc" id="L85">    private String getGenericSignature() {return signature;}</span>

    // Accessor for factory
    private GenericsFactory getFactory() {
        // create scope and factory
<span class="fc" id="L90">        return CoreReflectionFactory.make(this, MethodScope.make(this));</span>
    }

    // Accessor for generic info repository
    @Override
    MethodRepository getGenericInfo() {
        // lazily initialize repository if necessary
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (genericInfo == null) {</span>
            // create and cache generic info repository
<span class="fc" id="L99">            genericInfo = MethodRepository.make(getGenericSignature(),</span>
<span class="fc" id="L100">                                                getFactory());</span>
        }
<span class="fc" id="L102">        return genericInfo; //return cached repository</span>
    }

    /**
     * Package-private constructor used by ReflectAccess to enable
     * instantiation of these objects in Java code from the java.lang
     * package via sun.reflect.LangReflectAccess.
     */
    Method(Class&lt;?&gt; declaringClass,
           String name,
           Class&lt;?&gt;[] parameterTypes,
           Class&lt;?&gt; returnType,
           Class&lt;?&gt;[] checkedExceptions,
           int modifiers,
           int slot,
           String signature,
           byte[] annotations,
           byte[] parameterAnnotations,
<span class="fc" id="L120">           byte[] annotationDefault) {</span>
<span class="fc" id="L121">        this.clazz = declaringClass;</span>
<span class="fc" id="L122">        this.name = name;</span>
<span class="fc" id="L123">        this.parameterTypes = parameterTypes;</span>
<span class="fc" id="L124">        this.returnType = returnType;</span>
<span class="fc" id="L125">        this.exceptionTypes = checkedExceptions;</span>
<span class="fc" id="L126">        this.modifiers = modifiers;</span>
<span class="fc" id="L127">        this.slot = slot;</span>
<span class="fc" id="L128">        this.signature = signature;</span>
<span class="fc" id="L129">        this.annotations = annotations;</span>
<span class="fc" id="L130">        this.parameterAnnotations = parameterAnnotations;</span>
<span class="fc" id="L131">        this.annotationDefault = annotationDefault;</span>
<span class="fc" id="L132">    }</span>

    /**
     * Package-private routine (exposed to java.lang.Class via
     * ReflectAccess) which returns a copy of this Method. The copy's
     * &quot;root&quot; field points to this Method.
     */
    Method copy() {
        // This routine enables sharing of MethodAccessor objects
        // among Method objects which refer to the same underlying
        // method in the VM. (All of this contortion is only necessary
        // because of the &quot;accessibility&quot; bit in AccessibleObject,
        // which implicitly requires that new java.lang.reflect
        // objects be fabricated for each reflective call on Class
        // objects.)
<span class="fc" id="L147">        Method res = new Method(clazz, name, parameterTypes, returnType,</span>
                                exceptionTypes, modifiers, slot, signature,
                                annotations, parameterAnnotations, annotationDefault);
<span class="fc" id="L150">        res.root = this;</span>
        // Might as well eagerly propagate this if already present
<span class="fc" id="L152">        res.methodAccessor = methodAccessor;</span>
<span class="fc" id="L153">        return res;</span>
    }

    @Override
    boolean hasGenericInformation() {
<span class="fc bfc" id="L158" title="All 2 branches covered.">        return (getGenericSignature() != null);</span>
    }

    @Override
    byte[] getAnnotationBytes() {
<span class="fc" id="L163">        return annotations;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Class&lt;?&gt; getDeclaringClass() {
<span class="fc" id="L171">        return clazz;</span>
    }

    /**
     * Returns the name of the method represented by this {@code Method}
     * object, as a {@code String}.
     */
    @Override
    public String getName() {
<span class="fc" id="L180">        return name;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getModifiers() {
<span class="fc" id="L188">        return modifiers;</span>
    }

    /**
     * {@inheritDoc}
     * @throws GenericSignatureFormatError {@inheritDoc}
     * @since 1.5
     */
    @Override
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public TypeVariable&lt;Method&gt;[] getTypeParameters() {
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (getGenericSignature() != null)</span>
<span class="fc" id="L200">            return (TypeVariable&lt;Method&gt;[])getGenericInfo().getTypeParameters();</span>
        else
<span class="fc" id="L202">            return (TypeVariable&lt;Method&gt;[])new TypeVariable[0];</span>
    }

    /**
     * Returns a {@code Class} object that represents the formal return type
     * of the method represented by this {@code Method} object.
     *
     * @return the return type for the method this object represents
     */
    public Class&lt;?&gt; getReturnType() {
<span class="fc" id="L212">        return returnType;</span>
    }

    /**
     * Returns a {@code Type} object that represents the formal return
     * type of the method represented by this {@code Method} object.
     *
     * &lt;p&gt;If the return type is a parameterized type,
     * the {@code Type} object returned must accurately reflect
     * the actual type parameters used in the source code.
     *
     * &lt;p&gt;If the return type is a type variable or a parameterized type, it
     * is created. Otherwise, it is resolved.
     *
     * @return  a {@code Type} object that represents the formal return
     *     type of the underlying  method
     * @throws GenericSignatureFormatError
     *     if the generic method signature does not conform to the format
     *     specified in
     *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
     * @throws TypeNotPresentException if the underlying method's
     *     return type refers to a non-existent type declaration
     * @throws MalformedParameterizedTypeException if the
     *     underlying method's return typed refers to a parameterized
     *     type that cannot be instantiated for any reason
     * @since 1.5
     */
    public Type getGenericReturnType() {
<span class="fc bfc" id="L240" title="All 2 branches covered.">      if (getGenericSignature() != null) {</span>
<span class="fc" id="L241">        return getGenericInfo().getReturnType();</span>
<span class="fc" id="L242">      } else { return getReturnType();}</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Class&lt;?&gt;[] getParameterTypes() {
<span class="fc" id="L250">        return parameterTypes.clone();</span>
    }

    /**
     * {@inheritDoc}
     */
<span class="fc" id="L256">    public int getParameterCount() { return parameterTypes.length; }</span>


    /**
     * {@inheritDoc}
     * @throws GenericSignatureFormatError {@inheritDoc}
     * @throws TypeNotPresentException {@inheritDoc}
     * @throws MalformedParameterizedTypeException {@inheritDoc}
     * @since 1.5
     */
    @Override
    public Type[] getGenericParameterTypes() {
<span class="fc" id="L268">        return super.getGenericParameterTypes();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Class&lt;?&gt;[] getExceptionTypes() {
<span class="fc" id="L276">        return exceptionTypes.clone();</span>
    }

    /**
     * {@inheritDoc}
     * @throws GenericSignatureFormatError {@inheritDoc}
     * @throws TypeNotPresentException {@inheritDoc}
     * @throws MalformedParameterizedTypeException {@inheritDoc}
     * @since 1.5
     */
    @Override
    public Type[] getGenericExceptionTypes() {
<span class="fc" id="L288">        return super.getGenericExceptionTypes();</span>
    }

    /**
     * Compares this {@code Method} against the specified object.  Returns
     * true if the objects are the same.  Two {@code Methods} are the same if
     * they were declared by the same class and have the same name
     * and formal parameter types and return type.
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L298" title="1 of 4 branches missed.">        if (obj != null &amp;&amp; obj instanceof Method) {</span>
<span class="fc" id="L299">            Method other = (Method)obj;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">            if ((getDeclaringClass() == other.getDeclaringClass())</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">                &amp;&amp; (getName() == other.getName())) {</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">                if (!returnType.equals(other.getReturnType()))</span>
<span class="fc" id="L303">                    return false;</span>
<span class="fc" id="L304">                return equalParamTypes(parameterTypes, other.parameterTypes);</span>
            }
        }
<span class="fc" id="L307">        return false;</span>
    }

    /**
     * Returns a hashcode for this {@code Method}.  The hashcode is computed
     * as the exclusive-or of the hashcodes for the underlying
     * method's declaring class name and the method's name.
     */
    public int hashCode() {
<span class="fc" id="L316">        return getDeclaringClass().getName().hashCode() ^ getName().hashCode();</span>
    }

    /**
     * Returns a string describing this {@code Method}.  The string is
     * formatted as the method access modifiers, if any, followed by
     * the method return type, followed by a space, followed by the
     * class declaring the method, followed by a period, followed by
     * the method name, followed by a parenthesized, comma-separated
     * list of the method's formal parameter types. If the method
     * throws checked exceptions, the parameter list is followed by a
     * space, followed by the word throws followed by a
     * comma-separated list of the thrown exception types.
     * For example:
     * &lt;pre&gt;
     *    public boolean java.lang.Object.equals(java.lang.Object)
     * &lt;/pre&gt;
     *
     * &lt;p&gt;The access modifiers are placed in canonical order as
     * specified by &quot;The Java Language Specification&quot;.  This is
     * {@code public}, {@code protected} or {@code private} first,
     * and then other modifiers in the following order:
     * {@code abstract}, {@code default}, {@code static}, {@code final},
     * {@code synchronized}, {@code native}, {@code strictfp}.
     *
     * @return a string describing this {@code Method}
     *
     * @jls 8.4.3 Method Modifiers
     */
    public String toString() {
<span class="fc" id="L346">        return sharedToString(Modifier.methodModifiers(),</span>
<span class="fc" id="L347">                              isDefault(),</span>
                              parameterTypes,
                              exceptionTypes);
    }

    @Override
    void specificToStringHeader(StringBuilder sb) {
<span class="fc" id="L354">        sb.append(getReturnType().getTypeName()).append(' ');</span>
<span class="fc" id="L355">        sb.append(getDeclaringClass().getTypeName()).append('.');</span>
<span class="fc" id="L356">        sb.append(getName());</span>
<span class="fc" id="L357">    }</span>

    /**
     * Returns a string describing this {@code Method}, including
     * type parameters.  The string is formatted as the method access
     * modifiers, if any, followed by an angle-bracketed
     * comma-separated list of the method's type parameters, if any,
     * followed by the method's generic return type, followed by a
     * space, followed by the class declaring the method, followed by
     * a period, followed by the method name, followed by a
     * parenthesized, comma-separated list of the method's generic
     * formal parameter types.
     *
     * If this method was declared to take a variable number of
     * arguments, instead of denoting the last parameter as
     * &quot;&lt;tt&gt;&lt;i&gt;Type&lt;/i&gt;[]&lt;/tt&gt;&quot;, it is denoted as
     * &quot;&lt;tt&gt;&lt;i&gt;Type&lt;/i&gt;...&lt;/tt&gt;&quot;.
     *
     * A space is used to separate access modifiers from one another
     * and from the type parameters or return type.  If there are no
     * type parameters, the type parameter list is elided; if the type
     * parameter list is present, a space separates the list from the
     * class name.  If the method is declared to throw exceptions, the
     * parameter list is followed by a space, followed by the word
     * throws followed by a comma-separated list of the generic thrown
     * exception types.
     *
     * &lt;p&gt;The access modifiers are placed in canonical order as
     * specified by &quot;The Java Language Specification&quot;.  This is
     * {@code public}, {@code protected} or {@code private} first,
     * and then other modifiers in the following order:
     * {@code abstract}, {@code default}, {@code static}, {@code final},
     * {@code synchronized}, {@code native}, {@code strictfp}.
     *
     * @return a string describing this {@code Method},
     * include type parameters
     *
     * @since 1.5
     *
     * @jls 8.4.3 Method Modifiers
     */
    @Override
    public String toGenericString() {
<span class="fc" id="L400">        return sharedToGenericString(Modifier.methodModifiers(), isDefault());</span>
    }

    @Override
    void specificToGenericStringHeader(StringBuilder sb) {
<span class="fc" id="L405">        Type genRetType = getGenericReturnType();</span>
<span class="fc" id="L406">        sb.append(genRetType.getTypeName()).append(' ');</span>
<span class="fc" id="L407">        sb.append(getDeclaringClass().getTypeName()).append('.');</span>
<span class="fc" id="L408">        sb.append(getName());</span>
<span class="fc" id="L409">    }</span>

    /**
     * Invokes the underlying method represented by this {@code Method}
     * object, on the specified object with the specified parameters.
     * Individual parameters are automatically unwrapped to match
     * primitive formal parameters, and both primitive and reference
     * parameters are subject to method invocation conversions as
     * necessary.
     *
     * &lt;p&gt;If the underlying method is static, then the specified {@code obj}
     * argument is ignored. It may be null.
     *
     * &lt;p&gt;If the number of formal parameters required by the underlying method is
     * 0, the supplied {@code args} array may be of length 0 or null.
     *
     * &lt;p&gt;If the underlying method is an instance method, it is invoked
     * using dynamic method lookup as documented in The Java Language
     * Specification, Second Edition, section 15.12.4.4; in particular,
     * overriding based on the runtime type of the target object will occur.
     *
     * &lt;p&gt;If the underlying method is static, the class that declared
     * the method is initialized if it has not already been initialized.
     *
     * &lt;p&gt;If the method completes normally, the value it returns is
     * returned to the caller of invoke; if the value has a primitive
     * type, it is first appropriately wrapped in an object. However,
     * if the value has the type of an array of a primitive type, the
     * elements of the array are &lt;i&gt;not&lt;/i&gt; wrapped in objects; in
     * other words, an array of primitive type is returned.  If the
     * underlying method return type is void, the invocation returns
     * null.
     *
     * @param obj  the object the underlying method is invoked from
     * @param args the arguments used for the method call
     * @return the result of dispatching the method represented by
     * this object on {@code obj} with parameters
     * {@code args}
     *
     * @exception IllegalAccessException    if this {@code Method} object
     *              is enforcing Java language access control and the underlying
     *              method is inaccessible.
     * @exception IllegalArgumentException  if the method is an
     *              instance method and the specified object argument
     *              is not an instance of the class or interface
     *              declaring the underlying method (or of a subclass
     *              or implementor thereof); if the number of actual
     *              and formal parameters differ; if an unwrapping
     *              conversion for primitive arguments fails; or if,
     *              after possible unwrapping, a parameter value
     *              cannot be converted to the corresponding formal
     *              parameter type by a method invocation conversion.
     * @exception InvocationTargetException if the underlying method
     *              throws an exception.
     * @exception NullPointerException      if the specified object is null
     *              and the method is an instance method.
     * @exception ExceptionInInitializerError if the initialization
     * provoked by this method fails.
     */
    @CallerSensitive
    public Object invoke(Object obj, Object... args)
        throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException
    {
<span class="fc bfc" id="L473" title="All 2 branches covered.">        if (!override) {</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span>
<span class="fc" id="L475">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="fc" id="L476">                checkAccess(caller, clazz, obj, modifiers);</span>
            }
        }
<span class="fc" id="L479">        MethodAccessor ma = methodAccessor;             // read volatile</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">        if (ma == null) {</span>
<span class="fc" id="L481">            ma = acquireMethodAccessor();</span>
        }
<span class="fc" id="L483">        return ma.invoke(obj, args);</span>
    }

    /**
     * Returns {@code true} if this method is a bridge
     * method; returns {@code false} otherwise.
     *
     * @return true if and only if this method is a bridge
     * method as defined by the Java Language Specification.
     * @since 1.5
     */
    public boolean isBridge() {
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">        return (getModifiers() &amp; Modifier.BRIDGE) != 0;</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.5
     */
    @Override
    public boolean isVarArgs() {
<span class="fc" id="L504">        return super.isVarArgs();</span>
    }

    /**
     * {@inheritDoc}
     * @jls 13.1 The Form of a Binary
     * @since 1.5
     */
    @Override
    public boolean isSynthetic() {
<span class="fc" id="L514">        return super.isSynthetic();</span>
    }

    /**
     * Returns {@code true} if this method is a default
     * method; returns {@code false} otherwise.
     *
     * A default method is a public non-abstract instance method, that
     * is, a non-static method with a body, declared in an interface
     * type.
     *
     * @return true if and only if this method is a default
     * method as defined by the Java Language Specification.
     * @since 1.8
     */
    public boolean isDefault() {
        // Default methods are public non-abstract instance methods
        // declared in an interface.
<span class="fc bfc" id="L532" title="All 2 branches covered.">        return ((getModifiers() &amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) ==</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">                Modifier.PUBLIC) &amp;&amp; getDeclaringClass().isInterface();</span>
    }

    // NOTE that there is no synchronization used here. It is correct
    // (though not efficient) to generate more than one MethodAccessor
    // for a given Method. However, avoiding synchronization will
    // probably make the implementation more scalable.
    private MethodAccessor acquireMethodAccessor() {
        // First check to see if one has been created yet, and take it
        // if so
<span class="fc" id="L543">        MethodAccessor tmp = null;</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">        if (root != null) tmp = root.getMethodAccessor();</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">        if (tmp != null) {</span>
<span class="fc" id="L546">            methodAccessor = tmp;</span>
        } else {
            // Otherwise fabricate one and propagate it up to the root
<span class="fc" id="L549">            tmp = reflectionFactory.newMethodAccessor(this);</span>
<span class="fc" id="L550">            setMethodAccessor(tmp);</span>
        }

<span class="fc" id="L553">        return tmp;</span>
    }

    // Returns MethodAccessor for this Method object, not looking up
    // the chain to the root
    MethodAccessor getMethodAccessor() {
<span class="fc" id="L559">        return methodAccessor;</span>
    }

    // Sets the MethodAccessor for this Method object and
    // (recursively) its root
    void setMethodAccessor(MethodAccessor accessor) {
<span class="fc" id="L565">        methodAccessor = accessor;</span>
        // Propagate up
<span class="fc bfc" id="L567" title="All 2 branches covered.">        if (root != null) {</span>
<span class="fc" id="L568">            root.setMethodAccessor(accessor);</span>
        }
<span class="fc" id="L570">    }</span>

    /**
     * Returns the default value for the annotation member represented by
     * this {@code Method} instance.  If the member is of a primitive type,
     * an instance of the corresponding wrapper type is returned. Returns
     * null if no default is associated with the member, or if the method
     * instance does not represent a declared member of an annotation type.
     *
     * @return the default value for the annotation member represented
     *     by this {@code Method} instance.
     * @throws TypeNotPresentException if the annotation is of type
     *     {@link Class} and no definition can be found for the
     *     default class value.
     * @since  1.5
     */
    public Object getDefaultValue() {
<span class="fc bfc" id="L587" title="All 2 branches covered.">        if  (annotationDefault == null)</span>
<span class="fc" id="L588">            return null;</span>
<span class="fc" id="L589">        Class&lt;?&gt; memberType = AnnotationType.invocationHandlerReturnType(</span>
<span class="fc" id="L590">            getReturnType());</span>
<span class="fc" id="L591">        Object result = AnnotationParser.parseMemberValue(</span>
<span class="fc" id="L592">            memberType, ByteBuffer.wrap(annotationDefault),</span>
<span class="fc" id="L593">            sun.misc.SharedSecrets.getJavaLangAccess().</span>
<span class="fc" id="L594">                getConstantPool(getDeclaringClass()),</span>
<span class="fc" id="L595">            getDeclaringClass());</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        if (result instanceof sun.reflect.annotation.ExceptionProxy)</span>
<span class="nc" id="L597">            throw new AnnotationFormatError(&quot;Invalid default: &quot; + this);</span>
<span class="fc" id="L598">        return result;</span>
    }

    /**
     * {@inheritDoc}
     * @throws NullPointerException  {@inheritDoc}
     * @since 1.5
     */
    public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="fc" id="L607">        return super.getAnnotation(annotationClass);</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.5
     */
    public Annotation[] getDeclaredAnnotations()  {
<span class="fc" id="L615">        return super.getDeclaredAnnotations();</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.5
     */
    @Override
    public Annotation[][] getParameterAnnotations() {
<span class="fc" id="L624">        return sharedGetParameterAnnotations(parameterTypes, parameterAnnotations);</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.8
     */
    @Override
    public AnnotatedType getAnnotatedReturnType() {
<span class="fc" id="L633">        return getAnnotatedReturnType0(getGenericReturnType());</span>
    }

    @Override
    void handleParameterNumberMismatch(int resultLength, int numParameters) {
<span class="nc" id="L638">        throw new AnnotationFormatError(&quot;Parameter annotations don't match number of parameters&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>