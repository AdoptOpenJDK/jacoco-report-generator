<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Proxy.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.lang.reflect</a> &gt; <span class="el_source">Proxy.java</span></div><h1>Proxy.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.reflect;

import java.lang.ref.WeakReference;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Arrays;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.BiFunction;
import sun.misc.ProxyGenerator;
import sun.misc.VM;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;
import sun.reflect.misc.ReflectUtil;
import sun.security.util.SecurityConstants;

/**
 * {@code Proxy} provides static methods for creating dynamic proxy
 * classes and instances, and it is also the superclass of all
 * dynamic proxy classes created by those methods.
 *
 * &lt;p&gt;To create a proxy for some interface {@code Foo}:
 * &lt;pre&gt;
 *     InvocationHandler handler = new MyInvocationHandler(...);
 *     Class&amp;lt;?&amp;gt; proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);
 *     Foo f = (Foo) proxyClass.getConstructor(InvocationHandler.class).
 *                     newInstance(handler);
 * &lt;/pre&gt;
 * or more simply:
 * &lt;pre&gt;
 *     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
 *                                          new Class&amp;lt;?&amp;gt;[] { Foo.class },
 *                                          handler);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;A &lt;i&gt;dynamic proxy class&lt;/i&gt; (simply referred to as a &lt;i&gt;proxy
 * class&lt;/i&gt; below) is a class that implements a list of interfaces
 * specified at runtime when the class is created, with behavior as
 * described below.
 *
 * A &lt;i&gt;proxy interface&lt;/i&gt; is such an interface that is implemented
 * by a proxy class.
 *
 * A &lt;i&gt;proxy instance&lt;/i&gt; is an instance of a proxy class.
 *
 * Each proxy instance has an associated &lt;i&gt;invocation handler&lt;/i&gt;
 * object, which implements the interface {@link InvocationHandler}.
 * A method invocation on a proxy instance through one of its proxy
 * interfaces will be dispatched to the {@link InvocationHandler#invoke
 * invoke} method of the instance's invocation handler, passing the proxy
 * instance, a {@code java.lang.reflect.Method} object identifying
 * the method that was invoked, and an array of type {@code Object}
 * containing the arguments.  The invocation handler processes the
 * encoded method invocation as appropriate and the result that it
 * returns will be returned as the result of the method invocation on
 * the proxy instance.
 *
 * &lt;p&gt;A proxy class has the following properties:
 *
 * &lt;ul&gt;
 * &lt;li&gt;Proxy classes are &lt;em&gt;public, final, and not abstract&lt;/em&gt; if
 * all proxy interfaces are public.&lt;/li&gt;
 *
 * &lt;li&gt;Proxy classes are &lt;em&gt;non-public, final, and not abstract&lt;/em&gt; if
 * any of the proxy interfaces is non-public.&lt;/li&gt;
 *
 * &lt;li&gt;The unqualified name of a proxy class is unspecified.  The space
 * of class names that begin with the string {@code &quot;$Proxy&quot;}
 * should be, however, reserved for proxy classes.
 *
 * &lt;li&gt;A proxy class extends {@code java.lang.reflect.Proxy}.
 *
 * &lt;li&gt;A proxy class implements exactly the interfaces specified at its
 * creation, in the same order.
 *
 * &lt;li&gt;If a proxy class implements a non-public interface, then it will
 * be defined in the same package as that interface.  Otherwise, the
 * package of a proxy class is also unspecified.  Note that package
 * sealing will not prevent a proxy class from being successfully defined
 * in a particular package at runtime, and neither will classes already
 * defined by the same class loader and the same package with particular
 * signers.
 *
 * &lt;li&gt;Since a proxy class implements all of the interfaces specified at
 * its creation, invoking {@code getInterfaces} on its
 * {@code Class} object will return an array containing the same
 * list of interfaces (in the order specified at its creation), invoking
 * {@code getMethods} on its {@code Class} object will return
 * an array of {@code Method} objects that include all of the
 * methods in those interfaces, and invoking {@code getMethod} will
 * find methods in the proxy interfaces as would be expected.
 *
 * &lt;li&gt;The {@link Proxy#isProxyClass Proxy.isProxyClass} method will
 * return true if it is passed a proxy class-- a class returned by
 * {@code Proxy.getProxyClass} or the class of an object returned by
 * {@code Proxy.newProxyInstance}-- and false otherwise.
 *
 * &lt;li&gt;The {@code java.security.ProtectionDomain} of a proxy class
 * is the same as that of system classes loaded by the bootstrap class
 * loader, such as {@code java.lang.Object}, because the code for a
 * proxy class is generated by trusted system code.  This protection
 * domain will typically be granted
 * {@code java.security.AllPermission}.
 *
 * &lt;li&gt;Each proxy class has one public constructor that takes one argument,
 * an implementation of the interface {@link InvocationHandler}, to set
 * the invocation handler for a proxy instance.  Rather than having to use
 * the reflection API to access the public constructor, a proxy instance
 * can be also be created by calling the {@link Proxy#newProxyInstance
 * Proxy.newProxyInstance} method, which combines the actions of calling
 * {@link Proxy#getProxyClass Proxy.getProxyClass} with invoking the
 * constructor with an invocation handler.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;A proxy instance has the following properties:
 *
 * &lt;ul&gt;
 * &lt;li&gt;Given a proxy instance {@code proxy} and one of the
 * interfaces implemented by its proxy class {@code Foo}, the
 * following expression will return true:
 * &lt;pre&gt;
 *     {@code proxy instanceof Foo}
 * &lt;/pre&gt;
 * and the following cast operation will succeed (rather than throwing
 * a {@code ClassCastException}):
 * &lt;pre&gt;
 *     {@code (Foo) proxy}
 * &lt;/pre&gt;
 *
 * &lt;li&gt;Each proxy instance has an associated invocation handler, the one
 * that was passed to its constructor.  The static
 * {@link Proxy#getInvocationHandler Proxy.getInvocationHandler} method
 * will return the invocation handler associated with the proxy instance
 * passed as its argument.
 *
 * &lt;li&gt;An interface method invocation on a proxy instance will be
 * encoded and dispatched to the invocation handler's {@link
 * InvocationHandler#invoke invoke} method as described in the
 * documentation for that method.
 *
 * &lt;li&gt;An invocation of the {@code hashCode},
 * {@code equals}, or {@code toString} methods declared in
 * {@code java.lang.Object} on a proxy instance will be encoded and
 * dispatched to the invocation handler's {@code invoke} method in
 * the same manner as interface method invocations are encoded and
 * dispatched, as described above.  The declaring class of the
 * {@code Method} object passed to {@code invoke} will be
 * {@code java.lang.Object}.  Other public methods of a proxy
 * instance inherited from {@code java.lang.Object} are not
 * overridden by a proxy class, so invocations of those methods behave
 * like they do for instances of {@code java.lang.Object}.
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Methods Duplicated in Multiple Proxy Interfaces&lt;/h3&gt;
 *
 * &lt;p&gt;When two or more interfaces of a proxy class contain a method with
 * the same name and parameter signature, the order of the proxy class's
 * interfaces becomes significant.  When such a &lt;i&gt;duplicate method&lt;/i&gt;
 * is invoked on a proxy instance, the {@code Method} object passed
 * to the invocation handler will not necessarily be the one whose
 * declaring class is assignable from the reference type of the interface
 * that the proxy's method was invoked through.  This limitation exists
 * because the corresponding method implementation in the generated proxy
 * class cannot determine which interface it was invoked through.
 * Therefore, when a duplicate method is invoked on a proxy instance,
 * the {@code Method} object for the method in the foremost interface
 * that contains the method (either directly or inherited through a
 * superinterface) in the proxy class's list of interfaces is passed to
 * the invocation handler's {@code invoke} method, regardless of the
 * reference type through which the method invocation occurred.
 *
 * &lt;p&gt;If a proxy interface contains a method with the same name and
 * parameter signature as the {@code hashCode}, {@code equals},
 * or {@code toString} methods of {@code java.lang.Object},
 * when such a method is invoked on a proxy instance, the
 * {@code Method} object passed to the invocation handler will have
 * {@code java.lang.Object} as its declaring class.  In other words,
 * the public, non-final methods of {@code java.lang.Object}
 * logically precede all of the proxy interfaces for the determination of
 * which {@code Method} object to pass to the invocation handler.
 *
 * &lt;p&gt;Note also that when a duplicate method is dispatched to an
 * invocation handler, the {@code invoke} method may only throw
 * checked exception types that are assignable to one of the exception
 * types in the {@code throws} clause of the method in &lt;i&gt;all&lt;/i&gt; of
 * the proxy interfaces that it can be invoked through.  If the
 * {@code invoke} method throws a checked exception that is not
 * assignable to any of the exception types declared by the method in one
 * of the proxy interfaces that it can be invoked through, then an
 * unchecked {@code UndeclaredThrowableException} will be thrown by
 * the invocation on the proxy instance.  This restriction means that not
 * all of the exception types returned by invoking
 * {@code getExceptionTypes} on the {@code Method} object
 * passed to the {@code invoke} method can necessarily be thrown
 * successfully by the {@code invoke} method.
 *
 * @author      Peter Jones
 * @see         InvocationHandler
 * @since       1.3
 */
public class Proxy implements java.io.Serializable {

    private static final long serialVersionUID = -2222568056686623797L;

    /** parameter types of a proxy class constructor */
<span class="fc" id="L233">    private static final Class&lt;?&gt;[] constructorParams =</span>
        { InvocationHandler.class };

    /**
     * a cache of proxy classes
     */
    private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;
<span class="fc" id="L240">        proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());</span>

    /**
     * the invocation handler for this proxy instance.
     * @serial
     */
    protected InvocationHandler h;

    /**
     * Prohibits instantiation.
     */
<span class="nc" id="L251">    private Proxy() {</span>
<span class="nc" id="L252">    }</span>

    /**
     * Constructs a new {@code Proxy} instance from a subclass
     * (typically, a dynamic proxy class) with the specified value
     * for its invocation handler.
     *
     * @param  h the invocation handler for this proxy instance
     *
     * @throws NullPointerException if the given invocation handler, {@code h},
     *         is {@code null}.
     */
<span class="fc" id="L264">    protected Proxy(InvocationHandler h) {</span>
<span class="fc" id="L265">        Objects.requireNonNull(h);</span>
<span class="fc" id="L266">        this.h = h;</span>
<span class="fc" id="L267">    }</span>

    /**
     * Returns the {@code java.lang.Class} object for a proxy class
     * given a class loader and an array of interfaces.  The proxy class
     * will be defined by the specified class loader and will implement
     * all of the supplied interfaces.  If any of the given interfaces
     * is non-public, the proxy class will be non-public. If a proxy class
     * for the same permutation of interfaces has already been defined by the
     * class loader, then the existing proxy class will be returned; otherwise,
     * a proxy class for those interfaces will be generated dynamically
     * and defined by the class loader.
     *
     * &lt;p&gt;There are several restrictions on the parameters that may be
     * passed to {@code Proxy.getProxyClass}:
     *
     * &lt;ul&gt;
     * &lt;li&gt;All of the {@code Class} objects in the
     * {@code interfaces} array must represent interfaces, not
     * classes or primitive types.
     *
     * &lt;li&gt;No two elements in the {@code interfaces} array may
     * refer to identical {@code Class} objects.
     *
     * &lt;li&gt;All of the interface types must be visible by name through the
     * specified class loader.  In other words, for class loader
     * {@code cl} and every interface {@code i}, the following
     * expression must be true:
     * &lt;pre&gt;
     *     Class.forName(i.getName(), false, cl) == i
     * &lt;/pre&gt;
     *
     * &lt;li&gt;All non-public interfaces must be in the same package;
     * otherwise, it would not be possible for the proxy class to
     * implement all of the interfaces, regardless of what package it is
     * defined in.
     *
     * &lt;li&gt;For any set of member methods of the specified interfaces
     * that have the same signature:
     * &lt;ul&gt;
     * &lt;li&gt;If the return type of any of the methods is a primitive
     * type or void, then all of the methods must have that same
     * return type.
     * &lt;li&gt;Otherwise, one of the methods must have a return type that
     * is assignable to all of the return types of the rest of the
     * methods.
     * &lt;/ul&gt;
     *
     * &lt;li&gt;The resulting proxy class must not exceed any limits imposed
     * on classes by the virtual machine.  For example, the VM may limit
     * the number of interfaces that a class may implement to 65535; in
     * that case, the size of the {@code interfaces} array must not
     * exceed 65535.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If any of these restrictions are violated,
     * {@code Proxy.getProxyClass} will throw an
     * {@code IllegalArgumentException}.  If the {@code interfaces}
     * array argument or any of its elements are {@code null}, a
     * {@code NullPointerException} will be thrown.
     *
     * &lt;p&gt;Note that the order of the specified proxy interfaces is
     * significant: two requests for a proxy class with the same combination
     * of interfaces but in a different order will result in two distinct
     * proxy classes.
     *
     * @param   loader the class loader to define the proxy class
     * @param   interfaces the list of interfaces for the proxy class
     *          to implement
     * @return  a proxy class that is defined in the specified class loader
     *          and that implements the specified interfaces
     * @throws  IllegalArgumentException if any of the restrictions on the
     *          parameters that may be passed to {@code getProxyClass}
     *          are violated
     * @throws  SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present
     *          and any of the following conditions is met:
     *          &lt;ul&gt;
     *             &lt;li&gt; the given {@code loader} is {@code null} and
     *             the caller's class loader is not {@code null} and the
     *             invocation of {@link SecurityManager#checkPermission
     *             s.checkPermission} with
     *             {@code RuntimePermission(&quot;getClassLoader&quot;)} permission
     *             denies access.&lt;/li&gt;
     *             &lt;li&gt; for each proxy interface, {@code intf},
     *             the caller's class loader is not the same as or an
     *             ancestor of the class loader for {@code intf} and
     *             invocation of {@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to {@code intf}.&lt;/li&gt;
     *          &lt;/ul&gt;

     * @throws  NullPointerException if the {@code interfaces} array
     *          argument or any of its elements are {@code null}
     */
    @CallerSensitive
    public static Class&lt;?&gt; getProxyClass(ClassLoader loader,
                                         Class&lt;?&gt;... interfaces)
        throws IllegalArgumentException
    {
<span class="fc" id="L365">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if (sm != null) {</span>
<span class="fc" id="L367">            checkProxyAccess(Reflection.getCallerClass(), loader, interfaces);</span>
        }

<span class="fc" id="L370">        return getProxyClass0(loader, interfaces);</span>
    }

    /*
     * Check permissions required to create a Proxy class.
     *
     * To define a proxy class, it performs the access checks as in
     * Class.forName (VM will invoke ClassLoader.checkPackageAccess):
     * 1. &quot;getClassLoader&quot; permission check if loader == null
     * 2. checkPackageAccess on the interfaces it implements
     *
     * To get a constructor and new instance of a proxy class, it performs
     * the package access check on the interfaces it implements
     * as in Class.getConstructor.
     *
     * If an interface is non-public, the proxy class must be defined by
     * the defining loader of the interface.  If the caller's class loader
     * is not the same as the defining loader of the interface, the VM
     * will throw IllegalAccessError when the generated proxy class is
     * being defined via the defineClass0 method.
     */
    private static void checkProxyAccess(Class&lt;?&gt; caller,
                                         ClassLoader loader,
                                         Class&lt;?&gt;... interfaces)
    {
<span class="fc" id="L395">        SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (sm != null) {</span>
<span class="fc" id="L397">            ClassLoader ccl = caller.getClassLoader();</span>
<span class="fc bfc" id="L398" title="All 4 branches covered.">            if (VM.isSystemDomainLoader(loader) &amp;&amp; !VM.isSystemDomainLoader(ccl)) {</span>
<span class="fc" id="L399">                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span>
            }
<span class="fc" id="L401">            ReflectUtil.checkProxyPackageAccess(ccl, interfaces);</span>
        }
<span class="fc" id="L403">    }</span>

    /**
     * Generate a proxy class.  Must call the checkProxyAccess method
     * to perform permission checks before calling this.
     */
    private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,
                                           Class&lt;?&gt;... interfaces) {
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">        if (interfaces.length &gt; 65535) {</span>
<span class="nc" id="L412">            throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span>
        }

        // If the proxy class defined by the given loader implementing
        // the given interfaces exists, this will simply return the cached copy;
        // otherwise, it will create the proxy class via the ProxyClassFactory
<span class="fc" id="L418">        return proxyClassCache.get(loader, interfaces);</span>
    }

    /*
     * a key used for proxy class with 0 implemented interfaces
     */
<span class="fc" id="L424">    private static final Object key0 = new Object();</span>

    /*
     * Key1 and Key2 are optimized for the common use of dynamic proxies
     * that implement 1 or 2 interfaces.
     */

    /*
     * a key used for proxy class with 1 implemented interface
     */
    private static final class Key1 extends WeakReference&lt;Class&lt;?&gt;&gt; {
        private final int hash;

        Key1(Class&lt;?&gt; intf) {
<span class="fc" id="L438">            super(intf);</span>
<span class="fc" id="L439">            this.hash = intf.hashCode();</span>
<span class="fc" id="L440">        }</span>

        @Override
        public int hashCode() {
<span class="fc" id="L444">            return hash;</span>
        }

        @Override
        public boolean equals(Object obj) {
            Class&lt;?&gt; intf;
<span class="pc bpc" id="L450" title="2 of 4 branches missed.">            return this == obj ||</span>
                   obj != null &amp;&amp;
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">                   obj.getClass() == Key1.class &amp;&amp;</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">                   (intf = get()) != null &amp;&amp;</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">                   intf == ((Key1) obj).get();</span>
        }
    }

    /*
     * a key used for proxy class with 2 implemented interfaces
     */
    private static final class Key2 extends WeakReference&lt;Class&lt;?&gt;&gt; {
        private final int hash;
        private final WeakReference&lt;Class&lt;?&gt;&gt; ref2;

        Key2(Class&lt;?&gt; intf1, Class&lt;?&gt; intf2) {
<span class="fc" id="L466">            super(intf1);</span>
<span class="fc" id="L467">            hash = 31 * intf1.hashCode() + intf2.hashCode();</span>
<span class="fc" id="L468">            ref2 = new WeakReference&lt;Class&lt;?&gt;&gt;(intf2);</span>
<span class="fc" id="L469">        }</span>

        @Override
        public int hashCode() {
<span class="fc" id="L473">            return hash;</span>
        }

        @Override
        public boolean equals(Object obj) {
            Class&lt;?&gt; intf1, intf2;
<span class="pc bpc" id="L479" title="2 of 4 branches missed.">            return this == obj ||</span>
                   obj != null &amp;&amp;
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">                   obj.getClass() == Key2.class &amp;&amp;</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">                   (intf1 = get()) != null &amp;&amp;</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">                   intf1 == ((Key2) obj).get() &amp;&amp;</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">                   (intf2 = ref2.get()) != null &amp;&amp;</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">                   intf2 == ((Key2) obj).ref2.get();</span>
        }
    }

    /*
     * a key used for proxy class with any number of implemented interfaces
     * (used here for 3 or more only)
     */
    private static final class KeyX {
        private final int hash;
        private final WeakReference&lt;Class&lt;?&gt;&gt;[] refs;

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L498">        KeyX(Class&lt;?&gt;[] interfaces) {</span>
<span class="fc" id="L499">            hash = Arrays.hashCode(interfaces);</span>
<span class="fc" id="L500">            refs = (WeakReference&lt;Class&lt;?&gt;&gt;[])new WeakReference&lt;?&gt;[interfaces.length];</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">            for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="fc" id="L502">                refs[i] = new WeakReference&lt;&gt;(interfaces[i]);</span>
            }
<span class="fc" id="L504">        }</span>

        @Override
        public int hashCode() {
<span class="fc" id="L508">            return hash;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L513" title="2 of 4 branches missed.">            return this == obj ||</span>
                   obj != null &amp;&amp;
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">                   obj.getClass() == KeyX.class &amp;&amp;</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">                   equals(refs, ((KeyX) obj).refs);</span>
        }

        private static boolean equals(WeakReference&lt;Class&lt;?&gt;&gt;[] refs1,
                                      WeakReference&lt;Class&lt;?&gt;&gt;[] refs2) {
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">            if (refs1.length != refs2.length) {</span>
<span class="nc" id="L522">                return false;</span>
            }
<span class="fc bfc" id="L524" title="All 2 branches covered.">            for (int i = 0; i &lt; refs1.length; i++) {</span>
<span class="fc" id="L525">                Class&lt;?&gt; intf = refs1[i].get();</span>
<span class="pc bpc" id="L526" title="2 of 4 branches missed.">                if (intf == null || intf != refs2[i].get()) {</span>
<span class="nc" id="L527">                    return false;</span>
                }
            }
<span class="fc" id="L530">            return true;</span>
        }
    }

    /**
     * A function that maps an array of interfaces to an optimal key where
     * Class objects representing interfaces are weakly referenced.
     */
<span class="fc" id="L538">    private static final class KeyFactory</span>
        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt;
    {
        @Override
        public Object apply(ClassLoader classLoader, Class&lt;?&gt;[] interfaces) {
<span class="pc bpc" id="L543" title="1 of 4 branches missed.">            switch (interfaces.length) {</span>
<span class="fc" id="L544">                case 1: return new Key1(interfaces[0]); // the most frequent</span>
<span class="fc" id="L545">                case 2: return new Key2(interfaces[0], interfaces[1]);</span>
<span class="nc" id="L546">                case 0: return key0;</span>
<span class="fc" id="L547">                default: return new KeyX(interfaces);</span>
            }
        }
    }

    /**
     * A factory function that generates, defines and returns the proxy class given
     * the ClassLoader and array of interfaces.
     */
<span class="fc" id="L556">    private static final class ProxyClassFactory</span>
        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;
    {
        // prefix for all proxy class names
        private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;

        // next number to use for generation of unique proxy class names
<span class="fc" id="L563">        private static final AtomicLong nextUniqueNumber = new AtomicLong();</span>

        @Override
        public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {

<span class="fc" id="L568">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">            for (Class&lt;?&gt; intf : interfaces) {</span>
                /*
                 * Verify that the class loader resolves the name of this
                 * interface to the same Class object.
                 */
<span class="fc" id="L574">                Class&lt;?&gt; interfaceClass = null;</span>
                try {
<span class="fc" id="L576">                    interfaceClass = Class.forName(intf.getName(), false, loader);</span>
<span class="nc" id="L577">                } catch (ClassNotFoundException e) {</span>
<span class="fc" id="L578">                }</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">                if (interfaceClass != intf) {</span>
<span class="nc" id="L580">                    throw new IllegalArgumentException(</span>
                        intf + &quot; is not visible from class loader&quot;);
                }
                /*
                 * Verify that the Class object actually represents an
                 * interface.
                 */
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">                if (!interfaceClass.isInterface()) {</span>
<span class="nc" id="L588">                    throw new IllegalArgumentException(</span>
<span class="nc" id="L589">                        interfaceClass.getName() + &quot; is not an interface&quot;);</span>
                }
                /*
                 * Verify that this interface is not a duplicate.
                 */
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {</span>
<span class="nc" id="L595">                    throw new IllegalArgumentException(</span>
<span class="nc" id="L596">                        &quot;repeated interface: &quot; + interfaceClass.getName());</span>
                }
            }

<span class="fc" id="L600">            String proxyPkg = null;     // package to define proxy class in</span>
<span class="fc" id="L601">            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span>

            /*
             * Record the package of a non-public proxy interface so that the
             * proxy class will be defined in the same package.  Verify that
             * all non-public proxy interfaces are in the same package.
             */
<span class="fc bfc" id="L608" title="All 2 branches covered.">            for (Class&lt;?&gt; intf : interfaces) {</span>
<span class="fc" id="L609">                int flags = intf.getModifiers();</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">                if (!Modifier.isPublic(flags)) {</span>
<span class="fc" id="L611">                    accessFlags = Modifier.FINAL;</span>
<span class="fc" id="L612">                    String name = intf.getName();</span>
<span class="fc" id="L613">                    int n = name.lastIndexOf('.');</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">                    String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">                    if (proxyPkg == null) {</span>
<span class="fc" id="L616">                        proxyPkg = pkg;</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">                    } else if (!pkg.equals(proxyPkg)) {</span>
<span class="nc" id="L618">                        throw new IllegalArgumentException(</span>
                            &quot;non-public interfaces from different packages&quot;);
                    }
                }
            }

<span class="fc bfc" id="L624" title="All 2 branches covered.">            if (proxyPkg == null) {</span>
                // if no non-public proxy interfaces, use com.sun.proxy package
<span class="fc" id="L626">                proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span>
            }

            /*
             * Choose a name for the proxy class to generate.
             */
<span class="fc" id="L632">            long num = nextUniqueNumber.getAndIncrement();</span>
<span class="fc" id="L633">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</span>

            /*
             * Generate the specified proxy class.
             */
<span class="fc" id="L638">            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span>
                proxyName, interfaces, accessFlags);
            try {
<span class="fc" id="L641">                return defineClass0(loader, proxyName,</span>
                                    proxyClassFile, 0, proxyClassFile.length);
<span class="nc" id="L643">            } catch (ClassFormatError e) {</span>
                /*
                 * A ClassFormatError here means that (barring bugs in the
                 * proxy class generation code) there was some other
                 * invalid aspect of the arguments supplied to the proxy
                 * class creation (such as virtual machine limitations
                 * exceeded).
                 */
<span class="nc" id="L651">                throw new IllegalArgumentException(e.toString());</span>
            }
        }
    }

    /**
     * Returns an instance of a proxy class for the specified interfaces
     * that dispatches method invocations to the specified invocation
     * handler.
     *
     * &lt;p&gt;{@code Proxy.newProxyInstance} throws
     * {@code IllegalArgumentException} for the same reasons that
     * {@code Proxy.getProxyClass} does.
     *
     * @param   loader the class loader to define the proxy class
     * @param   interfaces the list of interfaces for the proxy class
     *          to implement
     * @param   h the invocation handler to dispatch method invocations to
     * @return  a proxy instance with the specified invocation handler of a
     *          proxy class that is defined by the specified class loader
     *          and that implements the specified interfaces
     * @throws  IllegalArgumentException if any of the restrictions on the
     *          parameters that may be passed to {@code getProxyClass}
     *          are violated
     * @throws  SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present
     *          and any of the following conditions is met:
     *          &lt;ul&gt;
     *          &lt;li&gt; the given {@code loader} is {@code null} and
     *               the caller's class loader is not {@code null} and the
     *               invocation of {@link SecurityManager#checkPermission
     *               s.checkPermission} with
     *               {@code RuntimePermission(&quot;getClassLoader&quot;)} permission
     *               denies access;&lt;/li&gt;
     *          &lt;li&gt; for each proxy interface, {@code intf},
     *               the caller's class loader is not the same as or an
     *               ancestor of the class loader for {@code intf} and
     *               invocation of {@link SecurityManager#checkPackageAccess
     *               s.checkPackageAccess()} denies access to {@code intf};&lt;/li&gt;
     *          &lt;li&gt; any of the given proxy interfaces is non-public and the
     *               caller class is not in the same {@linkplain Package runtime package}
     *               as the non-public interface and the invocation of
     *               {@link SecurityManager#checkPermission s.checkPermission} with
     *               {@code ReflectPermission(&quot;newProxyInPackage.{package name}&quot;)}
     *               permission denies access.&lt;/li&gt;
     *          &lt;/ul&gt;
     * @throws  NullPointerException if the {@code interfaces} array
     *          argument or any of its elements are {@code null}, or
     *          if the invocation handler, {@code h}, is
     *          {@code null}
     */
    @CallerSensitive
    public static Object newProxyInstance(ClassLoader loader,
                                          Class&lt;?&gt;[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
<span class="fc" id="L707">        Objects.requireNonNull(h);</span>

<span class="fc" id="L709">        final SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">        if (sm != null) {</span>
<span class="fc" id="L711">            checkProxyAccess(Reflection.getCallerClass(), loader, interfaces);</span>
        }

        /*
         * Look up or generate the designated proxy class.
         */
<span class="fc" id="L717">        Class&lt;?&gt; cl = getProxyClass0(loader, interfaces);</span>

        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
<span class="fc bfc" id="L723" title="All 2 branches covered.">            if (sm != null) {</span>
<span class="fc" id="L724">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span>
            }

<span class="fc" id="L727">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span>
<span class="fc" id="L728">            final InvocationHandler ih = h;</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">            if (!Modifier.isPublic(cl.getModifiers())) {</span>
<span class="fc" id="L730">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                    public Void run() {
<span class="fc" id="L732">                        cons.setAccessible(true);</span>
<span class="fc" id="L733">                        return null;</span>
                    }
                });
            }
<span class="fc" id="L737">            return cons.newInstance(new Object[]{h});</span>
<span class="nc" id="L738">        } catch (IllegalAccessException|InstantiationException e) {</span>
<span class="nc" id="L739">            throw new InternalError(e.toString(), e);</span>
<span class="nc" id="L740">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L741">            Throwable t = e.getCause();</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            if (t instanceof RuntimeException) {</span>
<span class="nc" id="L743">                throw (RuntimeException) t;</span>
            } else {
<span class="nc" id="L745">                throw new InternalError(t.toString(), t);</span>
            }
<span class="nc" id="L747">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L748">            throw new InternalError(e.toString(), e);</span>
        }
    }

    private static void checkNewProxyPermission(Class&lt;?&gt; caller, Class&lt;?&gt; proxyClass) {
<span class="fc" id="L753">        SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">        if (sm != null) {</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">            if (ReflectUtil.isNonPublicProxyClass(proxyClass)) {</span>
<span class="fc" id="L756">                ClassLoader ccl = caller.getClassLoader();</span>
<span class="fc" id="L757">                ClassLoader pcl = proxyClass.getClassLoader();</span>

                // do permission check if the caller is in a different runtime package
                // of the proxy class
<span class="fc" id="L761">                int n = proxyClass.getName().lastIndexOf('.');</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">                String pkg = (n == -1) ? &quot;&quot; : proxyClass.getName().substring(0, n);</span>

<span class="fc" id="L764">                n = caller.getName().lastIndexOf('.');</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">                String callerPkg = (n == -1) ? &quot;&quot; : caller.getName().substring(0, n);</span>

<span class="fc bfc" id="L767" title="All 4 branches covered.">                if (pcl != ccl || !pkg.equals(callerPkg)) {</span>
<span class="fc" id="L768">                    sm.checkPermission(new ReflectPermission(&quot;newProxyInPackage.&quot; + pkg));</span>
                }
            }
        }
<span class="fc" id="L772">    }</span>

    /**
     * Returns true if and only if the specified class was dynamically
     * generated to be a proxy class using the {@code getProxyClass}
     * method or the {@code newProxyInstance} method.
     *
     * &lt;p&gt;The reliability of this method is important for the ability
     * to use it to make security decisions, so its implementation should
     * not just test if the class in question extends {@code Proxy}.
     *
     * @param   cl the class to test
     * @return  {@code true} if the class is a proxy class and
     *          {@code false} otherwise
     * @throws  NullPointerException if {@code cl} is {@code null}
     */
    public static boolean isProxyClass(Class&lt;?&gt; cl) {
<span class="fc bfc" id="L789" title="All 4 branches covered.">        return Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl);</span>
    }

    /**
     * Returns the invocation handler for the specified proxy instance.
     *
     * @param   proxy the proxy instance to return the invocation handler for
     * @return  the invocation handler for the proxy instance
     * @throws  IllegalArgumentException if the argument is not a
     *          proxy instance
     * @throws  SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present
     *          and the caller's class loader is not the same as or an
     *          ancestor of the class loader for the invocation handler
     *          and invocation of {@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the invocation
     *          handler's class.
     */
    @CallerSensitive
    public static InvocationHandler getInvocationHandler(Object proxy)
        throws IllegalArgumentException
    {
        /*
         * Verify that the object is actually a proxy instance.
         */
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">        if (!isProxyClass(proxy.getClass())) {</span>
<span class="nc" id="L814">            throw new IllegalArgumentException(&quot;not a proxy instance&quot;);</span>
        }

<span class="fc" id="L817">        final Proxy p = (Proxy) proxy;</span>
<span class="fc" id="L818">        final InvocationHandler ih = p.h;</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">        if (System.getSecurityManager() != null) {</span>
<span class="fc" id="L820">            Class&lt;?&gt; ihClass = ih.getClass();</span>
<span class="fc" id="L821">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="fc bfc" id="L822" title="All 2 branches covered.">            if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),</span>
<span class="fc" id="L823">                                                    ihClass.getClassLoader()))</span>
            {
<span class="fc" id="L825">                ReflectUtil.checkPackageAccess(ihClass);</span>
            }
        }

<span class="fc" id="L829">        return ih;</span>
    }

    private static native Class&lt;?&gt; defineClass0(ClassLoader loader, String name,
                                                byte[] b, int off, int len);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>