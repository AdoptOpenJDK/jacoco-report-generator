<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Parameter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.lang.reflect</a> &gt; <span class="el_source">Parameter.java</span></div><h1>Parameter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.lang.reflect;

import java.lang.annotation.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import sun.reflect.annotation.AnnotationSupport;

/**
 * Information about method parameters.
 *
 * A {@code Parameter} provides information about method parameters,
 * including its name and modifiers.  It also provides an alternate
 * means of obtaining attributes for the parameter.
 *
 * @since 1.8
 */
public final class Parameter implements AnnotatedElement {

    private final String name;
    private final int modifiers;
    private final Executable executable;
    private final int index;

    /**
     * Package-private constructor for {@code Parameter}.
     *
     * If method parameter data is present in the classfile, then the
     * JVM creates {@code Parameter} objects directly.  If it is
     * absent, however, then {@code Executable} uses this constructor
     * to synthesize them.
     *
     * @param name The name of the parameter.
     * @param modifiers The modifier flags for the parameter.
     * @param executable The executable which defines this parameter.
     * @param index The index of the parameter.
     */
    Parameter(String name,
              int modifiers,
              Executable executable,
<span class="fc" id="L65">              int index) {</span>
<span class="fc" id="L66">        this.name = name;</span>
<span class="fc" id="L67">        this.modifiers = modifiers;</span>
<span class="fc" id="L68">        this.executable = executable;</span>
<span class="fc" id="L69">        this.index = index;</span>
<span class="fc" id="L70">    }</span>

    /**
     * Compares based on the executable and the index.
     *
     * @param obj The object to compare.
     * @return Whether or not this is equal to the argument.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L79" title="All 2 branches missed.">        if(obj instanceof Parameter) {</span>
<span class="nc" id="L80">            Parameter other = (Parameter)obj;</span>
<span class="nc bnc" id="L81" title="All 4 branches missed.">            return (other.executable.equals(executable) &amp;&amp;</span>
                    other.index == index);
        }
<span class="nc" id="L84">        return false;</span>
    }

    /**
     * Returns a hash code based on the executable's hash code and the
     * index.
     *
     * @return A hash code based on the executable's hash code.
     */
    public int hashCode() {
<span class="nc" id="L94">        return executable.hashCode() ^ index;</span>
    }

    /**
     * Returns true if the parameter has a name according to the class
     * file; returns false otherwise. Whether a parameter has a name
     * is determined by the {@literal MethodParameters} attribute of
     * the method which declares the parameter.
     *
     * @return true if and only if the parameter has a name according
     * to the class file.
     */
    public boolean isNamePresent() {
<span class="pc bpc" id="L107" title="3 of 4 branches missed.">        return executable.hasRealParameterData() &amp;&amp; name != null;</span>
    }

    /**
     * Returns a string describing this parameter.  The format is the
     * modifiers for the parameter, if any, in canonical order as
     * recommended by &lt;cite&gt;The Java&amp;trade; Language
     * Specification&lt;/cite&gt;, followed by the fully- qualified type of
     * the parameter (excluding the last [] if the parameter is
     * variable arity), followed by &quot;...&quot; if the parameter is variable
     * arity, followed by a space, followed by the name of the
     * parameter.
     *
     * @return A string representation of the parameter and associated
     * information.
     */
    public String toString() {
<span class="fc" id="L124">        final StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L125">        final Type type = getParameterizedType();</span>
<span class="fc" id="L126">        final String typename = type.getTypeName();</span>

<span class="fc" id="L128">        sb.append(Modifier.toString(getModifiers()));</span>

<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if(0 != modifiers)</span>
<span class="nc" id="L131">            sb.append(' ');</span>

<span class="fc bfc" id="L133" title="All 2 branches covered.">        if(isVarArgs())</span>
<span class="fc" id="L134">            sb.append(typename.replaceFirst(&quot;\\[\\]$&quot;, &quot;...&quot;));</span>
        else
<span class="fc" id="L136">            sb.append(typename);</span>

<span class="fc" id="L138">        sb.append(' ');</span>
<span class="fc" id="L139">        sb.append(getName());</span>

<span class="fc" id="L141">        return sb.toString();</span>
    }

    /**
     * Return the {@code Executable} which declares this parameter.
     *
     * @return The {@code Executable} declaring this parameter.
     */
    public Executable getDeclaringExecutable() {
<span class="fc" id="L150">        return executable;</span>
    }

    /**
     * Get the modifier flags for this the parameter represented by
     * this {@code Parameter} object.
     *
     * @return The modifier flags for this parameter.
     */
    public int getModifiers() {
<span class="fc" id="L160">        return modifiers;</span>
    }

    /**
     * Returns the name of the parameter.  If the parameter's name is
     * {@linkplain #isNamePresent() present}, then this method returns
     * the name provided by the class file. Otherwise, this method
     * synthesizes a name of the form argN, where N is the index of
     * the parameter in the descriptor of the method which declares
     * the parameter.
     *
     * @return The name of the parameter, either provided by the class
     *         file or synthesized if the class file does not provide
     *         a name.
     */
    public String getName() {
        // Note: empty strings as paramete names are now outlawed.
        // The .equals(&quot;&quot;) is for compatibility with current JVM
        // behavior.  It may be removed at some point.
<span class="pc bpc" id="L179" title="2 of 4 branches missed.">        if(name == null || name.equals(&quot;&quot;))</span>
<span class="nc" id="L180">            return &quot;arg&quot; + index;</span>
        else
<span class="fc" id="L182">            return name;</span>
    }

    // Package-private accessor to the real name field.
    String getRealName() {
<span class="nc" id="L187">        return name;</span>
    }

    /**
     * Returns a {@code Type} object that identifies the parameterized
     * type for the parameter represented by this {@code Parameter}
     * object.
     *
     * @return a {@code Type} object identifying the parameterized
     * type of the parameter represented by this object
     */
    public Type getParameterizedType() {
<span class="fc" id="L199">        Type tmp = parameterTypeCache;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (null == tmp) {</span>
<span class="fc" id="L201">            tmp = executable.getGenericParameterTypes()[index];</span>
<span class="fc" id="L202">            parameterTypeCache = tmp;</span>
        }

<span class="fc" id="L205">        return tmp;</span>
    }

<span class="fc" id="L208">    private transient volatile Type parameterTypeCache = null;</span>

    /**
     * Returns a {@code Class} object that identifies the
     * declared type for the parameter represented by this
     * {@code Parameter} object.
     *
     * @return a {@code Class} object identifying the declared
     * type of the parameter represented by this object
     */
    public Class&lt;?&gt; getType() {
<span class="fc" id="L219">        Class&lt;?&gt; tmp = parameterClassCache;</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (null == tmp) {</span>
<span class="fc" id="L221">            tmp = executable.getParameterTypes()[index];</span>
<span class="fc" id="L222">            parameterClassCache = tmp;</span>
        }
<span class="fc" id="L224">        return tmp;</span>
    }

    /**
     * Returns an AnnotatedType object that represents the use of a type to
     * specify the type of the formal parameter represented by this Parameter.
     *
     * @return an {@code AnnotatedType} object representing the use of a type
     *         to specify the type of the formal parameter represented by this
     *         Parameter
     */
    public AnnotatedType getAnnotatedType() {
        // no caching for now
<span class="fc" id="L237">        return executable.getAnnotatedParameterTypes()[index];</span>
    }

<span class="fc" id="L240">    private transient volatile Class&lt;?&gt; parameterClassCache = null;</span>

    /**
     * Returns {@code true} if this parameter is implicitly declared
     * in source code; returns {@code false} otherwise.
     *
     * @return true if and only if this parameter is implicitly
     * declared as defined by &lt;cite&gt;The Java&amp;trade; Language
     * Specification&lt;/cite&gt;.
     */
    public boolean isImplicit() {
<span class="nc" id="L251">        return Modifier.isMandated(getModifiers());</span>
    }

    /**
     * Returns {@code true} if this parameter is neither implicitly
     * nor explicitly declared in source code; returns {@code false}
     * otherwise.
     *
     * @jls 13.1 The Form of a Binary
     * @return true if and only if this parameter is a synthetic
     * construct as defined by
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
     */
    public boolean isSynthetic() {
<span class="nc" id="L265">        return Modifier.isSynthetic(getModifiers());</span>
    }

    /**
     * Returns {@code true} if this parameter represents a variable
     * argument list; returns {@code false} otherwise.
     *
     * @return {@code true} if an only if this parameter represents a
     * variable argument list.
     */
    public boolean isVarArgs() {
<span class="fc bfc" id="L276" title="All 2 branches covered.">        return executable.isVarArgs() &amp;&amp;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">            index == executable.getParameterCount() - 1;</span>
    }


    /**
     * {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */
    public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="nc" id="L286">        Objects.requireNonNull(annotationClass);</span>
<span class="nc" id="L287">        return annotationClass.cast(declaredAnnotations().get(annotationClass));</span>
    }

    /**
     * {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */
    @Override
    public &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) {
<span class="nc" id="L296">        Objects.requireNonNull(annotationClass);</span>

<span class="nc" id="L298">        return AnnotationSupport.getDirectlyAndIndirectlyPresent(declaredAnnotations(), annotationClass);</span>
    }

    /**
     * {@inheritDoc}
     */
    public Annotation[] getDeclaredAnnotations() {
<span class="nc" id="L305">        return executable.getParameterAnnotations()[index];</span>
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     */
    public &lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass) {
        // Only annotations on classes are inherited, for all other
        // objects getDeclaredAnnotation is the same as
        // getAnnotation.
<span class="nc" id="L315">        return getAnnotation(annotationClass);</span>
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     */
    @Override
    public &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass) {
        // Only annotations on classes are inherited, for all other
        // objects getDeclaredAnnotations is the same as
        // getAnnotations.
<span class="nc" id="L326">        return getAnnotationsByType(annotationClass);</span>
    }

    /**
     * {@inheritDoc}
     */
    public Annotation[] getAnnotations() {
<span class="nc" id="L333">        return getDeclaredAnnotations();</span>
    }

    private transient Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;

    private synchronized Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations() {
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if(null == declaredAnnotations) {</span>
<span class="nc" id="L340">            declaredAnnotations =</span>
                new HashMap&lt;Class&lt;? extends Annotation&gt;, Annotation&gt;();
<span class="nc" id="L342">            Annotation[] ann = getDeclaredAnnotations();</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            for(int i = 0; i &lt; ann.length; i++)</span>
<span class="nc" id="L344">                declaredAnnotations.put(ann[i].annotationType(), ann[i]);</span>
        }
<span class="nc" id="L346">        return declaredAnnotations;</span>
   }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>