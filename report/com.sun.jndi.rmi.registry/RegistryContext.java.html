<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RegistryContext.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jndi.rmi.registry</a> &gt; <span class="el_source">RegistryContext.java</span></div><h1>RegistryContext.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jndi.rmi.registry;


import java.util.Hashtable;
import java.util.Properties;
import java.rmi.*;
import java.rmi.server.*;
import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;

import javax.naming.*;
import javax.naming.spi.NamingManager;


/**
 * A RegistryContext is a context representing a remote RMI registry.
 *
 * @author Scott Seligman
 */


public class RegistryContext implements Context, Referenceable {

    private Hashtable&lt;String, Object&gt; environment;
    private Registry registry;
    private String host;
    private int port;
<span class="fc" id="L53">    private static final NameParser nameParser = new AtomicNameParser();</span>
    private static final String SOCKET_FACTORY = &quot;com.sun.jndi.rmi.factory.socket&quot;;

<span class="fc" id="L56">    Reference reference = null; // ref used to create this context, if any</span>

    // Environment property that, if set, indicates that a security
    // manager should be installed (if none is already in place).
    public static final String SECURITY_MGR =
            &quot;java.naming.rmi.security.manager&quot;;

    /**
     * Returns a context for the registry at a given host and port.
     * If &quot;host&quot; is null, uses default host.
     * If &quot;port&quot; is non-positive, uses default port.
     * Cloning of &quot;env&quot; is handled by caller; see comments within
     * RegistryContextFactory.getObjectInstance(), for example.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public RegistryContext(String host, int port, Hashtable&lt;?, ?&gt; env)
            throws NamingException
<span class="fc" id="L73">    {</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        environment = (env == null)</span>
                      ? new Hashtable&lt;String, Object&gt;(5)
                      : (Hashtable&lt;String, Object&gt;) env;
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        if (environment.get(SECURITY_MGR) != null) {</span>
<span class="nc" id="L78">            installSecurityMgr();</span>
        }

        // chop off '[' and ']' in an IPv6 literal address
<span class="pc bpc" id="L82" title="2 of 4 branches missed.">        if ((host != null) &amp;&amp; (host.charAt(0) == '[')) {</span>
<span class="nc" id="L83">            host = host.substring(1, host.length() - 1);</span>
        }

<span class="fc" id="L86">        RMIClientSocketFactory socketFactory =</span>
<span class="fc" id="L87">                (RMIClientSocketFactory) environment.get(SOCKET_FACTORY);</span>
<span class="fc" id="L88">        registry = getRegistry(host, port, socketFactory);</span>
<span class="fc" id="L89">        this.host = host;</span>
<span class="fc" id="L90">        this.port = port;</span>
<span class="fc" id="L91">    }</span>

    /**
     * Returns a clone of a registry context.  The context's private state
     * is independent of the original's (so closing one context, for example,
     * won't close the other).
     */
    // %%% Alternatively, this could be done with a clone() method.
    @SuppressWarnings(&quot;unchecked&quot;) // clone()
<span class="fc" id="L100">    RegistryContext(RegistryContext ctx) {</span>
<span class="fc" id="L101">        environment = (Hashtable&lt;String, Object&gt;)ctx.environment.clone();</span>
<span class="fc" id="L102">        registry = ctx.registry;</span>
<span class="fc" id="L103">        host = ctx.host;</span>
<span class="fc" id="L104">        port = ctx.port;</span>
<span class="fc" id="L105">        reference = ctx.reference;</span>
<span class="fc" id="L106">    }</span>

    protected void finalize() {
<span class="fc" id="L109">        close();</span>
<span class="fc" id="L110">    }</span>

    public Object lookup(Name name) throws NamingException {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (name.isEmpty()) {</span>
<span class="fc" id="L114">            return (new RegistryContext(this));</span>
        }
        Remote obj;
        try {
<span class="nc" id="L118">            obj = registry.lookup(name.get(0));</span>
<span class="nc" id="L119">        } catch (NotBoundException e) {</span>
<span class="nc" id="L120">            throw (new NameNotFoundException(name.get(0)));</span>
<span class="nc" id="L121">        } catch (RemoteException e) {</span>
<span class="nc" id="L122">            throw (NamingException)wrapRemoteException(e).fillInStackTrace();</span>
<span class="nc" id="L123">        }</span>
<span class="nc" id="L124">        return (decodeObject(obj, name.getPrefix(1)));</span>
    }

    public Object lookup(String name) throws NamingException {
<span class="nc" id="L128">        return lookup(new CompositeName(name));</span>
    }

    /**
     * If the object to be bound is both Remote and Referenceable, binds the
     * object itself, not its Reference.
     */
    public void bind(Name name, Object obj) throws NamingException {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (name.isEmpty()) {</span>
<span class="nc" id="L137">            throw (new InvalidNameException(</span>
                    &quot;RegistryContext: Cannot bind empty name&quot;));
        }
        try {
<span class="nc" id="L141">            registry.bind(name.get(0), encodeObject(obj, name.getPrefix(1)));</span>
<span class="nc" id="L142">        } catch (AlreadyBoundException e) {</span>
<span class="nc" id="L143">            NamingException ne = new NameAlreadyBoundException(name.get(0));</span>
<span class="nc" id="L144">            ne.setRootCause(e);</span>
<span class="nc" id="L145">            throw ne;</span>
<span class="nc" id="L146">        } catch (RemoteException e) {</span>
<span class="nc" id="L147">            throw (NamingException)wrapRemoteException(e).fillInStackTrace();</span>
<span class="nc" id="L148">        }</span>
<span class="nc" id="L149">    }</span>

    public void bind(String name, Object obj) throws NamingException {
<span class="nc" id="L152">        bind(new CompositeName(name), obj);</span>
<span class="nc" id="L153">    }</span>

    public void rebind(Name name, Object obj) throws NamingException {
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (name.isEmpty()) {</span>
<span class="nc" id="L157">            throw (new InvalidNameException(</span>
                    &quot;RegistryContext: Cannot rebind empty name&quot;));
        }
        try {
<span class="nc" id="L161">            registry.rebind(name.get(0), encodeObject(obj, name.getPrefix(1)));</span>
<span class="nc" id="L162">        } catch (RemoteException e) {</span>
<span class="nc" id="L163">            throw (NamingException)wrapRemoteException(e).fillInStackTrace();</span>
<span class="nc" id="L164">        }</span>
<span class="nc" id="L165">    }</span>

    public void rebind(String name, Object obj) throws NamingException {
<span class="nc" id="L168">        rebind(new CompositeName(name), obj);</span>
<span class="nc" id="L169">    }</span>

    public void unbind(Name name) throws NamingException {
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (name.isEmpty()) {</span>
<span class="nc" id="L173">            throw (new InvalidNameException(</span>
                    &quot;RegistryContext: Cannot unbind empty name&quot;));
        }
        try {
<span class="nc" id="L177">            registry.unbind(name.get(0));</span>
<span class="fc" id="L178">        } catch (NotBoundException e) {</span>
            // method is idempotent
<span class="nc" id="L180">        } catch (RemoteException e) {</span>
<span class="nc" id="L181">            throw (NamingException)wrapRemoteException(e).fillInStackTrace();</span>
<span class="pc" id="L182">        }</span>
<span class="fc" id="L183">    }</span>

    public void unbind(String name) throws NamingException {
<span class="fc" id="L186">        unbind(new CompositeName(name));</span>
<span class="fc" id="L187">    }</span>

    /**
     * Rename is implemented by this sequence of operations:
     * lookup, bind, unbind.  The sequence is not performed atomically.
     */
    public void rename(Name oldName, Name newName) throws NamingException {
<span class="nc" id="L194">        bind(newName, lookup(oldName));</span>
<span class="nc" id="L195">        unbind(oldName);</span>
<span class="nc" id="L196">    }</span>

    public void rename(String name, String newName) throws NamingException {
<span class="nc" id="L199">        rename(new CompositeName(name), new CompositeName(newName));</span>
<span class="nc" id="L200">    }</span>

    public NamingEnumeration&lt;NameClassPair&gt; list(Name name) throws
            NamingException {
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (!name.isEmpty()) {</span>
<span class="nc" id="L205">            throw (new InvalidNameException(</span>
                    &quot;RegistryContext: can only list \&quot;\&quot;&quot;));
        }
        try {
<span class="nc" id="L209">            String[] names = registry.list();</span>
<span class="nc" id="L210">            return (new NameClassPairEnumeration(names));</span>
<span class="nc" id="L211">        } catch (RemoteException e) {</span>
<span class="nc" id="L212">            throw (NamingException)wrapRemoteException(e).fillInStackTrace();</span>
        }
    }

    public NamingEnumeration&lt;NameClassPair&gt; list(String name) throws
            NamingException {
<span class="nc" id="L218">        return list(new CompositeName(name));</span>
    }

    public NamingEnumeration&lt;Binding&gt; listBindings(Name name)
            throws NamingException
    {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (!name.isEmpty()) {</span>
<span class="nc" id="L225">            throw (new InvalidNameException(</span>
                    &quot;RegistryContext: can only list \&quot;\&quot;&quot;));
        }
        try {
<span class="nc" id="L229">            String[] names = registry.list();</span>
<span class="nc" id="L230">            return (new BindingEnumeration(this, names));</span>
<span class="nc" id="L231">        } catch (RemoteException e) {</span>
<span class="nc" id="L232">            throw (NamingException)wrapRemoteException(e).fillInStackTrace();</span>
        }
    }

    public NamingEnumeration&lt;Binding&gt; listBindings(String name) throws
            NamingException {
<span class="nc" id="L238">        return listBindings(new CompositeName(name));</span>
    }

    public void destroySubcontext(Name name) throws NamingException {
<span class="nc" id="L242">        throw (new OperationNotSupportedException());</span>
    }

    public void destroySubcontext(String name) throws NamingException {
<span class="nc" id="L246">        throw (new OperationNotSupportedException());</span>
    }

    public Context createSubcontext(Name name) throws NamingException {
<span class="nc" id="L250">        throw (new OperationNotSupportedException());</span>
    }

    public Context createSubcontext(String name) throws NamingException {
<span class="nc" id="L254">        throw (new OperationNotSupportedException());</span>
    }

    public Object lookupLink(Name name) throws NamingException {
<span class="nc" id="L258">        return lookup(name);</span>
    }

    public Object lookupLink(String name) throws NamingException {
<span class="nc" id="L262">        return lookup(name);</span>
    }

    public NameParser getNameParser(Name name) throws NamingException {
<span class="nc" id="L266">        return nameParser;</span>
    }

    public NameParser getNameParser(String name) throws NamingException {
<span class="nc" id="L270">        return nameParser;</span>
    }

    public Name composeName(Name name, Name prefix) throws NamingException {
<span class="nc" id="L274">        Name result = (Name)prefix.clone();</span>
<span class="nc" id="L275">        return result.addAll(name);</span>
    }

    public String composeName(String name, String prefix)
            throws NamingException
    {
<span class="nc" id="L281">        return composeName(new CompositeName(name),</span>
<span class="nc" id="L282">                           new CompositeName(prefix)).toString();</span>
    }

    public Object removeFromEnvironment(String propName)
            throws NamingException
    {
<span class="nc" id="L288">        return environment.remove(propName);</span>
    }

    public Object addToEnvironment(String propName, Object propVal)
            throws NamingException
    {
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (propName.equals(SECURITY_MGR)) {</span>
<span class="nc" id="L295">            installSecurityMgr();</span>
        }
<span class="nc" id="L297">        return environment.put(propName, propVal);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;) // clone()
    public Hashtable&lt;String, Object&gt; getEnvironment() throws NamingException {
<span class="nc" id="L302">        return (Hashtable&lt;String, Object&gt;)environment.clone();</span>
    }

    public void close() {
<span class="fc" id="L306">        environment = null;</span>
<span class="fc" id="L307">        registry = null;</span>
        // &amp;&amp;&amp; If we were caching registry connections, we would probably
        // uncache this one now.
<span class="fc" id="L310">    }</span>

    public String getNameInNamespace() {
<span class="nc" id="L313">        return &quot;&quot;; // Registry has an empty name</span>
    }

    /**
     * Returns an RMI registry reference for this context.
     *&lt;p&gt;
     * If this context was created from a reference, that reference is
     * returned.  Otherwise, an exception is thrown if the registry's
     * host is &quot;localhost&quot; or the default (null).  Although this could
     * possibly make for a valid reference, it's far more likely to be
     * an easily made error.
     *
     * @see RegistryContextFactory
     */
    public Reference getReference() throws NamingException {
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (reference != null) {</span>
<span class="nc" id="L329">            return (Reference)reference.clone();  // %%% clone the addrs too?</span>
        }
<span class="nc bnc" id="L331" title="All 4 branches missed.">        if (host == null || host.equals(&quot;localhost&quot;)) {</span>
<span class="nc" id="L332">            throw (new ConfigurationException(</span>
                    &quot;Cannot create a reference for an RMI registry whose &quot; +
                    &quot;host was unspecified or specified as \&quot;localhost\&quot;&quot;));
        }
<span class="nc" id="L336">        String url = &quot;rmi://&quot;;</span>

        // Enclose IPv6 literal address in '[' and ']'
<span class="nc bnc" id="L339" title="All 2 branches missed.">        url = (host.indexOf(&quot;:&quot;) &gt; -1) ? url + &quot;[&quot; + host + &quot;]&quot; :</span>
                                         url + host;
<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (port &gt; 0) {</span>
<span class="nc" id="L342">            url += &quot;:&quot; + Integer.toString(port);</span>
        }
<span class="nc" id="L344">        RefAddr addr = new StringRefAddr(RegistryContextFactory.ADDRESS_TYPE,</span>
                                         url);
<span class="nc" id="L346">        return (new Reference(RegistryContext.class.getName(),</span>
                              addr,
<span class="nc" id="L348">                              RegistryContextFactory.class.getName(),</span>
                              null));
    }


    /**
     * Wrap a RemoteException inside a NamingException.
     */
    public static NamingException wrapRemoteException(RemoteException re) {

        NamingException ne;

<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (re instanceof ConnectException) {</span>
<span class="nc" id="L361">            ne = new ServiceUnavailableException();</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">        } else if (re instanceof AccessException) {</span>
<span class="nc" id="L364">            ne = new NoPermissionException();</span>

<span class="nc bnc" id="L366" title="All 6 branches missed.">        } else if (re instanceof StubNotFoundException ||</span>
                   re instanceof UnknownHostException ||
                   re instanceof SocketSecurityException) {
<span class="nc" id="L369">            ne = new ConfigurationException();</span>

<span class="nc bnc" id="L371" title="All 10 branches missed.">        } else if (re instanceof ExportException ||</span>
                   re instanceof ConnectIOException ||
                   re instanceof MarshalException ||
                   re instanceof UnmarshalException ||
                   re instanceof NoSuchObjectException) {
<span class="nc" id="L376">            ne = new CommunicationException();</span>

<span class="nc bnc" id="L378" title="All 4 branches missed.">        } else if (re instanceof ServerException &amp;&amp;</span>
                   re.detail instanceof RemoteException) {
<span class="nc" id="L380">            ne = wrapRemoteException((RemoteException)re.detail);</span>

        } else {
<span class="nc" id="L383">            ne = new NamingException();</span>
        }
<span class="nc" id="L385">        ne.setRootCause(re);</span>
<span class="nc" id="L386">        return ne;</span>
    }

    /**
     * Returns the registry at a given host, port and socket factory.
     * If &quot;host&quot; is null, uses default host.
     * If &quot;port&quot; is non-positive, uses default port.
     * If &quot;socketFactory&quot; is null, uses the default socket.
     */
    private static Registry getRegistry(String host, int port,
                RMIClientSocketFactory socketFactory)
            throws NamingException
    {
        // %%% We could cache registry connections here.  The transport layer
        // may already reuse connections.
        try {
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">            if (socketFactory == null) {</span>
<span class="fc" id="L403">                return LocateRegistry.getRegistry(host, port);</span>
            } else {
<span class="nc" id="L405">                return LocateRegistry.getRegistry(host, port, socketFactory);</span>
            }
<span class="nc" id="L407">        } catch (RemoteException e) {</span>
<span class="nc" id="L408">            throw (NamingException)wrapRemoteException(e).fillInStackTrace();</span>
        }
    }

    /**
     * Attempts to install a security manager if none is currently in
     * place.
     */
    private static void installSecurityMgr() {

        try {
<span class="nc" id="L419">            System.setSecurityManager(new RMISecurityManager());</span>
<span class="nc" id="L420">        } catch (Exception e) {</span>
<span class="nc" id="L421">        }</span>
<span class="nc" id="L422">    }</span>

    /**
     * Encodes an object prior to binding it in the registry.  First,
     * NamingManager.getStateToBind() is invoked.  If the resulting
     * object is Remote, it is returned.  If it is a Reference or
     * Referenceable, the reference is wrapped in a Remote object.
     * Otherwise, an exception is thrown.
     *
     * @param name      The object's name relative to this context.
     */
    private Remote encodeObject(Object obj, Name name)
            throws NamingException, RemoteException
    {
<span class="nc" id="L436">        obj = NamingManager.getStateToBind(obj, name, this, environment);</span>

<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (obj instanceof Remote) {</span>
<span class="nc" id="L439">            return (Remote)obj;</span>
        }
<span class="nc bnc" id="L441" title="All 2 branches missed.">        if (obj instanceof Reference) {</span>
<span class="nc" id="L442">            return (new ReferenceWrapper((Reference)obj));</span>
        }
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (obj instanceof Referenceable) {</span>
<span class="nc" id="L445">            return (new ReferenceWrapper(((Referenceable)obj).getReference()));</span>
        }
<span class="nc" id="L447">        throw (new IllegalArgumentException(</span>
                &quot;RegistryContext: &quot; +
                &quot;object to bind must be Remote, Reference, or Referenceable&quot;));
    }

    /**
     * Decodes an object that has been retrieved from the registry.
     * First, if the object is a RemoteReference, the Reference is
     * unwrapped.  Then, NamingManager.getObjectInstance() is invoked.
     *
     * @param name      The object's name relative to this context.
     */
    private Object decodeObject(Remote r, Name name) throws NamingException {
        try {
<span class="nc bnc" id="L461" title="All 2 branches missed.">            Object obj = (r instanceof RemoteReference)</span>
<span class="nc" id="L462">                        ? ((RemoteReference)r).getReference()</span>
                        : (Object)r;
<span class="nc" id="L464">            return NamingManager.getObjectInstance(obj, name, this,</span>
                                                   environment);
<span class="nc" id="L466">        } catch (NamingException e) {</span>
<span class="nc" id="L467">            throw e;</span>
<span class="nc" id="L468">        } catch (RemoteException e) {</span>
<span class="nc" id="L469">            throw (NamingException)</span>
<span class="nc" id="L470">                wrapRemoteException(e).fillInStackTrace();</span>
<span class="nc" id="L471">        } catch (Exception e) {</span>
<span class="nc" id="L472">            NamingException ne = new NamingException();</span>
<span class="nc" id="L473">            ne.setRootCause(e);</span>
<span class="nc" id="L474">            throw ne;</span>
        }
    }

}


/**
 * A name parser for case-sensitive atomic names.
 */
<span class="fc" id="L484">class AtomicNameParser implements NameParser {</span>
<span class="fc" id="L485">    private static final Properties syntax = new Properties();</span>

    public Name parse(String name) throws NamingException {
<span class="nc" id="L488">        return (new CompoundName(name, syntax));</span>
    }
}


/**
 * An enumeration of name / class-name pairs.
 */
class NameClassPairEnumeration implements NamingEnumeration&lt;NameClassPair&gt; {
    private final String[] names;
    private int nextName;       // index into &quot;names&quot;

<span class="nc" id="L500">    NameClassPairEnumeration(String[] names) {</span>
<span class="nc" id="L501">        this.names = names;</span>
<span class="nc" id="L502">        nextName = 0;</span>
<span class="nc" id="L503">    }</span>

    public boolean hasMore() {
<span class="nc bnc" id="L506" title="All 2 branches missed.">        return (nextName &lt; names.length);</span>
    }

    public NameClassPair next() throws NamingException {
<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (!hasMore()) {</span>
<span class="nc" id="L511">            throw (new java.util.NoSuchElementException());</span>
        }
        // Convert name to a one-element composite name, so embedded
        // meta-characters are properly escaped.
<span class="nc" id="L515">        String name = names[nextName++];</span>
<span class="nc" id="L516">        Name cname = (new CompositeName()).add(name);</span>
<span class="nc" id="L517">        NameClassPair ncp = new NameClassPair(cname.toString(),</span>
                                            &quot;java.lang.Object&quot;);
<span class="nc" id="L519">        ncp.setNameInNamespace(name);</span>
<span class="nc" id="L520">        return ncp;</span>
    }

    public boolean hasMoreElements() {
<span class="nc" id="L524">        return hasMore();</span>
    }

    public NameClassPair nextElement() {
        try {
<span class="nc" id="L529">            return next();</span>
<span class="nc" id="L530">        } catch (NamingException e) {   // should never happen</span>
<span class="nc" id="L531">            throw (new java.util.NoSuchElementException(</span>
                    &quot;javax.naming.NamingException was thrown&quot;));
        }
    }

    public void close() {
<span class="nc" id="L537">        nextName = names.length;</span>
<span class="nc" id="L538">    }</span>
}


/**
 * An enumeration of Bindings.
 *
 * The actual registry lookups are performed when next() is called.  It would
 * be nicer to defer this until the object (or its class name) is actually
 * requested.  The problem with that approach is that Binding.getObject()
 * cannot throw NamingException.
 */
class BindingEnumeration implements NamingEnumeration&lt;Binding&gt; {
    private RegistryContext ctx;
    private final String[] names;
    private int nextName;       // index into &quot;names&quot;

<span class="nc" id="L555">    BindingEnumeration(RegistryContext ctx, String[] names) {</span>
        // Clone ctx in case someone closes it before we're through.
<span class="nc" id="L557">        this.ctx = new RegistryContext(ctx);</span>
<span class="nc" id="L558">        this.names = names;</span>
<span class="nc" id="L559">        nextName = 0;</span>
<span class="nc" id="L560">    }</span>

    protected void finalize() {
<span class="nc" id="L563">        ctx.close();</span>
<span class="nc" id="L564">    }</span>

    public boolean hasMore() {
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (nextName &gt;= names.length) {</span>
<span class="nc" id="L568">            ctx.close();</span>
        }
<span class="nc bnc" id="L570" title="All 2 branches missed.">        return (nextName &lt; names.length);</span>
    }

    public Binding next() throws NamingException {
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (!hasMore()) {</span>
<span class="nc" id="L575">            throw (new java.util.NoSuchElementException());</span>
        }
        // Convert name to a one-element composite name, so embedded
        // meta-characters are properly escaped.
<span class="nc" id="L579">        String name = names[nextName++];</span>
<span class="nc" id="L580">        Name cname = (new CompositeName()).add(name);</span>

<span class="nc" id="L582">        Object obj = ctx.lookup(cname);</span>
<span class="nc" id="L583">        String cnameStr = cname.toString();</span>
<span class="nc" id="L584">        Binding binding = new Binding(cnameStr, obj);</span>
<span class="nc" id="L585">        binding.setNameInNamespace(cnameStr);</span>
<span class="nc" id="L586">        return binding;</span>
    }

    public boolean hasMoreElements() {
<span class="nc" id="L590">        return hasMore();</span>
    }

    public Binding nextElement() {
        try {
<span class="nc" id="L595">            return next();</span>
<span class="nc" id="L596">        } catch (NamingException e) {</span>
<span class="nc" id="L597">            throw (new java.util.NoSuchElementException(</span>
                    &quot;javax.naming.NamingException was thrown&quot;));
        }
    }

    public void close () {
<span class="nc" id="L603">        finalize();</span>
<span class="nc" id="L604">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>