<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SerialVersionUIDAdder.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">jdk.internal.org.objectweb.asm.commons</a> &gt; <span class="el_source">SerialVersionUIDAdder.java</span></div><h1>SerialVersionUIDAdder.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm.commons;

import java.io.ByteArrayOutputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

import jdk.internal.org.objectweb.asm.ClassVisitor;
import jdk.internal.org.objectweb.asm.FieldVisitor;
import jdk.internal.org.objectweb.asm.MethodVisitor;
import jdk.internal.org.objectweb.asm.Opcodes;

/**
 * A {@link ClassVisitor} that adds a serial version unique identifier to a
 * class if missing. Here is typical usage of this class:
 *
 * &lt;pre&gt;
 *   ClassWriter cw = new ClassWriter(...);
 *   ClassVisitor sv = new SerialVersionUIDAdder(cw);
 *   ClassVisitor ca = new MyClassAdapter(sv);
 *   new ClassReader(orginalClass).accept(ca, false);
 * &lt;/pre&gt;
 *
 * The SVUID algorithm can be found &lt;a href=
 * &quot;http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/class.html&quot;
 * &gt;http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/class.html&lt;/a&gt;:
 *
 * &lt;pre&gt;
 * The serialVersionUID is computed using the signature of a stream of bytes
 * that reflect the class definition. The National Institute of Standards and
 * Technology (NIST) Secure Hash Algorithm (SHA-1) is used to compute a
 * signature for the stream. The first two 32-bit quantities are used to form a
 * 64-bit hash. A java.lang.DataOutputStream is used to convert primitive data
 * types to a sequence of bytes. The values input to the stream are defined by
 * the Java Virtual Machine (VM) specification for classes.
 *
 * The sequence of items in the stream is as follows:
 *
 * 1. The class name written using UTF encoding.
 * 2. The class modifiers written as a 32-bit integer.
 * 3. The name of each interface sorted by name written using UTF encoding.
 * 4. For each field of the class sorted by field name (except private static
 * and private transient fields):
 * 1. The name of the field in UTF encoding.
 * 2. The modifiers of the field written as a 32-bit integer.
 * 3. The descriptor of the field in UTF encoding
 * 5. If a class initializer exists, write out the following:
 * 1. The name of the method, &amp;lt;clinit&amp;gt;, in UTF encoding.
 * 2. The modifier of the method, java.lang.reflect.Modifier.STATIC,
 * written as a 32-bit integer.
 * 3. The descriptor of the method, ()V, in UTF encoding.
 * 6. For each non-private constructor sorted by method name and signature:
 * 1. The name of the method, &amp;lt;init&amp;gt;, in UTF encoding.
 * 2. The modifiers of the method written as a 32-bit integer.
 * 3. The descriptor of the method in UTF encoding.
 * 7. For each non-private method sorted by method name and signature:
 * 1. The name of the method in UTF encoding.
 * 2. The modifiers of the method written as a 32-bit integer.
 * 3. The descriptor of the method in UTF encoding.
 * 8. The SHA-1 algorithm is executed on the stream of bytes produced by
 * DataOutputStream and produces five 32-bit values sha[0..4].
 *
 * 9. The hash value is assembled from the first and second 32-bit values of
 * the SHA-1 message digest. If the result of the message digest, the five
 * 32-bit words H0 H1 H2 H3 H4, is in an array of five int values named
 * sha, the hash value would be computed as follows:
 *
 * long hash = ((sha[0] &amp;gt;&amp;gt;&amp;gt; 24) &amp;amp; 0xFF) |
 * ((sha[0] &amp;gt;&amp;gt;&amp;gt; 16) &amp;amp; 0xFF) &amp;lt;&amp;lt; 8 |
 * ((sha[0] &amp;gt;&amp;gt;&amp;gt; 8) &amp;amp; 0xFF) &amp;lt;&amp;lt; 16 |
 * ((sha[0] &amp;gt;&amp;gt;&amp;gt; 0) &amp;amp; 0xFF) &amp;lt;&amp;lt; 24 |
 * ((sha[1] &amp;gt;&amp;gt;&amp;gt; 24) &amp;amp; 0xFF) &amp;lt;&amp;lt; 32 |
 * ((sha[1] &amp;gt;&amp;gt;&amp;gt; 16) &amp;amp; 0xFF) &amp;lt;&amp;lt; 40 |
 * ((sha[1] &amp;gt;&amp;gt;&amp;gt; 8) &amp;amp; 0xFF) &amp;lt;&amp;lt; 48 |
 * ((sha[1] &amp;gt;&amp;gt;&amp;gt; 0) &amp;amp; 0xFF) &amp;lt;&amp;lt; 56;
 * &lt;/pre&gt;
 *
 * @author Rajendra Inamdar, Vishal Vishnoi
 */
public class SerialVersionUIDAdder extends ClassVisitor {

    /**
     * Flag that indicates if we need to compute SVUID.
     */
    private boolean computeSVUID;

    /**
     * Set to true if the class already has SVUID.
     */
    private boolean hasSVUID;

    /**
     * Classes access flags.
     */
    private int access;

    /**
     * Internal name of the class
     */
    private String name;

    /**
     * Interfaces implemented by the class.
     */
    private String[] interfaces;

    /**
     * Collection of fields. (except private static and private transient
     * fields)
     */
    private Collection&lt;Item&gt; svuidFields;

    /**
     * Set to true if the class has static initializer.
     */
    private boolean hasStaticInitializer;

    /**
     * Collection of non-private constructors.
     */
    private Collection&lt;Item&gt; svuidConstructors;

    /**
     * Collection of non-private methods.
     */
    private Collection&lt;Item&gt; svuidMethods;

    /**
     * Creates a new {@link SerialVersionUIDAdder}. &lt;i&gt;Subclasses must not use
     * this constructor&lt;/i&gt;. Instead, they must use the
     * {@link #SerialVersionUIDAdder(int, ClassVisitor)} version.
     *
     * @param cv
     *            a {@link ClassVisitor} to which this visitor will delegate
     *            calls.
     * @throws IllegalStateException
     *             If a subclass calls this constructor.
     */
    public SerialVersionUIDAdder(final ClassVisitor cv) {
<span class="nc" id="L202">        this(Opcodes.ASM5, cv);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (getClass() != SerialVersionUIDAdder.class) {</span>
<span class="nc" id="L204">            throw new IllegalStateException();</span>
        }
<span class="nc" id="L206">    }</span>

    /**
     * Creates a new {@link SerialVersionUIDAdder}.
     *
     * @param api
     *            the ASM API version implemented by this visitor. Must be one
     *            of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     * @param cv
     *            a {@link ClassVisitor} to which this visitor will delegate
     *            calls.
     */
    protected SerialVersionUIDAdder(final int api, final ClassVisitor cv) {
<span class="nc" id="L219">        super(api, cv);</span>
<span class="nc" id="L220">        svuidFields = new ArrayList&lt;Item&gt;();</span>
<span class="nc" id="L221">        svuidConstructors = new ArrayList&lt;Item&gt;();</span>
<span class="nc" id="L222">        svuidMethods = new ArrayList&lt;Item&gt;();</span>
<span class="nc" id="L223">    }</span>

    // ------------------------------------------------------------------------
    // Overridden methods
    // ------------------------------------------------------------------------

    /*
     * Visit class header and get class name, access , and interfaces
     * information (step 1,2, and 3) for SVUID computation.
     */
    @Override
    public void visit(final int version, final int access, final String name,
            final String signature, final String superName,
            final String[] interfaces) {
<span class="nc bnc" id="L237" title="All 2 branches missed.">        computeSVUID = (access &amp; Opcodes.ACC_INTERFACE) == 0;</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (computeSVUID) {</span>
<span class="nc" id="L240">            this.name = name;</span>
<span class="nc" id="L241">            this.access = access;</span>
<span class="nc" id="L242">            this.interfaces = Arrays.copyOf(interfaces, interfaces.length);</span>
        }

<span class="nc" id="L245">        super.visit(version, access, name, signature, superName, interfaces);</span>
<span class="nc" id="L246">    }</span>

    /*
     * Visit the methods and get constructor and method information (step 5 and
     * 7). Also determine if there is a class initializer (step 6).
     */
    @Override
    public MethodVisitor visitMethod(final int access, final String name,
            final String desc, final String signature, final String[] exceptions) {
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (computeSVUID) {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (&quot;&lt;clinit&gt;&quot;.equals(name)) {</span>
<span class="nc" id="L257">                hasStaticInitializer = true;</span>
            }
            /*
             * Remembers non private constructors and methods for SVUID
             * computation For constructor and method modifiers, only the
             * ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,
             * ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT and ACC_STRICT flags
             * are used.
             */
<span class="nc" id="L266">            int mods = access</span>
                    &amp; (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE
                            | Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC
                            | Opcodes.ACC_FINAL | Opcodes.ACC_SYNCHRONIZED
                            | Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_STRICT);

            // all non private methods
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if ((access &amp; Opcodes.ACC_PRIVATE) == 0) {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">                if (&quot;&lt;init&gt;&quot;.equals(name)) {</span>
<span class="nc" id="L275">                    svuidConstructors.add(new Item(name, mods, desc));</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">                } else if (!&quot;&lt;clinit&gt;&quot;.equals(name)) {</span>
<span class="nc" id="L277">                    svuidMethods.add(new Item(name, mods, desc));</span>
                }
            }
        }

<span class="nc" id="L282">        return super.visitMethod(access, name, desc, signature, exceptions);</span>
    }

    /*
     * Gets class field information for step 4 of the algorithm. Also determines
     * if the class already has a SVUID.
     */
    @Override
    public FieldVisitor visitField(final int access, final String name,
            final String desc, final String signature, final Object value) {
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (computeSVUID) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (&quot;serialVersionUID&quot;.equals(name)) {</span>
                // since the class already has SVUID, we won't be computing it.
<span class="nc" id="L295">                computeSVUID = false;</span>
<span class="nc" id="L296">                hasSVUID = true;</span>
            }
            /*
             * Remember field for SVUID computation For field modifiers, only
             * the ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC,
             * ACC_FINAL, ACC_VOLATILE, and ACC_TRANSIENT flags are used when
             * computing serialVersionUID values.
             */
<span class="nc bnc" id="L304" title="All 4 branches missed.">            if ((access &amp; Opcodes.ACC_PRIVATE) == 0</span>
                    || (access &amp; (Opcodes.ACC_STATIC | Opcodes.ACC_TRANSIENT)) == 0) {
<span class="nc" id="L306">                int mods = access</span>
                        &amp; (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE
                                | Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC
                                | Opcodes.ACC_FINAL | Opcodes.ACC_VOLATILE | Opcodes.ACC_TRANSIENT);
<span class="nc" id="L310">                svuidFields.add(new Item(name, mods, desc));</span>
            }
        }

<span class="nc" id="L314">        return super.visitField(access, name, desc, signature, value);</span>
    }

    /**
     * Handle a bizarre special case. Nested classes (static classes declared
     * inside another class) that are protected have their access bit set to
     * public in their class files to deal with some odd reflection situation.
     * Our SVUID computation must do as the JVM does and ignore access bits in
     * the class file in favor of the access bits InnerClass attribute.
     */
    @Override
    public void visitInnerClass(final String aname, final String outerName,
            final String innerName, final int attr_access) {
<span class="nc bnc" id="L327" title="All 4 branches missed.">        if ((name != null) &amp;&amp; name.equals(aname)) {</span>
<span class="nc" id="L328">            this.access = attr_access;</span>
        }
<span class="nc" id="L330">        super.visitInnerClass(aname, outerName, innerName, attr_access);</span>
<span class="nc" id="L331">    }</span>

    /*
     * Add the SVUID if class doesn't have one
     */
    @Override
    public void visitEnd() {
        // compute SVUID and add it to the class
<span class="nc bnc" id="L339" title="All 4 branches missed.">        if (computeSVUID &amp;&amp; !hasSVUID) {</span>
            try {
<span class="nc" id="L341">                addSVUID(computeSVUID());</span>
<span class="nc" id="L342">            } catch (Throwable e) {</span>
<span class="nc" id="L343">                throw new RuntimeException(&quot;Error while computing SVUID for &quot;</span>
                        + name, e);
<span class="nc" id="L345">            }</span>
        }

<span class="nc" id="L348">        super.visitEnd();</span>
<span class="nc" id="L349">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods
    // ------------------------------------------------------------------------

    /**
     * Returns true if the class already has a SVUID field. The result of this
     * method is only valid when visitEnd is or has been called.
     *
     * @return true if the class already has a SVUID field.
     */
    public boolean hasSVUID() {
<span class="nc" id="L362">        return hasSVUID;</span>
    }

    protected void addSVUID(long svuid) {
<span class="nc" id="L366">        FieldVisitor fv = super.visitField(Opcodes.ACC_FINAL</span>
                + Opcodes.ACC_STATIC, &quot;serialVersionUID&quot;, &quot;J&quot;, null, new Long(
                svuid));
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (fv != null) {</span>
<span class="nc" id="L370">            fv.visitEnd();</span>
        }
<span class="nc" id="L372">    }</span>

    /**
     * Computes and returns the value of SVUID.
     *
     * @return Returns the serial version UID
     * @throws IOException
     *             if an I/O error occurs
     */
    protected long computeSVUID() throws IOException {
        ByteArrayOutputStream bos;
<span class="nc" id="L383">        DataOutputStream dos = null;</span>
<span class="nc" id="L384">        long svuid = 0;</span>

        try {
<span class="nc" id="L387">            bos = new ByteArrayOutputStream();</span>
<span class="nc" id="L388">            dos = new DataOutputStream(bos);</span>

            /*
             * 1. The class name written using UTF encoding.
             */
<span class="nc" id="L393">            dos.writeUTF(name.replace('/', '.'));</span>

            /*
             * 2. The class modifiers written as a 32-bit integer.
             */
<span class="nc" id="L398">            dos.writeInt(access</span>
                    &amp; (Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL
                            | Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT));

            /*
             * 3. The name of each interface sorted by name written using UTF
             * encoding.
             */
<span class="nc" id="L406">            Arrays.sort(interfaces);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">            for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="nc" id="L408">                dos.writeUTF(interfaces[i].replace('/', '.'));</span>
            }

            /*
             * 4. For each field of the class sorted by field name (except
             * private static and private transient fields):
             *
             * 1. The name of the field in UTF encoding. 2. The modifiers of the
             * field written as a 32-bit integer. 3. The descriptor of the field
             * in UTF encoding
             *
             * Note that field signatures are not dot separated. Method and
             * constructor signatures are dot separated. Go figure...
             */
<span class="nc" id="L422">            writeItems(svuidFields, dos, false);</span>

            /*
             * 5. If a class initializer exists, write out the following: 1. The
             * name of the method, &lt;clinit&gt;, in UTF encoding. 2. The modifier of
             * the method, java.lang.reflect.Modifier.STATIC, written as a
             * 32-bit integer. 3. The descriptor of the method, ()V, in UTF
             * encoding.
             */
<span class="nc bnc" id="L431" title="All 2 branches missed.">            if (hasStaticInitializer) {</span>
<span class="nc" id="L432">                dos.writeUTF(&quot;&lt;clinit&gt;&quot;);</span>
<span class="nc" id="L433">                dos.writeInt(Opcodes.ACC_STATIC);</span>
<span class="nc" id="L434">                dos.writeUTF(&quot;()V&quot;);</span>
            } // if..

            /*
             * 6. For each non-private constructor sorted by method name and
             * signature: 1. The name of the method, &lt;init&gt;, in UTF encoding. 2.
             * The modifiers of the method written as a 32-bit integer. 3. The
             * descriptor of the method in UTF encoding.
             */
<span class="nc" id="L443">            writeItems(svuidConstructors, dos, true);</span>

            /*
             * 7. For each non-private method sorted by method name and
             * signature: 1. The name of the method in UTF encoding. 2. The
             * modifiers of the method written as a 32-bit integer. 3. The
             * descriptor of the method in UTF encoding.
             */
<span class="nc" id="L451">            writeItems(svuidMethods, dos, true);</span>

<span class="nc" id="L453">            dos.flush();</span>

            /*
             * 8. The SHA-1 algorithm is executed on the stream of bytes
             * produced by DataOutputStream and produces five 32-bit values
             * sha[0..4].
             */
<span class="nc" id="L460">            byte[] hashBytes = computeSHAdigest(bos.toByteArray());</span>

            /*
             * 9. The hash value is assembled from the first and second 32-bit
             * values of the SHA-1 message digest. If the result of the message
             * digest, the five 32-bit words H0 H1 H2 H3 H4, is in an array of
             * five int values named sha, the hash value would be computed as
             * follows:
             *
             * long hash = ((sha[0] &gt;&gt;&gt; 24) &amp; 0xFF) | ((sha[0] &gt;&gt;&gt; 16) &amp; 0xFF)
             * &lt;&lt; 8 | ((sha[0] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 16 | ((sha[0] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt;
             * 24 | ((sha[1] &gt;&gt;&gt; 24) &amp; 0xFF) &lt;&lt; 32 | ((sha[1] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt;
             * 40 | ((sha[1] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 48 | ((sha[1] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt;
             * 56;
             */
<span class="nc bnc" id="L475" title="All 2 branches missed.">            for (int i = Math.min(hashBytes.length, 8) - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L476">                svuid = (svuid &lt;&lt; 8) | (hashBytes[i] &amp; 0xFF);</span>
            }
        } finally {
            // close the stream (if open)
<span class="nc bnc" id="L480" title="All 4 branches missed.">            if (dos != null) {</span>
<span class="nc" id="L481">                dos.close();</span>
            }
        }

<span class="nc" id="L485">        return svuid;</span>
    }

    /**
     * Returns the SHA-1 message digest of the given value.
     *
     * @param value
     *            the value whose SHA message digest must be computed.
     * @return the SHA-1 message digest of the given value.
     */
    protected byte[] computeSHAdigest(final byte[] value) {
        try {
<span class="nc" id="L497">            return MessageDigest.getInstance(&quot;SHA&quot;).digest(value);</span>
<span class="nc" id="L498">        } catch (Exception e) {</span>
<span class="nc" id="L499">            throw new UnsupportedOperationException(e.toString());</span>
        }
    }

    /**
     * Sorts the items in the collection and writes it to the data output stream
     *
     * @param itemCollection
     *            collection of items
     * @param dos
     *            a &lt;code&gt;DataOutputStream&lt;/code&gt; value
     * @param dotted
     *            a &lt;code&gt;boolean&lt;/code&gt; value
     * @exception IOException
     *                if an error occurs
     */
    private static void writeItems(final Collection&lt;Item&gt; itemCollection,
            final DataOutput dos, final boolean dotted) throws IOException {
<span class="nc" id="L517">        int size = itemCollection.size();</span>
<span class="nc" id="L518">        Item[] items = itemCollection.toArray(new Item[size]);</span>
<span class="nc" id="L519">        Arrays.sort(items);</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L521">            dos.writeUTF(items[i].name);</span>
<span class="nc" id="L522">            dos.writeInt(items[i].access);</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">            dos.writeUTF(dotted ? items[i].desc.replace('/', '.')</span>
                    : items[i].desc);
        }
<span class="nc" id="L526">    }</span>

    // ------------------------------------------------------------------------
    // Inner classes
    // ------------------------------------------------------------------------

    private static class Item implements Comparable&lt;Item&gt; {

        final String name;

        final int access;

        final String desc;

<span class="nc" id="L540">        Item(final String name, final int access, final String desc) {</span>
<span class="nc" id="L541">            this.name = name;</span>
<span class="nc" id="L542">            this.access = access;</span>
<span class="nc" id="L543">            this.desc = desc;</span>
<span class="nc" id="L544">        }</span>

        public int compareTo(final Item other) {
<span class="nc" id="L547">            int retVal = name.compareTo(other.name);</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">            if (retVal == 0) {</span>
<span class="nc" id="L549">                retVal = desc.compareTo(other.desc);</span>
            }
<span class="nc" id="L551">            return retVal;</span>
        }

        @Override
        public boolean equals(final Object o) {
<span class="nc bnc" id="L556" title="All 2 branches missed.">            if (o instanceof Item) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                return compareTo((Item) o) == 0;</span>
            }
<span class="nc" id="L559">            return false;</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L564">            return (name + desc).hashCode();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>