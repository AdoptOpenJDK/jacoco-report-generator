<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AnalyzerAdapter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">jdk.internal.org.objectweb.asm.commons</a> &gt; <span class="el_source">AnalyzerAdapter.java</span></div><h1>AnalyzerAdapter.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm.commons;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import jdk.internal.org.objectweb.asm.Handle;
import jdk.internal.org.objectweb.asm.Label;
import jdk.internal.org.objectweb.asm.MethodVisitor;
import jdk.internal.org.objectweb.asm.Opcodes;
import jdk.internal.org.objectweb.asm.Type;

/**
 * A {@link MethodVisitor} that keeps track of stack map frame changes between
 * {@link #visitFrame(int, int, Object[], int, Object[]) visitFrame} calls. This
 * adapter must be used with the
 * {@link jdk.internal.org.objectweb.asm.ClassReader#EXPAND_FRAMES} option. Each
 * visit&lt;i&gt;X&lt;/i&gt; instruction delegates to the next visitor in the chain, if any,
 * and then simulates the effect of this instruction on the stack map frame,
 * represented by {@link #locals} and {@link #stack}. The next visitor in the
 * chain can get the state of the stack map frame &lt;i&gt;before&lt;/i&gt; each instruction
 * by reading the value of these fields in its visit&lt;i&gt;X&lt;/i&gt; methods (this
 * requires a reference to the AnalyzerAdapter that is before it in the chain).
 * If this adapter is used with a class that does not contain stack map table
 * attributes (i.e., pre Java 6 classes) then this adapter may not be able to
 * compute the stack map frame for each instruction. In this case no exception
 * is thrown but the {@link #locals} and {@link #stack} fields will be null for
 * these instructions.
 *
 * @author Eric Bruneton
 */
public class AnalyzerAdapter extends MethodVisitor {

    /**
     * &lt;code&gt;List&lt;/code&gt; of the local variable slots for current execution
     * frame. Primitive types are represented by {@link Opcodes#TOP},
     * {@link Opcodes#INTEGER}, {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
     * {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
     * {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by
     * two elements, the second one being TOP). Reference types are represented
     * by String objects (representing internal names), and uninitialized types
     * by Label objects (this label designates the NEW instruction that created
     * this uninitialized value). This field is &lt;tt&gt;null&lt;/tt&gt; for unreachable
     * instructions.
     */
    public List&lt;Object&gt; locals;

    /**
     * &lt;code&gt;List&lt;/code&gt; of the operand stack slots for current execution frame.
     * Primitive types are represented by {@link Opcodes#TOP},
     * {@link Opcodes#INTEGER}, {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
     * {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
     * {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by
     * two elements, the second one being TOP). Reference types are represented
     * by String objects (representing internal names), and uninitialized types
     * by Label objects (this label designates the NEW instruction that created
     * this uninitialized value). This field is &lt;tt&gt;null&lt;/tt&gt; for unreachable
     * instructions.
     */
    public List&lt;Object&gt; stack;

    /**
     * The labels that designate the next instruction to be visited. May be
     * &lt;tt&gt;null&lt;/tt&gt;.
     */
    private List&lt;Label&gt; labels;

    /**
     * Information about uninitialized types in the current execution frame.
     * This map associates internal names to Label objects. Each label
     * designates a NEW instruction that created the currently uninitialized
     * types, and the associated internal name represents the NEW operand, i.e.
     * the final, initialized type value.
     */
    public Map&lt;Object, Object&gt; uninitializedTypes;

    /**
     * The maximum stack size of this method.
     */
    private int maxStack;

    /**
     * The maximum number of local variables of this method.
     */
    private int maxLocals;

    /**
     * The owner's class name.
     */
    private String owner;

    /**
     * Creates a new {@link AnalyzerAdapter}. &lt;i&gt;Subclasses must not use this
     * constructor&lt;/i&gt;. Instead, they must use the
     * {@link #AnalyzerAdapter(int, String, int, String, String, MethodVisitor)}
     * version.
     *
     * @param owner
     *            the owner's class name.
     * @param access
     *            the method's access flags (see {@link Opcodes}).
     * @param name
     *            the method's name.
     * @param desc
     *            the method's descriptor (see {@link Type Type}).
     * @param mv
     *            the method visitor to which this adapter delegates calls. May
     *            be &lt;tt&gt;null&lt;/tt&gt;.
     * @throws IllegalStateException
     *             If a subclass calls this constructor.
     */
    public AnalyzerAdapter(final String owner, final int access,
            final String name, final String desc, final MethodVisitor mv) {
<span class="nc" id="L173">        this(Opcodes.ASM5, owner, access, name, desc, mv);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (getClass() != AnalyzerAdapter.class) {</span>
<span class="nc" id="L175">            throw new IllegalStateException();</span>
        }
<span class="nc" id="L177">    }</span>

    /**
     * Creates a new {@link AnalyzerAdapter}.
     *
     * @param api
     *            the ASM API version implemented by this visitor. Must be one
     *            of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     * @param owner
     *            the owner's class name.
     * @param access
     *            the method's access flags (see {@link Opcodes}).
     * @param name
     *            the method's name.
     * @param desc
     *            the method's descriptor (see {@link Type Type}).
     * @param mv
     *            the method visitor to which this adapter delegates calls. May
     *            be &lt;tt&gt;null&lt;/tt&gt;.
     */
    protected AnalyzerAdapter(final int api, final String owner,
            final int access, final String name, final String desc,
            final MethodVisitor mv) {
<span class="nc" id="L200">        super(api, mv);</span>
<span class="nc" id="L201">        this.owner = owner;</span>
<span class="nc" id="L202">        locals = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L203">        stack = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L204">        uninitializedTypes = new HashMap&lt;Object, Object&gt;();</span>

<span class="nc bnc" id="L206" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_STATIC) == 0) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (&quot;&lt;init&gt;&quot;.equals(name)) {</span>
<span class="nc" id="L208">                locals.add(Opcodes.UNINITIALIZED_THIS);</span>
            } else {
<span class="nc" id="L210">                locals.add(owner);</span>
            }
        }
<span class="nc" id="L213">        Type[] types = Type.getArgumentTypes(desc);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        for (int i = 0; i &lt; types.length; ++i) {</span>
<span class="nc" id="L215">            Type type = types[i];</span>
<span class="nc bnc" id="L216" title="All 6 branches missed.">            switch (type.getSort()) {</span>
            case Type.BOOLEAN:
            case Type.CHAR:
            case Type.BYTE:
            case Type.SHORT:
            case Type.INT:
<span class="nc" id="L222">                locals.add(Opcodes.INTEGER);</span>
<span class="nc" id="L223">                break;</span>
            case Type.FLOAT:
<span class="nc" id="L225">                locals.add(Opcodes.FLOAT);</span>
<span class="nc" id="L226">                break;</span>
            case Type.LONG:
<span class="nc" id="L228">                locals.add(Opcodes.LONG);</span>
<span class="nc" id="L229">                locals.add(Opcodes.TOP);</span>
<span class="nc" id="L230">                break;</span>
            case Type.DOUBLE:
<span class="nc" id="L232">                locals.add(Opcodes.DOUBLE);</span>
<span class="nc" id="L233">                locals.add(Opcodes.TOP);</span>
<span class="nc" id="L234">                break;</span>
            case Type.ARRAY:
<span class="nc" id="L236">                locals.add(types[i].getDescriptor());</span>
<span class="nc" id="L237">                break;</span>
            // case Type.OBJECT:
            default:
<span class="nc" id="L240">                locals.add(types[i].getInternalName());</span>
            }
        }
<span class="nc" id="L243">    }</span>

    @Override
    public void visitFrame(final int type, final int nLocal,
            final Object[] local, final int nStack, final Object[] stack) {
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (type != Opcodes.F_NEW) { // uncompressed frame</span>
<span class="nc" id="L249">            throw new IllegalStateException(</span>
                    &quot;ClassReader.accept() should be called with EXPAND_FRAMES flag&quot;);
        }

<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L254">            mv.visitFrame(type, nLocal, local, nStack, stack);</span>
        }

<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (this.locals != null) {</span>
<span class="nc" id="L258">            this.locals.clear();</span>
<span class="nc" id="L259">            this.stack.clear();</span>
        } else {
<span class="nc" id="L261">            this.locals = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L262">            this.stack = new ArrayList&lt;Object&gt;();</span>
        }
<span class="nc" id="L264">        visitFrameTypes(nLocal, local, this.locals);</span>
<span class="nc" id="L265">        visitFrameTypes(nStack, stack, this.stack);</span>
<span class="nc" id="L266">        maxStack = Math.max(maxStack, this.stack.size());</span>
<span class="nc" id="L267">    }</span>

    private static void visitFrameTypes(final int n, final Object[] types,
            final List&lt;Object&gt; result) {
<span class="nc bnc" id="L271" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L272">            Object type = types[i];</span>
<span class="nc" id="L273">            result.add(type);</span>
<span class="nc bnc" id="L274" title="All 4 branches missed.">            if (type == Opcodes.LONG || type == Opcodes.DOUBLE) {</span>
<span class="nc" id="L275">                result.add(Opcodes.TOP);</span>
            }
        }
<span class="nc" id="L278">    }</span>

    @Override
    public void visitInsn(final int opcode) {
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L283">            mv.visitInsn(opcode);</span>
        }
<span class="nc" id="L285">        execute(opcode, 0, null);</span>
<span class="nc bnc" id="L286" title="All 6 branches missed.">        if ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN)</span>
                || opcode == Opcodes.ATHROW) {
<span class="nc" id="L288">            this.locals = null;</span>
<span class="nc" id="L289">            this.stack = null;</span>
        }
<span class="nc" id="L291">    }</span>

    @Override
    public void visitIntInsn(final int opcode, final int operand) {
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L296">            mv.visitIntInsn(opcode, operand);</span>
        }
<span class="nc" id="L298">        execute(opcode, operand, null);</span>
<span class="nc" id="L299">    }</span>

    @Override
    public void visitVarInsn(final int opcode, final int var) {
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L304">            mv.visitVarInsn(opcode, var);</span>
        }
<span class="nc" id="L306">        execute(opcode, var, null);</span>
<span class="nc" id="L307">    }</span>

    @Override
    public void visitTypeInsn(final int opcode, final String type) {
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (opcode == Opcodes.NEW) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (labels == null) {</span>
<span class="nc" id="L313">                Label l = new Label();</span>
<span class="nc" id="L314">                labels = new ArrayList&lt;Label&gt;(3);</span>
<span class="nc" id="L315">                labels.add(l);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                if (mv != null) {</span>
<span class="nc" id="L317">                    mv.visitLabel(l);</span>
                }
            }
<span class="nc bnc" id="L320" title="All 2 branches missed.">            for (int i = 0; i &lt; labels.size(); ++i) {</span>
<span class="nc" id="L321">                uninitializedTypes.put(labels.get(i), type);</span>
            }
        }
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L325">            mv.visitTypeInsn(opcode, type);</span>
        }
<span class="nc" id="L327">        execute(opcode, 0, type);</span>
<span class="nc" id="L328">    }</span>

    @Override
    public void visitFieldInsn(final int opcode, final String owner,
            final String name, final String desc) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L334">            mv.visitFieldInsn(opcode, owner, name, desc);</span>
        }
<span class="nc" id="L336">        execute(opcode, 0, desc);</span>
<span class="nc" id="L337">    }</span>

    @Deprecated
    @Override
    public void visitMethodInsn(final int opcode, final String owner,
            final String name, final String desc) {
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (api &gt;= Opcodes.ASM5) {</span>
<span class="nc" id="L344">            super.visitMethodInsn(opcode, owner, name, desc);</span>
<span class="nc" id="L345">            return;</span>
        }
<span class="nc bnc" id="L347" title="All 2 branches missed.">        doVisitMethodInsn(opcode, owner, name, desc,</span>
                opcode == Opcodes.INVOKEINTERFACE);
<span class="nc" id="L349">    }</span>

    @Override
    public void visitMethodInsn(final int opcode, final String owner,
            final String name, final String desc, final boolean itf) {
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (api &lt; Opcodes.ASM5) {</span>
<span class="nc" id="L355">            super.visitMethodInsn(opcode, owner, name, desc, itf);</span>
<span class="nc" id="L356">            return;</span>
        }
<span class="nc" id="L358">        doVisitMethodInsn(opcode, owner, name, desc, itf);</span>
<span class="nc" id="L359">    }</span>

    private void doVisitMethodInsn(int opcode, final String owner,
            final String name, final String desc, final boolean itf) {
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L364">            mv.visitMethodInsn(opcode, owner, name, desc, itf);</span>
        }
<span class="nc bnc" id="L366" title="All 2 branches missed.">        if (this.locals == null) {</span>
<span class="nc" id="L367">            labels = null;</span>
<span class="nc" id="L368">            return;</span>
        }
<span class="nc" id="L370">        pop(desc);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (opcode != Opcodes.INVOKESTATIC) {</span>
<span class="nc" id="L372">            Object t = pop();</span>
<span class="nc bnc" id="L373" title="All 4 branches missed.">            if (opcode == Opcodes.INVOKESPECIAL &amp;&amp; name.charAt(0) == '&lt;') {</span>
                Object u;
<span class="nc bnc" id="L375" title="All 2 branches missed.">                if (t == Opcodes.UNINITIALIZED_THIS) {</span>
<span class="nc" id="L376">                    u = this.owner;</span>
                } else {
<span class="nc" id="L378">                    u = uninitializedTypes.get(t);</span>
                }
<span class="nc bnc" id="L380" title="All 2 branches missed.">                for (int i = 0; i &lt; locals.size(); ++i) {</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">                    if (locals.get(i) == t) {</span>
<span class="nc" id="L382">                        locals.set(i, u);</span>
                    }
                }
<span class="nc bnc" id="L385" title="All 2 branches missed.">                for (int i = 0; i &lt; stack.size(); ++i) {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">                    if (stack.get(i) == t) {</span>
<span class="nc" id="L387">                        stack.set(i, u);</span>
                    }
                }
            }
        }
<span class="nc" id="L392">        pushDesc(desc);</span>
<span class="nc" id="L393">        labels = null;</span>
<span class="nc" id="L394">    }</span>

    @Override
    public void visitInvokeDynamicInsn(String name, String desc, Handle bsm,
            Object... bsmArgs) {
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L400">            mv.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);</span>
        }
<span class="nc bnc" id="L402" title="All 2 branches missed.">        if (this.locals == null) {</span>
<span class="nc" id="L403">            labels = null;</span>
<span class="nc" id="L404">            return;</span>
        }
<span class="nc" id="L406">        pop(desc);</span>
<span class="nc" id="L407">        pushDesc(desc);</span>
<span class="nc" id="L408">        labels = null;</span>
<span class="nc" id="L409">    }</span>

    @Override
    public void visitJumpInsn(final int opcode, final Label label) {
<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L414">            mv.visitJumpInsn(opcode, label);</span>
        }
<span class="nc" id="L416">        execute(opcode, 0, null);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (opcode == Opcodes.GOTO) {</span>
<span class="nc" id="L418">            this.locals = null;</span>
<span class="nc" id="L419">            this.stack = null;</span>
        }
<span class="nc" id="L421">    }</span>

    @Override
    public void visitLabel(final Label label) {
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L426">            mv.visitLabel(label);</span>
        }
<span class="nc bnc" id="L428" title="All 2 branches missed.">        if (labels == null) {</span>
<span class="nc" id="L429">            labels = new ArrayList&lt;Label&gt;(3);</span>
        }
<span class="nc" id="L431">        labels.add(label);</span>
<span class="nc" id="L432">    }</span>

    @Override
    public void visitLdcInsn(final Object cst) {
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L437">            mv.visitLdcInsn(cst);</span>
        }
<span class="nc bnc" id="L439" title="All 2 branches missed.">        if (this.locals == null) {</span>
<span class="nc" id="L440">            labels = null;</span>
<span class="nc" id="L441">            return;</span>
        }
<span class="nc bnc" id="L443" title="All 2 branches missed.">        if (cst instanceof Integer) {</span>
<span class="nc" id="L444">            push(Opcodes.INTEGER);</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">        } else if (cst instanceof Long) {</span>
<span class="nc" id="L446">            push(Opcodes.LONG);</span>
<span class="nc" id="L447">            push(Opcodes.TOP);</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">        } else if (cst instanceof Float) {</span>
<span class="nc" id="L449">            push(Opcodes.FLOAT);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">        } else if (cst instanceof Double) {</span>
<span class="nc" id="L451">            push(Opcodes.DOUBLE);</span>
<span class="nc" id="L452">            push(Opcodes.TOP);</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">        } else if (cst instanceof String) {</span>
<span class="nc" id="L454">            push(&quot;java/lang/String&quot;);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        } else if (cst instanceof Type) {</span>
<span class="nc" id="L456">            int sort = ((Type) cst).getSort();</span>
<span class="nc bnc" id="L457" title="All 4 branches missed.">            if (sort == Type.OBJECT || sort == Type.ARRAY) {</span>
<span class="nc" id="L458">                push(&quot;java/lang/Class&quot;);</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            } else if (sort == Type.METHOD) {</span>
<span class="nc" id="L460">                push(&quot;java/lang/invoke/MethodType&quot;);</span>
            } else {
<span class="nc" id="L462">                throw new IllegalArgumentException();</span>
            }
<span class="nc bnc" id="L464" title="All 2 branches missed.">        } else if (cst instanceof Handle) {</span>
<span class="nc" id="L465">            push(&quot;java/lang/invoke/MethodHandle&quot;);</span>
        } else {
<span class="nc" id="L467">            throw new IllegalArgumentException();</span>
        }
<span class="nc" id="L469">        labels = null;</span>
<span class="nc" id="L470">    }</span>

    @Override
    public void visitIincInsn(final int var, final int increment) {
<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L475">            mv.visitIincInsn(var, increment);</span>
        }
<span class="nc" id="L477">        execute(Opcodes.IINC, var, null);</span>
<span class="nc" id="L478">    }</span>

    @Override
    public void visitTableSwitchInsn(final int min, final int max,
            final Label dflt, final Label... labels) {
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L484">            mv.visitTableSwitchInsn(min, max, dflt, labels);</span>
        }
<span class="nc" id="L486">        execute(Opcodes.TABLESWITCH, 0, null);</span>
<span class="nc" id="L487">        this.locals = null;</span>
<span class="nc" id="L488">        this.stack = null;</span>
<span class="nc" id="L489">    }</span>

    @Override
    public void visitLookupSwitchInsn(final Label dflt, final int[] keys,
            final Label[] labels) {
<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L495">            mv.visitLookupSwitchInsn(dflt, keys, labels);</span>
        }
<span class="nc" id="L497">        execute(Opcodes.LOOKUPSWITCH, 0, null);</span>
<span class="nc" id="L498">        this.locals = null;</span>
<span class="nc" id="L499">        this.stack = null;</span>
<span class="nc" id="L500">    }</span>

    @Override
    public void visitMultiANewArrayInsn(final String desc, final int dims) {
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L505">            mv.visitMultiANewArrayInsn(desc, dims);</span>
        }
<span class="nc" id="L507">        execute(Opcodes.MULTIANEWARRAY, dims, desc);</span>
<span class="nc" id="L508">    }</span>

    @Override
    public void visitMaxs(final int maxStack, final int maxLocals) {
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L513">            this.maxStack = Math.max(this.maxStack, maxStack);</span>
<span class="nc" id="L514">            this.maxLocals = Math.max(this.maxLocals, maxLocals);</span>
<span class="nc" id="L515">            mv.visitMaxs(this.maxStack, this.maxLocals);</span>
        }
<span class="nc" id="L517">    }</span>

    // ------------------------------------------------------------------------

    private Object get(final int local) {
<span class="nc" id="L522">        maxLocals = Math.max(maxLocals, local);</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">        return local &lt; locals.size() ? locals.get(local) : Opcodes.TOP;</span>
    }

    private void set(final int local, final Object type) {
<span class="nc" id="L527">        maxLocals = Math.max(maxLocals, local);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        while (local &gt;= locals.size()) {</span>
<span class="nc" id="L529">            locals.add(Opcodes.TOP);</span>
        }
<span class="nc" id="L531">        locals.set(local, type);</span>
<span class="nc" id="L532">    }</span>

    private void push(final Object type) {
<span class="nc" id="L535">        stack.add(type);</span>
<span class="nc" id="L536">        maxStack = Math.max(maxStack, stack.size());</span>
<span class="nc" id="L537">    }</span>

    private void pushDesc(final String desc) {
<span class="nc bnc" id="L540" title="All 2 branches missed.">        int index = desc.charAt(0) == '(' ? desc.indexOf(')') + 1 : 0;</span>
<span class="nc bnc" id="L541" title="All 7 branches missed.">        switch (desc.charAt(index)) {</span>
        case 'V':
<span class="nc" id="L543">            return;</span>
        case 'Z':
        case 'C':
        case 'B':
        case 'S':
        case 'I':
<span class="nc" id="L549">            push(Opcodes.INTEGER);</span>
<span class="nc" id="L550">            return;</span>
        case 'F':
<span class="nc" id="L552">            push(Opcodes.FLOAT);</span>
<span class="nc" id="L553">            return;</span>
        case 'J':
<span class="nc" id="L555">            push(Opcodes.LONG);</span>
<span class="nc" id="L556">            push(Opcodes.TOP);</span>
<span class="nc" id="L557">            return;</span>
        case 'D':
<span class="nc" id="L559">            push(Opcodes.DOUBLE);</span>
<span class="nc" id="L560">            push(Opcodes.TOP);</span>
<span class="nc" id="L561">            return;</span>
        case '[':
<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (index == 0) {</span>
<span class="nc" id="L564">                push(desc);</span>
            } else {
<span class="nc" id="L566">                push(desc.substring(index, desc.length()));</span>
            }
<span class="nc" id="L568">            break;</span>
        // case 'L':
        default:
<span class="nc bnc" id="L571" title="All 2 branches missed.">            if (index == 0) {</span>
<span class="nc" id="L572">                push(desc.substring(1, desc.length() - 1));</span>
            } else {
<span class="nc" id="L574">                push(desc.substring(index + 1, desc.length() - 1));</span>
            }
        }
<span class="nc" id="L577">    }</span>

    private Object pop() {
<span class="nc" id="L580">        return stack.remove(stack.size() - 1);</span>
    }

    private void pop(final int n) {
<span class="nc" id="L584">        int size = stack.size();</span>
<span class="nc" id="L585">        int end = size - n;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">        for (int i = size - 1; i &gt;= end; --i) {</span>
<span class="nc" id="L587">            stack.remove(i);</span>
        }
<span class="nc" id="L589">    }</span>

    private void pop(final String desc) {
<span class="nc" id="L592">        char c = desc.charAt(0);</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (c == '(') {</span>
<span class="nc" id="L594">            int n = 0;</span>
<span class="nc" id="L595">            Type[] types = Type.getArgumentTypes(desc);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">            for (int i = 0; i &lt; types.length; ++i) {</span>
<span class="nc" id="L597">                n += types[i].getSize();</span>
            }
<span class="nc" id="L599">            pop(n);</span>
<span class="nc bnc" id="L600" title="All 4 branches missed.">        } else if (c == 'J' || c == 'D') {</span>
<span class="nc" id="L601">            pop(2);</span>
        } else {
<span class="nc" id="L603">            pop(1);</span>
        }
<span class="nc" id="L605">    }</span>

    private void execute(final int opcode, final int iarg, final String sarg) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (this.locals == null) {</span>
<span class="nc" id="L609">            labels = null;</span>
<span class="nc" id="L610">            return;</span>
        }
        Object t1, t2, t3, t4;
<span class="nc bnc" id="L613" title="All 47 branches missed.">        switch (opcode) {</span>
        case Opcodes.NOP:
        case Opcodes.INEG:
        case Opcodes.LNEG:
        case Opcodes.FNEG:
        case Opcodes.DNEG:
        case Opcodes.I2B:
        case Opcodes.I2C:
        case Opcodes.I2S:
        case Opcodes.GOTO:
        case Opcodes.RETURN:
<span class="nc" id="L624">            break;</span>
        case Opcodes.ACONST_NULL:
<span class="nc" id="L626">            push(Opcodes.NULL);</span>
<span class="nc" id="L627">            break;</span>
        case Opcodes.ICONST_M1:
        case Opcodes.ICONST_0:
        case Opcodes.ICONST_1:
        case Opcodes.ICONST_2:
        case Opcodes.ICONST_3:
        case Opcodes.ICONST_4:
        case Opcodes.ICONST_5:
        case Opcodes.BIPUSH:
        case Opcodes.SIPUSH:
<span class="nc" id="L637">            push(Opcodes.INTEGER);</span>
<span class="nc" id="L638">            break;</span>
        case Opcodes.LCONST_0:
        case Opcodes.LCONST_1:
<span class="nc" id="L641">            push(Opcodes.LONG);</span>
<span class="nc" id="L642">            push(Opcodes.TOP);</span>
<span class="nc" id="L643">            break;</span>
        case Opcodes.FCONST_0:
        case Opcodes.FCONST_1:
        case Opcodes.FCONST_2:
<span class="nc" id="L647">            push(Opcodes.FLOAT);</span>
<span class="nc" id="L648">            break;</span>
        case Opcodes.DCONST_0:
        case Opcodes.DCONST_1:
<span class="nc" id="L651">            push(Opcodes.DOUBLE);</span>
<span class="nc" id="L652">            push(Opcodes.TOP);</span>
<span class="nc" id="L653">            break;</span>
        case Opcodes.ILOAD:
        case Opcodes.FLOAD:
        case Opcodes.ALOAD:
<span class="nc" id="L657">            push(get(iarg));</span>
<span class="nc" id="L658">            break;</span>
        case Opcodes.LLOAD:
        case Opcodes.DLOAD:
<span class="nc" id="L661">            push(get(iarg));</span>
<span class="nc" id="L662">            push(Opcodes.TOP);</span>
<span class="nc" id="L663">            break;</span>
        case Opcodes.IALOAD:
        case Opcodes.BALOAD:
        case Opcodes.CALOAD:
        case Opcodes.SALOAD:
<span class="nc" id="L668">            pop(2);</span>
<span class="nc" id="L669">            push(Opcodes.INTEGER);</span>
<span class="nc" id="L670">            break;</span>
        case Opcodes.LALOAD:
        case Opcodes.D2L:
<span class="nc" id="L673">            pop(2);</span>
<span class="nc" id="L674">            push(Opcodes.LONG);</span>
<span class="nc" id="L675">            push(Opcodes.TOP);</span>
<span class="nc" id="L676">            break;</span>
        case Opcodes.FALOAD:
<span class="nc" id="L678">            pop(2);</span>
<span class="nc" id="L679">            push(Opcodes.FLOAT);</span>
<span class="nc" id="L680">            break;</span>
        case Opcodes.DALOAD:
        case Opcodes.L2D:
<span class="nc" id="L683">            pop(2);</span>
<span class="nc" id="L684">            push(Opcodes.DOUBLE);</span>
<span class="nc" id="L685">            push(Opcodes.TOP);</span>
<span class="nc" id="L686">            break;</span>
        case Opcodes.AALOAD:
<span class="nc" id="L688">            pop(1);</span>
<span class="nc" id="L689">            t1 = pop();</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if (t1 instanceof String) {</span>
<span class="nc" id="L691">                pushDesc(((String) t1).substring(1));</span>
            } else {
<span class="nc" id="L693">                push(&quot;java/lang/Object&quot;);</span>
            }
<span class="nc" id="L695">            break;</span>
        case Opcodes.ISTORE:
        case Opcodes.FSTORE:
        case Opcodes.ASTORE:
<span class="nc" id="L699">            t1 = pop();</span>
<span class="nc" id="L700">            set(iarg, t1);</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">            if (iarg &gt; 0) {</span>
<span class="nc" id="L702">                t2 = get(iarg - 1);</span>
<span class="nc bnc" id="L703" title="All 4 branches missed.">                if (t2 == Opcodes.LONG || t2 == Opcodes.DOUBLE) {</span>
<span class="nc" id="L704">                    set(iarg - 1, Opcodes.TOP);</span>
                }
            }
            break;
        case Opcodes.LSTORE:
        case Opcodes.DSTORE:
<span class="nc" id="L710">            pop(1);</span>
<span class="nc" id="L711">            t1 = pop();</span>
<span class="nc" id="L712">            set(iarg, t1);</span>
<span class="nc" id="L713">            set(iarg + 1, Opcodes.TOP);</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">            if (iarg &gt; 0) {</span>
<span class="nc" id="L715">                t2 = get(iarg - 1);</span>
<span class="nc bnc" id="L716" title="All 4 branches missed.">                if (t2 == Opcodes.LONG || t2 == Opcodes.DOUBLE) {</span>
<span class="nc" id="L717">                    set(iarg - 1, Opcodes.TOP);</span>
                }
            }
            break;
        case Opcodes.IASTORE:
        case Opcodes.BASTORE:
        case Opcodes.CASTORE:
        case Opcodes.SASTORE:
        case Opcodes.FASTORE:
        case Opcodes.AASTORE:
<span class="nc" id="L727">            pop(3);</span>
<span class="nc" id="L728">            break;</span>
        case Opcodes.LASTORE:
        case Opcodes.DASTORE:
<span class="nc" id="L731">            pop(4);</span>
<span class="nc" id="L732">            break;</span>
        case Opcodes.POP:
        case Opcodes.IFEQ:
        case Opcodes.IFNE:
        case Opcodes.IFLT:
        case Opcodes.IFGE:
        case Opcodes.IFGT:
        case Opcodes.IFLE:
        case Opcodes.IRETURN:
        case Opcodes.FRETURN:
        case Opcodes.ARETURN:
        case Opcodes.TABLESWITCH:
        case Opcodes.LOOKUPSWITCH:
        case Opcodes.ATHROW:
        case Opcodes.MONITORENTER:
        case Opcodes.MONITOREXIT:
        case Opcodes.IFNULL:
        case Opcodes.IFNONNULL:
<span class="nc" id="L750">            pop(1);</span>
<span class="nc" id="L751">            break;</span>
        case Opcodes.POP2:
        case Opcodes.IF_ICMPEQ:
        case Opcodes.IF_ICMPNE:
        case Opcodes.IF_ICMPLT:
        case Opcodes.IF_ICMPGE:
        case Opcodes.IF_ICMPGT:
        case Opcodes.IF_ICMPLE:
        case Opcodes.IF_ACMPEQ:
        case Opcodes.IF_ACMPNE:
        case Opcodes.LRETURN:
        case Opcodes.DRETURN:
<span class="nc" id="L763">            pop(2);</span>
<span class="nc" id="L764">            break;</span>
        case Opcodes.DUP:
<span class="nc" id="L766">            t1 = pop();</span>
<span class="nc" id="L767">            push(t1);</span>
<span class="nc" id="L768">            push(t1);</span>
<span class="nc" id="L769">            break;</span>
        case Opcodes.DUP_X1:
<span class="nc" id="L771">            t1 = pop();</span>
<span class="nc" id="L772">            t2 = pop();</span>
<span class="nc" id="L773">            push(t1);</span>
<span class="nc" id="L774">            push(t2);</span>
<span class="nc" id="L775">            push(t1);</span>
<span class="nc" id="L776">            break;</span>
        case Opcodes.DUP_X2:
<span class="nc" id="L778">            t1 = pop();</span>
<span class="nc" id="L779">            t2 = pop();</span>
<span class="nc" id="L780">            t3 = pop();</span>
<span class="nc" id="L781">            push(t1);</span>
<span class="nc" id="L782">            push(t3);</span>
<span class="nc" id="L783">            push(t2);</span>
<span class="nc" id="L784">            push(t1);</span>
<span class="nc" id="L785">            break;</span>
        case Opcodes.DUP2:
<span class="nc" id="L787">            t1 = pop();</span>
<span class="nc" id="L788">            t2 = pop();</span>
<span class="nc" id="L789">            push(t2);</span>
<span class="nc" id="L790">            push(t1);</span>
<span class="nc" id="L791">            push(t2);</span>
<span class="nc" id="L792">            push(t1);</span>
<span class="nc" id="L793">            break;</span>
        case Opcodes.DUP2_X1:
<span class="nc" id="L795">            t1 = pop();</span>
<span class="nc" id="L796">            t2 = pop();</span>
<span class="nc" id="L797">            t3 = pop();</span>
<span class="nc" id="L798">            push(t2);</span>
<span class="nc" id="L799">            push(t1);</span>
<span class="nc" id="L800">            push(t3);</span>
<span class="nc" id="L801">            push(t2);</span>
<span class="nc" id="L802">            push(t1);</span>
<span class="nc" id="L803">            break;</span>
        case Opcodes.DUP2_X2:
<span class="nc" id="L805">            t1 = pop();</span>
<span class="nc" id="L806">            t2 = pop();</span>
<span class="nc" id="L807">            t3 = pop();</span>
<span class="nc" id="L808">            t4 = pop();</span>
<span class="nc" id="L809">            push(t2);</span>
<span class="nc" id="L810">            push(t1);</span>
<span class="nc" id="L811">            push(t4);</span>
<span class="nc" id="L812">            push(t3);</span>
<span class="nc" id="L813">            push(t2);</span>
<span class="nc" id="L814">            push(t1);</span>
<span class="nc" id="L815">            break;</span>
        case Opcodes.SWAP:
<span class="nc" id="L817">            t1 = pop();</span>
<span class="nc" id="L818">            t2 = pop();</span>
<span class="nc" id="L819">            push(t1);</span>
<span class="nc" id="L820">            push(t2);</span>
<span class="nc" id="L821">            break;</span>
        case Opcodes.IADD:
        case Opcodes.ISUB:
        case Opcodes.IMUL:
        case Opcodes.IDIV:
        case Opcodes.IREM:
        case Opcodes.IAND:
        case Opcodes.IOR:
        case Opcodes.IXOR:
        case Opcodes.ISHL:
        case Opcodes.ISHR:
        case Opcodes.IUSHR:
        case Opcodes.L2I:
        case Opcodes.D2I:
        case Opcodes.FCMPL:
        case Opcodes.FCMPG:
<span class="nc" id="L837">            pop(2);</span>
<span class="nc" id="L838">            push(Opcodes.INTEGER);</span>
<span class="nc" id="L839">            break;</span>
        case Opcodes.LADD:
        case Opcodes.LSUB:
        case Opcodes.LMUL:
        case Opcodes.LDIV:
        case Opcodes.LREM:
        case Opcodes.LAND:
        case Opcodes.LOR:
        case Opcodes.LXOR:
<span class="nc" id="L848">            pop(4);</span>
<span class="nc" id="L849">            push(Opcodes.LONG);</span>
<span class="nc" id="L850">            push(Opcodes.TOP);</span>
<span class="nc" id="L851">            break;</span>
        case Opcodes.FADD:
        case Opcodes.FSUB:
        case Opcodes.FMUL:
        case Opcodes.FDIV:
        case Opcodes.FREM:
        case Opcodes.L2F:
        case Opcodes.D2F:
<span class="nc" id="L859">            pop(2);</span>
<span class="nc" id="L860">            push(Opcodes.FLOAT);</span>
<span class="nc" id="L861">            break;</span>
        case Opcodes.DADD:
        case Opcodes.DSUB:
        case Opcodes.DMUL:
        case Opcodes.DDIV:
        case Opcodes.DREM:
<span class="nc" id="L867">            pop(4);</span>
<span class="nc" id="L868">            push(Opcodes.DOUBLE);</span>
<span class="nc" id="L869">            push(Opcodes.TOP);</span>
<span class="nc" id="L870">            break;</span>
        case Opcodes.LSHL:
        case Opcodes.LSHR:
        case Opcodes.LUSHR:
<span class="nc" id="L874">            pop(3);</span>
<span class="nc" id="L875">            push(Opcodes.LONG);</span>
<span class="nc" id="L876">            push(Opcodes.TOP);</span>
<span class="nc" id="L877">            break;</span>
        case Opcodes.IINC:
<span class="nc" id="L879">            set(iarg, Opcodes.INTEGER);</span>
<span class="nc" id="L880">            break;</span>
        case Opcodes.I2L:
        case Opcodes.F2L:
<span class="nc" id="L883">            pop(1);</span>
<span class="nc" id="L884">            push(Opcodes.LONG);</span>
<span class="nc" id="L885">            push(Opcodes.TOP);</span>
<span class="nc" id="L886">            break;</span>
        case Opcodes.I2F:
<span class="nc" id="L888">            pop(1);</span>
<span class="nc" id="L889">            push(Opcodes.FLOAT);</span>
<span class="nc" id="L890">            break;</span>
        case Opcodes.I2D:
        case Opcodes.F2D:
<span class="nc" id="L893">            pop(1);</span>
<span class="nc" id="L894">            push(Opcodes.DOUBLE);</span>
<span class="nc" id="L895">            push(Opcodes.TOP);</span>
<span class="nc" id="L896">            break;</span>
        case Opcodes.F2I:
        case Opcodes.ARRAYLENGTH:
        case Opcodes.INSTANCEOF:
<span class="nc" id="L900">            pop(1);</span>
<span class="nc" id="L901">            push(Opcodes.INTEGER);</span>
<span class="nc" id="L902">            break;</span>
        case Opcodes.LCMP:
        case Opcodes.DCMPL:
        case Opcodes.DCMPG:
<span class="nc" id="L906">            pop(4);</span>
<span class="nc" id="L907">            push(Opcodes.INTEGER);</span>
<span class="nc" id="L908">            break;</span>
        case Opcodes.JSR:
        case Opcodes.RET:
<span class="nc" id="L911">            throw new RuntimeException(&quot;JSR/RET are not supported&quot;);</span>
        case Opcodes.GETSTATIC:
<span class="nc" id="L913">            pushDesc(sarg);</span>
<span class="nc" id="L914">            break;</span>
        case Opcodes.PUTSTATIC:
<span class="nc" id="L916">            pop(sarg);</span>
<span class="nc" id="L917">            break;</span>
        case Opcodes.GETFIELD:
<span class="nc" id="L919">            pop(1);</span>
<span class="nc" id="L920">            pushDesc(sarg);</span>
<span class="nc" id="L921">            break;</span>
        case Opcodes.PUTFIELD:
<span class="nc" id="L923">            pop(sarg);</span>
<span class="nc" id="L924">            pop();</span>
<span class="nc" id="L925">            break;</span>
        case Opcodes.NEW:
<span class="nc" id="L927">            push(labels.get(0));</span>
<span class="nc" id="L928">            break;</span>
        case Opcodes.NEWARRAY:
<span class="nc" id="L930">            pop();</span>
<span class="nc bnc" id="L931" title="All 8 branches missed.">            switch (iarg) {</span>
            case Opcodes.T_BOOLEAN:
<span class="nc" id="L933">                pushDesc(&quot;[Z&quot;);</span>
<span class="nc" id="L934">                break;</span>
            case Opcodes.T_CHAR:
<span class="nc" id="L936">                pushDesc(&quot;[C&quot;);</span>
<span class="nc" id="L937">                break;</span>
            case Opcodes.T_BYTE:
<span class="nc" id="L939">                pushDesc(&quot;[B&quot;);</span>
<span class="nc" id="L940">                break;</span>
            case Opcodes.T_SHORT:
<span class="nc" id="L942">                pushDesc(&quot;[S&quot;);</span>
<span class="nc" id="L943">                break;</span>
            case Opcodes.T_INT:
<span class="nc" id="L945">                pushDesc(&quot;[I&quot;);</span>
<span class="nc" id="L946">                break;</span>
            case Opcodes.T_FLOAT:
<span class="nc" id="L948">                pushDesc(&quot;[F&quot;);</span>
<span class="nc" id="L949">                break;</span>
            case Opcodes.T_DOUBLE:
<span class="nc" id="L951">                pushDesc(&quot;[D&quot;);</span>
<span class="nc" id="L952">                break;</span>
            // case Opcodes.T_LONG:
            default:
<span class="nc" id="L955">                pushDesc(&quot;[J&quot;);</span>
<span class="nc" id="L956">                break;</span>
            }
            break;
        case Opcodes.ANEWARRAY:
<span class="nc" id="L960">            pop();</span>
<span class="nc" id="L961">            pushDesc(&quot;[&quot; + Type.getObjectType(sarg));</span>
<span class="nc" id="L962">            break;</span>
        case Opcodes.CHECKCAST:
<span class="nc" id="L964">            pop();</span>
<span class="nc" id="L965">            pushDesc(Type.getObjectType(sarg).getDescriptor());</span>
<span class="nc" id="L966">            break;</span>
        // case Opcodes.MULTIANEWARRAY:
        default:
<span class="nc" id="L969">            pop(iarg);</span>
<span class="nc" id="L970">            pushDesc(sarg);</span>
            break;
        }
<span class="nc" id="L973">        labels = null;</span>
<span class="nc" id="L974">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>