<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ThreadImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.management</a> &gt; <span class="el_source">ThreadImpl.java</span></div><h1>ThreadImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.management;

import java.lang.management.ManagementFactory;

import java.lang.management.ThreadInfo;

import javax.management.ObjectName;

/**
 * Implementation class for the thread subsystem.
 * Standard and committed hotspot-specific metrics if any.
 *
 * ManagementFactory.getThreadMXBean() returns an instance
 * of this class.
 */
class ThreadImpl implements com.sun.management.ThreadMXBean {

    private final VMManagement jvm;

    // default for thread contention monitoring is disabled.
<span class="fc" id="L46">    private boolean contentionMonitoringEnabled = false;</span>
    private boolean cpuTimeEnabled;
    private boolean allocatedMemoryEnabled;

    /**
     * Constructor of ThreadImpl class.
     */
<span class="fc" id="L53">    ThreadImpl(VMManagement vm) {</span>
<span class="fc" id="L54">        this.jvm = vm;</span>
<span class="fc" id="L55">        this.cpuTimeEnabled = jvm.isThreadCpuTimeEnabled();</span>
<span class="fc" id="L56">        this.allocatedMemoryEnabled = jvm.isThreadAllocatedMemoryEnabled();</span>
<span class="fc" id="L57">    }</span>

    public int getThreadCount() {
<span class="nc" id="L60">        return jvm.getLiveThreadCount();</span>
    }

    public int getPeakThreadCount() {
<span class="nc" id="L64">        return jvm.getPeakThreadCount();</span>
    }

    public long getTotalStartedThreadCount() {
<span class="nc" id="L68">        return jvm.getTotalThreadCount();</span>
    }

    public int getDaemonThreadCount() {
<span class="nc" id="L72">        return jvm.getDaemonThreadCount();</span>
    }

    public boolean isThreadContentionMonitoringSupported() {
<span class="nc" id="L76">        return jvm.isThreadContentionMonitoringSupported();</span>
    }

    public synchronized boolean isThreadContentionMonitoringEnabled() {
<span class="nc bnc" id="L80" title="All 2 branches missed.">       if (!isThreadContentionMonitoringSupported()) {</span>
<span class="nc" id="L81">            throw new UnsupportedOperationException(</span>
                &quot;Thread contention monitoring is not supported.&quot;);
        }
<span class="nc" id="L84">        return contentionMonitoringEnabled;</span>
    }

    public boolean isThreadCpuTimeSupported() {
<span class="fc" id="L88">        return jvm.isOtherThreadCpuTimeSupported();</span>
    }

    public boolean isCurrentThreadCpuTimeSupported() {
<span class="nc" id="L92">        return jvm.isCurrentThreadCpuTimeSupported();</span>
    }

    public boolean isThreadAllocatedMemorySupported() {
<span class="nc" id="L96">        return jvm.isThreadAllocatedMemorySupported();</span>
    }

    public boolean isThreadCpuTimeEnabled() {
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if (!isThreadCpuTimeSupported() &amp;&amp;</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">            !isCurrentThreadCpuTimeSupported()) {</span>
<span class="nc" id="L102">            throw new UnsupportedOperationException(</span>
                &quot;Thread CPU time measurement is not supported&quot;);
        }
<span class="fc" id="L105">        return cpuTimeEnabled;</span>
    }

    public boolean isThreadAllocatedMemoryEnabled() {
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (!isThreadAllocatedMemorySupported()) {</span>
<span class="nc" id="L110">            throw new UnsupportedOperationException(</span>
                &quot;Thread allocated memory measurement is not supported&quot;);
        }
<span class="nc" id="L113">        return allocatedMemoryEnabled;</span>
    }

    public long[] getAllThreadIds() {
<span class="fc" id="L117">        Util.checkMonitorAccess();</span>

<span class="fc" id="L119">        Thread[] threads = getThreads();</span>
<span class="fc" id="L120">        int length = threads.length;</span>
<span class="fc" id="L121">        long[] ids = new long[length];</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L123">            Thread t = threads[i];</span>
<span class="fc" id="L124">            ids[i] = t.getId();</span>
        }
<span class="fc" id="L126">        return ids;</span>
    }

    public ThreadInfo getThreadInfo(long id) {
<span class="nc" id="L130">        long[] ids = new long[1];</span>
<span class="nc" id="L131">        ids[0] = id;</span>
<span class="nc" id="L132">        final ThreadInfo[] infos = getThreadInfo(ids, 0);</span>
<span class="nc" id="L133">        return infos[0];</span>
    }

    public ThreadInfo getThreadInfo(long id, int maxDepth) {
<span class="nc" id="L137">        long[] ids = new long[1];</span>
<span class="nc" id="L138">        ids[0] = id;</span>
<span class="nc" id="L139">        final ThreadInfo[] infos = getThreadInfo(ids, maxDepth);</span>
<span class="nc" id="L140">        return infos[0];</span>
    }

    public ThreadInfo[] getThreadInfo(long[] ids) {
<span class="fc" id="L144">        return getThreadInfo(ids, 0);</span>
    }

    private void verifyThreadIds(long[] ids) {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (ids == null) {</span>
<span class="nc" id="L149">            throw new NullPointerException(&quot;Null ids parameter.&quot;);</span>
        }

<span class="fc bfc" id="L152" title="All 2 branches covered.">        for (int i = 0; i &lt; ids.length; i++) {</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">            if (ids[i] &lt;= 0) {</span>
<span class="nc" id="L154">                throw new IllegalArgumentException(</span>
                    &quot;Invalid thread ID parameter: &quot; + ids[i]);
            }
        }
<span class="fc" id="L158">    }</span>

    public ThreadInfo[] getThreadInfo(long[] ids, int maxDepth) {
<span class="fc" id="L161">        verifyThreadIds(ids);</span>

<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (maxDepth &lt; 0) {</span>
<span class="nc" id="L164">            throw new IllegalArgumentException(</span>
                &quot;Invalid maxDepth parameter: &quot; + maxDepth);
        }

<span class="fc" id="L168">        Util.checkMonitorAccess();</span>

<span class="fc" id="L170">        ThreadInfo[] infos = new ThreadInfo[ids.length]; // nulls</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (maxDepth == Integer.MAX_VALUE) {</span>
<span class="nc" id="L172">            getThreadInfo1(ids, -1, infos);</span>
        } else {
<span class="fc" id="L174">            getThreadInfo1(ids, maxDepth, infos);</span>
        }
<span class="fc" id="L176">        return infos;</span>
    }

    public void setThreadContentionMonitoringEnabled(boolean enable) {
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (!isThreadContentionMonitoringSupported()) {</span>
<span class="nc" id="L181">            throw new UnsupportedOperationException(</span>
                &quot;Thread contention monitoring is not supported&quot;);
        }

<span class="nc" id="L185">        Util.checkControlAccess();</span>

<span class="nc" id="L187">        synchronized (this) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (contentionMonitoringEnabled != enable) {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                if (enable) {</span>
                    // if reeabled, reset contention time statistics
                    // for all threads
<span class="nc" id="L192">                    resetContentionTimes0(0);</span>
                }

                // update the VM of the state change
<span class="nc" id="L196">                setThreadContentionMonitoringEnabled0(enable);</span>

<span class="nc" id="L198">                contentionMonitoringEnabled = enable;</span>
            }
<span class="nc" id="L200">        }</span>
<span class="nc" id="L201">    }</span>

    private boolean verifyCurrentThreadCpuTime() {
        // check if Thread CPU time measurement is supported.
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (!isCurrentThreadCpuTimeSupported()) {</span>
<span class="nc" id="L206">            throw new UnsupportedOperationException(</span>
                &quot;Current thread CPU time measurement is not supported.&quot;);
        }
<span class="nc" id="L209">        return isThreadCpuTimeEnabled();</span>
    }

    public long getCurrentThreadCpuTime() {
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (verifyCurrentThreadCpuTime()) {</span>
<span class="nc" id="L214">            return getThreadTotalCpuTime0(0);</span>
        }
<span class="nc" id="L216">        return -1;</span>
    }

    public long getThreadCpuTime(long id) {
<span class="fc" id="L220">        long[] ids = new long[1];</span>
<span class="fc" id="L221">        ids[0] = id;</span>
<span class="fc" id="L222">        final long[] times = getThreadCpuTime(ids);</span>
<span class="fc" id="L223">        return times[0];</span>
    }

    private boolean verifyThreadCpuTime(long[] ids) {
<span class="fc" id="L227">        verifyThreadIds(ids);</span>

        // check if Thread CPU time measurement is supported.
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        if (!isThreadCpuTimeSupported() &amp;&amp;</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            !isCurrentThreadCpuTimeSupported()) {</span>
<span class="nc" id="L232">            throw new UnsupportedOperationException(</span>
                &quot;Thread CPU time measurement is not supported.&quot;);
        }

<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        if (!isThreadCpuTimeSupported()) {</span>
            // support current thread only
<span class="nc bnc" id="L238" title="All 2 branches missed.">            for (int i = 0; i &lt; ids.length; i++) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                if (ids[i] != Thread.currentThread().getId()) {</span>
<span class="nc" id="L240">                    throw new UnsupportedOperationException(</span>
                        &quot;Thread CPU time measurement is only supported&quot; +
                        &quot; for the current thread.&quot;);
                }
            }
        }

<span class="fc" id="L247">        return isThreadCpuTimeEnabled();</span>
    }

    public long[] getThreadCpuTime(long[] ids) {
<span class="fc" id="L251">        boolean verified = verifyThreadCpuTime(ids);</span>

<span class="fc" id="L253">        int length = ids.length;</span>
<span class="fc" id="L254">        long[] times = new long[length];</span>
<span class="fc" id="L255">        java.util.Arrays.fill(times, -1);</span>

<span class="pc bpc" id="L257" title="1 of 2 branches missed.">        if (verified) {</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">            if (length == 1) {</span>
<span class="fc" id="L259">                long id = ids[0];</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">                if (id == Thread.currentThread().getId()) {</span>
<span class="nc" id="L261">                    id = 0;</span>
                }
<span class="fc" id="L263">                times[0] = getThreadTotalCpuTime0(id);</span>
<span class="fc" id="L264">            } else {</span>
<span class="nc" id="L265">                getThreadTotalCpuTime1(ids, times);</span>
            }
        }
<span class="fc" id="L268">        return times;</span>
    }

    public long getCurrentThreadUserTime() {
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (verifyCurrentThreadCpuTime()) {</span>
<span class="nc" id="L273">            return getThreadUserCpuTime0(0);</span>
        }
<span class="nc" id="L275">        return -1;</span>
    }

    public long getThreadUserTime(long id) {
<span class="nc" id="L279">        long[] ids = new long[1];</span>
<span class="nc" id="L280">        ids[0] = id;</span>
<span class="nc" id="L281">        final long[] times = getThreadUserTime(ids);</span>
<span class="nc" id="L282">        return times[0];</span>
    }

    public long[] getThreadUserTime(long[] ids) {
<span class="nc" id="L286">        boolean verified = verifyThreadCpuTime(ids);</span>

<span class="nc" id="L288">        int length = ids.length;</span>
<span class="nc" id="L289">        long[] times = new long[length];</span>
<span class="nc" id="L290">        java.util.Arrays.fill(times, -1);</span>

<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (verified) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (length == 1) {</span>
<span class="nc" id="L294">                long id = ids[0];</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">                if (id == Thread.currentThread().getId()) {</span>
<span class="nc" id="L296">                    id = 0;</span>
                }
<span class="nc" id="L298">                times[0] = getThreadUserCpuTime0(id);</span>
<span class="nc" id="L299">            } else {</span>
<span class="nc" id="L300">                getThreadUserCpuTime1(ids, times);</span>
            }
        }
<span class="nc" id="L303">        return times;</span>
    }

    public void setThreadCpuTimeEnabled(boolean enable) {
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (!isThreadCpuTimeSupported() &amp;&amp;</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">            !isCurrentThreadCpuTimeSupported()) {</span>
<span class="nc" id="L309">            throw new UnsupportedOperationException(</span>
                &quot;Thread CPU time measurement is not supported&quot;);
        }

<span class="nc" id="L313">        Util.checkControlAccess();</span>
<span class="nc" id="L314">        synchronized (this) {</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (cpuTimeEnabled != enable) {</span>
                // notify VM of the state change
<span class="nc" id="L317">                setThreadCpuTimeEnabled0(enable);</span>
<span class="nc" id="L318">                cpuTimeEnabled = enable;</span>
            }
<span class="nc" id="L320">        }</span>
<span class="nc" id="L321">    }</span>

    public long getThreadAllocatedBytes(long id) {
<span class="nc" id="L324">        long[] ids = new long[1];</span>
<span class="nc" id="L325">        ids[0] = id;</span>
<span class="nc" id="L326">        final long[] sizes = getThreadAllocatedBytes(ids);</span>
<span class="nc" id="L327">        return sizes[0];</span>
    }

    private boolean verifyThreadAllocatedMemory(long[] ids) {
<span class="nc" id="L331">        verifyThreadIds(ids);</span>

        // check if Thread allocated memory measurement is supported.
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (!isThreadAllocatedMemorySupported()) {</span>
<span class="nc" id="L335">            throw new UnsupportedOperationException(</span>
                &quot;Thread allocated memory measurement is not supported.&quot;);
        }

<span class="nc" id="L339">        return isThreadAllocatedMemoryEnabled();</span>
    }

    public long[] getThreadAllocatedBytes(long[] ids) {
<span class="nc" id="L343">        boolean verified = verifyThreadAllocatedMemory(ids);</span>

<span class="nc" id="L345">        long[] sizes = new long[ids.length];</span>
<span class="nc" id="L346">        java.util.Arrays.fill(sizes, -1);</span>

<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (verified) {</span>
<span class="nc" id="L349">            getThreadAllocatedMemory1(ids, sizes);</span>
        }
<span class="nc" id="L351">        return sizes;</span>
    }

    public void setThreadAllocatedMemoryEnabled(boolean enable) {
<span class="nc bnc" id="L355" title="All 2 branches missed.">        if (!isThreadAllocatedMemorySupported()) {</span>
<span class="nc" id="L356">            throw new UnsupportedOperationException(</span>
                &quot;Thread allocated memory measurement is not supported.&quot;);
        }

<span class="nc" id="L360">        Util.checkControlAccess();</span>
<span class="nc" id="L361">        synchronized (this) {</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">            if (allocatedMemoryEnabled != enable) {</span>
                // notify VM of the state change
<span class="nc" id="L364">                setThreadAllocatedMemoryEnabled0(enable);</span>
<span class="nc" id="L365">                allocatedMemoryEnabled = enable;</span>
            }
<span class="nc" id="L367">        }</span>
<span class="nc" id="L368">    }</span>

    public long[] findMonitorDeadlockedThreads() {
<span class="nc" id="L371">        Util.checkMonitorAccess();</span>

<span class="nc" id="L373">        Thread[] threads = findMonitorDeadlockedThreads0();</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (threads == null) {</span>
<span class="nc" id="L375">            return null;</span>
        }

<span class="nc" id="L378">        long[] ids = new long[threads.length];</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">        for (int i = 0; i &lt; threads.length; i++) {</span>
<span class="nc" id="L380">            Thread t = threads[i];</span>
<span class="nc" id="L381">            ids[i] = t.getId();</span>
        }
<span class="nc" id="L383">        return ids;</span>
    }

    public long[] findDeadlockedThreads() {
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (!isSynchronizerUsageSupported()) {</span>
<span class="nc" id="L388">            throw new UnsupportedOperationException(</span>
                &quot;Monitoring of Synchronizer Usage is not supported.&quot;);
        }

<span class="fc" id="L392">        Util.checkMonitorAccess();</span>

<span class="fc" id="L394">        Thread[] threads = findDeadlockedThreads0();</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        if (threads == null) {</span>
<span class="fc" id="L396">            return null;</span>
        }

<span class="nc" id="L399">        long[] ids = new long[threads.length];</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        for (int i = 0; i &lt; threads.length; i++) {</span>
<span class="nc" id="L401">            Thread t = threads[i];</span>
<span class="nc" id="L402">            ids[i] = t.getId();</span>
        }
<span class="nc" id="L404">        return ids;</span>
    }

    public void resetPeakThreadCount() {
<span class="nc" id="L408">        Util.checkControlAccess();</span>
<span class="nc" id="L409">        resetPeakThreadCount0();</span>
<span class="nc" id="L410">    }</span>

    public boolean isObjectMonitorUsageSupported() {
<span class="nc" id="L413">        return jvm.isObjectMonitorUsageSupported();</span>
    }

    public boolean isSynchronizerUsageSupported() {
<span class="fc" id="L417">        return jvm.isSynchronizerUsageSupported();</span>
    }

    private void verifyDumpThreads(boolean lockedMonitors,
                                   boolean lockedSynchronizers) {
<span class="nc bnc" id="L422" title="All 4 branches missed.">        if (lockedMonitors &amp;&amp; !isObjectMonitorUsageSupported()) {</span>
<span class="nc" id="L423">            throw new UnsupportedOperationException(</span>
                &quot;Monitoring of Object Monitor Usage is not supported.&quot;);
        }

<span class="nc bnc" id="L427" title="All 4 branches missed.">        if (lockedSynchronizers &amp;&amp; !isSynchronizerUsageSupported()) {</span>
<span class="nc" id="L428">            throw new UnsupportedOperationException(</span>
                &quot;Monitoring of Synchronizer Usage is not supported.&quot;);
        }

<span class="nc" id="L432">        Util.checkMonitorAccess();</span>
<span class="nc" id="L433">    }</span>

    public ThreadInfo[] getThreadInfo(long[] ids,
                                      boolean lockedMonitors,
                                      boolean lockedSynchronizers) {
<span class="nc" id="L438">        verifyThreadIds(ids);</span>
<span class="nc" id="L439">        verifyDumpThreads(lockedMonitors, lockedSynchronizers);</span>
<span class="nc" id="L440">        return dumpThreads0(ids, lockedMonitors, lockedSynchronizers);</span>
    }

    public ThreadInfo[] dumpAllThreads(boolean lockedMonitors,
                                       boolean lockedSynchronizers) {
<span class="nc" id="L445">        verifyDumpThreads(lockedMonitors, lockedSynchronizers);</span>
<span class="nc" id="L446">        return dumpThreads0(null, lockedMonitors, lockedSynchronizers);</span>
    }

    // VM support where maxDepth == -1 to request entire stack dump
    private static native Thread[] getThreads();
    private static native void getThreadInfo1(long[] ids,
                                              int maxDepth,
                                              ThreadInfo[] result);
    private static native long getThreadTotalCpuTime0(long id);
    private static native void getThreadTotalCpuTime1(long[] ids, long[] result);
    private static native long getThreadUserCpuTime0(long id);
    private static native void getThreadUserCpuTime1(long[] ids, long[] result);
    private static native void getThreadAllocatedMemory1(long[] ids, long[] result);
    private static native void setThreadCpuTimeEnabled0(boolean enable);
    private static native void setThreadAllocatedMemoryEnabled0(boolean enable);
    private static native void setThreadContentionMonitoringEnabled0(boolean enable);
    private static native Thread[] findMonitorDeadlockedThreads0();
    private static native Thread[] findDeadlockedThreads0();
    private static native void resetPeakThreadCount0();
    private static native ThreadInfo[] dumpThreads0(long[] ids,
                                                    boolean lockedMonitors,
                                                    boolean lockedSynchronizers);

    // tid == 0 to reset contention times for all threads
    private static native void resetContentionTimes0(long tid);

    public ObjectName getObjectName() {
<span class="nc" id="L473">        return Util.newObjectName(ManagementFactory.THREAD_MXBEAN_NAME);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>