<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MimeType.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.print</a> &gt; <span class="el_source">MimeType.java</span></div><h1>MimeType.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.print;

import java.io.Serializable;

import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.Vector;

/**
 * Class MimeType encapsulates a Multipurpose Internet Mail Extensions (MIME)
 * media type as defined in &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC
 * 2045&lt;/A&gt; and &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/A&gt;. A
 * MIME type object is part of a {@link DocFlavor DocFlavor} object and
 * specifies the format of the print data.
 * &lt;P&gt;
 * Class MimeType is similar to the like-named
 * class in package {@link java.awt.datatransfer java.awt.datatransfer}. Class
 * java.awt.datatransfer.MimeType is not used in the Jini Print Service API
 * for two reasons:
 * &lt;OL TYPE=1&gt;
 * &lt;LI&gt;
 * Since not all Java profiles include the AWT, the Jini Print Service should
 * not depend on an AWT class.
 * &lt;P&gt;
 * &lt;LI&gt;
 * The implementation of class java.awt.datatransfer.MimeType does not
 * guarantee
 * that equivalent MIME types will have the same serialized representation.
 * Thus, since the Jini Lookup Service (JLUS) matches service attributes based
 * on equality of serialized representations, JLUS searches involving MIME
 * types encapsulated in class java.awt.datatransfer.MimeType may incorrectly
 * fail to match.
 * &lt;/OL&gt;
 * &lt;P&gt;
 * Class MimeType's serialized representation is based on the following
 * canonical form of a MIME type string. Thus, two MIME types that are not
 * identical but that are equivalent (that have the same canonical form) will
 * be considered equal by the JLUS's matching algorithm.
 * &lt;UL&gt;
 * &lt;LI&gt; The media type, media subtype, and parameters are retained, but all
 *      comments and whitespace characters are discarded.
 * &lt;LI&gt; The media type, media subtype, and parameter names are converted to
 *      lowercase.
 * &lt;LI&gt; The parameter values retain their original case, except a charset
 *      parameter value for a text media type is converted to lowercase.
 * &lt;LI&gt; Quote characters surrounding parameter values are removed.
 * &lt;LI&gt; Quoting backslash characters inside parameter values are removed.
 * &lt;LI&gt; The parameters are arranged in ascending order of parameter name.
 * &lt;/UL&gt;
 * &lt;P&gt;
 *
 * @author  Alan Kaminsky
 */
class MimeType implements Serializable, Cloneable {

    private static final long serialVersionUID = -2785720609362367683L;

    /**
     * Array of strings that hold pieces of this MIME type's canonical form.
     * If the MIME type has &lt;I&gt;n&lt;/I&gt; parameters, &lt;I&gt;n&lt;/I&gt; &amp;gt;= 0, then the
     * strings in the array are:
     * &lt;BR&gt;Index 0 -- Media type.
     * &lt;BR&gt;Index 1 -- Media subtype.
     * &lt;BR&gt;Index 2&lt;I&gt;i&lt;/I&gt;+2 -- Name of parameter &lt;I&gt;i&lt;/I&gt;,
     * &lt;I&gt;i&lt;/I&gt;=0,1,...,&lt;I&gt;n&lt;/I&gt;-1.
     * &lt;BR&gt;Index 2&lt;I&gt;i&lt;/I&gt;+3 -- Value of parameter &lt;I&gt;i&lt;/I&gt;,
     * &lt;I&gt;i&lt;/I&gt;=0,1,...,&lt;I&gt;n&lt;/I&gt;-1.
     * &lt;BR&gt;Parameters are arranged in ascending order of parameter name.
     * @serial
     */
    private String[] myPieces;

    /**
     * String value for this MIME type. Computed when needed and cached.
     */
<span class="nc" id="L105">    private transient String myStringValue = null;</span>

    /**
     * Parameter map entry set. Computed when needed and cached.
     */
<span class="nc" id="L110">    private transient ParameterMapEntrySet myEntrySet = null;</span>

    /**
     * Parameter map. Computed when needed and cached.
     */
<span class="nc" id="L115">    private transient ParameterMap myParameterMap = null;</span>

    /**
     * Parameter map entry.
     */
    private class ParameterMapEntry implements Map.Entry {
        private int myIndex;
<span class="nc" id="L122">        public ParameterMapEntry(int theIndex) {</span>
<span class="nc" id="L123">            myIndex = theIndex;</span>
<span class="nc" id="L124">        }</span>
        public Object getKey(){
<span class="nc" id="L126">            return myPieces[myIndex];</span>
        }
        public Object getValue(){
<span class="nc" id="L129">            return myPieces[myIndex+1];</span>
        }
        public Object setValue (Object value) {
<span class="nc" id="L132">            throw new UnsupportedOperationException();</span>
        }
        public boolean equals(Object o) {
<span class="nc bnc" id="L135" title="All 4 branches missed.">            return (o != null &amp;&amp;</span>
                    o instanceof Map.Entry &amp;&amp;
<span class="nc bnc" id="L137" title="All 2 branches missed.">                    getKey().equals (((Map.Entry) o).getKey()) &amp;&amp;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                    getValue().equals(((Map.Entry) o).getValue()));</span>
        }
        public int hashCode() {
<span class="nc" id="L141">            return getKey().hashCode() ^ getValue().hashCode();</span>
        }
    }

    /**
     * Parameter map entry set iterator.
     */
<span class="nc" id="L148">    private class ParameterMapEntrySetIterator implements Iterator {</span>
<span class="nc" id="L149">        private int myIndex = 2;</span>
        public boolean hasNext() {
<span class="nc bnc" id="L151" title="All 2 branches missed.">            return myIndex &lt; myPieces.length;</span>
        }
        public Object next() {
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (hasNext()) {</span>
<span class="nc" id="L155">                ParameterMapEntry result = new ParameterMapEntry (myIndex);</span>
<span class="nc" id="L156">                myIndex += 2;</span>
<span class="nc" id="L157">                return result;</span>
            } else {
<span class="nc" id="L159">                throw new NoSuchElementException();</span>
            }
        }
        public void remove() {
<span class="nc" id="L163">            throw new UnsupportedOperationException();</span>
        }
    }

    /**
     * Parameter map entry set.
     */
<span class="nc" id="L170">    private class ParameterMapEntrySet extends AbstractSet {</span>
        public Iterator iterator() {
<span class="nc" id="L172">            return new ParameterMapEntrySetIterator();</span>
        }
        public int size() {
<span class="nc" id="L175">            return (myPieces.length - 2) / 2;</span>
        }
    }

    /**
     * Parameter map.
     */
<span class="nc" id="L182">    private class ParameterMap extends AbstractMap {</span>
        public Set entrySet() {
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (myEntrySet == null) {</span>
<span class="nc" id="L185">                myEntrySet = new ParameterMapEntrySet();</span>
            }
<span class="nc" id="L187">            return myEntrySet;</span>
        }
    }

    /**
     * Construct a new MIME type object from the given string. The given
     * string is converted into canonical form and stored internally.
     *
     * @param  s  MIME media type string.
     *
     * @exception  NullPointerException
     *     (unchecked exception) Thrown if &lt;CODE&gt;s&lt;/CODE&gt; is null.
     * @exception  IllegalArgumentException
     *     (unchecked exception) Thrown if &lt;CODE&gt;s&lt;/CODE&gt; does not obey the
     *     syntax for a MIME media type string.
     */
<span class="nc" id="L203">    public MimeType(String s) {</span>
<span class="nc" id="L204">        parse (s);</span>
<span class="nc" id="L205">    }</span>

    /**
     * Returns this MIME type object's MIME type string based on the canonical
     * form. Each parameter value is enclosed in quotes.
     */
    public String getMimeType() {
<span class="nc" id="L212">        return getStringValue();</span>
    }

    /**
     * Returns this MIME type object's media type.
     */
    public String getMediaType() {
<span class="nc" id="L219">        return myPieces[0];</span>
    }

    /**
     * Returns this MIME type object's media subtype.
     */
    public String getMediaSubtype() {
<span class="nc" id="L226">        return myPieces[1];</span>
    }

    /**
     * Returns an unmodifiable map view of the parameters in this MIME type
     * object. Each entry in the parameter map view consists of a parameter
     * name String (key) mapping to a parameter value String. If this MIME
     * type object has no parameters, an empty map is returned.
     *
     * @return  Parameter map for this MIME type object.
     */
    public Map getParameterMap() {
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (myParameterMap == null) {</span>
<span class="nc" id="L239">            myParameterMap = new ParameterMap();</span>
        }
<span class="nc" id="L241">        return myParameterMap;</span>
    }

    /**
     * Converts this MIME type object to a string.
     *
     * @return  MIME type string based on the canonical form. Each parameter
     *          value is enclosed in quotes.
     */
    public String toString() {
<span class="nc" id="L251">        return getStringValue();</span>
    }

    /**
     * Returns a hash code for this MIME type object.
     */
    public int hashCode() {
<span class="nc" id="L258">        return getStringValue().hashCode();</span>
    }

    /**
     * Determine if this MIME type object is equal to the given object. The two
     * are equal if the given object is not null, is an instance of class
     * net.jini.print.data.MimeType, and has the same canonical form as this
     * MIME type object (that is, has the same type, subtype, and parameters).
     * Thus, if two MIME type objects are the same except for comments, they are
     * considered equal. However, &quot;text/plain&quot; and &quot;text/plain;
     * charset=us-ascii&quot; are not considered equal, even though they represent
     * the same media type (because the default character set for plain text is
     * US-ASCII).
     *
     * @param  obj  Object to test.
     *
     * @return  True if this MIME type object equals &lt;CODE&gt;obj&lt;/CODE&gt;, false
     *          otherwise.
     */
    public boolean equals (Object obj) {
<span class="nc bnc" id="L278" title="All 4 branches missed.">        return(obj != null &amp;&amp;</span>
               obj instanceof MimeType &amp;&amp;
<span class="nc bnc" id="L280" title="All 2 branches missed.">               getStringValue().equals(((MimeType) obj).getStringValue()));</span>
    }

    /**
     * Returns this MIME type's string value in canonical form.
     */
    private String getStringValue() {
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (myStringValue == null) {</span>
<span class="nc" id="L288">            StringBuffer result = new StringBuffer();</span>
<span class="nc" id="L289">            result.append (myPieces[0]);</span>
<span class="nc" id="L290">            result.append ('/');</span>
<span class="nc" id="L291">            result.append (myPieces[1]);</span>
<span class="nc" id="L292">            int n = myPieces.length;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            for (int i = 2; i &lt; n; i += 2) {</span>
<span class="nc" id="L294">                result.append(';');</span>
<span class="nc" id="L295">                result.append(' ');</span>
<span class="nc" id="L296">                result.append(myPieces[i]);</span>
<span class="nc" id="L297">                result.append('=');</span>
<span class="nc" id="L298">                result.append(addQuotes (myPieces[i+1]));</span>
            }
<span class="nc" id="L300">            myStringValue = result.toString();</span>
        }
<span class="nc" id="L302">        return myStringValue;</span>
    }

// Hidden classes, constants, and operations for parsing a MIME media type
// string.

    // Lexeme types.
    private static final int TOKEN_LEXEME         = 0;
    private static final int QUOTED_STRING_LEXEME = 1;
    private static final int TSPECIAL_LEXEME      = 2;
    private static final int EOF_LEXEME           = 3;
    private static final int ILLEGAL_LEXEME       = 4;

    // Class for a lexical analyzer.
    private static class LexicalAnalyzer {
        protected String mySource;
        protected int mySourceLength;
        protected int myCurrentIndex;
        protected int myLexemeType;
        protected int myLexemeBeginIndex;
        protected int myLexemeEndIndex;

<span class="nc" id="L324">        public LexicalAnalyzer(String theSource) {</span>
<span class="nc" id="L325">            mySource = theSource;</span>
<span class="nc" id="L326">            mySourceLength = theSource.length();</span>
<span class="nc" id="L327">            myCurrentIndex = 0;</span>
<span class="nc" id="L328">            nextLexeme();</span>
<span class="nc" id="L329">        }</span>

        public int getLexemeType() {
<span class="nc" id="L332">            return myLexemeType;</span>
        }

        public String getLexeme() {
<span class="nc bnc" id="L336" title="All 2 branches missed.">            return(myLexemeBeginIndex &gt;= mySourceLength ?</span>
                   null :
<span class="nc" id="L338">                   mySource.substring(myLexemeBeginIndex, myLexemeEndIndex));</span>
        }

        public char getLexemeFirstCharacter() {
<span class="nc bnc" id="L342" title="All 2 branches missed.">            return(myLexemeBeginIndex &gt;= mySourceLength ?</span>
                   '\u0000' :
<span class="nc" id="L344">                   mySource.charAt(myLexemeBeginIndex));</span>
        }

        public void nextLexeme() {
<span class="nc" id="L348">            int state = 0;</span>
<span class="nc" id="L349">            int commentLevel = 0;</span>
            char c;
<span class="nc bnc" id="L351" title="All 2 branches missed.">            while (state &gt;= 0) {</span>
<span class="nc bnc" id="L352" title="All 7 branches missed.">                switch (state) {</span>
                    // Looking for a token, quoted string, or tspecial
                case 0:
<span class="nc bnc" id="L355" title="All 2 branches missed.">                    if (myCurrentIndex &gt;= mySourceLength) {</span>
<span class="nc" id="L356">                        myLexemeType = EOF_LEXEME;</span>
<span class="nc" id="L357">                        myLexemeBeginIndex = mySourceLength;</span>
<span class="nc" id="L358">                        myLexemeEndIndex = mySourceLength;</span>
<span class="nc" id="L359">                        state = -1;</span>
<span class="nc" id="L360">                    } else if (Character.isWhitespace</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">                               (c = mySource.charAt (myCurrentIndex ++))) {</span>
<span class="nc" id="L362">                        state = 0;</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">                    } else if (c == '\&quot;') {</span>
<span class="nc" id="L364">                        myLexemeType = QUOTED_STRING_LEXEME;</span>
<span class="nc" id="L365">                        myLexemeBeginIndex = myCurrentIndex;</span>
<span class="nc" id="L366">                        state = 1;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                    } else if (c == '(') {</span>
<span class="nc" id="L368">                        ++ commentLevel;</span>
<span class="nc" id="L369">                        state = 3;</span>
<span class="nc bnc" id="L370" title="All 26 branches missed.">                    } else if (c == '/'  || c == ';' || c == '=' ||</span>
                               c == ')'  || c == '&lt;' || c == '&gt;' ||
                               c == '@'  || c == ',' || c == ':' ||
                               c == '\\' || c == '[' || c == ']' ||
                               c == '?') {
<span class="nc" id="L375">                        myLexemeType = TSPECIAL_LEXEME;</span>
<span class="nc" id="L376">                        myLexemeBeginIndex = myCurrentIndex - 1;</span>
<span class="nc" id="L377">                        myLexemeEndIndex = myCurrentIndex;</span>
<span class="nc" id="L378">                        state = -1;</span>
                    } else {
<span class="nc" id="L380">                        myLexemeType = TOKEN_LEXEME;</span>
<span class="nc" id="L381">                        myLexemeBeginIndex = myCurrentIndex - 1;</span>
<span class="nc" id="L382">                        state = 5;</span>
                    }
<span class="nc" id="L384">                    break;</span>
                    // In a quoted string
                case 1:
<span class="nc bnc" id="L387" title="All 2 branches missed.">                    if (myCurrentIndex &gt;= mySourceLength) {</span>
<span class="nc" id="L388">                        myLexemeType = ILLEGAL_LEXEME;</span>
<span class="nc" id="L389">                        myLexemeBeginIndex = mySourceLength;</span>
<span class="nc" id="L390">                        myLexemeEndIndex = mySourceLength;</span>
<span class="nc" id="L391">                        state = -1;</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                    } else if ((c = mySource.charAt (myCurrentIndex ++)) == '\&quot;') {</span>
<span class="nc" id="L393">                        myLexemeEndIndex = myCurrentIndex - 1;</span>
<span class="nc" id="L394">                        state = -1;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">                    } else if (c == '\\') {</span>
<span class="nc" id="L396">                        state = 2;</span>
                    } else {
<span class="nc" id="L398">                        state = 1;</span>
                    }
<span class="nc" id="L400">                    break;</span>
                    // In a quoted string, backslash seen
                case 2:
<span class="nc bnc" id="L403" title="All 2 branches missed.">                    if (myCurrentIndex &gt;= mySourceLength) {</span>
<span class="nc" id="L404">                        myLexemeType = ILLEGAL_LEXEME;</span>
<span class="nc" id="L405">                        myLexemeBeginIndex = mySourceLength;</span>
<span class="nc" id="L406">                        myLexemeEndIndex = mySourceLength;</span>
<span class="nc" id="L407">                        state = -1;</span>
                    } else {
<span class="nc" id="L409">                        ++ myCurrentIndex;</span>
<span class="nc" id="L410">                        state = 1;</span>
<span class="nc" id="L411">                    } break;</span>
                    // In a comment
<span class="nc bnc" id="L413" title="All 2 branches missed.">                case 3: if (myCurrentIndex &gt;= mySourceLength) {</span>
<span class="nc" id="L414">                    myLexemeType = ILLEGAL_LEXEME;</span>
<span class="nc" id="L415">                    myLexemeBeginIndex = mySourceLength;</span>
<span class="nc" id="L416">                    myLexemeEndIndex = mySourceLength;</span>
<span class="nc" id="L417">                    state = -1;</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                } else if ((c = mySource.charAt (myCurrentIndex ++)) == '(') {</span>
<span class="nc" id="L419">                    ++ commentLevel;</span>
<span class="nc" id="L420">                    state = 3;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                } else if (c == ')') {</span>
<span class="nc" id="L422">                    -- commentLevel;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                    state = commentLevel == 0 ? 0 : 3;</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">                } else if (c == '\\') {</span>
<span class="nc" id="L425">                    state = 4;</span>
<span class="nc" id="L426">                } else { state = 3;</span>
                }
<span class="nc" id="L428">                break;</span>
                // In a comment, backslash seen
                case 4:
<span class="nc bnc" id="L431" title="All 2 branches missed.">                    if (myCurrentIndex &gt;= mySourceLength) {</span>
<span class="nc" id="L432">                        myLexemeType = ILLEGAL_LEXEME;</span>
<span class="nc" id="L433">                        myLexemeBeginIndex = mySourceLength;</span>
<span class="nc" id="L434">                        myLexemeEndIndex = mySourceLength;</span>
<span class="nc" id="L435">                        state = -1;</span>
                    } else {
<span class="nc" id="L437">                        ++ myCurrentIndex;</span>
<span class="nc" id="L438">                        state = 3;</span>
                    }
<span class="nc" id="L440">                    break;</span>
                    // In a token
                case 5:
<span class="nc bnc" id="L443" title="All 2 branches missed.">                    if (myCurrentIndex &gt;= mySourceLength) {</span>
<span class="nc" id="L444">                        myLexemeEndIndex = myCurrentIndex;</span>
<span class="nc" id="L445">                        state = -1;</span>
<span class="nc" id="L446">                    } else if (Character.isWhitespace</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                               (c = mySource.charAt (myCurrentIndex ++))) {</span>
<span class="nc" id="L448">                        myLexemeEndIndex = myCurrentIndex - 1;</span>
<span class="nc" id="L449">                        state = -1;</span>
<span class="nc bnc" id="L450" title="All 30 branches missed.">                    } else if (c == '\&quot;' || c == '(' || c == '/' ||</span>
                               c == ';'  || c == '=' || c == ')' ||
                               c == '&lt;' || c == '&gt;'  || c == '@' ||
                               c == ',' || c == ':' || c == '\\' ||
                               c == '[' || c == ']' || c == '?') {
<span class="nc" id="L455">                        -- myCurrentIndex;</span>
<span class="nc" id="L456">                        myLexemeEndIndex = myCurrentIndex;</span>
<span class="nc" id="L457">                        state = -1;</span>
                    } else {
<span class="nc" id="L459">                        state = 5;</span>
                    }
<span class="nc" id="L461">                    break;</span>
                }
            }

<span class="nc" id="L465">        }</span>

    }

    /**
     * Returns a lowercase version of the given string. The lowercase version
     * is constructed by applying Character.toLowerCase() to each character of
     * the given string, which maps characters to lowercase using the rules of
     * Unicode. This mapping is the same regardless of locale, whereas the
     * mapping of String.toLowerCase() may be different depending on the
     * default locale.
     */
    private static String toUnicodeLowerCase(String s) {
<span class="nc" id="L478">        int n = s.length();</span>
<span class="nc" id="L479">        char[] result = new char [n];</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++ i) {</span>
<span class="nc" id="L481">            result[i] = Character.toLowerCase (s.charAt (i));</span>
        }
<span class="nc" id="L483">        return new String (result);</span>
    }

    /**
     * Returns a version of the given string with backslashes removed.
     */
    private static String removeBackslashes(String s) {
<span class="nc" id="L490">        int n = s.length();</span>
<span class="nc" id="L491">        char[] result = new char [n];</span>
        int i;
<span class="nc" id="L493">        int j = 0;</span>
        char c;
<span class="nc bnc" id="L495" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++ i) {</span>
<span class="nc" id="L496">            c = s.charAt (i);</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">            if (c == '\\') {</span>
<span class="nc" id="L498">                c = s.charAt (++ i);</span>
            }
<span class="nc" id="L500">            result[j++] = c;</span>
        }
<span class="nc" id="L502">        return new String (result, 0, j);</span>
    }

    /**
     * Returns a version of the string surrounded by quotes and with interior
     * quotes preceded by a backslash.
     */
    private static String addQuotes(String s) {
<span class="nc" id="L510">        int n = s.length();</span>
        int i;
        char c;
<span class="nc" id="L513">        StringBuffer result = new StringBuffer (n+2);</span>
<span class="nc" id="L514">        result.append ('\&quot;');</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++ i) {</span>
<span class="nc" id="L516">            c = s.charAt (i);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">            if (c == '\&quot;') {</span>
<span class="nc" id="L518">                result.append ('\\');</span>
            }
<span class="nc" id="L520">            result.append (c);</span>
        }
<span class="nc" id="L522">        result.append ('\&quot;');</span>
<span class="nc" id="L523">        return result.toString();</span>
    }

    /**
     * Parses the given string into canonical pieces and stores the pieces in
     * {@link #myPieces &lt;CODE&gt;myPieces&lt;/CODE&gt;}.
     * &lt;P&gt;
     * Special rules applied:
     * &lt;UL&gt;
     * &lt;LI&gt; If the media type is text, the value of a charset parameter is
     *      converted to lowercase.
     * &lt;/UL&gt;
     *
     * @param  s  MIME media type string.
     *
     * @exception  NullPointerException
     *     (unchecked exception) Thrown if &lt;CODE&gt;s&lt;/CODE&gt; is null.
     * @exception  IllegalArgumentException
     *     (unchecked exception) Thrown if &lt;CODE&gt;s&lt;/CODE&gt; does not obey the
     *     syntax for a MIME media type string.
     */
    private void parse(String s) {
        // Initialize.
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L547">            throw new NullPointerException();</span>
        }
<span class="nc" id="L549">        LexicalAnalyzer theLexer = new LexicalAnalyzer (s);</span>
        int theLexemeType;
<span class="nc" id="L551">        Vector thePieces = new Vector();</span>
<span class="nc" id="L552">        boolean mediaTypeIsText = false;</span>
<span class="nc" id="L553">        boolean parameterNameIsCharset = false;</span>

        // Parse media type.
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (theLexer.getLexemeType() == TOKEN_LEXEME) {</span>
<span class="nc" id="L557">            String mt = toUnicodeLowerCase (theLexer.getLexeme());</span>
<span class="nc" id="L558">            thePieces.add (mt);</span>
<span class="nc" id="L559">            theLexer.nextLexeme();</span>
<span class="nc" id="L560">            mediaTypeIsText = mt.equals (&quot;text&quot;);</span>
<span class="nc" id="L561">        } else {</span>
<span class="nc" id="L562">            throw new IllegalArgumentException();</span>
        }
        // Parse slash.
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (theLexer.getLexemeType() == TSPECIAL_LEXEME &amp;&amp;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">              theLexer.getLexemeFirstCharacter() == '/') {</span>
<span class="nc" id="L567">            theLexer.nextLexeme();</span>
        } else {
<span class="nc" id="L569">            throw new IllegalArgumentException();</span>
        }
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (theLexer.getLexemeType() == TOKEN_LEXEME) {</span>
<span class="nc" id="L572">            thePieces.add (toUnicodeLowerCase (theLexer.getLexeme()));</span>
<span class="nc" id="L573">            theLexer.nextLexeme();</span>
        } else {
<span class="nc" id="L575">            throw new IllegalArgumentException();</span>
        }
        // Parse zero or more parameters.
<span class="nc bnc" id="L578" title="All 2 branches missed.">        while (theLexer.getLexemeType() == TSPECIAL_LEXEME &amp;&amp;</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">               theLexer.getLexemeFirstCharacter() == ';') {</span>
            // Parse semicolon.
<span class="nc" id="L581">            theLexer.nextLexeme();</span>

            // Parse parameter name.
<span class="nc bnc" id="L584" title="All 2 branches missed.">            if (theLexer.getLexemeType() == TOKEN_LEXEME) {</span>
<span class="nc" id="L585">                String pn = toUnicodeLowerCase (theLexer.getLexeme());</span>
<span class="nc" id="L586">                thePieces.add (pn);</span>
<span class="nc" id="L587">                theLexer.nextLexeme();</span>
<span class="nc" id="L588">                parameterNameIsCharset = pn.equals (&quot;charset&quot;);</span>
<span class="nc" id="L589">            } else {</span>
<span class="nc" id="L590">                throw new IllegalArgumentException();</span>
            }

            // Parse equals.
<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (theLexer.getLexemeType() == TSPECIAL_LEXEME &amp;&amp;</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                theLexer.getLexemeFirstCharacter() == '=') {</span>
<span class="nc" id="L596">                theLexer.nextLexeme();</span>
            } else {
<span class="nc" id="L598">                throw new IllegalArgumentException();</span>
            }

            // Parse parameter value.
<span class="nc bnc" id="L602" title="All 2 branches missed.">            if (theLexer.getLexemeType() == TOKEN_LEXEME) {</span>
<span class="nc" id="L603">                String pv = theLexer.getLexeme();</span>
<span class="nc bnc" id="L604" title="All 4 branches missed.">                thePieces.add(mediaTypeIsText &amp;&amp; parameterNameIsCharset ?</span>
<span class="nc" id="L605">                              toUnicodeLowerCase (pv) :</span>
                              pv);
<span class="nc" id="L607">                theLexer.nextLexeme();</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">            } else if (theLexer.getLexemeType() == QUOTED_STRING_LEXEME) {</span>
<span class="nc" id="L609">                String pv = removeBackslashes (theLexer.getLexeme());</span>
<span class="nc bnc" id="L610" title="All 4 branches missed.">                thePieces.add(mediaTypeIsText &amp;&amp; parameterNameIsCharset ?</span>
<span class="nc" id="L611">                              toUnicodeLowerCase (pv) :</span>
                              pv);
<span class="nc" id="L613">                theLexer.nextLexeme();</span>
<span class="nc" id="L614">            } else {</span>
<span class="nc" id="L615">                throw new IllegalArgumentException();</span>
            }
        }

        // Make sure we've consumed everything.
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (theLexer.getLexemeType() != EOF_LEXEME) {</span>
<span class="nc" id="L621">            throw new IllegalArgumentException();</span>
        }

        // Save the pieces. Parameters are not in ascending order yet.
<span class="nc" id="L625">        int n = thePieces.size();</span>
<span class="nc" id="L626">        myPieces = (String[]) thePieces.toArray (new String [n]);</span>

        // Sort the parameters into ascending order using an insertion sort.
        int i, j;
        String temp;
<span class="nc bnc" id="L631" title="All 2 branches missed.">        for (i = 4; i &lt; n; i += 2) {</span>
<span class="nc" id="L632">            j = 2;</span>
<span class="nc bnc" id="L633" title="All 4 branches missed.">            while (j &lt; i &amp;&amp; myPieces[j].compareTo (myPieces[i]) &lt;= 0) {</span>
<span class="nc" id="L634">                j += 2;</span>
            }
<span class="nc bnc" id="L636" title="All 2 branches missed.">            while (j &lt; i) {</span>
<span class="nc" id="L637">                temp = myPieces[j];</span>
<span class="nc" id="L638">                myPieces[j] = myPieces[i];</span>
<span class="nc" id="L639">                myPieces[i] = temp;</span>
<span class="nc" id="L640">                temp = myPieces[j+1];</span>
<span class="nc" id="L641">                myPieces[j+1] = myPieces[i+1];</span>
<span class="nc" id="L642">                myPieces[i+1] = temp;</span>
<span class="nc" id="L643">                j += 2;</span>
            }
        }
<span class="nc" id="L646">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>