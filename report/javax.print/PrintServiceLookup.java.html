<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PrintServiceLookup.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.print</a> &gt; <span class="el_source">PrintServiceLookup.java</span></div><h1>PrintServiceLookup.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package javax.print;

import java.util.ArrayList;
import java.util.Iterator;
import javax.print.attribute.AttributeSet;

import sun.awt.AppContext;
import java.util.ServiceLoader;
import java.util.ServiceConfigurationError;

/** Implementations of this class provide lookup services for
  * print services (typically equivalent to printers) of a particular type.
  * &lt;p&gt;
  * Multiple implementations may be installed concurrently.
  * All implementations must be able to describe the located printers
  * as instances of a PrintService.
  * Typically implementations of this service class are located
  * automatically in JAR files (see the SPI JAR file specification).
  * These classes must be instantiable using a default constructor.
  * Alternatively applications may explicitly register instances
  * at runtime.
  * &lt;p&gt;
  * Applications use only the static methods of this abstract class.
  * The instance methods are implemented by a service provider in a subclass
  * and the unification of the results from all installed lookup classes
  * are reported by the static methods of this class when called by
  * the application.
  * &lt;p&gt;
  * A PrintServiceLookup implementor is recommended to check for the
  * SecurityManager.checkPrintJobAccess() to deny access to untrusted code.
  * Following this recommended policy means that untrusted code may not
  * be able to locate any print services. Downloaded applets are the most
  * common example of untrusted code.
  * &lt;p&gt;
  * This check is made on a per lookup service basis to allow flexibility in
  * the policy to reflect the needs of different lookup services.
  * &lt;p&gt;
  * Services which are registered by registerService(PrintService)
  * will not be included in lookup results if a security manager is
  * installed and its checkPrintJobAccess() method denies access.
  */

<span class="nc" id="L69">public abstract class PrintServiceLookup {</span>

<span class="nc" id="L71">    static class Services {</span>
<span class="nc" id="L72">        private ArrayList listOfLookupServices = null;</span>
<span class="nc" id="L73">        private ArrayList registeredServices = null;</span>
    }

    private static Services getServicesForContext() {
        Services services =
<span class="nc" id="L78">            (Services)AppContext.getAppContext().get(Services.class);</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">        if (services == null) {</span>
<span class="nc" id="L80">            services = new Services();</span>
<span class="nc" id="L81">            AppContext.getAppContext().put(Services.class, services);</span>
        }
<span class="nc" id="L83">        return services;</span>
    }

    private static ArrayList getListOfLookupServices() {
<span class="nc" id="L87">        return getServicesForContext().listOfLookupServices;</span>
    }

    private static ArrayList initListOfLookupServices() {
<span class="nc" id="L91">        ArrayList listOfLookupServices = new ArrayList();</span>
<span class="nc" id="L92">        getServicesForContext().listOfLookupServices = listOfLookupServices;</span>
<span class="nc" id="L93">        return listOfLookupServices;</span>
    }


    private static ArrayList getRegisteredServices() {
<span class="nc" id="L98">        return getServicesForContext().registeredServices;</span>
    }

    private static ArrayList initRegisteredServices() {
<span class="nc" id="L102">        ArrayList registeredServices = new ArrayList();</span>
<span class="nc" id="L103">        getServicesForContext().registeredServices = registeredServices;</span>
<span class="nc" id="L104">        return registeredServices;</span>
    }

    /**
     * Locates print services capable of printing the specified
     * {@link DocFlavor}.
     *
     * @param flavor the flavor to print. If null, this constraint is not
     *        used.
     * @param attributes attributes that the print service must support.
     * If null this constraint is not used.
     *
     * @return array of matching &lt;code&gt;PrintService&lt;/code&gt; objects
     * representing print services that support the specified flavor
     * attributes.  If no services match, the array is zero-length.
     */
    public static final PrintService[]
        lookupPrintServices(DocFlavor flavor,
                            AttributeSet attributes) {
<span class="nc" id="L123">        ArrayList list = getServices(flavor, attributes);</span>
<span class="nc" id="L124">        return (PrintService[])(list.toArray(new PrintService[list.size()]));</span>
    }


    /**
     * Locates MultiDoc print Services capable of printing MultiDocs
     * containing all the specified doc flavors.
     * &lt;P&gt; This method is useful to help locate a service that can print
     * a &lt;code&gt;MultiDoc&lt;/code&gt; in which the elements may be different
     * flavors. An application could perform this itself by multiple lookups
     * on each &lt;code&gt;DocFlavor&lt;/code&gt; in turn and collating the results,
     * but the lookup service may be able to do this more efficiently.
     *
     * @param flavors the flavors to print. If null or empty this
     *        constraint is not used.
     * Otherwise return only multidoc print services that can print all
     * specified doc flavors.
     * @param attributes attributes that the print service must
     * support.  If null this constraint is not used.
     *
     * @return array of matching {@link MultiDocPrintService} objects.
     * If no services match, the array is zero-length.
     *
     */
    public static final MultiDocPrintService[]
        lookupMultiDocPrintServices(DocFlavor[] flavors,
                                    AttributeSet attributes) {
<span class="nc" id="L151">        ArrayList list = getMultiDocServices(flavors, attributes);</span>
<span class="nc" id="L152">        return (MultiDocPrintService[])</span>
<span class="nc" id="L153">            list.toArray(new MultiDocPrintService[list.size()]);</span>
    }


    /**
     * Locates the default print service for this environment.
     * This may return null.
     * If multiple lookup services each specify a default, the
     * chosen service is not precisely defined, but a
     * platform native service, rather than an installed service,
     * is usually returned as the default.  If there is no clearly
     * identifiable
     * platform native default print service, the default is the first
     * to be located in an implementation-dependent manner.
     * &lt;p&gt;
     * This may include making use of any preferences API that is available
     * as part of the Java or native platform.
     * This algorithm may be overridden by a user setting the property
     * javax.print.defaultPrinter.
     * A service specified must be discovered to be valid and currently
     * available to be returned as the default.
     *
     * @return the default PrintService.
     */

    public static final PrintService lookupDefaultPrintService() {

<span class="nc" id="L180">        Iterator psIterator = getAllLookupServices().iterator();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        while (psIterator.hasNext()) {</span>
            try {
<span class="nc" id="L183">                PrintServiceLookup lus = (PrintServiceLookup)psIterator.next();</span>
<span class="nc" id="L184">                PrintService service = lus.getDefaultPrintService();</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                if (service != null) {</span>
<span class="nc" id="L186">                    return service;</span>
                }
<span class="nc" id="L188">            } catch (Exception e) {</span>
<span class="nc" id="L189">            }</span>
        }
<span class="nc" id="L191">        return null;</span>
    }


    /**
     * Allows an application to explicitly register a class that
     * implements lookup services. The registration will not persist
     * across VM invocations.
     * This is useful if an application needs to make a new service
     * available that is not part of the installation.
     * If the lookup service is already registered, or cannot be registered,
     * the method returns false.
     * &lt;p&gt;
     *
     * @param sp an implementation of a lookup service.
     * @return &lt;code&gt;true&lt;/code&gt; if the new lookup service is newly
     *         registered; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public static boolean registerServiceProvider(PrintServiceLookup sp) {
<span class="nc" id="L210">        synchronized (PrintServiceLookup.class) {</span>
<span class="nc" id="L211">            Iterator psIterator = getAllLookupServices().iterator();</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            while (psIterator.hasNext()) {</span>
                try {
<span class="nc" id="L214">                    Object lus = psIterator.next();</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                    if (lus.getClass() == sp.getClass()) {</span>
<span class="nc" id="L216">                        return false;</span>
                    }
<span class="nc" id="L218">                } catch (Exception e) {</span>
<span class="nc" id="L219">                }</span>
            }
<span class="nc" id="L221">            getListOfLookupServices().add(sp);</span>
<span class="nc" id="L222">            return true;</span>
<span class="nc" id="L223">        }</span>

    }


    /**
     * Allows an application to directly register an instance of a
     * class which implements a print service.
     * The lookup operations for this service will be
     * performed by the PrintServiceLookup class using the attribute
     * values and classes reported by the service.
     * This may be less efficient than a lookup
     * service tuned for that service.
     * Therefore registering a &lt;code&gt;PrintServiceLookup&lt;/code&gt; instance
     * instead is recommended.
     * The method returns true if this service is not previously
     * registered and is now successfully registered.
     * This method should not be called with StreamPrintService instances.
     * They will always fail to register and the method will return false.
     * @param service an implementation of a print service.
     * @return &lt;code&gt;true&lt;/code&gt; if the service is newly
     *         registered; &lt;code&gt;false&lt;/code&gt; otherwise.
     */

    public static boolean registerService(PrintService service) {
<span class="nc" id="L248">        synchronized (PrintServiceLookup.class) {</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (service instanceof StreamPrintService) {</span>
<span class="nc" id="L250">                return false;</span>
            }
<span class="nc" id="L252">            ArrayList registeredServices = getRegisteredServices();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (registeredServices == null) {</span>
<span class="nc" id="L254">                registeredServices = initRegisteredServices();</span>
            }
            else {
<span class="nc bnc" id="L257" title="All 2 branches missed.">              if (registeredServices.contains(service)) {</span>
<span class="nc" id="L258">                return false;</span>
              }
            }
<span class="nc" id="L261">            registeredServices.add(service);</span>
<span class="nc" id="L262">            return true;</span>
<span class="nc" id="L263">        }</span>
    }


   /**
    * Locates services that can be positively confirmed to support
    * the combination of attributes and DocFlavors specified.
    * This method is not called directly by applications.
    * &lt;p&gt;
    * Implemented by a service provider, used by the static methods
    * of this class.
    * &lt;p&gt;
    * The results should be the same as obtaining all the PrintServices
    * and querying each one individually on its support for the
    * specified attributes and flavors, but the process can be more
    * efficient by taking advantage of the capabilities of lookup services
    * for the print services.
    *
    * @param flavor of document required.  If null it is ignored.
    * @param attributes required to be supported. If null this
    * constraint is not used.
    * @return array of matching PrintServices. If no services match, the
    * array is zero-length.
    */
    public abstract PrintService[] getPrintServices(DocFlavor flavor,
                                                    AttributeSet attributes);

    /**
     * Not called directly by applications.
     * Implemented by a service provider, used by the static methods
     * of this class.
     * @return array of all PrintServices known to this lookup service
     * class. If none are found, the array is zero-length.
     */
    public abstract PrintService[] getPrintServices() ;


   /**
    * Not called directly by applications.
    * &lt;p&gt;
    * Implemented by a service provider, used by the static methods
    * of this class.
    * &lt;p&gt;
    * Locates MultiDoc print services which can be positively confirmed
    * to support the combination of attributes and DocFlavors specified.
    * &lt;p&gt;
    *
    * @param flavors of documents required. If null or empty it is ignored.
    * @param attributes required to be supported. If null this
     * constraint is not used.
    * @return array of matching PrintServices. If no services match, the
    * array is zero-length.
    */
    public abstract MultiDocPrintService[]
        getMultiDocPrintServices(DocFlavor[] flavors,
                                 AttributeSet attributes);

    /**
     * Not called directly by applications.
     * Implemented by a service provider, and called by the print lookup
     * service
     * @return the default PrintService for this lookup service.
     * If there is no default, returns null.
     */
    public abstract PrintService getDefaultPrintService();

    private static ArrayList getAllLookupServices() {
<span class="nc" id="L330">        synchronized (PrintServiceLookup.class) {</span>
<span class="nc" id="L331">            ArrayList listOfLookupServices = getListOfLookupServices();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (listOfLookupServices != null) {</span>
<span class="nc" id="L333">                return listOfLookupServices;</span>
            } else {
<span class="nc" id="L335">                listOfLookupServices = initListOfLookupServices();</span>
            }
            try {
<span class="nc" id="L338">                java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L339">                     new java.security.PrivilegedExceptionAction() {</span>
                        public Object run() {
<span class="nc" id="L341">                            Iterator&lt;PrintServiceLookup&gt; iterator =</span>
<span class="nc" id="L342">                                ServiceLoader.load(PrintServiceLookup.class).</span>
<span class="nc" id="L343">                                iterator();</span>
<span class="nc" id="L344">                            ArrayList los = getListOfLookupServices();</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                            while (iterator.hasNext()) {</span>
                                try {
<span class="nc" id="L347">                                    los.add(iterator.next());</span>
<span class="nc" id="L348">                                }  catch (ServiceConfigurationError err) {</span>
                                    /* In the applet case, we continue */
<span class="nc bnc" id="L350" title="All 2 branches missed.">                                    if (System.getSecurityManager() != null) {</span>
<span class="nc" id="L351">                                        err.printStackTrace();</span>
                                    } else {
<span class="nc" id="L353">                                        throw err;</span>
                                    }
<span class="nc" id="L355">                                }</span>
                            }
<span class="nc" id="L357">                            return null;</span>
                        }
                });
<span class="nc" id="L360">            } catch (java.security.PrivilegedActionException e) {</span>
<span class="nc" id="L361">            }</span>

<span class="nc" id="L363">            return listOfLookupServices;</span>
<span class="nc" id="L364">        }</span>
    }

    private static ArrayList getServices(DocFlavor flavor,
                                         AttributeSet attributes) {

<span class="nc" id="L370">        ArrayList listOfServices = new ArrayList();</span>
<span class="nc" id="L371">        Iterator psIterator = getAllLookupServices().iterator();</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">        while (psIterator.hasNext()) {</span>
            try {
<span class="nc" id="L374">                PrintServiceLookup lus = (PrintServiceLookup)psIterator.next();</span>
<span class="nc" id="L375">                PrintService[] services=null;</span>
<span class="nc bnc" id="L376" title="All 4 branches missed.">                if (flavor == null &amp;&amp; attributes == null) {</span>
                    try {
<span class="nc" id="L378">                    services = lus.getPrintServices();</span>
<span class="nc" id="L379">                    } catch (Throwable tr) {</span>
<span class="nc" id="L380">                    }</span>
                } else {
<span class="nc" id="L382">                    services = lus.getPrintServices(flavor, attributes);</span>
                }
<span class="nc bnc" id="L384" title="All 2 branches missed.">                if (services == null) {</span>
<span class="nc" id="L385">                    continue;</span>
                }
<span class="nc bnc" id="L387" title="All 2 branches missed.">                for (int i=0; i&lt;services.length; i++) {</span>
<span class="nc" id="L388">                    listOfServices.add(services[i]);</span>
                }
<span class="nc" id="L390">            } catch (Exception e) {</span>
<span class="nc" id="L391">            }</span>
        }
        /* add any directly registered services */
<span class="nc" id="L394">        ArrayList registeredServices = null;</span>
        try {
<span class="nc" id="L396">          SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">          if (security != null) {</span>
<span class="nc" id="L398">            security.checkPrintJobAccess();</span>
          }
<span class="nc" id="L400">          registeredServices = getRegisteredServices();</span>
<span class="nc" id="L401">        } catch (SecurityException se) {</span>
<span class="nc" id="L402">        }</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (registeredServices != null) {</span>
<span class="nc" id="L404">            PrintService[] services = (PrintService[])</span>
<span class="nc" id="L405">                registeredServices.toArray(</span>
<span class="nc" id="L406">                           new PrintService[registeredServices.size()]);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">            for (int i=0; i&lt;services.length; i++) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">                if (!listOfServices.contains(services[i])) {</span>
<span class="nc bnc" id="L409" title="All 4 branches missed.">                    if (flavor == null &amp;&amp; attributes == null) {</span>
<span class="nc" id="L410">                        listOfServices.add(services[i]);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                    } else if (((flavor != null &amp;&amp;</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">                                 services[i].isDocFlavorSupported(flavor)) ||</span>
                                flavor == null) &amp;&amp;
<span class="nc bnc" id="L414" title="All 2 branches missed.">                               null == services[i].getUnsupportedAttributes(</span>
                                                      flavor, attributes)) {
<span class="nc" id="L416">                        listOfServices.add(services[i]);</span>
                    }
                }
            }
        }
<span class="nc" id="L421">        return listOfServices;</span>
    }

    private static ArrayList getMultiDocServices(DocFlavor[] flavors,
                                                 AttributeSet attributes) {


<span class="nc" id="L428">        ArrayList listOfServices = new ArrayList();</span>
<span class="nc" id="L429">        Iterator psIterator = getAllLookupServices().iterator();</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        while (psIterator.hasNext()) {</span>
            try {
<span class="nc" id="L432">                PrintServiceLookup lus = (PrintServiceLookup)psIterator.next();</span>
<span class="nc" id="L433">                MultiDocPrintService[] services  =</span>
<span class="nc" id="L434">                    lus.getMultiDocPrintServices(flavors, attributes);</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                if (services == null) {</span>
<span class="nc" id="L436">                    continue;</span>
                }
<span class="nc bnc" id="L438" title="All 2 branches missed.">                for (int i=0; i&lt;services.length; i++) {</span>
<span class="nc" id="L439">                    listOfServices.add(services[i]);</span>
                }
<span class="nc" id="L441">            } catch (Exception e) {</span>
<span class="nc" id="L442">            }</span>
        }
        /* add any directly registered services */
<span class="nc" id="L445">        ArrayList registeredServices = null;</span>
        try {
<span class="nc" id="L447">          SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">          if (security != null) {</span>
<span class="nc" id="L449">            security.checkPrintJobAccess();</span>
          }
<span class="nc" id="L451">          registeredServices = getRegisteredServices();</span>
<span class="nc" id="L452">        } catch (Exception e) {</span>
<span class="nc" id="L453">        }</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (registeredServices != null) {</span>
<span class="nc" id="L455">            PrintService[] services = (PrintService[])</span>
<span class="nc" id="L456">                registeredServices.toArray(</span>
<span class="nc" id="L457">                           new PrintService[registeredServices.size()]);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">            for (int i=0; i&lt;services.length; i++) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">                if (services[i] instanceof MultiDocPrintService &amp;&amp;</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                    !listOfServices.contains(services[i])) {</span>
<span class="nc bnc" id="L461" title="All 4 branches missed.">                    if (flavors == null || flavors.length == 0) {</span>
<span class="nc" id="L462">                        listOfServices.add(services[i]);</span>
                    } else {
<span class="nc" id="L464">                        boolean supported = true;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                        for (int f=0; f&lt;flavors.length; f++) {</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                            if (services[i].isDocFlavorSupported(flavors[f])) {</span>

<span class="nc bnc" id="L468" title="All 2 branches missed.">                                if (services[i].getUnsupportedAttributes(</span>
                                     flavors[f], attributes) != null) {
<span class="nc" id="L470">                                        supported = false;</span>
<span class="nc" id="L471">                                        break;</span>
                                }
                            } else {
<span class="nc" id="L474">                                supported = false;</span>
<span class="nc" id="L475">                                break;</span>
                            }
                        }
<span class="nc bnc" id="L478" title="All 2 branches missed.">                        if (supported) {</span>
<span class="nc" id="L479">                            listOfServices.add(services[i]);</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L485">        return listOfServices;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>