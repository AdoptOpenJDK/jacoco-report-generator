<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Obj.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jndi.ldap</a> &gt; <span class="el_source">Obj.java</span></div><h1>Obj.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jndi.ldap;

import javax.naming.*;
import javax.naming.directory.*;
import javax.naming.spi.DirectoryManager;
import javax.naming.spi.DirStateFactory;

import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamClass;
import java.io.InputStream;

import java.util.Hashtable;
import java.util.Vector;
import java.util.StringTokenizer;

import sun.misc.BASE64Encoder;
import sun.misc.BASE64Decoder;

import java.lang.reflect.Proxy;
import java.lang.reflect.Modifier;

/**
  * Class containing static methods and constants for dealing with
  * encoding/decoding JNDI References and Serialized Objects
  * in LDAP.
  * @author Vincent Ryan
  * @author Rosanna Lee
  */
final class Obj {

<span class="nc" id="L60">    private Obj () {}; // Make sure no one can create one</span>

    // package private; used by Connection
<span class="fc" id="L63">    static VersionHelper helper = VersionHelper.getVersionHelper();</span>

    // LDAP attributes used to support Java objects.
<span class="fc" id="L66">    static final String[] JAVA_ATTRIBUTES = {</span>
        &quot;objectClass&quot;,
        &quot;javaSerializedData&quot;,
        &quot;javaClassName&quot;,
        &quot;javaFactory&quot;,
        &quot;javaCodeBase&quot;,
        &quot;javaReferenceAddress&quot;,
        &quot;javaClassNames&quot;,
        &quot;javaRemoteLocation&quot;     // Deprecated
    };

    static final int OBJECT_CLASS = 0;
    static final int SERIALIZED_DATA = 1;
    static final int CLASSNAME = 2;
    static final int FACTORY = 3;
    static final int CODEBASE = 4;
    static final int REF_ADDR = 5;
    static final int TYPENAME = 6;
    /**
     * @deprecated
     */
    @Deprecated
    private static final int REMOTE_LOC = 7;

    // LDAP object classes to support Java objects
<span class="fc" id="L91">    static final String[] JAVA_OBJECT_CLASSES = {</span>
        &quot;javaContainer&quot;,
        &quot;javaObject&quot;,
        &quot;javaNamingReference&quot;,
        &quot;javaSerializedObject&quot;,
        &quot;javaMarshalledObject&quot;,
    };

<span class="fc" id="L99">    static final String[] JAVA_OBJECT_CLASSES_LOWER = {</span>
        &quot;javacontainer&quot;,
        &quot;javaobject&quot;,
        &quot;javanamingreference&quot;,
        &quot;javaserializedobject&quot;,
        &quot;javamarshalledobject&quot;,
    };

    static final int STRUCTURAL = 0;    // structural object class
    static final int BASE_OBJECT = 1;   // auxiliary java object class
    static final int REF_OBJECT = 2;    // auxiliary reference object class
    static final int SER_OBJECT = 3;    // auxiliary serialized object class
    static final int MAR_OBJECT = 4;    // auxiliary marshalled object class

    /**
     * Encode an object in LDAP attributes.
     * Supports binding Referenceable or Reference, Serializable,
     * and DirContext.
     *
     * If the object supports the Referenceable interface then encode
     * the reference to the object. See encodeReference() for details.
     *&lt;p&gt;
     * If the object is serializable, it is stored as follows:
     * javaClassName
     *   value: Object.getClass();
     * javaSerializedData
     *   value: serialized form of Object (in binary form).
     * javaTypeName
     *   value: getTypeNames(Object.getClass());
     */
    private static Attributes encodeObject(char separator,
        Object obj, Attributes attrs,
        Attribute objectClass, boolean cloned)
        throws NamingException {
<span class="nc" id="L133">            boolean structural =</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">                (objectClass.size() == 0 ||</span>
<span class="nc bnc" id="L135" title="All 4 branches missed.">                    (objectClass.size() == 1 &amp;&amp; objectClass.contains(&quot;top&quot;)));</span>

<span class="nc bnc" id="L137" title="All 2 branches missed.">            if (structural) {</span>
<span class="nc" id="L138">                objectClass.add(JAVA_OBJECT_CLASSES[STRUCTURAL]);</span>
            }

    // References
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (obj instanceof Referenceable) {</span>
<span class="nc" id="L143">                objectClass.add(JAVA_OBJECT_CLASSES[BASE_OBJECT]);</span>
<span class="nc" id="L144">                objectClass.add(JAVA_OBJECT_CLASSES[REF_OBJECT]);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">                if (!cloned) {</span>
<span class="nc" id="L146">                    attrs = (Attributes)attrs.clone();</span>
                }
<span class="nc" id="L148">                attrs.put(objectClass);</span>
<span class="nc" id="L149">                return (encodeReference(separator,</span>
<span class="nc" id="L150">                    ((Referenceable)obj).getReference(),</span>
                    attrs, obj));

<span class="nc bnc" id="L153" title="All 2 branches missed.">            } else if (obj instanceof Reference) {</span>
<span class="nc" id="L154">                objectClass.add(JAVA_OBJECT_CLASSES[BASE_OBJECT]);</span>
<span class="nc" id="L155">                objectClass.add(JAVA_OBJECT_CLASSES[REF_OBJECT]);</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                if (!cloned) {</span>
<span class="nc" id="L157">                    attrs = (Attributes)attrs.clone();</span>
                }
<span class="nc" id="L159">                attrs.put(objectClass);</span>
<span class="nc" id="L160">                return (encodeReference(separator, (Reference)obj, attrs, null));</span>

    // Serializable Object
<span class="nc bnc" id="L163" title="All 2 branches missed.">            } else if (obj instanceof java.io.Serializable) {</span>
<span class="nc" id="L164">                objectClass.add(JAVA_OBJECT_CLASSES[BASE_OBJECT]);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                if (!(objectClass.contains(JAVA_OBJECT_CLASSES[MAR_OBJECT]) ||</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">                    objectClass.contains(JAVA_OBJECT_CLASSES_LOWER[MAR_OBJECT]))) {</span>
<span class="nc" id="L167">                    objectClass.add(JAVA_OBJECT_CLASSES[SER_OBJECT]);</span>
                }
<span class="nc bnc" id="L169" title="All 2 branches missed.">                if (!cloned) {</span>
<span class="nc" id="L170">                    attrs = (Attributes)attrs.clone();</span>
                }
<span class="nc" id="L172">                attrs.put(objectClass);</span>
<span class="nc" id="L173">                attrs.put(new BasicAttribute(JAVA_ATTRIBUTES[SERIALIZED_DATA],</span>
<span class="nc" id="L174">                    serializeObject(obj)));</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                if (attrs.get(JAVA_ATTRIBUTES[CLASSNAME]) == null) {</span>
<span class="nc" id="L176">                    attrs.put(JAVA_ATTRIBUTES[CLASSNAME],</span>
<span class="nc" id="L177">                        obj.getClass().getName());</span>
                }
<span class="nc bnc" id="L179" title="All 2 branches missed.">                if (attrs.get(JAVA_ATTRIBUTES[TYPENAME]) == null) {</span>
<span class="nc" id="L180">                    Attribute tAttr =</span>
<span class="nc" id="L181">                        LdapCtxFactory.createTypeNameAttr(obj.getClass());</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                    if (tAttr != null) {</span>
<span class="nc" id="L183">                        attrs.put(tAttr);</span>
                    }
<span class="nc" id="L185">                }</span>
    // DirContext Object
<span class="nc bnc" id="L187" title="All 2 branches missed.">            } else if (obj instanceof DirContext) {</span>
                // do nothing
            } else {
<span class="nc" id="L190">                throw new IllegalArgumentException(</span>
            &quot;can only bind Referenceable, Serializable, DirContext&quot;);
            }
            //      System.err.println(attrs);
<span class="nc" id="L194">            return attrs;</span>
    }

    /**
     * Each value in javaCodebase contains a list of space-separated
     * URLs. Each value is independent; we can pick any of the values
     * so we just use the first one.
     * @return an array of URL strings for the codebase
     */
    private static String[] getCodebases(Attribute codebaseAttr) throws
        NamingException {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (codebaseAttr == null) {</span>
<span class="nc" id="L206">            return null;</span>
        } else {
<span class="nc" id="L208">            StringTokenizer parser =</span>
<span class="nc" id="L209">                new StringTokenizer((String)codebaseAttr.get());</span>
<span class="nc" id="L210">            Vector&lt;String&gt; vec = new Vector&lt;&gt;(10);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            while (parser.hasMoreTokens()) {</span>
<span class="nc" id="L212">                vec.addElement(parser.nextToken());</span>
            }
<span class="nc" id="L214">            String[] answer = new String[vec.size()];</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">            for (int i = 0; i &lt; answer.length; i++) {</span>
<span class="nc" id="L216">                answer[i] = vec.elementAt(i);</span>
            }
<span class="nc" id="L218">            return answer;</span>
        }
    }

    /*
     * Decode an object from LDAP attribute(s).
     * The object may be a Reference, or a Serialized object.
     *
     * See encodeObject() and encodeReference() for details on formats
     * expected.
     */
    static Object decodeObject(Attributes attrs)
        throws NamingException {

        Attribute attr;

        // Get codebase, which is used in all 3 cases.
<span class="nc" id="L235">        String[] codebases = getCodebases(attrs.get(JAVA_ATTRIBUTES[CODEBASE]));</span>
        try {
<span class="nc bnc" id="L237" title="All 2 branches missed.">            if ((attr = attrs.get(JAVA_ATTRIBUTES[SERIALIZED_DATA])) != null) {</span>
<span class="nc" id="L238">                ClassLoader cl = helper.getURLClassLoader(codebases);</span>
<span class="nc" id="L239">                return deserializeObject((byte[])attr.get(), cl);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            } else if ((attr = attrs.get(JAVA_ATTRIBUTES[REMOTE_LOC])) != null) {</span>
                // For backward compatibility only
<span class="nc" id="L242">                return decodeRmiObject(</span>
<span class="nc" id="L243">                    (String)attrs.get(JAVA_ATTRIBUTES[CLASSNAME]).get(),</span>
<span class="nc" id="L244">                    (String)attr.get(), codebases);</span>
            }

<span class="nc" id="L247">            attr = attrs.get(JAVA_ATTRIBUTES[OBJECT_CLASS]);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            if (attr != null &amp;&amp;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">                (attr.contains(JAVA_OBJECT_CLASSES[REF_OBJECT]) ||</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                    attr.contains(JAVA_OBJECT_CLASSES_LOWER[REF_OBJECT]))) {</span>
<span class="nc" id="L251">                return decodeReference(attrs, codebases);</span>
            }
<span class="nc" id="L253">            return null;</span>
<span class="nc" id="L254">        } catch (IOException e) {</span>
<span class="nc" id="L255">            NamingException ne = new NamingException();</span>
<span class="nc" id="L256">            ne.setRootCause(e);</span>
<span class="nc" id="L257">            throw ne;</span>
        }
    }

    /**
     * Convert a Reference object into several LDAP attributes.
     *
     * A Reference is stored as into the following attributes:
     * javaClassName
     *   value: Reference.getClassName();
     * javaFactory
     *   value: Reference.getFactoryClassName();
     * javaCodeBase
     *   value: Reference.getFactoryClassLocation();
     * javaReferenceAddress
     *   value: #0#typeA#valA
     *   value: #1#typeB#valB
     *   value: #2#typeC##[serialized RefAddr C]
     *   value: #3#typeD#valD
     *
     * where
     * -  the first character denotes the separator
     * -  the number following the first separator denotes the position
     *    of the RefAddr within the Reference
     * -  &quot;typeA&quot; is RefAddr.getType()
     * -  ## denotes that the Base64-encoded form of the non-StringRefAddr
     *    is to follow; otherwise the value that follows is
     *    StringRefAddr.getContents()
     *
     * The default separator is the hash character (#).
     * May provide property for this in future.
     */

    private static Attributes encodeReference(char separator,
        Reference ref, Attributes attrs, Object orig)
        throws NamingException {

<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (ref == null)</span>
<span class="nc" id="L295">            return attrs;</span>

        String s;

<span class="nc bnc" id="L299" title="All 2 branches missed.">        if ((s = ref.getClassName()) != null) {</span>
<span class="nc" id="L300">            attrs.put(new BasicAttribute(JAVA_ATTRIBUTES[CLASSNAME], s));</span>
        }

<span class="nc bnc" id="L303" title="All 2 branches missed.">        if ((s = ref.getFactoryClassName()) != null) {</span>
<span class="nc" id="L304">            attrs.put(new BasicAttribute(JAVA_ATTRIBUTES[FACTORY], s));</span>
        }

<span class="nc bnc" id="L307" title="All 2 branches missed.">        if ((s = ref.getFactoryClassLocation()) != null) {</span>
<span class="nc" id="L308">            attrs.put(new BasicAttribute(JAVA_ATTRIBUTES[CODEBASE], s));</span>
        }

        // Get original object's types if caller has not explicitly
        // specified other type names
<span class="nc bnc" id="L313" title="All 4 branches missed.">        if (orig != null &amp;&amp; attrs.get(JAVA_ATTRIBUTES[TYPENAME]) != null) {</span>
<span class="nc" id="L314">            Attribute tAttr =</span>
<span class="nc" id="L315">                LdapCtxFactory.createTypeNameAttr(orig.getClass());</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (tAttr != null) {</span>
<span class="nc" id="L317">                attrs.put(tAttr);</span>
            }
        }

<span class="nc" id="L321">        int count = ref.size();</span>

<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (count &gt; 0) {</span>

<span class="nc" id="L325">            Attribute refAttr = new BasicAttribute(JAVA_ATTRIBUTES[REF_ADDR]);</span>
            RefAddr refAddr;
<span class="nc" id="L327">            BASE64Encoder encoder = null;</span>

<span class="nc bnc" id="L329" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L330">                refAddr = ref.get(i);</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">                if (refAddr instanceof StringRefAddr) {</span>
<span class="nc" id="L333">                    refAttr.add(&quot;&quot;+ separator + i +</span>
<span class="nc" id="L334">                        separator +     refAddr.getType() +</span>
<span class="nc" id="L335">                        separator + refAddr.getContent());</span>
                } else {
<span class="nc bnc" id="L337" title="All 2 branches missed.">                    if (encoder == null)</span>
<span class="nc" id="L338">                        encoder = new BASE64Encoder();</span>

<span class="nc" id="L340">                    refAttr.add(&quot;&quot;+ separator + i +</span>
<span class="nc" id="L341">                        separator + refAddr.getType() +</span>
                        separator + separator +
<span class="nc" id="L343">                        encoder.encodeBuffer(serializeObject(refAddr)));</span>
                }
            }
<span class="nc" id="L346">            attrs.put(refAttr);</span>
        }
<span class="nc" id="L348">        return attrs;</span>
    }

    /*
     * A RMI object is stored in the directory as
     * javaClassName
     *   value: Object.getClass();
     * javaRemoteLocation
     *   value: URL of RMI object (accessed through the RMI Registry)
     * javaCodebase:
     *   value: URL of codebase of where to find classes for object
     *
     * Return the RMI Location URL itself. This will be turned into
     * an RMI object when getObjectInstance() is called on it.
     * %%% Ignore codebase for now. Depend on RMI registry to send code.-RL
     * @deprecated For backward compatibility only
     */
    private static Object decodeRmiObject(String className,
        String rmiName, String[] codebases) throws NamingException {
<span class="nc" id="L367">            return new Reference(className, new StringRefAddr(&quot;URL&quot;, rmiName));</span>
    }

    /*
     * Restore a Reference object from several LDAP attributes
     */
    private static Reference decodeReference(Attributes attrs,
        String[] codebases) throws NamingException, IOException {

        Attribute attr;
        String className;
<span class="nc" id="L378">        String factory = null;</span>

<span class="nc bnc" id="L380" title="All 2 branches missed.">        if ((attr = attrs.get(JAVA_ATTRIBUTES[CLASSNAME])) != null) {</span>
<span class="nc" id="L381">            className = (String)attr.get();</span>
        } else {
<span class="nc" id="L383">            throw new InvalidAttributesException(JAVA_ATTRIBUTES[CLASSNAME] +</span>
                        &quot; attribute is required&quot;);
        }

<span class="nc bnc" id="L387" title="All 2 branches missed.">        if ((attr = attrs.get(JAVA_ATTRIBUTES[FACTORY])) != null) {</span>
<span class="nc" id="L388">            factory = (String)attr.get();</span>
        }

<span class="nc bnc" id="L391" title="All 2 branches missed.">        Reference ref = new Reference(className, factory,</span>
            (codebases != null? codebases[0] : null));

        /*
         * string encoding of a RefAddr is either:
         *
         *      #posn#&lt;type&gt;#&lt;address&gt;
         * or
         *      #posn#&lt;type&gt;##&lt;base64-encoded address&gt;
         */
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if ((attr = attrs.get(JAVA_ATTRIBUTES[REF_ADDR])) != null) {</span>

            String val, posnStr, type;
            char separator;
            int start, sep, posn;
<span class="nc" id="L406">            BASE64Decoder decoder = null;</span>

<span class="nc" id="L408">            ClassLoader cl = helper.getURLClassLoader(codebases);</span>

            /*
             * Temporary Vector for decoded RefAddr addresses - used to ensure
             * unordered addresses are correctly re-ordered.
             */
<span class="nc" id="L414">            Vector&lt;RefAddr&gt; refAddrList = new Vector&lt;&gt;();</span>
<span class="nc" id="L415">            refAddrList.setSize(attr.size());</span>

<span class="nc bnc" id="L417" title="All 2 branches missed.">            for (NamingEnumeration&lt;?&gt; vals = attr.getAll(); vals.hasMore(); ) {</span>

<span class="nc" id="L419">                val = (String)vals.next();</span>

<span class="nc bnc" id="L421" title="All 2 branches missed.">                if (val.length() == 0) {</span>
<span class="nc" id="L422">                    throw new InvalidAttributeValueException(</span>
                        &quot;malformed &quot; + JAVA_ATTRIBUTES[REF_ADDR] + &quot; attribute - &quot;+
                        &quot;empty attribute value&quot;);
                }
                // first character denotes encoding separator
<span class="nc" id="L427">                separator = val.charAt(0);</span>
<span class="nc" id="L428">                start = 1;  // skip over separator</span>

                // extract position within Reference
<span class="nc bnc" id="L431" title="All 2 branches missed.">                if ((sep = val.indexOf(separator, start)) &lt; 0) {</span>
<span class="nc" id="L432">                    throw new InvalidAttributeValueException(</span>
                        &quot;malformed &quot; + JAVA_ATTRIBUTES[REF_ADDR] + &quot; attribute - &quot; +
                        &quot;separator '&quot; + separator + &quot;'&quot; + &quot;not found&quot;);
                }
<span class="nc bnc" id="L436" title="All 2 branches missed.">                if ((posnStr = val.substring(start, sep)) == null) {</span>
<span class="nc" id="L437">                    throw new InvalidAttributeValueException(</span>
                        &quot;malformed &quot; + JAVA_ATTRIBUTES[REF_ADDR] + &quot; attribute - &quot; +
                        &quot;empty RefAddr position&quot;);
                }
                try {
<span class="nc" id="L442">                    posn = Integer.parseInt(posnStr);</span>
<span class="nc" id="L443">                } catch (NumberFormatException nfe) {</span>
<span class="nc" id="L444">                    throw new InvalidAttributeValueException(</span>
                        &quot;malformed &quot; + JAVA_ATTRIBUTES[REF_ADDR] + &quot; attribute - &quot; +
                        &quot;RefAddr position not an integer&quot;);
<span class="nc" id="L447">                }</span>
<span class="nc" id="L448">                start = sep + 1; // skip over position and trailing separator</span>

                // extract type
<span class="nc bnc" id="L451" title="All 2 branches missed.">                if ((sep = val.indexOf(separator, start)) &lt; 0) {</span>
<span class="nc" id="L452">                    throw new InvalidAttributeValueException(</span>
                        &quot;malformed &quot; + JAVA_ATTRIBUTES[REF_ADDR] + &quot; attribute - &quot; +
                        &quot;RefAddr type not found&quot;);
                }
<span class="nc bnc" id="L456" title="All 2 branches missed.">                if ((type = val.substring(start, sep)) == null) {</span>
<span class="nc" id="L457">                    throw new InvalidAttributeValueException(</span>
                        &quot;malformed &quot; + JAVA_ATTRIBUTES[REF_ADDR] + &quot; attribute - &quot; +
                        &quot;empty RefAddr type&quot;);
                }
<span class="nc" id="L461">                start = sep + 1; // skip over type and trailing separator</span>

                // extract content
<span class="nc bnc" id="L464" title="All 2 branches missed.">                if (start == val.length()) {</span>
                    // Empty content
<span class="nc" id="L466">                    refAddrList.setElementAt(new StringRefAddr(type, null), posn);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                } else if (val.charAt(start) == separator) {</span>
                    // Double separators indicate a non-StringRefAddr
                    // Content is a Base64-encoded serialized RefAddr

<span class="nc" id="L471">                    ++start;  // skip over consecutive separator</span>
                    // %%% RL: exception if empty after double separator

<span class="nc bnc" id="L474" title="All 2 branches missed.">                    if (decoder == null)</span>
<span class="nc" id="L475">                        decoder = new BASE64Decoder();</span>

<span class="nc" id="L477">                    RefAddr ra = (RefAddr)</span>
<span class="nc" id="L478">                        deserializeObject(</span>
<span class="nc" id="L479">                            decoder.decodeBuffer(val.substring(start)),</span>
                            cl);

<span class="nc" id="L482">                    refAddrList.setElementAt(ra, posn);</span>
<span class="nc" id="L483">                } else {</span>
                    // Single separator indicates a StringRefAddr
<span class="nc" id="L485">                    refAddrList.setElementAt(new StringRefAddr(type,</span>
<span class="nc" id="L486">                        val.substring(start)), posn);</span>
                }
            }

            // Copy to real reference
<span class="nc bnc" id="L491" title="All 2 branches missed.">            for (int i = 0; i &lt; refAddrList.size(); i++) {</span>
<span class="nc" id="L492">                ref.add(refAddrList.elementAt(i));</span>
            }
        }

<span class="nc" id="L496">        return (ref);</span>
    }

    /*
     * Serialize an object into a byte array
     */
    private static byte[] serializeObject(Object obj) throws NamingException {

        try {
<span class="nc" id="L505">            ByteArrayOutputStream bytes = new ByteArrayOutputStream();</span>
<span class="nc" id="L506">            try (ObjectOutputStream serial = new ObjectOutputStream(bytes)) {</span>
<span class="nc" id="L507">                serial.writeObject(obj);</span>
<span class="nc bnc" id="L508" title="All 8 branches missed.">            }</span>

<span class="nc" id="L510">            return (bytes.toByteArray());</span>

<span class="nc" id="L512">        } catch (IOException e) {</span>
<span class="nc" id="L513">            NamingException ne = new NamingException();</span>
<span class="nc" id="L514">            ne.setRootCause(e);</span>
<span class="nc" id="L515">            throw ne;</span>
        }
    }

    /*
     * Deserializes a byte array into an object.
     */
    private static Object deserializeObject(byte[] obj, ClassLoader cl)
        throws NamingException {

        try {
            // Create ObjectInputStream for deserialization
<span class="nc" id="L527">            ByteArrayInputStream bytes = new ByteArrayInputStream(obj);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            try (ObjectInputStream deserial = cl == null ?</span>
                    new ObjectInputStream(bytes) :
                    new LoaderInputStream(bytes, cl)) {
<span class="nc" id="L531">                return deserial.readObject();</span>
<span class="nc bnc" id="L532" title="All 8 branches missed.">            } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L533">                NamingException ne = new NamingException();</span>
<span class="nc" id="L534">                ne.setRootCause(e);</span>
<span class="nc" id="L535">                throw ne;</span>
            }
<span class="nc" id="L537">        } catch (IOException e) {</span>
<span class="nc" id="L538">            NamingException ne = new NamingException();</span>
<span class="nc" id="L539">            ne.setRootCause(e);</span>
<span class="nc" id="L540">            throw ne;</span>
        }
    }

    /**
      * Returns the attributes to bind given an object and its attributes.
      */
    static Attributes determineBindAttrs(
        char separator, Object obj, Attributes attrs, boolean cloned,
        Name name, Context ctx, Hashtable&lt;?,?&gt; env)
        throws NamingException {

        // Call state factories to convert object and attrs
<span class="nc" id="L553">        DirStateFactory.Result res =</span>
<span class="nc" id="L554">            DirectoryManager.getStateToBind(obj, name, ctx, env, attrs);</span>
<span class="nc" id="L555">        obj = res.getObject();</span>
<span class="nc" id="L556">        attrs = res.getAttributes();</span>

        // We're only storing attributes; no further processing required
<span class="nc bnc" id="L559" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L560">            return attrs;</span>
        }

        //if object to be bound is a DirContext extract its attributes
<span class="nc bnc" id="L564" title="All 4 branches missed.">        if ((attrs == null) &amp;&amp; (obj instanceof DirContext)) {</span>
<span class="nc" id="L565">            cloned = true;</span>
<span class="nc" id="L566">            attrs = ((DirContext)obj).getAttributes(&quot;&quot;);</span>
        }

<span class="nc" id="L569">        boolean ocNeedsCloning = false;</span>

        // Create &quot;objectClass&quot; attribute
        Attribute objectClass;
<span class="nc bnc" id="L573" title="All 4 branches missed.">        if (attrs == null || attrs.size() == 0) {</span>
<span class="nc" id="L574">            attrs = new BasicAttributes(LdapClient.caseIgnore);</span>
<span class="nc" id="L575">            cloned = true;</span>

            // No objectclasses supplied, use &quot;top&quot; to start
<span class="nc" id="L578">            objectClass = new BasicAttribute(&quot;objectClass&quot;, &quot;top&quot;);</span>

        } else {
            // Get existing objectclass attribute
<span class="nc" id="L582">            objectClass = attrs.get(&quot;objectClass&quot;);</span>
<span class="nc bnc" id="L583" title="All 4 branches missed.">            if (objectClass == null &amp;&amp; !attrs.isCaseIgnored()) {</span>
                // %%% workaround
<span class="nc" id="L585">                objectClass = attrs.get(&quot;objectclass&quot;);</span>
            }

            // No objectclasses supplied, use &quot;top&quot; to start
<span class="nc bnc" id="L589" title="All 2 branches missed.">            if (objectClass == null) {</span>
<span class="nc" id="L590">                objectClass =  new BasicAttribute(&quot;objectClass&quot;, &quot;top&quot;);</span>
<span class="nc bnc" id="L591" title="All 4 branches missed.">            } else if (ocNeedsCloning || !cloned) {</span>
<span class="nc" id="L592">                objectClass = (Attribute)objectClass.clone();</span>
            }
        }

        // convert the supplied object into LDAP attributes
<span class="nc" id="L597">        attrs = encodeObject(separator, obj, attrs, objectClass, cloned);</span>

        // System.err.println(&quot;Determined: &quot; + attrs);
<span class="nc" id="L600">        return attrs;</span>
    }

    /**
     * An ObjectInputStream that uses a class loader to find classes.
     */
    private static final class LoaderInputStream extends ObjectInputStream {
        private ClassLoader classLoader;

        LoaderInputStream(InputStream in, ClassLoader cl) throws IOException {
<span class="nc" id="L610">            super(in);</span>
<span class="nc" id="L611">            classLoader = cl;</span>
<span class="nc" id="L612">        }</span>

        protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws
                IOException, ClassNotFoundException {
            try {
                // %%% Should use Class.forName(desc.getName(), false, classLoader);
                // except we can't because that is only available on JDK1.2
<span class="nc" id="L619">                return classLoader.loadClass(desc.getName());</span>
<span class="nc" id="L620">            } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L621">                return super.resolveClass(desc);</span>
            }
        }

         protected Class&lt;?&gt; resolveProxyClass(String[] interfaces) throws
                IOException, ClassNotFoundException {
<span class="nc" id="L627">             ClassLoader nonPublicLoader = null;</span>
<span class="nc" id="L628">             boolean hasNonPublicInterface = false;</span>

             // define proxy in class loader of non-public interface(s), if any
<span class="nc" id="L631">             Class&lt;?&gt;[] classObjs = new Class&lt;?&gt;[interfaces.length];</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">             for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="nc" id="L633">                 Class&lt;?&gt; cl = Class.forName(interfaces[i], false, classLoader);</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                 if ((cl.getModifiers() &amp; Modifier.PUBLIC) == 0) {</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                     if (hasNonPublicInterface) {</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">                         if (nonPublicLoader != cl.getClassLoader()) {</span>
<span class="nc" id="L637">                             throw new IllegalAccessError(</span>
                                &quot;conflicting non-public interface class loaders&quot;);
                         }
                     } else {
<span class="nc" id="L641">                         nonPublicLoader = cl.getClassLoader();</span>
<span class="nc" id="L642">                         hasNonPublicInterface = true;</span>
                     }
                 }
<span class="nc" id="L645">                 classObjs[i] = cl;</span>
             }
             try {
<span class="nc bnc" id="L648" title="All 2 branches missed.">                 return Proxy.getProxyClass(hasNonPublicInterface ?</span>
                        nonPublicLoader : classLoader, classObjs);
<span class="nc" id="L650">             } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L651">                 throw new ClassNotFoundException(null, e);</span>
             }
         }

     }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>