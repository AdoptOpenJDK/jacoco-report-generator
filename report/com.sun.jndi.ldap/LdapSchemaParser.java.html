<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LdapSchemaParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jndi.ldap</a> &gt; <span class="el_source">LdapSchemaParser.java</span></div><h1>LdapSchemaParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jndi.ldap;

import javax.naming.*;
import javax.naming.directory.*;
import java.util.Vector;

/**
 * Netscape's 3.1 servers have some schema bugs:
 * - It puts quotes around OIDs (such as those for SUP, SYNTAX).
 * - When you try to write out the MUST/MAY list (such as &quot;MUST cn&quot;),
 *   it wants (&quot;MUST (cn)&quot;) instead
 */

final class LdapSchemaParser {

    // do debugging
    private static final boolean debug = false;


    // names of attribute IDs in the LDAP schema entry
    static final String OBJECTCLASSDESC_ATTR_ID = &quot;objectClasses&quot;;
    static final String ATTRIBUTEDESC_ATTR_ID = &quot;attributeTypes&quot;;
    static final String SYNTAXDESC_ATTR_ID = &quot;ldapSyntaxes&quot;;
    static final String MATCHRULEDESC_ATTR_ID = &quot;matchingRules&quot;;

    // information for creating internal nodes in JNDI schema tree
    static final String OBJECTCLASS_DEFINITION_NAME =
                        &quot;ClassDefinition&quot;;
<span class="nc" id="L54">    private static final String[] CLASS_DEF_ATTRS = {</span>
                         &quot;objectclass&quot;, &quot;ClassDefinition&quot;};
            static final String ATTRIBUTE_DEFINITION_NAME =
                        &quot;AttributeDefinition&quot;;
<span class="nc" id="L58">    private static final String[] ATTR_DEF_ATTRS = {</span>
                        &quot;objectclass&quot;, &quot;AttributeDefinition&quot; };
            static final String SYNTAX_DEFINITION_NAME =
                        &quot;SyntaxDefinition&quot;;
<span class="nc" id="L62">    private static final String[] SYNTAX_DEF_ATTRS = {</span>
                        &quot;objectclass&quot;, &quot;SyntaxDefinition&quot; };
            static final String MATCHRULE_DEFINITION_NAME =
                        &quot;MatchingRule&quot;;
<span class="nc" id="L66">    private static final String[] MATCHRULE_DEF_ATTRS = {</span>
                        &quot;objectclass&quot;, &quot;MatchingRule&quot; };

    // special tokens used in LDAP schema descriptions
    private static final char   SINGLE_QUOTE = '\'';
    private static final char   WHSP = ' ';
    private static final char   OID_LIST_BEGIN = '(';
    private static final char   OID_LIST_END = ')';
    private static final char   OID_SEPARATOR = '$';

    // common IDs
    private static final String  NUMERICOID_ID = &quot;NUMERICOID&quot;;
    private static final String        NAME_ID = &quot;NAME&quot;;
    private static final String        DESC_ID = &quot;DESC&quot;;
    private static final String    OBSOLETE_ID = &quot;OBSOLETE&quot;;
    private static final String         SUP_ID = &quot;SUP&quot;;
    private static final String     PRIVATE_ID = &quot;X-&quot;;

    // Object Class specific IDs
    private static final String    ABSTRACT_ID = &quot;ABSTRACT&quot;;
    private static final String  STRUCTURAL_ID = &quot;STRUCTURAL&quot;;
    private static final String    AUXILARY_ID = &quot;AUXILIARY&quot;;
    private static final String        MUST_ID = &quot;MUST&quot;;
    private static final String         MAY_ID = &quot;MAY&quot;;

    // Attribute Type specific IDs
    private static final String    EQUALITY_ID = &quot;EQUALITY&quot;;
    private static final String    ORDERING_ID = &quot;ORDERING&quot;;
    private static final String      SUBSTR_ID = &quot;SUBSTR&quot;;
    private static final String      SYNTAX_ID = &quot;SYNTAX&quot;;
    private static final String  SINGLE_VAL_ID = &quot;SINGLE-VALUE&quot;;
    private static final String  COLLECTIVE_ID = &quot;COLLECTIVE&quot;;
    private static final String NO_USER_MOD_ID = &quot;NO-USER-MODIFICATION&quot;;
    private static final String       USAGE_ID = &quot;USAGE&quot;;

    // The string value we give to boolean variables
    private static final String SCHEMA_TRUE_VALUE = &quot;true&quot;;

    // To get around writing schemas that crash Netscape server
    private boolean netscapeBug;

<span class="nc" id="L107">    LdapSchemaParser(boolean netscapeBug) {</span>
<span class="nc" id="L108">        this.netscapeBug = netscapeBug;</span>
<span class="nc" id="L109">    }</span>

    final static void LDAP2JNDISchema(Attributes schemaAttrs,
        LdapSchemaCtx schemaRoot) throws NamingException {
<span class="nc" id="L113">        Attribute               objectClassesAttr = null;</span>
<span class="nc" id="L114">        Attribute               attributeDefAttr = null;</span>
<span class="nc" id="L115">        Attribute               syntaxDefAttr = null;</span>
<span class="nc" id="L116">        Attribute               matchRuleDefAttr = null;</span>

<span class="nc" id="L118">        objectClassesAttr = schemaAttrs.get(OBJECTCLASSDESC_ATTR_ID);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if(objectClassesAttr != null) {</span>
<span class="nc" id="L120">            objectDescs2ClassDefs(objectClassesAttr,schemaRoot);</span>
        }

<span class="nc" id="L123">        attributeDefAttr = schemaAttrs.get(ATTRIBUTEDESC_ATTR_ID);</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if(attributeDefAttr != null) {</span>
<span class="nc" id="L125">            attrDescs2AttrDefs(attributeDefAttr, schemaRoot);</span>
        }

<span class="nc" id="L128">        syntaxDefAttr = schemaAttrs.get(SYNTAXDESC_ATTR_ID);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if(syntaxDefAttr != null) {</span>
<span class="nc" id="L130">            syntaxDescs2SyntaxDefs(syntaxDefAttr, schemaRoot);</span>
        }

<span class="nc" id="L133">        matchRuleDefAttr = schemaAttrs.get(MATCHRULEDESC_ATTR_ID);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if(matchRuleDefAttr != null) {</span>
<span class="nc" id="L135">            matchRuleDescs2MatchRuleDefs(matchRuleDefAttr, schemaRoot);</span>
        }
<span class="nc" id="L137">    }</span>

    final private static DirContext objectDescs2ClassDefs(Attribute objDescsAttr,
                                                   LdapSchemaCtx schemaRoot)
        throws NamingException {

        NamingEnumeration&lt;?&gt; objDescs;
        Attributes                objDef;
        LdapSchemaCtx             classDefTree;

        // create the class def subtree
<span class="nc" id="L148">        Attributes attrs = new BasicAttributes(LdapClient.caseIgnore);</span>
<span class="nc" id="L149">        attrs.put(CLASS_DEF_ATTRS[0], CLASS_DEF_ATTRS[1]);</span>
<span class="nc" id="L150">        classDefTree = schemaRoot.setup(LdapSchemaCtx.OBJECTCLASS_ROOT,</span>
            OBJECTCLASS_DEFINITION_NAME, attrs);

<span class="nc" id="L153">        objDescs = objDescsAttr.getAll();</span>
        String currentName;
<span class="nc bnc" id="L155" title="All 2 branches missed.">        while(objDescs.hasMore()) {</span>
<span class="nc" id="L156">            String objDesc = (String)objDescs.next();</span>
            try {
<span class="nc" id="L158">                Object[] def = desc2Def(objDesc);</span>
<span class="nc" id="L159">                currentName = (String) def[0];</span>
<span class="nc" id="L160">                objDef = (Attributes) def[1];</span>
<span class="nc" id="L161">                classDefTree.setup(LdapSchemaCtx.OBJECTCLASS,</span>
                    currentName, objDef);
<span class="nc" id="L163">            } catch (NamingException ne) {</span>
                // error occurred while parsing, ignore current entry
<span class="nc" id="L165">            }</span>
<span class="nc" id="L166">        }</span>

<span class="nc" id="L168">        return classDefTree;</span>
    }

    final private static DirContext attrDescs2AttrDefs(Attribute attributeDescAttr,
                                                LdapSchemaCtx schemaRoot)
        throws NamingException {

        NamingEnumeration&lt;?&gt; attrDescs;
        Attributes           attrDef;
        LdapSchemaCtx        attrDefTree;

        // create the AttributeDef subtree
<span class="nc" id="L180">        Attributes attrs = new BasicAttributes(LdapClient.caseIgnore);</span>
<span class="nc" id="L181">        attrs.put(ATTR_DEF_ATTRS[0], ATTR_DEF_ATTRS[1]);</span>
<span class="nc" id="L182">        attrDefTree = schemaRoot.setup(LdapSchemaCtx.ATTRIBUTE_ROOT,</span>
            ATTRIBUTE_DEFINITION_NAME, attrs);

<span class="nc" id="L185">        attrDescs = attributeDescAttr.getAll();</span>
        String currentName;
<span class="nc bnc" id="L187" title="All 2 branches missed.">        while(attrDescs.hasMore()) {</span>
<span class="nc" id="L188">            String attrDesc = (String)attrDescs.next();</span>
            try {
<span class="nc" id="L190">                Object[] def = desc2Def(attrDesc);</span>
<span class="nc" id="L191">                currentName = (String) def[0];</span>
<span class="nc" id="L192">                attrDef = (Attributes) def[1];</span>
<span class="nc" id="L193">                attrDefTree.setup(LdapSchemaCtx.ATTRIBUTE,</span>
                    currentName, attrDef);
<span class="nc" id="L195">            } catch (NamingException ne) {</span>
                // error occurred while parsing, ignore current entry
<span class="nc" id="L197">            }</span>
<span class="nc" id="L198">        }</span>

<span class="nc" id="L200">        return attrDefTree;</span>
    }

    final private static DirContext syntaxDescs2SyntaxDefs(
                                                Attribute syntaxDescAttr,
                                                LdapSchemaCtx schemaRoot)
        throws NamingException {

        NamingEnumeration&lt;?&gt; syntaxDescs;
        Attributes           syntaxDef;
        LdapSchemaCtx        syntaxDefTree;

        // create the SyntaxDef subtree
<span class="nc" id="L213">        Attributes attrs = new BasicAttributes(LdapClient.caseIgnore);</span>
<span class="nc" id="L214">        attrs.put(SYNTAX_DEF_ATTRS[0], SYNTAX_DEF_ATTRS[1]);</span>
<span class="nc" id="L215">        syntaxDefTree = schemaRoot.setup(LdapSchemaCtx.SYNTAX_ROOT,</span>
            SYNTAX_DEFINITION_NAME, attrs);

<span class="nc" id="L218">        syntaxDescs = syntaxDescAttr.getAll();</span>
        String currentName;
<span class="nc bnc" id="L220" title="All 2 branches missed.">        while(syntaxDescs.hasMore()) {</span>
<span class="nc" id="L221">            String syntaxDesc = (String)syntaxDescs.next();</span>
            try {
<span class="nc" id="L223">                Object[] def = desc2Def(syntaxDesc);</span>
<span class="nc" id="L224">                currentName = (String) def[0];</span>
<span class="nc" id="L225">                syntaxDef = (Attributes) def[1];</span>
<span class="nc" id="L226">                syntaxDefTree.setup(LdapSchemaCtx.SYNTAX,</span>
                    currentName, syntaxDef);
<span class="nc" id="L228">            } catch (NamingException ne) {</span>
                // error occurred while parsing, ignore current entry
<span class="nc" id="L230">            }</span>
<span class="nc" id="L231">        }</span>

<span class="nc" id="L233">        return syntaxDefTree;</span>
    }

    final private static DirContext matchRuleDescs2MatchRuleDefs(
                                                Attribute matchRuleDescAttr,
                                                LdapSchemaCtx schemaRoot)
        throws NamingException {

        NamingEnumeration&lt;?&gt; matchRuleDescs;
        Attributes           matchRuleDef;
        LdapSchemaCtx        matchRuleDefTree;

        // create the MatchRuleDef subtree
<span class="nc" id="L246">        Attributes attrs = new BasicAttributes(LdapClient.caseIgnore);</span>
<span class="nc" id="L247">        attrs.put(MATCHRULE_DEF_ATTRS[0], MATCHRULE_DEF_ATTRS[1]);</span>
<span class="nc" id="L248">        matchRuleDefTree = schemaRoot.setup(LdapSchemaCtx.MATCHRULE_ROOT,</span>
            MATCHRULE_DEFINITION_NAME, attrs);

<span class="nc" id="L251">        matchRuleDescs = matchRuleDescAttr.getAll();</span>
        String currentName;
<span class="nc bnc" id="L253" title="All 2 branches missed.">        while(matchRuleDescs.hasMore()) {</span>
<span class="nc" id="L254">            String matchRuleDesc = (String)matchRuleDescs.next();</span>
            try {
<span class="nc" id="L256">                Object[] def = desc2Def(matchRuleDesc);</span>
<span class="nc" id="L257">                currentName = (String) def[0];</span>
<span class="nc" id="L258">                matchRuleDef = (Attributes) def[1];</span>
<span class="nc" id="L259">                matchRuleDefTree.setup(LdapSchemaCtx.MATCHRULE,</span>
                    currentName, matchRuleDef);
<span class="nc" id="L261">            } catch (NamingException ne) {</span>
                // error occurred while parsing, ignore current entry
<span class="nc" id="L263">            }</span>
<span class="nc" id="L264">        }</span>

<span class="nc" id="L266">        return matchRuleDefTree;</span>
    }

    final private static Object[] desc2Def(String desc)
        throws NamingException {
            //System.err.println(desc);

<span class="nc" id="L273">        Attributes      attrs = new BasicAttributes(LdapClient.caseIgnore);</span>
<span class="nc" id="L274">        Attribute       attr = null;</span>
<span class="nc" id="L275">        int[]           pos = new int[]{1}; // tolerate missing leading space</span>
<span class="nc" id="L276">        boolean         moreTags = true;</span>

        // Always begins with &lt;whsp numericoid whsp&gt;
<span class="nc" id="L279">        attr = readNumericOID(desc, pos);</span>
<span class="nc" id="L280">        String currentName = (String) attr.get(0);  // name is OID by default</span>
<span class="nc" id="L281">        attrs.put(attr);</span>

<span class="nc" id="L283">        skipWhitespace(desc, pos);</span>

<span class="nc bnc" id="L285" title="All 2 branches missed.">        while (moreTags) {</span>
<span class="nc" id="L286">            attr = readNextTag(desc, pos);</span>
<span class="nc" id="L287">            attrs.put(attr);</span>

<span class="nc bnc" id="L289" title="All 2 branches missed.">            if (attr.getID().equals(NAME_ID)) {</span>
<span class="nc" id="L290">                currentName = (String) attr.get(0);  // use NAME attribute as name</span>
            }

<span class="nc" id="L293">            skipWhitespace(desc, pos);</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">            if( pos[0] &gt;= desc.length() -1 ) {</span>
<span class="nc" id="L296">                moreTags = false;</span>
            }
        }

<span class="nc" id="L300">        return new Object[] {currentName, attrs};</span>
    }

    // returns the index of the first whitespace char of a linear whitspace
    // sequince ending at the given position.
    final private static int findTrailingWhitespace(String string, int pos) {
<span class="nc bnc" id="L306" title="All 2 branches missed.">        for(int i = pos; i &gt; 0; i--) {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">            if(string.charAt(i) != WHSP) {</span>
<span class="nc" id="L308">                return i + 1;</span>
            }
        }
<span class="nc" id="L311">        return 0;</span>
    }

    final private static void skipWhitespace(String string, int[] pos) {
<span class="nc bnc" id="L315" title="All 2 branches missed.">        for(int i=pos[0]; i &lt; string.length(); i++) {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            if(string.charAt(i) != WHSP) {</span>
<span class="nc" id="L317">                pos[0] = i;</span>
                if (debug) {
                    System.err.println(&quot;skipWhitespace: skipping to &quot;+i);
                }
<span class="nc" id="L321">                return;</span>
            }
        }
<span class="nc" id="L324">    }</span>

    final private static Attribute readNumericOID(String string, int[] pos)
        throws NamingException {

        if (debug) {
            System.err.println(&quot;readNumericoid: pos=&quot;+pos[0]);
        }

        int begin, end;
<span class="nc" id="L334">        String value = null;</span>

<span class="nc" id="L336">        skipWhitespace(string, pos);</span>

<span class="nc" id="L338">        begin = pos[0];</span>
<span class="nc" id="L339">        end = string.indexOf(WHSP, begin);</span>

<span class="nc bnc" id="L341" title="All 4 branches missed.">        if (end == -1 || end - begin &lt; 1) {</span>
<span class="nc" id="L342">            throw new InvalidAttributeValueException(&quot;no numericoid found: &quot;</span>
                                                     + string);
        }

<span class="nc" id="L346">        value = string.substring(begin, end);</span>

<span class="nc" id="L348">        pos[0] += value.length();</span>

<span class="nc" id="L350">        return new BasicAttribute(NUMERICOID_ID, value);</span>
    }

    final private static Attribute readNextTag(String string, int[] pos)
        throws NamingException {

<span class="nc" id="L356">        Attribute       attr = null;</span>
<span class="nc" id="L357">        String          tagName = null;</span>
<span class="nc" id="L358">        String[]        values = null;</span>

<span class="nc" id="L360">        skipWhitespace(string, pos);</span>

        if (debug) {
            System.err.println(&quot;readNextTag: pos=&quot;+pos[0]);
        }

        // get the name and values of the attribute to return
<span class="nc" id="L367">        int trailingSpace = string.indexOf( WHSP, pos[0] );</span>

        // tolerate a schema that omits the trailing space
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (trailingSpace &lt; 0) {</span>
<span class="nc" id="L371">            tagName = string.substring( pos[0], string.length() - 1);</span>
        } else {
<span class="nc" id="L373">            tagName = string.substring( pos[0], trailingSpace );</span>
        }

<span class="nc" id="L376">        values = readTag(tagName, string, pos);</span>

        // make sure at least one value was returned
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if(values.length &lt; 0) {</span>
<span class="nc" id="L380">            throw new InvalidAttributeValueException(&quot;no values for &quot; +</span>
                                                     &quot;attribute \&quot;&quot; +
                                                     tagName + &quot;\&quot;&quot;);
        }

        // create the attribute, using the first value
<span class="nc" id="L386">        attr = new BasicAttribute(tagName, values[0]);</span>

        // add other values if there are any
<span class="nc bnc" id="L389" title="All 2 branches missed.">        for(int i = 1; i &lt; values.length; i++) {</span>
<span class="nc" id="L390">            attr.add(values[i]);</span>
        }

<span class="nc" id="L393">        return attr;</span>
    }

    final private static String[] readTag(String tag, String string, int[] pos)
        throws NamingException {

        if (debug) {
            System.err.println(&quot;ReadTag: &quot; + tag + &quot; pos=&quot;+pos[0]);
        }

        // move parser past tag name
<span class="nc" id="L404">        pos[0] += tag.length();</span>
<span class="nc" id="L405">        skipWhitespace(string, pos);</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (tag.equals(NAME_ID)) {</span>
<span class="nc" id="L408">            return readQDescrs(string, pos);  // names[0] is NAME</span>
        }

<span class="nc bnc" id="L411" title="All 2 branches missed.">        if(tag.equals(DESC_ID)) {</span>
<span class="nc" id="L412">           return readQDString(string, pos);</span>
        }

<span class="nc" id="L415">        if (</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">           tag.equals(EQUALITY_ID) ||</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">           tag.equals(ORDERING_ID) ||</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">           tag.equals(SUBSTR_ID) ||</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">           tag.equals(SYNTAX_ID)) {</span>
<span class="nc" id="L420">            return readWOID(string, pos);</span>
        }

<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (tag.equals(OBSOLETE_ID) ||</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">            tag.equals(ABSTRACT_ID) ||</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">            tag.equals(STRUCTURAL_ID) ||</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            tag.equals(AUXILARY_ID) ||</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">            tag.equals(SINGLE_VAL_ID) ||</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            tag.equals(COLLECTIVE_ID) ||</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">            tag.equals(NO_USER_MOD_ID)) {</span>
<span class="nc" id="L430">            return new String[] {SCHEMA_TRUE_VALUE};</span>
        }

<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (tag.equals(SUP_ID) ||   // oid list for object class; WOID for attribute</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            tag.equals(MUST_ID) ||</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            tag.equals(MAY_ID) ||</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            tag.equals(USAGE_ID)) {</span>
<span class="nc" id="L437">            return readOIDs(string, pos);</span>
        }

        // otherwise it's a schema element with a quoted string value
<span class="nc" id="L441">        return readQDStrings(string, pos);</span>
    }

    final private static String[] readQDString(String string, int[] pos)
        throws NamingException {

        int begin, end;

<span class="nc" id="L449">        begin = string.indexOf(SINGLE_QUOTE, pos[0]) + 1;</span>
<span class="nc" id="L450">        end = string.indexOf(SINGLE_QUOTE, begin);</span>

        if (debug) {
            System.err.println(&quot;ReadQDString: pos=&quot; + pos[0] +
                               &quot; begin=&quot; + begin + &quot; end=&quot; + end);
        }

<span class="nc bnc" id="L457" title="All 6 branches missed.">        if(begin == -1 || end == -1 || begin == end) {</span>
<span class="nc" id="L458">            throw new InvalidAttributeIdentifierException(&quot;malformed &quot; +</span>
                                                          &quot;QDString: &quot; +
                                                          string);
        }

        // make sure the qdstring end symbol is there
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (string.charAt(begin - 1) != SINGLE_QUOTE) {</span>
<span class="nc" id="L465">            throw new InvalidAttributeIdentifierException(&quot;qdstring has &quot; +</span>
                                                          &quot;no end mark: &quot; +
                                                          string);
        }

<span class="nc" id="L470">        pos[0] = end+1;</span>
<span class="nc" id="L471">        return new String[] {string.substring(begin, end)};</span>
    }

   /**
    * dstring         = 1*utf8
    * qdstring        = whsp &quot;'&quot; dstring &quot;'&quot; whsp
    * qdstringlist    = [ qdstring *( qdstring ) ]
    * qdstrings       = qdstring / ( whsp &quot;(&quot; qdstringlist &quot;)&quot; whsp )
    */
    private final static String[] readQDStrings(String string, int[] pos)
        throws NamingException {

<span class="nc" id="L483">        return readQDescrs(string, pos);</span>
    }

    /**
     * ; object descriptors used as schema element names
     * qdescrs         = qdescr / ( whsp &quot;(&quot; qdescrlist &quot;)&quot; whsp )
     * qdescrlist      = [ qdescr *( qdescr ) ]
     * qdescr          = whsp &quot;'&quot; descr &quot;'&quot; whsp
     * descr           = keystring
     */
    final private static String[] readQDescrs(String string, int[] pos)
        throws NamingException {

        if (debug) {
            System.err.println(&quot;readQDescrs: pos=&quot;+pos[0]);
        }

<span class="nc" id="L500">        skipWhitespace(string, pos);</span>

<span class="nc bnc" id="L502" title="All 3 branches missed.">        switch( string.charAt(pos[0]) ) {</span>
        case OID_LIST_BEGIN:
<span class="nc" id="L504">            return readQDescrList(string, pos);</span>
        case SINGLE_QUOTE:
<span class="nc" id="L506">            return readQDString(string, pos);</span>
        default:
<span class="nc" id="L508">            throw new InvalidAttributeValueException(&quot;unexpected oids &quot; +</span>
                                                     &quot;string: &quot; + string);
        }
    }

    /**
     * qdescrlist      = [ qdescr *( qdescr ) ]
     * qdescr          = whsp &quot;'&quot; descr &quot;'&quot; whsp
     * descr           = keystring
     */
    final private static String[] readQDescrList(String string, int[] pos)
        throws NamingException {

        int begin, end;
<span class="nc" id="L522">        Vector&lt;String&gt; values = new Vector&lt;&gt;(5);</span>

        if (debug) {
            System.err.println(&quot;ReadQDescrList: pos=&quot;+pos[0]);
        }

<span class="nc" id="L528">        pos[0]++; // skip '('</span>
<span class="nc" id="L529">        skipWhitespace(string, pos);</span>
<span class="nc" id="L530">        begin = pos[0];</span>
<span class="nc" id="L531">        end = string.indexOf(OID_LIST_END, begin);</span>

<span class="nc bnc" id="L533" title="All 2 branches missed.">        if(end == -1) {</span>
<span class="nc" id="L534">            throw new InvalidAttributeValueException (&quot;oidlist has no end &quot;+</span>
                                                      &quot;mark: &quot; + string);
        }

<span class="nc bnc" id="L538" title="All 2 branches missed.">        while(begin &lt; end) {</span>
<span class="nc" id="L539">            String[] one = readQDString(string,  pos);</span>

            if (debug) {
                System.err.println(&quot;ReadQDescrList: found '&quot; + one[0] +
                                   &quot;' at begin=&quot; + begin + &quot; end =&quot; + end);
            }

<span class="nc" id="L546">            values.addElement(one[0]);</span>
<span class="nc" id="L547">            skipWhitespace(string, pos);</span>
<span class="nc" id="L548">            begin = pos[0];</span>
<span class="nc" id="L549">        }</span>

<span class="nc" id="L551">        pos[0] = end+1; // skip ')'</span>

<span class="nc" id="L553">        String[] answer = new String[values.size()];</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">        for (int i = 0; i &lt; answer.length; i++) {</span>
<span class="nc" id="L555">            answer[i] = values.elementAt(i);</span>
        }
<span class="nc" id="L557">        return answer;</span>
    }

    final private static String[] readWOID(String string, int[] pos)
        throws NamingException {

        if (debug) {
            System.err.println(&quot;readWOIDs: pos=&quot;+pos[0]);
        }

<span class="nc" id="L567">        skipWhitespace(string, pos);</span>

<span class="nc bnc" id="L569" title="All 2 branches missed.">        if (string.charAt(pos[0]) == SINGLE_QUOTE) {</span>
            // %%% workaround for Netscape schema bug
<span class="nc" id="L571">            return readQDString(string, pos);</span>
        }

        int begin, end;

<span class="nc" id="L576">        begin = pos[0];</span>
<span class="nc" id="L577">        end = string.indexOf(WHSP, begin);</span>

        if (debug) {
            System.err.println(&quot;ReadWOID: pos=&quot; + pos[0] +
                               &quot; begin=&quot; + begin + &quot; end=&quot; + end);
        }

<span class="nc bnc" id="L584" title="All 4 branches missed.">        if(end == -1 || begin == end) {</span>
<span class="nc" id="L585">            throw new InvalidAttributeIdentifierException(&quot;malformed &quot; +</span>
                                                          &quot;OID: &quot; +
                                                          string);
        }
<span class="nc" id="L589">        pos[0] = end+1;</span>

<span class="nc" id="L591">        return new String[] {string.substring(begin, end)};</span>
    }

    /*
     * oids            = woid / ( &quot;(&quot; oidlist &quot;)&quot; )
     * oidlist         = woid *( &quot;$&quot; woid )
     */
    final private static String[] readOIDs(String string, int[] pos)
        throws NamingException {

        if (debug) {
            System.err.println(&quot;readOIDs: pos=&quot;+pos[0]);
        }

<span class="nc" id="L605">        skipWhitespace(string, pos);</span>

        // Single OID
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (string.charAt(pos[0]) != OID_LIST_BEGIN) {</span>
<span class="nc" id="L609">            return readWOID(string, pos);</span>
        }

        // Multiple OIDs

        int     begin, cur, end;
<span class="nc" id="L615">        String  oidName = null;</span>
<span class="nc" id="L616">        Vector&lt;String&gt; values = new Vector&lt;&gt;(5);</span>

        if (debug) {
            System.err.println(&quot;ReadOIDList: pos=&quot;+pos[0]);
        }

<span class="nc" id="L622">        pos[0]++;</span>
<span class="nc" id="L623">        skipWhitespace(string, pos);</span>
<span class="nc" id="L624">        begin = pos[0];</span>
<span class="nc" id="L625">        end = string.indexOf(OID_LIST_END, begin);</span>
<span class="nc" id="L626">        cur = string.indexOf(OID_SEPARATOR, begin);</span>

<span class="nc bnc" id="L628" title="All 2 branches missed.">        if(end == -1) {</span>
<span class="nc" id="L629">            throw new InvalidAttributeValueException (&quot;oidlist has no end &quot;+</span>
                                                      &quot;mark: &quot; + string);
        }

<span class="nc bnc" id="L633" title="All 4 branches missed.">        if(cur == -1 || end &lt; cur) {</span>
<span class="nc" id="L634">            cur = end;</span>
        }

<span class="nc bnc" id="L637" title="All 4 branches missed.">        while(cur &lt; end &amp;&amp; cur &gt; 0) {</span>
<span class="nc" id="L638">            int wsBegin = findTrailingWhitespace(string, cur - 1);</span>
<span class="nc" id="L639">            oidName = string.substring(begin, wsBegin);</span>
            if (debug) {
                System.err.println(&quot;ReadOIDList: found '&quot; + oidName +
                                   &quot;' at begin=&quot; + begin + &quot; end =&quot; + end);
            }
<span class="nc" id="L644">            values.addElement(oidName);</span>
<span class="nc" id="L645">            pos[0] = cur + 1;</span>
<span class="nc" id="L646">            skipWhitespace(string, pos);</span>
<span class="nc" id="L647">            begin = pos[0];</span>
<span class="nc" id="L648">            cur = string.indexOf(OID_SEPARATOR, begin);</span>
            if(debug) {System.err.println(&quot;ReadOIDList: begin = &quot; + begin);}
<span class="nc" id="L650">        }</span>

        if (debug) {
            System.err.println(&quot;ReadOIDList: found '&quot; + oidName +
                               &quot;' at begin=&quot; + begin + &quot; end =&quot; + end);
        }

<span class="nc" id="L657">        int wsBegin = findTrailingWhitespace(string, end - 1);</span>
<span class="nc" id="L658">        oidName = string.substring(begin, wsBegin);</span>
<span class="nc" id="L659">        values.addElement(oidName);</span>

<span class="nc" id="L661">        pos[0] = end+1;</span>

<span class="nc" id="L663">        String[] answer = new String[values.size()];</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">        for (int i = 0; i &lt; answer.length; i++) {</span>
<span class="nc" id="L665">            answer[i] = values.elementAt(i);</span>
        }
<span class="nc" id="L667">        return answer;</span>
    }

// ----------------- &quot;unparser&quot; methods
// Methods that are used for translating a node in the schema tree
// into RFC2252 format for storage back into the LDAP directory
/*
     static Attributes JNDI2LDAPSchema(DirContext schemaRoot)
        throws NamingException {

        Attribute objDescAttr = new BasicAttribute(OBJECTCLASSDESC_ATTR_ID);
        Attribute attrDescAttr = new BasicAttribute(ATTRIBUTEDESC_ATTR_ID);
        Attribute syntaxDescAttr = new BasicAttribute(SYNTAXDESC_ATTR_ID);
        Attributes attrs = new BasicAttributes(LdapClient.caseIgnore);
        DirContext classDefs, attributeDefs, syntaxDefs;
        Attributes classDefsAttrs, attributeDefsAttrs, syntaxDefsAttrs;
        NamingEnumeration defs;
        Object obj;
        int i = 0;

        try {
            obj = schemaRoot.lookup(OBJECTCLASS_DEFINITION_NAME);
            if(obj != null &amp;&amp; obj instanceof DirContext) {
                classDefs = (DirContext)obj;
                defs = classDefs.listBindings(&quot;&quot;);
                while(defs.hasMoreElements()) {
                    i++;
                    DirContext classDef = (DirContext)
                        ((Binding)(defs.next())).getObject();
                    classDefAttrs = classDef.getAttributes(&quot;&quot;);
                    objDescAttr.add(classDef2ObjectDesc(classDefAttrs));
                }
                if (debug)
                    System.err.println(i + &quot; total object classes&quot;);
                attrs.put(objDescAttr);
            } else {
                throw new NamingException(
                    &quot;Problem with Schema tree: the object named &quot; +
                    OBJECTCLASS_DEFINITION_NAME + &quot; is not a &quot; +
                    &quot;DirContext&quot;);
            }
        } catch (NameNotFoundException e) {} // ignore

        i=0;
        try {
            obj = schemaRoot.lookup(ATTRIBUTE_DEFINITION_NAME);
            if(obj instanceof DirContext) {
                attributeDefs = (DirContext)obj;
                defs = attributeDefs.listBindings(&quot;&quot;);
                while(defs.hasMoreElements()) {
                    i++;
                    DirContext attrDef = (DirContext)
                        ((Binding)defs.next()).getObject();
                    attrDefAttrs = attrDef.getAttributes(&quot;&quot;);
                    attrDescAttr.add(attrDef2AttrDesc(attrDefAttrs));
                }
                if (debug)
                    System.err.println(i + &quot; attribute definitions&quot;);
                attrs.put(attrDescAttr);
            } else {
                throw new NamingException(
                    &quot;Problem with schema tree: the object named &quot; +
                    ATTRIBUTE_DEFINITION_NAME + &quot; is not a &quot; +
                    &quot;DirContext&quot;);
            }
        } catch (NameNotFoundException e) {} // ignore

        i=0;
        try {
            obj = schemaRoot.lookup(SYNTAX_DEFINITION_NAME);
            if(obj instanceof DirContext) {
                syntaxDefs = (DirContext)obj;
                defs =syntaxDefs.listBindings(&quot;&quot;);
                while(defs.hasMoreElements()) {
                    i++;
                    DirContext syntaxDef = (DirContext)
                        ((Binding)defs.next()).getObject();
                    syntaxDefAttrs = syntaxDef.getAttributes(&quot;&quot;);
                    syntaxDescAttr.add(syntaxDef2SyntaxDesc(syntaxDefAttrs));
                }
                if (debug)
                    System.err.println(i + &quot; total syntax definitions&quot;);
                attrs.put(syntaxDescAttr);
            } else {
                throw new NamingException(
                    &quot;Problem with schema tree: the object named &quot; +
                    SYNTAX_DEFINITION_NAME + &quot; is not a &quot; +
                    &quot;DirContext&quot;);
            }
        } catch (NameNotFoundException e) {} // ignore

        return attrs;
    }

*/

    /**
      * Translate attributes that describe an object class into the
      * string description as defined in RFC 2252.
      */
    final private String classDef2ObjectDesc(Attributes attrs)
        throws NamingException {

<span class="nc" id="L770">        StringBuffer objectDesc = new StringBuffer(&quot;( &quot;);</span>

<span class="nc" id="L772">        Attribute attr = null;</span>
<span class="nc" id="L773">        int count = 0;</span>

        // extract attributes by ID to guarantee ordering

<span class="nc" id="L777">        attr = attrs.get(NUMERICOID_ID);</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L779">            objectDesc.append(writeNumericOID(attr));</span>
<span class="nc" id="L780">            count++;</span>
        } else {
<span class="nc" id="L782">            throw new ConfigurationException(&quot;Class definition doesn't&quot; +</span>
                                             &quot;have a numeric OID&quot;);
        }

<span class="nc" id="L786">        attr = attrs.get(NAME_ID);</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L788">            objectDesc.append(writeQDescrs(attr));</span>
<span class="nc" id="L789">            count++;</span>
        }

<span class="nc" id="L792">        attr = attrs.get(DESC_ID);</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L794">            objectDesc.append(writeQDString(attr));</span>
<span class="nc" id="L795">            count++;</span>
        }

<span class="nc" id="L798">        attr = attrs.get(OBSOLETE_ID);</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L800">            objectDesc.append(writeBoolean(attr));</span>
<span class="nc" id="L801">            count++;</span>
        }

<span class="nc" id="L804">        attr = attrs.get(SUP_ID);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L806">            objectDesc.append(writeOIDs(attr));</span>
<span class="nc" id="L807">            count++;</span>
        }

<span class="nc" id="L810">        attr = attrs.get(ABSTRACT_ID);</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L812">            objectDesc.append(writeBoolean(attr));</span>
<span class="nc" id="L813">            count++;</span>
        }

<span class="nc" id="L816">        attr = attrs.get(STRUCTURAL_ID);</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L818">            objectDesc.append(writeBoolean(attr));</span>
<span class="nc" id="L819">            count++;</span>
        }

<span class="nc" id="L822">        attr = attrs.get(AUXILARY_ID);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L824">            objectDesc.append(writeBoolean(attr));</span>
<span class="nc" id="L825">            count++;</span>
        }

<span class="nc" id="L828">        attr = attrs.get(MUST_ID);</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L830">            objectDesc.append(writeOIDs(attr));</span>
<span class="nc" id="L831">            count++;</span>
        }

<span class="nc" id="L834">        attr = attrs.get(MAY_ID);</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L836">            objectDesc.append(writeOIDs(attr));</span>
<span class="nc" id="L837">            count++;</span>
        }

        // process any remaining attributes
<span class="nc bnc" id="L841" title="All 2 branches missed.">        if (count &lt; attrs.size()) {</span>
<span class="nc" id="L842">            String attrId = null;</span>

            // use enumeration because attribute ID is not known
<span class="nc" id="L845">            for (NamingEnumeration&lt;? extends Attribute&gt; ae = attrs.getAll();</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">                ae.hasMoreElements(); ) {</span>

<span class="nc" id="L848">                attr = ae.next();</span>
<span class="nc" id="L849">                attrId = attr.getID();</span>

                // skip those already processed
<span class="nc bnc" id="L852" title="All 2 branches missed.">                if (attrId.equals(NUMERICOID_ID) ||</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">                    attrId.equals(NAME_ID) ||</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">                    attrId.equals(SUP_ID) ||</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">                    attrId.equals(MAY_ID) ||</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">                    attrId.equals(MUST_ID) ||</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">                    attrId.equals(STRUCTURAL_ID) ||</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">                    attrId.equals(DESC_ID) ||</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">                    attrId.equals(AUXILARY_ID) ||</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">                    attrId.equals(ABSTRACT_ID) ||</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">                    attrId.equals(OBSOLETE_ID)) {</span>
<span class="nc" id="L862">                    continue;</span>

                } else {
<span class="nc" id="L865">                    objectDesc.append(writeQDStrings(attr));</span>
                }
            }
        }

<span class="nc" id="L870">        objectDesc.append(&quot;)&quot;);</span>

<span class="nc" id="L872">        return objectDesc.toString();</span>
    }

    /**
      * Translate attributes that describe an attribute definition into the
      * string description as defined in RFC 2252.
      */
    final private String attrDef2AttrDesc(Attributes attrs)
        throws NamingException {

<span class="nc" id="L882">        StringBuffer attrDesc = new StringBuffer(&quot;( &quot;); // opening parens</span>

<span class="nc" id="L884">        Attribute attr = null;</span>
<span class="nc" id="L885">        int count = 0;</span>

        // extract attributes by ID to guarantee ordering

<span class="nc" id="L889">        attr = attrs.get(NUMERICOID_ID);</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L891">            attrDesc.append(writeNumericOID(attr));</span>
<span class="nc" id="L892">            count++;</span>
        } else {
<span class="nc" id="L894">            throw new ConfigurationException(&quot;Attribute type doesn't&quot; +</span>
                                             &quot;have a numeric OID&quot;);
        }

<span class="nc" id="L898">        attr = attrs.get(NAME_ID);</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L900">            attrDesc.append(writeQDescrs(attr));</span>
<span class="nc" id="L901">            count++;</span>
        }

<span class="nc" id="L904">        attr = attrs.get(DESC_ID);</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L906">            attrDesc.append(writeQDString(attr));</span>
<span class="nc" id="L907">            count++;</span>
        }

<span class="nc" id="L910">        attr = attrs.get(OBSOLETE_ID);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L912">            attrDesc.append(writeBoolean(attr));</span>
<span class="nc" id="L913">            count++;</span>
        }

<span class="nc" id="L916">        attr = attrs.get(SUP_ID);</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L918">            attrDesc.append(writeWOID(attr));</span>
<span class="nc" id="L919">            count++;</span>
        }

<span class="nc" id="L922">        attr = attrs.get(EQUALITY_ID);</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L924">            attrDesc.append(writeWOID(attr));</span>
<span class="nc" id="L925">            count++;</span>
        }

<span class="nc" id="L928">        attr = attrs.get(ORDERING_ID);</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L930">            attrDesc.append(writeWOID(attr));</span>
<span class="nc" id="L931">            count++;</span>
        }

<span class="nc" id="L934">        attr = attrs.get(SUBSTR_ID);</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L936">            attrDesc.append(writeWOID(attr));</span>
<span class="nc" id="L937">            count++;</span>
        }

<span class="nc" id="L940">        attr = attrs.get(SYNTAX_ID);</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L942">            attrDesc.append(writeWOID(attr));</span>
<span class="nc" id="L943">            count++;</span>
        }

<span class="nc" id="L946">        attr = attrs.get(SINGLE_VAL_ID);</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L948">            attrDesc.append(writeBoolean(attr));</span>
<span class="nc" id="L949">            count++;</span>
        }

<span class="nc" id="L952">        attr = attrs.get(COLLECTIVE_ID);</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L954">            attrDesc.append(writeBoolean(attr));</span>
<span class="nc" id="L955">            count++;</span>
        }

<span class="nc" id="L958">        attr = attrs.get(NO_USER_MOD_ID);</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L960">            attrDesc.append(writeBoolean(attr));</span>
<span class="nc" id="L961">            count++;</span>
        }

<span class="nc" id="L964">        attr = attrs.get(USAGE_ID);</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L966">            attrDesc.append(writeQDString(attr));</span>
<span class="nc" id="L967">            count++;</span>
        }

        // process any remaining attributes
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (count &lt; attrs.size()) {</span>
<span class="nc" id="L972">            String attrId = null;</span>

            // use enumeration because attribute ID is not known
<span class="nc" id="L975">            for (NamingEnumeration&lt;? extends Attribute&gt; ae = attrs.getAll();</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">                ae.hasMoreElements(); ) {</span>

<span class="nc" id="L978">                attr = ae.next();</span>
<span class="nc" id="L979">                attrId = attr.getID();</span>

                // skip those already processed
<span class="nc bnc" id="L982" title="All 2 branches missed.">                if (attrId.equals(NUMERICOID_ID) ||</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">                    attrId.equals(NAME_ID) ||</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">                    attrId.equals(SYNTAX_ID) ||</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">                    attrId.equals(DESC_ID) ||</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">                    attrId.equals(SINGLE_VAL_ID) ||</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">                    attrId.equals(EQUALITY_ID) ||</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">                    attrId.equals(ORDERING_ID) ||</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">                    attrId.equals(SUBSTR_ID) ||</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">                    attrId.equals(NO_USER_MOD_ID) ||</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">                    attrId.equals(USAGE_ID) ||</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">                    attrId.equals(SUP_ID) ||</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">                    attrId.equals(COLLECTIVE_ID) ||</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">                    attrId.equals(OBSOLETE_ID)) {</span>
<span class="nc" id="L995">                    continue;</span>

                } else {
<span class="nc" id="L998">                    attrDesc.append(writeQDStrings(attr));</span>
                }
            }
        }

<span class="nc" id="L1003">        attrDesc.append(&quot;)&quot;);  // add closing parens</span>

<span class="nc" id="L1005">        return attrDesc.toString();</span>
    }

    /**
      * Translate attributes that describe an attribute syntax definition into the
      * string description as defined in RFC 2252.
      */
    final private String syntaxDef2SyntaxDesc(Attributes attrs)
        throws NamingException {

<span class="nc" id="L1015">        StringBuffer syntaxDesc = new StringBuffer(&quot;( &quot;); // opening parens</span>

<span class="nc" id="L1017">        Attribute attr = null;</span>
<span class="nc" id="L1018">        int count = 0;</span>

        // extract attributes by ID to guarantee ordering

<span class="nc" id="L1022">        attr = attrs.get(NUMERICOID_ID);</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L1024">            syntaxDesc.append(writeNumericOID(attr));</span>
<span class="nc" id="L1025">            count++;</span>
        } else {
<span class="nc" id="L1027">            throw new ConfigurationException(&quot;Attribute type doesn't&quot; +</span>
                                             &quot;have a numeric OID&quot;);
        }

<span class="nc" id="L1031">        attr = attrs.get(DESC_ID);</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L1033">            syntaxDesc.append(writeQDString(attr));</span>
<span class="nc" id="L1034">            count++;</span>
        }

        // process any remaining attributes
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        if (count &lt; attrs.size()) {</span>
<span class="nc" id="L1039">            String attrId = null;</span>

            // use enumeration because attribute ID is not known
<span class="nc" id="L1042">            for (NamingEnumeration&lt;? extends Attribute&gt; ae = attrs.getAll();</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">                ae.hasMoreElements(); ) {</span>

<span class="nc" id="L1045">                attr = ae.next();</span>
<span class="nc" id="L1046">                attrId = attr.getID();</span>

                // skip those already processed
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                if (attrId.equals(NUMERICOID_ID) ||</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">                    attrId.equals(DESC_ID)) {</span>
<span class="nc" id="L1051">                    continue;</span>

                } else {
<span class="nc" id="L1054">                    syntaxDesc.append(writeQDStrings(attr));</span>
                }
            }
        }

<span class="nc" id="L1059">        syntaxDesc.append(&quot;)&quot;);</span>

<span class="nc" id="L1061">        return syntaxDesc.toString();</span>
    }

    /**
      * Translate attributes that describe an attribute matching rule
      * definition into the string description as defined in RFC 2252.
      */
    final private String matchRuleDef2MatchRuleDesc(Attributes attrs)
        throws NamingException {

<span class="nc" id="L1071">        StringBuffer matchRuleDesc = new StringBuffer(&quot;( &quot;); // opening parens</span>

<span class="nc" id="L1073">        Attribute attr = null;</span>
<span class="nc" id="L1074">        int count = 0;</span>

        // extract attributes by ID to guarantee ordering

<span class="nc" id="L1078">        attr = attrs.get(NUMERICOID_ID);</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L1080">            matchRuleDesc.append(writeNumericOID(attr));</span>
<span class="nc" id="L1081">            count++;</span>
        } else {
<span class="nc" id="L1083">            throw new ConfigurationException(&quot;Attribute type doesn't&quot; +</span>
                                             &quot;have a numeric OID&quot;);
        }

<span class="nc" id="L1087">        attr = attrs.get(NAME_ID);</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L1089">            matchRuleDesc.append(writeQDescrs(attr));</span>
<span class="nc" id="L1090">            count++;</span>
        }

<span class="nc" id="L1093">        attr = attrs.get(DESC_ID);</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L1095">            matchRuleDesc.append(writeQDString(attr));</span>
<span class="nc" id="L1096">            count++;</span>
        }

<span class="nc" id="L1099">        attr = attrs.get(OBSOLETE_ID);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L1101">            matchRuleDesc.append(writeBoolean(attr));</span>
<span class="nc" id="L1102">            count++;</span>
        }

<span class="nc" id="L1105">        attr = attrs.get(SYNTAX_ID);</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L1107">            matchRuleDesc.append(writeWOID(attr));</span>
<span class="nc" id="L1108">            count++;</span>
        } else {
<span class="nc" id="L1110">            throw new ConfigurationException(&quot;Attribute type doesn't&quot; +</span>
                                             &quot;have a syntax OID&quot;);
        }

        // process any remaining attributes
<span class="nc bnc" id="L1115" title="All 2 branches missed.">        if (count &lt; attrs.size()) {</span>
<span class="nc" id="L1116">            String attrId = null;</span>

            // use enumeration because attribute ID is not known
<span class="nc" id="L1119">            for (NamingEnumeration&lt;? extends Attribute&gt; ae = attrs.getAll();</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                ae.hasMoreElements(); ) {</span>

<span class="nc" id="L1122">                attr = ae.next();</span>
<span class="nc" id="L1123">                attrId = attr.getID();</span>

                // skip those already processed
<span class="nc bnc" id="L1126" title="All 2 branches missed.">                if (attrId.equals(NUMERICOID_ID) ||</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">                    attrId.equals(NAME_ID) ||</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">                    attrId.equals(SYNTAX_ID) ||</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">                    attrId.equals(DESC_ID) ||</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">                    attrId.equals(OBSOLETE_ID)) {</span>
<span class="nc" id="L1131">                    continue;</span>

                } else {
<span class="nc" id="L1134">                    matchRuleDesc.append(writeQDStrings(attr));</span>
                }
            }
        }

<span class="nc" id="L1139">        matchRuleDesc.append(&quot;)&quot;);</span>

<span class="nc" id="L1141">        return matchRuleDesc.toString();</span>
    }

    final private String writeNumericOID(Attribute nOIDAttr)
        throws NamingException {
<span class="nc bnc" id="L1146" title="All 2 branches missed.">        if(nOIDAttr.size() != 1) {</span>
<span class="nc" id="L1147">            throw new InvalidAttributeValueException(</span>
                &quot;A class definition must have exactly one numeric OID&quot;);
        }
<span class="nc" id="L1150">        return (String)(nOIDAttr.get()) + WHSP;</span>
    }

    final private String writeWOID(Attribute attr) throws NamingException {
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if (netscapeBug)</span>
<span class="nc" id="L1155">            return writeQDString(attr);</span>
        else
<span class="nc" id="L1157">            return attr.getID() + WHSP + attr.get() + WHSP;</span>
    }

    /*  qdescr          = whsp &quot;'&quot; descr &quot;'&quot; whsp */
    final private String writeQDString(Attribute qdStringAttr)
        throws NamingException {
<span class="nc bnc" id="L1163" title="All 2 branches missed.">        if(qdStringAttr.size() != 1) {</span>
<span class="nc" id="L1164">            throw new InvalidAttributeValueException(</span>
<span class="nc" id="L1165">                qdStringAttr.getID() + &quot; must have exactly one value&quot;);</span>
        }

<span class="nc" id="L1168">        return qdStringAttr.getID() + WHSP +</span>
<span class="nc" id="L1169">            SINGLE_QUOTE + qdStringAttr.get() + SINGLE_QUOTE + WHSP;</span>
    }

   /**
    * dstring         = 1*utf8
    * qdstring        = whsp &quot;'&quot; dstring &quot;'&quot; whsp
    * qdstringlist    = [ qdstring *( qdstring ) ]
    * qdstrings       = qdstring / ( whsp &quot;(&quot; qdstringlist &quot;)&quot; whsp )
    */
    private final String writeQDStrings(Attribute attr) throws NamingException {
<span class="nc" id="L1179">        return writeQDescrs(attr);</span>
    }

    /**
     * qdescrs         = qdescr / ( whsp &quot;(&quot; qdescrlist &quot;)&quot; whsp )
     * qdescrlist      = [ qdescr *( qdescr ) ]
     * qdescr          = whsp &quot;'&quot; descr &quot;'&quot; whsp
     * descr           = keystring
     */
    private final String writeQDescrs(Attribute attr) throws NamingException {
<span class="nc bnc" id="L1189" title="All 3 branches missed.">        switch(attr.size()) {</span>
        case 0:
<span class="nc" id="L1191">            throw new InvalidAttributeValueException(</span>
<span class="nc" id="L1192">                attr.getID() + &quot;has no values&quot;);</span>
        case 1:
<span class="nc" id="L1194">            return writeQDString(attr);</span>
        }

        // write QDList

<span class="nc" id="L1199">        StringBuffer qdList = new StringBuffer(attr.getID());</span>
<span class="nc" id="L1200">        qdList.append(WHSP);</span>
<span class="nc" id="L1201">        qdList.append(OID_LIST_BEGIN);</span>

<span class="nc" id="L1203">        NamingEnumeration&lt;?&gt; values = attr.getAll();</span>

<span class="nc bnc" id="L1205" title="All 2 branches missed.">        while(values.hasMore()) {</span>
<span class="nc" id="L1206">            qdList.append(WHSP);</span>
<span class="nc" id="L1207">            qdList.append(SINGLE_QUOTE);</span>
<span class="nc" id="L1208">            qdList.append((String)values.next());</span>
<span class="nc" id="L1209">            qdList.append(SINGLE_QUOTE);</span>
<span class="nc" id="L1210">            qdList.append(WHSP);</span>
        }

<span class="nc" id="L1213">        qdList.append(OID_LIST_END);</span>
<span class="nc" id="L1214">        qdList.append(WHSP);</span>

<span class="nc" id="L1216">        return qdList.toString();</span>
    }

    final private String writeOIDs(Attribute oidsAttr)
        throws NamingException {

<span class="nc bnc" id="L1222" title="All 3 branches missed.">        switch(oidsAttr.size()) {</span>
        case 0:
<span class="nc" id="L1224">            throw new InvalidAttributeValueException(</span>
<span class="nc" id="L1225">                oidsAttr.getID() + &quot;has no values&quot;);</span>

        case 1:
<span class="nc bnc" id="L1228" title="All 2 branches missed.">            if (netscapeBug) {</span>
<span class="nc" id="L1229">                break; // %%% write out as list to avoid crashing server</span>
            }
<span class="nc" id="L1231">            return writeWOID(oidsAttr);</span>
        }

        // write OID List

<span class="nc" id="L1236">        StringBuffer oidList = new StringBuffer(oidsAttr.getID());</span>
<span class="nc" id="L1237">        oidList.append(WHSP);</span>
<span class="nc" id="L1238">        oidList.append(OID_LIST_BEGIN);</span>

<span class="nc" id="L1240">        NamingEnumeration&lt;?&gt; values = oidsAttr.getAll();</span>
<span class="nc" id="L1241">        oidList.append(WHSP);</span>
<span class="nc" id="L1242">        oidList.append(values.next());</span>

<span class="nc bnc" id="L1244" title="All 2 branches missed.">        while(values.hasMore()) {</span>
<span class="nc" id="L1245">            oidList.append(WHSP);</span>
<span class="nc" id="L1246">            oidList.append(OID_SEPARATOR);</span>
<span class="nc" id="L1247">            oidList.append(WHSP);</span>
<span class="nc" id="L1248">            oidList.append((String)values.next());</span>
        }

<span class="nc" id="L1251">        oidList.append(WHSP);</span>
<span class="nc" id="L1252">        oidList.append(OID_LIST_END);</span>
<span class="nc" id="L1253">        oidList.append(WHSP);</span>

<span class="nc" id="L1255">        return oidList.toString();</span>
    }

    private final String writeBoolean(Attribute booleanAttr)
        throws NamingException {
<span class="nc" id="L1260">            return booleanAttr.getID() + WHSP;</span>
    }

    /**
     * Returns an attribute for updating the Object Class Definition schema
     * attribute
     */
    final Attribute stringifyObjDesc(Attributes classDefAttrs)
        throws NamingException {
<span class="nc" id="L1269">        Attribute objDescAttr = new BasicAttribute(OBJECTCLASSDESC_ATTR_ID);</span>
<span class="nc" id="L1270">        objDescAttr.add(classDef2ObjectDesc(classDefAttrs));</span>
<span class="nc" id="L1271">        return objDescAttr;</span>
    }

    /**
     * Returns an attribute for updating the Attribute Definition schema attribute
     */
    final Attribute stringifyAttrDesc(Attributes attrDefAttrs)
        throws NamingException {
<span class="nc" id="L1279">        Attribute attrDescAttr = new BasicAttribute(ATTRIBUTEDESC_ATTR_ID);</span>
<span class="nc" id="L1280">        attrDescAttr.add(attrDef2AttrDesc(attrDefAttrs));</span>
<span class="nc" id="L1281">        return attrDescAttr;</span>
    }

    /**
     * Returns an attribute for updating the Syntax schema attribute
     */
    final Attribute stringifySyntaxDesc(Attributes syntaxDefAttrs)
    throws NamingException {
<span class="nc" id="L1289">        Attribute syntaxDescAttr = new BasicAttribute(SYNTAXDESC_ATTR_ID);</span>
<span class="nc" id="L1290">        syntaxDescAttr.add(syntaxDef2SyntaxDesc(syntaxDefAttrs));</span>
<span class="nc" id="L1291">        return syntaxDescAttr;</span>
    }

    /**
     * Returns an attribute for updating the Matching Rule schema attribute
     */
    final Attribute stringifyMatchRuleDesc(Attributes matchRuleDefAttrs)
    throws NamingException {
<span class="nc" id="L1299">        Attribute matchRuleDescAttr = new BasicAttribute(MATCHRULEDESC_ATTR_ID);</span>
<span class="nc" id="L1300">        matchRuleDescAttr.add(matchRuleDef2MatchRuleDesc(matchRuleDefAttrs));</span>
<span class="nc" id="L1301">        return matchRuleDescAttr;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>