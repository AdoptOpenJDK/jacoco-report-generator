<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BigDecimal.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.math</a> &gt; <span class="el_source">BigDecimal.java</span></div><h1>BigDecimal.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * Portions Copyright IBM Corporation, 2001. All Rights Reserved.
 */

package java.math;

import java.util.Arrays;
import static java.math.BigInteger.LONG_MASK;

/**
 * Immutable, arbitrary-precision signed decimal numbers.  A
 * {@code BigDecimal} consists of an arbitrary precision integer
 * &lt;i&gt;unscaled value&lt;/i&gt; and a 32-bit integer &lt;i&gt;scale&lt;/i&gt;.  If zero
 * or positive, the scale is the number of digits to the right of the
 * decimal point.  If negative, the unscaled value of the number is
 * multiplied by ten to the power of the negation of the scale.  The
 * value of the number represented by the {@code BigDecimal} is
 * therefore &lt;tt&gt;(unscaledValue &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/tt&gt;.
 *
 * &lt;p&gt;The {@code BigDecimal} class provides operations for
 * arithmetic, scale manipulation, rounding, comparison, hashing, and
 * format conversion.  The {@link #toString} method provides a
 * canonical representation of a {@code BigDecimal}.
 *
 * &lt;p&gt;The {@code BigDecimal} class gives its user complete control
 * over rounding behavior.  If no rounding mode is specified and the
 * exact result cannot be represented, an exception is thrown;
 * otherwise, calculations can be carried out to a chosen precision
 * and rounding mode by supplying an appropriate {@link MathContext}
 * object to the operation.  In either case, eight &lt;em&gt;rounding
 * modes&lt;/em&gt; are provided for the control of rounding.  Using the
 * integer fields in this class (such as {@link #ROUND_HALF_UP}) to
 * represent rounding mode is largely obsolete; the enumeration values
 * of the {@code RoundingMode} {@code enum}, (such as {@link
 * RoundingMode#HALF_UP}) should be used instead.
 *
 * &lt;p&gt;When a {@code MathContext} object is supplied with a precision
 * setting of 0 (for example, {@link MathContext#UNLIMITED}),
 * arithmetic operations are exact, as are the arithmetic methods
 * which take no {@code MathContext} object.  (This is the only
 * behavior that was supported in releases prior to 5.)  As a
 * corollary of computing the exact result, the rounding mode setting
 * of a {@code MathContext} object with a precision setting of 0 is
 * not used and thus irrelevant.  In the case of divide, the exact
 * quotient could have an infinitely long decimal expansion; for
 * example, 1 divided by 3.  If the quotient has a nonterminating
 * decimal expansion and the operation is specified to return an exact
 * result, an {@code ArithmeticException} is thrown.  Otherwise, the
 * exact result of the division is returned, as done for other
 * operations.
 *
 * &lt;p&gt;When the precision setting is not 0, the rules of
 * {@code BigDecimal} arithmetic are broadly compatible with selected
 * modes of operation of the arithmetic defined in ANSI X3.274-1996
 * and ANSI X3.274-1996/AM 1-2000 (section 7.4).  Unlike those
 * standards, {@code BigDecimal} includes many rounding modes, which
 * were mandatory for division in {@code BigDecimal} releases prior
 * to 5.  Any conflicts between these ANSI standards and the
 * {@code BigDecimal} specification are resolved in favor of
 * {@code BigDecimal}.
 *
 * &lt;p&gt;Since the same numerical value can have different
 * representations (with different scales), the rules of arithmetic
 * and rounding must specify both the numerical result and the scale
 * used in the result's representation.
 *
 *
 * &lt;p&gt;In general the rounding modes and precision setting determine
 * how operations return results with a limited number of digits when
 * the exact result has more digits (perhaps infinitely many in the
 * case of division) than the number of digits returned.
 *
 * First, the
 * total number of digits to return is specified by the
 * {@code MathContext}'s {@code precision} setting; this determines
 * the result's &lt;i&gt;precision&lt;/i&gt;.  The digit count starts from the
 * leftmost nonzero digit of the exact result.  The rounding mode
 * determines how any discarded trailing digits affect the returned
 * result.
 *
 * &lt;p&gt;For all arithmetic operators , the operation is carried out as
 * though an exact intermediate result were first calculated and then
 * rounded to the number of digits specified by the precision setting
 * (if necessary), using the selected rounding mode.  If the exact
 * result is not returned, some digit positions of the exact result
 * are discarded.  When rounding increases the magnitude of the
 * returned result, it is possible for a new digit position to be
 * created by a carry propagating to a leading {@literal &quot;9&quot;} digit.
 * For example, rounding the value 999.9 to three digits rounding up
 * would be numerically equal to one thousand, represented as
 * 100&amp;times;10&lt;sup&gt;1&lt;/sup&gt;.  In such cases, the new {@literal &quot;1&quot;} is
 * the leading digit position of the returned result.
 *
 * &lt;p&gt;Besides a logical exact result, each arithmetic operation has a
 * preferred scale for representing a result.  The preferred
 * scale for each operation is listed in the table below.
 *
 * &lt;table border&gt;
 * &lt;caption&gt;&lt;b&gt;Preferred Scales for Results of Arithmetic Operations
 * &lt;/b&gt;&lt;/caption&gt;
 * &lt;tr&gt;&lt;th&gt;Operation&lt;/th&gt;&lt;th&gt;Preferred Scale of Result&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;Add&lt;/td&gt;&lt;td&gt;max(addend.scale(), augend.scale())&lt;/td&gt;
 * &lt;tr&gt;&lt;td&gt;Subtract&lt;/td&gt;&lt;td&gt;max(minuend.scale(), subtrahend.scale())&lt;/td&gt;
 * &lt;tr&gt;&lt;td&gt;Multiply&lt;/td&gt;&lt;td&gt;multiplier.scale() + multiplicand.scale()&lt;/td&gt;
 * &lt;tr&gt;&lt;td&gt;Divide&lt;/td&gt;&lt;td&gt;dividend.scale() - divisor.scale()&lt;/td&gt;
 * &lt;/table&gt;
 *
 * These scales are the ones used by the methods which return exact
 * arithmetic results; except that an exact divide may have to use a
 * larger scale since the exact result may have more digits.  For
 * example, {@code 1/32} is {@code 0.03125}.
 *
 * &lt;p&gt;Before rounding, the scale of the logical exact intermediate
 * result is the preferred scale for that operation.  If the exact
 * numerical result cannot be represented in {@code precision}
 * digits, rounding selects the set of digits to return and the scale
 * of the result is reduced from the scale of the intermediate result
 * to the least scale which can represent the {@code precision}
 * digits actually returned.  If the exact result can be represented
 * with at most {@code precision} digits, the representation
 * of the result with the scale closest to the preferred scale is
 * returned.  In particular, an exactly representable quotient may be
 * represented in fewer than {@code precision} digits by removing
 * trailing zeros and decreasing the scale.  For example, rounding to
 * three digits using the {@linkplain RoundingMode#FLOOR floor}
 * rounding mode, &lt;br&gt;
 *
 * {@code 19/100 = 0.19   // integer=19,  scale=2} &lt;br&gt;
 *
 * but&lt;br&gt;
 *
 * {@code 21/110 = 0.190  // integer=190, scale=3} &lt;br&gt;
 *
 * &lt;p&gt;Note that for add, subtract, and multiply, the reduction in
 * scale will equal the number of digit positions of the exact result
 * which are discarded. If the rounding causes a carry propagation to
 * create a new high-order digit position, an additional digit of the
 * result is discarded than when no new digit position is created.
 *
 * &lt;p&gt;Other methods may have slightly different rounding semantics.
 * For example, the result of the {@code pow} method using the
 * {@linkplain #pow(int, MathContext) specified algorithm} can
 * occasionally differ from the rounded mathematical result by more
 * than one unit in the last place, one &lt;i&gt;{@linkplain #ulp() ulp}&lt;/i&gt;.
 *
 * &lt;p&gt;Two types of operations are provided for manipulating the scale
 * of a {@code BigDecimal}: scaling/rounding operations and decimal
 * point motion operations.  Scaling/rounding operations ({@link
 * #setScale setScale} and {@link #round round}) return a
 * {@code BigDecimal} whose value is approximately (or exactly) equal
 * to that of the operand, but whose scale or precision is the
 * specified value; that is, they increase or decrease the precision
 * of the stored number with minimal effect on its value.  Decimal
 * point motion operations ({@link #movePointLeft movePointLeft} and
 * {@link #movePointRight movePointRight}) return a
 * {@code BigDecimal} created from the operand by moving the decimal
 * point a specified distance in the specified direction.
 *
 * &lt;p&gt;For the sake of brevity and clarity, pseudo-code is used
 * throughout the descriptions of {@code BigDecimal} methods.  The
 * pseudo-code expression {@code (i + j)} is shorthand for &quot;a
 * {@code BigDecimal} whose value is that of the {@code BigDecimal}
 * {@code i} added to that of the {@code BigDecimal}
 * {@code j}.&quot; The pseudo-code expression {@code (i == j)} is
 * shorthand for &quot;{@code true} if and only if the
 * {@code BigDecimal} {@code i} represents the same value as the
 * {@code BigDecimal} {@code j}.&quot; Other pseudo-code expressions
 * are interpreted similarly.  Square brackets are used to represent
 * the particular {@code BigInteger} and scale pair defining a
 * {@code BigDecimal} value; for example [19, 2] is the
 * {@code BigDecimal} numerically equal to 0.19 having a scale of 2.
 *
 * &lt;p&gt;Note: care should be exercised if {@code BigDecimal} objects
 * are used as keys in a {@link java.util.SortedMap SortedMap} or
 * elements in a {@link java.util.SortedSet SortedSet} since
 * {@code BigDecimal}'s &lt;i&gt;natural ordering&lt;/i&gt; is &lt;i&gt;inconsistent
 * with equals&lt;/i&gt;.  See {@link Comparable}, {@link
 * java.util.SortedMap} or {@link java.util.SortedSet} for more
 * information.
 *
 * &lt;p&gt;All methods and constructors for this class throw
 * {@code NullPointerException} when passed a {@code null} object
 * reference for any input parameter.
 *
 * @see     BigInteger
 * @see     MathContext
 * @see     RoundingMode
 * @see     java.util.SortedMap
 * @see     java.util.SortedSet
 * @author  Josh Bloch
 * @author  Mike Cowlishaw
 * @author  Joseph D. Darcy
 * @author  Sergey V. Kuksenko
 */
<span class="fc bfc" id="L220" title="All 2 branches covered.">public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; {</span>
    /**
     * The unscaled value of this BigDecimal, as returned by {@link
     * #unscaledValue}.
     *
     * @serial
     * @see #unscaledValue
     */
    private final BigInteger intVal;

    /**
     * The scale of this BigDecimal, as returned by {@link #scale}.
     *
     * @serial
     * @see #scale
     */
    private final int scale;  // Note: this may have any value, so
                              // calculations must be done in longs

    /**
     * The number of decimal digits in this BigDecimal, or 0 if the
     * number of digits are not known (lookaside information).  If
     * nonzero, the value is guaranteed correct.  Use the precision()
     * method to obtain and set the value if it might be 0.  This
     * field is mutable until set nonzero.
     *
     * @since  1.5
     */
    private transient int precision;

    /**
     * Used to store the canonical string representation, if computed.
     */
    private transient String stringCache;

    /**
     * Sentinel value for {@link #intCompact} indicating the
     * significand information is only available from {@code intVal}.
     */
    static final long INFLATED = Long.MIN_VALUE;

<span class="fc" id="L261">    private static final BigInteger INFLATED_BIGINT = BigInteger.valueOf(INFLATED);</span>

    /**
     * If the absolute value of the significand of this BigDecimal is
     * less than or equal to {@code Long.MAX_VALUE}, the value can be
     * compactly stored in this field and used in computations.
     */
    private final transient long intCompact;

    // All 18-digit base ten strings fit into a long; not all 19-digit
    // strings will
    private static final int MAX_COMPACT_DIGITS = 18;

    /* Appease the serialization gods */
    private static final long serialVersionUID = 6108874887143696463L;

    private static final ThreadLocal&lt;StringBuilderHelper&gt;
<span class="fc" id="L278">        threadLocalStringBuilderHelper = new ThreadLocal&lt;StringBuilderHelper&gt;() {</span>
        @Override
        protected StringBuilderHelper initialValue() {
<span class="fc" id="L281">            return new StringBuilderHelper();</span>
        }
    };

    // Cache of common small BigDecimal values.
<span class="fc" id="L286">    private static final BigDecimal zeroThroughTen[] = {</span>
        new BigDecimal(BigInteger.ZERO,       0,  0, 1),
        new BigDecimal(BigInteger.ONE,        1,  0, 1),
<span class="fc" id="L289">        new BigDecimal(BigInteger.valueOf(2), 2,  0, 1),</span>
<span class="fc" id="L290">        new BigDecimal(BigInteger.valueOf(3), 3,  0, 1),</span>
<span class="fc" id="L291">        new BigDecimal(BigInteger.valueOf(4), 4,  0, 1),</span>
<span class="fc" id="L292">        new BigDecimal(BigInteger.valueOf(5), 5,  0, 1),</span>
<span class="fc" id="L293">        new BigDecimal(BigInteger.valueOf(6), 6,  0, 1),</span>
<span class="fc" id="L294">        new BigDecimal(BigInteger.valueOf(7), 7,  0, 1),</span>
<span class="fc" id="L295">        new BigDecimal(BigInteger.valueOf(8), 8,  0, 1),</span>
<span class="fc" id="L296">        new BigDecimal(BigInteger.valueOf(9), 9,  0, 1),</span>
        new BigDecimal(BigInteger.TEN,        10, 0, 2),
    };

    // Cache of zero scaled by 0 - 15
<span class="fc" id="L301">    private static final BigDecimal[] ZERO_SCALED_BY = {</span>
        zeroThroughTen[0],
        new BigDecimal(BigInteger.ZERO, 0, 1, 1),
        new BigDecimal(BigInteger.ZERO, 0, 2, 1),
        new BigDecimal(BigInteger.ZERO, 0, 3, 1),
        new BigDecimal(BigInteger.ZERO, 0, 4, 1),
        new BigDecimal(BigInteger.ZERO, 0, 5, 1),
        new BigDecimal(BigInteger.ZERO, 0, 6, 1),
        new BigDecimal(BigInteger.ZERO, 0, 7, 1),
        new BigDecimal(BigInteger.ZERO, 0, 8, 1),
        new BigDecimal(BigInteger.ZERO, 0, 9, 1),
        new BigDecimal(BigInteger.ZERO, 0, 10, 1),
        new BigDecimal(BigInteger.ZERO, 0, 11, 1),
        new BigDecimal(BigInteger.ZERO, 0, 12, 1),
        new BigDecimal(BigInteger.ZERO, 0, 13, 1),
        new BigDecimal(BigInteger.ZERO, 0, 14, 1),
        new BigDecimal(BigInteger.ZERO, 0, 15, 1),
    };

    // Half of Long.MIN_VALUE &amp; Long.MAX_VALUE.
    private static final long HALF_LONG_MAX_VALUE = Long.MAX_VALUE / 2;
    private static final long HALF_LONG_MIN_VALUE = Long.MIN_VALUE / 2;

    // Constants
    /**
     * The value 0, with a scale of 0.
     *
     * @since  1.5
     */
<span class="fc" id="L330">    public static final BigDecimal ZERO =</span>
        zeroThroughTen[0];

    /**
     * The value 1, with a scale of 0.
     *
     * @since  1.5
     */
<span class="fc" id="L338">    public static final BigDecimal ONE =</span>
        zeroThroughTen[1];

    /**
     * The value 10, with a scale of 0.
     *
     * @since  1.5
     */
<span class="fc" id="L346">    public static final BigDecimal TEN =</span>
        zeroThroughTen[10];

    // Constructors

    /**
     * Trusted package private constructor.
     * Trusted simply means if val is INFLATED, intVal could not be null and
     * if intVal is null, val could not be INFLATED.
     */
<span class="fc" id="L356">    BigDecimal(BigInteger intVal, long val, int scale, int prec) {</span>
<span class="fc" id="L357">        this.scale = scale;</span>
<span class="fc" id="L358">        this.precision = prec;</span>
<span class="fc" id="L359">        this.intCompact = val;</span>
<span class="fc" id="L360">        this.intVal = intVal;</span>
<span class="fc" id="L361">    }</span>

    /**
     * Translates a character array representation of a
     * {@code BigDecimal} into a {@code BigDecimal}, accepting the
     * same sequence of characters as the {@link #BigDecimal(String)}
     * constructor, while allowing a sub-array to be specified.
     *
     * &lt;p&gt;Note that if the sequence of characters is already available
     * within a character array, using this constructor is faster than
     * converting the {@code char} array to string and using the
     * {@code BigDecimal(String)} constructor .
     *
     * @param  in {@code char} array that is the source of characters.
     * @param  offset first character in the array to inspect.
     * @param  len number of characters to consider.
     * @throws NumberFormatException if {@code in} is not a valid
     *         representation of a {@code BigDecimal} or the defined subarray
     *         is not wholly within {@code in}.
     * @since  1.5
     */
    public BigDecimal(char[] in, int offset, int len) {
<span class="fc" id="L383">        this(in,offset,len,MathContext.UNLIMITED);</span>
<span class="fc" id="L384">    }</span>

    /**
     * Translates a character array representation of a
     * {@code BigDecimal} into a {@code BigDecimal}, accepting the
     * same sequence of characters as the {@link #BigDecimal(String)}
     * constructor, while allowing a sub-array to be specified and
     * with rounding according to the context settings.
     *
     * &lt;p&gt;Note that if the sequence of characters is already available
     * within a character array, using this constructor is faster than
     * converting the {@code char} array to string and using the
     * {@code BigDecimal(String)} constructor .
     *
     * @param  in {@code char} array that is the source of characters.
     * @param  offset first character in the array to inspect.
     * @param  len number of characters to consider..
     * @param  mc the context to use.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @throws NumberFormatException if {@code in} is not a valid
     *         representation of a {@code BigDecimal} or the defined subarray
     *         is not wholly within {@code in}.
     * @since  1.5
     */
<span class="fc" id="L409">    public BigDecimal(char[] in, int offset, int len, MathContext mc) {</span>
        // protect against huge length.
<span class="pc bpc" id="L411" title="2 of 4 branches missed.">        if (offset + len &gt; in.length || offset &lt; 0)</span>
<span class="nc" id="L412">            throw new NumberFormatException(&quot;Bad offset or len arguments for char[] input.&quot;);</span>
        // This is the primary string to BigDecimal constructor; all
        // incoming strings end up here; it uses explicit (inline)
        // parsing for speed and generates at most one intermediate
        // (temporary) object (a char[] array) for non-compact case.

        // Use locals for all fields values until completion
<span class="fc" id="L419">        int prec = 0;                 // record precision value</span>
<span class="fc" id="L420">        int scl = 0;                  // record scale value</span>
<span class="fc" id="L421">        long rs = 0;                  // the compact value in long</span>
<span class="fc" id="L422">        BigInteger rb = null;         // the inflated value in BigInteger</span>
        // use array bounds checking to handle too-long, len == 0,
        // bad offset, etc.
        try {
            // handle the sign
<span class="fc" id="L427">            boolean isneg = false;          // assume positive</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">            if (in[offset] == '-') {</span>
<span class="fc" id="L429">                isneg = true;               // leading minus means negative</span>
<span class="fc" id="L430">                offset++;</span>
<span class="fc" id="L431">                len--;</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">            } else if (in[offset] == '+') { // leading + allowed</span>
<span class="fc" id="L433">                offset++;</span>
<span class="fc" id="L434">                len--;</span>
            }

            // should now be at numeric part of the significand
<span class="fc" id="L438">            boolean dot = false;             // true when there is a '.'</span>
<span class="fc" id="L439">            long exp = 0;                    // exponent</span>
            char c;                          // current character
<span class="fc bfc" id="L441" title="All 2 branches covered.">            boolean isCompact = (len &lt;= MAX_COMPACT_DIGITS);</span>
            // integer significand array &amp; idx is the index to it. The array
            // is ONLY used when we can't use a compact representation.
<span class="fc" id="L444">            int idx = 0;</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">            if (isCompact) {</span>
                // First compact case, we need not to preserve the character
                // and we can just compute the value in place.
<span class="fc bfc" id="L448" title="All 2 branches covered.">                for (; len &gt; 0; offset++, len--) {</span>
<span class="fc" id="L449">                    c = in[offset];</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">                    if ((c == '0')) { // have zero</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">                        if (prec == 0)</span>
<span class="fc" id="L452">                            prec = 1;</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">                        else if (rs != 0) {</span>
<span class="fc" id="L454">                            rs *= 10;</span>
<span class="fc" id="L455">                            ++prec;</span>
                        } // else digit is a redundant leading zero
<span class="fc bfc" id="L457" title="All 2 branches covered.">                        if (dot)</span>
<span class="fc" id="L458">                            ++scl;</span>
<span class="fc bfc" id="L459" title="All 4 branches covered.">                    } else if ((c &gt;= '1' &amp;&amp; c &lt;= '9')) { // have digit</span>
<span class="fc" id="L460">                        int digit = c - '0';</span>
<span class="fc bfc" id="L461" title="All 4 branches covered.">                        if (prec != 1 || rs != 0)</span>
<span class="fc" id="L462">                            ++prec; // prec unchanged if preceded by 0s</span>
<span class="fc" id="L463">                        rs = rs * 10 + digit;</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">                        if (dot)</span>
<span class="fc" id="L465">                            ++scl;</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">                    } else if (c == '.') {   // have dot</span>
                        // have dot
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">                        if (dot) // two dots</span>
<span class="nc" id="L469">                            throw new NumberFormatException();</span>
<span class="fc" id="L470">                        dot = true;</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">                    } else if (Character.isDigit(c)) { // slow path</span>
<span class="fc" id="L472">                        int digit = Character.digit(c, 10);</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">                        if (digit == 0) {</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">                            if (prec == 0)</span>
<span class="fc" id="L475">                                prec = 1;</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">                            else if (rs != 0) {</span>
<span class="nc" id="L477">                                rs *= 10;</span>
<span class="nc" id="L478">                                ++prec;</span>
                            } // else digit is a redundant leading zero
                        } else {
<span class="nc bnc" id="L481" title="All 4 branches missed.">                            if (prec != 1 || rs != 0)</span>
<span class="nc" id="L482">                                ++prec; // prec unchanged if preceded by 0s</span>
<span class="nc" id="L483">                            rs = rs * 10 + digit;</span>
                        }
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">                        if (dot)</span>
<span class="nc" id="L486">                            ++scl;</span>
<span class="pc bpc" id="L487" title="1 of 4 branches missed.">                    } else if ((c == 'e') || (c == 'E')) {</span>
<span class="fc" id="L488">                        exp = parseExp(in, offset, len);</span>
                        // Next test is required for backwards compatibility
<span class="fc bfc" id="L490" title="All 2 branches covered.">                        if ((int) exp != exp) // overflow</span>
<span class="fc" id="L491">                            throw new NumberFormatException();</span>
                        break; // [saves a test]
                    } else {
<span class="fc" id="L494">                        throw new NumberFormatException();</span>
                    }
                }
<span class="fc bfc" id="L497" title="All 2 branches covered.">                if (prec == 0) // no digits found</span>
<span class="fc" id="L498">                    throw new NumberFormatException();</span>
                // Adjust scale if exp is not zero.
<span class="fc bfc" id="L500" title="All 2 branches covered.">                if (exp != 0) { // had significant exponent</span>
<span class="fc" id="L501">                    scl = adjustScale(scl, exp);</span>
                }
<span class="fc bfc" id="L503" title="All 2 branches covered.">                rs = isneg ? -rs : rs;</span>
<span class="fc" id="L504">                int mcp = mc.precision;</span>
<span class="fc" id="L505">                int drop = prec - mcp; // prec has range [1, MAX_INT], mcp has range [0, MAX_INT];</span>
                                       // therefore, this subtract cannot overflow
<span class="pc bpc" id="L507" title="3 of 4 branches missed.">                if (mcp &gt; 0 &amp;&amp; drop &gt; 0) {  // do rounding</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                    while (drop &gt; 0) {</span>
<span class="nc" id="L509">                        scl = checkScaleNonZero((long) scl - drop);</span>
<span class="nc" id="L510">                        rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);</span>
<span class="nc" id="L511">                        prec = longDigitLength(rs);</span>
<span class="nc" id="L512">                        drop = prec - mcp;</span>
                    }
                }
<span class="fc" id="L515">            } else {</span>
<span class="fc" id="L516">                char coeff[] = new char[len];</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">                for (; len &gt; 0; offset++, len--) {</span>
<span class="fc" id="L518">                    c = in[offset];</span>
                    // have digit
<span class="pc bpc" id="L520" title="1 of 6 branches missed.">                    if ((c &gt;= '0' &amp;&amp; c &lt;= '9') || Character.isDigit(c)) {</span>
                        // First compact case, we need not to preserve the character
                        // and we can just compute the value in place.
<span class="pc bpc" id="L523" title="1 of 4 branches missed.">                        if (c == '0' || Character.digit(c, 10) == 0) {</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">                            if (prec == 0) {</span>
<span class="fc" id="L525">                                coeff[idx] = c;</span>
<span class="fc" id="L526">                                prec = 1;</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                            } else if (idx != 0) {</span>
<span class="fc" id="L528">                                coeff[idx++] = c;</span>
<span class="fc" id="L529">                                ++prec;</span>
                            } // else c must be a redundant leading zero
                        } else {
<span class="fc bfc" id="L532" title="All 4 branches covered.">                            if (prec != 1 || idx != 0)</span>
<span class="fc" id="L533">                                ++prec; // prec unchanged if preceded by 0s</span>
<span class="fc" id="L534">                            coeff[idx++] = c;</span>
                        }
<span class="fc bfc" id="L536" title="All 2 branches covered.">                        if (dot)</span>
<span class="fc" id="L537">                            ++scl;</span>
                        continue;
                    }
                    // have dot
<span class="fc bfc" id="L541" title="All 2 branches covered.">                    if (c == '.') {</span>
                        // have dot
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">                        if (dot) // two dots</span>
<span class="nc" id="L544">                            throw new NumberFormatException();</span>
<span class="fc" id="L545">                        dot = true;</span>
<span class="fc" id="L546">                        continue;</span>
                    }
                    // exponent expected
<span class="pc bpc" id="L549" title="3 of 4 branches missed.">                    if ((c != 'e') &amp;&amp; (c != 'E'))</span>
<span class="nc" id="L550">                        throw new NumberFormatException();</span>
<span class="fc" id="L551">                    exp = parseExp(in, offset, len);</span>
                    // Next test is required for backwards compatibility
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                    if ((int) exp != exp) // overflow</span>
<span class="nc" id="L554">                        throw new NumberFormatException();</span>
                    break; // [saves a test]
                }
                // here when no characters left
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">                if (prec == 0) // no digits found</span>
<span class="nc" id="L559">                    throw new NumberFormatException();</span>
                // Adjust scale if exp is not zero.
<span class="fc bfc" id="L561" title="All 2 branches covered.">                if (exp != 0) { // had significant exponent</span>
<span class="fc" id="L562">                    scl = adjustScale(scl, exp);</span>
                }
                // Remove leading zeros from precision (digits count)
<span class="fc bfc" id="L565" title="All 2 branches covered.">                rb = new BigInteger(coeff, isneg ? -1 : 1, prec);</span>
<span class="fc" id="L566">                rs = compactValFor(rb);</span>
<span class="fc" id="L567">                int mcp = mc.precision;</span>
<span class="pc bpc" id="L568" title="3 of 4 branches missed.">                if (mcp &gt; 0 &amp;&amp; (prec &gt; mcp)) {</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">                    if (rs == INFLATED) {</span>
<span class="nc" id="L570">                        int drop = prec - mcp;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">                        while (drop &gt; 0) {</span>
<span class="nc" id="L572">                            scl = checkScaleNonZero((long) scl - drop);</span>
<span class="nc" id="L573">                            rb = divideAndRoundByTenPow(rb, drop, mc.roundingMode.oldMode);</span>
<span class="nc" id="L574">                            rs = compactValFor(rb);</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">                            if (rs != INFLATED) {</span>
<span class="nc" id="L576">                                prec = longDigitLength(rs);</span>
<span class="nc" id="L577">                                break;</span>
                            }
<span class="nc" id="L579">                            prec = bigDigitLength(rb);</span>
<span class="nc" id="L580">                            drop = prec - mcp;</span>
                        }
                    }
<span class="nc bnc" id="L583" title="All 2 branches missed.">                    if (rs != INFLATED) {</span>
<span class="nc" id="L584">                        int drop = prec - mcp;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">                        while (drop &gt; 0) {</span>
<span class="nc" id="L586">                            scl = checkScaleNonZero((long) scl - drop);</span>
<span class="nc" id="L587">                            rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);</span>
<span class="nc" id="L588">                            prec = longDigitLength(rs);</span>
<span class="nc" id="L589">                            drop = prec - mcp;</span>
                        }
<span class="nc" id="L591">                        rb = null;</span>
                    }
                }
            }
<span class="fc" id="L595">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="fc" id="L596">            throw new NumberFormatException();</span>
<span class="nc" id="L597">        } catch (NegativeArraySizeException e) {</span>
<span class="nc" id="L598">            throw new NumberFormatException();</span>
<span class="fc" id="L599">        }</span>
<span class="fc" id="L600">        this.scale = scl;</span>
<span class="fc" id="L601">        this.precision = prec;</span>
<span class="fc" id="L602">        this.intCompact = rs;</span>
<span class="fc" id="L603">        this.intVal = rb;</span>
<span class="fc" id="L604">    }</span>

    private int adjustScale(int scl, long exp) {
<span class="fc" id="L607">        long adjustedScale = scl - exp;</span>
<span class="pc bpc" id="L608" title="1 of 4 branches missed.">        if (adjustedScale &gt; Integer.MAX_VALUE || adjustedScale &lt; Integer.MIN_VALUE)</span>
<span class="fc" id="L609">            throw new NumberFormatException(&quot;Scale out of range.&quot;);</span>
<span class="fc" id="L610">        scl = (int) adjustedScale;</span>
<span class="fc" id="L611">        return scl;</span>
    }

    /*
     * parse exponent
     */
    private static long parseExp(char[] in, int offset, int len){
<span class="fc" id="L618">        long exp = 0;</span>
<span class="fc" id="L619">        offset++;</span>
<span class="fc" id="L620">        char c = in[offset];</span>
<span class="fc" id="L621">        len--;</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">        boolean negexp = (c == '-');</span>
        // optional sign
<span class="fc bfc" id="L624" title="All 4 branches covered.">        if (negexp || c == '+') {</span>
<span class="fc" id="L625">            offset++;</span>
<span class="fc" id="L626">            c = in[offset];</span>
<span class="fc" id="L627">            len--;</span>
        }
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">        if (len &lt;= 0) // no exponent digits</span>
<span class="nc" id="L630">            throw new NumberFormatException();</span>
        // skip leading zeros in the exponent
<span class="pc bpc" id="L632" title="1 of 6 branches missed.">        while (len &gt; 10 &amp;&amp; (c=='0' || (Character.digit(c, 10) == 0))) {</span>
<span class="fc" id="L633">            offset++;</span>
<span class="fc" id="L634">            c = in[offset];</span>
<span class="fc" id="L635">            len--;</span>
        }
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">        if (len &gt; 10) // too many nonzero exponent digits</span>
<span class="nc" id="L638">            throw new NumberFormatException();</span>
        // c now holds first digit of exponent
<span class="fc" id="L640">        for (;; len--) {</span>
            int v;
<span class="fc bfc" id="L642" title="All 4 branches covered.">            if (c &gt;= '0' &amp;&amp; c &lt;= '9') {</span>
<span class="fc" id="L643">                v = c - '0';</span>
            } else {
<span class="fc" id="L645">                v = Character.digit(c, 10);</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">                if (v &lt; 0) // not a digit</span>
<span class="fc" id="L647">                    throw new NumberFormatException();</span>
            }
<span class="fc" id="L649">            exp = exp * 10 + v;</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">            if (len == 1)</span>
<span class="fc" id="L651">                break; // that was final character</span>
<span class="fc" id="L652">            offset++;</span>
<span class="fc" id="L653">            c = in[offset];</span>
        }
<span class="fc bfc" id="L655" title="All 2 branches covered.">        if (negexp) // apply sign</span>
<span class="fc" id="L656">            exp = -exp;</span>
<span class="fc" id="L657">        return exp;</span>
    }

    /**
     * Translates a character array representation of a
     * {@code BigDecimal} into a {@code BigDecimal}, accepting the
     * same sequence of characters as the {@link #BigDecimal(String)}
     * constructor.
     *
     * &lt;p&gt;Note that if the sequence of characters is already available
     * as a character array, using this constructor is faster than
     * converting the {@code char} array to string and using the
     * {@code BigDecimal(String)} constructor .
     *
     * @param in {@code char} array that is the source of characters.
     * @throws NumberFormatException if {@code in} is not a valid
     *         representation of a {@code BigDecimal}.
     * @since  1.5
     */
    public BigDecimal(char[] in) {
<span class="nc" id="L677">        this(in, 0, in.length);</span>
<span class="nc" id="L678">    }</span>

    /**
     * Translates a character array representation of a
     * {@code BigDecimal} into a {@code BigDecimal}, accepting the
     * same sequence of characters as the {@link #BigDecimal(String)}
     * constructor and with rounding according to the context
     * settings.
     *
     * &lt;p&gt;Note that if the sequence of characters is already available
     * as a character array, using this constructor is faster than
     * converting the {@code char} array to string and using the
     * {@code BigDecimal(String)} constructor .
     *
     * @param  in {@code char} array that is the source of characters.
     * @param  mc the context to use.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @throws NumberFormatException if {@code in} is not a valid
     *         representation of a {@code BigDecimal}.
     * @since  1.5
     */
    public BigDecimal(char[] in, MathContext mc) {
<span class="nc" id="L701">        this(in, 0, in.length, mc);</span>
<span class="nc" id="L702">    }</span>

    /**
     * Translates the string representation of a {@code BigDecimal}
     * into a {@code BigDecimal}.  The string representation consists
     * of an optional sign, {@code '+'} (&lt;tt&gt; '&amp;#92;u002B'&lt;/tt&gt;) or
     * {@code '-'} (&lt;tt&gt;'&amp;#92;u002D'&lt;/tt&gt;), followed by a sequence of
     * zero or more decimal digits (&quot;the integer&quot;), optionally
     * followed by a fraction, optionally followed by an exponent.
     *
     * &lt;p&gt;The fraction consists of a decimal point followed by zero
     * or more decimal digits.  The string must contain at least one
     * digit in either the integer or the fraction.  The number formed
     * by the sign, the integer and the fraction is referred to as the
     * &lt;i&gt;significand&lt;/i&gt;.
     *
     * &lt;p&gt;The exponent consists of the character {@code 'e'}
     * (&lt;tt&gt;'&amp;#92;u0065'&lt;/tt&gt;) or {@code 'E'} (&lt;tt&gt;'&amp;#92;u0045'&lt;/tt&gt;)
     * followed by one or more decimal digits.  The value of the
     * exponent must lie between -{@link Integer#MAX_VALUE} ({@link
     * Integer#MIN_VALUE}+1) and {@link Integer#MAX_VALUE}, inclusive.
     *
     * &lt;p&gt;More formally, the strings this constructor accepts are
     * described by the following grammar:
     * &lt;blockquote&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;i&gt;BigDecimalString:&lt;/i&gt;
     * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; Significand Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
     * &lt;dt&gt;&lt;i&gt;Sign:&lt;/i&gt;
     * &lt;dd&gt;{@code +}
     * &lt;dd&gt;{@code -}
     * &lt;dt&gt;&lt;i&gt;Significand:&lt;/i&gt;
     * &lt;dd&gt;&lt;i&gt;IntegerPart&lt;/i&gt; {@code .} &lt;i&gt;FractionPart&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
     * &lt;dd&gt;{@code .} &lt;i&gt;FractionPart&lt;/i&gt;
     * &lt;dd&gt;&lt;i&gt;IntegerPart&lt;/i&gt;
     * &lt;dt&gt;&lt;i&gt;IntegerPart:&lt;/i&gt;
     * &lt;dd&gt;&lt;i&gt;Digits&lt;/i&gt;
     * &lt;dt&gt;&lt;i&gt;FractionPart:&lt;/i&gt;
     * &lt;dd&gt;&lt;i&gt;Digits&lt;/i&gt;
     * &lt;dt&gt;&lt;i&gt;Exponent:&lt;/i&gt;
     * &lt;dd&gt;&lt;i&gt;ExponentIndicator SignedInteger&lt;/i&gt;
     * &lt;dt&gt;&lt;i&gt;ExponentIndicator:&lt;/i&gt;
     * &lt;dd&gt;{@code e}
     * &lt;dd&gt;{@code E}
     * &lt;dt&gt;&lt;i&gt;SignedInteger:&lt;/i&gt;
     * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; Digits&lt;/i&gt;
     * &lt;dt&gt;&lt;i&gt;Digits:&lt;/i&gt;
     * &lt;dd&gt;&lt;i&gt;Digit&lt;/i&gt;
     * &lt;dd&gt;&lt;i&gt;Digits Digit&lt;/i&gt;
     * &lt;dt&gt;&lt;i&gt;Digit:&lt;/i&gt;
     * &lt;dd&gt;any character for which {@link Character#isDigit}
     * returns {@code true}, including 0, 1, 2 ...
     * &lt;/dl&gt;
     * &lt;/blockquote&gt;
     *
     * &lt;p&gt;The scale of the returned {@code BigDecimal} will be the
     * number of digits in the fraction, or zero if the string
     * contains no decimal point, subject to adjustment for any
     * exponent; if the string contains an exponent, the exponent is
     * subtracted from the scale.  The value of the resulting scale
     * must lie between {@code Integer.MIN_VALUE} and
     * {@code Integer.MAX_VALUE}, inclusive.
     *
     * &lt;p&gt;The character-to-digit mapping is provided by {@link
     * java.lang.Character#digit} set to convert to radix 10.  The
     * String may not contain any extraneous characters (whitespace,
     * for example).
     *
     * &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;br&gt;
     * The value of the returned {@code BigDecimal} is equal to
     * &lt;i&gt;significand&lt;/i&gt; &amp;times; 10&lt;sup&gt;&amp;nbsp;&lt;i&gt;exponent&lt;/i&gt;&lt;/sup&gt;.
     * For each string on the left, the resulting representation
     * [{@code BigInteger}, {@code scale}] is shown on the right.
     * &lt;pre&gt;
     * &quot;0&quot;            [0,0]
     * &quot;0.00&quot;         [0,2]
     * &quot;123&quot;          [123,0]
     * &quot;-123&quot;         [-123,0]
     * &quot;1.23E3&quot;       [123,-1]
     * &quot;1.23E+3&quot;      [123,-1]
     * &quot;12.3E+7&quot;      [123,-6]
     * &quot;12.0&quot;         [120,1]
     * &quot;12.3&quot;         [123,1]
     * &quot;0.00123&quot;      [123,5]
     * &quot;-1.23E-12&quot;    [-123,14]
     * &quot;1234.5E-4&quot;    [12345,5]
     * &quot;0E+7&quot;         [0,-7]
     * &quot;-0&quot;           [0,0]
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Note: For values other than {@code float} and
     * {@code double} NaN and &amp;plusmn;Infinity, this constructor is
     * compatible with the values returned by {@link Float#toString}
     * and {@link Double#toString}.  This is generally the preferred
     * way to convert a {@code float} or {@code double} into a
     * BigDecimal, as it doesn't suffer from the unpredictability of
     * the {@link #BigDecimal(double)} constructor.
     *
     * @param val String representation of {@code BigDecimal}.
     *
     * @throws NumberFormatException if {@code val} is not a valid
     *         representation of a {@code BigDecimal}.
     */
    public BigDecimal(String val) {
<span class="fc" id="L806">        this(val.toCharArray(), 0, val.length());</span>
<span class="fc" id="L807">    }</span>

    /**
     * Translates the string representation of a {@code BigDecimal}
     * into a {@code BigDecimal}, accepting the same strings as the
     * {@link #BigDecimal(String)} constructor, with rounding
     * according to the context settings.
     *
     * @param  val string representation of a {@code BigDecimal}.
     * @param  mc the context to use.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @throws NumberFormatException if {@code val} is not a valid
     *         representation of a BigDecimal.
     * @since  1.5
     */
    public BigDecimal(String val, MathContext mc) {
<span class="nc" id="L824">        this(val.toCharArray(), 0, val.length(), mc);</span>
<span class="nc" id="L825">    }</span>

    /**
     * Translates a {@code double} into a {@code BigDecimal} which
     * is the exact decimal representation of the {@code double}'s
     * binary floating-point value.  The scale of the returned
     * {@code BigDecimal} is the smallest value such that
     * &lt;tt&gt;(10&lt;sup&gt;scale&lt;/sup&gt; &amp;times; val)&lt;/tt&gt; is an integer.
     * &lt;p&gt;
     * &lt;b&gt;Notes:&lt;/b&gt;
     * &lt;ol&gt;
     * &lt;li&gt;
     * The results of this constructor can be somewhat unpredictable.
     * One might assume that writing {@code new BigDecimal(0.1)} in
     * Java creates a {@code BigDecimal} which is exactly equal to
     * 0.1 (an unscaled value of 1, with a scale of 1), but it is
     * actually equal to
     * 0.1000000000000000055511151231257827021181583404541015625.
     * This is because 0.1 cannot be represented exactly as a
     * {@code double} (or, for that matter, as a binary fraction of
     * any finite length).  Thus, the value that is being passed
     * &lt;i&gt;in&lt;/i&gt; to the constructor is not exactly equal to 0.1,
     * appearances notwithstanding.
     *
     * &lt;li&gt;
     * The {@code String} constructor, on the other hand, is
     * perfectly predictable: writing {@code new BigDecimal(&quot;0.1&quot;)}
     * creates a {@code BigDecimal} which is &lt;i&gt;exactly&lt;/i&gt; equal to
     * 0.1, as one would expect.  Therefore, it is generally
     * recommended that the {@linkplain #BigDecimal(String)
     * &lt;tt&gt;String&lt;/tt&gt; constructor} be used in preference to this one.
     *
     * &lt;li&gt;
     * When a {@code double} must be used as a source for a
     * {@code BigDecimal}, note that this constructor provides an
     * exact conversion; it does not give the same result as
     * converting the {@code double} to a {@code String} using the
     * {@link Double#toString(double)} method and then using the
     * {@link #BigDecimal(String)} constructor.  To get that result,
     * use the {@code static} {@link #valueOf(double)} method.
     * &lt;/ol&gt;
     *
     * @param val {@code double} value to be converted to
     *        {@code BigDecimal}.
     * @throws NumberFormatException if {@code val} is infinite or NaN.
     */
    public BigDecimal(double val) {
<span class="fc" id="L872">        this(val,MathContext.UNLIMITED);</span>
<span class="fc" id="L873">    }</span>

    /**
     * Translates a {@code double} into a {@code BigDecimal}, with
     * rounding according to the context settings.  The scale of the
     * {@code BigDecimal} is the smallest value such that
     * &lt;tt&gt;(10&lt;sup&gt;scale&lt;/sup&gt; &amp;times; val)&lt;/tt&gt; is an integer.
     *
     * &lt;p&gt;The results of this constructor can be somewhat unpredictable
     * and its use is generally not recommended; see the notes under
     * the {@link #BigDecimal(double)} constructor.
     *
     * @param  val {@code double} value to be converted to
     *         {@code BigDecimal}.
     * @param  mc the context to use.
     * @throws ArithmeticException if the result is inexact but the
     *         RoundingMode is UNNECESSARY.
     * @throws NumberFormatException if {@code val} is infinite or NaN.
     * @since  1.5
     */
<span class="fc" id="L893">    public BigDecimal(double val, MathContext mc) {</span>
<span class="pc bpc" id="L894" title="2 of 4 branches missed.">        if (Double.isInfinite(val) || Double.isNaN(val))</span>
<span class="nc" id="L895">            throw new NumberFormatException(&quot;Infinite or NaN&quot;);</span>
        // Translate the double into sign, exponent and significand, according
        // to the formulae in JLS, Section 20.10.22.
<span class="fc" id="L898">        long valBits = Double.doubleToLongBits(val);</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">        int sign = ((valBits &gt;&gt; 63) == 0 ? 1 : -1);</span>
<span class="fc" id="L900">        int exponent = (int) ((valBits &gt;&gt; 52) &amp; 0x7ffL);</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">        long significand = (exponent == 0</span>
                ? (valBits &amp; ((1L &lt;&lt; 52) - 1)) &lt;&lt; 1
                : (valBits &amp; ((1L &lt;&lt; 52) - 1)) | (1L &lt;&lt; 52));
<span class="fc" id="L904">        exponent -= 1075;</span>
        // At this point, val == sign * significand * 2**exponent.

        /*
         * Special case zero to supress nonterminating normalization and bogus
         * scale calculation.
         */
<span class="fc bfc" id="L911" title="All 2 branches covered.">        if (significand == 0) {</span>
<span class="fc" id="L912">            this.intVal = BigInteger.ZERO;</span>
<span class="fc" id="L913">            this.scale = 0;</span>
<span class="fc" id="L914">            this.intCompact = 0;</span>
<span class="fc" id="L915">            this.precision = 1;</span>
<span class="fc" id="L916">            return;</span>
        }
        // Normalize
<span class="fc bfc" id="L919" title="All 2 branches covered.">        while ((significand &amp; 1) == 0) { // i.e., significand is even</span>
<span class="fc" id="L920">            significand &gt;&gt;= 1;</span>
<span class="fc" id="L921">            exponent++;</span>
        }
<span class="fc" id="L923">        int scale = 0;</span>
        // Calculate intVal and scale
        BigInteger intVal;
<span class="fc" id="L926">        long compactVal = sign * significand;</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">        if (exponent == 0) {</span>
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">            intVal = (compactVal == INFLATED) ? INFLATED_BIGINT : null;</span>
        } else {
<span class="fc bfc" id="L930" title="All 2 branches covered.">            if (exponent &lt; 0) {</span>
<span class="fc" id="L931">                intVal = BigInteger.valueOf(5).pow(-exponent).multiply(compactVal);</span>
<span class="fc" id="L932">                scale = -exponent;</span>
            } else { //  (exponent &gt; 0)
<span class="fc" id="L934">                intVal = BigInteger.valueOf(2).pow(exponent).multiply(compactVal);</span>
            }
<span class="fc" id="L936">            compactVal = compactValFor(intVal);</span>
        }
<span class="fc" id="L938">        int prec = 0;</span>
<span class="fc" id="L939">        int mcp = mc.precision;</span>
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">        if (mcp &gt; 0) { // do rounding</span>
<span class="nc" id="L941">            int mode = mc.roundingMode.oldMode;</span>
            int drop;
<span class="nc bnc" id="L943" title="All 2 branches missed.">            if (compactVal == INFLATED) {</span>
<span class="nc" id="L944">                prec = bigDigitLength(intVal);</span>
<span class="nc" id="L945">                drop = prec - mcp;</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">                while (drop &gt; 0) {</span>
<span class="nc" id="L947">                    scale = checkScaleNonZero((long) scale - drop);</span>
<span class="nc" id="L948">                    intVal = divideAndRoundByTenPow(intVal, drop, mode);</span>
<span class="nc" id="L949">                    compactVal = compactValFor(intVal);</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">                    if (compactVal != INFLATED) {</span>
<span class="nc" id="L951">                        break;</span>
                    }
<span class="nc" id="L953">                    prec = bigDigitLength(intVal);</span>
<span class="nc" id="L954">                    drop = prec - mcp;</span>
                }
            }
<span class="nc bnc" id="L957" title="All 2 branches missed.">            if (compactVal != INFLATED) {</span>
<span class="nc" id="L958">                prec = longDigitLength(compactVal);</span>
<span class="nc" id="L959">                drop = prec - mcp;</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">                while (drop &gt; 0) {</span>
<span class="nc" id="L961">                    scale = checkScaleNonZero((long) scale - drop);</span>
<span class="nc" id="L962">                    compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);</span>
<span class="nc" id="L963">                    prec = longDigitLength(compactVal);</span>
<span class="nc" id="L964">                    drop = prec - mcp;</span>
                }
<span class="nc" id="L966">                intVal = null;</span>
            }
        }
<span class="fc" id="L969">        this.intVal = intVal;</span>
<span class="fc" id="L970">        this.intCompact = compactVal;</span>
<span class="fc" id="L971">        this.scale = scale;</span>
<span class="fc" id="L972">        this.precision = prec;</span>
<span class="fc" id="L973">    }</span>

    /**
     * Translates a {@code BigInteger} into a {@code BigDecimal}.
     * The scale of the {@code BigDecimal} is zero.
     *
     * @param val {@code BigInteger} value to be converted to
     *            {@code BigDecimal}.
     */
<span class="fc" id="L982">    public BigDecimal(BigInteger val) {</span>
<span class="fc" id="L983">        scale = 0;</span>
<span class="fc" id="L984">        intVal = val;</span>
<span class="fc" id="L985">        intCompact = compactValFor(val);</span>
<span class="fc" id="L986">    }</span>

    /**
     * Translates a {@code BigInteger} into a {@code BigDecimal}
     * rounding according to the context settings.  The scale of the
     * {@code BigDecimal} is zero.
     *
     * @param val {@code BigInteger} value to be converted to
     *            {@code BigDecimal}.
     * @param  mc the context to use.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @since  1.5
     */
    public BigDecimal(BigInteger val, MathContext mc) {
<span class="nc" id="L1001">        this(val,0,mc);</span>
<span class="nc" id="L1002">    }</span>

    /**
     * Translates a {@code BigInteger} unscaled value and an
     * {@code int} scale into a {@code BigDecimal}.  The value of
     * the {@code BigDecimal} is
     * &lt;tt&gt;(unscaledVal &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/tt&gt;.
     *
     * @param unscaledVal unscaled value of the {@code BigDecimal}.
     * @param scale scale of the {@code BigDecimal}.
     */
<span class="fc" id="L1013">    public BigDecimal(BigInteger unscaledVal, int scale) {</span>
        // Negative scales are now allowed
<span class="fc" id="L1015">        this.intVal = unscaledVal;</span>
<span class="fc" id="L1016">        this.intCompact = compactValFor(unscaledVal);</span>
<span class="fc" id="L1017">        this.scale = scale;</span>
<span class="fc" id="L1018">    }</span>

    /**
     * Translates a {@code BigInteger} unscaled value and an
     * {@code int} scale into a {@code BigDecimal}, with rounding
     * according to the context settings.  The value of the
     * {@code BigDecimal} is &lt;tt&gt;(unscaledVal &amp;times;
     * 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/tt&gt;, rounded according to the
     * {@code precision} and rounding mode settings.
     *
     * @param  unscaledVal unscaled value of the {@code BigDecimal}.
     * @param  scale scale of the {@code BigDecimal}.
     * @param  mc the context to use.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @since  1.5
     */
<span class="fc" id="L1035">    public BigDecimal(BigInteger unscaledVal, int scale, MathContext mc) {</span>
<span class="fc" id="L1036">        long compactVal = compactValFor(unscaledVal);</span>
<span class="fc" id="L1037">        int mcp = mc.precision;</span>
<span class="fc" id="L1038">        int prec = 0;</span>
<span class="fc bfc" id="L1039" title="All 2 branches covered.">        if (mcp &gt; 0) { // do rounding</span>
<span class="fc" id="L1040">            int mode = mc.roundingMode.oldMode;</span>
<span class="fc bfc" id="L1041" title="All 2 branches covered.">            if (compactVal == INFLATED) {</span>
<span class="fc" id="L1042">                prec = bigDigitLength(unscaledVal);</span>
<span class="fc" id="L1043">                int drop = prec - mcp;</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">                while (drop &gt; 0) {</span>
<span class="fc" id="L1045">                    scale = checkScaleNonZero((long) scale - drop);</span>
<span class="fc" id="L1046">                    unscaledVal = divideAndRoundByTenPow(unscaledVal, drop, mode);</span>
<span class="fc" id="L1047">                    compactVal = compactValFor(unscaledVal);</span>
<span class="fc bfc" id="L1048" title="All 2 branches covered.">                    if (compactVal != INFLATED) {</span>
<span class="fc" id="L1049">                        break;</span>
                    }
<span class="fc" id="L1051">                    prec = bigDigitLength(unscaledVal);</span>
<span class="fc" id="L1052">                    drop = prec - mcp;</span>
                }
            }
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            if (compactVal != INFLATED) {</span>
<span class="fc" id="L1056">                prec = longDigitLength(compactVal);</span>
<span class="fc" id="L1057">                int drop = prec - mcp;     // drop can't be more than 18</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">                while (drop &gt; 0) {</span>
<span class="fc" id="L1059">                    scale = checkScaleNonZero((long) scale - drop);</span>
<span class="fc" id="L1060">                    compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mode);</span>
<span class="fc" id="L1061">                    prec = longDigitLength(compactVal);</span>
<span class="fc" id="L1062">                    drop = prec - mcp;</span>
                }
<span class="fc" id="L1064">                unscaledVal = null;</span>
            }
        }
<span class="fc" id="L1067">        this.intVal = unscaledVal;</span>
<span class="fc" id="L1068">        this.intCompact = compactVal;</span>
<span class="fc" id="L1069">        this.scale = scale;</span>
<span class="fc" id="L1070">        this.precision = prec;</span>
<span class="fc" id="L1071">    }</span>

    /**
     * Translates an {@code int} into a {@code BigDecimal}.  The
     * scale of the {@code BigDecimal} is zero.
     *
     * @param val {@code int} value to be converted to
     *            {@code BigDecimal}.
     * @since  1.5
     */
<span class="fc" id="L1081">    public BigDecimal(int val) {</span>
<span class="fc" id="L1082">        this.intCompact = val;</span>
<span class="fc" id="L1083">        this.scale = 0;</span>
<span class="fc" id="L1084">        this.intVal = null;</span>
<span class="fc" id="L1085">    }</span>

    /**
     * Translates an {@code int} into a {@code BigDecimal}, with
     * rounding according to the context settings.  The scale of the
     * {@code BigDecimal}, before any rounding, is zero.
     *
     * @param  val {@code int} value to be converted to {@code BigDecimal}.
     * @param  mc the context to use.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @since  1.5
     */
<span class="nc" id="L1098">    public BigDecimal(int val, MathContext mc) {</span>
<span class="nc" id="L1099">        int mcp = mc.precision;</span>
<span class="nc" id="L1100">        long compactVal = val;</span>
<span class="nc" id="L1101">        int scale = 0;</span>
<span class="nc" id="L1102">        int prec = 0;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (mcp &gt; 0) { // do rounding</span>
<span class="nc" id="L1104">            prec = longDigitLength(compactVal);</span>
<span class="nc" id="L1105">            int drop = prec - mcp; // drop can't be more than 18</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            while (drop &gt; 0) {</span>
<span class="nc" id="L1107">                scale = checkScaleNonZero((long) scale - drop);</span>
<span class="nc" id="L1108">                compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);</span>
<span class="nc" id="L1109">                prec = longDigitLength(compactVal);</span>
<span class="nc" id="L1110">                drop = prec - mcp;</span>
            }
        }
<span class="nc" id="L1113">        this.intVal = null;</span>
<span class="nc" id="L1114">        this.intCompact = compactVal;</span>
<span class="nc" id="L1115">        this.scale = scale;</span>
<span class="nc" id="L1116">        this.precision = prec;</span>
<span class="nc" id="L1117">    }</span>

    /**
     * Translates a {@code long} into a {@code BigDecimal}.  The
     * scale of the {@code BigDecimal} is zero.
     *
     * @param val {@code long} value to be converted to {@code BigDecimal}.
     * @since  1.5
     */
<span class="fc" id="L1126">    public BigDecimal(long val) {</span>
<span class="fc" id="L1127">        this.intCompact = val;</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">        this.intVal = (val == INFLATED) ? INFLATED_BIGINT : null;</span>
<span class="fc" id="L1129">        this.scale = 0;</span>
<span class="fc" id="L1130">    }</span>

    /**
     * Translates a {@code long} into a {@code BigDecimal}, with
     * rounding according to the context settings.  The scale of the
     * {@code BigDecimal}, before any rounding, is zero.
     *
     * @param  val {@code long} value to be converted to {@code BigDecimal}.
     * @param  mc the context to use.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @since  1.5
     */
<span class="fc" id="L1143">    public BigDecimal(long val, MathContext mc) {</span>
<span class="fc" id="L1144">        int mcp = mc.precision;</span>
<span class="fc" id="L1145">        int mode = mc.roundingMode.oldMode;</span>
<span class="fc" id="L1146">        int prec = 0;</span>
<span class="fc" id="L1147">        int scale = 0;</span>
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">        BigInteger intVal = (val == INFLATED) ? INFLATED_BIGINT : null;</span>
<span class="fc bfc" id="L1149" title="All 2 branches covered.">        if (mcp &gt; 0) { // do rounding</span>
<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">            if (val == INFLATED) {</span>
<span class="fc" id="L1151">                prec = 19;</span>
<span class="fc" id="L1152">                int drop = prec - mcp;</span>
<span class="fc bfc" id="L1153" title="All 2 branches covered.">                while (drop &gt; 0) {</span>
<span class="fc" id="L1154">                    scale = checkScaleNonZero((long) scale - drop);</span>
<span class="fc" id="L1155">                    intVal = divideAndRoundByTenPow(intVal, drop, mode);</span>
<span class="fc" id="L1156">                    val = compactValFor(intVal);</span>
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">                    if (val != INFLATED) {</span>
<span class="fc" id="L1158">                        break;</span>
                    }
<span class="nc" id="L1160">                    prec = bigDigitLength(intVal);</span>
<span class="nc" id="L1161">                    drop = prec - mcp;</span>
                }
            }
<span class="fc bfc" id="L1164" title="All 2 branches covered.">            if (val != INFLATED) {</span>
<span class="fc" id="L1165">                prec = longDigitLength(val);</span>
<span class="fc" id="L1166">                int drop = prec - mcp;</span>
<span class="pc bpc" id="L1167" title="1 of 2 branches missed.">                while (drop &gt; 0) {</span>
<span class="nc" id="L1168">                    scale = checkScaleNonZero((long) scale - drop);</span>
<span class="nc" id="L1169">                    val = divideAndRound(val, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);</span>
<span class="nc" id="L1170">                    prec = longDigitLength(val);</span>
<span class="nc" id="L1171">                    drop = prec - mcp;</span>
                }
<span class="fc" id="L1173">                intVal = null;</span>
            }
        }
<span class="fc" id="L1176">        this.intVal = intVal;</span>
<span class="fc" id="L1177">        this.intCompact = val;</span>
<span class="fc" id="L1178">        this.scale = scale;</span>
<span class="fc" id="L1179">        this.precision = prec;</span>
<span class="fc" id="L1180">    }</span>

    // Static Factory Methods

    /**
     * Translates a {@code long} unscaled value and an
     * {@code int} scale into a {@code BigDecimal}.  This
     * {@literal &quot;static factory method&quot;} is provided in preference to
     * a ({@code long}, {@code int}) constructor because it
     * allows for reuse of frequently used {@code BigDecimal} values..
     *
     * @param unscaledVal unscaled value of the {@code BigDecimal}.
     * @param scale scale of the {@code BigDecimal}.
     * @return a {@code BigDecimal} whose value is
     *         &lt;tt&gt;(unscaledVal &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/tt&gt;.
     */
    public static BigDecimal valueOf(long unscaledVal, int scale) {
<span class="fc bfc" id="L1197" title="All 2 branches covered.">        if (scale == 0)</span>
<span class="fc" id="L1198">            return valueOf(unscaledVal);</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">        else if (unscaledVal == 0) {</span>
<span class="fc" id="L1200">            return zeroValueOf(scale);</span>
        }
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">        return new BigDecimal(unscaledVal == INFLATED ?</span>
                              INFLATED_BIGINT : null,
                              unscaledVal, scale, 0);
    }

    /**
     * Translates a {@code long} value into a {@code BigDecimal}
     * with a scale of zero.  This {@literal &quot;static factory method&quot;}
     * is provided in preference to a ({@code long}) constructor
     * because it allows for reuse of frequently used
     * {@code BigDecimal} values.
     *
     * @param val value of the {@code BigDecimal}.
     * @return a {@code BigDecimal} whose value is {@code val}.
     */
    public static BigDecimal valueOf(long val) {
<span class="fc bfc" id="L1218" title="All 4 branches covered.">        if (val &gt;= 0 &amp;&amp; val &lt; zeroThroughTen.length)</span>
<span class="fc" id="L1219">            return zeroThroughTen[(int)val];</span>
<span class="fc bfc" id="L1220" title="All 2 branches covered.">        else if (val != INFLATED)</span>
<span class="fc" id="L1221">            return new BigDecimal(null, val, 0, 0);</span>
<span class="fc" id="L1222">        return new BigDecimal(INFLATED_BIGINT, val, 0, 0);</span>
    }

    static BigDecimal valueOf(long unscaledVal, int scale, int prec) {
<span class="fc bfc" id="L1226" title="All 6 branches covered.">        if (scale == 0 &amp;&amp; unscaledVal &gt;= 0 &amp;&amp; unscaledVal &lt; zeroThroughTen.length) {</span>
<span class="fc" id="L1227">            return zeroThroughTen[(int) unscaledVal];</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">        } else if (unscaledVal == 0) {</span>
<span class="fc" id="L1229">            return zeroValueOf(scale);</span>
        }
<span class="pc bpc" id="L1231" title="1 of 2 branches missed.">        return new BigDecimal(unscaledVal == INFLATED ? INFLATED_BIGINT : null,</span>
                unscaledVal, scale, prec);
    }

    static BigDecimal valueOf(BigInteger intVal, int scale, int prec) {
<span class="fc" id="L1236">        long val = compactValFor(intVal);</span>
<span class="fc bfc" id="L1237" title="All 2 branches covered.">        if (val == 0) {</span>
<span class="fc" id="L1238">            return zeroValueOf(scale);</span>
<span class="fc bfc" id="L1239" title="All 6 branches covered.">        } else if (scale == 0 &amp;&amp; val &gt;= 0 &amp;&amp; val &lt; zeroThroughTen.length) {</span>
<span class="fc" id="L1240">            return zeroThroughTen[(int) val];</span>
        }
<span class="fc" id="L1242">        return new BigDecimal(intVal, val, scale, prec);</span>
    }

    static BigDecimal zeroValueOf(int scale) {
<span class="fc bfc" id="L1246" title="All 4 branches covered.">        if (scale &gt;= 0 &amp;&amp; scale &lt; ZERO_SCALED_BY.length)</span>
<span class="fc" id="L1247">            return ZERO_SCALED_BY[scale];</span>
        else
<span class="fc" id="L1249">            return new BigDecimal(BigInteger.ZERO, 0, scale, 1);</span>
    }

    /**
     * Translates a {@code double} into a {@code BigDecimal}, using
     * the {@code double}'s canonical string representation provided
     * by the {@link Double#toString(double)} method.
     *
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This is generally the preferred way to convert
     * a {@code double} (or {@code float}) into a
     * {@code BigDecimal}, as the value returned is equal to that
     * resulting from constructing a {@code BigDecimal} from the
     * result of using {@link Double#toString(double)}.
     *
     * @param  val {@code double} to convert to a {@code BigDecimal}.
     * @return a {@code BigDecimal} whose value is equal to or approximately
     *         equal to the value of {@code val}.
     * @throws NumberFormatException if {@code val} is infinite or NaN.
     * @since  1.5
     */
    public static BigDecimal valueOf(double val) {
        // Reminder: a zero double returns '0.0', so we cannot fastpath
        // to use the constant ZERO.  This might be important enough to
        // justify a factory approach, a cache, or a few private
        // constants, later.
<span class="fc" id="L1274">        return new BigDecimal(Double.toString(val));</span>
    }

    // Arithmetic Operations
    /**
     * Returns a {@code BigDecimal} whose value is {@code (this +
     * augend)}, and whose scale is {@code max(this.scale(),
     * augend.scale())}.
     *
     * @param  augend value to be added to this {@code BigDecimal}.
     * @return {@code this + augend}
     */
    public BigDecimal add(BigDecimal augend) {
<span class="fc bfc" id="L1287" title="All 2 branches covered.">        if (this.intCompact != INFLATED) {</span>
<span class="fc bfc" id="L1288" title="All 2 branches covered.">            if ((augend.intCompact != INFLATED)) {</span>
<span class="fc" id="L1289">                return add(this.intCompact, this.scale, augend.intCompact, augend.scale);</span>
            } else {
<span class="fc" id="L1291">                return add(this.intCompact, this.scale, augend.intVal, augend.scale);</span>
            }
        } else {
<span class="fc bfc" id="L1294" title="All 2 branches covered.">            if ((augend.intCompact != INFLATED)) {</span>
<span class="fc" id="L1295">                return add(augend.intCompact, augend.scale, this.intVal, this.scale);</span>
            } else {
<span class="fc" id="L1297">                return add(this.intVal, this.scale, augend.intVal, augend.scale);</span>
            }
        }
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (this + augend)},
     * with rounding according to the context settings.
     *
     * If either number is zero and the precision setting is nonzero then
     * the other number, rounded if necessary, is used as the result.
     *
     * @param  augend value to be added to this {@code BigDecimal}.
     * @param  mc the context to use.
     * @return {@code this + augend}, rounded as necessary.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @since  1.5
     */
    public BigDecimal add(BigDecimal augend, MathContext mc) {
<span class="nc bnc" id="L1317" title="All 2 branches missed.">        if (mc.precision == 0)</span>
<span class="nc" id="L1318">            return add(augend);</span>
<span class="nc" id="L1319">        BigDecimal lhs = this;</span>

        // If either number is zero then the other number, rounded and
        // scaled if necessary, is used as the result.
        {
<span class="nc bnc" id="L1324" title="All 2 branches missed.">            boolean lhsIsZero = lhs.signum() == 0;</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">            boolean augendIsZero = augend.signum() == 0;</span>

<span class="nc bnc" id="L1327" title="All 4 branches missed.">            if (lhsIsZero || augendIsZero) {</span>
<span class="nc" id="L1328">                int preferredScale = Math.max(lhs.scale(), augend.scale());</span>
                BigDecimal result;

<span class="nc bnc" id="L1331" title="All 4 branches missed.">                if (lhsIsZero &amp;&amp; augendIsZero)</span>
<span class="nc" id="L1332">                    return zeroValueOf(preferredScale);</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">                result = lhsIsZero ? doRound(augend, mc) : doRound(lhs, mc);</span>

<span class="nc bnc" id="L1335" title="All 2 branches missed.">                if (result.scale() == preferredScale)</span>
<span class="nc" id="L1336">                    return result;</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">                else if (result.scale() &gt; preferredScale) {</span>
<span class="nc" id="L1338">                    return stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);</span>
                } else { // result.scale &lt; preferredScale
<span class="nc" id="L1340">                    int precisionDiff = mc.precision - result.precision();</span>
<span class="nc" id="L1341">                    int scaleDiff     = preferredScale - result.scale();</span>

<span class="nc bnc" id="L1343" title="All 2 branches missed.">                    if (precisionDiff &gt;= scaleDiff)</span>
<span class="nc" id="L1344">                        return result.setScale(preferredScale); // can achieve target scale</span>
                    else
<span class="nc" id="L1346">                        return result.setScale(result.scale() + precisionDiff);</span>
                }
            }
        }

<span class="nc" id="L1351">        long padding = (long) lhs.scale - augend.scale;</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">        if (padding != 0) { // scales differ; alignment needed</span>
<span class="nc" id="L1353">            BigDecimal arg[] = preAlign(lhs, augend, padding, mc);</span>
<span class="nc" id="L1354">            matchScale(arg);</span>
<span class="nc" id="L1355">            lhs = arg[0];</span>
<span class="nc" id="L1356">            augend = arg[1];</span>
        }
<span class="nc" id="L1358">        return doRound(lhs.inflated().add(augend.inflated()), lhs.scale, mc);</span>
    }

    /**
     * Returns an array of length two, the sum of whose entries is
     * equal to the rounded sum of the {@code BigDecimal} arguments.
     *
     * &lt;p&gt;If the digit positions of the arguments have a sufficient
     * gap between them, the value smaller in magnitude can be
     * condensed into a {@literal &quot;sticky bit&quot;} and the end result will
     * round the same way &lt;em&gt;if&lt;/em&gt; the precision of the final
     * result does not include the high order digit of the small
     * magnitude operand.
     *
     * &lt;p&gt;Note that while strictly speaking this is an optimization,
     * it makes a much wider range of additions practical.
     *
     * &lt;p&gt;This corresponds to a pre-shift operation in a fixed
     * precision floating-point adder; this method is complicated by
     * variable precision of the result as determined by the
     * MathContext.  A more nuanced operation could implement a
     * {@literal &quot;right shift&quot;} on the smaller magnitude operand so
     * that the number of digits of the smaller operand could be
     * reduced even though the significands partially overlapped.
     */
    private BigDecimal[] preAlign(BigDecimal lhs, BigDecimal augend, long padding, MathContext mc) {
<span class="nc bnc" id="L1384" title="All 4 branches missed.">        assert padding != 0;</span>
        BigDecimal big;
        BigDecimal small;

<span class="nc bnc" id="L1388" title="All 2 branches missed.">        if (padding &lt; 0) { // lhs is big; augend is small</span>
<span class="nc" id="L1389">            big = lhs;</span>
<span class="nc" id="L1390">            small = augend;</span>
        } else { // lhs is small; augend is big
<span class="nc" id="L1392">            big = augend;</span>
<span class="nc" id="L1393">            small = lhs;</span>
        }

        /*
         * This is the estimated scale of an ulp of the result; it assumes that
         * the result doesn't have a carry-out on a true add (e.g. 999 + 1 =&gt;
         * 1000) or any subtractive cancellation on borrowing (e.g. 100 - 1.2 =&gt;
         * 98.8)
         */
<span class="nc" id="L1402">        long estResultUlpScale = (long) big.scale - big.precision() + mc.precision;</span>

        /*
         * The low-order digit position of big is big.scale().  This
         * is true regardless of whether big has a positive or
         * negative scale.  The high-order digit position of small is
         * small.scale - (small.precision() - 1).  To do the full
         * condensation, the digit positions of big and small must be
         * disjoint *and* the digit positions of small should not be
         * directly visible in the result.
         */
<span class="nc" id="L1413">        long smallHighDigitPos = (long) small.scale - small.precision() + 1;</span>
<span class="nc bnc" id="L1414" title="All 4 branches missed.">        if (smallHighDigitPos &gt; big.scale + 2 &amp;&amp; // big and small disjoint</span>
            smallHighDigitPos &gt; estResultUlpScale + 2) { // small digits not visible
<span class="nc" id="L1416">            small = BigDecimal.valueOf(small.signum(), this.checkScale(Math.max(big.scale, estResultUlpScale) + 3));</span>
        }

        // Since addition is symmetric, preserving input order in
        // returned operands doesn't matter
<span class="nc" id="L1421">        BigDecimal[] result = {big, small};</span>
<span class="nc" id="L1422">        return result;</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (this -
     * subtrahend)}, and whose scale is {@code max(this.scale(),
     * subtrahend.scale())}.
     *
     * @param  subtrahend value to be subtracted from this {@code BigDecimal}.
     * @return {@code this - subtrahend}
     */
    public BigDecimal subtract(BigDecimal subtrahend) {
<span class="fc bfc" id="L1434" title="All 2 branches covered.">        if (this.intCompact != INFLATED) {</span>
<span class="fc bfc" id="L1435" title="All 2 branches covered.">            if ((subtrahend.intCompact != INFLATED)) {</span>
<span class="fc" id="L1436">                return add(this.intCompact, this.scale, -subtrahend.intCompact, subtrahend.scale);</span>
            } else {
<span class="fc" id="L1438">                return add(this.intCompact, this.scale, subtrahend.intVal.negate(), subtrahend.scale);</span>
            }
        } else {
<span class="fc bfc" id="L1441" title="All 2 branches covered.">            if ((subtrahend.intCompact != INFLATED)) {</span>
                // Pair of subtrahend values given before pair of
                // values from this BigDecimal to avoid need for
                // method overloading on the specialized add method
<span class="fc" id="L1445">                return add(-subtrahend.intCompact, subtrahend.scale, this.intVal, this.scale);</span>
            } else {
<span class="fc" id="L1447">                return add(this.intVal, this.scale, subtrahend.intVal.negate(), subtrahend.scale);</span>
            }
        }
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (this - subtrahend)},
     * with rounding according to the context settings.
     *
     * If {@code subtrahend} is zero then this, rounded if necessary, is used as the
     * result.  If this is zero then the result is {@code subtrahend.negate(mc)}.
     *
     * @param  subtrahend value to be subtracted from this {@code BigDecimal}.
     * @param  mc the context to use.
     * @return {@code this - subtrahend}, rounded as necessary.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @since  1.5
     */
    public BigDecimal subtract(BigDecimal subtrahend, MathContext mc) {
<span class="nc bnc" id="L1467" title="All 2 branches missed.">        if (mc.precision == 0)</span>
<span class="nc" id="L1468">            return subtract(subtrahend);</span>
        // share the special rounding code in add()
<span class="nc" id="L1470">        return add(subtrahend.negate(), mc);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is &lt;tt&gt;(this &amp;times;
     * multiplicand)&lt;/tt&gt;, and whose scale is {@code (this.scale() +
     * multiplicand.scale())}.
     *
     * @param  multiplicand value to be multiplied by this {@code BigDecimal}.
     * @return {@code this * multiplicand}
     */
    public BigDecimal multiply(BigDecimal multiplicand) {
<span class="fc" id="L1482">        int productScale = checkScale((long) scale + multiplicand.scale);</span>
<span class="fc bfc" id="L1483" title="All 2 branches covered.">        if (this.intCompact != INFLATED) {</span>
<span class="pc bpc" id="L1484" title="1 of 2 branches missed.">            if ((multiplicand.intCompact != INFLATED)) {</span>
<span class="fc" id="L1485">                return multiply(this.intCompact, multiplicand.intCompact, productScale);</span>
            } else {
<span class="nc" id="L1487">                return multiply(this.intCompact, multiplicand.intVal, productScale);</span>
            }
        } else {
<span class="fc bfc" id="L1490" title="All 2 branches covered.">            if ((multiplicand.intCompact != INFLATED)) {</span>
<span class="fc" id="L1491">                return multiply(multiplicand.intCompact, this.intVal, productScale);</span>
            } else {
<span class="fc" id="L1493">                return multiply(this.intVal, multiplicand.intVal, productScale);</span>
            }
        }
    }

    /**
     * Returns a {@code BigDecimal} whose value is &lt;tt&gt;(this &amp;times;
     * multiplicand)&lt;/tt&gt;, with rounding according to the context settings.
     *
     * @param  multiplicand value to be multiplied by this {@code BigDecimal}.
     * @param  mc the context to use.
     * @return {@code this * multiplicand}, rounded as necessary.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @since  1.5
     */
    public BigDecimal multiply(BigDecimal multiplicand, MathContext mc) {
<span class="nc bnc" id="L1510" title="All 2 branches missed.">        if (mc.precision == 0)</span>
<span class="nc" id="L1511">            return multiply(multiplicand);</span>
<span class="nc" id="L1512">        int productScale = checkScale((long) scale + multiplicand.scale);</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">        if (this.intCompact != INFLATED) {</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">            if ((multiplicand.intCompact != INFLATED)) {</span>
<span class="nc" id="L1515">                return multiplyAndRound(this.intCompact, multiplicand.intCompact, productScale, mc);</span>
            } else {
<span class="nc" id="L1517">                return multiplyAndRound(this.intCompact, multiplicand.intVal, productScale, mc);</span>
            }
        } else {
<span class="nc bnc" id="L1520" title="All 2 branches missed.">            if ((multiplicand.intCompact != INFLATED)) {</span>
<span class="nc" id="L1521">                return multiplyAndRound(multiplicand.intCompact, this.intVal, productScale, mc);</span>
            } else {
<span class="nc" id="L1523">                return multiplyAndRound(this.intVal, multiplicand.intVal, productScale, mc);</span>
            }
        }
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (this /
     * divisor)}, and whose scale is as specified.  If rounding must
     * be performed to generate a result with the specified scale, the
     * specified rounding mode is applied.
     *
     * &lt;p&gt;The new {@link #divide(BigDecimal, int, RoundingMode)} method
     * should be used in preference to this legacy method.
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided.
     * @param  scale scale of the {@code BigDecimal} quotient to be returned.
     * @param  roundingMode rounding mode to apply.
     * @return {@code this / divisor}
     * @throws ArithmeticException if {@code divisor} is zero,
     *         {@code roundingMode==ROUND_UNNECESSARY} and
     *         the specified scale is insufficient to represent the result
     *         of the division exactly.
     * @throws IllegalArgumentException if {@code roundingMode} does not
     *         represent a valid rounding mode.
     * @see    #ROUND_UP
     * @see    #ROUND_DOWN
     * @see    #ROUND_CEILING
     * @see    #ROUND_FLOOR
     * @see    #ROUND_HALF_UP
     * @see    #ROUND_HALF_DOWN
     * @see    #ROUND_HALF_EVEN
     * @see    #ROUND_UNNECESSARY
     */
    public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) {
<span class="pc bpc" id="L1557" title="2 of 4 branches missed.">        if (roundingMode &lt; ROUND_UP || roundingMode &gt; ROUND_UNNECESSARY)</span>
<span class="nc" id="L1558">            throw new IllegalArgumentException(&quot;Invalid rounding mode&quot;);</span>
<span class="fc bfc" id="L1559" title="All 2 branches covered.">        if (this.intCompact != INFLATED) {</span>
<span class="pc bpc" id="L1560" title="1 of 2 branches missed.">            if ((divisor.intCompact != INFLATED)) {</span>
<span class="fc" id="L1561">                return divide(this.intCompact, this.scale, divisor.intCompact, divisor.scale, scale, roundingMode);</span>
            } else {
<span class="nc" id="L1563">                return divide(this.intCompact, this.scale, divisor.intVal, divisor.scale, scale, roundingMode);</span>
            }
        } else {
<span class="pc bpc" id="L1566" title="1 of 2 branches missed.">            if ((divisor.intCompact != INFLATED)) {</span>
<span class="fc" id="L1567">                return divide(this.intVal, this.scale, divisor.intCompact, divisor.scale, scale, roundingMode);</span>
            } else {
<span class="nc" id="L1569">                return divide(this.intVal, this.scale, divisor.intVal, divisor.scale, scale, roundingMode);</span>
            }
        }
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (this /
     * divisor)}, and whose scale is as specified.  If rounding must
     * be performed to generate a result with the specified scale, the
     * specified rounding mode is applied.
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided.
     * @param  scale scale of the {@code BigDecimal} quotient to be returned.
     * @param  roundingMode rounding mode to apply.
     * @return {@code this / divisor}
     * @throws ArithmeticException if {@code divisor} is zero,
     *         {@code roundingMode==RoundingMode.UNNECESSARY} and
     *         the specified scale is insufficient to represent the result
     *         of the division exactly.
     * @since 1.5
     */
    public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) {
<span class="fc" id="L1591">        return divide(divisor, scale, roundingMode.oldMode);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (this /
     * divisor)}, and whose scale is {@code this.scale()}.  If
     * rounding must be performed to generate a result with the given
     * scale, the specified rounding mode is applied.
     *
     * &lt;p&gt;The new {@link #divide(BigDecimal, RoundingMode)} method
     * should be used in preference to this legacy method.
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided.
     * @param  roundingMode rounding mode to apply.
     * @return {@code this / divisor}
     * @throws ArithmeticException if {@code divisor==0}, or
     *         {@code roundingMode==ROUND_UNNECESSARY} and
     *         {@code this.scale()} is insufficient to represent the result
     *         of the division exactly.
     * @throws IllegalArgumentException if {@code roundingMode} does not
     *         represent a valid rounding mode.
     * @see    #ROUND_UP
     * @see    #ROUND_DOWN
     * @see    #ROUND_CEILING
     * @see    #ROUND_FLOOR
     * @see    #ROUND_HALF_UP
     * @see    #ROUND_HALF_DOWN
     * @see    #ROUND_HALF_EVEN
     * @see    #ROUND_UNNECESSARY
     */
    public BigDecimal divide(BigDecimal divisor, int roundingMode) {
<span class="nc" id="L1622">        return this.divide(divisor, scale, roundingMode);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (this /
     * divisor)}, and whose scale is {@code this.scale()}.  If
     * rounding must be performed to generate a result with the given
     * scale, the specified rounding mode is applied.
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided.
     * @param  roundingMode rounding mode to apply.
     * @return {@code this / divisor}
     * @throws ArithmeticException if {@code divisor==0}, or
     *         {@code roundingMode==RoundingMode.UNNECESSARY} and
     *         {@code this.scale()} is insufficient to represent the result
     *         of the division exactly.
     * @since 1.5
     */
    public BigDecimal divide(BigDecimal divisor, RoundingMode roundingMode) {
<span class="fc" id="L1641">        return this.divide(divisor, scale, roundingMode.oldMode);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (this /
     * divisor)}, and whose preferred scale is {@code (this.scale() -
     * divisor.scale())}; if the exact quotient cannot be
     * represented (because it has a non-terminating decimal
     * expansion) an {@code ArithmeticException} is thrown.
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided.
     * @throws ArithmeticException if the exact quotient does not have a
     *         terminating decimal expansion
     * @return {@code this / divisor}
     * @since 1.5
     * @author Joseph D. Darcy
     */
    public BigDecimal divide(BigDecimal divisor) {
        /*
         * Handle zero cases first.
         */
<span class="pc bpc" id="L1662" title="1 of 2 branches missed.">        if (divisor.signum() == 0) {   // x/0</span>
<span class="nc bnc" id="L1663" title="All 2 branches missed.">            if (this.signum() == 0)    // 0/0</span>
<span class="nc" id="L1664">                throw new ArithmeticException(&quot;Division undefined&quot;);  // NaN</span>
<span class="nc" id="L1665">            throw new ArithmeticException(&quot;Division by zero&quot;);</span>
        }

        // Calculate preferred scale
<span class="fc" id="L1669">        int preferredScale = saturateLong((long) this.scale - divisor.scale);</span>

<span class="pc bpc" id="L1671" title="1 of 2 branches missed.">        if (this.signum() == 0) // 0/y</span>
<span class="nc" id="L1672">            return zeroValueOf(preferredScale);</span>
        else {
            /*
             * If the quotient this/divisor has a terminating decimal
             * expansion, the expansion can have no more than
             * (a.precision() + ceil(10*b.precision)/3) digits.
             * Therefore, create a MathContext object with this
             * precision and do a divide with the UNNECESSARY rounding
             * mode.
             */
<span class="fc" id="L1682">            MathContext mc = new MathContext( (int)Math.min(this.precision() +</span>
<span class="fc" id="L1683">                                                            (long)Math.ceil(10.0*divisor.precision()/3.0),</span>
                                                            Integer.MAX_VALUE),
                                              RoundingMode.UNNECESSARY);
            BigDecimal quotient;
            try {
<span class="fc" id="L1688">                quotient = this.divide(divisor, mc);</span>
<span class="nc" id="L1689">            } catch (ArithmeticException e) {</span>
<span class="nc" id="L1690">                throw new ArithmeticException(&quot;Non-terminating decimal expansion; &quot; +</span>
                                              &quot;no exact representable decimal result.&quot;);
<span class="fc" id="L1692">            }</span>

<span class="fc" id="L1694">            int quotientScale = quotient.scale();</span>

            // divide(BigDecimal, mc) tries to adjust the quotient to
            // the desired one by removing trailing zeros; since the
            // exact divide method does not have an explicit digit
            // limit, we can add zeros too.
<span class="pc bpc" id="L1700" title="1 of 2 branches missed.">            if (preferredScale &gt; quotientScale)</span>
<span class="nc" id="L1701">                return quotient.setScale(preferredScale, ROUND_UNNECESSARY);</span>

<span class="fc" id="L1703">            return quotient;</span>
        }
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (this /
     * divisor)}, with rounding according to the context settings.
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided.
     * @param  mc the context to use.
     * @return {@code this / divisor}, rounded as necessary.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY} or
     *         {@code mc.precision == 0} and the quotient has a
     *         non-terminating decimal expansion.
     * @since  1.5
     */
    public BigDecimal divide(BigDecimal divisor, MathContext mc) {
<span class="fc" id="L1721">        int mcp = mc.precision;</span>
<span class="pc bpc" id="L1722" title="1 of 2 branches missed.">        if (mcp == 0)</span>
<span class="nc" id="L1723">            return divide(divisor);</span>

<span class="fc" id="L1725">        BigDecimal dividend = this;</span>
<span class="fc" id="L1726">        long preferredScale = (long)dividend.scale - divisor.scale;</span>
        // Now calculate the answer.  We use the existing
        // divide-and-round method, but as this rounds to scale we have
        // to normalize the values here to achieve the desired result.
        // For x/y we first handle y=0 and x=0, and then normalize x and
        // y to give x' and y' with the following constraints:
        //   (a) 0.1 &lt;= x' &lt; 1
        //   (b)  x' &lt;= y' &lt; 10*x'
        // Dividing x'/y' with the required scale set to mc.precision then
        // will give a result in the range 0.1 to 1 rounded to exactly
        // the right number of digits (except in the case of a result of
        // 1.000... which can arise when x=y, or when rounding overflows
        // The 1.000... case will reduce properly to 1.
<span class="pc bpc" id="L1739" title="1 of 2 branches missed.">        if (divisor.signum() == 0) {      // x/0</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">            if (dividend.signum() == 0)    // 0/0</span>
<span class="nc" id="L1741">                throw new ArithmeticException(&quot;Division undefined&quot;);  // NaN</span>
<span class="nc" id="L1742">            throw new ArithmeticException(&quot;Division by zero&quot;);</span>
        }
<span class="pc bpc" id="L1744" title="1 of 2 branches missed.">        if (dividend.signum() == 0) // 0/y</span>
<span class="nc" id="L1745">            return zeroValueOf(saturateLong(preferredScale));</span>
<span class="fc" id="L1746">        int xscale = dividend.precision();</span>
<span class="fc" id="L1747">        int yscale = divisor.precision();</span>
<span class="fc bfc" id="L1748" title="All 2 branches covered.">        if(dividend.intCompact!=INFLATED) {</span>
<span class="fc bfc" id="L1749" title="All 2 branches covered.">            if(divisor.intCompact!=INFLATED) {</span>
<span class="fc" id="L1750">                return divide(dividend.intCompact, xscale, divisor.intCompact, yscale, preferredScale, mc);</span>
            } else {
<span class="fc" id="L1752">                return divide(dividend.intCompact, xscale, divisor.intVal, yscale, preferredScale, mc);</span>
            }
        } else {
<span class="fc bfc" id="L1755" title="All 2 branches covered.">            if(divisor.intCompact!=INFLATED) {</span>
<span class="fc" id="L1756">                return divide(dividend.intVal, xscale, divisor.intCompact, yscale, preferredScale, mc);</span>
            } else {
<span class="fc" id="L1758">                return divide(dividend.intVal, xscale, divisor.intVal, yscale, preferredScale, mc);</span>
            }
        }
    }

    /**
     * Returns a {@code BigDecimal} whose value is the integer part
     * of the quotient {@code (this / divisor)} rounded down.  The
     * preferred scale of the result is {@code (this.scale() -
     * divisor.scale())}.
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided.
     * @return The integer part of {@code this / divisor}.
     * @throws ArithmeticException if {@code divisor==0}
     * @since  1.5
     */
    public BigDecimal divideToIntegralValue(BigDecimal divisor) {
        // Calculate preferred scale
<span class="nc" id="L1776">        int preferredScale = saturateLong((long) this.scale - divisor.scale);</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">        if (this.compareMagnitude(divisor) &lt; 0) {</span>
            // much faster when this &lt;&lt; divisor
<span class="nc" id="L1779">            return zeroValueOf(preferredScale);</span>
        }

<span class="nc bnc" id="L1782" title="All 4 branches missed.">        if (this.signum() == 0 &amp;&amp; divisor.signum() != 0)</span>
<span class="nc" id="L1783">            return this.setScale(preferredScale, ROUND_UNNECESSARY);</span>

        // Perform a divide with enough digits to round to a correct
        // integer value; then remove any fractional digits

<span class="nc" id="L1788">        int maxDigits = (int)Math.min(this.precision() +</span>
<span class="nc" id="L1789">                                      (long)Math.ceil(10.0*divisor.precision()/3.0) +</span>
<span class="nc" id="L1790">                                      Math.abs((long)this.scale() - divisor.scale()) + 2,</span>
                                      Integer.MAX_VALUE);
<span class="nc" id="L1792">        BigDecimal quotient = this.divide(divisor, new MathContext(maxDigits,</span>
                                                                   RoundingMode.DOWN));
<span class="nc bnc" id="L1794" title="All 2 branches missed.">        if (quotient.scale &gt; 0) {</span>
<span class="nc" id="L1795">            quotient = quotient.setScale(0, RoundingMode.DOWN);</span>
<span class="nc" id="L1796">            quotient = stripZerosToMatchScale(quotient.intVal, quotient.intCompact, quotient.scale, preferredScale);</span>
        }

<span class="nc bnc" id="L1799" title="All 2 branches missed.">        if (quotient.scale &lt; preferredScale) {</span>
            // pad with zeros if necessary
<span class="nc" id="L1801">            quotient = quotient.setScale(preferredScale, ROUND_UNNECESSARY);</span>
        }

<span class="nc" id="L1804">        return quotient;</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is the integer part
     * of {@code (this / divisor)}.  Since the integer part of the
     * exact quotient does not depend on the rounding mode, the
     * rounding mode does not affect the values returned by this
     * method.  The preferred scale of the result is
     * {@code (this.scale() - divisor.scale())}.  An
     * {@code ArithmeticException} is thrown if the integer part of
     * the exact quotient needs more than {@code mc.precision}
     * digits.
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided.
     * @param  mc the context to use.
     * @return The integer part of {@code this / divisor}.
     * @throws ArithmeticException if {@code divisor==0}
     * @throws ArithmeticException if {@code mc.precision} {@literal &gt;} 0 and the result
     *         requires a precision of more than {@code mc.precision} digits.
     * @since  1.5
     * @author Joseph D. Darcy
     */
    public BigDecimal divideToIntegralValue(BigDecimal divisor, MathContext mc) {
<span class="nc bnc" id="L1828" title="All 2 branches missed.">        if (mc.precision == 0 || // exact result</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">            (this.compareMagnitude(divisor) &lt; 0)) // zero result</span>
<span class="nc" id="L1830">            return divideToIntegralValue(divisor);</span>

        // Calculate preferred scale
<span class="nc" id="L1833">        int preferredScale = saturateLong((long)this.scale - divisor.scale);</span>

        /*
         * Perform a normal divide to mc.precision digits.  If the
         * remainder has absolute value less than the divisor, the
         * integer portion of the quotient fits into mc.precision
         * digits.  Next, remove any fractional digits from the
         * quotient and adjust the scale to the preferred value.
         */
<span class="nc" id="L1842">        BigDecimal result = this.divide(divisor, new MathContext(mc.precision, RoundingMode.DOWN));</span>

<span class="nc bnc" id="L1844" title="All 2 branches missed.">        if (result.scale() &lt; 0) {</span>
            /*
             * Result is an integer. See if quotient represents the
             * full integer portion of the exact quotient; if it does,
             * the computed remainder will be less than the divisor.
             */
<span class="nc" id="L1850">            BigDecimal product = result.multiply(divisor);</span>
            // If the quotient is the full integer value,
            // |dividend-product| &lt; |divisor|.
<span class="nc bnc" id="L1853" title="All 2 branches missed.">            if (this.subtract(product).compareMagnitude(divisor) &gt;= 0) {</span>
<span class="nc" id="L1854">                throw new ArithmeticException(&quot;Division impossible&quot;);</span>
            }
<span class="nc bnc" id="L1856" title="All 2 branches missed.">        } else if (result.scale() &gt; 0) {</span>
            /*
             * Integer portion of quotient will fit into precision
             * digits; recompute quotient to scale 0 to avoid double
             * rounding and then try to adjust, if necessary.
             */
<span class="nc" id="L1862">            result = result.setScale(0, RoundingMode.DOWN);</span>
        }
        // else result.scale() == 0;

        int precisionDiff;
<span class="nc bnc" id="L1867" title="All 2 branches missed.">        if ((preferredScale &gt; result.scale()) &amp;&amp;</span>
<span class="nc bnc" id="L1868" title="All 2 branches missed.">            (precisionDiff = mc.precision - result.precision()) &gt; 0) {</span>
<span class="nc" id="L1869">            return result.setScale(result.scale() +</span>
<span class="nc" id="L1870">                                   Math.min(precisionDiff, preferredScale - result.scale) );</span>
        } else {
<span class="nc" id="L1872">            return stripZerosToMatchScale(result.intVal,result.intCompact,result.scale,preferredScale);</span>
        }
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (this % divisor)}.
     *
     * &lt;p&gt;The remainder is given by
     * {@code this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))}.
     * Note that this is not the modulo operation (the result can be
     * negative).
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided.
     * @return {@code this % divisor}.
     * @throws ArithmeticException if {@code divisor==0}
     * @since  1.5
     */
    public BigDecimal remainder(BigDecimal divisor) {
<span class="nc" id="L1890">        BigDecimal divrem[] = this.divideAndRemainder(divisor);</span>
<span class="nc" id="L1891">        return divrem[1];</span>
    }


    /**
     * Returns a {@code BigDecimal} whose value is {@code (this %
     * divisor)}, with rounding according to the context settings.
     * The {@code MathContext} settings affect the implicit divide
     * used to compute the remainder.  The remainder computation
     * itself is by definition exact.  Therefore, the remainder may
     * contain more than {@code mc.getPrecision()} digits.
     *
     * &lt;p&gt;The remainder is given by
     * {@code this.subtract(this.divideToIntegralValue(divisor,
     * mc).multiply(divisor))}.  Note that this is not the modulo
     * operation (the result can be negative).
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided.
     * @param  mc the context to use.
     * @return {@code this % divisor}, rounded as necessary.
     * @throws ArithmeticException if {@code divisor==0}
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}, or {@code mc.precision}
     *         {@literal &gt;} 0 and the result of {@code this.divideToIntgralValue(divisor)} would
     *         require a precision of more than {@code mc.precision} digits.
     * @see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
     * @since  1.5
     */
    public BigDecimal remainder(BigDecimal divisor, MathContext mc) {
<span class="nc" id="L1920">        BigDecimal divrem[] = this.divideAndRemainder(divisor, mc);</span>
<span class="nc" id="L1921">        return divrem[1];</span>
    }

    /**
     * Returns a two-element {@code BigDecimal} array containing the
     * result of {@code divideToIntegralValue} followed by the result of
     * {@code remainder} on the two operands.
     *
     * &lt;p&gt;Note that if both the integer quotient and remainder are
     * needed, this method is faster than using the
     * {@code divideToIntegralValue} and {@code remainder} methods
     * separately because the division need only be carried out once.
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided,
     *         and the remainder computed.
     * @return a two element {@code BigDecimal} array: the quotient
     *         (the result of {@code divideToIntegralValue}) is the initial element
     *         and the remainder is the final element.
     * @throws ArithmeticException if {@code divisor==0}
     * @see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
     * @see    #remainder(java.math.BigDecimal, java.math.MathContext)
     * @since  1.5
     */
    public BigDecimal[] divideAndRemainder(BigDecimal divisor) {
        // we use the identity  x = i * y + r to determine r
<span class="nc" id="L1946">        BigDecimal[] result = new BigDecimal[2];</span>

<span class="nc" id="L1948">        result[0] = this.divideToIntegralValue(divisor);</span>
<span class="nc" id="L1949">        result[1] = this.subtract(result[0].multiply(divisor));</span>
<span class="nc" id="L1950">        return result;</span>
    }

    /**
     * Returns a two-element {@code BigDecimal} array containing the
     * result of {@code divideToIntegralValue} followed by the result of
     * {@code remainder} on the two operands calculated with rounding
     * according to the context settings.
     *
     * &lt;p&gt;Note that if both the integer quotient and remainder are
     * needed, this method is faster than using the
     * {@code divideToIntegralValue} and {@code remainder} methods
     * separately because the division need only be carried out once.
     *
     * @param  divisor value by which this {@code BigDecimal} is to be divided,
     *         and the remainder computed.
     * @param  mc the context to use.
     * @return a two element {@code BigDecimal} array: the quotient
     *         (the result of {@code divideToIntegralValue}) is the
     *         initial element and the remainder is the final element.
     * @throws ArithmeticException if {@code divisor==0}
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}, or {@code mc.precision}
     *         {@literal &gt;} 0 and the result of {@code this.divideToIntgralValue(divisor)} would
     *         require a precision of more than {@code mc.precision} digits.
     * @see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
     * @see    #remainder(java.math.BigDecimal, java.math.MathContext)
     * @since  1.5
     */
    public BigDecimal[] divideAndRemainder(BigDecimal divisor, MathContext mc) {
<span class="nc bnc" id="L1980" title="All 2 branches missed.">        if (mc.precision == 0)</span>
<span class="nc" id="L1981">            return divideAndRemainder(divisor);</span>

<span class="nc" id="L1983">        BigDecimal[] result = new BigDecimal[2];</span>
<span class="nc" id="L1984">        BigDecimal lhs = this;</span>

<span class="nc" id="L1986">        result[0] = lhs.divideToIntegralValue(divisor, mc);</span>
<span class="nc" id="L1987">        result[1] = lhs.subtract(result[0].multiply(divisor));</span>
<span class="nc" id="L1988">        return result;</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is
     * &lt;tt&gt;(this&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt;, The power is computed exactly, to
     * unlimited precision.
     *
     * &lt;p&gt;The parameter {@code n} must be in the range 0 through
     * 999999999, inclusive.  {@code ZERO.pow(0)} returns {@link
     * #ONE}.
     *
     * Note that future releases may expand the allowable exponent
     * range of this method.
     *
     * @param  n power to raise this {@code BigDecimal} to.
     * @return &lt;tt&gt;this&lt;sup&gt;n&lt;/sup&gt;&lt;/tt&gt;
     * @throws ArithmeticException if {@code n} is out of range.
     * @since  1.5
     */
    public BigDecimal pow(int n) {
<span class="pc bpc" id="L2009" title="2 of 4 branches missed.">        if (n &lt; 0 || n &gt; 999999999)</span>
<span class="nc" id="L2010">            throw new ArithmeticException(&quot;Invalid operation&quot;);</span>
        // No need to calculate pow(n) if result will over/underflow.
        // Don't attempt to support &quot;supernormal&quot; numbers.
<span class="fc" id="L2013">        int newScale = checkScale((long)scale * n);</span>
<span class="fc" id="L2014">        return new BigDecimal(this.inflated().pow(n), newScale);</span>
    }


    /**
     * Returns a {@code BigDecimal} whose value is
     * &lt;tt&gt;(this&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt;.  The current implementation uses
     * the core algorithm defined in ANSI standard X3.274-1996 with
     * rounding according to the context settings.  In general, the
     * returned numerical value is within two ulps of the exact
     * numerical value for the chosen precision.  Note that future
     * releases may use a different algorithm with a decreased
     * allowable error bound and increased allowable exponent range.
     *
     * &lt;p&gt;The X3.274-1996 algorithm is:
     *
     * &lt;ul&gt;
     * &lt;li&gt; An {@code ArithmeticException} exception is thrown if
     *  &lt;ul&gt;
     *    &lt;li&gt;{@code abs(n) &gt; 999999999}
     *    &lt;li&gt;{@code mc.precision == 0} and {@code n &lt; 0}
     *    &lt;li&gt;{@code mc.precision &gt; 0} and {@code n} has more than
     *    {@code mc.precision} decimal digits
     *  &lt;/ul&gt;
     *
     * &lt;li&gt; if {@code n} is zero, {@link #ONE} is returned even if
     * {@code this} is zero, otherwise
     * &lt;ul&gt;
     *   &lt;li&gt; if {@code n} is positive, the result is calculated via
     *   the repeated squaring technique into a single accumulator.
     *   The individual multiplications with the accumulator use the
     *   same math context settings as in {@code mc} except for a
     *   precision increased to {@code mc.precision + elength + 1}
     *   where {@code elength} is the number of decimal digits in
     *   {@code n}.
     *
     *   &lt;li&gt; if {@code n} is negative, the result is calculated as if
     *   {@code n} were positive; this value is then divided into one
     *   using the working precision specified above.
     *
     *   &lt;li&gt; The final value from either the positive or negative case
     *   is then rounded to the destination precision.
     *   &lt;/ul&gt;
     * &lt;/ul&gt;
     *
     * @param  n power to raise this {@code BigDecimal} to.
     * @param  mc the context to use.
     * @return &lt;tt&gt;this&lt;sup&gt;n&lt;/sup&gt;&lt;/tt&gt; using the ANSI standard X3.274-1996
     *         algorithm
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}, or {@code n} is out
     *         of range.
     * @since  1.5
     */
    public BigDecimal pow(int n, MathContext mc) {
<span class="nc bnc" id="L2069" title="All 2 branches missed.">        if (mc.precision == 0)</span>
<span class="nc" id="L2070">            return pow(n);</span>
<span class="nc bnc" id="L2071" title="All 4 branches missed.">        if (n &lt; -999999999 || n &gt; 999999999)</span>
<span class="nc" id="L2072">            throw new ArithmeticException(&quot;Invalid operation&quot;);</span>
<span class="nc bnc" id="L2073" title="All 2 branches missed.">        if (n == 0)</span>
<span class="nc" id="L2074">            return ONE;                      // x**0 == 1 in X3.274</span>
<span class="nc" id="L2075">        BigDecimal lhs = this;</span>
<span class="nc" id="L2076">        MathContext workmc = mc;           // working settings</span>
<span class="nc" id="L2077">        int mag = Math.abs(n);               // magnitude of n</span>
<span class="nc bnc" id="L2078" title="All 2 branches missed.">        if (mc.precision &gt; 0) {</span>
<span class="nc" id="L2079">            int elength = longDigitLength(mag); // length of n in digits</span>
<span class="nc bnc" id="L2080" title="All 2 branches missed.">            if (elength &gt; mc.precision)        // X3.274 rule</span>
<span class="nc" id="L2081">                throw new ArithmeticException(&quot;Invalid operation&quot;);</span>
<span class="nc" id="L2082">            workmc = new MathContext(mc.precision + elength + 1,</span>
                                      mc.roundingMode);
        }
        // ready to carry out power calculation...
<span class="nc" id="L2086">        BigDecimal acc = ONE;           // accumulator</span>
<span class="nc" id="L2087">        boolean seenbit = false;        // set once we've seen a 1-bit</span>
<span class="nc" id="L2088">        for (int i=1;;i++) {            // for each bit [top bit ignored]</span>
<span class="nc" id="L2089">            mag += mag;                 // shift left 1 bit</span>
<span class="nc bnc" id="L2090" title="All 2 branches missed.">            if (mag &lt; 0) {              // top bit is set</span>
<span class="nc" id="L2091">                seenbit = true;         // OK, we're off</span>
<span class="nc" id="L2092">                acc = acc.multiply(lhs, workmc); // acc=acc*x</span>
            }
<span class="nc bnc" id="L2094" title="All 2 branches missed.">            if (i == 31)</span>
<span class="nc" id="L2095">                break;                  // that was the last bit</span>
<span class="nc bnc" id="L2096" title="All 2 branches missed.">            if (seenbit)</span>
<span class="nc" id="L2097">                acc=acc.multiply(acc, workmc);   // acc=acc*acc [square]</span>
                // else (!seenbit) no point in squaring ONE
        }
        // if negative n, calculate the reciprocal using working precision
<span class="nc bnc" id="L2101" title="All 2 branches missed.">        if (n &lt; 0) // [hence mc.precision&gt;0]</span>
<span class="nc" id="L2102">            acc=ONE.divide(acc, workmc);</span>
        // round to final precision and strip zeros
<span class="nc" id="L2104">        return doRound(acc, mc);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is the absolute value
     * of this {@code BigDecimal}, and whose scale is
     * {@code this.scale()}.
     *
     * @return {@code abs(this)}
     */
    public BigDecimal abs() {
<span class="fc bfc" id="L2115" title="All 2 branches covered.">        return (signum() &lt; 0 ? negate() : this);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is the absolute value
     * of this {@code BigDecimal}, with rounding according to the
     * context settings.
     *
     * @param mc the context to use.
     * @return {@code abs(this)}, rounded as necessary.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @since 1.5
     */
    public BigDecimal abs(MathContext mc) {
<span class="fc bfc" id="L2130" title="All 2 branches covered.">        return (signum() &lt; 0 ? negate(mc) : plus(mc));</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (-this)},
     * and whose scale is {@code this.scale()}.
     *
     * @return {@code -this}.
     */
    public BigDecimal negate() {
<span class="fc bfc" id="L2140" title="All 2 branches covered.">        if (intCompact == INFLATED) {</span>
<span class="fc" id="L2141">            return new BigDecimal(intVal.negate(), INFLATED, scale, precision);</span>
        } else {
<span class="fc" id="L2143">            return valueOf(-intCompact, scale, precision);</span>
        }
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (-this)},
     * with rounding according to the context settings.
     *
     * @param mc the context to use.
     * @return {@code -this}, rounded as necessary.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @since  1.5
     */
    public BigDecimal negate(MathContext mc) {
<span class="fc" id="L2158">        return negate().plus(mc);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (+this)}, and whose
     * scale is {@code this.scale()}.
     *
     * &lt;p&gt;This method, which simply returns this {@code BigDecimal}
     * is included for symmetry with the unary minus method {@link
     * #negate()}.
     *
     * @return {@code this}.
     * @see #negate()
     * @since  1.5
     */
    public BigDecimal plus() {
<span class="nc" id="L2174">        return this;</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (+this)},
     * with rounding according to the context settings.
     *
     * &lt;p&gt;The effect of this method is identical to that of the {@link
     * #round(MathContext)} method.
     *
     * @param mc the context to use.
     * @return {@code this}, rounded as necessary.  A zero result will
     *         have a scale of 0.
     * @throws ArithmeticException if the result is inexact but the
     *         rounding mode is {@code UNNECESSARY}.
     * @see    #round(MathContext)
     * @since  1.5
     */
    public BigDecimal plus(MathContext mc) {
<span class="fc bfc" id="L2193" title="All 2 branches covered.">        if (mc.precision == 0)                 // no rounding please</span>
<span class="fc" id="L2194">            return this;</span>
<span class="fc" id="L2195">        return doRound(this, mc);</span>
    }

    /**
     * Returns the signum function of this {@code BigDecimal}.
     *
     * @return -1, 0, or 1 as the value of this {@code BigDecimal}
     *         is negative, zero, or positive.
     */
    public int signum() {
<span class="fc bfc" id="L2205" title="All 2 branches covered.">        return (intCompact != INFLATED)?</span>
<span class="fc" id="L2206">            Long.signum(intCompact):</span>
<span class="fc" id="L2207">            intVal.signum();</span>
    }

    /**
     * Returns the &lt;i&gt;scale&lt;/i&gt; of this {@code BigDecimal}.  If zero
     * or positive, the scale is the number of digits to the right of
     * the decimal point.  If negative, the unscaled value of the
     * number is multiplied by ten to the power of the negation of the
     * scale.  For example, a scale of {@code -3} means the unscaled
     * value is multiplied by 1000.
     *
     * @return the scale of this {@code BigDecimal}.
     */
    public int scale() {
<span class="fc" id="L2221">        return scale;</span>
    }

    /**
     * Returns the &lt;i&gt;precision&lt;/i&gt; of this {@code BigDecimal}.  (The
     * precision is the number of digits in the unscaled value.)
     *
     * &lt;p&gt;The precision of a zero value is 1.
     *
     * @return the precision of this {@code BigDecimal}.
     * @since  1.5
     */
    public int precision() {
<span class="fc" id="L2234">        int result = precision;</span>
<span class="fc bfc" id="L2235" title="All 2 branches covered.">        if (result == 0) {</span>
<span class="fc" id="L2236">            long s = intCompact;</span>
<span class="fc bfc" id="L2237" title="All 2 branches covered.">            if (s != INFLATED)</span>
<span class="fc" id="L2238">                result = longDigitLength(s);</span>
            else
<span class="fc" id="L2240">                result = bigDigitLength(intVal);</span>
<span class="fc" id="L2241">            precision = result;</span>
        }
<span class="fc" id="L2243">        return result;</span>
    }


    /**
     * Returns a {@code BigInteger} whose value is the &lt;i&gt;unscaled
     * value&lt;/i&gt; of this {@code BigDecimal}.  (Computes &lt;tt&gt;(this *
     * 10&lt;sup&gt;this.scale()&lt;/sup&gt;)&lt;/tt&gt;.)
     *
     * @return the unscaled value of this {@code BigDecimal}.
     * @since  1.2
     */
    public BigInteger unscaledValue() {
<span class="fc" id="L2256">        return this.inflated();</span>
    }

    // Rounding Modes

    /**
     * Rounding mode to round away from zero.  Always increments the
     * digit prior to a nonzero discarded fraction.  Note that this rounding
     * mode never decreases the magnitude of the calculated value.
     */
    public final static int ROUND_UP =           0;

    /**
     * Rounding mode to round towards zero.  Never increments the digit
     * prior to a discarded fraction (i.e., truncates).  Note that this
     * rounding mode never increases the magnitude of the calculated value.
     */
    public final static int ROUND_DOWN =         1;

    /**
     * Rounding mode to round towards positive infinity.  If the
     * {@code BigDecimal} is positive, behaves as for
     * {@code ROUND_UP}; if negative, behaves as for
     * {@code ROUND_DOWN}.  Note that this rounding mode never
     * decreases the calculated value.
     */
    public final static int ROUND_CEILING =      2;

    /**
     * Rounding mode to round towards negative infinity.  If the
     * {@code BigDecimal} is positive, behave as for
     * {@code ROUND_DOWN}; if negative, behave as for
     * {@code ROUND_UP}.  Note that this rounding mode never
     * increases the calculated value.
     */
    public final static int ROUND_FLOOR =        3;

    /**
     * Rounding mode to round towards {@literal &quot;nearest neighbor&quot;}
     * unless both neighbors are equidistant, in which case round up.
     * Behaves as for {@code ROUND_UP} if the discarded fraction is
     * &amp;ge; 0.5; otherwise, behaves as for {@code ROUND_DOWN}.  Note
     * that this is the rounding mode that most of us were taught in
     * grade school.
     */
    public final static int ROUND_HALF_UP =      4;

    /**
     * Rounding mode to round towards {@literal &quot;nearest neighbor&quot;}
     * unless both neighbors are equidistant, in which case round
     * down.  Behaves as for {@code ROUND_UP} if the discarded
     * fraction is {@literal &gt;} 0.5; otherwise, behaves as for
     * {@code ROUND_DOWN}.
     */
    public final static int ROUND_HALF_DOWN =    5;

    /**
     * Rounding mode to round towards the {@literal &quot;nearest neighbor&quot;}
     * unless both neighbors are equidistant, in which case, round
     * towards the even neighbor.  Behaves as for
     * {@code ROUND_HALF_UP} if the digit to the left of the
     * discarded fraction is odd; behaves as for
     * {@code ROUND_HALF_DOWN} if it's even.  Note that this is the
     * rounding mode that minimizes cumulative error when applied
     * repeatedly over a sequence of calculations.
     */
    public final static int ROUND_HALF_EVEN =    6;

    /**
     * Rounding mode to assert that the requested operation has an exact
     * result, hence no rounding is necessary.  If this rounding mode is
     * specified on an operation that yields an inexact result, an
     * {@code ArithmeticException} is thrown.
     */
    public final static int ROUND_UNNECESSARY =  7;


    // Scaling/Rounding Operations

    /**
     * Returns a {@code BigDecimal} rounded according to the
     * {@code MathContext} settings.  If the precision setting is 0 then
     * no rounding takes place.
     *
     * &lt;p&gt;The effect of this method is identical to that of the
     * {@link #plus(MathContext)} method.
     *
     * @param mc the context to use.
     * @return a {@code BigDecimal} rounded according to the
     *         {@code MathContext} settings.
     * @throws ArithmeticException if the rounding mode is
     *         {@code UNNECESSARY} and the
     *         {@code BigDecimal}  operation would require rounding.
     * @see    #plus(MathContext)
     * @since  1.5
     */
    public BigDecimal round(MathContext mc) {
<span class="fc" id="L2353">        return plus(mc);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose scale is the specified
     * value, and whose unscaled value is determined by multiplying or
     * dividing this {@code BigDecimal}'s unscaled value by the
     * appropriate power of ten to maintain its overall value.  If the
     * scale is reduced by the operation, the unscaled value must be
     * divided (rather than multiplied), and the value may be changed;
     * in this case, the specified rounding mode is applied to the
     * division.
     *
     * &lt;p&gt;Note that since BigDecimal objects are immutable, calls of
     * this method do &lt;i&gt;not&lt;/i&gt; result in the original object being
     * modified, contrary to the usual convention of having methods
     * named &lt;tt&gt;set&lt;i&gt;X&lt;/i&gt;&lt;/tt&gt; mutate field &lt;i&gt;{@code X}&lt;/i&gt;.
     * Instead, {@code setScale} returns an object with the proper
     * scale; the returned object may or may not be newly allocated.
     *
     * @param  newScale scale of the {@code BigDecimal} value to be returned.
     * @param  roundingMode The rounding mode to apply.
     * @return a {@code BigDecimal} whose scale is the specified value,
     *         and whose unscaled value is determined by multiplying or
     *         dividing this {@code BigDecimal}'s unscaled value by the
     *         appropriate power of ten to maintain its overall value.
     * @throws ArithmeticException if {@code roundingMode==UNNECESSARY}
     *         and the specified scaling operation would require
     *         rounding.
     * @see    RoundingMode
     * @since  1.5
     */
    public BigDecimal setScale(int newScale, RoundingMode roundingMode) {
<span class="fc" id="L2386">        return setScale(newScale, roundingMode.oldMode);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose scale is the specified
     * value, and whose unscaled value is determined by multiplying or
     * dividing this {@code BigDecimal}'s unscaled value by the
     * appropriate power of ten to maintain its overall value.  If the
     * scale is reduced by the operation, the unscaled value must be
     * divided (rather than multiplied), and the value may be changed;
     * in this case, the specified rounding mode is applied to the
     * division.
     *
     * &lt;p&gt;Note that since BigDecimal objects are immutable, calls of
     * this method do &lt;i&gt;not&lt;/i&gt; result in the original object being
     * modified, contrary to the usual convention of having methods
     * named &lt;tt&gt;set&lt;i&gt;X&lt;/i&gt;&lt;/tt&gt; mutate field &lt;i&gt;{@code X}&lt;/i&gt;.
     * Instead, {@code setScale} returns an object with the proper
     * scale; the returned object may or may not be newly allocated.
     *
     * &lt;p&gt;The new {@link #setScale(int, RoundingMode)} method should
     * be used in preference to this legacy method.
     *
     * @param  newScale scale of the {@code BigDecimal} value to be returned.
     * @param  roundingMode The rounding mode to apply.
     * @return a {@code BigDecimal} whose scale is the specified value,
     *         and whose unscaled value is determined by multiplying or
     *         dividing this {@code BigDecimal}'s unscaled value by the
     *         appropriate power of ten to maintain its overall value.
     * @throws ArithmeticException if {@code roundingMode==ROUND_UNNECESSARY}
     *         and the specified scaling operation would require
     *         rounding.
     * @throws IllegalArgumentException if {@code roundingMode} does not
     *         represent a valid rounding mode.
     * @see    #ROUND_UP
     * @see    #ROUND_DOWN
     * @see    #ROUND_CEILING
     * @see    #ROUND_FLOOR
     * @see    #ROUND_HALF_UP
     * @see    #ROUND_HALF_DOWN
     * @see    #ROUND_HALF_EVEN
     * @see    #ROUND_UNNECESSARY
     */
    public BigDecimal setScale(int newScale, int roundingMode) {
<span class="pc bpc" id="L2430" title="2 of 4 branches missed.">        if (roundingMode &lt; ROUND_UP || roundingMode &gt; ROUND_UNNECESSARY)</span>
<span class="nc" id="L2431">            throw new IllegalArgumentException(&quot;Invalid rounding mode&quot;);</span>

<span class="fc" id="L2433">        int oldScale = this.scale;</span>
<span class="fc bfc" id="L2434" title="All 2 branches covered.">        if (newScale == oldScale)        // easy case</span>
<span class="fc" id="L2435">            return this;</span>
<span class="pc bpc" id="L2436" title="1 of 2 branches missed.">        if (this.signum() == 0)            // zero can have any scale</span>
<span class="nc" id="L2437">            return zeroValueOf(newScale);</span>
<span class="fc bfc" id="L2438" title="All 2 branches covered.">        if(this.intCompact!=INFLATED) {</span>
<span class="fc" id="L2439">            long rs = this.intCompact;</span>
<span class="pc bpc" id="L2440" title="1 of 2 branches missed.">            if (newScale &gt; oldScale) {</span>
<span class="nc" id="L2441">                int raise = checkScale((long) newScale - oldScale);</span>
<span class="nc bnc" id="L2442" title="All 2 branches missed.">                if ((rs = longMultiplyPowerTen(rs, raise)) != INFLATED) {</span>
<span class="nc" id="L2443">                    return valueOf(rs,newScale);</span>
                }
<span class="nc" id="L2445">                BigInteger rb = bigMultiplyPowerTen(raise);</span>
<span class="nc bnc" id="L2446" title="All 2 branches missed.">                return new BigDecimal(rb, INFLATED, newScale, (precision &gt; 0) ? precision + raise : 0);</span>
            } else {
                // newScale &lt; oldScale -- drop some digits
                // Can't predict the precision due to the effect of rounding.
<span class="fc" id="L2450">                int drop = checkScale((long) oldScale - newScale);</span>
<span class="pc bpc" id="L2451" title="1 of 2 branches missed.">                if (drop &lt; LONG_TEN_POWERS_TABLE.length) {</span>
<span class="fc" id="L2452">                    return divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], newScale, roundingMode, newScale);</span>
                } else {
<span class="nc" id="L2454">                    return divideAndRound(this.inflated(), bigTenToThe(drop), newScale, roundingMode, newScale);</span>
                }
            }
        } else {
<span class="pc bpc" id="L2458" title="1 of 2 branches missed.">            if (newScale &gt; oldScale) {</span>
<span class="nc" id="L2459">                int raise = checkScale((long) newScale - oldScale);</span>
<span class="nc" id="L2460">                BigInteger rb = bigMultiplyPowerTen(this.intVal,raise);</span>
<span class="nc bnc" id="L2461" title="All 2 branches missed.">                return new BigDecimal(rb, INFLATED, newScale, (precision &gt; 0) ? precision + raise : 0);</span>
            } else {
                // newScale &lt; oldScale -- drop some digits
                // Can't predict the precision due to the effect of rounding.
<span class="fc" id="L2465">                int drop = checkScale((long) oldScale - newScale);</span>
<span class="pc bpc" id="L2466" title="1 of 2 branches missed.">                if (drop &lt; LONG_TEN_POWERS_TABLE.length)</span>
<span class="nc" id="L2467">                    return divideAndRound(this.intVal, LONG_TEN_POWERS_TABLE[drop], newScale, roundingMode,</span>
                                          newScale);
                else
<span class="fc" id="L2470">                    return divideAndRound(this.intVal,  bigTenToThe(drop), newScale, roundingMode, newScale);</span>
            }
        }
    }

    /**
     * Returns a {@code BigDecimal} whose scale is the specified
     * value, and whose value is numerically equal to this
     * {@code BigDecimal}'s.  Throws an {@code ArithmeticException}
     * if this is not possible.
     *
     * &lt;p&gt;This call is typically used to increase the scale, in which
     * case it is guaranteed that there exists a {@code BigDecimal}
     * of the specified scale and the correct value.  The call can
     * also be used to reduce the scale if the caller knows that the
     * {@code BigDecimal} has sufficiently many zeros at the end of
     * its fractional part (i.e., factors of ten in its integer value)
     * to allow for the rescaling without changing its value.
     *
     * &lt;p&gt;This method returns the same result as the two-argument
     * versions of {@code setScale}, but saves the caller the trouble
     * of specifying a rounding mode in cases where it is irrelevant.
     *
     * &lt;p&gt;Note that since {@code BigDecimal} objects are immutable,
     * calls of this method do &lt;i&gt;not&lt;/i&gt; result in the original
     * object being modified, contrary to the usual convention of
     * having methods named &lt;tt&gt;set&lt;i&gt;X&lt;/i&gt;&lt;/tt&gt; mutate field
     * &lt;i&gt;{@code X}&lt;/i&gt;.  Instead, {@code setScale} returns an
     * object with the proper scale; the returned object may or may
     * not be newly allocated.
     *
     * @param  newScale scale of the {@code BigDecimal} value to be returned.
     * @return a {@code BigDecimal} whose scale is the specified value, and
     *         whose unscaled value is determined by multiplying or dividing
     *         this {@code BigDecimal}'s unscaled value by the appropriate
     *         power of ten to maintain its overall value.
     * @throws ArithmeticException if the specified scaling operation would
     *         require rounding.
     * @see    #setScale(int, int)
     * @see    #setScale(int, RoundingMode)
     */
    public BigDecimal setScale(int newScale) {
<span class="nc" id="L2512">        return setScale(newScale, ROUND_UNNECESSARY);</span>
    }

    // Decimal Point Motion Operations

    /**
     * Returns a {@code BigDecimal} which is equivalent to this one
     * with the decimal point moved {@code n} places to the left.  If
     * {@code n} is non-negative, the call merely adds {@code n} to
     * the scale.  If {@code n} is negative, the call is equivalent
     * to {@code movePointRight(-n)}.  The {@code BigDecimal}
     * returned by this call has value &lt;tt&gt;(this &amp;times;
     * 10&lt;sup&gt;-n&lt;/sup&gt;)&lt;/tt&gt; and scale {@code max(this.scale()+n,
     * 0)}.
     *
     * @param  n number of places to move the decimal point to the left.
     * @return a {@code BigDecimal} which is equivalent to this one with the
     *         decimal point moved {@code n} places to the left.
     * @throws ArithmeticException if scale overflows.
     */
    public BigDecimal movePointLeft(int n) {
        // Cannot use movePointRight(-n) in case of n==Integer.MIN_VALUE
<span class="nc" id="L2534">        int newScale = checkScale((long)scale + n);</span>
<span class="nc" id="L2535">        BigDecimal num = new BigDecimal(intVal, intCompact, newScale, 0);</span>
<span class="nc bnc" id="L2536" title="All 2 branches missed.">        return num.scale &lt; 0 ? num.setScale(0, ROUND_UNNECESSARY) : num;</span>
    }

    /**
     * Returns a {@code BigDecimal} which is equivalent to this one
     * with the decimal point moved {@code n} places to the right.
     * If {@code n} is non-negative, the call merely subtracts
     * {@code n} from the scale.  If {@code n} is negative, the call
     * is equivalent to {@code movePointLeft(-n)}.  The
     * {@code BigDecimal} returned by this call has value &lt;tt&gt;(this
     * &amp;times; 10&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt; and scale {@code max(this.scale()-n,
     * 0)}.
     *
     * @param  n number of places to move the decimal point to the right.
     * @return a {@code BigDecimal} which is equivalent to this one
     *         with the decimal point moved {@code n} places to the right.
     * @throws ArithmeticException if scale overflows.
     */
    public BigDecimal movePointRight(int n) {
        // Cannot use movePointLeft(-n) in case of n==Integer.MIN_VALUE
<span class="nc" id="L2556">        int newScale = checkScale((long)scale - n);</span>
<span class="nc" id="L2557">        BigDecimal num = new BigDecimal(intVal, intCompact, newScale, 0);</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">        return num.scale &lt; 0 ? num.setScale(0, ROUND_UNNECESSARY) : num;</span>
    }

    /**
     * Returns a BigDecimal whose numerical value is equal to
     * ({@code this} * 10&lt;sup&gt;n&lt;/sup&gt;).  The scale of
     * the result is {@code (this.scale() - n)}.
     *
     * @param n the exponent power of ten to scale by
     * @return a BigDecimal whose numerical value is equal to
     * ({@code this} * 10&lt;sup&gt;n&lt;/sup&gt;)
     * @throws ArithmeticException if the scale would be
     *         outside the range of a 32-bit integer.
     *
     * @since 1.5
     */
    public BigDecimal scaleByPowerOfTen(int n) {
<span class="fc" id="L2575">        return new BigDecimal(intVal, intCompact,</span>
<span class="fc" id="L2576">                              checkScale((long)scale - n), precision);</span>
    }

    /**
     * Returns a {@code BigDecimal} which is numerically equal to
     * this one but with any trailing zeros removed from the
     * representation.  For example, stripping the trailing zeros from
     * the {@code BigDecimal} value {@code 600.0}, which has
     * [{@code BigInteger}, {@code scale}] components equals to
     * [6000, 1], yields {@code 6E2} with [{@code BigInteger},
     * {@code scale}] components equals to [6, -2].  If
     * this BigDecimal is numerically equal to zero, then
     * {@code BigDecimal.ZERO} is returned.
     *
     * @return a numerically equal {@code BigDecimal} with any
     * trailing zeros removed.
     * @since 1.5
     */
    public BigDecimal stripTrailingZeros() {
<span class="pc bpc" id="L2595" title="1 of 6 branches missed.">        if (intCompact == 0 || (intVal != null &amp;&amp; intVal.signum() == 0)) {</span>
<span class="fc" id="L2596">            return BigDecimal.ZERO;</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">        } else if (intCompact != INFLATED) {</span>
<span class="fc" id="L2598">            return createAndStripZerosToMatchScale(intCompact, scale, Long.MIN_VALUE);</span>
        } else {
<span class="fc" id="L2600">            return createAndStripZerosToMatchScale(intVal, scale, Long.MIN_VALUE);</span>
        }
    }

    // Comparison Operations

    /**
     * Compares this {@code BigDecimal} with the specified
     * {@code BigDecimal}.  Two {@code BigDecimal} objects that are
     * equal in value but have a different scale (like 2.0 and 2.00)
     * are considered equal by this method.  This method is provided
     * in preference to individual methods for each of the six boolean
     * comparison operators ({@literal &lt;}, ==,
     * {@literal &gt;}, {@literal &gt;=}, !=, {@literal &lt;=}).  The
     * suggested idiom for performing these comparisons is:
     * {@code (x.compareTo(y)} &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; {@code 0)}, where
     * &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; is one of the six comparison operators.
     *
     * @param  val {@code BigDecimal} to which this {@code BigDecimal} is
     *         to be compared.
     * @return -1, 0, or 1 as this {@code BigDecimal} is numerically
     *          less than, equal to, or greater than {@code val}.
     */
    public int compareTo(BigDecimal val) {
        // Quick path for equal scale and non-inflated case.
<span class="fc bfc" id="L2625" title="All 2 branches covered.">        if (scale == val.scale) {</span>
<span class="fc" id="L2626">            long xs = intCompact;</span>
<span class="fc" id="L2627">            long ys = val.intCompact;</span>
<span class="fc bfc" id="L2628" title="All 4 branches covered.">            if (xs != INFLATED &amp;&amp; ys != INFLATED)</span>
<span class="fc bfc" id="L2629" title="All 4 branches covered.">                return xs != ys ? ((xs &gt; ys) ? 1 : -1) : 0;</span>
        }
<span class="fc" id="L2631">        int xsign = this.signum();</span>
<span class="fc" id="L2632">        int ysign = val.signum();</span>
<span class="fc bfc" id="L2633" title="All 2 branches covered.">        if (xsign != ysign)</span>
<span class="fc bfc" id="L2634" title="All 2 branches covered.">            return (xsign &gt; ysign) ? 1 : -1;</span>
<span class="pc bpc" id="L2635" title="1 of 2 branches missed.">        if (xsign == 0)</span>
<span class="nc" id="L2636">            return 0;</span>
<span class="fc" id="L2637">        int cmp = compareMagnitude(val);</span>
<span class="fc bfc" id="L2638" title="All 2 branches covered.">        return (xsign &gt; 0) ? cmp : -cmp;</span>
    }

    /**
     * Version of compareTo that ignores sign.
     */
    private int compareMagnitude(BigDecimal val) {
        // Match scales, avoid unnecessary inflation
<span class="fc" id="L2646">        long ys = val.intCompact;</span>
<span class="fc" id="L2647">        long xs = this.intCompact;</span>
<span class="pc bpc" id="L2648" title="1 of 2 branches missed.">        if (xs == 0)</span>
<span class="nc bnc" id="L2649" title="All 2 branches missed.">            return (ys == 0) ? 0 : -1;</span>
<span class="pc bpc" id="L2650" title="1 of 2 branches missed.">        if (ys == 0)</span>
<span class="nc" id="L2651">            return 1;</span>

<span class="fc" id="L2653">        long sdiff = (long)this.scale - val.scale;</span>
<span class="fc bfc" id="L2654" title="All 2 branches covered.">        if (sdiff != 0) {</span>
            // Avoid matching scales if the (adjusted) exponents differ
<span class="fc" id="L2656">            long xae = (long)this.precision() - this.scale;   // [-1]</span>
<span class="fc" id="L2657">            long yae = (long)val.precision() - val.scale;     // [-1]</span>
<span class="fc bfc" id="L2658" title="All 2 branches covered.">            if (xae &lt; yae)</span>
<span class="fc" id="L2659">                return -1;</span>
<span class="fc bfc" id="L2660" title="All 2 branches covered.">            if (xae &gt; yae)</span>
<span class="fc" id="L2661">                return 1;</span>
<span class="fc" id="L2662">            BigInteger rb = null;</span>
<span class="fc bfc" id="L2663" title="All 2 branches covered.">            if (sdiff &lt; 0) {</span>
                // The cases sdiff &lt;= Integer.MIN_VALUE intentionally fall through.
<span class="pc bpc" id="L2665" title="1 of 4 branches missed.">                if ( sdiff &gt; Integer.MIN_VALUE &amp;&amp;</span>
                      (xs == INFLATED ||
<span class="pc bpc" id="L2667" title="1 of 4 branches missed.">                      (xs = longMultiplyPowerTen(xs, (int)-sdiff)) == INFLATED) &amp;&amp;</span>
                     ys == INFLATED) {
<span class="fc" id="L2669">                    rb = bigMultiplyPowerTen((int)-sdiff);</span>
<span class="fc" id="L2670">                    return rb.compareMagnitude(val.intVal);</span>
                }
            } else { // sdiff &gt; 0
                // The cases sdiff &gt; Integer.MAX_VALUE intentionally fall through.
<span class="pc bpc" id="L2674" title="1 of 4 branches missed.">                if ( sdiff &lt;= Integer.MAX_VALUE &amp;&amp;</span>
                      (ys == INFLATED ||
<span class="pc bpc" id="L2676" title="1 of 4 branches missed.">                      (ys = longMultiplyPowerTen(ys, (int)sdiff)) == INFLATED) &amp;&amp;</span>
                     xs == INFLATED) {
<span class="fc" id="L2678">                    rb = val.bigMultiplyPowerTen((int)sdiff);</span>
<span class="fc" id="L2679">                    return this.intVal.compareMagnitude(rb);</span>
                }
            }
        }
<span class="fc bfc" id="L2683" title="All 2 branches covered.">        if (xs != INFLATED)</span>
<span class="fc bfc" id="L2684" title="All 2 branches covered.">            return (ys != INFLATED) ? longCompareMagnitude(xs, ys) : -1;</span>
<span class="fc bfc" id="L2685" title="All 2 branches covered.">        else if (ys != INFLATED)</span>
<span class="fc" id="L2686">            return 1;</span>
        else
<span class="fc" id="L2688">            return this.intVal.compareMagnitude(val.intVal);</span>
    }

    /**
     * Compares this {@code BigDecimal} with the specified
     * {@code Object} for equality.  Unlike {@link
     * #compareTo(BigDecimal) compareTo}, this method considers two
     * {@code BigDecimal} objects equal only if they are equal in
     * value and scale (thus 2.0 is not equal to 2.00 when compared by
     * this method).
     *
     * @param  x {@code Object} to which this {@code BigDecimal} is
     *         to be compared.
     * @return {@code true} if and only if the specified {@code Object} is a
     *         {@code BigDecimal} whose value and scale are equal to this
     *         {@code BigDecimal}'s.
     * @see    #compareTo(java.math.BigDecimal)
     * @see    #hashCode
     */
    @Override
    public boolean equals(Object x) {
<span class="pc bpc" id="L2709" title="1 of 2 branches missed.">        if (!(x instanceof BigDecimal))</span>
<span class="nc" id="L2710">            return false;</span>
<span class="fc" id="L2711">        BigDecimal xDec = (BigDecimal) x;</span>
<span class="fc bfc" id="L2712" title="All 2 branches covered.">        if (x == this)</span>
<span class="fc" id="L2713">            return true;</span>
<span class="fc bfc" id="L2714" title="All 2 branches covered.">        if (scale != xDec.scale)</span>
<span class="fc" id="L2715">            return false;</span>
<span class="fc" id="L2716">        long s = this.intCompact;</span>
<span class="fc" id="L2717">        long xs = xDec.intCompact;</span>
<span class="fc bfc" id="L2718" title="All 2 branches covered.">        if (s != INFLATED) {</span>
<span class="pc bpc" id="L2719" title="1 of 2 branches missed.">            if (xs == INFLATED)</span>
<span class="nc" id="L2720">                xs = compactValFor(xDec.intVal);</span>
<span class="fc bfc" id="L2721" title="All 2 branches covered.">            return xs == s;</span>
<span class="fc bfc" id="L2722" title="All 2 branches covered.">        } else if (xs != INFLATED)</span>
<span class="pc bpc" id="L2723" title="1 of 2 branches missed.">            return xs == compactValFor(this.intVal);</span>

<span class="fc" id="L2725">        return this.inflated().equals(xDec.inflated());</span>
    }

    /**
     * Returns the minimum of this {@code BigDecimal} and
     * {@code val}.
     *
     * @param  val value with which the minimum is to be computed.
     * @return the {@code BigDecimal} whose value is the lesser of this
     *         {@code BigDecimal} and {@code val}.  If they are equal,
     *         as defined by the {@link #compareTo(BigDecimal) compareTo}
     *         method, {@code this} is returned.
     * @see    #compareTo(java.math.BigDecimal)
     */
    public BigDecimal min(BigDecimal val) {
<span class="nc bnc" id="L2740" title="All 2 branches missed.">        return (compareTo(val) &lt;= 0 ? this : val);</span>
    }

    /**
     * Returns the maximum of this {@code BigDecimal} and {@code val}.
     *
     * @param  val value with which the maximum is to be computed.
     * @return the {@code BigDecimal} whose value is the greater of this
     *         {@code BigDecimal} and {@code val}.  If they are equal,
     *         as defined by the {@link #compareTo(BigDecimal) compareTo}
     *         method, {@code this} is returned.
     * @see    #compareTo(java.math.BigDecimal)
     */
    public BigDecimal max(BigDecimal val) {
<span class="nc bnc" id="L2754" title="All 2 branches missed.">        return (compareTo(val) &gt;= 0 ? this : val);</span>
    }

    // Hash Function

    /**
     * Returns the hash code for this {@code BigDecimal}.  Note that
     * two {@code BigDecimal} objects that are numerically equal but
     * differ in scale (like 2.0 and 2.00) will generally &lt;i&gt;not&lt;/i&gt;
     * have the same hash code.
     *
     * @return hash code for this {@code BigDecimal}.
     * @see #equals(Object)
     */
    @Override
    public int hashCode() {
<span class="pc bpc" id="L2770" title="1 of 2 branches missed.">        if (intCompact != INFLATED) {</span>
<span class="fc bfc" id="L2771" title="All 2 branches covered.">            long val2 = (intCompact &lt; 0)? -intCompact : intCompact;</span>
<span class="fc" id="L2772">            int temp = (int)( ((int)(val2 &gt;&gt;&gt; 32)) * 31  +</span>
                              (val2 &amp; LONG_MASK));
<span class="fc bfc" id="L2774" title="All 2 branches covered.">            return 31*((intCompact &lt; 0) ?-temp:temp) + scale;</span>
        } else
<span class="nc" id="L2776">            return 31*intVal.hashCode() + scale;</span>
    }

    // Format Converters

    /**
     * Returns the string representation of this {@code BigDecimal},
     * using scientific notation if an exponent is needed.
     *
     * &lt;p&gt;A standard canonical string form of the {@code BigDecimal}
     * is created as though by the following steps: first, the
     * absolute value of the unscaled value of the {@code BigDecimal}
     * is converted to a string in base ten using the characters
     * {@code '0'} through {@code '9'} with no leading zeros (except
     * if its value is zero, in which case a single {@code '0'}
     * character is used).
     *
     * &lt;p&gt;Next, an &lt;i&gt;adjusted exponent&lt;/i&gt; is calculated; this is the
     * negated scale, plus the number of characters in the converted
     * unscaled value, less one.  That is,
     * {@code -scale+(ulength-1)}, where {@code ulength} is the
     * length of the absolute value of the unscaled value in decimal
     * digits (its &lt;i&gt;precision&lt;/i&gt;).
     *
     * &lt;p&gt;If the scale is greater than or equal to zero and the
     * adjusted exponent is greater than or equal to {@code -6}, the
     * number will be converted to a character form without using
     * exponential notation.  In this case, if the scale is zero then
     * no decimal point is added and if the scale is positive a
     * decimal point will be inserted with the scale specifying the
     * number of characters to the right of the decimal point.
     * {@code '0'} characters are added to the left of the converted
     * unscaled value as necessary.  If no character precedes the
     * decimal point after this insertion then a conventional
     * {@code '0'} character is prefixed.
     *
     * &lt;p&gt;Otherwise (that is, if the scale is negative, or the
     * adjusted exponent is less than {@code -6}), the number will be
     * converted to a character form using exponential notation.  In
     * this case, if the converted {@code BigInteger} has more than
     * one digit a decimal point is inserted after the first digit.
     * An exponent in character form is then suffixed to the converted
     * unscaled value (perhaps with inserted decimal point); this
     * comprises the letter {@code 'E'} followed immediately by the
     * adjusted exponent converted to a character form.  The latter is
     * in base ten, using the characters {@code '0'} through
     * {@code '9'} with no leading zeros, and is always prefixed by a
     * sign character {@code '-'} (&lt;tt&gt;'&amp;#92;u002D'&lt;/tt&gt;) if the
     * adjusted exponent is negative, {@code '+'}
     * (&lt;tt&gt;'&amp;#92;u002B'&lt;/tt&gt;) otherwise).
     *
     * &lt;p&gt;Finally, the entire string is prefixed by a minus sign
     * character {@code '-'} (&lt;tt&gt;'&amp;#92;u002D'&lt;/tt&gt;) if the unscaled
     * value is less than zero.  No sign character is prefixed if the
     * unscaled value is zero or positive.
     *
     * &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;
     * &lt;p&gt;For each representation [&lt;i&gt;unscaled value&lt;/i&gt;, &lt;i&gt;scale&lt;/i&gt;]
     * on the left, the resulting string is shown on the right.
     * &lt;pre&gt;
     * [123,0]      &quot;123&quot;
     * [-123,0]     &quot;-123&quot;
     * [123,-1]     &quot;1.23E+3&quot;
     * [123,-3]     &quot;1.23E+5&quot;
     * [123,1]      &quot;12.3&quot;
     * [123,5]      &quot;0.00123&quot;
     * [123,10]     &quot;1.23E-8&quot;
     * [-123,12]    &quot;-1.23E-10&quot;
     * &lt;/pre&gt;
     *
     * &lt;b&gt;Notes:&lt;/b&gt;
     * &lt;ol&gt;
     *
     * &lt;li&gt;There is a one-to-one mapping between the distinguishable
     * {@code BigDecimal} values and the result of this conversion.
     * That is, every distinguishable {@code BigDecimal} value
     * (unscaled value and scale) has a unique string representation
     * as a result of using {@code toString}.  If that string
     * representation is converted back to a {@code BigDecimal} using
     * the {@link #BigDecimal(String)} constructor, then the original
     * value will be recovered.
     *
     * &lt;li&gt;The string produced for a given number is always the same;
     * it is not affected by locale.  This means that it can be used
     * as a canonical string representation for exchanging decimal
     * data, or as a key for a Hashtable, etc.  Locale-sensitive
     * number formatting and parsing is handled by the {@link
     * java.text.NumberFormat} class and its subclasses.
     *
     * &lt;li&gt;The {@link #toEngineeringString} method may be used for
     * presenting numbers with exponents in engineering notation, and the
     * {@link #setScale(int,RoundingMode) setScale} method may be used for
     * rounding a {@code BigDecimal} so it has a known number of digits after
     * the decimal point.
     *
     * &lt;li&gt;The digit-to-character mapping provided by
     * {@code Character.forDigit} is used.
     *
     * &lt;/ol&gt;
     *
     * @return string representation of this {@code BigDecimal}.
     * @see    Character#forDigit
     * @see    #BigDecimal(java.lang.String)
     */
    @Override
    public String toString() {
<span class="fc" id="L2882">        String sc = stringCache;</span>
<span class="fc bfc" id="L2883" title="All 2 branches covered.">        if (sc == null)</span>
<span class="fc" id="L2884">            stringCache = sc = layoutChars(true);</span>
<span class="fc" id="L2885">        return sc;</span>
    }

    /**
     * Returns a string representation of this {@code BigDecimal},
     * using engineering notation if an exponent is needed.
     *
     * &lt;p&gt;Returns a string that represents the {@code BigDecimal} as
     * described in the {@link #toString()} method, except that if
     * exponential notation is used, the power of ten is adjusted to
     * be a multiple of three (engineering notation) such that the
     * integer part of nonzero values will be in the range 1 through
     * 999.  If exponential notation is used for zero values, a
     * decimal point and one or two fractional zero digits are used so
     * that the scale of the zero value is preserved.  Note that
     * unlike the output of {@link #toString()}, the output of this
     * method is &lt;em&gt;not&lt;/em&gt; guaranteed to recover the same [integer,
     * scale] pair of this {@code BigDecimal} if the output string is
     * converting back to a {@code BigDecimal} using the {@linkplain
     * #BigDecimal(String) string constructor}.  The result of this method meets
     * the weaker constraint of always producing a numerically equal
     * result from applying the string constructor to the method's output.
     *
     * @return string representation of this {@code BigDecimal}, using
     *         engineering notation if an exponent is needed.
     * @since  1.5
     */
    public String toEngineeringString() {
<span class="nc" id="L2913">        return layoutChars(false);</span>
    }

    /**
     * Returns a string representation of this {@code BigDecimal}
     * without an exponent field.  For values with a positive scale,
     * the number of digits to the right of the decimal point is used
     * to indicate scale.  For values with a zero or negative scale,
     * the resulting string is generated as if the value were
     * converted to a numerically equal value with zero scale and as
     * if all the trailing zeros of the zero scale value were present
     * in the result.
     *
     * The entire string is prefixed by a minus sign character '-'
     * (&lt;tt&gt;'&amp;#92;u002D'&lt;/tt&gt;) if the unscaled value is less than
     * zero. No sign character is prefixed if the unscaled value is
     * zero or positive.
     *
     * Note that if the result of this method is passed to the
     * {@linkplain #BigDecimal(String) string constructor}, only the
     * numerical value of this {@code BigDecimal} will necessarily be
     * recovered; the representation of the new {@code BigDecimal}
     * may have a different scale.  In particular, if this
     * {@code BigDecimal} has a negative scale, the string resulting
     * from this method will have a scale of zero when processed by
     * the string constructor.
     *
     * (This method behaves analogously to the {@code toString}
     * method in 1.4 and earlier releases.)
     *
     * @return a string representation of this {@code BigDecimal}
     * without an exponent field.
     * @since 1.5
     * @see #toString()
     * @see #toEngineeringString()
     */
    public String toPlainString() {
<span class="fc bfc" id="L2950" title="All 2 branches covered.">        if(scale==0) {</span>
<span class="fc bfc" id="L2951" title="All 2 branches covered.">            if(intCompact!=INFLATED) {</span>
<span class="fc" id="L2952">                return Long.toString(intCompact);</span>
            } else {
<span class="fc" id="L2954">                return intVal.toString();</span>
            }
        }
<span class="fc bfc" id="L2957" title="All 2 branches covered.">        if(this.scale&lt;0) { // No decimal point</span>
<span class="pc bpc" id="L2958" title="1 of 2 branches missed.">            if(signum()==0) {</span>
<span class="nc" id="L2959">                return &quot;0&quot;;</span>
            }
<span class="fc" id="L2961">            int tailingZeros = checkScaleNonZero((-(long)scale));</span>
            StringBuilder buf;
<span class="fc bfc" id="L2963" title="All 2 branches covered.">            if(intCompact!=INFLATED) {</span>
<span class="fc" id="L2964">                buf = new StringBuilder(20+tailingZeros);</span>
<span class="fc" id="L2965">                buf.append(intCompact);</span>
            } else {
<span class="fc" id="L2967">                String str = intVal.toString();</span>
<span class="fc" id="L2968">                buf = new StringBuilder(str.length()+tailingZeros);</span>
<span class="fc" id="L2969">                buf.append(str);</span>
            }
<span class="fc bfc" id="L2971" title="All 2 branches covered.">            for (int i = 0; i &lt; tailingZeros; i++)</span>
<span class="fc" id="L2972">                buf.append('0');</span>
<span class="fc" id="L2973">            return buf.toString();</span>
        }
        String str ;
<span class="fc bfc" id="L2976" title="All 2 branches covered.">        if(intCompact!=INFLATED) {</span>
<span class="fc" id="L2977">            str = Long.toString(Math.abs(intCompact));</span>
        } else {
<span class="fc" id="L2979">            str = intVal.abs().toString();</span>
        }
<span class="fc" id="L2981">        return getValueString(signum(), str, scale);</span>
    }

    /* Returns a digit.digit string */
    private String getValueString(int signum, String intString, int scale) {
        /* Insert decimal point */
        StringBuilder buf;
<span class="fc" id="L2988">        int insertionPoint = intString.length() - scale;</span>
<span class="fc bfc" id="L2989" title="All 2 branches covered.">        if (insertionPoint == 0) {  /* Point goes right before intVal */</span>
<span class="fc bfc" id="L2990" title="All 2 branches covered.">            return (signum&lt;0 ? &quot;-0.&quot; : &quot;0.&quot;) + intString;</span>
<span class="fc bfc" id="L2991" title="All 2 branches covered.">        } else if (insertionPoint &gt; 0) { /* Point goes inside intVal */</span>
<span class="fc" id="L2992">            buf = new StringBuilder(intString);</span>
<span class="fc" id="L2993">            buf.insert(insertionPoint, '.');</span>
<span class="pc bpc" id="L2994" title="1 of 2 branches missed.">            if (signum &lt; 0)</span>
<span class="nc" id="L2995">                buf.insert(0, '-');</span>
        } else { /* We must insert zeros between point and intVal */
<span class="fc" id="L2997">            buf = new StringBuilder(3-insertionPoint + intString.length());</span>
<span class="fc bfc" id="L2998" title="All 2 branches covered.">            buf.append(signum&lt;0 ? &quot;-0.&quot; : &quot;0.&quot;);</span>
<span class="fc bfc" id="L2999" title="All 2 branches covered.">            for (int i=0; i&lt;-insertionPoint; i++)</span>
<span class="fc" id="L3000">                buf.append('0');</span>
<span class="fc" id="L3001">            buf.append(intString);</span>
        }
<span class="fc" id="L3003">        return buf.toString();</span>
    }

    /**
     * Converts this {@code BigDecimal} to a {@code BigInteger}.
     * This conversion is analogous to the
     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
     * {@code long} as defined in section 5.1.3 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
     * any fractional part of this
     * {@code BigDecimal} will be discarded.  Note that this
     * conversion can lose information about the precision of the
     * {@code BigDecimal} value.
     * &lt;p&gt;
     * To have an exception thrown if the conversion is inexact (in
     * other words if a nonzero fractional part is discarded), use the
     * {@link #toBigIntegerExact()} method.
     *
     * @return this {@code BigDecimal} converted to a {@code BigInteger}.
     */
    public BigInteger toBigInteger() {
        // force to an integer, quietly
<span class="fc" id="L3025">        return this.setScale(0, ROUND_DOWN).inflated();</span>
    }

    /**
     * Converts this {@code BigDecimal} to a {@code BigInteger},
     * checking for lost information.  An exception is thrown if this
     * {@code BigDecimal} has a nonzero fractional part.
     *
     * @return this {@code BigDecimal} converted to a {@code BigInteger}.
     * @throws ArithmeticException if {@code this} has a nonzero
     *         fractional part.
     * @since  1.5
     */
    public BigInteger toBigIntegerExact() {
        // round to an integer, with Exception if decimal part non-0
<span class="nc" id="L3040">        return this.setScale(0, ROUND_UNNECESSARY).inflated();</span>
    }

    /**
     * Converts this {@code BigDecimal} to a {@code long}.
     * This conversion is analogous to the
     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
     * {@code short} as defined in section 5.1.3 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
     * any fractional part of this
     * {@code BigDecimal} will be discarded, and if the resulting
     * &quot;{@code BigInteger}&quot; is too big to fit in a
     * {@code long}, only the low-order 64 bits are returned.
     * Note that this conversion can lose information about the
     * overall magnitude and precision of this {@code BigDecimal} value as well
     * as return a result with the opposite sign.
     *
     * @return this {@code BigDecimal} converted to a {@code long}.
     */
    public long longValue(){
<span class="pc bpc" id="L3060" title="1 of 4 branches missed.">        return (intCompact != INFLATED &amp;&amp; scale == 0) ?</span>
            intCompact:
<span class="fc" id="L3062">            toBigInteger().longValue();</span>
    }

    /**
     * Converts this {@code BigDecimal} to a {@code long}, checking
     * for lost information.  If this {@code BigDecimal} has a
     * nonzero fractional part or is out of the possible range for a
     * {@code long} result then an {@code ArithmeticException} is
     * thrown.
     *
     * @return this {@code BigDecimal} converted to a {@code long}.
     * @throws ArithmeticException if {@code this} has a nonzero
     *         fractional part, or will not fit in a {@code long}.
     * @since  1.5
     */
    public long longValueExact() {
<span class="nc bnc" id="L3078" title="All 4 branches missed.">        if (intCompact != INFLATED &amp;&amp; scale == 0)</span>
<span class="nc" id="L3079">            return intCompact;</span>
        // If more than 19 digits in integer part it cannot possibly fit
<span class="nc bnc" id="L3081" title="All 2 branches missed.">        if ((precision() - scale) &gt; 19) // [OK for negative scale too]</span>
<span class="nc" id="L3082">            throw new java.lang.ArithmeticException(&quot;Overflow&quot;);</span>
        // Fastpath zero and &lt; 1.0 numbers (the latter can be very slow
        // to round if very small)
<span class="nc bnc" id="L3085" title="All 2 branches missed.">        if (this.signum() == 0)</span>
<span class="nc" id="L3086">            return 0;</span>
<span class="nc bnc" id="L3087" title="All 2 branches missed.">        if ((this.precision() - this.scale) &lt;= 0)</span>
<span class="nc" id="L3088">            throw new ArithmeticException(&quot;Rounding necessary&quot;);</span>
        // round to an integer, with Exception if decimal part non-0
<span class="nc" id="L3090">        BigDecimal num = this.setScale(0, ROUND_UNNECESSARY);</span>
<span class="nc bnc" id="L3091" title="All 2 branches missed.">        if (num.precision() &gt;= 19) // need to check carefully</span>
<span class="nc" id="L3092">            LongOverflow.check(num);</span>
<span class="nc" id="L3093">        return num.inflated().longValue();</span>
    }

<span class="nc" id="L3096">    private static class LongOverflow {</span>
        /** BigInteger equal to Long.MIN_VALUE. */
<span class="nc" id="L3098">        private static final BigInteger LONGMIN = BigInteger.valueOf(Long.MIN_VALUE);</span>

        /** BigInteger equal to Long.MAX_VALUE. */
<span class="nc" id="L3101">        private static final BigInteger LONGMAX = BigInteger.valueOf(Long.MAX_VALUE);</span>

        public static void check(BigDecimal num) {
<span class="nc" id="L3104">            BigInteger intVal = num.inflated();</span>
<span class="nc bnc" id="L3105" title="All 2 branches missed.">            if (intVal.compareTo(LONGMIN) &lt; 0 ||</span>
<span class="nc bnc" id="L3106" title="All 2 branches missed.">                intVal.compareTo(LONGMAX) &gt; 0)</span>
<span class="nc" id="L3107">                throw new java.lang.ArithmeticException(&quot;Overflow&quot;);</span>
<span class="nc" id="L3108">        }</span>
    }

    /**
     * Converts this {@code BigDecimal} to an {@code int}.
     * This conversion is analogous to the
     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
     * {@code short} as defined in section 5.1.3 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
     * any fractional part of this
     * {@code BigDecimal} will be discarded, and if the resulting
     * &quot;{@code BigInteger}&quot; is too big to fit in an
     * {@code int}, only the low-order 32 bits are returned.
     * Note that this conversion can lose information about the
     * overall magnitude and precision of this {@code BigDecimal}
     * value as well as return a result with the opposite sign.
     *
     * @return this {@code BigDecimal} converted to an {@code int}.
     */
    public int intValue() {
<span class="pc bpc" id="L3128" title="2 of 4 branches missed.">        return  (intCompact != INFLATED &amp;&amp; scale == 0) ?</span>
            (int)intCompact :
<span class="pc" id="L3130">            toBigInteger().intValue();</span>
    }

    /**
     * Converts this {@code BigDecimal} to an {@code int}, checking
     * for lost information.  If this {@code BigDecimal} has a
     * nonzero fractional part or is out of the possible range for an
     * {@code int} result then an {@code ArithmeticException} is
     * thrown.
     *
     * @return this {@code BigDecimal} converted to an {@code int}.
     * @throws ArithmeticException if {@code this} has a nonzero
     *         fractional part, or will not fit in an {@code int}.
     * @since  1.5
     */
    public int intValueExact() {
       long num;
<span class="nc" id="L3147">       num = this.longValueExact();     // will check decimal part</span>
<span class="nc bnc" id="L3148" title="All 2 branches missed.">       if ((int)num != num)</span>
<span class="nc" id="L3149">           throw new java.lang.ArithmeticException(&quot;Overflow&quot;);</span>
<span class="nc" id="L3150">       return (int)num;</span>
    }

    /**
     * Converts this {@code BigDecimal} to a {@code short}, checking
     * for lost information.  If this {@code BigDecimal} has a
     * nonzero fractional part or is out of the possible range for a
     * {@code short} result then an {@code ArithmeticException} is
     * thrown.
     *
     * @return this {@code BigDecimal} converted to a {@code short}.
     * @throws ArithmeticException if {@code this} has a nonzero
     *         fractional part, or will not fit in a {@code short}.
     * @since  1.5
     */
    public short shortValueExact() {
       long num;
<span class="nc" id="L3167">       num = this.longValueExact();     // will check decimal part</span>
<span class="nc bnc" id="L3168" title="All 2 branches missed.">       if ((short)num != num)</span>
<span class="nc" id="L3169">           throw new java.lang.ArithmeticException(&quot;Overflow&quot;);</span>
<span class="nc" id="L3170">       return (short)num;</span>
    }

    /**
     * Converts this {@code BigDecimal} to a {@code byte}, checking
     * for lost information.  If this {@code BigDecimal} has a
     * nonzero fractional part or is out of the possible range for a
     * {@code byte} result then an {@code ArithmeticException} is
     * thrown.
     *
     * @return this {@code BigDecimal} converted to a {@code byte}.
     * @throws ArithmeticException if {@code this} has a nonzero
     *         fractional part, or will not fit in a {@code byte}.
     * @since  1.5
     */
    public byte byteValueExact() {
       long num;
<span class="nc" id="L3187">       num = this.longValueExact();     // will check decimal part</span>
<span class="nc bnc" id="L3188" title="All 2 branches missed.">       if ((byte)num != num)</span>
<span class="nc" id="L3189">           throw new java.lang.ArithmeticException(&quot;Overflow&quot;);</span>
<span class="nc" id="L3190">       return (byte)num;</span>
    }

    /**
     * Converts this {@code BigDecimal} to a {@code float}.
     * This conversion is similar to the
     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
     * {@code float} as defined in section 5.1.3 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
     * if this {@code BigDecimal} has too great a
     * magnitude to represent as a {@code float}, it will be
     * converted to {@link Float#NEGATIVE_INFINITY} or {@link
     * Float#POSITIVE_INFINITY} as appropriate.  Note that even when
     * the return value is finite, this conversion can lose
     * information about the precision of the {@code BigDecimal}
     * value.
     *
     * @return this {@code BigDecimal} converted to a {@code float}.
     */
    public float floatValue(){
<span class="fc bfc" id="L3210" title="All 2 branches covered.">        if(intCompact != INFLATED) {</span>
<span class="fc bfc" id="L3211" title="All 2 branches covered.">            if (scale == 0) {</span>
<span class="fc" id="L3212">                return (float)intCompact;</span>
            } else {
                /*
                 * If both intCompact and the scale can be exactly
                 * represented as float values, perform a single float
                 * multiply or divide to compute the (properly
                 * rounded) result.
                 */
<span class="fc bfc" id="L3220" title="All 2 branches covered.">                if (Math.abs(intCompact) &lt; 1L&lt;&lt;22 ) {</span>
                    // Don't have too guard against
                    // Math.abs(MIN_VALUE) because of outer check
                    // against INFLATED.
<span class="pc bpc" id="L3224" title="1 of 4 branches missed.">                    if (scale &gt; 0 &amp;&amp; scale &lt; float10pow.length) {</span>
<span class="fc" id="L3225">                        return (float)intCompact / float10pow[scale];</span>
<span class="pc bpc" id="L3226" title="2 of 4 branches missed.">                    } else if (scale &lt; 0 &amp;&amp; scale &gt; -float10pow.length) {</span>
<span class="fc" id="L3227">                        return (float)intCompact * float10pow[-scale];</span>
                    }
                }
            }
        }
        // Somewhat inefficient, but guaranteed to work.
<span class="fc" id="L3233">        return Float.parseFloat(this.toString());</span>
    }

    /**
     * Converts this {@code BigDecimal} to a {@code double}.
     * This conversion is similar to the
     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
     * {@code float} as defined in section 5.1.3 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
     * if this {@code BigDecimal} has too great a
     * magnitude represent as a {@code double}, it will be
     * converted to {@link Double#NEGATIVE_INFINITY} or {@link
     * Double#POSITIVE_INFINITY} as appropriate.  Note that even when
     * the return value is finite, this conversion can lose
     * information about the precision of the {@code BigDecimal}
     * value.
     *
     * @return this {@code BigDecimal} converted to a {@code double}.
     */
    public double doubleValue(){
<span class="fc bfc" id="L3253" title="All 2 branches covered.">        if(intCompact != INFLATED) {</span>
<span class="fc bfc" id="L3254" title="All 2 branches covered.">            if (scale == 0) {</span>
<span class="fc" id="L3255">                return (double)intCompact;</span>
            } else {
                /*
                 * If both intCompact and the scale can be exactly
                 * represented as double values, perform a single
                 * double multiply or divide to compute the (properly
                 * rounded) result.
                 */
<span class="pc bpc" id="L3263" title="1 of 2 branches missed.">                if (Math.abs(intCompact) &lt; 1L&lt;&lt;52 ) {</span>
                    // Don't have too guard against
                    // Math.abs(MIN_VALUE) because of outer check
                    // against INFLATED.
<span class="pc bpc" id="L3267" title="1 of 4 branches missed.">                    if (scale &gt; 0 &amp;&amp; scale &lt; double10pow.length) {</span>
<span class="fc" id="L3268">                        return (double)intCompact / double10pow[scale];</span>
<span class="pc bpc" id="L3269" title="2 of 4 branches missed.">                    } else if (scale &lt; 0 &amp;&amp; scale &gt; -double10pow.length) {</span>
<span class="fc" id="L3270">                        return (double)intCompact * double10pow[-scale];</span>
                    }
                }
            }
        }
        // Somewhat inefficient, but guaranteed to work.
<span class="fc" id="L3276">        return Double.parseDouble(this.toString());</span>
    }

    /**
     * Powers of 10 which can be represented exactly in {@code
     * double}.
     */
<span class="fc" id="L3283">    private static final double double10pow[] = {</span>
        1.0e0,  1.0e1,  1.0e2,  1.0e3,  1.0e4,  1.0e5,
        1.0e6,  1.0e7,  1.0e8,  1.0e9,  1.0e10, 1.0e11,
        1.0e12, 1.0e13, 1.0e14, 1.0e15, 1.0e16, 1.0e17,
        1.0e18, 1.0e19, 1.0e20, 1.0e21, 1.0e22
    };

    /**
     * Powers of 10 which can be represented exactly in {@code
     * float}.
     */
<span class="fc" id="L3294">    private static final float float10pow[] = {</span>
        1.0e0f, 1.0e1f, 1.0e2f, 1.0e3f, 1.0e4f, 1.0e5f,
        1.0e6f, 1.0e7f, 1.0e8f, 1.0e9f, 1.0e10f
    };

    /**
     * Returns the size of an ulp, a unit in the last place, of this
     * {@code BigDecimal}.  An ulp of a nonzero {@code BigDecimal}
     * value is the positive distance between this value and the
     * {@code BigDecimal} value next larger in magnitude with the
     * same number of digits.  An ulp of a zero value is numerically
     * equal to 1 with the scale of {@code this}.  The result is
     * stored with the same scale as {@code this} so the result
     * for zero and nonzero values is equal to {@code [1,
     * this.scale()]}.
     *
     * @return the size of an ulp of {@code this}
     * @since 1.5
     */
    public BigDecimal ulp() {
<span class="nc" id="L3314">        return BigDecimal.valueOf(1, this.scale(), 1);</span>
    }

    // Private class to build a string representation for BigDecimal object.
    // &quot;StringBuilderHelper&quot; is constructed as a thread local variable so it is
    // thread safe. The StringBuilder field acts as a buffer to hold the temporary
    // representation of BigDecimal. The cmpCharArray holds all the characters for
    // the compact representation of BigDecimal (except for '-' sign' if it is
    // negative) if its intCompact field is not INFLATED. It is shared by all
    // calls to toString() and its variants in that particular thread.
<span class="pc bpc" id="L3324" title="1 of 2 branches missed.">    static class StringBuilderHelper {</span>
        final StringBuilder sb;    // Placeholder for BigDecimal string
        final char[] cmpCharArray; // character array to place the intCompact

<span class="fc" id="L3328">        StringBuilderHelper() {</span>
<span class="fc" id="L3329">            sb = new StringBuilder();</span>
            // All non negative longs can be made to fit into 19 character array.
<span class="fc" id="L3331">            cmpCharArray = new char[19];</span>
<span class="fc" id="L3332">        }</span>

        // Accessors.
        StringBuilder getStringBuilder() {
<span class="fc" id="L3336">            sb.setLength(0);</span>
<span class="fc" id="L3337">            return sb;</span>
        }

        char[] getCompactCharArray() {
<span class="fc" id="L3341">            return cmpCharArray;</span>
        }

        /**
         * Places characters representing the intCompact in {@code long} into
         * cmpCharArray and returns the offset to the array where the
         * representation starts.
         *
         * @param intCompact the number to put into the cmpCharArray.
         * @return offset to the array where the representation starts.
         * Note: intCompact must be greater or equal to zero.
         */
        int putIntCompact(long intCompact) {
<span class="pc bpc" id="L3354" title="2 of 4 branches missed.">            assert intCompact &gt;= 0;</span>

            long q;
            int r;
            // since we start from the least significant digit, charPos points to
            // the last character in cmpCharArray.
<span class="fc" id="L3360">            int charPos = cmpCharArray.length;</span>

            // Get 2 digits/iteration using longs until quotient fits into an int
<span class="fc bfc" id="L3363" title="All 2 branches covered.">            while (intCompact &gt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L3364">                q = intCompact / 100;</span>
<span class="fc" id="L3365">                r = (int)(intCompact - q * 100);</span>
<span class="fc" id="L3366">                intCompact = q;</span>
<span class="fc" id="L3367">                cmpCharArray[--charPos] = DIGIT_ONES[r];</span>
<span class="fc" id="L3368">                cmpCharArray[--charPos] = DIGIT_TENS[r];</span>
            }

            // Get 2 digits/iteration using ints when i2 &gt;= 100
            int q2;
<span class="fc" id="L3373">            int i2 = (int)intCompact;</span>
<span class="fc bfc" id="L3374" title="All 2 branches covered.">            while (i2 &gt;= 100) {</span>
<span class="fc" id="L3375">                q2 = i2 / 100;</span>
<span class="fc" id="L3376">                r  = i2 - q2 * 100;</span>
<span class="fc" id="L3377">                i2 = q2;</span>
<span class="fc" id="L3378">                cmpCharArray[--charPos] = DIGIT_ONES[r];</span>
<span class="fc" id="L3379">                cmpCharArray[--charPos] = DIGIT_TENS[r];</span>
            }

<span class="fc" id="L3382">            cmpCharArray[--charPos] = DIGIT_ONES[i2];</span>
<span class="fc bfc" id="L3383" title="All 2 branches covered.">            if (i2 &gt;= 10)</span>
<span class="fc" id="L3384">                cmpCharArray[--charPos] = DIGIT_TENS[i2];</span>

<span class="fc" id="L3386">            return charPos;</span>
        }

<span class="fc" id="L3389">        final static char[] DIGIT_TENS = {</span>
            '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
            '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
            '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',
            '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',
            '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',
            '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',
            '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',
            '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',
            '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',
            '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',
        };

<span class="fc" id="L3402">        final static char[] DIGIT_ONES = {</span>
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        };
    }

    /**
     * Lay out this {@code BigDecimal} into a {@code char[]} array.
     * The Java 1.2 equivalent to this was called {@code getValueString}.
     *
     * @param  sci {@code true} for Scientific exponential notation;
     *          {@code false} for Engineering
     * @return string with canonical string representation of this
     *         {@code BigDecimal}
     */
    private String layoutChars(boolean sci) {
<span class="fc bfc" id="L3426" title="All 2 branches covered.">        if (scale == 0)                      // zero scale is trivial</span>
<span class="fc bfc" id="L3427" title="All 2 branches covered.">            return (intCompact != INFLATED) ?</span>
<span class="fc" id="L3428">                Long.toString(intCompact):</span>
<span class="fc" id="L3429">                intVal.toString();</span>
<span class="fc bfc" id="L3430" title="All 6 branches covered.">        if (scale == 2  &amp;&amp;</span>
            intCompact &gt;= 0 &amp;&amp; intCompact &lt; Integer.MAX_VALUE) {
            // currency fast path
<span class="fc" id="L3433">            int lowInt = (int)intCompact % 100;</span>
<span class="fc" id="L3434">            int highInt = (int)intCompact / 100;</span>
<span class="fc" id="L3435">            return (Integer.toString(highInt) + '.' +</span>
                    StringBuilderHelper.DIGIT_TENS[lowInt] +
                    StringBuilderHelper.DIGIT_ONES[lowInt]) ;
        }

<span class="fc" id="L3440">        StringBuilderHelper sbHelper = threadLocalStringBuilderHelper.get();</span>
        char[] coeff;
        int offset;  // offset is the starting index for coeff array
        // Get the significand as an absolute value
<span class="fc bfc" id="L3444" title="All 2 branches covered.">        if (intCompact != INFLATED) {</span>
<span class="fc" id="L3445">            offset = sbHelper.putIntCompact(Math.abs(intCompact));</span>
<span class="fc" id="L3446">            coeff  = sbHelper.getCompactCharArray();</span>
        } else {
<span class="fc" id="L3448">            offset = 0;</span>
<span class="fc" id="L3449">            coeff  = intVal.abs().toString().toCharArray();</span>
        }

        // Construct a buffer, with sufficient capacity for all cases.
        // If E-notation is needed, length will be: +1 if negative, +1
        // if '.' needed, +2 for &quot;E+&quot;, + up to 10 for adjusted exponent.
        // Otherwise it could have +1 if negative, plus leading &quot;0.00000&quot;
<span class="fc" id="L3456">        StringBuilder buf = sbHelper.getStringBuilder();</span>
<span class="fc bfc" id="L3457" title="All 2 branches covered.">        if (signum() &lt; 0)             // prefix '-' if negative</span>
<span class="fc" id="L3458">            buf.append('-');</span>
<span class="fc" id="L3459">        int coeffLen = coeff.length - offset;</span>
<span class="fc" id="L3460">        long adjusted = -(long)scale + (coeffLen -1);</span>
<span class="fc bfc" id="L3461" title="All 4 branches covered.">        if ((scale &gt;= 0) &amp;&amp; (adjusted &gt;= -6)) { // plain number</span>
<span class="fc" id="L3462">            int pad = scale - coeffLen;         // count of padding zeros</span>
<span class="fc bfc" id="L3463" title="All 2 branches covered.">            if (pad &gt;= 0) {                     // 0.xxx form</span>
<span class="fc" id="L3464">                buf.append('0');</span>
<span class="fc" id="L3465">                buf.append('.');</span>
<span class="fc bfc" id="L3466" title="All 2 branches covered.">                for (; pad&gt;0; pad--) {</span>
<span class="fc" id="L3467">                    buf.append('0');</span>
                }
<span class="fc" id="L3469">                buf.append(coeff, offset, coeffLen);</span>
            } else {                         // xx.xx form
<span class="fc" id="L3471">                buf.append(coeff, offset, -pad);</span>
<span class="fc" id="L3472">                buf.append('.');</span>
<span class="fc" id="L3473">                buf.append(coeff, -pad + offset, scale);</span>
            }
<span class="fc" id="L3475">        } else { // E-notation is needed</span>
<span class="pc bpc" id="L3476" title="1 of 2 branches missed.">            if (sci) {                       // Scientific notation</span>
<span class="fc" id="L3477">                buf.append(coeff[offset]);   // first character</span>
<span class="pc bpc" id="L3478" title="1 of 2 branches missed.">                if (coeffLen &gt; 1) {          // more to come</span>
<span class="fc" id="L3479">                    buf.append('.');</span>
<span class="fc" id="L3480">                    buf.append(coeff, offset + 1, coeffLen - 1);</span>
                }
            } else {                         // Engineering notation
<span class="nc" id="L3483">                int sig = (int)(adjusted % 3);</span>
<span class="nc bnc" id="L3484" title="All 2 branches missed.">                if (sig &lt; 0)</span>
<span class="nc" id="L3485">                    sig += 3;                // [adjusted was negative]</span>
<span class="nc" id="L3486">                adjusted -= sig;             // now a multiple of 3</span>
<span class="nc" id="L3487">                sig++;</span>
<span class="nc bnc" id="L3488" title="All 2 branches missed.">                if (signum() == 0) {</span>
<span class="nc bnc" id="L3489" title="All 4 branches missed.">                    switch (sig) {</span>
                    case 1:
<span class="nc" id="L3491">                        buf.append('0'); // exponent is a multiple of three</span>
<span class="nc" id="L3492">                        break;</span>
                    case 2:
<span class="nc" id="L3494">                        buf.append(&quot;0.00&quot;);</span>
<span class="nc" id="L3495">                        adjusted += 3;</span>
<span class="nc" id="L3496">                        break;</span>
                    case 3:
<span class="nc" id="L3498">                        buf.append(&quot;0.0&quot;);</span>
<span class="nc" id="L3499">                        adjusted += 3;</span>
<span class="nc" id="L3500">                        break;</span>
                    default:
<span class="nc" id="L3502">                        throw new AssertionError(&quot;Unexpected sig value &quot; + sig);</span>
                    }
<span class="nc bnc" id="L3504" title="All 2 branches missed.">                } else if (sig &gt;= coeffLen) {   // significand all in integer</span>
<span class="nc" id="L3505">                    buf.append(coeff, offset, coeffLen);</span>
                    // may need some zeros, too
<span class="nc bnc" id="L3507" title="All 2 branches missed.">                    for (int i = sig - coeffLen; i &gt; 0; i--)</span>
<span class="nc" id="L3508">                        buf.append('0');</span>
                } else {                     // xx.xxE form
<span class="nc" id="L3510">                    buf.append(coeff, offset, sig);</span>
<span class="nc" id="L3511">                    buf.append('.');</span>
<span class="nc" id="L3512">                    buf.append(coeff, offset + sig, coeffLen - sig);</span>
                }
            }
<span class="pc bpc" id="L3515" title="1 of 2 branches missed.">            if (adjusted != 0) {             // [!sci could have made 0]</span>
<span class="fc" id="L3516">                buf.append('E');</span>
<span class="fc bfc" id="L3517" title="All 2 branches covered.">                if (adjusted &gt; 0)            // force sign for positive</span>
<span class="fc" id="L3518">                    buf.append('+');</span>
<span class="fc" id="L3519">                buf.append(adjusted);</span>
            }
        }
<span class="fc" id="L3522">        return buf.toString();</span>
    }

    /**
     * Return 10 to the power n, as a {@code BigInteger}.
     *
     * @param  n the power of ten to be returned (&gt;=0)
     * @return a {@code BigInteger} with the value (10&lt;sup&gt;n&lt;/sup&gt;)
     */
    private static BigInteger bigTenToThe(int n) {
<span class="pc bpc" id="L3532" title="1 of 2 branches missed.">        if (n &lt; 0)</span>
<span class="nc" id="L3533">            return BigInteger.ZERO;</span>

<span class="fc bfc" id="L3535" title="All 2 branches covered.">        if (n &lt; BIG_TEN_POWERS_TABLE_MAX) {</span>
<span class="fc" id="L3536">            BigInteger[] pows = BIG_TEN_POWERS_TABLE;</span>
<span class="fc bfc" id="L3537" title="All 2 branches covered.">            if (n &lt; pows.length)</span>
<span class="fc" id="L3538">                return pows[n];</span>
            else
<span class="fc" id="L3540">                return expandBigIntegerTenPowers(n);</span>
        }

<span class="fc" id="L3543">        return BigInteger.TEN.pow(n);</span>
    }

    /**
     * Expand the BIG_TEN_POWERS_TABLE array to contain at least 10**n.
     *
     * @param n the power of ten to be returned (&gt;=0)
     * @return a {@code BigDecimal} with the value (10&lt;sup&gt;n&lt;/sup&gt;) and
     *         in the meantime, the BIG_TEN_POWERS_TABLE array gets
     *         expanded to the size greater than n.
     */
    private static BigInteger expandBigIntegerTenPowers(int n) {
<span class="fc" id="L3555">        synchronized(BigDecimal.class) {</span>
<span class="fc" id="L3556">            BigInteger[] pows = BIG_TEN_POWERS_TABLE;</span>
<span class="fc" id="L3557">            int curLen = pows.length;</span>
            // The following comparison and the above synchronized statement is
            // to prevent multiple threads from expanding the same array.
<span class="pc bpc" id="L3560" title="1 of 2 branches missed.">            if (curLen &lt;= n) {</span>
<span class="fc" id="L3561">                int newLen = curLen &lt;&lt; 1;</span>
<span class="fc bfc" id="L3562" title="All 2 branches covered.">                while (newLen &lt;= n)</span>
<span class="fc" id="L3563">                    newLen &lt;&lt;= 1;</span>
<span class="fc" id="L3564">                pows = Arrays.copyOf(pows, newLen);</span>
<span class="fc bfc" id="L3565" title="All 2 branches covered.">                for (int i = curLen; i &lt; newLen; i++)</span>
<span class="fc" id="L3566">                    pows[i] = pows[i - 1].multiply(BigInteger.TEN);</span>
                // Based on the following facts:
                // 1. pows is a private local varible;
                // 2. the following store is a volatile store.
                // the newly created array elements can be safely published.
<span class="fc" id="L3571">                BIG_TEN_POWERS_TABLE = pows;</span>
            }
<span class="fc" id="L3573">            return pows[n];</span>
<span class="nc" id="L3574">        }</span>
    }

<span class="fc" id="L3577">    private static final long[] LONG_TEN_POWERS_TABLE = {</span>
        1,                     // 0 / 10^0
        10,                    // 1 / 10^1
        100,                   // 2 / 10^2
        1000,                  // 3 / 10^3
        10000,                 // 4 / 10^4
        100000,                // 5 / 10^5
        1000000,               // 6 / 10^6
        10000000,              // 7 / 10^7
        100000000,             // 8 / 10^8
        1000000000,            // 9 / 10^9
        10000000000L,          // 10 / 10^10
        100000000000L,         // 11 / 10^11
        1000000000000L,        // 12 / 10^12
        10000000000000L,       // 13 / 10^13
        100000000000000L,      // 14 / 10^14
        1000000000000000L,     // 15 / 10^15
        10000000000000000L,    // 16 / 10^16
        100000000000000000L,   // 17 / 10^17
        1000000000000000000L   // 18 / 10^18
    };

<span class="fc" id="L3599">    private static volatile BigInteger BIG_TEN_POWERS_TABLE[] = {</span>
        BigInteger.ONE,
<span class="fc" id="L3601">        BigInteger.valueOf(10),</span>
<span class="fc" id="L3602">        BigInteger.valueOf(100),</span>
<span class="fc" id="L3603">        BigInteger.valueOf(1000),</span>
<span class="fc" id="L3604">        BigInteger.valueOf(10000),</span>
<span class="fc" id="L3605">        BigInteger.valueOf(100000),</span>
<span class="fc" id="L3606">        BigInteger.valueOf(1000000),</span>
<span class="fc" id="L3607">        BigInteger.valueOf(10000000),</span>
<span class="fc" id="L3608">        BigInteger.valueOf(100000000),</span>
<span class="fc" id="L3609">        BigInteger.valueOf(1000000000),</span>
<span class="fc" id="L3610">        BigInteger.valueOf(10000000000L),</span>
<span class="fc" id="L3611">        BigInteger.valueOf(100000000000L),</span>
<span class="fc" id="L3612">        BigInteger.valueOf(1000000000000L),</span>
<span class="fc" id="L3613">        BigInteger.valueOf(10000000000000L),</span>
<span class="fc" id="L3614">        BigInteger.valueOf(100000000000000L),</span>
<span class="fc" id="L3615">        BigInteger.valueOf(1000000000000000L),</span>
<span class="fc" id="L3616">        BigInteger.valueOf(10000000000000000L),</span>
<span class="fc" id="L3617">        BigInteger.valueOf(100000000000000000L),</span>
<span class="fc" id="L3618">        BigInteger.valueOf(1000000000000000000L)</span>
    };

<span class="fc" id="L3621">    private static final int BIG_TEN_POWERS_TABLE_INITLEN =</span>
        BIG_TEN_POWERS_TABLE.length;
<span class="fc" id="L3623">    private static final int BIG_TEN_POWERS_TABLE_MAX =</span>
        16 * BIG_TEN_POWERS_TABLE_INITLEN;

<span class="fc" id="L3626">    private static final long THRESHOLDS_TABLE[] = {</span>
        Long.MAX_VALUE,                     // 0
        Long.MAX_VALUE/10L,                 // 1
        Long.MAX_VALUE/100L,                // 2
        Long.MAX_VALUE/1000L,               // 3
        Long.MAX_VALUE/10000L,              // 4
        Long.MAX_VALUE/100000L,             // 5
        Long.MAX_VALUE/1000000L,            // 6
        Long.MAX_VALUE/10000000L,           // 7
        Long.MAX_VALUE/100000000L,          // 8
        Long.MAX_VALUE/1000000000L,         // 9
        Long.MAX_VALUE/10000000000L,        // 10
        Long.MAX_VALUE/100000000000L,       // 11
        Long.MAX_VALUE/1000000000000L,      // 12
        Long.MAX_VALUE/10000000000000L,     // 13
        Long.MAX_VALUE/100000000000000L,    // 14
        Long.MAX_VALUE/1000000000000000L,   // 15
        Long.MAX_VALUE/10000000000000000L,  // 16
        Long.MAX_VALUE/100000000000000000L, // 17
        Long.MAX_VALUE/1000000000000000000L // 18
    };

    /**
     * Compute val * 10 ^ n; return this product if it is
     * representable as a long, INFLATED otherwise.
     */
    private static long longMultiplyPowerTen(long val, int n) {
<span class="fc bfc" id="L3653" title="All 4 branches covered.">        if (val == 0 || n &lt;= 0)</span>
<span class="fc" id="L3654">            return val;</span>
<span class="fc" id="L3655">        long[] tab = LONG_TEN_POWERS_TABLE;</span>
<span class="fc" id="L3656">        long[] bounds = THRESHOLDS_TABLE;</span>
<span class="pc bpc" id="L3657" title="1 of 4 branches missed.">        if (n &lt; tab.length &amp;&amp; n &lt; bounds.length) {</span>
<span class="fc" id="L3658">            long tenpower = tab[n];</span>
<span class="fc bfc" id="L3659" title="All 2 branches covered.">            if (val == 1)</span>
<span class="fc" id="L3660">                return tenpower;</span>
<span class="fc bfc" id="L3661" title="All 2 branches covered.">            if (Math.abs(val) &lt;= bounds[n])</span>
<span class="fc" id="L3662">                return val * tenpower;</span>
        }
<span class="fc" id="L3664">        return INFLATED;</span>
    }

    /**
     * Compute this * 10 ^ n.
     * Needed mainly to allow special casing to trap zero value
     */
    private BigInteger bigMultiplyPowerTen(int n) {
<span class="pc bpc" id="L3672" title="1 of 2 branches missed.">        if (n &lt;= 0)</span>
<span class="nc" id="L3673">            return this.inflated();</span>

<span class="fc bfc" id="L3675" title="All 2 branches covered.">        if (intCompact != INFLATED)</span>
<span class="fc" id="L3676">            return bigTenToThe(n).multiply(intCompact);</span>
        else
<span class="fc" id="L3678">            return intVal.multiply(bigTenToThe(n));</span>
    }

    /**
     * Returns appropriate BigInteger from intVal field if intVal is
     * null, i.e. the compact representation is in use.
     */
    private BigInteger inflated() {
<span class="fc bfc" id="L3686" title="All 2 branches covered.">        if (intVal == null) {</span>
<span class="fc" id="L3687">            return BigInteger.valueOf(intCompact);</span>
        }
<span class="fc" id="L3689">        return intVal;</span>
    }

    /**
     * Match the scales of two {@code BigDecimal}s to align their
     * least significant digits.
     *
     * &lt;p&gt;If the scales of val[0] and val[1] differ, rescale
     * (non-destructively) the lower-scaled {@code BigDecimal} so
     * they match.  That is, the lower-scaled reference will be
     * replaced by a reference to a new object with the same scale as
     * the other {@code BigDecimal}.
     *
     * @param  val array of two elements referring to the two
     *         {@code BigDecimal}s to be aligned.
     */
    private static void matchScale(BigDecimal[] val) {
<span class="nc bnc" id="L3706" title="All 2 branches missed.">        if (val[0].scale == val[1].scale) {</span>
<span class="nc" id="L3707">            return;</span>
<span class="nc bnc" id="L3708" title="All 2 branches missed.">        } else if (val[0].scale &lt; val[1].scale) {</span>
<span class="nc" id="L3709">            val[0] = val[0].setScale(val[1].scale, ROUND_UNNECESSARY);</span>
<span class="nc bnc" id="L3710" title="All 2 branches missed.">        } else if (val[1].scale &lt; val[0].scale) {</span>
<span class="nc" id="L3711">            val[1] = val[1].setScale(val[0].scale, ROUND_UNNECESSARY);</span>
        }
<span class="nc" id="L3713">    }</span>

<span class="nc" id="L3715">    private static class UnsafeHolder {</span>
        private static final sun.misc.Unsafe unsafe;
        private static final long intCompactOffset;
        private static final long intValOffset;
        static {
            try {
<span class="fc" id="L3721">                unsafe = sun.misc.Unsafe.getUnsafe();</span>
<span class="fc" id="L3722">                intCompactOffset = unsafe.objectFieldOffset</span>
<span class="fc" id="L3723">                    (BigDecimal.class.getDeclaredField(&quot;intCompact&quot;));</span>
<span class="fc" id="L3724">                intValOffset = unsafe.objectFieldOffset</span>
<span class="fc" id="L3725">                    (BigDecimal.class.getDeclaredField(&quot;intVal&quot;));</span>
<span class="nc" id="L3726">            } catch (Exception ex) {</span>
<span class="nc" id="L3727">                throw new ExceptionInInitializerError(ex);</span>
<span class="fc" id="L3728">            }</span>
<span class="fc" id="L3729">        }</span>
        static void setIntCompactVolatile(BigDecimal bd, long val) {
<span class="fc" id="L3731">            unsafe.putLongVolatile(bd, intCompactOffset, val);</span>
<span class="fc" id="L3732">        }</span>

        static void setIntValVolatile(BigDecimal bd, BigInteger val) {
<span class="fc" id="L3735">            unsafe.putObjectVolatile(bd, intValOffset, val);</span>
<span class="fc" id="L3736">        }</span>
    }

    /**
     * Reconstitute the {@code BigDecimal} instance from a stream (that is,
     * deserialize it).
     *
     * @param s the stream being read.
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in all fields
<span class="fc" id="L3748">        s.defaultReadObject();</span>
        // validate possibly bad fields
<span class="pc bpc" id="L3750" title="1 of 2 branches missed.">        if (intVal == null) {</span>
<span class="nc" id="L3751">            String message = &quot;BigDecimal: null intVal in stream&quot;;</span>
<span class="nc" id="L3752">            throw new java.io.StreamCorruptedException(message);</span>
        // [all values of scale are now allowed]
        }
<span class="fc" id="L3755">        UnsafeHolder.setIntCompactVolatile(this, compactValFor(intVal));</span>
<span class="fc" id="L3756">    }</span>

   /**
    * Serialize this {@code BigDecimal} to the stream in question
    *
    * @param s the stream to serialize to.
    */
   private void writeObject(java.io.ObjectOutputStream s)
       throws java.io.IOException {
       // Must inflate to maintain compatible serial form.
<span class="fc bfc" id="L3766" title="All 2 branches covered.">       if (this.intVal == null)</span>
<span class="fc" id="L3767">           UnsafeHolder.setIntValVolatile(this, BigInteger.valueOf(this.intCompact));</span>
       // Could reset intVal back to null if it has to be set.
<span class="fc" id="L3769">       s.defaultWriteObject();</span>
<span class="fc" id="L3770">   }</span>

    /**
     * Returns the length of the absolute value of a {@code long}, in decimal
     * digits.
     *
     * @param x the {@code long}
     * @return the length of the unscaled value, in deciaml digits.
     */
    static int longDigitLength(long x) {
        /*
         * As described in &quot;Bit Twiddling Hacks&quot; by Sean Anderson,
         * (http://graphics.stanford.edu/~seander/bithacks.html)
         * integer log 10 of x is within 1 of (1233/4096)* (1 +
         * integer log 2 of x). The fraction 1233/4096 approximates
         * log10(2). So we first do a version of log2 (a variant of
         * Long class with pre-checks and opposite directionality) and
         * then scale and check against powers table. This is a little
         * simpler in present context than the version in Hacker's
         * Delight sec 11-4. Adding one to bit length allows comparing
         * downward from the LONG_TEN_POWERS_TABLE that we need
         * anyway.
         */
<span class="pc bpc" id="L3793" title="2 of 4 branches missed.">        assert x != BigDecimal.INFLATED;</span>
<span class="fc bfc" id="L3794" title="All 2 branches covered.">        if (x &lt; 0)</span>
<span class="fc" id="L3795">            x = -x;</span>
<span class="fc bfc" id="L3796" title="All 2 branches covered.">        if (x &lt; 10) // must screen for 0, might as well 10</span>
<span class="fc" id="L3797">            return 1;</span>
<span class="fc" id="L3798">        int r = ((64 - Long.numberOfLeadingZeros(x) + 1) * 1233) &gt;&gt;&gt; 12;</span>
<span class="fc" id="L3799">        long[] tab = LONG_TEN_POWERS_TABLE;</span>
        // if r &gt;= length, must have max possible digits for long
<span class="fc bfc" id="L3801" title="All 4 branches covered.">        return (r &gt;= tab.length || x &lt; tab[r]) ? r : r + 1;</span>
    }

    /**
     * Returns the length of the absolute value of a BigInteger, in
     * decimal digits.
     *
     * @param b the BigInteger
     * @return the length of the unscaled value, in decimal digits
     */
    private static int bigDigitLength(BigInteger b) {
        /*
         * Same idea as the long version, but we need a better
         * approximation of log10(2). Using 646456993/2^31
         * is accurate up to max possible reported bitLength.
         */
<span class="pc bpc" id="L3817" title="1 of 2 branches missed.">        if (b.signum == 0)</span>
<span class="nc" id="L3818">            return 1;</span>
<span class="fc" id="L3819">        int r = (int)((((long)b.bitLength() + 1) * 646456993) &gt;&gt;&gt; 31);</span>
<span class="fc bfc" id="L3820" title="All 2 branches covered.">        return b.compareMagnitude(bigTenToThe(r)) &lt; 0? r : r+1;</span>
    }

    /**
     * Check a scale for Underflow or Overflow.  If this BigDecimal is
     * nonzero, throw an exception if the scale is outof range. If this
     * is zero, saturate the scale to the extreme value of the right
     * sign if the scale is out of range.
     *
     * @param val The new scale.
     * @throws ArithmeticException (overflow or underflow) if the new
     *         scale is out of range.
     * @return validated scale as an int.
     */
    private int checkScale(long val) {
<span class="fc" id="L3835">        int asInt = (int)val;</span>
<span class="pc bpc" id="L3836" title="1 of 2 branches missed.">        if (asInt != val) {</span>
<span class="nc bnc" id="L3837" title="All 2 branches missed.">            asInt = val&gt;Integer.MAX_VALUE ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span>
            BigInteger b;
<span class="nc bnc" id="L3839" title="All 4 branches missed.">            if (intCompact != 0 &amp;&amp;</span>
<span class="nc bnc" id="L3840" title="All 2 branches missed.">                ((b = intVal) == null || b.signum() != 0))</span>
<span class="nc bnc" id="L3841" title="All 2 branches missed.">                throw new ArithmeticException(asInt&gt;0 ? &quot;Underflow&quot;:&quot;Overflow&quot;);</span>
        }
<span class="fc" id="L3843">        return asInt;</span>
    }

   /**
     * Returns the compact value for given {@code BigInteger}, or
     * INFLATED if too big. Relies on internal representation of
     * {@code BigInteger}.
     */
    private static long compactValFor(BigInteger b) {
<span class="fc" id="L3852">        int[] m = b.mag;</span>
<span class="fc" id="L3853">        int len = m.length;</span>
<span class="fc bfc" id="L3854" title="All 2 branches covered.">        if (len == 0)</span>
<span class="fc" id="L3855">            return 0;</span>
<span class="fc" id="L3856">        int d = m[0];</span>
<span class="fc bfc" id="L3857" title="All 6 branches covered.">        if (len &gt; 2 || (len == 2 &amp;&amp; d &lt; 0))</span>
<span class="fc" id="L3858">            return INFLATED;</span>

<span class="fc bfc" id="L3860" title="All 2 branches covered.">        long u = (len == 2)?</span>
            (((long) m[1] &amp; LONG_MASK) + (((long)d) &lt;&lt; 32)) :
            (((long)d)   &amp; LONG_MASK);
<span class="fc bfc" id="L3863" title="All 2 branches covered.">        return (b.signum &lt; 0)? -u : u;</span>
    }

    private static int longCompareMagnitude(long x, long y) {
<span class="fc bfc" id="L3867" title="All 2 branches covered.">        if (x &lt; 0)</span>
<span class="fc" id="L3868">            x = -x;</span>
<span class="fc bfc" id="L3869" title="All 2 branches covered.">        if (y &lt; 0)</span>
<span class="fc" id="L3870">            y = -y;</span>
<span class="fc bfc" id="L3871" title="All 4 branches covered.">        return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);</span>
    }

    private static int saturateLong(long s) {
<span class="fc" id="L3875">        int i = (int)s;</span>
<span class="pc bpc" id="L3876" title="3 of 4 branches missed.">        return (s == i) ? i : (s &lt; 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE);</span>
    }

    /*
     * Internal printing routine
     */
    private static void print(String name, BigDecimal bd) {
<span class="nc" id="L3883">        System.err.format(&quot;%s:\tintCompact %d\tintVal %d\tscale %d\tprecision %d%n&quot;,</span>
                          name,
<span class="nc" id="L3885">                          bd.intCompact,</span>
                          bd.intVal,
<span class="nc" id="L3887">                          bd.scale,</span>
<span class="nc" id="L3888">                          bd.precision);</span>
<span class="nc" id="L3889">    }</span>

    /**
     * Check internal invariants of this BigDecimal.  These invariants
     * include:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;The object must be initialized; either intCompact must not be
     * INFLATED or intVal is non-null.  Both of these conditions may
     * be true.
     *
     * &lt;li&gt;If both intCompact and intVal and set, their values must be
     * consistent.
     *
     * &lt;li&gt;If precision is nonzero, it must have the right value.
     * &lt;/ul&gt;
     *
     * Note: Since this is an audit method, we are not supposed to change the
     * state of this BigDecimal object.
     */
    private BigDecimal audit() {
<span class="nc bnc" id="L3911" title="All 2 branches missed.">        if (intCompact == INFLATED) {</span>
<span class="nc bnc" id="L3912" title="All 2 branches missed.">            if (intVal == null) {</span>
<span class="nc" id="L3913">                print(&quot;audit&quot;, this);</span>
<span class="nc" id="L3914">                throw new AssertionError(&quot;null intVal&quot;);</span>
            }
            // Check precision
<span class="nc bnc" id="L3917" title="All 4 branches missed.">            if (precision &gt; 0 &amp;&amp; precision != bigDigitLength(intVal)) {</span>
<span class="nc" id="L3918">                print(&quot;audit&quot;, this);</span>
<span class="nc" id="L3919">                throw new AssertionError(&quot;precision mismatch&quot;);</span>
            }
        } else {
<span class="nc bnc" id="L3922" title="All 2 branches missed.">            if (intVal != null) {</span>
<span class="nc" id="L3923">                long val = intVal.longValue();</span>
<span class="nc bnc" id="L3924" title="All 2 branches missed.">                if (val != intCompact) {</span>
<span class="nc" id="L3925">                    print(&quot;audit&quot;, this);</span>
<span class="nc" id="L3926">                    throw new AssertionError(&quot;Inconsistent state, intCompact=&quot; +</span>
                                             intCompact + &quot;\t intVal=&quot; + val);
                }
            }
            // Check precision
<span class="nc bnc" id="L3931" title="All 4 branches missed.">            if (precision &gt; 0 &amp;&amp; precision != longDigitLength(intCompact)) {</span>
<span class="nc" id="L3932">                print(&quot;audit&quot;, this);</span>
<span class="nc" id="L3933">                throw new AssertionError(&quot;precision mismatch&quot;);</span>
            }
        }
<span class="nc" id="L3936">        return this;</span>
    }

    /* the same as checkScale where value!=0 */
    private static int checkScaleNonZero(long val) {
<span class="fc" id="L3941">        int asInt = (int)val;</span>
<span class="fc bfc" id="L3942" title="All 2 branches covered.">        if (asInt != val) {</span>
<span class="pc bpc" id="L3943" title="1 of 2 branches missed.">            throw new ArithmeticException(asInt&gt;0 ? &quot;Underflow&quot;:&quot;Overflow&quot;);</span>
        }
<span class="fc" id="L3945">        return asInt;</span>
    }

    private static int checkScale(long intCompact, long val) {
<span class="fc" id="L3949">        int asInt = (int)val;</span>
<span class="pc bpc" id="L3950" title="1 of 2 branches missed.">        if (asInt != val) {</span>
<span class="nc bnc" id="L3951" title="All 2 branches missed.">            asInt = val&gt;Integer.MAX_VALUE ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L3952" title="All 2 branches missed.">            if (intCompact != 0)</span>
<span class="nc bnc" id="L3953" title="All 2 branches missed.">                throw new ArithmeticException(asInt&gt;0 ? &quot;Underflow&quot;:&quot;Overflow&quot;);</span>
        }
<span class="fc" id="L3955">        return asInt;</span>
    }

    private static int checkScale(BigInteger intVal, long val) {
<span class="fc" id="L3959">        int asInt = (int)val;</span>
<span class="pc bpc" id="L3960" title="1 of 2 branches missed.">        if (asInt != val) {</span>
<span class="nc bnc" id="L3961" title="All 2 branches missed.">            asInt = val&gt;Integer.MAX_VALUE ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L3962" title="All 2 branches missed.">            if (intVal.signum() != 0)</span>
<span class="nc bnc" id="L3963" title="All 2 branches missed.">                throw new ArithmeticException(asInt&gt;0 ? &quot;Underflow&quot;:&quot;Overflow&quot;);</span>
        }
<span class="fc" id="L3965">        return asInt;</span>
    }

    /**
     * Returns a {@code BigDecimal} rounded according to the MathContext
     * settings;
     * If rounding is needed a new {@code BigDecimal} is created and returned.
     *
     * @param val the value to be rounded
     * @param mc the context to use.
     * @return a {@code BigDecimal} rounded according to the MathContext
     *         settings.  May return {@code value}, if no rounding needed.
     * @throws ArithmeticException if the rounding mode is
     *         {@code RoundingMode.UNNECESSARY} and the
     *         result is inexact.
     */
    private static BigDecimal doRound(BigDecimal val, MathContext mc) {
<span class="fc" id="L3982">        int mcp = mc.precision;</span>
<span class="fc" id="L3983">        boolean wasDivided = false;</span>
<span class="pc bpc" id="L3984" title="1 of 2 branches missed.">        if (mcp &gt; 0) {</span>
<span class="fc" id="L3985">            BigInteger intVal = val.intVal;</span>
<span class="fc" id="L3986">            long compactVal = val.intCompact;</span>
<span class="fc" id="L3987">            int scale = val.scale;</span>
<span class="fc" id="L3988">            int prec = val.precision();</span>
<span class="fc" id="L3989">            int mode = mc.roundingMode.oldMode;</span>
            int drop;
<span class="fc bfc" id="L3991" title="All 2 branches covered.">            if (compactVal == INFLATED) {</span>
<span class="fc" id="L3992">                drop = prec - mcp;</span>
<span class="fc bfc" id="L3993" title="All 2 branches covered.">                while (drop &gt; 0) {</span>
<span class="fc" id="L3994">                    scale = checkScaleNonZero((long) scale - drop);</span>
<span class="fc" id="L3995">                    intVal = divideAndRoundByTenPow(intVal, drop, mode);</span>
<span class="fc" id="L3996">                    wasDivided = true;</span>
<span class="fc" id="L3997">                    compactVal = compactValFor(intVal);</span>
<span class="fc bfc" id="L3998" title="All 2 branches covered.">                    if (compactVal != INFLATED) {</span>
<span class="fc" id="L3999">                        prec = longDigitLength(compactVal);</span>
<span class="fc" id="L4000">                        break;</span>
                    }
<span class="fc" id="L4002">                    prec = bigDigitLength(intVal);</span>
<span class="fc" id="L4003">                    drop = prec - mcp;</span>
                }
            }
<span class="fc bfc" id="L4006" title="All 2 branches covered.">            if (compactVal != INFLATED) {</span>
<span class="fc" id="L4007">                drop = prec - mcp;  // drop can't be more than 18</span>
<span class="fc bfc" id="L4008" title="All 2 branches covered.">                while (drop &gt; 0) {</span>
<span class="fc" id="L4009">                    scale = checkScaleNonZero((long) scale - drop);</span>
<span class="fc" id="L4010">                    compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);</span>
<span class="fc" id="L4011">                    wasDivided = true;</span>
<span class="fc" id="L4012">                    prec = longDigitLength(compactVal);</span>
<span class="fc" id="L4013">                    drop = prec - mcp;</span>
<span class="fc" id="L4014">                    intVal = null;</span>
                }
            }
<span class="fc bfc" id="L4017" title="All 2 branches covered.">            return wasDivided ? new BigDecimal(intVal,compactVal,scale,prec) : val;</span>
        }
<span class="nc" id="L4019">        return val;</span>
    }

    /*
     * Returns a {@code BigDecimal} created from {@code long} value with
     * given scale rounded according to the MathContext settings
     */
    private static BigDecimal doRound(long compactVal, int scale, MathContext mc) {
<span class="nc" id="L4027">        int mcp = mc.precision;</span>
<span class="nc bnc" id="L4028" title="All 4 branches missed.">        if (mcp &gt; 0 &amp;&amp; mcp &lt; 19) {</span>
<span class="nc" id="L4029">            int prec = longDigitLength(compactVal);</span>
<span class="nc" id="L4030">            int drop = prec - mcp;  // drop can't be more than 18</span>
<span class="nc bnc" id="L4031" title="All 2 branches missed.">            while (drop &gt; 0) {</span>
<span class="nc" id="L4032">                scale = checkScaleNonZero((long) scale - drop);</span>
<span class="nc" id="L4033">                compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);</span>
<span class="nc" id="L4034">                prec = longDigitLength(compactVal);</span>
<span class="nc" id="L4035">                drop = prec - mcp;</span>
            }
<span class="nc" id="L4037">            return valueOf(compactVal, scale, prec);</span>
        }
<span class="nc" id="L4039">        return valueOf(compactVal, scale);</span>
    }

    /*
     * Returns a {@code BigDecimal} created from {@code BigInteger} value with
     * given scale rounded according to the MathContext settings
     */
    private static BigDecimal doRound(BigInteger intVal, int scale, MathContext mc) {
<span class="nc" id="L4047">        int mcp = mc.precision;</span>
<span class="nc" id="L4048">        int prec = 0;</span>
<span class="nc bnc" id="L4049" title="All 2 branches missed.">        if (mcp &gt; 0) {</span>
<span class="nc" id="L4050">            long compactVal = compactValFor(intVal);</span>
<span class="nc" id="L4051">            int mode = mc.roundingMode.oldMode;</span>
            int drop;
<span class="nc bnc" id="L4053" title="All 2 branches missed.">            if (compactVal == INFLATED) {</span>
<span class="nc" id="L4054">                prec = bigDigitLength(intVal);</span>
<span class="nc" id="L4055">                drop = prec - mcp;</span>
<span class="nc bnc" id="L4056" title="All 2 branches missed.">                while (drop &gt; 0) {</span>
<span class="nc" id="L4057">                    scale = checkScaleNonZero((long) scale - drop);</span>
<span class="nc" id="L4058">                    intVal = divideAndRoundByTenPow(intVal, drop, mode);</span>
<span class="nc" id="L4059">                    compactVal = compactValFor(intVal);</span>
<span class="nc bnc" id="L4060" title="All 2 branches missed.">                    if (compactVal != INFLATED) {</span>
<span class="nc" id="L4061">                        break;</span>
                    }
<span class="nc" id="L4063">                    prec = bigDigitLength(intVal);</span>
<span class="nc" id="L4064">                    drop = prec - mcp;</span>
                }
            }
<span class="nc bnc" id="L4067" title="All 2 branches missed.">            if (compactVal != INFLATED) {</span>
<span class="nc" id="L4068">                prec = longDigitLength(compactVal);</span>
<span class="nc" id="L4069">                drop = prec - mcp;     // drop can't be more than 18</span>
<span class="nc bnc" id="L4070" title="All 2 branches missed.">                while (drop &gt; 0) {</span>
<span class="nc" id="L4071">                    scale = checkScaleNonZero((long) scale - drop);</span>
<span class="nc" id="L4072">                    compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);</span>
<span class="nc" id="L4073">                    prec = longDigitLength(compactVal);</span>
<span class="nc" id="L4074">                    drop = prec - mcp;</span>
                }
<span class="nc" id="L4076">                return valueOf(compactVal,scale,prec);</span>
            }
        }
<span class="nc" id="L4079">        return new BigDecimal(intVal,INFLATED,scale,prec);</span>
    }

    /*
     * Divides {@code BigInteger} value by ten power.
     */
    private static BigInteger divideAndRoundByTenPow(BigInteger intVal, int tenPow, int roundingMode) {
<span class="fc bfc" id="L4086" title="All 2 branches covered.">        if (tenPow &lt; LONG_TEN_POWERS_TABLE.length)</span>
<span class="fc" id="L4087">            intVal = divideAndRound(intVal, LONG_TEN_POWERS_TABLE[tenPow], roundingMode);</span>
        else
<span class="fc" id="L4089">            intVal = divideAndRound(intVal, bigTenToThe(tenPow), roundingMode);</span>
<span class="fc" id="L4090">        return intVal;</span>
    }

    /**
     * Internally used for division operation for division {@code long} by
     * {@code long}.
     * The returned {@code BigDecimal} object is the quotient whose scale is set
     * to the passed in scale. If the remainder is not zero, it will be rounded
     * based on the passed in roundingMode. Also, if the remainder is zero and
     * the last parameter, i.e. preferredScale is NOT equal to scale, the
     * trailing zeros of the result is stripped to match the preferredScale.
     */
    private static BigDecimal divideAndRound(long ldividend, long ldivisor, int scale, int roundingMode,
                                             int preferredScale) {

        int qsign; // quotient sign
<span class="fc" id="L4106">        long q = ldividend / ldivisor; // store quotient in long</span>
<span class="pc bpc" id="L4107" title="3 of 4 branches missed.">        if (roundingMode == ROUND_DOWN &amp;&amp; scale == preferredScale)</span>
<span class="nc" id="L4108">            return valueOf(q, scale);</span>
<span class="fc" id="L4109">        long r = ldividend % ldivisor; // store remainder in long</span>
<span class="fc bfc" id="L4110" title="All 6 branches covered.">        qsign = ((ldividend &lt; 0) == (ldivisor &lt; 0)) ? 1 : -1;</span>
<span class="fc bfc" id="L4111" title="All 2 branches covered.">        if (r != 0) {</span>
<span class="fc" id="L4112">            boolean increment = needIncrement(ldivisor, roundingMode, qsign, q, r);</span>
<span class="fc bfc" id="L4113" title="All 2 branches covered.">            return valueOf((increment ? q + qsign : q), scale);</span>
        } else {
<span class="fc bfc" id="L4115" title="All 2 branches covered.">            if (preferredScale != scale)</span>
<span class="fc" id="L4116">                return createAndStripZerosToMatchScale(q, scale, preferredScale);</span>
            else
<span class="fc" id="L4118">                return valueOf(q, scale);</span>
        }
    }

    /**
     * Divides {@code long} by {@code long} and do rounding based on the
     * passed in roundingMode.
     */
    private static long divideAndRound(long ldividend, long ldivisor, int roundingMode) {
        int qsign; // quotient sign
<span class="fc" id="L4128">        long q = ldividend / ldivisor; // store quotient in long</span>
<span class="pc bpc" id="L4129" title="1 of 2 branches missed.">        if (roundingMode == ROUND_DOWN)</span>
<span class="nc" id="L4130">            return q;</span>
<span class="fc" id="L4131">        long r = ldividend % ldivisor; // store remainder in long</span>
<span class="pc bpc" id="L4132" title="1 of 6 branches missed.">        qsign = ((ldividend &lt; 0) == (ldivisor &lt; 0)) ? 1 : -1;</span>
<span class="fc bfc" id="L4133" title="All 2 branches covered.">        if (r != 0) {</span>
<span class="fc" id="L4134">            boolean increment = needIncrement(ldivisor, roundingMode, qsign, q,     r);</span>
<span class="fc bfc" id="L4135" title="All 2 branches covered.">            return increment ? q + qsign : q;</span>
        } else {
<span class="fc" id="L4137">            return q;</span>
        }
    }

    /**
     * Shared logic of need increment computation.
     */
    private static boolean commonNeedIncrement(int roundingMode, int qsign,
                                        int cmpFracHalf, boolean oddQuot) {
<span class="pc bpc" id="L4146" title="3 of 6 branches missed.">        switch(roundingMode) {</span>
        case ROUND_UNNECESSARY:
<span class="nc" id="L4148">            throw new ArithmeticException(&quot;Rounding necessary&quot;);</span>

        case ROUND_UP: // Away from zero
<span class="nc" id="L4151">            return true;</span>

        case ROUND_DOWN: // Towards zero
<span class="nc" id="L4154">            return false;</span>

        case ROUND_CEILING: // Towards +infinity
<span class="fc bfc" id="L4157" title="All 2 branches covered.">            return qsign &gt; 0;</span>

        case ROUND_FLOOR: // Towards -infinity
<span class="fc bfc" id="L4160" title="All 2 branches covered.">            return qsign &lt; 0;</span>

        default: // Some kind of half-way rounding
<span class="pc bpc" id="L4163" title="2 of 6 branches missed.">            assert roundingMode &gt;= ROUND_HALF_UP &amp;&amp;</span>
<span class="nc" id="L4164">                roundingMode &lt;= ROUND_HALF_EVEN: &quot;Unexpected rounding mode&quot; + RoundingMode.valueOf(roundingMode);</span>

<span class="fc bfc" id="L4166" title="All 2 branches covered.">            if (cmpFracHalf &lt; 0 ) // We're closer to higher digit</span>
<span class="fc" id="L4167">                return false;</span>
<span class="fc bfc" id="L4168" title="All 2 branches covered.">            else if (cmpFracHalf &gt; 0 ) // We're closer to lower digit</span>
<span class="fc" id="L4169">                return true;</span>
            else { // half-way
<span class="pc bpc" id="L4171" title="2 of 4 branches missed.">                assert cmpFracHalf == 0;</span>

<span class="pc bpc" id="L4173" title="3 of 4 branches missed.">                switch(roundingMode) {</span>
                case ROUND_HALF_DOWN:
<span class="nc" id="L4175">                    return false;</span>

                case ROUND_HALF_UP:
<span class="fc" id="L4178">                    return true;</span>

                case ROUND_HALF_EVEN:
<span class="nc" id="L4181">                    return oddQuot;</span>

                default:
<span class="nc" id="L4184">                    throw new AssertionError(&quot;Unexpected rounding mode&quot; + roundingMode);</span>
                }
            }
        }
    }

    /**
     * Tests if quotient has to be incremented according the roundingMode
     */
    private static boolean needIncrement(long ldivisor, int roundingMode,
                                         int qsign, long q, long r) {
<span class="pc bpc" id="L4195" title="1 of 4 branches missed.">        assert r != 0L;</span>

        int cmpFracHalf;
<span class="pc bpc" id="L4198" title="2 of 4 branches missed.">        if (r &lt;= HALF_LONG_MIN_VALUE || r &gt; HALF_LONG_MAX_VALUE) {</span>
<span class="nc" id="L4199">            cmpFracHalf = 1; // 2 * r can't fit into long</span>
        } else {
<span class="fc" id="L4201">            cmpFracHalf = longCompareMagnitude(2 * r, ldivisor);</span>
        }

<span class="fc bfc" id="L4204" title="All 2 branches covered.">        return commonNeedIncrement(roundingMode, qsign, cmpFracHalf, (q &amp; 1L) != 0L);</span>
    }

    /**
     * Divides {@code BigInteger} value by {@code long} value and
     * do rounding based on the passed in roundingMode.
     */
    private static BigInteger divideAndRound(BigInteger bdividend, long ldivisor, int roundingMode) {
        boolean isRemainderZero; // record remainder is zero or not
        int qsign; // quotient sign
<span class="fc" id="L4214">        long r = 0; // store quotient &amp; remainder in long</span>
<span class="fc" id="L4215">        MutableBigInteger mq = null; // store quotient</span>
        // Descend into mutables for faster remainder checks
<span class="fc" id="L4217">        MutableBigInteger mdividend = new MutableBigInteger(bdividend.mag);</span>
<span class="fc" id="L4218">        mq = new MutableBigInteger();</span>
<span class="fc" id="L4219">        r = mdividend.divide(ldivisor, mq);</span>
<span class="pc bpc" id="L4220" title="1 of 2 branches missed.">        isRemainderZero = (r == 0);</span>
<span class="pc bpc" id="L4221" title="1 of 2 branches missed.">        qsign = (ldivisor &lt; 0) ? -bdividend.signum : bdividend.signum;</span>
<span class="pc bpc" id="L4222" title="1 of 2 branches missed.">        if (!isRemainderZero) {</span>
<span class="fc bfc" id="L4223" title="All 2 branches covered.">            if(needIncrement(ldivisor, roundingMode, qsign, mq, r)) {</span>
<span class="fc" id="L4224">                mq.add(MutableBigInteger.ONE);</span>
            }
        }
<span class="fc" id="L4227">        return mq.toBigInteger(qsign);</span>
    }

    /**
     * Internally used for division operation for division {@code BigInteger}
     * by {@code long}.
     * The returned {@code BigDecimal} object is the quotient whose scale is set
     * to the passed in scale. If the remainder is not zero, it will be rounded
     * based on the passed in roundingMode. Also, if the remainder is zero and
     * the last parameter, i.e. preferredScale is NOT equal to scale, the
     * trailing zeros of the result is stripped to match the preferredScale.
     */
    private static BigDecimal divideAndRound(BigInteger bdividend,
                                             long ldivisor, int scale, int roundingMode, int preferredScale) {
        boolean isRemainderZero; // record remainder is zero or not
        int qsign; // quotient sign
<span class="fc" id="L4243">        long r = 0; // store quotient &amp; remainder in long</span>
<span class="fc" id="L4244">        MutableBigInteger mq = null; // store quotient</span>
        // Descend into mutables for faster remainder checks
<span class="fc" id="L4246">        MutableBigInteger mdividend = new MutableBigInteger(bdividend.mag);</span>
<span class="fc" id="L4247">        mq = new MutableBigInteger();</span>
<span class="fc" id="L4248">        r = mdividend.divide(ldivisor, mq);</span>
<span class="fc bfc" id="L4249" title="All 2 branches covered.">        isRemainderZero = (r == 0);</span>
<span class="fc bfc" id="L4250" title="All 2 branches covered.">        qsign = (ldivisor &lt; 0) ? -bdividend.signum : bdividend.signum;</span>
<span class="fc bfc" id="L4251" title="All 2 branches covered.">        if (!isRemainderZero) {</span>
<span class="fc bfc" id="L4252" title="All 2 branches covered.">            if(needIncrement(ldivisor, roundingMode, qsign, mq, r)) {</span>
<span class="fc" id="L4253">                mq.add(MutableBigInteger.ONE);</span>
            }
<span class="fc" id="L4255">            return mq.toBigDecimal(qsign, scale);</span>
        } else {
<span class="fc bfc" id="L4257" title="All 2 branches covered.">            if (preferredScale != scale) {</span>
<span class="fc" id="L4258">                long compactVal = mq.toCompactValue(qsign);</span>
<span class="fc bfc" id="L4259" title="All 2 branches covered.">                if(compactVal!=INFLATED) {</span>
<span class="fc" id="L4260">                    return createAndStripZerosToMatchScale(compactVal, scale, preferredScale);</span>
                }
<span class="fc" id="L4262">                BigInteger intVal =  mq.toBigInteger(qsign);</span>
<span class="fc" id="L4263">                return createAndStripZerosToMatchScale(intVal,scale, preferredScale);</span>
            } else {
<span class="fc" id="L4265">                return mq.toBigDecimal(qsign, scale);</span>
            }
        }
    }

    /**
     * Tests if quotient has to be incremented according the roundingMode
     */
    private static boolean needIncrement(long ldivisor, int roundingMode,
                                         int qsign, MutableBigInteger mq, long r) {
<span class="pc bpc" id="L4275" title="2 of 4 branches missed.">        assert r != 0L;</span>

        int cmpFracHalf;
<span class="pc bpc" id="L4278" title="1 of 4 branches missed.">        if (r &lt;= HALF_LONG_MIN_VALUE || r &gt; HALF_LONG_MAX_VALUE) {</span>
<span class="fc" id="L4279">            cmpFracHalf = 1; // 2 * r can't fit into long</span>
        } else {
<span class="fc" id="L4281">            cmpFracHalf = longCompareMagnitude(2 * r, ldivisor);</span>
        }

<span class="fc" id="L4284">        return commonNeedIncrement(roundingMode, qsign, cmpFracHalf, mq.isOdd());</span>
    }

    /**
     * Divides {@code BigInteger} value by {@code BigInteger} value and
     * do rounding based on the passed in roundingMode.
     */
    private static BigInteger divideAndRound(BigInteger bdividend, BigInteger bdivisor, int roundingMode) {
        boolean isRemainderZero; // record remainder is zero or not
        int qsign; // quotient sign
        // Descend into mutables for faster remainder checks
<span class="fc" id="L4295">        MutableBigInteger mdividend = new MutableBigInteger(bdividend.mag);</span>
<span class="fc" id="L4296">        MutableBigInteger mq = new MutableBigInteger();</span>
<span class="fc" id="L4297">        MutableBigInteger mdivisor = new MutableBigInteger(bdivisor.mag);</span>
<span class="fc" id="L4298">        MutableBigInteger mr = mdividend.divide(mdivisor, mq);</span>
<span class="fc" id="L4299">        isRemainderZero = mr.isZero();</span>
<span class="pc bpc" id="L4300" title="1 of 2 branches missed.">        qsign = (bdividend.signum != bdivisor.signum) ? -1 : 1;</span>
<span class="pc bpc" id="L4301" title="1 of 2 branches missed.">        if (!isRemainderZero) {</span>
<span class="fc bfc" id="L4302" title="All 2 branches covered.">            if (needIncrement(mdivisor, roundingMode, qsign, mq, mr)) {</span>
<span class="fc" id="L4303">                mq.add(MutableBigInteger.ONE);</span>
            }
        }
<span class="fc" id="L4306">        return mq.toBigInteger(qsign);</span>
    }

    /**
     * Internally used for division operation for division {@code BigInteger}
     * by {@code BigInteger}.
     * The returned {@code BigDecimal} object is the quotient whose scale is set
     * to the passed in scale. If the remainder is not zero, it will be rounded
     * based on the passed in roundingMode. Also, if the remainder is zero and
     * the last parameter, i.e. preferredScale is NOT equal to scale, the
     * trailing zeros of the result is stripped to match the preferredScale.
     */
    private static BigDecimal divideAndRound(BigInteger bdividend, BigInteger bdivisor, int scale, int roundingMode,
                                             int preferredScale) {
        boolean isRemainderZero; // record remainder is zero or not
        int qsign; // quotient sign
        // Descend into mutables for faster remainder checks
<span class="fc" id="L4323">        MutableBigInteger mdividend = new MutableBigInteger(bdividend.mag);</span>
<span class="fc" id="L4324">        MutableBigInteger mq = new MutableBigInteger();</span>
<span class="fc" id="L4325">        MutableBigInteger mdivisor = new MutableBigInteger(bdivisor.mag);</span>
<span class="fc" id="L4326">        MutableBigInteger mr = mdividend.divide(mdivisor, mq);</span>
<span class="fc" id="L4327">        isRemainderZero = mr.isZero();</span>
<span class="pc bpc" id="L4328" title="1 of 2 branches missed.">        qsign = (bdividend.signum != bdivisor.signum) ? -1 : 1;</span>
<span class="fc bfc" id="L4329" title="All 2 branches covered.">        if (!isRemainderZero) {</span>
<span class="fc bfc" id="L4330" title="All 2 branches covered.">            if (needIncrement(mdivisor, roundingMode, qsign, mq, mr)) {</span>
<span class="fc" id="L4331">                mq.add(MutableBigInteger.ONE);</span>
            }
<span class="fc" id="L4333">            return mq.toBigDecimal(qsign, scale);</span>
        } else {
<span class="pc bpc" id="L4335" title="1 of 2 branches missed.">            if (preferredScale != scale) {</span>
<span class="fc" id="L4336">                long compactVal = mq.toCompactValue(qsign);</span>
<span class="fc bfc" id="L4337" title="All 2 branches covered.">                if (compactVal != INFLATED) {</span>
<span class="fc" id="L4338">                    return createAndStripZerosToMatchScale(compactVal, scale, preferredScale);</span>
                }
<span class="fc" id="L4340">                BigInteger intVal = mq.toBigInteger(qsign);</span>
<span class="fc" id="L4341">                return createAndStripZerosToMatchScale(intVal, scale, preferredScale);</span>
            } else {
<span class="nc" id="L4343">                return mq.toBigDecimal(qsign, scale);</span>
            }
        }
    }

    /**
     * Tests if quotient has to be incremented according the roundingMode
     */
    private static boolean needIncrement(MutableBigInteger mdivisor, int roundingMode,
                                         int qsign, MutableBigInteger mq, MutableBigInteger mr) {
<span class="pc bpc" id="L4353" title="2 of 4 branches missed.">        assert !mr.isZero();</span>
<span class="fc" id="L4354">        int cmpFracHalf = mr.compareHalf(mdivisor);</span>
<span class="fc" id="L4355">        return commonNeedIncrement(roundingMode, qsign, cmpFracHalf, mq.isOdd());</span>
    }

    /**
     * Remove insignificant trailing zeros from this
     * {@code BigInteger} value until the preferred scale is reached or no
     * more zeros can be removed.  If the preferred scale is less than
     * Integer.MIN_VALUE, all the trailing zeros will be removed.
     *
     * @return new {@code BigDecimal} with a scale possibly reduced
     * to be closed to the preferred scale.
     */
    private static BigDecimal createAndStripZerosToMatchScale(BigInteger intVal, int scale, long preferredScale) {
        BigInteger qr[]; // quotient-remainder pair
<span class="pc bpc" id="L4369" title="1 of 4 branches missed.">        while (intVal.compareMagnitude(BigInteger.TEN) &gt;= 0</span>
               &amp;&amp; scale &gt; preferredScale) {
<span class="fc bfc" id="L4371" title="All 2 branches covered.">            if (intVal.testBit(0))</span>
<span class="fc" id="L4372">                break; // odd number cannot end in 0</span>
<span class="fc" id="L4373">            qr = intVal.divideAndRemainder(BigInteger.TEN);</span>
<span class="fc bfc" id="L4374" title="All 2 branches covered.">            if (qr[1].signum() != 0)</span>
<span class="fc" id="L4375">                break; // non-0 remainder</span>
<span class="fc" id="L4376">            intVal = qr[0];</span>
<span class="fc" id="L4377">            scale = checkScale(intVal,(long) scale - 1); // could Overflow</span>
        }
<span class="fc" id="L4379">        return valueOf(intVal, scale, 0);</span>
    }

    /**
     * Remove insignificant trailing zeros from this
     * {@code long} value until the preferred scale is reached or no
     * more zeros can be removed.  If the preferred scale is less than
     * Integer.MIN_VALUE, all the trailing zeros will be removed.
     *
     * @return new {@code BigDecimal} with a scale possibly reduced
     * to be closed to the preferred scale.
     */
    private static BigDecimal createAndStripZerosToMatchScale(long compactVal, int scale, long preferredScale) {
<span class="pc bpc" id="L4392" title="1 of 4 branches missed.">        while (Math.abs(compactVal) &gt;= 10L &amp;&amp; scale &gt; preferredScale) {</span>
<span class="fc bfc" id="L4393" title="All 2 branches covered.">            if ((compactVal &amp; 1L) != 0L)</span>
<span class="fc" id="L4394">                break; // odd number cannot end in 0</span>
<span class="fc" id="L4395">            long r = compactVal % 10L;</span>
<span class="fc bfc" id="L4396" title="All 2 branches covered.">            if (r != 0L)</span>
<span class="fc" id="L4397">                break; // non-0 remainder</span>
<span class="fc" id="L4398">            compactVal /= 10;</span>
<span class="fc" id="L4399">            scale = checkScale(compactVal, (long) scale - 1); // could Overflow</span>
<span class="fc" id="L4400">        }</span>
<span class="fc" id="L4401">        return valueOf(compactVal, scale);</span>
    }

    private static BigDecimal stripZerosToMatchScale(BigInteger intVal, long intCompact, int scale, int preferredScale) {
<span class="nc bnc" id="L4405" title="All 2 branches missed.">        if(intCompact!=INFLATED) {</span>
<span class="nc" id="L4406">            return createAndStripZerosToMatchScale(intCompact, scale, preferredScale);</span>
        } else {
<span class="nc bnc" id="L4408" title="All 2 branches missed.">            return createAndStripZerosToMatchScale(intVal==null ? INFLATED_BIGINT : intVal,</span>
                                                   scale, preferredScale);
        }
    }

    /*
     * returns INFLATED if oveflow
     */
    private static long add(long xs, long ys){
<span class="fc" id="L4417">        long sum = xs + ys;</span>
        // See &quot;Hacker's Delight&quot; section 2-12 for explanation of
        // the overflow test.
<span class="pc bpc" id="L4420" title="1 of 2 branches missed.">        if ( (((sum ^ xs) &amp; (sum ^ ys))) &gt;= 0L) { // not overflowed</span>
<span class="fc" id="L4421">            return sum;</span>
        }
<span class="nc" id="L4423">        return INFLATED;</span>
    }

    private static BigDecimal add(long xs, long ys, int scale){
<span class="fc" id="L4427">        long sum = add(xs, ys);</span>
<span class="pc bpc" id="L4428" title="1 of 2 branches missed.">        if (sum!=INFLATED)</span>
<span class="fc" id="L4429">            return BigDecimal.valueOf(sum, scale);</span>
<span class="nc" id="L4430">        return new BigDecimal(BigInteger.valueOf(xs).add(ys), scale);</span>
    }

    private static BigDecimal add(final long xs, int scale1, final long ys, int scale2) {
<span class="fc" id="L4434">        long sdiff = (long) scale1 - scale2;</span>
<span class="fc bfc" id="L4435" title="All 2 branches covered.">        if (sdiff == 0) {</span>
<span class="fc" id="L4436">            return add(xs, ys, scale1);</span>
<span class="pc bpc" id="L4437" title="1 of 2 branches missed.">        } else if (sdiff &lt; 0) {</span>
<span class="fc" id="L4438">            int raise = checkScale(xs,-sdiff);</span>
<span class="fc" id="L4439">            long scaledX = longMultiplyPowerTen(xs, raise);</span>
<span class="fc bfc" id="L4440" title="All 2 branches covered.">            if (scaledX != INFLATED) {</span>
<span class="fc" id="L4441">                return add(scaledX, ys, scale2);</span>
            } else {
<span class="fc" id="L4443">                BigInteger bigsum = bigMultiplyPowerTen(xs,raise).add(ys);</span>
<span class="fc bfc" id="L4444" title="All 2 branches covered.">                return ((xs^ys)&gt;=0) ? // same sign test</span>
                    new BigDecimal(bigsum, INFLATED, scale2, 0)
<span class="fc" id="L4446">                    : valueOf(bigsum, scale2, 0);</span>
            }
        } else {
<span class="nc" id="L4449">            int raise = checkScale(ys,sdiff);</span>
<span class="nc" id="L4450">            long scaledY = longMultiplyPowerTen(ys, raise);</span>
<span class="nc bnc" id="L4451" title="All 2 branches missed.">            if (scaledY != INFLATED) {</span>
<span class="nc" id="L4452">                return add(xs, scaledY, scale1);</span>
            } else {
<span class="nc" id="L4454">                BigInteger bigsum = bigMultiplyPowerTen(ys,raise).add(xs);</span>
<span class="nc bnc" id="L4455" title="All 2 branches missed.">                return ((xs^ys)&gt;=0) ?</span>
                    new BigDecimal(bigsum, INFLATED, scale1, 0)
<span class="nc" id="L4457">                    : valueOf(bigsum, scale1, 0);</span>
            }
        }
    }

    private static BigDecimal add(final long xs, int scale1, BigInteger snd, int scale2) {
<span class="fc" id="L4463">        int rscale = scale1;</span>
<span class="fc" id="L4464">        long sdiff = (long)rscale - scale2;</span>
<span class="fc bfc" id="L4465" title="All 2 branches covered.">        boolean sameSigns =  (Long.signum(xs) == snd.signum);</span>
        BigInteger sum;
<span class="fc bfc" id="L4467" title="All 2 branches covered.">        if (sdiff &lt; 0) {</span>
<span class="fc" id="L4468">            int raise = checkScale(xs,-sdiff);</span>
<span class="fc" id="L4469">            rscale = scale2;</span>
<span class="fc" id="L4470">            long scaledX = longMultiplyPowerTen(xs, raise);</span>
<span class="fc bfc" id="L4471" title="All 2 branches covered.">            if (scaledX == INFLATED) {</span>
<span class="fc" id="L4472">                sum = snd.add(bigMultiplyPowerTen(xs,raise));</span>
            } else {
<span class="fc" id="L4474">                sum = snd.add(scaledX);</span>
            }
<span class="fc" id="L4476">        } else { //if (sdiff &gt; 0) {</span>
<span class="fc" id="L4477">            int raise = checkScale(snd,sdiff);</span>
<span class="fc" id="L4478">            snd = bigMultiplyPowerTen(snd,raise);</span>
<span class="fc" id="L4479">            sum = snd.add(xs);</span>
        }
<span class="fc bfc" id="L4481" title="All 2 branches covered.">        return (sameSigns) ?</span>
            new BigDecimal(sum, INFLATED, rscale, 0) :
<span class="fc" id="L4483">            valueOf(sum, rscale, 0);</span>
    }

    private static BigDecimal add(BigInteger fst, int scale1, BigInteger snd, int scale2) {
<span class="fc" id="L4487">        int rscale = scale1;</span>
<span class="fc" id="L4488">        long sdiff = (long)rscale - scale2;</span>
<span class="fc bfc" id="L4489" title="All 2 branches covered.">        if (sdiff != 0) {</span>
<span class="pc bpc" id="L4490" title="1 of 2 branches missed.">            if (sdiff &lt; 0) {</span>
<span class="fc" id="L4491">                int raise = checkScale(fst,-sdiff);</span>
<span class="fc" id="L4492">                rscale = scale2;</span>
<span class="fc" id="L4493">                fst = bigMultiplyPowerTen(fst,raise);</span>
<span class="fc" id="L4494">            } else {</span>
<span class="nc" id="L4495">                int raise = checkScale(snd,sdiff);</span>
<span class="nc" id="L4496">                snd = bigMultiplyPowerTen(snd,raise);</span>
            }
        }
<span class="fc" id="L4499">        BigInteger sum = fst.add(snd);</span>
<span class="fc bfc" id="L4500" title="All 2 branches covered.">        return (fst.signum == snd.signum) ?</span>
                new BigDecimal(sum, INFLATED, rscale, 0) :
<span class="fc" id="L4502">                valueOf(sum, rscale, 0);</span>
    }

    private static BigInteger bigMultiplyPowerTen(long value, int n) {
<span class="pc bpc" id="L4506" title="1 of 2 branches missed.">        if (n &lt;= 0)</span>
<span class="nc" id="L4507">            return BigInteger.valueOf(value);</span>
<span class="fc" id="L4508">        return bigTenToThe(n).multiply(value);</span>
    }

    private static BigInteger bigMultiplyPowerTen(BigInteger value, int n) {
<span class="fc bfc" id="L4512" title="All 2 branches covered.">        if (n &lt;= 0)</span>
<span class="fc" id="L4513">            return value;</span>
<span class="fc bfc" id="L4514" title="All 2 branches covered.">        if(n&lt;LONG_TEN_POWERS_TABLE.length) {</span>
<span class="fc" id="L4515">                return value.multiply(LONG_TEN_POWERS_TABLE[n]);</span>
        }
<span class="fc" id="L4517">        return value.multiply(bigTenToThe(n));</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (xs /
     * ys)}, with rounding according to the context settings.
     *
     * Fast path - used only when (xscale &lt;= yscale &amp;&amp; yscale &lt; 18
     *  &amp;&amp; mc.presision&lt;18) {
     */
    private static BigDecimal divideSmallFastPath(final long xs, int xscale,
                                                  final long ys, int yscale,
                                                  long preferredScale, MathContext mc) {
<span class="fc" id="L4530">        int mcp = mc.precision;</span>
<span class="fc" id="L4531">        int roundingMode = mc.roundingMode.oldMode;</span>

<span class="pc bpc" id="L4533" title="4 of 8 branches missed.">        assert (xscale &lt;= yscale) &amp;&amp; (yscale &lt; 18) &amp;&amp; (mcp &lt; 18);</span>
<span class="fc" id="L4534">        int xraise = yscale - xscale; // xraise &gt;=0</span>
<span class="fc bfc" id="L4535" title="All 2 branches covered.">        long scaledX = (xraise==0) ? xs :</span>
<span class="fc" id="L4536">            longMultiplyPowerTen(xs, xraise); // can't overflow here!</span>
        BigDecimal quotient;

<span class="fc" id="L4539">        int cmp = longCompareMagnitude(scaledX, ys);</span>
<span class="fc bfc" id="L4540" title="All 2 branches covered.">        if(cmp &gt; 0) { // satisfy constraint (b)</span>
<span class="fc" id="L4541">            yscale -= 1; // [that is, divisor *= 10]</span>
<span class="fc" id="L4542">            int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);</span>
<span class="fc bfc" id="L4543" title="All 2 branches covered.">            if (checkScaleNonZero((long) mcp + yscale - xscale) &gt; 0) {</span>
                // assert newScale &gt;= xscale
<span class="fc" id="L4545">                int raise = checkScaleNonZero((long) mcp + yscale - xscale);</span>
                long scaledXs;
<span class="fc bfc" id="L4547" title="All 2 branches covered.">                if ((scaledXs = longMultiplyPowerTen(xs, raise)) == INFLATED) {</span>
<span class="fc" id="L4548">                    quotient = null;</span>
<span class="pc bpc" id="L4549" title="2 of 4 branches missed.">                    if((mcp-1) &gt;=0 &amp;&amp; (mcp-1)&lt;LONG_TEN_POWERS_TABLE.length) {</span>
<span class="fc" id="L4550">                        quotient = multiplyDivideAndRound(LONG_TEN_POWERS_TABLE[mcp-1], scaledX, ys, scl, roundingMode, checkScaleNonZero(preferredScale));</span>
                    }
<span class="pc bpc" id="L4552" title="1 of 2 branches missed.">                    if(quotient==null) {</span>
<span class="nc" id="L4553">                        BigInteger rb = bigMultiplyPowerTen(scaledX,mcp-1);</span>
<span class="nc" id="L4554">                        quotient = divideAndRound(rb, ys,</span>
<span class="nc" id="L4555">                                                  scl, roundingMode, checkScaleNonZero(preferredScale));</span>
<span class="nc" id="L4556">                    }</span>
                } else {
<span class="fc" id="L4558">                    quotient = divideAndRound(scaledXs, ys, scl, roundingMode, checkScaleNonZero(preferredScale));</span>
                }
<span class="fc" id="L4560">            } else {</span>
<span class="fc" id="L4561">                int newScale = checkScaleNonZero((long) xscale - mcp);</span>
                // assert newScale &gt;= yscale
<span class="pc bpc" id="L4563" title="1 of 2 branches missed.">                if (newScale == yscale) { // easy case</span>
<span class="fc" id="L4564">                    quotient = divideAndRound(xs, ys, scl, roundingMode,checkScaleNonZero(preferredScale));</span>
                } else {
<span class="nc" id="L4566">                    int raise = checkScaleNonZero((long) newScale - yscale);</span>
                    long scaledYs;
<span class="nc bnc" id="L4568" title="All 2 branches missed.">                    if ((scaledYs = longMultiplyPowerTen(ys, raise)) == INFLATED) {</span>
<span class="nc" id="L4569">                        BigInteger rb = bigMultiplyPowerTen(ys,raise);</span>
<span class="nc" id="L4570">                        quotient = divideAndRound(BigInteger.valueOf(xs),</span>
<span class="nc" id="L4571">                                                  rb, scl, roundingMode,checkScaleNonZero(preferredScale));</span>
<span class="nc" id="L4572">                    } else {</span>
<span class="nc" id="L4573">                        quotient = divideAndRound(xs, scaledYs, scl, roundingMode,checkScaleNonZero(preferredScale));</span>
                    }
                }
            }
<span class="fc" id="L4577">        } else {</span>
            // abs(scaledX) &lt;= abs(ys)
            // result is &quot;scaledX * 10^msp / ys&quot;
<span class="fc" id="L4580">            int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);</span>
<span class="fc bfc" id="L4581" title="All 2 branches covered.">            if(cmp==0) {</span>
                // abs(scaleX)== abs(ys) =&gt; result will be scaled 10^mcp + correct sign
<span class="pc bpc" id="L4583" title="3 of 6 branches missed.">                quotient = roundedTenPower(((scaledX &lt; 0) == (ys &lt; 0)) ? 1 : -1, mcp, scl, checkScaleNonZero(preferredScale));</span>
            } else {
                // abs(scaledX) &lt; abs(ys)
                long scaledXs;
<span class="fc bfc" id="L4587" title="All 2 branches covered.">                if ((scaledXs = longMultiplyPowerTen(scaledX, mcp)) == INFLATED) {</span>
<span class="fc" id="L4588">                    quotient = null;</span>
<span class="pc bpc" id="L4589" title="1 of 2 branches missed.">                    if(mcp&lt;LONG_TEN_POWERS_TABLE.length) {</span>
<span class="fc" id="L4590">                        quotient = multiplyDivideAndRound(LONG_TEN_POWERS_TABLE[mcp], scaledX, ys, scl, roundingMode, checkScaleNonZero(preferredScale));</span>
                    }
<span class="pc bpc" id="L4592" title="1 of 2 branches missed.">                    if(quotient==null) {</span>
<span class="nc" id="L4593">                        BigInteger rb = bigMultiplyPowerTen(scaledX,mcp);</span>
<span class="nc" id="L4594">                        quotient = divideAndRound(rb, ys,</span>
<span class="nc" id="L4595">                                                  scl, roundingMode, checkScaleNonZero(preferredScale));</span>
<span class="nc" id="L4596">                    }</span>
                } else {
<span class="fc" id="L4598">                    quotient = divideAndRound(scaledXs, ys, scl, roundingMode, checkScaleNonZero(preferredScale));</span>
                }
            }
        }
        // doRound, here, only affects 1000000000 case.
<span class="fc" id="L4603">        return doRound(quotient,mc);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (xs /
     * ys)}, with rounding according to the context settings.
     */
    private static BigDecimal divide(final long xs, int xscale, final long ys, int yscale, long preferredScale, MathContext mc) {
<span class="fc" id="L4611">        int mcp = mc.precision;</span>
<span class="pc bpc" id="L4612" title="1 of 6 branches missed.">        if(xscale &lt;= yscale &amp;&amp; yscale &lt; 18 &amp;&amp; mcp&lt;18) {</span>
<span class="fc" id="L4613">            return divideSmallFastPath(xs, xscale, ys, yscale, preferredScale, mc);</span>
        }
<span class="fc bfc" id="L4615" title="All 2 branches covered.">        if (compareMagnitudeNormalized(xs, xscale, ys, yscale) &gt; 0) {// satisfy constraint (b)</span>
<span class="fc" id="L4616">            yscale -= 1; // [that is, divisor *= 10]</span>
        }
<span class="fc" id="L4618">        int roundingMode = mc.roundingMode.oldMode;</span>
        // In order to find out whether the divide generates the exact result,
        // we avoid calling the above divide method. 'quotient' holds the
        // return BigDecimal object whose scale will be set to 'scl'.
<span class="fc" id="L4622">        int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);</span>
        BigDecimal quotient;
<span class="fc bfc" id="L4624" title="All 2 branches covered.">        if (checkScaleNonZero((long) mcp + yscale - xscale) &gt; 0) {</span>
<span class="fc" id="L4625">            int raise = checkScaleNonZero((long) mcp + yscale - xscale);</span>
            long scaledXs;
<span class="fc bfc" id="L4627" title="All 2 branches covered.">            if ((scaledXs = longMultiplyPowerTen(xs, raise)) == INFLATED) {</span>
<span class="fc" id="L4628">                BigInteger rb = bigMultiplyPowerTen(xs,raise);</span>
<span class="fc" id="L4629">                quotient = divideAndRound(rb, ys, scl, roundingMode, checkScaleNonZero(preferredScale));</span>
<span class="fc" id="L4630">            } else {</span>
<span class="fc" id="L4631">                quotient = divideAndRound(scaledXs, ys, scl, roundingMode, checkScaleNonZero(preferredScale));</span>
            }
<span class="fc" id="L4633">        } else {</span>
<span class="fc" id="L4634">            int newScale = checkScaleNonZero((long) xscale - mcp);</span>
            // assert newScale &gt;= yscale
<span class="fc bfc" id="L4636" title="All 2 branches covered.">            if (newScale == yscale) { // easy case</span>
<span class="fc" id="L4637">                quotient = divideAndRound(xs, ys, scl, roundingMode,checkScaleNonZero(preferredScale));</span>
            } else {
<span class="fc" id="L4639">                int raise = checkScaleNonZero((long) newScale - yscale);</span>
                long scaledYs;
<span class="pc bpc" id="L4641" title="1 of 2 branches missed.">                if ((scaledYs = longMultiplyPowerTen(ys, raise)) == INFLATED) {</span>
<span class="nc" id="L4642">                    BigInteger rb = bigMultiplyPowerTen(ys,raise);</span>
<span class="nc" id="L4643">                    quotient = divideAndRound(BigInteger.valueOf(xs),</span>
<span class="nc" id="L4644">                                              rb, scl, roundingMode,checkScaleNonZero(preferredScale));</span>
<span class="nc" id="L4645">                } else {</span>
<span class="fc" id="L4646">                    quotient = divideAndRound(xs, scaledYs, scl, roundingMode,checkScaleNonZero(preferredScale));</span>
                }
            }
        }
        // doRound, here, only affects 1000000000 case.
<span class="fc" id="L4651">        return doRound(quotient,mc);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (xs /
     * ys)}, with rounding according to the context settings.
     */
    private static BigDecimal divide(BigInteger xs, int xscale, long ys, int yscale, long preferredScale, MathContext mc) {
        // Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
<span class="fc bfc" id="L4660" title="All 2 branches covered.">        if ((-compareMagnitudeNormalized(ys, yscale, xs, xscale)) &gt; 0) {// satisfy constraint (b)</span>
<span class="fc" id="L4661">            yscale -= 1; // [that is, divisor *= 10]</span>
        }
<span class="fc" id="L4663">        int mcp = mc.precision;</span>
<span class="fc" id="L4664">        int roundingMode = mc.roundingMode.oldMode;</span>

        // In order to find out whether the divide generates the exact result,
        // we avoid calling the above divide method. 'quotient' holds the
        // return BigDecimal object whose scale will be set to 'scl'.
        BigDecimal quotient;
<span class="fc" id="L4670">        int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);</span>
<span class="fc bfc" id="L4671" title="All 2 branches covered.">        if (checkScaleNonZero((long) mcp + yscale - xscale) &gt; 0) {</span>
<span class="fc" id="L4672">            int raise = checkScaleNonZero((long) mcp + yscale - xscale);</span>
<span class="fc" id="L4673">            BigInteger rb = bigMultiplyPowerTen(xs,raise);</span>
<span class="fc" id="L4674">            quotient = divideAndRound(rb, ys, scl, roundingMode, checkScaleNonZero(preferredScale));</span>
<span class="fc" id="L4675">        } else {</span>
<span class="fc" id="L4676">            int newScale = checkScaleNonZero((long) xscale - mcp);</span>
            // assert newScale &gt;= yscale
<span class="fc bfc" id="L4678" title="All 2 branches covered.">            if (newScale == yscale) { // easy case</span>
<span class="fc" id="L4679">                quotient = divideAndRound(xs, ys, scl, roundingMode,checkScaleNonZero(preferredScale));</span>
            } else {
<span class="fc" id="L4681">                int raise = checkScaleNonZero((long) newScale - yscale);</span>
                long scaledYs;
<span class="fc bfc" id="L4683" title="All 2 branches covered.">                if ((scaledYs = longMultiplyPowerTen(ys, raise)) == INFLATED) {</span>
<span class="fc" id="L4684">                    BigInteger rb = bigMultiplyPowerTen(ys,raise);</span>
<span class="fc" id="L4685">                    quotient = divideAndRound(xs, rb, scl, roundingMode,checkScaleNonZero(preferredScale));</span>
<span class="fc" id="L4686">                } else {</span>
<span class="fc" id="L4687">                    quotient = divideAndRound(xs, scaledYs, scl, roundingMode,checkScaleNonZero(preferredScale));</span>
                }
            }
        }
        // doRound, here, only affects 1000000000 case.
<span class="fc" id="L4692">        return doRound(quotient, mc);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (xs /
     * ys)}, with rounding according to the context settings.
     */
    private static BigDecimal divide(long xs, int xscale, BigInteger ys, int yscale, long preferredScale, MathContext mc) {
        // Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
<span class="fc bfc" id="L4701" title="All 2 branches covered.">        if (compareMagnitudeNormalized(xs, xscale, ys, yscale) &gt; 0) {// satisfy constraint (b)</span>
<span class="fc" id="L4702">            yscale -= 1; // [that is, divisor *= 10]</span>
        }
<span class="fc" id="L4704">        int mcp = mc.precision;</span>
<span class="fc" id="L4705">        int roundingMode = mc.roundingMode.oldMode;</span>

        // In order to find out whether the divide generates the exact result,
        // we avoid calling the above divide method. 'quotient' holds the
        // return BigDecimal object whose scale will be set to 'scl'.
        BigDecimal quotient;
<span class="fc" id="L4711">        int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);</span>
<span class="pc bpc" id="L4712" title="1 of 2 branches missed.">        if (checkScaleNonZero((long) mcp + yscale - xscale) &gt; 0) {</span>
<span class="fc" id="L4713">            int raise = checkScaleNonZero((long) mcp + yscale - xscale);</span>
<span class="fc" id="L4714">            BigInteger rb = bigMultiplyPowerTen(xs,raise);</span>
<span class="fc" id="L4715">            quotient = divideAndRound(rb, ys, scl, roundingMode, checkScaleNonZero(preferredScale));</span>
<span class="fc" id="L4716">        } else {</span>
<span class="nc" id="L4717">            int newScale = checkScaleNonZero((long) xscale - mcp);</span>
<span class="nc" id="L4718">            int raise = checkScaleNonZero((long) newScale - yscale);</span>
<span class="nc" id="L4719">            BigInteger rb = bigMultiplyPowerTen(ys,raise);</span>
<span class="nc" id="L4720">            quotient = divideAndRound(BigInteger.valueOf(xs), rb, scl, roundingMode,checkScaleNonZero(preferredScale));</span>
        }
        // doRound, here, only affects 1000000000 case.
<span class="fc" id="L4723">        return doRound(quotient, mc);</span>
    }

    /**
     * Returns a {@code BigDecimal} whose value is {@code (xs /
     * ys)}, with rounding according to the context settings.
     */
    private static BigDecimal divide(BigInteger xs, int xscale, BigInteger ys, int yscale, long preferredScale, MathContext mc) {
        // Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
<span class="fc bfc" id="L4732" title="All 2 branches covered.">        if (compareMagnitudeNormalized(xs, xscale, ys, yscale) &gt; 0) {// satisfy constraint (b)</span>
<span class="fc" id="L4733">            yscale -= 1; // [that is, divisor *= 10]</span>
        }
<span class="fc" id="L4735">        int mcp = mc.precision;</span>
<span class="fc" id="L4736">        int roundingMode = mc.roundingMode.oldMode;</span>

        // In order to find out whether the divide generates the exact result,
        // we avoid calling the above divide method. 'quotient' holds the
        // return BigDecimal object whose scale will be set to 'scl'.
        BigDecimal quotient;
<span class="fc" id="L4742">        int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);</span>
<span class="fc bfc" id="L4743" title="All 2 branches covered.">        if (checkScaleNonZero((long) mcp + yscale - xscale) &gt; 0) {</span>
<span class="fc" id="L4744">            int raise = checkScaleNonZero((long) mcp + yscale - xscale);</span>
<span class="fc" id="L4745">            BigInteger rb = bigMultiplyPowerTen(xs,raise);</span>
<span class="fc" id="L4746">            quotient = divideAndRound(rb, ys, scl, roundingMode, checkScaleNonZero(preferredScale));</span>
<span class="fc" id="L4747">        } else {</span>
<span class="fc" id="L4748">            int newScale = checkScaleNonZero((long) xscale - mcp);</span>
<span class="fc" id="L4749">            int raise = checkScaleNonZero((long) newScale - yscale);</span>
<span class="fc" id="L4750">            BigInteger rb = bigMultiplyPowerTen(ys,raise);</span>
<span class="fc" id="L4751">            quotient = divideAndRound(xs, rb, scl, roundingMode,checkScaleNonZero(preferredScale));</span>
        }
        // doRound, here, only affects 1000000000 case.
<span class="fc" id="L4754">        return doRound(quotient, mc);</span>
    }

    /*
     * performs divideAndRound for (dividend0*dividend1, divisor)
     * returns null if quotient can't fit into long value;
     */
    private static BigDecimal multiplyDivideAndRound(long dividend0, long dividend1, long divisor, int scale, int roundingMode,
                                                     int preferredScale) {
<span class="fc" id="L4763">        int qsign = Long.signum(dividend0)*Long.signum(dividend1)*Long.signum(divisor);</span>
<span class="fc" id="L4764">        dividend0 = Math.abs(dividend0);</span>
<span class="fc" id="L4765">        dividend1 = Math.abs(dividend1);</span>
<span class="fc" id="L4766">        divisor = Math.abs(divisor);</span>
        // multiply dividend0 * dividend1
<span class="fc" id="L4768">        long d0_hi = dividend0 &gt;&gt;&gt; 32;</span>
<span class="fc" id="L4769">        long d0_lo = dividend0 &amp; LONG_MASK;</span>
<span class="fc" id="L4770">        long d1_hi = dividend1 &gt;&gt;&gt; 32;</span>
<span class="fc" id="L4771">        long d1_lo = dividend1 &amp; LONG_MASK;</span>
<span class="fc" id="L4772">        long product = d0_lo * d1_lo;</span>
<span class="fc" id="L4773">        long d0 = product &amp; LONG_MASK;</span>
<span class="fc" id="L4774">        long d1 = product &gt;&gt;&gt; 32;</span>
<span class="fc" id="L4775">        product = d0_hi * d1_lo + d1;</span>
<span class="fc" id="L4776">        d1 = product &amp; LONG_MASK;</span>
<span class="fc" id="L4777">        long d2 = product &gt;&gt;&gt; 32;</span>
<span class="fc" id="L4778">        product = d0_lo * d1_hi + d1;</span>
<span class="fc" id="L4779">        d1 = product &amp; LONG_MASK;</span>
<span class="fc" id="L4780">        d2 += product &gt;&gt;&gt; 32;</span>
<span class="fc" id="L4781">        long d3 = d2&gt;&gt;&gt;32;</span>
<span class="fc" id="L4782">        d2 &amp;= LONG_MASK;</span>
<span class="fc" id="L4783">        product = d0_hi*d1_hi + d2;</span>
<span class="fc" id="L4784">        d2 = product &amp; LONG_MASK;</span>
<span class="fc" id="L4785">        d3 = ((product&gt;&gt;&gt;32) + d3) &amp; LONG_MASK;</span>
<span class="fc" id="L4786">        final long dividendHi = make64(d3,d2);</span>
<span class="fc" id="L4787">        final long dividendLo = make64(d1,d0);</span>
        // divide
<span class="fc" id="L4789">        return divideAndRound128(dividendHi, dividendLo, divisor, qsign, scale, roundingMode, preferredScale);</span>
    }

    private static final long DIV_NUM_BASE = (1L&lt;&lt;32); // Number base (32 bits).

    /*
     * divideAndRound 128-bit value by long divisor.
     * returns null if quotient can't fit into long value;
     * Specialized version of Knuth's division
     */
    private static BigDecimal divideAndRound128(final long dividendHi, final long dividendLo, long divisor, int sign,
                                                int scale, int roundingMode, int preferredScale) {
<span class="pc bpc" id="L4801" title="1 of 2 branches missed.">        if (dividendHi &gt;= divisor) {</span>
<span class="nc" id="L4802">            return null;</span>
        }
<span class="fc" id="L4804">        final int shift = Long.numberOfLeadingZeros(divisor);</span>
<span class="fc" id="L4805">        divisor &lt;&lt;= shift;</span>

<span class="fc" id="L4807">        final long v1 = divisor &gt;&gt;&gt; 32;</span>
<span class="fc" id="L4808">        final long v0 = divisor &amp; LONG_MASK;</span>

        long q1, q0;
        long r_tmp;

<span class="fc" id="L4813">        long tmp = dividendLo &lt;&lt; shift;</span>
<span class="fc" id="L4814">        long u1 = tmp &gt;&gt;&gt; 32;</span>
<span class="fc" id="L4815">        long u0 = tmp &amp; LONG_MASK;</span>

<span class="fc" id="L4817">        tmp = (dividendHi &lt;&lt; shift) | (dividendLo &gt;&gt;&gt; 64 - shift);</span>
<span class="fc" id="L4818">        long u2 = tmp &amp; LONG_MASK;</span>
<span class="fc" id="L4819">        tmp = divWord(tmp,v1);</span>
<span class="fc" id="L4820">        q1 = tmp &amp; LONG_MASK;</span>
<span class="fc" id="L4821">        r_tmp = tmp &gt;&gt;&gt; 32;</span>
<span class="pc bpc" id="L4822" title="1 of 4 branches missed.">        while(q1 &gt;= DIV_NUM_BASE || unsignedLongCompare(q1*v0, make64(r_tmp, u1))) {</span>
<span class="fc" id="L4823">            q1--;</span>
<span class="fc" id="L4824">            r_tmp += v1;</span>
<span class="pc bpc" id="L4825" title="1 of 2 branches missed.">            if (r_tmp &gt;= DIV_NUM_BASE)</span>
<span class="nc" id="L4826">                break;</span>
        }
<span class="fc" id="L4828">        tmp = mulsub(u2,u1,v1,v0,q1);</span>
<span class="fc" id="L4829">        u1 = tmp &amp; LONG_MASK;</span>
<span class="fc" id="L4830">        tmp = divWord(tmp,v1);</span>
<span class="fc" id="L4831">        q0 = tmp &amp; LONG_MASK;</span>
<span class="fc" id="L4832">        r_tmp = tmp &gt;&gt;&gt; 32;</span>
<span class="pc bpc" id="L4833" title="1 of 4 branches missed.">        while(q0 &gt;= DIV_NUM_BASE || unsignedLongCompare(q0*v0,make64(r_tmp,u0))) {</span>
<span class="fc" id="L4834">            q0--;</span>
<span class="fc" id="L4835">            r_tmp += v1;</span>
<span class="fc bfc" id="L4836" title="All 2 branches covered.">            if (r_tmp &gt;= DIV_NUM_BASE)</span>
<span class="fc" id="L4837">                break;</span>
        }
<span class="pc bpc" id="L4839" title="1 of 2 branches missed.">        if((int)q1 &lt; 0) {</span>
            // result (which is positive and unsigned here)
            // can't fit into long due to sign bit is used for value
<span class="nc" id="L4842">            MutableBigInteger mq = new MutableBigInteger(new int[]{(int)q1, (int)q0});</span>
<span class="nc bnc" id="L4843" title="All 4 branches missed.">            if (roundingMode == ROUND_DOWN &amp;&amp; scale == preferredScale) {</span>
<span class="nc" id="L4844">                return mq.toBigDecimal(sign, scale);</span>
            }
<span class="nc" id="L4846">            long r = mulsub(u1, u0, v1, v0, q0) &gt;&gt;&gt; shift;</span>
<span class="nc bnc" id="L4847" title="All 2 branches missed.">            if (r != 0) {</span>
<span class="nc bnc" id="L4848" title="All 2 branches missed.">                if(needIncrement(divisor &gt;&gt;&gt; shift, roundingMode, sign, mq, r)){</span>
<span class="nc" id="L4849">                    mq.add(MutableBigInteger.ONE);</span>
                }
<span class="nc" id="L4851">                return mq.toBigDecimal(sign, scale);</span>
            } else {
<span class="nc bnc" id="L4853" title="All 2 branches missed.">                if (preferredScale != scale) {</span>
<span class="nc" id="L4854">                    BigInteger intVal =  mq.toBigInteger(sign);</span>
<span class="nc" id="L4855">                    return createAndStripZerosToMatchScale(intVal,scale, preferredScale);</span>
                } else {
<span class="nc" id="L4857">                    return mq.toBigDecimal(sign, scale);</span>
                }
            }
        }
<span class="fc" id="L4861">        long q = make64(q1,q0);</span>
<span class="fc" id="L4862">        q*=sign;</span>
<span class="pc bpc" id="L4863" title="3 of 4 branches missed.">        if (roundingMode == ROUND_DOWN &amp;&amp; scale == preferredScale)</span>
<span class="nc" id="L4864">            return valueOf(q, scale);</span>
<span class="fc" id="L4865">        long r = mulsub(u1, u0, v1, v0, q0) &gt;&gt;&gt; shift;</span>
<span class="fc bfc" id="L4866" title="All 2 branches covered.">        if (r != 0) {</span>
<span class="fc" id="L4867">            boolean increment = needIncrement(divisor &gt;&gt;&gt; shift, roundingMode, sign, q, r);</span>
<span class="fc bfc" id="L4868" title="All 2 branches covered.">            return valueOf((increment ? q + sign : q), scale);</span>
        } else {
<span class="pc bpc" id="L4870" title="1 of 2 branches missed.">            if (preferredScale != scale) {</span>
<span class="fc" id="L4871">                return createAndStripZerosToMatchScale(q, scale, preferredScale);</span>
            } else {
<span class="nc" id="L4873">                return valueOf(q, scale);</span>
            }
        }
    }

    /*
     * calculate divideAndRound for ldividend*10^raise / divisor
     * when abs(dividend)==abs(divisor);
     */
    private static BigDecimal roundedTenPower(int qsign, int raise, int scale, int preferredScale) {
<span class="pc bpc" id="L4883" title="1 of 2 branches missed.">        if (scale &gt; preferredScale) {</span>
<span class="fc" id="L4884">            int diff = scale - preferredScale;</span>
<span class="pc bpc" id="L4885" title="1 of 2 branches missed.">            if(diff &lt; raise) {</span>
<span class="nc" id="L4886">                return scaledTenPow(raise - diff, qsign, preferredScale);</span>
            } else {
<span class="fc" id="L4888">                return valueOf(qsign,scale-raise);</span>
            }
        } else {
<span class="nc" id="L4891">            return scaledTenPow(raise, qsign, scale);</span>
        }
    }

    static BigDecimal scaledTenPow(int n, int sign, int scale) {
<span class="nc bnc" id="L4896" title="All 2 branches missed.">        if (n &lt; LONG_TEN_POWERS_TABLE.length)</span>
<span class="nc" id="L4897">            return valueOf(sign*LONG_TEN_POWERS_TABLE[n],scale);</span>
        else {
<span class="nc" id="L4899">            BigInteger unscaledVal = bigTenToThe(n);</span>
<span class="nc bnc" id="L4900" title="All 2 branches missed.">            if(sign==-1) {</span>
<span class="nc" id="L4901">                unscaledVal = unscaledVal.negate();</span>
            }
<span class="nc" id="L4903">            return new BigDecimal(unscaledVal, INFLATED, scale, n+1);</span>
        }
    }

    private static long divWord(long n, long dLong) {
        long r;
        long q;
<span class="pc bpc" id="L4910" title="1 of 2 branches missed.">        if (dLong == 1) {</span>
<span class="nc" id="L4911">            q = (int)n;</span>
<span class="nc" id="L4912">            return (q &amp; LONG_MASK);</span>
        }
        // Approximate the quotient and remainder
<span class="fc" id="L4915">        q = (n &gt;&gt;&gt; 1) / (dLong &gt;&gt;&gt; 1);</span>
<span class="fc" id="L4916">        r = n - q*dLong;</span>

        // Correct the approximation
<span class="fc bfc" id="L4919" title="All 2 branches covered.">        while (r &lt; 0) {</span>
<span class="fc" id="L4920">            r += dLong;</span>
<span class="fc" id="L4921">            q--;</span>
        }
<span class="pc bpc" id="L4923" title="1 of 2 branches missed.">        while (r &gt;= dLong) {</span>
<span class="nc" id="L4924">            r -= dLong;</span>
<span class="nc" id="L4925">            q++;</span>
        }
        // n - q*dlong == r &amp;&amp; 0 &lt;= r &lt;dLong, hence we're done.
<span class="fc" id="L4928">        return (r &lt;&lt; 32) | (q &amp; LONG_MASK);</span>
    }

    private static long make64(long hi, long lo) {
<span class="fc" id="L4932">        return hi&lt;&lt;32 | lo;</span>
    }

    private static long mulsub(long u1, long u0, final long v1, final long v0, long q0) {
<span class="fc" id="L4936">        long tmp = u0 - q0*v0;</span>
<span class="fc" id="L4937">        return make64(u1 + (tmp&gt;&gt;&gt;32) - q0*v1,tmp &amp; LONG_MASK);</span>
    }

    private static boolean unsignedLongCompare(long one, long two) {
<span class="fc bfc" id="L4941" title="All 2 branches covered.">        return (one+Long.MIN_VALUE) &gt; (two+Long.MIN_VALUE);</span>
    }

    private static boolean unsignedLongCompareEq(long one, long two) {
<span class="nc bnc" id="L4945" title="All 2 branches missed.">        return (one+Long.MIN_VALUE) &gt;= (two+Long.MIN_VALUE);</span>
    }


    // Compare Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
    private static int compareMagnitudeNormalized(long xs, int xscale, long ys, int yscale) {
        // assert xs!=0 &amp;&amp; ys!=0
<span class="fc" id="L4952">        int sdiff = xscale - yscale;</span>
<span class="fc bfc" id="L4953" title="All 2 branches covered.">        if (sdiff != 0) {</span>
<span class="fc bfc" id="L4954" title="All 2 branches covered.">            if (sdiff &lt; 0) {</span>
<span class="fc" id="L4955">                xs = longMultiplyPowerTen(xs, -sdiff);</span>
            } else { // sdiff &gt; 0
<span class="fc" id="L4957">                ys = longMultiplyPowerTen(ys, sdiff);</span>
            }
        }
<span class="pc bpc" id="L4960" title="1 of 2 branches missed.">        if (xs != INFLATED)</span>
<span class="pc bpc" id="L4961" title="1 of 2 branches missed.">            return (ys != INFLATED) ? longCompareMagnitude(xs, ys) : -1;</span>
        else
<span class="nc" id="L4963">            return 1;</span>
    }

    // Compare Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
    private static int compareMagnitudeNormalized(long xs, int xscale, BigInteger ys, int yscale) {
        // assert &quot;ys can't be represented as long&quot;
<span class="pc bpc" id="L4969" title="1 of 2 branches missed.">        if (xs == 0)</span>
<span class="nc" id="L4970">            return -1;</span>
<span class="fc" id="L4971">        int sdiff = xscale - yscale;</span>
<span class="pc bpc" id="L4972" title="1 of 2 branches missed.">        if (sdiff &lt; 0) {</span>
<span class="pc bpc" id="L4973" title="1 of 2 branches missed.">            if (longMultiplyPowerTen(xs, -sdiff) == INFLATED ) {</span>
<span class="fc" id="L4974">                return bigMultiplyPowerTen(xs, -sdiff).compareMagnitude(ys);</span>
            }
        }
<span class="nc" id="L4977">        return -1;</span>
    }

    // Compare Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
    private static int compareMagnitudeNormalized(BigInteger xs, int xscale, BigInteger ys, int yscale) {
<span class="fc" id="L4982">        int sdiff = xscale - yscale;</span>
<span class="fc bfc" id="L4983" title="All 2 branches covered.">        if (sdiff &lt; 0) {</span>
<span class="fc" id="L4984">            return bigMultiplyPowerTen(xs, -sdiff).compareMagnitude(ys);</span>
        } else { // sdiff &gt;= 0
<span class="fc" id="L4986">            return xs.compareMagnitude(bigMultiplyPowerTen(ys, sdiff));</span>
        }
    }

    private static long multiply(long x, long y){
<span class="fc" id="L4991">                long product = x * y;</span>
<span class="fc" id="L4992">        long ax = Math.abs(x);</span>
<span class="fc" id="L4993">        long ay = Math.abs(y);</span>
<span class="pc bpc" id="L4994" title="1 of 6 branches missed.">        if (((ax | ay) &gt;&gt;&gt; 31 == 0) || (y == 0) || (product / y == x)){</span>
<span class="fc" id="L4995">                        return product;</span>
                }
<span class="fc" id="L4997">        return INFLATED;</span>
    }

    private static BigDecimal multiply(long x, long y, int scale) {
<span class="fc" id="L5001">        long product = multiply(x, y);</span>
<span class="fc bfc" id="L5002" title="All 2 branches covered.">        if(product!=INFLATED) {</span>
<span class="fc" id="L5003">            return valueOf(product,scale);</span>
        }
<span class="fc" id="L5005">        return new BigDecimal(BigInteger.valueOf(x).multiply(y),INFLATED,scale,0);</span>
    }

    private static BigDecimal multiply(long x, BigInteger y, int scale) {
<span class="pc bpc" id="L5009" title="1 of 2 branches missed.">        if(x==0) {</span>
<span class="nc" id="L5010">            return zeroValueOf(scale);</span>
        }
<span class="fc" id="L5012">        return new BigDecimal(y.multiply(x),INFLATED,scale,0);</span>
    }

    private static BigDecimal multiply(BigInteger x, BigInteger y, int scale) {
<span class="fc" id="L5016">        return new BigDecimal(x.multiply(y),INFLATED,scale,0);</span>
    }

    /**
     * Multiplies two long values and rounds according {@code MathContext}
     */
    private static BigDecimal multiplyAndRound(long x, long y, int scale, MathContext mc) {
<span class="nc" id="L5023">        long product = multiply(x, y);</span>
<span class="nc bnc" id="L5024" title="All 2 branches missed.">        if(product!=INFLATED) {</span>
<span class="nc" id="L5025">            return doRound(product, scale, mc);</span>
        }
        // attempt to do it in 128 bits
<span class="nc" id="L5028">        int rsign = 1;</span>
<span class="nc bnc" id="L5029" title="All 2 branches missed.">        if(x &lt; 0) {</span>
<span class="nc" id="L5030">            x = -x;</span>
<span class="nc" id="L5031">            rsign = -1;</span>
        }
<span class="nc bnc" id="L5033" title="All 2 branches missed.">        if(y &lt; 0) {</span>
<span class="nc" id="L5034">            y = -y;</span>
<span class="nc" id="L5035">            rsign *= -1;</span>
        }
        // multiply dividend0 * dividend1
<span class="nc" id="L5038">        long m0_hi = x &gt;&gt;&gt; 32;</span>
<span class="nc" id="L5039">        long m0_lo = x &amp; LONG_MASK;</span>
<span class="nc" id="L5040">        long m1_hi = y &gt;&gt;&gt; 32;</span>
<span class="nc" id="L5041">        long m1_lo = y &amp; LONG_MASK;</span>
<span class="nc" id="L5042">        product = m0_lo * m1_lo;</span>
<span class="nc" id="L5043">        long m0 = product &amp; LONG_MASK;</span>
<span class="nc" id="L5044">        long m1 = product &gt;&gt;&gt; 32;</span>
<span class="nc" id="L5045">        product = m0_hi * m1_lo + m1;</span>
<span class="nc" id="L5046">        m1 = product &amp; LONG_MASK;</span>
<span class="nc" id="L5047">        long m2 = product &gt;&gt;&gt; 32;</span>
<span class="nc" id="L5048">        product = m0_lo * m1_hi + m1;</span>
<span class="nc" id="L5049">        m1 = product &amp; LONG_MASK;</span>
<span class="nc" id="L5050">        m2 += product &gt;&gt;&gt; 32;</span>
<span class="nc" id="L5051">        long m3 = m2&gt;&gt;&gt;32;</span>
<span class="nc" id="L5052">        m2 &amp;= LONG_MASK;</span>
<span class="nc" id="L5053">        product = m0_hi*m1_hi + m2;</span>
<span class="nc" id="L5054">        m2 = product &amp; LONG_MASK;</span>
<span class="nc" id="L5055">        m3 = ((product&gt;&gt;&gt;32) + m3) &amp; LONG_MASK;</span>
<span class="nc" id="L5056">        final long mHi = make64(m3,m2);</span>
<span class="nc" id="L5057">        final long mLo = make64(m1,m0);</span>
<span class="nc" id="L5058">        BigDecimal res = doRound128(mHi, mLo, rsign, scale, mc);</span>
<span class="nc bnc" id="L5059" title="All 2 branches missed.">        if(res!=null) {</span>
<span class="nc" id="L5060">            return res;</span>
        }
<span class="nc" id="L5062">        res = new BigDecimal(BigInteger.valueOf(x).multiply(y*rsign), INFLATED, scale, 0);</span>
<span class="nc" id="L5063">        return doRound(res,mc);</span>
    }

    private static BigDecimal multiplyAndRound(long x, BigInteger y, int scale, MathContext mc) {
<span class="nc bnc" id="L5067" title="All 2 branches missed.">        if(x==0) {</span>
<span class="nc" id="L5068">            return zeroValueOf(scale);</span>
        }
<span class="nc" id="L5070">        return doRound(y.multiply(x), scale, mc);</span>
    }

    private static BigDecimal multiplyAndRound(BigInteger x, BigInteger y, int scale, MathContext mc) {
<span class="nc" id="L5074">        return doRound(x.multiply(y), scale, mc);</span>
    }

    /**
     * rounds 128-bit value according {@code MathContext}
     * returns null if result can't be repsented as compact BigDecimal.
     */
    private static BigDecimal doRound128(long hi, long lo, int sign, int scale, MathContext mc) {
<span class="nc" id="L5082">        int mcp = mc.precision;</span>
        int drop;
<span class="nc" id="L5084">        BigDecimal res = null;</span>
<span class="nc bnc" id="L5085" title="All 4 branches missed.">        if(((drop = precision(hi, lo) - mcp) &gt; 0)&amp;&amp;(drop&lt;LONG_TEN_POWERS_TABLE.length)) {</span>
<span class="nc" id="L5086">            scale = checkScaleNonZero((long)scale - drop);</span>
<span class="nc" id="L5087">            res = divideAndRound128(hi, lo, LONG_TEN_POWERS_TABLE[drop], sign, scale, mc.roundingMode.oldMode, scale);</span>
        }
<span class="nc bnc" id="L5089" title="All 2 branches missed.">        if(res!=null) {</span>
<span class="nc" id="L5090">            return doRound(res,mc);</span>
        }
<span class="nc" id="L5092">        return null;</span>
    }

<span class="fc" id="L5095">    private static final long[][] LONGLONG_TEN_POWERS_TABLE = {</span>
        {   0L, 0x8AC7230489E80000L },  //10^19
        {       0x5L, 0x6bc75e2d63100000L },  //10^20
        {       0x36L, 0x35c9adc5dea00000L },  //10^21
        {       0x21eL, 0x19e0c9bab2400000L  },  //10^22
        {       0x152dL, 0x02c7e14af6800000L  },  //10^23
        {       0xd3c2L, 0x1bcecceda1000000L  },  //10^24
        {       0x84595L, 0x161401484a000000L  },  //10^25
        {       0x52b7d2L, 0xdcc80cd2e4000000L  },  //10^26
        {       0x33b2e3cL, 0x9fd0803ce8000000L  },  //10^27
        {       0x204fce5eL, 0x3e25026110000000L  },  //10^28
        {       0x1431e0faeL, 0x6d7217caa0000000L  },  //10^29
        {       0xc9f2c9cd0L, 0x4674edea40000000L  },  //10^30
        {       0x7e37be2022L, 0xc0914b2680000000L  },  //10^31
        {       0x4ee2d6d415bL, 0x85acef8100000000L  },  //10^32
        {       0x314dc6448d93L, 0x38c15b0a00000000L  },  //10^33
        {       0x1ed09bead87c0L, 0x378d8e6400000000L  },  //10^34
        {       0x13426172c74d82L, 0x2b878fe800000000L  },  //10^35
        {       0xc097ce7bc90715L, 0xb34b9f1000000000L  },  //10^36
        {       0x785ee10d5da46d9L, 0x00f436a000000000L  },  //10^37
        {       0x4b3b4ca85a86c47aL, 0x098a224000000000L  },  //10^38
    };

    /*
     * returns precision of 128-bit value
     */
    private static int precision(long hi, long lo){
<span class="nc bnc" id="L5122" title="All 2 branches missed.">        if(hi==0) {</span>
<span class="nc bnc" id="L5123" title="All 2 branches missed.">            if(lo&gt;=0) {</span>
<span class="nc" id="L5124">                return longDigitLength(lo);</span>
            }
<span class="nc bnc" id="L5126" title="All 2 branches missed.">            return (unsignedLongCompareEq(lo, LONGLONG_TEN_POWERS_TABLE[0][1])) ? 20 : 19;</span>
            // 0x8AC7230489E80000L  = unsigned 2^19
        }
<span class="nc" id="L5129">        int r = ((128 - Long.numberOfLeadingZeros(hi) + 1) * 1233) &gt;&gt;&gt; 12;</span>
<span class="nc" id="L5130">        int idx = r-19;</span>
<span class="nc bnc" id="L5131" title="All 4 branches missed.">        return (idx &gt;= LONGLONG_TEN_POWERS_TABLE.length || longLongCompareMagnitude(hi, lo,</span>
                                                                                    LONGLONG_TEN_POWERS_TABLE[idx][0], LONGLONG_TEN_POWERS_TABLE[idx][1])) ? r : r + 1;
    }

    /*
     * returns true if 128 bit number &lt;hi0,lo0&gt; is less then &lt;hi1,lo1&gt;
     * hi0 &amp; hi1 should be non-negative
     */
    private static boolean longLongCompareMagnitude(long hi0, long lo0, long hi1, long lo1) {
<span class="nc bnc" id="L5140" title="All 2 branches missed.">        if(hi0!=hi1) {</span>
<span class="nc bnc" id="L5141" title="All 2 branches missed.">            return hi0&lt;hi1;</span>
        }
<span class="nc bnc" id="L5143" title="All 2 branches missed.">        return (lo0+Long.MIN_VALUE) &lt;(lo1+Long.MIN_VALUE);</span>
    }

    private static BigDecimal divide(long dividend, int dividendScale, long divisor, int divisorScale, int scale, int roundingMode) {
<span class="fc bfc" id="L5147" title="All 2 branches covered.">        if (checkScale(dividend,(long)scale + divisorScale) &gt; dividendScale) {</span>
<span class="fc" id="L5148">            int newScale = scale + divisorScale;</span>
<span class="fc" id="L5149">            int raise = newScale - dividendScale;</span>
<span class="pc bpc" id="L5150" title="1 of 2 branches missed.">            if(raise&lt;LONG_TEN_POWERS_TABLE.length) {</span>
<span class="fc" id="L5151">                long xs = dividend;</span>
<span class="pc bpc" id="L5152" title="1 of 2 branches missed.">                if ((xs = longMultiplyPowerTen(xs, raise)) != INFLATED) {</span>
<span class="fc" id="L5153">                    return divideAndRound(xs, divisor, scale, roundingMode, scale);</span>
                }
<span class="nc" id="L5155">                BigDecimal q = multiplyDivideAndRound(LONG_TEN_POWERS_TABLE[raise], dividend, divisor, scale, roundingMode, scale);</span>
<span class="nc bnc" id="L5156" title="All 2 branches missed.">                if(q!=null) {</span>
<span class="nc" id="L5157">                    return q;</span>
                }
            }
<span class="nc" id="L5160">            BigInteger scaledDividend = bigMultiplyPowerTen(dividend, raise);</span>
<span class="nc" id="L5161">            return divideAndRound(scaledDividend, divisor, scale, roundingMode, scale);</span>
        } else {
<span class="fc" id="L5163">            int newScale = checkScale(divisor,(long)dividendScale - scale);</span>
<span class="fc" id="L5164">            int raise = newScale - divisorScale;</span>
<span class="pc bpc" id="L5165" title="1 of 2 branches missed.">            if(raise&lt;LONG_TEN_POWERS_TABLE.length) {</span>
<span class="fc" id="L5166">                long ys = divisor;</span>
<span class="pc bpc" id="L5167" title="1 of 2 branches missed.">                if ((ys = longMultiplyPowerTen(ys, raise)) != INFLATED) {</span>
<span class="fc" id="L5168">                    return divideAndRound(dividend, ys, scale, roundingMode, scale);</span>
                }
            }
<span class="nc" id="L5171">            BigInteger scaledDivisor = bigMultiplyPowerTen(divisor, raise);</span>
<span class="nc" id="L5172">            return divideAndRound(BigInteger.valueOf(dividend), scaledDivisor, scale, roundingMode, scale);</span>
        }
    }

    private static BigDecimal divide(BigInteger dividend, int dividendScale, long divisor, int divisorScale, int scale, int roundingMode) {
<span class="pc bpc" id="L5177" title="1 of 2 branches missed.">        if (checkScale(dividend,(long)scale + divisorScale) &gt; dividendScale) {</span>
<span class="nc" id="L5178">            int newScale = scale + divisorScale;</span>
<span class="nc" id="L5179">            int raise = newScale - dividendScale;</span>
<span class="nc" id="L5180">            BigInteger scaledDividend = bigMultiplyPowerTen(dividend, raise);</span>
<span class="nc" id="L5181">            return divideAndRound(scaledDividend, divisor, scale, roundingMode, scale);</span>
        } else {
<span class="fc" id="L5183">            int newScale = checkScale(divisor,(long)dividendScale - scale);</span>
<span class="fc" id="L5184">            int raise = newScale - divisorScale;</span>
<span class="pc bpc" id="L5185" title="1 of 2 branches missed.">            if(raise&lt;LONG_TEN_POWERS_TABLE.length) {</span>
<span class="fc" id="L5186">                long ys = divisor;</span>
<span class="pc bpc" id="L5187" title="1 of 2 branches missed.">                if ((ys = longMultiplyPowerTen(ys, raise)) != INFLATED) {</span>
<span class="fc" id="L5188">                    return divideAndRound(dividend, ys, scale, roundingMode, scale);</span>
                }
            }
<span class="nc" id="L5191">            BigInteger scaledDivisor = bigMultiplyPowerTen(divisor, raise);</span>
<span class="nc" id="L5192">            return divideAndRound(dividend, scaledDivisor, scale, roundingMode, scale);</span>
        }
    }

    private static BigDecimal divide(long dividend, int dividendScale, BigInteger divisor, int divisorScale, int scale, int roundingMode) {
<span class="nc bnc" id="L5197" title="All 2 branches missed.">        if (checkScale(dividend,(long)scale + divisorScale) &gt; dividendScale) {</span>
<span class="nc" id="L5198">            int newScale = scale + divisorScale;</span>
<span class="nc" id="L5199">            int raise = newScale - dividendScale;</span>
<span class="nc" id="L5200">            BigInteger scaledDividend = bigMultiplyPowerTen(dividend, raise);</span>
<span class="nc" id="L5201">            return divideAndRound(scaledDividend, divisor, scale, roundingMode, scale);</span>
        } else {
<span class="nc" id="L5203">            int newScale = checkScale(divisor,(long)dividendScale - scale);</span>
<span class="nc" id="L5204">            int raise = newScale - divisorScale;</span>
<span class="nc" id="L5205">            BigInteger scaledDivisor = bigMultiplyPowerTen(divisor, raise);</span>
<span class="nc" id="L5206">            return divideAndRound(BigInteger.valueOf(dividend), scaledDivisor, scale, roundingMode, scale);</span>
        }
    }

    private static BigDecimal divide(BigInteger dividend, int dividendScale, BigInteger divisor, int divisorScale, int scale, int roundingMode) {
<span class="nc bnc" id="L5211" title="All 2 branches missed.">        if (checkScale(dividend,(long)scale + divisorScale) &gt; dividendScale) {</span>
<span class="nc" id="L5212">            int newScale = scale + divisorScale;</span>
<span class="nc" id="L5213">            int raise = newScale - dividendScale;</span>
<span class="nc" id="L5214">            BigInteger scaledDividend = bigMultiplyPowerTen(dividend, raise);</span>
<span class="nc" id="L5215">            return divideAndRound(scaledDividend, divisor, scale, roundingMode, scale);</span>
        } else {
<span class="nc" id="L5217">            int newScale = checkScale(divisor,(long)dividendScale - scale);</span>
<span class="nc" id="L5218">            int raise = newScale - divisorScale;</span>
<span class="nc" id="L5219">            BigInteger scaledDivisor = bigMultiplyPowerTen(divisor, raise);</span>
<span class="nc" id="L5220">            return divideAndRound(dividend, scaledDivisor, scale, roundingMode, scale);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>