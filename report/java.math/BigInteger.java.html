<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BigInteger.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.math</a> &gt; <span class="el_source">BigInteger.java</span></div><h1>BigInteger.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * Portions Copyright (c) 1995  Colin Plumb.  All rights reserved.
 */

package java.math;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamField;
import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import sun.misc.DoubleConsts;
import sun.misc.FloatConsts;

/**
 * Immutable arbitrary-precision integers.  All operations behave as if
 * BigIntegers were represented in two's-complement notation (like Java's
 * primitive integer types).  BigInteger provides analogues to all of Java's
 * primitive integer operators, and all relevant methods from java.lang.Math.
 * Additionally, BigInteger provides operations for modular arithmetic, GCD
 * calculation, primality testing, prime generation, bit manipulation,
 * and a few other miscellaneous operations.
 *
 * &lt;p&gt;Semantics of arithmetic operations exactly mimic those of Java's integer
 * arithmetic operators, as defined in &lt;i&gt;The Java Language Specification&lt;/i&gt;.
 * For example, division by zero throws an {@code ArithmeticException}, and
 * division of a negative by a positive yields a negative (or zero) remainder.
 * All of the details in the Spec concerning overflow are ignored, as
 * BigIntegers are made as large as necessary to accommodate the results of an
 * operation.
 *
 * &lt;p&gt;Semantics of shift operations extend those of Java's shift operators
 * to allow for negative shift distances.  A right-shift with a negative
 * shift distance results in a left shift, and vice-versa.  The unsigned
 * right shift operator ({@code &gt;&gt;&gt;}) is omitted, as this operation makes
 * little sense in combination with the &quot;infinite word size&quot; abstraction
 * provided by this class.
 *
 * &lt;p&gt;Semantics of bitwise logical operations exactly mimic those of Java's
 * bitwise integer operators.  The binary operators ({@code and},
 * {@code or}, {@code xor}) implicitly perform sign extension on the shorter
 * of the two operands prior to performing the operation.
 *
 * &lt;p&gt;Comparison operations perform signed integer comparisons, analogous to
 * those performed by Java's relational and equality operators.
 *
 * &lt;p&gt;Modular arithmetic operations are provided to compute residues, perform
 * exponentiation, and compute multiplicative inverses.  These methods always
 * return a non-negative result, between {@code 0} and {@code (modulus - 1)},
 * inclusive.
 *
 * &lt;p&gt;Bit operations operate on a single bit of the two's-complement
 * representation of their operand.  If necessary, the operand is sign-
 * extended so that it contains the designated bit.  None of the single-bit
 * operations can produce a BigInteger with a different sign from the
 * BigInteger being operated on, as they affect only a single bit, and the
 * &quot;infinite word size&quot; abstraction provided by this class ensures that there
 * are infinitely many &quot;virtual sign bits&quot; preceding each BigInteger.
 *
 * &lt;p&gt;For the sake of brevity and clarity, pseudo-code is used throughout the
 * descriptions of BigInteger methods.  The pseudo-code expression
 * {@code (i + j)} is shorthand for &quot;a BigInteger whose value is
 * that of the BigInteger {@code i} plus that of the BigInteger {@code j}.&quot;
 * The pseudo-code expression {@code (i == j)} is shorthand for
 * &quot;{@code true} if and only if the BigInteger {@code i} represents the same
 * value as the BigInteger {@code j}.&quot;  Other pseudo-code expressions are
 * interpreted similarly.
 *
 * &lt;p&gt;All methods and constructors in this class throw
 * {@code NullPointerException} when passed
 * a null object reference for any input parameter.
 *
 * BigInteger must support values in the range
 * -2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive) to
 * +2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive)
 * and may support values outside of that range.
 *
 * The range of probable prime values is limited and may be less than
 * the full supported positive range of {@code BigInteger}.
 * The range must be at least 1 to 2&lt;sup&gt;500000000&lt;/sup&gt;.
 *
 * @implNote
 * BigInteger constructors and operations throw {@code ArithmeticException} when
 * the result is out of the supported range of
 * -2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive) to
 * +2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive).
 *
 * @see     BigDecimal
 * @author  Josh Bloch
 * @author  Michael McCloskey
 * @author  Alan Eliasen
 * @author  Timothy Buktu
 * @since JDK1.1
 */

<span class="fc bfc" id="L123" title="All 2 branches covered.">public class BigInteger extends Number implements Comparable&lt;BigInteger&gt; {</span>
    /**
     * The signum of this BigInteger: -1 for negative, 0 for zero, or
     * 1 for positive.  Note that the BigInteger zero &lt;i&gt;must&lt;/i&gt; have
     * a signum of 0.  This is necessary to ensures that there is exactly one
     * representation for each BigInteger value.
     *
     * @serial
     */
    final int signum;

    /**
     * The magnitude of this BigInteger, in &lt;i&gt;big-endian&lt;/i&gt; order: the
     * zeroth element of this array is the most-significant int of the
     * magnitude.  The magnitude must be &quot;minimal&quot; in that the most-significant
     * int ({@code mag[0]}) must be non-zero.  This is necessary to
     * ensure that there is exactly one representation for each BigInteger
     * value.  Note that this implies that the BigInteger zero has a
     * zero-length mag array.
     */
    final int[] mag;

    // These &quot;redundant fields&quot; are initialized with recognizable nonsense
    // values, and cached the first time they are needed (or never, if they
    // aren't needed).

     /**
     * One plus the bitCount of this BigInteger. Zeros means unitialized.
     *
     * @serial
     * @see #bitCount
     * @deprecated Deprecated since logical value is offset from stored
     * value and correction factor is applied in accessor method.
     */
    @Deprecated
    private int bitCount;

    /**
     * One plus the bitLength of this BigInteger. Zeros means unitialized.
     * (either value is acceptable).
     *
     * @serial
     * @see #bitLength()
     * @deprecated Deprecated since logical value is offset from stored
     * value and correction factor is applied in accessor method.
     */
    @Deprecated
    private int bitLength;

    /**
     * Two plus the lowest set bit of this BigInteger, as returned by
     * getLowestSetBit().
     *
     * @serial
     * @see #getLowestSetBit
     * @deprecated Deprecated since logical value is offset from stored
     * value and correction factor is applied in accessor method.
     */
    @Deprecated
    private int lowestSetBit;

    /**
     * Two plus the index of the lowest-order int in the magnitude of this
     * BigInteger that contains a nonzero int, or -2 (either value is acceptable).
     * The least significant int has int-number 0, the next int in order of
     * increasing significance has int-number 1, and so forth.
     * @deprecated Deprecated since logical value is offset from stored
     * value and correction factor is applied in accessor method.
     */
    @Deprecated
    private int firstNonzeroIntNum;

    /**
     * This mask is used to obtain the value of an int as if it were unsigned.
     */
    final static long LONG_MASK = 0xffffffffL;

    /**
     * This constant limits {@code mag.length} of BigIntegers to the supported
     * range.
     */
    private static final int MAX_MAG_LENGTH = Integer.MAX_VALUE / Integer.SIZE + 1; // (1 &lt;&lt; 26)

    /**
     * Bit lengths larger than this constant can cause overflow in searchLen
     * calculation and in BitSieve.singleSearch method.
     */
    private static final  int PRIME_SEARCH_BIT_LENGTH_LIMIT = 500000000;

    /**
     * The threshold value for using Karatsuba multiplication.  If the number
     * of ints in both mag arrays are greater than this number, then
     * Karatsuba multiplication will be used.   This value is found
     * experimentally to work well.
     */
    private static final int KARATSUBA_THRESHOLD = 50;

    /**
     * The threshold value for using 3-way Toom-Cook multiplication.
     * If the number of ints in each mag array is greater than the
     * Karatsuba threshold, and the number of ints in at least one of
     * the mag arrays is greater than this threshold, then Toom-Cook
     * multiplication will be used.
     */
    private static final int TOOM_COOK_THRESHOLD = 75;

    /**
     * The threshold value for using Karatsuba squaring.  If the number
     * of ints in the number are larger than this value,
     * Karatsuba squaring will be used.   This value is found
     * experimentally to work well.
     */
    private static final int KARATSUBA_SQUARE_THRESHOLD = 90;

    /**
     * The threshold value for using Toom-Cook squaring.  If the number
     * of ints in the number are larger than this value,
     * Toom-Cook squaring will be used.   This value is found
     * experimentally to work well.
     */
    private static final int TOOM_COOK_SQUARE_THRESHOLD = 140;

    /**
     * The threshold value for using Burnikel-Ziegler division.  If the number
     * of ints in the number are larger than this value,
     * Burnikel-Ziegler division will be used.   This value is found
     * experimentally to work well.
     */
    static final int BURNIKEL_ZIEGLER_THRESHOLD = 50;

    /**
     * The threshold value for using Schoenhage recursive base conversion. If
     * the number of ints in the number are larger than this value,
     * the Schoenhage algorithm will be used.  In practice, it appears that the
     * Schoenhage routine is faster for any threshold down to 2, and is
     * relatively flat for thresholds between 2-25, so this choice may be
     * varied within this range for very small effect.
     */
    private static final int SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 8;

    //Constructors

    /**
     * Translates a byte array containing the two's-complement binary
     * representation of a BigInteger into a BigInteger.  The input array is
     * assumed to be in &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant
     * byte is in the zeroth element.
     *
     * @param  val big-endian two's-complement binary representation of
     *         BigInteger.
     * @throws NumberFormatException {@code val} is zero bytes long.
     */
<span class="fc" id="L275">    public BigInteger(byte[] val) {</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if (val.length == 0)</span>
<span class="nc" id="L277">            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</span>

<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (val[0] &lt; 0) {</span>
<span class="fc" id="L280">            mag = makePositive(val);</span>
<span class="fc" id="L281">            signum = -1;</span>
        } else {
<span class="fc" id="L283">            mag = stripLeadingZeroBytes(val);</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">            signum = (mag.length == 0 ? 0 : 1);</span>
        }
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if (mag.length &gt;= MAX_MAG_LENGTH) {</span>
<span class="nc" id="L287">            checkRange();</span>
        }
<span class="fc" id="L289">    }</span>

    /**
     * This private constructor translates an int array containing the
     * two's-complement binary representation of a BigInteger into a
     * BigInteger. The input array is assumed to be in &lt;i&gt;big-endian&lt;/i&gt;
     * int-order: the most significant int is in the zeroth element.
     */
<span class="fc" id="L297">    private BigInteger(int[] val) {</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (val.length == 0)</span>
<span class="nc" id="L299">            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</span>

<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (val[0] &lt; 0) {</span>
<span class="fc" id="L302">            mag = makePositive(val);</span>
<span class="fc" id="L303">            signum = -1;</span>
        } else {
<span class="fc" id="L305">            mag = trustedStripLeadingZeroInts(val);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">            signum = (mag.length == 0 ? 0 : 1);</span>
        }
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if (mag.length &gt;= MAX_MAG_LENGTH) {</span>
<span class="nc" id="L309">            checkRange();</span>
        }
<span class="fc" id="L311">    }</span>

    /**
     * Translates the sign-magnitude representation of a BigInteger into a
     * BigInteger.  The sign is represented as an integer signum value: -1 for
     * negative, 0 for zero, or 1 for positive.  The magnitude is a byte array
     * in &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant byte is in the
     * zeroth element.  A zero-length magnitude array is permissible, and will
     * result in a BigInteger value of 0, whether signum is -1, 0 or 1.
     *
     * @param  signum signum of the number (-1 for negative, 0 for zero, 1
     *         for positive).
     * @param  magnitude big-endian binary representation of the magnitude of
     *         the number.
     * @throws NumberFormatException {@code signum} is not one of the three
     *         legal values (-1, 0, and 1), or {@code signum} is 0 and
     *         {@code magnitude} contains one or more non-zero bytes.
     */
<span class="fc" id="L329">    public BigInteger(int signum, byte[] magnitude) {</span>
<span class="fc" id="L330">        this.mag = stripLeadingZeroBytes(magnitude);</span>

<span class="pc bpc" id="L332" title="2 of 4 branches missed.">        if (signum &lt; -1 || signum &gt; 1)</span>
<span class="nc" id="L333">            throw(new NumberFormatException(&quot;Invalid signum value&quot;));</span>

<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (this.mag.length == 0) {</span>
<span class="fc" id="L336">            this.signum = 0;</span>
        } else {
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">            if (signum == 0)</span>
<span class="nc" id="L339">                throw(new NumberFormatException(&quot;signum-magnitude mismatch&quot;));</span>
<span class="fc" id="L340">            this.signum = signum;</span>
        }
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        if (mag.length &gt;= MAX_MAG_LENGTH) {</span>
<span class="nc" id="L343">            checkRange();</span>
        }
<span class="fc" id="L345">    }</span>

    /**
     * A constructor for internal use that translates the sign-magnitude
     * representation of a BigInteger into a BigInteger. It checks the
     * arguments and copies the magnitude so this constructor would be
     * safe for external use.
     */
<span class="fc" id="L353">    private BigInteger(int signum, int[] magnitude) {</span>
<span class="fc" id="L354">        this.mag = stripLeadingZeroInts(magnitude);</span>

<span class="pc bpc" id="L356" title="2 of 4 branches missed.">        if (signum &lt; -1 || signum &gt; 1)</span>
<span class="nc" id="L357">            throw(new NumberFormatException(&quot;Invalid signum value&quot;));</span>

<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (this.mag.length == 0) {</span>
<span class="fc" id="L360">            this.signum = 0;</span>
        } else {
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">            if (signum == 0)</span>
<span class="nc" id="L363">                throw(new NumberFormatException(&quot;signum-magnitude mismatch&quot;));</span>
<span class="fc" id="L364">            this.signum = signum;</span>
        }
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (mag.length &gt;= MAX_MAG_LENGTH) {</span>
<span class="nc" id="L367">            checkRange();</span>
        }
<span class="fc" id="L369">    }</span>

    /**
     * Translates the String representation of a BigInteger in the
     * specified radix into a BigInteger.  The String representation
     * consists of an optional minus or plus sign followed by a
     * sequence of one or more digits in the specified radix.  The
     * character-to-digit mapping is provided by {@code
     * Character.digit}.  The String may not contain any extraneous
     * characters (whitespace, for example).
     *
     * @param val String representation of BigInteger.
     * @param radix radix to be used in interpreting {@code val}.
     * @throws NumberFormatException {@code val} is not a valid representation
     *         of a BigInteger in the specified radix, or {@code radix} is
     *         outside the range from {@link Character#MIN_RADIX} to
     *         {@link Character#MAX_RADIX}, inclusive.
     * @see    Character#digit
     */
<span class="fc" id="L388">    public BigInteger(String val, int radix) {</span>
<span class="fc" id="L389">        int cursor = 0, numDigits;</span>
<span class="fc" id="L390">        final int len = val.length();</span>

<span class="pc bpc" id="L392" title="2 of 4 branches missed.">        if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)</span>
<span class="nc" id="L393">            throw new NumberFormatException(&quot;Radix out of range&quot;);</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        if (len == 0)</span>
<span class="nc" id="L395">            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</span>

        // Check for at most one leading sign
<span class="fc" id="L398">        int sign = 1;</span>
<span class="fc" id="L399">        int index1 = val.lastIndexOf('-');</span>
<span class="fc" id="L400">        int index2 = val.lastIndexOf('+');</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">        if (index1 &gt;= 0) {</span>
<span class="pc bpc" id="L402" title="2 of 4 branches missed.">            if (index1 != 0 || index2 &gt;= 0) {</span>
<span class="nc" id="L403">                throw new NumberFormatException(&quot;Illegal embedded sign character&quot;);</span>
            }
<span class="fc" id="L405">            sign = -1;</span>
<span class="fc" id="L406">            cursor = 1;</span>
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">        } else if (index2 &gt;= 0) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if (index2 != 0) {</span>
<span class="nc" id="L409">                throw new NumberFormatException(&quot;Illegal embedded sign character&quot;);</span>
            }
<span class="nc" id="L411">            cursor = 1;</span>
        }
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        if (cursor == len)</span>
<span class="nc" id="L414">            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</span>

        // Skip leading zeros and compute number of digits in magnitude
<span class="fc bfc" id="L417" title="All 2 branches covered.">        while (cursor &lt; len &amp;&amp;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">               Character.digit(val.charAt(cursor), radix) == 0) {</span>
<span class="fc" id="L419">            cursor++;</span>
        }

<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (cursor == len) {</span>
<span class="fc" id="L423">            signum = 0;</span>
<span class="fc" id="L424">            mag = ZERO.mag;</span>
<span class="fc" id="L425">            return;</span>
        }

<span class="fc" id="L428">        numDigits = len - cursor;</span>
<span class="fc" id="L429">        signum = sign;</span>

        // Pre-allocate array of expected size. May be too large but can
        // never be too small. Typically exact.
<span class="fc" id="L433">        long numBits = ((numDigits * bitsPerDigit[radix]) &gt;&gt;&gt; 10) + 1;</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        if (numBits + 31 &gt;= (1L &lt;&lt; 32)) {</span>
<span class="nc" id="L435">            reportOverflow();</span>
        }
<span class="fc" id="L437">        int numWords = (int) (numBits + 31) &gt;&gt;&gt; 5;</span>
<span class="fc" id="L438">        int[] magnitude = new int[numWords];</span>

        // Process first (potentially short) digit group
<span class="fc" id="L441">        int firstGroupLen = numDigits % digitsPerInt[radix];</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">        if (firstGroupLen == 0)</span>
<span class="fc" id="L443">            firstGroupLen = digitsPerInt[radix];</span>
<span class="fc" id="L444">        String group = val.substring(cursor, cursor += firstGroupLen);</span>
<span class="fc" id="L445">        magnitude[numWords - 1] = Integer.parseInt(group, radix);</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if (magnitude[numWords - 1] &lt; 0)</span>
<span class="nc" id="L447">            throw new NumberFormatException(&quot;Illegal digit&quot;);</span>

        // Process remaining digit groups
<span class="fc" id="L450">        int superRadix = intRadix[radix];</span>
<span class="fc" id="L451">        int groupVal = 0;</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">        while (cursor &lt; len) {</span>
<span class="fc" id="L453">            group = val.substring(cursor, cursor += digitsPerInt[radix]);</span>
<span class="fc" id="L454">            groupVal = Integer.parseInt(group, radix);</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">            if (groupVal &lt; 0)</span>
<span class="nc" id="L456">                throw new NumberFormatException(&quot;Illegal digit&quot;);</span>
<span class="fc" id="L457">            destructiveMulAdd(magnitude, superRadix, groupVal);</span>
        }
        // Required for cases where the array was overallocated.
<span class="fc" id="L460">        mag = trustedStripLeadingZeroInts(magnitude);</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        if (mag.length &gt;= MAX_MAG_LENGTH) {</span>
<span class="nc" id="L462">            checkRange();</span>
        }
<span class="fc" id="L464">    }</span>

    /*
     * Constructs a new BigInteger using a char array with radix=10.
     * Sign is precalculated outside and not allowed in the val.
     */
<span class="fc" id="L470">    BigInteger(char[] val, int sign, int len) {</span>
<span class="fc" id="L471">        int cursor = 0, numDigits;</span>

        // Skip leading zeros and compute number of digits in magnitude
<span class="pc bpc" id="L474" title="2 of 4 branches missed.">        while (cursor &lt; len &amp;&amp; Character.digit(val[cursor], 10) == 0) {</span>
<span class="nc" id="L475">            cursor++;</span>
        }
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">        if (cursor == len) {</span>
<span class="nc" id="L478">            signum = 0;</span>
<span class="nc" id="L479">            mag = ZERO.mag;</span>
<span class="nc" id="L480">            return;</span>
        }

<span class="fc" id="L483">        numDigits = len - cursor;</span>
<span class="fc" id="L484">        signum = sign;</span>
        // Pre-allocate array of expected size
        int numWords;
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (len &lt; 10) {</span>
<span class="fc" id="L488">            numWords = 1;</span>
        } else {
<span class="fc" id="L490">            long numBits = ((numDigits * bitsPerDigit[10]) &gt;&gt;&gt; 10) + 1;</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">            if (numBits + 31 &gt;= (1L &lt;&lt; 32)) {</span>
<span class="nc" id="L492">                reportOverflow();</span>
            }
<span class="fc" id="L494">            numWords = (int) (numBits + 31) &gt;&gt;&gt; 5;</span>
        }
<span class="fc" id="L496">        int[] magnitude = new int[numWords];</span>

        // Process first (potentially short) digit group
<span class="fc" id="L499">        int firstGroupLen = numDigits % digitsPerInt[10];</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">        if (firstGroupLen == 0)</span>
<span class="fc" id="L501">            firstGroupLen = digitsPerInt[10];</span>
<span class="fc" id="L502">        magnitude[numWords - 1] = parseInt(val, cursor,  cursor += firstGroupLen);</span>

        // Process remaining digit groups
<span class="fc bfc" id="L505" title="All 2 branches covered.">        while (cursor &lt; len) {</span>
<span class="fc" id="L506">            int groupVal = parseInt(val, cursor, cursor += digitsPerInt[10]);</span>
<span class="fc" id="L507">            destructiveMulAdd(magnitude, intRadix[10], groupVal);</span>
<span class="fc" id="L508">        }</span>
<span class="fc" id="L509">        mag = trustedStripLeadingZeroInts(magnitude);</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">        if (mag.length &gt;= MAX_MAG_LENGTH) {</span>
<span class="nc" id="L511">            checkRange();</span>
        }
<span class="fc" id="L513">    }</span>

    // Create an integer with the digits between the two indexes
    // Assumes start &lt; end. The result may be negative, but it
    // is to be treated as an unsigned value.
    private int parseInt(char[] source, int start, int end) {
<span class="fc" id="L519">        int result = Character.digit(source[start++], 10);</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">        if (result == -1)</span>
<span class="nc" id="L521">            throw new NumberFormatException(new String(source));</span>

<span class="fc bfc" id="L523" title="All 2 branches covered.">        for (int index = start; index &lt; end; index++) {</span>
<span class="fc" id="L524">            int nextVal = Character.digit(source[index], 10);</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">            if (nextVal == -1)</span>
<span class="nc" id="L526">                throw new NumberFormatException(new String(source));</span>
<span class="fc" id="L527">            result = 10*result + nextVal;</span>
        }

<span class="fc" id="L530">        return result;</span>
    }

    // bitsPerDigit in the given radix times 1024
    // Rounded up to avoid underallocation.
<span class="fc" id="L535">    private static long bitsPerDigit[] = { 0, 0,</span>
        1024, 1624, 2048, 2378, 2648, 2875, 3072, 3247, 3402, 3543, 3672,
        3790, 3899, 4001, 4096, 4186, 4271, 4350, 4426, 4498, 4567, 4633,
        4696, 4756, 4814, 4870, 4923, 4975, 5025, 5074, 5120, 5166, 5210,
                                           5253, 5295};

    // Multiply x array times word y in place, and add word z
    private static void destructiveMulAdd(int[] x, int y, int z) {
        // Perform the multiplication word by word
<span class="fc" id="L544">        long ylong = y &amp; LONG_MASK;</span>
<span class="fc" id="L545">        long zlong = z &amp; LONG_MASK;</span>
<span class="fc" id="L546">        int len = x.length;</span>

<span class="fc" id="L548">        long product = 0;</span>
<span class="fc" id="L549">        long carry = 0;</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">        for (int i = len-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L551">            product = ylong * (x[i] &amp; LONG_MASK) + carry;</span>
<span class="fc" id="L552">            x[i] = (int)product;</span>
<span class="fc" id="L553">            carry = product &gt;&gt;&gt; 32;</span>
        }

        // Perform the addition
<span class="fc" id="L557">        long sum = (x[len-1] &amp; LONG_MASK) + zlong;</span>
<span class="fc" id="L558">        x[len-1] = (int)sum;</span>
<span class="fc" id="L559">        carry = sum &gt;&gt;&gt; 32;</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">        for (int i = len-2; i &gt;= 0; i--) {</span>
<span class="fc" id="L561">            sum = (x[i] &amp; LONG_MASK) + carry;</span>
<span class="fc" id="L562">            x[i] = (int)sum;</span>
<span class="fc" id="L563">            carry = sum &gt;&gt;&gt; 32;</span>
        }
<span class="fc" id="L565">    }</span>

    /**
     * Translates the decimal String representation of a BigInteger into a
     * BigInteger.  The String representation consists of an optional minus
     * sign followed by a sequence of one or more decimal digits.  The
     * character-to-digit mapping is provided by {@code Character.digit}.
     * The String may not contain any extraneous characters (whitespace, for
     * example).
     *
     * @param val decimal String representation of BigInteger.
     * @throws NumberFormatException {@code val} is not a valid representation
     *         of a BigInteger.
     * @see    Character#digit
     */
    public BigInteger(String val) {
<span class="fc" id="L581">        this(val, 10);</span>
<span class="fc" id="L582">    }</span>

    /**
     * Constructs a randomly generated BigInteger, uniformly distributed over
     * the range 0 to (2&lt;sup&gt;{@code numBits}&lt;/sup&gt; - 1), inclusive.
     * The uniformity of the distribution assumes that a fair source of random
     * bits is provided in {@code rnd}.  Note that this constructor always
     * constructs a non-negative BigInteger.
     *
     * @param  numBits maximum bitLength of the new BigInteger.
     * @param  rnd source of randomness to be used in computing the new
     *         BigInteger.
     * @throws IllegalArgumentException {@code numBits} is negative.
     * @see #bitLength()
     */
    public BigInteger(int numBits, Random rnd) {
<span class="fc" id="L598">        this(1, randomBits(numBits, rnd));</span>
<span class="fc" id="L599">    }</span>

    private static byte[] randomBits(int numBits, Random rnd) {
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if (numBits &lt; 0)</span>
<span class="nc" id="L603">            throw new IllegalArgumentException(&quot;numBits must be non-negative&quot;);</span>
<span class="fc" id="L604">        int numBytes = (int)(((long)numBits+7)/8); // avoid overflow</span>
<span class="fc" id="L605">        byte[] randomBits = new byte[numBytes];</span>

        // Generate random bytes and mask out any excess bits
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        if (numBytes &gt; 0) {</span>
<span class="fc" id="L609">            rnd.nextBytes(randomBits);</span>
<span class="fc" id="L610">            int excessBits = 8*numBytes - numBits;</span>
<span class="fc" id="L611">            randomBits[0] &amp;= (1 &lt;&lt; (8-excessBits)) - 1;</span>
        }
<span class="fc" id="L613">        return randomBits;</span>
    }

    /**
     * Constructs a randomly generated positive BigInteger that is probably
     * prime, with the specified bitLength.
     *
     * &lt;p&gt;It is recommended that the {@link #probablePrime probablePrime}
     * method be used in preference to this constructor unless there
     * is a compelling need to specify a certainty.
     *
     * @param  bitLength bitLength of the returned BigInteger.
     * @param  certainty a measure of the uncertainty that the caller is
     *         willing to tolerate.  The probability that the new BigInteger
     *         represents a prime number will exceed
     *         (1 - 1/2&lt;sup&gt;{@code certainty}&lt;/sup&gt;).  The execution time of
     *         this constructor is proportional to the value of this parameter.
     * @param  rnd source of random bits used to select candidates to be
     *         tested for primality.
     * @throws ArithmeticException {@code bitLength &lt; 2} or {@code bitLength} is too large.
     * @see    #bitLength()
     */
<span class="fc" id="L635">    public BigInteger(int bitLength, int certainty, Random rnd) {</span>
        BigInteger prime;

<span class="pc bpc" id="L638" title="1 of 2 branches missed.">        if (bitLength &lt; 2)</span>
<span class="nc" id="L639">            throw new ArithmeticException(&quot;bitLength &lt; 2&quot;);</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">        prime = (bitLength &lt; SMALL_PRIME_THRESHOLD</span>
<span class="fc" id="L641">                                ? smallPrime(bitLength, certainty, rnd)</span>
<span class="fc" id="L642">                                : largePrime(bitLength, certainty, rnd));</span>
<span class="fc" id="L643">        signum = 1;</span>
<span class="fc" id="L644">        mag = prime.mag;</span>
<span class="fc" id="L645">    }</span>

    // Minimum size in bits that the requested prime number has
    // before we use the large prime number generating algorithms.
    // The cutoff of 95 was chosen empirically for best performance.
    private static final int SMALL_PRIME_THRESHOLD = 95;

    // Certainty required to meet the spec of probablePrime
    private static final int DEFAULT_PRIME_CERTAINTY = 100;

    /**
     * Returns a positive BigInteger that is probably prime, with the
     * specified bitLength. The probability that a BigInteger returned
     * by this method is composite does not exceed 2&lt;sup&gt;-100&lt;/sup&gt;.
     *
     * @param  bitLength bitLength of the returned BigInteger.
     * @param  rnd source of random bits used to select candidates to be
     *         tested for primality.
     * @return a BigInteger of {@code bitLength} bits that is probably prime
     * @throws ArithmeticException {@code bitLength &lt; 2} or {@code bitLength} is too large.
     * @see    #bitLength()
     * @since 1.4
     */
    public static BigInteger probablePrime(int bitLength, Random rnd) {
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">        if (bitLength &lt; 2)</span>
<span class="nc" id="L670">            throw new ArithmeticException(&quot;bitLength &lt; 2&quot;);</span>

<span class="fc bfc" id="L672" title="All 2 branches covered.">        return (bitLength &lt; SMALL_PRIME_THRESHOLD ?</span>
<span class="fc" id="L673">                smallPrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd) :</span>
<span class="fc" id="L674">                largePrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd));</span>
    }

    /**
     * Find a random number of the specified bitLength that is probably prime.
     * This method is used for smaller primes, its performance degrades on
     * larger bitlengths.
     *
     * This method assumes bitLength &gt; 1.
     */
    private static BigInteger smallPrime(int bitLength, int certainty, Random rnd) {
<span class="fc" id="L685">        int magLen = (bitLength + 31) &gt;&gt;&gt; 5;</span>
<span class="fc" id="L686">        int temp[] = new int[magLen];</span>
<span class="fc" id="L687">        int highBit = 1 &lt;&lt; ((bitLength+31) &amp; 0x1f);  // High bit of high int</span>
<span class="fc" id="L688">        int highMask = (highBit &lt;&lt; 1) - 1;  // Bits to keep in high int</span>

        while (true) {
            // Construct a candidate
<span class="fc bfc" id="L692" title="All 2 branches covered.">            for (int i=0; i &lt; magLen; i++)</span>
<span class="fc" id="L693">                temp[i] = rnd.nextInt();</span>
<span class="fc" id="L694">            temp[0] = (temp[0] &amp; highMask) | highBit;  // Ensure exact length</span>
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">            if (bitLength &gt; 2)</span>
<span class="fc" id="L696">                temp[magLen-1] |= 1;  // Make odd if bitlen &gt; 2</span>

<span class="fc" id="L698">            BigInteger p = new BigInteger(temp, 1);</span>

            // Do cheap &quot;pre-test&quot; if applicable
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">            if (bitLength &gt; 6) {</span>
<span class="fc" id="L702">                long r = p.remainder(SMALL_PRIME_PRODUCT).longValue();</span>
<span class="pc bpc" id="L703" title="1 of 24 branches missed.">                if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||</span>
                    (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||
                    (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0))
<span class="fc" id="L706">                    continue; // Candidate is composite; try another</span>
            }

            // All candidates of bitLength 2 and 3 are prime by this point
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">            if (bitLength &lt; 4)</span>
<span class="nc" id="L711">                return p;</span>

            // Do expensive test if we survive pre-test (or it's inapplicable)
<span class="fc bfc" id="L714" title="All 2 branches covered.">            if (p.primeToCertainty(certainty, rnd))</span>
<span class="fc" id="L715">                return p;</span>
<span class="fc" id="L716">        }</span>
    }

<span class="fc" id="L719">    private static final BigInteger SMALL_PRIME_PRODUCT</span>
<span class="fc" id="L720">                       = valueOf(3L*5*7*11*13*17*19*23*29*31*37*41);</span>

    /**
     * Find a random number of the specified bitLength that is probably prime.
     * This method is more appropriate for larger bitlengths since it uses
     * a sieve to eliminate most composites before using a more expensive
     * test.
     */
    private static BigInteger largePrime(int bitLength, int certainty, Random rnd) {
        BigInteger p;
<span class="fc" id="L730">        p = new BigInteger(bitLength, rnd).setBit(bitLength-1);</span>
<span class="fc" id="L731">        p.mag[p.mag.length-1] &amp;= 0xfffffffe;</span>

        // Use a sieve length likely to contain the next prime number
<span class="fc" id="L734">        int searchLen = getPrimeSearchLen(bitLength);</span>
<span class="fc" id="L735">        BitSieve searchSieve = new BitSieve(p, searchLen);</span>
<span class="fc" id="L736">        BigInteger candidate = searchSieve.retrieve(p, certainty, rnd);</span>

<span class="pc bpc" id="L738" title="2 of 4 branches missed.">        while ((candidate == null) || (candidate.bitLength() != bitLength)) {</span>
<span class="nc" id="L739">            p = p.add(BigInteger.valueOf(2*searchLen));</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">            if (p.bitLength() != bitLength)</span>
<span class="nc" id="L741">                p = new BigInteger(bitLength, rnd).setBit(bitLength-1);</span>
<span class="nc" id="L742">            p.mag[p.mag.length-1] &amp;= 0xfffffffe;</span>
<span class="nc" id="L743">            searchSieve = new BitSieve(p, searchLen);</span>
<span class="nc" id="L744">            candidate = searchSieve.retrieve(p, certainty, rnd);</span>
        }
<span class="fc" id="L746">        return candidate;</span>
    }

   /**
    * Returns the first integer greater than this {@code BigInteger} that
    * is probably prime.  The probability that the number returned by this
    * method is composite does not exceed 2&lt;sup&gt;-100&lt;/sup&gt;. This method will
    * never skip over a prime when searching: if it returns {@code p}, there
    * is no prime {@code q} such that {@code this &lt; q &lt; p}.
    *
    * @return the first integer greater than this {@code BigInteger} that
    *         is probably prime.
    * @throws ArithmeticException {@code this &lt; 0} or {@code this} is too large.
    * @since 1.5
    */
    public BigInteger nextProbablePrime() {
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">        if (this.signum &lt; 0)</span>
<span class="nc" id="L763">            throw new ArithmeticException(&quot;start &lt; 0: &quot; + this);</span>

        // Handle trivial cases
<span class="pc bpc" id="L766" title="1 of 4 branches missed.">        if ((this.signum == 0) || this.equals(ONE))</span>
<span class="fc" id="L767">            return TWO;</span>

<span class="fc" id="L769">        BigInteger result = this.add(ONE);</span>

        // Fastpath for small numbers
<span class="fc bfc" id="L772" title="All 2 branches covered.">        if (result.bitLength() &lt; SMALL_PRIME_THRESHOLD) {</span>

            // Ensure an odd number
<span class="fc bfc" id="L775" title="All 2 branches covered.">            if (!result.testBit(0))</span>
<span class="fc" id="L776">                result = result.add(ONE);</span>

            while (true) {
                // Do cheap &quot;pre-test&quot; if applicable
<span class="fc bfc" id="L780" title="All 2 branches covered.">                if (result.bitLength() &gt; 6) {</span>
<span class="fc" id="L781">                    long r = result.remainder(SMALL_PRIME_PRODUCT).longValue();</span>
<span class="fc bfc" id="L782" title="All 24 branches covered.">                    if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||</span>
                        (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||
                        (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0)) {
<span class="fc" id="L785">                        result = result.add(TWO);</span>
<span class="fc" id="L786">                        continue; // Candidate is composite; try another</span>
                    }
                }

                // All candidates of bitLength 2 and 3 are prime by this point
<span class="fc bfc" id="L791" title="All 2 branches covered.">                if (result.bitLength() &lt; 4)</span>
<span class="fc" id="L792">                    return result;</span>

                // The expensive test
<span class="fc bfc" id="L795" title="All 2 branches covered.">                if (result.primeToCertainty(DEFAULT_PRIME_CERTAINTY, null))</span>
<span class="fc" id="L796">                    return result;</span>

<span class="fc" id="L798">                result = result.add(TWO);</span>
            }
        }

        // Start at previous even number
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">        if (result.testBit(0))</span>
<span class="nc" id="L804">            result = result.subtract(ONE);</span>

        // Looking for the next large prime
<span class="fc" id="L807">        int searchLen = getPrimeSearchLen(result.bitLength());</span>

        while (true) {
<span class="fc" id="L810">           BitSieve searchSieve = new BitSieve(result, searchLen);</span>
<span class="fc" id="L811">           BigInteger candidate = searchSieve.retrieve(result,</span>
                                                 DEFAULT_PRIME_CERTAINTY, null);
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">           if (candidate != null)</span>
<span class="fc" id="L814">               return candidate;</span>
<span class="nc" id="L815">           result = result.add(BigInteger.valueOf(2 * searchLen));</span>
<span class="nc" id="L816">        }</span>
    }

    private static int getPrimeSearchLen(int bitLength) {
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">        if (bitLength &gt; PRIME_SEARCH_BIT_LENGTH_LIMIT + 1) {</span>
<span class="nc" id="L821">            throw new ArithmeticException(&quot;Prime search implementation restriction on bitLength&quot;);</span>
        }
<span class="fc" id="L823">        return bitLength / 20 * 64;</span>
    }

    /**
     * Returns {@code true} if this BigInteger is probably prime,
     * {@code false} if it's definitely composite.
     *
     * This method assumes bitLength &gt; 2.
     *
     * @param  certainty a measure of the uncertainty that the caller is
     *         willing to tolerate: if the call returns {@code true}
     *         the probability that this BigInteger is prime exceeds
     *         {@code (1 - 1/2&lt;sup&gt;certainty&lt;/sup&gt;)}.  The execution time of
     *         this method is proportional to the value of this parameter.
     * @return {@code true} if this BigInteger is probably prime,
     *         {@code false} if it's definitely composite.
     */
    boolean primeToCertainty(int certainty, Random random) {
<span class="fc" id="L841">        int rounds = 0;</span>
<span class="fc" id="L842">        int n = (Math.min(certainty, Integer.MAX_VALUE-1)+1)/2;</span>

        // The relationship between the certainty and the number of rounds
        // we perform is given in the draft standard ANSI X9.80, &quot;PRIME
        // NUMBER GENERATION, PRIMALITY TESTING, AND PRIMALITY CERTIFICATES&quot;.
<span class="fc" id="L847">        int sizeInBits = this.bitLength();</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">        if (sizeInBits &lt; 100) {</span>
<span class="fc" id="L849">            rounds = 50;</span>
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">            rounds = n &lt; rounds ? n : rounds;</span>
<span class="fc" id="L851">            return passesMillerRabin(rounds, random);</span>
        }

<span class="fc bfc" id="L854" title="All 2 branches covered.">        if (sizeInBits &lt; 256) {</span>
<span class="fc" id="L855">            rounds = 27;</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">        } else if (sizeInBits &lt; 512) {</span>
<span class="fc" id="L857">            rounds = 15;</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">        } else if (sizeInBits &lt; 768) {</span>
<span class="fc" id="L859">            rounds = 8;</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">        } else if (sizeInBits &lt; 1024) {</span>
<span class="fc" id="L861">            rounds = 4;</span>
        } else {
<span class="fc" id="L863">            rounds = 2;</span>
        }
<span class="fc bfc" id="L865" title="All 2 branches covered.">        rounds = n &lt; rounds ? n : rounds;</span>

<span class="pc bpc" id="L867" title="1 of 4 branches missed.">        return passesMillerRabin(rounds, random) &amp;&amp; passesLucasLehmer();</span>
    }

    /**
     * Returns true iff this BigInteger is a Lucas-Lehmer probable prime.
     *
     * The following assumptions are made:
     * This BigInteger is a positive, odd number.
     */
    private boolean passesLucasLehmer() {
<span class="fc" id="L877">        BigInteger thisPlusOne = this.add(ONE);</span>

        // Step 1
<span class="fc" id="L880">        int d = 5;</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">        while (jacobiSymbol(d, this) != -1) {</span>
            // 5, -7, 9, -11, ...
<span class="fc bfc" id="L883" title="All 2 branches covered.">            d = (d &lt; 0) ? Math.abs(d)+2 : -(d+2);</span>
        }

        // Step 2
<span class="fc" id="L887">        BigInteger u = lucasLehmerSequence(d, thisPlusOne, this);</span>

        // Step 3
<span class="fc" id="L890">        return u.mod(this).equals(ZERO);</span>
    }

    /**
     * Computes Jacobi(p,n).
     * Assumes n positive, odd, n&gt;=3.
     */
    private static int jacobiSymbol(int p, BigInteger n) {
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">        if (p == 0)</span>
<span class="nc" id="L899">            return 0;</span>

        // Algorithm and comments adapted from Colin Plumb's C library.
<span class="fc" id="L902">        int j = 1;</span>
<span class="fc" id="L903">        int u = n.mag[n.mag.length-1];</span>

        // Make p positive
<span class="fc bfc" id="L906" title="All 2 branches covered.">        if (p &lt; 0) {</span>
<span class="fc" id="L907">            p = -p;</span>
<span class="fc" id="L908">            int n8 = u &amp; 7;</span>
<span class="fc bfc" id="L909" title="All 4 branches covered.">            if ((n8 == 3) || (n8 == 7))</span>
<span class="fc" id="L910">                j = -j; // 3 (011) or 7 (111) mod 8</span>
        }

        // Get rid of factors of 2 in p
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">        while ((p &amp; 3) == 0)</span>
<span class="nc" id="L915">            p &gt;&gt;= 2;</span>
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">        if ((p &amp; 1) == 0) {</span>
<span class="nc" id="L917">            p &gt;&gt;= 1;</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">            if (((u ^ (u&gt;&gt;1)) &amp; 2) != 0)</span>
<span class="nc" id="L919">                j = -j; // 3 (011) or 5 (101) mod 8</span>
        }
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">        if (p == 1)</span>
<span class="nc" id="L922">            return j;</span>
        // Then, apply quadratic reciprocity
<span class="fc bfc" id="L924" title="All 2 branches covered.">        if ((p &amp; u &amp; 2) != 0)   // p = u = 3 (mod 4)?</span>
<span class="fc" id="L925">            j = -j;</span>
        // And reduce u mod p
<span class="fc" id="L927">        u = n.mod(BigInteger.valueOf(p)).intValue();</span>

        // Now compute Jacobi(u,p), u &lt; p
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">        while (u != 0) {</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">            while ((u &amp; 3) == 0)</span>
<span class="fc" id="L932">                u &gt;&gt;= 2;</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">            if ((u &amp; 1) == 0) {</span>
<span class="fc" id="L934">                u &gt;&gt;= 1;</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">                if (((p ^ (p&gt;&gt;1)) &amp; 2) != 0)</span>
<span class="fc" id="L936">                    j = -j;     // 3 (011) or 5 (101) mod 8</span>
            }
<span class="fc bfc" id="L938" title="All 2 branches covered.">            if (u == 1)</span>
<span class="fc" id="L939">                return j;</span>
            // Now both u and p are odd, so use quadratic reciprocity
<span class="pc bpc" id="L941" title="2 of 4 branches missed.">            assert (u &lt; p);</span>
<span class="fc" id="L942">            int t = u; u = p; p = t;</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">            if ((u &amp; p &amp; 2) != 0) // u = p = 3 (mod 4)?</span>
<span class="fc" id="L944">                j = -j;</span>
            // Now u &gt;= p, so it can be reduced
<span class="fc" id="L946">            u %= p;</span>
<span class="fc" id="L947">        }</span>
<span class="nc" id="L948">        return 0;</span>
    }

    private static BigInteger lucasLehmerSequence(int z, BigInteger k, BigInteger n) {
<span class="fc" id="L952">        BigInteger d = BigInteger.valueOf(z);</span>
<span class="fc" id="L953">        BigInteger u = ONE; BigInteger u2;</span>
<span class="fc" id="L954">        BigInteger v = ONE; BigInteger v2;</span>

<span class="fc bfc" id="L956" title="All 2 branches covered.">        for (int i=k.bitLength()-2; i &gt;= 0; i--) {</span>
<span class="fc" id="L957">            u2 = u.multiply(v).mod(n);</span>

<span class="fc" id="L959">            v2 = v.square().add(d.multiply(u.square())).mod(n);</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">            if (v2.testBit(0))</span>
<span class="fc" id="L961">                v2 = v2.subtract(n);</span>

<span class="fc" id="L963">            v2 = v2.shiftRight(1);</span>

<span class="fc" id="L965">            u = u2; v = v2;</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">            if (k.testBit(i)) {</span>
<span class="fc" id="L967">                u2 = u.add(v).mod(n);</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">                if (u2.testBit(0))</span>
<span class="fc" id="L969">                    u2 = u2.subtract(n);</span>

<span class="fc" id="L971">                u2 = u2.shiftRight(1);</span>
<span class="fc" id="L972">                v2 = v.add(d.multiply(u)).mod(n);</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">                if (v2.testBit(0))</span>
<span class="fc" id="L974">                    v2 = v2.subtract(n);</span>
<span class="fc" id="L975">                v2 = v2.shiftRight(1);</span>

<span class="fc" id="L977">                u = u2; v = v2;</span>
            }
        }
<span class="fc" id="L980">        return u;</span>
    }

    /**
     * Returns true iff this BigInteger passes the specified number of
     * Miller-Rabin tests. This test is taken from the DSA spec (NIST FIPS
     * 186-2).
     *
     * The following assumptions are made:
     * This BigInteger is a positive, odd number greater than 2.
     * iterations&lt;=50.
     */
    private boolean passesMillerRabin(int iterations, Random rnd) {
        // Find a and m such that m is odd and this == 1 + 2**a * m
<span class="fc" id="L994">        BigInteger thisMinusOne = this.subtract(ONE);</span>
<span class="fc" id="L995">        BigInteger m = thisMinusOne;</span>
<span class="fc" id="L996">        int a = m.getLowestSetBit();</span>
<span class="fc" id="L997">        m = m.shiftRight(a);</span>

        // Do the tests
<span class="fc bfc" id="L1000" title="All 2 branches covered.">        if (rnd == null) {</span>
<span class="fc" id="L1001">            rnd = ThreadLocalRandom.current();</span>
        }
<span class="fc bfc" id="L1003" title="All 2 branches covered.">        for (int i=0; i &lt; iterations; i++) {</span>
            // Generate a uniform random on (1, this)
            BigInteger b;
            do {
<span class="fc" id="L1007">                b = new BigInteger(this.bitLength(), rnd);</span>
<span class="fc bfc" id="L1008" title="All 4 branches covered.">            } while (b.compareTo(ONE) &lt;= 0 || b.compareTo(this) &gt;= 0);</span>

<span class="fc" id="L1010">            int j = 0;</span>
<span class="fc" id="L1011">            BigInteger z = b.modPow(m, this);</span>
<span class="fc bfc" id="L1012" title="All 6 branches covered.">            while (!((j == 0 &amp;&amp; z.equals(ONE)) || z.equals(thisMinusOne))) {</span>
<span class="fc bfc" id="L1013" title="All 6 branches covered.">                if (j &gt; 0 &amp;&amp; z.equals(ONE) || ++j == a)</span>
<span class="fc" id="L1014">                    return false;</span>
<span class="fc" id="L1015">                z = z.modPow(TWO, this);</span>
            }
        }
<span class="fc" id="L1018">        return true;</span>
    }

    /**
     * This internal constructor differs from its public cousin
     * with the arguments reversed in two ways: it assumes that its
     * arguments are correct, and it doesn't copy the magnitude array.
     */
<span class="fc" id="L1026">    BigInteger(int[] magnitude, int signum) {</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">        this.signum = (magnitude.length == 0 ? 0 : signum);</span>
<span class="fc" id="L1028">        this.mag = magnitude;</span>
<span class="pc bpc" id="L1029" title="1 of 2 branches missed.">        if (mag.length &gt;= MAX_MAG_LENGTH) {</span>
<span class="nc" id="L1030">            checkRange();</span>
        }
<span class="fc" id="L1032">    }</span>

    /**
     * This private constructor is for internal use and assumes that its
     * arguments are correct.
     */
<span class="nc" id="L1038">    private BigInteger(byte[] magnitude, int signum) {</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">        this.signum = (magnitude.length == 0 ? 0 : signum);</span>
<span class="nc" id="L1040">        this.mag = stripLeadingZeroBytes(magnitude);</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">        if (mag.length &gt;= MAX_MAG_LENGTH) {</span>
<span class="nc" id="L1042">            checkRange();</span>
        }
<span class="nc" id="L1044">    }</span>

    /**
     * Throws an {@code ArithmeticException} if the {@code BigInteger} would be
     * out of the supported range.
     *
     * @throws ArithmeticException if {@code this} exceeds the supported range.
     */
    private void checkRange() {
<span class="pc bpc" id="L1053" title="5 of 6 branches missed.">        if (mag.length &gt; MAX_MAG_LENGTH || mag.length == MAX_MAG_LENGTH &amp;&amp; mag[0] &lt; 0) {</span>
<span class="nc" id="L1054">            reportOverflow();</span>
        }
<span class="nc" id="L1056">    }</span>

    private static void reportOverflow() {
<span class="fc" id="L1059">        throw new ArithmeticException(&quot;BigInteger would overflow supported range&quot;);</span>
    }

    //Static Factory Methods

    /**
     * Returns a BigInteger whose value is equal to that of the
     * specified {@code long}.  This &quot;static factory method&quot; is
     * provided in preference to a ({@code long}) constructor
     * because it allows for reuse of frequently used BigIntegers.
     *
     * @param  val value of the BigInteger to return.
     * @return a BigInteger with the specified value.
     */
    public static BigInteger valueOf(long val) {
        // If -MAX_CONSTANT &lt; val &lt; MAX_CONSTANT, return stashed constant
<span class="fc bfc" id="L1075" title="All 2 branches covered.">        if (val == 0)</span>
<span class="fc" id="L1076">            return ZERO;</span>
<span class="fc bfc" id="L1077" title="All 4 branches covered.">        if (val &gt; 0 &amp;&amp; val &lt;= MAX_CONSTANT)</span>
<span class="fc" id="L1078">            return posConst[(int) val];</span>
<span class="fc bfc" id="L1079" title="All 4 branches covered.">        else if (val &lt; 0 &amp;&amp; val &gt;= -MAX_CONSTANT)</span>
<span class="fc" id="L1080">            return negConst[(int) -val];</span>

<span class="fc" id="L1082">        return new BigInteger(val);</span>
    }

    /**
     * Constructs a BigInteger with the specified value, which may not be zero.
     */
<span class="fc" id="L1088">    private BigInteger(long val) {</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">        if (val &lt; 0) {</span>
<span class="fc" id="L1090">            val = -val;</span>
<span class="fc" id="L1091">            signum = -1;</span>
        } else {
<span class="fc" id="L1093">            signum = 1;</span>
        }

<span class="fc" id="L1096">        int highWord = (int)(val &gt;&gt;&gt; 32);</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">        if (highWord == 0) {</span>
<span class="fc" id="L1098">            mag = new int[1];</span>
<span class="fc" id="L1099">            mag[0] = (int)val;</span>
        } else {
<span class="fc" id="L1101">            mag = new int[2];</span>
<span class="fc" id="L1102">            mag[0] = highWord;</span>
<span class="fc" id="L1103">            mag[1] = (int)val;</span>
        }
<span class="fc" id="L1105">    }</span>

    /**
     * Returns a BigInteger with the given two's complement representation.
     * Assumes that the input array will not be modified (the returned
     * BigInteger will reference the input array if feasible).
     */
    private static BigInteger valueOf(int val[]) {
<span class="fc bfc" id="L1113" title="All 2 branches covered.">        return (val[0] &gt; 0 ? new BigInteger(val, 1) : new BigInteger(val));</span>
    }

    // Constants

    /**
     * Initialize static constant array when class is loaded.
     */
    private final static int MAX_CONSTANT = 16;
<span class="fc" id="L1122">    private static BigInteger posConst[] = new BigInteger[MAX_CONSTANT+1];</span>
<span class="fc" id="L1123">    private static BigInteger negConst[] = new BigInteger[MAX_CONSTANT+1];</span>

    /**
     * The cache of powers of each radix.  This allows us to not have to
     * recalculate powers of radix^(2^n) more than once.  This speeds
     * Schoenhage recursive base conversion significantly.
     */
    private static volatile BigInteger[][] powerCache;

    /** The cache of logarithms of radices for base conversion. */
    private static final double[] logCache;

    /** The natural log of 2.  This is used in computing cache indices. */
<span class="fc" id="L1136">    private static final double LOG_TWO = Math.log(2.0);</span>

    static {
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        for (int i = 1; i &lt;= MAX_CONSTANT; i++) {</span>
<span class="fc" id="L1140">            int[] magnitude = new int[1];</span>
<span class="fc" id="L1141">            magnitude[0] = i;</span>
<span class="fc" id="L1142">            posConst[i] = new BigInteger(magnitude,  1);</span>
<span class="fc" id="L1143">            negConst[i] = new BigInteger(magnitude, -1);</span>
        }

        /*
         * Initialize the cache of radix^(2^x) values used for base conversion
         * with just the very first value.  Additional values will be created
         * on demand.
         */
<span class="fc" id="L1151">        powerCache = new BigInteger[Character.MAX_RADIX+1][];</span>
<span class="fc" id="L1152">        logCache = new double[Character.MAX_RADIX+1];</span>

<span class="fc bfc" id="L1154" title="All 2 branches covered.">        for (int i=Character.MIN_RADIX; i &lt;= Character.MAX_RADIX; i++) {</span>
<span class="fc" id="L1155">            powerCache[i] = new BigInteger[] { BigInteger.valueOf(i) };</span>
<span class="fc" id="L1156">            logCache[i] = Math.log(i);</span>
        }
    }

    /**
     * The BigInteger constant zero.
     *
     * @since   1.2
     */
<span class="fc" id="L1165">    public static final BigInteger ZERO = new BigInteger(new int[0], 0);</span>

    /**
     * The BigInteger constant one.
     *
     * @since   1.2
     */
<span class="fc" id="L1172">    public static final BigInteger ONE = valueOf(1);</span>

    /**
     * The BigInteger constant two.  (Not exported.)
     */
<span class="fc" id="L1177">    private static final BigInteger TWO = valueOf(2);</span>

    /**
     * The BigInteger constant -1.  (Not exported.)
     */
<span class="fc" id="L1182">    private static final BigInteger NEGATIVE_ONE = valueOf(-1);</span>

    /**
     * The BigInteger constant ten.
     *
     * @since   1.5
     */
<span class="fc" id="L1189">    public static final BigInteger TEN = valueOf(10);</span>

    // Arithmetic Operations

    /**
     * Returns a BigInteger whose value is {@code (this + val)}.
     *
     * @param  val value to be added to this BigInteger.
     * @return {@code this + val}
     */
    public BigInteger add(BigInteger val) {
<span class="fc bfc" id="L1200" title="All 2 branches covered.">        if (val.signum == 0)</span>
<span class="fc" id="L1201">            return this;</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">        if (signum == 0)</span>
<span class="fc" id="L1203">            return val;</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">        if (val.signum == signum)</span>
<span class="fc" id="L1205">            return new BigInteger(add(mag, val.mag), signum);</span>

<span class="fc" id="L1207">        int cmp = compareMagnitude(val);</span>
<span class="fc bfc" id="L1208" title="All 2 branches covered.">        if (cmp == 0)</span>
<span class="fc" id="L1209">            return ZERO;</span>
<span class="fc bfc" id="L1210" title="All 2 branches covered.">        int[] resultMag = (cmp &gt; 0 ? subtract(mag, val.mag)</span>
<span class="fc" id="L1211">                           : subtract(val.mag, mag));</span>
<span class="fc" id="L1212">        resultMag = trustedStripLeadingZeroInts(resultMag);</span>

<span class="fc bfc" id="L1214" title="All 2 branches covered.">        return new BigInteger(resultMag, cmp == signum ? 1 : -1);</span>
    }

    /**
     * Package private methods used by BigDecimal code to add a BigInteger
     * with a long. Assumes val is not equal to INFLATED.
     */
    BigInteger add(long val) {
<span class="fc bfc" id="L1222" title="All 2 branches covered.">        if (val == 0)</span>
<span class="fc" id="L1223">            return this;</span>
<span class="pc bpc" id="L1224" title="1 of 2 branches missed.">        if (signum == 0)</span>
<span class="nc" id="L1225">            return valueOf(val);</span>
<span class="fc bfc" id="L1226" title="All 2 branches covered.">        if (Long.signum(val) == signum)</span>
<span class="fc" id="L1227">            return new BigInteger(add(mag, Math.abs(val)), signum);</span>
<span class="fc" id="L1228">        int cmp = compareMagnitude(val);</span>
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">        if (cmp == 0)</span>
<span class="nc" id="L1230">            return ZERO;</span>
<span class="pc bpc" id="L1231" title="1 of 2 branches missed.">        int[] resultMag = (cmp &gt; 0 ? subtract(mag, Math.abs(val)) : subtract(Math.abs(val), mag));</span>
<span class="fc" id="L1232">        resultMag = trustedStripLeadingZeroInts(resultMag);</span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">        return new BigInteger(resultMag, cmp == signum ? 1 : -1);</span>
    }

    /**
     * Adds the contents of the int array x and long value val. This
     * method allocates a new int array to hold the answer and returns
     * a reference to that array.  Assumes x.length &amp;gt; 0 and val is
     * non-negative
     */
    private static int[] add(int[] x, long val) {
        int[] y;
<span class="fc" id="L1244">        long sum = 0;</span>
<span class="fc" id="L1245">        int xIndex = x.length;</span>
        int[] result;
<span class="fc" id="L1247">        int highWord = (int)(val &gt;&gt;&gt; 32);</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">        if (highWord == 0) {</span>
<span class="fc" id="L1249">            result = new int[xIndex];</span>
<span class="fc" id="L1250">            sum = (x[--xIndex] &amp; LONG_MASK) + val;</span>
<span class="fc" id="L1251">            result[xIndex] = (int)sum;</span>
        } else {
<span class="pc bpc" id="L1253" title="1 of 2 branches missed.">            if (xIndex == 1) {</span>
<span class="nc" id="L1254">                result = new int[2];</span>
<span class="nc" id="L1255">                sum = val  + (x[0] &amp; LONG_MASK);</span>
<span class="nc" id="L1256">                result[1] = (int)sum;</span>
<span class="nc" id="L1257">                result[0] = (int)(sum &gt;&gt;&gt; 32);</span>
<span class="nc" id="L1258">                return result;</span>
            } else {
<span class="fc" id="L1260">                result = new int[xIndex];</span>
<span class="fc" id="L1261">                sum = (x[--xIndex] &amp; LONG_MASK) + (val &amp; LONG_MASK);</span>
<span class="fc" id="L1262">                result[xIndex] = (int)sum;</span>
<span class="fc" id="L1263">                sum = (x[--xIndex] &amp; LONG_MASK) + (highWord &amp; LONG_MASK) + (sum &gt;&gt;&gt; 32);</span>
<span class="fc" id="L1264">                result[xIndex] = (int)sum;</span>
            }
        }
        // Copy remainder of longer number while carry propagation is required
<span class="fc bfc" id="L1268" title="All 2 branches covered.">        boolean carry = (sum &gt;&gt;&gt; 32 != 0);</span>
<span class="fc bfc" id="L1269" title="All 4 branches covered.">        while (xIndex &gt; 0 &amp;&amp; carry)</span>
<span class="fc bfc" id="L1270" title="All 2 branches covered.">            carry = ((result[--xIndex] = x[xIndex] + 1) == 0);</span>
        // Copy remainder of longer number
<span class="fc bfc" id="L1272" title="All 2 branches covered.">        while (xIndex &gt; 0)</span>
<span class="fc" id="L1273">            result[--xIndex] = x[xIndex];</span>
        // Grow result if necessary
<span class="fc bfc" id="L1275" title="All 2 branches covered.">        if (carry) {</span>
<span class="fc" id="L1276">            int bigger[] = new int[result.length + 1];</span>
<span class="fc" id="L1277">            System.arraycopy(result, 0, bigger, 1, result.length);</span>
<span class="fc" id="L1278">            bigger[0] = 0x01;</span>
<span class="fc" id="L1279">            return bigger;</span>
        }
<span class="fc" id="L1281">        return result;</span>
    }

    /**
     * Adds the contents of the int arrays x and y. This method allocates
     * a new int array to hold the answer and returns a reference to that
     * array.
     */
    private static int[] add(int[] x, int[] y) {
        // If x is shorter, swap the two arrays
<span class="fc bfc" id="L1291" title="All 2 branches covered.">        if (x.length &lt; y.length) {</span>
<span class="fc" id="L1292">            int[] tmp = x;</span>
<span class="fc" id="L1293">            x = y;</span>
<span class="fc" id="L1294">            y = tmp;</span>
        }

<span class="fc" id="L1297">        int xIndex = x.length;</span>
<span class="fc" id="L1298">        int yIndex = y.length;</span>
<span class="fc" id="L1299">        int result[] = new int[xIndex];</span>
<span class="fc" id="L1300">        long sum = 0;</span>
<span class="fc bfc" id="L1301" title="All 2 branches covered.">        if (yIndex == 1) {</span>
<span class="fc" id="L1302">            sum = (x[--xIndex] &amp; LONG_MASK) + (y[0] &amp; LONG_MASK) ;</span>
<span class="fc" id="L1303">            result[xIndex] = (int)sum;</span>
        } else {
            // Add common parts of both numbers
<span class="fc bfc" id="L1306" title="All 2 branches covered.">            while (yIndex &gt; 0) {</span>
<span class="fc" id="L1307">                sum = (x[--xIndex] &amp; LONG_MASK) +</span>
                      (y[--yIndex] &amp; LONG_MASK) + (sum &gt;&gt;&gt; 32);
<span class="fc" id="L1309">                result[xIndex] = (int)sum;</span>
            }
        }
        // Copy remainder of longer number while carry propagation is required
<span class="fc bfc" id="L1313" title="All 2 branches covered.">        boolean carry = (sum &gt;&gt;&gt; 32 != 0);</span>
<span class="fc bfc" id="L1314" title="All 4 branches covered.">        while (xIndex &gt; 0 &amp;&amp; carry)</span>
<span class="fc bfc" id="L1315" title="All 2 branches covered.">            carry = ((result[--xIndex] = x[xIndex] + 1) == 0);</span>

        // Copy remainder of longer number
<span class="fc bfc" id="L1318" title="All 2 branches covered.">        while (xIndex &gt; 0)</span>
<span class="fc" id="L1319">            result[--xIndex] = x[xIndex];</span>

        // Grow result if necessary
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        if (carry) {</span>
<span class="fc" id="L1323">            int bigger[] = new int[result.length + 1];</span>
<span class="fc" id="L1324">            System.arraycopy(result, 0, bigger, 1, result.length);</span>
<span class="fc" id="L1325">            bigger[0] = 0x01;</span>
<span class="fc" id="L1326">            return bigger;</span>
        }
<span class="fc" id="L1328">        return result;</span>
    }

    private static int[] subtract(long val, int[] little) {
<span class="nc" id="L1332">        int highWord = (int)(val &gt;&gt;&gt; 32);</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">        if (highWord == 0) {</span>
<span class="nc" id="L1334">            int result[] = new int[1];</span>
<span class="nc" id="L1335">            result[0] = (int)(val - (little[0] &amp; LONG_MASK));</span>
<span class="nc" id="L1336">            return result;</span>
        } else {
<span class="nc" id="L1338">            int result[] = new int[2];</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">            if (little.length == 1) {</span>
<span class="nc" id="L1340">                long difference = ((int)val &amp; LONG_MASK) - (little[0] &amp; LONG_MASK);</span>
<span class="nc" id="L1341">                result[1] = (int)difference;</span>
                // Subtract remainder of longer number while borrow propagates
<span class="nc bnc" id="L1343" title="All 2 branches missed.">                boolean borrow = (difference &gt;&gt; 32 != 0);</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">                if (borrow) {</span>
<span class="nc" id="L1345">                    result[0] = highWord - 1;</span>
                } else {        // Copy remainder of longer number
<span class="nc" id="L1347">                    result[0] = highWord;</span>
                }
<span class="nc" id="L1349">                return result;</span>
            } else { // little.length == 2
<span class="nc" id="L1351">                long difference = ((int)val &amp; LONG_MASK) - (little[1] &amp; LONG_MASK);</span>
<span class="nc" id="L1352">                result[1] = (int)difference;</span>
<span class="nc" id="L1353">                difference = (highWord &amp; LONG_MASK) - (little[0] &amp; LONG_MASK) + (difference &gt;&gt; 32);</span>
<span class="nc" id="L1354">                result[0] = (int)difference;</span>
<span class="nc" id="L1355">                return result;</span>
            }
        }
    }

    /**
     * Subtracts the contents of the second argument (val) from the
     * first (big).  The first int array (big) must represent a larger number
     * than the second.  This method allocates the space necessary to hold the
     * answer.
     * assumes val &amp;gt;= 0
     */
    private static int[] subtract(int[] big, long val) {
<span class="fc" id="L1368">        int highWord = (int)(val &gt;&gt;&gt; 32);</span>
<span class="fc" id="L1369">        int bigIndex = big.length;</span>
<span class="fc" id="L1370">        int result[] = new int[bigIndex];</span>
<span class="fc" id="L1371">        long difference = 0;</span>

<span class="fc bfc" id="L1373" title="All 2 branches covered.">        if (highWord == 0) {</span>
<span class="fc" id="L1374">            difference = (big[--bigIndex] &amp; LONG_MASK) - val;</span>
<span class="fc" id="L1375">            result[bigIndex] = (int)difference;</span>
        } else {
<span class="fc" id="L1377">            difference = (big[--bigIndex] &amp; LONG_MASK) - (val &amp; LONG_MASK);</span>
<span class="fc" id="L1378">            result[bigIndex] = (int)difference;</span>
<span class="fc" id="L1379">            difference = (big[--bigIndex] &amp; LONG_MASK) - (highWord &amp; LONG_MASK) + (difference &gt;&gt; 32);</span>
<span class="fc" id="L1380">            result[bigIndex] = (int)difference;</span>
        }

        // Subtract remainder of longer number while borrow propagates
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        boolean borrow = (difference &gt;&gt; 32 != 0);</span>
<span class="fc bfc" id="L1385" title="All 4 branches covered.">        while (bigIndex &gt; 0 &amp;&amp; borrow)</span>
<span class="fc bfc" id="L1386" title="All 2 branches covered.">            borrow = ((result[--bigIndex] = big[bigIndex] - 1) == -1);</span>

        // Copy remainder of longer number
<span class="fc bfc" id="L1389" title="All 2 branches covered.">        while (bigIndex &gt; 0)</span>
<span class="fc" id="L1390">            result[--bigIndex] = big[bigIndex];</span>

<span class="fc" id="L1392">        return result;</span>
    }

    /**
     * Returns a BigInteger whose value is {@code (this - val)}.
     *
     * @param  val value to be subtracted from this BigInteger.
     * @return {@code this - val}
     */
    public BigInteger subtract(BigInteger val) {
<span class="fc bfc" id="L1402" title="All 2 branches covered.">        if (val.signum == 0)</span>
<span class="fc" id="L1403">            return this;</span>
<span class="fc bfc" id="L1404" title="All 2 branches covered.">        if (signum == 0)</span>
<span class="fc" id="L1405">            return val.negate();</span>
<span class="fc bfc" id="L1406" title="All 2 branches covered.">        if (val.signum != signum)</span>
<span class="fc" id="L1407">            return new BigInteger(add(mag, val.mag), signum);</span>

<span class="fc" id="L1409">        int cmp = compareMagnitude(val);</span>
<span class="fc bfc" id="L1410" title="All 2 branches covered.">        if (cmp == 0)</span>
<span class="fc" id="L1411">            return ZERO;</span>
<span class="fc bfc" id="L1412" title="All 2 branches covered.">        int[] resultMag = (cmp &gt; 0 ? subtract(mag, val.mag)</span>
<span class="fc" id="L1413">                           : subtract(val.mag, mag));</span>
<span class="fc" id="L1414">        resultMag = trustedStripLeadingZeroInts(resultMag);</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">        return new BigInteger(resultMag, cmp == signum ? 1 : -1);</span>
    }

    /**
     * Subtracts the contents of the second int arrays (little) from the
     * first (big).  The first int array (big) must represent a larger number
     * than the second.  This method allocates the space necessary to hold the
     * answer.
     */
    private static int[] subtract(int[] big, int[] little) {
<span class="fc" id="L1425">        int bigIndex = big.length;</span>
<span class="fc" id="L1426">        int result[] = new int[bigIndex];</span>
<span class="fc" id="L1427">        int littleIndex = little.length;</span>
<span class="fc" id="L1428">        long difference = 0;</span>

        // Subtract common parts of both numbers
<span class="fc bfc" id="L1431" title="All 2 branches covered.">        while (littleIndex &gt; 0) {</span>
<span class="fc" id="L1432">            difference = (big[--bigIndex] &amp; LONG_MASK) -</span>
                         (little[--littleIndex] &amp; LONG_MASK) +
                         (difference &gt;&gt; 32);
<span class="fc" id="L1435">            result[bigIndex] = (int)difference;</span>
        }

        // Subtract remainder of longer number while borrow propagates
<span class="fc bfc" id="L1439" title="All 2 branches covered.">        boolean borrow = (difference &gt;&gt; 32 != 0);</span>
<span class="fc bfc" id="L1440" title="All 4 branches covered.">        while (bigIndex &gt; 0 &amp;&amp; borrow)</span>
<span class="fc bfc" id="L1441" title="All 2 branches covered.">            borrow = ((result[--bigIndex] = big[bigIndex] - 1) == -1);</span>

        // Copy remainder of longer number
<span class="fc bfc" id="L1444" title="All 2 branches covered.">        while (bigIndex &gt; 0)</span>
<span class="fc" id="L1445">            result[--bigIndex] = big[bigIndex];</span>

<span class="fc" id="L1447">        return result;</span>
    }

    /**
     * Returns a BigInteger whose value is {@code (this * val)}.
     *
     * @param  val value to be multiplied by this BigInteger.
     * @return {@code this * val}
     */
    public BigInteger multiply(BigInteger val) {
<span class="fc bfc" id="L1457" title="All 4 branches covered.">        if (val.signum == 0 || signum == 0)</span>
<span class="fc" id="L1458">            return ZERO;</span>

<span class="fc" id="L1460">        int xlen = mag.length;</span>
<span class="fc" id="L1461">        int ylen = val.mag.length;</span>

<span class="fc bfc" id="L1463" title="All 4 branches covered.">        if ((xlen &lt; KARATSUBA_THRESHOLD) || (ylen &lt; KARATSUBA_THRESHOLD)) {</span>
<span class="fc bfc" id="L1464" title="All 2 branches covered.">            int resultSign = signum == val.signum ? 1 : -1;</span>
<span class="fc bfc" id="L1465" title="All 2 branches covered.">            if (val.mag.length == 1) {</span>
<span class="fc" id="L1466">                return multiplyByInt(mag,val.mag[0], resultSign);</span>
            }
<span class="fc bfc" id="L1468" title="All 2 branches covered.">            if (mag.length == 1) {</span>
<span class="fc" id="L1469">                return multiplyByInt(val.mag,mag[0], resultSign);</span>
            }
<span class="fc" id="L1471">            int[] result = multiplyToLen(mag, xlen,</span>
                                         val.mag, ylen, null);
<span class="fc" id="L1473">            result = trustedStripLeadingZeroInts(result);</span>
<span class="fc" id="L1474">            return new BigInteger(result, resultSign);</span>
        } else {
<span class="fc bfc" id="L1476" title="All 4 branches covered.">            if ((xlen &lt; TOOM_COOK_THRESHOLD) &amp;&amp; (ylen &lt; TOOM_COOK_THRESHOLD)) {</span>
<span class="fc" id="L1477">                return multiplyKaratsuba(this, val);</span>
            } else {
<span class="fc" id="L1479">                return multiplyToomCook3(this, val);</span>
            }
        }
    }

    private static BigInteger multiplyByInt(int[] x, int y, int sign) {
<span class="fc bfc" id="L1485" title="All 2 branches covered.">        if (Integer.bitCount(y) == 1) {</span>
<span class="fc" id="L1486">            return new BigInteger(shiftLeft(x,Integer.numberOfTrailingZeros(y)), sign);</span>
        }
<span class="fc" id="L1488">        int xlen = x.length;</span>
<span class="fc" id="L1489">        int[] rmag =  new int[xlen + 1];</span>
<span class="fc" id="L1490">        long carry = 0;</span>
<span class="fc" id="L1491">        long yl = y &amp; LONG_MASK;</span>
<span class="fc" id="L1492">        int rstart = rmag.length - 1;</span>
<span class="fc bfc" id="L1493" title="All 2 branches covered.">        for (int i = xlen - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1494">            long product = (x[i] &amp; LONG_MASK) * yl + carry;</span>
<span class="fc" id="L1495">            rmag[rstart--] = (int)product;</span>
<span class="fc" id="L1496">            carry = product &gt;&gt;&gt; 32;</span>
        }
<span class="fc bfc" id="L1498" title="All 2 branches covered.">        if (carry == 0L) {</span>
<span class="fc" id="L1499">            rmag = java.util.Arrays.copyOfRange(rmag, 1, rmag.length);</span>
        } else {
<span class="fc" id="L1501">            rmag[rstart] = (int)carry;</span>
        }
<span class="fc" id="L1503">        return new BigInteger(rmag, sign);</span>
    }

    /**
     * Package private methods used by BigDecimal code to multiply a BigInteger
     * with a long. Assumes v is not equal to INFLATED.
     */
    BigInteger multiply(long v) {
<span class="pc bpc" id="L1511" title="2 of 4 branches missed.">        if (v == 0 || signum == 0)</span>
<span class="nc" id="L1512">          return ZERO;</span>
<span class="pc bpc" id="L1513" title="1 of 2 branches missed.">        if (v == BigDecimal.INFLATED)</span>
<span class="nc" id="L1514">            return multiply(BigInteger.valueOf(v));</span>
<span class="fc bfc" id="L1515" title="All 2 branches covered.">        int rsign = (v &gt; 0 ? signum : -signum);</span>
<span class="fc bfc" id="L1516" title="All 2 branches covered.">        if (v &lt; 0)</span>
<span class="fc" id="L1517">            v = -v;</span>
<span class="fc" id="L1518">        long dh = v &gt;&gt;&gt; 32;      // higher order bits</span>
<span class="fc" id="L1519">        long dl = v &amp; LONG_MASK; // lower order bits</span>

<span class="fc" id="L1521">        int xlen = mag.length;</span>
<span class="fc" id="L1522">        int[] value = mag;</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">        int[] rmag = (dh == 0L) ? (new int[xlen + 1]) : (new int[xlen + 2]);</span>
<span class="fc" id="L1524">        long carry = 0;</span>
<span class="fc" id="L1525">        int rstart = rmag.length - 1;</span>
<span class="fc bfc" id="L1526" title="All 2 branches covered.">        for (int i = xlen - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1527">            long product = (value[i] &amp; LONG_MASK) * dl + carry;</span>
<span class="fc" id="L1528">            rmag[rstart--] = (int)product;</span>
<span class="fc" id="L1529">            carry = product &gt;&gt;&gt; 32;</span>
        }
<span class="fc" id="L1531">        rmag[rstart] = (int)carry;</span>
<span class="fc bfc" id="L1532" title="All 2 branches covered.">        if (dh != 0L) {</span>
<span class="fc" id="L1533">            carry = 0;</span>
<span class="fc" id="L1534">            rstart = rmag.length - 2;</span>
<span class="fc bfc" id="L1535" title="All 2 branches covered.">            for (int i = xlen - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1536">                long product = (value[i] &amp; LONG_MASK) * dh +</span>
                    (rmag[rstart] &amp; LONG_MASK) + carry;
<span class="fc" id="L1538">                rmag[rstart--] = (int)product;</span>
<span class="fc" id="L1539">                carry = product &gt;&gt;&gt; 32;</span>
            }
<span class="fc" id="L1541">            rmag[0] = (int)carry;</span>
        }
<span class="fc bfc" id="L1543" title="All 2 branches covered.">        if (carry == 0L)</span>
<span class="fc" id="L1544">            rmag = java.util.Arrays.copyOfRange(rmag, 1, rmag.length);</span>
<span class="fc" id="L1545">        return new BigInteger(rmag, rsign);</span>
    }

    /**
     * Multiplies int arrays x and y to the specified lengths and places
     * the result into z. There will be no leading zeros in the resultant array.
     */
    private int[] multiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) {
<span class="fc" id="L1553">        int xstart = xlen - 1;</span>
<span class="fc" id="L1554">        int ystart = ylen - 1;</span>

<span class="fc bfc" id="L1556" title="All 4 branches covered.">        if (z == null || z.length &lt; (xlen+ ylen))</span>
<span class="fc" id="L1557">            z = new int[xlen+ylen];</span>

<span class="fc" id="L1559">        long carry = 0;</span>
<span class="fc bfc" id="L1560" title="All 2 branches covered.">        for (int j=ystart, k=ystart+1+xstart; j &gt;= 0; j--, k--) {</span>
<span class="fc" id="L1561">            long product = (y[j] &amp; LONG_MASK) *</span>
                           (x[xstart] &amp; LONG_MASK) + carry;
<span class="fc" id="L1563">            z[k] = (int)product;</span>
<span class="fc" id="L1564">            carry = product &gt;&gt;&gt; 32;</span>
        }
<span class="fc" id="L1566">        z[xstart] = (int)carry;</span>

<span class="fc bfc" id="L1568" title="All 2 branches covered.">        for (int i = xstart-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1569">            carry = 0;</span>
<span class="fc bfc" id="L1570" title="All 2 branches covered.">            for (int j=ystart, k=ystart+1+i; j &gt;= 0; j--, k--) {</span>
<span class="fc" id="L1571">                long product = (y[j] &amp; LONG_MASK) *</span>
                               (x[i] &amp; LONG_MASK) +
                               (z[k] &amp; LONG_MASK) + carry;
<span class="fc" id="L1574">                z[k] = (int)product;</span>
<span class="fc" id="L1575">                carry = product &gt;&gt;&gt; 32;</span>
            }
<span class="fc" id="L1577">            z[i] = (int)carry;</span>
        }
<span class="fc" id="L1579">        return z;</span>
    }

    /**
     * Multiplies two BigIntegers using the Karatsuba multiplication
     * algorithm.  This is a recursive divide-and-conquer algorithm which is
     * more efficient for large numbers than what is commonly called the
     * &quot;grade-school&quot; algorithm used in multiplyToLen.  If the numbers to be
     * multiplied have length n, the &quot;grade-school&quot; algorithm has an
     * asymptotic complexity of O(n^2).  In contrast, the Karatsuba algorithm
     * has complexity of O(n^(log2(3))), or O(n^1.585).  It achieves this
     * increased performance by doing 3 multiplies instead of 4 when
     * evaluating the product.  As it has some overhead, should be used when
     * both numbers are larger than a certain threshold (found
     * experimentally).
     *
     * See:  http://en.wikipedia.org/wiki/Karatsuba_algorithm
     */
    private static BigInteger multiplyKaratsuba(BigInteger x, BigInteger y) {
<span class="fc" id="L1598">        int xlen = x.mag.length;</span>
<span class="fc" id="L1599">        int ylen = y.mag.length;</span>

        // The number of ints in each half of the number.
<span class="fc" id="L1602">        int half = (Math.max(xlen, ylen)+1) / 2;</span>

        // xl and yl are the lower halves of x and y respectively,
        // xh and yh are the upper halves.
<span class="fc" id="L1606">        BigInteger xl = x.getLower(half);</span>
<span class="fc" id="L1607">        BigInteger xh = x.getUpper(half);</span>
<span class="fc" id="L1608">        BigInteger yl = y.getLower(half);</span>
<span class="fc" id="L1609">        BigInteger yh = y.getUpper(half);</span>

<span class="fc" id="L1611">        BigInteger p1 = xh.multiply(yh);  // p1 = xh*yh</span>
<span class="fc" id="L1612">        BigInteger p2 = xl.multiply(yl);  // p2 = xl*yl</span>

        // p3=(xh+xl)*(yh+yl)
<span class="fc" id="L1615">        BigInteger p3 = xh.add(xl).multiply(yh.add(yl));</span>

        // result = p1 * 2^(32*2*half) + (p3 - p1 - p2) * 2^(32*half) + p2
<span class="fc" id="L1618">        BigInteger result = p1.shiftLeft(32*half).add(p3.subtract(p1).subtract(p2)).shiftLeft(32*half).add(p2);</span>

<span class="fc bfc" id="L1620" title="All 2 branches covered.">        if (x.signum != y.signum) {</span>
<span class="fc" id="L1621">            return result.negate();</span>
        } else {
<span class="fc" id="L1623">            return result;</span>
        }
    }

    /**
     * Multiplies two BigIntegers using a 3-way Toom-Cook multiplication
     * algorithm.  This is a recursive divide-and-conquer algorithm which is
     * more efficient for large numbers than what is commonly called the
     * &quot;grade-school&quot; algorithm used in multiplyToLen.  If the numbers to be
     * multiplied have length n, the &quot;grade-school&quot; algorithm has an
     * asymptotic complexity of O(n^2).  In contrast, 3-way Toom-Cook has a
     * complexity of about O(n^1.465).  It achieves this increased asymptotic
     * performance by breaking each number into three parts and by doing 5
     * multiplies instead of 9 when evaluating the product.  Due to overhead
     * (additions, shifts, and one division) in the Toom-Cook algorithm, it
     * should only be used when both numbers are larger than a certain
     * threshold (found experimentally).  This threshold is generally larger
     * than that for Karatsuba multiplication, so this algorithm is generally
     * only used when numbers become significantly larger.
     *
     * The algorithm used is the &quot;optimal&quot; 3-way Toom-Cook algorithm outlined
     * by Marco Bodrato.
     *
     *  See: http://bodrato.it/toom-cook/
     *       http://bodrato.it/papers/#WAIFI2007
     *
     * &quot;Towards Optimal Toom-Cook Multiplication for Univariate and
     * Multivariate Polynomials in Characteristic 2 and 0.&quot; by Marco BODRATO;
     * In C.Carlet and B.Sunar, Eds., &quot;WAIFI'07 proceedings&quot;, p. 116-133,
     * LNCS #4547. Springer, Madrid, Spain, June 21-22, 2007.
     *
     */
    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) {
<span class="fc" id="L1656">        int alen = a.mag.length;</span>
<span class="fc" id="L1657">        int blen = b.mag.length;</span>

<span class="fc" id="L1659">        int largest = Math.max(alen, blen);</span>

        // k is the size (in ints) of the lower-order slices.
<span class="fc" id="L1662">        int k = (largest+2)/3;   // Equal to ceil(largest/3)</span>

        // r is the size (in ints) of the highest-order slice.
<span class="fc" id="L1665">        int r = largest - 2*k;</span>

        // Obtain slices of the numbers. a2 and b2 are the most significant
        // bits of the numbers a and b, and a0 and b0 the least significant.
        BigInteger a0, a1, a2, b0, b1, b2;
<span class="fc" id="L1670">        a2 = a.getToomSlice(k, r, 0, largest);</span>
<span class="fc" id="L1671">        a1 = a.getToomSlice(k, r, 1, largest);</span>
<span class="fc" id="L1672">        a0 = a.getToomSlice(k, r, 2, largest);</span>
<span class="fc" id="L1673">        b2 = b.getToomSlice(k, r, 0, largest);</span>
<span class="fc" id="L1674">        b1 = b.getToomSlice(k, r, 1, largest);</span>
<span class="fc" id="L1675">        b0 = b.getToomSlice(k, r, 2, largest);</span>

        BigInteger v0, v1, v2, vm1, vinf, t1, t2, tm1, da1, db1;

<span class="fc" id="L1679">        v0 = a0.multiply(b0);</span>
<span class="fc" id="L1680">        da1 = a2.add(a0);</span>
<span class="fc" id="L1681">        db1 = b2.add(b0);</span>
<span class="fc" id="L1682">        vm1 = da1.subtract(a1).multiply(db1.subtract(b1));</span>
<span class="fc" id="L1683">        da1 = da1.add(a1);</span>
<span class="fc" id="L1684">        db1 = db1.add(b1);</span>
<span class="fc" id="L1685">        v1 = da1.multiply(db1);</span>
<span class="fc" id="L1686">        v2 = da1.add(a2).shiftLeft(1).subtract(a0).multiply(</span>
<span class="fc" id="L1687">             db1.add(b2).shiftLeft(1).subtract(b0));</span>
<span class="fc" id="L1688">        vinf = a2.multiply(b2);</span>

        // The algorithm requires two divisions by 2 and one by 3.
        // All divisions are known to be exact, that is, they do not produce
        // remainders, and all results are positive.  The divisions by 2 are
        // implemented as right shifts which are relatively efficient, leaving
        // only an exact division by 3, which is done by a specialized
        // linear-time algorithm.
<span class="fc" id="L1696">        t2 = v2.subtract(vm1).exactDivideBy3();</span>
<span class="fc" id="L1697">        tm1 = v1.subtract(vm1).shiftRight(1);</span>
<span class="fc" id="L1698">        t1 = v1.subtract(v0);</span>
<span class="fc" id="L1699">        t2 = t2.subtract(t1).shiftRight(1);</span>
<span class="fc" id="L1700">        t1 = t1.subtract(tm1).subtract(vinf);</span>
<span class="fc" id="L1701">        t2 = t2.subtract(vinf.shiftLeft(1));</span>
<span class="fc" id="L1702">        tm1 = tm1.subtract(t2);</span>

        // Number of bits to shift left.
<span class="fc" id="L1705">        int ss = k*32;</span>

<span class="fc" id="L1707">        BigInteger result = vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);</span>

<span class="fc bfc" id="L1709" title="All 2 branches covered.">        if (a.signum != b.signum) {</span>
<span class="fc" id="L1710">            return result.negate();</span>
        } else {
<span class="fc" id="L1712">            return result;</span>
        }
    }


    /**
     * Returns a slice of a BigInteger for use in Toom-Cook multiplication.
     *
     * @param lowerSize The size of the lower-order bit slices.
     * @param upperSize The size of the higher-order bit slices.
     * @param slice The index of which slice is requested, which must be a
     * number from 0 to size-1. Slice 0 is the highest-order bits, and slice
     * size-1 are the lowest-order bits. Slice 0 may be of different size than
     * the other slices.
     * @param fullsize The size of the larger integer array, used to align
     * slices to the appropriate position when multiplying different-sized
     * numbers.
     */
    private BigInteger getToomSlice(int lowerSize, int upperSize, int slice,
                                    int fullsize) {
        int start, end, sliceSize, len, offset;

<span class="fc" id="L1734">        len = mag.length;</span>
<span class="fc" id="L1735">        offset = fullsize - len;</span>

<span class="fc bfc" id="L1737" title="All 2 branches covered.">        if (slice == 0) {</span>
<span class="fc" id="L1738">            start = 0 - offset;</span>
<span class="fc" id="L1739">            end = upperSize - 1 - offset;</span>
        } else {
<span class="fc" id="L1741">            start = upperSize + (slice-1)*lowerSize - offset;</span>
<span class="fc" id="L1742">            end = start + lowerSize - 1;</span>
        }

<span class="fc bfc" id="L1745" title="All 2 branches covered.">        if (start &lt; 0) {</span>
<span class="fc" id="L1746">            start = 0;</span>
        }
<span class="fc bfc" id="L1748" title="All 2 branches covered.">        if (end &lt; 0) {</span>
<span class="fc" id="L1749">           return ZERO;</span>
        }

<span class="fc" id="L1752">        sliceSize = (end-start) + 1;</span>

<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">        if (sliceSize &lt;= 0) {</span>
<span class="nc" id="L1755">            return ZERO;</span>
        }

        // While performing Toom-Cook, all slices are positive and
        // the sign is adjusted when the final number is composed.
<span class="fc bfc" id="L1760" title="All 4 branches covered.">        if (start == 0 &amp;&amp; sliceSize &gt;= len) {</span>
<span class="fc" id="L1761">            return this.abs();</span>
        }

<span class="fc" id="L1764">        int intSlice[] = new int[sliceSize];</span>
<span class="fc" id="L1765">        System.arraycopy(mag, start, intSlice, 0, sliceSize);</span>

<span class="fc" id="L1767">        return new BigInteger(trustedStripLeadingZeroInts(intSlice), 1);</span>
    }

    /**
     * Does an exact division (that is, the remainder is known to be zero)
     * of the specified number by 3.  This is used in Toom-Cook
     * multiplication.  This is an efficient algorithm that runs in linear
     * time.  If the argument is not exactly divisible by 3, results are
     * undefined.  Note that this is expected to be called with positive
     * arguments only.
     */
    private BigInteger exactDivideBy3() {
<span class="fc" id="L1779">        int len = mag.length;</span>
<span class="fc" id="L1780">        int[] result = new int[len];</span>
        long x, w, q, borrow;
<span class="fc" id="L1782">        borrow = 0L;</span>
<span class="fc bfc" id="L1783" title="All 2 branches covered.">        for (int i=len-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1784">            x = (mag[i] &amp; LONG_MASK);</span>
<span class="fc" id="L1785">            w = x - borrow;</span>
<span class="pc bpc" id="L1786" title="1 of 2 branches missed.">            if (borrow &gt; x) {      // Did we make the number go negative?</span>
<span class="nc" id="L1787">                borrow = 1L;</span>
            } else {
<span class="fc" id="L1789">                borrow = 0L;</span>
            }

            // 0xAAAAAAAB is the modular inverse of 3 (mod 2^32).  Thus,
            // the effect of this is to divide by 3 (mod 2^32).
            // This is much faster than division on most architectures.
<span class="fc" id="L1795">            q = (w * 0xAAAAAAABL) &amp; LONG_MASK;</span>
<span class="fc" id="L1796">            result[i] = (int) q;</span>

            // Now check the borrow. The second check can of course be
            // eliminated if the first fails.
<span class="fc bfc" id="L1800" title="All 2 branches covered.">            if (q &gt;= 0x55555556L) {</span>
<span class="fc" id="L1801">                borrow++;</span>
<span class="fc bfc" id="L1802" title="All 2 branches covered.">                if (q &gt;= 0xAAAAAAABL)</span>
<span class="fc" id="L1803">                    borrow++;</span>
            }
        }
<span class="fc" id="L1806">        result = trustedStripLeadingZeroInts(result);</span>
<span class="fc" id="L1807">        return new BigInteger(result, signum);</span>
    }

    /**
     * Returns a new BigInteger representing n lower ints of the number.
     * This is used by Karatsuba multiplication and Karatsuba squaring.
     */
    private BigInteger getLower(int n) {
<span class="fc" id="L1815">        int len = mag.length;</span>

<span class="pc bpc" id="L1817" title="1 of 2 branches missed.">        if (len &lt;= n) {</span>
<span class="nc" id="L1818">            return this;</span>
        }

<span class="fc" id="L1821">        int lowerInts[] = new int[n];</span>
<span class="fc" id="L1822">        System.arraycopy(mag, len-n, lowerInts, 0, n);</span>

<span class="fc" id="L1824">        return new BigInteger(trustedStripLeadingZeroInts(lowerInts), 1);</span>
    }

    /**
     * Returns a new BigInteger representing mag.length-n upper
     * ints of the number.  This is used by Karatsuba multiplication and
     * Karatsuba squaring.
     */
    private BigInteger getUpper(int n) {
<span class="fc" id="L1833">        int len = mag.length;</span>

<span class="pc bpc" id="L1835" title="1 of 2 branches missed.">        if (len &lt;= n) {</span>
<span class="nc" id="L1836">            return ZERO;</span>
        }

<span class="fc" id="L1839">        int upperLen = len - n;</span>
<span class="fc" id="L1840">        int upperInts[] = new int[upperLen];</span>
<span class="fc" id="L1841">        System.arraycopy(mag, 0, upperInts, 0, upperLen);</span>

<span class="fc" id="L1843">        return new BigInteger(trustedStripLeadingZeroInts(upperInts), 1);</span>
    }

    // Squaring

    /**
     * Returns a BigInteger whose value is {@code (this&lt;sup&gt;2&lt;/sup&gt;)}.
     *
     * @return {@code this&lt;sup&gt;2&lt;/sup&gt;}
     */
    private BigInteger square() {
<span class="fc bfc" id="L1854" title="All 2 branches covered.">        if (signum == 0) {</span>
<span class="fc" id="L1855">            return ZERO;</span>
        }
<span class="fc" id="L1857">        int len = mag.length;</span>

<span class="fc bfc" id="L1859" title="All 2 branches covered.">        if (len &lt; KARATSUBA_SQUARE_THRESHOLD) {</span>
<span class="fc" id="L1860">            int[] z = squareToLen(mag, len, null);</span>
<span class="fc" id="L1861">            return new BigInteger(trustedStripLeadingZeroInts(z), 1);</span>
        } else {
<span class="fc bfc" id="L1863" title="All 2 branches covered.">            if (len &lt; TOOM_COOK_SQUARE_THRESHOLD) {</span>
<span class="fc" id="L1864">                return squareKaratsuba();</span>
            } else {
<span class="fc" id="L1866">                return squareToomCook3();</span>
            }
        }
    }

    /**
     * Squares the contents of the int array x. The result is placed into the
     * int array z.  The contents of x are not changed.
     */
    private static final int[] squareToLen(int[] x, int len, int[] z) {
        /*
         * The algorithm used here is adapted from Colin Plumb's C library.
         * Technique: Consider the partial products in the multiplication
         * of &quot;abcde&quot; by itself:
         *
         *               a  b  c  d  e
         *            *  a  b  c  d  e
         *          ==================
         *              ae be ce de ee
         *           ad bd cd dd de
         *        ac bc cc cd ce
         *     ab bb bc bd be
         *  aa ab ac ad ae
         *
         * Note that everything above the main diagonal:
         *              ae be ce de = (abcd) * e
         *           ad bd cd       = (abc) * d
         *        ac bc             = (ab) * c
         *     ab                   = (a) * b
         *
         * is a copy of everything below the main diagonal:
         *                       de
         *                 cd ce
         *           bc bd be
         *     ab ac ad ae
         *
         * Thus, the sum is 2 * (off the diagonal) + diagonal.
         *
         * This is accumulated beginning with the diagonal (which
         * consist of the squares of the digits of the input), which is then
         * divided by two, the off-diagonal added, and multiplied by two
         * again.  The low bit is simply a copy of the low bit of the
         * input, so it doesn't need special care.
         */
<span class="fc" id="L1910">        int zlen = len &lt;&lt; 1;</span>
<span class="fc bfc" id="L1911" title="All 4 branches covered.">        if (z == null || z.length &lt; zlen)</span>
<span class="fc" id="L1912">            z = new int[zlen];</span>

        // Store the squares, right shifted one bit (i.e., divided by 2)
<span class="fc" id="L1915">        int lastProductLowWord = 0;</span>
<span class="fc bfc" id="L1916" title="All 2 branches covered.">        for (int j=0, i=0; j &lt; len; j++) {</span>
<span class="fc" id="L1917">            long piece = (x[j] &amp; LONG_MASK);</span>
<span class="fc" id="L1918">            long product = piece * piece;</span>
<span class="fc" id="L1919">            z[i++] = (lastProductLowWord &lt;&lt; 31) | (int)(product &gt;&gt;&gt; 33);</span>
<span class="fc" id="L1920">            z[i++] = (int)(product &gt;&gt;&gt; 1);</span>
<span class="fc" id="L1921">            lastProductLowWord = (int)product;</span>
        }

        // Add in off-diagonal sums
<span class="fc bfc" id="L1925" title="All 2 branches covered.">        for (int i=len, offset=1; i &gt; 0; i--, offset+=2) {</span>
<span class="fc" id="L1926">            int t = x[i-1];</span>
<span class="fc" id="L1927">            t = mulAdd(z, x, offset, i-1, t);</span>
<span class="fc" id="L1928">            addOne(z, offset-1, i, t);</span>
        }

        // Shift back up and set low bit
<span class="fc" id="L1932">        primitiveLeftShift(z, zlen, 1);</span>
<span class="fc" id="L1933">        z[zlen-1] |= x[len-1] &amp; 1;</span>

<span class="fc" id="L1935">        return z;</span>
    }

    /**
     * Squares a BigInteger using the Karatsuba squaring algorithm.  It should
     * be used when both numbers are larger than a certain threshold (found
     * experimentally).  It is a recursive divide-and-conquer algorithm that
     * has better asymptotic performance than the algorithm used in
     * squareToLen.
     */
    private BigInteger squareKaratsuba() {
<span class="fc" id="L1946">        int half = (mag.length+1) / 2;</span>

<span class="fc" id="L1948">        BigInteger xl = getLower(half);</span>
<span class="fc" id="L1949">        BigInteger xh = getUpper(half);</span>

<span class="fc" id="L1951">        BigInteger xhs = xh.square();  // xhs = xh^2</span>
<span class="fc" id="L1952">        BigInteger xls = xl.square();  // xls = xl^2</span>

        // xh^2 &lt;&lt; 64  +  (((xl+xh)^2 - (xh^2 + xl^2)) &lt;&lt; 32) + xl^2
<span class="fc" id="L1955">        return xhs.shiftLeft(half*32).add(xl.add(xh).square().subtract(xhs.add(xls))).shiftLeft(half*32).add(xls);</span>
    }

    /**
     * Squares a BigInteger using the 3-way Toom-Cook squaring algorithm.  It
     * should be used when both numbers are larger than a certain threshold
     * (found experimentally).  It is a recursive divide-and-conquer algorithm
     * that has better asymptotic performance than the algorithm used in
     * squareToLen or squareKaratsuba.
     */
    private BigInteger squareToomCook3() {
<span class="fc" id="L1966">        int len = mag.length;</span>

        // k is the size (in ints) of the lower-order slices.
<span class="fc" id="L1969">        int k = (len+2)/3;   // Equal to ceil(largest/3)</span>

        // r is the size (in ints) of the highest-order slice.
<span class="fc" id="L1972">        int r = len - 2*k;</span>

        // Obtain slices of the numbers. a2 is the most significant
        // bits of the number, and a0 the least significant.
        BigInteger a0, a1, a2;
<span class="fc" id="L1977">        a2 = getToomSlice(k, r, 0, len);</span>
<span class="fc" id="L1978">        a1 = getToomSlice(k, r, 1, len);</span>
<span class="fc" id="L1979">        a0 = getToomSlice(k, r, 2, len);</span>
        BigInteger v0, v1, v2, vm1, vinf, t1, t2, tm1, da1;

<span class="fc" id="L1982">        v0 = a0.square();</span>
<span class="fc" id="L1983">        da1 = a2.add(a0);</span>
<span class="fc" id="L1984">        vm1 = da1.subtract(a1).square();</span>
<span class="fc" id="L1985">        da1 = da1.add(a1);</span>
<span class="fc" id="L1986">        v1 = da1.square();</span>
<span class="fc" id="L1987">        vinf = a2.square();</span>
<span class="fc" id="L1988">        v2 = da1.add(a2).shiftLeft(1).subtract(a0).square();</span>

        // The algorithm requires two divisions by 2 and one by 3.
        // All divisions are known to be exact, that is, they do not produce
        // remainders, and all results are positive.  The divisions by 2 are
        // implemented as right shifts which are relatively efficient, leaving
        // only a division by 3.
        // The division by 3 is done by an optimized algorithm for this case.
<span class="fc" id="L1996">        t2 = v2.subtract(vm1).exactDivideBy3();</span>
<span class="fc" id="L1997">        tm1 = v1.subtract(vm1).shiftRight(1);</span>
<span class="fc" id="L1998">        t1 = v1.subtract(v0);</span>
<span class="fc" id="L1999">        t2 = t2.subtract(t1).shiftRight(1);</span>
<span class="fc" id="L2000">        t1 = t1.subtract(tm1).subtract(vinf);</span>
<span class="fc" id="L2001">        t2 = t2.subtract(vinf.shiftLeft(1));</span>
<span class="fc" id="L2002">        tm1 = tm1.subtract(t2);</span>

        // Number of bits to shift left.
<span class="fc" id="L2005">        int ss = k*32;</span>

<span class="fc" id="L2007">        return vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);</span>
    }

    // Division

    /**
     * Returns a BigInteger whose value is {@code (this / val)}.
     *
     * @param  val value by which this BigInteger is to be divided.
     * @return {@code this / val}
     * @throws ArithmeticException if {@code val} is zero.
     */
    public BigInteger divide(BigInteger val) {
<span class="fc bfc" id="L2020" title="All 4 branches covered.">        if (mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD ||</span>
                val.mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD) {
<span class="fc" id="L2022">            return divideKnuth(val);</span>
        } else {
<span class="fc" id="L2024">            return divideBurnikelZiegler(val);</span>
        }
    }

    /**
     * Returns a BigInteger whose value is {@code (this / val)} using an O(n^2) algorithm from Knuth.
     *
     * @param  val value by which this BigInteger is to be divided.
     * @return {@code this / val}
     * @throws ArithmeticException if {@code val} is zero.
     * @see MutableBigInteger#divideKnuth(MutableBigInteger, MutableBigInteger, boolean)
     */
    private BigInteger divideKnuth(BigInteger val) {
<span class="fc" id="L2037">        MutableBigInteger q = new MutableBigInteger(),</span>
<span class="fc" id="L2038">                          a = new MutableBigInteger(this.mag),</span>
<span class="fc" id="L2039">                          b = new MutableBigInteger(val.mag);</span>

<span class="fc" id="L2041">        a.divideKnuth(b, q, false);</span>
<span class="fc" id="L2042">        return q.toBigInteger(this.signum * val.signum);</span>
    }

    /**
     * Returns an array of two BigIntegers containing {@code (this / val)}
     * followed by {@code (this % val)}.
     *
     * @param  val value by which this BigInteger is to be divided, and the
     *         remainder computed.
     * @return an array of two BigIntegers: the quotient {@code (this / val)}
     *         is the initial element, and the remainder {@code (this % val)}
     *         is the final element.
     * @throws ArithmeticException if {@code val} is zero.
     */
    public BigInteger[] divideAndRemainder(BigInteger val) {
<span class="fc bfc" id="L2057" title="All 4 branches covered.">        if (mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD ||</span>
                val.mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD) {
<span class="fc" id="L2059">            return divideAndRemainderKnuth(val);</span>
        } else {
<span class="fc" id="L2061">            return divideAndRemainderBurnikelZiegler(val);</span>
        }
    }

    /** Long division */
    private BigInteger[] divideAndRemainderKnuth(BigInteger val) {
<span class="fc" id="L2067">        BigInteger[] result = new BigInteger[2];</span>
<span class="fc" id="L2068">        MutableBigInteger q = new MutableBigInteger(),</span>
<span class="fc" id="L2069">                          a = new MutableBigInteger(this.mag),</span>
<span class="fc" id="L2070">                          b = new MutableBigInteger(val.mag);</span>
<span class="fc" id="L2071">        MutableBigInteger r = a.divideKnuth(b, q);</span>
<span class="fc bfc" id="L2072" title="All 2 branches covered.">        result[0] = q.toBigInteger(this.signum == val.signum ? 1 : -1);</span>
<span class="fc" id="L2073">        result[1] = r.toBigInteger(this.signum);</span>
<span class="fc" id="L2074">        return result;</span>
    }

    /**
     * Returns a BigInteger whose value is {@code (this % val)}.
     *
     * @param  val value by which this BigInteger is to be divided, and the
     *         remainder computed.
     * @return {@code this % val}
     * @throws ArithmeticException if {@code val} is zero.
     */
    public BigInteger remainder(BigInteger val) {
<span class="fc bfc" id="L2086" title="All 4 branches covered.">        if (mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD ||</span>
                val.mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD) {
<span class="fc" id="L2088">            return remainderKnuth(val);</span>
        } else {
<span class="fc" id="L2090">            return remainderBurnikelZiegler(val);</span>
        }
    }

    /** Long division */
    private BigInteger remainderKnuth(BigInteger val) {
<span class="fc" id="L2096">        MutableBigInteger q = new MutableBigInteger(),</span>
<span class="fc" id="L2097">                          a = new MutableBigInteger(this.mag),</span>
<span class="fc" id="L2098">                          b = new MutableBigInteger(val.mag);</span>

<span class="fc" id="L2100">        return a.divideKnuth(b, q).toBigInteger(this.signum);</span>
    }

    /**
     * Calculates {@code this / val} using the Burnikel-Ziegler algorithm.
     * @param  val the divisor
     * @return {@code this / val}
     */
    private BigInteger divideBurnikelZiegler(BigInteger val) {
<span class="fc" id="L2109">        return divideAndRemainderBurnikelZiegler(val)[0];</span>
    }

    /**
     * Calculates {@code this % val} using the Burnikel-Ziegler algorithm.
     * @param val the divisor
     * @return {@code this % val}
     */
    private BigInteger remainderBurnikelZiegler(BigInteger val) {
<span class="fc" id="L2118">        return divideAndRemainderBurnikelZiegler(val)[1];</span>
    }

    /**
     * Computes {@code this / val} and {@code this % val} using the
     * Burnikel-Ziegler algorithm.
     * @param val the divisor
     * @return an array containing the quotient and remainder
     */
    private BigInteger[] divideAndRemainderBurnikelZiegler(BigInteger val) {
<span class="fc" id="L2128">        MutableBigInteger q = new MutableBigInteger();</span>
<span class="fc" id="L2129">        MutableBigInteger r = new MutableBigInteger(this).divideAndRemainderBurnikelZiegler(new MutableBigInteger(val), q);</span>
<span class="fc bfc" id="L2130" title="All 2 branches covered.">        BigInteger qBigInt = q.isZero() ? ZERO : q.toBigInteger(signum*val.signum);</span>
<span class="fc bfc" id="L2131" title="All 2 branches covered.">        BigInteger rBigInt = r.isZero() ? ZERO : r.toBigInteger(signum);</span>
<span class="fc" id="L2132">        return new BigInteger[] {qBigInt, rBigInt};</span>
    }

    /**
     * Returns a BigInteger whose value is &lt;tt&gt;(this&lt;sup&gt;exponent&lt;/sup&gt;)&lt;/tt&gt;.
     * Note that {@code exponent} is an integer rather than a BigInteger.
     *
     * @param  exponent exponent to which this BigInteger is to be raised.
     * @return &lt;tt&gt;this&lt;sup&gt;exponent&lt;/sup&gt;&lt;/tt&gt;
     * @throws ArithmeticException {@code exponent} is negative.  (This would
     *         cause the operation to yield a non-integer value.)
     */
    public BigInteger pow(int exponent) {
<span class="pc bpc" id="L2145" title="1 of 2 branches missed.">        if (exponent &lt; 0) {</span>
<span class="nc" id="L2146">            throw new ArithmeticException(&quot;Negative exponent&quot;);</span>
        }
<span class="fc bfc" id="L2148" title="All 2 branches covered.">        if (signum == 0) {</span>
<span class="fc bfc" id="L2149" title="All 2 branches covered.">            return (exponent == 0 ? ONE : this);</span>
        }

<span class="fc" id="L2152">        BigInteger partToSquare = this.abs();</span>

        // Factor out powers of two from the base, as the exponentiation of
        // these can be done by left shifts only.
        // The remaining part can then be exponentiated faster.  The
        // powers of two will be multiplied back at the end.
<span class="fc" id="L2158">        int powersOfTwo = partToSquare.getLowestSetBit();</span>
<span class="fc" id="L2159">        long bitsToShift = (long)powersOfTwo * exponent;</span>
<span class="pc bpc" id="L2160" title="1 of 2 branches missed.">        if (bitsToShift &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L2161">            reportOverflow();</span>
        }

        int remainingBits;

        // Factor the powers of two out quickly by shifting right, if needed.
<span class="fc bfc" id="L2167" title="All 2 branches covered.">        if (powersOfTwo &gt; 0) {</span>
<span class="fc" id="L2168">            partToSquare = partToSquare.shiftRight(powersOfTwo);</span>
<span class="fc" id="L2169">            remainingBits = partToSquare.bitLength();</span>
<span class="fc bfc" id="L2170" title="All 2 branches covered.">            if (remainingBits == 1) {  // Nothing left but +/- 1?</span>
<span class="fc bfc" id="L2171" title="All 4 branches covered.">                if (signum &lt; 0 &amp;&amp; (exponent&amp;1) == 1) {</span>
<span class="fc" id="L2172">                    return NEGATIVE_ONE.shiftLeft(powersOfTwo*exponent);</span>
                } else {
<span class="fc" id="L2174">                    return ONE.shiftLeft(powersOfTwo*exponent);</span>
                }
            }
        } else {
<span class="fc" id="L2178">            remainingBits = partToSquare.bitLength();</span>
<span class="fc bfc" id="L2179" title="All 2 branches covered.">            if (remainingBits == 1) { // Nothing left but +/- 1?</span>
<span class="fc bfc" id="L2180" title="All 4 branches covered.">                if (signum &lt; 0  &amp;&amp; (exponent&amp;1) == 1) {</span>
<span class="fc" id="L2181">                    return NEGATIVE_ONE;</span>
                } else {
<span class="fc" id="L2183">                    return ONE;</span>
                }
            }
        }

        // This is a quick way to approximate the size of the result,
        // similar to doing log2[n] * exponent.  This will give an upper bound
        // of how big the result can be, and which algorithm to use.
<span class="fc" id="L2191">        long scaleFactor = (long)remainingBits * exponent;</span>

        // Use slightly different algorithms for small and large operands.
        // See if the result will safely fit into a long. (Largest 2^63-1)
<span class="fc bfc" id="L2195" title="All 4 branches covered.">        if (partToSquare.mag.length == 1 &amp;&amp; scaleFactor &lt;= 62) {</span>
            // Small number algorithm.  Everything fits into a long.
<span class="fc bfc" id="L2197" title="All 4 branches covered.">            int newSign = (signum &lt;0  &amp;&amp; (exponent&amp;1) == 1 ? -1 : 1);</span>
<span class="fc" id="L2198">            long result = 1;</span>
<span class="fc" id="L2199">            long baseToPow2 = partToSquare.mag[0] &amp; LONG_MASK;</span>

<span class="fc" id="L2201">            int workingExponent = exponent;</span>

            // Perform exponentiation using repeated squaring trick
<span class="fc bfc" id="L2204" title="All 2 branches covered.">            while (workingExponent != 0) {</span>
<span class="fc bfc" id="L2205" title="All 2 branches covered.">                if ((workingExponent &amp; 1) == 1) {</span>
<span class="fc" id="L2206">                    result = result * baseToPow2;</span>
                }

<span class="fc bfc" id="L2209" title="All 2 branches covered.">                if ((workingExponent &gt;&gt;&gt;= 1) != 0) {</span>
<span class="fc" id="L2210">                    baseToPow2 = baseToPow2 * baseToPow2;</span>
                }
            }

            // Multiply back the powers of two (quickly, by shifting left)
<span class="fc bfc" id="L2215" title="All 2 branches covered.">            if (powersOfTwo &gt; 0) {</span>
<span class="fc bfc" id="L2216" title="All 2 branches covered.">                if (bitsToShift + scaleFactor &lt;= 62) { // Fits in long?</span>
<span class="fc" id="L2217">                    return valueOf((result &lt;&lt; bitsToShift) * newSign);</span>
                } else {
<span class="fc" id="L2219">                    return valueOf(result*newSign).shiftLeft((int) bitsToShift);</span>
                }
            }
            else {
<span class="fc" id="L2223">                return valueOf(result*newSign);</span>
            }
        } else {
            // Large number algorithm.  This is basically identical to
            // the algorithm above, but calls multiply() and square()
            // which may use more efficient algorithms for large numbers.
<span class="fc" id="L2229">            BigInteger answer = ONE;</span>

<span class="fc" id="L2231">            int workingExponent = exponent;</span>
            // Perform exponentiation using repeated squaring trick
<span class="fc bfc" id="L2233" title="All 2 branches covered.">            while (workingExponent != 0) {</span>
<span class="fc bfc" id="L2234" title="All 2 branches covered.">                if ((workingExponent &amp; 1) == 1) {</span>
<span class="fc" id="L2235">                    answer = answer.multiply(partToSquare);</span>
                }

<span class="fc bfc" id="L2238" title="All 2 branches covered.">                if ((workingExponent &gt;&gt;&gt;= 1) != 0) {</span>
<span class="fc" id="L2239">                    partToSquare = partToSquare.square();</span>
                }
            }
            // Multiply back the (exponentiated) powers of two (quickly,
            // by shifting left)
<span class="fc bfc" id="L2244" title="All 2 branches covered.">            if (powersOfTwo &gt; 0) {</span>
<span class="fc" id="L2245">                answer = answer.shiftLeft(powersOfTwo*exponent);</span>
            }

<span class="fc bfc" id="L2248" title="All 4 branches covered.">            if (signum &lt; 0 &amp;&amp; (exponent&amp;1) == 1) {</span>
<span class="fc" id="L2249">                return answer.negate();</span>
            } else {
<span class="fc" id="L2251">                return answer;</span>
            }
        }
    }

    /**
     * Returns a BigInteger whose value is the greatest common divisor of
     * {@code abs(this)} and {@code abs(val)}.  Returns 0 if
     * {@code this == 0 &amp;&amp; val == 0}.
     *
     * @param  val value with which the GCD is to be computed.
     * @return {@code GCD(abs(this), abs(val))}
     */
    public BigInteger gcd(BigInteger val) {
<span class="pc bpc" id="L2265" title="1 of 2 branches missed.">        if (val.signum == 0)</span>
<span class="nc" id="L2266">            return this.abs();</span>
<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">        else if (this.signum == 0)</span>
<span class="nc" id="L2268">            return val.abs();</span>

<span class="fc" id="L2270">        MutableBigInteger a = new MutableBigInteger(this);</span>
<span class="fc" id="L2271">        MutableBigInteger b = new MutableBigInteger(val);</span>

<span class="fc" id="L2273">        MutableBigInteger result = a.hybridGCD(b);</span>

<span class="fc" id="L2275">        return result.toBigInteger(1);</span>
    }

    /**
     * Package private method to return bit length for an integer.
     */
    static int bitLengthForInt(int n) {
<span class="fc" id="L2282">        return 32 - Integer.numberOfLeadingZeros(n);</span>
    }

    /**
     * Left shift int array a up to len by n bits. Returns the array that
     * results from the shift since space may have to be reallocated.
     */
    private static int[] leftShift(int[] a, int len, int n) {
<span class="fc" id="L2290">        int nInts = n &gt;&gt;&gt; 5;</span>
<span class="fc" id="L2291">        int nBits = n&amp;0x1F;</span>
<span class="fc" id="L2292">        int bitsInHighWord = bitLengthForInt(a[0]);</span>

        // If shift can be done without recopy, do so
<span class="pc bpc" id="L2295" title="1 of 2 branches missed.">        if (n &lt;= (32-bitsInHighWord)) {</span>
<span class="nc" id="L2296">            primitiveLeftShift(a, len, nBits);</span>
<span class="nc" id="L2297">            return a;</span>
        } else { // Array must be resized
<span class="pc bpc" id="L2299" title="1 of 2 branches missed.">            if (nBits &lt;= (32-bitsInHighWord)) {</span>
<span class="fc" id="L2300">                int result[] = new int[nInts+len];</span>
<span class="fc" id="L2301">                System.arraycopy(a, 0, result, 0, len);</span>
<span class="fc" id="L2302">                primitiveLeftShift(result, result.length, nBits);</span>
<span class="fc" id="L2303">                return result;</span>
            } else {
<span class="nc" id="L2305">                int result[] = new int[nInts+len+1];</span>
<span class="nc" id="L2306">                System.arraycopy(a, 0, result, 0, len);</span>
<span class="nc" id="L2307">                primitiveRightShift(result, result.length, 32 - nBits);</span>
<span class="nc" id="L2308">                return result;</span>
            }
        }
    }

    // shifts a up to len right n bits assumes no leading zeros, 0&lt;n&lt;32
    static void primitiveRightShift(int[] a, int len, int n) {
<span class="nc" id="L2315">        int n2 = 32 - n;</span>
<span class="nc bnc" id="L2316" title="All 2 branches missed.">        for (int i=len-1, c=a[i]; i &gt; 0; i--) {</span>
<span class="nc" id="L2317">            int b = c;</span>
<span class="nc" id="L2318">            c = a[i-1];</span>
<span class="nc" id="L2319">            a[i] = (c &lt;&lt; n2) | (b &gt;&gt;&gt; n);</span>
        }
<span class="nc" id="L2321">        a[0] &gt;&gt;&gt;= n;</span>
<span class="nc" id="L2322">    }</span>

    // shifts a up to len left n bits assumes no leading zeros, 0&lt;=n&lt;32
    static void primitiveLeftShift(int[] a, int len, int n) {
<span class="pc bpc" id="L2326" title="1 of 4 branches missed.">        if (len == 0 || n == 0)</span>
<span class="fc" id="L2327">            return;</span>

<span class="fc" id="L2329">        int n2 = 32 - n;</span>
<span class="fc bfc" id="L2330" title="All 2 branches covered.">        for (int i=0, c=a[i], m=i+len-1; i &lt; m; i++) {</span>
<span class="fc" id="L2331">            int b = c;</span>
<span class="fc" id="L2332">            c = a[i+1];</span>
<span class="fc" id="L2333">            a[i] = (b &lt;&lt; n) | (c &gt;&gt;&gt; n2);</span>
        }
<span class="fc" id="L2335">        a[len-1] &lt;&lt;= n;</span>
<span class="fc" id="L2336">    }</span>

    /**
     * Calculate bitlength of contents of the first len elements an int array,
     * assuming there are no leading zero ints.
     */
    private static int bitLength(int[] val, int len) {
<span class="pc bpc" id="L2343" title="1 of 2 branches missed.">        if (len == 0)</span>
<span class="nc" id="L2344">            return 0;</span>
<span class="fc" id="L2345">        return ((len - 1) &lt;&lt; 5) + bitLengthForInt(val[0]);</span>
    }

    /**
     * Returns a BigInteger whose value is the absolute value of this
     * BigInteger.
     *
     * @return {@code abs(this)}
     */
    public BigInteger abs() {
<span class="fc bfc" id="L2355" title="All 2 branches covered.">        return (signum &gt;= 0 ? this : this.negate());</span>
    }

    /**
     * Returns a BigInteger whose value is {@code (-this)}.
     *
     * @return {@code -this}
     */
    public BigInteger negate() {
<span class="fc" id="L2364">        return new BigInteger(this.mag, -this.signum);</span>
    }

    /**
     * Returns the signum function of this BigInteger.
     *
     * @return -1, 0 or 1 as the value of this BigInteger is negative, zero or
     *         positive.
     */
    public int signum() {
<span class="fc" id="L2374">        return this.signum;</span>
    }

    // Modular Arithmetic Operations

    /**
     * Returns a BigInteger whose value is {@code (this mod m}).  This method
     * differs from {@code remainder} in that it always returns a
     * &lt;i&gt;non-negative&lt;/i&gt; BigInteger.
     *
     * @param  m the modulus.
     * @return {@code this mod m}
     * @throws ArithmeticException {@code m} &amp;le; 0
     * @see    #remainder
     */
    public BigInteger mod(BigInteger m) {
<span class="pc bpc" id="L2390" title="1 of 2 branches missed.">        if (m.signum &lt;= 0)</span>
<span class="nc" id="L2391">            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);</span>

<span class="fc" id="L2393">        BigInteger result = this.remainder(m);</span>
<span class="fc bfc" id="L2394" title="All 2 branches covered.">        return (result.signum &gt;= 0 ? result : result.add(m));</span>
    }

    /**
     * Returns a BigInteger whose value is
     * &lt;tt&gt;(this&lt;sup&gt;exponent&lt;/sup&gt; mod m)&lt;/tt&gt;.  (Unlike {@code pow}, this
     * method permits negative exponents.)
     *
     * @param  exponent the exponent.
     * @param  m the modulus.
     * @return &lt;tt&gt;this&lt;sup&gt;exponent&lt;/sup&gt; mod m&lt;/tt&gt;
     * @throws ArithmeticException {@code m} &amp;le; 0 or the exponent is
     *         negative and this BigInteger is not &lt;i&gt;relatively
     *         prime&lt;/i&gt; to {@code m}.
     * @see    #modInverse
     */
    public BigInteger modPow(BigInteger exponent, BigInteger m) {
<span class="pc bpc" id="L2411" title="1 of 2 branches missed.">        if (m.signum &lt;= 0)</span>
<span class="nc" id="L2412">            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);</span>

        // Trivial cases
<span class="fc bfc" id="L2415" title="All 2 branches covered.">        if (exponent.signum == 0)</span>
<span class="pc bpc" id="L2416" title="1 of 2 branches missed.">            return (m.equals(ONE) ? ZERO : ONE);</span>

<span class="fc bfc" id="L2418" title="All 2 branches covered.">        if (this.equals(ONE))</span>
<span class="pc bpc" id="L2419" title="1 of 2 branches missed.">            return (m.equals(ONE) ? ZERO : ONE);</span>

<span class="pc bpc" id="L2421" title="1 of 4 branches missed.">        if (this.equals(ZERO) &amp;&amp; exponent.signum &gt;= 0)</span>
<span class="fc" id="L2422">            return ZERO;</span>

<span class="fc bfc" id="L2424" title="All 4 branches covered.">        if (this.equals(negConst[1]) &amp;&amp; (!exponent.testBit(0)))</span>
<span class="pc bpc" id="L2425" title="1 of 2 branches missed.">            return (m.equals(ONE) ? ZERO : ONE);</span>

        boolean invertResult;
<span class="pc bpc" id="L2428" title="2 of 4 branches missed.">        if ((invertResult = (exponent.signum &lt; 0)))</span>
<span class="nc" id="L2429">            exponent = exponent.negate();</span>

<span class="fc bfc" id="L2431" title="All 4 branches covered.">        BigInteger base = (this.signum &lt; 0 || this.compareTo(m) &gt;= 0</span>
<span class="fc" id="L2432">                           ? this.mod(m) : this);</span>
        BigInteger result;
<span class="fc bfc" id="L2434" title="All 2 branches covered.">        if (m.testBit(0)) { // odd modulus</span>
<span class="fc" id="L2435">            result = base.oddModPow(exponent, m);</span>
        } else {
            /*
             * Even modulus.  Tear it into an &quot;odd part&quot; (m1) and power of two
             * (m2), exponentiate mod m1, manually exponentiate mod m2, and
             * use Chinese Remainder Theorem to combine results.
             */

            // Tear m apart into odd part (m1) and power of 2 (m2)
<span class="fc" id="L2444">            int p = m.getLowestSetBit();   // Max pow of 2 that divides m</span>

<span class="fc" id="L2446">            BigInteger m1 = m.shiftRight(p);  // m/2**p</span>
<span class="fc" id="L2447">            BigInteger m2 = ONE.shiftLeft(p); // 2**p</span>

            // Calculate new base from m1
<span class="fc bfc" id="L2450" title="All 4 branches covered.">            BigInteger base2 = (this.signum &lt; 0 || this.compareTo(m1) &gt;= 0</span>
<span class="fc" id="L2451">                                ? this.mod(m1) : this);</span>

            // Caculate (base ** exponent) mod m1.
<span class="fc bfc" id="L2454" title="All 2 branches covered.">            BigInteger a1 = (m1.equals(ONE) ? ZERO :</span>
<span class="fc" id="L2455">                             base2.oddModPow(exponent, m1));</span>

            // Calculate (this ** exponent) mod m2
<span class="fc" id="L2458">            BigInteger a2 = base.modPow2(exponent, p);</span>

            // Combine results using Chinese Remainder Theorem
<span class="fc" id="L2461">            BigInteger y1 = m2.modInverse(m1);</span>
<span class="fc" id="L2462">            BigInteger y2 = m1.modInverse(m2);</span>

<span class="pc bpc" id="L2464" title="1 of 2 branches missed.">            if (m.mag.length &lt; MAX_MAG_LENGTH / 2) {</span>
<span class="fc" id="L2465">                result = a1.multiply(m2).multiply(y1).add(a2.multiply(m1).multiply(y2)).mod(m);</span>
            } else {
<span class="nc" id="L2467">                MutableBigInteger t1 = new MutableBigInteger();</span>
<span class="nc" id="L2468">                new MutableBigInteger(a1.multiply(m2)).multiply(new MutableBigInteger(y1), t1);</span>
<span class="nc" id="L2469">                MutableBigInteger t2 = new MutableBigInteger();</span>
<span class="nc" id="L2470">                new MutableBigInteger(a2.multiply(m1)).multiply(new MutableBigInteger(y2), t2);</span>
<span class="nc" id="L2471">                t1.add(t2);</span>
<span class="nc" id="L2472">                MutableBigInteger q = new MutableBigInteger();</span>
<span class="nc" id="L2473">                result = t1.divide(new MutableBigInteger(m), q).toBigInteger();</span>
            }
        }

<span class="pc bpc" id="L2477" title="1 of 2 branches missed.">        return (invertResult ? result.modInverse(m) : result);</span>
    }

<span class="fc" id="L2480">    static int[] bnExpModThreshTable = {7, 25, 81, 241, 673, 1793,</span>
                                                Integer.MAX_VALUE}; // Sentinel

    /**
     * Returns a BigInteger whose value is x to the power of y mod z.
     * Assumes: z is odd &amp;&amp; x &lt; z.
     */
    private BigInteger oddModPow(BigInteger y, BigInteger z) {
    /*
     * The algorithm is adapted from Colin Plumb's C library.
     *
     * The window algorithm:
     * The idea is to keep a running product of b1 = n^(high-order bits of exp)
     * and then keep appending exponent bits to it.  The following patterns
     * apply to a 3-bit window (k = 3):
     * To append   0: square
     * To append   1: square, multiply by n^1
     * To append  10: square, multiply by n^1, square
     * To append  11: square, square, multiply by n^3
     * To append 100: square, multiply by n^1, square, square
     * To append 101: square, square, square, multiply by n^5
     * To append 110: square, square, multiply by n^3, square
     * To append 111: square, square, square, multiply by n^7
     *
     * Since each pattern involves only one multiply, the longer the pattern
     * the better, except that a 0 (no multiplies) can be appended directly.
     * We precompute a table of odd powers of n, up to 2^k, and can then
     * multiply k bits of exponent at a time.  Actually, assuming random
     * exponents, there is on average one zero bit between needs to
     * multiply (1/2 of the time there's none, 1/4 of the time there's 1,
     * 1/8 of the time, there's 2, 1/32 of the time, there's 3, etc.), so
     * you have to do one multiply per k+1 bits of exponent.
     *
     * The loop walks down the exponent, squaring the result buffer as
     * it goes.  There is a wbits+1 bit lookahead buffer, buf, that is
     * filled with the upcoming exponent bits.  (What is read after the
     * end of the exponent is unimportant, but it is filled with zero here.)
     * When the most-significant bit of this buffer becomes set, i.e.
     * (buf &amp; tblmask) != 0, we have to decide what pattern to multiply
     * by, and when to do it.  We decide, remember to do it in future
     * after a suitable number of squarings have passed (e.g. a pattern
     * of &quot;100&quot; in the buffer requires that we multiply by n^1 immediately;
     * a pattern of &quot;110&quot; calls for multiplying by n^3 after one more
     * squaring), clear the buffer, and continue.
     *
     * When we start, there is one more optimization: the result buffer
     * is implcitly one, so squaring it or multiplying by it can be
     * optimized away.  Further, if we start with a pattern like &quot;100&quot;
     * in the lookahead window, rather than placing n into the buffer
     * and then starting to square it, we have already computed n^2
     * to compute the odd-powers table, so we can place that into
     * the buffer and save a squaring.
     *
     * This means that if you have a k-bit window, to compute n^z,
     * where z is the high k bits of the exponent, 1/2 of the time
     * it requires no squarings.  1/4 of the time, it requires 1
     * squaring, ... 1/2^(k-1) of the time, it reqires k-2 squarings.
     * And the remaining 1/2^(k-1) of the time, the top k bits are a
     * 1 followed by k-1 0 bits, so it again only requires k-2
     * squarings, not k-1.  The average of these is 1.  Add that
     * to the one squaring we have to do to compute the table,
     * and you'll see that a k-bit window saves k-2 squarings
     * as well as reducing the multiplies.  (It actually doesn't
     * hurt in the case k = 1, either.)
     */
        // Special case for exponent of one
<span class="fc bfc" id="L2546" title="All 2 branches covered.">        if (y.equals(ONE))</span>
<span class="fc" id="L2547">            return this;</span>

        // Special case for base of zero
<span class="pc bpc" id="L2550" title="1 of 2 branches missed.">        if (signum == 0)</span>
<span class="nc" id="L2551">            return ZERO;</span>

<span class="fc" id="L2553">        int[] base = mag.clone();</span>
<span class="fc" id="L2554">        int[] exp = y.mag;</span>
<span class="fc" id="L2555">        int[] mod = z.mag;</span>
<span class="fc" id="L2556">        int modLen = mod.length;</span>

        // Select an appropriate window size
<span class="fc" id="L2559">        int wbits = 0;</span>
<span class="fc" id="L2560">        int ebits = bitLength(exp, exp.length);</span>
        // if exponent is 65537 (0x10001), use minimum window size
<span class="fc bfc" id="L2562" title="All 4 branches covered.">        if ((ebits != 17) || (exp[0] != 65537)) {</span>
<span class="fc bfc" id="L2563" title="All 2 branches covered.">            while (ebits &gt; bnExpModThreshTable[wbits]) {</span>
<span class="fc" id="L2564">                wbits++;</span>
            }
        }

        // Calculate appropriate table size
<span class="fc" id="L2569">        int tblmask = 1 &lt;&lt; wbits;</span>

        // Allocate table for precomputed odd powers of base in Montgomery form
<span class="fc" id="L2572">        int[][] table = new int[tblmask][];</span>
<span class="fc bfc" id="L2573" title="All 2 branches covered.">        for (int i=0; i &lt; tblmask; i++)</span>
<span class="fc" id="L2574">            table[i] = new int[modLen];</span>

        // Compute the modular inverse
<span class="fc" id="L2577">        int inv = -MutableBigInteger.inverseMod32(mod[modLen-1]);</span>

        // Convert base to Montgomery form
<span class="fc" id="L2580">        int[] a = leftShift(base, base.length, modLen &lt;&lt; 5);</span>

<span class="fc" id="L2582">        MutableBigInteger q = new MutableBigInteger(),</span>
<span class="fc" id="L2583">                          a2 = new MutableBigInteger(a),</span>
<span class="fc" id="L2584">                          b2 = new MutableBigInteger(mod);</span>

<span class="fc" id="L2586">        MutableBigInteger r= a2.divide(b2, q);</span>
<span class="fc" id="L2587">        table[0] = r.toIntArray();</span>

        // Pad table[0] with leading zeros so its length is at least modLen
<span class="fc bfc" id="L2590" title="All 2 branches covered.">        if (table[0].length &lt; modLen) {</span>
<span class="fc" id="L2591">           int offset = modLen - table[0].length;</span>
<span class="fc" id="L2592">           int[] t2 = new int[modLen];</span>
<span class="fc bfc" id="L2593" title="All 2 branches covered.">           for (int i=0; i &lt; table[0].length; i++)</span>
<span class="fc" id="L2594">               t2[i+offset] = table[0][i];</span>
<span class="fc" id="L2595">           table[0] = t2;</span>
        }

        // Set b to the square of the base
<span class="fc" id="L2599">        int[] b = squareToLen(table[0], modLen, null);</span>
<span class="fc" id="L2600">        b = montReduce(b, mod, modLen, inv);</span>

        // Set t to high half of b
<span class="fc" id="L2603">        int[] t = Arrays.copyOf(b, modLen);</span>

        // Fill in the table with odd powers of the base
<span class="fc bfc" id="L2606" title="All 2 branches covered.">        for (int i=1; i &lt; tblmask; i++) {</span>
<span class="fc" id="L2607">            int[] prod = multiplyToLen(t, modLen, table[i-1], modLen, null);</span>
<span class="fc" id="L2608">            table[i] = montReduce(prod, mod, modLen, inv);</span>
        }

        // Pre load the window that slides over the exponent
<span class="fc" id="L2612">        int bitpos = 1 &lt;&lt; ((ebits-1) &amp; (32-1));</span>

<span class="fc" id="L2614">        int buf = 0;</span>
<span class="fc" id="L2615">        int elen = exp.length;</span>
<span class="fc" id="L2616">        int eIndex = 0;</span>
<span class="fc bfc" id="L2617" title="All 2 branches covered.">        for (int i = 0; i &lt;= wbits; i++) {</span>
<span class="fc bfc" id="L2618" title="All 2 branches covered.">            buf = (buf &lt;&lt; 1) | (((exp[eIndex] &amp; bitpos) != 0)?1:0);</span>
<span class="fc" id="L2619">            bitpos &gt;&gt;&gt;= 1;</span>
<span class="fc bfc" id="L2620" title="All 2 branches covered.">            if (bitpos == 0) {</span>
<span class="fc" id="L2621">                eIndex++;</span>
<span class="fc" id="L2622">                bitpos = 1 &lt;&lt; (32-1);</span>
<span class="fc" id="L2623">                elen--;</span>
            }
        }

<span class="fc" id="L2627">        int multpos = ebits;</span>

        // The first iteration, which is hoisted out of the main loop
<span class="fc" id="L2630">        ebits--;</span>
<span class="fc" id="L2631">        boolean isone = true;</span>

<span class="fc" id="L2633">        multpos = ebits - wbits;</span>
<span class="fc bfc" id="L2634" title="All 2 branches covered.">        while ((buf &amp; 1) == 0) {</span>
<span class="fc" id="L2635">            buf &gt;&gt;&gt;= 1;</span>
<span class="fc" id="L2636">            multpos++;</span>
        }

<span class="fc" id="L2639">        int[] mult = table[buf &gt;&gt;&gt; 1];</span>

<span class="fc" id="L2641">        buf = 0;</span>
<span class="fc bfc" id="L2642" title="All 2 branches covered.">        if (multpos == ebits)</span>
<span class="fc" id="L2643">            isone = false;</span>

        // The main loop
        while (true) {
<span class="fc" id="L2647">            ebits--;</span>
            // Advance the window
<span class="fc" id="L2649">            buf &lt;&lt;= 1;</span>

<span class="fc bfc" id="L2651" title="All 2 branches covered.">            if (elen != 0) {</span>
<span class="fc bfc" id="L2652" title="All 2 branches covered.">                buf |= ((exp[eIndex] &amp; bitpos) != 0) ? 1 : 0;</span>
<span class="fc" id="L2653">                bitpos &gt;&gt;&gt;= 1;</span>
<span class="fc bfc" id="L2654" title="All 2 branches covered.">                if (bitpos == 0) {</span>
<span class="fc" id="L2655">                    eIndex++;</span>
<span class="fc" id="L2656">                    bitpos = 1 &lt;&lt; (32-1);</span>
<span class="fc" id="L2657">                    elen--;</span>
                }
            }

            // Examine the window for pending multiplies
<span class="fc bfc" id="L2662" title="All 2 branches covered.">            if ((buf &amp; tblmask) != 0) {</span>
<span class="fc" id="L2663">                multpos = ebits - wbits;</span>
<span class="fc bfc" id="L2664" title="All 2 branches covered.">                while ((buf &amp; 1) == 0) {</span>
<span class="fc" id="L2665">                    buf &gt;&gt;&gt;= 1;</span>
<span class="fc" id="L2666">                    multpos++;</span>
                }
<span class="fc" id="L2668">                mult = table[buf &gt;&gt;&gt; 1];</span>
<span class="fc" id="L2669">                buf = 0;</span>
            }

            // Perform multiply
<span class="fc bfc" id="L2673" title="All 2 branches covered.">            if (ebits == multpos) {</span>
<span class="fc bfc" id="L2674" title="All 2 branches covered.">                if (isone) {</span>
<span class="fc" id="L2675">                    b = mult.clone();</span>
<span class="fc" id="L2676">                    isone = false;</span>
                } else {
<span class="fc" id="L2678">                    t = b;</span>
<span class="fc" id="L2679">                    a = multiplyToLen(t, modLen, mult, modLen, a);</span>
<span class="fc" id="L2680">                    a = montReduce(a, mod, modLen, inv);</span>
<span class="fc" id="L2681">                    t = a; a = b; b = t;</span>
                }
            }

            // Check if done
<span class="fc bfc" id="L2686" title="All 2 branches covered.">            if (ebits == 0)</span>
<span class="fc" id="L2687">                break;</span>

            // Square the input
<span class="fc bfc" id="L2690" title="All 2 branches covered.">            if (!isone) {</span>
<span class="fc" id="L2691">                t = b;</span>
<span class="fc" id="L2692">                a = squareToLen(t, modLen, a);</span>
<span class="fc" id="L2693">                a = montReduce(a, mod, modLen, inv);</span>
<span class="fc" id="L2694">                t = a; a = b; b = t;</span>
            }
        }

        // Convert result out of Montgomery form and return
<span class="fc" id="L2699">        int[] t2 = new int[2*modLen];</span>
<span class="fc" id="L2700">        System.arraycopy(b, 0, t2, modLen, modLen);</span>

<span class="fc" id="L2702">        b = montReduce(t2, mod, modLen, inv);</span>

<span class="fc" id="L2704">        t2 = Arrays.copyOf(b, modLen);</span>

<span class="fc" id="L2706">        return new BigInteger(1, t2);</span>
    }

    /**
     * Montgomery reduce n, modulo mod.  This reduces modulo mod and divides
     * by 2^(32*mlen). Adapted from Colin Plumb's C library.
     */
    private static int[] montReduce(int[] n, int[] mod, int mlen, int inv) {
<span class="fc" id="L2714">        int c=0;</span>
<span class="fc" id="L2715">        int len = mlen;</span>
<span class="fc" id="L2716">        int offset=0;</span>

        do {
<span class="fc" id="L2719">            int nEnd = n[n.length-1-offset];</span>
<span class="fc" id="L2720">            int carry = mulAdd(n, mod, offset, mlen, inv * nEnd);</span>
<span class="fc" id="L2721">            c += addOne(n, offset, mlen, carry);</span>
<span class="fc" id="L2722">            offset++;</span>
<span class="fc bfc" id="L2723" title="All 2 branches covered.">        } while (--len &gt; 0);</span>

<span class="fc bfc" id="L2725" title="All 2 branches covered.">        while (c &gt; 0)</span>
<span class="fc" id="L2726">            c += subN(n, mod, mlen);</span>

<span class="fc bfc" id="L2728" title="All 2 branches covered.">        while (intArrayCmpToLen(n, mod, mlen) &gt;= 0)</span>
<span class="fc" id="L2729">            subN(n, mod, mlen);</span>

<span class="fc" id="L2731">        return n;</span>
    }


    /*
     * Returns -1, 0 or +1 as big-endian unsigned int array arg1 is less than,
     * equal to, or greater than arg2 up to length len.
     */
    private static int intArrayCmpToLen(int[] arg1, int[] arg2, int len) {
<span class="fc bfc" id="L2740" title="All 2 branches covered.">        for (int i=0; i &lt; len; i++) {</span>
<span class="fc" id="L2741">            long b1 = arg1[i] &amp; LONG_MASK;</span>
<span class="fc" id="L2742">            long b2 = arg2[i] &amp; LONG_MASK;</span>
<span class="fc bfc" id="L2743" title="All 2 branches covered.">            if (b1 &lt; b2)</span>
<span class="fc" id="L2744">                return -1;</span>
<span class="fc bfc" id="L2745" title="All 2 branches covered.">            if (b1 &gt; b2)</span>
<span class="fc" id="L2746">                return 1;</span>
        }
<span class="fc" id="L2748">        return 0;</span>
    }

    /**
     * Subtracts two numbers of same length, returning borrow.
     */
    private static int subN(int[] a, int[] b, int len) {
<span class="fc" id="L2755">        long sum = 0;</span>

<span class="fc bfc" id="L2757" title="All 2 branches covered.">        while (--len &gt;= 0) {</span>
<span class="fc" id="L2758">            sum = (a[len] &amp; LONG_MASK) -</span>
                 (b[len] &amp; LONG_MASK) + (sum &gt;&gt; 32);
<span class="fc" id="L2760">            a[len] = (int)sum;</span>
        }

<span class="fc" id="L2763">        return (int)(sum &gt;&gt; 32);</span>
    }

    /**
     * Multiply an array by one word k and add to result, return the carry
     */
    static int mulAdd(int[] out, int[] in, int offset, int len, int k) {
<span class="fc" id="L2770">        long kLong = k &amp; LONG_MASK;</span>
<span class="fc" id="L2771">        long carry = 0;</span>

<span class="fc" id="L2773">        offset = out.length-offset - 1;</span>
<span class="fc bfc" id="L2774" title="All 2 branches covered.">        for (int j=len-1; j &gt;= 0; j--) {</span>
<span class="fc" id="L2775">            long product = (in[j] &amp; LONG_MASK) * kLong +</span>
                           (out[offset] &amp; LONG_MASK) + carry;
<span class="fc" id="L2777">            out[offset--] = (int)product;</span>
<span class="fc" id="L2778">            carry = product &gt;&gt;&gt; 32;</span>
        }
<span class="fc" id="L2780">        return (int)carry;</span>
    }

    /**
     * Add one word to the number a mlen words into a. Return the resulting
     * carry.
     */
    static int addOne(int[] a, int offset, int mlen, int carry) {
<span class="fc" id="L2788">        offset = a.length-1-mlen-offset;</span>
<span class="fc" id="L2789">        long t = (a[offset] &amp; LONG_MASK) + (carry &amp; LONG_MASK);</span>

<span class="fc" id="L2791">        a[offset] = (int)t;</span>
<span class="fc bfc" id="L2792" title="All 2 branches covered.">        if ((t &gt;&gt;&gt; 32) == 0)</span>
<span class="fc" id="L2793">            return 0;</span>
<span class="pc bpc" id="L2794" title="1 of 2 branches missed.">        while (--mlen &gt;= 0) {</span>
<span class="fc bfc" id="L2795" title="All 2 branches covered.">            if (--offset &lt; 0) { // Carry out of number</span>
<span class="fc" id="L2796">                return 1;</span>
            } else {
<span class="fc" id="L2798">                a[offset]++;</span>
<span class="fc bfc" id="L2799" title="All 2 branches covered.">                if (a[offset] != 0)</span>
<span class="fc" id="L2800">                    return 0;</span>
            }
        }
<span class="nc" id="L2803">        return 1;</span>
    }

    /**
     * Returns a BigInteger whose value is (this ** exponent) mod (2**p)
     */
    private BigInteger modPow2(BigInteger exponent, int p) {
        /*
         * Perform exponentiation using repeated squaring trick, chopping off
         * high order bits as indicated by modulus.
         */
<span class="fc" id="L2814">        BigInteger result = ONE;</span>
<span class="fc" id="L2815">        BigInteger baseToPow2 = this.mod2(p);</span>
<span class="fc" id="L2816">        int expOffset = 0;</span>

<span class="fc" id="L2818">        int limit = exponent.bitLength();</span>

<span class="fc bfc" id="L2820" title="All 2 branches covered.">        if (this.testBit(0))</span>
<span class="fc bfc" id="L2821" title="All 2 branches covered.">           limit = (p-1) &lt; limit ? (p-1) : limit;</span>

<span class="fc bfc" id="L2823" title="All 2 branches covered.">        while (expOffset &lt; limit) {</span>
<span class="fc bfc" id="L2824" title="All 2 branches covered.">            if (exponent.testBit(expOffset))</span>
<span class="fc" id="L2825">                result = result.multiply(baseToPow2).mod2(p);</span>
<span class="fc" id="L2826">            expOffset++;</span>
<span class="fc bfc" id="L2827" title="All 2 branches covered.">            if (expOffset &lt; limit)</span>
<span class="fc" id="L2828">                baseToPow2 = baseToPow2.square().mod2(p);</span>
        }

<span class="fc" id="L2831">        return result;</span>
    }

    /**
     * Returns a BigInteger whose value is this mod(2**p).
     * Assumes that this {@code BigInteger &gt;= 0} and {@code p &gt; 0}.
     */
    private BigInteger mod2(int p) {
<span class="fc bfc" id="L2839" title="All 2 branches covered.">        if (bitLength() &lt;= p)</span>
<span class="fc" id="L2840">            return this;</span>

        // Copy remaining ints of mag
<span class="fc" id="L2843">        int numInts = (p + 31) &gt;&gt;&gt; 5;</span>
<span class="fc" id="L2844">        int[] mag = new int[numInts];</span>
<span class="fc" id="L2845">        System.arraycopy(this.mag, (this.mag.length - numInts), mag, 0, numInts);</span>

        // Mask out any excess bits
<span class="fc" id="L2848">        int excessBits = (numInts &lt;&lt; 5) - p;</span>
<span class="fc" id="L2849">        mag[0] &amp;= (1L &lt;&lt; (32-excessBits)) - 1;</span>

<span class="fc bfc" id="L2851" title="All 2 branches covered.">        return (mag[0] == 0 ? new BigInteger(1, mag) : new BigInteger(mag, 1));</span>
    }

    /**
     * Returns a BigInteger whose value is {@code (this}&lt;sup&gt;-1&lt;/sup&gt; {@code mod m)}.
     *
     * @param  m the modulus.
     * @return {@code this}&lt;sup&gt;-1&lt;/sup&gt; {@code mod m}.
     * @throws ArithmeticException {@code  m} &amp;le; 0, or this BigInteger
     *         has no multiplicative inverse mod m (that is, this BigInteger
     *         is not &lt;i&gt;relatively prime&lt;/i&gt; to m).
     */
    public BigInteger modInverse(BigInteger m) {
<span class="pc bpc" id="L2864" title="1 of 2 branches missed.">        if (m.signum != 1)</span>
<span class="nc" id="L2865">            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);</span>

<span class="fc bfc" id="L2867" title="All 2 branches covered.">        if (m.equals(ONE))</span>
<span class="fc" id="L2868">            return ZERO;</span>

        // Calculate (this mod m)
<span class="fc" id="L2871">        BigInteger modVal = this;</span>
<span class="fc bfc" id="L2872" title="All 4 branches covered.">        if (signum &lt; 0 || (this.compareMagnitude(m) &gt;= 0))</span>
<span class="fc" id="L2873">            modVal = this.mod(m);</span>

<span class="fc bfc" id="L2875" title="All 2 branches covered.">        if (modVal.equals(ONE))</span>
<span class="fc" id="L2876">            return ONE;</span>

<span class="fc" id="L2878">        MutableBigInteger a = new MutableBigInteger(modVal);</span>
<span class="fc" id="L2879">        MutableBigInteger b = new MutableBigInteger(m);</span>

<span class="fc" id="L2881">        MutableBigInteger result = a.mutableModInverse(b);</span>
<span class="fc" id="L2882">        return result.toBigInteger(1);</span>
    }

    // Shift Operations

    /**
     * Returns a BigInteger whose value is {@code (this &lt;&lt; n)}.
     * The shift distance, {@code n}, may be negative, in which case
     * this method performs a right shift.
     * (Computes &lt;tt&gt;floor(this * 2&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt;.)
     *
     * @param  n shift distance, in bits.
     * @return {@code this &lt;&lt; n}
     * @see #shiftRight
     */
    public BigInteger shiftLeft(int n) {
<span class="fc bfc" id="L2898" title="All 2 branches covered.">        if (signum == 0)</span>
<span class="fc" id="L2899">            return ZERO;</span>
<span class="fc bfc" id="L2900" title="All 2 branches covered.">        if (n &gt; 0) {</span>
<span class="fc" id="L2901">            return new BigInteger(shiftLeft(mag, n), signum);</span>
<span class="fc bfc" id="L2902" title="All 2 branches covered.">        } else if (n == 0) {</span>
<span class="fc" id="L2903">            return this;</span>
        } else {
            // Possible int overflow in (-n) is not a trouble,
            // because shiftRightImpl considers its argument unsigned
<span class="fc" id="L2907">            return shiftRightImpl(-n);</span>
        }
    }

    /**
     * Returns a magnitude array whose value is {@code (mag &lt;&lt; n)}.
     * The shift distance, {@code n}, is considered unnsigned.
     * (Computes &lt;tt&gt;this * 2&lt;sup&gt;n&lt;/sup&gt;&lt;/tt&gt;.)
     *
     * @param mag magnitude, the most-significant int ({@code mag[0]}) must be non-zero.
     * @param  n unsigned shift distance, in bits.
     * @return {@code mag &lt;&lt; n}
     */
    private static int[] shiftLeft(int[] mag, int n) {
<span class="fc" id="L2921">        int nInts = n &gt;&gt;&gt; 5;</span>
<span class="fc" id="L2922">        int nBits = n &amp; 0x1f;</span>
<span class="fc" id="L2923">        int magLen = mag.length;</span>
<span class="fc" id="L2924">        int newMag[] = null;</span>

<span class="fc bfc" id="L2926" title="All 2 branches covered.">        if (nBits == 0) {</span>
<span class="fc" id="L2927">            newMag = new int[magLen + nInts];</span>
<span class="fc" id="L2928">            System.arraycopy(mag, 0, newMag, 0, magLen);</span>
        } else {
<span class="fc" id="L2930">            int i = 0;</span>
<span class="fc" id="L2931">            int nBits2 = 32 - nBits;</span>
<span class="fc" id="L2932">            int highBits = mag[0] &gt;&gt;&gt; nBits2;</span>
<span class="fc bfc" id="L2933" title="All 2 branches covered.">            if (highBits != 0) {</span>
<span class="fc" id="L2934">                newMag = new int[magLen + nInts + 1];</span>
<span class="fc" id="L2935">                newMag[i++] = highBits;</span>
            } else {
<span class="fc" id="L2937">                newMag = new int[magLen + nInts];</span>
            }
<span class="fc" id="L2939">            int j=0;</span>
<span class="fc bfc" id="L2940" title="All 2 branches covered.">            while (j &lt; magLen-1)</span>
<span class="fc" id="L2941">                newMag[i++] = mag[j++] &lt;&lt; nBits | mag[j] &gt;&gt;&gt; nBits2;</span>
<span class="fc" id="L2942">            newMag[i] = mag[j] &lt;&lt; nBits;</span>
        }
<span class="fc" id="L2944">        return newMag;</span>
    }

    /**
     * Returns a BigInteger whose value is {@code (this &gt;&gt; n)}.  Sign
     * extension is performed.  The shift distance, {@code n}, may be
     * negative, in which case this method performs a left shift.
     * (Computes &lt;tt&gt;floor(this / 2&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt;.)
     *
     * @param  n shift distance, in bits.
     * @return {@code this &gt;&gt; n}
     * @see #shiftLeft
     */
    public BigInteger shiftRight(int n) {
<span class="fc bfc" id="L2958" title="All 2 branches covered.">        if (signum == 0)</span>
<span class="fc" id="L2959">            return ZERO;</span>
<span class="pc bpc" id="L2960" title="1 of 2 branches missed.">        if (n &gt; 0) {</span>
<span class="fc" id="L2961">            return shiftRightImpl(n);</span>
<span class="nc bnc" id="L2962" title="All 2 branches missed.">        } else if (n == 0) {</span>
<span class="nc" id="L2963">            return this;</span>
        } else {
            // Possible int overflow in {@code -n} is not a trouble,
            // because shiftLeft considers its argument unsigned
<span class="nc" id="L2967">            return new BigInteger(shiftLeft(mag, -n), signum);</span>
        }
    }

    /**
     * Returns a BigInteger whose value is {@code (this &gt;&gt; n)}. The shift
     * distance, {@code n}, is considered unsigned.
     * (Computes &lt;tt&gt;floor(this * 2&lt;sup&gt;-n&lt;/sup&gt;)&lt;/tt&gt;.)
     *
     * @param  n unsigned shift distance, in bits.
     * @return {@code this &gt;&gt; n}
     */
    private BigInteger shiftRightImpl(int n) {
<span class="fc" id="L2980">        int nInts = n &gt;&gt;&gt; 5;</span>
<span class="fc" id="L2981">        int nBits = n &amp; 0x1f;</span>
<span class="fc" id="L2982">        int magLen = mag.length;</span>
<span class="fc" id="L2983">        int newMag[] = null;</span>

        // Special case: entire contents shifted off the end
<span class="fc bfc" id="L2986" title="All 2 branches covered.">        if (nInts &gt;= magLen)</span>
<span class="fc bfc" id="L2987" title="All 2 branches covered.">            return (signum &gt;= 0 ? ZERO : negConst[1]);</span>

<span class="fc bfc" id="L2989" title="All 2 branches covered.">        if (nBits == 0) {</span>
<span class="fc" id="L2990">            int newMagLen = magLen - nInts;</span>
<span class="fc" id="L2991">            newMag = Arrays.copyOf(mag, newMagLen);</span>
<span class="fc" id="L2992">        } else {</span>
<span class="fc" id="L2993">            int i = 0;</span>
<span class="fc" id="L2994">            int highBits = mag[0] &gt;&gt;&gt; nBits;</span>
<span class="fc bfc" id="L2995" title="All 2 branches covered.">            if (highBits != 0) {</span>
<span class="fc" id="L2996">                newMag = new int[magLen - nInts];</span>
<span class="fc" id="L2997">                newMag[i++] = highBits;</span>
            } else {
<span class="fc" id="L2999">                newMag = new int[magLen - nInts -1];</span>
            }

<span class="fc" id="L3002">            int nBits2 = 32 - nBits;</span>
<span class="fc" id="L3003">            int j=0;</span>
<span class="fc bfc" id="L3004" title="All 2 branches covered.">            while (j &lt; magLen - nInts - 1)</span>
<span class="fc" id="L3005">                newMag[i++] = (mag[j++] &lt;&lt; nBits2) | (mag[j] &gt;&gt;&gt; nBits);</span>
        }

<span class="fc bfc" id="L3008" title="All 2 branches covered.">        if (signum &lt; 0) {</span>
            // Find out whether any one-bits were shifted off the end.
<span class="fc" id="L3010">            boolean onesLost = false;</span>
<span class="fc bfc" id="L3011" title="All 4 branches covered.">            for (int i=magLen-1, j=magLen-nInts; i &gt;= j &amp;&amp; !onesLost; i--)</span>
<span class="fc bfc" id="L3012" title="All 2 branches covered.">                onesLost = (mag[i] != 0);</span>
<span class="fc bfc" id="L3013" title="All 4 branches covered.">            if (!onesLost &amp;&amp; nBits != 0)</span>
<span class="fc bfc" id="L3014" title="All 2 branches covered.">                onesLost = (mag[magLen - nInts - 1] &lt;&lt; (32 - nBits) != 0);</span>

<span class="fc bfc" id="L3016" title="All 2 branches covered.">            if (onesLost)</span>
<span class="fc" id="L3017">                newMag = javaIncrement(newMag);</span>
        }

<span class="fc" id="L3020">        return new BigInteger(newMag, signum);</span>
    }

    int[] javaIncrement(int[] val) {
<span class="fc" id="L3024">        int lastSum = 0;</span>
<span class="fc bfc" id="L3025" title="All 4 branches covered.">        for (int i=val.length-1;  i &gt;= 0 &amp;&amp; lastSum == 0; i--)</span>
<span class="fc" id="L3026">            lastSum = (val[i] += 1);</span>
<span class="fc bfc" id="L3027" title="All 2 branches covered.">        if (lastSum == 0) {</span>
<span class="fc" id="L3028">            val = new int[val.length+1];</span>
<span class="fc" id="L3029">            val[0] = 1;</span>
        }
<span class="fc" id="L3031">        return val;</span>
    }

    // Bitwise Operations

    /**
     * Returns a BigInteger whose value is {@code (this &amp; val)}.  (This
     * method returns a negative BigInteger if and only if this and val are
     * both negative.)
     *
     * @param val value to be AND'ed with this BigInteger.
     * @return {@code this &amp; val}
     */
    public BigInteger and(BigInteger val) {
<span class="fc" id="L3045">        int[] result = new int[Math.max(intLength(), val.intLength())];</span>
<span class="fc bfc" id="L3046" title="All 2 branches covered.">        for (int i=0; i &lt; result.length; i++)</span>
<span class="fc" id="L3047">            result[i] = (getInt(result.length-i-1)</span>
<span class="fc" id="L3048">                         &amp; val.getInt(result.length-i-1));</span>

<span class="fc" id="L3050">        return valueOf(result);</span>
    }

    /**
     * Returns a BigInteger whose value is {@code (this | val)}.  (This method
     * returns a negative BigInteger if and only if either this or val is
     * negative.)
     *
     * @param val value to be OR'ed with this BigInteger.
     * @return {@code this | val}
     */
    public BigInteger or(BigInteger val) {
<span class="fc" id="L3062">        int[] result = new int[Math.max(intLength(), val.intLength())];</span>
<span class="fc bfc" id="L3063" title="All 2 branches covered.">        for (int i=0; i &lt; result.length; i++)</span>
<span class="fc" id="L3064">            result[i] = (getInt(result.length-i-1)</span>
<span class="fc" id="L3065">                         | val.getInt(result.length-i-1));</span>

<span class="fc" id="L3067">        return valueOf(result);</span>
    }

    /**
     * Returns a BigInteger whose value is {@code (this ^ val)}.  (This method
     * returns a negative BigInteger if and only if exactly one of this and
     * val are negative.)
     *
     * @param val value to be XOR'ed with this BigInteger.
     * @return {@code this ^ val}
     */
    public BigInteger xor(BigInteger val) {
<span class="fc" id="L3079">        int[] result = new int[Math.max(intLength(), val.intLength())];</span>
<span class="fc bfc" id="L3080" title="All 2 branches covered.">        for (int i=0; i &lt; result.length; i++)</span>
<span class="fc" id="L3081">            result[i] = (getInt(result.length-i-1)</span>
<span class="fc" id="L3082">                         ^ val.getInt(result.length-i-1));</span>

<span class="fc" id="L3084">        return valueOf(result);</span>
    }

    /**
     * Returns a BigInteger whose value is {@code (~this)}.  (This method
     * returns a negative value if and only if this BigInteger is
     * non-negative.)
     *
     * @return {@code ~this}
     */
    public BigInteger not() {
<span class="fc" id="L3095">        int[] result = new int[intLength()];</span>
<span class="fc bfc" id="L3096" title="All 2 branches covered.">        for (int i=0; i &lt; result.length; i++)</span>
<span class="fc" id="L3097">            result[i] = ~getInt(result.length-i-1);</span>

<span class="fc" id="L3099">        return valueOf(result);</span>
    }

    /**
     * Returns a BigInteger whose value is {@code (this &amp; ~val)}.  This
     * method, which is equivalent to {@code and(val.not())}, is provided as
     * a convenience for masking operations.  (This method returns a negative
     * BigInteger if and only if {@code this} is negative and {@code val} is
     * positive.)
     *
     * @param val value to be complemented and AND'ed with this BigInteger.
     * @return {@code this &amp; ~val}
     */
    public BigInteger andNot(BigInteger val) {
<span class="fc" id="L3113">        int[] result = new int[Math.max(intLength(), val.intLength())];</span>
<span class="fc bfc" id="L3114" title="All 2 branches covered.">        for (int i=0; i &lt; result.length; i++)</span>
<span class="fc" id="L3115">            result[i] = (getInt(result.length-i-1)</span>
<span class="fc" id="L3116">                         &amp; ~val.getInt(result.length-i-1));</span>

<span class="fc" id="L3118">        return valueOf(result);</span>
    }


    // Single Bit Operations

    /**
     * Returns {@code true} if and only if the designated bit is set.
     * (Computes {@code ((this &amp; (1&lt;&lt;n)) != 0)}.)
     *
     * @param  n index of bit to test.
     * @return {@code true} if and only if the designated bit is set.
     * @throws ArithmeticException {@code n} is negative.
     */
    public boolean testBit(int n) {
<span class="pc bpc" id="L3133" title="1 of 2 branches missed.">        if (n &lt; 0)</span>
<span class="nc" id="L3134">            throw new ArithmeticException(&quot;Negative bit address&quot;);</span>

<span class="fc bfc" id="L3136" title="All 2 branches covered.">        return (getInt(n &gt;&gt;&gt; 5) &amp; (1 &lt;&lt; (n &amp; 31))) != 0;</span>
    }

    /**
     * Returns a BigInteger whose value is equivalent to this BigInteger
     * with the designated bit set.  (Computes {@code (this | (1&lt;&lt;n))}.)
     *
     * @param  n index of bit to set.
     * @return {@code this | (1&lt;&lt;n)}
     * @throws ArithmeticException {@code n} is negative.
     */
    public BigInteger setBit(int n) {
<span class="pc bpc" id="L3148" title="1 of 2 branches missed.">        if (n &lt; 0)</span>
<span class="nc" id="L3149">            throw new ArithmeticException(&quot;Negative bit address&quot;);</span>

<span class="fc" id="L3151">        int intNum = n &gt;&gt;&gt; 5;</span>
<span class="fc" id="L3152">        int[] result = new int[Math.max(intLength(), intNum+2)];</span>

<span class="fc bfc" id="L3154" title="All 2 branches covered.">        for (int i=0; i &lt; result.length; i++)</span>
<span class="fc" id="L3155">            result[result.length-i-1] = getInt(i);</span>

<span class="fc" id="L3157">        result[result.length-intNum-1] |= (1 &lt;&lt; (n &amp; 31));</span>

<span class="fc" id="L3159">        return valueOf(result);</span>
    }

    /**
     * Returns a BigInteger whose value is equivalent to this BigInteger
     * with the designated bit cleared.
     * (Computes {@code (this &amp; ~(1&lt;&lt;n))}.)
     *
     * @param  n index of bit to clear.
     * @return {@code this &amp; ~(1&lt;&lt;n)}
     * @throws ArithmeticException {@code n} is negative.
     */
    public BigInteger clearBit(int n) {
<span class="pc bpc" id="L3172" title="1 of 2 branches missed.">        if (n &lt; 0)</span>
<span class="nc" id="L3173">            throw new ArithmeticException(&quot;Negative bit address&quot;);</span>

<span class="fc" id="L3175">        int intNum = n &gt;&gt;&gt; 5;</span>
<span class="fc" id="L3176">        int[] result = new int[Math.max(intLength(), ((n + 1) &gt;&gt;&gt; 5) + 1)];</span>

<span class="fc bfc" id="L3178" title="All 2 branches covered.">        for (int i=0; i &lt; result.length; i++)</span>
<span class="fc" id="L3179">            result[result.length-i-1] = getInt(i);</span>

<span class="fc" id="L3181">        result[result.length-intNum-1] &amp;= ~(1 &lt;&lt; (n &amp; 31));</span>

<span class="fc" id="L3183">        return valueOf(result);</span>
    }

    /**
     * Returns a BigInteger whose value is equivalent to this BigInteger
     * with the designated bit flipped.
     * (Computes {@code (this ^ (1&lt;&lt;n))}.)
     *
     * @param  n index of bit to flip.
     * @return {@code this ^ (1&lt;&lt;n)}
     * @throws ArithmeticException {@code n} is negative.
     */
    public BigInteger flipBit(int n) {
<span class="pc bpc" id="L3196" title="1 of 2 branches missed.">        if (n &lt; 0)</span>
<span class="nc" id="L3197">            throw new ArithmeticException(&quot;Negative bit address&quot;);</span>

<span class="fc" id="L3199">        int intNum = n &gt;&gt;&gt; 5;</span>
<span class="fc" id="L3200">        int[] result = new int[Math.max(intLength(), intNum+2)];</span>

<span class="fc bfc" id="L3202" title="All 2 branches covered.">        for (int i=0; i &lt; result.length; i++)</span>
<span class="fc" id="L3203">            result[result.length-i-1] = getInt(i);</span>

<span class="fc" id="L3205">        result[result.length-intNum-1] ^= (1 &lt;&lt; (n &amp; 31));</span>

<span class="fc" id="L3207">        return valueOf(result);</span>
    }

    /**
     * Returns the index of the rightmost (lowest-order) one bit in this
     * BigInteger (the number of zero bits to the right of the rightmost
     * one bit).  Returns -1 if this BigInteger contains no one bits.
     * (Computes {@code (this == 0? -1 : log2(this &amp; -this))}.)
     *
     * @return index of the rightmost one bit in this BigInteger.
     */
    public int getLowestSetBit() {
<span class="fc" id="L3219">        @SuppressWarnings(&quot;deprecation&quot;) int lsb = lowestSetBit - 2;</span>
<span class="fc bfc" id="L3220" title="All 2 branches covered.">        if (lsb == -2) {  // lowestSetBit not initialized yet</span>
<span class="fc" id="L3221">            lsb = 0;</span>
<span class="fc bfc" id="L3222" title="All 2 branches covered.">            if (signum == 0) {</span>
<span class="fc" id="L3223">                lsb -= 1;</span>
            } else {
                // Search for lowest order nonzero int
                int i,b;
<span class="fc bfc" id="L3227" title="All 2 branches covered.">                for (i=0; (b = getInt(i)) == 0; i++)</span>
                    ;
<span class="fc" id="L3229">                lsb += (i &lt;&lt; 5) + Integer.numberOfTrailingZeros(b);</span>
            }
<span class="fc" id="L3231">            lowestSetBit = lsb + 2;</span>
        }
<span class="fc" id="L3233">        return lsb;</span>
    }


    // Miscellaneous Bit Operations

    /**
     * Returns the number of bits in the minimal two's-complement
     * representation of this BigInteger, &lt;i&gt;excluding&lt;/i&gt; a sign bit.
     * For positive BigIntegers, this is equivalent to the number of bits in
     * the ordinary binary representation.  (Computes
     * {@code (ceil(log2(this &lt; 0 ? -this : this+1)))}.)
     *
     * @return number of bits in the minimal two's-complement
     *         representation of this BigInteger, &lt;i&gt;excluding&lt;/i&gt; a sign bit.
     */
    public int bitLength() {
<span class="fc" id="L3250">        @SuppressWarnings(&quot;deprecation&quot;) int n = bitLength - 1;</span>
<span class="fc bfc" id="L3251" title="All 2 branches covered.">        if (n == -1) { // bitLength not initialized yet</span>
<span class="fc" id="L3252">            int[] m = mag;</span>
<span class="fc" id="L3253">            int len = m.length;</span>
<span class="fc bfc" id="L3254" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L3255">                n = 0; // offset by one to initialize</span>
            }  else {
                // Calculate the bit length of the magnitude
<span class="fc" id="L3258">                int magBitLength = ((len - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]);</span>
<span class="fc bfc" id="L3259" title="All 2 branches covered.">                 if (signum &lt; 0) {</span>
                     // Check if magnitude is a power of two
<span class="fc bfc" id="L3261" title="All 2 branches covered.">                     boolean pow2 = (Integer.bitCount(mag[0]) == 1);</span>
<span class="fc bfc" id="L3262" title="All 4 branches covered.">                     for (int i=1; i&lt; len &amp;&amp; pow2; i++)</span>
<span class="fc bfc" id="L3263" title="All 2 branches covered.">                         pow2 = (mag[i] == 0);</span>

<span class="fc bfc" id="L3265" title="All 2 branches covered.">                     n = (pow2 ? magBitLength -1 : magBitLength);</span>
<span class="fc" id="L3266">                 } else {</span>
<span class="fc" id="L3267">                     n = magBitLength;</span>
                 }
            }
<span class="fc" id="L3270">            bitLength = n + 1;</span>
        }
<span class="fc" id="L3272">        return n;</span>
    }

    /**
     * Returns the number of bits in the two's complement representation
     * of this BigInteger that differ from its sign bit.  This method is
     * useful when implementing bit-vector style sets atop BigIntegers.
     *
     * @return number of bits in the two's complement representation
     *         of this BigInteger that differ from its sign bit.
     */
    public int bitCount() {
<span class="fc" id="L3284">        @SuppressWarnings(&quot;deprecation&quot;) int bc = bitCount - 1;</span>
<span class="pc bpc" id="L3285" title="1 of 2 branches missed.">        if (bc == -1) {  // bitCount not initialized yet</span>
<span class="fc" id="L3286">            bc = 0;      // offset by one to initialize</span>
            // Count the bits in the magnitude
<span class="fc bfc" id="L3288" title="All 2 branches covered.">            for (int i=0; i &lt; mag.length; i++)</span>
<span class="fc" id="L3289">                bc += Integer.bitCount(mag[i]);</span>
<span class="fc bfc" id="L3290" title="All 2 branches covered.">            if (signum &lt; 0) {</span>
                // Count the trailing zeros in the magnitude
<span class="fc" id="L3292">                int magTrailingZeroCount = 0, j;</span>
<span class="pc bpc" id="L3293" title="1 of 2 branches missed.">                for (j=mag.length-1; mag[j] == 0; j--)</span>
<span class="nc" id="L3294">                    magTrailingZeroCount += 32;</span>
<span class="fc" id="L3295">                magTrailingZeroCount += Integer.numberOfTrailingZeros(mag[j]);</span>
<span class="fc" id="L3296">                bc += magTrailingZeroCount - 1;</span>
            }
<span class="fc" id="L3298">            bitCount = bc + 1;</span>
        }
<span class="fc" id="L3300">        return bc;</span>
    }

    // Primality Testing

    /**
     * Returns {@code true} if this BigInteger is probably prime,
     * {@code false} if it's definitely composite.  If
     * {@code certainty} is &amp;le; 0, {@code true} is
     * returned.
     *
     * @param  certainty a measure of the uncertainty that the caller is
     *         willing to tolerate: if the call returns {@code true}
     *         the probability that this BigInteger is prime exceeds
     *         (1 - 1/2&lt;sup&gt;{@code certainty}&lt;/sup&gt;).  The execution time of
     *         this method is proportional to the value of this parameter.
     * @return {@code true} if this BigInteger is probably prime,
     *         {@code false} if it's definitely composite.
     */
    public boolean isProbablePrime(int certainty) {
<span class="pc bpc" id="L3320" title="1 of 2 branches missed.">        if (certainty &lt;= 0)</span>
<span class="nc" id="L3321">            return true;</span>
<span class="fc" id="L3322">        BigInteger w = this.abs();</span>
<span class="pc bpc" id="L3323" title="1 of 2 branches missed.">        if (w.equals(TWO))</span>
<span class="nc" id="L3324">            return true;</span>
<span class="pc bpc" id="L3325" title="1 of 4 branches missed.">        if (!w.testBit(0) || w.equals(ONE))</span>
<span class="fc" id="L3326">            return false;</span>

<span class="fc" id="L3328">        return w.primeToCertainty(certainty, null);</span>
    }

    // Comparison Operations

    /**
     * Compares this BigInteger with the specified BigInteger.  This
     * method is provided in preference to individual methods for each
     * of the six boolean comparison operators ({@literal &lt;}, ==,
     * {@literal &gt;}, {@literal &gt;=}, !=, {@literal &lt;=}).  The suggested
     * idiom for performing these comparisons is: {@code
     * (x.compareTo(y)} &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; {@code 0)}, where
     * &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; is one of the six comparison operators.
     *
     * @param  val BigInteger to which this BigInteger is to be compared.
     * @return -1, 0 or 1 as this BigInteger is numerically less than, equal
     *         to, or greater than {@code val}.
     */
    public int compareTo(BigInteger val) {
<span class="fc bfc" id="L3347" title="All 2 branches covered.">        if (signum == val.signum) {</span>
<span class="fc bfc" id="L3348" title="All 3 branches covered.">            switch (signum) {</span>
            case 1:
<span class="fc" id="L3350">                return compareMagnitude(val);</span>
            case -1:
<span class="fc" id="L3352">                return val.compareMagnitude(this);</span>
            default:
<span class="fc" id="L3354">                return 0;</span>
            }
        }
<span class="fc bfc" id="L3357" title="All 2 branches covered.">        return signum &gt; val.signum ? 1 : -1;</span>
    }

    /**
     * Compares the magnitude array of this BigInteger with the specified
     * BigInteger's. This is the version of compareTo ignoring sign.
     *
     * @param val BigInteger whose magnitude array to be compared.
     * @return -1, 0 or 1 as this magnitude array is less than, equal to or
     *         greater than the magnitude aray for the specified BigInteger's.
     */
    final int compareMagnitude(BigInteger val) {
<span class="fc" id="L3369">        int[] m1 = mag;</span>
<span class="fc" id="L3370">        int len1 = m1.length;</span>
<span class="fc" id="L3371">        int[] m2 = val.mag;</span>
<span class="fc" id="L3372">        int len2 = m2.length;</span>
<span class="fc bfc" id="L3373" title="All 2 branches covered.">        if (len1 &lt; len2)</span>
<span class="fc" id="L3374">            return -1;</span>
<span class="fc bfc" id="L3375" title="All 2 branches covered.">        if (len1 &gt; len2)</span>
<span class="fc" id="L3376">            return 1;</span>
<span class="fc bfc" id="L3377" title="All 2 branches covered.">        for (int i = 0; i &lt; len1; i++) {</span>
<span class="fc" id="L3378">            int a = m1[i];</span>
<span class="fc" id="L3379">            int b = m2[i];</span>
<span class="fc bfc" id="L3380" title="All 2 branches covered.">            if (a != b)</span>
<span class="fc bfc" id="L3381" title="All 2 branches covered.">                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK)) ? -1 : 1;</span>
        }
<span class="fc" id="L3383">        return 0;</span>
    }

    /**
     * Version of compareMagnitude that compares magnitude with long value.
     * val can't be Long.MIN_VALUE.
     */
    final int compareMagnitude(long val) {
<span class="pc bpc" id="L3391" title="2 of 4 branches missed.">        assert val != Long.MIN_VALUE;</span>
<span class="fc" id="L3392">        int[] m1 = mag;</span>
<span class="fc" id="L3393">        int len = m1.length;</span>
<span class="fc bfc" id="L3394" title="All 2 branches covered.">        if (len &gt; 2) {</span>
<span class="fc" id="L3395">            return 1;</span>
        }
<span class="fc bfc" id="L3397" title="All 2 branches covered.">        if (val &lt; 0) {</span>
<span class="fc" id="L3398">            val = -val;</span>
        }
<span class="fc" id="L3400">        int highWord = (int)(val &gt;&gt;&gt; 32);</span>
<span class="fc bfc" id="L3401" title="All 2 branches covered.">        if (highWord == 0) {</span>
<span class="pc bpc" id="L3402" title="1 of 2 branches missed.">            if (len &lt; 1)</span>
<span class="nc" id="L3403">                return -1;</span>
<span class="pc bpc" id="L3404" title="1 of 2 branches missed.">            if (len &gt; 1)</span>
<span class="fc" id="L3405">                return 1;</span>
<span class="nc" id="L3406">            int a = m1[0];</span>
<span class="nc" id="L3407">            int b = (int)val;</span>
<span class="nc bnc" id="L3408" title="All 2 branches missed.">            if (a != b) {</span>
<span class="nc bnc" id="L3409" title="All 2 branches missed.">                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK))? -1 : 1;</span>
            }
<span class="nc" id="L3411">            return 0;</span>
        } else {
<span class="pc bpc" id="L3413" title="1 of 2 branches missed.">            if (len &lt; 2)</span>
<span class="nc" id="L3414">                return -1;</span>
<span class="fc" id="L3415">            int a = m1[0];</span>
<span class="fc" id="L3416">            int b = highWord;</span>
<span class="pc bpc" id="L3417" title="1 of 2 branches missed.">            if (a != b) {</span>
<span class="pc bpc" id="L3418" title="1 of 2 branches missed.">                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK))? -1 : 1;</span>
            }
<span class="nc" id="L3420">            a = m1[1];</span>
<span class="nc" id="L3421">            b = (int)val;</span>
<span class="nc bnc" id="L3422" title="All 2 branches missed.">            if (a != b) {</span>
<span class="nc bnc" id="L3423" title="All 2 branches missed.">                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK))? -1 : 1;</span>
            }
<span class="nc" id="L3425">            return 0;</span>
        }
    }

    /**
     * Compares this BigInteger with the specified Object for equality.
     *
     * @param  x Object to which this BigInteger is to be compared.
     * @return {@code true} if and only if the specified Object is a
     *         BigInteger whose value is numerically equal to this BigInteger.
     */
    public boolean equals(Object x) {
        // This test is just an optimization, which may or may not help
<span class="fc bfc" id="L3438" title="All 2 branches covered.">        if (x == this)</span>
<span class="fc" id="L3439">            return true;</span>

<span class="pc bpc" id="L3441" title="1 of 2 branches missed.">        if (!(x instanceof BigInteger))</span>
<span class="nc" id="L3442">            return false;</span>

<span class="fc" id="L3444">        BigInteger xInt = (BigInteger) x;</span>
<span class="fc bfc" id="L3445" title="All 2 branches covered.">        if (xInt.signum != signum)</span>
<span class="fc" id="L3446">            return false;</span>

<span class="fc" id="L3448">        int[] m = mag;</span>
<span class="fc" id="L3449">        int len = m.length;</span>
<span class="fc" id="L3450">        int[] xm = xInt.mag;</span>
<span class="fc bfc" id="L3451" title="All 2 branches covered.">        if (len != xm.length)</span>
<span class="fc" id="L3452">            return false;</span>

<span class="fc bfc" id="L3454" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++)</span>
<span class="fc bfc" id="L3455" title="All 2 branches covered.">            if (xm[i] != m[i])</span>
<span class="fc" id="L3456">                return false;</span>

<span class="fc" id="L3458">        return true;</span>
    }

    /**
     * Returns the minimum of this BigInteger and {@code val}.
     *
     * @param  val value with which the minimum is to be computed.
     * @return the BigInteger whose value is the lesser of this BigInteger and
     *         {@code val}.  If they are equal, either may be returned.
     */
    public BigInteger min(BigInteger val) {
<span class="nc bnc" id="L3469" title="All 2 branches missed.">        return (compareTo(val) &lt; 0 ? this : val);</span>
    }

    /**
     * Returns the maximum of this BigInteger and {@code val}.
     *
     * @param  val value with which the maximum is to be computed.
     * @return the BigInteger whose value is the greater of this and
     *         {@code val}.  If they are equal, either may be returned.
     */
    public BigInteger max(BigInteger val) {
<span class="nc bnc" id="L3480" title="All 2 branches missed.">        return (compareTo(val) &gt; 0 ? this : val);</span>
    }


    // Hash Function

    /**
     * Returns the hash code for this BigInteger.
     *
     * @return hash code for this BigInteger.
     */
    public int hashCode() {
<span class="fc" id="L3492">        int hashCode = 0;</span>

<span class="fc bfc" id="L3494" title="All 2 branches covered.">        for (int i=0; i &lt; mag.length; i++)</span>
<span class="fc" id="L3495">            hashCode = (int)(31*hashCode + (mag[i] &amp; LONG_MASK));</span>

<span class="fc" id="L3497">        return hashCode * signum;</span>
    }

    /**
     * Returns the String representation of this BigInteger in the
     * given radix.  If the radix is outside the range from {@link
     * Character#MIN_RADIX} to {@link Character#MAX_RADIX} inclusive,
     * it will default to 10 (as is the case for
     * {@code Integer.toString}).  The digit-to-character mapping
     * provided by {@code Character.forDigit} is used, and a minus
     * sign is prepended if appropriate.  (This representation is
     * compatible with the {@link #BigInteger(String, int) (String,
     * int)} constructor.)
     *
     * @param  radix  radix of the String representation.
     * @return String representation of this BigInteger in the given radix.
     * @see    Integer#toString
     * @see    Character#forDigit
     * @see    #BigInteger(java.lang.String, int)
     */
    public String toString(int radix) {
<span class="fc bfc" id="L3518" title="All 2 branches covered.">        if (signum == 0)</span>
<span class="fc" id="L3519">            return &quot;0&quot;;</span>
<span class="pc bpc" id="L3520" title="2 of 4 branches missed.">        if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)</span>
<span class="nc" id="L3521">            radix = 10;</span>

        // If it's small enough, use smallToString.
<span class="fc bfc" id="L3524" title="All 2 branches covered.">        if (mag.length &lt;= SCHOENHAGE_BASE_CONVERSION_THRESHOLD)</span>
<span class="fc" id="L3525">           return smallToString(radix);</span>

        // Otherwise use recursive toString, which requires positive arguments.
        // The results will be concatenated into this StringBuilder
<span class="fc" id="L3529">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L3530" title="All 2 branches covered.">        if (signum &lt; 0) {</span>
<span class="fc" id="L3531">            toString(this.negate(), sb, radix, 0);</span>
<span class="fc" id="L3532">            sb.insert(0, '-');</span>
        }
        else
<span class="fc" id="L3535">            toString(this, sb, radix, 0);</span>

<span class="fc" id="L3537">        return sb.toString();</span>
    }

    /** This method is used to perform toString when arguments are small. */
    private String smallToString(int radix) {
<span class="pc bpc" id="L3542" title="1 of 2 branches missed.">        if (signum == 0) {</span>
<span class="nc" id="L3543">            return &quot;0&quot;;</span>
        }

        // Compute upper bound on number of digit groups and allocate space
<span class="fc" id="L3547">        int maxNumDigitGroups = (4*mag.length + 6)/7;</span>
<span class="fc" id="L3548">        String digitGroup[] = new String[maxNumDigitGroups];</span>

        // Translate number to string, a digit group at a time
<span class="fc" id="L3551">        BigInteger tmp = this.abs();</span>
<span class="fc" id="L3552">        int numGroups = 0;</span>
<span class="fc bfc" id="L3553" title="All 2 branches covered.">        while (tmp.signum != 0) {</span>
<span class="fc" id="L3554">            BigInteger d = longRadix[radix];</span>

<span class="fc" id="L3556">            MutableBigInteger q = new MutableBigInteger(),</span>
<span class="fc" id="L3557">                              a = new MutableBigInteger(tmp.mag),</span>
<span class="fc" id="L3558">                              b = new MutableBigInteger(d.mag);</span>
<span class="fc" id="L3559">            MutableBigInteger r = a.divide(b, q);</span>
<span class="fc" id="L3560">            BigInteger q2 = q.toBigInteger(tmp.signum * d.signum);</span>
<span class="fc" id="L3561">            BigInteger r2 = r.toBigInteger(tmp.signum * d.signum);</span>

<span class="fc" id="L3563">            digitGroup[numGroups++] = Long.toString(r2.longValue(), radix);</span>
<span class="fc" id="L3564">            tmp = q2;</span>
<span class="fc" id="L3565">        }</span>

        // Put sign (if any) and first digit group into result buffer
<span class="fc" id="L3568">        StringBuilder buf = new StringBuilder(numGroups*digitsPerLong[radix]+1);</span>
<span class="fc bfc" id="L3569" title="All 2 branches covered.">        if (signum &lt; 0) {</span>
<span class="fc" id="L3570">            buf.append('-');</span>
        }
<span class="fc" id="L3572">        buf.append(digitGroup[numGroups-1]);</span>

        // Append remaining digit groups padded with leading zeros
<span class="fc bfc" id="L3575" title="All 2 branches covered.">        for (int i=numGroups-2; i &gt;= 0; i--) {</span>
            // Prepend (any) leading zeros for this digit group
<span class="fc" id="L3577">            int numLeadingZeros = digitsPerLong[radix]-digitGroup[i].length();</span>
<span class="fc bfc" id="L3578" title="All 2 branches covered.">            if (numLeadingZeros != 0) {</span>
<span class="fc" id="L3579">                buf.append(zeros[numLeadingZeros]);</span>
            }
<span class="fc" id="L3581">            buf.append(digitGroup[i]);</span>
        }
<span class="fc" id="L3583">        return buf.toString();</span>
    }

    /**
     * Converts the specified BigInteger to a string and appends to
     * {@code sb}.  This implements the recursive Schoenhage algorithm
     * for base conversions.
     * &lt;p/&gt;
     * See Knuth, Donald,  _The Art of Computer Programming_, Vol. 2,
     * Answers to Exercises (4.4) Question 14.
     *
     * @param u      The number to convert to a string.
     * @param sb     The StringBuilder that will be appended to in place.
     * @param radix  The base to convert to.
     * @param digits The minimum number of digits to pad to.
     */
    private static void toString(BigInteger u, StringBuilder sb, int radix,
                                 int digits) {
        /* If we're smaller than a certain threshold, use the smallToString
           method, padding with leading zeroes when necessary. */
<span class="fc bfc" id="L3603" title="All 2 branches covered.">        if (u.mag.length &lt;= SCHOENHAGE_BASE_CONVERSION_THRESHOLD) {</span>
<span class="fc" id="L3604">            String s = u.smallToString(radix);</span>

            // Pad with internal zeros if necessary.
            // Don't pad if we're at the beginning of the string.
<span class="pc bpc" id="L3608" title="1 of 4 branches missed.">            if ((s.length() &lt; digits) &amp;&amp; (sb.length() &gt; 0)) {</span>
<span class="fc bfc" id="L3609" title="All 2 branches covered.">                for (int i=s.length(); i &lt; digits; i++) { // May be a faster way to</span>
<span class="fc" id="L3610">                    sb.append('0');                    // do this?</span>
                }
            }

<span class="fc" id="L3614">            sb.append(s);</span>
<span class="fc" id="L3615">            return;</span>
        }

        int b, n;
<span class="fc" id="L3619">        b = u.bitLength();</span>

        // Calculate a value for n in the equation radix^(2^n) = u
        // and subtract 1 from that value.  This is used to find the
        // cache index that contains the best value to divide u.
<span class="fc" id="L3624">        n = (int) Math.round(Math.log(b * LOG_TWO / logCache[radix]) / LOG_TWO - 1.0);</span>
<span class="fc" id="L3625">        BigInteger v = getRadixConversionCache(radix, n);</span>
        BigInteger[] results;
<span class="fc" id="L3627">        results = u.divideAndRemainder(v);</span>

<span class="fc" id="L3629">        int expectedDigits = 1 &lt;&lt; n;</span>

        // Now recursively build the two halves of each number.
<span class="fc" id="L3632">        toString(results[0], sb, radix, digits-expectedDigits);</span>
<span class="fc" id="L3633">        toString(results[1], sb, radix, expectedDigits);</span>
<span class="fc" id="L3634">    }</span>

    /**
     * Returns the value radix^(2^exponent) from the cache.
     * If this value doesn't already exist in the cache, it is added.
     * &lt;p/&gt;
     * This could be changed to a more complicated caching method using
     * {@code Future}.
     */
    private static BigInteger getRadixConversionCache(int radix, int exponent) {
<span class="fc" id="L3644">        BigInteger[] cacheLine = powerCache[radix]; // volatile read</span>
<span class="fc bfc" id="L3645" title="All 2 branches covered.">        if (exponent &lt; cacheLine.length) {</span>
<span class="fc" id="L3646">            return cacheLine[exponent];</span>
        }

<span class="fc" id="L3649">        int oldLength = cacheLine.length;</span>
<span class="fc" id="L3650">        cacheLine = Arrays.copyOf(cacheLine, exponent + 1);</span>
<span class="fc bfc" id="L3651" title="All 2 branches covered.">        for (int i = oldLength; i &lt;= exponent; i++) {</span>
<span class="fc" id="L3652">            cacheLine[i] = cacheLine[i - 1].pow(2);</span>
        }

<span class="fc" id="L3655">        BigInteger[][] pc = powerCache; // volatile read again</span>
<span class="pc bpc" id="L3656" title="1 of 2 branches missed.">        if (exponent &gt;= pc[radix].length) {</span>
<span class="fc" id="L3657">            pc = pc.clone();</span>
<span class="fc" id="L3658">            pc[radix] = cacheLine;</span>
<span class="fc" id="L3659">            powerCache = pc; // volatile write, publish</span>
        }
<span class="fc" id="L3661">        return cacheLine[exponent];</span>
    }

    /* zero[i] is a string of i consecutive zeros. */
<span class="fc" id="L3665">    private static String zeros[] = new String[64];</span>
    static {
<span class="fc" id="L3667">        zeros[63] =</span>
            &quot;000000000000000000000000000000000000000000000000000000000000000&quot;;
<span class="fc bfc" id="L3669" title="All 2 branches covered.">        for (int i=0; i &lt; 63; i++)</span>
<span class="fc" id="L3670">            zeros[i] = zeros[63].substring(0, i);</span>
    }

    /**
     * Returns the decimal String representation of this BigInteger.
     * The digit-to-character mapping provided by
     * {@code Character.forDigit} is used, and a minus sign is
     * prepended if appropriate.  (This representation is compatible
     * with the {@link #BigInteger(String) (String)} constructor, and
     * allows for String concatenation with Java's + operator.)
     *
     * @return decimal String representation of this BigInteger.
     * @see    Character#forDigit
     * @see    #BigInteger(java.lang.String)
     */
    public String toString() {
<span class="fc" id="L3686">        return toString(10);</span>
    }

    /**
     * Returns a byte array containing the two's-complement
     * representation of this BigInteger.  The byte array will be in
     * &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant byte is in
     * the zeroth element.  The array will contain the minimum number
     * of bytes required to represent this BigInteger, including at
     * least one sign bit, which is {@code (ceil((this.bitLength() +
     * 1)/8))}.  (This representation is compatible with the
     * {@link #BigInteger(byte[]) (byte[])} constructor.)
     *
     * @return a byte array containing the two's-complement representation of
     *         this BigInteger.
     * @see    #BigInteger(byte[])
     */
    public byte[] toByteArray() {
<span class="fc" id="L3704">        int byteLen = bitLength()/8 + 1;</span>
<span class="fc" id="L3705">        byte[] byteArray = new byte[byteLen];</span>

<span class="fc bfc" id="L3707" title="All 2 branches covered.">        for (int i=byteLen-1, bytesCopied=4, nextInt=0, intIndex=0; i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L3708" title="All 2 branches covered.">            if (bytesCopied == 4) {</span>
<span class="fc" id="L3709">                nextInt = getInt(intIndex++);</span>
<span class="fc" id="L3710">                bytesCopied = 1;</span>
            } else {
<span class="fc" id="L3712">                nextInt &gt;&gt;&gt;= 8;</span>
<span class="fc" id="L3713">                bytesCopied++;</span>
            }
<span class="fc" id="L3715">            byteArray[i] = (byte)nextInt;</span>
        }
<span class="fc" id="L3717">        return byteArray;</span>
    }

    /**
     * Converts this BigInteger to an {@code int}.  This
     * conversion is analogous to a
     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code long} to
     * {@code int} as defined in section 5.1.3 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
     * if this BigInteger is too big to fit in an
     * {@code int}, only the low-order 32 bits are returned.
     * Note that this conversion can lose information about the
     * overall magnitude of the BigInteger value as well as return a
     * result with the opposite sign.
     *
     * @return this BigInteger converted to an {@code int}.
     * @see #intValueExact()
     */
    public int intValue() {
<span class="fc" id="L3736">        int result = 0;</span>
<span class="fc" id="L3737">        result = getInt(0);</span>
<span class="fc" id="L3738">        return result;</span>
    }

    /**
     * Converts this BigInteger to a {@code long}.  This
     * conversion is analogous to a
     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code long} to
     * {@code int} as defined in section 5.1.3 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
     * if this BigInteger is too big to fit in a
     * {@code long}, only the low-order 64 bits are returned.
     * Note that this conversion can lose information about the
     * overall magnitude of the BigInteger value as well as return a
     * result with the opposite sign.
     *
     * @return this BigInteger converted to a {@code long}.
     * @see #longValueExact()
     */
    public long longValue() {
<span class="fc" id="L3757">        long result = 0;</span>

<span class="fc bfc" id="L3759" title="All 2 branches covered.">        for (int i=1; i &gt;= 0; i--)</span>
<span class="fc" id="L3760">            result = (result &lt;&lt; 32) + (getInt(i) &amp; LONG_MASK);</span>
<span class="fc" id="L3761">        return result;</span>
    }

    /**
     * Converts this BigInteger to a {@code float}.  This
     * conversion is similar to the
     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
     * {@code float} as defined in section 5.1.3 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
     * if this BigInteger has too great a magnitude
     * to represent as a {@code float}, it will be converted to
     * {@link Float#NEGATIVE_INFINITY} or {@link
     * Float#POSITIVE_INFINITY} as appropriate.  Note that even when
     * the return value is finite, this conversion can lose
     * information about the precision of the BigInteger value.
     *
     * @return this BigInteger converted to a {@code float}.
     */
    public float floatValue() {
<span class="nc bnc" id="L3780" title="All 2 branches missed.">        if (signum == 0) {</span>
<span class="nc" id="L3781">            return 0.0f;</span>
        }

<span class="nc" id="L3784">        int exponent = ((mag.length - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]) - 1;</span>

        // exponent == floor(log2(abs(this)))
<span class="nc bnc" id="L3787" title="All 2 branches missed.">        if (exponent &lt; Long.SIZE - 1) {</span>
<span class="nc" id="L3788">            return longValue();</span>
<span class="nc bnc" id="L3789" title="All 2 branches missed.">        } else if (exponent &gt; Float.MAX_EXPONENT) {</span>
<span class="nc bnc" id="L3790" title="All 2 branches missed.">            return signum &gt; 0 ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;</span>
        }

        /*
         * We need the top SIGNIFICAND_WIDTH bits, including the &quot;implicit&quot;
         * one bit. To make rounding easier, we pick out the top
         * SIGNIFICAND_WIDTH + 1 bits, so we have one to help us round up or
         * down. twiceSignifFloor will contain the top SIGNIFICAND_WIDTH + 1
         * bits, and signifFloor the top SIGNIFICAND_WIDTH.
         *
         * It helps to consider the real number signif = abs(this) *
         * 2^(SIGNIFICAND_WIDTH - 1 - exponent).
         */
<span class="nc" id="L3803">        int shift = exponent - FloatConsts.SIGNIFICAND_WIDTH;</span>

        int twiceSignifFloor;
        // twiceSignifFloor will be == abs().shiftRight(shift).intValue()
        // We do the shift into an int directly to improve performance.

<span class="nc" id="L3809">        int nBits = shift &amp; 0x1f;</span>
<span class="nc" id="L3810">        int nBits2 = 32 - nBits;</span>

<span class="nc bnc" id="L3812" title="All 2 branches missed.">        if (nBits == 0) {</span>
<span class="nc" id="L3813">            twiceSignifFloor = mag[0];</span>
        } else {
<span class="nc" id="L3815">            twiceSignifFloor = mag[0] &gt;&gt;&gt; nBits;</span>
<span class="nc bnc" id="L3816" title="All 2 branches missed.">            if (twiceSignifFloor == 0) {</span>
<span class="nc" id="L3817">                twiceSignifFloor = (mag[0] &lt;&lt; nBits2) | (mag[1] &gt;&gt;&gt; nBits);</span>
            }
        }

<span class="nc" id="L3821">        int signifFloor = twiceSignifFloor &gt;&gt; 1;</span>
<span class="nc" id="L3822">        signifFloor &amp;= FloatConsts.SIGNIF_BIT_MASK; // remove the implied bit</span>

        /*
         * We round up if either the fractional part of signif is strictly
         * greater than 0.5 (which is true if the 0.5 bit is set and any lower
         * bit is set), or if the fractional part of signif is &gt;= 0.5 and
         * signifFloor is odd (which is true if both the 0.5 bit and the 1 bit
         * are set). This is equivalent to the desired HALF_EVEN rounding.
         */
<span class="nc bnc" id="L3831" title="All 4 branches missed.">        boolean increment = (twiceSignifFloor &amp; 1) != 0</span>
<span class="nc bnc" id="L3832" title="All 2 branches missed.">                &amp;&amp; ((signifFloor &amp; 1) != 0 || abs().getLowestSetBit() &lt; shift);</span>
<span class="nc bnc" id="L3833" title="All 2 branches missed.">        int signifRounded = increment ? signifFloor + 1 : signifFloor;</span>
<span class="nc" id="L3834">        int bits = ((exponent + FloatConsts.EXP_BIAS))</span>
                &lt;&lt; (FloatConsts.SIGNIFICAND_WIDTH - 1);
<span class="nc" id="L3836">        bits += signifRounded;</span>
        /*
         * If signifRounded == 2^24, we'd need to set all of the significand
         * bits to zero and add 1 to the exponent. This is exactly the behavior
         * we get from just adding signifRounded to bits directly. If the
         * exponent is Float.MAX_EXPONENT, we round up (correctly) to
         * Float.POSITIVE_INFINITY.
         */
<span class="nc" id="L3844">        bits |= signum &amp; FloatConsts.SIGN_BIT_MASK;</span>
<span class="nc" id="L3845">        return Float.intBitsToFloat(bits);</span>
    }

    /**
     * Converts this BigInteger to a {@code double}.  This
     * conversion is similar to the
     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
     * {@code float} as defined in section 5.1.3 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
     * if this BigInteger has too great a magnitude
     * to represent as a {@code double}, it will be converted to
     * {@link Double#NEGATIVE_INFINITY} or {@link
     * Double#POSITIVE_INFINITY} as appropriate.  Note that even when
     * the return value is finite, this conversion can lose
     * information about the precision of the BigInteger value.
     *
     * @return this BigInteger converted to a {@code double}.
     */
    public double doubleValue() {
<span class="nc bnc" id="L3864" title="All 2 branches missed.">        if (signum == 0) {</span>
<span class="nc" id="L3865">            return 0.0;</span>
        }

<span class="nc" id="L3868">        int exponent = ((mag.length - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]) - 1;</span>

        // exponent == floor(log2(abs(this))Double)
<span class="nc bnc" id="L3871" title="All 2 branches missed.">        if (exponent &lt; Long.SIZE - 1) {</span>
<span class="nc" id="L3872">            return longValue();</span>
<span class="nc bnc" id="L3873" title="All 2 branches missed.">        } else if (exponent &gt; Double.MAX_EXPONENT) {</span>
<span class="nc bnc" id="L3874" title="All 2 branches missed.">            return signum &gt; 0 ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</span>
        }

        /*
         * We need the top SIGNIFICAND_WIDTH bits, including the &quot;implicit&quot;
         * one bit. To make rounding easier, we pick out the top
         * SIGNIFICAND_WIDTH + 1 bits, so we have one to help us round up or
         * down. twiceSignifFloor will contain the top SIGNIFICAND_WIDTH + 1
         * bits, and signifFloor the top SIGNIFICAND_WIDTH.
         *
         * It helps to consider the real number signif = abs(this) *
         * 2^(SIGNIFICAND_WIDTH - 1 - exponent).
         */
<span class="nc" id="L3887">        int shift = exponent - DoubleConsts.SIGNIFICAND_WIDTH;</span>

        long twiceSignifFloor;
        // twiceSignifFloor will be == abs().shiftRight(shift).longValue()
        // We do the shift into a long directly to improve performance.

<span class="nc" id="L3893">        int nBits = shift &amp; 0x1f;</span>
<span class="nc" id="L3894">        int nBits2 = 32 - nBits;</span>

        int highBits;
        int lowBits;
<span class="nc bnc" id="L3898" title="All 2 branches missed.">        if (nBits == 0) {</span>
<span class="nc" id="L3899">            highBits = mag[0];</span>
<span class="nc" id="L3900">            lowBits = mag[1];</span>
        } else {
<span class="nc" id="L3902">            highBits = mag[0] &gt;&gt;&gt; nBits;</span>
<span class="nc" id="L3903">            lowBits = (mag[0] &lt;&lt; nBits2) | (mag[1] &gt;&gt;&gt; nBits);</span>
<span class="nc bnc" id="L3904" title="All 2 branches missed.">            if (highBits == 0) {</span>
<span class="nc" id="L3905">                highBits = lowBits;</span>
<span class="nc" id="L3906">                lowBits = (mag[1] &lt;&lt; nBits2) | (mag[2] &gt;&gt;&gt; nBits);</span>
            }
        }

<span class="nc" id="L3910">        twiceSignifFloor = ((highBits &amp; LONG_MASK) &lt;&lt; 32)</span>
                | (lowBits &amp; LONG_MASK);

<span class="nc" id="L3913">        long signifFloor = twiceSignifFloor &gt;&gt; 1;</span>
<span class="nc" id="L3914">        signifFloor &amp;= DoubleConsts.SIGNIF_BIT_MASK; // remove the implied bit</span>

        /*
         * We round up if either the fractional part of signif is strictly
         * greater than 0.5 (which is true if the 0.5 bit is set and any lower
         * bit is set), or if the fractional part of signif is &gt;= 0.5 and
         * signifFloor is odd (which is true if both the 0.5 bit and the 1 bit
         * are set). This is equivalent to the desired HALF_EVEN rounding.
         */
<span class="nc bnc" id="L3923" title="All 4 branches missed.">        boolean increment = (twiceSignifFloor &amp; 1) != 0</span>
<span class="nc bnc" id="L3924" title="All 2 branches missed.">                &amp;&amp; ((signifFloor &amp; 1) != 0 || abs().getLowestSetBit() &lt; shift);</span>
<span class="nc bnc" id="L3925" title="All 2 branches missed.">        long signifRounded = increment ? signifFloor + 1 : signifFloor;</span>
<span class="nc" id="L3926">        long bits = (long) ((exponent + DoubleConsts.EXP_BIAS))</span>
                &lt;&lt; (DoubleConsts.SIGNIFICAND_WIDTH - 1);
<span class="nc" id="L3928">        bits += signifRounded;</span>
        /*
         * If signifRounded == 2^53, we'd need to set all of the significand
         * bits to zero and add 1 to the exponent. This is exactly the behavior
         * we get from just adding signifRounded to bits directly. If the
         * exponent is Double.MAX_EXPONENT, we round up (correctly) to
         * Double.POSITIVE_INFINITY.
         */
<span class="nc" id="L3936">        bits |= signum &amp; DoubleConsts.SIGN_BIT_MASK;</span>
<span class="nc" id="L3937">        return Double.longBitsToDouble(bits);</span>
    }

    /**
     * Returns a copy of the input array stripped of any leading zero bytes.
     */
    private static int[] stripLeadingZeroInts(int val[]) {
<span class="fc" id="L3944">        int vlen = val.length;</span>
        int keep;

        // Find first nonzero byte
<span class="fc bfc" id="L3948" title="All 4 branches covered.">        for (keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; keep++)</span>
            ;
<span class="fc" id="L3950">        return java.util.Arrays.copyOfRange(val, keep, vlen);</span>
    }

    /**
     * Returns the input array stripped of any leading zero bytes.
     * Since the source is trusted the copying may be skipped.
     */
    private static int[] trustedStripLeadingZeroInts(int val[]) {
<span class="fc" id="L3958">        int vlen = val.length;</span>
        int keep;

        // Find first nonzero byte
<span class="fc bfc" id="L3962" title="All 4 branches covered.">        for (keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; keep++)</span>
            ;
<span class="fc bfc" id="L3964" title="All 2 branches covered.">        return keep == 0 ? val : java.util.Arrays.copyOfRange(val, keep, vlen);</span>
    }

    /**
     * Returns a copy of the input array stripped of any leading zero bytes.
     */
    private static int[] stripLeadingZeroBytes(byte a[]) {
<span class="fc" id="L3971">        int byteLength = a.length;</span>
        int keep;

        // Find first nonzero byte
<span class="fc bfc" id="L3975" title="All 4 branches covered.">        for (keep = 0; keep &lt; byteLength &amp;&amp; a[keep] == 0; keep++)</span>
            ;

        // Allocate new array and copy relevant part of input array
<span class="fc" id="L3979">        int intLength = ((byteLength - keep) + 3) &gt;&gt;&gt; 2;</span>
<span class="fc" id="L3980">        int[] result = new int[intLength];</span>
<span class="fc" id="L3981">        int b = byteLength - 1;</span>
<span class="fc bfc" id="L3982" title="All 2 branches covered.">        for (int i = intLength-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L3983">            result[i] = a[b--] &amp; 0xff;</span>
<span class="fc" id="L3984">            int bytesRemaining = b - keep + 1;</span>
<span class="fc" id="L3985">            int bytesToTransfer = Math.min(3, bytesRemaining);</span>
<span class="fc bfc" id="L3986" title="All 2 branches covered.">            for (int j=8; j &lt;= (bytesToTransfer &lt;&lt; 3); j += 8)</span>
<span class="fc" id="L3987">                result[i] |= ((a[b--] &amp; 0xff) &lt;&lt; j);</span>
        }
<span class="fc" id="L3989">        return result;</span>
    }

    /**
     * Takes an array a representing a negative 2's-complement number and
     * returns the minimal (no leading zero bytes) unsigned whose value is -a.
     */
    private static int[] makePositive(byte a[]) {
        int keep, k;
<span class="fc" id="L3998">        int byteLength = a.length;</span>

        // Find first non-sign (0xff) byte of input
<span class="fc bfc" id="L4001" title="All 4 branches covered.">        for (keep=0; keep &lt; byteLength &amp;&amp; a[keep] == -1; keep++)</span>
            ;


        /* Allocate output array.  If all non-sign bytes are 0x00, we must
         * allocate space for one extra output byte. */
<span class="fc bfc" id="L4007" title="All 4 branches covered.">        for (k=keep; k &lt; byteLength &amp;&amp; a[k] == 0; k++)</span>
            ;

<span class="fc bfc" id="L4010" title="All 2 branches covered.">        int extraByte = (k == byteLength) ? 1 : 0;</span>
<span class="fc" id="L4011">        int intLength = ((byteLength - keep + extraByte) + 3) &gt;&gt;&gt; 2;</span>
<span class="fc" id="L4012">        int result[] = new int[intLength];</span>

        /* Copy one's complement of input into output, leaving extra
         * byte (if it exists) == 0x00 */
<span class="fc" id="L4016">        int b = byteLength - 1;</span>
<span class="fc bfc" id="L4017" title="All 2 branches covered.">        for (int i = intLength-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L4018">            result[i] = a[b--] &amp; 0xff;</span>
<span class="fc" id="L4019">            int numBytesToTransfer = Math.min(3, b-keep+1);</span>
<span class="fc bfc" id="L4020" title="All 2 branches covered.">            if (numBytesToTransfer &lt; 0)</span>
<span class="fc" id="L4021">                numBytesToTransfer = 0;</span>
<span class="fc bfc" id="L4022" title="All 2 branches covered.">            for (int j=8; j &lt;= 8*numBytesToTransfer; j += 8)</span>
<span class="fc" id="L4023">                result[i] |= ((a[b--] &amp; 0xff) &lt;&lt; j);</span>

            // Mask indicates which bits must be complemented
<span class="fc" id="L4026">            int mask = -1 &gt;&gt;&gt; (8*(3-numBytesToTransfer));</span>
<span class="fc" id="L4027">            result[i] = ~result[i] &amp; mask;</span>
        }

        // Add one to one's complement to generate two's complement
<span class="pc bpc" id="L4031" title="1 of 2 branches missed.">        for (int i=result.length-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L4032">            result[i] = (int)((result[i] &amp; LONG_MASK) + 1);</span>
<span class="fc bfc" id="L4033" title="All 2 branches covered.">            if (result[i] != 0)</span>
<span class="fc" id="L4034">                break;</span>
        }

<span class="fc" id="L4037">        return result;</span>
    }

    /**
     * Takes an array a representing a negative 2's-complement number and
     * returns the minimal (no leading zero ints) unsigned whose value is -a.
     */
    private static int[] makePositive(int a[]) {
        int keep, j;

        // Find first non-sign (0xffffffff) int of input
<span class="fc bfc" id="L4048" title="All 4 branches covered.">        for (keep=0; keep &lt; a.length &amp;&amp; a[keep] == -1; keep++)</span>
            ;

        /* Allocate output array.  If all non-sign ints are 0x00, we must
         * allocate space for one extra output int. */
<span class="fc bfc" id="L4053" title="All 4 branches covered.">        for (j=keep; j &lt; a.length &amp;&amp; a[j] == 0; j++)</span>
            ;
<span class="fc bfc" id="L4055" title="All 2 branches covered.">        int extraInt = (j == a.length ? 1 : 0);</span>
<span class="fc" id="L4056">        int result[] = new int[a.length - keep + extraInt];</span>

        /* Copy one's complement of input into output, leaving extra
         * int (if it exists) == 0x00 */
<span class="fc bfc" id="L4060" title="All 2 branches covered.">        for (int i = keep; i &lt; a.length; i++)</span>
<span class="fc" id="L4061">            result[i - keep + extraInt] = ~a[i];</span>

        // Add one to one's complement to generate two's complement
<span class="fc bfc" id="L4064" title="All 2 branches covered.">        for (int i=result.length-1; ++result[i] == 0; i--)</span>
            ;

<span class="fc" id="L4067">        return result;</span>
    }

    /*
     * The following two arrays are used for fast String conversions.  Both
     * are indexed by radix.  The first is the number of digits of the given
     * radix that can fit in a Java long without &quot;going negative&quot;, i.e., the
     * highest integer n such that radix**n &lt; 2**63.  The second is the
     * &quot;long radix&quot; that tears each number into &quot;long digits&quot;, each of which
     * consists of the number of digits in the corresponding element in
     * digitsPerLong (longRadix[i] = i**digitPerLong[i]).  Both arrays have
     * nonsense values in their 0 and 1 elements, as radixes 0 and 1 are not
     * used.
     */
<span class="fc" id="L4081">    private static int digitsPerLong[] = {0, 0,</span>
        62, 39, 31, 27, 24, 22, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14,
        14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12};

<span class="fc" id="L4085">    private static BigInteger longRadix[] = {null, null,</span>
<span class="fc" id="L4086">        valueOf(0x4000000000000000L), valueOf(0x383d9170b85ff80bL),</span>
<span class="fc" id="L4087">        valueOf(0x4000000000000000L), valueOf(0x6765c793fa10079dL),</span>
<span class="fc" id="L4088">        valueOf(0x41c21cb8e1000000L), valueOf(0x3642798750226111L),</span>
<span class="fc" id="L4089">        valueOf(0x1000000000000000L), valueOf(0x12bf307ae81ffd59L),</span>
<span class="fc" id="L4090">        valueOf( 0xde0b6b3a7640000L), valueOf(0x4d28cb56c33fa539L),</span>
<span class="fc" id="L4091">        valueOf(0x1eca170c00000000L), valueOf(0x780c7372621bd74dL),</span>
<span class="fc" id="L4092">        valueOf(0x1e39a5057d810000L), valueOf(0x5b27ac993df97701L),</span>
<span class="fc" id="L4093">        valueOf(0x1000000000000000L), valueOf(0x27b95e997e21d9f1L),</span>
<span class="fc" id="L4094">        valueOf(0x5da0e1e53c5c8000L), valueOf( 0xb16a458ef403f19L),</span>
<span class="fc" id="L4095">        valueOf(0x16bcc41e90000000L), valueOf(0x2d04b7fdd9c0ef49L),</span>
<span class="fc" id="L4096">        valueOf(0x5658597bcaa24000L), valueOf( 0x6feb266931a75b7L),</span>
<span class="fc" id="L4097">        valueOf( 0xc29e98000000000L), valueOf(0x14adf4b7320334b9L),</span>
<span class="fc" id="L4098">        valueOf(0x226ed36478bfa000L), valueOf(0x383d9170b85ff80bL),</span>
<span class="fc" id="L4099">        valueOf(0x5a3c23e39c000000L), valueOf( 0x4e900abb53e6b71L),</span>
<span class="fc" id="L4100">        valueOf( 0x7600ec618141000L), valueOf( 0xaee5720ee830681L),</span>
<span class="fc" id="L4101">        valueOf(0x1000000000000000L), valueOf(0x172588ad4f5f0981L),</span>
<span class="fc" id="L4102">        valueOf(0x211e44f7d02c1000L), valueOf(0x2ee56725f06e5c71L),</span>
<span class="fc" id="L4103">        valueOf(0x41c21cb8e1000000L)};</span>

    /*
     * These two arrays are the integer analogue of above.
     */
<span class="fc" id="L4108">    private static int digitsPerInt[] = {0, 0, 30, 19, 15, 13, 11,</span>
        11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5};

<span class="fc" id="L4112">    private static int intRadix[] = {0, 0,</span>
        0x40000000, 0x4546b3db, 0x40000000, 0x48c27395, 0x159fd800,
        0x75db9c97, 0x40000000, 0x17179149, 0x3b9aca00, 0xcc6db61,
        0x19a10000, 0x309f1021, 0x57f6c100, 0xa2f1b6f,  0x10000000,
        0x18754571, 0x247dbc80, 0x3547667b, 0x4c4b4000, 0x6b5a6e1d,
        0x6c20a40,  0x8d2d931,  0xb640000,  0xe8d4a51,  0x1269ae40,
        0x17179149, 0x1cb91000, 0x23744899, 0x2b73a840, 0x34e63b41,
        0x40000000, 0x4cfa3cc1, 0x5c13d840, 0x6d91b519, 0x39aa400
    };

    /**
     * These routines provide access to the two's complement representation
     * of BigIntegers.
     */

    /**
     * Returns the length of the two's complement representation in ints,
     * including space for at least one sign bit.
     */
    private int intLength() {
<span class="fc" id="L4132">        return (bitLength() &gt;&gt;&gt; 5) + 1;</span>
    }

    /* Returns sign bit */
    private int signBit() {
<span class="nc bnc" id="L4137" title="All 2 branches missed.">        return signum &lt; 0 ? 1 : 0;</span>
    }

    /* Returns an int of sign bits */
    private int signInt() {
<span class="fc bfc" id="L4142" title="All 2 branches covered.">        return signum &lt; 0 ? -1 : 0;</span>
    }

    /**
     * Returns the specified int of the little-endian two's complement
     * representation (int 0 is the least significant).  The int number can
     * be arbitrarily high (values are logically preceded by infinitely many
     * sign ints).
     */
    private int getInt(int n) {
<span class="pc bpc" id="L4152" title="1 of 2 branches missed.">        if (n &lt; 0)</span>
<span class="nc" id="L4153">            return 0;</span>
<span class="fc bfc" id="L4154" title="All 2 branches covered.">        if (n &gt;= mag.length)</span>
<span class="fc" id="L4155">            return signInt();</span>

<span class="fc" id="L4157">        int magInt = mag[mag.length-n-1];</span>

<span class="fc bfc" id="L4159" title="All 2 branches covered.">        return (signum &gt;= 0 ? magInt :</span>
<span class="fc bfc" id="L4160" title="All 2 branches covered.">                (n &lt;= firstNonzeroIntNum() ? -magInt : ~magInt));</span>
    }

    /**
     * Returns the index of the int that contains the first nonzero int in the
     * little-endian binary representation of the magnitude (int 0 is the
     * least significant). If the magnitude is zero, return value is undefined.
     */
    private int firstNonzeroIntNum() {
<span class="fc" id="L4169">        int fn = firstNonzeroIntNum - 2;</span>
<span class="fc bfc" id="L4170" title="All 2 branches covered.">        if (fn == -2) { // firstNonzeroIntNum not initialized yet</span>
<span class="fc" id="L4171">            fn = 0;</span>

            // Search for the first nonzero int
            int i;
<span class="fc" id="L4175">            int mlen = mag.length;</span>
<span class="pc bpc" id="L4176" title="1 of 4 branches missed.">            for (i = mlen - 1; i &gt;= 0 &amp;&amp; mag[i] == 0; i--)</span>
                ;
<span class="fc" id="L4178">            fn = mlen - i - 1;</span>
<span class="fc" id="L4179">            firstNonzeroIntNum = fn + 2; // offset by two to initialize</span>
        }
<span class="fc" id="L4181">        return fn;</span>
    }

    /** use serialVersionUID from JDK 1.1. for interoperability */
    private static final long serialVersionUID = -8287574255936472291L;

    /**
     * Serializable fields for BigInteger.
     *
     * @serialField signum  int
     *              signum of this BigInteger.
     * @serialField magnitude int[]
     *              magnitude array of this BigInteger.
     * @serialField bitCount  int
     *              number of bits in this BigInteger
     * @serialField bitLength int
     *              the number of bits in the minimal two's-complement
     *              representation of this BigInteger
     * @serialField lowestSetBit int
     *              lowest set bit in the twos complement representation
     */
<span class="fc" id="L4202">    private static final ObjectStreamField[] serialPersistentFields = {</span>
        new ObjectStreamField(&quot;signum&quot;, Integer.TYPE),
        new ObjectStreamField(&quot;magnitude&quot;, byte[].class),
        new ObjectStreamField(&quot;bitCount&quot;, Integer.TYPE),
        new ObjectStreamField(&quot;bitLength&quot;, Integer.TYPE),
        new ObjectStreamField(&quot;firstNonzeroByteNum&quot;, Integer.TYPE),
        new ObjectStreamField(&quot;lowestSetBit&quot;, Integer.TYPE)
        };

    /**
     * Reconstitute the {@code BigInteger} instance from a stream (that is,
     * deserialize it). The magnitude is read in as an array of bytes
     * for historical reasons, but it is converted to an array of ints
     * and the byte array is discarded.
     * Note:
     * The current convention is to initialize the cache fields, bitCount,
     * bitLength and lowestSetBit, to 0 rather than some other marker value.
     * Therefore, no explicit action to set these fields needs to be taken in
     * readObject because those fields already have a 0 value be default since
     * defaultReadObject is not being used.
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        /*
         * In order to maintain compatibility with previous serialized forms,
         * the magnitude of a BigInteger is serialized as an array of bytes.
         * The magnitude field is used as a temporary store for the byte array
         * that is deserialized. The cached computation fields should be
         * transient but are serialized for compatibility reasons.
         */

        // prepare to read the alternate persistent fields
<span class="fc" id="L4234">        ObjectInputStream.GetField fields = s.readFields();</span>

        // Read the alternate persistent fields that we care about
<span class="fc" id="L4237">        int sign = fields.get(&quot;signum&quot;, -2);</span>
<span class="fc" id="L4238">        byte[] magnitude = (byte[])fields.get(&quot;magnitude&quot;, null);</span>

        // Validate signum
<span class="pc bpc" id="L4241" title="2 of 4 branches missed.">        if (sign &lt; -1 || sign &gt; 1) {</span>
<span class="nc" id="L4242">            String message = &quot;BigInteger: Invalid signum value&quot;;</span>
<span class="nc bnc" id="L4243" title="All 2 branches missed.">            if (fields.defaulted(&quot;signum&quot;))</span>
<span class="nc" id="L4244">                message = &quot;BigInteger: Signum not present in stream&quot;;</span>
<span class="nc" id="L4245">            throw new java.io.StreamCorruptedException(message);</span>
        }
<span class="fc" id="L4247">        int[] mag = stripLeadingZeroBytes(magnitude);</span>
<span class="pc bpc" id="L4248" title="1 of 6 branches missed.">        if ((mag.length == 0) != (sign == 0)) {</span>
<span class="nc" id="L4249">            String message = &quot;BigInteger: signum-magnitude mismatch&quot;;</span>
<span class="nc bnc" id="L4250" title="All 2 branches missed.">            if (fields.defaulted(&quot;magnitude&quot;))</span>
<span class="nc" id="L4251">                message = &quot;BigInteger: Magnitude not present in stream&quot;;</span>
<span class="nc" id="L4252">            throw new java.io.StreamCorruptedException(message);</span>
        }

        // Commit final fields via Unsafe
<span class="fc" id="L4256">        UnsafeHolder.putSign(this, sign);</span>

        // Calculate mag field from magnitude and discard magnitude
<span class="fc" id="L4259">        UnsafeHolder.putMag(this, mag);</span>
<span class="pc bpc" id="L4260" title="1 of 2 branches missed.">        if (mag.length &gt;= MAX_MAG_LENGTH) {</span>
            try {
<span class="nc" id="L4262">                checkRange();</span>
<span class="nc" id="L4263">            } catch (ArithmeticException e) {</span>
<span class="nc" id="L4264">                throw new java.io.StreamCorruptedException(&quot;BigInteger: Out of the supported range&quot;);</span>
<span class="nc" id="L4265">            }</span>
        }
<span class="fc" id="L4267">    }</span>

    // Support for resetting final fields while deserializing
<span class="nc" id="L4270">    private static class UnsafeHolder {</span>
        private static final sun.misc.Unsafe unsafe;
        private static final long signumOffset;
        private static final long magOffset;
        static {
            try {
<span class="fc" id="L4276">                unsafe = sun.misc.Unsafe.getUnsafe();</span>
<span class="fc" id="L4277">                signumOffset = unsafe.objectFieldOffset</span>
<span class="fc" id="L4278">                    (BigInteger.class.getDeclaredField(&quot;signum&quot;));</span>
<span class="fc" id="L4279">                magOffset = unsafe.objectFieldOffset</span>
<span class="fc" id="L4280">                    (BigInteger.class.getDeclaredField(&quot;mag&quot;));</span>
<span class="nc" id="L4281">            } catch (Exception ex) {</span>
<span class="nc" id="L4282">                throw new ExceptionInInitializerError(ex);</span>
<span class="fc" id="L4283">            }</span>
<span class="fc" id="L4284">        }</span>

        static void putSign(BigInteger bi, int sign) {
<span class="fc" id="L4287">            unsafe.putIntVolatile(bi, signumOffset, sign);</span>
<span class="fc" id="L4288">        }</span>

        static void putMag(BigInteger bi, int[] magnitude) {
<span class="fc" id="L4291">            unsafe.putObjectVolatile(bi, magOffset, magnitude);</span>
<span class="fc" id="L4292">        }</span>
    }

    /**
     * Save the {@code BigInteger} instance to a stream.
     * The magnitude of a BigInteger is serialized as a byte array for
     * historical reasons.
     *
     * @serialData two necessary fields are written as well as obsolete
     *             fields for compatibility with older versions.
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
        // set the values of the Serializable fields
<span class="fc" id="L4305">        ObjectOutputStream.PutField fields = s.putFields();</span>
<span class="fc" id="L4306">        fields.put(&quot;signum&quot;, signum);</span>
<span class="fc" id="L4307">        fields.put(&quot;magnitude&quot;, magSerializedForm());</span>
        // The values written for cached fields are compatible with older
        // versions, but are ignored in readObject so don't otherwise matter.
<span class="fc" id="L4310">        fields.put(&quot;bitCount&quot;, -1);</span>
<span class="fc" id="L4311">        fields.put(&quot;bitLength&quot;, -1);</span>
<span class="fc" id="L4312">        fields.put(&quot;lowestSetBit&quot;, -2);</span>
<span class="fc" id="L4313">        fields.put(&quot;firstNonzeroByteNum&quot;, -2);</span>

        // save them
<span class="fc" id="L4316">        s.writeFields();</span>
<span class="fc" id="L4317">}</span>

    /**
     * Returns the mag array as an array of bytes.
     */
    private byte[] magSerializedForm() {
<span class="fc" id="L4323">        int len = mag.length;</span>

<span class="fc bfc" id="L4325" title="All 2 branches covered.">        int bitLen = (len == 0 ? 0 : ((len - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]));</span>
<span class="fc" id="L4326">        int byteLen = (bitLen + 7) &gt;&gt;&gt; 3;</span>
<span class="fc" id="L4327">        byte[] result = new byte[byteLen];</span>

<span class="fc" id="L4329">        for (int i = byteLen - 1, bytesCopied = 4, intIndex = len - 1, nextInt = 0;</span>
<span class="fc bfc" id="L4330" title="All 2 branches covered.">             i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L4331" title="All 2 branches covered.">            if (bytesCopied == 4) {</span>
<span class="fc" id="L4332">                nextInt = mag[intIndex--];</span>
<span class="fc" id="L4333">                bytesCopied = 1;</span>
            } else {
<span class="fc" id="L4335">                nextInt &gt;&gt;&gt;= 8;</span>
<span class="fc" id="L4336">                bytesCopied++;</span>
            }
<span class="fc" id="L4338">            result[i] = (byte)nextInt;</span>
        }
<span class="fc" id="L4340">        return result;</span>
    }

    /**
     * Converts this {@code BigInteger} to a {@code long}, checking
     * for lost information.  If the value of this {@code BigInteger}
     * is out of the range of the {@code long} type, then an
     * {@code ArithmeticException} is thrown.
     *
     * @return this {@code BigInteger} converted to a {@code long}.
     * @throws ArithmeticException if the value of {@code this} will
     * not exactly fit in a {@code long}.
     * @see BigInteger#longValue
     * @since  1.8
     */
    public long longValueExact() {
<span class="nc bnc" id="L4356" title="All 4 branches missed.">        if (mag.length &lt;= 2 &amp;&amp; bitLength() &lt;= 63)</span>
<span class="nc" id="L4357">            return longValue();</span>
        else
<span class="nc" id="L4359">            throw new ArithmeticException(&quot;BigInteger out of long range&quot;);</span>
    }

    /**
     * Converts this {@code BigInteger} to an {@code int}, checking
     * for lost information.  If the value of this {@code BigInteger}
     * is out of the range of the {@code int} type, then an
     * {@code ArithmeticException} is thrown.
     *
     * @return this {@code BigInteger} converted to an {@code int}.
     * @throws ArithmeticException if the value of {@code this} will
     * not exactly fit in a {@code int}.
     * @see BigInteger#intValue
     * @since  1.8
     */
    public int intValueExact() {
<span class="nc bnc" id="L4375" title="All 4 branches missed.">        if (mag.length &lt;= 1 &amp;&amp; bitLength() &lt;= 31)</span>
<span class="nc" id="L4376">            return intValue();</span>
        else
<span class="nc" id="L4378">            throw new ArithmeticException(&quot;BigInteger out of int range&quot;);</span>
    }

    /**
     * Converts this {@code BigInteger} to a {@code short}, checking
     * for lost information.  If the value of this {@code BigInteger}
     * is out of the range of the {@code short} type, then an
     * {@code ArithmeticException} is thrown.
     *
     * @return this {@code BigInteger} converted to a {@code short}.
     * @throws ArithmeticException if the value of {@code this} will
     * not exactly fit in a {@code short}.
     * @see BigInteger#shortValue
     * @since  1.8
     */
    public short shortValueExact() {
<span class="nc bnc" id="L4394" title="All 4 branches missed.">        if (mag.length &lt;= 1 &amp;&amp; bitLength() &lt;= 31) {</span>
<span class="nc" id="L4395">            int value = intValue();</span>
<span class="nc bnc" id="L4396" title="All 4 branches missed.">            if (value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE)</span>
<span class="nc" id="L4397">                return shortValue();</span>
        }
<span class="nc" id="L4399">        throw new ArithmeticException(&quot;BigInteger out of short range&quot;);</span>
    }

    /**
     * Converts this {@code BigInteger} to a {@code byte}, checking
     * for lost information.  If the value of this {@code BigInteger}
     * is out of the range of the {@code byte} type, then an
     * {@code ArithmeticException} is thrown.
     *
     * @return this {@code BigInteger} converted to a {@code byte}.
     * @throws ArithmeticException if the value of {@code this} will
     * not exactly fit in a {@code byte}.
     * @see BigInteger#byteValue
     * @since  1.8
     */
    public byte byteValueExact() {
<span class="nc bnc" id="L4415" title="All 4 branches missed.">        if (mag.length &lt;= 1 &amp;&amp; bitLength() &lt;= 31) {</span>
<span class="nc" id="L4416">            int value = intValue();</span>
<span class="nc bnc" id="L4417" title="All 4 branches missed.">            if (value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE)</span>
<span class="nc" id="L4418">                return byteValue();</span>
        }
<span class="nc" id="L4420">        throw new ArithmeticException(&quot;BigInteger out of byte range&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>