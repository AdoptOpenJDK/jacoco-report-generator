<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ByteInterleavedRaster.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.awt.image</a> &gt; <span class="el_source">ByteInterleavedRaster.java</span></div><h1>ByteInterleavedRaster.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.image;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.awt.image.RasterFormatException;
import java.awt.image.SampleModel;
import java.awt.image.ComponentSampleModel;
import java.awt.image.PixelInterleavedSampleModel;
import java.awt.image.SinglePixelPackedSampleModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.Rectangle;
import java.awt.Point;

/**
 * This class defines a Raster with pixels consisting of one or more
 * 8-bit data elements stored in close proximity to each other in a
 * single byte array.
 * &lt;p&gt;
 * The bit precision per data element is that of the data type (that
 * is, the bit precision for this Raster is 8).  There is only one
 * pixel stride and one scanline stride for all bands.  This type of
 * Raster can be used with a ComponentColorModel if there are multiple
 * bands, or an IndexColorModel if there is only one band.
 *
 */
public class ByteInterleavedRaster extends ByteComponentRaster {

    /** True if the data offsets range from 0 to (pixelStride - 1) in order. */
    boolean inOrder;

    /**
     * The DataBuffer offset, minus sampleModelTranslateX*pixelStride,
     * minus sampleModelTranslateY*scanlineStride, used to calculate
     * pixel offsets.
     */
    int dbOffset;
    int dbOffsetPacked;

    /** True if a SinglePixelPackedSampleModel is being used. */
<span class="nc" id="L65">    boolean packed = false;</span>

    /** If packed == true, the SampleModel's bit masks. */
    int[] bitMasks;

    /** If packed == true, the SampleModel's bit offsets. */
    int[] bitOffsets;

    /** A cached copy of minX + width for use in bounds checks. */
    private int maxX;

    /** A cached copy of minY + height for use in bounds checks. */
    private int maxY;

    /**
     * Constructs a ByteInterleavedRaster with the given SampleModel.
     * The Raster's upper left corner is origin and it is the same
     * size as the SampleModel.  A DataBuffer large enough to describe the
     * Raster is automatically created.  SampleModel must be of type
     * SinglePixelPackedSampleModel or InterleavedSampleModel.
     * @param sampleModel     The SampleModel that specifies the layout.
     * @param origin          The Point that specified the origin.
     */
    public ByteInterleavedRaster(SampleModel sampleModel, Point origin) {
<span class="nc" id="L89">        this(sampleModel,</span>
<span class="nc" id="L90">             sampleModel.createDataBuffer(),</span>
             new Rectangle(origin.x,
                           origin.y,
<span class="nc" id="L93">                           sampleModel.getWidth(),</span>
<span class="nc" id="L94">                           sampleModel.getHeight()),</span>
             origin,
             null);
<span class="nc" id="L97">    }</span>

    /**
     * Constructs a ByteInterleavedRaster with the given SampleModel
     * and DataBuffer.  The Raster's upper left corner is origin and
     * it is the same size as the SampleModel.  The DataBuffer is not
     * initialized and must be a DataBufferByte compatible with SampleModel.
     * SampleModel must be of type SinglePixelPackedSampleModel
     * or InterleavedSampleModel.
     * @param sampleModel     The SampleModel that specifies the layout.
     * @param dataBuffer      The DataBufferShort that contains the image data.
     * @param origin          The Point that specifies the origin.
     */
    public ByteInterleavedRaster(SampleModel sampleModel,
                                  DataBuffer dataBuffer,
                                  Point origin) {
<span class="nc" id="L113">        this(sampleModel,</span>
             dataBuffer,
             new Rectangle(origin.x,
                           origin.y,
<span class="nc" id="L117">                           sampleModel.getWidth(),</span>
<span class="nc" id="L118">                           sampleModel.getHeight()),</span>
             origin,
             null);
<span class="nc" id="L121">    }</span>

    /*** Analyzes a ComponentSampleModel to determine if it can function
     * as a PixelInterleavedSampleModel.  In order to do so, it must use
     * only bank 0 of its DataBuffer, and the data offsets must span a range
     * of less than pixelStride.
     *
     * &lt;p&gt; These properties are trivially true for a 1-banded SampleModel.
     */
    private boolean isInterleaved(ComponentSampleModel sm) {
        // Analyze ComponentSampleModel to determine if it has the
        // properties of a PixelInterleavedSampleModel

<span class="nc" id="L134">        int numBands = sampleModel.getNumBands();</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (numBands == 1) {</span>
<span class="nc" id="L136">            return true;</span>
        }

        // Determine banks used
<span class="nc" id="L140">        int[] bankIndices = sm.getBankIndices();</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        for (int i = 0; i &lt; numBands; i++) {</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (bankIndices[i] != 0) {</span>
<span class="nc" id="L143">                return false;</span>
            }
        }

        // Determine range of band offsets
<span class="nc" id="L148">        int[] bandOffsets = sm.getBandOffsets();</span>
<span class="nc" id="L149">        int minOffset = bandOffsets[0];</span>
<span class="nc" id="L150">        int maxOffset = minOffset;</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        for (int i = 1; i &lt; numBands; i++) {</span>
<span class="nc" id="L152">            int offset = bandOffsets[i];</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (offset &lt; minOffset) {</span>
<span class="nc" id="L154">                minOffset = offset;</span>
            }
<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (offset &gt; maxOffset) {</span>
<span class="nc" id="L157">                maxOffset = offset;</span>
            }
        }
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (maxOffset - minOffset &gt;= sm.getPixelStride()) {</span>
<span class="nc" id="L161">            return false;</span>
        }

<span class="nc" id="L164">        return true;</span>
    }

    /**
     * Constructs a ByteInterleavedRaster with the given SampleModel,
     * DataBuffer, and parent.  DataBuffer must be a DataBufferByte and
     * SampleModel must be of type SinglePixelPackedSampleModel
     * or InterleavedSampleModel.
     * When translated into the base Raster's
     * coordinate system, aRegion must be contained by the base Raster.
     * Origin is the coordinate in the new Raster's coordinate system of
     * the origin of the base Raster.  (The base Raster is the Raster's
     * ancestor which has no parent.)
     *
     * Note that this constructor should generally be called by other
     * constructors or create methods, it should not be used directly.
     * @param sampleModel     The SampleModel that specifies the layout.
     * @param dataBuffer      The DataBufferShort that contains the image data.
     * @param aRegion         The Rectangle that specifies the image area.
     * @param origin          The Point that specifies the origin.
     * @param parent          The parent (if any) of this raster.
     */
    public ByteInterleavedRaster(SampleModel sampleModel,
                                  DataBuffer dataBuffer,
                                  Rectangle aRegion,
                                  Point origin,
                                  ByteInterleavedRaster parent) {
<span class="nc" id="L191">        super(sampleModel, dataBuffer, aRegion, origin, parent);</span>
<span class="nc" id="L192">        this.maxX = minX + width;</span>
<span class="nc" id="L193">        this.maxY = minY + height;</span>

<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (!(dataBuffer instanceof DataBufferByte)) {</span>
<span class="nc" id="L196">            throw new RasterFormatException(&quot;ByteInterleavedRasters must have &quot; +</span>
                                            &quot;byte DataBuffers&quot;);
        }

<span class="nc" id="L200">        DataBufferByte dbb = (DataBufferByte)dataBuffer;</span>
<span class="nc" id="L201">        this.data = stealData(dbb, 0);</span>

<span class="nc" id="L203">        int xOffset = aRegion.x - origin.x;</span>
<span class="nc" id="L204">        int yOffset = aRegion.y - origin.y;</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">        if (sampleModel instanceof PixelInterleavedSampleModel ||</span>
            (sampleModel instanceof ComponentSampleModel &amp;&amp;
<span class="nc bnc" id="L207" title="All 2 branches missed.">             isInterleaved((ComponentSampleModel)sampleModel))) {</span>
<span class="nc" id="L208">            ComponentSampleModel csm = (ComponentSampleModel)sampleModel;</span>
<span class="nc" id="L209">            this.scanlineStride = csm.getScanlineStride();</span>
<span class="nc" id="L210">            this.pixelStride = csm.getPixelStride();</span>
<span class="nc" id="L211">            this.dataOffsets = csm.getBandOffsets();</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            for (int i = 0; i &lt; getNumDataElements(); i++) {</span>
<span class="nc" id="L213">                dataOffsets[i] += xOffset*pixelStride+yOffset*scanlineStride;</span>
            }
<span class="nc bnc" id="L215" title="All 2 branches missed.">        } else if (sampleModel instanceof SinglePixelPackedSampleModel) {</span>
<span class="nc" id="L216">            SinglePixelPackedSampleModel sppsm =</span>
                    (SinglePixelPackedSampleModel)sampleModel;
<span class="nc" id="L218">            this.packed = true;</span>
<span class="nc" id="L219">            this.bitMasks = sppsm.getBitMasks();</span>
<span class="nc" id="L220">            this.bitOffsets = sppsm.getBitOffsets();</span>
<span class="nc" id="L221">            this.scanlineStride = sppsm.getScanlineStride();</span>
<span class="nc" id="L222">            this.pixelStride = 1;</span>
<span class="nc" id="L223">            this.dataOffsets = new int[1];</span>
<span class="nc" id="L224">            this.dataOffsets[0] = dbb.getOffset();</span>
<span class="nc" id="L225">            dataOffsets[0] += xOffset*pixelStride+yOffset*scanlineStride;</span>
<span class="nc" id="L226">        } else {</span>
<span class="nc" id="L227">            throw new RasterFormatException(&quot;ByteInterleavedRasters must &quot; +</span>
              &quot;have PixelInterleavedSampleModel, SinglePixelPackedSampleModel&quot;+
              &quot; or interleaved ComponentSampleModel.  Sample model is &quot; +
              sampleModel);
        }
<span class="nc" id="L232">        this.bandOffset = this.dataOffsets[0];</span>

<span class="nc" id="L234">        this.dbOffsetPacked = dataBuffer.getOffset() -</span>
            sampleModelTranslateY*scanlineStride -
            sampleModelTranslateX*pixelStride;
<span class="nc" id="L237">        this.dbOffset = dbOffsetPacked -</span>
            (xOffset*pixelStride+yOffset*scanlineStride);

        // Set inOrder to true if the data elements are in order and
        // have no gaps between them
<span class="nc" id="L242">        this.inOrder = false;</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (numDataElements == pixelStride) {</span>
<span class="nc" id="L244">            inOrder = true;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">            for (int i = 1; i &lt; numDataElements; i++) {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                if (dataOffsets[i] - dataOffsets[0] != i) {</span>
<span class="nc" id="L247">                    inOrder = false;</span>
<span class="nc" id="L248">                    break;</span>
                }
            }
        }

<span class="nc" id="L253">        verify();</span>
<span class="nc" id="L254">    }</span>

    /**
     * Returns a copy of the data offsets array. For each band the data offset
     * is the index into the band's data array, of the first sample of the
     * band.
     */
    public int[] getDataOffsets() {
<span class="nc" id="L262">        return (int[]) dataOffsets.clone();</span>
    }

    /**
     * Returns the data offset for the specified band.  The data offset
     * is the index into the data array
     * in which the first sample of the first scanline is stored.
     * @param band  The band whose offset is returned.
     */
    public int getDataOffset(int band) {
<span class="nc" id="L272">        return dataOffsets[band];</span>
    }

    /**
     * Returns the scanline stride -- the number of data array elements between
     * a given sample and the sample in the same column of the next row in the
     * same band.
     */
    public int getScanlineStride() {
<span class="nc" id="L281">        return scanlineStride;</span>
    }

    /**
     * Returns pixel stride -- the number of data array elements between two
     * samples for the same band on the same scanline.
     */
    public int getPixelStride() {
<span class="nc" id="L289">        return pixelStride;</span>
    }

    /**
     * Returns a reference to the data array.
     */
    public byte[] getDataStorage() {
<span class="nc" id="L296">        return data;</span>
    }

    /**
     * Returns the data elements for all bands at the specified
     * location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinate is out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param outData  An object reference to an array of type defined by
     *                 getTransferType() and length getNumDataElements().
     *                 If null an array of appropriate type and size will be
     *                 allocated.
     * @return         An object reference to an array of type defined by
     *                 getTransferType() with the request pixel data.
     */
    public Object getDataElements(int x, int y, Object obj) {
<span class="nc bnc" id="L316" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x &gt;= this.maxX) || (y &gt;= this.maxY)) {
<span class="nc" id="L318">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        byte outData[];
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L323">            outData = new byte[numDataElements];</span>
        } else {
<span class="nc" id="L325">            outData = (byte[])obj;</span>
        }
<span class="nc" id="L327">        int off = (y-minY)*scanlineStride +</span>
                  (x-minX)*pixelStride;

<span class="nc bnc" id="L330" title="All 2 branches missed.">        for (int band = 0; band &lt; numDataElements; band++) {</span>
<span class="nc" id="L331">            outData[band] = data[dataOffsets[band] + off];</span>
        }

<span class="nc" id="L334">        return outData;</span>
    }

    /**
     * Returns an array of data elements from the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * &lt;pre&gt;
     *       byte[] bandData = (byte[])raster.getDataElements(x, y, w, h, null);
     *       int numDataElements = raster.getNumDataElements();
     *       byte[] pixel = new byte[numDataElements];
     *       // To find a data element at location (x2, y2)
     *       System.arraycopy(bandData, ((y2-y)*w + (x2-x))*numDataElements,
     *                        pixel, 0, numDataElements);
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the pixel rectangle.
     * @param height   Height of the pixel rectangle.
     * @param outData  An object reference to an array of type defined by
     *                 getTransferType() and length w*h*getNumDataElements().
     *                 If null an array of appropriate type and size will be
     *                 allocated.
     * @return         An object reference to an array of type defined by
     *                 getTransferType() with the request pixel data.
     */
    public Object getDataElements(int x, int y, int w, int h, Object obj) {
<span class="nc" id="L364">        return getByteData(x, y, w, h, (byte[])obj);</span>
    }

    /**
     * Returns a byte array of data elements from the specified rectangular
     * region for the specified band.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * &lt;pre&gt;
     *       byte[] bandData = raster.getByteData(x, y, w, h, null);
     *       // To find the data element at location (x2, y2)
     *       byte bandElement = bandData[((y2-y)*w + (x2-x))];
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the pixel rectangle.
     * @param height   Height of the pixel rectangle.
     * @param band     The band to return.
     * @param outData  If non-null, data elements for all bands
     *                 at the specified location are returned in this array.
     * @return         Data array with data elements for all bands.
     */
    public byte[] getByteData(int x, int y, int w, int h,
                              int band, byte[] outData) {
        // Bounds check for 'band' will be performed automatically
<span class="nc bnc" id="L389" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L391">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (outData == null) {</span>
<span class="nc" id="L395">            outData = new byte[w*h];</span>
        }
<span class="nc" id="L397">        int yoff = (y-minY)*scanlineStride +</span>
                   (x-minX)*pixelStride + dataOffsets[band];
        int xoff;
<span class="nc" id="L400">        int off = 0;</span>
        int xstart;
        int ystart;

<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (pixelStride == 1) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (scanlineStride == w) {</span>
<span class="nc" id="L406">                System.arraycopy(data, yoff, outData, 0, w*h);</span>
            } else {
<span class="nc bnc" id="L408" title="All 2 branches missed.">                for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L409">                    System.arraycopy(data, yoff, outData, off, w);</span>
<span class="nc" id="L410">                    off += w;</span>
                }
            }
        } else {
<span class="nc bnc" id="L414" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L415">                xoff = yoff;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L417">                    outData[off++] = data[xoff];</span>
                }
            }
        }

<span class="nc" id="L422">        return outData;</span>
    }

    /**
     * Returns a byte array of data elements from the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * &lt;pre&gt;
     *       byte[] bandData = raster.getByteData(x, y, w, h, null);
     *       int numDataElements = raster.getnumDataElements();
     *       byte[] pixel = new byte[numDataElements];
     *       // To find a data element at location (x2, y2)
     *       System.arraycopy(bandData, ((y2-y)*w + (x2-x))*numDataElements,
     *                        pixel, 0, numDataElements);
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the pixel rectangle.
     * @param height   Height of the pixel rectangle.
     * @param outData  If non-null, data elements for all bands
     *                 at the specified location are returned in this array.
     * @return         Data array with data elements for all bands.
     */
    public byte[] getByteData(int x, int y, int w, int h, byte[] outData) {
<span class="nc bnc" id="L447" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L449">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (outData == null) {</span>
<span class="nc" id="L453">            outData = new byte[numDataElements*w*h];</span>
        }
<span class="nc" id="L455">        int yoff = (y-minY)*scanlineStride +</span>
                   (x-minX)*pixelStride;
        int xoff;
<span class="nc" id="L458">        int off = 0;</span>
        int xstart;
        int ystart;

<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (inOrder) {</span>
<span class="nc" id="L463">            yoff += dataOffsets[0];</span>
<span class="nc" id="L464">            int rowBytes = w*pixelStride;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            if (scanlineStride == rowBytes) {</span>
<span class="nc" id="L466">                System.arraycopy(data, yoff, outData, off, rowBytes*h);</span>
            } else {
<span class="nc bnc" id="L468" title="All 2 branches missed.">                for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L469">                    System.arraycopy(data, yoff, outData, off, rowBytes);</span>
<span class="nc" id="L470">                    off += rowBytes;</span>
                }
            }
<span class="nc bnc" id="L473" title="All 2 branches missed.">        } else if (numDataElements == 1) {</span>
<span class="nc" id="L474">            yoff += dataOffsets[0];</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L476">                xoff = yoff;</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L478">                    outData[off++] = data[xoff];</span>
                }
            }
<span class="nc bnc" id="L481" title="All 2 branches missed.">        } else if (numDataElements == 2) {</span>
<span class="nc" id="L482">            yoff += dataOffsets[0];</span>
<span class="nc" id="L483">            int d1 = dataOffsets[1] - dataOffsets[0];</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L485">                xoff = yoff;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L487">                    outData[off++] = data[xoff];</span>
<span class="nc" id="L488">                    outData[off++] = data[xoff + d1];</span>
                }
            }
<span class="nc bnc" id="L491" title="All 2 branches missed.">        } else if (numDataElements == 3) {</span>
<span class="nc" id="L492">            yoff += dataOffsets[0];</span>
<span class="nc" id="L493">            int d1 = dataOffsets[1] - dataOffsets[0];</span>
<span class="nc" id="L494">            int d2 = dataOffsets[2] - dataOffsets[0];</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L496">                xoff = yoff;</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L498">                    outData[off++] = data[xoff];</span>
<span class="nc" id="L499">                    outData[off++] = data[xoff + d1];</span>
<span class="nc" id="L500">                    outData[off++] = data[xoff + d2];</span>
                }
            }
<span class="nc bnc" id="L503" title="All 2 branches missed.">        } else if (numDataElements == 4) {</span>
<span class="nc" id="L504">            yoff += dataOffsets[0];</span>
<span class="nc" id="L505">            int d1 = dataOffsets[1] - dataOffsets[0];</span>
<span class="nc" id="L506">            int d2 = dataOffsets[2] - dataOffsets[0];</span>
<span class="nc" id="L507">            int d3 = dataOffsets[3] - dataOffsets[0];</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L509">                xoff = yoff;</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L511">                    outData[off++] = data[xoff];</span>
<span class="nc" id="L512">                    outData[off++] = data[xoff + d1];</span>
<span class="nc" id="L513">                    outData[off++] = data[xoff + d2];</span>
<span class="nc" id="L514">                    outData[off++] = data[xoff + d3];</span>
                }
            }
<span class="nc" id="L517">        } else {</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L519">                xoff = yoff;</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                    for (int c = 0; c &lt; numDataElements; c++) {</span>
<span class="nc" id="L522">                        outData[off++] = data[dataOffsets[c] + xoff];</span>
                    }
                }
            }
        }

<span class="nc" id="L528">        return outData;</span>
    }

    /**
     * Stores the data elements for all bands at the specified location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinate is out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param inData   An object reference to an array of type defined by
     *                 getTransferType() and length getNumDataElements()
     *                 containing the pixel data to place at x,y.
     */
    public void setDataElements(int x, int y, Object obj) {
<span class="nc bnc" id="L544" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x &gt;= this.maxX) || (y &gt;= this.maxY)) {
<span class="nc" id="L546">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L549">        byte inData[] = (byte[])obj;</span>
<span class="nc" id="L550">        int off = (y-minY)*scanlineStride +</span>
                  (x-minX)*pixelStride;

<span class="nc bnc" id="L553" title="All 2 branches missed.">        for (int i = 0; i &lt; numDataElements; i++) {</span>
<span class="nc" id="L554">            data[dataOffsets[i] + off] = inData[i];</span>
        }

<span class="nc" id="L557">        markDirty();</span>
<span class="nc" id="L558">    }</span>

    /**
     * Stores the Raster data at the specified location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * @param x          The X coordinate of the pixel location.
     * @param y          The Y coordinate of the pixel location.
     * @param inRaster   Raster of data to place at x,y location.
     */
    public void setDataElements(int x, int y, Raster inRaster) {
<span class="nc" id="L569">        int srcOffX = inRaster.getMinX();</span>
<span class="nc" id="L570">        int srcOffY = inRaster.getMinY();</span>
<span class="nc" id="L571">        int dstOffX = x + srcOffX;</span>
<span class="nc" id="L572">        int dstOffY = y + srcOffY;</span>
<span class="nc" id="L573">        int width  = inRaster.getWidth();</span>
<span class="nc" id="L574">        int height = inRaster.getHeight();</span>
<span class="nc bnc" id="L575" title="All 8 branches missed.">        if ((dstOffX &lt; this.minX) || (dstOffY &lt; this.minY) ||</span>
            (dstOffX + width &gt; this.maxX) || (dstOffY + height &gt; this.maxY)) {
<span class="nc" id="L577">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L581">        setDataElements(dstOffX, dstOffY, srcOffX, srcOffY,</span>
                        width, height, inRaster);
<span class="nc" id="L583">    }</span>

    /**
     * Stores the Raster data at the specified location.
     * @param dstX The absolute X coordinate of the destination pixel
     * that will receive a copy of the upper-left pixel of the
     * inRaster
     * @param dstY The absolute Y coordinate of the destination pixel
     * that will receive a copy of the upper-left pixel of the
     * inRaster
     * @param srcX The absolute X coordinate of the upper-left source
     * pixel that will be copied into this Raster
     * @param srcY The absolute Y coordinate of the upper-left source
     * pixel that will be copied into this Raster
     * @param width      The number of pixels to store horizontally
     * @param height     The number of pixels to store vertically
     * @param inRaster   Raster of data to place at x,y location.
     */
    private void setDataElements(int dstX, int dstY,
                                 int srcX, int srcY,
                                 int width, int height,
                                 Raster inRaster) {
        // Assume bounds checking has been performed previously
<span class="nc bnc" id="L606" title="All 4 branches missed.">        if (width &lt;= 0 || height &lt;= 0) {</span>
<span class="nc" id="L607">            return;</span>
        }

        // Write inRaster (minX, minY) to (dstX, dstY)

<span class="nc" id="L612">        int srcOffX = inRaster.getMinX();</span>
<span class="nc" id="L613">        int srcOffY = inRaster.getMinY();</span>
<span class="nc" id="L614">        Object tdata = null;</span>

<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (inRaster instanceof ByteInterleavedRaster) {</span>
<span class="nc" id="L617">            ByteInterleavedRaster bct = (ByteInterleavedRaster) inRaster;</span>
<span class="nc" id="L618">            byte[] bdata = bct.getDataStorage();</span>
            // copy whole scanlines
<span class="nc bnc" id="L620" title="All 6 branches missed.">            if (inOrder &amp;&amp; bct.inOrder &amp;&amp; pixelStride == bct.pixelStride) {</span>
<span class="nc" id="L621">                int toff = bct.getDataOffset(0);</span>
<span class="nc" id="L622">                int tss  = bct.getScanlineStride();</span>
<span class="nc" id="L623">                int tps  = bct.getPixelStride();</span>

<span class="nc" id="L625">                int srcOffset = toff +</span>
                    (srcY - srcOffY) * tss +
                    (srcX - srcOffX) * tps;
<span class="nc" id="L628">                int dstOffset = dataOffsets[0] +</span>
                    (dstY - minY) * scanlineStride +
                    (dstX - minX) * pixelStride;

<span class="nc" id="L632">                int nbytes = width*pixelStride;</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">                for (int tmpY=0; tmpY &lt; height; tmpY++) {</span>
<span class="nc" id="L634">                    System.arraycopy(bdata, srcOffset,</span>
                                     data, dstOffset, nbytes);
<span class="nc" id="L636">                    srcOffset += tss;</span>
<span class="nc" id="L637">                    dstOffset += scanlineStride;</span>
                }
<span class="nc" id="L639">                markDirty();</span>
<span class="nc" id="L640">                return;</span>
            }
        }

<span class="nc bnc" id="L644" title="All 2 branches missed.">        for (int startY=0; startY &lt; height; startY++) {</span>
            // Grab one scanline at a time
<span class="nc" id="L646">            tdata = inRaster.getDataElements(srcOffX, srcOffY+startY,</span>
                                             width, 1, tdata);
<span class="nc" id="L648">            setDataElements(dstX, dstY + startY, width, 1, tdata);</span>
        }
<span class="nc" id="L650">    }</span>

    /**
     * Stores an array of data elements into the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * for the nth band at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x))*numDataElements + n]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param inData   An object reference to an array of type defined by
     *                 getTransferType() and length w*h*getNumDataElements()
     *                 containing the pixel data to place between x,y and
     *                 x+h, y+h.
     */
    public void setDataElements(int x, int y, int w, int h, Object obj) {
<span class="nc" id="L675">        putByteData(x, y, w, h, (byte[])obj);</span>
<span class="nc" id="L676">    }</span>

    /**
     * Stores a byte array of data elements into the specified rectangular
     * region for the specified band.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x)) + n]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param band     The band to set.
     * @param inData   The data elements to be stored.
     */
    public void putByteData(int x, int y, int w, int h,
                            int band, byte[] inData) {
        // Bounds check for 'band' will be performed automatically
<span class="nc bnc" id="L699" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L701">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L704">        int yoff = (y-minY)*scanlineStride +</span>
                   (x-minX)*pixelStride + dataOffsets[band];
        int xoff;
<span class="nc" id="L707">        int off = 0;</span>
        int xstart;
        int ystart;

<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (pixelStride == 1) {</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">            if (scanlineStride == w) {</span>
<span class="nc" id="L713">                System.arraycopy(inData, 0, data, yoff, w*h);</span>
            }
            else {
<span class="nc bnc" id="L716" title="All 2 branches missed.">                for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L717">                    System.arraycopy(inData, off, data, yoff, w);</span>
<span class="nc" id="L718">                    off += w;</span>
                }
            }
        }
        else {
<span class="nc bnc" id="L723" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L724">                xoff = yoff;</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L726">                    data[xoff] = inData[off++];</span>
                }
            }
        }

<span class="nc" id="L731">        markDirty();</span>
<span class="nc" id="L732">    }</span>

    /**
     * Stores a byte array of data elements into the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * for the nth band at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x))*numDataElements + n]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param inData   The data elements to be stored.
     */
    public void putByteData(int x, int y, int w, int h, byte[] inData) {
<span class="nc bnc" id="L752" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L754">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L757">        int yoff = (y-minY)*scanlineStride +</span>
                   (x-minX)*pixelStride;

        int xoff;
<span class="nc" id="L761">        int off = 0;</span>
        int xstart;
        int ystart;

<span class="nc bnc" id="L765" title="All 2 branches missed.">        if (inOrder) {</span>
<span class="nc" id="L766">            yoff += dataOffsets[0];</span>
<span class="nc" id="L767">            int rowBytes = w*pixelStride;</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">            if (rowBytes == scanlineStride) {</span>
<span class="nc" id="L769">                System.arraycopy(inData, 0, data, yoff, rowBytes*h);</span>
            } else {
<span class="nc bnc" id="L771" title="All 2 branches missed.">                for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L772">                    System.arraycopy(inData, off, data, yoff, rowBytes);</span>
<span class="nc" id="L773">                    off += rowBytes;</span>
                }
            }
<span class="nc bnc" id="L776" title="All 2 branches missed.">        } else if (numDataElements == 1) {</span>
<span class="nc" id="L777">            yoff += dataOffsets[0];</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L779">                xoff = yoff;</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L781">                    data[xoff] = inData[off++];</span>
                }
            }
<span class="nc bnc" id="L784" title="All 2 branches missed.">        } else if (numDataElements == 2) {</span>
<span class="nc" id="L785">            yoff += dataOffsets[0];</span>
<span class="nc" id="L786">            int d1 = dataOffsets[1] - dataOffsets[0];</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L788">                xoff = yoff;</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L790">                    data[xoff] = inData[off++];</span>
<span class="nc" id="L791">                    data[xoff + d1] = inData[off++];</span>
                }
            }
<span class="nc bnc" id="L794" title="All 2 branches missed.">        } else if (numDataElements == 3) {</span>
<span class="nc" id="L795">            yoff += dataOffsets[0];</span>
<span class="nc" id="L796">            int d1 = dataOffsets[1] - dataOffsets[0];</span>
<span class="nc" id="L797">            int d2 = dataOffsets[2] - dataOffsets[0];</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L799">                xoff = yoff;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L801">                    data[xoff] = inData[off++];</span>
<span class="nc" id="L802">                    data[xoff + d1] = inData[off++];</span>
<span class="nc" id="L803">                    data[xoff + d2] = inData[off++];</span>
                }
            }
<span class="nc bnc" id="L806" title="All 2 branches missed.">        } else if (numDataElements == 4) {</span>
<span class="nc" id="L807">            yoff += dataOffsets[0];</span>
<span class="nc" id="L808">            int d1 = dataOffsets[1] - dataOffsets[0];</span>
<span class="nc" id="L809">            int d2 = dataOffsets[2] - dataOffsets[0];</span>
<span class="nc" id="L810">            int d3 = dataOffsets[3] - dataOffsets[0];</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L812">                xoff = yoff;</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L814">                    data[xoff] = inData[off++];</span>
<span class="nc" id="L815">                    data[xoff + d1] = inData[off++];</span>
<span class="nc" id="L816">                    data[xoff + d2] = inData[off++];</span>
<span class="nc" id="L817">                    data[xoff + d3] = inData[off++];</span>
                }
            }
<span class="nc" id="L820">        } else {</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L822">                xoff = yoff;</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">                    for (int c = 0; c &lt; numDataElements; c++) {</span>
<span class="nc" id="L825">                        data[dataOffsets[c] + xoff] = inData[off++];</span>
                    }
                }
            }
        }

<span class="nc" id="L831">        markDirty();</span>
<span class="nc" id="L832">    }</span>

    public int getSample(int x, int y, int b) {
<span class="nc bnc" id="L835" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x &gt;= this.maxX) || (y &gt;= this.maxY)) {
<span class="nc" id="L837">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc bnc" id="L840" title="All 2 branches missed.">        if (packed) {</span>
<span class="nc" id="L841">            int offset = y*scanlineStride + x + dbOffsetPacked;</span>
<span class="nc" id="L842">            byte sample = data[offset];</span>
<span class="nc" id="L843">            return (sample &amp; bitMasks[b]) &gt;&gt;&gt; bitOffsets[b];</span>
        } else {
<span class="nc" id="L845">            int offset = y*scanlineStride + x*pixelStride + dbOffset;</span>
<span class="nc" id="L846">            return data[offset + dataOffsets[b]] &amp; 0xff;</span>
        }
    }

    public void setSample(int x, int y, int b, int s) {
<span class="nc bnc" id="L851" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x &gt;= this.maxX) || (y &gt;= this.maxY)) {
<span class="nc" id="L853">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc bnc" id="L856" title="All 2 branches missed.">        if (packed) {</span>
<span class="nc" id="L857">            int offset = y*scanlineStride + x + dbOffsetPacked;</span>
<span class="nc" id="L858">            int bitMask = bitMasks[b];</span>

<span class="nc" id="L860">            byte value = data[offset];</span>
<span class="nc" id="L861">            value &amp;= ~bitMask;</span>
<span class="nc" id="L862">            value |= (s &lt;&lt; bitOffsets[b]) &amp; bitMask;</span>
<span class="nc" id="L863">            data[offset] = value;</span>
<span class="nc" id="L864">        } else {</span>
<span class="nc" id="L865">            int offset = y*scanlineStride + x*pixelStride + dbOffset;</span>
<span class="nc" id="L866">            data[offset + dataOffsets[b]] = (byte)s;</span>
        }

<span class="nc" id="L869">        markDirty();</span>
<span class="nc" id="L870">    }</span>

    public int[] getSamples(int x, int y, int w, int h, int b,
                            int[] iArray) {
<span class="nc bnc" id="L874" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L876">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        int samples[];
<span class="nc bnc" id="L880" title="All 2 branches missed.">        if (iArray != null) {</span>
<span class="nc" id="L881">            samples = iArray;</span>
        } else {
<span class="nc" id="L883">            samples = new int [w*h];</span>
        }

<span class="nc" id="L886">        int lineOffset = y*scanlineStride + x*pixelStride;</span>
<span class="nc" id="L887">        int dstOffset = 0;</span>

<span class="nc bnc" id="L889" title="All 2 branches missed.">        if (packed) {</span>
<span class="nc" id="L890">            lineOffset += dbOffsetPacked;</span>
<span class="nc" id="L891">            int bitMask = bitMasks[b];</span>
<span class="nc" id="L892">            int bitOffset = bitOffsets[b];</span>

<span class="nc bnc" id="L894" title="All 2 branches missed.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L895">                int sampleOffset = lineOffset;</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">                for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L897">                    int value = data[sampleOffset++];</span>
<span class="nc" id="L898">                    samples[dstOffset++] = ((value &amp; bitMask) &gt;&gt;&gt; bitOffset);</span>
                }
<span class="nc" id="L900">                lineOffset += scanlineStride;</span>
            }
<span class="nc" id="L902">        } else {</span>
<span class="nc" id="L903">            lineOffset += dbOffset + dataOffsets[b];</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L905">                int sampleOffset = lineOffset;</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">                for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L907">                    samples[dstOffset++] = data[sampleOffset] &amp; 0xff;</span>
<span class="nc" id="L908">                    sampleOffset += pixelStride;</span>
                }
<span class="nc" id="L910">                lineOffset += scanlineStride;</span>
            }
        }

<span class="nc" id="L914">        return samples;</span>
    }

    public void setSamples(int x, int y, int w, int h, int b, int iArray[]) {
<span class="nc bnc" id="L918" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L920">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L923">        int lineOffset = y*scanlineStride + x*pixelStride;</span>
<span class="nc" id="L924">        int srcOffset = 0;</span>

<span class="nc bnc" id="L926" title="All 2 branches missed.">        if (packed) {</span>
<span class="nc" id="L927">            lineOffset += dbOffsetPacked;</span>
<span class="nc" id="L928">            int bitMask = bitMasks[b];</span>

<span class="nc bnc" id="L930" title="All 2 branches missed.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L931">                int sampleOffset = lineOffset;</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">                for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L933">                    byte value = data[sampleOffset];</span>
<span class="nc" id="L934">                    value &amp;= ~bitMask;</span>
<span class="nc" id="L935">                    int sample = iArray[srcOffset++];</span>
<span class="nc" id="L936">                    value |= (sample &lt;&lt; bitOffsets[b]) &amp; bitMask;</span>
<span class="nc" id="L937">                    data[sampleOffset++] = value;</span>
                }
<span class="nc" id="L939">                lineOffset += scanlineStride;</span>
            }
<span class="nc" id="L941">        } else {</span>
<span class="nc" id="L942">            lineOffset += dbOffset + dataOffsets[b];</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">            for (int i = 0; i &lt; h; i++) {</span>
<span class="nc" id="L944">                int sampleOffset = lineOffset;</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">                for (int j = 0; j &lt; w; j++) {</span>
<span class="nc" id="L946">                    data[sampleOffset] = (byte)iArray[srcOffset++];</span>
<span class="nc" id="L947">                    sampleOffset += pixelStride;</span>
                }
<span class="nc" id="L949">                lineOffset += scanlineStride;</span>
            }
        }

<span class="nc" id="L953">        markDirty();</span>
<span class="nc" id="L954">    }</span>

    public int[] getPixels(int x, int y, int w, int h, int[] iArray) {
<span class="nc bnc" id="L957" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L959">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        int pixels[];
<span class="nc bnc" id="L963" title="All 2 branches missed.">        if (iArray != null) {</span>
<span class="nc" id="L964">            pixels = iArray;</span>
        } else {
<span class="nc" id="L966">            pixels = new int[w*h*numBands];</span>
        }

<span class="nc" id="L969">        int lineOffset = y*scanlineStride + x*pixelStride;</span>
<span class="nc" id="L970">        int dstOffset = 0;</span>

<span class="nc bnc" id="L972" title="All 2 branches missed.">        if (packed) {</span>
<span class="nc" id="L973">            lineOffset += dbOffsetPacked;</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">                for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L976">                    int value = data[lineOffset + i];</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">                    for (int k = 0; k &lt; numBands; k++) {</span>
<span class="nc" id="L978">                        pixels[dstOffset++] =</span>
                            (value &amp; bitMasks[k]) &gt;&gt;&gt; bitOffsets[k];
                    }
                }
<span class="nc" id="L982">                lineOffset += scanlineStride;</span>
            }
        } else {
<span class="nc" id="L985">            lineOffset += dbOffset;</span>
<span class="nc" id="L986">            int d0 = dataOffsets[0];</span>

<span class="nc bnc" id="L988" title="All 2 branches missed.">            if (numBands == 1) {</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">                for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L990">                    int pixelOffset = lineOffset + d0;</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">                    for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L992">                        pixels[dstOffset++] = data[pixelOffset] &amp; 0xff;</span>
<span class="nc" id="L993">                        pixelOffset += pixelStride;</span>
                    }
<span class="nc" id="L995">                    lineOffset += scanlineStride;</span>
                }
<span class="nc bnc" id="L997" title="All 2 branches missed.">            } else if (numBands == 2) {</span>
<span class="nc" id="L998">                int d1 = dataOffsets[1] - d0;</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">                for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L1000">                    int pixelOffset = lineOffset + d0;</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">                    for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L1002">                        pixels[dstOffset++] = data[pixelOffset] &amp; 0xff;</span>
<span class="nc" id="L1003">                        pixels[dstOffset++] = data[pixelOffset + d1] &amp; 0xff;</span>
<span class="nc" id="L1004">                        pixelOffset += pixelStride;</span>
                    }
<span class="nc" id="L1006">                    lineOffset += scanlineStride;</span>
                }
<span class="nc bnc" id="L1008" title="All 2 branches missed.">            } else if (numBands == 3) {</span>
<span class="nc" id="L1009">                int d1 = dataOffsets[1] - d0;</span>
<span class="nc" id="L1010">                int d2 = dataOffsets[2] - d0;</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L1012">                    int pixelOffset = lineOffset + d0;</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">                    for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L1014">                        pixels[dstOffset++] = data[pixelOffset] &amp; 0xff;</span>
<span class="nc" id="L1015">                        pixels[dstOffset++] = data[pixelOffset + d1] &amp; 0xff;</span>
<span class="nc" id="L1016">                        pixels[dstOffset++] = data[pixelOffset + d2] &amp; 0xff;</span>
<span class="nc" id="L1017">                        pixelOffset += pixelStride;</span>
                    }
<span class="nc" id="L1019">                    lineOffset += scanlineStride;</span>
                }
<span class="nc bnc" id="L1021" title="All 2 branches missed.">            } else if (numBands == 4) {</span>
<span class="nc" id="L1022">                int d1 = dataOffsets[1] - d0;</span>
<span class="nc" id="L1023">                int d2 = dataOffsets[2] - d0;</span>
<span class="nc" id="L1024">                int d3 = dataOffsets[3] - d0;</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">                for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L1026">                    int pixelOffset = lineOffset + d0;</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">                    for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L1028">                        pixels[dstOffset++] = data[pixelOffset] &amp; 0xff;</span>
<span class="nc" id="L1029">                        pixels[dstOffset++] = data[pixelOffset + d1] &amp; 0xff;</span>
<span class="nc" id="L1030">                        pixels[dstOffset++] = data[pixelOffset + d2] &amp; 0xff;</span>
<span class="nc" id="L1031">                        pixels[dstOffset++] = data[pixelOffset + d3] &amp; 0xff;</span>
<span class="nc" id="L1032">                        pixelOffset += pixelStride;</span>
                    }
<span class="nc" id="L1034">                    lineOffset += scanlineStride;</span>
                }
<span class="nc" id="L1036">            } else {</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">                for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L1038">                    int pixelOffset = lineOffset;</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">                    for (int i = 0; i &lt; w; i++) {</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">                        for (int k = 0; k &lt; numBands; k++) {</span>
<span class="nc" id="L1041">                            pixels[dstOffset++] =</span>
                                data[pixelOffset + dataOffsets[k]] &amp; 0xff;
                        }
<span class="nc" id="L1044">                        pixelOffset += pixelStride;</span>
                    }
<span class="nc" id="L1046">                    lineOffset += scanlineStride;</span>
                }
            }
        }

<span class="nc" id="L1051">        return pixels;</span>
    }

    public void setPixels(int x, int y, int w, int h, int[] iArray) {
<span class="nc bnc" id="L1055" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L1057">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L1060">        int lineOffset = y*scanlineStride + x*pixelStride;</span>
<span class="nc" id="L1061">        int srcOffset = 0;</span>

<span class="nc bnc" id="L1063" title="All 2 branches missed.">        if (packed) {</span>
<span class="nc" id="L1064">            lineOffset += dbOffsetPacked;</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L1067">                    int value = 0;</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                    for (int k = 0; k &lt; numBands; k++) {</span>
<span class="nc" id="L1069">                        int srcValue = iArray[srcOffset++];</span>
<span class="nc" id="L1070">                        value |= ((srcValue &lt;&lt; bitOffsets[k])</span>
                                  &amp; bitMasks[k]);
                    }
<span class="nc" id="L1073">                    data[lineOffset + i] = (byte)value;</span>
                }
<span class="nc" id="L1075">                lineOffset += scanlineStride;</span>
            }
        } else {
<span class="nc" id="L1078">            lineOffset += dbOffset;</span>
<span class="nc" id="L1079">            int d0 = dataOffsets[0];</span>

<span class="nc bnc" id="L1081" title="All 2 branches missed.">            if (numBands == 1) {</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">                for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L1083">                    int pixelOffset = lineOffset + d0;</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">                    for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L1085">                        data[pixelOffset] = (byte)iArray[srcOffset++];</span>
<span class="nc" id="L1086">                        pixelOffset += pixelStride;</span>
                    }
<span class="nc" id="L1088">                    lineOffset += scanlineStride;</span>
                }
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            } else if (numBands == 2) {</span>
<span class="nc" id="L1091">                int d1 = dataOffsets[1] - d0;</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">                for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L1093">                    int pixelOffset = lineOffset + d0;</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">                    for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L1095">                        data[pixelOffset] = (byte)iArray[srcOffset++];</span>
<span class="nc" id="L1096">                        data[pixelOffset + d1] = (byte)iArray[srcOffset++];</span>
<span class="nc" id="L1097">                        pixelOffset += pixelStride;</span>
                    }
<span class="nc" id="L1099">                    lineOffset += scanlineStride;</span>
                }
<span class="nc bnc" id="L1101" title="All 2 branches missed.">            } else if (numBands == 3) {</span>
<span class="nc" id="L1102">                int d1 = dataOffsets[1] - d0;</span>
<span class="nc" id="L1103">                int d2 = dataOffsets[2] - d0;</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L1105">                    int pixelOffset = lineOffset + d0;</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">                    for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L1107">                        data[pixelOffset] = (byte)iArray[srcOffset++];</span>
<span class="nc" id="L1108">                        data[pixelOffset + d1] = (byte)iArray[srcOffset++];</span>
<span class="nc" id="L1109">                        data[pixelOffset + d2] = (byte)iArray[srcOffset++];</span>
<span class="nc" id="L1110">                        pixelOffset += pixelStride;</span>
                    }
<span class="nc" id="L1112">                    lineOffset += scanlineStride;</span>
                }
<span class="nc bnc" id="L1114" title="All 2 branches missed.">            } else if (numBands == 4) {</span>
<span class="nc" id="L1115">                int d1 = dataOffsets[1] - d0;</span>
<span class="nc" id="L1116">                int d2 = dataOffsets[2] - d0;</span>
<span class="nc" id="L1117">                int d3 = dataOffsets[3] - d0;</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L1119">                    int pixelOffset = lineOffset + d0;</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                    for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L1121">                        data[pixelOffset] = (byte)iArray[srcOffset++];</span>
<span class="nc" id="L1122">                        data[pixelOffset + d1] = (byte)iArray[srcOffset++];</span>
<span class="nc" id="L1123">                        data[pixelOffset + d2] = (byte)iArray[srcOffset++];</span>
<span class="nc" id="L1124">                        data[pixelOffset + d3] = (byte)iArray[srcOffset++];</span>
<span class="nc" id="L1125">                        pixelOffset += pixelStride;</span>
                    }
<span class="nc" id="L1127">                    lineOffset += scanlineStride;</span>
                }
<span class="nc" id="L1129">            } else {</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">                for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L1131">                    int pixelOffset = lineOffset;</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">                    for (int i = 0; i &lt; w; i++) {</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                        for (int k = 0; k &lt; numBands; k++) {</span>
<span class="nc" id="L1134">                            data[pixelOffset + dataOffsets[k]] =</span>
                                (byte)iArray[srcOffset++];
                        }
<span class="nc" id="L1137">                        pixelOffset += pixelStride;</span>
                    }
<span class="nc" id="L1139">                    lineOffset += scanlineStride;</span>
                }
            }
        }

<span class="nc" id="L1144">        markDirty();</span>
<span class="nc" id="L1145">    }</span>

    public void setRect(int dx, int dy, Raster srcRaster) {
<span class="nc bnc" id="L1148" title="All 2 branches missed.">        if (!(srcRaster instanceof ByteInterleavedRaster)) {</span>
<span class="nc" id="L1149">            super.setRect(dx, dy, srcRaster);</span>
<span class="nc" id="L1150">            return;</span>
        }

<span class="nc" id="L1153">        int width  = srcRaster.getWidth();</span>
<span class="nc" id="L1154">        int height = srcRaster.getHeight();</span>
<span class="nc" id="L1155">        int srcOffX = srcRaster.getMinX();</span>
<span class="nc" id="L1156">        int srcOffY = srcRaster.getMinY();</span>
<span class="nc" id="L1157">        int dstOffX = dx+srcOffX;</span>
<span class="nc" id="L1158">        int dstOffY = dy+srcOffY;</span>

        // Clip to this raster
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        if (dstOffX &lt; this.minX) {</span>
<span class="nc" id="L1162">            int skipX = minX - dstOffX;</span>
<span class="nc" id="L1163">            width -= skipX;</span>
<span class="nc" id="L1164">            srcOffX += skipX;</span>
<span class="nc" id="L1165">            dstOffX = this.minX;</span>
        }
<span class="nc bnc" id="L1167" title="All 2 branches missed.">        if (dstOffY &lt; this.minY) {</span>
<span class="nc" id="L1168">            int skipY = this.minY - dstOffY;</span>
<span class="nc" id="L1169">            height -= skipY;</span>
<span class="nc" id="L1170">            srcOffY += skipY;</span>
<span class="nc" id="L1171">            dstOffY = this.minY;</span>
        }
<span class="nc bnc" id="L1173" title="All 2 branches missed.">        if (dstOffX+width &gt; this.maxX) {</span>
<span class="nc" id="L1174">            width = this.maxX - dstOffX;</span>
        }
<span class="nc bnc" id="L1176" title="All 2 branches missed.">        if (dstOffY+height &gt; this.maxY) {</span>
<span class="nc" id="L1177">            height = this.maxY - dstOffY;</span>
        }

<span class="nc" id="L1180">        setDataElements(dstOffX, dstOffY,</span>
                        srcOffX, srcOffY,
                        width, height, srcRaster);
<span class="nc" id="L1183">    }</span>


    /**
     * Creates a subraster given a region of the raster.  The x and y
     * coordinates specify the horizontal and vertical offsets
     * from the upper-left corner of this raster to the upper-left corner
     * of the subraster.  A subset of the bands of the parent Raster may
     * be specified.  If this is null, then all the bands are present in the
     * subRaster. A translation to the subRaster may also be specified.
     * Note that the subraster will reference the same
     * DataBuffer as the parent raster, but using different offsets.
     * @param x               X offset.
     * @param y               Y offset.
     * @param width           Width (in pixels) of the subraster.
     * @param height          Height (in pixels) of the subraster.
     * @param x0              Translated X origin of the subraster.
     * @param y0              Translated Y origin of the subraster.
     * @param bandList        Array of band indices.
     * @exception RasterFormatException
     *            if the specified bounding box is outside of the parent raster.
     */
    public Raster createChild(int x, int y,
                              int width, int height,
                              int x0, int y0, int[] bandList) {
<span class="nc" id="L1208">        WritableRaster newRaster = createWritableChild(x, y,</span>
                                                       width, height,
                                                       x0, y0,
                                                       bandList);
<span class="nc" id="L1212">        return (Raster) newRaster;</span>
    }

    /**
     * Creates a Writable subRaster given a region of the Raster. The x and y
     * coordinates specify the horizontal and vertical offsets
     * from the upper-left corner of this Raster to the upper-left corner
     * of the subRaster.  A subset of the bands of the parent Raster may
     * be specified.  If this is null, then all the bands are present in the
     * subRaster. A translation to the subRaster may also be specified.
     * Note that the subRaster will reference the same
     * DataBuffer as the parent Raster, but using different offsets.
     * @param x               X offset.
     * @param y               Y offset.
     * @param width           Width (in pixels) of the subraster.
     * @param height          Height (in pixels) of the subraster.
     * @param x0              Translated X origin of the subraster.
     * @param y0              Translated Y origin of the subraster.
     * @param bandList        Array of band indices.
     * @exception RasterFormatException
     *            if the specified bounding box is outside of the parent Raster.
     */
    public WritableRaster createWritableChild(int x, int y,
                                              int width, int height,
                                              int x0, int y0,
                                              int[] bandList) {
<span class="nc bnc" id="L1238" title="All 2 branches missed.">        if (x &lt; this.minX) {</span>
<span class="nc" id="L1239">            throw new RasterFormatException(&quot;x lies outside the raster&quot;);</span>
        }
<span class="nc bnc" id="L1241" title="All 2 branches missed.">        if (y &lt; this.minY) {</span>
<span class="nc" id="L1242">            throw new RasterFormatException(&quot;y lies outside the raster&quot;);</span>
        }
<span class="nc bnc" id="L1244" title="All 4 branches missed.">        if ((x+width &lt; x) || (x+width &gt; this.minX + this.width)) {</span>
<span class="nc" id="L1245">            throw new RasterFormatException(&quot;(x + width) is outside of Raster&quot;);</span>
        }
<span class="nc bnc" id="L1247" title="All 4 branches missed.">        if ((y+height &lt; y) || (y+height &gt; this.minY + this.height)) {</span>
<span class="nc" id="L1248">            throw new RasterFormatException(&quot;(y + height) is outside of Raster&quot;);</span>
        }

        SampleModel sm;

<span class="nc bnc" id="L1253" title="All 2 branches missed.">        if (bandList != null)</span>
<span class="nc" id="L1254">            sm = sampleModel.createSubsetSampleModel(bandList);</span>
        else
<span class="nc" id="L1256">            sm = sampleModel;</span>

<span class="nc" id="L1258">        int deltaX = x0 - x;</span>
<span class="nc" id="L1259">        int deltaY = y0 - y;</span>

<span class="nc" id="L1261">        return new ByteInterleavedRaster(sm,</span>
                                       dataBuffer,
                                       new Rectangle(x0, y0, width, height),
                                       new Point(sampleModelTranslateX+deltaX,
                                                 sampleModelTranslateY+deltaY),
                                       this);
    }

    /**
     * Creates a Raster with the same layout but using a different
     * width and height, and with new zeroed data arrays.
     */
    public WritableRaster createCompatibleWritableRaster(int w, int h) {
<span class="nc bnc" id="L1274" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;=0) {</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">            throw new RasterFormatException(&quot;negative &quot;+</span>
                                          ((w &lt;= 0) ? &quot;width&quot; : &quot;height&quot;));
        }

<span class="nc" id="L1279">        SampleModel sm = sampleModel.createCompatibleSampleModel(w, h);</span>

<span class="nc" id="L1281">        return new ByteInterleavedRaster(sm, new Point(0,0));</span>

    }

    /**
     * Creates a Raster with the same layout and the same
     * width and height, and with new zeroed data arrays.  If
     * the Raster is a subRaster, this will call
     * createCompatibleRaster(width, height).
     */
    public WritableRaster createCompatibleWritableRaster() {
<span class="nc" id="L1292">        return createCompatibleWritableRaster(width,height);</span>
    }

    public String toString() {
<span class="nc" id="L1296">        return new String (&quot;ByteInterleavedRaster: width = &quot;+width+&quot; height = &quot;</span>
                           + height
                           +&quot; #numDataElements &quot;+numDataElements
                           //  +&quot; xOff = &quot;+xOffset+&quot; yOff = &quot;+yOffset
                           +&quot; dataOff[0] = &quot;+dataOffsets[0]);
    }

//    /**
//     * For debugging...  prints a region of a one-band ByteInterleavedRaster
//     */
//    public void print(int x, int y, int w, int h) {
//        // REMIND:  Only works for 1 band!
//        System.out.println(this);
//        int offset = dataOffsets[0] + y*scanlineStride + x*pixelStride;
//        int off;
//        for (int yoff=0; yoff &lt; h; yoff++, offset += scanlineStride) {
//            off = offset;
//            System.out.print(&quot;Line &quot;+(y+yoff)+&quot;: &quot;);
//            for (int xoff = 0; xoff &lt; w; xoff++, off+= pixelStride) {
//                String s = Integer.toHexString(data[off]);
//                if (s.length() == 8) {
//                    s = s.substring(6,8);
//                }
//                System.out.print(s+&quot; &quot;);
//            }
//            System.out.println(&quot;&quot;);
//        }
//    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>