<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ByteBandedRaster.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.awt.image</a> &gt; <span class="el_source">ByteBandedRaster.java</span></div><h1>ByteBandedRaster.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.image;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.awt.image.RasterFormatException;
import java.awt.image.SampleModel;
import java.awt.image.BandedSampleModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.Rectangle;
import java.awt.Point;

/**
 * This class defines a Raster with pixels consisting of multiple
 * 8-bit samples stored in possibly separate arrays for each band.
 * Operations on sets of pixels are performed on a given band in the
 * Raster before moving on to the next band.  The arrays used for
 * storage may be distinct or shared between some or all of the bands.
 * Each band additionally has an offset that is added to determine the
 * DataBuffer location of each pixel.
 *
 * There is only one scanline stride for all bands.  The pixel stride
 * is always equal to one.  This type of raster can be used with a
 * ComponentColorModel. This class requires a BandedSampleModel.
 *
 */
public class ByteBandedRaster extends SunWritableRaster {

    /** Data offsets for each band of image data. */
    int[]         dataOffsets;

    /** Scanline stride of the image data contained in this Raster. */
    int           scanlineStride;

    /** The image data array. */
    byte[][]      data;

    /** A cached copy of minX + width for use in bounds checks. */
    private int maxX;

    /** A cached copy of minY + height for use in bounds checks. */
    private int maxY;

    /**
     *  Constructs a ByteBandedRaster with the given sampleModel. The
     *  Raster's upper left corner is origin and it is the same
     *  size as the SampleModel.  A dataBuffer large
     *  enough to describe the Raster is automatically created. SampleModel
     *  must be of type BandedSampleModel.
     *  @param sampleModel     The SampleModel that specifies the layout.
     *  @param origin          The Point that specifies the origin.
     */
    public ByteBandedRaster(SampleModel sampleModel,
                               Point origin) {
<span class="nc" id="L79">        this(sampleModel,</span>
<span class="nc" id="L80">             sampleModel.createDataBuffer(),</span>
             new Rectangle(origin.x,
                           origin.y,
<span class="nc" id="L83">                           sampleModel.getWidth(),</span>
<span class="nc" id="L84">                           sampleModel.getHeight()),</span>
             origin,
             null);
<span class="nc" id="L87">    }</span>

    /**
     *  Constructs a ByteBanded Raster with the given sampleModel
     *  and DataBuffer. The Raster's upper left corner is origin and
     *  it is the same size as the SampleModel.  The DataBuffer is not
     *  initialized and must be a DataBufferShort compatible with SampleModel.
     *  SampleModel must be of type BandedSampleModel.
     *  @param sampleModel     The SampleModel that specifies the layout.
     *  @param dataBuffer      The DataBufferShort that contains the image data.
     *  @param origin          The Point that specifies the origin.
     */
    public ByteBandedRaster(SampleModel sampleModel,
                               DataBuffer dataBuffer,
                               Point origin) {
<span class="nc" id="L102">        this(sampleModel, dataBuffer,</span>
             new Rectangle(origin.x , origin.y,
<span class="nc" id="L104">                           sampleModel.getWidth(),</span>
<span class="nc" id="L105">                           sampleModel.getHeight()),</span>
             origin, null);
<span class="nc" id="L107">    }</span>

    /**
     *  Constructs a ByteBandedRaster with the given sampleModel,
     *  DataBuffer, and parent. DataBuffer must be a DataBufferShort and
     *  SampleModel must be of type BandedSampleModel.
     *  When translated into the base Raster's
     *  coordinate system, aRegion must be contained by the base Raster.
     *  Origin is the coordinate in the new Raster's coordinate system of
     *  the origin of the base Raster.  (The base Raster is the Raster's
     *  ancestor which has no parent.)
     *
     *  Note that this constructor should generally be called by other
     *  constructors or create methods, it should not be used directly.
     *  @param sampleModel     The SampleModel that specifies the layout.
     *  @param dataBuffer      The DataBufferShort that contains the image data.
     *  @param aRegion         The Rectangle that specifies the image area.
     *  @param origin          The Point that specifies the origin.
     *  @param parent          The parent (if any) of this raster.
     */
    public ByteBandedRaster(SampleModel sampleModel,
                            DataBuffer dataBuffer,
                            Rectangle aRegion,
                            Point origin,
                            ByteBandedRaster parent) {

<span class="nc" id="L133">        super(sampleModel, dataBuffer, aRegion, origin, parent);</span>
<span class="nc" id="L134">        this.maxX = minX + width;</span>
<span class="nc" id="L135">        this.maxY = minY + height;</span>

<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (!(dataBuffer instanceof DataBufferByte)) {</span>
<span class="nc" id="L138">           throw new RasterFormatException(&quot;ByteBandedRaster must have&quot; +</span>
                &quot;byte DataBuffers&quot;);
        }
<span class="nc" id="L141">        DataBufferByte dbb = (DataBufferByte)dataBuffer;</span>

<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (sampleModel instanceof BandedSampleModel) {</span>
<span class="nc" id="L144">            BandedSampleModel bsm = (BandedSampleModel)sampleModel;</span>
<span class="nc" id="L145">            this.scanlineStride = bsm.getScanlineStride();</span>
<span class="nc" id="L146">            int bankIndices[] = bsm.getBankIndices();</span>
<span class="nc" id="L147">            int bandOffsets[] = bsm.getBandOffsets();</span>
<span class="nc" id="L148">            int dOffsets[] = dbb.getOffsets();</span>
<span class="nc" id="L149">            dataOffsets = new int[bankIndices.length];</span>
<span class="nc" id="L150">            data = new byte[bankIndices.length][];</span>
<span class="nc" id="L151">            int xOffset = aRegion.x - origin.x;</span>
<span class="nc" id="L152">            int yOffset = aRegion.y - origin.y;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            for (int i = 0; i &lt; bankIndices.length; i++) {</span>
<span class="nc" id="L154">               data[i] = stealData(dbb, bankIndices[i]);</span>
<span class="nc" id="L155">               dataOffsets[i] = dOffsets[bankIndices[i]] +</span>
                   xOffset + yOffset*scanlineStride + bandOffsets[i];
            }
<span class="nc" id="L158">        } else {</span>
<span class="nc" id="L159">            throw new RasterFormatException(&quot;ByteBandedRasters must have&quot;+</span>
                &quot;BandedSampleModels&quot;);
        }
<span class="nc" id="L162">        verify();</span>
<span class="nc" id="L163">    }</span>


    /**
     * Returns a copy of the data offsets array. For each band the data
     * offset is the index into the band's data array, of the first sample
     * of the band.
     */
    public int[] getDataOffsets() {
<span class="nc" id="L172">        return (int[])dataOffsets.clone();</span>
    }

    /**
     * Returns data offset for the specified band.  The data offset
     * is the index into the band's data array
     * in which the first sample of the first scanline is stored.
     * @param The band whose offset is returned.
     */
    public int getDataOffset(int band) {
<span class="nc" id="L182">        return dataOffsets[band];</span>
    }

    /**
     * Returns the scanline stride -- the number of data array elements
     * between a given sample and the sample in the same column
     * of the next row in the same band.
     */
    public int getScanlineStride() {
<span class="nc" id="L191">        return scanlineStride;</span>
    }

    /**
     * Returns the pixel stride, which is always equal to one for
     * a Raster with a BandedSampleModel.
     */
    public int getPixelStride() {
<span class="nc" id="L199">        return 1;</span>
    }

    /**
     * Returns a reference to the entire data array.
     */
    public byte[][] getDataStorage() {
<span class="nc" id="L206">        return data;</span>
    }

    /**
     * Returns a reference to the specific band data array.
     */
    public byte[] getDataStorage(int band) {
<span class="nc" id="L213">        return data[band];</span>
    }

    /**
     * Returns the data elements for all bands at the specified
     * location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinate is out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param outData  An object reference to an array of type defined by
     *                 getTransferType() and length getNumDataElements().
     *                 If null an array of appropriate type and size will be
     *                 allocated.
     * @return         An object reference to an array of type defined by
     *                 getTransferType() with the request pixel data.
     */
    public Object getDataElements(int x, int y, Object obj) {
<span class="nc bnc" id="L233" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x &gt;= this.maxX) || (y &gt;= this.maxY)) {
<span class="nc" id="L235">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        byte outData[];
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L240">            outData = new byte[numDataElements];</span>
        } else {
<span class="nc" id="L242">            outData = (byte[])obj;</span>
        }
<span class="nc" id="L244">        int off = (y-minY)*scanlineStride + (x-minX);</span>

<span class="nc bnc" id="L246" title="All 2 branches missed.">        for (int band = 0; band &lt; numDataElements; band++) {</span>
<span class="nc" id="L247">            outData[band] = data[band][dataOffsets[band] + off];</span>
        }

<span class="nc" id="L250">        return outData;</span>
    }

    /**
     * Returns an  array  of data elements from the specified
     * rectangular region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * &lt;pre&gt;
     *       byte[] bandData = (byte[])raster.getDataElement(x, y, w, h, null);
     *       int numDataElements = raster.getNumDataElements();
     *       byte[] pixel = new byte[numDataElements];
     *       // To find a data element at location (x2, y2)
     *       System.arraycopy(bandData, ((y2-y)*w + (x2-x))*numDataElements,
     *                        pixel, 0, numDataElements);
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the pixel rectangle.
     * @param height   Height of the pixel rectangle.
     * @param outData  An object reference to an array of type defined by
     *                 getTransferType() and length w*h*getNumDataElements().
     *                 If null an array of appropriate type and size will be
     *                 allocated.
     * @return         An object reference to an array of type defined by
     *                 getTransferType() with the request pixel data.
     */
    public Object getDataElements(int x, int y, int w, int h, Object obj) {
<span class="nc bnc" id="L280" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L282">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        byte outData[];
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L287">            outData = new byte[numDataElements*w*h];</span>
        } else {
<span class="nc" id="L289">            outData = (byte[])obj;</span>
        }
<span class="nc" id="L291">        int yoff = (y-minY)*scanlineStride + (x-minX);</span>

<span class="nc bnc" id="L293" title="All 2 branches missed.">        for (int c = 0; c &lt; numDataElements; c++) {</span>
<span class="nc" id="L294">            int off = c;</span>
<span class="nc" id="L295">            byte[] bank = data[c];</span>
<span class="nc" id="L296">            int dataOffset = dataOffsets[c];</span>

<span class="nc" id="L298">            int yoff2 = yoff;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">            for (int ystart=0; ystart &lt; h; ystart++, yoff2 += scanlineStride) {</span>
<span class="nc" id="L300">                int xoff = dataOffset + yoff2;</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                for (int xstart=0; xstart &lt; w; xstart++) {</span>
<span class="nc" id="L302">                    outData[off] = bank[xoff++];</span>
<span class="nc" id="L303">                    off += numDataElements;</span>
                }
            }
        }

<span class="nc" id="L308">        return outData;</span>
    }

    /**
     * Returns a byte array  of data elements from the specified rectangular
     * region for the specified band.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * &lt;pre&gt;
     *       byte[] bandData = raster.getByteData(x, y, w, h, null);
     *       // To find the data element at location (x2, y2)
     *       byte bandElement = bandData[((y2-y)*w + (x2-x))];
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the pixel rectangle.
     * @param height   Height of the pixel rectangle.
     * @param band     The band to return.
     * @param outData  If non-null, data elements for all bands
     *                 at the specified location are returned in this array.
     * @return         Data array with data elements for all bands.
     */
    public byte[] getByteData(int x, int y, int w, int h,
                              int band, byte[] outData) {
        // Bounds check for 'band' will be performed automatically
<span class="nc bnc" id="L333" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L335">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (outData == null) {</span>
<span class="nc" id="L339">            outData = new byte[scanlineStride*h];</span>
        }
<span class="nc" id="L341">        int yoff = (y-minY)*scanlineStride + (x-minX) + dataOffsets[band];</span>

<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (scanlineStride == w) {</span>
<span class="nc" id="L344">            System.arraycopy(data[band], yoff, outData, 0, w*h);</span>
        } else {
<span class="nc" id="L346">            int off = 0;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            for (int ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L348">                System.arraycopy(data[band], yoff, outData, off, w);</span>
<span class="nc" id="L349">                off += w;</span>
            }
        }

<span class="nc" id="L353">        return outData;</span>
    }

    /**
     * Returns a byte array of data elements from the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * &lt;pre&gt;
     *       byte[] bandData = raster.getByteData(x, y, w, h, null);
     *       int numDataElements = raster.getNumDataElements();
     *       byte[] pixel = new byte[numDataElements];
     *       // To find a data element at location (x2, y2)
     *       System.arraycopy(bandData, ((y2-y)*w + (x2-x))*numDataElements,
     *                        pixel, 0, numDataElements);
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the pixel rectangle.
     * @param height   Height of the pixel rectangle.
     * @param outData  If non-null, data elements for all bands
     *                 at the specified location are returned in this array.
     * @return         Data array with data elements for all bands.
     */
    public byte[] getByteData(int x, int y, int w, int h, byte[] outData) {
<span class="nc bnc" id="L378" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L380">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (outData == null) {</span>
<span class="nc" id="L384">            outData = new byte[numDataElements*scanlineStride*h];</span>
        }
<span class="nc" id="L386">        int yoff = (y-minY)*scanlineStride + (x-minX);</span>

<span class="nc bnc" id="L388" title="All 2 branches missed.">        for (int c = 0; c &lt; numDataElements; c++) {</span>
<span class="nc" id="L389">            int off = c;</span>
<span class="nc" id="L390">            byte[] bank = data[c];</span>
<span class="nc" id="L391">            int dataOffset = dataOffsets[c];</span>

            // REMIND: Should keep track if dataoffsets are in a nice order
<span class="nc" id="L394">            int yoff2 = yoff;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">            for (int ystart=0; ystart &lt; h; ystart++, yoff2 += scanlineStride) {</span>
<span class="nc" id="L396">                int xoff = dataOffset + yoff2;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                for (int xstart=0; xstart &lt; w; xstart++) {</span>
<span class="nc" id="L398">                    outData[off] = bank[xoff++];</span>
<span class="nc" id="L399">                    off += numDataElements;</span>
                }
            }
        }

<span class="nc" id="L404">        return outData;</span>
    }

    /**
     * Stores the data elements for all bands at the specified location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinate is out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param inData   An object reference to an array of type defined by
     *                 getTransferType() and length getNumDataElements()
     *                 containing the pixel data to place at x,y.
     */
    public void setDataElements(int x, int y, Object obj) {
<span class="nc bnc" id="L420" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x &gt;= this.maxX) || (y &gt;= this.maxY)) {
<span class="nc" id="L422">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L425">        byte inData[] = (byte[])obj;</span>
<span class="nc" id="L426">        int off = (y-minY)*scanlineStride + (x-minX);</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        for (int i = 0; i &lt; numDataElements; i++) {</span>
<span class="nc" id="L428">            data[i][dataOffsets[i] + off] = inData[i];</span>
        }
<span class="nc" id="L430">        markDirty();</span>
<span class="nc" id="L431">    }</span>

    /**
     * Stores the Raster data at the specified location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinate is out of bounds.
     * @param x          The X coordinate of the pixel location.
     * @param y          The Y coordinate of the pixel location.
     * @param inRaster   Raster of data to place at x,y location.
     */
    public void setDataElements(int x, int y, Raster inRaster) {
<span class="nc" id="L442">        int dstOffX = inRaster.getMinX() + x;</span>
<span class="nc" id="L443">        int dstOffY = inRaster.getMinY() + y;</span>
<span class="nc" id="L444">        int width  = inRaster.getWidth();</span>
<span class="nc" id="L445">        int height = inRaster.getHeight();</span>
<span class="nc bnc" id="L446" title="All 8 branches missed.">        if ((dstOffX &lt; this.minX) || (dstOffY &lt; this.minY) ||</span>
            (dstOffX + width &gt; this.maxX) || (dstOffY + height &gt; this.maxY)) {
<span class="nc" id="L448">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L452">        setDataElements(dstOffX, dstOffY, width, height, inRaster);</span>
<span class="nc" id="L453">    }</span>

   /**
     * Stores the Raster data at the specified location.
     * @param dstX The absolute X coordinate of the destination pixel
     * that will receive a copy of the upper-left pixel of the
     * inRaster
     * @param dstY The absolute Y coordinate of the destination pixel
     * that will receive a copy of the upper-left pixel of the
     * inRaster
     * @param width      The number of pixels to store horizontally
     * @param height     The number of pixels to store vertically
     * @param inRaster   Raster of data to place at x,y location.
     */
    private void setDataElements(int dstX, int dstY,
                                 int width, int height,
                                 Raster inRaster) {
        // Assume bounds checking has been performed previously
<span class="nc bnc" id="L471" title="All 4 branches missed.">        if (width &lt;= 0 || height &lt;= 0) {</span>
<span class="nc" id="L472">            return;</span>
        }

<span class="nc" id="L475">        int srcOffX = inRaster.getMinX();</span>
<span class="nc" id="L476">        int srcOffY = inRaster.getMinY();</span>
<span class="nc" id="L477">        Object tdata = null;</span>

//      // REMIND: Do something faster!
//      if (inRaster instanceof ByteBandedRaster) {
//      }

<span class="nc bnc" id="L483" title="All 2 branches missed.">        for (int startY=0; startY &lt; height; startY++) {</span>
            // Grab one scanline at a time
<span class="nc" id="L485">            tdata = inRaster.getDataElements(srcOffX, srcOffY+startY,</span>
                                             width, 1, tdata);
<span class="nc" id="L487">            setDataElements(dstX, dstY+startY, width, 1, tdata);</span>
        }
<span class="nc" id="L489">    }</span>

    /**
     * Stores an array of data elements into the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * for the nth band at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x))*numDataElements + n]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param inData   An object reference to an array of type defined by
     *                 getTransferType() and length w*h*getNumDataElements()
     *                 containing the pixel data to place between x,y and
     *                 x+h, y+h.
     */
    public void setDataElements(int x, int y, int w, int h, Object obj) {
<span class="nc bnc" id="L514" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L516">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L519">        byte inData[] = (byte[])obj;</span>
<span class="nc" id="L520">        int yoff = (y-minY)*scanlineStride + (x-minX);</span>

<span class="nc bnc" id="L522" title="All 2 branches missed.">        for (int c = 0; c &lt; numDataElements; c++) {</span>
<span class="nc" id="L523">            int off = c;</span>
<span class="nc" id="L524">            byte[] bank = data[c];</span>
<span class="nc" id="L525">            int dataOffset = dataOffsets[c];</span>

<span class="nc" id="L527">            int yoff2 = yoff;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            for (int ystart=0; ystart &lt; h; ystart++, yoff2 += scanlineStride) {</span>
<span class="nc" id="L529">                int xoff = dataOffset + yoff2;</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                for (int xstart=0; xstart &lt; w; xstart++) {</span>
<span class="nc" id="L531">                    bank[xoff++] = inData[off];</span>
<span class="nc" id="L532">                    off += numDataElements;</span>
                }
            }
        }

<span class="nc" id="L537">        markDirty();</span>
<span class="nc" id="L538">    }</span>

    /**
     * Stores a byte array of data elements into the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * for the nth band at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x))*numDataElements + n]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param band     The band to set.
     * @param inData   The data elements to be stored.
     */
    public void putByteData(int x, int y, int w, int h,
                            int band, byte[] inData) {
        // Bounds check for 'band' will be performed automatically
<span class="nc bnc" id="L561" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L563">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L566">        int yoff = (y-minY)*scanlineStride + (x-minX) + dataOffsets[band];</span>
        int xoff;
<span class="nc" id="L568">        int off = 0;</span>
        int xstart;
        int ystart;

<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (scanlineStride == w) {</span>
<span class="nc" id="L573">            System.arraycopy(inData, 0, data[band], yoff, w*h);</span>
        } else {
<span class="nc bnc" id="L575" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L576">                System.arraycopy(inData, off, data[band], yoff, w);</span>
<span class="nc" id="L577">                off += w;</span>
            }
        }

<span class="nc" id="L581">        markDirty();</span>
<span class="nc" id="L582">    }</span>

    /**
     * Stores a byte array of data elements into the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * for the nth band at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x))*numDataElements + n]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param inData   The data elements to be stored.
     */
    public void putByteData(int x, int y, int w, int h, byte[] inData) {
<span class="nc bnc" id="L602" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L604">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L607">        int yoff = (y-minY)*scanlineStride + (x-minX);</span>

<span class="nc bnc" id="L609" title="All 2 branches missed.">        for (int c = 0; c &lt; numDataElements; c++) {</span>
<span class="nc" id="L610">            int off = c;</span>
<span class="nc" id="L611">            byte[] bank = data[c];</span>
<span class="nc" id="L612">            int dataOffset = dataOffsets[c];</span>

<span class="nc" id="L614">            int yoff2 = yoff;</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">            for (int ystart=0; ystart &lt; h; ystart++, yoff2 += scanlineStride) {</span>
<span class="nc" id="L616">                int xoff = dataOffset + yoff2;</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">                for (int xstart=0; xstart &lt; w; xstart++) {</span>
<span class="nc" id="L618">                    bank[xoff++] = inData[off];</span>
<span class="nc" id="L619">                    off += numDataElements;</span>
                }
            }
        }

<span class="nc" id="L624">        markDirty();</span>
<span class="nc" id="L625">    }</span>

    /**
     * Creates a Writable subraster given a region of the raster.  The x and y
     * coordinates specify the horizontal and vertical offsets
     * from the upper-left corner of this raster to the upper-left corner
     * of the subraster.  A subset of the bands of the parent Raster may
     * be specified.  If this is null, then all the bands are present in the
     * subRaster. A translation to the subRaster may also be specified.
     * Note that the subraster will reference the same
     * DataBuffers as the parent raster, but using different offsets.
     * @param x               X offset.
     * @param y               Y offset.
     * @param width           Width of the subraster.
     * @param height          Height of the subraster.
     * @param x0              Translated X origin of the subraster.
     * @param y0              Translated Y origin of the subraster.
     * @param bandList        Array of band indices.
     * @exception RasterFormatException
     *            if the specified bounding box is outside of the parent raster.
     */
    public WritableRaster createWritableChild (int x, int y,
                                               int width, int height,
                                               int x0, int y0,
                                               int bandList[]) {

<span class="nc bnc" id="L651" title="All 2 branches missed.">        if (x &lt; this.minX) {</span>
<span class="nc" id="L652">            throw new RasterFormatException(&quot;x lies outside raster&quot;);</span>
        }
<span class="nc bnc" id="L654" title="All 2 branches missed.">        if (y &lt; this.minY) {</span>
<span class="nc" id="L655">            throw new RasterFormatException(&quot;y lies outside raster&quot;);</span>
        }
<span class="nc bnc" id="L657" title="All 4 branches missed.">        if ((x+width &lt; x) || (x+width &gt; this.width + this.minX)) {</span>
<span class="nc" id="L658">            throw new RasterFormatException(&quot;(x + width) is outside raster&quot;) ;</span>
        }
<span class="nc bnc" id="L660" title="All 4 branches missed.">        if ((y+height &lt; y) || (y+height &gt; this.height + this.minY)) {</span>
<span class="nc" id="L661">            throw new RasterFormatException(&quot;(y + height) is outside raster&quot;);</span>
        }

        SampleModel sm;

<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (bandList != null)</span>
<span class="nc" id="L667">            sm = sampleModel.createSubsetSampleModel(bandList);</span>
        else
<span class="nc" id="L669">            sm = sampleModel;</span>

<span class="nc" id="L671">        int deltaX = x0 - x;</span>
<span class="nc" id="L672">        int deltaY = y0 - y;</span>

<span class="nc" id="L674">        return new ByteBandedRaster(sm,</span>
                                    dataBuffer,
                                    new Rectangle(x0,y0,width,height),
                                    new Point(sampleModelTranslateX+deltaX,
                                              sampleModelTranslateY+deltaY),
                                    this);
    }

    /**
     * Creates a subraster given a region of the raster.  The x and y
     * coordinates specify the horizontal and vertical offsets
     * from the upper-left corner of this raster to the upper-left corner
     * of the subraster.  A subset of the bands of the parent Raster may
     * be specified.  If this is null, then all the bands are present in the
     * subRaster. A translation to the subRaster may also be specified.
     * Note that the subraster will reference the same
     * DataBuffers as the parent raster, but using different offsets.
     * @param x               X offset.
     * @param y               Y offset.
     * @param width           Width (in pixels) of the subraster.
     * @param height          Height (in pixels) of the subraster.
     * @param x0              Translated X origin of the subraster.
     * @param y0              Translated Y origin of the subraster.
     * @param bandList        Array of band indices.
     * @exception RasterFormatException
     *            if the specified bounding box is outside of the parent raster.
     */
    public Raster createChild (int x, int y,
                                   int width, int height,
                                   int x0, int y0,
                                   int bandList[]) {
<span class="nc" id="L705">        return createWritableChild(x, y, width, height, x0, y0, bandList);</span>
    }

    /**
     * Creates a Raster with the same layout but using a different
     * width and height, and with new zeroed data arrays.
     */
    public WritableRaster createCompatibleWritableRaster(int w, int h) {
<span class="nc bnc" id="L713" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;=0) {</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">            throw new RasterFormatException(&quot;negative &quot;+</span>
                                          ((w &lt;= 0) ? &quot;width&quot; : &quot;height&quot;));
        }

<span class="nc" id="L718">        SampleModel sm = sampleModel.createCompatibleSampleModel(w,h);</span>

<span class="nc" id="L720">        return new ByteBandedRaster(sm, new Point(0,0));</span>
    }

    /**
     * Creates a Raster with the same layout and the same
     * width and height, and with new zeroed data arrays.  If
     * the Raster is a subRaster, this will call
     * createCompatibleRaster(width, height).
     */
    public WritableRaster createCompatibleWritableRaster() {
<span class="nc" id="L730">        return createCompatibleWritableRaster(width, height);</span>
    }

    /**
     * Verify that the layout parameters are consistent with the data.
     * Verifies whether the data buffer has enough data for the raster,
     * taking into account offsets, after ensuring all offsets are &gt;=0.
     * @throws RasterFormatException if a problem is detected.
     */
    private void verify() {

        /* Need to re-verify the dimensions since a sample model may be
         * specified to the constructor
         */
<span class="nc bnc" id="L744" title="All 6 branches missed.">        if (width &lt;= 0 || height &lt;= 0 ||</span>
            height &gt; (Integer.MAX_VALUE / width))
        {
<span class="nc" id="L747">            throw new RasterFormatException(&quot;Invalid raster dimension&quot;);</span>
        }

<span class="nc bnc" id="L750" title="All 4 branches missed.">        if (scanlineStride &lt; 0 ||</span>
            scanlineStride &gt; (Integer.MAX_VALUE / height))
        {
            // integer overflow
<span class="nc" id="L754">            throw new RasterFormatException(&quot;Incorrect scanline stride: &quot;</span>
                    + scanlineStride);
        }

<span class="nc bnc" id="L758" title="All 2 branches missed.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">            if (scanlineStride &gt; data[i].length) {</span>
<span class="nc" id="L760">                throw new RasterFormatException(&quot;Incorrect scanline stride: &quot;</span>
                    + scanlineStride);
            }
        }

        // Make sure data for Raster is in a legal range
<span class="nc bnc" id="L766" title="All 2 branches missed.">        for (int i=0; i &lt; dataOffsets.length; i++) {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">            if (dataOffsets[i] &lt; 0) {</span>
<span class="nc" id="L768">                throw new RasterFormatException(&quot;Data offsets for band &quot;+i+</span>
                                                &quot;(&quot;+dataOffsets[i]+
                                                &quot;) must be &gt;= 0&quot;);
            }
        }

<span class="nc" id="L774">        int lastScanOffset = (height - 1) * scanlineStride;</span>

<span class="nc bnc" id="L776" title="All 2 branches missed.">        if ((width - 1) &gt; (Integer.MAX_VALUE - lastScanOffset)) {</span>
<span class="nc" id="L777">            throw new RasterFormatException(&quot;Invalid raster dimension&quot;);</span>
        }
<span class="nc" id="L779">        int lastPixelOffset = lastScanOffset + (width-1);</span>

<span class="nc" id="L781">        int maxIndex = 0;</span>
        int index;

<span class="nc bnc" id="L784" title="All 2 branches missed.">        for (int i=0; i &lt; numDataElements; i++) {</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">            if (dataOffsets[i] &gt; (Integer.MAX_VALUE - lastPixelOffset)) {</span>
<span class="nc" id="L786">                throw new RasterFormatException(&quot;Invalid raster dimension&quot;);</span>
            }
<span class="nc" id="L788">            index = lastPixelOffset + dataOffsets[i];</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">            if (index &gt; maxIndex) {</span>
<span class="nc" id="L790">                maxIndex = index;</span>
            }
        }

<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (data.length == 1) {</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">            if (data[0].length &lt;= maxIndex*numDataElements) {</span>
<span class="nc" id="L796">                throw new RasterFormatException(&quot;Data array too small &quot;+</span>
                                                &quot;(it is &quot;+data[0].length+
                                                &quot; and should be &gt; &quot;+
                                                (maxIndex*numDataElements)+
                                                &quot; )&quot;);
            }
        }
        else {
<span class="nc bnc" id="L804" title="All 2 branches missed.">            for (int i=0; i &lt; numDataElements; i++) {</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">                if (data[i].length &lt;= maxIndex) {</span>
<span class="nc" id="L806">                    throw new RasterFormatException(&quot;Data array too small &quot;+</span>
                                                    &quot;(it is &quot;+data[i].length+
                                                    &quot; and should be &gt; &quot;+
                                                    maxIndex+&quot; )&quot;);
                }
            }
        }
<span class="nc" id="L813">    }</span>

    public String toString() {
<span class="nc" id="L816">        return new String (&quot;ByteBandedRaster: width = &quot;+width+&quot; height = &quot;</span>
                           + height
                           +&quot; #bands &quot;+numDataElements
                           +&quot; minX = &quot;+minX+&quot; minY = &quot;+minY);
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>