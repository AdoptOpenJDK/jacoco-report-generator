<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShortInterleavedRaster.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.awt.image</a> &gt; <span class="el_source">ShortInterleavedRaster.java</span></div><h1>ShortInterleavedRaster.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.image;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.awt.image.RasterFormatException;
import java.awt.image.SampleModel;
import java.awt.image.ComponentSampleModel;
import java.awt.image.PixelInterleavedSampleModel;
import java.awt.image.SinglePixelPackedSampleModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferUShort;
import java.awt.Rectangle;
import java.awt.Point;

/**
 * This class defines a Raster with pixels consisting of one or more 16-bit
 * data elements stored in close proximity to each other in a short integer
 * array.  The bit precision per data element is that
 * of the data type (that is, the bit precision for this Raster is 16).
 * There is only one pixel stride and one scanline stride for all
 * bands.  This type of Raster can be used with a
 * ComponentColorModel if there are multiple bands, or a
 * IndexColorModel if there is only one band.
 * &lt;p&gt;
 * For example, 5-6-5 RGB image data can be represented by a
 * ShortInterleavedRaster using a SinglePixelPackedSampleModel and
 * a ComponentColorModel.
 *
 *
 */
public class ShortInterleavedRaster extends ShortComponentRaster {

    /** A cached copy of minX + width for use in bounds checks. */
    private int maxX;

    /** A cached copy of minY + height for use in bounds checks. */
    private int maxY;

    /**
     *  Constructs a ShortInterleavedRaster with the given SampleModel.
     *  The Raster's upper left corner is origin and it is the same
     *  size as the SampleModel.  A DataBuffer large enough to describe the
     *  Raster is automatically created.  SampleModel must be of type
     *  PixelInterleavedSampleModel or SinglePixelPackedSampleModel.
     *  @param sampleModel     The SampleModel that specifies the layout.
     *  @param origin          The Point that specified the origin.
     */
    public ShortInterleavedRaster(SampleModel sampleModel, Point origin) {
<span class="nc" id="L73">        this(sampleModel,</span>
<span class="nc" id="L74">             sampleModel.createDataBuffer(),</span>
             new Rectangle(origin.x,
                           origin.y,
<span class="nc" id="L77">                           sampleModel.getWidth(),</span>
<span class="nc" id="L78">                           sampleModel.getHeight()),</span>
             origin,
             null);
<span class="nc" id="L81">    }</span>

    /**
     * Constructs a ShortInterleavedRaster with the given SampleModel
     * and DataBuffer.  The Raster's upper left corner is origin and
     * it is the same sizes the SampleModel.  The DataBuffer is not
     * initialized and must be a DataBufferUShort compatible with SampleModel.
     * SampleModel must be of type PixelInterleavedSampleModel or
     * SinglePixelPackedSampleModel.
     * @param sampleModel     The SampleModel that specifies the layout.
     * @param dataBuffer      The DataBufferUShort that contains the image data.
     * @param origin          The Point that specifies the origin.
     */
    public ShortInterleavedRaster(SampleModel sampleModel,
                                   DataBuffer dataBuffer,
                                   Point origin) {
<span class="nc" id="L97">        this(sampleModel,</span>
             dataBuffer,
             new Rectangle(origin.x,
                           origin.y,
<span class="nc" id="L101">                           sampleModel.getWidth(),</span>
<span class="nc" id="L102">                           sampleModel.getHeight()),</span>
             origin,
             null);
<span class="nc" id="L105">    }</span>

    /**
     * Constructs a ShortInterleavedRaster with the given SampleModel,
     * DataBuffer, and parent.  DataBuffer must be a DataBufferUShort and
     * SampleModel must be of type PixelInterleavedSampleModel or
     * SinglePixelPackedSampleModel.  When translated into the base Raster's
     * coordinate system, aRegion must be contained by the base Raster.
     * Origin is the coodinate in the new Raster's coordinate system of
     * the origin of the base Raster.  (The base Raster is the Raster's
     * ancestor which has no parent.)
     *
     * Note that this constructor should generally be called by other
     * constructors or create methods, it should not be used directly.
     * @param sampleModel     The SampleModel that specifies the layout.
     * @param dataBuffer      The DataBufferUShort that contains the image data.
     * @param aRegion         The Rectangle that specifies the image area.
     * @param origin          The Point that specifies the origin.
     * @param parent          The parent (if any) of this raster.
     */
    public ShortInterleavedRaster(SampleModel sampleModel,
                                   DataBuffer dataBuffer,
                                   Rectangle aRegion,
                                   Point origin,
                                   ShortInterleavedRaster parent) {

<span class="nc" id="L131">        super(sampleModel, dataBuffer, aRegion, origin, parent);</span>
<span class="nc" id="L132">        this.maxX = minX + width;</span>
<span class="nc" id="L133">        this.maxY = minY + height;</span>

<span class="nc bnc" id="L135" title="All 2 branches missed.">        if(!(dataBuffer instanceof DataBufferUShort)) {</span>
<span class="nc" id="L136">            throw new RasterFormatException(&quot;ShortInterleavedRasters must &quot;+</span>
                                            &quot;have ushort DataBuffers&quot;);
        }

<span class="nc" id="L140">        DataBufferUShort dbus = (DataBufferUShort)dataBuffer;</span>
<span class="nc" id="L141">        this.data = stealData(dbus, 0);</span>

        // REMIND: need case for interleaved ComponentSampleModel
<span class="nc bnc" id="L144" title="All 4 branches missed.">        if ((sampleModel instanceof PixelInterleavedSampleModel) ||</span>
            (sampleModel instanceof ComponentSampleModel &amp;&amp;
<span class="nc bnc" id="L146" title="All 2 branches missed.">             sampleModel.getNumBands() == 1)) {</span>
<span class="nc" id="L147">            ComponentSampleModel csm = (ComponentSampleModel)sampleModel;</span>

<span class="nc" id="L149">            this.scanlineStride = csm.getScanlineStride();</span>
<span class="nc" id="L150">            this.pixelStride = csm.getPixelStride();</span>
<span class="nc" id="L151">            this.dataOffsets = csm.getBandOffsets();</span>
<span class="nc" id="L152">            int xOffset = aRegion.x - origin.x;</span>
<span class="nc" id="L153">            int yOffset = aRegion.y - origin.y;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            for (int i = 0; i &lt; getNumDataElements(); i++) {</span>
<span class="nc" id="L155">                dataOffsets[i] += xOffset*pixelStride+yOffset*scanlineStride;</span>
            }
<span class="nc bnc" id="L157" title="All 2 branches missed.">        } else if (sampleModel instanceof SinglePixelPackedSampleModel) {</span>
<span class="nc" id="L158">            SinglePixelPackedSampleModel sppsm =</span>
                    (SinglePixelPackedSampleModel)sampleModel;
<span class="nc" id="L160">            this.scanlineStride = sppsm.getScanlineStride();</span>
<span class="nc" id="L161">            this.pixelStride    = 1;</span>
<span class="nc" id="L162">            this.dataOffsets = new int[1];</span>
<span class="nc" id="L163">            this.dataOffsets[0] = dbus.getOffset();</span>
<span class="nc" id="L164">            int xOffset = aRegion.x - origin.x;</span>
<span class="nc" id="L165">            int yOffset = aRegion.y - origin.y;</span>
<span class="nc" id="L166">            dataOffsets[0] += xOffset+yOffset*scanlineStride;</span>
<span class="nc" id="L167">        } else {</span>
<span class="nc" id="L168">            throw new RasterFormatException(&quot;ShortInterleavedRasters must &quot;+</span>
              &quot;have PixelInterleavedSampleModel, SinglePixelPackedSampleModel&quot;+
              &quot; or 1 band ComponentSampleModel.  Sample model is &quot;+
              sampleModel);
        }
<span class="nc" id="L173">        this.bandOffset = this.dataOffsets[0];</span>
<span class="nc" id="L174">        verify();</span>
<span class="nc" id="L175">    }</span>

    /**
     * Returns a copy of the data offsets array. For each band the data offset
     * is the index into the band's data array, of the first sample of the
     * band.
     */
    public int[] getDataOffsets() {
<span class="nc" id="L183">        return (int[]) dataOffsets.clone();</span>
    }

    /**
     * Returns the data offset for the specified band.  The data offset
     * is the index into the data array in which the first sample
     * of the first scanline is stored.
     * @param band  The band whose offset is returned.
     */
    public int getDataOffset(int band) {
<span class="nc" id="L193">        return dataOffsets[band];</span>
    }

    /**
     * Returns the scanline stride -- the number of data array elements between
     * a given sample and the same sample in the same column of the next row.
     */
    public int getScanlineStride() {
<span class="nc" id="L201">        return scanlineStride;</span>
    }

    /**
     * Returns pixel stride -- the number of data array elements  between two
     * samples for the same band on the same scanline.
     */
    public int getPixelStride() {
<span class="nc" id="L209">        return pixelStride;</span>
    }

    /**
     * Returns a reference to the data array.
     */
    public short[] getDataStorage() {
<span class="nc" id="L216">        return data;</span>
    }

    /**
     * Returns the data elements for all bands at the specified
     * location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinate is out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param outData  An object reference to an array of type defined by
     *                 getTransferType() and length getNumDataElements().
     *                 If null an array of appropriate type and size will be
     *                 allocated.
     * @return         An object reference to an array of type defined by
     *                 getTransferType() with the request pixel data.
     */
    public Object getDataElements(int x, int y, Object obj) {
<span class="nc bnc" id="L236" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x &gt;= this.maxX) || (y &gt;= this.maxY)) {
<span class="nc" id="L238">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        short outData[];
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L243">            outData = new short[numDataElements];</span>
        } else {
<span class="nc" id="L245">            outData = (short[])obj;</span>
        }
<span class="nc" id="L247">        int off = (y-minY)*scanlineStride +</span>
                  (x-minX)*pixelStride;

<span class="nc bnc" id="L250" title="All 2 branches missed.">        for (int band = 0; band &lt; numDataElements; band++) {</span>
<span class="nc" id="L251">            outData[band] = data[dataOffsets[band] + off];</span>
        }

<span class="nc" id="L254">        return outData;</span>
    }

    /**
     * Returns an array  of data elements from the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * &lt;pre&gt;
     *       short[] bandData = (short[])Raster.getDataElements(x, y, w, h, null);
     *       int numDataElements = Raster.getBands();
     *       short[] pixel = new short[numDataElements];
     *       // To find the data element at location (x2, y2)
     *       System.arraycopy(bandData, ((y2-y)*w + (x2-x))*numDataElements,
     *                        pixel, 0, numDataElements);
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the pixel rectangle.
     * @param height   Height of the pixel rectangle.
     * @param outData  An object reference to an array of type defined by
     *                 getTransferType() and length w*h*getNumDataElements().
     *                 If null an array of appropriate type and size will be
     *                 allocated.
     * @return         An object reference to an array of type defined by
     *                 getTransferType() with the request pixel data.
     */
    public Object getDataElements(int x, int y, int w, int h, Object obj) {
<span class="nc bnc" id="L284" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L286">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        short outData[];
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L291">            outData = new short[w*h*numDataElements];</span>
        } else {
<span class="nc" id="L293">            outData = (short[])obj;</span>
        }
<span class="nc" id="L295">        int yoff = (y-minY)*scanlineStride +</span>
                   (x-minX)*pixelStride;

        int xoff;
<span class="nc" id="L299">        int off = 0;</span>
        int xstart;
        int ystart;

<span class="nc bnc" id="L303" title="All 2 branches missed.">        for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L304">            xoff = yoff;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                for (int c = 0; c &lt; numDataElements; c++) {</span>
<span class="nc" id="L307">                    outData[off++] = data[dataOffsets[c] + xoff];</span>
                }
            }
        }

<span class="nc" id="L312">        return outData;</span>
    }

    /**
     * Returns a short integer array of data elements from the
     * specified rectangular region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * &lt;pre&gt;
     *       short[] bandData = Raster.getShortData(x, y, w, h, null);
     *       // To find the data element at location (x2, y2)
     *       short dataElenent = bandData[((y2-y)*w + (x2-x))];
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the sample rectangle.
     * @param height   Height of the sample rectangle.
     * @param band     The band to return.
     * @param outData  If non-null, data elements for all bands
     *                 at the specified location are returned in this array.
     * @return         Data array with data elements for all bands.
     */
    public short[] getShortData(int x, int y, int w, int h,
                               int band, short[] outData) {
        // Bounds check for 'band' will be performed automatically
<span class="nc bnc" id="L337" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L339">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (outData == null) {</span>
<span class="nc" id="L343">            outData = new short[numDataElements*w*h];</span>
        }
<span class="nc" id="L345">        int yoff =  (y-minY)*scanlineStride +</span>
                    (x-minX)*pixelStride+ dataOffsets[band];
        int xoff;
<span class="nc" id="L348">        int off = 0;</span>
        int xstart;
        int ystart;

<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (pixelStride == 1) {</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (scanlineStride == w) {</span>
<span class="nc" id="L354">                System.arraycopy(data, yoff, outData, 0, w*h);</span>
            }
            else {
<span class="nc bnc" id="L357" title="All 2 branches missed.">                for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L358">                    System.arraycopy(data, yoff, outData, off, w);</span>
<span class="nc" id="L359">                    off += w;</span>
                }
            }
        }
        else {
<span class="nc bnc" id="L364" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L365">                xoff = yoff;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L367">                    outData[off++] = data[xoff];</span>
                }
            }
        }

<span class="nc" id="L372">        return outData;</span>
    }

    /**
     * Returns a short integer array  of data elements from the
     * specified rectangular region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * &lt;pre&gt;
     *       short[] bandData = Raster.getShortData(x, y, w, h, null);
     *       int numDataElements = Raster.getNumBands();
     *       short[] pixel = new short[numDataElements];
     *       // To find the data element at location (x2, y2)
     *       System.arraycopy(bandData, ((y2-y)*w + (x2-x))*numDataElements,
     *                        pixel, 0, numDataElements);
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the pixel rectangle.
     * @param height   Height of the pixel rectangle.
     * @param outData  If non-null, data elements for all bands
     *                 at the specified location are returned in this array.
     * @return         Data array with data elements for all bands.
     */
    public short[] getShortData(int x, int y, int w, int h, short[] outData) {
<span class="nc bnc" id="L397" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L399">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc bnc" id="L402" title="All 2 branches missed.">        if (outData == null) {</span>
<span class="nc" id="L403">            outData = new short[numDataElements*w*h];</span>
        }
<span class="nc" id="L405">        int yoff = (y-minY)*scanlineStride +</span>
                   (x-minX)*pixelStride;
        int xoff;
<span class="nc" id="L408">        int off = 0;</span>
        int xstart;
        int ystart;

<span class="nc bnc" id="L412" title="All 2 branches missed.">        for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L413">            xoff = yoff;</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">            for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                for (int c = 0; c &lt; numDataElements; c++) {</span>
<span class="nc" id="L416">                    outData[off++] = data[dataOffsets[c] + xoff];</span>
                }
            }
        }

<span class="nc" id="L421">        return outData;</span>
    }

    /**
     * Stores the data elements for all bands at the specified location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinate is out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param inData   An object reference to an array of type defined by
     *                 getTransferType() and length getNumDataElements()
     *                 containing the pixel data to place at x,y.
     */
    public void setDataElements(int x, int y, Object obj) {
<span class="nc bnc" id="L437" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x &gt;= this.maxX) || (y &gt;= this.maxY)) {
<span class="nc" id="L439">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L442">        short inData[] = (short[])obj;</span>
<span class="nc" id="L443">        int off = (y-minY)*scanlineStride +</span>
                  (x-minX)*pixelStride;
<span class="nc bnc" id="L445" title="All 2 branches missed.">        for (int i = 0; i &lt; numDataElements; i++) {</span>
<span class="nc" id="L446">            data[dataOffsets[i] + off] = (short) inData[i];</span>
        }
<span class="nc" id="L448">        markDirty();</span>
<span class="nc" id="L449">    }</span>

    /**
     * Stores the Raster data at the specified location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * @param x          The X coordinate of the pixel location.
     * @param y          The Y coordinate of the pixel location.
     * @param inRaster   Raster of data to place at x,y location.
     */
    public void setDataElements(int x, int y, Raster inRaster) {
<span class="nc" id="L460">        int dstOffX = x + inRaster.getMinX();</span>
<span class="nc" id="L461">        int dstOffY = y + inRaster.getMinY();</span>
<span class="nc" id="L462">        int width  = inRaster.getWidth();</span>
<span class="nc" id="L463">        int height = inRaster.getHeight();</span>
<span class="nc bnc" id="L464" title="All 8 branches missed.">        if ((dstOffX &lt; this.minX) || (dstOffY &lt; this.minY) ||</span>
            (dstOffX + width &gt; this.maxX) || (dstOffY + height &gt; this.maxY)) {
<span class="nc" id="L466">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L470">        setDataElements(dstOffX, dstOffY, width, height, inRaster);</span>
<span class="nc" id="L471">    }</span>

    /**
     * Stores the Raster data at the specified location.
     * @param dstX The absolute X coordinate of the destination pixel
     * that will receive a copy of the upper-left pixel of the
     * inRaster
     * @param dstY The absolute Y coordinate of the destination pixel
     * that will receive a copy of the upper-left pixel of the
     * inRaster
     * @param width      The number of pixels to store horizontally
     * @param height     The number of pixels to store vertically
     * @param inRaster   Raster of data to place at x,y location.
     */
    private void setDataElements(int dstX, int dstY,
                                 int width, int height,
                                 Raster inRaster) {
        // Assume bounds checking has been performed previously
<span class="nc bnc" id="L489" title="All 4 branches missed.">        if (width &lt;= 0 || height &lt;= 0) {</span>
<span class="nc" id="L490">            return;</span>
        }

        // Write inRaster (minX, minY) to (dstX, dstY)

<span class="nc" id="L495">        int srcOffX = inRaster.getMinX();</span>
<span class="nc" id="L496">        int srcOffY = inRaster.getMinY();</span>
<span class="nc" id="L497">        Object tdata = null;</span>

//      REMIND: Do something faster!
//      if (inRaster instanceof ShortInterleavedRaster) {
//      }

<span class="nc bnc" id="L503" title="All 2 branches missed.">        for (int startY=0; startY &lt; height; startY++) {</span>
            // Grab one scanline at a time
<span class="nc" id="L505">            tdata = inRaster.getDataElements(srcOffX, srcOffY+startY,</span>
                                             width, 1, tdata);
<span class="nc" id="L507">            setDataElements(dstX, dstY + startY, width, 1, tdata);</span>
        }
<span class="nc" id="L509">    }</span>

    /**
     * Stores an array of data elements into the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * for the nth band at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x))*numDataElements + n]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param inData   An object reference to an array of type defined by
     *                 getTransferType() and length w*h*getNumDataElements()
     *                 containing the pixel data to place between x,y and
     *                 x+h, y+h.
     */
    public void setDataElements(int x, int y, int w, int h, Object obj) {
<span class="nc bnc" id="L534" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L536">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L539">        short inData[] = (short[])obj;</span>
<span class="nc" id="L540">        int yoff = (y-minY)*scanlineStride +</span>
                   (x-minX)*pixelStride;
        int xoff;
<span class="nc" id="L543">        int off = 0;</span>
        int xstart;
        int ystart;

<span class="nc bnc" id="L547" title="All 2 branches missed.">        for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L548">            xoff = yoff;</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">                for (int c = 0; c &lt; numDataElements; c++) {</span>
<span class="nc" id="L551">                    data[dataOffsets[c] + xoff] = (short) inData[off++];</span>
                }
            }
        }

<span class="nc" id="L556">        markDirty();</span>
<span class="nc" id="L557">    }</span>

    /**
     * Stores a short integer array of data elements into the
     * specified rectangular region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x))]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param band     The band to set.
     * @param inData   The data elements to be stored.
     */
    public void putShortData(int x, int y, int w, int h,
                             int band, short[] inData) {
        // Bounds check for 'band' will be performed automatically
<span class="nc bnc" id="L580" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L582">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L585">        int yoff =  (y-minY)*scanlineStride +</span>
                    (x-minX)*pixelStride + dataOffsets[band];
        int xoff;
<span class="nc" id="L588">        int off = 0;</span>
        int xstart;
        int ystart;

<span class="nc bnc" id="L592" title="All 2 branches missed.">        if (pixelStride == 1) {</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">            if (scanlineStride == w) {</span>
<span class="nc" id="L594">                System.arraycopy(inData, 0, data, yoff, w*h);</span>
            }
            else {
<span class="nc bnc" id="L597" title="All 2 branches missed.">                for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L598">                    System.arraycopy(inData, off, data, yoff, w);</span>
<span class="nc" id="L599">                    off += w;</span>
                }
            }
        }
        else {
<span class="nc bnc" id="L604" title="All 2 branches missed.">            for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L605">                xoff = yoff;</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">                for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc" id="L607">                    data[xoff] = inData[off++];</span>
                }
            }
        }

<span class="nc" id="L612">        markDirty();</span>
<span class="nc" id="L613">    }</span>

    /**
     * Stores a short integer array of data elements into the
     * specified rectangular region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * for the nth band at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x))*numDataElements + n]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param inData   The data elements to be stored.
     */
    public void putShortData(int x, int y, int w, int h, short[] inData) {
<span class="nc bnc" id="L633" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L635">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L638">        int yoff = (y-minY)*scanlineStride +</span>
                   (x-minX)*pixelStride;
        int xoff;
<span class="nc" id="L641">        int off = 0;</span>
        int xstart;
        int ystart;

<span class="nc bnc" id="L645" title="All 2 branches missed.">        for (ystart=0; ystart &lt; h; ystart++, yoff += scanlineStride) {</span>
<span class="nc" id="L646">            xoff = yoff;</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">            for (xstart=0; xstart &lt; w; xstart++, xoff += pixelStride) {</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">                for (int c = 0; c &lt; numDataElements; c++) {</span>
<span class="nc" id="L649">                    data[dataOffsets[c] + xoff] = inData[off++];</span>
                }
            }
        }

<span class="nc" id="L654">        markDirty();</span>
<span class="nc" id="L655">    }</span>

    /**
     * Creates a subraster given a region of the raster.  The x and y
     * coordinates specify the horizontal and vertical offsets
     * from the upper-left corner of this raster to the upper-left corner
     * of the subraster.  A subset of the bands of the parent Raster may
     * be specified.  If this is null, then all the bands are present in the
     * subRaster. A translation to the subRaster may also be specified.
     * Note that the subraster will reference the same
     * band objects as the parent raster, but using different offsets.
     * @param x               X offset.
     * @param y               Y offset.
     * @param width           Width (in pixels) of the subraster.
     * @param height          Height (in pixels) of the subraster.
     * @param x0              Translated X origin of the subraster.
     * @param y0              Translated Y origin of the subraster.
     * @param bandList        Array of band indices.
     * @exception RasterFormatException
     *            if the specified bounding box is outside of the parent raster.
     */
    public Raster createChild (int x, int y,
                               int width, int height,
                               int x0, int y0, int[] bandList) {
<span class="nc" id="L679">        WritableRaster newRaster = createWritableChild(x, y,</span>
                                                       width, height,
                                                       x0, y0,
                                                       bandList);
<span class="nc" id="L683">        return (Raster) newRaster;</span>
    }

    /**
     * Creates a Writable subRaster given a region of the Raster. The x and y
     * coordinates specify the horizontal and vertical offsets
     * from the upper-left corner of this Raster to the upper-left corner
     * of the subRaster.  A subset of the bands of the parent Raster may
     * be specified.  If this is null, then all the bands are present in the
     * subRaster. A translation to the subRaster may also be specified.
     * Note that the subRaster will reference the same
     * DataBuffers as the parent Raster, but using different offsets.
     * @param x               X offset.
     * @param y               Y offset.
     * @param width           Width (in pixels) of the subraster.
     * @param height          Height (in pixels) of the subraster.
     * @param x0              Translated X origin of the subraster.
     * @param y0              Translated Y origin of the subraster.
     * @param bandList        Array of band indices.
     * @exception RasterFormatException
     *            if the specified bounding box is outside of the parent Raster.
     */
    public WritableRaster createWritableChild(int x, int y,
                                              int width, int height,
                                              int x0, int y0,
                                              int[] bandList) {
<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (x &lt; this.minX) {</span>
<span class="nc" id="L710">            throw new RasterFormatException(&quot;x lies outside the raster&quot;);</span>
        }
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (y &lt; this.minY) {</span>
<span class="nc" id="L713">            throw new RasterFormatException(&quot;y lies outside the raster&quot;);</span>
        }
<span class="nc bnc" id="L715" title="All 4 branches missed.">        if ((x+width &lt; x) || (x+width &gt; this.minX + this.width)) {</span>
<span class="nc" id="L716">            throw new RasterFormatException(&quot;(x + width) is outside of Raster&quot;);</span>
        }
<span class="nc bnc" id="L718" title="All 4 branches missed.">        if ((y+height &lt; y) || (y+height &gt; this.minY + this.height)) {</span>
<span class="nc" id="L719">            throw new RasterFormatException(&quot;(y + height) is outside of Raster&quot;);</span>
        }

        SampleModel sm;

<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (bandList != null)</span>
<span class="nc" id="L725">            sm = sampleModel.createSubsetSampleModel(bandList);</span>
        else
<span class="nc" id="L727">            sm = sampleModel;</span>

<span class="nc" id="L729">        int deltaX = x0 - x;</span>
<span class="nc" id="L730">        int deltaY = y0 - y;</span>

<span class="nc" id="L732">        return new ShortInterleavedRaster(sm,</span>
                                       dataBuffer,
                                       new Rectangle(x0, y0, width, height),
                                       new Point(sampleModelTranslateX+deltaX,
                                                 sampleModelTranslateY+deltaY),
                                       this);
    }

    /**
     * Creates a Raster with the same layout but using a different
     * width and height, and with new zeroed data arrays.
     */
    public WritableRaster createCompatibleWritableRaster(int w, int h) {
<span class="nc bnc" id="L745" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;=0) {</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">            throw new RasterFormatException(&quot;negative &quot;+</span>
                                          ((w &lt;= 0) ? &quot;width&quot; : &quot;height&quot;));
        }

<span class="nc" id="L750">        SampleModel sm = sampleModel.createCompatibleSampleModel(w, h);</span>

<span class="nc" id="L752">        return new ShortInterleavedRaster(sm, new Point(0, 0));</span>
    }

    /**
     * Creates a Raster with the same layout and the same
     * width and height, and with new zeroed data arrays.  If
     * the Raster is a subRaster, this will call
     * createCompatibleRaster(width, height).
     */
    public WritableRaster createCompatibleWritableRaster() {
<span class="nc" id="L762">        return createCompatibleWritableRaster(width,height);</span>
    }

    public String toString() {
<span class="nc" id="L766">        return new String (&quot;ShortInterleavedRaster: width = &quot;+width</span>
                           +&quot; height = &quot; + height
                           +&quot; #numDataElements &quot;+numDataElements);
                           // +&quot; xOff = &quot;+xOffset+&quot; yOff = &quot;+yOffset);
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>