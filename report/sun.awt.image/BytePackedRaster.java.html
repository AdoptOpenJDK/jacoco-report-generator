<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BytePackedRaster.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.awt.image</a> &gt; <span class="el_source">BytePackedRaster.java</span></div><h1>BytePackedRaster.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.image;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.awt.image.RasterFormatException;
import java.awt.image.SampleModel;
import java.awt.image.MultiPixelPackedSampleModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.Rectangle;
import java.awt.Point;

/**
 * This class is useful for describing 1, 2, or 4 bit image data
 * elements.  This raster has one band whose pixels are packed
 * together into individual bytes in a single byte array.  This type
 * of raster can be used with an IndexColorModel. This raster uses a
 * MultiPixelPackedSampleModel.
 *
 */
public class BytePackedRaster extends SunWritableRaster {

    /** The data bit offset for each pixel. */
    int           dataBitOffset;

    /** Scanline stride of the image data contained in this Raster. */
    int           scanlineStride;

    /**
     * The bit stride of a pixel, equal to the total number of bits
     * required to store a pixel.
     */
    int           pixelBitStride;

    /** The bit mask for extracting the pixel. */
    int           bitMask;

    /** The image data array. */
    byte[]        data;

    /** 8 minus the pixel bit stride. */
    int shiftOffset;

    int type;

    /** A cached copy of minX + width for use in bounds checks. */
    private int maxX;

    /** A cached copy of minY + height for use in bounds checks. */
    private int maxY;

    static private native void initIDs();
    static {
        /* ensure that the necessary native libraries are loaded */
<span class="nc" id="L79">        NativeLibLoader.loadLibraries();</span>
<span class="nc" id="L80">        initIDs();</span>
<span class="nc" id="L81">    }</span>

    /**
     * Constructs a BytePackedRaster with the given SampleModel.
     * The Raster's upper left corner is origin and it is the same
     * size as the SampleModel.  A DataBuffer large enough to describe the
     * Raster is automatically created.  SampleModel must be of type
     * MultiPixelPackedSampleModel.
     * @param sampleModel     The SampleModel that specifies the layout.
     * @param origin          The Point that specified the origin.
     */
    public BytePackedRaster(SampleModel sampleModel,
                            Point origin) {
<span class="nc" id="L94">        this(sampleModel,</span>
<span class="nc" id="L95">             sampleModel.createDataBuffer(),</span>
             new Rectangle(origin.x,
                           origin.y,
<span class="nc" id="L98">                           sampleModel.getWidth(),</span>
<span class="nc" id="L99">                           sampleModel.getHeight()),</span>
             origin,
             null);
<span class="nc" id="L102">    }</span>

    /**
     * Constructs a BytePackedRaster with the given SampleModel
     * and DataBuffer.  The Raster's upper left corner is origin and
     * it is the same size as the SampleModel.  The DataBuffer is not
     * initialized and must be a DataBufferByte compatible with SampleModel.
     * SampleModel must be of type MultiPixelPackedSampleModel.
     * @param sampleModel     The SampleModel that specifies the layout.
     * @param dataBuffer      The DataBufferShort that contains the image data.
     * @param origin          The Point that specifies the origin.
     */
    public BytePackedRaster(SampleModel sampleModel,
                            DataBuffer dataBuffer,
                            Point origin) {
<span class="nc" id="L117">        this(sampleModel,</span>
             dataBuffer,
             new Rectangle(origin.x,
                           origin.y,
<span class="nc" id="L121">                           sampleModel.getWidth(),</span>
<span class="nc" id="L122">                           sampleModel.getHeight()),</span>
             origin,
             null);
<span class="nc" id="L125">    }</span>

    /**
     * Constructs a BytePackedRaster with the given SampleModel,
     * DataBuffer, and parent.  DataBuffer must be a DataBufferByte and
     * SampleModel must be of type MultiPixelPackedSampleModel.
     * When translated into the base Raster's
     * coordinate system, aRegion must be contained by the base Raster.
     * Origin is the coordinate in the new Raster's coordinate system of
     * the origin of the base Raster.  (The base Raster is the Raster's
     * ancestor which has no parent.)
     *
     * Note that this constructor should generally be called by other
     * constructors or create methods, it should not be used directly.
     * @param sampleModel     The SampleModel that specifies the layout.
     * @param dataBuffer      The DataBufferShort that contains the image data.
     * @param aRegion         The Rectangle that specifies the image area.
     * @param origin          The Point that specifies the origin.
     * @param parent          The parent (if any) of this raster.
     *
     * @exception RasterFormatException if the parameters do not conform
     * to requirements of this Raster type.
     */
    public BytePackedRaster(SampleModel sampleModel,
                            DataBuffer dataBuffer,
                            Rectangle aRegion,
                            Point origin,
                            BytePackedRaster parent){
<span class="nc" id="L153">        super(sampleModel,dataBuffer,aRegion,origin, parent);</span>
<span class="nc" id="L154">        this.maxX = minX + width;</span>
<span class="nc" id="L155">        this.maxY = minY + height;</span>

<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (!(dataBuffer instanceof DataBufferByte)) {</span>
<span class="nc" id="L158">           throw new RasterFormatException(&quot;BytePackedRasters must have&quot; +</span>
                &quot;byte DataBuffers&quot;);
        }
<span class="nc" id="L161">        DataBufferByte dbb = (DataBufferByte)dataBuffer;</span>
<span class="nc" id="L162">        this.data = stealData(dbb, 0);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (dbb.getNumBanks() != 1) {</span>
<span class="nc" id="L164">            throw new</span>
                RasterFormatException(&quot;DataBuffer for BytePackedRasters&quot;+
                                      &quot; must only have 1 bank.&quot;);
        }
<span class="nc" id="L168">        int dbOffset = dbb.getOffset();</span>

<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (sampleModel instanceof MultiPixelPackedSampleModel) {</span>
<span class="nc" id="L171">            MultiPixelPackedSampleModel mppsm =</span>
                (MultiPixelPackedSampleModel)sampleModel;
<span class="nc" id="L173">            this.type = IntegerComponentRaster.TYPE_BYTE_BINARY_SAMPLES;</span>
<span class="nc" id="L174">            pixelBitStride = mppsm.getPixelBitStride();</span>
<span class="nc bnc" id="L175" title="All 6 branches missed.">            if (pixelBitStride != 1 &amp;&amp;</span>
                pixelBitStride != 2 &amp;&amp;
                pixelBitStride != 4) {
<span class="nc" id="L178">                throw new RasterFormatException</span>
                  (&quot;BytePackedRasters must have a bit depth of 1, 2, or 4&quot;);
            }
<span class="nc" id="L181">            scanlineStride = mppsm.getScanlineStride();</span>
<span class="nc" id="L182">            dataBitOffset = mppsm.getDataBitOffset() + dbOffset*8;</span>
<span class="nc" id="L183">            int xOffset = aRegion.x - origin.x;</span>
<span class="nc" id="L184">            int yOffset = aRegion.y - origin.y;</span>
<span class="nc" id="L185">            dataBitOffset += xOffset*pixelBitStride + yOffset*scanlineStride*8;</span>
<span class="nc" id="L186">            bitMask = (1 &lt;&lt; pixelBitStride) -1;</span>
<span class="nc" id="L187">            shiftOffset = 8 - pixelBitStride;</span>
<span class="nc" id="L188">        } else {</span>
<span class="nc" id="L189">            throw new RasterFormatException(&quot;BytePackedRasters must have&quot;+</span>
                &quot;MultiPixelPackedSampleModel&quot;);
        }
<span class="nc" id="L192">        verify(false);</span>
<span class="nc" id="L193">    }</span>

    /**
     * Returns the data bit offset for the Raster.  The data
     * bit offset is the bit index into the data array element
     * corresponding to the first sample of the first scanline.
     */
    public int getDataBitOffset() {
<span class="nc" id="L201">        return dataBitOffset;</span>
    }

    /**
     * Returns the scanline stride -- the number of data array elements between
     * a given sample and the sample in the same column
     * of the next row.
     */
    public int getScanlineStride() {
<span class="nc" id="L210">        return scanlineStride;</span>
    }

    /**
     * Returns pixel bit stride -- the number of bits between two
     * samples on the same scanline.
     */
    public int getPixelBitStride() {
<span class="nc" id="L218">        return pixelBitStride;</span>
    }

    /**
     * Returns a reference to the entire data array.
     */
    public byte[] getDataStorage() {
<span class="nc" id="L225">        return data;</span>
    }

    /**
     * Returns the data element at the specified
     * location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinate is out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param outData  An object reference to an array of type defined by
     *                 getTransferType() and length getNumDataElements().
     *                 If null an array of appropriate type and size will be
     *                 allocated.
     * @return         An object reference to an array of type defined by
     *                 getTransferType() with the request pixel data.
     */
    public Object getDataElements(int x, int y, Object obj) {
<span class="nc bnc" id="L245" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x &gt;= this.maxX) || (y &gt;= this.maxY)) {
<span class="nc" id="L247">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        byte outData[];
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L252">            outData = new byte[numDataElements];</span>
        } else {
<span class="nc" id="L254">            outData = (byte[])obj;</span>
        }
<span class="nc" id="L256">        int bitnum = dataBitOffset + (x-minX) * pixelBitStride;</span>
        // Fix 4184283
<span class="nc" id="L258">        int element = data[(y-minY) * scanlineStride + (bitnum &gt;&gt; 3)] &amp; 0xff;</span>
<span class="nc" id="L259">        int shift = shiftOffset - (bitnum &amp; 7);</span>
<span class="nc" id="L260">        outData[0] = (byte)((element &gt;&gt; shift) &amp; bitMask);</span>
<span class="nc" id="L261">        return outData;</span>
    }

    /**
     * Returns the pixel data for the specified rectangle of pixels in a
     * primitive array of type TransferType.
     * For image data supported by the Java 2D API, this
     * will be one of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, or
     * DataBuffer.TYPE_INT.  Data may be returned in a packed format,
     * thus increasing efficiency for data transfers.
     *
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of TransferType.
     * @see java.awt.image.SampleModel#getDataElements(int, int, int, int, Object, DataBuffer)
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param outData  An object reference to an array of type defined by
     *                 getTransferType() and length w*h*getNumDataElements().
     *                 If null, an array of appropriate type and size will be
     *                 allocated.
     * @return         An object reference to an array of type defined by
     *                 getTransferType() with the requested pixel data.
     */
    public Object getDataElements(int x, int y, int w, int h,
                                  Object outData) {
<span class="nc" id="L290">        return getByteData(x, y, w, h, (byte[])outData);</span>
    }

    /**
     * Returns an array  of data elements from the specified rectangular
     * region.
     *
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * &lt;pre&gt;
     *       byte[] bandData = (byte[])raster.getPixelData(x, y, w, h, null);
     *       int pixel;
     *       // To find a data element at location (x2, y2)
     *       pixel = bandData[((y2-y)*w + (x2-x))];
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the pixel rectangle.
     * @param height   Height of the pixel rectangle.
     * @param outData  An object reference to an array of type defined by
     *                 getTransferType() and length w*h*getNumDataElements().
     *                 If null an array of appropriate type and size will be
     *                 allocated.
     * @return         An object reference to an array of type defined by
     *                 getTransferType() with the request pixel data.
     */
    public Object getPixelData(int x, int y, int w, int h, Object obj) {
<span class="nc bnc" id="L319" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L321">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        byte outData[];
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L326">            outData = new byte[numDataElements*w*h];</span>
        } else {
<span class="nc" id="L328">            outData = (byte[])obj;</span>
        }
<span class="nc" id="L330">        int pixbits = pixelBitStride;</span>
<span class="nc" id="L331">        int scanbit = dataBitOffset + (x-minX) * pixbits;</span>
<span class="nc" id="L332">        int index = (y-minY) * scanlineStride;</span>
<span class="nc" id="L333">        int outindex = 0;</span>
<span class="nc" id="L334">        byte data[] = this.data;</span>

<span class="nc bnc" id="L336" title="All 2 branches missed.">        for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L337">            int bitnum = scanbit;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            for (int i = 0; i &lt; w; i++) {</span>
<span class="nc" id="L339">                int shift = shiftOffset - (bitnum &amp; 7);</span>
<span class="nc" id="L340">                outData[outindex++] =</span>
                    (byte)(bitMask &amp; (data[index + (bitnum &gt;&gt; 3)] &gt;&gt; shift));
<span class="nc" id="L342">                bitnum += pixbits;</span>
            }
<span class="nc" id="L344">            index += scanlineStride;</span>
        }
<span class="nc" id="L346">        return outData;</span>
    }

    /**
     * Returns a byte array containing the specified data elements
     * from the data array.  The band index will be ignored.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * &lt;pre&gt;
     *       byte[] byteData = getByteData(x, y, band, w, h, null);
     *       // To find a data element at location (x2, y2)
     *       byte element = byteData[(y2-y)*w + (x2-x)];
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the pixel rectangle.
     * @param height   Height of the pixel rectangle.
     * @param band     The band to return, is ignored.
     * @param outData  If non-null, data elements
     *                 at the specified locations are returned in this array.
     * @return         Byte array with data elements.
     */
    public byte[] getByteData(int x, int y, int w, int h,
                              int band, byte[] outData) {
<span class="nc" id="L370">        return getByteData(x, y, w, h, outData);</span>
    }

    /**
     * Returns a byte array containing the specified data elements
     * from the data array.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * &lt;pre&gt;
     *       byte[] byteData = raster.getByteData(x, y, w, h, null);
     *       byte pixel;
     *       // To find a data element at location (x2, y2)
     *       pixel = byteData[((y2-y)*w + (x2-x))];
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param width    Width of the pixel rectangle.
     * @param height   Height of the pixel rectangle.
     * @param outData  If non-null, data elements
     *                 at the specified locations are returned in this array.
     * @return         Byte array with data elements.
     */
    public byte[] getByteData(int x, int y, int w, int h, byte[] outData) {
<span class="nc bnc" id="L393" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L395">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (outData == null) {</span>
<span class="nc" id="L399">            outData = new byte[w * h];</span>
        }
<span class="nc" id="L401">        int pixbits = pixelBitStride;</span>
<span class="nc" id="L402">        int scanbit = dataBitOffset + (x-minX) * pixbits;</span>
<span class="nc" id="L403">        int index = (y-minY) * scanlineStride;</span>
<span class="nc" id="L404">        int outindex = 0;</span>
<span class="nc" id="L405">        byte data[] = this.data;</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">        for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L408">            int bitnum = scanbit;</span>
            int element;

            // Process initial portion of scanline
<span class="nc" id="L412">            int i = 0;</span>
<span class="nc bnc" id="L413" title="All 4 branches missed.">            while ((i &lt; w) &amp;&amp; ((bitnum &amp; 7) != 0)) {</span>
<span class="nc" id="L414">                int shift = shiftOffset - (bitnum &amp; 7);</span>
<span class="nc" id="L415">                outData[outindex++] =</span>
                    (byte)(bitMask &amp; (data[index + (bitnum &gt;&gt; 3)] &gt;&gt; shift));
<span class="nc" id="L417">                bitnum += pixbits;</span>
<span class="nc" id="L418">                i++;</span>
<span class="nc" id="L419">            }</span>

            // Process central portion of scanline 8 pixels at a time
<span class="nc" id="L422">            int inIndex = index + (bitnum &gt;&gt; 3);</span>
<span class="nc bnc" id="L423" title="All 4 branches missed.">            switch (pixbits) {</span>
            case 1:
<span class="nc bnc" id="L425" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L426">                    element = data[inIndex++];</span>
<span class="nc" id="L427">                    outData[outindex++] = (byte)((element &gt;&gt; 7) &amp; 1);</span>
<span class="nc" id="L428">                    outData[outindex++] = (byte)((element &gt;&gt; 6) &amp; 1);</span>
<span class="nc" id="L429">                    outData[outindex++] = (byte)((element &gt;&gt; 5) &amp; 1);</span>
<span class="nc" id="L430">                    outData[outindex++] = (byte)((element &gt;&gt; 4) &amp; 1);</span>
<span class="nc" id="L431">                    outData[outindex++] = (byte)((element &gt;&gt; 3) &amp; 1);</span>
<span class="nc" id="L432">                    outData[outindex++] = (byte)((element &gt;&gt; 2) &amp; 1);</span>
<span class="nc" id="L433">                    outData[outindex++] = (byte)((element &gt;&gt; 1) &amp; 1);</span>
<span class="nc" id="L434">                    outData[outindex++] = (byte)(element &amp; 1);</span>
<span class="nc" id="L435">                    bitnum += 8;</span>
                }
                break;

            case 2:
<span class="nc bnc" id="L440" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L441">                    element = data[inIndex++];</span>
<span class="nc" id="L442">                    outData[outindex++] = (byte)((element &gt;&gt; 6) &amp; 3);</span>
<span class="nc" id="L443">                    outData[outindex++] = (byte)((element &gt;&gt; 4) &amp; 3);</span>
<span class="nc" id="L444">                    outData[outindex++] = (byte)((element &gt;&gt; 2) &amp; 3);</span>
<span class="nc" id="L445">                    outData[outindex++] = (byte)(element &amp; 3);</span>

<span class="nc" id="L447">                    element = data[inIndex++];</span>
<span class="nc" id="L448">                    outData[outindex++] = (byte)((element &gt;&gt; 6) &amp; 3);</span>
<span class="nc" id="L449">                    outData[outindex++] = (byte)((element &gt;&gt; 4) &amp; 3);</span>
<span class="nc" id="L450">                    outData[outindex++] = (byte)((element &gt;&gt; 2) &amp; 3);</span>
<span class="nc" id="L451">                    outData[outindex++] = (byte)(element &amp; 3);</span>

<span class="nc" id="L453">                    bitnum += 16;</span>
                }
                break;

            case 4:
<span class="nc bnc" id="L458" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L459">                    element = data[inIndex++];</span>
<span class="nc" id="L460">                    outData[outindex++] = (byte)((element &gt;&gt; 4) &amp; 0xf);</span>
<span class="nc" id="L461">                    outData[outindex++] = (byte)(element &amp; 0xf);</span>

<span class="nc" id="L463">                    element = data[inIndex++];</span>
<span class="nc" id="L464">                    outData[outindex++] = (byte)((element &gt;&gt; 4) &amp; 0xf);</span>
<span class="nc" id="L465">                    outData[outindex++] = (byte)(element &amp; 0xf);</span>

<span class="nc" id="L467">                    element = data[inIndex++];</span>
<span class="nc" id="L468">                    outData[outindex++] = (byte)((element &gt;&gt; 4) &amp; 0xf);</span>
<span class="nc" id="L469">                    outData[outindex++] = (byte)(element &amp; 0xf);</span>

<span class="nc" id="L471">                    element = data[inIndex++];</span>
<span class="nc" id="L472">                    outData[outindex++] = (byte)((element &gt;&gt; 4) &amp; 0xf);</span>
<span class="nc" id="L473">                    outData[outindex++] = (byte)(element &amp; 0xf);</span>

<span class="nc" id="L475">                    bitnum += 32;</span>
                }
                break;
            }

            // Process final portion of scanline
<span class="nc bnc" id="L481" title="All 2 branches missed.">            for (; i &lt; w; i++) {</span>
<span class="nc" id="L482">                int shift = shiftOffset - (bitnum &amp; 7);</span>
<span class="nc" id="L483">                outData[outindex++] =</span>
                    (byte) (bitMask &amp; (data[index + (bitnum &gt;&gt; 3)] &gt;&gt; shift));
<span class="nc" id="L485">                bitnum += pixbits;</span>
            }

<span class="nc" id="L488">            index += scanlineStride;</span>
        }

<span class="nc" id="L491">        return outData;</span>
    }

    /**
     * Stores the data elements at the specified location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinate is out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param inData   An object reference to an array of type defined by
     *                 getTransferType() and length getNumDataElements()
     *                 containing the pixel data to place at x,y.
     */
    public void setDataElements(int x, int y, Object obj) {
<span class="nc bnc" id="L507" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x &gt;= this.maxX) || (y &gt;= this.maxY)) {
<span class="nc" id="L509">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L512">        byte inData[] = (byte[])obj;</span>
<span class="nc" id="L513">        int bitnum = dataBitOffset + (x-minX) * pixelBitStride;</span>
<span class="nc" id="L514">        int index = (y-minY) * scanlineStride + (bitnum &gt;&gt; 3);</span>
<span class="nc" id="L515">        int shift = shiftOffset - (bitnum &amp; 7);</span>

<span class="nc" id="L517">        byte element = data[index];</span>
<span class="nc" id="L518">        element &amp;= ~(bitMask &lt;&lt; shift);</span>
<span class="nc" id="L519">        element |= (inData[0] &amp; bitMask) &lt;&lt; shift;</span>
<span class="nc" id="L520">        data[index] = element;</span>

<span class="nc" id="L522">        markDirty();</span>
<span class="nc" id="L523">    }</span>

    /**
     * Stores the Raster data at the specified location.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * @param x          The X coordinate of the pixel location.
     * @param y          The Y coordinate of the pixel location.
     * @param inRaster   Raster of data to place at x,y location.
     */
    public void setDataElements(int x, int y, Raster inRaster) {
        // Check if we can use fast code
<span class="nc bnc" id="L535" title="All 4 branches missed.">        if (!(inRaster instanceof BytePackedRaster) ||</span>
            ((BytePackedRaster)inRaster).pixelBitStride != pixelBitStride) {
<span class="nc" id="L537">            super.setDataElements(x, y, inRaster);</span>
<span class="nc" id="L538">            return;</span>
        }

<span class="nc" id="L541">        int srcOffX = inRaster.getMinX();</span>
<span class="nc" id="L542">        int srcOffY = inRaster.getMinY();</span>
<span class="nc" id="L543">        int dstOffX = srcOffX + x;</span>
<span class="nc" id="L544">        int dstOffY = srcOffY + y;</span>
<span class="nc" id="L545">        int width = inRaster.getWidth();</span>
<span class="nc" id="L546">        int height = inRaster.getHeight();</span>
<span class="nc bnc" id="L547" title="All 8 branches missed.">        if ((dstOffX &lt; this.minX) || (dstOffY &lt; this.minY) ||</span>
            (dstOffX + width &gt; this.maxX) || (dstOffY + height &gt; this.maxY)) {
<span class="nc" id="L549">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L552">        setDataElements(dstOffX, dstOffY,</span>
                        srcOffX, srcOffY,
                        width, height,
                        (BytePackedRaster)inRaster);
<span class="nc" id="L556">    }</span>

    /**
     * Stores the Raster data at the specified location.
     * @param dstX The absolute X coordinate of the destination pixel
     * that will receive a copy of the upper-left pixel of the
     * inRaster
     * @param dstY The absolute Y coordinate of the destination pixel
     * that will receive a copy of the upper-left pixel of the
     * inRaster
     * @param srcX The absolute X coordinate of the upper-left source
     * pixel that will be copied into this Raster
     * @param srcY The absolute Y coordinate of the upper-left source
     * pixel that will be copied into this Raster
     * @param width      The number of pixels to store horizontally
     * @param height     The number of pixels to store vertically
     * @param inRaster   BytePackedRaster of data to place at x,y location.
     */
    private void setDataElements(int dstX, int dstY,
                                 int srcX, int srcY,
                                 int width, int height,
                                 BytePackedRaster inRaster) {
        // Assume bounds checking has been performed previously
<span class="nc bnc" id="L579" title="All 4 branches missed.">        if (width &lt;= 0 || height &lt;= 0) {</span>
<span class="nc" id="L580">            return;</span>
        }

<span class="nc" id="L583">        byte[] inData = inRaster.data;</span>
<span class="nc" id="L584">        byte[] outData = this.data;</span>

<span class="nc" id="L586">        int inscan = inRaster.scanlineStride;</span>
<span class="nc" id="L587">        int outscan = this.scanlineStride;</span>
<span class="nc" id="L588">        int inbit = inRaster.dataBitOffset +</span>
                      8 * (srcY - inRaster.minY) * inscan +
                      (srcX - inRaster.minX) * inRaster.pixelBitStride;
<span class="nc" id="L591">        int outbit = (this.dataBitOffset +</span>
                      8 * (dstY - minY) * outscan +
                      (dstX - minX) * this.pixelBitStride);
<span class="nc" id="L594">        int copybits = width * pixelBitStride;</span>

        // Check whether the same bit alignment is present in both
        // Rasters; if so, we can copy whole bytes using
        // System.arraycopy.  If not, we must do a &quot;funnel shift&quot;
        // where adjacent bytes contribute to each destination byte.
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if ((inbit &amp; 7) == (outbit &amp; 7)) {</span>
            // copy is bit aligned
<span class="nc" id="L602">            int bitpos = outbit &amp; 7;</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">            if (bitpos != 0) {</span>
<span class="nc" id="L604">                int bits = 8 - bitpos;</span>
                // Copy partial bytes on left
<span class="nc" id="L606">                int inbyte = inbit &gt;&gt; 3;</span>
<span class="nc" id="L607">                int outbyte = outbit &gt;&gt; 3;</span>
<span class="nc" id="L608">                int mask = 0xff &gt;&gt; bitpos;</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                if (copybits &lt; bits) {</span>
                    // Fix bug 4399076: previously had '8 - copybits' instead
                    // of 'bits - copybits'.
                    //
                    // Prior to the this expression, 'mask' has its rightmost
                    // 'bits' bits set to '1'.  We want it to have a total
                    // of 'copybits' bits set, therefore we want to introduce
                    // 'bits - copybits' zeroes on the right.
<span class="nc" id="L617">                    mask &amp;= 0xff &lt;&lt; (bits - copybits);</span>
<span class="nc" id="L618">                    bits = copybits;</span>
                }
<span class="nc bnc" id="L620" title="All 2 branches missed.">                for (int j = 0; j &lt; height; j++) {</span>
<span class="nc" id="L621">                    int element = outData[outbyte];</span>
<span class="nc" id="L622">                    element &amp;= ~mask;</span>
<span class="nc" id="L623">                    element |= (inData[inbyte] &amp; mask);</span>
<span class="nc" id="L624">                    outData[outbyte] = (byte) element;</span>
<span class="nc" id="L625">                    inbyte += inscan;</span>
<span class="nc" id="L626">                    outbyte += outscan;</span>
                }
<span class="nc" id="L628">                inbit += bits;</span>
<span class="nc" id="L629">                outbit += bits;</span>
<span class="nc" id="L630">                copybits -= bits;</span>
            }
<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (copybits &gt;= 8) {</span>
                // Copy whole bytes
<span class="nc" id="L634">                int inbyte = inbit &gt;&gt; 3;</span>
<span class="nc" id="L635">                int outbyte = outbit &gt;&gt; 3;</span>
<span class="nc" id="L636">                int copybytes = copybits &gt;&gt; 3;</span>
<span class="nc bnc" id="L637" title="All 4 branches missed.">                if (copybytes == inscan &amp;&amp; inscan == outscan) {</span>
<span class="nc" id="L638">                    System.arraycopy(inData, inbyte,</span>
                                     outData, outbyte,
                                     inscan * height);
                } else {
<span class="nc bnc" id="L642" title="All 2 branches missed.">                    for (int j = 0; j &lt; height; j++) {</span>
<span class="nc" id="L643">                        System.arraycopy(inData, inbyte,</span>
                                         outData, outbyte,
                                         copybytes);
<span class="nc" id="L646">                        inbyte += inscan;</span>
<span class="nc" id="L647">                        outbyte += outscan;</span>
                    }
                }

<span class="nc" id="L651">                int bits = copybytes*8;</span>
<span class="nc" id="L652">                inbit += bits;</span>
<span class="nc" id="L653">                outbit += bits;</span>
<span class="nc" id="L654">                copybits -= bits;</span>
            }
<span class="nc bnc" id="L656" title="All 2 branches missed.">            if (copybits &gt; 0) {</span>
                // Copy partial bytes on right
<span class="nc" id="L658">                int inbyte = inbit &gt;&gt; 3;</span>
<span class="nc" id="L659">                int outbyte = outbit &gt;&gt; 3;</span>
<span class="nc" id="L660">                int mask = (0xff00 &gt;&gt; copybits) &amp; 0xff;</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                for (int j = 0; j &lt; height; j++) {</span>
<span class="nc" id="L662">                    int element = outData[outbyte];</span>
<span class="nc" id="L663">                    element &amp;= ~mask;</span>
<span class="nc" id="L664">                    element |= (inData[inbyte] &amp; mask);</span>
<span class="nc" id="L665">                    outData[outbyte] = (byte) element;</span>
<span class="nc" id="L666">                    inbyte += inscan;</span>
<span class="nc" id="L667">                    outbyte += outscan;</span>
                }
            }
<span class="nc" id="L670">        } else {</span>
            // Unaligned case, see RFE #4284166
            // Note that the code in that RFE is not correct

            // Insert bits into the first byte of the output
            // if either the starting bit position is not zero or
            // we are writing fewer than 8 bits in total
<span class="nc" id="L677">            int bitpos = outbit &amp; 7;</span>
<span class="nc bnc" id="L678" title="All 4 branches missed.">            if (bitpos != 0 || copybits &lt; 8) {</span>
<span class="nc" id="L679">                int bits = 8 - bitpos;</span>
<span class="nc" id="L680">                int inbyte = inbit &gt;&gt; 3;</span>
<span class="nc" id="L681">                int outbyte = outbit &gt;&gt; 3;</span>

<span class="nc" id="L683">                int lshift = inbit &amp; 7;</span>
<span class="nc" id="L684">                int rshift = 8 - lshift;</span>
<span class="nc" id="L685">                int mask = 0xff &gt;&gt; bitpos;</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">                if (copybits &lt; bits) {</span>
                    // Fix mask if we're only writing a partial byte
<span class="nc" id="L688">                    mask &amp;= 0xff &lt;&lt; (bits - copybits);</span>
<span class="nc" id="L689">                    bits = copybits;</span>
                }
<span class="nc" id="L691">                int lastByte = inData.length - 1;</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                for (int j = 0; j &lt; height; j++) {</span>
                    // Read two bytes from the source if possible
                    // Don't worry about going over a scanline boundary
                    // since any extra bits won't get used anyway
<span class="nc" id="L696">                    byte inData0 = inData[inbyte];</span>
<span class="nc" id="L697">                    byte inData1 = (byte)0;</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">                    if (inbyte &lt; lastByte) {</span>
<span class="nc" id="L699">                        inData1 = inData[inbyte + 1];</span>
                    }

                    // Insert the new bits into the output
<span class="nc" id="L703">                    int element = outData[outbyte];</span>
<span class="nc" id="L704">                    element &amp;= ~mask;</span>
<span class="nc" id="L705">                    element |= (((inData0 &lt;&lt; lshift) |</span>
                                 ((inData1 &amp; 0xff) &gt;&gt; rshift))
                                &gt;&gt; bitpos) &amp; mask;
<span class="nc" id="L708">                    outData[outbyte] = (byte)element;</span>
<span class="nc" id="L709">                    inbyte += inscan;</span>
<span class="nc" id="L710">                    outbyte += outscan;</span>
                }

<span class="nc" id="L713">                inbit += bits;</span>
<span class="nc" id="L714">                outbit += bits;</span>
<span class="nc" id="L715">                copybits -= bits;</span>
            }

            // Now we have outbit &amp; 7 == 0 so we can write
            // complete bytes for a while

            // Make sure we have work to do in the central loop
            // to avoid reading past the end of the scanline
<span class="nc bnc" id="L723" title="All 2 branches missed.">            if (copybits &gt;= 8) {</span>
<span class="nc" id="L724">                int inbyte = inbit &gt;&gt; 3;</span>
<span class="nc" id="L725">                int outbyte = outbit &gt;&gt; 3;</span>
<span class="nc" id="L726">                int copybytes = copybits &gt;&gt; 3;</span>
<span class="nc" id="L727">                int lshift = inbit &amp; 7;</span>
<span class="nc" id="L728">                int rshift = 8 - lshift;</span>

<span class="nc bnc" id="L730" title="All 2 branches missed.">                for (int j = 0; j &lt; height; j++) {</span>
<span class="nc" id="L731">                    int ibyte = inbyte + j*inscan;</span>
<span class="nc" id="L732">                    int obyte = outbyte + j*outscan;</span>

<span class="nc" id="L734">                    int inData0 = inData[ibyte];</span>
                    // Combine adjacent bytes while 8 or more bits left
<span class="nc bnc" id="L736" title="All 2 branches missed.">                    for (int i = 0; i &lt; copybytes; i++) {</span>
<span class="nc" id="L737">                        int inData1 = inData[ibyte + 1];</span>
<span class="nc" id="L738">                        int val = (inData0 &lt;&lt; lshift) |</span>
                            ((inData1 &amp; 0xff) &gt;&gt; rshift);
<span class="nc" id="L740">                        outData[obyte] = (byte)val;</span>
<span class="nc" id="L741">                        inData0 = inData1;</span>

<span class="nc" id="L743">                        ++ibyte;</span>
<span class="nc" id="L744">                        ++obyte;</span>
                    }
                }

<span class="nc" id="L748">                int bits = copybytes*8;</span>
<span class="nc" id="L749">                inbit += bits;</span>
<span class="nc" id="L750">                outbit += bits;</span>
<span class="nc" id="L751">                copybits -= bits;</span>
            }

            // Finish last byte
<span class="nc bnc" id="L755" title="All 2 branches missed.">            if (copybits &gt; 0) {</span>
<span class="nc" id="L756">                int inbyte = inbit &gt;&gt; 3;</span>
<span class="nc" id="L757">                int outbyte = outbit &gt;&gt; 3;</span>
<span class="nc" id="L758">                int mask = (0xff00 &gt;&gt; copybits) &amp; 0xff;</span>
<span class="nc" id="L759">                int lshift = inbit &amp; 7;</span>
<span class="nc" id="L760">                int rshift = 8 - lshift;</span>

<span class="nc" id="L762">                int lastByte = inData.length - 1;</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">                for (int j = 0; j &lt; height; j++) {</span>
<span class="nc" id="L764">                    byte inData0 = inData[inbyte];</span>
<span class="nc" id="L765">                    byte inData1 = (byte)0;</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">                    if (inbyte &lt; lastByte) {</span>
<span class="nc" id="L767">                        inData1 = inData[inbyte + 1];</span>
                    }

                    // Insert the new bits into the output
<span class="nc" id="L771">                    int element = outData[outbyte];</span>
<span class="nc" id="L772">                    element &amp;= ~mask;</span>
<span class="nc" id="L773">                    element |= ((inData0 &lt;&lt; lshift) |</span>
                                ((inData1 &amp; 0xff) &gt;&gt; rshift)) &amp; mask;
<span class="nc" id="L775">                    outData[outbyte] = (byte)element;</span>

<span class="nc" id="L777">                    inbyte += inscan;</span>
<span class="nc" id="L778">                    outbyte += outscan;</span>
                }
            }
        }

<span class="nc" id="L783">        markDirty();</span>
<span class="nc" id="L784">    }</span>

    /**
     * Copies pixels from Raster srcRaster to this WritableRaster.
     * For each (x, y) address in srcRaster, the corresponding pixel
     * is copied to address (x+dx, y+dy) in this WritableRaster,
     * unless (x+dx, y+dy) falls outside the bounds of this raster.
     * srcRaster must have the same number of bands as this WritableRaster.
     * The copy is a simple copy of source samples to the corresponding
     * destination samples.  For details, see
     * {@link WritableRaster#setRect(Raster)}.
     *
     * @param dx        The X translation factor from src space to dst space
     *                  of the copy.
     * @param dy        The Y translation factor from src space to dst space
     *                  of the copy.
     * @param srcRaster The Raster from which to copy pixels.
     */
    public void setRect(int dx, int dy, Raster srcRaster) {
        // Check if we can use fast code
<span class="nc bnc" id="L804" title="All 4 branches missed.">        if (!(srcRaster instanceof BytePackedRaster) ||</span>
            ((BytePackedRaster)srcRaster).pixelBitStride != pixelBitStride) {
<span class="nc" id="L806">            super.setRect(dx, dy, srcRaster);</span>
<span class="nc" id="L807">            return;</span>
        }

<span class="nc" id="L810">        int width  = srcRaster.getWidth();</span>
<span class="nc" id="L811">        int height = srcRaster.getHeight();</span>
<span class="nc" id="L812">        int srcOffX = srcRaster.getMinX();</span>
<span class="nc" id="L813">        int srcOffY = srcRaster.getMinY();</span>
<span class="nc" id="L814">        int dstOffX = dx+srcOffX;</span>
<span class="nc" id="L815">        int dstOffY = dy+srcOffY;</span>

        // Clip to this raster
<span class="nc bnc" id="L818" title="All 2 branches missed.">        if (dstOffX &lt; this.minX) {</span>
<span class="nc" id="L819">            int skipX = this.minX - dstOffX;</span>
<span class="nc" id="L820">            width -= skipX;</span>
<span class="nc" id="L821">            srcOffX += skipX;</span>
<span class="nc" id="L822">            dstOffX = this.minX;</span>
        }
<span class="nc bnc" id="L824" title="All 2 branches missed.">        if (dstOffY &lt; this.minY) {</span>
<span class="nc" id="L825">            int skipY = this.minY - dstOffY;</span>
<span class="nc" id="L826">            height -= skipY;</span>
<span class="nc" id="L827">            srcOffY += skipY;</span>
<span class="nc" id="L828">            dstOffY = this.minY;</span>
        }
<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (dstOffX+width &gt; this.maxX) {</span>
<span class="nc" id="L831">            width = this.maxX - dstOffX;</span>
        }
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (dstOffY+height &gt; this.maxY) {</span>
<span class="nc" id="L834">            height = this.maxY - dstOffY;</span>
        }

<span class="nc" id="L837">        setDataElements(dstOffX, dstOffY,</span>
                        srcOffX, srcOffY,
                        width, height,
                        (BytePackedRaster)srcRaster);
<span class="nc" id="L841">    }</span>

    /**
     * Stores an array of data elements into the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of transferType.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x))]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param inData   An object reference to an array of type defined by
     *                 getTransferType() and length w*h*getNumDataElements()
     *                 containing the pixel data to place between x,y and
     *                 x+h, y+h.
     */
    public void setDataElements(int x, int y, int w, int h, Object obj) {
<span class="nc" id="L866">        putByteData(x, y, w, h, (byte[])obj);</span>
<span class="nc" id="L867">    }</span>

    /**
     * Stores a byte array of data elements into the specified rectangular
     * region.  The band index will be ignored.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x))]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param band     The band to set, is ignored.
     * @param inData   The data elements to be stored.
     */
    public void putByteData(int x, int y, int w, int h,
                            int band, byte[] inData) {
<span class="nc" id="L889">        putByteData(x, y, w, h, inData);</span>
<span class="nc" id="L890">    }</span>

    /**
     * Stores a byte array of data elements into the specified rectangular
     * region.
     * An ArrayIndexOutOfBounds exception will be thrown at runtime
     * if the pixel coordinates are out of bounds.
     * The data elements in the
     * data array are assumed to be packed.  That is, a data element
     * at location (x2, y2) would be found at:
     * &lt;pre&gt;
     *      inData[((y2-y)*w + (x2-x))]
     * &lt;/pre&gt;
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param inData   The data elements to be stored.
     */
    public void putByteData(int x, int y, int w, int h, byte[] inData) {
<span class="nc bnc" id="L910" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L912">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc bnc" id="L915" title="All 4 branches missed.">        if (w == 0 || h == 0) {</span>
<span class="nc" id="L916">            return;</span>
        }

<span class="nc" id="L919">        int pixbits = pixelBitStride;</span>
<span class="nc" id="L920">        int scanbit = dataBitOffset + (x - minX) * pixbits;</span>
<span class="nc" id="L921">        int index = (y - minY) * scanlineStride;</span>
<span class="nc" id="L922">        int outindex = 0;</span>
<span class="nc" id="L923">        byte data[] = this.data;</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">        for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L925">            int bitnum = scanbit;</span>
            int element;

            // Process initial portion of scanline
<span class="nc" id="L929">            int i = 0;</span>
<span class="nc bnc" id="L930" title="All 4 branches missed.">            while ((i &lt; w) &amp;&amp; ((bitnum &amp; 7) != 0)) {</span>
<span class="nc" id="L931">                int shift = shiftOffset - (bitnum &amp; 7);</span>
<span class="nc" id="L932">                element = data[index + (bitnum &gt;&gt; 3)];</span>
<span class="nc" id="L933">                element &amp;= ~(bitMask &lt;&lt; shift);</span>
<span class="nc" id="L934">                element |= (inData[outindex++] &amp; bitMask) &lt;&lt; shift;</span>
<span class="nc" id="L935">                data[index + (bitnum &gt;&gt; 3)] = (byte)element;</span>

<span class="nc" id="L937">                bitnum += pixbits;</span>
<span class="nc" id="L938">                i++;</span>
<span class="nc" id="L939">            }</span>

            // Process central portion of scanline 8 pixels at a time
<span class="nc" id="L942">            int inIndex = index + (bitnum &gt;&gt; 3);</span>
<span class="nc bnc" id="L943" title="All 4 branches missed.">            switch (pixbits) {</span>
            case 1:
<span class="nc bnc" id="L945" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L946">                    element = (inData[outindex++] &amp; 1) &lt;&lt; 7;</span>
<span class="nc" id="L947">                    element |= (inData[outindex++] &amp; 1) &lt;&lt; 6;</span>
<span class="nc" id="L948">                    element |= (inData[outindex++] &amp; 1) &lt;&lt; 5;</span>
<span class="nc" id="L949">                    element |= (inData[outindex++] &amp; 1) &lt;&lt; 4;</span>
<span class="nc" id="L950">                    element |= (inData[outindex++] &amp; 1) &lt;&lt; 3;</span>
<span class="nc" id="L951">                    element |= (inData[outindex++] &amp; 1) &lt;&lt; 2;</span>
<span class="nc" id="L952">                    element |= (inData[outindex++] &amp; 1) &lt;&lt; 1;</span>
<span class="nc" id="L953">                    element |= (inData[outindex++] &amp; 1);</span>

<span class="nc" id="L955">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L957">                    bitnum += 8;</span>
                }
                break;

            case 2:
<span class="nc bnc" id="L962" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L963">                    element = (inData[outindex++] &amp; 3) &lt;&lt; 6;</span>
<span class="nc" id="L964">                    element |= (inData[outindex++] &amp; 3) &lt;&lt; 4;</span>
<span class="nc" id="L965">                    element |= (inData[outindex++] &amp; 3) &lt;&lt; 2;</span>
<span class="nc" id="L966">                    element |= (inData[outindex++] &amp; 3);</span>
<span class="nc" id="L967">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L969">                    element = (inData[outindex++] &amp; 3) &lt;&lt; 6;</span>
<span class="nc" id="L970">                    element |= (inData[outindex++] &amp; 3) &lt;&lt; 4;</span>
<span class="nc" id="L971">                    element |= (inData[outindex++] &amp; 3) &lt;&lt; 2;</span>
<span class="nc" id="L972">                    element |= (inData[outindex++] &amp; 3);</span>
<span class="nc" id="L973">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L975">                    bitnum += 16;</span>
                }
                break;

            case 4:
<span class="nc bnc" id="L980" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L981">                    element = (inData[outindex++] &amp; 0xf) &lt;&lt; 4;</span>
<span class="nc" id="L982">                    element |= (inData[outindex++] &amp; 0xf);</span>
<span class="nc" id="L983">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L985">                    element = (inData[outindex++] &amp; 0xf) &lt;&lt; 4;</span>
<span class="nc" id="L986">                    element |= (inData[outindex++] &amp; 0xf);</span>
<span class="nc" id="L987">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L989">                    element = (inData[outindex++] &amp; 0xf) &lt;&lt; 4;</span>
<span class="nc" id="L990">                    element |= (inData[outindex++] &amp; 0xf);</span>
<span class="nc" id="L991">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L993">                    element = (inData[outindex++] &amp; 0xf) &lt;&lt; 4;</span>
<span class="nc" id="L994">                    element |= (inData[outindex++] &amp; 0xf);</span>
<span class="nc" id="L995">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L997">                    bitnum += 32;</span>
                }
                break;
            }

            // Process final portion of scanline
<span class="nc bnc" id="L1003" title="All 2 branches missed.">            for (; i &lt; w; i++) {</span>
<span class="nc" id="L1004">                int shift = shiftOffset - (bitnum &amp; 7);</span>

<span class="nc" id="L1006">                element = data[index + (bitnum &gt;&gt; 3)];</span>
<span class="nc" id="L1007">                element &amp;= ~(bitMask &lt;&lt; shift);</span>
<span class="nc" id="L1008">                element |= (inData[outindex++] &amp; bitMask) &lt;&lt; shift;</span>
<span class="nc" id="L1009">                data[index + (bitnum &gt;&gt; 3)] = (byte)element;</span>

<span class="nc" id="L1011">                bitnum += pixbits;</span>
            }

<span class="nc" id="L1014">            index += scanlineStride;</span>
        }

<span class="nc" id="L1017">        markDirty();</span>
<span class="nc" id="L1018">    }</span>

    /**
     * Returns an int array containing all samples for a rectangle of pixels,
     * one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.
     * @param x,&amp;nbsp;y   the coordinates of the upper-left pixel location
     * @param w      Width of the pixel rectangle
     * @param h      Height of the pixel rectangle
     * @param iArray An optionally pre-allocated int array
     * @return the samples for the specified rectangle of pixels.
     */
    public int[] getPixels(int x, int y, int w, int h, int iArray[]) {
<span class="nc bnc" id="L1032" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L1034">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        if (iArray == null) {</span>
<span class="nc" id="L1038">            iArray = new int[w * h];</span>
        }
<span class="nc" id="L1040">        int pixbits = pixelBitStride;</span>
<span class="nc" id="L1041">        int scanbit = dataBitOffset + (x-minX) * pixbits;</span>
<span class="nc" id="L1042">        int index = (y-minY) * scanlineStride;</span>
<span class="nc" id="L1043">        int outindex = 0;</span>
<span class="nc" id="L1044">        byte data[] = this.data;</span>

<span class="nc bnc" id="L1046" title="All 2 branches missed.">        for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L1047">            int bitnum = scanbit;</span>
            int element;

            // Process initial portion of scanline
<span class="nc" id="L1051">            int i = 0;</span>
<span class="nc bnc" id="L1052" title="All 4 branches missed.">            while ((i &lt; w) &amp;&amp; ((bitnum &amp; 7) != 0)) {</span>
<span class="nc" id="L1053">                int shift = shiftOffset - (bitnum &amp; 7);</span>
<span class="nc" id="L1054">                iArray[outindex++] =</span>
                    bitMask &amp; (data[index + (bitnum &gt;&gt; 3)] &gt;&gt; shift);
<span class="nc" id="L1056">                bitnum += pixbits;</span>
<span class="nc" id="L1057">                i++;</span>
<span class="nc" id="L1058">            }</span>

            // Process central portion of scanline 8 pixels at a time
<span class="nc" id="L1061">            int inIndex = index + (bitnum &gt;&gt; 3);</span>
<span class="nc bnc" id="L1062" title="All 4 branches missed.">            switch (pixbits) {</span>
            case 1:
<span class="nc bnc" id="L1064" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L1065">                    element = data[inIndex++];</span>
<span class="nc" id="L1066">                    iArray[outindex++] = (element &gt;&gt; 7) &amp; 1;</span>
<span class="nc" id="L1067">                    iArray[outindex++] = (element &gt;&gt; 6) &amp; 1;</span>
<span class="nc" id="L1068">                    iArray[outindex++] = (element &gt;&gt; 5) &amp; 1;</span>
<span class="nc" id="L1069">                    iArray[outindex++] = (element &gt;&gt; 4) &amp; 1;</span>
<span class="nc" id="L1070">                    iArray[outindex++] = (element &gt;&gt; 3) &amp; 1;</span>
<span class="nc" id="L1071">                    iArray[outindex++] = (element &gt;&gt; 2) &amp; 1;</span>
<span class="nc" id="L1072">                    iArray[outindex++] = (element &gt;&gt; 1) &amp; 1;</span>
<span class="nc" id="L1073">                    iArray[outindex++] = element &amp; 1;</span>
<span class="nc" id="L1074">                    bitnum += 8;</span>
                }
                break;

            case 2:
<span class="nc bnc" id="L1079" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L1080">                    element = data[inIndex++];</span>
<span class="nc" id="L1081">                    iArray[outindex++] = (element &gt;&gt; 6) &amp; 3;</span>
<span class="nc" id="L1082">                    iArray[outindex++] = (element &gt;&gt; 4) &amp; 3;</span>
<span class="nc" id="L1083">                    iArray[outindex++] = (element &gt;&gt; 2) &amp; 3;</span>
<span class="nc" id="L1084">                    iArray[outindex++] = element &amp; 3;</span>

<span class="nc" id="L1086">                    element = data[inIndex++];</span>
<span class="nc" id="L1087">                    iArray[outindex++] = (element &gt;&gt; 6) &amp; 3;</span>
<span class="nc" id="L1088">                    iArray[outindex++] = (element &gt;&gt; 4) &amp; 3;</span>
<span class="nc" id="L1089">                    iArray[outindex++] = (element &gt;&gt; 2) &amp; 3;</span>
<span class="nc" id="L1090">                    iArray[outindex++] = element &amp; 3;</span>

<span class="nc" id="L1092">                    bitnum += 16;</span>
                }
                break;

            case 4:
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L1098">                    element = data[inIndex++];</span>
<span class="nc" id="L1099">                    iArray[outindex++] = (element &gt;&gt; 4) &amp; 0xf;</span>
<span class="nc" id="L1100">                    iArray[outindex++] = element &amp; 0xf;</span>

<span class="nc" id="L1102">                    element = data[inIndex++];</span>
<span class="nc" id="L1103">                    iArray[outindex++] = (element &gt;&gt; 4) &amp; 0xf;</span>
<span class="nc" id="L1104">                    iArray[outindex++] = element &amp; 0xf;</span>

<span class="nc" id="L1106">                    element = data[inIndex++];</span>
<span class="nc" id="L1107">                    iArray[outindex++] = (element &gt;&gt; 4) &amp; 0xf;</span>
<span class="nc" id="L1108">                    iArray[outindex++] = element &amp; 0xf;</span>

<span class="nc" id="L1110">                    element = data[inIndex++];</span>
<span class="nc" id="L1111">                    iArray[outindex++] = (element &gt;&gt; 4) &amp; 0xf;</span>
<span class="nc" id="L1112">                    iArray[outindex++] = element &amp; 0xf;</span>

<span class="nc" id="L1114">                    bitnum += 32;</span>
                }
                break;
            }

            // Process final portion of scanline
<span class="nc bnc" id="L1120" title="All 2 branches missed.">            for (; i &lt; w; i++) {</span>
<span class="nc" id="L1121">                int shift = shiftOffset - (bitnum &amp; 7);</span>
<span class="nc" id="L1122">                iArray[outindex++] =</span>
                    bitMask &amp; (data[index + (bitnum &gt;&gt; 3)] &gt;&gt; shift);
<span class="nc" id="L1124">                bitnum += pixbits;</span>
            }

<span class="nc" id="L1127">            index += scanlineStride;</span>
        }

<span class="nc" id="L1130">        return iArray;</span>
    }

    /**
     * Sets all samples for a rectangle of pixels from an int array containing
     * one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param iArray   The input int pixel array.
     */
    public void setPixels(int x, int y, int w, int h, int iArray[]) {
<span class="nc bnc" id="L1145" title="All 8 branches missed.">        if ((x &lt; this.minX) || (y &lt; this.minY) ||</span>
            (x + w &gt; this.maxX) || (y + h &gt; this.maxY)) {
<span class="nc" id="L1147">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L1150">        int pixbits = pixelBitStride;</span>
<span class="nc" id="L1151">        int scanbit = dataBitOffset + (x - minX) * pixbits;</span>
<span class="nc" id="L1152">        int index = (y - minY) * scanlineStride;</span>
<span class="nc" id="L1153">        int outindex = 0;</span>
<span class="nc" id="L1154">        byte data[] = this.data;</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">        for (int j = 0; j &lt; h; j++) {</span>
<span class="nc" id="L1156">            int bitnum = scanbit;</span>
            int element;

            // Process initial portion of scanline
<span class="nc" id="L1160">            int i = 0;</span>
<span class="nc bnc" id="L1161" title="All 4 branches missed.">            while ((i &lt; w) &amp;&amp; ((bitnum &amp; 7) != 0)) {</span>
<span class="nc" id="L1162">                int shift = shiftOffset - (bitnum &amp; 7);</span>
<span class="nc" id="L1163">                element = data[index + (bitnum &gt;&gt; 3)];</span>
<span class="nc" id="L1164">                element &amp;= ~(bitMask &lt;&lt; shift);</span>
<span class="nc" id="L1165">                element |= (iArray[outindex++] &amp; bitMask) &lt;&lt; shift;</span>
<span class="nc" id="L1166">                data[index + (bitnum &gt;&gt; 3)] = (byte)element;</span>

<span class="nc" id="L1168">                bitnum += pixbits;</span>
<span class="nc" id="L1169">                i++;</span>
<span class="nc" id="L1170">            }</span>

            // Process central portion of scanline 8 pixels at a time
<span class="nc" id="L1173">            int inIndex = index + (bitnum &gt;&gt; 3);</span>
<span class="nc bnc" id="L1174" title="All 4 branches missed.">            switch (pixbits) {</span>
            case 1:
<span class="nc bnc" id="L1176" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L1177">                    element = (iArray[outindex++] &amp; 1) &lt;&lt; 7;</span>
<span class="nc" id="L1178">                    element |= (iArray[outindex++] &amp; 1) &lt;&lt; 6;</span>
<span class="nc" id="L1179">                    element |= (iArray[outindex++] &amp; 1) &lt;&lt; 5;</span>
<span class="nc" id="L1180">                    element |= (iArray[outindex++] &amp; 1) &lt;&lt; 4;</span>
<span class="nc" id="L1181">                    element |= (iArray[outindex++] &amp; 1) &lt;&lt; 3;</span>
<span class="nc" id="L1182">                    element |= (iArray[outindex++] &amp; 1) &lt;&lt; 2;</span>
<span class="nc" id="L1183">                    element |= (iArray[outindex++] &amp; 1) &lt;&lt; 1;</span>
<span class="nc" id="L1184">                    element |= (iArray[outindex++] &amp; 1);</span>
<span class="nc" id="L1185">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L1187">                    bitnum += 8;</span>
                }
                break;

            case 2:
<span class="nc bnc" id="L1192" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L1193">                    element = (iArray[outindex++] &amp; 3) &lt;&lt; 6;</span>
<span class="nc" id="L1194">                    element |= (iArray[outindex++] &amp; 3) &lt;&lt; 4;</span>
<span class="nc" id="L1195">                    element |= (iArray[outindex++] &amp; 3) &lt;&lt; 2;</span>
<span class="nc" id="L1196">                    element |= (iArray[outindex++] &amp; 3);</span>
<span class="nc" id="L1197">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L1199">                    element = (iArray[outindex++] &amp; 3) &lt;&lt; 6;</span>
<span class="nc" id="L1200">                    element |= (iArray[outindex++] &amp; 3) &lt;&lt; 4;</span>
<span class="nc" id="L1201">                    element |= (iArray[outindex++] &amp; 3) &lt;&lt; 2;</span>
<span class="nc" id="L1202">                    element |= (iArray[outindex++] &amp; 3);</span>
<span class="nc" id="L1203">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L1205">                    bitnum += 16;</span>
                }
                break;

            case 4:
<span class="nc bnc" id="L1210" title="All 2 branches missed.">                for (; i &lt; w - 7; i += 8) {</span>
<span class="nc" id="L1211">                    element = (iArray[outindex++] &amp; 0xf) &lt;&lt; 4;</span>
<span class="nc" id="L1212">                    element |= (iArray[outindex++] &amp; 0xf);</span>
<span class="nc" id="L1213">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L1215">                    element = (iArray[outindex++] &amp; 0xf) &lt;&lt; 4;</span>
<span class="nc" id="L1216">                    element |= (iArray[outindex++] &amp; 0xf);</span>
<span class="nc" id="L1217">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L1219">                    element = (iArray[outindex++] &amp; 0xf) &lt;&lt; 4;</span>
<span class="nc" id="L1220">                    element |= (iArray[outindex++] &amp; 0xf);</span>
<span class="nc" id="L1221">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L1223">                    element = (iArray[outindex++] &amp; 0xf) &lt;&lt; 4;</span>
<span class="nc" id="L1224">                    element |= (iArray[outindex++] &amp; 0xf);</span>
<span class="nc" id="L1225">                    data[inIndex++] = (byte)element;</span>

<span class="nc" id="L1227">                    bitnum += 32;</span>
                }
                break;
            }

            // Process final portion of scanline
<span class="nc bnc" id="L1233" title="All 2 branches missed.">            for (; i &lt; w; i++) {</span>
<span class="nc" id="L1234">                int shift = shiftOffset - (bitnum &amp; 7);</span>

<span class="nc" id="L1236">                element = data[index + (bitnum &gt;&gt; 3)];</span>
<span class="nc" id="L1237">                element &amp;= ~(bitMask &lt;&lt; shift);</span>
<span class="nc" id="L1238">                element |= (iArray[outindex++] &amp; bitMask) &lt;&lt; shift;</span>
<span class="nc" id="L1239">                data[index + (bitnum &gt;&gt; 3)] = (byte)element;</span>

<span class="nc" id="L1241">                bitnum += pixbits;</span>
            }

<span class="nc" id="L1244">            index += scanlineStride;</span>
        }

<span class="nc" id="L1247">        markDirty();</span>
<span class="nc" id="L1248">    }</span>

    /**
     * Creates a subraster given a region of the raster.  The x and y
     * coordinates specify the horizontal and vertical offsets
     * from the upper-left corner of this raster to the upper-left corner
     * of the subraster.  Note that the subraster will reference the same
     * DataBuffer as the parent raster, but using different offsets. The
     * bandList is ignored.
     * @param x               X offset.
     * @param y               Y offset.
     * @param width           Width (in pixels) of the subraster.
     * @param height          Height (in pixels) of the subraster.
     * @param x0              Translated X origin of the subraster.
     * @param y0              Translated Y origin of the subraster.
     * @param bandList        Array of band indices.
     * @exception RasterFormatException
     *            if the specified bounding box is outside of the parent raster.
     */
    public Raster createChild(int x, int y,
                              int width, int height,
                              int x0, int y0, int[] bandList) {
<span class="nc" id="L1270">        WritableRaster newRaster = createWritableChild(x, y,</span>
                                                       width, height,
                                                       x0, y0,
                                                       bandList);
<span class="nc" id="L1274">        return (Raster) newRaster;</span>
    }

    /**
     * Creates a Writable subRaster given a region of the Raster. The x and y
     * coordinates specify the horizontal and vertical offsets
     * from the upper-left corner of this Raster to the upper-left corner
     * of the subRaster.  The bandList is ignored.
     * A translation to the subRaster may also be specified.
     * Note that the subRaster will reference the same
     * DataBuffer as the parent Raster, but using different offsets.
     * @param x               X offset.
     * @param y               Y offset.
     * @param width           Width (in pixels) of the subraster.
     * @param height          Height (in pixels) of the subraster.
     * @param x0              Translated X origin of the subraster.
     * @param y0              Translated Y origin of the subraster.
     * @param bandList        Array of band indices.
     * @exception RasterFormatException
     *            if the specified bounding box is outside of the parent Raster.
     */
    public WritableRaster createWritableChild(int x, int y,
                                              int width, int height,
                                              int x0, int y0,
                                              int[] bandList) {
<span class="nc bnc" id="L1299" title="All 2 branches missed.">        if (x &lt; this.minX) {</span>
<span class="nc" id="L1300">            throw new RasterFormatException(&quot;x lies outside the raster&quot;);</span>
        }
<span class="nc bnc" id="L1302" title="All 2 branches missed.">        if (y &lt; this.minY) {</span>
<span class="nc" id="L1303">            throw new RasterFormatException(&quot;y lies outside the raster&quot;);</span>
        }
<span class="nc bnc" id="L1305" title="All 4 branches missed.">        if ((x+width &lt; x) || (x+width &gt; this.minX + this.width)) {</span>
<span class="nc" id="L1306">            throw new RasterFormatException(&quot;(x + width) is outside of Raster&quot;);</span>
        }
<span class="nc bnc" id="L1308" title="All 4 branches missed.">        if ((y+height &lt; y) || (y+height &gt; this.minY + this.height)) {</span>
<span class="nc" id="L1309">            throw new RasterFormatException(&quot;(y + height) is outside of Raster&quot;);</span>
        }

        SampleModel sm;

<span class="nc bnc" id="L1314" title="All 2 branches missed.">        if (bandList != null) {</span>
<span class="nc" id="L1315">            sm = sampleModel.createSubsetSampleModel(bandList);</span>
        }
        else {
<span class="nc" id="L1318">            sm = sampleModel;</span>
        }

<span class="nc" id="L1321">        int deltaX = x0 - x;</span>
<span class="nc" id="L1322">        int deltaY = y0 - y;</span>

<span class="nc" id="L1324">        return new BytePackedRaster(sm,</span>
                                    dataBuffer,
                                    new Rectangle(x0, y0, width, height),
                                    new Point(sampleModelTranslateX+deltaX,
                                              sampleModelTranslateY+deltaY),
                                    this);
    }

    /**
     * Creates a raster with the same layout but using a different
     * width and height, and with new zeroed data arrays.
     */
    public WritableRaster createCompatibleWritableRaster(int w, int h) {
<span class="nc bnc" id="L1337" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;=0) {</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">            throw new RasterFormatException(&quot;negative &quot;+</span>
                                          ((w &lt;= 0) ? &quot;width&quot; : &quot;height&quot;));
        }

<span class="nc" id="L1342">        SampleModel sm = sampleModel.createCompatibleSampleModel(w,h);</span>

<span class="nc" id="L1344">        return new BytePackedRaster(sm, new Point(0,0));</span>
    }

    /**
     * Creates a raster with the same layout and the same
     * width and height, and with new zeroed data arrays.
     */
    public WritableRaster createCompatibleWritableRaster () {
<span class="nc" id="L1352">        return createCompatibleWritableRaster(width,height);</span>
    }

    /**
     * Verify that the layout parameters are consistent with
     * the data.  If strictCheck
     * is false, this method will check for ArrayIndexOutOfBounds conditions.
     * If strictCheck is true, this method will check for additional error
     * conditions such as line wraparound (width of a line greater than
     * the scanline stride).
     * @return   String   Error string, if the layout is incompatible with
     *                    the data.  Otherwise returns null.
     */
    private void verify (boolean strictCheck) {
        // Make sure data for Raster is in a legal range
<span class="nc bnc" id="L1367" title="All 2 branches missed.">        if (dataBitOffset &lt; 0) {</span>
<span class="nc" id="L1368">            throw new RasterFormatException(&quot;Data offsets must be &gt;= 0&quot;);</span>
        }

        /* Need to re-verify the dimensions since a sample model may be
         * specified to the constructor
         */
<span class="nc bnc" id="L1374" title="All 6 branches missed.">        if (width &lt;= 0 || height &lt;= 0 ||</span>
            height &gt; (Integer.MAX_VALUE / width))
        {
<span class="nc" id="L1377">            throw new RasterFormatException(&quot;Invalid raster dimension&quot;);</span>
        }


        /*
         * pixelBitstride was verified in constructor, so just make
         * sure that it is safe to multiply it by width.
         */
<span class="nc bnc" id="L1385" title="All 2 branches missed.">        if ((width - 1) &gt; Integer.MAX_VALUE / pixelBitStride) {</span>
<span class="nc" id="L1386">            throw new RasterFormatException(&quot;Invalid raster dimension&quot;);</span>
        }

<span class="nc bnc" id="L1389" title="All 6 branches missed.">        if (scanlineStride &lt; 0 ||</span>
            scanlineStride &gt; (Integer.MAX_VALUE / height) ||
            scanlineStride &gt; data.length)
        {
<span class="nc" id="L1393">            throw new RasterFormatException(&quot;Invalid scanline stride&quot;);</span>
        }

<span class="nc" id="L1396">        int lastbit = (dataBitOffset</span>
                       + (height-1) * scanlineStride * 8
                       + (width-1) * pixelBitStride
                       + pixelBitStride - 1);
<span class="nc bnc" id="L1400" title="All 4 branches missed.">        if (lastbit &lt; 0 || lastbit / 8 &gt;= data.length) {</span>
<span class="nc" id="L1401">            throw new RasterFormatException(&quot;raster dimensions overflow &quot; +</span>
                                            &quot;array bounds&quot;);
        }
<span class="nc bnc" id="L1404" title="All 2 branches missed.">        if (strictCheck) {</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">            if (height &gt; 1) {</span>
<span class="nc" id="L1406">                lastbit = width * pixelBitStride - 1;</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">                if (lastbit / 8 &gt;= scanlineStride) {</span>
<span class="nc" id="L1408">                    throw new RasterFormatException(&quot;data for adjacent&quot; +</span>
                                                    &quot; scanlines overlaps&quot;);
                }
            }
        }
<span class="nc" id="L1413">    }</span>

    public String toString() {
<span class="nc" id="L1416">        return new String (&quot;BytePackedRaster: width = &quot;+width+&quot; height = &quot;+height</span>
                           +&quot; #channels &quot;+numBands
                           +&quot; xOff = &quot;+sampleModelTranslateX
                           +&quot; yOff = &quot;+sampleModelTranslateY);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>