<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>VolatileSurfaceManager.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.awt.image</a> &gt; <span class="el_source">VolatileSurfaceManager.java</span></div><h1>VolatileSurfaceManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.image;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsEnvironment;
import java.awt.ImageCapabilities;
import java.awt.image.BufferedImage;
import java.awt.image.VolatileImage;
import sun.awt.DisplayChangedListener;
import sun.awt.image.SunVolatileImage;
import sun.java2d.SunGraphicsEnvironment;
import sun.java2d.SurfaceData;
import sun.java2d.loops.CompositeType;
import static sun.java2d.pipe.hw.AccelSurface.*;

/**
 * This SurfaceManager variant manages an accelerated volatile surface, if it
 * is possible to create that surface.  If there is limited accelerated
 * memory, or if the volatile surface disappears due to an operating system
 * event, the VolatileSurfaceManager will attempt to restore the
 * accelerated surface.  If that fails, a system memory surface will be
 * created in its place.
 */
public abstract class VolatileSurfaceManager
    extends SurfaceManager
    implements DisplayChangedListener
{
    /**
     * A reference to the VolatileImage whose contents are being managed.
     */
    protected SunVolatileImage vImg;

    /**
     * The accelerated SurfaceData object.
     */
    protected SurfaceData sdAccel;

    /**
     * The software-based SurfaceData object.  Only create when first asked
     * to (otherwise it is a waste of memory as it will only be used in
     * situations of surface loss).
     */
    protected SurfaceData sdBackup;

    /**
     * The current SurfaceData object.
     */
    protected SurfaceData sdCurrent;

    /**
     * A record-keeping object.  This keeps track of which SurfaceData was
     * in use during the last call to validate().  This lets us see whether
     * the SurfaceData object has changed since then and allows us to return
     * the correct returnCode to the user in the validate() call.
     */
    protected SurfaceData sdPrevious;

    /**
     * Tracks loss of surface contents; queriable by user to see whether
     * contents need to be restored.
     */
    protected boolean lostSurface;

    /**
     * Context for extra initialization parameters.
     */
    protected Object context;

<span class="nc" id="L95">    protected VolatileSurfaceManager(SunVolatileImage vImg, Object context) {</span>
<span class="nc" id="L96">        this.vImg = vImg;</span>
<span class="nc" id="L97">        this.context = context;</span>

        GraphicsEnvironment ge =
<span class="nc" id="L100">            GraphicsEnvironment.getLocalGraphicsEnvironment();</span>
        // We could have a HeadlessGE at this point, so double-check before
        // assuming anything.
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (ge instanceof SunGraphicsEnvironment) {</span>
<span class="nc" id="L104">            ((SunGraphicsEnvironment)ge).addDisplayChangedListener(this);</span>
        }
<span class="nc" id="L106">    }</span>

    /**
     * This init function is separate from the constructor because the
     * things we are doing here necessitate the object's existence.
     * Otherwise, we end up calling into a subclass' overridden method
     * during construction, before that subclass is completely constructed.
     */
    public void initialize() {
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (isAccelerationEnabled()) {</span>
<span class="nc" id="L116">            sdAccel = initAcceleratedSurface();</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">            if (sdAccel != null) {</span>
<span class="nc" id="L118">                sdCurrent = sdAccel;</span>
            }
        }
        // only initialize the backup surface for images with unforced
        // acceleration type
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (sdCurrent == null &amp;&amp;</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">            vImg.getForcedAccelSurfaceType() == UNDEFINED)</span>
        {
<span class="nc" id="L126">            sdCurrent = getBackupSurface();</span>
        }
<span class="nc" id="L128">    }</span>

    public SurfaceData getPrimarySurfaceData() {
<span class="nc" id="L131">        return sdCurrent;</span>
    }

    /**
     * Returns true if acceleration is enabled.  If not, we simply use the
     * backup SurfaceData object and return quickly from most methods
     * in this class.
     */
    protected abstract boolean isAccelerationEnabled();

    /**
     * Get the image ready for rendering.  This method is called to make
     * sure that the accelerated SurfaceData exists and is
     * ready to be used.  Users call this method prior to any set of
     * rendering to or from the image, to make sure the image is ready
     * and compatible with the given GraphicsConfiguration.
     *
     * The image may not be &quot;ready&quot; if either we had problems creating
     * it in the first place (e.g., there was no space in vram) or if
     * the surface became lost (e.g., some other app or the OS caused
     * vram surfaces to be removed).
     *
     * Note that we want to return RESTORED in any situation where the
     * SurfaceData is different than it was last time.  So whether it's
     * software or hardware, if we have a different SurfaceData object,
     * then the contents have been altered and we must reflect that
     * change to the user.
     */
    public int validate(GraphicsConfiguration gc) {
<span class="nc" id="L160">        int returnCode = VolatileImage.IMAGE_OK;</span>
<span class="nc" id="L161">        boolean lostSurfaceTmp = lostSurface;</span>
<span class="nc" id="L162">        lostSurface = false;</span>

<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (isAccelerationEnabled()) {</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">            if (!isConfigValid(gc)) {</span>
                // If we're asked to render to a different device than the
                // one we were created under, return INCOMPATIBLE error code.
                // Note that a null gc simply ignores the incompatibility
                // issue
<span class="nc" id="L170">                returnCode = VolatileImage.IMAGE_INCOMPATIBLE;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            } else if (sdAccel == null) {</span>
                // We either had problems creating the surface or the display
                // mode changed and we nullified the old one.  Try it again.
<span class="nc" id="L174">                sdAccel = initAcceleratedSurface();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                if (sdAccel != null) {</span>
                    // set the current SurfaceData to accelerated version
<span class="nc" id="L177">                    sdCurrent = sdAccel;</span>
                    // we don't need the system memory surface anymore, so
                    // let's release it now (it can always be restored later)
<span class="nc" id="L180">                    sdBackup = null;</span>
<span class="nc" id="L181">                    returnCode = VolatileImage.IMAGE_RESTORED;</span>
                } else {
<span class="nc" id="L183">                    sdCurrent = getBackupSurface();</span>
                }
<span class="nc bnc" id="L185" title="All 2 branches missed.">            } else if (sdAccel.isSurfaceLost()) {</span>
                try {
<span class="nc" id="L187">                    restoreAcceleratedSurface();</span>
                    // set the current SurfaceData to accelerated version
<span class="nc" id="L189">                    sdCurrent = sdAccel;</span>
                    // restoration successful: accel surface no longer lost
<span class="nc" id="L191">                    sdAccel.setSurfaceLost(false);</span>
                    // we don't need the system memory surface anymore, so
                    // let's release it now (it can always be restored later)
<span class="nc" id="L194">                    sdBackup = null;</span>
<span class="nc" id="L195">                    returnCode = VolatileImage.IMAGE_RESTORED;</span>
<span class="nc" id="L196">                } catch (sun.java2d.InvalidPipeException e) {</span>
                    // Set the current SurfaceData to software version so that
                    // drawing can continue.  Note that we still have
                    // the lostAccelSurface flag set so that we will continue
                    // to attempt to restore the accelerated surface.
<span class="nc" id="L201">                    sdCurrent = getBackupSurface();</span>
<span class="nc" id="L202">                }</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            } else if (lostSurfaceTmp) {</span>
                // Something else triggered this loss/restoration.  Could
                // be a palette change that didn't require a SurfaceData
                // recreation but merely a re-rendering of the pixels.
<span class="nc" id="L207">                returnCode = VolatileImage.IMAGE_RESTORED;</span>
            }
<span class="nc bnc" id="L209" title="All 2 branches missed.">        } else if (sdAccel != null) {</span>
            // if the &quot;acceleration enabled&quot; state changed to disabled,
            // switch to software surface
<span class="nc" id="L212">            sdCurrent = getBackupSurface();</span>
<span class="nc" id="L213">            sdAccel = null;</span>
<span class="nc" id="L214">            returnCode = VolatileImage.IMAGE_RESTORED;</span>
        }

<span class="nc bnc" id="L217" title="All 4 branches missed.">        if ((returnCode != VolatileImage.IMAGE_INCOMPATIBLE) &amp;&amp;</span>
            (sdCurrent != sdPrevious))
        {
            // contents have changed - return RESTORED to user
<span class="nc" id="L221">            sdPrevious = sdCurrent;</span>
<span class="nc" id="L222">            returnCode = VolatileImage.IMAGE_RESTORED;</span>
        }

<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (returnCode == VolatileImage.IMAGE_RESTORED) {</span>
            // clear the current surface with the background color,
            // only if the surface has been restored
<span class="nc" id="L228">            initContents();</span>
        }

<span class="nc" id="L231">        return returnCode;</span>
    }

    /**
     * Returns true if rendering data was lost since the last validate call.
     *
     * @see java.awt.image.VolatileImage#contentsLost
     */
    public boolean contentsLost() {
<span class="nc" id="L240">        return lostSurface;</span>
    }

    /**
     * Creates a new accelerated surface that is compatible with the
     * current GraphicsConfiguration.  Returns the new accelerated
     * SurfaceData object, or null if the surface creation was not successful.
     *
     * Platform-specific subclasses should initialize an accelerated
     * surface (e.g. a DirectDraw surface on Windows, an OpenGL pbuffer,
     * or an X11 pixmap).
     */
    protected abstract SurfaceData initAcceleratedSurface();

    /**
     * Creates a software-based surface (of type BufImgSurfaceData).
     * The software representation is only created when needed, which
     * is only during some situation in which the hardware surface
     * cannot be allocated.  This allows apps to at least run,
     * albeit more slowly than they would otherwise.
     */
    protected SurfaceData getBackupSurface() {
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (sdBackup == null) {</span>
<span class="nc" id="L263">            BufferedImage bImg = vImg.getBackupImage();</span>
            // Sabotage the acceleration capabilities of the BufImg surface
<span class="nc" id="L265">            SunWritableRaster.stealTrackable(bImg</span>
<span class="nc" id="L266">                                             .getRaster()</span>
<span class="nc" id="L267">                                             .getDataBuffer()).setUntrackable();</span>
<span class="nc" id="L268">            sdBackup = BufImgSurfaceData.createData(bImg);</span>
        }
<span class="nc" id="L270">        return sdBackup;</span>
    }

    /**
     * Set contents of the current SurfaceData to default state (i.e. clear
     * the background).
     */
    public void initContents() {
        // images with forced acceleration type may have a null sdCurrent
        // because we do not create a backup surface for them
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (sdCurrent != null) {</span>
<span class="nc" id="L281">            Graphics g = vImg.createGraphics();</span>
<span class="nc" id="L282">            g.clearRect(0, 0, vImg.getWidth(), vImg.getHeight());</span>
<span class="nc" id="L283">            g.dispose();</span>
        }
<span class="nc" id="L285">    }</span>

    /**
     * Called from a SurfaceData object, indicating that our
     * accelerated surface has been lost and should be restored (perhaps
     * using a backup system memory surface).  Returns the newly restored
     * primary SurfaceData object.
     */
    public SurfaceData restoreContents() {
<span class="nc" id="L294">        return getBackupSurface();</span>
    }

    /**
     * If the accelerated surface is the current SurfaceData for this manager,
     * sets the variable lostSurface to true, which indicates that something
     * happened to the image under management.  This variable is used in the
     * validate method to tell the caller that the surface contents need to
     * be restored.
     */
    public void acceleratedSurfaceLost() {
<span class="nc bnc" id="L305" title="All 4 branches missed.">        if (isAccelerationEnabled() &amp;&amp; (sdCurrent == sdAccel)) {</span>
<span class="nc" id="L306">            lostSurface = true;</span>
        }
<span class="nc" id="L308">    }</span>

    /**
     * Restore sdAccel in case it was lost.  Do nothing in this
     * default case; platform-specific implementations may do more in
     * this situation as appropriate.
     */
    protected void restoreAcceleratedSurface() {
<span class="nc" id="L316">    }</span>

    /**
     * Called from SunGraphicsEnv when there has been a display mode change.
     * Note that we simply invalidate hardware surfaces here; we do not
     * attempt to recreate or re-render them.  This is to avoid threading
     * conflicts with the native toolkit and associated threads.  Instead,
     * we just nullify the old surface data object and wait for a future
     * method in the rendering process to recreate the surface.
     */
    public void displayChanged() {
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (!isAccelerationEnabled()) {</span>
<span class="nc" id="L328">            return;</span>
        }
<span class="nc" id="L330">        lostSurface = true;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (sdAccel != null) {</span>
            // First, nullify the software surface.  This guards against
            // using a SurfaceData that was created in a different
            // display mode.
<span class="nc" id="L335">            sdBackup = null;</span>
            // Now, invalidate the old hardware-based SurfaceData
            // Note that getBackupSurface may set sdAccel to null so we have to invalidate it before
<span class="nc" id="L338">            SurfaceData oldData = sdAccel;</span>
<span class="nc" id="L339">            sdAccel = null;</span>
<span class="nc" id="L340">            oldData.invalidate();</span>
<span class="nc" id="L341">            sdCurrent = getBackupSurface();</span>
        }
        // Update graphicsConfig for the vImg in case it changed due to
        // this display change event
<span class="nc" id="L345">        vImg.updateGraphicsConfig();</span>
<span class="nc" id="L346">    }</span>

    /**
     * When device palette changes, need to force a new copy
     * of the image into our hardware cache to update the
     * color indices of the pixels (indexed mode only).
     */
    public void paletteChanged() {
<span class="nc" id="L354">        lostSurface = true;</span>
<span class="nc" id="L355">    }</span>

    /**
     * Called by validate() to see whether the GC passed in is ok for
     * rendering to.  This generic implementation checks to see
     * whether the GC is either null or is from the same
     * device as the one that this image was created on.  Platform-
     * specific implementations may perform other checks as
     * appropriate.
     */
    protected boolean isConfigValid(GraphicsConfiguration gc) {
<span class="nc bnc" id="L366" title="All 2 branches missed.">        return ((gc == null) ||</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                (gc.getDevice() == vImg.getGraphicsConfig().getDevice()));</span>
    }

    @Override
    public ImageCapabilities getCapabilities(GraphicsConfiguration gc) {
<span class="nc bnc" id="L372" title="All 2 branches missed.">        if (isConfigValid(gc)) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            return isAccelerationEnabled() ?</span>
                new AcceleratedImageCapabilities() :
                new ImageCapabilities(false);
        }
<span class="nc" id="L377">        return super.getCapabilities(gc);</span>
    }

    private class AcceleratedImageCapabilities
        extends ImageCapabilities
    {
<span class="nc" id="L383">        AcceleratedImageCapabilities() {</span>
<span class="nc" id="L384">            super(false);</span>
<span class="nc" id="L385">        }</span>
        @Override
        public boolean isAccelerated() {
<span class="nc bnc" id="L388" title="All 2 branches missed.">            return (sdCurrent == sdAccel);</span>
        }
        @Override
        public boolean isTrueVolatile() {
<span class="nc" id="L392">            return isAccelerated();</span>
        }
    }

    /**
     * Releases any associated hardware memory for this image by
     * calling flush on sdAccel.  This method forces a lostSurface
     * situation so any future operations on the image will need to
     * revalidate the image first.
     */
    public void flush() {
<span class="nc" id="L403">        lostSurface = true;</span>
<span class="nc" id="L404">        SurfaceData oldSD = sdAccel;</span>
<span class="nc" id="L405">        sdAccel = null;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (oldSD != null) {</span>
<span class="nc" id="L407">            oldSD.flush();</span>
        }
<span class="nc" id="L409">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>