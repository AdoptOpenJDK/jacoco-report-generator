<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PNGImageDecoder.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.awt.image</a> &gt; <span class="el_source">PNGImageDecoder.java</span></div><h1>PNGImageDecoder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.image;

import java.io.*;
import java.util.*;
import java.util.zip.*;
import java.awt.image.*;
import java.awt.Color;

/** PNG - Portable Network Graphics - image file reader.
    See &lt;a href=http://www.ietf.org/rfc/rfc2083.txt&gt;RFC2083&lt;/a&gt; for details. */

/* this is changed
public class PNGImageDecoder extends FilterInputStream implements Runnable
{ */

public class PNGImageDecoder extends ImageDecoder
{
    private static final int GRAY=0;
    private static final int PALETTE=1;
    private static final int COLOR=2;
    private static final int ALPHA=4;

    private static final int bKGDChunk = 0x624B4744;
    private static final int cHRMChunk = 0x6348524D;
    private static final int gAMAChunk = 0x67414D41;
    private static final int hISTChunk = 0x68495354;
    private static final int IDATChunk = 0x49444154;
    private static final int IENDChunk = 0x49454E44;
    private static final int IHDRChunk = 0x49484452;
    private static final int PLTEChunk = 0x504C5445;
    private static final int pHYsChunk = 0x70485973;
    private static final int sBITChunk = 0x73424954;
    private static final int tEXtChunk = 0x74455874;
    private static final int tIMEChunk = 0x74494D45;
    private static final int tRNSChunk = 0x74524E53;
    private static final int zTXtChunk = 0x7A545874;

    private int width;
    private int height;
    private int bitDepth;
    private int colorType;
    private int compressionMethod;
    private int filterMethod;
    private int interlaceMethod;
<span class="nc" id="L70">    private int gamma = 100000;</span>
    private java.util.Hashtable properties;
  /* this is not needed
    ImageConsumer target;
    */
    private ColorModel cm;
    private byte[] red_map, green_map, blue_map, alpha_map;
<span class="nc" id="L77">    private int transparentPixel = -1;</span>
<span class="nc" id="L78">    private byte[]  transparentPixel_16 = null; // we need 6 bytes to store 16bpp value</span>
<span class="nc" id="L79">    private static ColorModel greyModels[] = new ColorModel[4];</span>
  /* this is not needed
     PNGImageDecoder next;
     */

    private void property(String key,Object value) {
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if(value==null) return;</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if(properties==null) properties=new java.util.Hashtable();</span>
<span class="nc" id="L87">        properties.put(key,value);</span>
<span class="nc" id="L88">    }</span>
    private void property(String key,float value) {
<span class="nc" id="L90">        property(key,new Float(value));</span>
<span class="nc" id="L91">    }</span>
    private final void pngassert(boolean b) throws IOException {
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if(!b) {</span>
<span class="nc" id="L94">            PNGException e = new PNGException(&quot;Broken file&quot;);</span>
<span class="nc" id="L95">            e.printStackTrace();</span>
<span class="nc" id="L96">            throw e;</span>
        }
<span class="nc" id="L98">    }</span>
    protected boolean handleChunk(int key, byte[] buf, int st, int len)
        throws IOException {
<span class="nc bnc" id="L101" title="All 14 branches missed.">        switch(key) {</span>
            case bKGDChunk:
<span class="nc" id="L103">                Color c = null;</span>
<span class="nc bnc" id="L104" title="All 4 branches missed.">                switch(colorType) {</span>
                    case COLOR:
                    case COLOR|ALPHA:
<span class="nc bnc" id="L107" title="All 2 branches missed.">                        pngassert(len==6);</span>
<span class="nc" id="L108">                        c = new Color(buf[st]&amp;0xff,buf[st+2]&amp;0xff,buf[st+4]&amp;0xff);</span>
<span class="nc" id="L109">                        break;</span>
                    case COLOR|PALETTE:
                    case COLOR|PALETTE|ALPHA:
<span class="nc bnc" id="L112" title="All 2 branches missed.">                        pngassert(len==1);</span>
<span class="nc" id="L113">                        int ix = buf[st]&amp;0xFF;</span>
<span class="nc bnc" id="L114" title="All 4 branches missed.">                        pngassert(red_map!=null &amp;&amp; ix&lt;red_map.length);</span>
<span class="nc" id="L115">                        c = new Color(red_map[ix]&amp;0xff,green_map[ix]&amp;0xff,blue_map[ix]&amp;0xff);</span>
<span class="nc" id="L116">                        break;</span>
                    case GRAY:
                    case GRAY|ALPHA:
<span class="nc bnc" id="L119" title="All 2 branches missed.">                        pngassert(len==2);</span>
<span class="nc" id="L120">                        int t = buf[st]&amp;0xFF;</span>
<span class="nc" id="L121">                        c = new Color(t,t,t);</span>
                        break;
                }
<span class="nc bnc" id="L124" title="All 2 branches missed.">                if(c!=null) property(&quot;background&quot;,c);</span>
                break;
            case cHRMChunk:
<span class="nc" id="L127">                property(&quot;chromaticities&quot;,</span>
                    new Chromaticities(
<span class="nc" id="L129">                        getInt(st),</span>
<span class="nc" id="L130">                        getInt(st+4),</span>
<span class="nc" id="L131">                        getInt(st+8),</span>
<span class="nc" id="L132">                        getInt(st+12),</span>
<span class="nc" id="L133">                        getInt(st+16),</span>
<span class="nc" id="L134">                        getInt(st+20),</span>
<span class="nc" id="L135">                        getInt(st+24),</span>
<span class="nc" id="L136">                        getInt(st+28)));</span>
<span class="nc" id="L137">                break;</span>
            case gAMAChunk:
<span class="nc bnc" id="L139" title="All 2 branches missed.">                if(len!=4) throw new PNGException(&quot;bogus gAMA&quot;);</span>
<span class="nc" id="L140">                gamma = getInt(st);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">                if(gamma!=100000) property(&quot;gamma&quot;,gamma/100000.0f);</span>
                break;
<span class="nc" id="L143">            case hISTChunk: break;</span>
<span class="nc" id="L144">            case IDATChunk: return false;</span>
<span class="nc" id="L145">            case IENDChunk: break;</span>
            case IHDRChunk:
<span class="nc bnc" id="L147" title="All 2 branches missed.">                if(len!=13</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                    ||(width = getInt(st))==0</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">                    ||(height = getInt(st+4))==0</span>
<span class="nc" id="L150">                    ) throw new PNGException(&quot;bogus IHDR&quot;);</span>
<span class="nc" id="L151">                bitDepth = getByte(st+8);</span>
<span class="nc" id="L152">                colorType = getByte(st+9);</span>
<span class="nc" id="L153">                compressionMethod = getByte(st+10);</span>
<span class="nc" id="L154">                filterMethod = getByte(st+11);</span>
<span class="nc" id="L155">                interlaceMethod = getByte(st+12);</span>
                /* this is not needed
                  if(target!=null) target.setDimensions(width,height);
                  */
<span class="nc" id="L159">                break;</span>
            case PLTEChunk:
<span class="nc" id="L161">                {   int tsize = len/3;</span>
<span class="nc" id="L162">                    red_map = new byte[tsize];</span>
<span class="nc" id="L163">                    green_map = new byte[tsize];</span>
<span class="nc" id="L164">                    blue_map = new byte[tsize];</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                    for(int i=0,j=st; i&lt;tsize; i++, j+=3) {</span>
<span class="nc" id="L166">                        red_map[i] = buf[j];</span>
<span class="nc" id="L167">                        green_map[i] = buf[j+1];</span>
<span class="nc" id="L168">                        blue_map[i] = buf[j+2];</span>
                    }
                }
<span class="nc" id="L171">                break;</span>
<span class="nc" id="L172">            case pHYsChunk: break;</span>
<span class="nc" id="L173">            case sBITChunk: break;</span>
            case tEXtChunk:
<span class="nc" id="L175">                int klen = 0;</span>
<span class="nc bnc" id="L176" title="All 4 branches missed.">                while(klen&lt;len &amp;&amp; buf[st+klen]!=0) klen++;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                if(klen&lt;len) {</span>
<span class="nc" id="L178">                    String tkey = new String(buf,st,klen);</span>
<span class="nc" id="L179">                    String tvalue = new String(buf,st+klen+1,len-klen-1);</span>
<span class="nc" id="L180">                    property(tkey,tvalue);</span>
<span class="nc" id="L181">                }</span>
                break;
            case tIMEChunk:
<span class="nc" id="L184">                property(&quot;modtime&quot;,new GregorianCalendar(</span>
<span class="nc" id="L185">                    getShort(st+0),</span>
<span class="nc" id="L186">                    getByte(st+2)-1,</span>
<span class="nc" id="L187">                    getByte(st+3),</span>
<span class="nc" id="L188">                    getByte(st+4),</span>
<span class="nc" id="L189">                    getByte(st+5),</span>
<span class="nc" id="L190">                    getByte(st+6)).getTime());</span>
<span class="nc" id="L191">                break;</span>
            case tRNSChunk:
<span class="nc bnc" id="L193" title="All 4 branches missed.">                switch(colorType) {</span>
                    case PALETTE|COLOR:
                    case PALETTE|COLOR|ALPHA:
<span class="nc" id="L196">                        int alen = len;</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">                        if(red_map!=null) alen = red_map.length;</span>
<span class="nc" id="L198">                        alpha_map = new byte[alen];</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                        System.arraycopy(buf,st,alpha_map,0,len&lt;alen ? len : alen);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                        while (--alen&gt;=len) alpha_map[alen] = (byte)0xFF;</span>
                        break;
                    case COLOR: // doesn't deal with 16 bit colors properly
                    case COLOR|ALPHA: // doesn't deal with 16 bit colors properly
<span class="nc bnc" id="L204" title="All 2 branches missed.">                        pngassert(len==6);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                        if (bitDepth == 16) {</span>
<span class="nc" id="L206">                            transparentPixel_16 = new byte[6];</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">                            for (int i = 0; i &lt; 6; i++) {</span>
<span class="nc" id="L208">                                transparentPixel_16[i] = (byte)getByte(st + i);</span>
                            }
                        } else {
<span class="nc" id="L211">                            transparentPixel =</span>
<span class="nc" id="L212">                                      ((getShort(st + 0)&amp;0xFF)&lt;&lt;16)</span>
<span class="nc" id="L213">                                    | ((getShort(st + 2)&amp;0xFF)&lt;&lt; 8)</span>
<span class="nc" id="L214">                                    | ((getShort(st + 4)&amp;0xFF)    );</span>
                        }
<span class="nc" id="L216">                        break;</span>
                    case GRAY:  // doesn't deal with 16 bit colors properly
                    case GRAY|ALPHA:  // doesn't deal with 16 bit colors properly
<span class="nc bnc" id="L219" title="All 2 branches missed.">                        pngassert(len==2);</span>
                        /* REMIND: Discarding the LSB for 16 bit depth here
                         * means that the all pixels which match the MSB
                         * will be treated as transparent.
                         */
<span class="nc" id="L224">                        int t = getShort(st);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">                        t = 0xFF &amp; ((bitDepth == 16) ? (t &gt;&gt; 8) : t);</span>
<span class="nc" id="L226">                        transparentPixel = (t&lt;&lt;16) | (t&lt;&lt; 8) | t;</span>
                        break;
                }
<span class="nc" id="L229">                break;</span>
            case zTXtChunk: break;
        }
<span class="nc" id="L232">        return true;</span>
    }
    public class PNGException extends IOException {
<span class="nc" id="L235">        PNGException(String s) { super(s); }</span>
    }
  /* this is changed
     public void run() {
     */
  public void produceImage() throws IOException, ImageFormatException {
    /* this is not needed
       ImageConsumer t = target;
       if(t!=null) try {
       */
    try {
<span class="nc bnc" id="L246" title="All 2 branches missed.">            for(int i=0; i&lt;signature.length; i++)</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">              if((signature[i]&amp;0xFF)!=underlyingInputStream.read())</span>
<span class="nc" id="L248">                throw new PNGException(&quot;Chunk signature mismatch&quot;);</span>

<span class="nc" id="L250">            InputStream is = new BufferedInputStream(new InflaterInputStream(inputStream,new Inflater()));</span>

<span class="nc" id="L252">            getData();</span>

<span class="nc" id="L254">            byte[] bPixels = null;</span>
<span class="nc" id="L255">            int[] wPixels = null;</span>
<span class="nc" id="L256">            int pixSize = width;</span>
            int rowStride;
<span class="nc" id="L258">            int logDepth = 0;</span>
<span class="nc bnc" id="L259" title="All 6 branches missed.">            switch(bitDepth) {</span>
<span class="nc" id="L260">                case  1: logDepth = 0; break;</span>
<span class="nc" id="L261">                case  2: logDepth = 1; break;</span>
<span class="nc" id="L262">                case  4: logDepth = 2; break;</span>
<span class="nc" id="L263">                case  8: logDepth = 3; break;</span>
<span class="nc" id="L264">                case 16: logDepth = 4; break;</span>
<span class="nc" id="L265">                default: throw new PNGException(&quot;invalid depth&quot;);</span>
            }
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if(interlaceMethod!=0) {pixSize *= height;rowStride=width;}</span>
<span class="nc" id="L268">            else rowStride = 0;</span>
<span class="nc" id="L269">            int combinedType = colorType|(bitDepth&lt;&lt;3);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            int bitMask = (1&lt;&lt;(bitDepth&gt;=8?8:bitDepth))-1;</span>
            //Figure out the color model
<span class="nc bnc" id="L272" title="All 4 branches missed.">            switch(colorType) {</span>
                case COLOR|PALETTE:
                case COLOR|PALETTE|ALPHA:
<span class="nc bnc" id="L275" title="All 2 branches missed.">                    if(red_map==null) throw new PNGException(&quot;palette expected&quot;);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">                    if(alpha_map==null)</span>
<span class="nc" id="L277">                        cm = new IndexColorModel(bitDepth,red_map.length,</span>
                            red_map,green_map,blue_map);
                    else
<span class="nc" id="L280">                        cm = new IndexColorModel(bitDepth,red_map.length,</span>
                            red_map,green_map,blue_map,alpha_map);
<span class="nc" id="L282">                    bPixels = new byte[pixSize];</span>
<span class="nc" id="L283">                    break;</span>
                case GRAY:
<span class="nc bnc" id="L285" title="All 2 branches missed.">                    {   int llog = logDepth&gt;=4 ? 3 : logDepth;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                        if((cm=greyModels[llog]) == null) {</span>
<span class="nc" id="L287">                            int size = 1&lt;&lt;(1&lt;&lt;llog);</span>

<span class="nc" id="L289">                            byte ramp[] = new byte[size];</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                            for(int i = 0; i&lt;size; i++) ramp[i] = (byte)(255*i/(size-1));</span>

<span class="nc bnc" id="L292" title="All 2 branches missed.">                            if (transparentPixel == -1) {</span>
<span class="nc" id="L293">                                cm = new IndexColorModel(bitDepth,ramp.length,ramp,ramp,ramp);</span>
                            } else {
<span class="nc" id="L295">                                cm = new IndexColorModel(bitDepth,ramp.length,ramp,ramp,ramp,</span>
                                                         (transparentPixel &amp; 0xFF));
                            }
<span class="nc" id="L298">                            greyModels[llog] = cm;</span>
                        }
                    }
<span class="nc" id="L301">                    bPixels = new byte[pixSize];</span>
<span class="nc" id="L302">                    break;</span>
                case COLOR:
                case COLOR|ALPHA:
                case GRAY|ALPHA:
<span class="nc" id="L306">                    cm = ColorModel.getRGBdefault();</span>
<span class="nc" id="L307">                    wPixels = new int[pixSize];</span>
<span class="nc" id="L308">                    break;</span>
                default:
<span class="nc" id="L310">                    throw new PNGException(&quot;invalid color type&quot;);</span>
            }
            /* this is going to be set in the pixel store
              t.setColorModel(cm);
            t.setHints(interlaceMethod !=0
                       ? ImageConsumer.TOPDOWNLEFTRIGHT | ImageConsumer.COMPLETESCANLINES
                       : ImageConsumer.TOPDOWNLEFTRIGHT | ImageConsumer.COMPLETESCANLINES |
                         ImageConsumer.SINGLEPASS | ImageConsumer.SINGLEFRAME);
                         */
            // code added to make it work with ImageDecoder architecture
<span class="nc" id="L320">            setDimensions(width, height);</span>
<span class="nc" id="L321">            setColorModel(cm);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            int flags = (interlaceMethod !=0</span>
                       ? ImageConsumer.TOPDOWNLEFTRIGHT | ImageConsumer.COMPLETESCANLINES
                       : ImageConsumer.TOPDOWNLEFTRIGHT | ImageConsumer.COMPLETESCANLINES |
                         ImageConsumer.SINGLEPASS | ImageConsumer.SINGLEFRAME);
<span class="nc" id="L326">            setHints(flags);</span>
<span class="nc" id="L327">            headerComplete();</span>
            // end of adding

<span class="nc bnc" id="L330" title="All 6 branches missed.">            int samplesPerPixel = ((colorType&amp;PALETTE)!=0 ? 1</span>
                                 : ((colorType&amp;COLOR)!=0 ? 3 : 1)+((colorType&amp;ALPHA)!=0?1:0));
<span class="nc" id="L332">            int bitsPerPixel = samplesPerPixel*bitDepth;</span>
<span class="nc" id="L333">            int bytesPerPixel = (bitsPerPixel+7)&gt;&gt;3;</span>
            int pass, passLimit;
<span class="nc bnc" id="L335" title="All 2 branches missed.">            if(interlaceMethod==0) { pass = -1; passLimit = 0; }</span>
<span class="nc" id="L336">            else { pass = 0; passLimit = 7; }</span>
            // These loops are far from being tuned.  They're this way to make them easy to
            // debug.  Tuning comes later.
            /* code changed. target not needed here
               while(++pass&lt;=passLimit &amp;&amp; (t=target)!=null) {
               */
<span class="nc bnc" id="L342" title="All 2 branches missed.">            while(++pass&lt;=passLimit) {</span>
<span class="nc" id="L343">                int row = startingRow[pass];</span>
<span class="nc" id="L344">                int rowInc = rowIncrement[pass];</span>
<span class="nc" id="L345">                int colInc = colIncrement[pass];</span>
<span class="nc" id="L346">                int bWidth = blockWidth[pass];</span>
<span class="nc" id="L347">                int bHeight = blockHeight[pass];</span>
<span class="nc" id="L348">                int sCol = startingCol[pass];</span>
<span class="nc" id="L349">                int rowPixelWidth = (width-sCol+(colInc-1))/colInc;</span>
<span class="nc" id="L350">                int rowByteWidth = ((rowPixelWidth*bitsPerPixel)+7)&gt;&gt;3;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                if(rowByteWidth==0) continue;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                int pixelBufferInc = interlaceMethod==0 ? rowInc*width : 0;</span>
<span class="nc" id="L353">                int rowOffset = rowStride*row;</span>
<span class="nc" id="L354">                boolean firstRow = true;</span>

<span class="nc" id="L356">                byte[] rowByteBuffer = new byte[rowByteWidth];</span>
<span class="nc" id="L357">                byte[] prevRowByteBuffer = new byte[rowByteWidth];</span>
                /* code changed. target not needed here
                   while (row &lt; height &amp;&amp; (t=target)!=null) {
                   */
<span class="nc bnc" id="L361" title="All 2 branches missed.">                while (row &lt; height) {</span>
<span class="nc" id="L362">                    int rowFilter = is.read();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">                    for (int rowFillPos=0;rowFillPos&lt;rowByteWidth; ) {</span>
<span class="nc" id="L364">                        int n = is.read(rowByteBuffer,rowFillPos,rowByteWidth-rowFillPos);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                        if(n&lt;=0) throw new PNGException(&quot;missing data&quot;);</span>
<span class="nc" id="L366">                        rowFillPos+=n;</span>
<span class="nc" id="L367">                    }</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                    filterRow(rowByteBuffer,</span>
                              firstRow ? null : prevRowByteBuffer,
                              rowFilter, rowByteWidth, bytesPerPixel);
<span class="nc" id="L371">                    int col = sCol;</span>
<span class="nc" id="L372">                    int spos=0;</span>
<span class="nc" id="L373">                    int pixel = 0;</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                    while (col &lt; width) {</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                        if(wPixels !=null) {</span>
<span class="nc bnc" id="L376" title="All 7 branches missed.">                            switch(combinedType) {</span>
                                case COLOR|ALPHA|(8&lt;&lt;3):
<span class="nc" id="L378">                                    wPixels[col+rowOffset] =</span>
                                          ((rowByteBuffer[spos  ]&amp;0xFF)&lt;&lt;16)
                                        | ((rowByteBuffer[spos+1]&amp;0xFF)&lt;&lt; 8)
                                        | ((rowByteBuffer[spos+2]&amp;0xFF)    )
                                        | ((rowByteBuffer[spos+3]&amp;0xFF)&lt;&lt;24);
<span class="nc" id="L383">                                    spos+=4;</span>
<span class="nc" id="L384">                                    break;</span>
                                case COLOR|ALPHA|(16&lt;&lt;3):
<span class="nc" id="L386">                                    wPixels[col+rowOffset] =</span>
                                          ((rowByteBuffer[spos  ]&amp;0xFF)&lt;&lt;16)
                                        | ((rowByteBuffer[spos+2]&amp;0xFF)&lt;&lt; 8)
                                        | ((rowByteBuffer[spos+4]&amp;0xFF)    )
                                        | ((rowByteBuffer[spos+6]&amp;0xFF)&lt;&lt;24);
<span class="nc" id="L391">                                    spos+=8;</span>
<span class="nc" id="L392">                                    break;</span>
                                case COLOR|(8&lt;&lt;3):
<span class="nc" id="L394">                                    pixel =</span>
                                          ((rowByteBuffer[spos  ]&amp;0xFF)&lt;&lt;16)
                                        | ((rowByteBuffer[spos+1]&amp;0xFF)&lt;&lt; 8)
                                        | ((rowByteBuffer[spos+2]&amp;0xFF)    );
<span class="nc bnc" id="L398" title="All 2 branches missed.">                                    if (pixel != transparentPixel) {</span>
<span class="nc" id="L399">                                        pixel |= 0xff000000;</span>
                                    }
<span class="nc" id="L401">                                    wPixels[col+rowOffset] = pixel;</span>
<span class="nc" id="L402">                                    spos+=3;</span>
<span class="nc" id="L403">                                    break;</span>
                                case COLOR|(16&lt;&lt;3):
<span class="nc" id="L405">                                    pixel =</span>
                                              ((rowByteBuffer[spos  ]&amp;0xFF)&lt;&lt;16)
                                            | ((rowByteBuffer[spos+2]&amp;0xFF)&lt;&lt; 8)
                                            | ((rowByteBuffer[spos+4]&amp;0xFF)    );

<span class="nc bnc" id="L410" title="All 2 branches missed.">                                    boolean isTransparent = (transparentPixel_16 != null);</span>
<span class="nc bnc" id="L411" title="All 4 branches missed.">                                    for (int i = 0; isTransparent &amp;&amp; (i &lt; 6); i++) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                                        isTransparent &amp;=</span>
                                                (rowByteBuffer[spos + i] &amp; 0xFF) == (transparentPixel_16[i] &amp; 0xFF);
                                    }
<span class="nc bnc" id="L415" title="All 2 branches missed.">                                    if (!isTransparent)  {</span>
<span class="nc" id="L416">                                        pixel |= 0xff000000;</span>
                                    }
<span class="nc" id="L418">                                    wPixels[col+rowOffset] = pixel;</span>
<span class="nc" id="L419">                                    spos+=6;</span>
<span class="nc" id="L420">                                    break;</span>
                                case GRAY|ALPHA|(8&lt;&lt;3):
<span class="nc" id="L422">                                    { int tx = rowByteBuffer[spos]&amp;0xFF;</span>
<span class="nc" id="L423">                                      wPixels[col+rowOffset] =</span>
                                          (tx&lt;&lt;16)|(tx&lt;&lt;8)|tx
                                        |((rowByteBuffer[spos+1]&amp;0xFF)&lt;&lt;24); }
<span class="nc" id="L426">                                    spos+=2;</span>
<span class="nc" id="L427">                                    break;</span>
                                case GRAY|ALPHA|(16&lt;&lt;3):
<span class="nc" id="L429">                                    { int tx = rowByteBuffer[spos]&amp;0xFF;</span>
<span class="nc" id="L430">                                      wPixels[col+rowOffset] =</span>
                                          (tx&lt;&lt;16)|(tx&lt;&lt;8)|tx
                                        |((rowByteBuffer[spos+2]&amp;0xFF)&lt;&lt;24); }
<span class="nc" id="L433">                                    spos+=4;</span>
<span class="nc" id="L434">                                    break;</span>
<span class="nc" id="L435">                                default: throw new PNGException(&quot;illegal type/depth&quot;);</span>
                            }
<span class="nc bnc" id="L437" title="All 6 branches missed.">                        } else switch(bitDepth) {</span>
                            case 1:
<span class="nc" id="L439">                                bPixels[col+rowOffset] =</span>
                                    (byte)((rowByteBuffer[spos&gt;&gt;3]&gt;&gt;(7-(spos&amp;7)))&amp;1);
<span class="nc" id="L441">                                spos++;</span>
<span class="nc" id="L442">                                break;</span>
                            case 2:
<span class="nc" id="L444">                                bPixels[col+rowOffset] =</span>
                                    (byte)((rowByteBuffer[spos&gt;&gt;2]&gt;&gt;((3-(spos&amp;3))*2))&amp;3);
<span class="nc" id="L446">                                spos++;</span>
<span class="nc" id="L447">                                break;</span>
                            case 4:
<span class="nc" id="L449">                                bPixels[col+rowOffset] =</span>
                                    (byte)((rowByteBuffer[spos&gt;&gt;1]&gt;&gt;((1-(spos&amp;1))*4))&amp;15);
<span class="nc" id="L451">                                spos++;</span>
<span class="nc" id="L452">                                break;</span>
<span class="nc" id="L453">                            case 8: bPixels[col+rowOffset] = rowByteBuffer[spos++];</span>
<span class="nc" id="L454">                                break;</span>
<span class="nc" id="L455">                            case 16: bPixels[col+rowOffset] = rowByteBuffer[spos]; spos+=2;</span>
<span class="nc" id="L456">                                break;</span>
<span class="nc" id="L457">                            default: throw new PNGException(&quot;illegal type/depth&quot;);</span>
                        }
                        /*visit (row, col,
                            min (bHeight, height - row),
                            min (bWidth, width - col)); */
<span class="nc" id="L462">                        col += colInc;</span>
                    }
<span class="nc bnc" id="L464" title="All 2 branches missed.">                    if(interlaceMethod==0)</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                      if(wPixels!=null) {</span>
                        /* code changed. target not needed here
                          t.setPixels(0,row,width,1,cm,wPixels,0,width);
                          */
                       // code added to make it work with ImageDecoder arch
<span class="nc" id="L470">                        sendPixels(0,row,width,1,wPixels,0,width);</span>
                        // end of adding
                      }
                      else {
                        /* code changed. target not needed here
                           t.setPixels(0,row,width,1,cm,bPixels,0,width);
                           */
                        // code added to make it work with ImageDecoder arch
<span class="nc" id="L478">                        sendPixels(0,row,width,1,bPixels,0,width);</span>
                        //end of adding
                      }
<span class="nc" id="L481">                    row += rowInc;</span>
<span class="nc" id="L482">                    rowOffset += rowInc*rowStride;</span>
<span class="nc" id="L483">                    byte[] T = rowByteBuffer;</span>
<span class="nc" id="L484">                    rowByteBuffer = prevRowByteBuffer;</span>
<span class="nc" id="L485">                    prevRowByteBuffer = T;</span>
<span class="nc" id="L486">                    firstRow = false;</span>
<span class="nc" id="L487">                }</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">                if(interlaceMethod!=0)</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">                  if(wPixels!=null) {</span>
                    /* code changed. target not needed here
                       t.setPixels(0,0,width,height,cm,wPixels,0,width);
                       */
                    // code added to make it work with ImageDecoder arch
<span class="nc" id="L494">                      sendPixels(0,0,width,height,wPixels,0,width);</span>
                      //end of adding
                  }
                  else {
                     /* code changed. target not needed here
                        t.setPixels(0,0,width,height,cm,bPixels,0,width);
                        */
                    // code added to make it work with ImageDecoder arch
<span class="nc" id="L502">                      sendPixels(0,0,width,height,bPixels,0,width);</span>
                      //end of adding
                  }
<span class="nc" id="L505">            }</span>

   /* Here, the function &quot;visit(row,column,height,width)&quot; obtains the
      next transmitted pixel and paints a rectangle of the specified
      height and width, whose upper-left corner is at the specified row
      and column, using the color indicated by the pixel.  Note that row
      and column are measured from 0,0 at the upper left corner. */

            /* code not needed, don't deal with target
             if((t=target)!=null) {
               if(properties!=null) t.setProperties(properties);
                 t.imageComplete(ImageConsumer.STATICIMAGEDONE);
                 */

<span class="nc" id="L519">              imageComplete(ImageConsumer.STATICIMAGEDONE, true);</span>

              /* code not needed }
               is.close();
               */
<span class="nc" id="L524">        } catch(IOException e) {</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">            if(!aborted) {</span>
                /* code not needed
                   if((t=target)!=null) {
                   PNGEncoder.prChunk(e.toString(),inbuf,pos,limit-pos,true);
                */
<span class="nc" id="L530">                property(&quot;error&quot;, e);</span>
                /* code not needed
                   t.setProperties(properties);
                   t.imageComplete(ImageConsumer.IMAGEERROR|ImageConsumer.STATICIMAGEDONE);
                */
<span class="nc" id="L535">                imageComplete(ImageConsumer.IMAGEERROR|ImageConsumer.STATICIMAGEDONE, true);</span>
<span class="nc" id="L536">                throw e;</span>
            }
        } finally {
<span class="nc" id="L539">          try { close(); } catch(Throwable e){}</span>
          /* code not needed
             target = null;
             endTurn();
             */
<span class="nc" id="L544">        }</span>
<span class="nc" id="L545">    }</span>

    private boolean sendPixels(int x, int y, int w, int h, int[] pixels,
                               int offset, int pixlength) {
<span class="nc" id="L549">        int count = setPixels(x, y, w, h, cm,</span>
                              pixels, offset, pixlength);
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (count &lt;= 0) {</span>
<span class="nc" id="L552">            aborted = true;</span>
        }
<span class="nc bnc" id="L554" title="All 2 branches missed.">        return !aborted;</span>
    }
    private boolean sendPixels(int x, int y, int w, int h, byte[] pixels,
                               int offset, int pixlength) {
<span class="nc" id="L558">        int count = setPixels(x, y, w, h, cm,</span>
                              pixels, offset, pixlength);
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (count &lt;= 0) {</span>
<span class="nc" id="L561">            aborted = true;</span>
        }
<span class="nc bnc" id="L563" title="All 2 branches missed.">        return !aborted;</span>
    }

    private void filterRow(byte rowByteBuffer[], byte[] prevRow,
                           int rowFilter, int rowByteWidth, int bytesPerSample)
        throws IOException {
<span class="nc" id="L569">        int x = 0;</span>
<span class="nc bnc" id="L570" title="All 6 branches missed.">        switch (rowFilter) {</span>
          case 0:
<span class="nc" id="L572">            break;</span>
          case 1:
<span class="nc bnc" id="L574" title="All 2 branches missed.">            for (x = bytesPerSample; x &lt; rowByteWidth; x++)</span>
<span class="nc" id="L575">                rowByteBuffer[x] += rowByteBuffer[x - bytesPerSample];</span>
            break;
          case 2:
<span class="nc bnc" id="L578" title="All 2 branches missed.">            if (prevRow != null)</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">                for ( ; x &lt; rowByteWidth; x++)</span>
<span class="nc" id="L580">                    rowByteBuffer[x] += prevRow[x];</span>
            break;
          case 3:
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (prevRow != null) {</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">                for ( ; x &lt; bytesPerSample; x++)</span>
<span class="nc" id="L585">                    rowByteBuffer[x] += (0xff &amp; prevRow[x])&gt;&gt;1;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">                for ( ; x &lt; rowByteWidth; x++)</span>
<span class="nc" id="L587">                    rowByteBuffer[x] += ((prevRow[x]&amp;0xFF) + (rowByteBuffer[x - bytesPerSample]&amp;0xFF))&gt;&gt;1;</span>
            } else
<span class="nc bnc" id="L589" title="All 2 branches missed.">                for (x = bytesPerSample; x &lt; rowByteWidth; x++)</span>
<span class="nc" id="L590">                    rowByteBuffer[x] += (rowByteBuffer[x - bytesPerSample]&amp;0xFF)&gt;&gt;1;</span>
            break;
          case 4:
<span class="nc bnc" id="L593" title="All 2 branches missed.">            if (prevRow != null) {</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">                for ( ; x &lt; bytesPerSample; x++)</span>
<span class="nc" id="L595">                    rowByteBuffer[x] += prevRow[x];</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                for ( ; x &lt; rowByteWidth; x++) {</span>
                    int a, b, c, p, pa, pb, pc, rval;
<span class="nc" id="L598">                    a = rowByteBuffer[x - bytesPerSample]&amp;0xFF;</span>
<span class="nc" id="L599">                    b = prevRow[x]&amp;0xFF;</span>
<span class="nc" id="L600">                    c = prevRow[x - bytesPerSample]&amp;0xFF;</span>
<span class="nc" id="L601">                    p = a + b - c;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">                    pa = p &gt; a ? p - a : a - p;</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                    pb = p &gt; b ? p - b : b - p;</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">                    pc = p &gt; c ? p - c : c - p;</span>
<span class="nc bnc" id="L605" title="All 6 branches missed.">                    rowByteBuffer[x] += (pa &lt;= pb) &amp;&amp; (pa &lt;= pc) ? a : pb &lt;= pc ? b : c;</span>
                }
            } else
<span class="nc bnc" id="L608" title="All 2 branches missed.">                for (x = bytesPerSample; x &lt; rowByteWidth; x++)</span>
<span class="nc" id="L609">                    rowByteBuffer[x] += rowByteBuffer[x - bytesPerSample];</span>
            break;
          default:
<span class="nc" id="L612">            throw new PNGException(&quot;Illegal filter&quot;);</span>
        }
<span class="nc" id="L614">    }</span>
<span class="nc" id="L615">    private static final byte[] startingRow =  { 0, 0, 0, 4, 0, 2, 0, 1 };</span>
<span class="nc" id="L616">    private static final byte[] startingCol =  { 0, 0, 4, 0, 2, 0, 1, 0 };</span>
<span class="nc" id="L617">    private static final byte[] rowIncrement = { 1, 8, 8, 8, 4, 4, 2, 2 };</span>
<span class="nc" id="L618">    private static final byte[] colIncrement = { 1, 8, 8, 4, 4, 2, 2, 1 };</span>
<span class="nc" id="L619">    private static final byte[] blockHeight =  { 1, 8, 8, 4, 4, 2, 2, 1 };</span>
<span class="nc" id="L620">    private static final byte[] blockWidth =   { 1, 8, 4, 4, 2, 2, 1, 1 };</span>

    //abstract public class ChunkReader extends FilterInputStream {
  int pos, limit;
    int chunkStart;
   int chunkKey, chunkLength, chunkCRC;
    boolean seenEOF;

<span class="nc" id="L628">    private static final byte[] signature = { (byte) 137, (byte) 80, (byte) 78,</span>
        (byte) 71, (byte) 13, (byte) 10, (byte) 26, (byte) 10 };

  PNGFilterInputStream inputStream;
  InputStream underlyingInputStream;

  /* code changed
    public PNGImageDecoder(InputStream in, ImageConsumer t) throws IOException {
    */
  public PNGImageDecoder(InputStreamImageSource src, InputStream input) throws IOException {
    // code added
<span class="nc" id="L639">    super(src, input);</span>
<span class="nc" id="L640">    inputStream = new PNGFilterInputStream(this, input);</span>
<span class="nc" id="L641">    underlyingInputStream = inputStream.underlyingInputStream;</span>
    // end of adding
    /* code changed
       super(in);
       target = t;
       waitTurn();
       new Thread(this).start();
       */
<span class="nc" id="L649">    }</span>
  /* code changed to make it work with ImageDecoder architecture
    static int ThreadLimit = 10;
    private synchronized static void waitTurn() {
        try {
            while(ThreadLimit&lt;=0) PNGImageDecoder.class.wait(1000);
        } catch(InterruptedException e){}
        ThreadLimit--;
    }
    private synchronized static void endTurn() {
        if(ThreadLimit&lt;=0) PNGImageDecoder.class.notify();
        ThreadLimit++;
    }
    */
<span class="nc" id="L663">    byte[] inbuf = new byte[4096];</span>
    private void fill() throws IOException {
<span class="nc bnc" id="L665" title="All 2 branches missed.">        if(!seenEOF) {</span>
<span class="nc bnc" id="L666" title="All 4 branches missed.">            if(pos&gt;0 &amp;&amp; pos&lt;limit) {</span>
<span class="nc" id="L667">                System.arraycopy(inbuf,pos,inbuf,0,limit-pos);</span>
<span class="nc" id="L668">                limit = limit-pos;</span>
<span class="nc" id="L669">                pos = 0;</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            } else if(pos&gt;=limit) {</span>
<span class="nc" id="L671">                pos = 0; limit = 0;</span>
            }
<span class="nc" id="L673">            int bsize = inbuf.length;</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">            while(limit&lt;bsize) {</span>
<span class="nc" id="L675">                int n = underlyingInputStream.read(inbuf,limit,bsize-limit);</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">                if(n&lt;=0) { seenEOF=true; break; }</span>
<span class="nc" id="L677">                limit += n;</span>
<span class="nc" id="L678">            }</span>
        }
<span class="nc" id="L680">    }</span>
    private boolean need(int n) throws IOException {
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if(limit-pos&gt;=n) return true;</span>
<span class="nc" id="L683">        fill();</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">        if(limit-pos&gt;=n) return true;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">        if(seenEOF) return false;</span>
<span class="nc" id="L686">        byte nin[] = new byte[n+100];</span>
<span class="nc" id="L687">        System.arraycopy(inbuf,pos,nin,0,limit-pos);</span>
<span class="nc" id="L688">        limit = limit-pos;</span>
<span class="nc" id="L689">        pos = 0;</span>
<span class="nc" id="L690">        inbuf = nin;</span>
<span class="nc" id="L691">        fill();</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        return limit-pos&gt;=n;</span>
    }
    private final int getInt(int pos) {
<span class="nc" id="L695">        return ((inbuf[pos  ]&amp;0xFF)&lt;&lt;24)</span>
             | ((inbuf[pos+1]&amp;0xFF)&lt;&lt;16)
             | ((inbuf[pos+2]&amp;0xFF)&lt;&lt; 8)
             | ((inbuf[pos+3]&amp;0xFF)    );
    }
    private final int getShort(int pos) {
<span class="nc" id="L701">        return (short)(((inbuf[pos  ]&amp;0xFF)&lt;&lt;8)</span>
                     | ((inbuf[pos+1]&amp;0xFF)   ));
    }
    private final int getByte(int pos) {
<span class="nc" id="L705">        return inbuf[pos]&amp;0xFF;</span>
    }
    private final boolean getChunk() throws IOException {
<span class="nc" id="L708">        chunkLength = 0;</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (!need(8)) return false;</span>
<span class="nc" id="L710">        chunkLength = getInt(pos);</span>
<span class="nc" id="L711">        chunkKey = getInt(pos+4);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if(chunkLength&lt;0) throw new PNGException(&quot;bogus length: &quot;+chunkLength);</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">        if (!need(chunkLength+12)) return false;</span>
<span class="nc" id="L714">        chunkCRC = getInt(pos+8+chunkLength);</span>
<span class="nc" id="L715">        chunkStart = pos+8;</span>
<span class="nc" id="L716">        int calcCRC = crc(inbuf,pos+4,chunkLength+4);</span>
<span class="nc bnc" id="L717" title="All 4 branches missed.">        if(chunkCRC!=calcCRC &amp;&amp; checkCRC) throw new PNGException(&quot;crc corruption&quot;);</span>
<span class="nc" id="L718">        pos+=chunkLength+12;</span>
<span class="nc" id="L719">        return true;</span>
    }
    private void readAll() throws IOException {
<span class="nc bnc" id="L722" title="All 2 branches missed.">        while(getChunk()) handleChunk(chunkKey,inbuf,chunkStart,chunkLength);</span>
<span class="nc" id="L723">    }</span>
    boolean getData() throws IOException {
<span class="nc bnc" id="L725" title="All 4 branches missed.">        while(chunkLength==0 &amp;&amp; getChunk())</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">            if(handleChunk(chunkKey,inbuf,chunkStart,chunkLength))</span>
<span class="nc" id="L727">                chunkLength = 0;</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">        return chunkLength&gt;0;</span>
    }
    //abstract protected boolean handleChunk(int key, byte[] buf, int st, int len)
    //    throws IOException;
<span class="nc" id="L732">    private static boolean checkCRC = true;</span>
<span class="nc" id="L733">    public static boolean getCheckCRC() { return checkCRC; }</span>
<span class="nc" id="L734">    public static void setCheckCRC(boolean c) { checkCRC = c; }</span>

    protected void wrc(int c) {
<span class="nc" id="L737">        c = c&amp;0xFF;</span>
<span class="nc bnc" id="L738" title="All 4 branches missed.">        if(c&lt;=' '||c&gt;'z') c = '?';</span>
<span class="nc" id="L739">        System.out.write(c);</span>
<span class="nc" id="L740">    }</span>
    protected void wrk(int n) {
<span class="nc" id="L742">        wrc(n&gt;&gt;24);</span>
<span class="nc" id="L743">        wrc(n&gt;&gt;16);</span>
<span class="nc" id="L744">        wrc(n&gt;&gt;8);</span>
<span class="nc" id="L745">        wrc(n);</span>
<span class="nc" id="L746">    }</span>
    public void print() {
<span class="nc" id="L748">        wrk(chunkKey);</span>
<span class="nc" id="L749">        System.out.print(&quot; &quot;+chunkLength+&quot;\n&quot;);</span>
<span class="nc" id="L750">    }</span>

    /* Table of CRCs of all 8-bit messages. */
<span class="nc" id="L753">    private static final int[] crc_table = new int[256];</span>

    /* Make the table for a fast CRC. */
    static {
<span class="nc bnc" id="L757" title="All 2 branches missed.">        for (int n = 0; n &lt; 256; n++) {</span>
<span class="nc" id="L758">            int c = n;</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">            for (int k = 0; k &lt; 8; k++)</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">                if ((c &amp; 1) != 0)</span>
<span class="nc" id="L761">                    c = 0xedb88320 ^ (c &gt;&gt;&gt; 1);</span>
                else
<span class="nc" id="L763">                    c = c &gt;&gt;&gt; 1;</span>
<span class="nc" id="L764">            crc_table[n] = c;</span>
        }
<span class="nc" id="L766">    }</span>

    /* Update a running CRC with the bytes buf[0..len-1]--the CRC
    should be initialized to all 1's, and the transmitted value
    is the 1's complement of the final running CRC (see the
    crc() routine below)). */

    static private int update_crc(int crc, byte[] buf, int offset, int len) {
<span class="nc" id="L774">        int c = crc;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">        while (--len&gt;=0)</span>
<span class="nc" id="L776">            c = crc_table[(c ^ buf[offset++]) &amp; 0xff] ^ (c &gt;&gt;&gt; 8);</span>
<span class="nc" id="L777">        return c;</span>
    }

    /* Return the CRC of the bytes buf[0..len-1]. */
    static private int crc(byte[] buf, int offset, int len) {
<span class="nc" id="L782">        return update_crc(0xffffffff, buf, offset, len) ^ 0xffffffff;</span>
    }
    public static class Chromaticities {
        public float whiteX, whiteY, redX, redY, greenX, greenY, blueX, blueY;
<span class="nc" id="L786">        Chromaticities(int wx, int wy, int rx, int ry, int gx, int gy, int bx, int by) {</span>
<span class="nc" id="L787">            whiteX = wx/100000.0f;</span>
<span class="nc" id="L788">            whiteY = wy/100000.0f;</span>
<span class="nc" id="L789">            redX = rx/100000.0f;</span>
<span class="nc" id="L790">            redY = ry/100000.0f;</span>
<span class="nc" id="L791">            greenX = gx/100000.0f;</span>
<span class="nc" id="L792">            greenY = gy/100000.0f;</span>
<span class="nc" id="L793">            blueX = bx/100000.0f;</span>
<span class="nc" id="L794">            blueY = by/100000.0f;</span>
<span class="nc" id="L795">        }</span>
        public String toString() {
<span class="nc" id="L797">            return &quot;Chromaticities(white=&quot;+whiteX+&quot;,&quot;+whiteY+&quot;;red=&quot;+</span>
                redX+&quot;,&quot;+redY+&quot;;green=&quot;+
                greenX+&quot;,&quot;+greenY+&quot;;blue=&quot;+
                blueX+&quot;,&quot;+blueY+&quot;)&quot;;
        }
    }
}

// the following class are added to make it work with ImageDecoder architecture

class PNGFilterInputStream extends FilterInputStream {
  PNGImageDecoder owner;
  public InputStream underlyingInputStream;
  public PNGFilterInputStream(PNGImageDecoder owner, InputStream is) {
<span class="nc" id="L811">    super(is);</span>
<span class="nc" id="L812">    underlyingInputStream = in;</span>
<span class="nc" id="L813">    this.owner = owner;</span>
<span class="nc" id="L814">  }</span>

    public int available() throws IOException {
<span class="nc" id="L817">        return owner.limit-owner.pos+in.available();}</span>
<span class="nc" id="L818">    public boolean markSupported() { return false; }</span>
    public int read() throws IOException {
<span class="nc bnc" id="L820" title="All 4 branches missed.">        if(owner.chunkLength&lt;=0) if(!owner.getData()) return -1;</span>
<span class="nc" id="L821">        owner.chunkLength--;</span>
<span class="nc" id="L822">        return owner.inbuf[owner.chunkStart++]&amp;0xFF;</span>
    }
<span class="nc" id="L824">    public int read(byte[] b) throws IOException{return read(b,0,b.length);}</span>
    public int read(byte[] b, int st, int len) throws IOException {
<span class="nc bnc" id="L826" title="All 4 branches missed.">        if(owner.chunkLength&lt;=0) if(!owner.getData()) return -1;</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">        if(owner.chunkLength&lt;len) len = owner.chunkLength;</span>
<span class="nc" id="L828">        System.arraycopy(owner.inbuf,owner.chunkStart,b,st,len);</span>
<span class="nc" id="L829">        owner.chunkLength-=len;</span>
<span class="nc" id="L830">        owner.chunkStart+=len;</span>
<span class="nc" id="L831">        return len;</span>
    }
  public long skip(long n) throws IOException {
        int i;
<span class="nc bnc" id="L835" title="All 4 branches missed.">        for(i = 0; i&lt;n &amp;&amp; read()&gt;=0; i++);</span>
<span class="nc" id="L836">        return i;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>