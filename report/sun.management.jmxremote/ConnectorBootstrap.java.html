<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ConnectorBootstrap.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.management.jmxremote</a> &gt; <span class="el_source">ConnectorBootstrap.java</span></div><h1>ConnectorBootstrap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.management.jmxremote;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.management.ManagementFactory;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.UnknownHostException;
import java.rmi.NoSuchObjectException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.registry.Registry;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMIServerSocketFactory;
import java.rmi.server.RemoteObject;
import java.rmi.server.UnicastRemoteObject;
import java.security.KeyStore;
import java.security.Principal;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.StringTokenizer;

import javax.management.MBeanServer;
import javax.management.remote.JMXAuthenticator;
import javax.management.remote.JMXConnectorServer;
import javax.management.remote.JMXConnectorServerFactory;
import javax.management.remote.JMXServiceURL;
import javax.management.remote.rmi.RMIConnectorServer;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;
import javax.rmi.ssl.SslRMIClientSocketFactory;
import javax.rmi.ssl.SslRMIServerSocketFactory;
import javax.security.auth.Subject;

import com.sun.jmx.remote.internal.RMIExporter;
import com.sun.jmx.remote.security.JMXPluggableAuthenticator;
import com.sun.jmx.remote.util.ClassLogger;

import sun.management.Agent;
import sun.management.AgentConfigurationError;
import static sun.management.AgentConfigurationError.*;
import sun.management.ConnectorAddressLink;
import sun.management.FileSystem;
import sun.rmi.server.UnicastRef;
import sun.rmi.server.UnicastServerRef;
import sun.rmi.server.UnicastServerRef2;

/**
 * This class initializes and starts the RMIConnectorServer for JSR 163
 * JMX Monitoring.
 **/
public final class ConnectorBootstrap {

    /**
     * Default values for JMX configuration properties.
     **/
    public static interface DefaultValues {

        public static final String PORT = &quot;0&quot;;
        public static final String CONFIG_FILE_NAME = &quot;management.properties&quot;;
        public static final String USE_SSL = &quot;true&quot;;
        public static final String USE_LOCAL_ONLY = &quot;true&quot;;
        public static final String USE_REGISTRY_SSL = &quot;false&quot;;
        public static final String USE_AUTHENTICATION = &quot;true&quot;;
        public static final String PASSWORD_FILE_NAME = &quot;jmxremote.password&quot;;
        public static final String ACCESS_FILE_NAME = &quot;jmxremote.access&quot;;
        public static final String SSL_NEED_CLIENT_AUTH = &quot;false&quot;;
    }

    /**
     * Names of JMX configuration properties.
     **/
    public static interface PropertyNames {

        public static final String PORT =
                &quot;com.sun.management.jmxremote.port&quot;;
        public static final String RMI_PORT =
                &quot;com.sun.management.jmxremote.rmi.port&quot;;
        public static final String CONFIG_FILE_NAME =
                &quot;com.sun.management.config.file&quot;;
        public static final String USE_LOCAL_ONLY =
                &quot;com.sun.management.jmxremote.local.only&quot;;
        public static final String USE_SSL =
                &quot;com.sun.management.jmxremote.ssl&quot;;
        public static final String USE_REGISTRY_SSL =
                &quot;com.sun.management.jmxremote.registry.ssl&quot;;
        public static final String USE_AUTHENTICATION =
                &quot;com.sun.management.jmxremote.authenticate&quot;;
        public static final String PASSWORD_FILE_NAME =
                &quot;com.sun.management.jmxremote.password.file&quot;;
        public static final String ACCESS_FILE_NAME =
                &quot;com.sun.management.jmxremote.access.file&quot;;
        public static final String LOGIN_CONFIG_NAME =
                &quot;com.sun.management.jmxremote.login.config&quot;;
        public static final String SSL_ENABLED_CIPHER_SUITES =
                &quot;com.sun.management.jmxremote.ssl.enabled.cipher.suites&quot;;
        public static final String SSL_ENABLED_PROTOCOLS =
                &quot;com.sun.management.jmxremote.ssl.enabled.protocols&quot;;
        public static final String SSL_NEED_CLIENT_AUTH =
                &quot;com.sun.management.jmxremote.ssl.need.client.auth&quot;;
        public static final String SSL_CONFIG_FILE_NAME =
                &quot;com.sun.management.jmxremote.ssl.config.file&quot;;
    }

    /**
     * JMXConnectorServer associated data.
     */
    private static class JMXConnectorServerData {

        public JMXConnectorServerData(
                JMXConnectorServer jmxConnectorServer,
<span class="nc" id="L145">                JMXServiceURL jmxRemoteURL) {</span>
<span class="nc" id="L146">            this.jmxConnectorServer = jmxConnectorServer;</span>
<span class="nc" id="L147">            this.jmxRemoteURL = jmxRemoteURL;</span>
<span class="nc" id="L148">        }</span>
        JMXConnectorServer jmxConnectorServer;
        JMXServiceURL jmxRemoteURL;
    }

    /**
     * &lt;p&gt;Prevents our RMI server objects from keeping the JVM alive.&lt;/p&gt;
     *
     * &lt;p&gt;We use a private interface in Sun's JMX Remote API implementation
     * that allows us to specify how to export RMI objects.  We do so using
     * UnicastServerRef, a class in Sun's RMI implementation.  This is all
     * non-portable, of course, so this is only valid because we are inside
     * Sun's JRE.&lt;/p&gt;
     *
     * &lt;p&gt;Objects are exported using {@link
     * UnicastServerRef#exportObject(Remote, Object, boolean)}.  The
     * boolean parameter is called &lt;code&gt;permanent&lt;/code&gt; and means
     * both that the object is not eligible for Distributed Garbage
     * Collection, and that its continued existence will not prevent
     * the JVM from exiting.  It is the latter semantics we want (we
     * already have the former because of the way the JMX Remote API
     * works).  Hence the somewhat misleading name of this class.&lt;/p&gt;
     */
<span class="nc" id="L171">    private static class PermanentExporter implements RMIExporter {</span>

        public Remote exportObject(Remote obj,
                int port,
                RMIClientSocketFactory csf,
                RMIServerSocketFactory ssf)
                throws RemoteException {

<span class="nc" id="L179">            synchronized (this) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                if (firstExported == null) {</span>
<span class="nc" id="L181">                    firstExported = obj;</span>
                }
<span class="nc" id="L183">            }</span>

            final UnicastServerRef ref;
<span class="nc bnc" id="L186" title="All 4 branches missed.">            if (csf == null &amp;&amp; ssf == null) {</span>
<span class="nc" id="L187">                ref = new UnicastServerRef(port);</span>
            } else {
<span class="nc" id="L189">                ref = new UnicastServerRef2(port, csf, ssf);</span>
            }
<span class="nc" id="L191">            return ref.exportObject(obj, null, true);</span>
        }

        // Nothing special to be done for this case
        public boolean unexportObject(Remote obj, boolean force)
                throws NoSuchObjectException {
<span class="nc" id="L197">            return UnicastRemoteObject.unexportObject(obj, force);</span>
        }
        Remote firstExported;
    }

    /**
     * This JMXAuthenticator wraps the JMXPluggableAuthenticator and verifies
     * that at least one of the principal names contained in the authenticated
     * Subject is present in the access file.
     */
    private static class AccessFileCheckerAuthenticator
            implements JMXAuthenticator {

<span class="nc" id="L210">        public AccessFileCheckerAuthenticator(Map&lt;String, Object&gt; env) throws IOException {</span>
<span class="nc" id="L211">            environment = env;</span>
<span class="nc" id="L212">            accessFile = (String) env.get(&quot;jmx.remote.x.access.file&quot;);</span>
<span class="nc" id="L213">            properties = propertiesFromFile(accessFile);</span>
<span class="nc" id="L214">        }</span>

        public Subject authenticate(Object credentials) {
<span class="nc" id="L217">            final JMXAuthenticator authenticator =</span>
                    new JMXPluggableAuthenticator(environment);
<span class="nc" id="L219">            final Subject subject = authenticator.authenticate(credentials);</span>
<span class="nc" id="L220">            checkAccessFileEntries(subject);</span>
<span class="nc" id="L221">            return subject;</span>
        }

        private void checkAccessFileEntries(Subject subject) {
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (subject == null) {</span>
<span class="nc" id="L226">                throw new SecurityException(</span>
                        &quot;Access denied! No matching entries found in &quot; +
                        &quot;the access file [&quot; + accessFile + &quot;] as the &quot; +
                        &quot;authenticated Subject is null&quot;);
            }
<span class="nc" id="L231">            final Set&lt;Principal&gt; principals = subject.getPrincipals();</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">            for (Principal p1: principals) {</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                if (properties.containsKey(p1.getName())) {</span>
<span class="nc" id="L234">                    return;</span>
                }
<span class="nc" id="L236">            }</span>

<span class="nc" id="L238">            final Set&lt;String&gt; principalsStr = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            for (Principal p2: principals) {</span>
<span class="nc" id="L240">                principalsStr.add(p2.getName());</span>
<span class="nc" id="L241">            }</span>
<span class="nc" id="L242">            throw new SecurityException(</span>
                    &quot;Access denied! No entries found in the access file [&quot; +
                    accessFile + &quot;] for any of the authenticated identities &quot; +
                    principalsStr);
        }

        private static Properties propertiesFromFile(String fname)
                throws IOException {
<span class="nc" id="L250">            Properties p = new Properties();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if (fname == null) {</span>
<span class="nc" id="L252">                return p;</span>
            }
<span class="nc" id="L254">            try (FileInputStream fin = new FileInputStream(fname)) {</span>
<span class="nc" id="L255">                p.load(fin);</span>
<span class="nc bnc" id="L256" title="All 8 branches missed.">            }</span>
<span class="nc" id="L257">            return p;</span>
        }
        private final Map&lt;String, Object&gt; environment;
        private final Properties properties;
        private final String accessFile;
    }

    // The variable below is here to support stop functionality
    // It would be overriten if you call startRemoteCommectionServer second
    // time. It's OK for now as logic in Agent.java forbids mutiple agents
<span class="nc" id="L267">    private static Registry registry = null;</span>

    public static void unexportRegistry() {
        // Remove the entry from registry
        try {
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (registry != null) {</span>
<span class="nc" id="L273">                UnicastRemoteObject.unexportObject(registry, true);</span>
<span class="nc" id="L274">                registry = null;</span>
            }
<span class="nc" id="L276">        } catch(NoSuchObjectException ex) {</span>
            // This exception can appears only if we attempt
            // to unexportRegistry second time. So it's safe
            // to ignore it without additional messages.
<span class="nc" id="L280">        }</span>
<span class="nc" id="L281">    }</span>

     /**
      * Initializes and starts the JMX Connector Server.
      * If the com.sun.management.jmxremote.port property is not defined,
      * simply return. Otherwise, attempts to load the config file, and
      * then calls {@link #startRemoteConnectorServer
      *                            (java.lang.String, java.util.Properties)}.
      *
      * This method is used by some jtreg tests.
      **/
      public static synchronized JMXConnectorServer initialize() {

         // Load a new management properties
<span class="nc" id="L295">         final Properties props = Agent.loadManagementProperties();</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">         if (props == null) {</span>
<span class="nc" id="L297">              return null;</span>
         }

<span class="nc" id="L300">         final String portStr = props.getProperty(PropertyNames.PORT);</span>
<span class="nc" id="L301">         return startRemoteConnectorServer(portStr, props);</span>
     }

    /**
     * This method is used by some jtreg tests.
     *
     * @see #startRemoteConnectorServer
     *             (String portStr, Properties props)
     */
    public static synchronized JMXConnectorServer initialize(String portStr, Properties props)  {
<span class="nc" id="L311">         return startRemoteConnectorServer(portStr, props);</span>
    }

    /**
     * Initializes and starts a JMX Connector Server for remote
     * monitoring and management.
     **/
    public static synchronized JMXConnectorServer startRemoteConnectorServer(String portStr, Properties props) {

        // Get port number
        final int port;
        try {
<span class="nc" id="L323">            port = Integer.parseInt(portStr);</span>
<span class="nc" id="L324">        } catch (NumberFormatException x) {</span>
<span class="nc" id="L325">            throw new AgentConfigurationError(INVALID_JMXREMOTE_PORT, x, portStr);</span>
<span class="nc" id="L326">        }</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (port &lt; 0) {</span>
<span class="nc" id="L328">            throw new AgentConfigurationError(INVALID_JMXREMOTE_PORT, portStr);</span>
        }

        // User can specify a port to be used to export rmi object,
        // in order to simplify firewall rules
        // if port is not specified random one will be allocated.
<span class="nc" id="L334">        int rmiPort = 0;</span>
<span class="nc" id="L335">        String rmiPortStr = props.getProperty(PropertyNames.RMI_PORT);</span>
        try {
<span class="nc bnc" id="L337" title="All 2 branches missed.">            if (rmiPortStr != null) {</span>
<span class="nc" id="L338">               rmiPort = Integer.parseInt(rmiPortStr);</span>
            }
<span class="nc" id="L340">        } catch (NumberFormatException x) {</span>
<span class="nc" id="L341">            throw new AgentConfigurationError(INVALID_JMXREMOTE_RMI_PORT, x, rmiPortStr);</span>
<span class="nc" id="L342">        }</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (rmiPort &lt; 0) {</span>
<span class="nc" id="L344">            throw new AgentConfigurationError(INVALID_JMXREMOTE_RMI_PORT, rmiPortStr);</span>
        }

        // Do we use authentication?
<span class="nc" id="L348">        final String useAuthenticationStr =</span>
<span class="nc" id="L349">                props.getProperty(PropertyNames.USE_AUTHENTICATION,</span>
                DefaultValues.USE_AUTHENTICATION);
<span class="nc" id="L351">        final boolean useAuthentication =</span>
<span class="nc" id="L352">                Boolean.valueOf(useAuthenticationStr).booleanValue();</span>

        // Do we use SSL?
<span class="nc" id="L355">        final String useSslStr =</span>
<span class="nc" id="L356">                props.getProperty(PropertyNames.USE_SSL,</span>
                DefaultValues.USE_SSL);
<span class="nc" id="L358">        final boolean useSsl =</span>
<span class="nc" id="L359">                Boolean.valueOf(useSslStr).booleanValue();</span>

        // Do we use RMI Registry SSL?
<span class="nc" id="L362">        final String useRegistrySslStr =</span>
<span class="nc" id="L363">                props.getProperty(PropertyNames.USE_REGISTRY_SSL,</span>
                DefaultValues.USE_REGISTRY_SSL);
<span class="nc" id="L365">        final boolean useRegistrySsl =</span>
<span class="nc" id="L366">                Boolean.valueOf(useRegistrySslStr).booleanValue();</span>

<span class="nc" id="L368">        final String enabledCipherSuites =</span>
<span class="nc" id="L369">                props.getProperty(PropertyNames.SSL_ENABLED_CIPHER_SUITES);</span>
<span class="nc" id="L370">        String enabledCipherSuitesList[] = null;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (enabledCipherSuites != null) {</span>
<span class="nc" id="L372">            StringTokenizer st = new StringTokenizer(enabledCipherSuites, &quot;,&quot;);</span>
<span class="nc" id="L373">            int tokens = st.countTokens();</span>
<span class="nc" id="L374">            enabledCipherSuitesList = new String[tokens];</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            for (int i = 0; i &lt; tokens; i++) {</span>
<span class="nc" id="L376">                enabledCipherSuitesList[i] = st.nextToken();</span>
            }
        }

<span class="nc" id="L380">        final String enabledProtocols =</span>
<span class="nc" id="L381">                props.getProperty(PropertyNames.SSL_ENABLED_PROTOCOLS);</span>
<span class="nc" id="L382">        String enabledProtocolsList[] = null;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (enabledProtocols != null) {</span>
<span class="nc" id="L384">            StringTokenizer st = new StringTokenizer(enabledProtocols, &quot;,&quot;);</span>
<span class="nc" id="L385">            int tokens = st.countTokens();</span>
<span class="nc" id="L386">            enabledProtocolsList = new String[tokens];</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            for (int i = 0; i &lt; tokens; i++) {</span>
<span class="nc" id="L388">                enabledProtocolsList[i] = st.nextToken();</span>
            }
        }

<span class="nc" id="L392">        final String sslNeedClientAuthStr =</span>
<span class="nc" id="L393">                props.getProperty(PropertyNames.SSL_NEED_CLIENT_AUTH,</span>
                DefaultValues.SSL_NEED_CLIENT_AUTH);
<span class="nc" id="L395">        final boolean sslNeedClientAuth =</span>
<span class="nc" id="L396">                Boolean.valueOf(sslNeedClientAuthStr).booleanValue();</span>

        // Read SSL config file name
<span class="nc" id="L399">        final String sslConfigFileName =</span>
<span class="nc" id="L400">                props.getProperty(PropertyNames.SSL_CONFIG_FILE_NAME);</span>

<span class="nc" id="L402">        String loginConfigName = null;</span>
<span class="nc" id="L403">        String passwordFileName = null;</span>
<span class="nc" id="L404">        String accessFileName = null;</span>

        // Initialize settings when authentication is active
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (useAuthentication) {</span>

            // Get non-default login configuration
<span class="nc" id="L410">            loginConfigName =</span>
<span class="nc" id="L411">                    props.getProperty(PropertyNames.LOGIN_CONFIG_NAME);</span>

<span class="nc bnc" id="L413" title="All 2 branches missed.">            if (loginConfigName == null) {</span>
                // Get password file
<span class="nc" id="L415">                passwordFileName =</span>
<span class="nc" id="L416">                        props.getProperty(PropertyNames.PASSWORD_FILE_NAME,</span>
<span class="nc" id="L417">                        getDefaultFileName(DefaultValues.PASSWORD_FILE_NAME));</span>
<span class="nc" id="L418">                checkPasswordFile(passwordFileName);</span>
            }

            // Get access file
<span class="nc" id="L422">            accessFileName = props.getProperty(PropertyNames.ACCESS_FILE_NAME,</span>
<span class="nc" id="L423">                    getDefaultFileName(DefaultValues.ACCESS_FILE_NAME));</span>
<span class="nc" id="L424">            checkAccessFile(accessFileName);</span>
        }

<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (log.debugOn()) {</span>
<span class="nc" id="L428">            log.debug(&quot;startRemoteConnectorServer&quot;,</span>
<span class="nc bnc" id="L429" title="All 4 branches missed.">                    Agent.getText(&quot;jmxremote.ConnectorBootstrap.starting&quot;) +</span>
                    &quot;\n\t&quot; + PropertyNames.PORT + &quot;=&quot; + port +
                    &quot;\n\t&quot; + PropertyNames.RMI_PORT + &quot;=&quot; + rmiPort +
                    &quot;\n\t&quot; + PropertyNames.USE_SSL + &quot;=&quot; + useSsl +
                    &quot;\n\t&quot; + PropertyNames.USE_REGISTRY_SSL + &quot;=&quot; + useRegistrySsl +
                    &quot;\n\t&quot; + PropertyNames.SSL_CONFIG_FILE_NAME + &quot;=&quot; + sslConfigFileName +
                    &quot;\n\t&quot; + PropertyNames.SSL_ENABLED_CIPHER_SUITES + &quot;=&quot; +
                    enabledCipherSuites +
                    &quot;\n\t&quot; + PropertyNames.SSL_ENABLED_PROTOCOLS + &quot;=&quot; +
                    enabledProtocols +
                    &quot;\n\t&quot; + PropertyNames.SSL_NEED_CLIENT_AUTH + &quot;=&quot; +
                    sslNeedClientAuth +
                    &quot;\n\t&quot; + PropertyNames.USE_AUTHENTICATION + &quot;=&quot; +
                    useAuthentication +
                    (useAuthentication ? (loginConfigName == null ? (&quot;\n\t&quot; + PropertyNames.PASSWORD_FILE_NAME + &quot;=&quot; +
                    passwordFileName) : (&quot;\n\t&quot; + PropertyNames.LOGIN_CONFIG_NAME + &quot;=&quot; +
                    loginConfigName)) : &quot;\n\t&quot; +
<span class="nc bnc" id="L446" title="All 2 branches missed.">                    Agent.getText(&quot;jmxremote.ConnectorBootstrap.noAuthentication&quot;)) +</span>
                    (useAuthentication ? (&quot;\n\t&quot; + PropertyNames.ACCESS_FILE_NAME + &quot;=&quot; +
                    accessFileName) : &quot;&quot;) +
                    &quot;&quot;);
        }

<span class="nc" id="L452">        final MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();</span>
<span class="nc" id="L453">        JMXConnectorServer cs = null;</span>
<span class="nc" id="L454">        JMXServiceURL url = null;</span>
        try {
<span class="nc" id="L456">            final JMXConnectorServerData data = exportMBeanServer(</span>
                    mbs, port, rmiPort, useSsl, useRegistrySsl,
                    sslConfigFileName, enabledCipherSuitesList,
                    enabledProtocolsList, sslNeedClientAuth,
                    useAuthentication, loginConfigName,
                    passwordFileName, accessFileName);
<span class="nc" id="L462">            cs = data.jmxConnectorServer;</span>
<span class="nc" id="L463">            url = data.jmxRemoteURL;</span>
<span class="nc" id="L464">            log.config(&quot;startRemoteConnectorServer&quot;,</span>
<span class="nc" id="L465">                    Agent.getText(&quot;jmxremote.ConnectorBootstrap.ready&quot;,</span>
<span class="nc" id="L466">                    url.toString()));</span>
<span class="nc" id="L467">        } catch (Exception e) {</span>
<span class="nc" id="L468">            throw new AgentConfigurationError(AGENT_EXCEPTION, e, e.toString());</span>
<span class="nc" id="L469">        }</span>
        try {
            // Export remote connector address and associated configuration
            // properties to the instrumentation buffer.
<span class="nc" id="L473">            Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();</span>
<span class="nc" id="L474">            properties.put(&quot;remoteAddress&quot;, url.toString());</span>
<span class="nc" id="L475">            properties.put(&quot;authenticate&quot;, useAuthenticationStr);</span>
<span class="nc" id="L476">            properties.put(&quot;ssl&quot;, useSslStr);</span>
<span class="nc" id="L477">            properties.put(&quot;sslRegistry&quot;, useRegistrySslStr);</span>
<span class="nc" id="L478">            properties.put(&quot;sslNeedClientAuth&quot;, sslNeedClientAuthStr);</span>
<span class="nc" id="L479">            ConnectorAddressLink.exportRemote(properties);</span>
<span class="nc" id="L480">        } catch (Exception e) {</span>
            // Remote connector server started but unable to export remote
            // connector address and associated configuration properties to
            // the instrumentation buffer - non-fatal error.
<span class="nc" id="L484">            log.debug(&quot;startRemoteConnectorServer&quot;, e);</span>
<span class="nc" id="L485">        }</span>
<span class="nc" id="L486">        return cs;</span>
    }

    /*
     * Creates and starts a RMI Connector Server for &quot;local&quot; monitoring
     * and management.
     */
    public static JMXConnectorServer startLocalConnectorServer() {
        // Ensure cryptographically strong random number generater used
        // to choose the object number - see java.rmi.server.ObjID
<span class="nc" id="L496">        System.setProperty(&quot;java.rmi.server.randomIDs&quot;, &quot;true&quot;);</span>

        // This RMI server should not keep the VM alive
<span class="nc" id="L499">        Map&lt;String, Object&gt; env = new HashMap&lt;&gt;();</span>
<span class="nc" id="L500">        env.put(RMIExporter.EXPORTER_ATTRIBUTE, new PermanentExporter());</span>

        // The local connector server need only be available via the
        // loopback connection.
<span class="nc" id="L504">        String localhost = &quot;localhost&quot;;</span>
<span class="nc" id="L505">        InetAddress lh = null;</span>
        try {
<span class="nc" id="L507">            lh = InetAddress.getByName(localhost);</span>
<span class="nc" id="L508">            localhost = lh.getHostAddress();</span>
<span class="nc" id="L509">        } catch (UnknownHostException x) {</span>
<span class="nc" id="L510">        }</span>

        // localhost unknown or (somehow) didn't resolve to
        // a loopback address.
<span class="nc bnc" id="L514" title="All 4 branches missed.">        if (lh == null || !lh.isLoopbackAddress()) {</span>
<span class="nc" id="L515">            localhost = &quot;127.0.0.1&quot;;</span>
        }

<span class="nc" id="L518">        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();</span>
        try {
<span class="nc" id="L520">            JMXServiceURL url = new JMXServiceURL(&quot;rmi&quot;, localhost, 0);</span>
            // Do we accept connections from local interfaces only?
<span class="nc" id="L522">            Properties props = Agent.getManagementProperties();</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">            if (props ==  null) {</span>
<span class="nc" id="L524">                props = new Properties();</span>
            }
<span class="nc" id="L526">            String useLocalOnlyStr = props.getProperty(</span>
                    PropertyNames.USE_LOCAL_ONLY, DefaultValues.USE_LOCAL_ONLY);
<span class="nc" id="L528">            boolean useLocalOnly = Boolean.valueOf(useLocalOnlyStr).booleanValue();</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">            if (useLocalOnly) {</span>
<span class="nc" id="L530">                env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,</span>
                        new LocalRMIServerSocketFactory());
            }
<span class="nc" id="L533">            JMXConnectorServer server =</span>
<span class="nc" id="L534">                    JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);</span>
<span class="nc" id="L535">            server.start();</span>
<span class="nc" id="L536">            return server;</span>
<span class="nc" id="L537">        } catch (Exception e) {</span>
<span class="nc" id="L538">            throw new AgentConfigurationError(AGENT_EXCEPTION, e, e.toString());</span>
        }
    }

    private static void checkPasswordFile(String passwordFileName) {
<span class="nc bnc" id="L543" title="All 4 branches missed.">        if (passwordFileName == null || passwordFileName.length() == 0) {</span>
<span class="nc" id="L544">            throw new AgentConfigurationError(PASSWORD_FILE_NOT_SET);</span>
        }
<span class="nc" id="L546">        File file = new File(passwordFileName);</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (!file.exists()) {</span>
<span class="nc" id="L548">            throw new AgentConfigurationError(PASSWORD_FILE_NOT_FOUND, passwordFileName);</span>
        }

<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (!file.canRead()) {</span>
<span class="nc" id="L552">            throw new AgentConfigurationError(PASSWORD_FILE_NOT_READABLE, passwordFileName);</span>
        }

<span class="nc" id="L555">        FileSystem fs = FileSystem.open();</span>
        try {
<span class="nc bnc" id="L557" title="All 2 branches missed.">            if (fs.supportsFileSecurity(file)) {</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">                if (!fs.isAccessUserOnly(file)) {</span>
<span class="nc" id="L559">                    final String msg = Agent.getText(&quot;jmxremote.ConnectorBootstrap.password.readonly&quot;,</span>
                            passwordFileName);
<span class="nc" id="L561">                    log.config(&quot;startRemoteConnectorServer&quot;, msg);</span>
<span class="nc" id="L562">                    throw new AgentConfigurationError(PASSWORD_FILE_ACCESS_NOT_RESTRICTED,</span>
                            passwordFileName);
                }
            }
<span class="nc" id="L566">        } catch (IOException e) {</span>
<span class="nc" id="L567">            throw new AgentConfigurationError(PASSWORD_FILE_READ_FAILED,</span>
                    e, passwordFileName);
<span class="nc" id="L569">        }</span>
<span class="nc" id="L570">    }</span>

    private static void checkAccessFile(String accessFileName) {
<span class="nc bnc" id="L573" title="All 4 branches missed.">        if (accessFileName == null || accessFileName.length() == 0) {</span>
<span class="nc" id="L574">            throw new AgentConfigurationError(ACCESS_FILE_NOT_SET);</span>
        }
<span class="nc" id="L576">        File file = new File(accessFileName);</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (!file.exists()) {</span>
<span class="nc" id="L578">            throw new AgentConfigurationError(ACCESS_FILE_NOT_FOUND, accessFileName);</span>
        }

<span class="nc bnc" id="L581" title="All 2 branches missed.">        if (!file.canRead()) {</span>
<span class="nc" id="L582">            throw new AgentConfigurationError(ACCESS_FILE_NOT_READABLE, accessFileName);</span>
        }
<span class="nc" id="L584">    }</span>

    private static void checkRestrictedFile(String restrictedFileName) {
<span class="nc bnc" id="L587" title="All 4 branches missed.">        if (restrictedFileName == null || restrictedFileName.length() == 0) {</span>
<span class="nc" id="L588">            throw new AgentConfigurationError(FILE_NOT_SET);</span>
        }
<span class="nc" id="L590">        File file = new File(restrictedFileName);</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">        if (!file.exists()) {</span>
<span class="nc" id="L592">            throw new AgentConfigurationError(FILE_NOT_FOUND, restrictedFileName);</span>
        }
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (!file.canRead()) {</span>
<span class="nc" id="L595">            throw new AgentConfigurationError(FILE_NOT_READABLE, restrictedFileName);</span>
        }
<span class="nc" id="L597">        FileSystem fs = FileSystem.open();</span>
        try {
<span class="nc bnc" id="L599" title="All 2 branches missed.">            if (fs.supportsFileSecurity(file)) {</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                if (!fs.isAccessUserOnly(file)) {</span>
<span class="nc" id="L601">                    final String msg = Agent.getText(</span>
                            &quot;jmxremote.ConnectorBootstrap.file.readonly&quot;,
                            restrictedFileName);
<span class="nc" id="L604">                    log.config(&quot;startRemoteConnectorServer&quot;, msg);</span>
<span class="nc" id="L605">                    throw new AgentConfigurationError(</span>
                            FILE_ACCESS_NOT_RESTRICTED, restrictedFileName);
                }
            }
<span class="nc" id="L609">        } catch (IOException e) {</span>
<span class="nc" id="L610">            throw new AgentConfigurationError(</span>
                    FILE_READ_FAILED, e, restrictedFileName);
<span class="nc" id="L612">        }</span>
<span class="nc" id="L613">    }</span>

    /**
     * Compute the full path name for a default file.
     * @param basename basename (with extension) of the default file.
     * @return ${JRE}/lib/management/${basename}
     **/
    private static String getDefaultFileName(String basename) {
<span class="nc" id="L621">        final String fileSeparator = File.separator;</span>
<span class="nc" id="L622">        return System.getProperty(&quot;java.home&quot;) + fileSeparator + &quot;lib&quot; +</span>
                fileSeparator + &quot;management&quot; + fileSeparator +
                basename;
    }

    private static SslRMIServerSocketFactory createSslRMIServerSocketFactory(
            String sslConfigFileName,
            String[] enabledCipherSuites,
            String[] enabledProtocols,
            boolean sslNeedClientAuth) {
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (sslConfigFileName == null) {</span>
<span class="nc" id="L633">            return new SslRMIServerSocketFactory(</span>
                    enabledCipherSuites,
                    enabledProtocols,
                    sslNeedClientAuth);
        } else {
<span class="nc" id="L638">            checkRestrictedFile(sslConfigFileName);</span>
            try {
                // Load the SSL keystore properties from the config file
<span class="nc" id="L641">                Properties p = new Properties();</span>
<span class="nc" id="L642">                try (InputStream in = new FileInputStream(sslConfigFileName)) {</span>
<span class="nc" id="L643">                    BufferedInputStream bin = new BufferedInputStream(in);</span>
<span class="nc" id="L644">                    p.load(bin);</span>
<span class="nc bnc" id="L645" title="All 8 branches missed.">                }</span>
<span class="nc" id="L646">                String keyStore =</span>
<span class="nc" id="L647">                        p.getProperty(&quot;javax.net.ssl.keyStore&quot;);</span>
<span class="nc" id="L648">                String keyStorePassword =</span>
<span class="nc" id="L649">                        p.getProperty(&quot;javax.net.ssl.keyStorePassword&quot;, &quot;&quot;);</span>
<span class="nc" id="L650">                String trustStore =</span>
<span class="nc" id="L651">                        p.getProperty(&quot;javax.net.ssl.trustStore&quot;);</span>
<span class="nc" id="L652">                String trustStorePassword =</span>
<span class="nc" id="L653">                        p.getProperty(&quot;javax.net.ssl.trustStorePassword&quot;, &quot;&quot;);</span>

<span class="nc" id="L655">                char[] keyStorePasswd = null;</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                if (keyStorePassword.length() != 0) {</span>
<span class="nc" id="L657">                    keyStorePasswd = keyStorePassword.toCharArray();</span>
                }

<span class="nc" id="L660">                char[] trustStorePasswd = null;</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                if (trustStorePassword.length() != 0) {</span>
<span class="nc" id="L662">                    trustStorePasswd = trustStorePassword.toCharArray();</span>
                }

<span class="nc" id="L665">                KeyStore ks = null;</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                if (keyStore != null) {</span>
<span class="nc" id="L667">                    ks = KeyStore.getInstance(KeyStore.getDefaultType());</span>
<span class="nc" id="L668">                    try (FileInputStream ksfis = new FileInputStream(keyStore)) {</span>
<span class="nc" id="L669">                        ks.load(ksfis, keyStorePasswd);</span>
<span class="nc bnc" id="L670" title="All 8 branches missed.">                    }</span>
                }
<span class="nc" id="L672">                KeyManagerFactory kmf = KeyManagerFactory.getInstance(</span>
<span class="nc" id="L673">                        KeyManagerFactory.getDefaultAlgorithm());</span>
<span class="nc" id="L674">                kmf.init(ks, keyStorePasswd);</span>

<span class="nc" id="L676">                KeyStore ts = null;</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">                if (trustStore != null) {</span>
<span class="nc" id="L678">                    ts = KeyStore.getInstance(KeyStore.getDefaultType());</span>
<span class="nc" id="L679">                    try (FileInputStream tsfis = new FileInputStream(trustStore)) {</span>
<span class="nc" id="L680">                        ts.load(tsfis, trustStorePasswd);</span>
<span class="nc bnc" id="L681" title="All 8 branches missed.">                    }</span>
                }
<span class="nc" id="L683">                TrustManagerFactory tmf = TrustManagerFactory.getInstance(</span>
<span class="nc" id="L684">                        TrustManagerFactory.getDefaultAlgorithm());</span>
<span class="nc" id="L685">                tmf.init(ts);</span>

<span class="nc" id="L687">                SSLContext ctx = SSLContext.getInstance(&quot;SSL&quot;);</span>
<span class="nc" id="L688">                ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);</span>

<span class="nc" id="L690">                return new SslRMIServerSocketFactory(</span>
                        ctx,
                        enabledCipherSuites,
                        enabledProtocols,
                        sslNeedClientAuth);
<span class="nc" id="L695">            } catch (Exception e) {</span>
<span class="nc" id="L696">                throw new AgentConfigurationError(AGENT_EXCEPTION, e, e.toString());</span>
            }
        }
    }

    private static JMXConnectorServerData exportMBeanServer(
            MBeanServer mbs,
            int port,
            int rmiPort,
            boolean useSsl,
            boolean useRegistrySsl,
            String sslConfigFileName,
            String[] enabledCipherSuites,
            String[] enabledProtocols,
            boolean sslNeedClientAuth,
            boolean useAuthentication,
            String loginConfigName,
            String passwordFileName,
            String accessFileName)
            throws IOException, MalformedURLException {

        /* Make sure we use non-guessable RMI object IDs.  Otherwise
         * attackers could hijack open connections by guessing their
         * IDs.  */
<span class="nc" id="L720">        System.setProperty(&quot;java.rmi.server.randomIDs&quot;, &quot;true&quot;);</span>

<span class="nc" id="L722">        JMXServiceURL url = new JMXServiceURL(&quot;rmi&quot;, null, rmiPort);</span>

<span class="nc" id="L724">        Map&lt;String, Object&gt; env = new HashMap&lt;&gt;();</span>

<span class="nc" id="L726">        PermanentExporter exporter = new PermanentExporter();</span>

<span class="nc" id="L728">        env.put(RMIExporter.EXPORTER_ATTRIBUTE, exporter);</span>

<span class="nc bnc" id="L730" title="All 2 branches missed.">        if (useAuthentication) {</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">            if (loginConfigName != null) {</span>
<span class="nc" id="L732">                env.put(&quot;jmx.remote.x.login.config&quot;, loginConfigName);</span>
            }
<span class="nc bnc" id="L734" title="All 2 branches missed.">            if (passwordFileName != null) {</span>
<span class="nc" id="L735">                env.put(&quot;jmx.remote.x.password.file&quot;, passwordFileName);</span>
            }

<span class="nc" id="L738">            env.put(&quot;jmx.remote.x.access.file&quot;, accessFileName);</span>

<span class="nc bnc" id="L740" title="All 2 branches missed.">            if (env.get(&quot;jmx.remote.x.password.file&quot;) != null ||</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">                    env.get(&quot;jmx.remote.x.login.config&quot;) != null) {</span>
<span class="nc" id="L742">                env.put(JMXConnectorServer.AUTHENTICATOR,</span>
                        new AccessFileCheckerAuthenticator(env));
            }
        }

<span class="nc" id="L747">        RMIClientSocketFactory csf = null;</span>
<span class="nc" id="L748">        RMIServerSocketFactory ssf = null;</span>

<span class="nc bnc" id="L750" title="All 4 branches missed.">        if (useSsl || useRegistrySsl) {</span>
<span class="nc" id="L751">            csf = new SslRMIClientSocketFactory();</span>
<span class="nc" id="L752">            ssf = createSslRMIServerSocketFactory(</span>
                    sslConfigFileName, enabledCipherSuites,
                    enabledProtocols, sslNeedClientAuth);
        }

<span class="nc bnc" id="L757" title="All 2 branches missed.">        if (useSsl) {</span>
<span class="nc" id="L758">            env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE,</span>
                    csf);
<span class="nc" id="L760">            env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,</span>
                    ssf);
        }

<span class="nc" id="L764">        JMXConnectorServer connServer = null;</span>
        try {
<span class="nc" id="L766">            connServer =</span>
<span class="nc" id="L767">                    JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);</span>
<span class="nc" id="L768">            connServer.start();</span>
<span class="nc" id="L769">        } catch (IOException e) {</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">            if (connServer == null) {</span>
<span class="nc" id="L771">                throw new AgentConfigurationError(CONNECTOR_SERVER_IO_ERROR,</span>
<span class="nc" id="L772">                        e, url.toString());</span>
            } else {
<span class="nc" id="L774">                throw new AgentConfigurationError(CONNECTOR_SERVER_IO_ERROR,</span>
<span class="nc" id="L775">                        e, connServer.getAddress().toString());</span>
            }
<span class="nc" id="L777">        }</span>

<span class="nc bnc" id="L779" title="All 2 branches missed.">        if (useRegistrySsl) {</span>
<span class="nc" id="L780">            registry =</span>
                    new SingleEntryRegistry(port, csf, ssf,
                    &quot;jmxrmi&quot;, exporter.firstExported);
        } else {
<span class="nc" id="L784">            registry =</span>
                    new SingleEntryRegistry(port,
                    &quot;jmxrmi&quot;, exporter.firstExported);
        }


<span class="nc" id="L790">        int registryPort =</span>
<span class="nc" id="L791">            ((UnicastRef) ((RemoteObject) registry).getRef()).getLiveRef().getPort();</span>
<span class="nc" id="L792">        String jmxUrlStr =  String.format(&quot;service:jmx:rmi:///jndi/rmi://%s:%d/jmxrmi&quot;,</span>
<span class="nc" id="L793">                                           url.getHost(), registryPort);</span>
<span class="nc" id="L794">        JMXServiceURL remoteURL = new JMXServiceURL(jmxUrlStr);</span>

        /* Our exporter remembers the first object it was asked to
        export, which will be an RMIServerImpl appropriate for
        publication in our special registry.  We could
        alternatively have constructed the RMIServerImpl explicitly
        and then constructed an RMIConnectorServer passing it as a
        parameter, but that's quite a bit more verbose and pulls in
        lots of knowledge of the RMI connector.  */

<span class="nc" id="L804">        return new JMXConnectorServerData(connServer, remoteURL);</span>
    }

    /**
     * This class cannot be instantiated.
     **/
<span class="nc" id="L810">    private ConnectorBootstrap() {</span>
<span class="nc" id="L811">    }</span>

<span class="nc" id="L813">    private static final ClassLogger log =</span>
<span class="nc" id="L814">        new ClassLogger(ConnectorBootstrap.class.getPackage().getName(),</span>
                        &quot;ConnectorBootstrap&quot;);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>