<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GridBagLayout.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">GridBagLayout.java</span></div><h1>GridBagLayout.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt;

import java.util.Hashtable;
import java.util.Arrays;

/**
 * The &lt;code&gt;GridBagLayout&lt;/code&gt; class is a flexible layout
 * manager that aligns components vertically, horizontally or along their
 * baseline without requiring that the components be of the same size.
 * Each &lt;code&gt;GridBagLayout&lt;/code&gt; object maintains a dynamic,
 * rectangular grid of cells, with each component occupying
 * one or more cells, called its &lt;em&gt;display area&lt;/em&gt;.
 * &lt;p&gt;
 * Each component managed by a &lt;code&gt;GridBagLayout&lt;/code&gt; is associated with
 * an instance of {@link GridBagConstraints}.  The constraints object
 * specifies where a component's display area should be located on the grid
 * and how the component should be positioned within its display area.  In
 * addition to its constraints object, the &lt;code&gt;GridBagLayout&lt;/code&gt; also
 * considers each component's minimum and preferred sizes in order to
 * determine a component's size.
 * &lt;p&gt;
 * The overall orientation of the grid depends on the container's
 * {@link ComponentOrientation} property.  For horizontal left-to-right
 * orientations, grid coordinate (0,0) is in the upper left corner of the
 * container with x increasing to the right and y increasing downward.  For
 * horizontal right-to-left orientations, grid coordinate (0,0) is in the upper
 * right corner of the container with x increasing to the left and y
 * increasing downward.
 * &lt;p&gt;
 * To use a grid bag layout effectively, you must customize one or more
 * of the &lt;code&gt;GridBagConstraints&lt;/code&gt; objects that are associated
 * with its components. You customize a &lt;code&gt;GridBagConstraints&lt;/code&gt;
 * object by setting one or more of its instance variables:
 * &lt;p&gt;
 * &lt;dl&gt;
 * &lt;dt&gt;{@link GridBagConstraints#gridx},
 * {@link GridBagConstraints#gridy}
 * &lt;dd&gt;Specifies the cell containing the leading corner of the component's
 * display area, where the cell at the origin of the grid has address
 * &lt;code&gt;gridx&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;,
 * &lt;code&gt;gridy&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;.  For horizontal left-to-right layout,
 * a component's leading corner is its upper left.  For horizontal
 * right-to-left layout, a component's leading corner is its upper right.
 * Use &lt;code&gt;GridBagConstraints.RELATIVE&lt;/code&gt; (the default value)
 * to specify that the component be placed immediately following
 * (along the x axis for &lt;code&gt;gridx&lt;/code&gt; or the y axis for
 * &lt;code&gt;gridy&lt;/code&gt;) the component that was added to the container
 * just before this component was added.
 * &lt;dt&gt;{@link GridBagConstraints#gridwidth},
 * {@link GridBagConstraints#gridheight}
 * &lt;dd&gt;Specifies the number of cells in a row (for &lt;code&gt;gridwidth&lt;/code&gt;)
 * or column (for &lt;code&gt;gridheight&lt;/code&gt;)
 * in the component's display area.
 * The default value is 1.
 * Use &lt;code&gt;GridBagConstraints.REMAINDER&lt;/code&gt; to specify
 * that the component's display area will be from &lt;code&gt;gridx&lt;/code&gt;
 * to the last cell in the row (for &lt;code&gt;gridwidth&lt;/code&gt;)
 * or from &lt;code&gt;gridy&lt;/code&gt; to the last cell in the column
 * (for &lt;code&gt;gridheight&lt;/code&gt;).
 *
 * Use &lt;code&gt;GridBagConstraints.RELATIVE&lt;/code&gt; to specify
 * that the component's display area will be from &lt;code&gt;gridx&lt;/code&gt;
 * to the next to the last cell in its row (for &lt;code&gt;gridwidth&lt;/code&gt;
 * or from &lt;code&gt;gridy&lt;/code&gt; to the next to the last cell in its
 * column (for &lt;code&gt;gridheight&lt;/code&gt;).
 *
 * &lt;dt&gt;{@link GridBagConstraints#fill}
 * &lt;dd&gt;Used when the component's display area
 * is larger than the component's requested size
 * to determine whether (and how) to resize the component.
 * Possible values are
 * &lt;code&gt;GridBagConstraints.NONE&lt;/code&gt; (the default),
 * &lt;code&gt;GridBagConstraints.HORIZONTAL&lt;/code&gt;
 * (make the component wide enough to fill its display area
 * horizontally, but don't change its height),
 * &lt;code&gt;GridBagConstraints.VERTICAL&lt;/code&gt;
 * (make the component tall enough to fill its display area
 * vertically, but don't change its width), and
 * &lt;code&gt;GridBagConstraints.BOTH&lt;/code&gt;
 * (make the component fill its display area entirely).
 * &lt;dt&gt;{@link GridBagConstraints#ipadx},
 * {@link GridBagConstraints#ipady}
 * &lt;dd&gt;Specifies the component's internal padding within the layout,
 * how much to add to the minimum size of the component.
 * The width of the component will be at least its minimum width
 * plus &lt;code&gt;ipadx&lt;/code&gt; pixels. Similarly, the height of
 * the component will be at least the minimum height plus
 * &lt;code&gt;ipady&lt;/code&gt; pixels.
 * &lt;dt&gt;{@link GridBagConstraints#insets}
 * &lt;dd&gt;Specifies the component's external padding, the minimum
 * amount of space between the component and the edges of its display area.
 * &lt;dt&gt;{@link GridBagConstraints#anchor}
 * &lt;dd&gt;Specifies where the component should be positioned in its display area.
 * There are three kinds of possible values: absolute, orientation-relative,
 * and baseline-relative
 * Orientation relative values are interpreted relative to the container's
 * &lt;code&gt;ComponentOrientation&lt;/code&gt; property while absolute values
 * are not.  Baseline relative values are calculated relative to the
 * baseline.  Valid values are:
 * &lt;p&gt;
 * &lt;center&gt;&lt;table BORDER=0 WIDTH=800
 *        SUMMARY=&quot;absolute, relative and baseline values as described above&quot;&gt;
 * &lt;tr&gt;
 * &lt;th&gt;&lt;P style=&quot;text-align:left&quot;&gt;Absolute Values&lt;/th&gt;
 * &lt;th&gt;&lt;P style=&quot;text-align:left&quot;&gt;Orientation Relative Values&lt;/th&gt;
 * &lt;th&gt;&lt;P style=&quot;text-align:left&quot;&gt;Baseline Relative Values&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;
 * &lt;ul style=&quot;list-style-type:none&quot;&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.NORTH&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.SOUTH&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.WEST&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.EAST&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.NORTHWEST&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.NORTHEAST&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.SOUTHWEST&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.SOUTHEAST&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.CENTER&lt;/code&gt; (the default)&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/td&gt;
 * &lt;td&gt;
 * &lt;ul style=&quot;list-style-type:none&quot;&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.PAGE_START&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.PAGE_END&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.LINE_START&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.LINE_END&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.FIRST_LINE_START&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.FIRST_LINE_END&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.LAST_LINE_START&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.LAST_LINE_END&lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/td&gt;
 * &lt;td&gt;
 * &lt;ul style=&quot;list-style-type:none&quot;&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.BASELINE&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.BASELINE_LEADING&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.BASELINE_TRAILING&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.ABOVE_BASELINE&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.ABOVE_BASELINE_LEADING&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.ABOVE_BASELINE_TRAILING&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.BELOW_BASELINE&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.BELOW_BASELINE_LEADING&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;GridBagConstraints.BELOW_BASELINE_TRAILING&lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;&lt;/center&gt;
 * &lt;dt&gt;{@link GridBagConstraints#weightx},
 * {@link GridBagConstraints#weighty}
 * &lt;dd&gt;Used to determine how to distribute space, which is
 * important for specifying resizing behavior.
 * Unless you specify a weight for at least one component
 * in a row (&lt;code&gt;weightx&lt;/code&gt;) and column (&lt;code&gt;weighty&lt;/code&gt;),
 * all the components clump together in the center of their container.
 * This is because when the weight is zero (the default),
 * the &lt;code&gt;GridBagLayout&lt;/code&gt; object puts any extra space
 * between its grid of cells and the edges of the container.
 * &lt;/dl&gt;
 * &lt;p&gt;
 * Each row may have a baseline; the baseline is determined by the
 * components in that row that have a valid baseline and are aligned
 * along the baseline (the component's anchor value is one of {@code
 * BASELINE}, {@code BASELINE_LEADING} or {@code BASELINE_TRAILING}).
 * If none of the components in the row has a valid baseline, the row
 * does not have a baseline.
 * &lt;p&gt;
 * If a component spans rows it is aligned either to the baseline of
 * the start row (if the baseline-resize behavior is {@code
 * CONSTANT_ASCENT}) or the end row (if the baseline-resize behavior
 * is {@code CONSTANT_DESCENT}).  The row that the component is
 * aligned to is called the &lt;em&gt;prevailing row&lt;/em&gt;.
 * &lt;p&gt;
 * The following figure shows a baseline layout and includes a
 * component that spans rows:
 * &lt;center&gt;&lt;table summary=&quot;Baseline Layout&quot;&gt;
 * &lt;tr ALIGN=CENTER&gt;
 * &lt;td&gt;
 * &lt;img src=&quot;doc-files/GridBagLayout-baseline.png&quot;
 *  alt=&quot;The following text describes this graphic (Figure 1).&quot; style=&quot;float:center&quot;&gt;
 * &lt;/td&gt;
 * &lt;/table&gt;&lt;/center&gt;
 * This layout consists of three components:
 * &lt;ul&gt;&lt;li&gt;A panel that starts in row 0 and ends in row 1.  The panel
 *   has a baseline-resize behavior of &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt; and has
 *   an anchor of &lt;code&gt;BASELINE&lt;/code&gt;.  As the baseline-resize behavior
 *   is &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt; the prevailing row for the panel is
 *   row 1.
 * &lt;li&gt;Two buttons, each with a baseline-resize behavior of
 *   &lt;code&gt;CENTER_OFFSET&lt;/code&gt; and an anchor of &lt;code&gt;BASELINE&lt;/code&gt;.
 * &lt;/ul&gt;
 * Because the second button and the panel share the same prevailing row,
 * they are both aligned along their baseline.
 * &lt;p&gt;
 * Components positioned using one of the baseline-relative values resize
 * differently than when positioned using an absolute or orientation-relative
 * value.  How components change is dictated by how the baseline of the
 * prevailing row changes.  The baseline is anchored to the
 * bottom of the display area if any components with the same prevailing row
 * have a baseline-resize behavior of &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt;,
 * otherwise the baseline is anchored to the top of the display area.
 * The following rules dictate the resize behavior:
 * &lt;ul&gt;
 * &lt;li&gt;Resizable components positioned above the baseline can only
 * grow as tall as the baseline.  For example, if the baseline is at 100
 * and anchored at the top, a resizable component positioned above the
 * baseline can never grow more than 100 units.
 * &lt;li&gt;Similarly, resizable components positioned below the baseline can
 * only grow as high as the difference between the display height and the
 * baseline.
 * &lt;li&gt;Resizable components positioned on the baseline with a
 * baseline-resize behavior of &lt;code&gt;OTHER&lt;/code&gt; are only resized if
 * the baseline at the resized size fits within the display area.  If
 * the baseline is such that it does not fit within the display area
 * the component is not resized.
 * &lt;li&gt;Components positioned on the baseline that do not have a
 * baseline-resize behavior of &lt;code&gt;OTHER&lt;/code&gt;
 * can only grow as tall as {@code display height - baseline + baseline of component}.
 * &lt;/ul&gt;
 * If you position a component along the baseline, but the
 * component does not have a valid baseline, it will be vertically centered
 * in its space.  Similarly if you have positioned a component relative
 * to the baseline and none of the components in the row have a valid
 * baseline the component is vertically centered.
 * &lt;p&gt;
 * The following figures show ten components (all buttons)
 * managed by a grid bag layout.  Figure 2 shows the layout for a horizontal,
 * left-to-right container and Figure 3 shows the layout for a horizontal,
 * right-to-left container.
 * &lt;p&gt;
 * &lt;center&gt;&lt;table WIDTH=600 summary=&quot;layout&quot;&gt;
 * &lt;tr ALIGN=CENTER&gt;
 * &lt;td&gt;
 * &lt;img src=&quot;doc-files/GridBagLayout-1.gif&quot; alt=&quot;The preceding text describes this graphic (Figure 1).&quot; style=&quot;float:center; margin: 7px 10px;&quot;&gt;
 * &lt;/td&gt;
 * &lt;td&gt;
 * &lt;img src=&quot;doc-files/GridBagLayout-2.gif&quot; alt=&quot;The preceding text describes this graphic (Figure 2).&quot; style=&quot;float:center; margin: 7px 10px;&quot;&gt;
 * &lt;/td&gt;
 * &lt;tr ALIGN=CENTER&gt;
 * &lt;td&gt;Figure 2: Horizontal, Left-to-Right&lt;/td&gt;
 * &lt;td&gt;Figure 3: Horizontal, Right-to-Left&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;&lt;/center&gt;
 * &lt;p&gt;
 * Each of the ten components has the &lt;code&gt;fill&lt;/code&gt; field
 * of its associated &lt;code&gt;GridBagConstraints&lt;/code&gt; object
 * set to &lt;code&gt;GridBagConstraints.BOTH&lt;/code&gt;.
 * In addition, the components have the following non-default constraints:
 * &lt;p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Button1, Button2, Button3: &lt;code&gt;weightx&amp;nbsp;=&amp;nbsp;1.0&lt;/code&gt;
 * &lt;li&gt;Button4: &lt;code&gt;weightx&amp;nbsp;=&amp;nbsp;1.0&lt;/code&gt;,
 * &lt;code&gt;gridwidth&amp;nbsp;=&amp;nbsp;GridBagConstraints.REMAINDER&lt;/code&gt;
 * &lt;li&gt;Button5: &lt;code&gt;gridwidth&amp;nbsp;=&amp;nbsp;GridBagConstraints.REMAINDER&lt;/code&gt;
 * &lt;li&gt;Button6: &lt;code&gt;gridwidth&amp;nbsp;=&amp;nbsp;GridBagConstraints.RELATIVE&lt;/code&gt;
 * &lt;li&gt;Button7: &lt;code&gt;gridwidth&amp;nbsp;=&amp;nbsp;GridBagConstraints.REMAINDER&lt;/code&gt;
 * &lt;li&gt;Button8: &lt;code&gt;gridheight&amp;nbsp;=&amp;nbsp;2&lt;/code&gt;,
 * &lt;code&gt;weighty&amp;nbsp;=&amp;nbsp;1.0&lt;/code&gt;
 * &lt;li&gt;Button9, Button 10:
 * &lt;code&gt;gridwidth&amp;nbsp;=&amp;nbsp;GridBagConstraints.REMAINDER&lt;/code&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Here is the code that implements the example shown above:
 * &lt;p&gt;
 * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
 * import java.awt.*;
 * import java.util.*;
 * import java.applet.Applet;
 *
 * public class GridBagEx1 extends Applet {
 *
 *     protected void makebutton(String name,
 *                               GridBagLayout gridbag,
 *                               GridBagConstraints c) {
 *         Button button = new Button(name);
 *         gridbag.setConstraints(button, c);
 *         add(button);
 *     }
 *
 *     public void init() {
 *         GridBagLayout gridbag = new GridBagLayout();
 *         GridBagConstraints c = new GridBagConstraints();
 *
 *         setFont(new Font(&quot;SansSerif&quot;, Font.PLAIN, 14));
 *         setLayout(gridbag);
 *
 *         c.fill = GridBagConstraints.BOTH;
 *         c.weightx = 1.0;
 *         makebutton(&quot;Button1&quot;, gridbag, c);
 *         makebutton(&quot;Button2&quot;, gridbag, c);
 *         makebutton(&quot;Button3&quot;, gridbag, c);
 *
 *         c.gridwidth = GridBagConstraints.REMAINDER; //end row
 *         makebutton(&quot;Button4&quot;, gridbag, c);
 *
 *         c.weightx = 0.0;                //reset to the default
 *         makebutton(&quot;Button5&quot;, gridbag, c); //another row
 *
 *         c.gridwidth = GridBagConstraints.RELATIVE; //next-to-last in row
 *         makebutton(&quot;Button6&quot;, gridbag, c);
 *
 *         c.gridwidth = GridBagConstraints.REMAINDER; //end row
 *         makebutton(&quot;Button7&quot;, gridbag, c);
 *
 *         c.gridwidth = 1;                //reset to the default
 *         c.gridheight = 2;
 *         c.weighty = 1.0;
 *         makebutton(&quot;Button8&quot;, gridbag, c);
 *
 *         c.weighty = 0.0;                //reset to the default
 *         c.gridwidth = GridBagConstraints.REMAINDER; //end row
 *         c.gridheight = 1;               //reset to the default
 *         makebutton(&quot;Button9&quot;, gridbag, c);
 *         makebutton(&quot;Button10&quot;, gridbag, c);
 *
 *         setSize(300, 100);
 *     }
 *
 *     public static void main(String args[]) {
 *         Frame f = new Frame(&quot;GridBag Layout Example&quot;);
 *         GridBagEx1 ex1 = new GridBagEx1();
 *
 *         ex1.init();
 *
 *         f.add(&quot;Center&quot;, ex1);
 *         f.pack();
 *         f.setSize(f.getPreferredSize());
 *         f.show();
 *     }
 * }
 * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
 * &lt;p&gt;
 * @author Doug Stein
 * @author Bill Spitzak (orignial NeWS &amp;amp; OLIT implementation)
 * @see       java.awt.GridBagConstraints
 * @see       java.awt.GridBagLayoutInfo
 * @see       java.awt.ComponentOrientation
 * @since JDK1.0
 */
public class GridBagLayout implements LayoutManager2,
java.io.Serializable {

    static final int EMPIRICMULTIPLIER = 2;
    /**
     * This field is no longer used to reserve arrays and kept for backward
     * compatibility. Previously, this was
     * the maximum number of grid positions (both horizontal and
     * vertical) that could be laid out by the grid bag layout.
     * Current implementation doesn't impose any limits
     * on the size of a grid.
     */
    protected static final int MAXGRIDSIZE = 512;

    /**
     * The smallest grid that can be laid out by the grid bag layout.
     */
    protected static final int MINSIZE = 1;
    /**
     * The preferred grid size that can be laid out by the grid bag layout.
     */
    protected static final int PREFERREDSIZE = 2;

    /**
     * This hashtable maintains the association between
     * a component and its gridbag constraints.
     * The Keys in &lt;code&gt;comptable&lt;/code&gt; are the components and the
     * values are the instances of &lt;code&gt;GridBagConstraints&lt;/code&gt;.
     *
     * @serial
     * @see java.awt.GridBagConstraints
     */
    protected Hashtable&lt;Component,GridBagConstraints&gt; comptable;

    /**
     * This field holds a gridbag constraints instance
     * containing the default values, so if a component
     * does not have gridbag constraints associated with
     * it, then the component will be assigned a
     * copy of the &lt;code&gt;defaultConstraints&lt;/code&gt;.
     *
     * @serial
     * @see #getConstraints(Component)
     * @see #setConstraints(Component, GridBagConstraints)
     * @see #lookupConstraints(Component)
     */
    protected GridBagConstraints defaultConstraints;

    /**
     * This field holds the layout information
     * for the gridbag.  The information in this field
     * is based on the most recent validation of the
     * gridbag.
     * If &lt;code&gt;layoutInfo&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * this indicates that there are no components in
     * the gridbag or if there are components, they have
     * not yet been validated.
     *
     * @serial
     * @see #getLayoutInfo(Container, int)
     */
    protected GridBagLayoutInfo layoutInfo;

    /**
     * This field holds the overrides to the column minimum
     * width.  If this field is non-&lt;code&gt;null&lt;/code&gt; the values are
     * applied to the gridbag after all of the minimum columns
     * widths have been calculated.
     * If columnWidths has more elements than the number of
     * columns, columns are added to the gridbag to match
     * the number of elements in columnWidth.
     *
     * @serial
     * @see #getLayoutDimensions()
     */
    public int columnWidths[];

    /**
     * This field holds the overrides to the row minimum
     * heights.  If this field is non-&lt;code&gt;null&lt;/code&gt; the values are
     * applied to the gridbag after all of the minimum row
     * heights have been calculated.
     * If &lt;code&gt;rowHeights&lt;/code&gt; has more elements than the number of
     * rows, rows are added to the gridbag to match
     * the number of elements in &lt;code&gt;rowHeights&lt;/code&gt;.
     *
     * @serial
     * @see #getLayoutDimensions()
     */
    public int rowHeights[];

    /**
     * This field holds the overrides to the column weights.
     * If this field is non-&lt;code&gt;null&lt;/code&gt; the values are
     * applied to the gridbag after all of the columns
     * weights have been calculated.
     * If &lt;code&gt;columnWeights[i]&lt;/code&gt; &amp;gt; weight for column i, then
     * column i is assigned the weight in &lt;code&gt;columnWeights[i]&lt;/code&gt;.
     * If &lt;code&gt;columnWeights&lt;/code&gt; has more elements than the number
     * of columns, the excess elements are ignored - they do
     * not cause more columns to be created.
     *
     * @serial
     */
    public double columnWeights[];

    /**
     * This field holds the overrides to the row weights.
     * If this field is non-&lt;code&gt;null&lt;/code&gt; the values are
     * applied to the gridbag after all of the rows
     * weights have been calculated.
     * If &lt;code&gt;rowWeights[i]&lt;/code&gt; &amp;gt; weight for row i, then
     * row i is assigned the weight in &lt;code&gt;rowWeights[i]&lt;/code&gt;.
     * If &lt;code&gt;rowWeights&lt;/code&gt; has more elements than the number
     * of rows, the excess elements are ignored - they do
     * not cause more rows to be created.
     *
     * @serial
     */
    public double rowWeights[];

    /**
     * The component being positioned.  This is set before calling into
     * &lt;code&gt;adjustForGravity&lt;/code&gt;.
     */
    private Component componentAdjusting;

    /**
     * Creates a grid bag layout manager.
     */
<span class="nc" id="L494">    public GridBagLayout () {</span>
<span class="nc" id="L495">        comptable = new Hashtable&lt;Component,GridBagConstraints&gt;();</span>
<span class="nc" id="L496">        defaultConstraints = new GridBagConstraints();</span>
<span class="nc" id="L497">    }</span>

    /**
     * Sets the constraints for the specified component in this layout.
     * @param       comp the component to be modified
     * @param       constraints the constraints to be applied
     */
    public void setConstraints(Component comp, GridBagConstraints constraints) {
<span class="nc" id="L505">        comptable.put(comp, (GridBagConstraints)constraints.clone());</span>
<span class="nc" id="L506">    }</span>

    /**
     * Gets the constraints for the specified component.  A copy of
     * the actual &lt;code&gt;GridBagConstraints&lt;/code&gt; object is returned.
     * @param       comp the component to be queried
     * @return      the constraint for the specified component in this
     *                  grid bag layout; a copy of the actual constraint
     *                  object is returned
     */
    public GridBagConstraints getConstraints(Component comp) {
<span class="nc" id="L517">        GridBagConstraints constraints = comptable.get(comp);</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">        if (constraints == null) {</span>
<span class="nc" id="L519">            setConstraints(comp, defaultConstraints);</span>
<span class="nc" id="L520">            constraints = comptable.get(comp);</span>
        }
<span class="nc" id="L522">        return (GridBagConstraints)constraints.clone();</span>
    }

    /**
     * Retrieves the constraints for the specified component.
     * The return value is not a copy, but is the actual
     * &lt;code&gt;GridBagConstraints&lt;/code&gt; object used by the layout mechanism.
     * &lt;p&gt;
     * If &lt;code&gt;comp&lt;/code&gt; is not in the &lt;code&gt;GridBagLayout&lt;/code&gt;,
     * a set of default &lt;code&gt;GridBagConstraints&lt;/code&gt; are returned.
     * A &lt;code&gt;comp&lt;/code&gt; value of &lt;code&gt;null&lt;/code&gt; is invalid
     * and returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @param       comp the component to be queried
     * @return      the constraints for the specified component
     */
    protected GridBagConstraints lookupConstraints(Component comp) {
<span class="nc" id="L539">        GridBagConstraints constraints = comptable.get(comp);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (constraints == null) {</span>
<span class="nc" id="L541">            setConstraints(comp, defaultConstraints);</span>
<span class="nc" id="L542">            constraints = comptable.get(comp);</span>
        }
<span class="nc" id="L544">        return constraints;</span>
    }

    /**
     * Removes the constraints for the specified component in this layout
     * @param       comp the component to be modified
     */
    private void removeConstraints(Component comp) {
<span class="nc" id="L552">        comptable.remove(comp);</span>
<span class="nc" id="L553">    }</span>

    /**
     * Determines the origin of the layout area, in the graphics coordinate
     * space of the target container.  This value represents the pixel
     * coordinates of the top-left corner of the layout area regardless of
     * the &lt;code&gt;ComponentOrientation&lt;/code&gt; value of the container.  This
     * is distinct from the grid origin given by the cell coordinates (0,0).
     * Most applications do not call this method directly.
     * @return     the graphics origin of the cell in the top-left
     *             corner of the layout grid
     * @see        java.awt.ComponentOrientation
     * @since      JDK1.1
     */
    public Point getLayoutOrigin () {
<span class="nc" id="L568">        Point origin = new Point(0,0);</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">        if (layoutInfo != null) {</span>
<span class="nc" id="L570">            origin.x = layoutInfo.startx;</span>
<span class="nc" id="L571">            origin.y = layoutInfo.starty;</span>
        }
<span class="nc" id="L573">        return origin;</span>
    }

    /**
     * Determines column widths and row heights for the layout grid.
     * &lt;p&gt;
     * Most applications do not call this method directly.
     * @return     an array of two arrays, containing the widths
     *                       of the layout columns and
     *                       the heights of the layout rows
     * @since      JDK1.1
     */
    public int [][] getLayoutDimensions () {
<span class="nc bnc" id="L586" title="All 2 branches missed.">        if (layoutInfo == null)</span>
<span class="nc" id="L587">            return new int[2][0];</span>

<span class="nc" id="L589">        int dim[][] = new int [2][];</span>
<span class="nc" id="L590">        dim[0] = new int[layoutInfo.width];</span>
<span class="nc" id="L591">        dim[1] = new int[layoutInfo.height];</span>

<span class="nc" id="L593">        System.arraycopy(layoutInfo.minWidth, 0, dim[0], 0, layoutInfo.width);</span>
<span class="nc" id="L594">        System.arraycopy(layoutInfo.minHeight, 0, dim[1], 0, layoutInfo.height);</span>

<span class="nc" id="L596">        return dim;</span>
    }

    /**
     * Determines the weights of the layout grid's columns and rows.
     * Weights are used to calculate how much a given column or row
     * stretches beyond its preferred size, if the layout has extra
     * room to fill.
     * &lt;p&gt;
     * Most applications do not call this method directly.
     * @return      an array of two arrays, representing the
     *                    horizontal weights of the layout columns
     *                    and the vertical weights of the layout rows
     * @since       JDK1.1
     */
    public double [][] getLayoutWeights () {
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (layoutInfo == null)</span>
<span class="nc" id="L613">            return new double[2][0];</span>

<span class="nc" id="L615">        double weights[][] = new double [2][];</span>
<span class="nc" id="L616">        weights[0] = new double[layoutInfo.width];</span>
<span class="nc" id="L617">        weights[1] = new double[layoutInfo.height];</span>

<span class="nc" id="L619">        System.arraycopy(layoutInfo.weightX, 0, weights[0], 0, layoutInfo.width);</span>
<span class="nc" id="L620">        System.arraycopy(layoutInfo.weightY, 0, weights[1], 0, layoutInfo.height);</span>

<span class="nc" id="L622">        return weights;</span>
    }

    /**
     * Determines which cell in the layout grid contains the point
     * specified by &lt;code&gt;(x,&amp;nbsp;y)&lt;/code&gt;. Each cell is identified
     * by its column index (ranging from 0 to the number of columns
     * minus 1) and its row index (ranging from 0 to the number of
     * rows minus 1).
     * &lt;p&gt;
     * If the &lt;code&gt;(x,&amp;nbsp;y)&lt;/code&gt; point lies
     * outside the grid, the following rules are used.
     * The column index is returned as zero if &lt;code&gt;x&lt;/code&gt; lies to the
     * left of the layout for a left-to-right container or to the right of
     * the layout for a right-to-left container.  The column index is returned
     * as the number of columns if &lt;code&gt;x&lt;/code&gt; lies
     * to the right of the layout in a left-to-right container or to the left
     * in a right-to-left container.
     * The row index is returned as zero if &lt;code&gt;y&lt;/code&gt; lies above the
     * layout, and as the number of rows if &lt;code&gt;y&lt;/code&gt; lies
     * below the layout.  The orientation of a container is determined by its
     * &lt;code&gt;ComponentOrientation&lt;/code&gt; property.
     * @param      x    the &lt;i&gt;x&lt;/i&gt; coordinate of a point
     * @param      y    the &lt;i&gt;y&lt;/i&gt; coordinate of a point
     * @return     an ordered pair of indexes that indicate which cell
     *             in the layout grid contains the point
     *             (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;).
     * @see        java.awt.ComponentOrientation
     * @since      JDK1.1
     */
    public Point location(int x, int y) {
<span class="nc" id="L653">        Point loc = new Point(0,0);</span>
        int i, d;

<span class="nc bnc" id="L656" title="All 2 branches missed.">        if (layoutInfo == null)</span>
<span class="nc" id="L657">            return loc;</span>

<span class="nc" id="L659">        d = layoutInfo.startx;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (!rightToLeft) {</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">            for (i=0; i&lt;layoutInfo.width; i++) {</span>
<span class="nc" id="L662">                d += layoutInfo.minWidth[i];</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">                if (d &gt; x)</span>
<span class="nc" id="L664">                    break;</span>
            }
        } else {
<span class="nc bnc" id="L667" title="All 2 branches missed.">            for (i=layoutInfo.width-1; i&gt;=0; i--) {</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">                if (d &gt; x)</span>
<span class="nc" id="L669">                    break;</span>
<span class="nc" id="L670">                d += layoutInfo.minWidth[i];</span>
            }
<span class="nc" id="L672">            i++;</span>
        }
<span class="nc" id="L674">        loc.x = i;</span>

<span class="nc" id="L676">        d = layoutInfo.starty;</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">        for (i=0; i&lt;layoutInfo.height; i++) {</span>
<span class="nc" id="L678">            d += layoutInfo.minHeight[i];</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">            if (d &gt; y)</span>
<span class="nc" id="L680">                break;</span>
        }
<span class="nc" id="L682">        loc.y = i;</span>

<span class="nc" id="L684">        return loc;</span>
    }

    /**
     * Has no effect, since this layout manager does not use a per-component string.
     */
    public void addLayoutComponent(String name, Component comp) {
<span class="nc" id="L691">    }</span>

    /**
     * Adds the specified component to the layout, using the specified
     * &lt;code&gt;constraints&lt;/code&gt; object.  Note that constraints
     * are mutable and are, therefore, cloned when cached.
     *
     * @param      comp         the component to be added
     * @param      constraints  an object that determines how
     *                          the component is added to the layout
     * @exception IllegalArgumentException if &lt;code&gt;constraints&lt;/code&gt;
     *            is not a &lt;code&gt;GridBagConstraint&lt;/code&gt;
     */
    public void addLayoutComponent(Component comp, Object constraints) {
<span class="nc bnc" id="L705" title="All 2 branches missed.">        if (constraints instanceof GridBagConstraints) {</span>
<span class="nc" id="L706">            setConstraints(comp, (GridBagConstraints)constraints);</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">        } else if (constraints != null) {</span>
<span class="nc" id="L708">            throw new IllegalArgumentException(&quot;cannot add to layout: constraints must be a GridBagConstraint&quot;);</span>
        }
<span class="nc" id="L710">    }</span>

    /**
     * Removes the specified component from this layout.
     * &lt;p&gt;
     * Most applications do not call this method directly.
     * @param    comp   the component to be removed.
     * @see      java.awt.Container#remove(java.awt.Component)
     * @see      java.awt.Container#removeAll()
     */
    public void removeLayoutComponent(Component comp) {
<span class="nc" id="L721">        removeConstraints(comp);</span>
<span class="nc" id="L722">    }</span>

    /**
     * Determines the preferred size of the &lt;code&gt;parent&lt;/code&gt;
     * container using this grid bag layout.
     * &lt;p&gt;
     * Most applications do not call this method directly.
     *
     * @param     parent   the container in which to do the layout
     * @see       java.awt.Container#getPreferredSize
     * @return the preferred size of the &lt;code&gt;parent&lt;/code&gt;
     *  container
     */
    public Dimension preferredLayoutSize(Container parent) {
<span class="nc" id="L736">        GridBagLayoutInfo info = getLayoutInfo(parent, PREFERREDSIZE);</span>
<span class="nc" id="L737">        return getMinSize(parent, info);</span>
    }

    /**
     * Determines the minimum size of the &lt;code&gt;parent&lt;/code&gt; container
     * using this grid bag layout.
     * &lt;p&gt;
     * Most applications do not call this method directly.
     * @param     parent   the container in which to do the layout
     * @see       java.awt.Container#doLayout
     * @return the minimum size of the &lt;code&gt;parent&lt;/code&gt; container
     */
    public Dimension minimumLayoutSize(Container parent) {
<span class="nc" id="L750">        GridBagLayoutInfo info = getLayoutInfo(parent, MINSIZE);</span>
<span class="nc" id="L751">        return getMinSize(parent, info);</span>
    }

    /**
     * Returns the maximum dimensions for this layout given the components
     * in the specified target container.
     * @param target the container which needs to be laid out
     * @see Container
     * @see #minimumLayoutSize(Container)
     * @see #preferredLayoutSize(Container)
     * @return the maximum dimensions for this layout
     */
    public Dimension maximumLayoutSize(Container target) {
<span class="nc" id="L764">        return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);</span>
    }

    /**
     * Returns the alignment along the x axis.  This specifies how
     * the component would like to be aligned relative to other
     * components.  The value should be a number between 0 and 1
     * where 0 represents alignment along the origin, 1 is aligned
     * the furthest away from the origin, 0.5 is centered, etc.
     * &lt;p&gt;
     * @return the value &lt;code&gt;0.5f&lt;/code&gt; to indicate centered
     */
    public float getLayoutAlignmentX(Container parent) {
<span class="nc" id="L777">        return 0.5f;</span>
    }

    /**
     * Returns the alignment along the y axis.  This specifies how
     * the component would like to be aligned relative to other
     * components.  The value should be a number between 0 and 1
     * where 0 represents alignment along the origin, 1 is aligned
     * the furthest away from the origin, 0.5 is centered, etc.
     * &lt;p&gt;
     * @return the value &lt;code&gt;0.5f&lt;/code&gt; to indicate centered
     */
    public float getLayoutAlignmentY(Container parent) {
<span class="nc" id="L790">        return 0.5f;</span>
    }

    /**
     * Invalidates the layout, indicating that if the layout manager
     * has cached information it should be discarded.
     */
    public void invalidateLayout(Container target) {
<span class="nc" id="L798">    }</span>

    /**
     * Lays out the specified container using this grid bag layout.
     * This method reshapes components in the specified container in
     * order to satisfy the constraints of this &lt;code&gt;GridBagLayout&lt;/code&gt;
     * object.
     * &lt;p&gt;
     * Most applications do not call this method directly.
     * @param parent the container in which to do the layout
     * @see java.awt.Container
     * @see java.awt.Container#doLayout
     */
    public void layoutContainer(Container parent) {
<span class="nc" id="L812">        arrangeGrid(parent);</span>
<span class="nc" id="L813">    }</span>

    /**
     * Returns a string representation of this grid bag layout's values.
     * @return     a string representation of this grid bag layout.
     */
    public String toString() {
<span class="nc" id="L820">        return getClass().getName();</span>
    }

    /**
     * Print the layout information.  Useful for debugging.
     */

    /* DEBUG
     *
     *  protected void dumpLayoutInfo(GridBagLayoutInfo s) {
     *    int x;
     *
     *    System.out.println(&quot;Col\tWidth\tWeight&quot;);
     *    for (x=0; x&lt;s.width; x++) {
     *      System.out.println(x + &quot;\t&quot; +
     *                   s.minWidth[x] + &quot;\t&quot; +
     *                   s.weightX[x]);
     *    }
     *    System.out.println(&quot;Row\tHeight\tWeight&quot;);
     *    for (x=0; x&lt;s.height; x++) {
     *      System.out.println(x + &quot;\t&quot; +
     *                   s.minHeight[x] + &quot;\t&quot; +
     *                   s.weightY[x]);
     *    }
     *  }
     */

    /**
     * Print the layout constraints.  Useful for debugging.
     */

    /* DEBUG
     *
     *  protected void dumpConstraints(GridBagConstraints constraints) {
     *    System.out.println(
     *                 &quot;wt &quot; +
     *                 constraints.weightx +
     *                 &quot; &quot; +
     *                 constraints.weighty +
     *                 &quot;, &quot; +
     *
     *                 &quot;box &quot; +
     *                 constraints.gridx +
     *                 &quot; &quot; +
     *                 constraints.gridy +
     *                 &quot; &quot; +
     *                 constraints.gridwidth +
     *                 &quot; &quot; +
     *                 constraints.gridheight +
     *                 &quot;, &quot; +
     *
     *                 &quot;min &quot; +
     *                 constraints.minWidth +
     *                 &quot; &quot; +
     *                 constraints.minHeight +
     *                 &quot;, &quot; +
     *
     *                 &quot;pad &quot; +
     *                 constraints.insets.bottom +
     *                 &quot; &quot; +
     *                 constraints.insets.left +
     *                 &quot; &quot; +
     *                 constraints.insets.right +
     *                 &quot; &quot; +
     *                 constraints.insets.top +
     *                 &quot; &quot; +
     *                 constraints.ipadx +
     *                 &quot; &quot; +
     *                 constraints.ipady);
     *  }
     */

    /**
     * Fills in an instance of &lt;code&gt;GridBagLayoutInfo&lt;/code&gt; for the
     * current set of managed children. This requires three passes through the
     * set of children:
     *
     * &lt;ol&gt;
     * &lt;li&gt;Figure out the dimensions of the layout grid.
     * &lt;li&gt;Determine which cells the components occupy.
     * &lt;li&gt;Distribute the weights and min sizes among the rows/columns.
     * &lt;/ol&gt;
     *
     * This also caches the minsizes for all the children when they are
     * first encountered (so subsequent loops don't need to ask again).
     * &lt;p&gt;
     * This method should only be used internally by
     * &lt;code&gt;GridBagLayout&lt;/code&gt;.
     *
     * @param parent  the layout container
     * @param sizeflag either &lt;code&gt;PREFERREDSIZE&lt;/code&gt; or
     *   &lt;code&gt;MINSIZE&lt;/code&gt;
     * @return the &lt;code&gt;GridBagLayoutInfo&lt;/code&gt; for the set of children
     * @since 1.4
     */
    protected GridBagLayoutInfo getLayoutInfo(Container parent, int sizeflag) {
<span class="nc" id="L916">        return GetLayoutInfo(parent, sizeflag);</span>
    }

    /*
     * Calculate maximum array sizes to allocate arrays without ensureCapacity
     * we may use preCalculated sizes in whole class because of upper estimation of
     * maximumArrayXIndex and maximumArrayYIndex.
     */

    private long[]  preInitMaximumArraySizes(Container parent){
<span class="nc" id="L926">        Component components[] = parent.getComponents();</span>
        Component comp;
        GridBagConstraints constraints;
        int curX, curY;
        int curWidth, curHeight;
<span class="nc" id="L931">        int preMaximumArrayXIndex = 0;</span>
<span class="nc" id="L932">        int preMaximumArrayYIndex = 0;</span>
<span class="nc" id="L933">        long [] returnArray = new long[2];</span>

<span class="nc bnc" id="L935" title="All 2 branches missed.">        for (int compId = 0 ; compId &lt; components.length ; compId++) {</span>
<span class="nc" id="L936">            comp = components[compId];</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">            if (!comp.isVisible()) {</span>
<span class="nc" id="L938">                continue;</span>
            }

<span class="nc" id="L941">            constraints = lookupConstraints(comp);</span>
<span class="nc" id="L942">            curX = constraints.gridx;</span>
<span class="nc" id="L943">            curY = constraints.gridy;</span>
<span class="nc" id="L944">            curWidth = constraints.gridwidth;</span>
<span class="nc" id="L945">            curHeight = constraints.gridheight;</span>

            // -1==RELATIVE, means that column|row equals to previously added component,
            // since each next Component with gridx|gridy == RELATIVE starts from
            // previous position, so we should start from previous component which
            // already used in maximumArray[X|Y]Index calculation. We could just increase
            // maximum by 1 to handle situation when component with gridx=-1 was added.
<span class="nc bnc" id="L952" title="All 2 branches missed.">            if (curX &lt; 0){</span>
<span class="nc" id="L953">                curX = ++preMaximumArrayYIndex;</span>
            }
<span class="nc bnc" id="L955" title="All 2 branches missed.">            if (curY &lt; 0){</span>
<span class="nc" id="L956">                curY = ++preMaximumArrayXIndex;</span>
            }
            // gridwidth|gridheight may be equal to RELATIVE (-1) or REMAINDER (0)
            // in any case using 1 instead of 0 or -1 should be sufficient to for
            // correct maximumArraySizes calculation
<span class="nc bnc" id="L961" title="All 2 branches missed.">            if (curWidth &lt;= 0){</span>
<span class="nc" id="L962">                curWidth = 1;</span>
            }
<span class="nc bnc" id="L964" title="All 2 branches missed.">            if (curHeight &lt;= 0){</span>
<span class="nc" id="L965">                curHeight = 1;</span>
            }

<span class="nc" id="L968">            preMaximumArrayXIndex = Math.max(curY + curHeight, preMaximumArrayXIndex);</span>
<span class="nc" id="L969">            preMaximumArrayYIndex = Math.max(curX + curWidth, preMaximumArrayYIndex);</span>
        } //for (components) loop
        // Must specify index++ to allocate well-working arrays.
        /* fix for 4623196.
         * now return long array instead of Point
         */
<span class="nc" id="L975">        returnArray[0] = preMaximumArrayXIndex;</span>
<span class="nc" id="L976">        returnArray[1] = preMaximumArrayYIndex;</span>
<span class="nc" id="L977">        return returnArray;</span>
    } //PreInitMaximumSizes

    /**
     * This method is obsolete and supplied for backwards
     * compatibility only; new code should call {@link
     * #getLayoutInfo(java.awt.Container, int) getLayoutInfo} instead.
     * This method is the same as &lt;code&gt;getLayoutInfo&lt;/code&gt;;
     * refer to &lt;code&gt;getLayoutInfo&lt;/code&gt; for details on parameters
     * and return value.
     */
    protected GridBagLayoutInfo GetLayoutInfo(Container parent, int sizeflag) {
<span class="nc" id="L989">        synchronized (parent.getTreeLock()) {</span>
            GridBagLayoutInfo r;
            Component comp;
            GridBagConstraints constraints;
            Dimension d;
<span class="nc" id="L994">            Component components[] = parent.getComponents();</span>
            // Code below will address index curX+curWidth in the case of yMaxArray, weightY
            // ( respectively curY+curHeight for xMaxArray, weightX ) where
            //  curX in 0 to preInitMaximumArraySizes.y
            // Thus, the maximum index that could
            // be calculated in the following code is curX+curX.
            // EmpericMultier equals 2 because of this.

            int layoutWidth, layoutHeight;
            int []xMaxArray;
            int []yMaxArray;
            int compindex, i, k, px, py, pixels_diff, nextSize;
<span class="nc" id="L1006">            int curX = 0; // constraints.gridx</span>
<span class="nc" id="L1007">            int curY = 0; // constraints.gridy</span>
<span class="nc" id="L1008">            int curWidth = 1;  // constraints.gridwidth</span>
<span class="nc" id="L1009">            int curHeight = 1;  // constraints.gridheight</span>
            int curRow, curCol;
            double weight_diff, weight;
<span class="nc" id="L1012">            int maximumArrayXIndex = 0;</span>
<span class="nc" id="L1013">            int maximumArrayYIndex = 0;</span>
            int anchor;

            /*
             * Pass #1
             *
             * Figure out the dimensions of the layout grid (use a value of 1 for
             * zero or negative widths and heights).
             */

<span class="nc" id="L1023">            layoutWidth = layoutHeight = 0;</span>
<span class="nc" id="L1024">            curRow = curCol = -1;</span>
<span class="nc" id="L1025">            long [] arraySizes = preInitMaximumArraySizes(parent);</span>

            /* fix for 4623196.
             * If user try to create a very big grid we can
             * get NegativeArraySizeException because of integer value
             * overflow (EMPIRICMULTIPLIER*gridSize might be more then Integer.MAX_VALUE).
             * We need to detect this situation and try to create a
             * grid with Integer.MAX_VALUE size instead.
             */
<span class="nc bnc" id="L1034" title="All 2 branches missed.">            maximumArrayXIndex = (EMPIRICMULTIPLIER * arraySizes[0] &gt; Integer.MAX_VALUE )? Integer.MAX_VALUE : EMPIRICMULTIPLIER*(int)arraySizes[0];</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            maximumArrayYIndex = (EMPIRICMULTIPLIER * arraySizes[1] &gt; Integer.MAX_VALUE )? Integer.MAX_VALUE : EMPIRICMULTIPLIER*(int)arraySizes[1];</span>

<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (rowHeights != null){</span>
<span class="nc" id="L1038">                maximumArrayXIndex = Math.max(maximumArrayXIndex, rowHeights.length);</span>
            }
<span class="nc bnc" id="L1040" title="All 2 branches missed.">            if (columnWidths != null){</span>
<span class="nc" id="L1041">                maximumArrayYIndex = Math.max(maximumArrayYIndex, columnWidths.length);</span>
            }

<span class="nc" id="L1044">            xMaxArray = new int[maximumArrayXIndex];</span>
<span class="nc" id="L1045">            yMaxArray = new int[maximumArrayYIndex];</span>

<span class="nc" id="L1047">            boolean hasBaseline = false;</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">            for (compindex = 0 ; compindex &lt; components.length ; compindex++) {</span>
<span class="nc" id="L1049">                comp = components[compindex];</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">                if (!comp.isVisible())</span>
<span class="nc" id="L1051">                    continue;</span>
<span class="nc" id="L1052">                constraints = lookupConstraints(comp);</span>

<span class="nc" id="L1054">                curX = constraints.gridx;</span>
<span class="nc" id="L1055">                curY = constraints.gridy;</span>
<span class="nc" id="L1056">                curWidth = constraints.gridwidth;</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">                if (curWidth &lt;= 0)</span>
<span class="nc" id="L1058">                    curWidth = 1;</span>
<span class="nc" id="L1059">                curHeight = constraints.gridheight;</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">                if (curHeight &lt;= 0)</span>
<span class="nc" id="L1061">                    curHeight = 1;</span>

                /* If x or y is negative, then use relative positioning: */
<span class="nc bnc" id="L1064" title="All 4 branches missed.">                if (curX &lt; 0 &amp;&amp; curY &lt; 0) {</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">                    if (curRow &gt;= 0)</span>
<span class="nc" id="L1066">                        curY = curRow;</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                    else if (curCol &gt;= 0)</span>
<span class="nc" id="L1068">                        curX = curCol;</span>
                    else
<span class="nc" id="L1070">                        curY = 0;</span>
                }
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                if (curX &lt; 0) {</span>
<span class="nc" id="L1073">                    px = 0;</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">                    for (i = curY; i &lt; (curY + curHeight); i++) {</span>
<span class="nc" id="L1075">                        px = Math.max(px, xMaxArray[i]);</span>
                    }

<span class="nc" id="L1078">                    curX = px - curX - 1;</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">                    if(curX &lt; 0)</span>
<span class="nc" id="L1080">                        curX = 0;</span>
                }
<span class="nc bnc" id="L1082" title="All 2 branches missed.">                else if (curY &lt; 0) {</span>
<span class="nc" id="L1083">                    py = 0;</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">                    for (i = curX; i &lt; (curX + curWidth); i++) {</span>
<span class="nc" id="L1085">                        py = Math.max(py, yMaxArray[i]);</span>
                    }
<span class="nc" id="L1087">                    curY = py - curY - 1;</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">                    if(curY &lt; 0)</span>
<span class="nc" id="L1089">                        curY = 0;</span>
                }

                /* Adjust the grid width and height
                 *  fix for 5005945: unneccessary loops removed
                 */
<span class="nc" id="L1095">                px = curX + curWidth;</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">                if (layoutWidth &lt; px) {</span>
<span class="nc" id="L1097">                    layoutWidth = px;</span>
                }
<span class="nc" id="L1099">                py = curY + curHeight;</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                if (layoutHeight &lt; py) {</span>
<span class="nc" id="L1101">                    layoutHeight = py;</span>
                }

                /* Adjust xMaxArray and yMaxArray */
<span class="nc bnc" id="L1105" title="All 2 branches missed.">                for (i = curX; i &lt; (curX + curWidth); i++) {</span>
<span class="nc" id="L1106">                    yMaxArray[i] =py;</span>
                }
<span class="nc bnc" id="L1108" title="All 2 branches missed.">                for (i = curY; i &lt; (curY + curHeight); i++) {</span>
<span class="nc" id="L1109">                    xMaxArray[i] = px;</span>
                }


                /* Cache the current slave's size. */
<span class="nc bnc" id="L1114" title="All 2 branches missed.">                if (sizeflag == PREFERREDSIZE)</span>
<span class="nc" id="L1115">                    d = comp.getPreferredSize();</span>
                else
<span class="nc" id="L1117">                    d = comp.getMinimumSize();</span>
<span class="nc" id="L1118">                constraints.minWidth = d.width;</span>
<span class="nc" id="L1119">                constraints.minHeight = d.height;</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                if (calculateBaseline(comp, constraints, d)) {</span>
<span class="nc" id="L1121">                    hasBaseline = true;</span>
                }

                /* Zero width and height must mean that this is the last item (or
                 * else something is wrong). */
<span class="nc bnc" id="L1126" title="All 4 branches missed.">                if (constraints.gridheight == 0 &amp;&amp; constraints.gridwidth == 0)</span>
<span class="nc" id="L1127">                    curRow = curCol = -1;</span>

                /* Zero width starts a new row */
<span class="nc bnc" id="L1130" title="All 4 branches missed.">                if (constraints.gridheight == 0 &amp;&amp; curRow &lt; 0)</span>
<span class="nc" id="L1131">                    curCol = curX + curWidth;</span>

                /* Zero height starts a new column */
<span class="nc bnc" id="L1134" title="All 4 branches missed.">                else if (constraints.gridwidth == 0 &amp;&amp; curCol &lt; 0)</span>
<span class="nc" id="L1135">                    curRow = curY + curHeight;</span>
            } //for (components) loop


            /*
             * Apply minimum row/column dimensions
             */
<span class="nc bnc" id="L1142" title="All 4 branches missed.">            if (columnWidths != null &amp;&amp; layoutWidth &lt; columnWidths.length)</span>
<span class="nc" id="L1143">                layoutWidth = columnWidths.length;</span>
<span class="nc bnc" id="L1144" title="All 4 branches missed.">            if (rowHeights != null &amp;&amp; layoutHeight &lt; rowHeights.length)</span>
<span class="nc" id="L1145">                layoutHeight = rowHeights.length;</span>

<span class="nc" id="L1147">            r = new GridBagLayoutInfo(layoutWidth, layoutHeight);</span>

            /*
             * Pass #2
             *
             * Negative values for gridX are filled in with the current x value.
             * Negative values for gridY are filled in with the current y value.
             * Negative or zero values for gridWidth and gridHeight end the current
             *  row or column, respectively.
             */

<span class="nc" id="L1158">            curRow = curCol = -1;</span>

<span class="nc" id="L1160">            Arrays.fill(xMaxArray, 0);</span>
<span class="nc" id="L1161">            Arrays.fill(yMaxArray, 0);</span>

<span class="nc" id="L1163">            int[] maxAscent = null;</span>
<span class="nc" id="L1164">            int[] maxDescent = null;</span>
<span class="nc" id="L1165">            short[] baselineType = null;</span>

<span class="nc bnc" id="L1167" title="All 2 branches missed.">            if (hasBaseline) {</span>
<span class="nc" id="L1168">                r.maxAscent = maxAscent = new int[layoutHeight];</span>
<span class="nc" id="L1169">                r.maxDescent = maxDescent = new int[layoutHeight];</span>
<span class="nc" id="L1170">                r.baselineType = baselineType = new short[layoutHeight];</span>
<span class="nc" id="L1171">                r.hasBaseline = true;</span>
            }


<span class="nc bnc" id="L1175" title="All 2 branches missed.">            for (compindex = 0 ; compindex &lt; components.length ; compindex++) {</span>
<span class="nc" id="L1176">                comp = components[compindex];</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">                if (!comp.isVisible())</span>
<span class="nc" id="L1178">                    continue;</span>
<span class="nc" id="L1179">                constraints = lookupConstraints(comp);</span>

<span class="nc" id="L1181">                curX = constraints.gridx;</span>
<span class="nc" id="L1182">                curY = constraints.gridy;</span>
<span class="nc" id="L1183">                curWidth = constraints.gridwidth;</span>
<span class="nc" id="L1184">                curHeight = constraints.gridheight;</span>

                /* If x or y is negative, then use relative positioning: */
<span class="nc bnc" id="L1187" title="All 4 branches missed.">                if (curX &lt; 0 &amp;&amp; curY &lt; 0) {</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">                    if(curRow &gt;= 0)</span>
<span class="nc" id="L1189">                        curY = curRow;</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">                    else if(curCol &gt;= 0)</span>
<span class="nc" id="L1191">                        curX = curCol;</span>
                    else
<span class="nc" id="L1193">                        curY = 0;</span>
                }

<span class="nc bnc" id="L1196" title="All 2 branches missed.">                if (curX &lt; 0) {</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">                    if (curHeight &lt;= 0) {</span>
<span class="nc" id="L1198">                        curHeight += r.height - curY;</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">                        if (curHeight &lt; 1)</span>
<span class="nc" id="L1200">                            curHeight = 1;</span>
                    }

<span class="nc" id="L1203">                    px = 0;</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">                    for (i = curY; i &lt; (curY + curHeight); i++)</span>
<span class="nc" id="L1205">                        px = Math.max(px, xMaxArray[i]);</span>

<span class="nc" id="L1207">                    curX = px - curX - 1;</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                    if(curX &lt; 0)</span>
<span class="nc" id="L1209">                        curX = 0;</span>
                }
<span class="nc bnc" id="L1211" title="All 2 branches missed.">                else if (curY &lt; 0) {</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">                    if (curWidth &lt;= 0) {</span>
<span class="nc" id="L1213">                        curWidth += r.width - curX;</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">                        if (curWidth &lt; 1)</span>
<span class="nc" id="L1215">                            curWidth = 1;</span>
                    }

<span class="nc" id="L1218">                    py = 0;</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">                    for (i = curX; i &lt; (curX + curWidth); i++){</span>
<span class="nc" id="L1220">                        py = Math.max(py, yMaxArray[i]);</span>
                    }

<span class="nc" id="L1223">                    curY = py - curY - 1;</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">                    if(curY &lt; 0)</span>
<span class="nc" id="L1225">                        curY = 0;</span>
                }

<span class="nc bnc" id="L1228" title="All 2 branches missed.">                if (curWidth &lt;= 0) {</span>
<span class="nc" id="L1229">                    curWidth += r.width - curX;</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">                    if (curWidth &lt; 1)</span>
<span class="nc" id="L1231">                        curWidth = 1;</span>
                }

<span class="nc bnc" id="L1234" title="All 2 branches missed.">                if (curHeight &lt;= 0) {</span>
<span class="nc" id="L1235">                    curHeight += r.height - curY;</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">                    if (curHeight &lt; 1)</span>
<span class="nc" id="L1237">                        curHeight = 1;</span>
                }

<span class="nc" id="L1240">                px = curX + curWidth;</span>
<span class="nc" id="L1241">                py = curY + curHeight;</span>

<span class="nc bnc" id="L1243" title="All 2 branches missed.">                for (i = curX; i &lt; (curX + curWidth); i++) { yMaxArray[i] = py; }</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">                for (i = curY; i &lt; (curY + curHeight); i++) { xMaxArray[i] = px; }</span>

                /* Make negative sizes start a new row/column */
<span class="nc bnc" id="L1247" title="All 4 branches missed.">                if (constraints.gridheight == 0 &amp;&amp; constraints.gridwidth == 0)</span>
<span class="nc" id="L1248">                    curRow = curCol = -1;</span>
<span class="nc bnc" id="L1249" title="All 4 branches missed.">                if (constraints.gridheight == 0 &amp;&amp; curRow &lt; 0)</span>
<span class="nc" id="L1250">                    curCol = curX + curWidth;</span>
<span class="nc bnc" id="L1251" title="All 4 branches missed.">                else if (constraints.gridwidth == 0 &amp;&amp; curCol &lt; 0)</span>
<span class="nc" id="L1252">                    curRow = curY + curHeight;</span>

                /* Assign the new values to the gridbag slave */
<span class="nc" id="L1255">                constraints.tempX = curX;</span>
<span class="nc" id="L1256">                constraints.tempY = curY;</span>
<span class="nc" id="L1257">                constraints.tempWidth = curWidth;</span>
<span class="nc" id="L1258">                constraints.tempHeight = curHeight;</span>

<span class="nc" id="L1260">                anchor = constraints.anchor;</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">                if (hasBaseline) {</span>
<span class="nc bnc" id="L1262" title="All 4 branches missed.">                    switch(anchor) {</span>
                    case GridBagConstraints.BASELINE:
                    case GridBagConstraints.BASELINE_LEADING:
                    case GridBagConstraints.BASELINE_TRAILING:
<span class="nc bnc" id="L1266" title="All 2 branches missed.">                        if (constraints.ascent &gt;= 0) {</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">                            if (curHeight == 1) {</span>
<span class="nc" id="L1268">                                maxAscent[curY] =</span>
<span class="nc" id="L1269">                                        Math.max(maxAscent[curY],</span>
                                                 constraints.ascent);
<span class="nc" id="L1271">                                maxDescent[curY] =</span>
<span class="nc" id="L1272">                                        Math.max(maxDescent[curY],</span>
                                                 constraints.descent);
                            }
                            else {
<span class="nc bnc" id="L1276" title="All 2 branches missed.">                                if (constraints.baselineResizeBehavior ==</span>
                                        Component.BaselineResizeBehavior.
                                        CONSTANT_DESCENT) {
<span class="nc" id="L1279">                                    maxDescent[curY + curHeight - 1] =</span>
<span class="nc" id="L1280">                                        Math.max(maxDescent[curY + curHeight</span>
                                                            - 1],
                                                 constraints.descent);
                                }
                                else {
<span class="nc" id="L1285">                                    maxAscent[curY] = Math.max(maxAscent[curY],</span>
                                                           constraints.ascent);
                                }
                            }
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                            if (constraints.baselineResizeBehavior ==</span>
                                    Component.BaselineResizeBehavior.CONSTANT_DESCENT) {
<span class="nc" id="L1291">                                baselineType[curY + curHeight - 1] |=</span>
                                        (1 &lt;&lt; constraints.
<span class="nc" id="L1293">                                         baselineResizeBehavior.ordinal());</span>
                            }
                            else {
<span class="nc" id="L1296">                                baselineType[curY] |= (1 &lt;&lt; constraints.</span>
<span class="nc" id="L1297">                                             baselineResizeBehavior.ordinal());</span>
                            }
                        }
                        break;
                    case GridBagConstraints.ABOVE_BASELINE:
                    case GridBagConstraints.ABOVE_BASELINE_LEADING:
                    case GridBagConstraints.ABOVE_BASELINE_TRAILING:
                        // Component positioned above the baseline.
                        // To make the bottom edge of the component aligned
                        // with the baseline the bottom inset is
                        // added to the descent, the rest to the ascent.
<span class="nc" id="L1308">                        pixels_diff = constraints.minHeight +</span>
                                constraints.insets.top +
                                constraints.ipady;
<span class="nc" id="L1311">                        maxAscent[curY] = Math.max(maxAscent[curY],</span>
                                                   pixels_diff);
<span class="nc" id="L1313">                        maxDescent[curY] = Math.max(maxDescent[curY],</span>
                                                    constraints.insets.bottom);
<span class="nc" id="L1315">                        break;</span>
                    case GridBagConstraints.BELOW_BASELINE:
                    case GridBagConstraints.BELOW_BASELINE_LEADING:
                    case GridBagConstraints.BELOW_BASELINE_TRAILING:
                        // Component positioned below the baseline.
                        // To make the top edge of the component aligned
                        // with the baseline the top inset is
                        // added to the ascent, the rest to the descent.
<span class="nc" id="L1323">                        pixels_diff = constraints.minHeight +</span>
                                constraints.insets.bottom + constraints.ipady;
<span class="nc" id="L1325">                        maxDescent[curY] = Math.max(maxDescent[curY],</span>
                                                    pixels_diff);
<span class="nc" id="L1327">                        maxAscent[curY] = Math.max(maxAscent[curY],</span>
                                                   constraints.insets.top);
                        break;
                    }
                }
            }

<span class="nc" id="L1334">            r.weightX = new double[maximumArrayYIndex];</span>
<span class="nc" id="L1335">            r.weightY = new double[maximumArrayXIndex];</span>
<span class="nc" id="L1336">            r.minWidth = new int[maximumArrayYIndex];</span>
<span class="nc" id="L1337">            r.minHeight = new int[maximumArrayXIndex];</span>


            /*
             * Apply minimum row/column dimensions and weights
             */
<span class="nc bnc" id="L1343" title="All 2 branches missed.">            if (columnWidths != null)</span>
<span class="nc" id="L1344">                System.arraycopy(columnWidths, 0, r.minWidth, 0, columnWidths.length);</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">            if (rowHeights != null)</span>
<span class="nc" id="L1346">                System.arraycopy(rowHeights, 0, r.minHeight, 0, rowHeights.length);</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">            if (columnWeights != null)</span>
<span class="nc" id="L1348">                System.arraycopy(columnWeights, 0, r.weightX, 0,  Math.min(r.weightX.length, columnWeights.length));</span>
<span class="nc bnc" id="L1349" title="All 2 branches missed.">            if (rowWeights != null)</span>
<span class="nc" id="L1350">                System.arraycopy(rowWeights, 0, r.weightY, 0,  Math.min(r.weightY.length, rowWeights.length));</span>

            /*
             * Pass #3
             *
             * Distribute the minimun widths and weights:
             */

<span class="nc" id="L1358">            nextSize = Integer.MAX_VALUE;</span>

<span class="nc" id="L1360">            for (i = 1;</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">                 i != Integer.MAX_VALUE;</span>
<span class="nc" id="L1362">                 i = nextSize, nextSize = Integer.MAX_VALUE) {</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">                for (compindex = 0 ; compindex &lt; components.length ; compindex++) {</span>
<span class="nc" id="L1364">                    comp = components[compindex];</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">                    if (!comp.isVisible())</span>
<span class="nc" id="L1366">                        continue;</span>
<span class="nc" id="L1367">                    constraints = lookupConstraints(comp);</span>

<span class="nc bnc" id="L1369" title="All 2 branches missed.">                    if (constraints.tempWidth == i) {</span>
<span class="nc" id="L1370">                        px = constraints.tempX + constraints.tempWidth; /* right column */</span>

                        /*
                         * Figure out if we should use this slave\'s weight.  If the weight
                         * is less than the total weight spanned by the width of the cell,
                         * then discard the weight.  Otherwise split the difference
                         * according to the existing weights.
                         */

<span class="nc" id="L1379">                        weight_diff = constraints.weightx;</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">                        for (k = constraints.tempX; k &lt; px; k++)</span>
<span class="nc" id="L1381">                            weight_diff -= r.weightX[k];</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">                        if (weight_diff &gt; 0.0) {</span>
<span class="nc" id="L1383">                            weight = 0.0;</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">                            for (k = constraints.tempX; k &lt; px; k++)</span>
<span class="nc" id="L1385">                                weight += r.weightX[k];</span>
<span class="nc bnc" id="L1386" title="All 4 branches missed.">                            for (k = constraints.tempX; weight &gt; 0.0 &amp;&amp; k &lt; px; k++) {</span>
<span class="nc" id="L1387">                                double wt = r.weightX[k];</span>
<span class="nc" id="L1388">                                double dx = (wt * weight_diff) / weight;</span>
<span class="nc" id="L1389">                                r.weightX[k] += dx;</span>
<span class="nc" id="L1390">                                weight_diff -= dx;</span>
<span class="nc" id="L1391">                                weight -= wt;</span>
                            }
                            /* Assign the remainder to the rightmost cell */
<span class="nc" id="L1394">                            r.weightX[px-1] += weight_diff;</span>
                        }

                        /*
                         * Calculate the minWidth array values.
                         * First, figure out how wide the current slave needs to be.
                         * Then, see if it will fit within the current minWidth values.
                         * If it will not fit, add the difference according to the
                         * weightX array.
                         */

<span class="nc" id="L1405">                        pixels_diff =</span>
                            constraints.minWidth + constraints.ipadx +
                            constraints.insets.left + constraints.insets.right;

<span class="nc bnc" id="L1409" title="All 2 branches missed.">                        for (k = constraints.tempX; k &lt; px; k++)</span>
<span class="nc" id="L1410">                            pixels_diff -= r.minWidth[k];</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">                        if (pixels_diff &gt; 0) {</span>
<span class="nc" id="L1412">                            weight = 0.0;</span>
<span class="nc bnc" id="L1413" title="All 2 branches missed.">                            for (k = constraints.tempX; k &lt; px; k++)</span>
<span class="nc" id="L1414">                                weight += r.weightX[k];</span>
<span class="nc bnc" id="L1415" title="All 4 branches missed.">                            for (k = constraints.tempX; weight &gt; 0.0 &amp;&amp; k &lt; px; k++) {</span>
<span class="nc" id="L1416">                                double wt = r.weightX[k];</span>
<span class="nc" id="L1417">                                int dx = (int)((wt * ((double)pixels_diff)) / weight);</span>
<span class="nc" id="L1418">                                r.minWidth[k] += dx;</span>
<span class="nc" id="L1419">                                pixels_diff -= dx;</span>
<span class="nc" id="L1420">                                weight -= wt;</span>
                            }
                            /* Any leftovers go into the rightmost cell */
<span class="nc" id="L1423">                            r.minWidth[px-1] += pixels_diff;</span>
                        }
                    }
<span class="nc bnc" id="L1426" title="All 4 branches missed.">                    else if (constraints.tempWidth &gt; i &amp;&amp; constraints.tempWidth &lt; nextSize)</span>
<span class="nc" id="L1427">                        nextSize = constraints.tempWidth;</span>


<span class="nc bnc" id="L1430" title="All 2 branches missed.">                    if (constraints.tempHeight == i) {</span>
<span class="nc" id="L1431">                        py = constraints.tempY + constraints.tempHeight; /* bottom row */</span>

                        /*
                         * Figure out if we should use this slave's weight.  If the weight
                         * is less than the total weight spanned by the height of the cell,
                         * then discard the weight.  Otherwise split it the difference
                         * according to the existing weights.
                         */

<span class="nc" id="L1440">                        weight_diff = constraints.weighty;</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">                        for (k = constraints.tempY; k &lt; py; k++)</span>
<span class="nc" id="L1442">                            weight_diff -= r.weightY[k];</span>
<span class="nc bnc" id="L1443" title="All 2 branches missed.">                        if (weight_diff &gt; 0.0) {</span>
<span class="nc" id="L1444">                            weight = 0.0;</span>
<span class="nc bnc" id="L1445" title="All 2 branches missed.">                            for (k = constraints.tempY; k &lt; py; k++)</span>
<span class="nc" id="L1446">                                weight += r.weightY[k];</span>
<span class="nc bnc" id="L1447" title="All 4 branches missed.">                            for (k = constraints.tempY; weight &gt; 0.0 &amp;&amp; k &lt; py; k++) {</span>
<span class="nc" id="L1448">                                double wt = r.weightY[k];</span>
<span class="nc" id="L1449">                                double dy = (wt * weight_diff) / weight;</span>
<span class="nc" id="L1450">                                r.weightY[k] += dy;</span>
<span class="nc" id="L1451">                                weight_diff -= dy;</span>
<span class="nc" id="L1452">                                weight -= wt;</span>
                            }
                            /* Assign the remainder to the bottom cell */
<span class="nc" id="L1455">                            r.weightY[py-1] += weight_diff;</span>
                        }

                        /*
                         * Calculate the minHeight array values.
                         * First, figure out how tall the current slave needs to be.
                         * Then, see if it will fit within the current minHeight values.
                         * If it will not fit, add the difference according to the
                         * weightY array.
                         */

<span class="nc" id="L1466">                        pixels_diff = -1;</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">                        if (hasBaseline) {</span>
<span class="nc bnc" id="L1468" title="All 4 branches missed.">                            switch(constraints.anchor) {</span>
                            case GridBagConstraints.BASELINE:
                            case GridBagConstraints.BASELINE_LEADING:
                            case GridBagConstraints.BASELINE_TRAILING:
<span class="nc bnc" id="L1472" title="All 2 branches missed.">                                if (constraints.ascent &gt;= 0) {</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">                                    if (constraints.tempHeight == 1) {</span>
<span class="nc" id="L1474">                                        pixels_diff =</span>
                                            maxAscent[constraints.tempY] +
                                            maxDescent[constraints.tempY];
                                    }
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                                    else if (constraints.baselineResizeBehavior !=</span>
                                             Component.BaselineResizeBehavior.
                                             CONSTANT_DESCENT) {
<span class="nc" id="L1481">                                        pixels_diff =</span>
                                                maxAscent[constraints.tempY] +
                                                constraints.descent;
                                    }
                                    else {
<span class="nc" id="L1486">                                        pixels_diff = constraints.ascent +</span>
                                                maxDescent[constraints.tempY +
                                                   constraints.tempHeight - 1];
                                    }
                                }
                                break;
                            case GridBagConstraints.ABOVE_BASELINE:
                            case GridBagConstraints.ABOVE_BASELINE_LEADING:
                            case GridBagConstraints.ABOVE_BASELINE_TRAILING:
<span class="nc" id="L1495">                                pixels_diff = constraints.insets.top +</span>
                                        constraints.minHeight +
                                        constraints.ipady +
                                        maxDescent[constraints.tempY];
<span class="nc" id="L1499">                                break;</span>
                            case GridBagConstraints.BELOW_BASELINE:
                            case GridBagConstraints.BELOW_BASELINE_LEADING:
                            case GridBagConstraints.BELOW_BASELINE_TRAILING:
<span class="nc" id="L1503">                                pixels_diff = maxAscent[constraints.tempY] +</span>
                                        constraints.minHeight +
                                        constraints.insets.bottom +
                                        constraints.ipady;
                                break;
                            }
                        }
<span class="nc bnc" id="L1510" title="All 2 branches missed.">                        if (pixels_diff == -1) {</span>
<span class="nc" id="L1511">                            pixels_diff =</span>
                                constraints.minHeight + constraints.ipady +
                                constraints.insets.top +
                                constraints.insets.bottom;
                        }
<span class="nc bnc" id="L1516" title="All 2 branches missed.">                        for (k = constraints.tempY; k &lt; py; k++)</span>
<span class="nc" id="L1517">                            pixels_diff -= r.minHeight[k];</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">                        if (pixels_diff &gt; 0) {</span>
<span class="nc" id="L1519">                            weight = 0.0;</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">                            for (k = constraints.tempY; k &lt; py; k++)</span>
<span class="nc" id="L1521">                                weight += r.weightY[k];</span>
<span class="nc bnc" id="L1522" title="All 4 branches missed.">                            for (k = constraints.tempY; weight &gt; 0.0 &amp;&amp; k &lt; py; k++) {</span>
<span class="nc" id="L1523">                                double wt = r.weightY[k];</span>
<span class="nc" id="L1524">                                int dy = (int)((wt * ((double)pixels_diff)) / weight);</span>
<span class="nc" id="L1525">                                r.minHeight[k] += dy;</span>
<span class="nc" id="L1526">                                pixels_diff -= dy;</span>
<span class="nc" id="L1527">                                weight -= wt;</span>
                            }
                            /* Any leftovers go into the bottom cell */
<span class="nc" id="L1530">                            r.minHeight[py-1] += pixels_diff;</span>
                        }
                    }
<span class="nc bnc" id="L1533" title="All 4 branches missed.">                    else if (constraints.tempHeight &gt; i &amp;&amp;</span>
                             constraints.tempHeight &lt; nextSize)
<span class="nc" id="L1535">                        nextSize = constraints.tempHeight;</span>
                }
            }
<span class="nc" id="L1538">            return r;</span>
<span class="nc" id="L1539">        }</span>
    } //getLayoutInfo()

    /**
     * Calculate the baseline for the specified component.
     * If {@code c} is positioned along it's baseline, the baseline is
     * obtained and the {@code constraints} ascent, descent and
     * baseline resize behavior are set from the component; and true is
     * returned. Otherwise false is returned.
     */
    private boolean calculateBaseline(Component c,
                                      GridBagConstraints constraints,
                                      Dimension size) {
<span class="nc" id="L1552">        int anchor = constraints.anchor;</span>
<span class="nc bnc" id="L1553" title="All 6 branches missed.">        if (anchor == GridBagConstraints.BASELINE ||</span>
                anchor == GridBagConstraints.BASELINE_LEADING ||
                anchor == GridBagConstraints.BASELINE_TRAILING) {
            // Apply the padding to the component, then ask for the baseline.
<span class="nc" id="L1557">            int w = size.width + constraints.ipadx;</span>
<span class="nc" id="L1558">            int h = size.height + constraints.ipady;</span>
<span class="nc" id="L1559">            constraints.ascent = c.getBaseline(w, h);</span>
<span class="nc bnc" id="L1560" title="All 2 branches missed.">            if (constraints.ascent &gt;= 0) {</span>
                // Component has a baseline
<span class="nc" id="L1562">                int baseline = constraints.ascent;</span>
                // Adjust the ascent and descent to include the insets.
<span class="nc" id="L1564">                constraints.descent = h - constraints.ascent +</span>
                            constraints.insets.bottom;
<span class="nc" id="L1566">                constraints.ascent += constraints.insets.top;</span>
<span class="nc" id="L1567">                constraints.baselineResizeBehavior =</span>
<span class="nc" id="L1568">                        c.getBaselineResizeBehavior();</span>
<span class="nc" id="L1569">                constraints.centerPadding = 0;</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">                if (constraints.baselineResizeBehavior == Component.</span>
                        BaselineResizeBehavior.CENTER_OFFSET) {
                    // Component has a baseline resize behavior of
                    // CENTER_OFFSET, calculate centerPadding and
                    // centerOffset (see the description of
                    // CENTER_OFFSET in the enum for detais on this
                    // algorithm).
<span class="nc" id="L1577">                    int nextBaseline = c.getBaseline(w, h + 1);</span>
<span class="nc" id="L1578">                    constraints.centerOffset = baseline - h / 2;</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">                    if (h % 2 == 0) {</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">                        if (baseline != nextBaseline) {</span>
<span class="nc" id="L1581">                            constraints.centerPadding = 1;</span>
                        }
                    }
<span class="nc bnc" id="L1584" title="All 2 branches missed.">                    else if (baseline == nextBaseline){</span>
<span class="nc" id="L1585">                        constraints.centerOffset--;</span>
<span class="nc" id="L1586">                        constraints.centerPadding = 1;</span>
                    }
                }
            }
<span class="nc" id="L1590">            return true;</span>
        }
        else {
<span class="nc" id="L1593">            constraints.ascent = -1;</span>
<span class="nc" id="L1594">            return false;</span>
        }
    }

    /**
     * Adjusts the x, y, width, and height fields to the correct
     * values depending on the constraint geometry and pads.
     * This method should only be used internally by
     * &lt;code&gt;GridBagLayout&lt;/code&gt;.
     *
     * @param constraints the constraints to be applied
     * @param r the &lt;code&gt;Rectangle&lt;/code&gt; to be adjusted
     * @since 1.4
     */
    protected void adjustForGravity(GridBagConstraints constraints,
                                    Rectangle r) {
<span class="nc" id="L1610">        AdjustForGravity(constraints, r);</span>
<span class="nc" id="L1611">    }</span>

    /**
     * This method is obsolete and supplied for backwards
     * compatibility only; new code should call {@link
     * #adjustForGravity(java.awt.GridBagConstraints, java.awt.Rectangle)
     * adjustForGravity} instead.
     * This method is the same as &lt;code&gt;adjustForGravity&lt;/code&gt;;
     * refer to &lt;code&gt;adjustForGravity&lt;/code&gt; for details
     * on parameters.
     */
    protected void AdjustForGravity(GridBagConstraints constraints,
                                    Rectangle r) {
        int diffx, diffy;
<span class="nc" id="L1625">        int cellY = r.y;</span>
<span class="nc" id="L1626">        int cellHeight = r.height;</span>

<span class="nc bnc" id="L1628" title="All 2 branches missed.">        if (!rightToLeft) {</span>
<span class="nc" id="L1629">            r.x += constraints.insets.left;</span>
        } else {
<span class="nc" id="L1631">            r.x -= r.width - constraints.insets.right;</span>
        }
<span class="nc" id="L1633">        r.width -= (constraints.insets.left + constraints.insets.right);</span>
<span class="nc" id="L1634">        r.y += constraints.insets.top;</span>
<span class="nc" id="L1635">        r.height -= (constraints.insets.top + constraints.insets.bottom);</span>

<span class="nc" id="L1637">        diffx = 0;</span>
<span class="nc bnc" id="L1638" title="All 6 branches missed.">        if ((constraints.fill != GridBagConstraints.HORIZONTAL &amp;&amp;</span>
             constraints.fill != GridBagConstraints.BOTH)
            &amp;&amp; (r.width &gt; (constraints.minWidth + constraints.ipadx))) {
<span class="nc" id="L1641">            diffx = r.width - (constraints.minWidth + constraints.ipadx);</span>
<span class="nc" id="L1642">            r.width = constraints.minWidth + constraints.ipadx;</span>
        }

<span class="nc" id="L1645">        diffy = 0;</span>
<span class="nc bnc" id="L1646" title="All 6 branches missed.">        if ((constraints.fill != GridBagConstraints.VERTICAL &amp;&amp;</span>
             constraints.fill != GridBagConstraints.BOTH)
            &amp;&amp; (r.height &gt; (constraints.minHeight + constraints.ipady))) {
<span class="nc" id="L1649">            diffy = r.height - (constraints.minHeight + constraints.ipady);</span>
<span class="nc" id="L1650">            r.height = constraints.minHeight + constraints.ipady;</span>
        }

<span class="nc bnc" id="L1653" title="All 25 branches missed.">        switch (constraints.anchor) {</span>
          case GridBagConstraints.BASELINE:
<span class="nc" id="L1655">              r.x += diffx/2;</span>
<span class="nc" id="L1656">              alignOnBaseline(constraints, r, cellY, cellHeight);</span>
<span class="nc" id="L1657">              break;</span>
          case GridBagConstraints.BASELINE_LEADING:
<span class="nc bnc" id="L1659" title="All 2 branches missed.">              if (rightToLeft) {</span>
<span class="nc" id="L1660">                  r.x += diffx;</span>
              }
<span class="nc" id="L1662">              alignOnBaseline(constraints, r, cellY, cellHeight);</span>
<span class="nc" id="L1663">              break;</span>
          case GridBagConstraints.BASELINE_TRAILING:
<span class="nc bnc" id="L1665" title="All 2 branches missed.">              if (!rightToLeft) {</span>
<span class="nc" id="L1666">                  r.x += diffx;</span>
              }
<span class="nc" id="L1668">              alignOnBaseline(constraints, r, cellY, cellHeight);</span>
<span class="nc" id="L1669">              break;</span>
          case GridBagConstraints.ABOVE_BASELINE:
<span class="nc" id="L1671">              r.x += diffx/2;</span>
<span class="nc" id="L1672">              alignAboveBaseline(constraints, r, cellY, cellHeight);</span>
<span class="nc" id="L1673">              break;</span>
          case GridBagConstraints.ABOVE_BASELINE_LEADING:
<span class="nc bnc" id="L1675" title="All 2 branches missed.">              if (rightToLeft) {</span>
<span class="nc" id="L1676">                  r.x += diffx;</span>
              }
<span class="nc" id="L1678">              alignAboveBaseline(constraints, r, cellY, cellHeight);</span>
<span class="nc" id="L1679">              break;</span>
          case GridBagConstraints.ABOVE_BASELINE_TRAILING:
<span class="nc bnc" id="L1681" title="All 2 branches missed.">              if (!rightToLeft) {</span>
<span class="nc" id="L1682">                  r.x += diffx;</span>
              }
<span class="nc" id="L1684">              alignAboveBaseline(constraints, r, cellY, cellHeight);</span>
<span class="nc" id="L1685">              break;</span>
          case GridBagConstraints.BELOW_BASELINE:
<span class="nc" id="L1687">              r.x += diffx/2;</span>
<span class="nc" id="L1688">              alignBelowBaseline(constraints, r, cellY, cellHeight);</span>
<span class="nc" id="L1689">              break;</span>
          case GridBagConstraints.BELOW_BASELINE_LEADING:
<span class="nc bnc" id="L1691" title="All 2 branches missed.">              if (rightToLeft) {</span>
<span class="nc" id="L1692">                  r.x += diffx;</span>
              }
<span class="nc" id="L1694">              alignBelowBaseline(constraints, r, cellY, cellHeight);</span>
<span class="nc" id="L1695">              break;</span>
          case GridBagConstraints.BELOW_BASELINE_TRAILING:
<span class="nc bnc" id="L1697" title="All 2 branches missed.">              if (!rightToLeft) {</span>
<span class="nc" id="L1698">                  r.x += diffx;</span>
              }
<span class="nc" id="L1700">              alignBelowBaseline(constraints, r, cellY, cellHeight);</span>
<span class="nc" id="L1701">              break;</span>
          case GridBagConstraints.CENTER:
<span class="nc" id="L1703">              r.x += diffx/2;</span>
<span class="nc" id="L1704">              r.y += diffy/2;</span>
<span class="nc" id="L1705">              break;</span>
          case GridBagConstraints.PAGE_START:
          case GridBagConstraints.NORTH:
<span class="nc" id="L1708">              r.x += diffx/2;</span>
<span class="nc" id="L1709">              break;</span>
          case GridBagConstraints.NORTHEAST:
<span class="nc" id="L1711">              r.x += diffx;</span>
<span class="nc" id="L1712">              break;</span>
          case GridBagConstraints.EAST:
<span class="nc" id="L1714">              r.x += diffx;</span>
<span class="nc" id="L1715">              r.y += diffy/2;</span>
<span class="nc" id="L1716">              break;</span>
          case GridBagConstraints.SOUTHEAST:
<span class="nc" id="L1718">              r.x += diffx;</span>
<span class="nc" id="L1719">              r.y += diffy;</span>
<span class="nc" id="L1720">              break;</span>
          case GridBagConstraints.PAGE_END:
          case GridBagConstraints.SOUTH:
<span class="nc" id="L1723">              r.x += diffx/2;</span>
<span class="nc" id="L1724">              r.y += diffy;</span>
<span class="nc" id="L1725">              break;</span>
          case GridBagConstraints.SOUTHWEST:
<span class="nc" id="L1727">              r.y += diffy;</span>
<span class="nc" id="L1728">              break;</span>
          case GridBagConstraints.WEST:
<span class="nc" id="L1730">              r.y += diffy/2;</span>
<span class="nc" id="L1731">              break;</span>
          case GridBagConstraints.NORTHWEST:
<span class="nc" id="L1733">              break;</span>
          case GridBagConstraints.LINE_START:
<span class="nc bnc" id="L1735" title="All 2 branches missed.">              if (rightToLeft) {</span>
<span class="nc" id="L1736">                  r.x += diffx;</span>
              }
<span class="nc" id="L1738">              r.y += diffy/2;</span>
<span class="nc" id="L1739">              break;</span>
          case GridBagConstraints.LINE_END:
<span class="nc bnc" id="L1741" title="All 2 branches missed.">              if (!rightToLeft) {</span>
<span class="nc" id="L1742">                  r.x += diffx;</span>
              }
<span class="nc" id="L1744">              r.y += diffy/2;</span>
<span class="nc" id="L1745">              break;</span>
          case GridBagConstraints.FIRST_LINE_START:
<span class="nc bnc" id="L1747" title="All 2 branches missed.">              if (rightToLeft) {</span>
<span class="nc" id="L1748">                  r.x += diffx;</span>
              }
              break;
          case GridBagConstraints.FIRST_LINE_END:
<span class="nc bnc" id="L1752" title="All 2 branches missed.">              if (!rightToLeft) {</span>
<span class="nc" id="L1753">                  r.x += diffx;</span>
              }
              break;
          case GridBagConstraints.LAST_LINE_START:
<span class="nc bnc" id="L1757" title="All 2 branches missed.">              if (rightToLeft) {</span>
<span class="nc" id="L1758">                  r.x += diffx;</span>
              }
<span class="nc" id="L1760">              r.y += diffy;</span>
<span class="nc" id="L1761">              break;</span>
          case GridBagConstraints.LAST_LINE_END:
<span class="nc bnc" id="L1763" title="All 2 branches missed.">              if (!rightToLeft) {</span>
<span class="nc" id="L1764">                  r.x += diffx;</span>
              }
<span class="nc" id="L1766">              r.y += diffy;</span>
<span class="nc" id="L1767">              break;</span>
          default:
<span class="nc" id="L1769">              throw new IllegalArgumentException(&quot;illegal anchor value&quot;);</span>
        }
<span class="nc" id="L1771">    }</span>

    /**
     * Positions on the baseline.
     *
     * @param cellY the location of the row, does not include insets
     * @param cellHeight the height of the row, does not take into account
     *        insets
     * @param r available bounds for the component, is padded by insets and
     *        ipady
     */
    private void alignOnBaseline(GridBagConstraints cons, Rectangle r,
                                 int cellY, int cellHeight) {
<span class="nc bnc" id="L1784" title="All 2 branches missed.">        if (cons.ascent &gt;= 0) {</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">            if (cons.baselineResizeBehavior == Component.</span>
                    BaselineResizeBehavior.CONSTANT_DESCENT) {
                // Anchor to the bottom.
                // Baseline is at (cellY + cellHeight - maxDescent).
                // Bottom of component (maxY) is at baseline + descent
                // of component. We need to subtract the bottom inset here
                // as the descent in the constraints object includes the
                // bottom inset.
<span class="nc" id="L1793">                int maxY = cellY + cellHeight -</span>
                      layoutInfo.maxDescent[cons.tempY + cons.tempHeight - 1] +
                      cons.descent - cons.insets.bottom;
<span class="nc bnc" id="L1796" title="All 2 branches missed.">                if (!cons.isVerticallyResizable()) {</span>
                    // Component not resizable, calculate y location
                    // from maxY - height.
<span class="nc" id="L1799">                    r.y = maxY - cons.minHeight;</span>
<span class="nc" id="L1800">                    r.height = cons.minHeight;</span>
                } else {
                    // Component is resizable. As brb is constant descent,
                    // can expand component to fill region above baseline.
                    // Subtract out the top inset so that components insets
                    // are honored.
<span class="nc" id="L1806">                    r.height = maxY - cellY - cons.insets.top;</span>
                }
<span class="nc" id="L1808">            }</span>
            else {
                // BRB is not constant_descent
                int baseline; // baseline for the row, relative to cellY
                // Component baseline, includes insets.top
<span class="nc" id="L1813">                int ascent = cons.ascent;</span>
<span class="nc bnc" id="L1814" title="All 2 branches missed.">                if (layoutInfo.hasConstantDescent(cons.tempY)) {</span>
                    // Mixed ascent/descent in same row, calculate position
                    // off maxDescent
<span class="nc" id="L1817">                    baseline = cellHeight - layoutInfo.maxDescent[cons.tempY];</span>
                }
                else {
                    // Only ascents/unknown in this row, anchor to top
<span class="nc" id="L1821">                    baseline = layoutInfo.maxAscent[cons.tempY];</span>
                }
<span class="nc bnc" id="L1823" title="All 2 branches missed.">                if (cons.baselineResizeBehavior == Component.</span>
                        BaselineResizeBehavior.OTHER) {
                    // BRB is other, which means we can only determine
                    // the baseline by asking for it again giving the
                    // size we plan on using for the component.
<span class="nc" id="L1828">                    boolean fits = false;</span>
<span class="nc" id="L1829">                    ascent = componentAdjusting.getBaseline(r.width, r.height);</span>
<span class="nc bnc" id="L1830" title="All 2 branches missed.">                    if (ascent &gt;= 0) {</span>
                        // Component has a baseline, pad with top inset
                        // (this follows from calculateBaseline which
                        // does the same).
<span class="nc" id="L1834">                        ascent += cons.insets.top;</span>
                    }
<span class="nc bnc" id="L1836" title="All 4 branches missed.">                    if (ascent &gt;= 0 &amp;&amp; ascent &lt;= baseline) {</span>
                        // Components baseline fits within rows baseline.
                        // Make sure the descent fits within the space as well.
<span class="nc bnc" id="L1839" title="All 2 branches missed.">                        if (baseline + (r.height - ascent - cons.insets.top) &lt;=</span>
                                cellHeight - cons.insets.bottom) {
                            // It fits, we're good.
<span class="nc" id="L1842">                            fits = true;</span>
                        }
<span class="nc bnc" id="L1844" title="All 2 branches missed.">                        else if (cons.isVerticallyResizable()) {</span>
                            // Doesn't fit, but it's resizable.  Try
                            // again assuming we'll get ascent again.
<span class="nc" id="L1847">                            int ascent2 = componentAdjusting.getBaseline(</span>
                                    r.width, cellHeight - cons.insets.bottom -
                                    baseline + ascent);
<span class="nc bnc" id="L1850" title="All 2 branches missed.">                            if (ascent2 &gt;= 0) {</span>
<span class="nc" id="L1851">                                ascent2 += cons.insets.top;</span>
                            }
<span class="nc bnc" id="L1853" title="All 4 branches missed.">                            if (ascent2 &gt;= 0 &amp;&amp; ascent2 &lt;= ascent) {</span>
                                // It'll fit
<span class="nc" id="L1855">                                r.height = cellHeight - cons.insets.bottom -</span>
                                        baseline + ascent;
<span class="nc" id="L1857">                                ascent = ascent2;</span>
<span class="nc" id="L1858">                                fits = true;</span>
                            }
                        }
                    }
<span class="nc bnc" id="L1862" title="All 2 branches missed.">                    if (!fits) {</span>
                        // Doesn't fit, use min size and original ascent
<span class="nc" id="L1864">                        ascent = cons.ascent;</span>
<span class="nc" id="L1865">                        r.width = cons.minWidth;</span>
<span class="nc" id="L1866">                        r.height = cons.minHeight;</span>
                    }
                }
                // Reset the components y location based on
                // components ascent and baseline for row. Because ascent
                // includes the baseline
<span class="nc" id="L1872">                r.y = cellY + baseline - ascent + cons.insets.top;</span>
<span class="nc bnc" id="L1873" title="All 2 branches missed.">                if (cons.isVerticallyResizable()) {</span>
<span class="nc bnc" id="L1874" title="All 4 branches missed.">                    switch(cons.baselineResizeBehavior) {</span>
                    case CONSTANT_ASCENT:
<span class="nc" id="L1876">                        r.height = Math.max(cons.minHeight,cellY + cellHeight -</span>
                                            r.y - cons.insets.bottom);
<span class="nc" id="L1878">                        break;</span>
                    case CENTER_OFFSET:
                        {
<span class="nc" id="L1881">                            int upper = r.y - cellY - cons.insets.top;</span>
<span class="nc" id="L1882">                            int lower = cellY + cellHeight - r.y -</span>
                                cons.minHeight - cons.insets.bottom;
<span class="nc" id="L1884">                            int delta = Math.min(upper, lower);</span>
<span class="nc" id="L1885">                            delta += delta;</span>
<span class="nc bnc" id="L1886" title="All 4 branches missed.">                            if (delta &gt; 0 &amp;&amp;</span>
                                (cons.minHeight + cons.centerPadding +
                                 delta) / 2 + cons.centerOffset != baseline) {
                                // Off by 1
<span class="nc" id="L1890">                                delta--;</span>
                            }
<span class="nc" id="L1892">                            r.height = cons.minHeight + delta;</span>
<span class="nc" id="L1893">                            r.y = cellY + baseline -</span>
                                (r.height + cons.centerPadding) / 2 -
                                cons.centerOffset;
                        }
<span class="nc" id="L1897">                        break;</span>
                    case OTHER:
                        // Handled above
<span class="nc" id="L1900">                        break;</span>
                    default:
                        break;
                    }
                }
<span class="nc" id="L1905">            }</span>
        }
        else {
<span class="nc" id="L1908">            centerVertically(cons, r, cellHeight);</span>
        }
<span class="nc" id="L1910">    }</span>

    /**
     * Positions the specified component above the baseline. That is
     * the bottom edge of the component will be aligned along the baseline.
     * If the row does not have a baseline, this centers the component.
     */
    private void alignAboveBaseline(GridBagConstraints cons, Rectangle r,
                                    int cellY, int cellHeight) {
<span class="nc bnc" id="L1919" title="All 2 branches missed.">        if (layoutInfo.hasBaseline(cons.tempY)) {</span>
            int maxY; // Baseline for the row
<span class="nc bnc" id="L1921" title="All 2 branches missed.">            if (layoutInfo.hasConstantDescent(cons.tempY)) {</span>
                // Prefer descent
<span class="nc" id="L1923">                maxY = cellY + cellHeight - layoutInfo.maxDescent[cons.tempY];</span>
            }
            else {
                // Prefer ascent
<span class="nc" id="L1927">                maxY = cellY + layoutInfo.maxAscent[cons.tempY];</span>
            }
<span class="nc bnc" id="L1929" title="All 2 branches missed.">            if (cons.isVerticallyResizable()) {</span>
                // Component is resizable. Top edge is offset by top
                // inset, bottom edge on baseline.
<span class="nc" id="L1932">                r.y = cellY + cons.insets.top;</span>
<span class="nc" id="L1933">                r.height = maxY - r.y;</span>
            }
            else {
                // Not resizable.
<span class="nc" id="L1937">                r.height = cons.minHeight + cons.ipady;</span>
<span class="nc" id="L1938">                r.y = maxY - r.height;</span>
            }
<span class="nc" id="L1940">        }</span>
        else {
<span class="nc" id="L1942">            centerVertically(cons, r, cellHeight);</span>
        }
<span class="nc" id="L1944">    }</span>

    /**
     * Positions below the baseline.
     */
    private void alignBelowBaseline(GridBagConstraints cons, Rectangle r,
                                    int cellY, int cellHeight) {
<span class="nc bnc" id="L1951" title="All 2 branches missed.">        if (layoutInfo.hasBaseline(cons.tempY)) {</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">            if (layoutInfo.hasConstantDescent(cons.tempY)) {</span>
                // Prefer descent
<span class="nc" id="L1954">                r.y = cellY + cellHeight - layoutInfo.maxDescent[cons.tempY];</span>
            }
            else {
                // Prefer ascent
<span class="nc" id="L1958">                r.y = cellY + layoutInfo.maxAscent[cons.tempY];</span>
            }
<span class="nc bnc" id="L1960" title="All 2 branches missed.">            if (cons.isVerticallyResizable()) {</span>
<span class="nc" id="L1961">                r.height = cellY + cellHeight - r.y - cons.insets.bottom;</span>
            }
        }
        else {
<span class="nc" id="L1965">            centerVertically(cons, r, cellHeight);</span>
        }
<span class="nc" id="L1967">    }</span>

    private void centerVertically(GridBagConstraints cons, Rectangle r,
                                  int cellHeight) {
<span class="nc bnc" id="L1971" title="All 2 branches missed.">        if (!cons.isVerticallyResizable()) {</span>
<span class="nc" id="L1972">            r.y += Math.max(0, (cellHeight - cons.insets.top -</span>
                                cons.insets.bottom - cons.minHeight -
                                cons.ipady) / 2);
        }
<span class="nc" id="L1976">    }</span>

    /**
     * Figures out the minimum size of the
     * master based on the information from &lt;code&gt;getLayoutInfo&lt;/code&gt;.
     * This method should only be used internally by
     * &lt;code&gt;GridBagLayout&lt;/code&gt;.
     *
     * @param parent the layout container
     * @param info the layout info for this parent
     * @return a &lt;code&gt;Dimension&lt;/code&gt; object containing the
     *   minimum size
     * @since 1.4
     */
    protected Dimension getMinSize(Container parent, GridBagLayoutInfo info) {
<span class="nc" id="L1991">        return GetMinSize(parent, info);</span>
    }

    /**
     * This method is obsolete and supplied for backwards
     * compatibility only; new code should call {@link
     * #getMinSize(java.awt.Container, GridBagLayoutInfo) getMinSize} instead.
     * This method is the same as &lt;code&gt;getMinSize&lt;/code&gt;;
     * refer to &lt;code&gt;getMinSize&lt;/code&gt; for details on parameters
     * and return value.
     */
    protected Dimension GetMinSize(Container parent, GridBagLayoutInfo info) {
<span class="nc" id="L2003">        Dimension d = new Dimension();</span>
        int i, t;
<span class="nc" id="L2005">        Insets insets = parent.getInsets();</span>

<span class="nc" id="L2007">        t = 0;</span>
<span class="nc bnc" id="L2008" title="All 2 branches missed.">        for(i = 0; i &lt; info.width; i++)</span>
<span class="nc" id="L2009">            t += info.minWidth[i];</span>
<span class="nc" id="L2010">        d.width = t + insets.left + insets.right;</span>

<span class="nc" id="L2012">        t = 0;</span>
<span class="nc bnc" id="L2013" title="All 2 branches missed.">        for(i = 0; i &lt; info.height; i++)</span>
<span class="nc" id="L2014">            t += info.minHeight[i];</span>
<span class="nc" id="L2015">        d.height = t + insets.top + insets.bottom;</span>

<span class="nc" id="L2017">        return d;</span>
    }

<span class="nc" id="L2020">    transient boolean rightToLeft = false;</span>

    /**
     * Lays out the grid.
     * This method should only be used internally by
     * &lt;code&gt;GridBagLayout&lt;/code&gt;.
     *
     * @param parent the layout container
     * @since 1.4
     */
    protected void arrangeGrid(Container parent) {
<span class="nc" id="L2031">        ArrangeGrid(parent);</span>
<span class="nc" id="L2032">    }</span>

    /**
     * This method is obsolete and supplied for backwards
     * compatibility only; new code should call {@link
     * #arrangeGrid(Container) arrangeGrid} instead.
     * This method is the same as &lt;code&gt;arrangeGrid&lt;/code&gt;;
     * refer to &lt;code&gt;arrangeGrid&lt;/code&gt; for details on the
     * parameter.
     */
    protected void ArrangeGrid(Container parent) {
        Component comp;
        int compindex;
        GridBagConstraints constraints;
<span class="nc" id="L2046">        Insets insets = parent.getInsets();</span>
<span class="nc" id="L2047">        Component components[] = parent.getComponents();</span>
        Dimension d;
<span class="nc" id="L2049">        Rectangle r = new Rectangle();</span>
        int i, diffw, diffh;
        double weight;
        GridBagLayoutInfo info;

<span class="nc bnc" id="L2054" title="All 2 branches missed.">        rightToLeft = !parent.getComponentOrientation().isLeftToRight();</span>

        /*
         * If the parent has no slaves anymore, then don't do anything
         * at all:  just leave the parent's size as-is.
         */
<span class="nc bnc" id="L2060" title="All 10 branches missed.">        if (components.length == 0 &amp;&amp;</span>
            (columnWidths == null || columnWidths.length == 0) &amp;&amp;
            (rowHeights == null || rowHeights.length == 0)) {
<span class="nc" id="L2063">            return;</span>
        }

        /*
         * Pass #1: scan all the slaves to figure out the total amount
         * of space needed.
         */

<span class="nc" id="L2071">        info = getLayoutInfo(parent, PREFERREDSIZE);</span>
<span class="nc" id="L2072">        d = getMinSize(parent, info);</span>

<span class="nc bnc" id="L2074" title="All 4 branches missed.">        if (parent.width &lt; d.width || parent.height &lt; d.height) {</span>
<span class="nc" id="L2075">            info = getLayoutInfo(parent, MINSIZE);</span>
<span class="nc" id="L2076">            d = getMinSize(parent, info);</span>
        }

<span class="nc" id="L2079">        layoutInfo = info;</span>
<span class="nc" id="L2080">        r.width = d.width;</span>
<span class="nc" id="L2081">        r.height = d.height;</span>

        /*
         * DEBUG
         *
         * DumpLayoutInfo(info);
         * for (compindex = 0 ; compindex &lt; components.length ; compindex++) {
         * comp = components[compindex];
         * if (!comp.isVisible())
         *      continue;
         * constraints = lookupConstraints(comp);
         * DumpConstraints(constraints);
         * }
         * System.out.println(&quot;minSize &quot; + r.width + &quot; &quot; + r.height);
         */

        /*
         * If the current dimensions of the window don't match the desired
         * dimensions, then adjust the minWidth and minHeight arrays
         * according to the weights.
         */

<span class="nc" id="L2103">        diffw = parent.width - r.width;</span>
<span class="nc bnc" id="L2104" title="All 2 branches missed.">        if (diffw != 0) {</span>
<span class="nc" id="L2105">            weight = 0.0;</span>
<span class="nc bnc" id="L2106" title="All 2 branches missed.">            for (i = 0; i &lt; info.width; i++)</span>
<span class="nc" id="L2107">                weight += info.weightX[i];</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">            if (weight &gt; 0.0) {</span>
<span class="nc bnc" id="L2109" title="All 2 branches missed.">                for (i = 0; i &lt; info.width; i++) {</span>
<span class="nc" id="L2110">                    int dx = (int)(( ((double)diffw) * info.weightX[i]) / weight);</span>
<span class="nc" id="L2111">                    info.minWidth[i] += dx;</span>
<span class="nc" id="L2112">                    r.width += dx;</span>
<span class="nc bnc" id="L2113" title="All 2 branches missed.">                    if (info.minWidth[i] &lt; 0) {</span>
<span class="nc" id="L2114">                        r.width -= info.minWidth[i];</span>
<span class="nc" id="L2115">                        info.minWidth[i] = 0;</span>
                    }
                }
            }
<span class="nc" id="L2119">            diffw = parent.width - r.width;</span>
        }

        else {
<span class="nc" id="L2123">            diffw = 0;</span>
        }

<span class="nc" id="L2126">        diffh = parent.height - r.height;</span>
<span class="nc bnc" id="L2127" title="All 2 branches missed.">        if (diffh != 0) {</span>
<span class="nc" id="L2128">            weight = 0.0;</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">            for (i = 0; i &lt; info.height; i++)</span>
<span class="nc" id="L2130">                weight += info.weightY[i];</span>
<span class="nc bnc" id="L2131" title="All 2 branches missed.">            if (weight &gt; 0.0) {</span>
<span class="nc bnc" id="L2132" title="All 2 branches missed.">                for (i = 0; i &lt; info.height; i++) {</span>
<span class="nc" id="L2133">                    int dy = (int)(( ((double)diffh) * info.weightY[i]) / weight);</span>
<span class="nc" id="L2134">                    info.minHeight[i] += dy;</span>
<span class="nc" id="L2135">                    r.height += dy;</span>
<span class="nc bnc" id="L2136" title="All 2 branches missed.">                    if (info.minHeight[i] &lt; 0) {</span>
<span class="nc" id="L2137">                        r.height -= info.minHeight[i];</span>
<span class="nc" id="L2138">                        info.minHeight[i] = 0;</span>
                    }
                }
            }
<span class="nc" id="L2142">            diffh = parent.height - r.height;</span>
        }

        else {
<span class="nc" id="L2146">            diffh = 0;</span>
        }

        /*
         * DEBUG
         *
         * System.out.println(&quot;Re-adjusted:&quot;);
         * DumpLayoutInfo(info);
         */

        /*
         * Now do the actual layout of the slaves using the layout information
         * that has been collected.
         */

<span class="nc" id="L2161">        info.startx = diffw/2 + insets.left;</span>
<span class="nc" id="L2162">        info.starty = diffh/2 + insets.top;</span>

<span class="nc bnc" id="L2164" title="All 2 branches missed.">        for (compindex = 0 ; compindex &lt; components.length ; compindex++) {</span>
<span class="nc" id="L2165">            comp = components[compindex];</span>
<span class="nc bnc" id="L2166" title="All 2 branches missed.">            if (!comp.isVisible()){</span>
<span class="nc" id="L2167">                continue;</span>
            }
<span class="nc" id="L2169">            constraints = lookupConstraints(comp);</span>

<span class="nc bnc" id="L2171" title="All 2 branches missed.">            if (!rightToLeft) {</span>
<span class="nc" id="L2172">                r.x = info.startx;</span>
<span class="nc bnc" id="L2173" title="All 2 branches missed.">                for(i = 0; i &lt; constraints.tempX; i++)</span>
<span class="nc" id="L2174">                    r.x += info.minWidth[i];</span>
            } else {
<span class="nc" id="L2176">                r.x = parent.width - (diffw/2 + insets.right);</span>
<span class="nc bnc" id="L2177" title="All 2 branches missed.">                for(i = 0; i &lt; constraints.tempX; i++)</span>
<span class="nc" id="L2178">                    r.x -= info.minWidth[i];</span>
            }

<span class="nc" id="L2181">            r.y = info.starty;</span>
<span class="nc bnc" id="L2182" title="All 2 branches missed.">            for(i = 0; i &lt; constraints.tempY; i++)</span>
<span class="nc" id="L2183">                r.y += info.minHeight[i];</span>

<span class="nc" id="L2185">            r.width = 0;</span>
<span class="nc" id="L2186">            for(i = constraints.tempX;</span>
<span class="nc bnc" id="L2187" title="All 2 branches missed.">                i &lt; (constraints.tempX + constraints.tempWidth);</span>
<span class="nc" id="L2188">                i++) {</span>
<span class="nc" id="L2189">                r.width += info.minWidth[i];</span>
            }

<span class="nc" id="L2192">            r.height = 0;</span>
<span class="nc" id="L2193">            for(i = constraints.tempY;</span>
<span class="nc bnc" id="L2194" title="All 2 branches missed.">                i &lt; (constraints.tempY + constraints.tempHeight);</span>
<span class="nc" id="L2195">                i++) {</span>
<span class="nc" id="L2196">                r.height += info.minHeight[i];</span>
            }

<span class="nc" id="L2199">            componentAdjusting = comp;</span>
<span class="nc" id="L2200">            adjustForGravity(constraints, r);</span>

            /* fix for 4408108 - components were being created outside of the container */
            /* fix for 4969409 &quot;-&quot; replaced by &quot;+&quot;  */
<span class="nc bnc" id="L2204" title="All 2 branches missed.">            if (r.x &lt; 0) {</span>
<span class="nc" id="L2205">                r.width += r.x;</span>
<span class="nc" id="L2206">                r.x = 0;</span>
            }

<span class="nc bnc" id="L2209" title="All 2 branches missed.">            if (r.y &lt; 0) {</span>
<span class="nc" id="L2210">                r.height += r.y;</span>
<span class="nc" id="L2211">                r.y = 0;</span>
            }

            /*
             * If the window is too small to be interesting then
             * unmap it.  Otherwise configure it and then make sure
             * it's mapped.
             */

<span class="nc bnc" id="L2220" title="All 4 branches missed.">            if ((r.width &lt;= 0) || (r.height &lt;= 0)) {</span>
<span class="nc" id="L2221">                comp.setBounds(0, 0, 0, 0);</span>
            }
            else {
<span class="nc bnc" id="L2224" title="All 8 branches missed.">                if (comp.x != r.x || comp.y != r.y ||</span>
                    comp.width != r.width || comp.height != r.height) {
<span class="nc" id="L2226">                    comp.setBounds(r.x, r.y, r.width, r.height);</span>
                }
            }
        }
<span class="nc" id="L2230">    }</span>

    // Added for serial backwards compatibility (4348425)
    static final long serialVersionUID = 8838754796412211005L;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>