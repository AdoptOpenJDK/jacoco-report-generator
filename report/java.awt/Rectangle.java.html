<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Rectangle.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">Rectangle.java</span></div><h1>Rectangle.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt;

import java.awt.geom.Rectangle2D;
import java.beans.Transient;

/**
 * A &lt;code&gt;Rectangle&lt;/code&gt; specifies an area in a coordinate space that is
 * enclosed by the &lt;code&gt;Rectangle&lt;/code&gt; object's upper-left point
 * {@code (x,y)}
 * in the coordinate space, its width, and its height.
 * &lt;p&gt;
 * A &lt;code&gt;Rectangle&lt;/code&gt; object's &lt;code&gt;width&lt;/code&gt; and
 * &lt;code&gt;height&lt;/code&gt; are &lt;code&gt;public&lt;/code&gt; fields. The constructors
 * that create a &lt;code&gt;Rectangle&lt;/code&gt;, and the methods that can modify
 * one, do not prevent setting a negative value for width or height.
 * &lt;p&gt;
 * &lt;a name=&quot;Empty&quot;&gt;
 * A {@code Rectangle} whose width or height is exactly zero has location
 * along those axes with zero dimension, but is otherwise considered empty.
 * The {@link #isEmpty} method will return true for such a {@code Rectangle}.
 * Methods which test if an empty {@code Rectangle} contains or intersects
 * a point or rectangle will always return false if either dimension is zero.
 * Methods which combine such a {@code Rectangle} with a point or rectangle
 * will include the location of the {@code Rectangle} on that axis in the
 * result as if the {@link #add(Point)} method were being called.
 * &lt;/a&gt;
 * &lt;p&gt;
 * &lt;a name=&quot;NonExistant&quot;&gt;
 * A {@code Rectangle} whose width or height is negative has neither
 * location nor dimension along those axes with negative dimensions.
 * Such a {@code Rectangle} is treated as non-existant along those axes.
 * Such a {@code Rectangle} is also empty with respect to containment
 * calculations and methods which test if it contains or intersects a
 * point or rectangle will always return false.
 * Methods which combine such a {@code Rectangle} with a point or rectangle
 * will ignore the {@code Rectangle} entirely in generating the result.
 * If two {@code Rectangle} objects are combined and each has a negative
 * dimension, the result will have at least one negative dimension.
 * &lt;/a&gt;
 * &lt;p&gt;
 * Methods which affect only the location of a {@code Rectangle} will
 * operate on its location regardless of whether or not it has a negative
 * or zero dimension along either axis.
 * &lt;p&gt;
 * Note that a {@code Rectangle} constructed with the default no-argument
 * constructor will have dimensions of {@code 0x0} and therefore be empty.
 * That {@code Rectangle} will still have a location of {@code (0,0)} and
 * will contribute that location to the union and add operations.
 * Code attempting to accumulate the bounds of a set of points should
 * therefore initially construct the {@code Rectangle} with a specifically
 * negative width and height or it should use the first point in the set
 * to construct the {@code Rectangle}.
 * For example:
 * &lt;pre&gt;
 *     Rectangle bounds = new Rectangle(0, 0, -1, -1);
 *     for (int i = 0; i &lt; points.length; i++) {
 *         bounds.add(points[i]);
 *     }
 * &lt;/pre&gt;
 * or if we know that the points array contains at least one point:
 * &lt;pre&gt;
 *     Rectangle bounds = new Rectangle(points[0]);
 *     for (int i = 1; i &lt; points.length; i++) {
 *         bounds.add(points[i]);
 *     }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * This class uses 32-bit integers to store its location and dimensions.
 * Frequently operations may produce a result that exceeds the range of
 * a 32-bit integer.
 * The methods will calculate their results in a way that avoids any
 * 32-bit overflow for intermediate results and then choose the best
 * representation to store the final results back into the 32-bit fields
 * which hold the location and dimensions.
 * The location of the result will be stored into the {@link #x} and
 * {@link #y} fields by clipping the true result to the nearest 32-bit value.
 * The values stored into the {@link #width} and {@link #height} dimension
 * fields will be chosen as the 32-bit values that encompass the largest
 * part of the true result as possible.
 * Generally this means that the dimension will be clipped independently
 * to the range of 32-bit integers except that if the location had to be
 * moved to store it into its pair of 32-bit fields then the dimensions
 * will be adjusted relative to the &quot;best representation&quot; of the location.
 * If the true result had a negative dimension and was therefore
 * non-existant along one or both axes, the stored dimensions will be
 * negative numbers in those axes.
 * If the true result had a location that could be represented within
 * the range of 32-bit integers, but zero dimension along one or both
 * axes, then the stored dimensions will be zero in those axes.
 *
 * @author      Sami Shaio
 * @since 1.0
 */
public class Rectangle extends Rectangle2D
    implements Shape, java.io.Serializable
{

    /**
     * The X coordinate of the upper-left corner of the &lt;code&gt;Rectangle&lt;/code&gt;.
     *
     * @serial
     * @see #setLocation(int, int)
     * @see #getLocation()
     * @since 1.0
     */
    public int x;

    /**
     * The Y coordinate of the upper-left corner of the &lt;code&gt;Rectangle&lt;/code&gt;.
     *
     * @serial
     * @see #setLocation(int, int)
     * @see #getLocation()
     * @since 1.0
     */
    public int y;

    /**
     * The width of the &lt;code&gt;Rectangle&lt;/code&gt;.
     * @serial
     * @see #setSize(int, int)
     * @see #getSize()
     * @since 1.0
     */
    public int width;

    /**
     * The height of the &lt;code&gt;Rectangle&lt;/code&gt;.
     *
     * @serial
     * @see #setSize(int, int)
     * @see #getSize()
     * @since 1.0
     */
    public int height;

    /*
     * JDK 1.1 serialVersionUID
     */
     private static final long serialVersionUID = -4345857070255674764L;

    /**
     * Initialize JNI field and method IDs
     */
    private static native void initIDs();

    static {
        /* ensure that the necessary native libraries are loaded */
<span class="nc" id="L174">        Toolkit.loadLibraries();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L176">            initIDs();</span>
        }
<span class="nc" id="L178">    }</span>

    /**
     * Constructs a new &lt;code&gt;Rectangle&lt;/code&gt; whose upper-left corner
     * is at (0,&amp;nbsp;0) in the coordinate space, and whose width and
     * height are both zero.
     */
    public Rectangle() {
<span class="nc" id="L186">        this(0, 0, 0, 0);</span>
<span class="nc" id="L187">    }</span>

    /**
     * Constructs a new &lt;code&gt;Rectangle&lt;/code&gt;, initialized to match
     * the values of the specified &lt;code&gt;Rectangle&lt;/code&gt;.
     * @param r  the &lt;code&gt;Rectangle&lt;/code&gt; from which to copy initial values
     *           to a newly constructed &lt;code&gt;Rectangle&lt;/code&gt;
     * @since 1.1
     */
    public Rectangle(Rectangle r) {
<span class="nc" id="L197">        this(r.x, r.y, r.width, r.height);</span>
<span class="nc" id="L198">    }</span>

    /**
     * Constructs a new &lt;code&gt;Rectangle&lt;/code&gt; whose upper-left corner is
     * specified as
     * {@code (x,y)} and whose width and height
     * are specified by the arguments of the same name.
     * @param     x the specified X coordinate
     * @param     y the specified Y coordinate
     * @param     width    the width of the &lt;code&gt;Rectangle&lt;/code&gt;
     * @param     height   the height of the &lt;code&gt;Rectangle&lt;/code&gt;
     * @since 1.0
     */
<span class="nc" id="L211">    public Rectangle(int x, int y, int width, int height) {</span>
<span class="nc" id="L212">        this.x = x;</span>
<span class="nc" id="L213">        this.y = y;</span>
<span class="nc" id="L214">        this.width = width;</span>
<span class="nc" id="L215">        this.height = height;</span>
<span class="nc" id="L216">    }</span>

    /**
     * Constructs a new &lt;code&gt;Rectangle&lt;/code&gt; whose upper-left corner
     * is at (0,&amp;nbsp;0) in the coordinate space, and whose width and
     * height are specified by the arguments of the same name.
     * @param width the width of the &lt;code&gt;Rectangle&lt;/code&gt;
     * @param height the height of the &lt;code&gt;Rectangle&lt;/code&gt;
     */
    public Rectangle(int width, int height) {
<span class="nc" id="L226">        this(0, 0, width, height);</span>
<span class="nc" id="L227">    }</span>

    /**
     * Constructs a new &lt;code&gt;Rectangle&lt;/code&gt; whose upper-left corner is
     * specified by the {@link Point} argument, and
     * whose width and height are specified by the
     * {@link Dimension} argument.
     * @param p a &lt;code&gt;Point&lt;/code&gt; that is the upper-left corner of
     * the &lt;code&gt;Rectangle&lt;/code&gt;
     * @param d a &lt;code&gt;Dimension&lt;/code&gt;, representing the
     * width and height of the &lt;code&gt;Rectangle&lt;/code&gt;
     */
    public Rectangle(Point p, Dimension d) {
<span class="nc" id="L240">        this(p.x, p.y, d.width, d.height);</span>
<span class="nc" id="L241">    }</span>

    /**
     * Constructs a new &lt;code&gt;Rectangle&lt;/code&gt; whose upper-left corner is the
     * specified &lt;code&gt;Point&lt;/code&gt;, and whose width and height are both zero.
     * @param p a &lt;code&gt;Point&lt;/code&gt; that is the top left corner
     * of the &lt;code&gt;Rectangle&lt;/code&gt;
     */
    public Rectangle(Point p) {
<span class="nc" id="L250">        this(p.x, p.y, 0, 0);</span>
<span class="nc" id="L251">    }</span>

    /**
     * Constructs a new &lt;code&gt;Rectangle&lt;/code&gt; whose top left corner is
     * (0,&amp;nbsp;0) and whose width and height are specified
     * by the &lt;code&gt;Dimension&lt;/code&gt; argument.
     * @param d a &lt;code&gt;Dimension&lt;/code&gt;, specifying width and height
     */
    public Rectangle(Dimension d) {
<span class="nc" id="L260">        this(0, 0, d.width, d.height);</span>
<span class="nc" id="L261">    }</span>

    /**
     * Returns the X coordinate of the bounding &lt;code&gt;Rectangle&lt;/code&gt; in
     * &lt;code&gt;double&lt;/code&gt; precision.
     * @return the X coordinate of the bounding &lt;code&gt;Rectangle&lt;/code&gt;.
     */
    public double getX() {
<span class="nc" id="L269">        return x;</span>
    }

    /**
     * Returns the Y coordinate of the bounding &lt;code&gt;Rectangle&lt;/code&gt; in
     * &lt;code&gt;double&lt;/code&gt; precision.
     * @return the Y coordinate of the bounding &lt;code&gt;Rectangle&lt;/code&gt;.
     */
    public double getY() {
<span class="nc" id="L278">        return y;</span>
    }

    /**
     * Returns the width of the bounding &lt;code&gt;Rectangle&lt;/code&gt; in
     * &lt;code&gt;double&lt;/code&gt; precision.
     * @return the width of the bounding &lt;code&gt;Rectangle&lt;/code&gt;.
     */
    public double getWidth() {
<span class="nc" id="L287">        return width;</span>
    }

    /**
     * Returns the height of the bounding &lt;code&gt;Rectangle&lt;/code&gt; in
     * &lt;code&gt;double&lt;/code&gt; precision.
     * @return the height of the bounding &lt;code&gt;Rectangle&lt;/code&gt;.
     */
    public double getHeight() {
<span class="nc" id="L296">        return height;</span>
    }

    /**
     * Gets the bounding &lt;code&gt;Rectangle&lt;/code&gt; of this &lt;code&gt;Rectangle&lt;/code&gt;.
     * &lt;p&gt;
     * This method is included for completeness, to parallel the
     * &lt;code&gt;getBounds&lt;/code&gt; method of
     * {@link Component}.
     * @return    a new &lt;code&gt;Rectangle&lt;/code&gt;, equal to the
     * bounding &lt;code&gt;Rectangle&lt;/code&gt; for this &lt;code&gt;Rectangle&lt;/code&gt;.
     * @see       java.awt.Component#getBounds
     * @see       #setBounds(Rectangle)
     * @see       #setBounds(int, int, int, int)
     * @since     1.1
     */
    @Transient
    public Rectangle getBounds() {
<span class="nc" id="L314">        return new Rectangle(x, y, width, height);</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public Rectangle2D getBounds2D() {
<span class="nc" id="L322">        return new Rectangle(x, y, width, height);</span>
    }

    /**
     * Sets the bounding &lt;code&gt;Rectangle&lt;/code&gt; of this &lt;code&gt;Rectangle&lt;/code&gt;
     * to match the specified &lt;code&gt;Rectangle&lt;/code&gt;.
     * &lt;p&gt;
     * This method is included for completeness, to parallel the
     * &lt;code&gt;setBounds&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;.
     * @param r the specified &lt;code&gt;Rectangle&lt;/code&gt;
     * @see       #getBounds
     * @see       java.awt.Component#setBounds(java.awt.Rectangle)
     * @since     1.1
     */
    public void setBounds(Rectangle r) {
<span class="nc" id="L337">        setBounds(r.x, r.y, r.width, r.height);</span>
<span class="nc" id="L338">    }</span>

    /**
     * Sets the bounding &lt;code&gt;Rectangle&lt;/code&gt; of this
     * &lt;code&gt;Rectangle&lt;/code&gt; to the specified
     * &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;,
     * and &lt;code&gt;height&lt;/code&gt;.
     * &lt;p&gt;
     * This method is included for completeness, to parallel the
     * &lt;code&gt;setBounds&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;.
     * @param x the new X coordinate for the upper-left
     *                    corner of this &lt;code&gt;Rectangle&lt;/code&gt;
     * @param y the new Y coordinate for the upper-left
     *                    corner of this &lt;code&gt;Rectangle&lt;/code&gt;
     * @param width the new width for this &lt;code&gt;Rectangle&lt;/code&gt;
     * @param height the new height for this &lt;code&gt;Rectangle&lt;/code&gt;
     * @see       #getBounds
     * @see       java.awt.Component#setBounds(int, int, int, int)
     * @since     1.1
     */
    public void setBounds(int x, int y, int width, int height) {
<span class="nc" id="L359">        reshape(x, y, width, height);</span>
<span class="nc" id="L360">    }</span>

    /**
     * Sets the bounds of this {@code Rectangle} to the integer bounds
     * which encompass the specified {@code x}, {@code y}, {@code width},
     * and {@code height}.
     * If the parameters specify a {@code Rectangle} that exceeds the
     * maximum range of integers, the result will be the best
     * representation of the specified {@code Rectangle} intersected
     * with the maximum integer bounds.
     * @param x the X coordinate of the upper-left corner of
     *                  the specified rectangle
     * @param y the Y coordinate of the upper-left corner of
     *                  the specified rectangle
     * @param width the width of the specified rectangle
     * @param height the new height of the specified rectangle
     */
    public void setRect(double x, double y, double width, double height) {
        int newx, newy, neww, newh;

<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (x &gt; 2.0 * Integer.MAX_VALUE) {</span>
            // Too far in positive X direction to represent...
            // We cannot even reach the left side of the specified
            // rectangle even with both x &amp; width set to MAX_VALUE.
            // The intersection with the &quot;maximal integer rectangle&quot;
            // is non-existant so we should use a width &lt; 0.
            // REMIND: Should we try to determine a more &quot;meaningful&quot;
            // adjusted value for neww than just &quot;-1&quot;?
<span class="nc" id="L388">            newx = Integer.MAX_VALUE;</span>
<span class="nc" id="L389">            neww = -1;</span>
        } else {
<span class="nc" id="L391">            newx = clip(x, false);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (width &gt;= 0) width += x-newx;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            neww = clip(width, width &gt;= 0);</span>
        }

<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (y &gt; 2.0 * Integer.MAX_VALUE) {</span>
            // Too far in positive Y direction to represent...
<span class="nc" id="L398">            newy = Integer.MAX_VALUE;</span>
<span class="nc" id="L399">            newh = -1;</span>
        } else {
<span class="nc" id="L401">            newy = clip(y, false);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if (height &gt;= 0) height += y-newy;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            newh = clip(height, height &gt;= 0);</span>
        }

<span class="nc" id="L406">        reshape(newx, newy, neww, newh);</span>
<span class="nc" id="L407">    }</span>
    // Return best integer representation for v, clipped to integer
    // range and floor-ed or ceiling-ed, depending on the boolean.
    private static int clip(double v, boolean doceil) {
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (v &lt;= Integer.MIN_VALUE) {</span>
<span class="nc" id="L412">            return Integer.MIN_VALUE;</span>
        }
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (v &gt;= Integer.MAX_VALUE) {</span>
<span class="nc" id="L415">            return Integer.MAX_VALUE;</span>
        }
<span class="nc bnc" id="L417" title="All 2 branches missed.">        return (int) (doceil ? Math.ceil(v) : Math.floor(v));</span>
    }

    /**
     * Sets the bounding &lt;code&gt;Rectangle&lt;/code&gt; of this
     * &lt;code&gt;Rectangle&lt;/code&gt; to the specified
     * &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;,
     * and &lt;code&gt;height&lt;/code&gt;.
     * &lt;p&gt;
     * @param x the new X coordinate for the upper-left
     *                    corner of this &lt;code&gt;Rectangle&lt;/code&gt;
     * @param y the new Y coordinate for the upper-left
     *                    corner of this &lt;code&gt;Rectangle&lt;/code&gt;
     * @param width the new width for this &lt;code&gt;Rectangle&lt;/code&gt;
     * @param height the new height for this &lt;code&gt;Rectangle&lt;/code&gt;
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setBounds(int, int, int, int)&lt;/code&gt;.
     */
    @Deprecated
    public void reshape(int x, int y, int width, int height) {
<span class="nc" id="L437">        this.x = x;</span>
<span class="nc" id="L438">        this.y = y;</span>
<span class="nc" id="L439">        this.width = width;</span>
<span class="nc" id="L440">        this.height = height;</span>
<span class="nc" id="L441">    }</span>

    /**
     * Returns the location of this &lt;code&gt;Rectangle&lt;/code&gt;.
     * &lt;p&gt;
     * This method is included for completeness, to parallel the
     * &lt;code&gt;getLocation&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;.
     * @return the &lt;code&gt;Point&lt;/code&gt; that is the upper-left corner of
     *                  this &lt;code&gt;Rectangle&lt;/code&gt;.
     * @see       java.awt.Component#getLocation
     * @see       #setLocation(Point)
     * @see       #setLocation(int, int)
     * @since     1.1
     */
    public Point getLocation() {
<span class="nc" id="L456">        return new Point(x, y);</span>
    }

    /**
     * Moves this &lt;code&gt;Rectangle&lt;/code&gt; to the specified location.
     * &lt;p&gt;
     * This method is included for completeness, to parallel the
     * &lt;code&gt;setLocation&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;.
     * @param p the &lt;code&gt;Point&lt;/code&gt; specifying the new location
     *                for this &lt;code&gt;Rectangle&lt;/code&gt;
     * @see       java.awt.Component#setLocation(java.awt.Point)
     * @see       #getLocation
     * @since     1.1
     */
    public void setLocation(Point p) {
<span class="nc" id="L471">        setLocation(p.x, p.y);</span>
<span class="nc" id="L472">    }</span>

    /**
     * Moves this &lt;code&gt;Rectangle&lt;/code&gt; to the specified location.
     * &lt;p&gt;
     * This method is included for completeness, to parallel the
     * &lt;code&gt;setLocation&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;.
     * @param x the X coordinate of the new location
     * @param y the Y coordinate of the new location
     * @see       #getLocation
     * @see       java.awt.Component#setLocation(int, int)
     * @since     1.1
     */
    public void setLocation(int x, int y) {
<span class="nc" id="L486">        move(x, y);</span>
<span class="nc" id="L487">    }</span>

    /**
     * Moves this &lt;code&gt;Rectangle&lt;/code&gt; to the specified location.
     * &lt;p&gt;
     * @param x the X coordinate of the new location
     * @param y the Y coordinate of the new location
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setLocation(int, int)&lt;/code&gt;.
     */
    @Deprecated
    public void move(int x, int y) {
<span class="nc" id="L499">        this.x = x;</span>
<span class="nc" id="L500">        this.y = y;</span>
<span class="nc" id="L501">    }</span>

    /**
     * Translates this &lt;code&gt;Rectangle&lt;/code&gt; the indicated distance,
     * to the right along the X coordinate axis, and
     * downward along the Y coordinate axis.
     * @param dx the distance to move this &lt;code&gt;Rectangle&lt;/code&gt;
     *                 along the X axis
     * @param dy the distance to move this &lt;code&gt;Rectangle&lt;/code&gt;
     *                 along the Y axis
     * @see       java.awt.Rectangle#setLocation(int, int)
     * @see       java.awt.Rectangle#setLocation(java.awt.Point)
     */
    public void translate(int dx, int dy) {
<span class="nc" id="L515">        int oldv = this.x;</span>
<span class="nc" id="L516">        int newv = oldv + dx;</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">        if (dx &lt; 0) {</span>
            // moving leftward
<span class="nc bnc" id="L519" title="All 2 branches missed.">            if (newv &gt; oldv) {</span>
                // negative overflow
                // Only adjust width if it was valid (&gt;= 0).
<span class="nc bnc" id="L522" title="All 2 branches missed.">                if (width &gt;= 0) {</span>
                    // The right edge is now conceptually at
                    // newv+width, but we may move newv to prevent
                    // overflow.  But we want the right edge to
                    // remain at its new location in spite of the
                    // clipping.  Think of the following adjustment
                    // conceptually the same as:
                    // width += newv; newv = MIN_VALUE; width -= newv;
<span class="nc" id="L530">                    width += newv - Integer.MIN_VALUE;</span>
                    // width may go negative if the right edge went past
                    // MIN_VALUE, but it cannot overflow since it cannot
                    // have moved more than MIN_VALUE and any non-negative
                    // number + MIN_VALUE does not overflow.
                }
<span class="nc" id="L536">                newv = Integer.MIN_VALUE;</span>
            }
        } else {
            // moving rightward (or staying still)
<span class="nc bnc" id="L540" title="All 2 branches missed.">            if (newv &lt; oldv) {</span>
                // positive overflow
<span class="nc bnc" id="L542" title="All 2 branches missed.">                if (width &gt;= 0) {</span>
                    // Conceptually the same as:
                    // width += newv; newv = MAX_VALUE; width -= newv;
<span class="nc" id="L545">                    width += newv - Integer.MAX_VALUE;</span>
                    // With large widths and large displacements
                    // we may overflow so we need to check it.
<span class="nc bnc" id="L548" title="All 2 branches missed.">                    if (width &lt; 0) width = Integer.MAX_VALUE;</span>
                }
<span class="nc" id="L550">                newv = Integer.MAX_VALUE;</span>
            }
        }
<span class="nc" id="L553">        this.x = newv;</span>

<span class="nc" id="L555">        oldv = this.y;</span>
<span class="nc" id="L556">        newv = oldv + dy;</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">        if (dy &lt; 0) {</span>
            // moving upward
<span class="nc bnc" id="L559" title="All 2 branches missed.">            if (newv &gt; oldv) {</span>
                // negative overflow
<span class="nc bnc" id="L561" title="All 2 branches missed.">                if (height &gt;= 0) {</span>
<span class="nc" id="L562">                    height += newv - Integer.MIN_VALUE;</span>
                    // See above comment about no overflow in this case
                }
<span class="nc" id="L565">                newv = Integer.MIN_VALUE;</span>
            }
        } else {
            // moving downward (or staying still)
<span class="nc bnc" id="L569" title="All 2 branches missed.">            if (newv &lt; oldv) {</span>
                // positive overflow
<span class="nc bnc" id="L571" title="All 2 branches missed.">                if (height &gt;= 0) {</span>
<span class="nc" id="L572">                    height += newv - Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">                    if (height &lt; 0) height = Integer.MAX_VALUE;</span>
                }
<span class="nc" id="L575">                newv = Integer.MAX_VALUE;</span>
            }
        }
<span class="nc" id="L578">        this.y = newv;</span>
<span class="nc" id="L579">    }</span>

    /**
     * Gets the size of this &lt;code&gt;Rectangle&lt;/code&gt;, represented by
     * the returned &lt;code&gt;Dimension&lt;/code&gt;.
     * &lt;p&gt;
     * This method is included for completeness, to parallel the
     * &lt;code&gt;getSize&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;.
     * @return a &lt;code&gt;Dimension&lt;/code&gt;, representing the size of
     *            this &lt;code&gt;Rectangle&lt;/code&gt;.
     * @see       java.awt.Component#getSize
     * @see       #setSize(Dimension)
     * @see       #setSize(int, int)
     * @since     1.1
     */
    public Dimension getSize() {
<span class="nc" id="L595">        return new Dimension(width, height);</span>
    }

    /**
     * Sets the size of this &lt;code&gt;Rectangle&lt;/code&gt; to match the
     * specified &lt;code&gt;Dimension&lt;/code&gt;.
     * &lt;p&gt;
     * This method is included for completeness, to parallel the
     * &lt;code&gt;setSize&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;.
     * @param d the new size for the &lt;code&gt;Dimension&lt;/code&gt; object
     * @see       java.awt.Component#setSize(java.awt.Dimension)
     * @see       #getSize
     * @since     1.1
     */
    public void setSize(Dimension d) {
<span class="nc" id="L610">        setSize(d.width, d.height);</span>
<span class="nc" id="L611">    }</span>

    /**
     * Sets the size of this &lt;code&gt;Rectangle&lt;/code&gt; to the specified
     * width and height.
     * &lt;p&gt;
     * This method is included for completeness, to parallel the
     * &lt;code&gt;setSize&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;.
     * @param width the new width for this &lt;code&gt;Rectangle&lt;/code&gt;
     * @param height the new height for this &lt;code&gt;Rectangle&lt;/code&gt;
     * @see       java.awt.Component#setSize(int, int)
     * @see       #getSize
     * @since     1.1
     */
    public void setSize(int width, int height) {
<span class="nc" id="L626">        resize(width, height);</span>
<span class="nc" id="L627">    }</span>

    /**
     * Sets the size of this &lt;code&gt;Rectangle&lt;/code&gt; to the specified
     * width and height.
     * &lt;p&gt;
     * @param width the new width for this &lt;code&gt;Rectangle&lt;/code&gt;
     * @param height the new height for this &lt;code&gt;Rectangle&lt;/code&gt;
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setSize(int, int)&lt;/code&gt;.
     */
    @Deprecated
    public void resize(int width, int height) {
<span class="nc" id="L640">        this.width = width;</span>
<span class="nc" id="L641">        this.height = height;</span>
<span class="nc" id="L642">    }</span>

    /**
     * Checks whether or not this &lt;code&gt;Rectangle&lt;/code&gt; contains the
     * specified &lt;code&gt;Point&lt;/code&gt;.
     * @param p the &lt;code&gt;Point&lt;/code&gt; to test
     * @return    &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;Point&lt;/code&gt;
     *            is inside this &lt;code&gt;Rectangle&lt;/code&gt;;
     *            &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since     1.1
     */
    public boolean contains(Point p) {
<span class="nc" id="L654">        return contains(p.x, p.y);</span>
    }

    /**
     * Checks whether or not this &lt;code&gt;Rectangle&lt;/code&gt; contains the
     * point at the specified location {@code (x,y)}.
     *
     * @param  x the specified X coordinate
     * @param  y the specified Y coordinate
     * @return    &lt;code&gt;true&lt;/code&gt; if the point
     *            {@code (x,y)} is inside this
     *            &lt;code&gt;Rectangle&lt;/code&gt;;
     *            &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since     1.1
     */
    public boolean contains(int x, int y) {
<span class="nc" id="L670">        return inside(x, y);</span>
    }

    /**
     * Checks whether or not this &lt;code&gt;Rectangle&lt;/code&gt; entirely contains
     * the specified &lt;code&gt;Rectangle&lt;/code&gt;.
     *
     * @param     r   the specified &lt;code&gt;Rectangle&lt;/code&gt;
     * @return    &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Rectangle&lt;/code&gt;
     *            is contained entirely inside this &lt;code&gt;Rectangle&lt;/code&gt;;
     *            &lt;code&gt;false&lt;/code&gt; otherwise
     * @since     1.2
     */
    public boolean contains(Rectangle r) {
<span class="nc" id="L684">        return contains(r.x, r.y, r.width, r.height);</span>
    }

    /**
     * Checks whether this &lt;code&gt;Rectangle&lt;/code&gt; entirely contains
     * the &lt;code&gt;Rectangle&lt;/code&gt;
     * at the specified location {@code (X,Y)} with the
     * specified dimensions {@code (W,H)}.
     * @param     X the specified X coordinate
     * @param     Y the specified Y coordinate
     * @param     W   the width of the &lt;code&gt;Rectangle&lt;/code&gt;
     * @param     H   the height of the &lt;code&gt;Rectangle&lt;/code&gt;
     * @return    &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Rectangle&lt;/code&gt; specified by
     *            {@code (X, Y, W, H)}
     *            is entirely enclosed inside this &lt;code&gt;Rectangle&lt;/code&gt;;
     *            &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since     1.1
     */
    public boolean contains(int X, int Y, int W, int H) {
<span class="nc" id="L703">        int w = this.width;</span>
<span class="nc" id="L704">        int h = this.height;</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">        if ((w | h | W | H) &lt; 0) {</span>
            // At least one of the dimensions is negative...
<span class="nc" id="L707">            return false;</span>
        }
        // Note: if any dimension is zero, tests below must return false...
<span class="nc" id="L710">        int x = this.x;</span>
<span class="nc" id="L711">        int y = this.y;</span>
<span class="nc bnc" id="L712" title="All 4 branches missed.">        if (X &lt; x || Y &lt; y) {</span>
<span class="nc" id="L713">            return false;</span>
        }
<span class="nc" id="L715">        w += x;</span>
<span class="nc" id="L716">        W += X;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (W &lt;= X) {</span>
            // X+W overflowed or W was zero, return false if...
            // either original w or W was zero or
            // x+w did not overflow or
            // the overflowed x+w is smaller than the overflowed X+W
<span class="nc bnc" id="L722" title="All 4 branches missed.">            if (w &gt;= x || W &gt; w) return false;</span>
        } else {
            // X+W did not overflow and W was not zero, return false if...
            // original w was zero or
            // x+w did not overflow and x+w is smaller than X+W
<span class="nc bnc" id="L727" title="All 4 branches missed.">            if (w &gt;= x &amp;&amp; W &gt; w) return false;</span>
        }
<span class="nc" id="L729">        h += y;</span>
<span class="nc" id="L730">        H += Y;</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (H &lt;= Y) {</span>
<span class="nc bnc" id="L732" title="All 4 branches missed.">            if (h &gt;= y || H &gt; h) return false;</span>
        } else {
<span class="nc bnc" id="L734" title="All 4 branches missed.">            if (h &gt;= y &amp;&amp; H &gt; h) return false;</span>
        }
<span class="nc" id="L736">        return true;</span>
    }

    /**
     * Checks whether or not this &lt;code&gt;Rectangle&lt;/code&gt; contains the
     * point at the specified location {@code (X,Y)}.
     *
     * @param  X the specified X coordinate
     * @param  Y the specified Y coordinate
     * @return    &lt;code&gt;true&lt;/code&gt; if the point
     *            {@code (X,Y)} is inside this
     *            &lt;code&gt;Rectangle&lt;/code&gt;;
     *            &lt;code&gt;false&lt;/code&gt; otherwise.
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;contains(int, int)&lt;/code&gt;.
     */
    @Deprecated
    public boolean inside(int X, int Y) {
<span class="nc" id="L754">        int w = this.width;</span>
<span class="nc" id="L755">        int h = this.height;</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">        if ((w | h) &lt; 0) {</span>
            // At least one of the dimensions is negative...
<span class="nc" id="L758">            return false;</span>
        }
        // Note: if either dimension is zero, tests below must return false...
<span class="nc" id="L761">        int x = this.x;</span>
<span class="nc" id="L762">        int y = this.y;</span>
<span class="nc bnc" id="L763" title="All 4 branches missed.">        if (X &lt; x || Y &lt; y) {</span>
<span class="nc" id="L764">            return false;</span>
        }
<span class="nc" id="L766">        w += x;</span>
<span class="nc" id="L767">        h += y;</span>
        //    overflow || intersect
<span class="nc bnc" id="L769" title="All 8 branches missed.">        return ((w &lt; x || w &gt; X) &amp;&amp;</span>
                (h &lt; y || h &gt; Y));
    }

    /**
     * Determines whether or not this &lt;code&gt;Rectangle&lt;/code&gt; and the specified
     * &lt;code&gt;Rectangle&lt;/code&gt; intersect. Two rectangles intersect if
     * their intersection is nonempty.
     *
     * @param r the specified &lt;code&gt;Rectangle&lt;/code&gt;
     * @return    &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;Rectangle&lt;/code&gt;
     *            and this &lt;code&gt;Rectangle&lt;/code&gt; intersect;
     *            &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean intersects(Rectangle r) {
<span class="nc" id="L784">        int tw = this.width;</span>
<span class="nc" id="L785">        int th = this.height;</span>
<span class="nc" id="L786">        int rw = r.width;</span>
<span class="nc" id="L787">        int rh = r.height;</span>
<span class="nc bnc" id="L788" title="All 8 branches missed.">        if (rw &lt;= 0 || rh &lt;= 0 || tw &lt;= 0 || th &lt;= 0) {</span>
<span class="nc" id="L789">            return false;</span>
        }
<span class="nc" id="L791">        int tx = this.x;</span>
<span class="nc" id="L792">        int ty = this.y;</span>
<span class="nc" id="L793">        int rx = r.x;</span>
<span class="nc" id="L794">        int ry = r.y;</span>
<span class="nc" id="L795">        rw += rx;</span>
<span class="nc" id="L796">        rh += ry;</span>
<span class="nc" id="L797">        tw += tx;</span>
<span class="nc" id="L798">        th += ty;</span>
        //      overflow || intersect
<span class="nc bnc" id="L800" title="All 16 branches missed.">        return ((rw &lt; rx || rw &gt; tx) &amp;&amp;</span>
                (rh &lt; ry || rh &gt; ty) &amp;&amp;
                (tw &lt; tx || tw &gt; rx) &amp;&amp;
                (th &lt; ty || th &gt; ry));
    }

    /**
     * Computes the intersection of this &lt;code&gt;Rectangle&lt;/code&gt; with the
     * specified &lt;code&gt;Rectangle&lt;/code&gt;. Returns a new &lt;code&gt;Rectangle&lt;/code&gt;
     * that represents the intersection of the two rectangles.
     * If the two rectangles do not intersect, the result will be
     * an empty rectangle.
     *
     * @param     r   the specified &lt;code&gt;Rectangle&lt;/code&gt;
     * @return    the largest &lt;code&gt;Rectangle&lt;/code&gt; contained in both the
     *            specified &lt;code&gt;Rectangle&lt;/code&gt; and in
     *            this &lt;code&gt;Rectangle&lt;/code&gt;; or if the rectangles
     *            do not intersect, an empty rectangle.
     */
    public Rectangle intersection(Rectangle r) {
<span class="nc" id="L820">        int tx1 = this.x;</span>
<span class="nc" id="L821">        int ty1 = this.y;</span>
<span class="nc" id="L822">        int rx1 = r.x;</span>
<span class="nc" id="L823">        int ry1 = r.y;</span>
<span class="nc" id="L824">        long tx2 = tx1; tx2 += this.width;</span>
<span class="nc" id="L825">        long ty2 = ty1; ty2 += this.height;</span>
<span class="nc" id="L826">        long rx2 = rx1; rx2 += r.width;</span>
<span class="nc" id="L827">        long ry2 = ry1; ry2 += r.height;</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">        if (tx1 &lt; rx1) tx1 = rx1;</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">        if (ty1 &lt; ry1) ty1 = ry1;</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (tx2 &gt; rx2) tx2 = rx2;</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">        if (ty2 &gt; ry2) ty2 = ry2;</span>
<span class="nc" id="L832">        tx2 -= tx1;</span>
<span class="nc" id="L833">        ty2 -= ty1;</span>
        // tx2,ty2 will never overflow (they will never be
        // larger than the smallest of the two source w,h)
        // they might underflow, though...
<span class="nc bnc" id="L837" title="All 2 branches missed.">        if (tx2 &lt; Integer.MIN_VALUE) tx2 = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">        if (ty2 &lt; Integer.MIN_VALUE) ty2 = Integer.MIN_VALUE;</span>
<span class="nc" id="L839">        return new Rectangle(tx1, ty1, (int) tx2, (int) ty2);</span>
    }

    /**
     * Computes the union of this &lt;code&gt;Rectangle&lt;/code&gt; with the
     * specified &lt;code&gt;Rectangle&lt;/code&gt;. Returns a new
     * &lt;code&gt;Rectangle&lt;/code&gt; that
     * represents the union of the two rectangles.
     * &lt;p&gt;
     * If either {@code Rectangle} has any dimension less than zero
     * the rules for &lt;a href=#NonExistant&gt;non-existant&lt;/a&gt; rectangles
     * apply.
     * If only one has a dimension less than zero, then the result
     * will be a copy of the other {@code Rectangle}.
     * If both have dimension less than zero, then the result will
     * have at least one dimension less than zero.
     * &lt;p&gt;
     * If the resulting {@code Rectangle} would have a dimension
     * too large to be expressed as an {@code int}, the result
     * will have a dimension of {@code Integer.MAX_VALUE} along
     * that dimension.
     * @param r the specified &lt;code&gt;Rectangle&lt;/code&gt;
     * @return    the smallest &lt;code&gt;Rectangle&lt;/code&gt; containing both
     *            the specified &lt;code&gt;Rectangle&lt;/code&gt; and this
     *            &lt;code&gt;Rectangle&lt;/code&gt;.
     */
    public Rectangle union(Rectangle r) {
<span class="nc" id="L866">        long tx2 = this.width;</span>
<span class="nc" id="L867">        long ty2 = this.height;</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">        if ((tx2 | ty2) &lt; 0) {</span>
            // This rectangle has negative dimensions...
            // If r has non-negative dimensions then it is the answer.
            // If r is non-existant (has a negative dimension), then both
            // are non-existant and we can return any non-existant rectangle
            // as an answer.  Thus, returning r meets that criterion.
            // Either way, r is our answer.
<span class="nc" id="L875">            return new Rectangle(r);</span>
        }
<span class="nc" id="L877">        long rx2 = r.width;</span>
<span class="nc" id="L878">        long ry2 = r.height;</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">        if ((rx2 | ry2) &lt; 0) {</span>
<span class="nc" id="L880">            return new Rectangle(this);</span>
        }
<span class="nc" id="L882">        int tx1 = this.x;</span>
<span class="nc" id="L883">        int ty1 = this.y;</span>
<span class="nc" id="L884">        tx2 += tx1;</span>
<span class="nc" id="L885">        ty2 += ty1;</span>
<span class="nc" id="L886">        int rx1 = r.x;</span>
<span class="nc" id="L887">        int ry1 = r.y;</span>
<span class="nc" id="L888">        rx2 += rx1;</span>
<span class="nc" id="L889">        ry2 += ry1;</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">        if (tx1 &gt; rx1) tx1 = rx1;</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (ty1 &gt; ry1) ty1 = ry1;</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">        if (tx2 &lt; rx2) tx2 = rx2;</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">        if (ty2 &lt; ry2) ty2 = ry2;</span>
<span class="nc" id="L894">        tx2 -= tx1;</span>
<span class="nc" id="L895">        ty2 -= ty1;</span>
        // tx2,ty2 will never underflow since both original rectangles
        // were already proven to be non-empty
        // they might overflow, though...
<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (tx2 &gt; Integer.MAX_VALUE) tx2 = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (ty2 &gt; Integer.MAX_VALUE) ty2 = Integer.MAX_VALUE;</span>
<span class="nc" id="L901">        return new Rectangle(tx1, ty1, (int) tx2, (int) ty2);</span>
    }

    /**
     * Adds a point, specified by the integer arguments {@code newx,newy}
     * to the bounds of this {@code Rectangle}.
     * &lt;p&gt;
     * If this {@code Rectangle} has any dimension less than zero,
     * the rules for &lt;a href=#NonExistant&gt;non-existant&lt;/a&gt;
     * rectangles apply.
     * In that case, the new bounds of this {@code Rectangle} will
     * have a location equal to the specified coordinates and
     * width and height equal to zero.
     * &lt;p&gt;
     * After adding a point, a call to &lt;code&gt;contains&lt;/code&gt; with the
     * added point as an argument does not necessarily return
     * &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;contains&lt;/code&gt; method does not
     * return &lt;code&gt;true&lt;/code&gt; for points on the right or bottom
     * edges of a &lt;code&gt;Rectangle&lt;/code&gt;. Therefore, if the added point
     * falls on the right or bottom edge of the enlarged
     * &lt;code&gt;Rectangle&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt; returns
     * &lt;code&gt;false&lt;/code&gt; for that point.
     * If the specified point must be contained within the new
     * {@code Rectangle}, a 1x1 rectangle should be added instead:
     * &lt;pre&gt;
     *     r.add(newx, newy, 1, 1);
     * &lt;/pre&gt;
     * @param newx the X coordinate of the new point
     * @param newy the Y coordinate of the new point
     */
    public void add(int newx, int newy) {
<span class="nc bnc" id="L932" title="All 2 branches missed.">        if ((width | height) &lt; 0) {</span>
<span class="nc" id="L933">            this.x = newx;</span>
<span class="nc" id="L934">            this.y = newy;</span>
<span class="nc" id="L935">            this.width = this.height = 0;</span>
<span class="nc" id="L936">            return;</span>
        }
<span class="nc" id="L938">        int x1 = this.x;</span>
<span class="nc" id="L939">        int y1 = this.y;</span>
<span class="nc" id="L940">        long x2 = this.width;</span>
<span class="nc" id="L941">        long y2 = this.height;</span>
<span class="nc" id="L942">        x2 += x1;</span>
<span class="nc" id="L943">        y2 += y1;</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">        if (x1 &gt; newx) x1 = newx;</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (y1 &gt; newy) y1 = newy;</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if (x2 &lt; newx) x2 = newx;</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">        if (y2 &lt; newy) y2 = newy;</span>
<span class="nc" id="L948">        x2 -= x1;</span>
<span class="nc" id="L949">        y2 -= y1;</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">        if (x2 &gt; Integer.MAX_VALUE) x2 = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">        if (y2 &gt; Integer.MAX_VALUE) y2 = Integer.MAX_VALUE;</span>
<span class="nc" id="L952">        reshape(x1, y1, (int) x2, (int) y2);</span>
<span class="nc" id="L953">    }</span>

    /**
     * Adds the specified {@code Point} to the bounds of this
     * {@code Rectangle}.
     * &lt;p&gt;
     * If this {@code Rectangle} has any dimension less than zero,
     * the rules for &lt;a href=#NonExistant&gt;non-existant&lt;/a&gt;
     * rectangles apply.
     * In that case, the new bounds of this {@code Rectangle} will
     * have a location equal to the coordinates of the specified
     * {@code Point} and width and height equal to zero.
     * &lt;p&gt;
     * After adding a &lt;code&gt;Point&lt;/code&gt;, a call to &lt;code&gt;contains&lt;/code&gt;
     * with the added &lt;code&gt;Point&lt;/code&gt; as an argument does not
     * necessarily return &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;contains&lt;/code&gt;
     * method does not return &lt;code&gt;true&lt;/code&gt; for points on the right
     * or bottom edges of a &lt;code&gt;Rectangle&lt;/code&gt;. Therefore if the added
     * &lt;code&gt;Point&lt;/code&gt; falls on the right or bottom edge of the
     * enlarged &lt;code&gt;Rectangle&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt; returns
     * &lt;code&gt;false&lt;/code&gt; for that &lt;code&gt;Point&lt;/code&gt;.
     * If the specified point must be contained within the new
     * {@code Rectangle}, a 1x1 rectangle should be added instead:
     * &lt;pre&gt;
     *     r.add(pt.x, pt.y, 1, 1);
     * &lt;/pre&gt;
     * @param pt the new &lt;code&gt;Point&lt;/code&gt; to add to this
     *           &lt;code&gt;Rectangle&lt;/code&gt;
     */
    public void add(Point pt) {
<span class="nc" id="L983">        add(pt.x, pt.y);</span>
<span class="nc" id="L984">    }</span>

    /**
     * Adds a &lt;code&gt;Rectangle&lt;/code&gt; to this &lt;code&gt;Rectangle&lt;/code&gt;.
     * The resulting &lt;code&gt;Rectangle&lt;/code&gt; is the union of the two
     * rectangles.
     * &lt;p&gt;
     * If either {@code Rectangle} has any dimension less than 0, the
     * result will have the dimensions of the other {@code Rectangle}.
     * If both {@code Rectangle}s have at least one dimension less
     * than 0, the result will have at least one dimension less than 0.
     * &lt;p&gt;
     * If either {@code Rectangle} has one or both dimensions equal
     * to 0, the result along those axes with 0 dimensions will be
     * equivalent to the results obtained by adding the corresponding
     * origin coordinate to the result rectangle along that axis,
     * similar to the operation of the {@link #add(Point)} method,
     * but contribute no further dimension beyond that.
     * &lt;p&gt;
     * If the resulting {@code Rectangle} would have a dimension
     * too large to be expressed as an {@code int}, the result
     * will have a dimension of {@code Integer.MAX_VALUE} along
     * that dimension.
     * @param  r the specified &lt;code&gt;Rectangle&lt;/code&gt;
     */
    public void add(Rectangle r) {
<span class="nc" id="L1010">        long tx2 = this.width;</span>
<span class="nc" id="L1011">        long ty2 = this.height;</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">        if ((tx2 | ty2) &lt; 0) {</span>
<span class="nc" id="L1013">            reshape(r.x, r.y, r.width, r.height);</span>
        }
<span class="nc" id="L1015">        long rx2 = r.width;</span>
<span class="nc" id="L1016">        long ry2 = r.height;</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">        if ((rx2 | ry2) &lt; 0) {</span>
<span class="nc" id="L1018">            return;</span>
        }
<span class="nc" id="L1020">        int tx1 = this.x;</span>
<span class="nc" id="L1021">        int ty1 = this.y;</span>
<span class="nc" id="L1022">        tx2 += tx1;</span>
<span class="nc" id="L1023">        ty2 += ty1;</span>
<span class="nc" id="L1024">        int rx1 = r.x;</span>
<span class="nc" id="L1025">        int ry1 = r.y;</span>
<span class="nc" id="L1026">        rx2 += rx1;</span>
<span class="nc" id="L1027">        ry2 += ry1;</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">        if (tx1 &gt; rx1) tx1 = rx1;</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        if (ty1 &gt; ry1) ty1 = ry1;</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (tx2 &lt; rx2) tx2 = rx2;</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        if (ty2 &lt; ry2) ty2 = ry2;</span>
<span class="nc" id="L1032">        tx2 -= tx1;</span>
<span class="nc" id="L1033">        ty2 -= ty1;</span>
        // tx2,ty2 will never underflow since both original
        // rectangles were non-empty
        // they might overflow, though...
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        if (tx2 &gt; Integer.MAX_VALUE) tx2 = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        if (ty2 &gt; Integer.MAX_VALUE) ty2 = Integer.MAX_VALUE;</span>
<span class="nc" id="L1039">        reshape(tx1, ty1, (int) tx2, (int) ty2);</span>
<span class="nc" id="L1040">    }</span>

    /**
     * Resizes the &lt;code&gt;Rectangle&lt;/code&gt; both horizontally and vertically.
     * &lt;p&gt;
     * This method modifies the &lt;code&gt;Rectangle&lt;/code&gt; so that it is
     * &lt;code&gt;h&lt;/code&gt; units larger on both the left and right side,
     * and &lt;code&gt;v&lt;/code&gt; units larger at both the top and bottom.
     * &lt;p&gt;
     * The new &lt;code&gt;Rectangle&lt;/code&gt; has {@code (x - h, y - v)}
     * as its upper-left corner,
     * width of {@code (width + 2h)},
     * and a height of {@code (height + 2v)}.
     * &lt;p&gt;
     * If negative values are supplied for &lt;code&gt;h&lt;/code&gt; and
     * &lt;code&gt;v&lt;/code&gt;, the size of the &lt;code&gt;Rectangle&lt;/code&gt;
     * decreases accordingly.
     * The {@code grow} method will check for integer overflow
     * and underflow, but does not check whether the resulting
     * values of {@code width} and {@code height} grow
     * from negative to non-negative or shrink from non-negative
     * to negative.
     * @param h the horizontal expansion
     * @param v the vertical expansion
     */
    public void grow(int h, int v) {
<span class="nc" id="L1066">        long x0 = this.x;</span>
<span class="nc" id="L1067">        long y0 = this.y;</span>
<span class="nc" id="L1068">        long x1 = this.width;</span>
<span class="nc" id="L1069">        long y1 = this.height;</span>
<span class="nc" id="L1070">        x1 += x0;</span>
<span class="nc" id="L1071">        y1 += y0;</span>

<span class="nc" id="L1073">        x0 -= h;</span>
<span class="nc" id="L1074">        y0 -= v;</span>
<span class="nc" id="L1075">        x1 += h;</span>
<span class="nc" id="L1076">        y1 += v;</span>

<span class="nc bnc" id="L1078" title="All 2 branches missed.">        if (x1 &lt; x0) {</span>
            // Non-existant in X direction
            // Final width must remain negative so subtract x0 before
            // it is clipped so that we avoid the risk that the clipping
            // of x0 will reverse the ordering of x0 and x1.
<span class="nc" id="L1083">            x1 -= x0;</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">            if (x1 &lt; Integer.MIN_VALUE) x1 = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">            if (x0 &lt; Integer.MIN_VALUE) x0 = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">            else if (x0 &gt; Integer.MAX_VALUE) x0 = Integer.MAX_VALUE;</span>
        } else { // (x1 &gt;= x0)
            // Clip x0 before we subtract it from x1 in case the clipping
            // affects the representable area of the rectangle.
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            if (x0 &lt; Integer.MIN_VALUE) x0 = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">            else if (x0 &gt; Integer.MAX_VALUE) x0 = Integer.MAX_VALUE;</span>
<span class="nc" id="L1092">            x1 -= x0;</span>
            // The only way x1 can be negative now is if we clipped
            // x0 against MIN and x1 is less than MIN - in which case
            // we want to leave the width negative since the result
            // did not intersect the representable area.
<span class="nc bnc" id="L1097" title="All 2 branches missed.">            if (x1 &lt; Integer.MIN_VALUE) x1 = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">            else if (x1 &gt; Integer.MAX_VALUE) x1 = Integer.MAX_VALUE;</span>
        }

<span class="nc bnc" id="L1101" title="All 2 branches missed.">        if (y1 &lt; y0) {</span>
            // Non-existant in Y direction
<span class="nc" id="L1103">            y1 -= y0;</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">            if (y1 &lt; Integer.MIN_VALUE) y1 = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">            if (y0 &lt; Integer.MIN_VALUE) y0 = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            else if (y0 &gt; Integer.MAX_VALUE) y0 = Integer.MAX_VALUE;</span>
        } else { // (y1 &gt;= y0)
<span class="nc bnc" id="L1108" title="All 2 branches missed.">            if (y0 &lt; Integer.MIN_VALUE) y0 = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">            else if (y0 &gt; Integer.MAX_VALUE) y0 = Integer.MAX_VALUE;</span>
<span class="nc" id="L1110">            y1 -= y0;</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">            if (y1 &lt; Integer.MIN_VALUE) y1 = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">            else if (y1 &gt; Integer.MAX_VALUE) y1 = Integer.MAX_VALUE;</span>
        }

<span class="nc" id="L1115">        reshape((int) x0, (int) y0, (int) x1, (int) y1);</span>
<span class="nc" id="L1116">    }</span>

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public boolean isEmpty() {
<span class="nc bnc" id="L1123" title="All 4 branches missed.">        return (width &lt;= 0) || (height &lt;= 0);</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public int outcode(double x, double y) {
        /*
         * Note on casts to double below.  If the arithmetic of
         * x+w or y+h is done in int, then we may get integer
         * overflow. By converting to double before the addition
         * we force the addition to be carried out in double to
         * avoid overflow in the comparison.
         *
         * See bug 4320890 for problems that this can cause.
         */
<span class="nc" id="L1140">        int out = 0;</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">        if (this.width &lt;= 0) {</span>
<span class="nc" id="L1142">            out |= OUT_LEFT | OUT_RIGHT;</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        } else if (x &lt; this.x) {</span>
<span class="nc" id="L1144">            out |= OUT_LEFT;</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        } else if (x &gt; this.x + (double) this.width) {</span>
<span class="nc" id="L1146">            out |= OUT_RIGHT;</span>
        }
<span class="nc bnc" id="L1148" title="All 2 branches missed.">        if (this.height &lt;= 0) {</span>
<span class="nc" id="L1149">            out |= OUT_TOP | OUT_BOTTOM;</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">        } else if (y &lt; this.y) {</span>
<span class="nc" id="L1151">            out |= OUT_TOP;</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">        } else if (y &gt; this.y + (double) this.height) {</span>
<span class="nc" id="L1153">            out |= OUT_BOTTOM;</span>
        }
<span class="nc" id="L1155">        return out;</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public Rectangle2D createIntersection(Rectangle2D r) {
<span class="nc bnc" id="L1163" title="All 2 branches missed.">        if (r instanceof Rectangle) {</span>
<span class="nc" id="L1164">            return intersection((Rectangle) r);</span>
        }
<span class="nc" id="L1166">        Rectangle2D dest = new Rectangle2D.Double();</span>
<span class="nc" id="L1167">        Rectangle2D.intersect(this, r, dest);</span>
<span class="nc" id="L1168">        return dest;</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public Rectangle2D createUnion(Rectangle2D r) {
<span class="nc bnc" id="L1176" title="All 2 branches missed.">        if (r instanceof Rectangle) {</span>
<span class="nc" id="L1177">            return union((Rectangle) r);</span>
        }
<span class="nc" id="L1179">        Rectangle2D dest = new Rectangle2D.Double();</span>
<span class="nc" id="L1180">        Rectangle2D.union(this, r, dest);</span>
<span class="nc" id="L1181">        return dest;</span>
    }

    /**
     * Checks whether two rectangles are equal.
     * &lt;p&gt;
     * The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not
     * &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;Rectangle&lt;/code&gt; object that has the
     * same upper-left corner, width, and height as
     * this &lt;code&gt;Rectangle&lt;/code&gt;.
     * @param obj the &lt;code&gt;Object&lt;/code&gt; to compare with
     *                this &lt;code&gt;Rectangle&lt;/code&gt;
     * @return    &lt;code&gt;true&lt;/code&gt; if the objects are equal;
     *            &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L1197" title="All 2 branches missed.">        if (obj instanceof Rectangle) {</span>
<span class="nc" id="L1198">            Rectangle r = (Rectangle)obj;</span>
<span class="nc bnc" id="L1199" title="All 8 branches missed.">            return ((x == r.x) &amp;&amp;</span>
                    (y == r.y) &amp;&amp;
                    (width == r.width) &amp;&amp;
                    (height == r.height));
        }
<span class="nc" id="L1204">        return super.equals(obj);</span>
    }

    /**
     * Returns a &lt;code&gt;String&lt;/code&gt; representing this
     * &lt;code&gt;Rectangle&lt;/code&gt; and its values.
     * @return a &lt;code&gt;String&lt;/code&gt; representing this
     *               &lt;code&gt;Rectangle&lt;/code&gt; object's coordinate and size values.
     */
    public String toString() {
<span class="nc" id="L1214">        return getClass().getName() + &quot;[x=&quot; + x + &quot;,y=&quot; + y + &quot;,width=&quot; + width + &quot;,height=&quot; + height + &quot;]&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>