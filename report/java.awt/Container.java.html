<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Container.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">Container.java</span></div><h1>Container.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt;

import java.awt.dnd.DropTarget;

import java.awt.event.*;

import java.awt.peer.ContainerPeer;
import java.awt.peer.ComponentPeer;
import java.awt.peer.LightweightPeer;

import java.beans.PropertyChangeListener;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamField;
import java.io.PrintStream;
import java.io.PrintWriter;

import java.security.AccessController;

import java.util.Arrays;
import java.util.EventListener;
import java.util.HashSet;
import java.util.Set;

import javax.accessibility.*;

import sun.util.logging.PlatformLogger;

import sun.awt.AppContext;
import sun.awt.AWTAccessor;
import sun.awt.CausedFocusEvent;
import sun.awt.PeerEvent;
import sun.awt.SunToolkit;

import sun.awt.dnd.SunDropTargetEvent;

import sun.java2d.pipe.Region;

import sun.security.action.GetBooleanAction;

/**
 * A generic Abstract Window Toolkit(AWT) container object is a component
 * that can contain other AWT components.
 * &lt;p&gt;
 * Components added to a container are tracked in a list.  The order
 * of the list will define the components' front-to-back stacking order
 * within the container.  If no index is specified when adding a
 * component to a container, it will be added to the end of the list
 * (and hence to the bottom of the stacking order).
 * &lt;p&gt;
 * &lt;b&gt;Note&lt;/b&gt;: For details on the focus subsystem, see
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
 * How to Use the Focus Subsystem&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
 * &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
 * for more information.
 *
 * @author      Arthur van Hoff
 * @author      Sami Shaio
 * @see       #add(java.awt.Component, int)
 * @see       #getComponent(int)
 * @see       LayoutManager
 * @since     JDK1.0
 */
public class Container extends Component {

<span class="fc" id="L93">    private static final PlatformLogger log = PlatformLogger.getLogger(&quot;java.awt.Container&quot;);</span>
<span class="fc" id="L94">    private static final PlatformLogger eventLog = PlatformLogger.getLogger(&quot;java.awt.event.Container&quot;);</span>

<span class="fc" id="L96">    private static final Component[] EMPTY_ARRAY = new Component[0];</span>

    /**
     * The components in this container.
     * @see #add
     * @see #getComponents
     */
<span class="nc" id="L103">    private java.util.List&lt;Component&gt; component = new java.util.ArrayList&lt;Component&gt;();</span>

    /**
     * Layout manager for this container.
     * @see #doLayout
     * @see #setLayout
     * @see #getLayout
     */
    LayoutManager layoutMgr;

    /**
     * Event router for lightweight components.  If this container
     * is native, this dispatcher takes care of forwarding and
     * retargeting the events to lightweight components contained
     * (if any).
     */
    private LightweightDispatcher dispatcher;

    /**
     * The focus traversal policy that will manage keyboard traversal of this
     * Container's children, if this Container is a focus cycle root. If the
     * value is null, this Container inherits its policy from its focus-cycle-
     * root ancestor. If all such ancestors of this Container have null
     * policies, then the current KeyboardFocusManager's default policy is
     * used. If the value is non-null, this policy will be inherited by all
     * focus-cycle-root children that have no keyboard-traversal policy of
     * their own (as will, recursively, their focus-cycle-root children).
     * &lt;p&gt;
     * If this Container is not a focus cycle root, the value will be
     * remembered, but will not be used or inherited by this or any other
     * Containers until this Container is made a focus cycle root.
     *
     * @see #setFocusTraversalPolicy
     * @see #getFocusTraversalPolicy
     * @since 1.4
     */
    private transient FocusTraversalPolicy focusTraversalPolicy;

    /**
     * Indicates whether this Component is the root of a focus traversal cycle.
     * Once focus enters a traversal cycle, typically it cannot leave it via
     * focus traversal unless one of the up- or down-cycle keys is pressed.
     * Normal traversal is limited to this Container, and all of this
     * Container's descendants that are not descendants of inferior focus cycle
     * roots.
     *
     * @see #setFocusCycleRoot
     * @see #isFocusCycleRoot
     * @since 1.4
     */
<span class="nc" id="L153">    private boolean focusCycleRoot = false;</span>


    /**
     * Stores the value of focusTraversalPolicyProvider property.
     * @since 1.5
     * @see #setFocusTraversalPolicyProvider
     */
    private boolean focusTraversalPolicyProvider;

    // keeps track of the threads that are printing this component
    private transient Set&lt;Thread&gt; printingThreads;
    // True if there is at least one thread that's printing this component
<span class="nc" id="L166">    private transient boolean printing = false;</span>

    transient ContainerListener containerListener;

    /* HierarchyListener and HierarchyBoundsListener support */
    transient int listeningChildren;
    transient int listeningBoundsChildren;
    transient int descendantsCount;

    /* Non-opaque window support -- see Window.setLayersOpaque */
<span class="nc" id="L176">    transient Color preserveBackgroundColor = null;</span>

    /**
     * JDK 1.1 serialVersionUID
     */
    private static final long serialVersionUID = 4613797578919906343L;

    /**
     * A constant which toggles one of the controllable behaviors
     * of &lt;code&gt;getMouseEventTarget&lt;/code&gt;. It is used to specify whether
     * the method can return the Container on which it is originally called
     * in case if none of its children are the current mouse event targets.
     *
     * @see #getMouseEventTarget(int, int, boolean, boolean, boolean)
     */
    static final boolean INCLUDE_SELF = true;

    /**
     * A constant which toggles one of the controllable behaviors
     * of &lt;code&gt;getMouseEventTarget&lt;/code&gt;. It is used to specify whether
     * the method should search only lightweight components.
     *
     * @see #getMouseEventTarget(int, int, boolean, boolean, boolean)
     */
    static final boolean SEARCH_HEAVYWEIGHTS = true;

    /*
     * Number of HW or LW components in this container (including
     * all descendant containers).
     */
<span class="nc" id="L206">    private transient int numOfHWComponents = 0;</span>
<span class="nc" id="L207">    private transient int numOfLWComponents = 0;</span>

<span class="fc" id="L209">    private static final PlatformLogger mixingLog = PlatformLogger.getLogger(&quot;java.awt.mixing.Container&quot;);</span>

    /**
     * @serialField ncomponents                     int
     *       The number of components in this container.
     *       This value can be null.
     * @serialField component                       Component[]
     *       The components in this container.
     * @serialField layoutMgr                       LayoutManager
     *       Layout manager for this container.
     * @serialField dispatcher                      LightweightDispatcher
     *       Event router for lightweight components.  If this container
     *       is native, this dispatcher takes care of forwarding and
     *       retargeting the events to lightweight components contained
     *       (if any).
     * @serialField maxSize                         Dimension
     *       Maximum size of this Container.
     * @serialField focusCycleRoot                  boolean
     *       Indicates whether this Component is the root of a focus traversal cycle.
     *       Once focus enters a traversal cycle, typically it cannot leave it via
     *       focus traversal unless one of the up- or down-cycle keys is pressed.
     *       Normal traversal is limited to this Container, and all of this
     *       Container's descendants that are not descendants of inferior focus cycle
     *       roots.
     * @serialField containerSerializedDataVersion  int
     *       Container Serial Data Version.
     * @serialField focusTraversalPolicyProvider    boolean
     *       Stores the value of focusTraversalPolicyProvider property.
     */
<span class="fc" id="L238">    private static final ObjectStreamField[] serialPersistentFields = {</span>
        new ObjectStreamField(&quot;ncomponents&quot;, Integer.TYPE),
        new ObjectStreamField(&quot;component&quot;, Component[].class),
        new ObjectStreamField(&quot;layoutMgr&quot;, LayoutManager.class),
        new ObjectStreamField(&quot;dispatcher&quot;, LightweightDispatcher.class),
        new ObjectStreamField(&quot;maxSize&quot;, Dimension.class),
        new ObjectStreamField(&quot;focusCycleRoot&quot;, Boolean.TYPE),
        new ObjectStreamField(&quot;containerSerializedDataVersion&quot;, Integer.TYPE),
        new ObjectStreamField(&quot;focusTraversalPolicyProvider&quot;, Boolean.TYPE),
    };

    static {
        /* ensure that the necessary native libraries are loaded */
<span class="fc" id="L251">        Toolkit.loadLibraries();</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L253">            initIDs();</span>
        }

<span class="fc" id="L256">        AWTAccessor.setContainerAccessor(new AWTAccessor.ContainerAccessor() {</span>
            @Override
            public void validateUnconditionally(Container cont) {
<span class="nc" id="L259">                cont.validateUnconditionally();</span>
<span class="nc" id="L260">            }</span>

            @Override
            public Component findComponentAt(Container cont, int x, int y,
                    boolean ignoreEnabled) {
<span class="nc" id="L265">                return cont.findComponentAt(x, y, ignoreEnabled);</span>
            }
        });
    }

    /**
     * Initialize JNI field and method IDs for fields that may be
       called from C.
     */
    private static native void initIDs();

    /**
     * Constructs a new Container. Containers can be extended directly,
     * but are lightweight in this case and must be contained by a parent
     * somewhere higher up in the component tree that is native.
     * (such as Frame for example).
     */
<span class="nc" id="L282">    public Container() {</span>
<span class="nc" id="L283">    }</span>
    @SuppressWarnings({&quot;unchecked&quot;,&quot;rawtypes&quot;})
    void initializeFocusTraversalKeys() {
<span class="nc" id="L286">        focusTraversalKeys = new Set[4];</span>
<span class="nc" id="L287">    }</span>

    /**
     * Gets the number of components in this panel.
     * &lt;p&gt;
     * Note: This method should be called under AWT tree lock.
     *
     * @return    the number of components in this panel.
     * @see       #getComponent
     * @since     JDK1.1
     * @see Component#getTreeLock()
     */
    public int getComponentCount() {
<span class="nc" id="L300">        return countComponents();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by getComponentCount().
     */
    @Deprecated
    public int countComponents() {
        // This method is not synchronized under AWT tree lock.
        // Instead, the calling code is responsible for the
        // synchronization. See 6784816 for details.
<span class="nc" id="L312">        return component.size();</span>
    }

    /**
     * Gets the nth component in this container.
     * &lt;p&gt;
     * Note: This method should be called under AWT tree lock.
     *
     * @param      n   the index of the component to get.
     * @return     the n&lt;sup&gt;th&lt;/sup&gt; component in this container.
     * @exception  ArrayIndexOutOfBoundsException
     *                 if the n&lt;sup&gt;th&lt;/sup&gt; value does not exist.
     * @see Component#getTreeLock()
     */
    public Component getComponent(int n) {
        // This method is not synchronized under AWT tree lock.
        // Instead, the calling code is responsible for the
        // synchronization. See 6784816 for details.
        try {
<span class="nc" id="L331">            return component.get(n);</span>
<span class="nc" id="L332">        } catch (IndexOutOfBoundsException z) {</span>
<span class="nc" id="L333">            throw new ArrayIndexOutOfBoundsException(&quot;No such child: &quot; + n);</span>
        }
    }

    /**
     * Gets all the components in this container.
     * &lt;p&gt;
     * Note: This method should be called under AWT tree lock.
     *
     * @return    an array of all the components in this container.
     * @see Component#getTreeLock()
     */
    public Component[] getComponents() {
        // This method is not synchronized under AWT tree lock.
        // Instead, the calling code is responsible for the
        // synchronization. See 6784816 for details.
<span class="nc" id="L349">        return getComponents_NoClientCode();</span>
    }

    // NOTE: This method may be called by privileged threads.
    //       This functionality is implemented in a package-private method
    //       to insure that it cannot be overridden by client subclasses.
    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
    final Component[] getComponents_NoClientCode() {
<span class="nc" id="L357">        return component.toArray(EMPTY_ARRAY);</span>
    }

    /*
     * Wrapper for getComponents() method with a proper synchronization.
     */
    Component[] getComponentsSync() {
<span class="nc" id="L364">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L365">            return getComponents();</span>
<span class="nc" id="L366">        }</span>
    }

    /**
     * Determines the insets of this container, which indicate the size
     * of the container's border.
     * &lt;p&gt;
     * A &lt;code&gt;Frame&lt;/code&gt; object, for example, has a top inset that
     * corresponds to the height of the frame's title bar.
     * @return    the insets of this container.
     * @see       Insets
     * @see       LayoutManager
     * @since     JDK1.1
     */
    public Insets getInsets() {
<span class="nc" id="L381">        return insets();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getInsets()&lt;/code&gt;.
     */
    @Deprecated
    public Insets insets() {
<span class="nc" id="L390">        ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (peer instanceof ContainerPeer) {</span>
<span class="nc" id="L392">            ContainerPeer cpeer = (ContainerPeer)peer;</span>
<span class="nc" id="L393">            return (Insets)cpeer.getInsets().clone();</span>
        }
<span class="nc" id="L395">        return new Insets(0, 0, 0, 0);</span>
    }

    /**
     * Appends the specified component to the end of this container.
     * This is a convenience method for {@link #addImpl}.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy. If the container has already been
     * displayed, the hierarchy must be validated thereafter in order to
     * display the added component.
     *
     * @param     comp   the component to be added
     * @exception NullPointerException if {@code comp} is {@code null}
     * @see #addImpl
     * @see #invalidate
     * @see #validate
     * @see javax.swing.JComponent#revalidate()
     * @return    the component argument
     */
    public Component add(Component comp) {
<span class="nc" id="L416">        addImpl(comp, null, -1);</span>
<span class="nc" id="L417">        return comp;</span>
    }

    /**
     * Adds the specified component to this container.
     * This is a convenience method for {@link #addImpl}.
     * &lt;p&gt;
     * This method is obsolete as of 1.1.  Please use the
     * method &lt;code&gt;add(Component, Object)&lt;/code&gt; instead.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy. If the container has already been
     * displayed, the hierarchy must be validated thereafter in order to
     * display the added component.
     *
     * @exception NullPointerException if {@code comp} is {@code null}
     * @see #add(Component, Object)
     * @see #invalidate
     */
    public Component add(String name, Component comp) {
<span class="nc" id="L437">        addImpl(comp, name, -1);</span>
<span class="nc" id="L438">        return comp;</span>
    }

    /**
     * Adds the specified component to this container at the given
     * position.
     * This is a convenience method for {@link #addImpl}.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy. If the container has already been
     * displayed, the hierarchy must be validated thereafter in order to
     * display the added component.
     *
     *
     * @param     comp   the component to be added
     * @param     index    the position at which to insert the component,
     *                   or &lt;code&gt;-1&lt;/code&gt; to append the component to the end
     * @exception NullPointerException if {@code comp} is {@code null}
     * @exception IllegalArgumentException if {@code index} is invalid (see
     *            {@link #addImpl} for details)
     * @return    the component &lt;code&gt;comp&lt;/code&gt;
     * @see #addImpl
     * @see #remove
     * @see #invalidate
     * @see #validate
     * @see javax.swing.JComponent#revalidate()
     */
    public Component add(Component comp, int index) {
<span class="nc" id="L466">        addImpl(comp, null, index);</span>
<span class="nc" id="L467">        return comp;</span>
    }

    /**
     * Checks that the component
     * isn't supposed to be added into itself.
     */
    private void checkAddToSelf(Component comp){
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (comp instanceof Container) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">            for (Container cn = this; cn != null; cn=cn.parent) {</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">                if (cn == comp) {</span>
<span class="nc" id="L478">                    throw new IllegalArgumentException(&quot;adding container's parent to itself&quot;);</span>
                }
            }
        }
<span class="nc" id="L482">    }</span>

    /**
     * Checks that the component is not a Window instance.
     */
    private void checkNotAWindow(Component comp){
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (comp instanceof Window) {</span>
<span class="nc" id="L489">            throw new IllegalArgumentException(&quot;adding a window to a container&quot;);</span>
        }
<span class="nc" id="L491">    }</span>

    /**
     * Checks that the component comp can be added to this container
     * Checks :  index in bounds of container's size,
     * comp is not one of this container's parents,
     * and comp is not a window.
     * Comp and container must be on the same GraphicsDevice.
     * if comp is container, all sub-components must be on
     * same GraphicsDevice.
     *
     * @since 1.5
     */
    private void checkAdding(Component comp, int index) {
<span class="nc" id="L505">        checkTreeLock();</span>

<span class="nc" id="L507">        GraphicsConfiguration thisGC = getGraphicsConfiguration();</span>

<span class="nc bnc" id="L509" title="All 4 branches missed.">        if (index &gt; component.size() || index &lt; 0) {</span>
<span class="nc" id="L510">            throw new IllegalArgumentException(&quot;illegal component position&quot;);</span>
        }
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (comp.parent == this) {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">            if (index == component.size()) {</span>
<span class="nc" id="L514">                throw new IllegalArgumentException(&quot;illegal component position &quot; +</span>
<span class="nc" id="L515">                                                   index + &quot; should be less then &quot; + component.size());</span>
            }
        }
<span class="nc" id="L518">        checkAddToSelf(comp);</span>
<span class="nc" id="L519">        checkNotAWindow(comp);</span>

<span class="nc" id="L521">        Window thisTopLevel = getContainingWindow();</span>
<span class="nc" id="L522">        Window compTopLevel = comp.getContainingWindow();</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">        if (thisTopLevel != compTopLevel) {</span>
<span class="nc" id="L524">            throw new IllegalArgumentException(&quot;component and container should be in the same top-level window&quot;);</span>
        }
<span class="nc bnc" id="L526" title="All 2 branches missed.">        if (thisGC != null) {</span>
<span class="nc" id="L527">            comp.checkGD(thisGC.getDevice().getIDstring());</span>
        }
<span class="nc" id="L529">    }</span>

    /**
     * Removes component comp from this container without making unneccessary changes
     * and generating unneccessary events. This function intended to perform optimized
     * remove, for example, if newParent and current parent are the same it just changes
     * index without calling removeNotify.
     * Note: Should be called while holding treeLock
     * Returns whether removeNotify was invoked
     * @since: 1.5
     */
    private boolean removeDelicately(Component comp, Container newParent, int newIndex) {
<span class="nc" id="L541">        checkTreeLock();</span>

<span class="nc" id="L543">        int index = getComponentZOrder(comp);</span>
<span class="nc" id="L544">        boolean needRemoveNotify = isRemoveNotifyNeeded(comp, this, newParent);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (needRemoveNotify) {</span>
<span class="nc" id="L546">            comp.removeNotify();</span>
        }
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (newParent != this) {</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            if (layoutMgr != null) {</span>
<span class="nc" id="L550">                layoutMgr.removeLayoutComponent(comp);</span>
            }
<span class="nc" id="L552">            adjustListeningChildren(AWTEvent.HIERARCHY_EVENT_MASK,</span>
<span class="nc" id="L553">                                    -comp.numListening(AWTEvent.HIERARCHY_EVENT_MASK));</span>
<span class="nc" id="L554">            adjustListeningChildren(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK,</span>
<span class="nc" id="L555">                                    -comp.numListening(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));</span>
<span class="nc" id="L556">            adjustDescendants(-(comp.countHierarchyMembers()));</span>

<span class="nc" id="L558">            comp.parent = null;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">            if (needRemoveNotify) {</span>
<span class="nc" id="L560">                comp.setGraphicsConfiguration(null);</span>
            }
<span class="nc" id="L562">            component.remove(index);</span>

<span class="nc" id="L564">            invalidateIfValid();</span>
        } else {
            // We should remove component and then
            // add it by the newIndex without newIndex decrement if even we shift components to the left
            // after remove. Consult the rules below:
            // 2-&gt;4: 012345 -&gt; 013425, 2-&gt;5: 012345 -&gt; 013452
            // 4-&gt;2: 012345 -&gt; 014235
<span class="nc" id="L571">            component.remove(index);</span>
<span class="nc" id="L572">            component.add(newIndex, comp);</span>
        }
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (comp.parent == null) { // was actually removed</span>
<span class="nc bnc" id="L575" title="All 4 branches missed.">            if (containerListener != null ||</span>
                (eventMask &amp; AWTEvent.CONTAINER_EVENT_MASK) != 0 ||
<span class="nc bnc" id="L577" title="All 2 branches missed.">                Toolkit.enabledOnToolkit(AWTEvent.CONTAINER_EVENT_MASK)) {</span>
<span class="nc" id="L578">                ContainerEvent e = new ContainerEvent(this,</span>
                                                      ContainerEvent.COMPONENT_REMOVED,
                                                      comp);
<span class="nc" id="L581">                dispatchEvent(e);</span>

            }
<span class="nc" id="L584">            comp.createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED, comp,</span>
                                       this, HierarchyEvent.PARENT_CHANGED,
<span class="nc" id="L586">                                       Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));</span>
<span class="nc bnc" id="L587" title="All 6 branches missed.">            if (peer != null &amp;&amp; layoutMgr == null &amp;&amp; isVisible()) {</span>
<span class="nc" id="L588">                updateCursorImmediately();</span>
            }
        }
<span class="nc" id="L591">        return needRemoveNotify;</span>
    }

    /**
     * Checks whether this container can contain component which is focus owner.
     * Verifies that container is enable and showing, and if it is focus cycle root
     * its FTP allows component to be focus owner
     * @since 1.5
     */
    boolean canContainFocusOwner(Component focusOwnerCandidate) {
<span class="nc bnc" id="L601" title="All 4 branches missed.">        if (!(isEnabled() &amp;&amp; isDisplayable()</span>
<span class="nc bnc" id="L602" title="All 4 branches missed.">              &amp;&amp; isVisible() &amp;&amp; isFocusable()))</span>
        {
<span class="nc" id="L604">            return false;</span>
        }
<span class="nc bnc" id="L606" title="All 2 branches missed.">        if (isFocusCycleRoot()) {</span>
<span class="nc" id="L607">            FocusTraversalPolicy policy = getFocusTraversalPolicy();</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">            if (policy instanceof DefaultFocusTraversalPolicy) {</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                if (!((DefaultFocusTraversalPolicy)policy).accept(focusOwnerCandidate)) {</span>
<span class="nc" id="L610">                    return false;</span>
                }
            }
        }
<span class="nc" id="L614">        synchronized(getTreeLock()) {</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L616">                return parent.canContainFocusOwner(focusOwnerCandidate);</span>
            }
<span class="nc" id="L618">        }</span>
<span class="nc" id="L619">        return true;</span>
    }

    /**
     * Checks whether or not this container has heavyweight children.
     * Note: Should be called while holding tree lock
     * @return true if there is at least one heavyweight children in a container, false otherwise
     * @since 1.5
     */
    final boolean hasHeavyweightDescendants() {
<span class="nc" id="L629">        checkTreeLock();</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">        return numOfHWComponents &gt; 0;</span>
    }

    /**
     * Checks whether or not this container has lightweight children.
     * Note: Should be called while holding tree lock
     * @return true if there is at least one lightweight children in a container, false otherwise
     * @since 1.7
     */
    final boolean hasLightweightDescendants() {
<span class="nc" id="L640">        checkTreeLock();</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">        return numOfLWComponents &gt; 0;</span>
    }

    /**
     * Returns closest heavyweight component to this container. If this container is heavyweight
     * returns this.
     * @since 1.5
     */
    Container getHeavyweightContainer() {
<span class="nc" id="L650">        checkTreeLock();</span>
<span class="nc bnc" id="L651" title="All 4 branches missed.">        if (peer != null &amp;&amp; !(peer instanceof LightweightPeer)) {</span>
<span class="nc" id="L652">            return this;</span>
        } else {
<span class="nc" id="L654">            return getNativeContainer();</span>
        }
    }

    /**
     * Detects whether or not remove from current parent and adding to new parent requires call of
     * removeNotify on the component. Since removeNotify destroys native window this might (not)
     * be required. For example, if new container and old containers are the same we don't need to
     * destroy native window.
     * @since: 1.5
     */
    private static boolean isRemoveNotifyNeeded(Component comp, Container oldContainer, Container newContainer) {
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (oldContainer == null) { // Component didn't have parent - no removeNotify</span>
<span class="nc" id="L667">            return false;</span>
        }
<span class="nc bnc" id="L669" title="All 2 branches missed.">        if (comp.peer == null) { // Component didn't have peer - no removeNotify</span>
<span class="nc" id="L670">            return false;</span>
        }
<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (newContainer.peer == null) {</span>
            // Component has peer but new Container doesn't - call removeNotify
<span class="nc" id="L674">            return true;</span>
        }

        // If component is lightweight non-Container or lightweight Container with all but heavyweight
        // children there is no need to call remove notify
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (comp.isLightweight()) {</span>
<span class="nc" id="L680">            boolean isContainer = comp instanceof Container;</span>

<span class="nc bnc" id="L682" title="All 6 branches missed.">            if (!isContainer || (isContainer &amp;&amp; !((Container)comp).hasHeavyweightDescendants())) {</span>
<span class="nc" id="L683">                return false;</span>
            }
        }

        // If this point is reached, then the comp is either a HW or a LW container with HW descendants.

        // All three components have peers, check for peer change
<span class="nc" id="L690">        Container newNativeContainer = oldContainer.getHeavyweightContainer();</span>
<span class="nc" id="L691">        Container oldNativeContainer = newContainer.getHeavyweightContainer();</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (newNativeContainer != oldNativeContainer) {</span>
            // Native containers change - check whether or not current platform supports
            // changing of widget hierarchy on native level without recreation.
            // The current implementation forbids reparenting of LW containers with HW descendants
            // into another native container w/o destroying the peers. Actually such an operation
            // is quite rare. If we ever need to save the peers, we'll have to slightly change the
            // addDelicately() method in order to handle such LW containers recursively, reparenting
            // each HW descendant independently.
<span class="nc bnc" id="L700" title="All 2 branches missed.">            return !comp.peer.isReparentSupported();</span>
        } else {
<span class="nc" id="L702">            return false;</span>
        }
    }

    /**
     * Moves the specified component to the specified z-order index in
     * the container. The z-order determines the order that components
     * are painted; the component with the highest z-order paints first
     * and the component with the lowest z-order paints last.
     * Where components overlap, the component with the lower
     * z-order paints over the component with the higher z-order.
     * &lt;p&gt;
     * If the component is a child of some other container, it is
     * removed from that container before being added to this container.
     * The important difference between this method and
     * &lt;code&gt;java.awt.Container.add(Component, int)&lt;/code&gt; is that this method
     * doesn't call &lt;code&gt;removeNotify&lt;/code&gt; on the component while
     * removing it from its previous container unless necessary and when
     * allowed by the underlying native windowing system. This way, if the
     * component has the keyboard focus, it maintains the focus when
     * moved to the new position.
     * &lt;p&gt;
     * This property is guaranteed to apply only to lightweight
     * non-&lt;code&gt;Container&lt;/code&gt; components.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: Not all platforms support changing the z-order of
     * heavyweight components from one container into another without
     * the call to &lt;code&gt;removeNotify&lt;/code&gt;. There is no way to detect
     * whether a platform supports this, so developers shouldn't make
     * any assumptions.
     *
     * @param     comp the component to be moved
     * @param     index the position in the container's list to
     *            insert the component, where &lt;code&gt;getComponentCount()&lt;/code&gt;
     *            appends to the end
     * @exception NullPointerException if &lt;code&gt;comp&lt;/code&gt; is
     *            &lt;code&gt;null&lt;/code&gt;
     * @exception IllegalArgumentException if &lt;code&gt;comp&lt;/code&gt; is one of the
     *            container's parents
     * @exception IllegalArgumentException if &lt;code&gt;index&lt;/code&gt; is not in
     *            the range &lt;code&gt;[0, getComponentCount()]&lt;/code&gt; for moving
     *            between containers, or not in the range
     *            &lt;code&gt;[0, getComponentCount()-1]&lt;/code&gt; for moving inside
     *            a container
     * @exception IllegalArgumentException if adding a container to itself
     * @exception IllegalArgumentException if adding a &lt;code&gt;Window&lt;/code&gt;
     *            to a container
     * @see #getComponentZOrder(java.awt.Component)
     * @see #invalidate
     * @since 1.5
     */
    public void setComponentZOrder(Component comp, int index) {
<span class="nc" id="L757">         synchronized (getTreeLock()) {</span>
             // Store parent because remove will clear it
<span class="nc" id="L759">             Container curParent = comp.parent;</span>
<span class="nc" id="L760">             int oldZindex = getComponentZOrder(comp);</span>

<span class="nc bnc" id="L762" title="All 4 branches missed.">             if (curParent == this &amp;&amp; index == oldZindex) {</span>
<span class="nc" id="L763">                 return;</span>
             }
<span class="nc" id="L765">             checkAdding(comp, index);</span>

<span class="nc bnc" id="L767" title="All 2 branches missed.">             boolean peerRecreated = (curParent != null) ?</span>
<span class="nc" id="L768">                 curParent.removeDelicately(comp, this, index) : false;</span>

<span class="nc" id="L770">             addDelicately(comp, curParent, index);</span>

             // If the oldZindex == -1, the component gets inserted,
             // rather than it changes its z-order.
<span class="nc bnc" id="L774" title="All 4 branches missed.">             if (!peerRecreated &amp;&amp; oldZindex != -1) {</span>
                 // The new 'index' cannot be == -1.
                 // It gets checked at the checkAdding() method.
                 // Therefore both oldZIndex and index denote
                 // some existing positions at this point and
                 // this is actually a Z-order changing.
<span class="nc" id="L780">                 comp.mixOnZOrderChanging(oldZindex, index);</span>
             }
<span class="nc" id="L782">         }</span>
<span class="nc" id="L783">    }</span>

    /**
     * Traverses the tree of components and reparents children heavyweight component
     * to new heavyweight parent.
     * @since 1.5
     */
    private void reparentTraverse(ContainerPeer parentPeer, Container child) {
<span class="nc" id="L791">        checkTreeLock();</span>

<span class="nc bnc" id="L793" title="All 2 branches missed.">        for (int i = 0; i &lt; child.getComponentCount(); i++) {</span>
<span class="nc" id="L794">            Component comp = child.getComponent(i);</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">            if (comp.isLightweight()) {</span>
                // If components is lightweight check if it is container
                // If it is container it might contain heavyweight children we need to reparent
<span class="nc bnc" id="L798" title="All 2 branches missed.">                if (comp instanceof Container) {</span>
<span class="nc" id="L799">                    reparentTraverse(parentPeer, (Container)comp);</span>
                }
            } else {
                // Q: Need to update NativeInLightFixer?
<span class="nc" id="L803">                comp.getPeer().reparent(parentPeer);</span>
            }
        }
<span class="nc" id="L806">    }</span>

    /**
     * Reparents child component peer to this container peer.
     * Container must be heavyweight.
     * @since 1.5
     */
    private void reparentChild(Component comp) {
<span class="nc" id="L814">        checkTreeLock();</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">        if (comp == null) {</span>
<span class="nc" id="L816">            return;</span>
        }
<span class="nc bnc" id="L818" title="All 2 branches missed.">        if (comp.isLightweight()) {</span>
            // If component is lightweight container we need to reparent all its explicit  heavyweight children
<span class="nc bnc" id="L820" title="All 2 branches missed.">            if (comp instanceof Container) {</span>
                // Traverse component's tree till depth-first until encountering heavyweight component
<span class="nc" id="L822">                reparentTraverse((ContainerPeer)getPeer(), (Container)comp);</span>
            }
        } else {
<span class="nc" id="L825">            comp.getPeer().reparent((ContainerPeer)getPeer());</span>
        }
<span class="nc" id="L827">    }</span>

    /**
     * Adds component to this container. Tries to minimize side effects of this adding -
     * doesn't call remove notify if it is not required.
     * @since 1.5
     */
    private void addDelicately(Component comp, Container curParent, int index) {
<span class="nc" id="L835">        checkTreeLock();</span>

        // Check if moving between containers
<span class="nc bnc" id="L838" title="All 2 branches missed.">        if (curParent != this) {</span>
            //index == -1 means add to the end.
<span class="nc bnc" id="L840" title="All 2 branches missed.">            if (index == -1) {</span>
<span class="nc" id="L841">                component.add(comp);</span>
            } else {
<span class="nc" id="L843">                component.add(index, comp);</span>
            }
<span class="nc" id="L845">            comp.parent = this;</span>
<span class="nc" id="L846">            comp.setGraphicsConfiguration(getGraphicsConfiguration());</span>

<span class="nc" id="L848">            adjustListeningChildren(AWTEvent.HIERARCHY_EVENT_MASK,</span>
<span class="nc" id="L849">                                    comp.numListening(AWTEvent.HIERARCHY_EVENT_MASK));</span>
<span class="nc" id="L850">            adjustListeningChildren(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK,</span>
<span class="nc" id="L851">                                    comp.numListening(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));</span>
<span class="nc" id="L852">            adjustDescendants(comp.countHierarchyMembers());</span>
        } else {
<span class="nc bnc" id="L854" title="All 2 branches missed.">            if (index &lt; component.size()) {</span>
<span class="nc" id="L855">                component.set(index, comp);</span>
            }
        }

<span class="nc" id="L859">        invalidateIfValid();</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">            if (comp.peer == null) { // Remove notify was called or it didn't have peer - create new one</span>
<span class="nc" id="L862">                comp.addNotify();</span>
            } else { // Both container and child have peers, it means child peer should be reparented.
                // In both cases we need to reparent native widgets.
<span class="nc" id="L865">                Container newNativeContainer = getHeavyweightContainer();</span>
<span class="nc" id="L866">                Container oldNativeContainer = curParent.getHeavyweightContainer();</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">                if (oldNativeContainer != newNativeContainer) {</span>
                    // Native container changed - need to reparent native widgets
<span class="nc" id="L869">                    newNativeContainer.reparentChild(comp);</span>
                }
<span class="nc" id="L871">                comp.updateZOrder();</span>

<span class="nc bnc" id="L873" title="All 4 branches missed.">                if (!comp.isLightweight() &amp;&amp; isLightweight()) {</span>
                    // If component is heavyweight and one of the containers is lightweight
                    // the location of the component should be fixed.
<span class="nc" id="L876">                    comp.relocateComponent();</span>
                }
            }
        }
<span class="nc bnc" id="L880" title="All 2 branches missed.">        if (curParent != this) {</span>
            /* Notify the layout manager of the added component. */
<span class="nc bnc" id="L882" title="All 2 branches missed.">            if (layoutMgr != null) {</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">                if (layoutMgr instanceof LayoutManager2) {</span>
<span class="nc" id="L884">                    ((LayoutManager2)layoutMgr).addLayoutComponent(comp, null);</span>
                } else {
<span class="nc" id="L886">                    layoutMgr.addLayoutComponent(null, comp);</span>
                }
            }
<span class="nc bnc" id="L889" title="All 4 branches missed.">            if (containerListener != null ||</span>
                (eventMask &amp; AWTEvent.CONTAINER_EVENT_MASK) != 0 ||
<span class="nc bnc" id="L891" title="All 2 branches missed.">                Toolkit.enabledOnToolkit(AWTEvent.CONTAINER_EVENT_MASK)) {</span>
<span class="nc" id="L892">                ContainerEvent e = new ContainerEvent(this,</span>
                                                      ContainerEvent.COMPONENT_ADDED,
                                                      comp);
<span class="nc" id="L895">                dispatchEvent(e);</span>
            }
<span class="nc" id="L897">            comp.createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED, comp,</span>
                                       this, HierarchyEvent.PARENT_CHANGED,
<span class="nc" id="L899">                                       Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));</span>

            // If component is focus owner or parent container of focus owner check that after reparenting
            // focus owner moved out if new container prohibit this kind of focus owner.
<span class="nc bnc" id="L903" title="All 4 branches missed.">            if (comp.isFocusOwner() &amp;&amp; !comp.canBeFocusOwnerRecursively()) {</span>
<span class="nc" id="L904">                comp.transferFocus();</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">            } else if (comp instanceof Container) {</span>
<span class="nc" id="L906">                Component focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();</span>
<span class="nc bnc" id="L907" title="All 6 branches missed.">                if (focusOwner != null &amp;&amp; isParentOf(focusOwner) &amp;&amp; !focusOwner.canBeFocusOwnerRecursively()) {</span>
<span class="nc" id="L908">                    focusOwner.transferFocus();</span>
                }
<span class="nc" id="L910">            }</span>
        } else {
<span class="nc" id="L912">            comp.createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED, comp,</span>
                                       this, HierarchyEvent.HIERARCHY_CHANGED,
<span class="nc" id="L914">                                       Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));</span>
        }

<span class="nc bnc" id="L917" title="All 6 branches missed.">        if (peer != null &amp;&amp; layoutMgr == null &amp;&amp; isVisible()) {</span>
<span class="nc" id="L918">            updateCursorImmediately();</span>
        }
<span class="nc" id="L920">    }</span>

    /**
     * Returns the z-order index of the component inside the container.
     * The higher a component is in the z-order hierarchy, the lower
     * its index.  The component with the lowest z-order index is
     * painted last, above all other child components.
     *
     * @param comp the component being queried
     * @return  the z-order index of the component; otherwise
     *          returns -1 if the component is &lt;code&gt;null&lt;/code&gt;
     *          or doesn't belong to the container
     * @see #setComponentZOrder(java.awt.Component, int)
     * @since 1.5
     */
    public int getComponentZOrder(Component comp) {
<span class="nc bnc" id="L936" title="All 2 branches missed.">        if (comp == null) {</span>
<span class="nc" id="L937">            return -1;</span>
        }
<span class="nc" id="L939">        synchronized(getTreeLock()) {</span>
            // Quick check - container should be immediate parent of the component
<span class="nc bnc" id="L941" title="All 2 branches missed.">            if (comp.parent != this) {</span>
<span class="nc" id="L942">                return -1;</span>
            }
<span class="nc" id="L944">            return component.indexOf(comp);</span>
<span class="nc" id="L945">        }</span>
    }

    /**
     * Adds the specified component to the end of this container.
     * Also notifies the layout manager to add the component to
     * this container's layout using the specified constraints object.
     * This is a convenience method for {@link #addImpl}.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy. If the container has already been
     * displayed, the hierarchy must be validated thereafter in order to
     * display the added component.
     *
     *
     * @param     comp the component to be added
     * @param     constraints an object expressing
     *                  layout constraints for this component
     * @exception NullPointerException if {@code comp} is {@code null}
     * @see #addImpl
     * @see #invalidate
     * @see #validate
     * @see javax.swing.JComponent#revalidate()
     * @see       LayoutManager
     * @since     JDK1.1
     */
    public void add(Component comp, Object constraints) {
<span class="nc" id="L972">        addImpl(comp, constraints, -1);</span>
<span class="nc" id="L973">    }</span>

    /**
     * Adds the specified component to this container with the specified
     * constraints at the specified index.  Also notifies the layout
     * manager to add the component to the this container's layout using
     * the specified constraints object.
     * This is a convenience method for {@link #addImpl}.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy. If the container has already been
     * displayed, the hierarchy must be validated thereafter in order to
     * display the added component.
     *
     *
     * @param comp the component to be added
     * @param constraints an object expressing layout constraints for this
     * @param index the position in the container's list at which to insert
     * the component; &lt;code&gt;-1&lt;/code&gt; means insert at the end
     * component
     * @exception NullPointerException if {@code comp} is {@code null}
     * @exception IllegalArgumentException if {@code index} is invalid (see
     *            {@link #addImpl} for details)
     * @see #addImpl
     * @see #invalidate
     * @see #validate
     * @see javax.swing.JComponent#revalidate()
     * @see #remove
     * @see LayoutManager
     */
    public void add(Component comp, Object constraints, int index) {
<span class="nc" id="L1004">       addImpl(comp, constraints, index);</span>
<span class="nc" id="L1005">    }</span>

    /**
     * Adds the specified component to this container at the specified
     * index. This method also notifies the layout manager to add
     * the component to this container's layout using the specified
     * constraints object via the &lt;code&gt;addLayoutComponent&lt;/code&gt;
     * method.
     * &lt;p&gt;
     * The constraints are
     * defined by the particular layout manager being used.  For
     * example, the &lt;code&gt;BorderLayout&lt;/code&gt; class defines five
     * constraints: &lt;code&gt;BorderLayout.NORTH&lt;/code&gt;,
     * &lt;code&gt;BorderLayout.SOUTH&lt;/code&gt;, &lt;code&gt;BorderLayout.EAST&lt;/code&gt;,
     * &lt;code&gt;BorderLayout.WEST&lt;/code&gt;, and &lt;code&gt;BorderLayout.CENTER&lt;/code&gt;.
     * &lt;p&gt;
     * The &lt;code&gt;GridBagLayout&lt;/code&gt; class requires a
     * &lt;code&gt;GridBagConstraints&lt;/code&gt; object.  Failure to pass
     * the correct type of constraints object results in an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt;.
     * &lt;p&gt;
     * If the current layout manager implements {@code LayoutManager2}, then
     * {@link LayoutManager2#addLayoutComponent(Component,Object)} is invoked on
     * it. If the current layout manager does not implement
     * {@code LayoutManager2}, and constraints is a {@code String}, then
     * {@link LayoutManager#addLayoutComponent(String,Component)} is invoked on it.
     * &lt;p&gt;
     * If the component is not an ancestor of this container and has a non-null
     * parent, it is removed from its current parent before it is added to this
     * container.
     * &lt;p&gt;
     * This is the method to override if a program needs to track
     * every add request to a container as all other add methods defer
     * to this one. An overriding method should
     * usually include a call to the superclass's version of the method:
     * &lt;p&gt;
     * &lt;blockquote&gt;
     * &lt;code&gt;super.addImpl(comp, constraints, index)&lt;/code&gt;
     * &lt;/blockquote&gt;
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy. If the container has already been
     * displayed, the hierarchy must be validated thereafter in order to
     * display the added component.
     *
     * @param     comp       the component to be added
     * @param     constraints an object expressing layout constraints
     *                 for this component
     * @param     index the position in the container's list at which to
     *                 insert the component, where &lt;code&gt;-1&lt;/code&gt;
     *                 means append to the end
     * @exception IllegalArgumentException if {@code index} is invalid;
     *            if {@code comp} is a child of this container, the valid
     *            range is {@code [-1, getComponentCount()-1]}; if component is
     *            not a child of this container, the valid range is
     *            {@code [-1, getComponentCount()]}
     *
     * @exception IllegalArgumentException if {@code comp} is an ancestor of
     *                                     this container
     * @exception IllegalArgumentException if adding a window to a container
     * @exception NullPointerException if {@code comp} is {@code null}
     * @see       #add(Component)
     * @see       #add(Component, int)
     * @see       #add(Component, java.lang.Object)
     * @see #invalidate
     * @see       LayoutManager
     * @see       LayoutManager2
     * @since     JDK1.1
     */
    protected void addImpl(Component comp, Object constraints, int index) {
<span class="nc" id="L1075">        synchronized (getTreeLock()) {</span>
            /* Check for correct arguments:  index in bounds,
             * comp cannot be one of this container's parents,
             * and comp cannot be a window.
             * comp and container must be on the same GraphicsDevice.
             * if comp is container, all sub-components must be on
             * same GraphicsDevice.
             */
<span class="nc" id="L1083">            GraphicsConfiguration thisGC = this.getGraphicsConfiguration();</span>

<span class="nc bnc" id="L1085" title="All 6 branches missed.">            if (index &gt; component.size() || (index &lt; 0 &amp;&amp; index != -1)) {</span>
<span class="nc" id="L1086">                throw new IllegalArgumentException(</span>
                          &quot;illegal component position&quot;);
            }
<span class="nc" id="L1089">            checkAddToSelf(comp);</span>
<span class="nc" id="L1090">            checkNotAWindow(comp);</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">            if (thisGC != null) {</span>
<span class="nc" id="L1092">                comp.checkGD(thisGC.getDevice().getIDstring());</span>
            }

            /* Reparent the component and tidy up the tree's state. */
<span class="nc bnc" id="L1096" title="All 2 branches missed.">            if (comp.parent != null) {</span>
<span class="nc" id="L1097">                comp.parent.remove(comp);</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">                    if (index &gt; component.size()) {</span>
<span class="nc" id="L1099">                        throw new IllegalArgumentException(&quot;illegal component position&quot;);</span>
                    }
            }

            //index == -1 means add to the end.
<span class="nc bnc" id="L1104" title="All 2 branches missed.">            if (index == -1) {</span>
<span class="nc" id="L1105">                component.add(comp);</span>
            } else {
<span class="nc" id="L1107">                component.add(index, comp);</span>
            }
<span class="nc" id="L1109">            comp.parent = this;</span>
<span class="nc" id="L1110">            comp.setGraphicsConfiguration(thisGC);</span>

<span class="nc" id="L1112">            adjustListeningChildren(AWTEvent.HIERARCHY_EVENT_MASK,</span>
<span class="nc" id="L1113">                comp.numListening(AWTEvent.HIERARCHY_EVENT_MASK));</span>
<span class="nc" id="L1114">            adjustListeningChildren(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK,</span>
<span class="nc" id="L1115">                comp.numListening(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));</span>
<span class="nc" id="L1116">            adjustDescendants(comp.countHierarchyMembers());</span>

<span class="nc" id="L1118">            invalidateIfValid();</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L1120">                comp.addNotify();</span>
            }

            /* Notify the layout manager of the added component. */
<span class="nc bnc" id="L1124" title="All 2 branches missed.">            if (layoutMgr != null) {</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">                if (layoutMgr instanceof LayoutManager2) {</span>
<span class="nc" id="L1126">                    ((LayoutManager2)layoutMgr).addLayoutComponent(comp, constraints);</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">                } else if (constraints instanceof String) {</span>
<span class="nc" id="L1128">                    layoutMgr.addLayoutComponent((String)constraints, comp);</span>
                }
            }
<span class="nc bnc" id="L1131" title="All 4 branches missed.">            if (containerListener != null ||</span>
                (eventMask &amp; AWTEvent.CONTAINER_EVENT_MASK) != 0 ||
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                Toolkit.enabledOnToolkit(AWTEvent.CONTAINER_EVENT_MASK)) {</span>
<span class="nc" id="L1134">                ContainerEvent e = new ContainerEvent(this,</span>
                                     ContainerEvent.COMPONENT_ADDED,
                                     comp);
<span class="nc" id="L1137">                dispatchEvent(e);</span>
            }

<span class="nc" id="L1140">            comp.createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED, comp,</span>
                                       this, HierarchyEvent.PARENT_CHANGED,
<span class="nc" id="L1142">                                       Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));</span>
<span class="nc bnc" id="L1143" title="All 6 branches missed.">            if (peer != null &amp;&amp; layoutMgr == null &amp;&amp; isVisible()) {</span>
<span class="nc" id="L1144">                updateCursorImmediately();</span>
            }
<span class="nc" id="L1146">        }</span>
<span class="nc" id="L1147">    }</span>

    @Override
    boolean updateGraphicsData(GraphicsConfiguration gc) {
<span class="nc" id="L1151">        checkTreeLock();</span>

<span class="nc" id="L1153">        boolean ret = super.updateGraphicsData(gc);</span>

<span class="nc bnc" id="L1155" title="All 2 branches missed.">        for (Component comp : component) {</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">            if (comp != null) {</span>
<span class="nc" id="L1157">                ret |= comp.updateGraphicsData(gc);</span>
            }
<span class="nc" id="L1159">        }</span>
<span class="nc" id="L1160">        return ret;</span>
    }

    /**
     * Checks that all Components that this Container contains are on
     * the same GraphicsDevice as this Container.  If not, throws an
     * IllegalArgumentException.
     */
    void checkGD(String stringID) {
<span class="nc bnc" id="L1169" title="All 2 branches missed.">        for (Component comp : component) {</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">            if (comp != null) {</span>
<span class="nc" id="L1171">                comp.checkGD(stringID);</span>
            }
<span class="nc" id="L1173">        }</span>
<span class="nc" id="L1174">    }</span>

    /**
     * Removes the component, specified by &lt;code&gt;index&lt;/code&gt;,
     * from this container.
     * This method also notifies the layout manager to remove the
     * component from this container's layout via the
     * &lt;code&gt;removeLayoutComponent&lt;/code&gt; method.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy. If the container has already been
     * displayed, the hierarchy must be validated thereafter in order to
     * reflect the changes.
     *
     *
     * @param     index   the index of the component to be removed
     * @throws ArrayIndexOutOfBoundsException if {@code index} is not in
     *         range {@code [0, getComponentCount()-1]}
     * @see #add
     * @see #invalidate
     * @see #validate
     * @see #getComponentCount
     * @since JDK1.1
     */
    public void remove(int index) {
<span class="nc" id="L1199">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L1200" title="All 4 branches missed.">            if (index &lt; 0  || index &gt;= component.size()) {</span>
<span class="nc" id="L1201">                throw new ArrayIndexOutOfBoundsException(index);</span>
            }
<span class="nc" id="L1203">            Component comp = component.get(index);</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L1205">                comp.removeNotify();</span>
            }
<span class="nc bnc" id="L1207" title="All 2 branches missed.">            if (layoutMgr != null) {</span>
<span class="nc" id="L1208">                layoutMgr.removeLayoutComponent(comp);</span>
            }

<span class="nc" id="L1211">            adjustListeningChildren(AWTEvent.HIERARCHY_EVENT_MASK,</span>
<span class="nc" id="L1212">                -comp.numListening(AWTEvent.HIERARCHY_EVENT_MASK));</span>
<span class="nc" id="L1213">            adjustListeningChildren(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK,</span>
<span class="nc" id="L1214">                -comp.numListening(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));</span>
<span class="nc" id="L1215">            adjustDescendants(-(comp.countHierarchyMembers()));</span>

<span class="nc" id="L1217">            comp.parent = null;</span>
<span class="nc" id="L1218">            component.remove(index);</span>
<span class="nc" id="L1219">            comp.setGraphicsConfiguration(null);</span>

<span class="nc" id="L1221">            invalidateIfValid();</span>
<span class="nc bnc" id="L1222" title="All 4 branches missed.">            if (containerListener != null ||</span>
                (eventMask &amp; AWTEvent.CONTAINER_EVENT_MASK) != 0 ||
<span class="nc bnc" id="L1224" title="All 2 branches missed.">                Toolkit.enabledOnToolkit(AWTEvent.CONTAINER_EVENT_MASK)) {</span>
<span class="nc" id="L1225">                ContainerEvent e = new ContainerEvent(this,</span>
                                     ContainerEvent.COMPONENT_REMOVED,
                                     comp);
<span class="nc" id="L1228">                dispatchEvent(e);</span>
            }

<span class="nc" id="L1231">            comp.createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED, comp,</span>
                                       this, HierarchyEvent.PARENT_CHANGED,
<span class="nc" id="L1233">                                       Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));</span>
<span class="nc bnc" id="L1234" title="All 6 branches missed.">            if (peer != null &amp;&amp; layoutMgr == null &amp;&amp; isVisible()) {</span>
<span class="nc" id="L1235">                updateCursorImmediately();</span>
            }
<span class="nc" id="L1237">        }</span>
<span class="nc" id="L1238">    }</span>

    /**
     * Removes the specified component from this container.
     * This method also notifies the layout manager to remove the
     * component from this container's layout via the
     * &lt;code&gt;removeLayoutComponent&lt;/code&gt; method.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy. If the container has already been
     * displayed, the hierarchy must be validated thereafter in order to
     * reflect the changes.
     *
     * @param comp the component to be removed
     * @throws NullPointerException if {@code comp} is {@code null}
     * @see #add
     * @see #invalidate
     * @see #validate
     * @see #remove(int)
     */
    public void remove(Component comp) {
<span class="nc" id="L1259">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">            if (comp.parent == this)  {</span>
<span class="nc" id="L1261">                int index = component.indexOf(comp);</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">                if (index &gt;= 0) {</span>
<span class="nc" id="L1263">                    remove(index);</span>
                }
            }
<span class="nc" id="L1266">        }</span>
<span class="nc" id="L1267">    }</span>

    /**
     * Removes all the components from this container.
     * This method also notifies the layout manager to remove the
     * components from this container's layout via the
     * &lt;code&gt;removeLayoutComponent&lt;/code&gt; method.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy. If the container has already been
     * displayed, the hierarchy must be validated thereafter in order to
     * reflect the changes.
     *
     * @see #add
     * @see #remove
     * @see #invalidate
     */
    public void removeAll() {
<span class="nc" id="L1285">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L1286">            adjustListeningChildren(AWTEvent.HIERARCHY_EVENT_MASK,</span>
                                    -listeningChildren);
<span class="nc" id="L1288">            adjustListeningChildren(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK,</span>
                                    -listeningBoundsChildren);
<span class="nc" id="L1290">            adjustDescendants(-descendantsCount);</span>

<span class="nc bnc" id="L1292" title="All 2 branches missed.">            while (!component.isEmpty()) {</span>
<span class="nc" id="L1293">                Component comp = component.remove(component.size()-1);</span>

<span class="nc bnc" id="L1295" title="All 2 branches missed.">                if (peer != null) {</span>
<span class="nc" id="L1296">                    comp.removeNotify();</span>
                }
<span class="nc bnc" id="L1298" title="All 2 branches missed.">                if (layoutMgr != null) {</span>
<span class="nc" id="L1299">                    layoutMgr.removeLayoutComponent(comp);</span>
                }
<span class="nc" id="L1301">                comp.parent = null;</span>
<span class="nc" id="L1302">                comp.setGraphicsConfiguration(null);</span>
<span class="nc bnc" id="L1303" title="All 4 branches missed.">                if (containerListener != null ||</span>
                   (eventMask &amp; AWTEvent.CONTAINER_EVENT_MASK) != 0 ||
<span class="nc bnc" id="L1305" title="All 2 branches missed.">                    Toolkit.enabledOnToolkit(AWTEvent.CONTAINER_EVENT_MASK)) {</span>
<span class="nc" id="L1306">                    ContainerEvent e = new ContainerEvent(this,</span>
                                     ContainerEvent.COMPONENT_REMOVED,
                                     comp);
<span class="nc" id="L1309">                    dispatchEvent(e);</span>
                }

<span class="nc" id="L1312">                comp.createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED,</span>
                                           comp, this,
                                           HierarchyEvent.PARENT_CHANGED,
<span class="nc" id="L1315">                                           Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));</span>
<span class="nc" id="L1316">            }</span>
<span class="nc bnc" id="L1317" title="All 6 branches missed.">            if (peer != null &amp;&amp; layoutMgr == null &amp;&amp; isVisible()) {</span>
<span class="nc" id="L1318">                updateCursorImmediately();</span>
            }
<span class="nc" id="L1320">            invalidateIfValid();</span>
<span class="nc" id="L1321">        }</span>
<span class="nc" id="L1322">    }</span>

    // Should only be called while holding tree lock
    int numListening(long mask) {
<span class="nc" id="L1326">        int superListening = super.numListening(mask);</span>

<span class="nc bnc" id="L1328" title="All 2 branches missed.">        if (mask == AWTEvent.HIERARCHY_EVENT_MASK) {</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">            if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
                // Verify listeningChildren is correct
<span class="nc" id="L1331">                int sum = 0;</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">                for (Component comp : component) {</span>
<span class="nc" id="L1333">                    sum += comp.numListening(mask);</span>
<span class="nc" id="L1334">                }</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">                if (listeningChildren != sum) {</span>
<span class="nc" id="L1336">                    eventLog.fine(&quot;Assertion (listeningChildren == sum) failed&quot;);</span>
                }
            }
<span class="nc" id="L1339">            return listeningChildren + superListening;</span>
<span class="nc bnc" id="L1340" title="All 2 branches missed.">        } else if (mask == AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) {</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">            if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
                // Verify listeningBoundsChildren is correct
<span class="nc" id="L1343">                int sum = 0;</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">                for (Component comp : component) {</span>
<span class="nc" id="L1345">                    sum += comp.numListening(mask);</span>
<span class="nc" id="L1346">                }</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">                if (listeningBoundsChildren != sum) {</span>
<span class="nc" id="L1348">                    eventLog.fine(&quot;Assertion (listeningBoundsChildren == sum) failed&quot;);</span>
                }
            }
<span class="nc" id="L1351">            return listeningBoundsChildren + superListening;</span>
        } else {
            // assert false;
<span class="nc bnc" id="L1354" title="All 2 branches missed.">            if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L1355">                eventLog.fine(&quot;This code must never be reached&quot;);</span>
            }
<span class="nc" id="L1357">            return superListening;</span>
        }
    }

    // Should only be called while holding tree lock
    void adjustListeningChildren(long mask, int num) {
<span class="nc bnc" id="L1363" title="All 2 branches missed.">        if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc bnc" id="L1364" title="All 6 branches missed.">            boolean toAssert = (mask == AWTEvent.HIERARCHY_EVENT_MASK ||</span>
                                mask == AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK ||
                                mask == (AWTEvent.HIERARCHY_EVENT_MASK |
                                         AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));
<span class="nc bnc" id="L1368" title="All 2 branches missed.">            if (!toAssert) {</span>
<span class="nc" id="L1369">                eventLog.fine(&quot;Assertion failed&quot;);</span>
            }
        }

<span class="nc bnc" id="L1373" title="All 2 branches missed.">        if (num == 0)</span>
<span class="nc" id="L1374">            return;</span>

<span class="nc bnc" id="L1376" title="All 2 branches missed.">        if ((mask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0) {</span>
<span class="nc" id="L1377">            listeningChildren += num;</span>
        }
<span class="nc bnc" id="L1379" title="All 2 branches missed.">        if ((mask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0) {</span>
<span class="nc" id="L1380">            listeningBoundsChildren += num;</span>
        }

<span class="nc" id="L1383">        adjustListeningChildrenOnParent(mask, num);</span>
<span class="nc" id="L1384">    }</span>

    // Should only be called while holding tree lock
    void adjustDescendants(int num) {
<span class="nc bnc" id="L1388" title="All 2 branches missed.">        if (num == 0)</span>
<span class="nc" id="L1389">            return;</span>

<span class="nc" id="L1391">        descendantsCount += num;</span>
<span class="nc" id="L1392">        adjustDecendantsOnParent(num);</span>
<span class="nc" id="L1393">    }</span>

    // Should only be called while holding tree lock
    void adjustDecendantsOnParent(int num) {
<span class="nc bnc" id="L1397" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L1398">            parent.adjustDescendants(num);</span>
        }
<span class="nc" id="L1400">    }</span>

    // Should only be called while holding tree lock
    int countHierarchyMembers() {
<span class="nc bnc" id="L1404" title="All 2 branches missed.">        if (log.isLoggable(PlatformLogger.Level.FINE)) {</span>
            // Verify descendantsCount is correct
<span class="nc" id="L1406">            int sum = 0;</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">            for (Component comp : component) {</span>
<span class="nc" id="L1408">                sum += comp.countHierarchyMembers();</span>
<span class="nc" id="L1409">            }</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">            if (descendantsCount != sum) {</span>
<span class="nc" id="L1411">                log.fine(&quot;Assertion (descendantsCount == sum) failed&quot;);</span>
            }
        }
<span class="nc" id="L1414">        return descendantsCount + 1;</span>
    }

    private int getListenersCount(int id, boolean enabledOnToolkit) {
<span class="nc" id="L1418">        checkTreeLock();</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">        if (enabledOnToolkit) {</span>
<span class="nc" id="L1420">            return descendantsCount;</span>
        }
<span class="nc bnc" id="L1422" title="All 3 branches missed.">        switch (id) {</span>
          case HierarchyEvent.HIERARCHY_CHANGED:
<span class="nc" id="L1424">            return listeningChildren;</span>
          case HierarchyEvent.ANCESTOR_MOVED:
          case HierarchyEvent.ANCESTOR_RESIZED:
<span class="nc" id="L1427">            return listeningBoundsChildren;</span>
          default:
<span class="nc" id="L1429">            return 0;</span>
        }
    }

    final int createHierarchyEvents(int id, Component changed,
        Container changedParent, long changeFlags, boolean enabledOnToolkit)
    {
<span class="nc" id="L1436">        checkTreeLock();</span>
<span class="nc" id="L1437">        int listeners = getListenersCount(id, enabledOnToolkit);</span>

<span class="nc bnc" id="L1439" title="All 2 branches missed.">        for (int count = listeners, i = 0; count &gt; 0; i++) {</span>
<span class="nc" id="L1440">            count -= component.get(i).createHierarchyEvents(id, changed,</span>
                changedParent, changeFlags, enabledOnToolkit);
        }
<span class="nc" id="L1443">        return listeners +</span>
<span class="nc" id="L1444">            super.createHierarchyEvents(id, changed, changedParent,</span>
                                        changeFlags, enabledOnToolkit);
    }

    final void createChildHierarchyEvents(int id, long changeFlags,
        boolean enabledOnToolkit)
    {
<span class="nc" id="L1451">        checkTreeLock();</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">        if (component.isEmpty()) {</span>
<span class="nc" id="L1453">            return;</span>
        }
<span class="nc" id="L1455">        int listeners = getListenersCount(id, enabledOnToolkit);</span>

<span class="nc bnc" id="L1457" title="All 2 branches missed.">        for (int count = listeners, i = 0; count &gt; 0; i++) {</span>
<span class="nc" id="L1458">            count -= component.get(i).createHierarchyEvents(id, this, parent,</span>
                changeFlags, enabledOnToolkit);
        }
<span class="nc" id="L1461">    }</span>

    /**
     * Gets the layout manager for this container.
     * @see #doLayout
     * @see #setLayout
     */
    public LayoutManager getLayout() {
<span class="nc" id="L1469">        return layoutMgr;</span>
    }

    /**
     * Sets the layout manager for this container.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param mgr the specified layout manager
     * @see #doLayout
     * @see #getLayout
     * @see #invalidate
     */
    public void setLayout(LayoutManager mgr) {
<span class="nc" id="L1484">        layoutMgr = mgr;</span>
<span class="nc" id="L1485">        invalidateIfValid();</span>
<span class="nc" id="L1486">    }</span>

    /**
     * Causes this container to lay out its components.  Most programs
     * should not call this method directly, but should invoke
     * the &lt;code&gt;validate&lt;/code&gt; method instead.
     * @see LayoutManager#layoutContainer
     * @see #setLayout
     * @see #validate
     * @since JDK1.1
     */
    public void doLayout() {
<span class="nc" id="L1498">        layout();</span>
<span class="nc" id="L1499">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;doLayout()&lt;/code&gt;.
     */
    @Deprecated
    public void layout() {
<span class="nc" id="L1507">        LayoutManager layoutMgr = this.layoutMgr;</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">        if (layoutMgr != null) {</span>
<span class="nc" id="L1509">            layoutMgr.layoutContainer(this);</span>
        }
<span class="nc" id="L1511">    }</span>

    /**
     * Indicates if this container is a &lt;i&gt;validate root&lt;/i&gt;.
     * &lt;p&gt;
     * Layout-related changes, such as bounds of the validate root descendants,
     * do not affect the layout of the validate root parent. This peculiarity
     * enables the {@code invalidate()} method to stop invalidating the
     * component hierarchy when the method encounters a validate root. However,
     * to preserve backward compatibility this new optimized behavior is
     * enabled only when the {@code java.awt.smartInvalidate} system property
     * value is set to {@code true}.
     * &lt;p&gt;
     * If a component hierarchy contains validate roots and the new optimized
     * {@code invalidate()} behavior is enabled, the {@code validate()} method
     * must be invoked on the validate root of a previously invalidated
     * component to restore the validity of the hierarchy later. Otherwise,
     * calling the {@code validate()} method on the top-level container (such
     * as a {@code Frame} object) should be used to restore the validity of the
     * component hierarchy.
     * &lt;p&gt;
     * The {@code Window} class and the {@code Applet} class are the validate
     * roots in AWT.  Swing introduces more validate roots.
     *
     * @return whether this container is a validate root
     * @see #invalidate
     * @see java.awt.Component#invalidate
     * @see javax.swing.JComponent#isValidateRoot
     * @see javax.swing.JComponent#revalidate
     * @since 1.7
     */
    public boolean isValidateRoot() {
<span class="nc" id="L1543">        return false;</span>
    }

    private static final boolean isJavaAwtSmartInvalidate;
    static {
        // Don't lazy-read because every app uses invalidate()
<span class="fc" id="L1549">        isJavaAwtSmartInvalidate = AccessController.doPrivileged(</span>
                new GetBooleanAction(&quot;java.awt.smartInvalidate&quot;));
    }

    /**
     * Invalidates the parent of the container unless the container
     * is a validate root.
     */
    @Override
    void invalidateParent() {
<span class="nc bnc" id="L1559" title="All 4 branches missed.">        if (!isJavaAwtSmartInvalidate || !isValidateRoot()) {</span>
<span class="nc" id="L1560">            super.invalidateParent();</span>
        }
<span class="nc" id="L1562">    }</span>

    /**
     * Invalidates the container.
     * &lt;p&gt;
     * If the {@code LayoutManager} installed on this container is an instance
     * of the {@code LayoutManager2} interface, then
     * the {@link LayoutManager2#invalidateLayout(Container)} method is invoked
     * on it supplying this {@code Container} as the argument.
     * &lt;p&gt;
     * Afterwards this method marks this container invalid, and invalidates its
     * ancestors. See the {@link Component#invalidate} method for more details.
     *
     * @see #validate
     * @see #layout
     * @see LayoutManager2
     */
    @Override
    public void invalidate() {
<span class="nc" id="L1581">        LayoutManager layoutMgr = this.layoutMgr;</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">        if (layoutMgr instanceof LayoutManager2) {</span>
<span class="nc" id="L1583">            LayoutManager2 lm = (LayoutManager2) layoutMgr;</span>
<span class="nc" id="L1584">            lm.invalidateLayout(this);</span>
        }
<span class="nc" id="L1586">        super.invalidate();</span>
<span class="nc" id="L1587">    }</span>

    /**
     * Validates this container and all of its subcomponents.
     * &lt;p&gt;
     * Validating a container means laying out its subcomponents.
     * Layout-related changes, such as setting the bounds of a component, or
     * adding a component to the container, invalidate the container
     * automatically.  Note that the ancestors of the container may be
     * invalidated also (see {@link Component#invalidate} for details.)
     * Therefore, to restore the validity of the hierarchy, the {@code
     * validate()} method should be invoked on the top-most invalid
     * container of the hierarchy.
     * &lt;p&gt;
     * Validating the container may be a quite time-consuming operation. For
     * performance reasons a developer may postpone the validation of the
     * hierarchy till a set of layout-related operations completes, e.g. after
     * adding all the children to the container.
     * &lt;p&gt;
     * If this {@code Container} is not valid, this method invokes
     * the {@code validateTree} method and marks this {@code Container}
     * as valid. Otherwise, no action is performed.
     *
     * @see #add(java.awt.Component)
     * @see #invalidate
     * @see Container#isValidateRoot
     * @see javax.swing.JComponent#revalidate()
     * @see #validateTree
     */
    public void validate() {
<span class="nc" id="L1617">        boolean updateCur = false;</span>
<span class="nc" id="L1618">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L1619" title="All 6 branches missed.">            if ((!isValid() || descendUnconditionallyWhenValidating)</span>
                    &amp;&amp; peer != null)
            {
<span class="nc" id="L1622">                ContainerPeer p = null;</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                if (peer instanceof ContainerPeer) {</span>
<span class="nc" id="L1624">                    p = (ContainerPeer) peer;</span>
                }
<span class="nc bnc" id="L1626" title="All 2 branches missed.">                if (p != null) {</span>
<span class="nc" id="L1627">                    p.beginValidate();</span>
                }
<span class="nc" id="L1629">                validateTree();</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">                if (p != null) {</span>
<span class="nc" id="L1631">                    p.endValidate();</span>
                    // Avoid updating cursor if this is an internal call.
                    // See validateUnconditionally() for details.
<span class="nc bnc" id="L1634" title="All 2 branches missed.">                    if (!descendUnconditionallyWhenValidating) {</span>
<span class="nc" id="L1635">                        updateCur = isVisible();</span>
                    }
                }
            }
<span class="nc" id="L1639">        }</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">        if (updateCur) {</span>
<span class="nc" id="L1641">            updateCursorImmediately();</span>
        }
<span class="nc" id="L1643">    }</span>

    /**
     * Indicates whether valid containers should also traverse their
     * children and call the validateTree() method on them.
     *
     * Synchronization: TreeLock.
     *
     * The field is allowed to be static as long as the TreeLock itself is
     * static.
     *
     * @see #validateUnconditionally()
     */
<span class="fc" id="L1656">    private static boolean descendUnconditionallyWhenValidating = false;</span>

    /**
     * Unconditionally validate the component hierarchy.
     */
    final void validateUnconditionally() {
<span class="nc" id="L1662">        boolean updateCur = false;</span>
<span class="nc" id="L1663">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L1664">            descendUnconditionallyWhenValidating = true;</span>

<span class="nc" id="L1666">            validate();</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">            if (peer instanceof ContainerPeer) {</span>
<span class="nc" id="L1668">                updateCur = isVisible();</span>
            }

<span class="nc" id="L1671">            descendUnconditionallyWhenValidating = false;</span>
<span class="nc" id="L1672">        }</span>
<span class="nc bnc" id="L1673" title="All 2 branches missed.">        if (updateCur) {</span>
<span class="nc" id="L1674">            updateCursorImmediately();</span>
        }
<span class="nc" id="L1676">    }</span>

    /**
     * Recursively descends the container tree and recomputes the
     * layout for any subtrees marked as needing it (those marked as
     * invalid).  Synchronization should be provided by the method
     * that calls this one:  &lt;code&gt;validate&lt;/code&gt;.
     *
     * @see #doLayout
     * @see #validate
     */
    protected void validateTree() {
<span class="nc" id="L1688">        checkTreeLock();</span>
<span class="nc bnc" id="L1689" title="All 4 branches missed.">        if (!isValid() || descendUnconditionallyWhenValidating) {</span>
<span class="nc bnc" id="L1690" title="All 2 branches missed.">            if (peer instanceof ContainerPeer) {</span>
<span class="nc" id="L1691">                ((ContainerPeer)peer).beginLayout();</span>
            }
<span class="nc bnc" id="L1693" title="All 2 branches missed.">            if (!isValid()) {</span>
<span class="nc" id="L1694">                doLayout();</span>
            }
<span class="nc bnc" id="L1696" title="All 2 branches missed.">            for (int i = 0; i &lt; component.size(); i++) {</span>
<span class="nc" id="L1697">                Component comp = component.get(i);</span>
<span class="nc bnc" id="L1698" title="All 4 branches missed.">                if (   (comp instanceof Container)</span>
                       &amp;&amp; !(comp instanceof Window)
<span class="nc bnc" id="L1700" title="All 4 branches missed.">                       &amp;&amp; (!comp.isValid() ||</span>
                           descendUnconditionallyWhenValidating))
                {
<span class="nc" id="L1703">                    ((Container)comp).validateTree();</span>
                } else {
<span class="nc" id="L1705">                    comp.validate();</span>
                }
            }
<span class="nc bnc" id="L1708" title="All 2 branches missed.">            if (peer instanceof ContainerPeer) {</span>
<span class="nc" id="L1709">                ((ContainerPeer)peer).endLayout();</span>
            }
        }
<span class="nc" id="L1712">        super.validate();</span>
<span class="nc" id="L1713">    }</span>

    /**
     * Recursively descends the container tree and invalidates all
     * contained components.
     */
    void invalidateTree() {
<span class="nc" id="L1720">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">            for (int i = 0; i &lt; component.size(); i++) {</span>
<span class="nc" id="L1722">                Component comp = component.get(i);</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">                if (comp instanceof Container) {</span>
<span class="nc" id="L1724">                    ((Container)comp).invalidateTree();</span>
                }
                else {
<span class="nc" id="L1727">                    comp.invalidateIfValid();</span>
                }
            }
<span class="nc" id="L1730">            invalidateIfValid();</span>
<span class="nc" id="L1731">        }</span>
<span class="nc" id="L1732">    }</span>

    /**
     * Sets the font of this container.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param f The font to become this container's font.
     * @see Component#getFont
     * @see #invalidate
     * @since JDK1.0
     */
    public void setFont(Font f) {
<span class="nc" id="L1746">        boolean shouldinvalidate = false;</span>

<span class="nc" id="L1748">        Font oldfont = getFont();</span>
<span class="nc" id="L1749">        super.setFont(f);</span>
<span class="nc" id="L1750">        Font newfont = getFont();</span>
<span class="nc bnc" id="L1751" title="All 4 branches missed.">        if (newfont != oldfont &amp;&amp; (oldfont == null ||</span>
<span class="nc bnc" id="L1752" title="All 2 branches missed.">                                   !oldfont.equals(newfont))) {</span>
<span class="nc" id="L1753">            invalidateTree();</span>
        }
<span class="nc" id="L1755">    }</span>

    /**
     * Returns the preferred size of this container.  If the preferred size has
     * not been set explicitly by {@link Component#setPreferredSize(Dimension)}
     * and this {@code Container} has a {@code non-null} {@link LayoutManager},
     * then {@link LayoutManager#preferredLayoutSize(Container)}
     * is used to calculate the preferred size.
     *
     * &lt;p&gt;Note: some implementations may cache the value returned from the
     * {@code LayoutManager}.  Implementations that cache need not invoke
     * {@code preferredLayoutSize} on the {@code LayoutManager} every time
     * this method is invoked, rather the {@code LayoutManager} will only
     * be queried after the {@code Container} becomes invalid.
     *
     * @return    an instance of &lt;code&gt;Dimension&lt;/code&gt; that represents
     *                the preferred size of this container.
     * @see       #getMinimumSize
     * @see       #getMaximumSize
     * @see       #getLayout
     * @see       LayoutManager#preferredLayoutSize(Container)
     * @see       Component#getPreferredSize
     */
    public Dimension getPreferredSize() {
<span class="nc" id="L1779">        return preferredSize();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getPreferredSize()&lt;/code&gt;.
     */
    @Deprecated
    public Dimension preferredSize() {
        /* Avoid grabbing the lock if a reasonable cached size value
         * is available.
         */
<span class="nc" id="L1791">        Dimension dim = prefSize;</span>
<span class="nc bnc" id="L1792" title="All 6 branches missed.">        if (dim == null || !(isPreferredSizeSet() || isValid())) {</span>
<span class="nc" id="L1793">            synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">                prefSize = (layoutMgr != null) ?</span>
<span class="nc" id="L1795">                    layoutMgr.preferredLayoutSize(this) :</span>
<span class="nc" id="L1796">                    super.preferredSize();</span>
<span class="nc" id="L1797">                dim = prefSize;</span>
<span class="nc" id="L1798">            }</span>
        }
<span class="nc bnc" id="L1800" title="All 2 branches missed.">        if (dim != null){</span>
<span class="nc" id="L1801">            return new Dimension(dim);</span>
        }
        else{
<span class="nc" id="L1804">            return dim;</span>
        }
    }

    /**
     * Returns the minimum size of this container.  If the minimum size has
     * not been set explicitly by {@link Component#setMinimumSize(Dimension)}
     * and this {@code Container} has a {@code non-null} {@link LayoutManager},
     * then {@link LayoutManager#minimumLayoutSize(Container)}
     * is used to calculate the minimum size.
     *
     * &lt;p&gt;Note: some implementations may cache the value returned from the
     * {@code LayoutManager}.  Implementations that cache need not invoke
     * {@code minimumLayoutSize} on the {@code LayoutManager} every time
     * this method is invoked, rather the {@code LayoutManager} will only
     * be queried after the {@code Container} becomes invalid.
     *
     * @return    an instance of &lt;code&gt;Dimension&lt;/code&gt; that represents
     *                the minimum size of this container.
     * @see       #getPreferredSize
     * @see       #getMaximumSize
     * @see       #getLayout
     * @see       LayoutManager#minimumLayoutSize(Container)
     * @see       Component#getMinimumSize
     * @since     JDK1.1
     */
    public Dimension getMinimumSize() {
<span class="nc" id="L1831">        return minimumSize();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getMinimumSize()&lt;/code&gt;.
     */
    @Deprecated
    public Dimension minimumSize() {
        /* Avoid grabbing the lock if a reasonable cached size value
         * is available.
         */
<span class="nc" id="L1843">        Dimension dim = minSize;</span>
<span class="nc bnc" id="L1844" title="All 6 branches missed.">        if (dim == null || !(isMinimumSizeSet() || isValid())) {</span>
<span class="nc" id="L1845">            synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L1846" title="All 2 branches missed.">                minSize = (layoutMgr != null) ?</span>
<span class="nc" id="L1847">                    layoutMgr.minimumLayoutSize(this) :</span>
<span class="nc" id="L1848">                    super.minimumSize();</span>
<span class="nc" id="L1849">                dim = minSize;</span>
<span class="nc" id="L1850">            }</span>
        }
<span class="nc bnc" id="L1852" title="All 2 branches missed.">        if (dim != null){</span>
<span class="nc" id="L1853">            return new Dimension(dim);</span>
        }
        else{
<span class="nc" id="L1856">            return dim;</span>
        }
    }

    /**
     * Returns the maximum size of this container.  If the maximum size has
     * not been set explicitly by {@link Component#setMaximumSize(Dimension)}
     * and the {@link LayoutManager} installed on this {@code Container}
     * is an instance of {@link LayoutManager2}, then
     * {@link LayoutManager2#maximumLayoutSize(Container)}
     * is used to calculate the maximum size.
     *
     * &lt;p&gt;Note: some implementations may cache the value returned from the
     * {@code LayoutManager2}.  Implementations that cache need not invoke
     * {@code maximumLayoutSize} on the {@code LayoutManager2} every time
     * this method is invoked, rather the {@code LayoutManager2} will only
     * be queried after the {@code Container} becomes invalid.
     *
     * @return    an instance of &lt;code&gt;Dimension&lt;/code&gt; that represents
     *                the maximum size of this container.
     * @see       #getPreferredSize
     * @see       #getMinimumSize
     * @see       #getLayout
     * @see       LayoutManager2#maximumLayoutSize(Container)
     * @see       Component#getMaximumSize
     */
    public Dimension getMaximumSize() {
        /* Avoid grabbing the lock if a reasonable cached size value
         * is available.
         */
<span class="nc" id="L1886">        Dimension dim = maxSize;</span>
<span class="nc bnc" id="L1887" title="All 6 branches missed.">        if (dim == null || !(isMaximumSizeSet() || isValid())) {</span>
<span class="nc" id="L1888">            synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">               if (layoutMgr instanceof LayoutManager2) {</span>
<span class="nc" id="L1890">                    LayoutManager2 lm = (LayoutManager2) layoutMgr;</span>
<span class="nc" id="L1891">                    maxSize = lm.maximumLayoutSize(this);</span>
<span class="nc" id="L1892">               } else {</span>
<span class="nc" id="L1893">                    maxSize = super.getMaximumSize();</span>
               }
<span class="nc" id="L1895">               dim = maxSize;</span>
<span class="nc" id="L1896">            }</span>
        }
<span class="nc bnc" id="L1898" title="All 2 branches missed.">        if (dim != null){</span>
<span class="nc" id="L1899">            return new Dimension(dim);</span>
        }
        else{
<span class="nc" id="L1902">            return dim;</span>
        }
    }

    /**
     * Returns the alignment along the x axis.  This specifies how
     * the component would like to be aligned relative to other
     * components.  The value should be a number between 0 and 1
     * where 0 represents alignment along the origin, 1 is aligned
     * the furthest away from the origin, 0.5 is centered, etc.
     */
    public float getAlignmentX() {
        float xAlign;
<span class="nc bnc" id="L1915" title="All 2 branches missed.">        if (layoutMgr instanceof LayoutManager2) {</span>
<span class="nc" id="L1916">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L1917">                LayoutManager2 lm = (LayoutManager2) layoutMgr;</span>
<span class="nc" id="L1918">                xAlign = lm.getLayoutAlignmentX(this);</span>
<span class="nc" id="L1919">            }</span>
        } else {
<span class="nc" id="L1921">            xAlign = super.getAlignmentX();</span>
        }
<span class="nc" id="L1923">        return xAlign;</span>
    }

    /**
     * Returns the alignment along the y axis.  This specifies how
     * the component would like to be aligned relative to other
     * components.  The value should be a number between 0 and 1
     * where 0 represents alignment along the origin, 1 is aligned
     * the furthest away from the origin, 0.5 is centered, etc.
     */
    public float getAlignmentY() {
        float yAlign;
<span class="nc bnc" id="L1935" title="All 2 branches missed.">        if (layoutMgr instanceof LayoutManager2) {</span>
<span class="nc" id="L1936">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L1937">                LayoutManager2 lm = (LayoutManager2) layoutMgr;</span>
<span class="nc" id="L1938">                yAlign = lm.getLayoutAlignmentY(this);</span>
<span class="nc" id="L1939">            }</span>
        } else {
<span class="nc" id="L1941">            yAlign = super.getAlignmentY();</span>
        }
<span class="nc" id="L1943">        return yAlign;</span>
    }

    /**
     * Paints the container. This forwards the paint to any lightweight
     * components that are children of this container. If this method is
     * reimplemented, super.paint(g) should be called so that lightweight
     * components are properly rendered. If a child component is entirely
     * clipped by the current clipping setting in g, paint() will not be
     * forwarded to that child.
     *
     * @param g the specified Graphics window
     * @see   Component#update(Graphics)
     */
    public void paint(Graphics g) {
<span class="nc bnc" id="L1958" title="All 2 branches missed.">        if (isShowing()) {</span>
<span class="nc" id="L1959">            synchronized (getObjectLock()) {</span>
<span class="nc bnc" id="L1960" title="All 2 branches missed.">                if (printing) {</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">                    if (printingThreads.contains(Thread.currentThread())) {</span>
<span class="nc" id="L1962">                        return;</span>
                    }
                }
<span class="nc" id="L1965">            }</span>

            // The container is showing on screen and
            // this paint() is not called from print().
            // Paint self and forward the paint to lightweight subcomponents.

            // super.paint(); -- Don't bother, since it's a NOP.

<span class="nc" id="L1973">            GraphicsCallback.PaintCallback.getInstance().</span>
<span class="nc" id="L1974">                runComponents(getComponentsSync(), g, GraphicsCallback.LIGHTWEIGHTS);</span>
        }
<span class="nc" id="L1976">    }</span>

    /**
     * Updates the container.  This forwards the update to any lightweight
     * components that are children of this container.  If this method is
     * reimplemented, super.update(g) should be called so that lightweight
     * components are properly rendered.  If a child component is entirely
     * clipped by the current clipping setting in g, update() will not be
     * forwarded to that child.
     *
     * @param g the specified Graphics window
     * @see   Component#update(Graphics)
     */
    public void update(Graphics g) {
<span class="nc bnc" id="L1990" title="All 2 branches missed.">        if (isShowing()) {</span>
<span class="nc bnc" id="L1991" title="All 2 branches missed.">            if (! (peer instanceof LightweightPeer)) {</span>
<span class="nc" id="L1992">                g.clearRect(0, 0, width, height);</span>
            }
<span class="nc" id="L1994">            paint(g);</span>
        }
<span class="nc" id="L1996">    }</span>

    /**
     * Prints the container. This forwards the print to any lightweight
     * components that are children of this container. If this method is
     * reimplemented, super.print(g) should be called so that lightweight
     * components are properly rendered. If a child component is entirely
     * clipped by the current clipping setting in g, print() will not be
     * forwarded to that child.
     *
     * @param g the specified Graphics window
     * @see   Component#update(Graphics)
     */
    public void print(Graphics g) {
<span class="nc bnc" id="L2010" title="All 2 branches missed.">        if (isShowing()) {</span>
<span class="nc" id="L2011">            Thread t = Thread.currentThread();</span>
            try {
<span class="nc" id="L2013">                synchronized (getObjectLock()) {</span>
<span class="nc bnc" id="L2014" title="All 2 branches missed.">                    if (printingThreads == null) {</span>
<span class="nc" id="L2015">                        printingThreads = new HashSet&lt;&gt;();</span>
                    }
<span class="nc" id="L2017">                    printingThreads.add(t);</span>
<span class="nc" id="L2018">                    printing = true;</span>
<span class="nc" id="L2019">                }</span>
<span class="nc" id="L2020">                super.print(g);  // By default, Component.print() calls paint()</span>
            } finally {
<span class="nc" id="L2022">                synchronized (getObjectLock()) {</span>
<span class="nc" id="L2023">                    printingThreads.remove(t);</span>
<span class="nc bnc" id="L2024" title="All 4 branches missed.">                    printing = !printingThreads.isEmpty();</span>
<span class="nc" id="L2025">                }</span>
<span class="nc" id="L2026">            }</span>

<span class="nc" id="L2028">            GraphicsCallback.PrintCallback.getInstance().</span>
<span class="nc" id="L2029">                runComponents(getComponentsSync(), g, GraphicsCallback.LIGHTWEIGHTS);</span>
        }
<span class="nc" id="L2031">    }</span>

    /**
     * Paints each of the components in this container.
     * @param     g   the graphics context.
     * @see       Component#paint
     * @see       Component#paintAll
     */
    public void paintComponents(Graphics g) {
<span class="nc bnc" id="L2040" title="All 2 branches missed.">        if (isShowing()) {</span>
<span class="nc" id="L2041">            GraphicsCallback.PaintAllCallback.getInstance().</span>
<span class="nc" id="L2042">                runComponents(getComponentsSync(), g, GraphicsCallback.TWO_PASSES);</span>
        }
<span class="nc" id="L2044">    }</span>

    /**
     * Simulates the peer callbacks into java.awt for printing of
     * lightweight Containers.
     * @param     g   the graphics context to use for printing.
     * @see       Component#printAll
     * @see       #printComponents
     */
    void lightweightPaint(Graphics g) {
<span class="nc" id="L2054">        super.lightweightPaint(g);</span>
<span class="nc" id="L2055">        paintHeavyweightComponents(g);</span>
<span class="nc" id="L2056">    }</span>

    /**
     * Prints all the heavyweight subcomponents.
     */
    void paintHeavyweightComponents(Graphics g) {
<span class="nc bnc" id="L2062" title="All 2 branches missed.">        if (isShowing()) {</span>
<span class="nc" id="L2063">            GraphicsCallback.PaintHeavyweightComponentsCallback.getInstance().</span>
<span class="nc" id="L2064">                runComponents(getComponentsSync(), g,</span>
                              GraphicsCallback.LIGHTWEIGHTS | GraphicsCallback.HEAVYWEIGHTS);
        }
<span class="nc" id="L2067">    }</span>

    /**
     * Prints each of the components in this container.
     * @param     g   the graphics context.
     * @see       Component#print
     * @see       Component#printAll
     */
    public void printComponents(Graphics g) {
<span class="nc bnc" id="L2076" title="All 2 branches missed.">        if (isShowing()) {</span>
<span class="nc" id="L2077">            GraphicsCallback.PrintAllCallback.getInstance().</span>
<span class="nc" id="L2078">                runComponents(getComponentsSync(), g, GraphicsCallback.TWO_PASSES);</span>
        }
<span class="nc" id="L2080">    }</span>

    /**
     * Simulates the peer callbacks into java.awt for printing of
     * lightweight Containers.
     * @param     g   the graphics context to use for printing.
     * @see       Component#printAll
     * @see       #printComponents
     */
    void lightweightPrint(Graphics g) {
<span class="nc" id="L2090">        super.lightweightPrint(g);</span>
<span class="nc" id="L2091">        printHeavyweightComponents(g);</span>
<span class="nc" id="L2092">    }</span>

    /**
     * Prints all the heavyweight subcomponents.
     */
    void printHeavyweightComponents(Graphics g) {
<span class="nc bnc" id="L2098" title="All 2 branches missed.">        if (isShowing()) {</span>
<span class="nc" id="L2099">            GraphicsCallback.PrintHeavyweightComponentsCallback.getInstance().</span>
<span class="nc" id="L2100">                runComponents(getComponentsSync(), g,</span>
                              GraphicsCallback.LIGHTWEIGHTS | GraphicsCallback.HEAVYWEIGHTS);
        }
<span class="nc" id="L2103">    }</span>

    /**
     * Adds the specified container listener to receive container events
     * from this container.
     * If l is null, no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l the container listener
     *
     * @see #removeContainerListener
     * @see #getContainerListeners
     */
    public synchronized void addContainerListener(ContainerListener l) {
<span class="nc bnc" id="L2118" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L2119">            return;</span>
        }
<span class="nc" id="L2121">        containerListener = AWTEventMulticaster.add(containerListener, l);</span>
<span class="nc" id="L2122">        newEventsOnly = true;</span>
<span class="nc" id="L2123">    }</span>

    /**
     * Removes the specified container listener so it no longer receives
     * container events from this container.
     * If l is null, no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param   l the container listener
     *
     * @see #addContainerListener
     * @see #getContainerListeners
     */
    public synchronized void removeContainerListener(ContainerListener l) {
<span class="nc bnc" id="L2138" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L2139">            return;</span>
        }
<span class="nc" id="L2141">        containerListener = AWTEventMulticaster.remove(containerListener, l);</span>
<span class="nc" id="L2142">    }</span>

    /**
     * Returns an array of all the container listeners
     * registered on this container.
     *
     * @return all of this container's &lt;code&gt;ContainerListener&lt;/code&gt;s
     *         or an empty array if no container
     *         listeners are currently registered
     *
     * @see #addContainerListener
     * @see #removeContainerListener
     * @since 1.4
     */
    public synchronized ContainerListener[] getContainerListeners() {
<span class="nc" id="L2157">        return getListeners(ContainerListener.class);</span>
    }

    /**
     * Returns an array of all the objects currently registered
     * as &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s
     * upon this &lt;code&gt;Container&lt;/code&gt;.
     * &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
     * &lt;code&gt;add&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt; method.
     *
     * &lt;p&gt;
     * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
     * with a class literal, such as
     * &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener.class&lt;/code&gt;.
     * For example, you can query a
     * &lt;code&gt;Container&lt;/code&gt; &lt;code&gt;c&lt;/code&gt;
     * for its container listeners with the following code:
     *
     * &lt;pre&gt;ContainerListener[] cls = (ContainerListener[])(c.getListeners(ContainerListener.class));&lt;/pre&gt;
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @return an array of all objects registered as
     *          &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s on this container,
     *          or an empty array if no such listeners have been added
     * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt;
     *          doesn't specify a class or interface that implements
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @exception NullPointerException if {@code listenerType} is {@code null}
     *
     * @see #getContainerListeners
     *
     * @since 1.3
     */
    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<span class="nc" id="L2195">        EventListener l = null;</span>
<span class="nc bnc" id="L2196" title="All 2 branches missed.">        if  (listenerType == ContainerListener.class) {</span>
<span class="nc" id="L2197">            l = containerListener;</span>
        } else {
<span class="nc" id="L2199">            return super.getListeners(listenerType);</span>
        }
<span class="nc" id="L2201">        return AWTEventMulticaster.getListeners(l, listenerType);</span>
    }

    // REMIND: remove when filtering is done at lower level
    boolean eventEnabled(AWTEvent e) {
<span class="nc" id="L2206">        int id = e.getID();</span>

<span class="nc bnc" id="L2208" title="All 4 branches missed.">        if (id == ContainerEvent.COMPONENT_ADDED ||</span>
            id == ContainerEvent.COMPONENT_REMOVED) {
<span class="nc bnc" id="L2210" title="All 4 branches missed.">            if ((eventMask &amp; AWTEvent.CONTAINER_EVENT_MASK) != 0 ||</span>
                containerListener != null) {
<span class="nc" id="L2212">                return true;</span>
            }
<span class="nc" id="L2214">            return false;</span>
        }
<span class="nc" id="L2216">        return super.eventEnabled(e);</span>
    }

    /**
     * Processes events on this container. If the event is a
     * &lt;code&gt;ContainerEvent&lt;/code&gt;, it invokes the
     * &lt;code&gt;processContainerEvent&lt;/code&gt; method, else it invokes
     * its superclass's &lt;code&gt;processEvent&lt;/code&gt;.
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param e the event
     */
    protected void processEvent(AWTEvent e) {
<span class="nc bnc" id="L2231" title="All 2 branches missed.">        if (e instanceof ContainerEvent) {</span>
<span class="nc" id="L2232">            processContainerEvent((ContainerEvent)e);</span>
<span class="nc" id="L2233">            return;</span>
        }
<span class="nc" id="L2235">        super.processEvent(e);</span>
<span class="nc" id="L2236">    }</span>

    /**
     * Processes container events occurring on this container by
     * dispatching them to any registered ContainerListener objects.
     * NOTE: This method will not be called unless container events
     * are enabled for this component; this happens when one of the
     * following occurs:
     * &lt;ul&gt;
     * &lt;li&gt;A ContainerListener object is registered via
     *     &lt;code&gt;addContainerListener&lt;/code&gt;
     * &lt;li&gt;Container events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param e the container event
     * @see Component#enableEvents
     */
    protected void processContainerEvent(ContainerEvent e) {
<span class="nc" id="L2257">        ContainerListener listener = containerListener;</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc bnc" id="L2259" title="All 3 branches missed.">            switch(e.getID()) {</span>
              case ContainerEvent.COMPONENT_ADDED:
<span class="nc" id="L2261">                listener.componentAdded(e);</span>
<span class="nc" id="L2262">                break;</span>
              case ContainerEvent.COMPONENT_REMOVED:
<span class="nc" id="L2264">                listener.componentRemoved(e);</span>
                break;
            }
        }
<span class="nc" id="L2268">    }</span>

    /*
     * Dispatches an event to this component or one of its sub components.
     * Create ANCESTOR_RESIZED and ANCESTOR_MOVED events in response to
     * COMPONENT_RESIZED and COMPONENT_MOVED events. We have to do this
     * here instead of in processComponentEvent because ComponentEvents
     * may not be enabled for this Container.
     * @param e the event
     */
    void dispatchEventImpl(AWTEvent e) {
<span class="nc bnc" id="L2279" title="All 4 branches missed.">        if ((dispatcher != null) &amp;&amp; dispatcher.dispatchEvent(e)) {</span>
            // event was sent to a lightweight component.  The
            // native-produced event sent to the native container
            // must be properly disposed of by the peer, so it
            // gets forwarded.  If the native host has been removed
            // as a result of the sending the lightweight event,
            // the peer reference will be null.
<span class="nc" id="L2286">            e.consume();</span>
<span class="nc bnc" id="L2287" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L2288">                peer.handleEvent(e);</span>
            }
<span class="nc" id="L2290">            return;</span>
        }

<span class="nc" id="L2293">        super.dispatchEventImpl(e);</span>

<span class="nc" id="L2295">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L2296" title="All 3 branches missed.">            switch (e.getID()) {</span>
              case ComponentEvent.COMPONENT_RESIZED:
<span class="nc" id="L2298">                createChildHierarchyEvents(HierarchyEvent.ANCESTOR_RESIZED, 0,</span>
<span class="nc" id="L2299">                                           Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));</span>
<span class="nc" id="L2300">                break;</span>
              case ComponentEvent.COMPONENT_MOVED:
<span class="nc" id="L2302">                createChildHierarchyEvents(HierarchyEvent.ANCESTOR_MOVED, 0,</span>
<span class="nc" id="L2303">                                       Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));</span>
<span class="nc" id="L2304">                break;</span>
              default:
                break;
            }
<span class="nc" id="L2308">        }</span>
<span class="nc" id="L2309">    }</span>

    /*
     * Dispatches an event to this component, without trying to forward
     * it to any subcomponents
     * @param e the event
     */
    void dispatchEventToSelf(AWTEvent e) {
<span class="nc" id="L2317">        super.dispatchEventImpl(e);</span>
<span class="nc" id="L2318">    }</span>

    /**
     * Fetchs the top-most (deepest) lightweight component that is interested
     * in receiving mouse events.
     */
    Component getMouseEventTarget(int x, int y, boolean includeSelf) {
<span class="nc" id="L2325">        return getMouseEventTarget(x, y, includeSelf,</span>
                                   MouseEventTargetFilter.FILTER,
                                   !SEARCH_HEAVYWEIGHTS);
    }

    /**
     * Fetches the top-most (deepest) component to receive SunDropTargetEvents.
     */
    Component getDropTargetEventTarget(int x, int y, boolean includeSelf) {
<span class="nc" id="L2334">        return getMouseEventTarget(x, y, includeSelf,</span>
                                   DropTargetEventTargetFilter.FILTER,
                                   SEARCH_HEAVYWEIGHTS);
    }

    /**
     * A private version of getMouseEventTarget which has two additional
     * controllable behaviors. This method searches for the top-most
     * descendant of this container that contains the given coordinates
     * and is accepted by the given filter. The search will be constrained to
     * lightweight descendants if the last argument is &lt;code&gt;false&lt;/code&gt;.
     *
     * @param filter EventTargetFilter instance to determine whether the
     *        given component is a valid target for this event.
     * @param searchHeavyweights if &lt;code&gt;false&lt;/code&gt;, the method
     *        will bypass heavyweight components during the search.
     */
    private Component getMouseEventTarget(int x, int y, boolean includeSelf,
                                          EventTargetFilter filter,
                                          boolean searchHeavyweights) {
<span class="nc" id="L2354">        Component comp = null;</span>
<span class="nc bnc" id="L2355" title="All 2 branches missed.">        if (searchHeavyweights) {</span>
<span class="nc" id="L2356">            comp = getMouseEventTargetImpl(x, y, includeSelf, filter,</span>
                                           SEARCH_HEAVYWEIGHTS,
                                           searchHeavyweights);
        }

<span class="nc bnc" id="L2361" title="All 4 branches missed.">        if (comp == null || comp == this) {</span>
<span class="nc" id="L2362">            comp = getMouseEventTargetImpl(x, y, includeSelf, filter,</span>
                                           !SEARCH_HEAVYWEIGHTS,
                                           searchHeavyweights);
        }

<span class="nc" id="L2367">        return comp;</span>
    }

    /**
     * A private version of getMouseEventTarget which has three additional
     * controllable behaviors. This method searches for the top-most
     * descendant of this container that contains the given coordinates
     * and is accepted by the given filter. The search will be constrained to
     * descendants of only lightweight children or only heavyweight children
     * of this container depending on searchHeavyweightChildren. The search will
     * be constrained to only lightweight descendants of the searched children
     * of this container if searchHeavyweightDescendants is &lt;code&gt;false&lt;/code&gt;.
     *
     * @param filter EventTargetFilter instance to determine whether the
     *        selected component is a valid target for this event.
     * @param searchHeavyweightChildren if &lt;code&gt;true&lt;/code&gt;, the method
     *        will bypass immediate lightweight children during the search.
     *        If &lt;code&gt;false&lt;/code&gt;, the methods will bypass immediate
     *        heavyweight children during the search.
     * @param searchHeavyweightDescendants if &lt;code&gt;false&lt;/code&gt;, the method
     *        will bypass heavyweight descendants which are not immediate
     *        children during the search. If &lt;code&gt;true&lt;/code&gt;, the method
     *        will traverse both lightweight and heavyweight descendants during
     *        the search.
     */
    private Component getMouseEventTargetImpl(int x, int y, boolean includeSelf,
                                         EventTargetFilter filter,
                                         boolean searchHeavyweightChildren,
                                         boolean searchHeavyweightDescendants) {
<span class="nc" id="L2396">        synchronized (getTreeLock()) {</span>

<span class="nc bnc" id="L2398" title="All 2 branches missed.">            for (int i = 0; i &lt; component.size(); i++) {</span>
<span class="nc" id="L2399">                Component comp = component.get(i);</span>
<span class="nc bnc" id="L2400" title="All 12 branches missed.">                if (comp != null &amp;&amp; comp.visible &amp;&amp;</span>
                    ((!searchHeavyweightChildren &amp;&amp;
                      comp.peer instanceof LightweightPeer) ||
                     (searchHeavyweightChildren &amp;&amp;
                      !(comp.peer instanceof LightweightPeer))) &amp;&amp;
<span class="nc bnc" id="L2405" title="All 2 branches missed.">                    comp.contains(x - comp.x, y - comp.y)) {</span>

                    // found a component that intersects the point, see if there
                    // is a deeper possibility.
<span class="nc bnc" id="L2409" title="All 2 branches missed.">                    if (comp instanceof Container) {</span>
<span class="nc" id="L2410">                        Container child = (Container) comp;</span>
<span class="nc" id="L2411">                        Component deeper = child.getMouseEventTarget(</span>
                                x - child.x,
                                y - child.y,
                                includeSelf,
                                filter,
                                searchHeavyweightDescendants);
<span class="nc bnc" id="L2417" title="All 2 branches missed.">                        if (deeper != null) {</span>
<span class="nc" id="L2418">                            return deeper;</span>
                        }
<span class="nc" id="L2420">                    } else {</span>
<span class="nc bnc" id="L2421" title="All 2 branches missed.">                        if (filter.accept(comp)) {</span>
                            // there isn't a deeper target, but this component
                            // is a target
<span class="nc" id="L2424">                            return comp;</span>
                        }
                    }
                }
            }

            boolean isPeerOK;
            boolean isMouseOverMe;

<span class="nc bnc" id="L2433" title="All 4 branches missed.">            isPeerOK = (peer instanceof LightweightPeer) || includeSelf;</span>
<span class="nc" id="L2434">            isMouseOverMe = contains(x,y);</span>

            // didn't find a child target, return this component if it's
            // a possible target
<span class="nc bnc" id="L2438" title="All 6 branches missed.">            if (isMouseOverMe &amp;&amp; isPeerOK &amp;&amp; filter.accept(this)) {</span>
<span class="nc" id="L2439">                return this;</span>
            }
            // no possible target
<span class="nc" id="L2442">            return null;</span>
<span class="nc" id="L2443">        }</span>
    }

    static interface EventTargetFilter {
        boolean accept(final Component comp);
    }

    static class MouseEventTargetFilter implements EventTargetFilter {
<span class="nc" id="L2451">        static final EventTargetFilter FILTER = new MouseEventTargetFilter();</span>

<span class="nc" id="L2453">        private MouseEventTargetFilter() {}</span>

        public boolean accept(final Component comp) {
<span class="nc bnc" id="L2456" title="All 12 branches missed.">            return (comp.eventMask &amp; AWTEvent.MOUSE_MOTION_EVENT_MASK) != 0</span>
                || (comp.eventMask &amp; AWTEvent.MOUSE_EVENT_MASK) != 0
                || (comp.eventMask &amp; AWTEvent.MOUSE_WHEEL_EVENT_MASK) != 0
                || comp.mouseListener != null
                || comp.mouseMotionListener != null
                || comp.mouseWheelListener != null;
        }
    }

    static class DropTargetEventTargetFilter implements EventTargetFilter {
<span class="nc" id="L2466">        static final EventTargetFilter FILTER = new DropTargetEventTargetFilter();</span>

<span class="nc" id="L2468">        private DropTargetEventTargetFilter() {}</span>

        public boolean accept(final Component comp) {
<span class="nc" id="L2471">            DropTarget dt = comp.getDropTarget();</span>
<span class="nc bnc" id="L2472" title="All 4 branches missed.">            return dt != null &amp;&amp; dt.isActive();</span>
        }
    }

    /**
     * This is called by lightweight components that want the containing
     * windowed parent to enable some kind of events on their behalf.
     * This is needed for events that are normally only dispatched to
     * windows to be accepted so that they can be forwarded downward to
     * the lightweight component that has enabled them.
     */
    void proxyEnableEvents(long events) {
<span class="nc bnc" id="L2484" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
            // this container is lightweight.... continue sending it
            // upward.
<span class="nc bnc" id="L2487" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L2488">                parent.proxyEnableEvents(events);</span>
            }
        } else {
            // This is a native container, so it needs to host
            // one of it's children.  If this function is called before
            // a peer has been created we don't yet have a dispatcher
            // because it has not yet been determined if this instance
            // is lightweight.
<span class="nc bnc" id="L2496" title="All 2 branches missed.">            if (dispatcher != null) {</span>
<span class="nc" id="L2497">                dispatcher.enableEvents(events);</span>
            }
        }
<span class="nc" id="L2500">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;dispatchEvent(AWTEvent e)&lt;/code&gt;
     */
    @Deprecated
    public void deliverEvent(Event e) {
<span class="nc" id="L2508">        Component comp = getComponentAt(e.x, e.y);</span>
<span class="nc bnc" id="L2509" title="All 4 branches missed.">        if ((comp != null) &amp;&amp; (comp != this)) {</span>
<span class="nc" id="L2510">            e.translate(-comp.x, -comp.y);</span>
<span class="nc" id="L2511">            comp.deliverEvent(e);</span>
        } else {
<span class="nc" id="L2513">            postEvent(e);</span>
        }
<span class="nc" id="L2515">    }</span>

    /**
     * Locates the component that contains the x,y position.  The
     * top-most child component is returned in the case where there
     * is overlap in the components.  This is determined by finding
     * the component closest to the index 0 that claims to contain
     * the given point via Component.contains(), except that Components
     * which have native peers take precedence over those which do not
     * (i.e., lightweight Components).
     *
     * @param x the &lt;i&gt;x&lt;/i&gt; coordinate
     * @param y the &lt;i&gt;y&lt;/i&gt; coordinate
     * @return null if the component does not contain the position.
     * If there is no child component at the requested point and the
     * point is within the bounds of the container the container itself
     * is returned; otherwise the top-most child is returned.
     * @see Component#contains
     * @since JDK1.1
     */
    public Component getComponentAt(int x, int y) {
<span class="nc" id="L2536">        return locate(x, y);</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getComponentAt(int, int)&lt;/code&gt;.
     */
    @Deprecated
    public Component locate(int x, int y) {
<span class="nc bnc" id="L2545" title="All 2 branches missed.">        if (!contains(x, y)) {</span>
<span class="nc" id="L2546">            return null;</span>
        }
<span class="nc" id="L2548">        synchronized (getTreeLock()) {</span>
            // Two passes: see comment in sun.awt.SunGraphicsCallback
<span class="nc bnc" id="L2550" title="All 2 branches missed.">            for (int i = 0; i &lt; component.size(); i++) {</span>
<span class="nc" id="L2551">                Component comp = component.get(i);</span>
<span class="nc bnc" id="L2552" title="All 4 branches missed.">                if (comp != null &amp;&amp;</span>
                    !(comp.peer instanceof LightweightPeer)) {
<span class="nc bnc" id="L2554" title="All 2 branches missed.">                    if (comp.contains(x - comp.x, y - comp.y)) {</span>
<span class="nc" id="L2555">                        return comp;</span>
                    }
                }
            }
<span class="nc bnc" id="L2559" title="All 2 branches missed.">            for (int i = 0; i &lt; component.size(); i++) {</span>
<span class="nc" id="L2560">                Component comp = component.get(i);</span>
<span class="nc bnc" id="L2561" title="All 4 branches missed.">                if (comp != null &amp;&amp;</span>
                    comp.peer instanceof LightweightPeer) {
<span class="nc bnc" id="L2563" title="All 2 branches missed.">                    if (comp.contains(x - comp.x, y - comp.y)) {</span>
<span class="nc" id="L2564">                        return comp;</span>
                    }
                }
            }
<span class="nc" id="L2568">        }</span>
<span class="nc" id="L2569">        return this;</span>
    }

    /**
     * Gets the component that contains the specified point.
     * @param      p   the point.
     * @return     returns the component that contains the point,
     *                 or &lt;code&gt;null&lt;/code&gt; if the component does
     *                 not contain the point.
     * @see        Component#contains
     * @since      JDK1.1
     */
    public Component getComponentAt(Point p) {
<span class="nc" id="L2582">        return getComponentAt(p.x, p.y);</span>
    }

    /**
     * Returns the position of the mouse pointer in this &lt;code&gt;Container&lt;/code&gt;'s
     * coordinate space if the &lt;code&gt;Container&lt;/code&gt; is under the mouse pointer,
     * otherwise returns &lt;code&gt;null&lt;/code&gt;.
     * This method is similar to {@link Component#getMousePosition()} with the exception
     * that it can take the &lt;code&gt;Container&lt;/code&gt;'s children into account.
     * If &lt;code&gt;allowChildren&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this method will return
     * a non-null value only if the mouse pointer is above the &lt;code&gt;Container&lt;/code&gt;
     * directly, not above the part obscured by children.
     * If &lt;code&gt;allowChildren&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this method returns
     * a non-null value if the mouse pointer is above &lt;code&gt;Container&lt;/code&gt; or any
     * of its descendants.
     *
     * @exception HeadlessException if GraphicsEnvironment.isHeadless() returns true
     * @param     allowChildren true if children should be taken into account
     * @see       Component#getMousePosition
     * @return    mouse coordinates relative to this &lt;code&gt;Component&lt;/code&gt;, or null
     * @since     1.5
     */
    public Point getMousePosition(boolean allowChildren) throws HeadlessException {
<span class="nc bnc" id="L2605" title="All 2 branches missed.">        if (GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L2606">            throw new HeadlessException();</span>
        }
<span class="nc" id="L2608">        PointerInfo pi = java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L2609">            new java.security.PrivilegedAction&lt;PointerInfo&gt;() {</span>
                public PointerInfo run() {
<span class="nc" id="L2611">                    return MouseInfo.getPointerInfo();</span>
                }
            }
        );
<span class="nc" id="L2615">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L2616">            Component inTheSameWindow = findUnderMouseInWindow(pi);</span>
<span class="nc bnc" id="L2617" title="All 2 branches missed.">            if (isSameOrAncestorOf(inTheSameWindow, allowChildren)) {</span>
<span class="nc" id="L2618">                return  pointRelativeToComponent(pi.getLocation());</span>
            }
<span class="nc" id="L2620">            return null;</span>
<span class="nc" id="L2621">        }</span>
    }

    boolean isSameOrAncestorOf(Component comp, boolean allowChildren) {
<span class="nc bnc" id="L2625" title="All 6 branches missed.">        return this == comp || (allowChildren &amp;&amp; isParentOf(comp));</span>
    }

    /**
     * Locates the visible child component that contains the specified
     * position.  The top-most child component is returned in the case
     * where there is overlap in the components.  If the containing child
     * component is a Container, this method will continue searching for
     * the deepest nested child component.  Components which are not
     * visible are ignored during the search.&lt;p&gt;
     *
     * The findComponentAt method is different from getComponentAt in
     * that getComponentAt only searches the Container's immediate
     * children; if the containing component is a Container,
     * findComponentAt will search that child to find a nested component.
     *
     * @param x the &lt;i&gt;x&lt;/i&gt; coordinate
     * @param y the &lt;i&gt;y&lt;/i&gt; coordinate
     * @return null if the component does not contain the position.
     * If there is no child component at the requested point and the
     * point is within the bounds of the container the container itself
     * is returned.
     * @see Component#contains
     * @see #getComponentAt
     * @since 1.2
     */
    public Component findComponentAt(int x, int y) {
<span class="nc" id="L2652">        return findComponentAt(x, y, true);</span>
    }

    /**
     * Private version of findComponentAt which has a controllable
     * behavior. Setting 'ignoreEnabled' to 'false' bypasses disabled
     * Components during the search. This behavior is used by the
     * lightweight cursor support in sun.awt.GlobalCursorManager.
     *
     * The addition of this feature is temporary, pending the
     * adoption of new, public API which exports this feature.
     */
    final Component findComponentAt(int x, int y, boolean ignoreEnabled) {
<span class="nc" id="L2665">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L2666" title="All 2 branches missed.">            if (isRecursivelyVisible()){</span>
<span class="nc" id="L2667">                return findComponentAtImpl(x, y, ignoreEnabled);</span>
            }
<span class="nc" id="L2669">        }</span>
<span class="nc" id="L2670">        return null;</span>
    }

    final Component findComponentAtImpl(int x, int y, boolean ignoreEnabled){
<span class="nc" id="L2674">        checkTreeLock();</span>

<span class="nc bnc" id="L2676" title="All 8 branches missed.">        if (!(contains(x, y) &amp;&amp; visible &amp;&amp; (ignoreEnabled || enabled))) {</span>
<span class="nc" id="L2677">            return null;</span>
        }

        // Two passes: see comment in sun.awt.SunGraphicsCallback
<span class="nc bnc" id="L2681" title="All 2 branches missed.">        for (int i = 0; i &lt; component.size(); i++) {</span>
<span class="nc" id="L2682">            Component comp = component.get(i);</span>
<span class="nc bnc" id="L2683" title="All 4 branches missed.">            if (comp != null &amp;&amp;</span>
                !(comp.peer instanceof LightweightPeer)) {
<span class="nc bnc" id="L2685" title="All 2 branches missed.">                if (comp instanceof Container) {</span>
<span class="nc" id="L2686">                    comp = ((Container)comp).findComponentAtImpl(x - comp.x,</span>
                                                                 y - comp.y,
                                                                 ignoreEnabled);
                } else {
<span class="nc" id="L2690">                    comp = comp.getComponentAt(x - comp.x, y - comp.y);</span>
                }
<span class="nc bnc" id="L2692" title="All 8 branches missed.">                if (comp != null &amp;&amp; comp.visible &amp;&amp;</span>
                    (ignoreEnabled || comp.enabled))
                {
<span class="nc" id="L2695">                    return comp;</span>
                }
            }
        }
<span class="nc bnc" id="L2699" title="All 2 branches missed.">        for (int i = 0; i &lt; component.size(); i++) {</span>
<span class="nc" id="L2700">            Component comp = component.get(i);</span>
<span class="nc bnc" id="L2701" title="All 4 branches missed.">            if (comp != null &amp;&amp;</span>
                comp.peer instanceof LightweightPeer) {
<span class="nc bnc" id="L2703" title="All 2 branches missed.">                if (comp instanceof Container) {</span>
<span class="nc" id="L2704">                    comp = ((Container)comp).findComponentAtImpl(x - comp.x,</span>
                                                                 y - comp.y,
                                                                 ignoreEnabled);
                } else {
<span class="nc" id="L2708">                    comp = comp.getComponentAt(x - comp.x, y - comp.y);</span>
                }
<span class="nc bnc" id="L2710" title="All 8 branches missed.">                if (comp != null &amp;&amp; comp.visible &amp;&amp;</span>
                    (ignoreEnabled || comp.enabled))
                {
<span class="nc" id="L2713">                    return comp;</span>
                }
            }
        }

<span class="nc" id="L2718">        return this;</span>
    }

    /**
     * Locates the visible child component that contains the specified
     * point.  The top-most child component is returned in the case
     * where there is overlap in the components.  If the containing child
     * component is a Container, this method will continue searching for
     * the deepest nested child component.  Components which are not
     * visible are ignored during the search.&lt;p&gt;
     *
     * The findComponentAt method is different from getComponentAt in
     * that getComponentAt only searches the Container's immediate
     * children; if the containing component is a Container,
     * findComponentAt will search that child to find a nested component.
     *
     * @param      p   the point.
     * @return null if the component does not contain the position.
     * If there is no child component at the requested point and the
     * point is within the bounds of the container the container itself
     * is returned.
     * @throws NullPointerException if {@code p} is {@code null}
     * @see Component#contains
     * @see #getComponentAt
     * @since 1.2
     */
    public Component findComponentAt(Point p) {
<span class="nc" id="L2745">        return findComponentAt(p.x, p.y);</span>
    }

    /**
     * Makes this Container displayable by connecting it to
     * a native screen resource.  Making a container displayable will
     * cause all of its children to be made displayable.
     * This method is called internally by the toolkit and should
     * not be called directly by programs.
     * @see Component#isDisplayable
     * @see #removeNotify
     */
    public void addNotify() {
<span class="nc" id="L2758">        synchronized (getTreeLock()) {</span>
            // addNotify() on the children may cause proxy event enabling
            // on this instance, so we first call super.addNotify() and
            // possibly create an lightweight event dispatcher before calling
            // addNotify() on the children which may be lightweight.
<span class="nc" id="L2763">            super.addNotify();</span>
<span class="nc bnc" id="L2764" title="All 2 branches missed.">            if (! (peer instanceof LightweightPeer)) {</span>
<span class="nc" id="L2765">                dispatcher = new LightweightDispatcher(this);</span>
            }

            // We shouldn't use iterator because of the Swing menu
            // implementation specifics:
            // the menu is being assigned as a child to JLayeredPane
            // instead of particular component so always affect
            // collection of component if menu is becoming shown or hidden.
<span class="nc bnc" id="L2773" title="All 2 branches missed.">            for (int i = 0; i &lt; component.size(); i++) {</span>
<span class="nc" id="L2774">                component.get(i).addNotify();</span>
            }
<span class="nc" id="L2776">        }</span>
<span class="nc" id="L2777">    }</span>

    /**
     * Makes this Container undisplayable by removing its connection
     * to its native screen resource.  Making a container undisplayable
     * will cause all of its children to be made undisplayable.
     * This method is called by the toolkit internally and should
     * not be called directly by programs.
     * @see Component#isDisplayable
     * @see #addNotify
     */
    public void removeNotify() {
<span class="nc" id="L2789">        synchronized (getTreeLock()) {</span>
            // We shouldn't use iterator because of the Swing menu
            // implementation specifics:
            // the menu is being assigned as a child to JLayeredPane
            // instead of particular component so always affect
            // collection of component if menu is becoming shown or hidden.
<span class="nc bnc" id="L2795" title="All 2 branches missed.">            for (int i = component.size()-1 ; i &gt;= 0 ; i--) {</span>
<span class="nc" id="L2796">                Component comp = component.get(i);</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">                if (comp != null) {</span>
                    // Fix for 6607170.
                    // We want to suppress focus change on disposal
                    // of the focused component. But because of focus
                    // is asynchronous, we should suppress focus change
                    // on every component in case it receives native focus
                    // in the process of disposal.
<span class="nc" id="L2804">                    comp.setAutoFocusTransferOnDisposal(false);</span>
<span class="nc" id="L2805">                    comp.removeNotify();</span>
<span class="nc" id="L2806">                    comp.setAutoFocusTransferOnDisposal(true);</span>
                 }
             }
            // If some of the children had focus before disposal then it still has.
            // Auto-transfer focus to the next (or previous) component if auto-transfer
            // is enabled.
<span class="nc bnc" id="L2812" title="All 4 branches missed.">            if (containsFocus() &amp;&amp; KeyboardFocusManager.isAutoFocusTransferEnabledFor(this)) {</span>
<span class="nc bnc" id="L2813" title="All 2 branches missed.">                if (!transferFocus(false)) {</span>
<span class="nc" id="L2814">                    transferFocusBackward(true);</span>
                }
            }
<span class="nc bnc" id="L2817" title="All 2 branches missed.">            if ( dispatcher != null ) {</span>
<span class="nc" id="L2818">                dispatcher.dispose();</span>
<span class="nc" id="L2819">                dispatcher = null;</span>
            }
<span class="nc" id="L2821">            super.removeNotify();</span>
<span class="nc" id="L2822">        }</span>
<span class="nc" id="L2823">    }</span>

    /**
     * Checks if the component is contained in the component hierarchy of
     * this container.
     * @param c the component
     * @return     &lt;code&gt;true&lt;/code&gt; if it is an ancestor;
     *             &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since      JDK1.1
     */
    public boolean isAncestorOf(Component c) {
        Container p;
<span class="nc bnc" id="L2835" title="All 4 branches missed.">        if (c == null || ((p = c.getParent()) == null)) {</span>
<span class="nc" id="L2836">            return false;</span>
        }
<span class="nc bnc" id="L2838" title="All 2 branches missed.">        while (p != null) {</span>
<span class="nc bnc" id="L2839" title="All 2 branches missed.">            if (p == this) {</span>
<span class="nc" id="L2840">                return true;</span>
            }
<span class="nc" id="L2842">            p = p.getParent();</span>
        }
<span class="nc" id="L2844">        return false;</span>
    }

    /*
     * The following code was added to support modal JInternalFrames
     * Unfortunately this code has to be added here so that we can get access to
     * some private AWT classes like SequencedEvent.
     *
     * The native container of the LW component has this field set
     * to tell it that it should block Mouse events for all LW
     * children except for the modal component.
     *
     * In the case of nested Modal components, we store the previous
     * modal component in the new modal components value of modalComp;
     */

    transient Component modalComp;
    transient AppContext modalAppContext;

    private void startLWModal() {
        // Store the app context on which this component is being shown.
        // Event dispatch thread of this app context will be sleeping until
        // we wake it by any event from hideAndDisposeHandler().
<span class="nc" id="L2867">        modalAppContext = AppContext.getAppContext();</span>

        // keep the KeyEvents from being dispatched
        // until the focus has been transfered
<span class="nc" id="L2871">        long time = Toolkit.getEventQueue().getMostRecentKeyEventTime();</span>
<span class="nc bnc" id="L2872" title="All 2 branches missed.">        Component predictedFocusOwner = (Component.isInstanceOf(this, &quot;javax.swing.JInternalFrame&quot;)) ? ((javax.swing.JInternalFrame)(this)).getMostRecentFocusOwner() : null;</span>
<span class="nc bnc" id="L2873" title="All 2 branches missed.">        if (predictedFocusOwner != null) {</span>
<span class="nc" id="L2874">            KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L2875">                enqueueKeyEvents(time, predictedFocusOwner);</span>
        }
        // We have two mechanisms for blocking: 1. If we're on the
        // EventDispatchThread, start a new event pump. 2. If we're
        // on any other thread, call wait() on the treelock.
        final Container nativeContainer;
<span class="nc" id="L2881">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L2882">            nativeContainer = getHeavyweightContainer();</span>
<span class="nc bnc" id="L2883" title="All 2 branches missed.">            if (nativeContainer.modalComp != null) {</span>
<span class="nc" id="L2884">                this.modalComp =  nativeContainer.modalComp;</span>
<span class="nc" id="L2885">                nativeContainer.modalComp = this;</span>
<span class="nc" id="L2886">                return;</span>
            }
            else {
<span class="nc" id="L2889">                nativeContainer.modalComp = this;</span>
            }
<span class="nc" id="L2891">        }</span>

<span class="nc" id="L2893">        Runnable pumpEventsForHierarchy = new Runnable() {</span>
            public void run() {
                EventDispatchThread dispatchThread =
<span class="nc" id="L2896">                    (EventDispatchThread)Thread.currentThread();</span>
<span class="nc" id="L2897">                dispatchThread.pumpEventsForHierarchy(</span>
<span class="nc" id="L2898">                        new Conditional() {</span>
                        public boolean evaluate() {
<span class="nc bnc" id="L2900" title="All 4 branches missed.">                        return ((windowClosingException == null) &amp;&amp; (nativeContainer.modalComp != null)) ;</span>
                        }
                        }, Container.this);
<span class="nc" id="L2903">            }</span>
        };

<span class="nc bnc" id="L2906" title="All 2 branches missed.">        if (EventQueue.isDispatchThread()) {</span>
            SequencedEvent currentSequencedEvent =
<span class="nc" id="L2908">                KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L2909">                getCurrentSequencedEvent();</span>
<span class="nc bnc" id="L2910" title="All 2 branches missed.">            if (currentSequencedEvent != null) {</span>
<span class="nc" id="L2911">                currentSequencedEvent.dispose();</span>
            }

<span class="nc" id="L2914">            pumpEventsForHierarchy.run();</span>
<span class="nc" id="L2915">        } else {</span>
<span class="nc" id="L2916">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L2917">                Toolkit.getEventQueue().</span>
<span class="nc" id="L2918">                    postEvent(new PeerEvent(this,</span>
                                pumpEventsForHierarchy,
                                PeerEvent.PRIORITY_EVENT));
<span class="nc bnc" id="L2921" title="All 4 branches missed.">                while ((windowClosingException == null) &amp;&amp;</span>
                       (nativeContainer.modalComp != null))
                {
                    try {
<span class="nc" id="L2925">                        getTreeLock().wait();</span>
<span class="nc" id="L2926">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L2927">                        break;</span>
<span class="nc" id="L2928">                    }</span>
                }
<span class="nc" id="L2930">            }</span>
        }
<span class="nc bnc" id="L2932" title="All 2 branches missed.">        if (windowClosingException != null) {</span>
<span class="nc" id="L2933">            windowClosingException.fillInStackTrace();</span>
<span class="nc" id="L2934">            throw windowClosingException;</span>
        }
<span class="nc bnc" id="L2936" title="All 2 branches missed.">        if (predictedFocusOwner != null) {</span>
<span class="nc" id="L2937">            KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L2938">                dequeueKeyEvents(time, predictedFocusOwner);</span>
        }
<span class="nc" id="L2940">    }</span>

    private void stopLWModal() {
<span class="nc" id="L2943">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L2944" title="All 2 branches missed.">            if (modalAppContext != null) {</span>
<span class="nc" id="L2945">                Container nativeContainer = getHeavyweightContainer();</span>
<span class="nc bnc" id="L2946" title="All 2 branches missed.">                if(nativeContainer != null) {</span>
<span class="nc bnc" id="L2947" title="All 2 branches missed.">                    if (this.modalComp !=  null) {</span>
<span class="nc" id="L2948">                        nativeContainer.modalComp = this.modalComp;</span>
<span class="nc" id="L2949">                        this.modalComp = null;</span>
<span class="nc" id="L2950">                        return;</span>
                    }
                    else {
<span class="nc" id="L2953">                        nativeContainer.modalComp = null;</span>
                    }
                }
                // Wake up event dispatch thread on which the dialog was
                // initially shown
<span class="nc" id="L2958">                SunToolkit.postEvent(modalAppContext,</span>
                        new PeerEvent(this,
                                new WakingRunnable(),
                                PeerEvent.PRIORITY_EVENT));
            }
<span class="nc" id="L2963">            EventQueue.invokeLater(new WakingRunnable());</span>
<span class="nc" id="L2964">            getTreeLock().notifyAll();</span>
<span class="nc" id="L2965">        }</span>
<span class="nc" id="L2966">    }</span>

<span class="nc" id="L2968">    final static class WakingRunnable implements Runnable {</span>
        public void run() {
<span class="nc" id="L2970">        }</span>
    }

    /* End of JOptionPane support code */

    /**
     * Returns a string representing the state of this &lt;code&gt;Container&lt;/code&gt;.
     * This method is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not be
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @return    the parameter string of this container
     */
    protected String paramString() {
<span class="nc" id="L2985">        String str = super.paramString();</span>
<span class="nc" id="L2986">        LayoutManager layoutMgr = this.layoutMgr;</span>
<span class="nc bnc" id="L2987" title="All 2 branches missed.">        if (layoutMgr != null) {</span>
<span class="nc" id="L2988">            str += &quot;,layout=&quot; + layoutMgr.getClass().getName();</span>
        }
<span class="nc" id="L2990">        return str;</span>
    }

    /**
     * Prints a listing of this container to the specified output
     * stream. The listing starts at the specified indentation.
     * &lt;p&gt;
     * The immediate children of the container are printed with
     * an indentation of &lt;code&gt;indent+1&lt;/code&gt;.  The children
     * of those children are printed at &lt;code&gt;indent+2&lt;/code&gt;
     * and so on.
     *
     * @param    out      a print stream
     * @param    indent   the number of spaces to indent
     * @throws   NullPointerException if {@code out} is {@code null}
     * @see      Component#list(java.io.PrintStream, int)
     * @since    JDK1.0
     */
    public void list(PrintStream out, int indent) {
<span class="nc" id="L3009">        super.list(out, indent);</span>
<span class="nc" id="L3010">        synchronized(getTreeLock()) {</span>
<span class="nc bnc" id="L3011" title="All 2 branches missed.">            for (int i = 0; i &lt; component.size(); i++) {</span>
<span class="nc" id="L3012">                Component comp = component.get(i);</span>
<span class="nc bnc" id="L3013" title="All 2 branches missed.">                if (comp != null) {</span>
<span class="nc" id="L3014">                    comp.list(out, indent+1);</span>
                }
            }
<span class="nc" id="L3017">        }</span>
<span class="nc" id="L3018">    }</span>

    /**
     * Prints out a list, starting at the specified indentation,
     * to the specified print writer.
     * &lt;p&gt;
     * The immediate children of the container are printed with
     * an indentation of &lt;code&gt;indent+1&lt;/code&gt;.  The children
     * of those children are printed at &lt;code&gt;indent+2&lt;/code&gt;
     * and so on.
     *
     * @param    out      a print writer
     * @param    indent   the number of spaces to indent
     * @throws   NullPointerException if {@code out} is {@code null}
     * @see      Component#list(java.io.PrintWriter, int)
     * @since    JDK1.1
     */
    public void list(PrintWriter out, int indent) {
<span class="nc" id="L3036">        super.list(out, indent);</span>
<span class="nc" id="L3037">        synchronized(getTreeLock()) {</span>
<span class="nc bnc" id="L3038" title="All 2 branches missed.">            for (int i = 0; i &lt; component.size(); i++) {</span>
<span class="nc" id="L3039">                Component comp = component.get(i);</span>
<span class="nc bnc" id="L3040" title="All 2 branches missed.">                if (comp != null) {</span>
<span class="nc" id="L3041">                    comp.list(out, indent+1);</span>
                }
            }
<span class="nc" id="L3044">        }</span>
<span class="nc" id="L3045">    }</span>

    /**
     * Sets the focus traversal keys for a given traversal operation for this
     * Container.
     * &lt;p&gt;
     * The default values for a Container's focus traversal keys are
     * implementation-dependent. Sun recommends that all implementations for a
     * particular native platform use the same default values. The
     * recommendations for Windows and Unix are listed below. These
     * recommendations are used in the Sun AWT implementations.
     *
     * &lt;table border=1 summary=&quot;Recommended default values for a Container's focus traversal keys&quot;&gt;
     * &lt;tr&gt;
     *    &lt;th&gt;Identifier&lt;/th&gt;
     *    &lt;th&gt;Meaning&lt;/th&gt;
     *    &lt;th&gt;Default&lt;/th&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *    &lt;td&gt;KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS&lt;/td&gt;
     *    &lt;td&gt;Normal forward keyboard traversal&lt;/td&gt;
     *    &lt;td&gt;TAB on KEY_PRESSED, CTRL-TAB on KEY_PRESSED&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *    &lt;td&gt;KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS&lt;/td&gt;
     *    &lt;td&gt;Normal reverse keyboard traversal&lt;/td&gt;
     *    &lt;td&gt;SHIFT-TAB on KEY_PRESSED, CTRL-SHIFT-TAB on KEY_PRESSED&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *    &lt;td&gt;KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS&lt;/td&gt;
     *    &lt;td&gt;Go up one focus traversal cycle&lt;/td&gt;
     *    &lt;td&gt;none&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *    &lt;td&gt;KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS&lt;td&gt;
     *    &lt;td&gt;Go down one focus traversal cycle&lt;/td&gt;
     *    &lt;td&gt;none&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;/table&gt;
     *
     * To disable a traversal key, use an empty Set; Collections.EMPTY_SET is
     * recommended.
     * &lt;p&gt;
     * Using the AWTKeyStroke API, client code can specify on which of two
     * specific KeyEvents, KEY_PRESSED or KEY_RELEASED, the focus traversal
     * operation will occur. Regardless of which KeyEvent is specified,
     * however, all KeyEvents related to the focus traversal key, including the
     * associated KEY_TYPED event, will be consumed, and will not be dispatched
     * to any Container. It is a runtime error to specify a KEY_TYPED event as
     * mapping to a focus traversal operation, or to map the same event to
     * multiple default focus traversal operations.
     * &lt;p&gt;
     * If a value of null is specified for the Set, this Container inherits the
     * Set from its parent. If all ancestors of this Container have null
     * specified for the Set, then the current KeyboardFocusManager's default
     * Set is used.
     * &lt;p&gt;
     * This method may throw a {@code ClassCastException} if any {@code Object}
     * in {@code keystrokes} is not an {@code AWTKeyStroke}.
     *
     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
     * @param keystrokes the Set of AWTKeyStroke for the specified operation
     * @see #getFocusTraversalKeys
     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS
     * @throws IllegalArgumentException if id is not one of
     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS, or if keystrokes
     *         contains null, or if any keystroke represents a KEY_TYPED event,
     *         or if any keystroke already maps to another focus traversal
     *         operation for this Container
     * @since 1.4
     * @beaninfo
     *       bound: true
     */
    public void setFocusTraversalKeys(int id,
                                      Set&lt;? extends AWTKeyStroke&gt; keystrokes)
    {
<span class="nc bnc" id="L3130" title="All 4 branches missed.">        if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {</span>
<span class="nc" id="L3131">            throw new IllegalArgumentException(&quot;invalid focus traversal key identifier&quot;);</span>
        }

        // Don't call super.setFocusTraversalKey. The Component parameter check
        // does not allow DOWN_CYCLE_TRAVERSAL_KEYS, but we do.
<span class="nc" id="L3136">        setFocusTraversalKeys_NoIDCheck(id, keystrokes);</span>
<span class="nc" id="L3137">    }</span>

    /**
     * Returns the Set of focus traversal keys for a given traversal operation
     * for this Container. (See
     * &lt;code&gt;setFocusTraversalKeys&lt;/code&gt; for a full description of each key.)
     * &lt;p&gt;
     * If a Set of traversal keys has not been explicitly defined for this
     * Container, then this Container's parent's Set is returned. If no Set
     * has been explicitly defined for any of this Container's ancestors, then
     * the current KeyboardFocusManager's default Set is returned.
     *
     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
     * @return the Set of AWTKeyStrokes for the specified operation. The Set
     *         will be unmodifiable, and may be empty. null will never be
     *         returned.
     * @see #setFocusTraversalKeys
     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS
     * @throws IllegalArgumentException if id is not one of
     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
     * @since 1.4
     */
    public Set&lt;AWTKeyStroke&gt; getFocusTraversalKeys(int id) {
<span class="nc bnc" id="L3169" title="All 4 branches missed.">        if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {</span>
<span class="nc" id="L3170">            throw new IllegalArgumentException(&quot;invalid focus traversal key identifier&quot;);</span>
        }

        // Don't call super.getFocusTraversalKey. The Component parameter check
        // does not allow DOWN_CYCLE_TRAVERSAL_KEY, but we do.
<span class="nc" id="L3175">        return getFocusTraversalKeys_NoIDCheck(id);</span>
    }

    /**
     * Returns whether the Set of focus traversal keys for the given focus
     * traversal operation has been explicitly defined for this Container. If
     * this method returns &lt;code&gt;false&lt;/code&gt;, this Container is inheriting the
     * Set from an ancestor, or from the current KeyboardFocusManager.
     *
     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
     * @return &lt;code&gt;true&lt;/code&gt; if the the Set of focus traversal keys for the
     *         given focus traversal operation has been explicitly defined for
     *         this Component; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @throws IllegalArgumentException if id is not one of
     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
     * @since 1.4
     */
    public boolean areFocusTraversalKeysSet(int id) {
<span class="nc bnc" id="L3199" title="All 4 branches missed.">        if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {</span>
<span class="nc" id="L3200">            throw new IllegalArgumentException(&quot;invalid focus traversal key identifier&quot;);</span>
        }

<span class="nc bnc" id="L3203" title="All 4 branches missed.">        return (focusTraversalKeys != null &amp;&amp; focusTraversalKeys[id] != null);</span>
    }

    /**
     * Returns whether the specified Container is the focus cycle root of this
     * Container's focus traversal cycle. Each focus traversal cycle has only
     * a single focus cycle root and each Container which is not a focus cycle
     * root belongs to only a single focus traversal cycle. Containers which
     * are focus cycle roots belong to two cycles: one rooted at the Container
     * itself, and one rooted at the Container's nearest focus-cycle-root
     * ancestor. This method will return &lt;code&gt;true&lt;/code&gt; for both such
     * Containers in this case.
     *
     * @param container the Container to be tested
     * @return &lt;code&gt;true&lt;/code&gt; if the specified Container is a focus-cycle-
     *         root of this Container; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #isFocusCycleRoot()
     * @since 1.4
     */
    public boolean isFocusCycleRoot(Container container) {
<span class="nc bnc" id="L3223" title="All 4 branches missed.">        if (isFocusCycleRoot() &amp;&amp; container == this) {</span>
<span class="nc" id="L3224">            return true;</span>
        } else {
<span class="nc" id="L3226">            return super.isFocusCycleRoot(container);</span>
        }
    }

    private Container findTraversalRoot() {
        // I potentially have two roots, myself and my root parent
        // If I am the current root, then use me
        // If none of my parents are roots, then use me
        // If my root parent is the current root, then use my root parent
        // If neither I nor my root parent is the current root, then
        // use my root parent (a guess)

        Container currentFocusCycleRoot = KeyboardFocusManager.
<span class="nc" id="L3239">            getCurrentKeyboardFocusManager().getCurrentFocusCycleRoot();</span>
        Container root;

<span class="nc bnc" id="L3242" title="All 2 branches missed.">        if (currentFocusCycleRoot == this) {</span>
<span class="nc" id="L3243">            root = this;</span>
        } else {
<span class="nc" id="L3245">            root = getFocusCycleRootAncestor();</span>
<span class="nc bnc" id="L3246" title="All 2 branches missed.">            if (root == null) {</span>
<span class="nc" id="L3247">                root = this;</span>
            }
        }

<span class="nc bnc" id="L3251" title="All 2 branches missed.">        if (root != currentFocusCycleRoot) {</span>
<span class="nc" id="L3252">            KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L3253">                setGlobalCurrentFocusCycleRootPriv(root);</span>
        }
<span class="nc" id="L3255">        return root;</span>
    }

    final boolean containsFocus() {
        final Component focusOwner = KeyboardFocusManager.
<span class="nc" id="L3260">            getCurrentKeyboardFocusManager().getFocusOwner();</span>
<span class="nc" id="L3261">        return isParentOf(focusOwner);</span>
    }

    /**
     * Check if this component is the child of this container or its children.
     * Note: this function acquires treeLock
     * Note: this function traverses children tree only in one Window.
     * @param comp a component in test, must not be null
     */
    private boolean isParentOf(Component comp) {
<span class="nc" id="L3271">        synchronized(getTreeLock()) {</span>
<span class="nc bnc" id="L3272" title="All 6 branches missed.">            while (comp != null &amp;&amp; comp != this &amp;&amp; !(comp instanceof Window)) {</span>
<span class="nc" id="L3273">                comp = comp.getParent();</span>
            }
<span class="nc bnc" id="L3275" title="All 2 branches missed.">            return (comp == this);</span>
<span class="nc" id="L3276">        }</span>
    }

    void clearMostRecentFocusOwnerOnHide() {
<span class="nc" id="L3280">        boolean reset = false;</span>
<span class="nc" id="L3281">        Window window = null;</span>

<span class="nc" id="L3283">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L3284">            window = getContainingWindow();</span>
<span class="nc bnc" id="L3285" title="All 2 branches missed.">            if (window != null) {</span>
<span class="nc" id="L3286">                Component comp = KeyboardFocusManager.getMostRecentFocusOwner(window);</span>
<span class="nc bnc" id="L3287" title="All 4 branches missed.">                reset = ((comp == this) || isParentOf(comp));</span>
                // This synchronized should always be the second in a pair
                // (tree lock, KeyboardFocusManager.class)
<span class="nc" id="L3290">                synchronized(KeyboardFocusManager.class) {</span>
<span class="nc" id="L3291">                    Component storedComp = window.getTemporaryLostComponent();</span>
<span class="nc bnc" id="L3292" title="All 4 branches missed.">                    if (isParentOf(storedComp) || storedComp == this) {</span>
<span class="nc" id="L3293">                        window.setTemporaryLostComponent(null);</span>
                    }
<span class="nc" id="L3295">                }</span>
            }
<span class="nc" id="L3297">        }</span>

<span class="nc bnc" id="L3299" title="All 2 branches missed.">        if (reset) {</span>
<span class="nc" id="L3300">            KeyboardFocusManager.setMostRecentFocusOwner(window, null);</span>
        }
<span class="nc" id="L3302">    }</span>

    void clearCurrentFocusCycleRootOnHide() {
        KeyboardFocusManager kfm =
<span class="nc" id="L3306">            KeyboardFocusManager.getCurrentKeyboardFocusManager();</span>
<span class="nc" id="L3307">        Container cont = kfm.getCurrentFocusCycleRoot();</span>

<span class="nc bnc" id="L3309" title="All 4 branches missed.">        if (cont == this || isParentOf(cont)) {</span>
<span class="nc" id="L3310">            kfm.setGlobalCurrentFocusCycleRootPriv(null);</span>
        }
<span class="nc" id="L3312">    }</span>

    @Override
    void clearLightweightDispatcherOnRemove(Component removedComponent) {
<span class="nc bnc" id="L3316" title="All 2 branches missed.">        if (dispatcher != null) {</span>
<span class="nc" id="L3317">            dispatcher.removeReferences(removedComponent);</span>
        } else {
            //It is a Lightweight Container, should clear parent`s Dispatcher
<span class="nc" id="L3320">            super.clearLightweightDispatcherOnRemove(removedComponent);</span>
        }
<span class="nc" id="L3322">    }</span>

    final Container getTraversalRoot() {
<span class="nc bnc" id="L3325" title="All 2 branches missed.">        if (isFocusCycleRoot()) {</span>
<span class="nc" id="L3326">            return findTraversalRoot();</span>
        }

<span class="nc" id="L3329">        return super.getTraversalRoot();</span>
    }

    /**
     * Sets the focus traversal policy that will manage keyboard traversal of
     * this Container's children, if this Container is a focus cycle root. If
     * the argument is null, this Container inherits its policy from its focus-
     * cycle-root ancestor. If the argument is non-null, this policy will be
     * inherited by all focus-cycle-root children that have no keyboard-
     * traversal policy of their own (as will, recursively, their focus-cycle-
     * root children).
     * &lt;p&gt;
     * If this Container is not a focus cycle root, the policy will be
     * remembered, but will not be used or inherited by this or any other
     * Containers until this Container is made a focus cycle root.
     *
     * @param policy the new focus traversal policy for this Container
     * @see #getFocusTraversalPolicy
     * @see #setFocusCycleRoot
     * @see #isFocusCycleRoot
     * @since 1.4
     * @beaninfo
     *       bound: true
     */
    public void setFocusTraversalPolicy(FocusTraversalPolicy policy) {
        FocusTraversalPolicy oldPolicy;
<span class="nc" id="L3355">        synchronized (this) {</span>
<span class="nc" id="L3356">            oldPolicy = this.focusTraversalPolicy;</span>
<span class="nc" id="L3357">            this.focusTraversalPolicy = policy;</span>
<span class="nc" id="L3358">        }</span>
<span class="nc" id="L3359">        firePropertyChange(&quot;focusTraversalPolicy&quot;, oldPolicy, policy);</span>
<span class="nc" id="L3360">    }</span>

    /**
     * Returns the focus traversal policy that will manage keyboard traversal
     * of this Container's children, or null if this Container is not a focus
     * cycle root. If no traversal policy has been explicitly set for this
     * Container, then this Container's focus-cycle-root ancestor's policy is
     * returned.
     *
     * @return this Container's focus traversal policy, or null if this
     *         Container is not a focus cycle root.
     * @see #setFocusTraversalPolicy
     * @see #setFocusCycleRoot
     * @see #isFocusCycleRoot
     * @since 1.4
     */
    public FocusTraversalPolicy getFocusTraversalPolicy() {
<span class="nc bnc" id="L3377" title="All 4 branches missed.">        if (!isFocusTraversalPolicyProvider() &amp;&amp; !isFocusCycleRoot()) {</span>
<span class="nc" id="L3378">            return null;</span>
        }

<span class="nc" id="L3381">        FocusTraversalPolicy policy = this.focusTraversalPolicy;</span>
<span class="nc bnc" id="L3382" title="All 2 branches missed.">        if (policy != null) {</span>
<span class="nc" id="L3383">            return policy;</span>
        }

<span class="nc" id="L3386">        Container rootAncestor = getFocusCycleRootAncestor();</span>
<span class="nc bnc" id="L3387" title="All 2 branches missed.">        if (rootAncestor != null) {</span>
<span class="nc" id="L3388">            return rootAncestor.getFocusTraversalPolicy();</span>
        } else {
<span class="nc" id="L3390">            return KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L3391">                getDefaultFocusTraversalPolicy();</span>
        }
    }

    /**
     * Returns whether the focus traversal policy has been explicitly set for
     * this Container. If this method returns &lt;code&gt;false&lt;/code&gt;, this
     * Container will inherit its focus traversal policy from an ancestor.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the focus traversal policy has been
     *         explicitly set for this Container; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.4
     */
    public boolean isFocusTraversalPolicySet() {
<span class="nc bnc" id="L3405" title="All 2 branches missed.">        return (focusTraversalPolicy != null);</span>
    }

    /**
     * Sets whether this Container is the root of a focus traversal cycle. Once
     * focus enters a traversal cycle, typically it cannot leave it via focus
     * traversal unless one of the up- or down-cycle keys is pressed. Normal
     * traversal is limited to this Container, and all of this Container's
     * descendants that are not descendants of inferior focus cycle roots. Note
     * that a FocusTraversalPolicy may bend these restrictions, however. For
     * example, ContainerOrderFocusTraversalPolicy supports implicit down-cycle
     * traversal.
     * &lt;p&gt;
     * The alternative way to specify the traversal order of this Container's
     * children is to make this Container a
     * &lt;a href=&quot;doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;focus traversal policy provider&lt;/a&gt;.
     *
     * @param focusCycleRoot indicates whether this Container is the root of a
     *        focus traversal cycle
     * @see #isFocusCycleRoot()
     * @see #setFocusTraversalPolicy
     * @see #getFocusTraversalPolicy
     * @see ContainerOrderFocusTraversalPolicy
     * @see #setFocusTraversalPolicyProvider
     * @since 1.4
     * @beaninfo
     *       bound: true
     */
    public void setFocusCycleRoot(boolean focusCycleRoot) {
        boolean oldFocusCycleRoot;
<span class="nc" id="L3435">        synchronized (this) {</span>
<span class="nc" id="L3436">            oldFocusCycleRoot = this.focusCycleRoot;</span>
<span class="nc" id="L3437">            this.focusCycleRoot = focusCycleRoot;</span>
<span class="nc" id="L3438">        }</span>
<span class="nc" id="L3439">        firePropertyChange(&quot;focusCycleRoot&quot;, oldFocusCycleRoot,</span>
                           focusCycleRoot);
<span class="nc" id="L3441">    }</span>

    /**
     * Returns whether this Container is the root of a focus traversal cycle.
     * Once focus enters a traversal cycle, typically it cannot leave it via
     * focus traversal unless one of the up- or down-cycle keys is pressed.
     * Normal traversal is limited to this Container, and all of this
     * Container's descendants that are not descendants of inferior focus
     * cycle roots. Note that a FocusTraversalPolicy may bend these
     * restrictions, however. For example, ContainerOrderFocusTraversalPolicy
     * supports implicit down-cycle traversal.
     *
     * @return whether this Container is the root of a focus traversal cycle
     * @see #setFocusCycleRoot
     * @see #setFocusTraversalPolicy
     * @see #getFocusTraversalPolicy
     * @see ContainerOrderFocusTraversalPolicy
     * @since 1.4
     */
    public boolean isFocusCycleRoot() {
<span class="nc" id="L3461">        return focusCycleRoot;</span>
    }

    /**
     * Sets whether this container will be used to provide focus
     * traversal policy. Container with this property as
     * &lt;code&gt;true&lt;/code&gt; will be used to acquire focus traversal policy
     * instead of closest focus cycle root ancestor.
     * @param provider indicates whether this container will be used to
     *                provide focus traversal policy
     * @see #setFocusTraversalPolicy
     * @see #getFocusTraversalPolicy
     * @see #isFocusTraversalPolicyProvider
     * @since 1.5
     * @beaninfo
     *        bound: true
     */
    public final void setFocusTraversalPolicyProvider(boolean provider) {
        boolean oldProvider;
<span class="nc" id="L3480">        synchronized(this) {</span>
<span class="nc" id="L3481">            oldProvider = focusTraversalPolicyProvider;</span>
<span class="nc" id="L3482">            focusTraversalPolicyProvider = provider;</span>
<span class="nc" id="L3483">        }</span>
<span class="nc" id="L3484">        firePropertyChange(&quot;focusTraversalPolicyProvider&quot;, oldProvider, provider);</span>
<span class="nc" id="L3485">    }</span>

    /**
     * Returns whether this container provides focus traversal
     * policy. If this property is set to &lt;code&gt;true&lt;/code&gt; then when
     * keyboard focus manager searches container hierarchy for focus
     * traversal policy and encounters this container before any other
     * container with this property as true or focus cycle roots then
     * its focus traversal policy will be used instead of focus cycle
     * root's policy.
     * @see #setFocusTraversalPolicy
     * @see #getFocusTraversalPolicy
     * @see #setFocusCycleRoot
     * @see #setFocusTraversalPolicyProvider
     * @return &lt;code&gt;true&lt;/code&gt; if this container provides focus traversal
     *         policy, &lt;code&gt;false&lt;/code&gt; otherwise
     * @since 1.5
     * @beaninfo
     *        bound: true
     */
    public final boolean isFocusTraversalPolicyProvider() {
<span class="nc" id="L3506">        return focusTraversalPolicyProvider;</span>
    }

    /**
     * Transfers the focus down one focus traversal cycle. If this Container is
     * a focus cycle root, then the focus owner is set to this Container's
     * default Component to focus, and the current focus cycle root is set to
     * this Container. If this Container is not a focus cycle root, then no
     * focus traversal operation occurs.
     *
     * @see       Component#requestFocus()
     * @see       #isFocusCycleRoot
     * @see       #setFocusCycleRoot
     * @since     1.4
     */
    public void transferFocusDownCycle() {
<span class="nc bnc" id="L3522" title="All 2 branches missed.">        if (isFocusCycleRoot()) {</span>
<span class="nc" id="L3523">            KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L3524">                setGlobalCurrentFocusCycleRootPriv(this);</span>
<span class="nc" id="L3525">            Component toFocus = getFocusTraversalPolicy().</span>
<span class="nc" id="L3526">                getDefaultComponent(this);</span>
<span class="nc bnc" id="L3527" title="All 2 branches missed.">            if (toFocus != null) {</span>
<span class="nc" id="L3528">                toFocus.requestFocus(CausedFocusEvent.Cause.TRAVERSAL_DOWN);</span>
            }
        }
<span class="nc" id="L3531">    }</span>

    void preProcessKeyEvent(KeyEvent e) {
<span class="nc" id="L3534">        Container parent = this.parent;</span>
<span class="nc bnc" id="L3535" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L3536">            parent.preProcessKeyEvent(e);</span>
        }
<span class="nc" id="L3538">    }</span>

    void postProcessKeyEvent(KeyEvent e) {
<span class="nc" id="L3541">        Container parent = this.parent;</span>
<span class="nc bnc" id="L3542" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L3543">            parent.postProcessKeyEvent(e);</span>
        }
<span class="nc" id="L3545">    }</span>

    boolean postsOldMouseEvents() {
<span class="nc" id="L3548">        return true;</span>
    }

    /**
     * Sets the &lt;code&gt;ComponentOrientation&lt;/code&gt; property of this container
     * and all components contained within it.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param o the new component orientation of this container and
     *        the components contained within it.
     * @exception NullPointerException if &lt;code&gt;orientation&lt;/code&gt; is null.
     * @see Component#setComponentOrientation
     * @see Component#getComponentOrientation
     * @see #invalidate
     * @since 1.4
     */
    public void applyComponentOrientation(ComponentOrientation o) {
<span class="nc" id="L3567">        super.applyComponentOrientation(o);</span>
<span class="nc" id="L3568">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L3569" title="All 2 branches missed.">            for (int i = 0; i &lt; component.size(); i++) {</span>
<span class="nc" id="L3570">                Component comp = component.get(i);</span>
<span class="nc" id="L3571">                comp.applyComponentOrientation(o);</span>
            }
<span class="nc" id="L3573">        }</span>
<span class="nc" id="L3574">    }</span>

    /**
     * Adds a PropertyChangeListener to the listener list. The listener is
     * registered for all bound properties of this class, including the
     * following:
     * &lt;ul&gt;
     *    &lt;li&gt;this Container's font (&quot;font&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's background color (&quot;background&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's foreground color (&quot;foreground&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's focusability (&quot;focusable&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's focus traversal keys enabled state
     *        (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's Set of FORWARD_TRAVERSAL_KEYS
     *        (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's Set of BACKWARD_TRAVERSAL_KEYS
     *        (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's Set of UP_CYCLE_TRAVERSAL_KEYS
     *        (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's Set of DOWN_CYCLE_TRAVERSAL_KEYS
     *        (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's focus traversal policy (&quot;focusTraversalPolicy&quot;)
     *        &lt;/li&gt;
     *    &lt;li&gt;this Container's focus-cycle-root state (&quot;focusCycleRoot&quot;)&lt;/li&gt;
     * &lt;/ul&gt;
     * Note that if this Container is inheriting a bound property, then no
     * event will be fired in response to a change in the inherited property.
     * &lt;p&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param    listener  the PropertyChangeListener to be added
     *
     * @see Component#removePropertyChangeListener
     * @see #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
     */
    public void addPropertyChangeListener(PropertyChangeListener listener) {
<span class="nc" id="L3610">        super.addPropertyChangeListener(listener);</span>
<span class="nc" id="L3611">    }</span>

    /**
     * Adds a PropertyChangeListener to the listener list for a specific
     * property. The specified property may be user-defined, or one of the
     * following defaults:
     * &lt;ul&gt;
     *    &lt;li&gt;this Container's font (&quot;font&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's background color (&quot;background&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's foreground color (&quot;foreground&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's focusability (&quot;focusable&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's focus traversal keys enabled state
     *        (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's Set of FORWARD_TRAVERSAL_KEYS
     *        (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's Set of BACKWARD_TRAVERSAL_KEYS
     *        (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's Set of UP_CYCLE_TRAVERSAL_KEYS
     *        (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's Set of DOWN_CYCLE_TRAVERSAL_KEYS
     *        (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's focus traversal policy (&quot;focusTraversalPolicy&quot;)
     *        &lt;/li&gt;
     *    &lt;li&gt;this Container's focus-cycle-root state (&quot;focusCycleRoot&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's focus-traversal-policy-provider state(&quot;focusTraversalPolicyProvider&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Container's focus-traversal-policy-provider state(&quot;focusTraversalPolicyProvider&quot;)&lt;/li&gt;
     * &lt;/ul&gt;
     * Note that if this Container is inheriting a bound property, then no
     * event will be fired in response to a change in the inherited property.
     * &lt;p&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param propertyName one of the property names listed above
     * @param listener the PropertyChangeListener to be added
     *
     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)
     * @see Component#removePropertyChangeListener
     */
    public void addPropertyChangeListener(String propertyName,
                                          PropertyChangeListener listener) {
<span class="nc" id="L3651">        super.addPropertyChangeListener(propertyName, listener);</span>
<span class="nc" id="L3652">    }</span>

    // Serialization support. A Container is responsible for restoring the
    // parent fields of its component children.

    /**
     * Container Serial Data Version.
     */
<span class="nc" id="L3660">    private int containerSerializedDataVersion = 1;</span>

    /**
     * Serializes this &lt;code&gt;Container&lt;/code&gt; to the specified
     * &lt;code&gt;ObjectOutputStream&lt;/code&gt;.
     * &lt;ul&gt;
     *    &lt;li&gt;Writes default serializable fields to the stream.&lt;/li&gt;
     *    &lt;li&gt;Writes a list of serializable ContainerListener(s) as optional
     *        data. The non-serializable ContainerListner(s) are detected and
     *        no attempt is made to serialize them.&lt;/li&gt;
     *    &lt;li&gt;Write this Container's FocusTraversalPolicy if and only if it
     *        is Serializable; otherwise, &lt;code&gt;null&lt;/code&gt; is written.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param s the &lt;code&gt;ObjectOutputStream&lt;/code&gt; to write
     * @serialData &lt;code&gt;null&lt;/code&gt; terminated sequence of 0 or more pairs;
     *   the pair consists of a &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;;
     *   the &lt;code&gt;String&lt;/code&gt; indicates the type of object and
     *   is one of the following:
     *   &lt;code&gt;containerListenerK&lt;/code&gt; indicating an
     *     &lt;code&gt;ContainerListener&lt;/code&gt; object;
     *   the &lt;code&gt;Container&lt;/code&gt;'s &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;,
     *     or &lt;code&gt;null&lt;/code&gt;
     *
     * @see AWTEventMulticaster#save(java.io.ObjectOutputStream, java.lang.String, java.util.EventListener)
     * @see Container#containerListenerK
     * @see #readObject(ObjectInputStream)
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L3689">        ObjectOutputStream.PutField f = s.putFields();</span>
<span class="nc" id="L3690">        f.put(&quot;ncomponents&quot;, component.size());</span>
<span class="nc" id="L3691">        f.put(&quot;component&quot;, getComponentsSync());</span>
<span class="nc" id="L3692">        f.put(&quot;layoutMgr&quot;, layoutMgr);</span>
<span class="nc" id="L3693">        f.put(&quot;dispatcher&quot;, dispatcher);</span>
<span class="nc" id="L3694">        f.put(&quot;maxSize&quot;, maxSize);</span>
<span class="nc" id="L3695">        f.put(&quot;focusCycleRoot&quot;, focusCycleRoot);</span>
<span class="nc" id="L3696">        f.put(&quot;containerSerializedDataVersion&quot;, containerSerializedDataVersion);</span>
<span class="nc" id="L3697">        f.put(&quot;focusTraversalPolicyProvider&quot;, focusTraversalPolicyProvider);</span>
<span class="nc" id="L3698">        s.writeFields();</span>

<span class="nc" id="L3700">        AWTEventMulticaster.save(s, containerListenerK, containerListener);</span>
<span class="nc" id="L3701">        s.writeObject(null);</span>

<span class="nc bnc" id="L3703" title="All 2 branches missed.">        if (focusTraversalPolicy instanceof java.io.Serializable) {</span>
<span class="nc" id="L3704">            s.writeObject(focusTraversalPolicy);</span>
        } else {
<span class="nc" id="L3706">            s.writeObject(null);</span>
        }
<span class="nc" id="L3708">    }</span>

    /**
     * Deserializes this &lt;code&gt;Container&lt;/code&gt; from the specified
     * &lt;code&gt;ObjectInputStream&lt;/code&gt;.
     * &lt;ul&gt;
     *    &lt;li&gt;Reads default serializable fields from the stream.&lt;/li&gt;
     *    &lt;li&gt;Reads a list of serializable ContainerListener(s) as optional
     *        data. If the list is null, no Listeners are installed.&lt;/li&gt;
     *    &lt;li&gt;Reads this Container's FocusTraversalPolicy, which may be null,
     *        as optional data.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param s the &lt;code&gt;ObjectInputStream&lt;/code&gt; to read
     * @serial
     * @see #addContainerListener
     * @see #writeObject(ObjectOutputStream)
     */
    private void readObject(ObjectInputStream s)
        throws ClassNotFoundException, IOException
    {
<span class="nc" id="L3729">        ObjectInputStream.GetField f = s.readFields();</span>
<span class="nc" id="L3730">        Component [] tmpComponent = (Component[])f.get(&quot;component&quot;, EMPTY_ARRAY);</span>
<span class="nc" id="L3731">        int ncomponents = (Integer) f.get(&quot;ncomponents&quot;, 0);</span>
<span class="nc" id="L3732">        component = new java.util.ArrayList&lt;Component&gt;(ncomponents);</span>
<span class="nc bnc" id="L3733" title="All 2 branches missed.">        for (int i = 0; i &lt; ncomponents; ++i) {</span>
<span class="nc" id="L3734">            component.add(tmpComponent[i]);</span>
        }
<span class="nc" id="L3736">        layoutMgr = (LayoutManager)f.get(&quot;layoutMgr&quot;, null);</span>
<span class="nc" id="L3737">        dispatcher = (LightweightDispatcher)f.get(&quot;dispatcher&quot;, null);</span>
        // Old stream. Doesn't contain maxSize among Component's fields.
<span class="nc bnc" id="L3739" title="All 2 branches missed.">        if (maxSize == null) {</span>
<span class="nc" id="L3740">            maxSize = (Dimension)f.get(&quot;maxSize&quot;, null);</span>
        }
<span class="nc" id="L3742">        focusCycleRoot = f.get(&quot;focusCycleRoot&quot;, false);</span>
<span class="nc" id="L3743">        containerSerializedDataVersion = f.get(&quot;containerSerializedDataVersion&quot;, 1);</span>
<span class="nc" id="L3744">        focusTraversalPolicyProvider = f.get(&quot;focusTraversalPolicyProvider&quot;, false);</span>
<span class="nc" id="L3745">        java.util.List&lt;Component&gt; component = this.component;</span>
<span class="nc bnc" id="L3746" title="All 2 branches missed.">        for(Component comp : component) {</span>
<span class="nc" id="L3747">            comp.parent = this;</span>
<span class="nc" id="L3748">            adjustListeningChildren(AWTEvent.HIERARCHY_EVENT_MASK,</span>
<span class="nc" id="L3749">                                    comp.numListening(AWTEvent.HIERARCHY_EVENT_MASK));</span>
<span class="nc" id="L3750">            adjustListeningChildren(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK,</span>
<span class="nc" id="L3751">                                    comp.numListening(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));</span>
<span class="nc" id="L3752">            adjustDescendants(comp.countHierarchyMembers());</span>
<span class="nc" id="L3753">        }</span>

        Object keyOrNull;
<span class="nc bnc" id="L3756" title="All 2 branches missed.">        while(null != (keyOrNull = s.readObject())) {</span>
<span class="nc" id="L3757">            String key = ((String)keyOrNull).intern();</span>

<span class="nc bnc" id="L3759" title="All 2 branches missed.">            if (containerListenerK == key) {</span>
<span class="nc" id="L3760">                addContainerListener((ContainerListener)(s.readObject()));</span>
            } else {
                // skip value for unrecognized key
<span class="nc" id="L3763">                s.readObject();</span>
            }
<span class="nc" id="L3765">        }</span>

        try {
<span class="nc" id="L3768">            Object policy = s.readObject();</span>
<span class="nc bnc" id="L3769" title="All 2 branches missed.">            if (policy instanceof FocusTraversalPolicy) {</span>
<span class="nc" id="L3770">                focusTraversalPolicy = (FocusTraversalPolicy)policy;</span>
            }
<span class="nc" id="L3772">        } catch (java.io.OptionalDataException e) {</span>
            // JDK 1.1/1.2/1.3 instances will not have this optional data.
            // e.eof will be true to indicate that there is no more data
            // available for this object. If e.eof is not true, throw the
            // exception as it might have been caused by reasons unrelated to
            // focusTraversalPolicy.

<span class="nc bnc" id="L3779" title="All 2 branches missed.">            if (!e.eof) {</span>
<span class="nc" id="L3780">                throw e;</span>
            }
<span class="nc" id="L3782">        }</span>
<span class="nc" id="L3783">    }</span>

    /*
     * --- Accessibility Support ---
     */

    /**
     * Inner class of Container used to provide default support for
     * accessibility.  This class is not meant to be used directly by
     * application developers, but is instead meant only to be
     * subclassed by container developers.
     * &lt;p&gt;
     * The class used to obtain the accessible role for this object,
     * as well as implementing many of the methods in the
     * AccessibleContainer interface.
     * @since 1.3
     */
<span class="nc" id="L3800">    protected class AccessibleAWTContainer extends AccessibleAWTComponent {</span>

        /**
         * JDK1.3 serialVersionUID
         */
        private static final long serialVersionUID = 5081320404842566097L;

        /**
         * Returns the number of accessible children in the object.  If all
         * of the children of this object implement &lt;code&gt;Accessible&lt;/code&gt;,
         * then this method should return the number of children of this object.
         *
         * @return the number of accessible children in the object
         */
        public int getAccessibleChildrenCount() {
<span class="nc" id="L3815">            return Container.this.getAccessibleChildrenCount();</span>
        }

        /**
         * Returns the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object.
         *
         * @param i zero-based index of child
         * @return the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object
         */
        public Accessible getAccessibleChild(int i) {
<span class="nc" id="L3825">            return Container.this.getAccessibleChild(i);</span>
        }

        /**
         * Returns the &lt;code&gt;Accessible&lt;/code&gt; child, if one exists,
         * contained at the local coordinate &lt;code&gt;Point&lt;/code&gt;.
         *
         * @param p the point defining the top-left corner of the
         *    &lt;code&gt;Accessible&lt;/code&gt;, given in the coordinate space
         *    of the object's parent
         * @return the &lt;code&gt;Accessible&lt;/code&gt;, if it exists,
         *    at the specified location; else &lt;code&gt;null&lt;/code&gt;
         */
        public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L3839">            return Container.this.getAccessibleAt(p);</span>
        }

        /**
         * Number of PropertyChangeListener objects registered. It's used
         * to add/remove ContainerListener to track target Container's state.
         */
<span class="nc" id="L3846">        private volatile transient int propertyListenersCount = 0;</span>

<span class="nc" id="L3848">        protected ContainerListener accessibleContainerHandler = null;</span>

        /**
         * Fire &lt;code&gt;PropertyChange&lt;/code&gt; listener, if one is registered,
         * when children are added or removed.
         * @since 1.3
         */
<span class="nc" id="L3855">        protected class AccessibleContainerHandler</span>
            implements ContainerListener {
            public void componentAdded(ContainerEvent e) {
<span class="nc" id="L3858">                Component c = e.getChild();</span>
<span class="nc bnc" id="L3859" title="All 4 branches missed.">                if (c != null &amp;&amp; c instanceof Accessible) {</span>
<span class="nc" id="L3860">                    AccessibleAWTContainer.this.firePropertyChange(</span>
                        AccessibleContext.ACCESSIBLE_CHILD_PROPERTY,
<span class="nc" id="L3862">                        null, ((Accessible) c).getAccessibleContext());</span>
                }
<span class="nc" id="L3864">            }</span>
            public void componentRemoved(ContainerEvent e) {
<span class="nc" id="L3866">                Component c = e.getChild();</span>
<span class="nc bnc" id="L3867" title="All 4 branches missed.">                if (c != null &amp;&amp; c instanceof Accessible) {</span>
<span class="nc" id="L3868">                    AccessibleAWTContainer.this.firePropertyChange(</span>
                        AccessibleContext.ACCESSIBLE_CHILD_PROPERTY,
<span class="nc" id="L3870">                        ((Accessible) c).getAccessibleContext(), null);</span>
                }
<span class="nc" id="L3872">            }</span>
        }

        /**
         * Adds a PropertyChangeListener to the listener list.
         *
         * @param listener  the PropertyChangeListener to be added
         */
        public void addPropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L3881" title="All 2 branches missed.">            if (accessibleContainerHandler == null) {</span>
<span class="nc" id="L3882">                accessibleContainerHandler = new AccessibleContainerHandler();</span>
            }
<span class="nc bnc" id="L3884" title="All 2 branches missed.">            if (propertyListenersCount++ == 0) {</span>
<span class="nc" id="L3885">                Container.this.addContainerListener(accessibleContainerHandler);</span>
            }
<span class="nc" id="L3887">            super.addPropertyChangeListener(listener);</span>
<span class="nc" id="L3888">        }</span>

        /**
         * Remove a PropertyChangeListener from the listener list.
         * This removes a PropertyChangeListener that was registered
         * for all properties.
         *
         * @param listener the PropertyChangeListener to be removed
         */
        public void removePropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L3898" title="All 2 branches missed.">            if (--propertyListenersCount == 0) {</span>
<span class="nc" id="L3899">                Container.this.removeContainerListener(accessibleContainerHandler);</span>
            }
<span class="nc" id="L3901">            super.removePropertyChangeListener(listener);</span>
<span class="nc" id="L3902">        }</span>

    } // inner class AccessibleAWTContainer

    /**
     * Returns the &lt;code&gt;Accessible&lt;/code&gt; child contained at the local
     * coordinate &lt;code&gt;Point&lt;/code&gt;, if one exists.  Otherwise
     * returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @param p the point defining the top-left corner of the
     *    &lt;code&gt;Accessible&lt;/code&gt;, given in the coordinate space
     *    of the object's parent
     * @return the &lt;code&gt;Accessible&lt;/code&gt; at the specified location,
     *    if it exists; otherwise &lt;code&gt;null&lt;/code&gt;
     */
    Accessible getAccessibleAt(Point p) {
<span class="nc" id="L3918">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L3919" title="All 2 branches missed.">            if (this instanceof Accessible) {</span>
<span class="nc" id="L3920">                Accessible a = (Accessible)this;</span>
<span class="nc" id="L3921">                AccessibleContext ac = a.getAccessibleContext();</span>
<span class="nc bnc" id="L3922" title="All 2 branches missed.">                if (ac != null) {</span>
                    AccessibleComponent acmp;
                    Point location;
<span class="nc" id="L3925">                    int nchildren = ac.getAccessibleChildrenCount();</span>
<span class="nc bnc" id="L3926" title="All 2 branches missed.">                    for (int i=0; i &lt; nchildren; i++) {</span>
<span class="nc" id="L3927">                        a = ac.getAccessibleChild(i);</span>
<span class="nc bnc" id="L3928" title="All 2 branches missed.">                        if ((a != null)) {</span>
<span class="nc" id="L3929">                            ac = a.getAccessibleContext();</span>
<span class="nc bnc" id="L3930" title="All 2 branches missed.">                            if (ac != null) {</span>
<span class="nc" id="L3931">                                acmp = ac.getAccessibleComponent();</span>
<span class="nc bnc" id="L3932" title="All 4 branches missed.">                                if ((acmp != null) &amp;&amp; (acmp.isShowing())) {</span>
<span class="nc" id="L3933">                                    location = acmp.getLocation();</span>
<span class="nc" id="L3934">                                    Point np = new Point(p.x-location.x,</span>
                                                         p.y-location.y);
<span class="nc bnc" id="L3936" title="All 2 branches missed.">                                    if (acmp.contains(np)){</span>
<span class="nc" id="L3937">                                        return a;</span>
                                    }
                                }
                            }
                        }
                    }
                }
<span class="nc" id="L3944">                return (Accessible)this;</span>
            } else {
<span class="nc" id="L3946">                Component ret = this;</span>
<span class="nc bnc" id="L3947" title="All 2 branches missed.">                if (!this.contains(p.x,p.y)) {</span>
<span class="nc" id="L3948">                    ret = null;</span>
                } else {
<span class="nc" id="L3950">                    int ncomponents = this.getComponentCount();</span>
<span class="nc bnc" id="L3951" title="All 2 branches missed.">                    for (int i=0; i &lt; ncomponents; i++) {</span>
<span class="nc" id="L3952">                        Component comp = this.getComponent(i);</span>
<span class="nc bnc" id="L3953" title="All 4 branches missed.">                        if ((comp != null) &amp;&amp; comp.isShowing()) {</span>
<span class="nc" id="L3954">                            Point location = comp.getLocation();</span>
<span class="nc bnc" id="L3955" title="All 2 branches missed.">                            if (comp.contains(p.x-location.x,p.y-location.y)) {</span>
<span class="nc" id="L3956">                                ret = comp;</span>
                            }
                        }
                    }
                }
<span class="nc bnc" id="L3961" title="All 2 branches missed.">                if (ret instanceof Accessible) {</span>
<span class="nc" id="L3962">                    return (Accessible) ret;</span>
                }
            }
<span class="nc" id="L3965">            return null;</span>
<span class="nc" id="L3966">        }</span>
    }

    /**
     * Returns the number of accessible children in the object.  If all
     * of the children of this object implement &lt;code&gt;Accessible&lt;/code&gt;,
     * then this method should return the number of children of this object.
     *
     * @return the number of accessible children in the object
     */
    int getAccessibleChildrenCount() {
<span class="nc" id="L3977">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L3978">            int count = 0;</span>
<span class="nc" id="L3979">            Component[] children = this.getComponents();</span>
<span class="nc bnc" id="L3980" title="All 2 branches missed.">            for (int i = 0; i &lt; children.length; i++) {</span>
<span class="nc bnc" id="L3981" title="All 2 branches missed.">                if (children[i] instanceof Accessible) {</span>
<span class="nc" id="L3982">                    count++;</span>
                }
            }
<span class="nc" id="L3985">            return count;</span>
<span class="nc" id="L3986">        }</span>
    }

    /**
     * Returns the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object.
     *
     * @param i zero-based index of child
     * @return the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object
     */
    Accessible getAccessibleChild(int i) {
<span class="nc" id="L3996">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L3997">            Component[] children = this.getComponents();</span>
<span class="nc" id="L3998">            int count = 0;</span>
<span class="nc bnc" id="L3999" title="All 2 branches missed.">            for (int j = 0; j &lt; children.length; j++) {</span>
<span class="nc bnc" id="L4000" title="All 2 branches missed.">                if (children[j] instanceof Accessible) {</span>
<span class="nc bnc" id="L4001" title="All 2 branches missed.">                    if (count == i) {</span>
<span class="nc" id="L4002">                        return (Accessible) children[j];</span>
                    } else {
<span class="nc" id="L4004">                        count++;</span>
                    }
                }
            }
<span class="nc" id="L4008">            return null;</span>
<span class="nc" id="L4009">        }</span>
    }

    // ************************** MIXING CODE *******************************

    final void increaseComponentCount(Component c) {
<span class="nc" id="L4015">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L4016" title="All 2 branches missed.">            if (!c.isDisplayable()) {</span>
<span class="nc" id="L4017">                throw new IllegalStateException(</span>
                    &quot;Peer does not exist while invoking the increaseComponentCount() method&quot;
                );
            }

<span class="nc" id="L4022">            int addHW = 0;</span>
<span class="nc" id="L4023">            int addLW = 0;</span>

<span class="nc bnc" id="L4025" title="All 2 branches missed.">            if (c instanceof Container) {</span>
<span class="nc" id="L4026">                addLW = ((Container)c).numOfLWComponents;</span>
<span class="nc" id="L4027">                addHW = ((Container)c).numOfHWComponents;</span>
            }
<span class="nc bnc" id="L4029" title="All 2 branches missed.">            if (c.isLightweight()) {</span>
<span class="nc" id="L4030">                addLW++;</span>
            } else {
<span class="nc" id="L4032">                addHW++;</span>
            }

<span class="nc bnc" id="L4035" title="All 2 branches missed.">            for (Container cont = this; cont != null; cont = cont.getContainer()) {</span>
<span class="nc" id="L4036">                cont.numOfLWComponents += addLW;</span>
<span class="nc" id="L4037">                cont.numOfHWComponents += addHW;</span>
            }
<span class="nc" id="L4039">        }</span>
<span class="nc" id="L4040">    }</span>

    final void decreaseComponentCount(Component c) {
<span class="nc" id="L4043">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L4044" title="All 2 branches missed.">            if (!c.isDisplayable()) {</span>
<span class="nc" id="L4045">                throw new IllegalStateException(</span>
                    &quot;Peer does not exist while invoking the decreaseComponentCount() method&quot;
                );
            }

<span class="nc" id="L4050">            int subHW = 0;</span>
<span class="nc" id="L4051">            int subLW = 0;</span>

<span class="nc bnc" id="L4053" title="All 2 branches missed.">            if (c instanceof Container) {</span>
<span class="nc" id="L4054">                subLW = ((Container)c).numOfLWComponents;</span>
<span class="nc" id="L4055">                subHW = ((Container)c).numOfHWComponents;</span>
            }
<span class="nc bnc" id="L4057" title="All 2 branches missed.">            if (c.isLightweight()) {</span>
<span class="nc" id="L4058">                subLW++;</span>
            } else {
<span class="nc" id="L4060">                subHW++;</span>
            }

<span class="nc bnc" id="L4063" title="All 2 branches missed.">            for (Container cont = this; cont != null; cont = cont.getContainer()) {</span>
<span class="nc" id="L4064">                cont.numOfLWComponents -= subLW;</span>
<span class="nc" id="L4065">                cont.numOfHWComponents -= subHW;</span>
            }
<span class="nc" id="L4067">        }</span>
<span class="nc" id="L4068">    }</span>

    private int getTopmostComponentIndex() {
<span class="nc" id="L4071">        checkTreeLock();</span>
<span class="nc bnc" id="L4072" title="All 2 branches missed.">        if (getComponentCount() &gt; 0) {</span>
<span class="nc" id="L4073">            return 0;</span>
        }
<span class="nc" id="L4075">        return -1;</span>
    }

    private int getBottommostComponentIndex() {
<span class="nc" id="L4079">        checkTreeLock();</span>
<span class="nc bnc" id="L4080" title="All 2 branches missed.">        if (getComponentCount() &gt; 0) {</span>
<span class="nc" id="L4081">            return getComponentCount() - 1;</span>
        }
<span class="nc" id="L4083">        return -1;</span>
    }

    /*
     * This method is overriden to handle opaque children in non-opaque
     * containers.
     */
    @Override
    final Region getOpaqueShape() {
<span class="nc" id="L4092">        checkTreeLock();</span>
<span class="nc bnc" id="L4093" title="All 4 branches missed.">        if (isLightweight() &amp;&amp; isNonOpaqueForMixing()</span>
<span class="nc bnc" id="L4094" title="All 2 branches missed.">                &amp;&amp; hasLightweightDescendants())</span>
        {
<span class="nc" id="L4096">            Region s = Region.EMPTY_REGION;</span>
<span class="nc bnc" id="L4097" title="All 2 branches missed.">            for (int index = 0; index &lt; getComponentCount(); index++) {</span>
<span class="nc" id="L4098">                Component c = getComponent(index);</span>
<span class="nc bnc" id="L4099" title="All 4 branches missed.">                if (c.isLightweight() &amp;&amp; c.isShowing()) {</span>
<span class="nc" id="L4100">                    s = s.getUnion(c.getOpaqueShape());</span>
                }
            }
<span class="nc" id="L4103">            return s.getIntersection(getNormalShape());</span>
        }
<span class="nc" id="L4105">        return super.getOpaqueShape();</span>
    }

    final void recursiveSubtractAndApplyShape(Region shape) {
<span class="nc" id="L4109">        recursiveSubtractAndApplyShape(shape, getTopmostComponentIndex(), getBottommostComponentIndex());</span>
<span class="nc" id="L4110">    }</span>

    final void recursiveSubtractAndApplyShape(Region shape, int fromZorder) {
<span class="nc" id="L4113">        recursiveSubtractAndApplyShape(shape, fromZorder, getBottommostComponentIndex());</span>
<span class="nc" id="L4114">    }</span>

    final void recursiveSubtractAndApplyShape(Region shape, int fromZorder, int toZorder) {
<span class="nc" id="L4117">        checkTreeLock();</span>
<span class="nc bnc" id="L4118" title="All 2 branches missed.">        if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L4119">            mixingLog.fine(&quot;this = &quot; + this +</span>
                &quot;; shape=&quot; + shape + &quot;; fromZ=&quot; + fromZorder + &quot;; toZ=&quot; + toZorder);
        }
<span class="nc bnc" id="L4122" title="All 2 branches missed.">        if (fromZorder == -1) {</span>
<span class="nc" id="L4123">            return;</span>
        }
<span class="nc bnc" id="L4125" title="All 2 branches missed.">        if (shape.isEmpty()) {</span>
<span class="nc" id="L4126">            return;</span>
        }
        // An invalid container with not-null layout should be ignored
        // by the mixing code, the container will be validated later
        // and the mixing code will be executed later.
<span class="nc bnc" id="L4131" title="All 4 branches missed.">        if (getLayout() != null &amp;&amp; !isValid()) {</span>
<span class="nc" id="L4132">            return;</span>
        }
<span class="nc bnc" id="L4134" title="All 2 branches missed.">        for (int index = fromZorder; index &lt;= toZorder; index++) {</span>
<span class="nc" id="L4135">            Component comp = getComponent(index);</span>
<span class="nc bnc" id="L4136" title="All 2 branches missed.">            if (!comp.isLightweight()) {</span>
<span class="nc" id="L4137">                comp.subtractAndApplyShape(shape);</span>
<span class="nc bnc" id="L4138" title="All 2 branches missed.">            } else if (comp instanceof Container &amp;&amp;</span>
<span class="nc bnc" id="L4139" title="All 4 branches missed.">                    ((Container)comp).hasHeavyweightDescendants() &amp;&amp; comp.isShowing()) {</span>
<span class="nc" id="L4140">                ((Container)comp).recursiveSubtractAndApplyShape(shape);</span>
            }
        }
<span class="nc" id="L4143">    }</span>

    final void recursiveApplyCurrentShape() {
<span class="nc" id="L4146">        recursiveApplyCurrentShape(getTopmostComponentIndex(), getBottommostComponentIndex());</span>
<span class="nc" id="L4147">    }</span>

    final void recursiveApplyCurrentShape(int fromZorder) {
<span class="nc" id="L4150">        recursiveApplyCurrentShape(fromZorder, getBottommostComponentIndex());</span>
<span class="nc" id="L4151">    }</span>

    final void recursiveApplyCurrentShape(int fromZorder, int toZorder) {
<span class="nc" id="L4154">        checkTreeLock();</span>
<span class="nc bnc" id="L4155" title="All 2 branches missed.">        if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L4156">            mixingLog.fine(&quot;this = &quot; + this +</span>
                &quot;; fromZ=&quot; + fromZorder + &quot;; toZ=&quot; + toZorder);
        }
<span class="nc bnc" id="L4159" title="All 2 branches missed.">        if (fromZorder == -1) {</span>
<span class="nc" id="L4160">            return;</span>
        }
        // An invalid container with not-null layout should be ignored
        // by the mixing code, the container will be validated later
        // and the mixing code will be executed later.
<span class="nc bnc" id="L4165" title="All 4 branches missed.">        if (getLayout() != null &amp;&amp; !isValid()) {</span>
<span class="nc" id="L4166">            return;</span>
        }
<span class="nc bnc" id="L4168" title="All 2 branches missed.">        for (int index = fromZorder; index &lt;= toZorder; index++) {</span>
<span class="nc" id="L4169">            Component comp = getComponent(index);</span>
<span class="nc bnc" id="L4170" title="All 2 branches missed.">            if (!comp.isLightweight()) {</span>
<span class="nc" id="L4171">                comp.applyCurrentShape();</span>
            }
<span class="nc bnc" id="L4173" title="All 2 branches missed.">            if (comp instanceof Container &amp;&amp;</span>
<span class="nc bnc" id="L4174" title="All 2 branches missed.">                    ((Container)comp).hasHeavyweightDescendants()) {</span>
<span class="nc" id="L4175">                ((Container)comp).recursiveApplyCurrentShape();</span>
            }
        }
<span class="nc" id="L4178">    }</span>

    private void recursiveShowHeavyweightChildren() {
<span class="nc bnc" id="L4181" title="All 4 branches missed.">        if (!hasHeavyweightDescendants() || !isVisible()) {</span>
<span class="nc" id="L4182">            return;</span>
        }
<span class="nc bnc" id="L4184" title="All 2 branches missed.">        for (int index = 0; index &lt; getComponentCount(); index++) {</span>
<span class="nc" id="L4185">            Component comp = getComponent(index);</span>
<span class="nc bnc" id="L4186" title="All 2 branches missed.">            if (comp.isLightweight()) {</span>
<span class="nc bnc" id="L4187" title="All 2 branches missed.">                if  (comp instanceof Container) {</span>
<span class="nc" id="L4188">                    ((Container)comp).recursiveShowHeavyweightChildren();</span>
                }
            } else {
<span class="nc bnc" id="L4191" title="All 2 branches missed.">                if (comp.isVisible()) {</span>
<span class="nc" id="L4192">                    ComponentPeer peer = comp.getPeer();</span>
<span class="nc bnc" id="L4193" title="All 2 branches missed.">                    if (peer != null) {</span>
<span class="nc" id="L4194">                        peer.setVisible(true);</span>
                    }
                }
            }
        }
<span class="nc" id="L4199">    }</span>

    private void recursiveHideHeavyweightChildren() {
<span class="nc bnc" id="L4202" title="All 2 branches missed.">        if (!hasHeavyweightDescendants()) {</span>
<span class="nc" id="L4203">            return;</span>
        }
<span class="nc bnc" id="L4205" title="All 2 branches missed.">        for (int index = 0; index &lt; getComponentCount(); index++) {</span>
<span class="nc" id="L4206">            Component comp = getComponent(index);</span>
<span class="nc bnc" id="L4207" title="All 2 branches missed.">            if (comp.isLightweight()) {</span>
<span class="nc bnc" id="L4208" title="All 2 branches missed.">                if  (comp instanceof Container) {</span>
<span class="nc" id="L4209">                    ((Container)comp).recursiveHideHeavyweightChildren();</span>
                }
            } else {
<span class="nc bnc" id="L4212" title="All 2 branches missed.">                if (comp.isVisible()) {</span>
<span class="nc" id="L4213">                    ComponentPeer peer = comp.getPeer();</span>
<span class="nc bnc" id="L4214" title="All 2 branches missed.">                    if (peer != null) {</span>
<span class="nc" id="L4215">                        peer.setVisible(false);</span>
                    }
                }
            }
        }
<span class="nc" id="L4220">    }</span>

    private void recursiveRelocateHeavyweightChildren(Point origin) {
<span class="nc bnc" id="L4223" title="All 2 branches missed.">        for (int index = 0; index &lt; getComponentCount(); index++) {</span>
<span class="nc" id="L4224">            Component comp = getComponent(index);</span>
<span class="nc bnc" id="L4225" title="All 2 branches missed.">            if (comp.isLightweight()) {</span>
<span class="nc bnc" id="L4226" title="All 2 branches missed.">                if  (comp instanceof Container &amp;&amp;</span>
<span class="nc bnc" id="L4227" title="All 2 branches missed.">                        ((Container)comp).hasHeavyweightDescendants())</span>
                {
<span class="nc" id="L4229">                    final Point newOrigin = new Point(origin);</span>
<span class="nc" id="L4230">                    newOrigin.translate(comp.getX(), comp.getY());</span>
<span class="nc" id="L4231">                    ((Container)comp).recursiveRelocateHeavyweightChildren(newOrigin);</span>
<span class="nc" id="L4232">                }</span>
            } else {
<span class="nc" id="L4234">                ComponentPeer peer = comp.getPeer();</span>
<span class="nc bnc" id="L4235" title="All 2 branches missed.">                if (peer != null) {</span>
<span class="nc" id="L4236">                    peer.setBounds(origin.x + comp.getX(), origin.y + comp.getY(),</span>
<span class="nc" id="L4237">                            comp.getWidth(), comp.getHeight(),</span>
                            ComponentPeer.SET_LOCATION);
                }
            }
        }
<span class="nc" id="L4242">    }</span>

    /**
     * Checks if the container and its direct lightweight containers are
     * visible.
     *
     * Consider the heavyweight container hides or shows the HW descendants
     * automatically. Therefore we care of LW containers' visibility only.
     *
     * This method MUST be invoked under the TreeLock.
     */
    final boolean isRecursivelyVisibleUpToHeavyweightContainer() {
<span class="nc bnc" id="L4254" title="All 2 branches missed.">        if (!isLightweight()) {</span>
<span class="nc" id="L4255">            return true;</span>
        }

<span class="nc" id="L4258">        for (Container cont = this;</span>
<span class="nc bnc" id="L4259" title="All 4 branches missed.">                cont != null &amp;&amp; cont.isLightweight();</span>
<span class="nc" id="L4260">                cont = cont.getContainer())</span>
        {
<span class="nc bnc" id="L4262" title="All 2 branches missed.">            if (!cont.isVisible()) {</span>
<span class="nc" id="L4263">                return false;</span>
            }
        }
<span class="nc" id="L4266">        return true;</span>
    }

    @Override
    void mixOnShowing() {
<span class="nc" id="L4271">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L4272" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L4273">                mixingLog.fine(&quot;this = &quot; + this);</span>
            }

<span class="nc" id="L4276">            boolean isLightweight = isLightweight();</span>

<span class="nc bnc" id="L4278" title="All 4 branches missed.">            if (isLightweight &amp;&amp; isRecursivelyVisibleUpToHeavyweightContainer()) {</span>
<span class="nc" id="L4279">                recursiveShowHeavyweightChildren();</span>
            }

<span class="nc bnc" id="L4282" title="All 2 branches missed.">            if (!isMixingNeeded()) {</span>
<span class="nc" id="L4283">                return;</span>
            }

<span class="nc bnc" id="L4286" title="All 6 branches missed.">            if (!isLightweight || (isLightweight &amp;&amp; hasHeavyweightDescendants())) {</span>
<span class="nc" id="L4287">                recursiveApplyCurrentShape();</span>
            }

<span class="nc" id="L4290">            super.mixOnShowing();</span>
<span class="nc" id="L4291">        }</span>
<span class="nc" id="L4292">    }</span>

    @Override
    void mixOnHiding(boolean isLightweight) {
<span class="nc" id="L4296">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L4297" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L4298">                mixingLog.fine(&quot;this = &quot; + this +</span>
                        &quot;; isLightweight=&quot; + isLightweight);
            }
<span class="nc bnc" id="L4301" title="All 2 branches missed.">            if (isLightweight) {</span>
<span class="nc" id="L4302">                recursiveHideHeavyweightChildren();</span>
            }
<span class="nc" id="L4304">            super.mixOnHiding(isLightweight);</span>
<span class="nc" id="L4305">        }</span>
<span class="nc" id="L4306">    }</span>

    @Override
    void mixOnReshaping() {
<span class="nc" id="L4310">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L4311" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L4312">                mixingLog.fine(&quot;this = &quot; + this);</span>
            }

<span class="nc" id="L4315">            boolean isMixingNeeded = isMixingNeeded();</span>

<span class="nc bnc" id="L4317" title="All 4 branches missed.">            if (isLightweight() &amp;&amp; hasHeavyweightDescendants()) {</span>
<span class="nc" id="L4318">                final Point origin = new Point(getX(), getY());</span>
<span class="nc" id="L4319">                for (Container cont = getContainer();</span>
<span class="nc bnc" id="L4320" title="All 4 branches missed.">                        cont != null &amp;&amp; cont.isLightweight();</span>
<span class="nc" id="L4321">                        cont = cont.getContainer())</span>
                {
<span class="nc" id="L4323">                    origin.translate(cont.getX(), cont.getY());</span>
                }

<span class="nc" id="L4326">                recursiveRelocateHeavyweightChildren(origin);</span>

<span class="nc bnc" id="L4328" title="All 2 branches missed.">                if (!isMixingNeeded) {</span>
<span class="nc" id="L4329">                    return;</span>
                }

<span class="nc" id="L4332">                recursiveApplyCurrentShape();</span>
            }

<span class="nc bnc" id="L4335" title="All 2 branches missed.">            if (!isMixingNeeded) {</span>
<span class="nc" id="L4336">                return;</span>
            }

<span class="nc" id="L4339">            super.mixOnReshaping();</span>
<span class="nc" id="L4340">        }</span>
<span class="nc" id="L4341">    }</span>

    @Override
    void mixOnZOrderChanging(int oldZorder, int newZorder) {
<span class="nc" id="L4345">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L4346" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L4347">                mixingLog.fine(&quot;this = &quot; + this +</span>
                    &quot;; oldZ=&quot; + oldZorder + &quot;; newZ=&quot; + newZorder);
            }

<span class="nc bnc" id="L4351" title="All 2 branches missed.">            if (!isMixingNeeded()) {</span>
<span class="nc" id="L4352">                return;</span>
            }

<span class="nc bnc" id="L4355" title="All 2 branches missed.">            boolean becameHigher = newZorder &lt; oldZorder;</span>

<span class="nc bnc" id="L4357" title="All 6 branches missed.">            if (becameHigher &amp;&amp; isLightweight() &amp;&amp; hasHeavyweightDescendants()) {</span>
<span class="nc" id="L4358">                recursiveApplyCurrentShape();</span>
            }
<span class="nc" id="L4360">            super.mixOnZOrderChanging(oldZorder, newZorder);</span>
<span class="nc" id="L4361">        }</span>
<span class="nc" id="L4362">    }</span>

    @Override
    void mixOnValidating() {
<span class="nc" id="L4366">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L4367" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L4368">                mixingLog.fine(&quot;this = &quot; + this);</span>
            }

<span class="nc bnc" id="L4371" title="All 2 branches missed.">            if (!isMixingNeeded()) {</span>
<span class="nc" id="L4372">                return;</span>
            }

<span class="nc bnc" id="L4375" title="All 2 branches missed.">            if (hasHeavyweightDescendants()) {</span>
<span class="nc" id="L4376">                recursiveApplyCurrentShape();</span>
            }

<span class="nc bnc" id="L4379" title="All 4 branches missed.">            if (isLightweight() &amp;&amp; isNonOpaqueForMixing()) {</span>
<span class="nc" id="L4380">                subtractAndApplyShapeBelowMe();</span>
            }

<span class="nc" id="L4383">            super.mixOnValidating();</span>
<span class="nc" id="L4384">        }</span>
<span class="nc" id="L4385">    }</span>

    // ****************** END OF MIXING CODE ********************************
}


/**
 * Class to manage the dispatching of MouseEvents to the lightweight descendants
 * and SunDropTargetEvents to both lightweight and heavyweight descendants
 * contained by a native container.
 *
 * NOTE: the class name is not appropriate anymore, but we cannot change it
 * because we must keep serialization compatibility.
 *
 * @author Timothy Prinzing
 */
<span class="nc bnc" id="L4401" title="All 2 branches missed.">class LightweightDispatcher implements java.io.Serializable, AWTEventListener {</span>

    /*
     * JDK 1.1 serialVersionUID
     */
    private static final long serialVersionUID = 5184291520170872969L;
    /*
     * Our own mouse event for when we're dragged over from another hw
     * container
     */
    private static final int  LWD_MOUSE_DRAGGED_OVER = 1500;

<span class="nc" id="L4413">    private static final PlatformLogger eventLog = PlatformLogger.getLogger(&quot;java.awt.event.LightweightDispatcher&quot;);</span>

<span class="nc" id="L4415">    LightweightDispatcher(Container nativeContainer) {</span>
<span class="nc" id="L4416">        this.nativeContainer = nativeContainer;</span>
<span class="nc" id="L4417">        mouseEventTarget = null;</span>
<span class="nc" id="L4418">        eventMask = 0;</span>
<span class="nc" id="L4419">    }</span>

    /*
     * Clean up any resources allocated when dispatcher was created;
     * should be called from Container.removeNotify
     */
    void dispose() {
        //System.out.println(&quot;Disposing lw dispatcher&quot;);
<span class="nc" id="L4427">        stopListeningForOtherDrags();</span>
<span class="nc" id="L4428">        mouseEventTarget = null;</span>
<span class="nc" id="L4429">        targetLastEntered = null;</span>
<span class="nc" id="L4430">    }</span>

    /**
     * Enables events to subcomponents.
     */
    void enableEvents(long events) {
<span class="nc" id="L4436">        eventMask |= events;</span>
<span class="nc" id="L4437">    }</span>

    /**
     * Dispatches an event to a sub-component if necessary, and
     * returns whether or not the event was forwarded to a
     * sub-component.
     *
     * @param e the event
     */
    boolean dispatchEvent(AWTEvent e) {
<span class="nc" id="L4447">        boolean ret = false;</span>

        /*
         * Fix for BugTraq Id 4389284.
         * Dispatch SunDropTargetEvents regardless of eventMask value.
         * Do not update cursor on dispatching SunDropTargetEvents.
         */
<span class="nc bnc" id="L4454" title="All 2 branches missed.">        if (e instanceof SunDropTargetEvent) {</span>

<span class="nc" id="L4456">            SunDropTargetEvent sdde = (SunDropTargetEvent) e;</span>
<span class="nc" id="L4457">            ret = processDropTargetEvent(sdde);</span>

<span class="nc" id="L4459">        } else {</span>
<span class="nc bnc" id="L4460" title="All 4 branches missed.">            if (e instanceof MouseEvent &amp;&amp; (eventMask &amp; MOUSE_MASK) != 0) {</span>
<span class="nc" id="L4461">                MouseEvent me = (MouseEvent) e;</span>
<span class="nc" id="L4462">                ret = processMouseEvent(me);</span>
            }

<span class="nc bnc" id="L4465" title="All 2 branches missed.">            if (e.getID() == MouseEvent.MOUSE_MOVED) {</span>
<span class="nc" id="L4466">                nativeContainer.updateCursorImmediately();</span>
            }
        }

<span class="nc" id="L4470">        return ret;</span>
    }

    /* This method effectively returns whether or not a mouse button was down
     * just BEFORE the event happened.  A better method name might be
     * wasAMouseButtonDownBeforeThisEvent().
     */
    private boolean isMouseGrab(MouseEvent e) {
<span class="nc" id="L4478">        int modifiers = e.getModifiersEx();</span>

<span class="nc bnc" id="L4480" title="All 2 branches missed.">        if(e.getID() == MouseEvent.MOUSE_PRESSED</span>
<span class="nc bnc" id="L4481" title="All 2 branches missed.">            || e.getID() == MouseEvent.MOUSE_RELEASED)</span>
        {
<span class="nc bnc" id="L4483" title="All 4 branches missed.">            switch (e.getButton()) {</span>
            case MouseEvent.BUTTON1:
<span class="nc" id="L4485">                modifiers ^= InputEvent.BUTTON1_DOWN_MASK;</span>
<span class="nc" id="L4486">                break;</span>
            case MouseEvent.BUTTON2:
<span class="nc" id="L4488">                modifiers ^= InputEvent.BUTTON2_DOWN_MASK;</span>
<span class="nc" id="L4489">                break;</span>
            case MouseEvent.BUTTON3:
<span class="nc" id="L4491">                modifiers ^= InputEvent.BUTTON3_DOWN_MASK;</span>
                break;
            }
        }
        /* modifiers now as just before event */
<span class="nc bnc" id="L4496" title="All 2 branches missed.">        return ((modifiers &amp; (InputEvent.BUTTON1_DOWN_MASK</span>
                              | InputEvent.BUTTON2_DOWN_MASK
                              | InputEvent.BUTTON3_DOWN_MASK)) != 0);
    }

    /**
     * This method attempts to distribute a mouse event to a lightweight
     * component.  It tries to avoid doing any unnecessary probes down
     * into the component tree to minimize the overhead of determining
     * where to route the event, since mouse movement events tend to
     * come in large and frequent amounts.
     */
    private boolean processMouseEvent(MouseEvent e) {
<span class="nc" id="L4509">        int id = e.getID();</span>
<span class="nc" id="L4510">        Component mouseOver =   // sensitive to mouse events</span>
<span class="nc" id="L4511">            nativeContainer.getMouseEventTarget(e.getX(), e.getY(),</span>
                                                Container.INCLUDE_SELF);

<span class="nc" id="L4514">        trackMouseEnterExit(mouseOver, e);</span>

    // 4508327 : MOUSE_CLICKED should only go to the recipient of
    // the accompanying MOUSE_PRESSED, so don't reset mouseEventTarget on a
    // MOUSE_CLICKED.
<span class="nc bnc" id="L4519" title="All 4 branches missed.">    if (!isMouseGrab(e) &amp;&amp; id != MouseEvent.MOUSE_CLICKED) {</span>
<span class="nc bnc" id="L4520" title="All 2 branches missed.">            mouseEventTarget = (mouseOver != nativeContainer) ? mouseOver: null;</span>
<span class="nc" id="L4521">            isCleaned = false;</span>
        }

<span class="nc bnc" id="L4524" title="All 2 branches missed.">        if (mouseEventTarget != null) {</span>
<span class="nc bnc" id="L4525" title="All 8 branches missed.">            switch (id) {</span>
            case MouseEvent.MOUSE_ENTERED:
            case MouseEvent.MOUSE_EXITED:
<span class="nc" id="L4528">                break;</span>
            case MouseEvent.MOUSE_PRESSED:
<span class="nc" id="L4530">                retargetMouseEvent(mouseEventTarget, id, e);</span>
<span class="nc" id="L4531">                break;</span>
        case MouseEvent.MOUSE_RELEASED:
<span class="nc" id="L4533">            retargetMouseEvent(mouseEventTarget, id, e);</span>
<span class="nc" id="L4534">        break;</span>
        case MouseEvent.MOUSE_CLICKED:
        // 4508327: MOUSE_CLICKED should never be dispatched to a Component
        // other than that which received the MOUSE_PRESSED event.  If the
        // mouse is now over a different Component, don't dispatch the event.
        // The previous fix for a similar problem was associated with bug
        // 4155217.
<span class="nc bnc" id="L4541" title="All 2 branches missed.">        if (mouseOver == mouseEventTarget) {</span>
<span class="nc" id="L4542">            retargetMouseEvent(mouseOver, id, e);</span>
        }
        break;
            case MouseEvent.MOUSE_MOVED:
<span class="nc" id="L4546">                retargetMouseEvent(mouseEventTarget, id, e);</span>
<span class="nc" id="L4547">                break;</span>
        case MouseEvent.MOUSE_DRAGGED:
<span class="nc bnc" id="L4549" title="All 2 branches missed.">            if (isMouseGrab(e)) {</span>
<span class="nc" id="L4550">                retargetMouseEvent(mouseEventTarget, id, e);</span>
            }
                break;
        case MouseEvent.MOUSE_WHEEL:
            // This may send it somewhere that doesn't have MouseWheelEvents
            // enabled.  In this case, Component.dispatchEventImpl() will
            // retarget the event to a parent that DOES have the events enabled.
<span class="nc bnc" id="L4557" title="All 4 branches missed.">            if (eventLog.isLoggable(PlatformLogger.Level.FINEST) &amp;&amp; (mouseOver != null)) {</span>
<span class="nc" id="L4558">                eventLog.finest(&quot;retargeting mouse wheel to &quot; +</span>
<span class="nc" id="L4559">                                mouseOver.getName() + &quot;, &quot; +</span>
<span class="nc" id="L4560">                                mouseOver.getClass());</span>
            }
<span class="nc" id="L4562">            retargetMouseEvent(mouseOver, id, e);</span>
        break;
            }
        //Consuming of wheel events is implemented in &quot;retargetMouseEvent&quot;.
<span class="nc bnc" id="L4566" title="All 2 branches missed.">        if (id != MouseEvent.MOUSE_WHEEL) {</span>
<span class="nc" id="L4567">            e.consume();</span>
        }
<span class="nc bnc" id="L4569" title="All 4 branches missed.">    } else if (isCleaned &amp;&amp; id != MouseEvent.MOUSE_WHEEL) {</span>
        //After mouseEventTarget was removed and cleaned should consume all events
        //until new mouseEventTarget is found
<span class="nc" id="L4572">        e.consume();</span>
    }
<span class="nc" id="L4574">    return e.isConsumed();</span>
    }

    private boolean processDropTargetEvent(SunDropTargetEvent e) {
<span class="nc" id="L4578">        int id = e.getID();</span>
<span class="nc" id="L4579">        int x = e.getX();</span>
<span class="nc" id="L4580">        int y = e.getY();</span>

        /*
         * Fix for BugTraq ID 4395290.
         * It is possible that SunDropTargetEvent's Point is outside of the
         * native container bounds. In this case we truncate coordinates.
         */
<span class="nc bnc" id="L4587" title="All 2 branches missed.">        if (!nativeContainer.contains(x, y)) {</span>
<span class="nc" id="L4588">            final Dimension d = nativeContainer.getSize();</span>
<span class="nc bnc" id="L4589" title="All 2 branches missed.">            if (d.width &lt;= x) {</span>
<span class="nc" id="L4590">                x = d.width - 1;</span>
<span class="nc bnc" id="L4591" title="All 2 branches missed.">            } else if (x &lt; 0) {</span>
<span class="nc" id="L4592">                x = 0;</span>
            }
<span class="nc bnc" id="L4594" title="All 2 branches missed.">            if (d.height &lt;= y) {</span>
<span class="nc" id="L4595">                y = d.height - 1;</span>
<span class="nc bnc" id="L4596" title="All 2 branches missed.">            } else if (y &lt; 0) {</span>
<span class="nc" id="L4597">                y = 0;</span>
            }
        }
<span class="nc" id="L4600">        Component mouseOver =   // not necessarily sensitive to mouse events</span>
<span class="nc" id="L4601">            nativeContainer.getDropTargetEventTarget(x, y,</span>
                                                     Container.INCLUDE_SELF);
<span class="nc" id="L4603">        trackMouseEnterExit(mouseOver, e);</span>

<span class="nc bnc" id="L4605" title="All 4 branches missed.">        if (mouseOver != nativeContainer &amp;&amp; mouseOver != null) {</span>
<span class="nc bnc" id="L4606" title="All 2 branches missed.">            switch (id) {</span>
            case SunDropTargetEvent.MOUSE_ENTERED:
            case SunDropTargetEvent.MOUSE_EXITED:
<span class="nc" id="L4609">                break;</span>
            default:
<span class="nc" id="L4611">                retargetMouseEvent(mouseOver, id, e);</span>
<span class="nc" id="L4612">                e.consume();</span>
                break;
            }
        }
<span class="nc" id="L4616">        return e.isConsumed();</span>
    }

    /*
     * Generates enter/exit events as mouse moves over lw components
     * @param targetOver        Target mouse is over (including native container)
     * @param e                 Mouse event in native container
     */
    private void trackMouseEnterExit(Component targetOver, MouseEvent e) {
<span class="nc" id="L4625">        Component       targetEnter = null;</span>
<span class="nc" id="L4626">        int             id = e.getID();</span>

<span class="nc bnc" id="L4628" title="All 6 branches missed.">        if (e instanceof SunDropTargetEvent &amp;&amp;</span>
            id == MouseEvent.MOUSE_ENTERED &amp;&amp;
            isMouseInNativeContainer == true) {
            // This can happen if a lightweight component which initiated the
            // drag has an associated drop target. MOUSE_ENTERED comes when the
            // mouse is in the native container already. To propagate this event
            // properly we should null out targetLastEntered.
<span class="nc" id="L4635">            targetLastEntered = null;</span>
<span class="nc bnc" id="L4636" title="All 8 branches missed.">        } else if ( id != MouseEvent.MOUSE_EXITED &amp;&amp;</span>
             id != MouseEvent.MOUSE_DRAGGED &amp;&amp;
             id != LWD_MOUSE_DRAGGED_OVER &amp;&amp;
             isMouseInNativeContainer == false ) {
            // any event but an exit or drag means we're in the native container
<span class="nc" id="L4641">            isMouseInNativeContainer = true;</span>
<span class="nc" id="L4642">            startListeningForOtherDrags();</span>
<span class="nc bnc" id="L4643" title="All 2 branches missed.">        } else if ( id == MouseEvent.MOUSE_EXITED ) {</span>
<span class="nc" id="L4644">            isMouseInNativeContainer = false;</span>
<span class="nc" id="L4645">            stopListeningForOtherDrags();</span>
        }

<span class="nc bnc" id="L4648" title="All 2 branches missed.">        if (isMouseInNativeContainer) {</span>
<span class="nc" id="L4649">            targetEnter = targetOver;</span>
        }

<span class="nc bnc" id="L4652" title="All 2 branches missed.">        if (targetLastEntered == targetEnter) {</span>
<span class="nc" id="L4653">                return;</span>
        }

<span class="nc bnc" id="L4656" title="All 2 branches missed.">        if (targetLastEntered != null) {</span>
<span class="nc" id="L4657">            retargetMouseEvent(targetLastEntered, MouseEvent.MOUSE_EXITED, e);</span>
        }
<span class="nc bnc" id="L4659" title="All 2 branches missed.">        if (id == MouseEvent.MOUSE_EXITED) {</span>
            // consume native exit event if we generate one
<span class="nc" id="L4661">            e.consume();</span>
        }

<span class="nc bnc" id="L4664" title="All 2 branches missed.">        if (targetEnter != null) {</span>
<span class="nc" id="L4665">            retargetMouseEvent(targetEnter, MouseEvent.MOUSE_ENTERED, e);</span>
        }
<span class="nc bnc" id="L4667" title="All 2 branches missed.">        if (id == MouseEvent.MOUSE_ENTERED) {</span>
            // consume native enter event if we generate one
<span class="nc" id="L4669">            e.consume();</span>
        }

<span class="nc" id="L4672">        targetLastEntered = targetEnter;</span>
<span class="nc" id="L4673">    }</span>

    /*
     * Listens to global mouse drag events so even drags originating
     * from other heavyweight containers will generate enter/exit
     * events in this container
     */
    private void startListeningForOtherDrags() {
        //System.out.println(&quot;Adding AWTEventListener&quot;);
<span class="nc" id="L4682">        java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L4683">            new java.security.PrivilegedAction&lt;Object&gt;() {</span>
                public Object run() {
<span class="nc" id="L4685">                    nativeContainer.getToolkit().addAWTEventListener(</span>
                        LightweightDispatcher.this,
                        AWTEvent.MOUSE_EVENT_MASK |
                        AWTEvent.MOUSE_MOTION_EVENT_MASK);
<span class="nc" id="L4689">                    return null;</span>
                }
            }
        );
<span class="nc" id="L4693">    }</span>

    private void stopListeningForOtherDrags() {
        //System.out.println(&quot;Removing AWTEventListener&quot;);
<span class="nc" id="L4697">        java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L4698">            new java.security.PrivilegedAction&lt;Object&gt;() {</span>
                public Object run() {
<span class="nc" id="L4700">                    nativeContainer.getToolkit().removeAWTEventListener(LightweightDispatcher.this);</span>
<span class="nc" id="L4701">                    return null;</span>
                }
            }
        );
<span class="nc" id="L4705">    }</span>

    /*
     * (Implementation of AWTEventListener)
     * Listen for drag events posted in other hw components so we can
     * track enter/exit regardless of where a drag originated
     */
    public void eventDispatched(AWTEvent e) {
<span class="nc bnc" id="L4713" title="All 6 branches missed.">        boolean isForeignDrag = (e instanceof MouseEvent) &amp;&amp;</span>
                                !(e instanceof SunDropTargetEvent) &amp;&amp;
                                (e.id == MouseEvent.MOUSE_DRAGGED) &amp;&amp;
<span class="nc bnc" id="L4716" title="All 2 branches missed.">                                (e.getSource() != nativeContainer);</span>

<span class="nc bnc" id="L4718" title="All 2 branches missed.">        if (!isForeignDrag) {</span>
            // only interested in drags from other hw components
<span class="nc" id="L4720">            return;</span>
        }

<span class="nc" id="L4723">        MouseEvent      srcEvent = (MouseEvent)e;</span>
        MouseEvent      me;

<span class="nc" id="L4726">        synchronized (nativeContainer.getTreeLock()) {</span>
<span class="nc" id="L4727">            Component srcComponent = srcEvent.getComponent();</span>

            // component may have disappeared since drag event posted
            // (i.e. Swing hierarchical menus)
<span class="nc bnc" id="L4731" title="All 2 branches missed.">            if ( !srcComponent.isShowing() ) {</span>
<span class="nc" id="L4732">                return;</span>
            }

            // see 5083555
            // check if srcComponent is in any modal blocked window
<span class="nc" id="L4737">            Component c = nativeContainer;</span>
<span class="nc bnc" id="L4738" title="All 4 branches missed.">            while ((c != null) &amp;&amp; !(c instanceof Window)) {</span>
<span class="nc" id="L4739">                c = c.getParent_NoClientCode();</span>
            }
<span class="nc bnc" id="L4741" title="All 4 branches missed.">            if ((c == null) || ((Window)c).isModalBlocked()) {</span>
<span class="nc" id="L4742">                return;</span>
            }

            //
            // create an internal 'dragged-over' event indicating
            // we are being dragged over from another hw component
            //
<span class="nc" id="L4749">            me = new MouseEvent(nativeContainer,</span>
                               LWD_MOUSE_DRAGGED_OVER,
<span class="nc" id="L4751">                               srcEvent.getWhen(),</span>
<span class="nc" id="L4752">                               srcEvent.getModifiersEx() | srcEvent.getModifiers(),</span>
<span class="nc" id="L4753">                               srcEvent.getX(),</span>
<span class="nc" id="L4754">                               srcEvent.getY(),</span>
<span class="nc" id="L4755">                               srcEvent.getXOnScreen(),</span>
<span class="nc" id="L4756">                               srcEvent.getYOnScreen(),</span>
<span class="nc" id="L4757">                               srcEvent.getClickCount(),</span>
<span class="nc" id="L4758">                               srcEvent.isPopupTrigger(),</span>
<span class="nc" id="L4759">                               srcEvent.getButton());</span>
<span class="nc" id="L4760">            ((AWTEvent)srcEvent).copyPrivateDataInto(me);</span>
            // translate coordinates to this native container
<span class="nc" id="L4762">            final Point ptSrcOrigin = srcComponent.getLocationOnScreen();</span>

<span class="nc bnc" id="L4764" title="All 2 branches missed.">            if (AppContext.getAppContext() != nativeContainer.appContext) {</span>
<span class="nc" id="L4765">                final MouseEvent mouseEvent = me;</span>
<span class="nc" id="L4766">                Runnable r = new Runnable() {</span>
                        public void run() {
<span class="nc bnc" id="L4768" title="All 2 branches missed.">                            if (!nativeContainer.isShowing() ) {</span>
<span class="nc" id="L4769">                                return;</span>
                            }

<span class="nc" id="L4772">                            Point       ptDstOrigin = nativeContainer.getLocationOnScreen();</span>
<span class="nc" id="L4773">                            mouseEvent.translatePoint(ptSrcOrigin.x - ptDstOrigin.x,</span>
                                              ptSrcOrigin.y - ptDstOrigin.y );
<span class="nc" id="L4775">                            Component targetOver =</span>
<span class="nc" id="L4776">                                nativeContainer.getMouseEventTarget(mouseEvent.getX(),</span>
<span class="nc" id="L4777">                                                                    mouseEvent.getY(),</span>
                                                                    Container.INCLUDE_SELF);
<span class="nc" id="L4779">                            trackMouseEnterExit(targetOver, mouseEvent);</span>
<span class="nc" id="L4780">                        }</span>
                    };
<span class="nc" id="L4782">                SunToolkit.executeOnEventHandlerThread(nativeContainer, r);</span>
<span class="nc" id="L4783">                return;</span>
            } else {
<span class="nc bnc" id="L4785" title="All 2 branches missed.">                if (!nativeContainer.isShowing() ) {</span>
<span class="nc" id="L4786">                    return;</span>
                }

<span class="nc" id="L4789">                Point   ptDstOrigin = nativeContainer.getLocationOnScreen();</span>
<span class="nc" id="L4790">                me.translatePoint( ptSrcOrigin.x - ptDstOrigin.x, ptSrcOrigin.y - ptDstOrigin.y );</span>
            }
<span class="nc" id="L4792">        }</span>
        //System.out.println(&quot;Track event: &quot; + me);
        // feed the 'dragged-over' event directly to the enter/exit
        // code (not a real event so don't pass it to dispatchEvent)
<span class="nc" id="L4796">        Component targetOver =</span>
<span class="nc" id="L4797">            nativeContainer.getMouseEventTarget(me.getX(), me.getY(),</span>
                                                Container.INCLUDE_SELF);
<span class="nc" id="L4799">        trackMouseEnterExit(targetOver, me);</span>
<span class="nc" id="L4800">    }</span>

    /**
     * Sends a mouse event to the current mouse event recipient using
     * the given event (sent to the windowed host) as a srcEvent.  If
     * the mouse event target is still in the component tree, the
     * coordinates of the event are translated to those of the target.
     * If the target has been removed, we don't bother to send the
     * message.
     */
    void retargetMouseEvent(Component target, int id, MouseEvent e) {
<span class="nc bnc" id="L4811" title="All 2 branches missed.">        if (target == null) {</span>
<span class="nc" id="L4812">            return; // mouse is over another hw component or target is disabled</span>
        }

<span class="nc" id="L4815">        int x = e.getX(), y = e.getY();</span>
        Component component;

<span class="nc" id="L4818">        for(component = target;</span>
<span class="nc bnc" id="L4819" title="All 4 branches missed.">            component != null &amp;&amp; component != nativeContainer;</span>
<span class="nc" id="L4820">            component = component.getParent()) {</span>
<span class="nc" id="L4821">            x -= component.x;</span>
<span class="nc" id="L4822">            y -= component.y;</span>
        }
        MouseEvent retargeted;
<span class="nc bnc" id="L4825" title="All 2 branches missed.">        if (component != null) {</span>
<span class="nc bnc" id="L4826" title="All 2 branches missed.">            if (e instanceof SunDropTargetEvent) {</span>
<span class="nc" id="L4827">                retargeted = new SunDropTargetEvent(target,</span>
                                                    id,
                                                    x,
                                                    y,
<span class="nc" id="L4831">                                                    ((SunDropTargetEvent)e).getDispatcher());</span>
<span class="nc bnc" id="L4832" title="All 2 branches missed.">            } else if (id == MouseEvent.MOUSE_WHEEL) {</span>
<span class="nc" id="L4833">                retargeted = new MouseWheelEvent(target,</span>
                                      id,
<span class="nc" id="L4835">                                       e.getWhen(),</span>
<span class="nc" id="L4836">                                       e.getModifiersEx() | e.getModifiers(),</span>
                                       x,
                                       y,
<span class="nc" id="L4839">                                       e.getXOnScreen(),</span>
<span class="nc" id="L4840">                                       e.getYOnScreen(),</span>
<span class="nc" id="L4841">                                       e.getClickCount(),</span>
<span class="nc" id="L4842">                                       e.isPopupTrigger(),</span>
<span class="nc" id="L4843">                                       ((MouseWheelEvent)e).getScrollType(),</span>
<span class="nc" id="L4844">                                       ((MouseWheelEvent)e).getScrollAmount(),</span>
<span class="nc" id="L4845">                                       ((MouseWheelEvent)e).getWheelRotation(),</span>
<span class="nc" id="L4846">                                       ((MouseWheelEvent)e).getPreciseWheelRotation());</span>
            }
            else {
<span class="nc" id="L4849">                retargeted = new MouseEvent(target,</span>
                                            id,
<span class="nc" id="L4851">                                            e.getWhen(),</span>
<span class="nc" id="L4852">                                            e.getModifiersEx() | e.getModifiers(),</span>
                                            x,
                                            y,
<span class="nc" id="L4855">                                            e.getXOnScreen(),</span>
<span class="nc" id="L4856">                                            e.getYOnScreen(),</span>
<span class="nc" id="L4857">                                            e.getClickCount(),</span>
<span class="nc" id="L4858">                                            e.isPopupTrigger(),</span>
<span class="nc" id="L4859">                                            e.getButton());</span>
            }

<span class="nc" id="L4862">            ((AWTEvent)e).copyPrivateDataInto(retargeted);</span>

<span class="nc bnc" id="L4864" title="All 2 branches missed.">            if (target == nativeContainer) {</span>
                // avoid recursively calling LightweightDispatcher...
<span class="nc" id="L4866">                ((Container)target).dispatchEventToSelf(retargeted);</span>
            } else {
<span class="nc bnc" id="L4868" title="All 4 branches missed.">                assert AppContext.getAppContext() == target.appContext;</span>

<span class="nc bnc" id="L4870" title="All 2 branches missed.">                if (nativeContainer.modalComp != null) {</span>
<span class="nc bnc" id="L4871" title="All 2 branches missed.">                    if (((Container)nativeContainer.modalComp).isAncestorOf(target)) {</span>
<span class="nc" id="L4872">                        target.dispatchEvent(retargeted);</span>
                    } else {
<span class="nc" id="L4874">                        e.consume();</span>
                    }
                } else {
<span class="nc" id="L4877">                    target.dispatchEvent(retargeted);</span>
                }
            }
<span class="nc bnc" id="L4880" title="All 4 branches missed.">            if (id == MouseEvent.MOUSE_WHEEL &amp;&amp; retargeted.isConsumed()) {</span>
                //An exception for wheel bubbling to the native system.
                //In &quot;processMouseEvent&quot; total event consuming for wheel events is skipped.
                //Protection from bubbling of Java-accepted wheel events.
<span class="nc" id="L4884">                e.consume();</span>
            }
        }
<span class="nc" id="L4887">    }</span>

    // --- member variables -------------------------------

    /**
     * The windowed container that might be hosting events for
     * subcomponents.
     */
    private Container nativeContainer;

    /**
     * This variable is not used, but kept for serialization compatibility
     */
    private Component focus;

    /**
     * The current subcomponent being hosted by this windowed
     * component that has events being forwarded to it.  If this
     * is null, there are currently no events being forwarded to
     * a subcomponent.
     */
    private transient Component mouseEventTarget;

    /**
     * The last component entered
     */
    private transient Component targetLastEntered;

    /**
     * Indicates whether {@code mouseEventTarget} was removed and nulled
     */
    private transient boolean isCleaned;

    /**
     * Is the mouse over the native container
     */
<span class="nc" id="L4923">    private transient boolean isMouseInNativeContainer = false;</span>

    /**
     * This variable is not used, but kept for serialization compatibility
     */
    private Cursor nativeCursor;

    /**
     * The event mask for contained lightweight components.  Lightweight
     * components need a windowed container to host window-related
     * events.  This separate mask indicates events that have been
     * requested by contained lightweight components without effecting
     * the mask of the windowed component itself.
     */
    private long eventMask;

    /**
     * The kind of events routed to lightweight components from windowed
     * hosts.
     */
    private static final long PROXY_EVENT_MASK =
        AWTEvent.FOCUS_EVENT_MASK |
        AWTEvent.KEY_EVENT_MASK |
        AWTEvent.MOUSE_EVENT_MASK |
        AWTEvent.MOUSE_MOTION_EVENT_MASK |
        AWTEvent.MOUSE_WHEEL_EVENT_MASK;

    private static final long MOUSE_MASK =
        AWTEvent.MOUSE_EVENT_MASK |
        AWTEvent.MOUSE_MOTION_EVENT_MASK |
        AWTEvent.MOUSE_WHEEL_EVENT_MASK;

    void removeReferences(Component removedComponent) {
<span class="nc bnc" id="L4956" title="All 2 branches missed.">        if (mouseEventTarget == removedComponent) {</span>
<span class="nc" id="L4957">            isCleaned = true;</span>
<span class="nc" id="L4958">            mouseEventTarget = null;</span>
        }
<span class="nc bnc" id="L4960" title="All 2 branches missed.">        if (targetLastEntered == removedComponent) {</span>
<span class="nc" id="L4961">            targetLastEntered = null;</span>
        }
<span class="nc" id="L4963">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>