<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Window.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">Window.java</span></div><h1>Window.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt;

import java.awt.event.*;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.awt.im.InputContext;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;
import java.awt.peer.ComponentPeer;
import java.awt.peer.WindowPeer;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OptionalDataException;
import java.io.Serializable;
import java.lang.ref.WeakReference;
import java.lang.reflect.InvocationTargetException;
import java.security.AccessController;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EventListener;
import java.util.Locale;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.Vector;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.accessibility.*;
import sun.awt.AWTAccessor;
import sun.awt.AppContext;
import sun.awt.CausedFocusEvent;
import sun.awt.SunToolkit;
import sun.awt.util.IdentityArrayList;
import sun.java2d.Disposer;
import sun.java2d.pipe.Region;
import sun.security.action.GetPropertyAction;
import sun.security.util.SecurityConstants;
import sun.util.logging.PlatformLogger;

/**
 * A {@code Window} object is a top-level window with no borders and no
 * menubar.
 * The default layout for a window is {@code BorderLayout}.
 * &lt;p&gt;
 * A window must have either a frame, dialog, or another window defined as its
 * owner when it's constructed.
 * &lt;p&gt;
 * In a multi-screen environment, you can create a {@code Window}
 * on a different screen device by constructing the {@code Window}
 * with {@link #Window(Window, GraphicsConfiguration)}.  The
 * {@code GraphicsConfiguration} object is one of the
 * {@code GraphicsConfiguration} objects of the target screen device.
 * &lt;p&gt;
 * In a virtual device multi-screen environment in which the desktop
 * area could span multiple physical screen devices, the bounds of all
 * configurations are relative to the virtual device coordinate system.
 * The origin of the virtual-coordinate system is at the upper left-hand
 * corner of the primary physical screen.  Depending on the location of
 * the primary screen in the virtual device, negative coordinates are
 * possible, as shown in the following figure.
 * &lt;p&gt;
 * &lt;img src=&quot;doc-files/MultiScreen.gif&quot;
 * alt=&quot;Diagram shows virtual device containing 4 physical screens. Primary physical screen shows coords (0,0), other screen shows (-80,-100).&quot;
 * style=&quot;float:center; margin: 7px 10px;&quot;&gt;
 * &lt;p&gt;
 * In such an environment, when calling {@code setLocation},
 * you must pass a virtual coordinate to this method.  Similarly,
 * calling {@code getLocationOnScreen} on a {@code Window} returns
 * virtual device coordinates.  Call the {@code getBounds} method
 * of a {@code GraphicsConfiguration} to find its origin in the virtual
 * coordinate system.
 * &lt;p&gt;
 * The following code sets the location of a {@code Window}
 * at (10, 10) relative to the origin of the physical screen
 * of the corresponding {@code GraphicsConfiguration}.  If the
 * bounds of the {@code GraphicsConfiguration} is not taken
 * into account, the {@code Window} location would be set
 * at (10, 10) relative to the virtual-coordinate system and would appear
 * on the primary physical screen, which might be different from the
 * physical screen of the specified {@code GraphicsConfiguration}.
 *
 * &lt;pre&gt;
 *      Window w = new Window(Window owner, GraphicsConfiguration gc);
 *      Rectangle bounds = gc.getBounds();
 *      w.setLocation(10 + bounds.x, 10 + bounds.y);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Note: the location and size of top-level windows (including
 * {@code Window}s, {@code Frame}s, and {@code Dialog}s)
 * are under the control of the desktop's window management system.
 * Calls to {@code setLocation}, {@code setSize}, and
 * {@code setBounds} are requests (not directives) which are
 * forwarded to the window management system.  Every effort will be
 * made to honor such requests.  However, in some cases the window
 * management system may ignore such requests, or modify the requested
 * geometry in order to place and size the {@code Window} in a way
 * that more closely matches the desktop settings.
 * &lt;p&gt;
 * Due to the asynchronous nature of native event handling, the results
 * returned by {@code getBounds}, {@code getLocation},
 * {@code getLocationOnScreen}, and {@code getSize} might not
 * reflect the actual geometry of the Window on screen until the last
 * request has been processed.  During the processing of subsequent
 * requests these values might change accordingly while the window
 * management system fulfills the requests.
 * &lt;p&gt;
 * An application may set the size and location of an invisible
 * {@code Window} arbitrarily, but the window management system may
 * subsequently change its size and/or location when the
 * {@code Window} is made visible. One or more {@code ComponentEvent}s
 * will be generated to indicate the new geometry.
 * &lt;p&gt;
 * Windows are capable of generating the following WindowEvents:
 * WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus.
 *
 * @author      Sami Shaio
 * @author      Arthur van Hoff
 * @see WindowEvent
 * @see #addWindowListener
 * @see java.awt.BorderLayout
 * @since       JDK1.0
 */
public class Window extends Container implements Accessible {

    /**
     * Enumeration of available &lt;i&gt;window types&lt;/i&gt;.
     *
     * A window type defines the generic visual appearance and behavior of a
     * top-level window. For example, the type may affect the kind of
     * decorations of a decorated {@code Frame} or {@code Dialog} instance.
     * &lt;p&gt;
     * Some platforms may not fully support a certain window type. Depending on
     * the level of support, some properties of the window type may be
     * disobeyed.
     *
     * @see   #getType
     * @see   #setType
     * @since 1.7
     */
<span class="nc" id="L165">    public static enum Type {</span>
        /**
         * Represents a &lt;i&gt;normal&lt;/i&gt; window.
         *
         * This is the default type for objects of the {@code Window} class or
         * its descendants. Use this type for regular top-level windows.
         */
<span class="nc" id="L172">        NORMAL,</span>

        /**
         * Represents a &lt;i&gt;utility&lt;/i&gt; window.
         *
         * A utility window is usually a small window such as a toolbar or a
         * palette. The native system may render the window with smaller
         * title-bar if the window is either a {@code Frame} or a {@code
         * Dialog} object, and if it has its decorations enabled.
         */
<span class="nc" id="L182">        UTILITY,</span>

        /**
         * Represents a &lt;i&gt;popup&lt;/i&gt; window.
         *
         * A popup window is a temporary window such as a drop-down menu or a
         * tooltip. On some platforms, windows of that type may be forcibly
         * made undecorated even if they are instances of the {@code Frame} or
         * {@code Dialog} class, and have decorations enabled.
         */
<span class="nc" id="L192">        POPUP</span>
    }

    /**
     * This represents the warning message that is
     * to be displayed in a non secure window. ie :
     * a window that has a security manager installed that denies
     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
     * This message can be displayed anywhere in the window.
     *
     * @serial
     * @see #getWarningString
     */
    String      warningString;

    /**
     * {@code icons} is the graphical way we can
     * represent the frames and dialogs.
     * {@code Window} can't display icon but it's
     * being inherited by owned {@code Dialog}s.
     *
     * @serial
     * @see #getIconImages
     * @see #setIconImages(List&lt;? extends Image&gt;)
     */
    transient java.util.List&lt;Image&gt; icons;

    /**
     * Holds the reference to the component which last had focus in this window
     * before it lost focus.
     */
    private transient Component temporaryLostComponent;

<span class="fc" id="L225">    static boolean systemSyncLWRequests = false;</span>
<span class="nc" id="L226">    boolean     syncLWRequests = false;</span>
<span class="nc" id="L227">    transient boolean beforeFirstShow = true;</span>
<span class="nc" id="L228">    private transient boolean disposing = false;</span>
<span class="nc" id="L229">    transient WindowDisposerRecord disposerRecord = null;</span>

    static final int OPENED = 0x01;

    /**
     * An Integer value representing the Window State.
     *
     * @serial
     * @since 1.2
     * @see #show
     */
    int state;

    /**
     * A boolean value representing Window always-on-top state
     * @since 1.5
     * @serial
     * @see #setAlwaysOnTop
     * @see #isAlwaysOnTop
     */
    private boolean alwaysOnTop;

    /**
     * Contains all the windows that have a peer object associated,
     * i. e. between addNotify() and removeNotify() calls. The list
     * of all Window instances can be obtained from AppContext object.
     *
     * @since 1.6
     */
<span class="fc" id="L258">    private static final IdentityArrayList&lt;Window&gt; allWindows = new IdentityArrayList&lt;Window&gt;();</span>

    /**
     * A vector containing all the windows this
     * window currently owns.
     * @since 1.2
     * @see #getOwnedWindows
     */
<span class="nc" id="L266">    transient Vector&lt;WeakReference&lt;Window&gt;&gt; ownedWindowList =</span>
                                            new Vector&lt;WeakReference&lt;Window&gt;&gt;();

    /*
     * We insert a weak reference into the Vector of all Windows in AppContext
     * instead of 'this' so that garbage collection can still take place
     * correctly.
     */
    private transient WeakReference&lt;Window&gt; weakThis;

    transient boolean showWithParent;

    /**
     * Contains the modal dialog that blocks this window, or null
     * if the window is unblocked.
     *
     * @since 1.6
     */
    transient Dialog modalBlocker;

    /**
     * @serial
     *
     * @see java.awt.Dialog.ModalExclusionType
     * @see #getModalExclusionType
     * @see #setModalExclusionType
     *
     * @since 1.6
     */
    Dialog.ModalExclusionType modalExclusionType;

    transient WindowListener windowListener;
    transient WindowStateListener windowStateListener;
    transient WindowFocusListener windowFocusListener;

    transient InputContext inputContext;
<span class="nc" id="L302">    private transient Object inputContextLock = new Object();</span>

    /**
     * Unused. Maintained for serialization backward-compatibility.
     *
     * @serial
     * @since 1.2
     */
    private FocusManager focusMgr;

    /**
     * Indicates whether this Window can become the focused Window.
     *
     * @serial
     * @see #getFocusableWindowState
     * @see #setFocusableWindowState
     * @since 1.4
     */
<span class="nc" id="L320">    private boolean focusableWindowState = true;</span>

    /**
     * Indicates whether this window should receive focus on
     * subsequently being shown (with a call to {@code setVisible(true)}), or
     * being moved to the front (with a call to {@code toFront()}).
     *
     * @serial
     * @see #setAutoRequestFocus
     * @see #isAutoRequestFocus
     * @since 1.7
     */
<span class="nc" id="L332">    private volatile boolean autoRequestFocus = true;</span>

    /*
     * Indicates that this window is being shown. This flag is set to true at
     * the beginning of show() and to false at the end of show().
     *
     * @see #show()
     * @see Dialog#shouldBlock
     */
<span class="nc" id="L341">    transient boolean isInShow = false;</span>

    /**
     * The opacity level of the window
     *
     * @serial
     * @see #setOpacity(float)
     * @see #getOpacity()
     * @since 1.7
     */
<span class="nc" id="L351">    private float opacity = 1.0f;</span>

    /**
     * The shape assigned to this window. This field is set to {@code null} if
     * no shape is set (rectangular window).
     *
     * @serial
     * @see #getShape()
     * @see #setShape(Shape)
     * @since 1.7
     */
<span class="nc" id="L362">    private Shape shape = null;</span>

    private static final String base = &quot;win&quot;;
<span class="fc" id="L365">    private static int nameCounter = 0;</span>

    /*
     * JDK 1.1 serialVersionUID
     */
    private static final long serialVersionUID = 4497834738069338734L;

<span class="fc" id="L372">    private static final PlatformLogger log = PlatformLogger.getLogger(&quot;java.awt.Window&quot;);</span>

    private static final boolean locationByPlatformProp;

<span class="nc" id="L376">    transient boolean isTrayIconWindow = false;</span>

    /**
     * These fields are initialized in the native peer code
     * or via AWTAccessor's WindowAccessor.
     */
<span class="nc" id="L382">    private transient volatile int securityWarningWidth = 0;</span>
<span class="nc" id="L383">    private transient volatile int securityWarningHeight = 0;</span>

    /**
     * These fields represent the desired location for the security
     * warning if this window is untrusted.
     * See com.sun.awt.SecurityWarning for more details.
     */
<span class="nc" id="L390">    private transient double securityWarningPointX = 2.0;</span>
<span class="nc" id="L391">    private transient double securityWarningPointY = 0.0;</span>
<span class="nc" id="L392">    private transient float securityWarningAlignmentX = RIGHT_ALIGNMENT;</span>
<span class="nc" id="L393">    private transient float securityWarningAlignmentY = TOP_ALIGNMENT;</span>

    static {
        /* ensure that the necessary native libraries are loaded */
<span class="fc" id="L397">        Toolkit.loadLibraries();</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L399">            initIDs();</span>
        }

<span class="fc" id="L402">        String s = java.security.AccessController.doPrivileged(</span>
            new GetPropertyAction(&quot;java.awt.syncLWRequests&quot;));
<span class="pc bpc" id="L404" title="3 of 4 branches missed.">        systemSyncLWRequests = (s != null &amp;&amp; s.equals(&quot;true&quot;));</span>
<span class="fc" id="L405">        s = java.security.AccessController.doPrivileged(</span>
            new GetPropertyAction(&quot;java.awt.Window.locationByPlatform&quot;));
<span class="pc bpc" id="L407" title="3 of 4 branches missed.">        locationByPlatformProp = (s != null &amp;&amp; s.equals(&quot;true&quot;));</span>
    }

    /**
     * Initialize JNI field and method IDs for fields that may be
       accessed from C.
     */
    private static native void initIDs();

    /**
     * Constructs a new, initially invisible window in default size with the
     * specified {@code GraphicsConfiguration}.
     * &lt;p&gt;
     * If there is a security manager, then it is invoked to check
     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}
     * to determine whether or not the window must be displayed with
     * a warning banner.
     *
     * @param gc the {@code GraphicsConfiguration} of the target screen
     *     device. If {@code gc} is {@code null}, the system default
     *     {@code GraphicsConfiguration} is assumed
     * @exception IllegalArgumentException if {@code gc}
     *    is not from a screen device
     * @exception HeadlessException when
     *     {@code GraphicsEnvironment.isHeadless()} returns {@code true}
     *
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
<span class="nc" id="L435">    Window(GraphicsConfiguration gc) {</span>
<span class="nc" id="L436">        init(gc);</span>
<span class="nc" id="L437">    }</span>

<span class="nc" id="L439">    transient Object anchor = new Object();</span>
    static class WindowDisposerRecord implements sun.java2d.DisposerRecord {
        WeakReference&lt;Window&gt; owner;
        final WeakReference&lt;Window&gt; weakThis;
        final WeakReference&lt;AppContext&gt; context;

<span class="nc" id="L445">        WindowDisposerRecord(AppContext context, Window victim) {</span>
<span class="nc" id="L446">            weakThis = victim.weakThis;</span>
<span class="nc" id="L447">            this.context = new WeakReference&lt;AppContext&gt;(context);</span>
<span class="nc" id="L448">        }</span>

        public void updateOwner() {
<span class="nc" id="L451">            Window victim = weakThis.get();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            owner = (victim == null)</span>
                    ? null
<span class="nc" id="L454">                    : new WeakReference&lt;Window&gt;(victim.getOwner());</span>
<span class="nc" id="L455">        }</span>

        public void dispose() {
<span class="nc bnc" id="L458" title="All 2 branches missed.">            if (owner != null) {</span>
<span class="nc" id="L459">                Window parent = owner.get();</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L461">                    parent.removeOwnedWindow(weakThis);</span>
                }
            }
<span class="nc" id="L464">            AppContext ac = context.get();</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            if (null != ac) {</span>
<span class="nc" id="L466">                Window.removeFromWindowList(ac, weakThis);</span>
            }
<span class="nc" id="L468">        }</span>
    }

    private GraphicsConfiguration initGC(GraphicsConfiguration gc) {
<span class="nc" id="L472">        GraphicsEnvironment.checkHeadless();</span>

<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (gc == null) {</span>
<span class="nc" id="L475">            gc = GraphicsEnvironment.getLocalGraphicsEnvironment().</span>
<span class="nc" id="L476">                getDefaultScreenDevice().getDefaultConfiguration();</span>
        }
<span class="nc" id="L478">        setGraphicsConfiguration(gc);</span>

<span class="nc" id="L480">        return gc;</span>
    }

    private void init(GraphicsConfiguration gc) {
<span class="nc" id="L484">        GraphicsEnvironment.checkHeadless();</span>

<span class="nc" id="L486">        syncLWRequests = systemSyncLWRequests;</span>

<span class="nc" id="L488">        weakThis = new WeakReference&lt;Window&gt;(this);</span>
<span class="nc" id="L489">        addToWindowList();</span>

<span class="nc" id="L491">        setWarningString();</span>
<span class="nc" id="L492">        this.cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);</span>
<span class="nc" id="L493">        this.visible = false;</span>

<span class="nc" id="L495">        gc = initGC(gc);</span>

<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (gc.getDevice().getType() !=</span>
            GraphicsDevice.TYPE_RASTER_SCREEN) {
<span class="nc" id="L499">            throw new IllegalArgumentException(&quot;not a screen device&quot;);</span>
        }
<span class="nc" id="L501">        setLayout(new BorderLayout());</span>

        /* offset the initial location with the original of the screen */
        /* and any insets                                              */
<span class="nc" id="L505">        Rectangle screenBounds = gc.getBounds();</span>
<span class="nc" id="L506">        Insets screenInsets = getToolkit().getScreenInsets(gc);</span>
<span class="nc" id="L507">        int x = getX() + screenBounds.x + screenInsets.left;</span>
<span class="nc" id="L508">        int y = getY() + screenBounds.y + screenInsets.top;</span>
<span class="nc bnc" id="L509" title="All 4 branches missed.">        if (x != this.x || y != this.y) {</span>
<span class="nc" id="L510">            setLocation(x, y);</span>
            /* reset after setLocation */
<span class="nc" id="L512">            setLocationByPlatform(locationByPlatformProp);</span>
        }

<span class="nc" id="L515">        modalExclusionType = Dialog.ModalExclusionType.NO_EXCLUDE;</span>
<span class="nc" id="L516">        disposerRecord = new WindowDisposerRecord(appContext, this);</span>
<span class="nc" id="L517">        sun.java2d.Disposer.addRecord(anchor, disposerRecord);</span>

<span class="nc" id="L519">        SunToolkit.checkAndSetPolicy(this);</span>
<span class="nc" id="L520">    }</span>

    /**
     * Constructs a new, initially invisible window in the default size.
     * &lt;p&gt;
     * If there is a security manager set, it is invoked to check
     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
     * If that check fails with a {@code SecurityException} then a warning
     * banner is created.
     *
     * @exception HeadlessException when
     *     {@code GraphicsEnvironment.isHeadless()} returns {@code true}
     *
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
<span class="nc" id="L535">    Window() throws HeadlessException {</span>
<span class="nc" id="L536">        GraphicsEnvironment.checkHeadless();</span>
<span class="nc" id="L537">        init((GraphicsConfiguration)null);</span>
<span class="nc" id="L538">    }</span>

    /**
     * Constructs a new, initially invisible window with the specified
     * {@code Frame} as its owner. The window will not be focusable
     * unless its owner is showing on the screen.
     * &lt;p&gt;
     * If there is a security manager set, it is invoked to check
     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
     * If that check fails with a {@code SecurityException} then a warning
     * banner is created.
     *
     * @param owner the {@code Frame} to act as owner or {@code null}
     *    if this window has no owner
     * @exception IllegalArgumentException if the {@code owner}'s
     *    {@code GraphicsConfiguration} is not from a screen device
     * @exception HeadlessException when
     *    {@code GraphicsEnvironment.isHeadless} returns {@code true}
     *
     * @see java.awt.GraphicsEnvironment#isHeadless
     * @see #isShowing
     */
    public Window(Frame owner) {
<span class="nc bnc" id="L561" title="All 2 branches missed.">        this(owner == null ? (GraphicsConfiguration)null :</span>
<span class="nc" id="L562">            owner.getGraphicsConfiguration());</span>
<span class="nc" id="L563">        ownedInit(owner);</span>
<span class="nc" id="L564">    }</span>

    /**
     * Constructs a new, initially invisible window with the specified
     * {@code Window} as its owner. This window will not be focusable
     * unless its nearest owning {@code Frame} or {@code Dialog}
     * is showing on the screen.
     * &lt;p&gt;
     * If there is a security manager set, it is invoked to check
     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
     * If that check fails with a {@code SecurityException} then a
     * warning banner is created.
     *
     * @param owner the {@code Window} to act as owner or
     *     {@code null} if this window has no owner
     * @exception IllegalArgumentException if the {@code owner}'s
     *     {@code GraphicsConfiguration} is not from a screen device
     * @exception HeadlessException when
     *     {@code GraphicsEnvironment.isHeadless()} returns
     *     {@code true}
     *
     * @see       java.awt.GraphicsEnvironment#isHeadless
     * @see       #isShowing
     *
     * @since     1.2
     */
    public Window(Window owner) {
<span class="nc bnc" id="L591" title="All 2 branches missed.">        this(owner == null ? (GraphicsConfiguration)null :</span>
<span class="nc" id="L592">            owner.getGraphicsConfiguration());</span>
<span class="nc" id="L593">        ownedInit(owner);</span>
<span class="nc" id="L594">    }</span>

    /**
     * Constructs a new, initially invisible window with the specified owner
     * {@code Window} and a {@code GraphicsConfiguration}
     * of a screen device. The Window will not be focusable unless
     * its nearest owning {@code Frame} or {@code Dialog}
     * is showing on the screen.
     * &lt;p&gt;
     * If there is a security manager set, it is invoked to check
     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}. If that
     * check fails with a {@code SecurityException} then a warning banner
     * is created.
     *
     * @param owner the window to act as owner or {@code null}
     *     if this window has no owner
     * @param gc the {@code GraphicsConfiguration} of the target
     *     screen device; if {@code gc} is {@code null},
     *     the system default {@code GraphicsConfiguration} is assumed
     * @exception IllegalArgumentException if {@code gc}
     *     is not from a screen device
     * @exception HeadlessException when
     *     {@code GraphicsEnvironment.isHeadless()} returns
     *     {@code true}
     *
     * @see       java.awt.GraphicsEnvironment#isHeadless
     * @see       GraphicsConfiguration#getBounds
     * @see       #isShowing
     * @since     1.3
     */
    public Window(Window owner, GraphicsConfiguration gc) {
<span class="nc" id="L625">        this(gc);</span>
<span class="nc" id="L626">        ownedInit(owner);</span>
<span class="nc" id="L627">    }</span>

    private void ownedInit(Window owner) {
<span class="nc" id="L630">        this.parent = owner;</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">        if (owner != null) {</span>
<span class="nc" id="L632">            owner.addOwnedWindow(weakThis);</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">            if (owner.isAlwaysOnTop()) {</span>
                try {
<span class="nc" id="L635">                    setAlwaysOnTop(true);</span>
<span class="nc" id="L636">                } catch (SecurityException ignore) {</span>
<span class="nc" id="L637">                }</span>
            }
        }

        // WindowDisposerRecord requires a proper value of parent field.
<span class="nc" id="L642">        disposerRecord.updateOwner();</span>
<span class="nc" id="L643">    }</span>

    /**
     * Construct a name for this component.  Called by getName() when the
     * name is null.
     */
    String constructComponentName() {
<span class="nc" id="L650">        synchronized (Window.class) {</span>
<span class="nc" id="L651">            return base + nameCounter++;</span>
<span class="nc" id="L652">        }</span>
    }

    /**
     * Returns the sequence of images to be displayed as the icon for this window.
     * &lt;p&gt;
     * This method returns a copy of the internally stored list, so all operations
     * on the returned object will not affect the window's behavior.
     *
     * @return    the copy of icon images' list for this window, or
     *            empty list if this window doesn't have icon images.
     * @see       #setIconImages
     * @see       #setIconImage(Image)
     * @since     1.6
     */
    public java.util.List&lt;Image&gt; getIconImages() {
<span class="nc" id="L668">        java.util.List&lt;Image&gt; icons = this.icons;</span>
<span class="nc bnc" id="L669" title="All 4 branches missed.">        if (icons == null || icons.size() == 0) {</span>
<span class="nc" id="L670">            return new ArrayList&lt;Image&gt;();</span>
        }
<span class="nc" id="L672">        return new ArrayList&lt;Image&gt;(icons);</span>
    }

    /**
     * Sets the sequence of images to be displayed as the icon
     * for this window. Subsequent calls to {@code getIconImages} will
     * always return a copy of the {@code icons} list.
     * &lt;p&gt;
     * Depending on the platform capabilities one or several images
     * of different dimensions will be used as the window's icon.
     * &lt;p&gt;
     * The {@code icons} list is scanned for the images of most
     * appropriate dimensions from the beginning. If the list contains
     * several images of the same size, the first will be used.
     * &lt;p&gt;
     * Ownerless windows with no icon specified use platfrom-default icon.
     * The icon of an owned window may be inherited from the owner
     * unless explicitly overridden.
     * Setting the icon to {@code null} or empty list restores
     * the default behavior.
     * &lt;p&gt;
     * Note : Native windowing systems may use different images of differing
     * dimensions to represent a window, depending on the context (e.g.
     * window decoration, window list, taskbar, etc.). They could also use
     * just a single image for all contexts or no image at all.
     *
     * @param     icons the list of icon images to be displayed.
     * @see       #getIconImages()
     * @see       #setIconImage(Image)
     * @since     1.6
     */
    public synchronized void setIconImages(java.util.List&lt;? extends Image&gt; icons) {
<span class="nc bnc" id="L704" title="All 2 branches missed.">        this.icons = (icons == null) ? new ArrayList&lt;Image&gt;() :</span>
            new ArrayList&lt;Image&gt;(icons);
<span class="nc" id="L706">        WindowPeer peer = (WindowPeer)this.peer;</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L708">            peer.updateIconImages();</span>
        }
        // Always send a property change event
<span class="nc" id="L711">        firePropertyChange(&quot;iconImage&quot;, null, null);</span>
<span class="nc" id="L712">    }</span>

    /**
     * Sets the image to be displayed as the icon for this window.
     * &lt;p&gt;
     * This method can be used instead of {@link #setIconImages setIconImages()}
     * to specify a single image as a window's icon.
     * &lt;p&gt;
     * The following statement:
     * &lt;pre&gt;
     *     setIconImage(image);
     * &lt;/pre&gt;
     * is equivalent to:
     * &lt;pre&gt;
     *     ArrayList&amp;lt;Image&amp;gt; imageList = new ArrayList&amp;lt;Image&amp;gt;();
     *     imageList.add(image);
     *     setIconImages(imageList);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Note : Native windowing systems may use different images of differing
     * dimensions to represent a window, depending on the context (e.g.
     * window decoration, window list, taskbar, etc.). They could also use
     * just a single image for all contexts or no image at all.
     *
     * @param     image the icon image to be displayed.
     * @see       #setIconImages
     * @see       #getIconImages()
     * @since     1.6
     */
    public void setIconImage(Image image) {
<span class="nc" id="L742">        ArrayList&lt;Image&gt; imageList = new ArrayList&lt;Image&gt;();</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (image != null) {</span>
<span class="nc" id="L744">            imageList.add(image);</span>
        }
<span class="nc" id="L746">        setIconImages(imageList);</span>
<span class="nc" id="L747">    }</span>

    /**
     * Makes this Window displayable by creating the connection to its
     * native screen resource.
     * This method is called internally by the toolkit and should
     * not be called directly by programs.
     * @see Component#isDisplayable
     * @see Container#removeNotify
     * @since JDK1.0
     */
    public void addNotify() {
<span class="nc" id="L759">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L760">            Container parent = this.parent;</span>
<span class="nc bnc" id="L761" title="All 4 branches missed.">            if (parent != null &amp;&amp; parent.getPeer() == null) {</span>
<span class="nc" id="L762">                parent.addNotify();</span>
            }
<span class="nc bnc" id="L764" title="All 2 branches missed.">            if (peer == null) {</span>
<span class="nc" id="L765">                peer = getToolkit().createWindow(this);</span>
            }
<span class="nc" id="L767">            synchronized (allWindows) {</span>
<span class="nc" id="L768">                allWindows.add(this);</span>
<span class="nc" id="L769">            }</span>
<span class="nc" id="L770">            super.addNotify();</span>
<span class="nc" id="L771">        }</span>
<span class="nc" id="L772">    }</span>

    /**
     * {@inheritDoc}
     */
    public void removeNotify() {
<span class="nc" id="L778">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L779">            synchronized (allWindows) {</span>
<span class="nc" id="L780">                allWindows.remove(this);</span>
<span class="nc" id="L781">            }</span>
<span class="nc" id="L782">            super.removeNotify();</span>
<span class="nc" id="L783">        }</span>
<span class="nc" id="L784">    }</span>

    /**
     * Causes this Window to be sized to fit the preferred size
     * and layouts of its subcomponents. The resulting width and
     * height of the window are automatically enlarged if either
     * of dimensions is less than the minimum size as specified
     * by the previous call to the {@code setMinimumSize} method.
     * &lt;p&gt;
     * If the window and/or its owner are not displayable yet,
     * both of them are made displayable before calculating
     * the preferred size. The Window is validated after its
     * size is being calculated.
     *
     * @see Component#isDisplayable
     * @see #setMinimumSize
     */
    public void pack() {
<span class="nc" id="L802">        Container parent = this.parent;</span>
<span class="nc bnc" id="L803" title="All 4 branches missed.">        if (parent != null &amp;&amp; parent.getPeer() == null) {</span>
<span class="nc" id="L804">            parent.addNotify();</span>
        }
<span class="nc bnc" id="L806" title="All 2 branches missed.">        if (peer == null) {</span>
<span class="nc" id="L807">            addNotify();</span>
        }
<span class="nc" id="L809">        Dimension newSize = getPreferredSize();</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L811">            setClientSize(newSize.width, newSize.height);</span>
        }

<span class="nc bnc" id="L814" title="All 2 branches missed.">        if(beforeFirstShow) {</span>
<span class="nc" id="L815">            isPacked = true;</span>
        }

<span class="nc" id="L818">        validateUnconditionally();</span>
<span class="nc" id="L819">    }</span>

    /**
     * Sets the minimum size of this window to a constant
     * value.  Subsequent calls to {@code getMinimumSize}
     * will always return this value. If current window's
     * size is less than {@code minimumSize} the size of the
     * window is automatically enlarged to honor the minimum size.
     * &lt;p&gt;
     * If the {@code setSize} or {@code setBounds} methods
     * are called afterwards with a width or height less than
     * that was specified by the {@code setMinimumSize} method
     * the window is automatically enlarged to meet
     * the {@code minimumSize} value. The {@code minimumSize}
     * value also affects the behaviour of the {@code pack} method.
     * &lt;p&gt;
     * The default behavior is restored by setting the minimum size
     * parameter to the {@code null} value.
     * &lt;p&gt;
     * Resizing operation may be restricted if the user tries
     * to resize window below the {@code minimumSize} value.
     * This behaviour is platform-dependent.
     *
     * @param minimumSize the new minimum size of this window
     * @see Component#setMinimumSize
     * @see #getMinimumSize
     * @see #isMinimumSizeSet
     * @see #setSize(Dimension)
     * @see #pack
     * @since 1.6
     */
    public void setMinimumSize(Dimension minimumSize) {
<span class="nc" id="L851">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L852">            super.setMinimumSize(minimumSize);</span>
<span class="nc" id="L853">            Dimension size = getSize();</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">            if (isMinimumSizeSet()) {</span>
<span class="nc bnc" id="L855" title="All 4 branches missed.">                if (size.width &lt; minimumSize.width || size.height &lt; minimumSize.height) {</span>
<span class="nc" id="L856">                    int nw = Math.max(width, minimumSize.width);</span>
<span class="nc" id="L857">                    int nh = Math.max(height, minimumSize.height);</span>
<span class="nc" id="L858">                    setSize(nw, nh);</span>
                }
            }
<span class="nc bnc" id="L861" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L862">                ((WindowPeer)peer).updateMinimumSize();</span>
            }
<span class="nc" id="L864">        }</span>
<span class="nc" id="L865">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * The {@code d.width} and {@code d.height} values
     * are automatically enlarged if either is less than
     * the minimum size as specified by previous call to
     * {@code setMinimumSize}.
     * &lt;p&gt;
     * The method changes the geometry-related data. Therefore,
     * the native windowing system may ignore such requests, or it may modify
     * the requested data, so that the {@code Window} object is placed and sized
     * in a way that corresponds closely to the desktop settings.
     *
     * @see #getSize
     * @see #setBounds
     * @see #setMinimumSize
     * @since 1.6
     */
    public void setSize(Dimension d) {
<span class="nc" id="L886">        super.setSize(d);</span>
<span class="nc" id="L887">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * The {@code width} and {@code height} values
     * are automatically enlarged if either is less than
     * the minimum size as specified by previous call to
     * {@code setMinimumSize}.
     * &lt;p&gt;
     * The method changes the geometry-related data. Therefore,
     * the native windowing system may ignore such requests, or it may modify
     * the requested data, so that the {@code Window} object is placed and sized
     * in a way that corresponds closely to the desktop settings.
     *
     * @see #getSize
     * @see #setBounds
     * @see #setMinimumSize
     * @since 1.6
     */
    public void setSize(int width, int height) {
<span class="nc" id="L908">        super.setSize(width, height);</span>
<span class="nc" id="L909">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * The method changes the geometry-related data. Therefore,
     * the native windowing system may ignore such requests, or it may modify
     * the requested data, so that the {@code Window} object is placed and sized
     * in a way that corresponds closely to the desktop settings.
     */
    @Override
    public void setLocation(int x, int y) {
<span class="nc" id="L921">        super.setLocation(x, y);</span>
<span class="nc" id="L922">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * The method changes the geometry-related data. Therefore,
     * the native windowing system may ignore such requests, or it may modify
     * the requested data, so that the {@code Window} object is placed and sized
     * in a way that corresponds closely to the desktop settings.
     */
    @Override
    public void setLocation(Point p) {
<span class="nc" id="L934">        super.setLocation(p);</span>
<span class="nc" id="L935">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by {@code setBounds(int, int, int, int)}.
     */
    @Deprecated
    public void reshape(int x, int y, int width, int height) {
<span class="nc bnc" id="L943" title="All 2 branches missed.">        if (isMinimumSizeSet()) {</span>
<span class="nc" id="L944">            Dimension minSize = getMinimumSize();</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">            if (width &lt; minSize.width) {</span>
<span class="nc" id="L946">                width = minSize.width;</span>
            }
<span class="nc bnc" id="L948" title="All 2 branches missed.">            if (height &lt; minSize.height) {</span>
<span class="nc" id="L949">                height = minSize.height;</span>
            }
        }
<span class="nc" id="L952">        super.reshape(x, y, width, height);</span>
<span class="nc" id="L953">    }</span>

    void setClientSize(int w, int h) {
<span class="nc" id="L956">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L957">            setBoundsOp(ComponentPeer.SET_CLIENT_SIZE);</span>
<span class="nc" id="L958">            setBounds(x, y, w, h);</span>
<span class="nc" id="L959">        }</span>
<span class="nc" id="L960">    }</span>

    static private final AtomicBoolean
<span class="fc" id="L963">        beforeFirstWindowShown = new AtomicBoolean(true);</span>

    final void closeSplashScreen() {
<span class="nc bnc" id="L966" title="All 2 branches missed.">        if (isTrayIconWindow) {</span>
<span class="nc" id="L967">            return;</span>
        }
<span class="nc bnc" id="L969" title="All 2 branches missed.">        if (beforeFirstWindowShown.getAndSet(false)) {</span>
            // We don't use SplashScreen.getSplashScreen() to avoid instantiating
            // the object if it hasn't been requested by user code explicitly
<span class="nc" id="L972">            SunToolkit.closeSplashScreen();</span>
<span class="nc" id="L973">            SplashScreen.markClosed();</span>
        }
<span class="nc" id="L975">    }</span>

    /**
     * Shows or hides this {@code Window} depending on the value of parameter
     * {@code b}.
     * &lt;p&gt;
     * If the method shows the window then the window is also made
     * focused under the following conditions:
     * &lt;ul&gt;
     * &lt;li&gt; The {@code Window} meets the requirements outlined in the
     *      {@link #isFocusableWindow} method.
     * &lt;li&gt; The {@code Window}'s {@code autoRequestFocus} property is of the {@code true} value.
     * &lt;li&gt; Native windowing system allows the {@code Window} to get focused.
     * &lt;/ul&gt;
     * There is an exception for the second condition (the value of the
     * {@code autoRequestFocus} property). The property is not taken into account if the
     * window is a modal dialog, which blocks the currently focused window.
     * &lt;p&gt;
     * Developers must never assume that the window is the focused or active window
     * until it receives a WINDOW_GAINED_FOCUS or WINDOW_ACTIVATED event.
     * @param b  if {@code true}, makes the {@code Window} visible,
     * otherwise hides the {@code Window}.
     * If the {@code Window} and/or its owner
     * are not yet displayable, both are made displayable.  The
     * {@code Window} will be validated prior to being made visible.
     * If the {@code Window} is already visible, this will bring the
     * {@code Window} to the front.&lt;p&gt;
     * If {@code false}, hides this {@code Window}, its subcomponents, and all
     * of its owned children.
     * The {@code Window} and its subcomponents can be made visible again
     * with a call to {@code #setVisible(true)}.
     * @see java.awt.Component#isDisplayable
     * @see java.awt.Component#setVisible
     * @see java.awt.Window#toFront
     * @see java.awt.Window#dispose
     * @see java.awt.Window#setAutoRequestFocus
     * @see java.awt.Window#isFocusableWindow
     */
    public void setVisible(boolean b) {
<span class="nc" id="L1014">        super.setVisible(b);</span>
<span class="nc" id="L1015">    }</span>

    /**
     * Makes the Window visible. If the Window and/or its owner
     * are not yet displayable, both are made displayable.  The
     * Window will be validated prior to being made visible.
     * If the Window is already visible, this will bring the Window
     * to the front.
     * @see       Component#isDisplayable
     * @see       #toFront
     * @deprecated As of JDK version 1.5, replaced by
     * {@link #setVisible(boolean)}.
     */
    @Deprecated
    public void show() {
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (peer == null) {</span>
<span class="nc" id="L1031">            addNotify();</span>
        }
<span class="nc" id="L1033">        validateUnconditionally();</span>

<span class="nc" id="L1035">        isInShow = true;</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L1037">            toFront();</span>
        } else {
<span class="nc" id="L1039">            beforeFirstShow = false;</span>
<span class="nc" id="L1040">            closeSplashScreen();</span>
<span class="nc" id="L1041">            Dialog.checkShouldBeBlocked(this);</span>
<span class="nc" id="L1042">            super.show();</span>
<span class="nc" id="L1043">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L1044">                this.locationByPlatform = false;</span>
<span class="nc" id="L1045">            }</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            for (int i = 0; i &lt; ownedWindowList.size(); i++) {</span>
<span class="nc" id="L1047">                Window child = ownedWindowList.elementAt(i).get();</span>
<span class="nc bnc" id="L1048" title="All 4 branches missed.">                if ((child != null) &amp;&amp; child.showWithParent) {</span>
<span class="nc" id="L1049">                    child.show();</span>
<span class="nc" id="L1050">                    child.showWithParent = false;</span>
                }       // endif
            }   // endfor
<span class="nc bnc" id="L1053" title="All 2 branches missed.">            if (!isModalBlocked()) {</span>
<span class="nc" id="L1054">                updateChildrenBlocking();</span>
            } else {
                // fix for 6532736: after this window is shown, its blocker
                // should be raised to front
<span class="nc" id="L1058">                modalBlocker.toFront_NoClientCode();</span>
            }
<span class="nc bnc" id="L1060" title="All 4 branches missed.">            if (this instanceof Frame || this instanceof Dialog) {</span>
<span class="nc" id="L1061">                updateChildFocusableWindowState(this);</span>
            }
        }
<span class="nc" id="L1064">        isInShow = false;</span>

        // If first time shown, generate WindowOpened event
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        if ((state &amp; OPENED) == 0) {</span>
<span class="nc" id="L1068">            postWindowEvent(WindowEvent.WINDOW_OPENED);</span>
<span class="nc" id="L1069">            state |= OPENED;</span>
        }
<span class="nc" id="L1071">    }</span>

    static void updateChildFocusableWindowState(Window w) {
<span class="nc bnc" id="L1074" title="All 4 branches missed.">        if (w.getPeer() != null &amp;&amp; w.isShowing()) {</span>
<span class="nc" id="L1075">            ((WindowPeer)w.getPeer()).updateFocusableWindowState();</span>
        }
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        for (int i = 0; i &lt; w.ownedWindowList.size(); i++) {</span>
<span class="nc" id="L1078">            Window child = w.ownedWindowList.elementAt(i).get();</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">            if (child != null) {</span>
<span class="nc" id="L1080">                updateChildFocusableWindowState(child);</span>
            }
        }
<span class="nc" id="L1083">    }</span>

    synchronized void postWindowEvent(int id) {
<span class="nc bnc" id="L1086" title="All 4 branches missed.">        if (windowListener != null</span>
            || (eventMask &amp; AWTEvent.WINDOW_EVENT_MASK) != 0
<span class="nc bnc" id="L1088" title="All 2 branches missed.">            ||  Toolkit.enabledOnToolkit(AWTEvent.WINDOW_EVENT_MASK)) {</span>
<span class="nc" id="L1089">            WindowEvent e = new WindowEvent(this, id);</span>
<span class="nc" id="L1090">            Toolkit.getEventQueue().postEvent(e);</span>
        }
<span class="nc" id="L1092">    }</span>

    /**
     * Hide this Window, its subcomponents, and all of its owned children.
     * The Window and its subcomponents can be made visible again
     * with a call to {@code show}.
     * @see #show
     * @see #dispose
     * @deprecated As of JDK version 1.5, replaced by
     * {@link #setVisible(boolean)}.
     */
    @Deprecated
    public void hide() {
<span class="nc" id="L1105">        synchronized(ownedWindowList) {</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            for (int i = 0; i &lt; ownedWindowList.size(); i++) {</span>
<span class="nc" id="L1107">                Window child = ownedWindowList.elementAt(i).get();</span>
<span class="nc bnc" id="L1108" title="All 4 branches missed.">                if ((child != null) &amp;&amp; child.visible) {</span>
<span class="nc" id="L1109">                    child.hide();</span>
<span class="nc" id="L1110">                    child.showWithParent = true;</span>
                }
            }
<span class="nc" id="L1113">        }</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">        if (isModalBlocked()) {</span>
<span class="nc" id="L1115">            modalBlocker.unblockWindow(this);</span>
        }
<span class="nc" id="L1117">        super.hide();</span>
<span class="nc" id="L1118">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L1119">            this.locationByPlatform = false;</span>
<span class="nc" id="L1120">        }</span>
<span class="nc" id="L1121">    }</span>

    final void clearMostRecentFocusOwnerOnHide() {
        /* do nothing */
<span class="nc" id="L1125">    }</span>

    /**
     * Releases all of the native screen resources used by this
     * {@code Window}, its subcomponents, and all of its owned
     * children. That is, the resources for these {@code Component}s
     * will be destroyed, any memory they consume will be returned to the
     * OS, and they will be marked as undisplayable.
     * &lt;p&gt;
     * The {@code Window} and its subcomponents can be made displayable
     * again by rebuilding the native resources with a subsequent call to
     * {@code pack} or {@code show}. The states of the recreated
     * {@code Window} and its subcomponents will be identical to the
     * states of these objects at the point where the {@code Window}
     * was disposed (not accounting for additional modifications between
     * those actions).
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: When the last displayable window
     * within the Java virtual machine (VM) is disposed of, the VM may
     * terminate.  See &lt;a href=&quot;doc-files/AWTThreadIssues.html#Autoshutdown&quot;&gt;
     * AWT Threading Issues&lt;/a&gt; for more information.
     * @see Component#isDisplayable
     * @see #pack
     * @see #show
     */
    public void dispose() {
<span class="nc" id="L1151">        doDispose();</span>
<span class="nc" id="L1152">    }</span>

    /*
     * Fix for 4872170.
     * If dispose() is called on parent then its children have to be disposed as well
     * as reported in javadoc. So we need to implement this functionality even if a
     * child overrides dispose() in a wrong way without calling super.dispose().
     */
    void disposeImpl() {
<span class="nc" id="L1161">        dispose();</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">        if (getPeer() != null) {</span>
<span class="nc" id="L1163">            doDispose();</span>
        }
<span class="nc" id="L1165">    }</span>

    void doDispose() {
<span class="nc" id="L1168">    class DisposeAction implements Runnable {</span>
        public void run() {
<span class="nc" id="L1170">            disposing = true;</span>
            try {
                // Check if this window is the fullscreen window for the
                // device. Exit the fullscreen mode prior to disposing
                // of the window if that's the case.
<span class="nc" id="L1175">                GraphicsDevice gd = getGraphicsConfiguration().getDevice();</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">                if (gd.getFullScreenWindow() == Window.this) {</span>
<span class="nc" id="L1177">                    gd.setFullScreenWindow(null);</span>
                }

                Object[] ownedWindowArray;
<span class="nc" id="L1181">                synchronized(ownedWindowList) {</span>
<span class="nc" id="L1182">                    ownedWindowArray = new Object[ownedWindowList.size()];</span>
<span class="nc" id="L1183">                    ownedWindowList.copyInto(ownedWindowArray);</span>
<span class="nc" id="L1184">                }</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">                for (int i = 0; i &lt; ownedWindowArray.length; i++) {</span>
<span class="nc" id="L1186">                    Window child = (Window) (((WeakReference)</span>
<span class="nc" id="L1187">                                   (ownedWindowArray[i])).get());</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">                    if (child != null) {</span>
<span class="nc" id="L1189">                        child.disposeImpl();</span>
                    }
                }
<span class="nc" id="L1192">                hide();</span>
<span class="nc" id="L1193">                beforeFirstShow = true;</span>
<span class="nc" id="L1194">                removeNotify();</span>
<span class="nc" id="L1195">                synchronized (inputContextLock) {</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">                    if (inputContext != null) {</span>
<span class="nc" id="L1197">                        inputContext.dispose();</span>
<span class="nc" id="L1198">                        inputContext = null;</span>
                    }
<span class="nc" id="L1200">                }</span>
<span class="nc" id="L1201">                clearCurrentFocusCycleRootOnHide();</span>
            } finally {
<span class="nc" id="L1203">                disposing = false;</span>
<span class="nc" id="L1204">            }</span>
<span class="nc" id="L1205">        }</span>
    }
<span class="nc" id="L1207">        boolean fireWindowClosedEvent = isDisplayable();</span>
<span class="nc" id="L1208">        DisposeAction action = new DisposeAction();</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">        if (EventQueue.isDispatchThread()) {</span>
<span class="nc" id="L1210">            action.run();</span>
        }
        else {
            try {
<span class="nc" id="L1214">                EventQueue.invokeAndWait(this, action);</span>
            }
<span class="nc" id="L1216">            catch (InterruptedException e) {</span>
<span class="nc" id="L1217">                System.err.println(&quot;Disposal was interrupted:&quot;);</span>
<span class="nc" id="L1218">                e.printStackTrace();</span>
            }
<span class="nc" id="L1220">            catch (InvocationTargetException e) {</span>
<span class="nc" id="L1221">                System.err.println(&quot;Exception during disposal:&quot;);</span>
<span class="nc" id="L1222">                e.printStackTrace();</span>
<span class="nc" id="L1223">            }</span>
        }
        // Execute outside the Runnable because postWindowEvent is
        // synchronized on (this). We don't need to synchronize the call
        // on the EventQueue anyways.
<span class="nc bnc" id="L1228" title="All 2 branches missed.">        if (fireWindowClosedEvent) {</span>
<span class="nc" id="L1229">            postWindowEvent(WindowEvent.WINDOW_CLOSED);</span>
        }
<span class="nc" id="L1231">    }</span>

    /*
     * Should only be called while holding the tree lock.
     * It's overridden here because parent == owner in Window,
     * and we shouldn't adjust counter on owner
     */
    void adjustListeningChildrenOnParent(long mask, int num) {
<span class="nc" id="L1239">    }</span>

    // Should only be called while holding tree lock
    void adjustDecendantsOnParent(int num) {
        // do nothing since parent == owner and we shouldn't
        // ajust counter on owner
<span class="nc" id="L1245">    }</span>

    /**
     * If this Window is visible, brings this Window to the front and may make
     * it the focused Window.
     * &lt;p&gt;
     * Places this Window at the top of the stacking order and shows it in
     * front of any other Windows in this VM. No action will take place if this
     * Window is not visible. Some platforms do not allow Windows which own
     * other Windows to appear on top of those owned Windows. Some platforms
     * may not permit this VM to place its Windows above windows of native
     * applications, or Windows of other VMs. This permission may depend on
     * whether a Window in this VM is already focused. Every attempt will be
     * made to move this Window as high as possible in the stacking order;
     * however, developers should not assume that this method will move this
     * Window above all other windows in every situation.
     * &lt;p&gt;
     * Developers must never assume that this Window is the focused or active
     * Window until this Window receives a WINDOW_GAINED_FOCUS or WINDOW_ACTIVATED
     * event. On platforms where the top-most window is the focused window, this
     * method will &lt;b&gt;probably&lt;/b&gt; focus this Window (if it is not already focused)
     * under the following conditions:
     * &lt;ul&gt;
     * &lt;li&gt; The window meets the requirements outlined in the
     *      {@link #isFocusableWindow} method.
     * &lt;li&gt; The window's property {@code autoRequestFocus} is of the
     *      {@code true} value.
     * &lt;li&gt; Native windowing system allows the window to get focused.
     * &lt;/ul&gt;
     * On platforms where the stacking order does not typically affect the focused
     * window, this method will &lt;b&gt;probably&lt;/b&gt; leave the focused and active
     * Windows unchanged.
     * &lt;p&gt;
     * If this method causes this Window to be focused, and this Window is a
     * Frame or a Dialog, it will also become activated. If this Window is
     * focused, but it is not a Frame or a Dialog, then the first Frame or
     * Dialog that is an owner of this Window will be activated.
     * &lt;p&gt;
     * If this window is blocked by modal dialog, then the blocking dialog
     * is brought to the front and remains above the blocked window.
     *
     * @see       #toBack
     * @see       #setAutoRequestFocus
     * @see       #isFocusableWindow
     */
    public void toFront() {
<span class="nc" id="L1291">        toFront_NoClientCode();</span>
<span class="nc" id="L1292">    }</span>

    // This functionality is implemented in a final package-private method
    // to insure that it cannot be overridden by client subclasses.
    final void toFront_NoClientCode() {
<span class="nc bnc" id="L1297" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L1298">            WindowPeer peer = (WindowPeer)this.peer;</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L1300">                peer.toFront();</span>
            }
<span class="nc bnc" id="L1302" title="All 2 branches missed.">            if (isModalBlocked()) {</span>
<span class="nc" id="L1303">                modalBlocker.toFront_NoClientCode();</span>
            }
        }
<span class="nc" id="L1306">    }</span>

    /**
     * If this Window is visible, sends this Window to the back and may cause
     * it to lose focus or activation if it is the focused or active Window.
     * &lt;p&gt;
     * Places this Window at the bottom of the stacking order and shows it
     * behind any other Windows in this VM. No action will take place is this
     * Window is not visible. Some platforms do not allow Windows which are
     * owned by other Windows to appear below their owners. Every attempt will
     * be made to move this Window as low as possible in the stacking order;
     * however, developers should not assume that this method will move this
     * Window below all other windows in every situation.
     * &lt;p&gt;
     * Because of variations in native windowing systems, no guarantees about
     * changes to the focused and active Windows can be made. Developers must
     * never assume that this Window is no longer the focused or active Window
     * until this Window receives a WINDOW_LOST_FOCUS or WINDOW_DEACTIVATED
     * event. On platforms where the top-most window is the focused window,
     * this method will &lt;b&gt;probably&lt;/b&gt; cause this Window to lose focus. In
     * that case, the next highest, focusable Window in this VM will receive
     * focus. On platforms where the stacking order does not typically affect
     * the focused window, this method will &lt;b&gt;probably&lt;/b&gt; leave the focused
     * and active Windows unchanged.
     *
     * @see       #toFront
     */
    public void toBack() {
<span class="nc" id="L1334">        toBack_NoClientCode();</span>
<span class="nc" id="L1335">    }</span>

    // This functionality is implemented in a final package-private method
    // to insure that it cannot be overridden by client subclasses.
    final void toBack_NoClientCode() {
<span class="nc bnc" id="L1340" title="All 2 branches missed.">        if(isAlwaysOnTop()) {</span>
            try {
<span class="nc" id="L1342">                setAlwaysOnTop(false);</span>
<span class="nc" id="L1343">            }catch(SecurityException e) {</span>
<span class="nc" id="L1344">            }</span>
        }
<span class="nc bnc" id="L1346" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L1347">            WindowPeer peer = (WindowPeer)this.peer;</span>
<span class="nc bnc" id="L1348" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L1349">                peer.toBack();</span>
            }
        }
<span class="nc" id="L1352">    }</span>

    /**
     * Returns the toolkit of this frame.
     * @return    the toolkit of this window.
     * @see       Toolkit
     * @see       Toolkit#getDefaultToolkit
     * @see       Component#getToolkit
     */
    public Toolkit getToolkit() {
<span class="nc" id="L1362">        return Toolkit.getDefaultToolkit();</span>
    }

    /**
     * Gets the warning string that is displayed with this window.
     * If this window is insecure, the warning string is displayed
     * somewhere in the visible area of the window. A window is
     * insecure if there is a security manager and the security
     * manager denies
     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
     * &lt;p&gt;
     * If the window is secure, then {@code getWarningString}
     * returns {@code null}. If the window is insecure, this
     * method checks for the system property
     * {@code awt.appletWarning}
     * and returns the string value of that property.
     * @return    the warning string for this window.
     */
    public final String getWarningString() {
<span class="nc" id="L1381">        return warningString;</span>
    }

    private void setWarningString() {
<span class="nc" id="L1385">        warningString = null;</span>
<span class="nc" id="L1386">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">        if (sm != null) {</span>
            try {
<span class="nc" id="L1389">                sm.checkPermission(SecurityConstants.AWT.TOPLEVEL_WINDOW_PERMISSION);</span>
<span class="nc" id="L1390">            } catch (SecurityException se) {</span>
                // make sure the privileged action is only
                // for getting the property! We don't want the
                // above checkPermission call to always succeed!
<span class="nc" id="L1394">                warningString = AccessController.doPrivileged(</span>
                      new GetPropertyAction(&quot;awt.appletWarning&quot;,
                                            &quot;Java Applet Window&quot;));
<span class="nc" id="L1397">            }</span>
        }
<span class="nc" id="L1399">    }</span>

    /**
     * Gets the {@code Locale} object that is associated
     * with this window, if the locale has been set.
     * If no locale has been set, then the default locale
     * is returned.
     * @return    the locale that is set for this window.
     * @see       java.util.Locale
     * @since     JDK1.1
     */
    public Locale getLocale() {
<span class="nc bnc" id="L1411" title="All 2 branches missed.">      if (this.locale == null) {</span>
<span class="nc" id="L1412">        return Locale.getDefault();</span>
      }
<span class="nc" id="L1414">      return this.locale;</span>
    }

    /**
     * Gets the input context for this window. A window always has an input context,
     * which is shared by subcomponents unless they create and set their own.
     * @see Component#getInputContext
     * @since 1.2
     */
    public InputContext getInputContext() {
<span class="nc" id="L1424">        synchronized (inputContextLock) {</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">            if (inputContext == null) {</span>
<span class="nc" id="L1426">                inputContext = InputContext.getInstance();</span>
            }
<span class="nc" id="L1428">        }</span>
<span class="nc" id="L1429">        return inputContext;</span>
    }

    /**
     * Set the cursor image to a specified cursor.
     * &lt;p&gt;
     * The method may have no visual effect if the Java platform
     * implementation and/or the native system do not support
     * changing the mouse cursor shape.
     * @param     cursor One of the constants defined
     *            by the {@code Cursor} class. If this parameter is null
     *            then the cursor for this window will be set to the type
     *            Cursor.DEFAULT_CURSOR.
     * @see       Component#getCursor
     * @see       Cursor
     * @since     JDK1.1
     */
    public void setCursor(Cursor cursor) {
<span class="nc bnc" id="L1447" title="All 2 branches missed.">        if (cursor == null) {</span>
<span class="nc" id="L1448">            cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);</span>
        }
<span class="nc" id="L1450">        super.setCursor(cursor);</span>
<span class="nc" id="L1451">    }</span>

    /**
     * Returns the owner of this window.
     * @since 1.2
     */
    public Window getOwner() {
<span class="nc" id="L1458">        return getOwner_NoClientCode();</span>
    }
    final Window getOwner_NoClientCode() {
<span class="nc" id="L1461">        return (Window)parent;</span>
    }

    /**
     * Return an array containing all the windows this
     * window currently owns.
     * @since 1.2
     */
    public Window[] getOwnedWindows() {
<span class="nc" id="L1470">        return getOwnedWindows_NoClientCode();</span>
    }
    final Window[] getOwnedWindows_NoClientCode() {
        Window realCopy[];

<span class="nc" id="L1475">        synchronized(ownedWindowList) {</span>
            // Recall that ownedWindowList is actually a Vector of
            // WeakReferences and calling get() on one of these references
            // may return null. Make two arrays-- one the size of the
            // Vector (fullCopy with size fullSize), and one the size of
            // all non-null get()s (realCopy with size realSize).
<span class="nc" id="L1481">            int fullSize = ownedWindowList.size();</span>
<span class="nc" id="L1482">            int realSize = 0;</span>
<span class="nc" id="L1483">            Window fullCopy[] = new Window[fullSize];</span>

<span class="nc bnc" id="L1485" title="All 2 branches missed.">            for (int i = 0; i &lt; fullSize; i++) {</span>
<span class="nc" id="L1486">                fullCopy[realSize] = ownedWindowList.elementAt(i).get();</span>

<span class="nc bnc" id="L1488" title="All 2 branches missed.">                if (fullCopy[realSize] != null) {</span>
<span class="nc" id="L1489">                    realSize++;</span>
                }
            }

<span class="nc bnc" id="L1493" title="All 2 branches missed.">            if (fullSize != realSize) {</span>
<span class="nc" id="L1494">                realCopy = Arrays.copyOf(fullCopy, realSize);</span>
            } else {
<span class="nc" id="L1496">                realCopy = fullCopy;</span>
            }
<span class="nc" id="L1498">        }</span>

<span class="nc" id="L1500">        return realCopy;</span>
    }

    boolean isModalBlocked() {
<span class="nc bnc" id="L1504" title="All 2 branches missed.">        return modalBlocker != null;</span>
    }

    void setModalBlocked(Dialog blocker, boolean blocked, boolean peerCall) {
<span class="nc bnc" id="L1508" title="All 2 branches missed.">        this.modalBlocker = blocked ? blocker : null;</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">        if (peerCall) {</span>
<span class="nc" id="L1510">            WindowPeer peer = (WindowPeer)this.peer;</span>
<span class="nc bnc" id="L1511" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L1512">                peer.setModalBlocked(blocker, blocked);</span>
            }
        }
<span class="nc" id="L1515">    }</span>

    Dialog getModalBlocker() {
<span class="nc" id="L1518">        return modalBlocker;</span>
    }

    /*
     * Returns a list of all displayable Windows, i. e. all the
     * Windows which peer is not null.
     *
     * @see #addNotify
     * @see #removeNotify
     */
    static IdentityArrayList&lt;Window&gt; getAllWindows() {
<span class="nc" id="L1529">        synchronized (allWindows) {</span>
<span class="nc" id="L1530">            IdentityArrayList&lt;Window&gt; v = new IdentityArrayList&lt;Window&gt;();</span>
<span class="nc" id="L1531">            v.addAll(allWindows);</span>
<span class="nc" id="L1532">            return v;</span>
<span class="nc" id="L1533">        }</span>
    }

    static IdentityArrayList&lt;Window&gt; getAllUnblockedWindows() {
<span class="nc" id="L1537">        synchronized (allWindows) {</span>
<span class="nc" id="L1538">            IdentityArrayList&lt;Window&gt; unblocked = new IdentityArrayList&lt;Window&gt;();</span>
<span class="nc bnc" id="L1539" title="All 2 branches missed.">            for (int i = 0; i &lt; allWindows.size(); i++) {</span>
<span class="nc" id="L1540">                Window w = allWindows.get(i);</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">                if (!w.isModalBlocked()) {</span>
<span class="nc" id="L1542">                    unblocked.add(w);</span>
                }
            }
<span class="nc" id="L1545">            return unblocked;</span>
<span class="nc" id="L1546">        }</span>
    }

    private static Window[] getWindows(AppContext appContext) {
<span class="nc" id="L1550">        synchronized (Window.class) {</span>
            Window realCopy[];
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1553">            Vector&lt;WeakReference&lt;Window&gt;&gt; windowList =</span>
<span class="nc" id="L1554">                (Vector&lt;WeakReference&lt;Window&gt;&gt;)appContext.get(Window.class);</span>
<span class="nc bnc" id="L1555" title="All 2 branches missed.">            if (windowList != null) {</span>
<span class="nc" id="L1556">                int fullSize = windowList.size();</span>
<span class="nc" id="L1557">                int realSize = 0;</span>
<span class="nc" id="L1558">                Window fullCopy[] = new Window[fullSize];</span>
<span class="nc bnc" id="L1559" title="All 2 branches missed.">                for (int i = 0; i &lt; fullSize; i++) {</span>
<span class="nc" id="L1560">                    Window w = windowList.get(i).get();</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">                    if (w != null) {</span>
<span class="nc" id="L1562">                        fullCopy[realSize++] = w;</span>
                    }
                }
<span class="nc bnc" id="L1565" title="All 2 branches missed.">                if (fullSize != realSize) {</span>
<span class="nc" id="L1566">                    realCopy = Arrays.copyOf(fullCopy, realSize);</span>
                } else {
<span class="nc" id="L1568">                    realCopy = fullCopy;</span>
                }
<span class="nc" id="L1570">            } else {</span>
<span class="nc" id="L1571">                realCopy = new Window[0];</span>
            }
<span class="nc" id="L1573">            return realCopy;</span>
<span class="nc" id="L1574">        }</span>
    }

    /**
     * Returns an array of all {@code Window}s, both owned and ownerless,
     * created by this application.
     * If called from an applet, the array includes only the {@code Window}s
     * accessible by that applet.
     * &lt;p&gt;
     * &lt;b&gt;Warning:&lt;/b&gt; this method may return system created windows, such
     * as a print dialog. Applications should not assume the existence of
     * these dialogs, nor should an application assume anything about these
     * dialogs such as component positions, {@code LayoutManager}s
     * or serialization.
     *
     * @see Frame#getFrames
     * @see Window#getOwnerlessWindows
     *
     * @since 1.6
     */
    public static Window[] getWindows() {
<span class="nc" id="L1595">        return getWindows(AppContext.getAppContext());</span>
    }

    /**
     * Returns an array of all {@code Window}s created by this application
     * that have no owner. They include {@code Frame}s and ownerless
     * {@code Dialog}s and {@code Window}s.
     * If called from an applet, the array includes only the {@code Window}s
     * accessible by that applet.
     * &lt;p&gt;
     * &lt;b&gt;Warning:&lt;/b&gt; this method may return system created windows, such
     * as a print dialog. Applications should not assume the existence of
     * these dialogs, nor should an application assume anything about these
     * dialogs such as component positions, {@code LayoutManager}s
     * or serialization.
     *
     * @see Frame#getFrames
     * @see Window#getWindows()
     *
     * @since 1.6
     */
    public static Window[] getOwnerlessWindows() {
<span class="nc" id="L1617">        Window[] allWindows = Window.getWindows();</span>

<span class="nc" id="L1619">        int ownerlessCount = 0;</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">        for (Window w : allWindows) {</span>
<span class="nc bnc" id="L1621" title="All 2 branches missed.">            if (w.getOwner() == null) {</span>
<span class="nc" id="L1622">                ownerlessCount++;</span>
            }
        }

<span class="nc" id="L1626">        Window[] ownerless = new Window[ownerlessCount];</span>
<span class="nc" id="L1627">        int c = 0;</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">        for (Window w : allWindows) {</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">            if (w.getOwner() == null) {</span>
<span class="nc" id="L1630">                ownerless[c++] = w;</span>
            }
        }

<span class="nc" id="L1634">        return ownerless;</span>
    }

    Window getDocumentRoot() {
<span class="nc" id="L1638">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L1639">            Window w = this;</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">            while (w.getOwner() != null) {</span>
<span class="nc" id="L1641">                w = w.getOwner();</span>
            }
<span class="nc" id="L1643">            return w;</span>
<span class="nc" id="L1644">        }</span>
    }

    /**
     * Specifies the modal exclusion type for this window. If a window is modal
     * excluded, it is not blocked by some modal dialogs. See {@link
     * java.awt.Dialog.ModalExclusionType Dialog.ModalExclusionType} for
     * possible modal exclusion types.
     * &lt;p&gt;
     * If the given type is not supported, {@code NO_EXCLUDE} is used.
     * &lt;p&gt;
     * Note: changing the modal exclusion type for a visible window may have no
     * effect until it is hidden and then shown again.
     *
     * @param exclusionType the modal exclusion type for this window; a {@code null}
     *     value is equivalent to {@link Dialog.ModalExclusionType#NO_EXCLUDE
     *     NO_EXCLUDE}
     * @throws SecurityException if the calling thread does not have permission
     *     to set the modal exclusion property to the window with the given
     *     {@code exclusionType}
     * @see java.awt.Dialog.ModalExclusionType
     * @see java.awt.Window#getModalExclusionType
     * @see java.awt.Toolkit#isModalExclusionTypeSupported
     *
     * @since 1.6
     */
    public void setModalExclusionType(Dialog.ModalExclusionType exclusionType) {
<span class="nc bnc" id="L1671" title="All 2 branches missed.">        if (exclusionType == null) {</span>
<span class="nc" id="L1672">            exclusionType = Dialog.ModalExclusionType.NO_EXCLUDE;</span>
        }
<span class="nc bnc" id="L1674" title="All 2 branches missed.">        if (!Toolkit.getDefaultToolkit().isModalExclusionTypeSupported(exclusionType)) {</span>
<span class="nc" id="L1675">            exclusionType = Dialog.ModalExclusionType.NO_EXCLUDE;</span>
        }
<span class="nc bnc" id="L1677" title="All 2 branches missed.">        if (modalExclusionType == exclusionType) {</span>
<span class="nc" id="L1678">            return;</span>
        }
<span class="nc bnc" id="L1680" title="All 2 branches missed.">        if (exclusionType == Dialog.ModalExclusionType.TOOLKIT_EXCLUDE) {</span>
<span class="nc" id="L1681">            SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1682" title="All 2 branches missed.">            if (sm != null) {</span>
<span class="nc" id="L1683">                sm.checkPermission(SecurityConstants.AWT.TOOLKIT_MODALITY_PERMISSION);</span>
            }
        }
<span class="nc" id="L1686">        modalExclusionType = exclusionType;</span>

        // if we want on-fly changes, we need to uncomment the lines below
        //   and override the method in Dialog to use modalShow() instead
        //   of updateChildrenBlocking()
 /*
        if (isModalBlocked()) {
            modalBlocker.unblockWindow(this);
        }
        Dialog.checkShouldBeBlocked(this);
        updateChildrenBlocking();
 */
<span class="nc" id="L1698">    }</span>

    /**
     * Returns the modal exclusion type of this window.
     *
     * @return the modal exclusion type of this window
     *
     * @see java.awt.Dialog.ModalExclusionType
     * @see java.awt.Window#setModalExclusionType
     *
     * @since 1.6
     */
    public Dialog.ModalExclusionType getModalExclusionType() {
<span class="nc" id="L1711">        return modalExclusionType;</span>
    }

    boolean isModalExcluded(Dialog.ModalExclusionType exclusionType) {
<span class="nc bnc" id="L1715" title="All 2 branches missed.">        if ((modalExclusionType != null) &amp;&amp;</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">            modalExclusionType.compareTo(exclusionType) &gt;= 0)</span>
        {
<span class="nc" id="L1718">            return true;</span>
        }
<span class="nc" id="L1720">        Window owner = getOwner_NoClientCode();</span>
<span class="nc bnc" id="L1721" title="All 4 branches missed.">        return (owner != null) &amp;&amp; owner.isModalExcluded(exclusionType);</span>
    }

    void updateChildrenBlocking() {
<span class="nc" id="L1725">        Vector&lt;Window&gt; childHierarchy = new Vector&lt;Window&gt;();</span>
<span class="nc" id="L1726">        Window[] ownedWindows = getOwnedWindows();</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">        for (int i = 0; i &lt; ownedWindows.length; i++) {</span>
<span class="nc" id="L1728">            childHierarchy.add(ownedWindows[i]);</span>
        }
<span class="nc" id="L1730">        int k = 0;</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">        while (k &lt; childHierarchy.size()) {</span>
<span class="nc" id="L1732">            Window w = childHierarchy.get(k);</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">            if (w.isVisible()) {</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">                if (w.isModalBlocked()) {</span>
<span class="nc" id="L1735">                    Dialog blocker = w.getModalBlocker();</span>
<span class="nc" id="L1736">                    blocker.unblockWindow(w);</span>
                }
<span class="nc" id="L1738">                Dialog.checkShouldBeBlocked(w);</span>
<span class="nc" id="L1739">                Window[] wOwned = w.getOwnedWindows();</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">                for (int j = 0; j &lt; wOwned.length; j++) {</span>
<span class="nc" id="L1741">                    childHierarchy.add(wOwned[j]);</span>
                }
            }
<span class="nc" id="L1744">            k++;</span>
<span class="nc" id="L1745">        }</span>
<span class="nc" id="L1746">    }</span>

    /**
     * Adds the specified window listener to receive window events from
     * this window.
     * If l is null, no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param   l the window listener
     * @see #removeWindowListener
     * @see #getWindowListeners
     */
    public synchronized void addWindowListener(WindowListener l) {
<span class="nc bnc" id="L1760" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L1761">            return;</span>
        }
<span class="nc" id="L1763">        newEventsOnly = true;</span>
<span class="nc" id="L1764">        windowListener = AWTEventMulticaster.add(windowListener, l);</span>
<span class="nc" id="L1765">    }</span>

    /**
     * Adds the specified window state listener to receive window
     * events from this window.  If {@code l} is {@code null},
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param   l the window state listener
     * @see #removeWindowStateListener
     * @see #getWindowStateListeners
     * @since 1.4
     */
    public synchronized void addWindowStateListener(WindowStateListener l) {
<span class="nc bnc" id="L1780" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L1781">            return;</span>
        }
<span class="nc" id="L1783">        windowStateListener = AWTEventMulticaster.add(windowStateListener, l);</span>
<span class="nc" id="L1784">        newEventsOnly = true;</span>
<span class="nc" id="L1785">    }</span>

    /**
     * Adds the specified window focus listener to receive window events
     * from this window.
     * If l is null, no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param   l the window focus listener
     * @see #removeWindowFocusListener
     * @see #getWindowFocusListeners
     * @since 1.4
     */
    public synchronized void addWindowFocusListener(WindowFocusListener l) {
<span class="nc bnc" id="L1800" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L1801">            return;</span>
        }
<span class="nc" id="L1803">        windowFocusListener = AWTEventMulticaster.add(windowFocusListener, l);</span>
<span class="nc" id="L1804">        newEventsOnly = true;</span>
<span class="nc" id="L1805">    }</span>

    /**
     * Removes the specified window listener so that it no longer
     * receives window events from this window.
     * If l is null, no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param   l the window listener
     * @see #addWindowListener
     * @see #getWindowListeners
     */
    public synchronized void removeWindowListener(WindowListener l) {
<span class="nc bnc" id="L1819" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L1820">            return;</span>
        }
<span class="nc" id="L1822">        windowListener = AWTEventMulticaster.remove(windowListener, l);</span>
<span class="nc" id="L1823">    }</span>

    /**
     * Removes the specified window state listener so that it no
     * longer receives window events from this window.  If
     * {@code l} is {@code null}, no exception is thrown and
     * no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param   l the window state listener
     * @see #addWindowStateListener
     * @see #getWindowStateListeners
     * @since 1.4
     */
    public synchronized void removeWindowStateListener(WindowStateListener l) {
<span class="nc bnc" id="L1839" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L1840">            return;</span>
        }
<span class="nc" id="L1842">        windowStateListener = AWTEventMulticaster.remove(windowStateListener, l);</span>
<span class="nc" id="L1843">    }</span>

    /**
     * Removes the specified window focus listener so that it no longer
     * receives window events from this window.
     * If l is null, no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param   l the window focus listener
     * @see #addWindowFocusListener
     * @see #getWindowFocusListeners
     * @since 1.4
     */
    public synchronized void removeWindowFocusListener(WindowFocusListener l) {
<span class="nc bnc" id="L1858" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L1859">            return;</span>
        }
<span class="nc" id="L1861">        windowFocusListener = AWTEventMulticaster.remove(windowFocusListener, l);</span>
<span class="nc" id="L1862">    }</span>

    /**
     * Returns an array of all the window listeners
     * registered on this window.
     *
     * @return all of this window's {@code WindowListener}s
     *         or an empty array if no window
     *         listeners are currently registered
     *
     * @see #addWindowListener
     * @see #removeWindowListener
     * @since 1.4
     */
    public synchronized WindowListener[] getWindowListeners() {
<span class="nc" id="L1877">        return getListeners(WindowListener.class);</span>
    }

    /**
     * Returns an array of all the window focus listeners
     * registered on this window.
     *
     * @return all of this window's {@code WindowFocusListener}s
     *         or an empty array if no window focus
     *         listeners are currently registered
     *
     * @see #addWindowFocusListener
     * @see #removeWindowFocusListener
     * @since 1.4
     */
    public synchronized WindowFocusListener[] getWindowFocusListeners() {
<span class="nc" id="L1893">        return getListeners(WindowFocusListener.class);</span>
    }

    /**
     * Returns an array of all the window state listeners
     * registered on this window.
     *
     * @return all of this window's {@code WindowStateListener}s
     *         or an empty array if no window state
     *         listeners are currently registered
     *
     * @see #addWindowStateListener
     * @see #removeWindowStateListener
     * @since 1.4
     */
    public synchronized WindowStateListener[] getWindowStateListeners() {
<span class="nc" id="L1909">        return getListeners(WindowStateListener.class);</span>
    }


    /**
     * Returns an array of all the objects currently registered
     * as &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s
     * upon this {@code Window}.
     * &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
     * &lt;code&gt;add&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt; method.
     *
     * &lt;p&gt;
     *
     * You can specify the {@code listenerType} argument
     * with a class literal, such as
     * &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener.class&lt;/code&gt;.
     * For example, you can query a
     * {@code Window} {@code w}
     * for its window listeners with the following code:
     *
     * &lt;pre&gt;WindowListener[] wls = (WindowListener[])(w.getListeners(WindowListener.class));&lt;/pre&gt;
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          {@code java.util.EventListener}
     * @return an array of all objects registered as
     *          &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s on this window,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if {@code listenerType}
     *          doesn't specify a class or interface that implements
     *          {@code java.util.EventListener}
     * @exception NullPointerException if {@code listenerType} is {@code null}
     *
     * @see #getWindowListeners
     * @since 1.3
     */
    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<span class="nc" id="L1949">        EventListener l = null;</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">        if (listenerType == WindowFocusListener.class) {</span>
<span class="nc" id="L1951">            l = windowFocusListener;</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">        } else if (listenerType == WindowStateListener.class) {</span>
<span class="nc" id="L1953">            l = windowStateListener;</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">        } else if (listenerType == WindowListener.class) {</span>
<span class="nc" id="L1955">            l = windowListener;</span>
        } else {
<span class="nc" id="L1957">            return super.getListeners(listenerType);</span>
        }
<span class="nc" id="L1959">        return AWTEventMulticaster.getListeners(l, listenerType);</span>
    }

    // REMIND: remove when filtering is handled at lower level
    boolean eventEnabled(AWTEvent e) {
<span class="nc bnc" id="L1964" title="All 4 branches missed.">        switch(e.id) {</span>
          case WindowEvent.WINDOW_OPENED:
          case WindowEvent.WINDOW_CLOSING:
          case WindowEvent.WINDOW_CLOSED:
          case WindowEvent.WINDOW_ICONIFIED:
          case WindowEvent.WINDOW_DEICONIFIED:
          case WindowEvent.WINDOW_ACTIVATED:
          case WindowEvent.WINDOW_DEACTIVATED:
<span class="nc bnc" id="L1972" title="All 4 branches missed.">            if ((eventMask &amp; AWTEvent.WINDOW_EVENT_MASK) != 0 ||</span>
                windowListener != null) {
<span class="nc" id="L1974">                return true;</span>
            }
<span class="nc" id="L1976">            return false;</span>
          case WindowEvent.WINDOW_GAINED_FOCUS:
          case WindowEvent.WINDOW_LOST_FOCUS:
<span class="nc bnc" id="L1979" title="All 4 branches missed.">            if ((eventMask &amp; AWTEvent.WINDOW_FOCUS_EVENT_MASK) != 0 ||</span>
                windowFocusListener != null) {
<span class="nc" id="L1981">                return true;</span>
            }
<span class="nc" id="L1983">            return false;</span>
          case WindowEvent.WINDOW_STATE_CHANGED:
<span class="nc bnc" id="L1985" title="All 4 branches missed.">            if ((eventMask &amp; AWTEvent.WINDOW_STATE_EVENT_MASK) != 0 ||</span>
                windowStateListener != null) {
<span class="nc" id="L1987">                return true;</span>
            }
<span class="nc" id="L1989">            return false;</span>
          default:
            break;
        }
<span class="nc" id="L1993">        return super.eventEnabled(e);</span>
    }

    /**
     * Processes events on this window. If the event is an
     * {@code WindowEvent}, it invokes the
     * {@code processWindowEvent} method, else it invokes its
     * superclass's {@code processEvent}.
     * &lt;p&gt;Note that if the event parameter is {@code null}
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param e the event
     */
    protected void processEvent(AWTEvent e) {
<span class="nc bnc" id="L2008" title="All 2 branches missed.">        if (e instanceof WindowEvent) {</span>
<span class="nc bnc" id="L2009" title="All 4 branches missed.">            switch (e.getID()) {</span>
                case WindowEvent.WINDOW_OPENED:
                case WindowEvent.WINDOW_CLOSING:
                case WindowEvent.WINDOW_CLOSED:
                case WindowEvent.WINDOW_ICONIFIED:
                case WindowEvent.WINDOW_DEICONIFIED:
                case WindowEvent.WINDOW_ACTIVATED:
                case WindowEvent.WINDOW_DEACTIVATED:
<span class="nc" id="L2017">                    processWindowEvent((WindowEvent)e);</span>
<span class="nc" id="L2018">                    break;</span>
                case WindowEvent.WINDOW_GAINED_FOCUS:
                case WindowEvent.WINDOW_LOST_FOCUS:
<span class="nc" id="L2021">                    processWindowFocusEvent((WindowEvent)e);</span>
<span class="nc" id="L2022">                    break;</span>
                case WindowEvent.WINDOW_STATE_CHANGED:
<span class="nc" id="L2024">                    processWindowStateEvent((WindowEvent)e);</span>
                    break;
            }
<span class="nc" id="L2027">            return;</span>
        }
<span class="nc" id="L2029">        super.processEvent(e);</span>
<span class="nc" id="L2030">    }</span>

    /**
     * Processes window events occurring on this window by
     * dispatching them to any registered WindowListener objects.
     * NOTE: This method will not be called unless window events
     * are enabled for this component; this happens when one of the
     * following occurs:
     * &lt;ul&gt;
     * &lt;li&gt;A WindowListener object is registered via
     *     {@code addWindowListener}
     * &lt;li&gt;Window events are enabled via {@code enableEvents}
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is {@code null}
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param e the window event
     * @see Component#enableEvents
     */
    protected void processWindowEvent(WindowEvent e) {
<span class="nc" id="L2051">        WindowListener listener = windowListener;</span>
<span class="nc bnc" id="L2052" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc bnc" id="L2053" title="All 8 branches missed.">            switch(e.getID()) {</span>
                case WindowEvent.WINDOW_OPENED:
<span class="nc" id="L2055">                    listener.windowOpened(e);</span>
<span class="nc" id="L2056">                    break;</span>
                case WindowEvent.WINDOW_CLOSING:
<span class="nc" id="L2058">                    listener.windowClosing(e);</span>
<span class="nc" id="L2059">                    break;</span>
                case WindowEvent.WINDOW_CLOSED:
<span class="nc" id="L2061">                    listener.windowClosed(e);</span>
<span class="nc" id="L2062">                    break;</span>
                case WindowEvent.WINDOW_ICONIFIED:
<span class="nc" id="L2064">                    listener.windowIconified(e);</span>
<span class="nc" id="L2065">                    break;</span>
                case WindowEvent.WINDOW_DEICONIFIED:
<span class="nc" id="L2067">                    listener.windowDeiconified(e);</span>
<span class="nc" id="L2068">                    break;</span>
                case WindowEvent.WINDOW_ACTIVATED:
<span class="nc" id="L2070">                    listener.windowActivated(e);</span>
<span class="nc" id="L2071">                    break;</span>
                case WindowEvent.WINDOW_DEACTIVATED:
<span class="nc" id="L2073">                    listener.windowDeactivated(e);</span>
<span class="nc" id="L2074">                    break;</span>
                default:
                    break;
            }
        }
<span class="nc" id="L2079">    }</span>

    /**
     * Processes window focus event occurring on this window by
     * dispatching them to any registered WindowFocusListener objects.
     * NOTE: this method will not be called unless window focus events
     * are enabled for this window. This happens when one of the
     * following occurs:
     * &lt;ul&gt;
     * &lt;li&gt;a WindowFocusListener is registered via
     *     {@code addWindowFocusListener}
     * &lt;li&gt;Window focus events are enabled via {@code enableEvents}
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is {@code null}
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param e the window focus event
     * @see Component#enableEvents
     * @since 1.4
     */
    protected void processWindowFocusEvent(WindowEvent e) {
<span class="nc" id="L2101">        WindowFocusListener listener = windowFocusListener;</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc bnc" id="L2103" title="All 3 branches missed.">            switch (e.getID()) {</span>
                case WindowEvent.WINDOW_GAINED_FOCUS:
<span class="nc" id="L2105">                    listener.windowGainedFocus(e);</span>
<span class="nc" id="L2106">                    break;</span>
                case WindowEvent.WINDOW_LOST_FOCUS:
<span class="nc" id="L2108">                    listener.windowLostFocus(e);</span>
<span class="nc" id="L2109">                    break;</span>
                default:
                    break;
            }
        }
<span class="nc" id="L2114">    }</span>

    /**
     * Processes window state event occurring on this window by
     * dispatching them to any registered {@code WindowStateListener}
     * objects.
     * NOTE: this method will not be called unless window state events
     * are enabled for this window.  This happens when one of the
     * following occurs:
     * &lt;ul&gt;
     * &lt;li&gt;a {@code WindowStateListener} is registered via
     *    {@code addWindowStateListener}
     * &lt;li&gt;window state events are enabled via {@code enableEvents}
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is {@code null}
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param e the window state event
     * @see java.awt.Component#enableEvents
     * @since 1.4
     */
    protected void processWindowStateEvent(WindowEvent e) {
<span class="nc" id="L2137">        WindowStateListener listener = windowStateListener;</span>
<span class="nc bnc" id="L2138" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">            switch (e.getID()) {</span>
                case WindowEvent.WINDOW_STATE_CHANGED:
<span class="nc" id="L2141">                    listener.windowStateChanged(e);</span>
<span class="nc" id="L2142">                    break;</span>
                default:
                    break;
            }
        }
<span class="nc" id="L2147">    }</span>

    /**
     * Implements a debugging hook -- checks to see if
     * the user has typed &lt;i&gt;control-shift-F1&lt;/i&gt;.  If so,
     * the list of child windows is dumped to {@code System.out}.
     * @param e  the keyboard event
     */
    void preProcessKeyEvent(KeyEvent e) {
        // Dump the list of child windows to System.out.
<span class="nc bnc" id="L2157" title="All 4 branches missed.">        if (e.isActionKey() &amp;&amp; e.getKeyCode() == KeyEvent.VK_F1 &amp;&amp;</span>
<span class="nc bnc" id="L2158" title="All 4 branches missed.">            e.isControlDown() &amp;&amp; e.isShiftDown() &amp;&amp;</span>
<span class="nc bnc" id="L2159" title="All 2 branches missed.">            e.getID() == KeyEvent.KEY_PRESSED) {</span>
<span class="nc" id="L2160">            list(System.out, 0);</span>
        }
<span class="nc" id="L2162">    }</span>

    void postProcessKeyEvent(KeyEvent e) {
        // Do nothing
<span class="nc" id="L2166">    }</span>


    /**
     * Sets whether this window should always be above other windows.  If
     * there are multiple always-on-top windows, their relative order is
     * unspecified and platform dependent.
     * &lt;p&gt;
     * If some other window is already always-on-top then the
     * relative order between these windows is unspecified (depends on
     * platform).  No window can be brought to be over the always-on-top
     * window except maybe another always-on-top window.
     * &lt;p&gt;
     * All windows owned by an always-on-top window inherit this state and
     * automatically become always-on-top.  If a window ceases to be
     * always-on-top, the windows that it owns will no longer be
     * always-on-top.  When an always-on-top window is sent {@link #toBack
     * toBack}, its always-on-top state is set to {@code false}.
     *
     * &lt;p&gt; When this method is called on a window with a value of
     * {@code true}, and the window is visible and the platform
     * supports always-on-top for this window, the window is immediately
     * brought forward, &quot;sticking&quot; it in the top-most position. If the
     * window isn`t currently visible, this method sets the always-on-top
     * state to {@code true} but does not bring the window forward.
     * When the window is later shown, it will be always-on-top.
     *
     * &lt;p&gt; When this method is called on a window with a value of
     * {@code false} the always-on-top state is set to normal. It may also
     * cause an unspecified, platform-dependent change in the z-order of
     * top-level windows, but other always-on-top windows will remain in
     * top-most position. Calling this method with a value of {@code false}
     * on a window that has a normal state has no effect.
     *
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: some platforms might not support always-on-top
     * windows.  To detect if always-on-top windows are supported by the
     * current platform, use {@link Toolkit#isAlwaysOnTopSupported()} and
     * {@link Window#isAlwaysOnTopSupported()}.  If always-on-top mode
     * isn't supported for this window or this window's toolkit does not
     * support always-on-top windows, calling this method has no effect.
     * &lt;p&gt;
     * If a SecurityManager is installed, the calling thread must be
     * granted the AWTPermission &quot;setWindowAlwaysOnTop&quot; in
     * order to set the value of this property. If this
     * permission is not granted, this method will throw a
     * SecurityException, and the current value of the property will
     * be left unchanged.
     *
     * @param alwaysOnTop true if the window should always be above other
     *        windows
     * @throws SecurityException if the calling thread does not have
     *         permission to set the value of always-on-top property
     *
     * @see #isAlwaysOnTop
     * @see #toFront
     * @see #toBack
     * @see AWTPermission
     * @see #isAlwaysOnTopSupported
     * @see #getToolkit
     * @see Toolkit#isAlwaysOnTopSupported
     * @since 1.5
     */
    public final void setAlwaysOnTop(boolean alwaysOnTop) throws SecurityException {
<span class="nc" id="L2229">        SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L2230" title="All 2 branches missed.">        if (security != null) {</span>
<span class="nc" id="L2231">            security.checkPermission(SecurityConstants.AWT.SET_WINDOW_ALWAYS_ON_TOP_PERMISSION);</span>
        }

        boolean oldAlwaysOnTop;
<span class="nc" id="L2235">        synchronized(this) {</span>
<span class="nc" id="L2236">            oldAlwaysOnTop = this.alwaysOnTop;</span>
<span class="nc" id="L2237">            this.alwaysOnTop = alwaysOnTop;</span>
<span class="nc" id="L2238">        }</span>
<span class="nc bnc" id="L2239" title="All 2 branches missed.">        if (oldAlwaysOnTop != alwaysOnTop ) {</span>
<span class="nc bnc" id="L2240" title="All 2 branches missed.">            if (isAlwaysOnTopSupported()) {</span>
<span class="nc" id="L2241">                WindowPeer peer = (WindowPeer)this.peer;</span>
<span class="nc" id="L2242">                synchronized(getTreeLock()) {</span>
<span class="nc bnc" id="L2243" title="All 2 branches missed.">                    if (peer != null) {</span>
<span class="nc" id="L2244">                        peer.updateAlwaysOnTopState();</span>
                    }
<span class="nc" id="L2246">                }</span>
            }
<span class="nc" id="L2248">            firePropertyChange(&quot;alwaysOnTop&quot;, oldAlwaysOnTop, alwaysOnTop);</span>
        }
<span class="nc bnc" id="L2250" title="All 2 branches missed.">        for (WeakReference&lt;Window&gt; ref : ownedWindowList) {</span>
<span class="nc" id="L2251">            Window window = ref.get();</span>
<span class="nc bnc" id="L2252" title="All 2 branches missed.">            if (window != null) {</span>
                try {
<span class="nc" id="L2254">                    window.setAlwaysOnTop(alwaysOnTop);</span>
<span class="nc" id="L2255">                } catch (SecurityException ignore) {</span>
<span class="nc" id="L2256">                }</span>
            }
<span class="nc" id="L2258">        }</span>
<span class="nc" id="L2259">    }</span>

    /**
     * Returns whether the always-on-top mode is supported for this
     * window. Some platforms may not support always-on-top windows, some
     * may support only some kinds of top-level windows; for example,
     * a platform may not support always-on-top modal dialogs.
     *
     * @return {@code true}, if the always-on-top mode is supported for
     *         this window and this window's toolkit supports always-on-top windows,
     *         {@code false} otherwise
     *
     * @see #setAlwaysOnTop(boolean)
     * @see #getToolkit
     * @see Toolkit#isAlwaysOnTopSupported
     * @since 1.6
     */
    public boolean isAlwaysOnTopSupported() {
<span class="nc" id="L2277">        return Toolkit.getDefaultToolkit().isAlwaysOnTopSupported();</span>
    }


    /**
     * Returns whether this window is an always-on-top window.
     * @return {@code true}, if the window is in always-on-top state,
     *         {@code false} otherwise
     * @see #setAlwaysOnTop
     * @since 1.5
     */
    public final boolean isAlwaysOnTop() {
<span class="nc" id="L2289">        return alwaysOnTop;</span>
    }


    /**
     * Returns the child Component of this Window that has focus if this Window
     * is focused; returns null otherwise.
     *
     * @return the child Component with focus, or null if this Window is not
     *         focused
     * @see #getMostRecentFocusOwner
     * @see #isFocused
     */
    public Component getFocusOwner() {
<span class="nc bnc" id="L2303" title="All 2 branches missed.">        return (isFocused())</span>
<span class="nc" id="L2304">            ? KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L2305">                  getFocusOwner()</span>
            : null;
    }

    /**
     * Returns the child Component of this Window that will receive the focus
     * when this Window is focused. If this Window is currently focused, this
     * method returns the same Component as {@code getFocusOwner()}. If
     * this Window is not focused, then the child Component that most recently
     * requested focus will be returned. If no child Component has ever
     * requested focus, and this is a focusable Window, then this Window's
     * initial focusable Component is returned. If no child Component has ever
     * requested focus, and this is a non-focusable Window, null is returned.
     *
     * @return the child Component that will receive focus when this Window is
     *         focused
     * @see #getFocusOwner
     * @see #isFocused
     * @see #isFocusableWindow
     * @since 1.4
     */
    public Component getMostRecentFocusOwner() {
<span class="nc bnc" id="L2327" title="All 2 branches missed.">        if (isFocused()) {</span>
<span class="nc" id="L2328">            return getFocusOwner();</span>
        } else {
<span class="nc" id="L2330">            Component mostRecent =</span>
<span class="nc" id="L2331">                KeyboardFocusManager.getMostRecentFocusOwner(this);</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">            if (mostRecent != null) {</span>
<span class="nc" id="L2333">                return mostRecent;</span>
            } else {
<span class="nc bnc" id="L2335" title="All 2 branches missed.">                return (isFocusableWindow())</span>
<span class="nc" id="L2336">                    ? getFocusTraversalPolicy().getInitialComponent(this)</span>
                    : null;
            }
        }
    }

    /**
     * Returns whether this Window is active. Only a Frame or a Dialog may be
     * active. The native windowing system may denote the active Window or its
     * children with special decorations, such as a highlighted title bar. The
     * active Window is always either the focused Window, or the first Frame or
     * Dialog that is an owner of the focused Window.
     *
     * @return whether this is the active Window.
     * @see #isFocused
     * @since 1.4
     */
    public boolean isActive() {
<span class="nc" id="L2354">        return (KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc bnc" id="L2355" title="All 2 branches missed.">                getActiveWindow() == this);</span>
    }

    /**
     * Returns whether this Window is focused. If there exists a focus owner,
     * the focused Window is the Window that is, or contains, that focus owner.
     * If there is no focus owner, then no Window is focused.
     * &lt;p&gt;
     * If the focused Window is a Frame or a Dialog it is also the active
     * Window. Otherwise, the active Window is the first Frame or Dialog that
     * is an owner of the focused Window.
     *
     * @return whether this is the focused Window.
     * @see #isActive
     * @since 1.4
     */
    public boolean isFocused() {
<span class="nc" id="L2372">        return (KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc bnc" id="L2373" title="All 2 branches missed.">                getGlobalFocusedWindow() == this);</span>
    }

    /**
     * Gets a focus traversal key for this Window. (See {@code
     * setFocusTraversalKeys} for a full description of each key.)
     * &lt;p&gt;
     * If the traversal key has not been explicitly set for this Window,
     * then this Window's parent's traversal key is returned. If the
     * traversal key has not been explicitly set for any of this Window's
     * ancestors, then the current KeyboardFocusManager's default traversal key
     * is returned.
     *
     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
     * @return the AWTKeyStroke for the specified key
     * @see Container#setFocusTraversalKeys
     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS
     * @throws IllegalArgumentException if id is not one of
     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
     * @since 1.4
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Set&lt;AWTKeyStroke&gt; getFocusTraversalKeys(int id) {
<span class="nc bnc" id="L2405" title="All 4 branches missed.">        if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {</span>
<span class="nc" id="L2406">            throw new IllegalArgumentException(&quot;invalid focus traversal key identifier&quot;);</span>
        }

        // Okay to return Set directly because it is an unmodifiable view
        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="nc bnc" id="L2411" title="All 2 branches missed.">        Set keystrokes = (focusTraversalKeys != null)</span>
            ? focusTraversalKeys[id]
            : null;

<span class="nc bnc" id="L2415" title="All 2 branches missed.">        if (keystrokes != null) {</span>
<span class="nc" id="L2416">            return keystrokes;</span>
        } else {
<span class="nc" id="L2418">            return KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L2419">                getDefaultFocusTraversalKeys(id);</span>
        }
    }

    /**
     * Does nothing because Windows must always be roots of a focus traversal
     * cycle. The passed-in value is ignored.
     *
     * @param focusCycleRoot this value is ignored
     * @see #isFocusCycleRoot
     * @see Container#setFocusTraversalPolicy
     * @see Container#getFocusTraversalPolicy
     * @since 1.4
     */
    public final void setFocusCycleRoot(boolean focusCycleRoot) {
<span class="nc" id="L2434">    }</span>

    /**
     * Always returns {@code true} because all Windows must be roots of a
     * focus traversal cycle.
     *
     * @return {@code true}
     * @see #setFocusCycleRoot
     * @see Container#setFocusTraversalPolicy
     * @see Container#getFocusTraversalPolicy
     * @since 1.4
     */
    public final boolean isFocusCycleRoot() {
<span class="nc" id="L2447">        return true;</span>
    }

    /**
     * Always returns {@code null} because Windows have no ancestors; they
     * represent the top of the Component hierarchy.
     *
     * @return {@code null}
     * @see Container#isFocusCycleRoot()
     * @since 1.4
     */
    public final Container getFocusCycleRootAncestor() {
<span class="nc" id="L2459">        return null;</span>
    }

    /**
     * Returns whether this Window can become the focused Window, that is,
     * whether this Window or any of its subcomponents can become the focus
     * owner. For a Frame or Dialog to be focusable, its focusable Window state
     * must be set to {@code true}. For a Window which is not a Frame or
     * Dialog to be focusable, its focusable Window state must be set to
     * {@code true}, its nearest owning Frame or Dialog must be
     * showing on the screen, and it must contain at least one Component in
     * its focus traversal cycle. If any of these conditions is not met, then
     * neither this Window nor any of its subcomponents can become the focus
     * owner.
     *
     * @return {@code true} if this Window can be the focused Window;
     *         {@code false} otherwise
     * @see #getFocusableWindowState
     * @see #setFocusableWindowState
     * @see #isShowing
     * @see Component#isFocusable
     * @since 1.4
     */
    public final boolean isFocusableWindow() {
        // If a Window/Frame/Dialog was made non-focusable, then it is always
        // non-focusable.
<span class="nc bnc" id="L2485" title="All 2 branches missed.">        if (!getFocusableWindowState()) {</span>
<span class="nc" id="L2486">            return false;</span>
        }

        // All other tests apply only to Windows.
<span class="nc bnc" id="L2490" title="All 4 branches missed.">        if (this instanceof Frame || this instanceof Dialog) {</span>
<span class="nc" id="L2491">            return true;</span>
        }

        // A Window must have at least one Component in its root focus
        // traversal cycle to be focusable.
<span class="nc bnc" id="L2496" title="All 2 branches missed.">        if (getFocusTraversalPolicy().getDefaultComponent(this) == null) {</span>
<span class="nc" id="L2497">            return false;</span>
        }

        // A Window's nearest owning Frame or Dialog must be showing on the
        // screen.
<span class="nc bnc" id="L2502" title="All 2 branches missed.">        for (Window owner = getOwner(); owner != null;</span>
<span class="nc" id="L2503">             owner = owner.getOwner())</span>
        {
<span class="nc bnc" id="L2505" title="All 4 branches missed.">            if (owner instanceof Frame || owner instanceof Dialog) {</span>
<span class="nc" id="L2506">                return owner.isShowing();</span>
            }
        }

<span class="nc" id="L2510">        return false;</span>
    }

    /**
     * Returns whether this Window can become the focused Window if it meets
     * the other requirements outlined in {@code isFocusableWindow}. If
     * this method returns {@code false}, then
     * {@code isFocusableWindow} will return {@code false} as well.
     * If this method returns {@code true}, then
     * {@code isFocusableWindow} may return {@code true} or
     * {@code false} depending upon the other requirements which must be
     * met in order for a Window to be focusable.
     * &lt;p&gt;
     * By default, all Windows have a focusable Window state of
     * {@code true}.
     *
     * @return whether this Window can be the focused Window
     * @see #isFocusableWindow
     * @see #setFocusableWindowState
     * @see #isShowing
     * @see Component#setFocusable
     * @since 1.4
     */
    public boolean getFocusableWindowState() {
<span class="nc" id="L2534">        return focusableWindowState;</span>
    }

    /**
     * Sets whether this Window can become the focused Window if it meets
     * the other requirements outlined in {@code isFocusableWindow}. If
     * this Window's focusable Window state is set to {@code false}, then
     * {@code isFocusableWindow} will return {@code false}. If this
     * Window's focusable Window state is set to {@code true}, then
     * {@code isFocusableWindow} may return {@code true} or
     * {@code false} depending upon the other requirements which must be
     * met in order for a Window to be focusable.
     * &lt;p&gt;
     * Setting a Window's focusability state to {@code false} is the
     * standard mechanism for an application to identify to the AWT a Window
     * which will be used as a floating palette or toolbar, and thus should be
     * a non-focusable Window.
     *
     * Setting the focusability state on a visible {@code Window}
     * can have a delayed effect on some platforms &amp;#151; the actual
     * change may happen only when the {@code Window} becomes
     * hidden and then visible again.  To ensure consistent behavior
     * across platforms, set the {@code Window}'s focusable state
     * when the {@code Window} is invisible and then show it.
     *
     * @param focusableWindowState whether this Window can be the focused
     *        Window
     * @see #isFocusableWindow
     * @see #getFocusableWindowState
     * @see #isShowing
     * @see Component#setFocusable
     * @since 1.4
     */
    public void setFocusableWindowState(boolean focusableWindowState) {
        boolean oldFocusableWindowState;
<span class="nc" id="L2569">        synchronized (this) {</span>
<span class="nc" id="L2570">            oldFocusableWindowState = this.focusableWindowState;</span>
<span class="nc" id="L2571">            this.focusableWindowState = focusableWindowState;</span>
<span class="nc" id="L2572">        }</span>
<span class="nc" id="L2573">        WindowPeer peer = (WindowPeer)this.peer;</span>
<span class="nc bnc" id="L2574" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L2575">            peer.updateFocusableWindowState();</span>
        }
<span class="nc" id="L2577">        firePropertyChange(&quot;focusableWindowState&quot;, oldFocusableWindowState,</span>
                           focusableWindowState);
<span class="nc bnc" id="L2579" title="All 6 branches missed.">        if (oldFocusableWindowState &amp;&amp; !focusableWindowState &amp;&amp; isFocused()) {</span>
<span class="nc" id="L2580">            for (Window owner = getOwner();</span>
<span class="nc bnc" id="L2581" title="All 2 branches missed.">                 owner != null;</span>
<span class="nc" id="L2582">                 owner = owner.getOwner())</span>
                {
<span class="nc" id="L2584">                    Component toFocus =</span>
<span class="nc" id="L2585">                        KeyboardFocusManager.getMostRecentFocusOwner(owner);</span>
<span class="nc bnc" id="L2586" title="All 4 branches missed.">                    if (toFocus != null &amp;&amp; toFocus.requestFocus(false, CausedFocusEvent.Cause.ACTIVATION)) {</span>
<span class="nc" id="L2587">                        return;</span>
                    }
                }
<span class="nc" id="L2590">            KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L2591">                clearGlobalFocusOwnerPriv();</span>
        }
<span class="nc" id="L2593">    }</span>

    /**
     * Sets whether this window should receive focus on
     * subsequently being shown (with a call to {@link #setVisible setVisible(true)}),
     * or being moved to the front (with a call to {@link #toFront}).
     * &lt;p&gt;
     * Note that {@link #setVisible setVisible(true)} may be called indirectly
     * (e.g. when showing an owner of the window makes the window to be shown).
     * {@link #toFront} may also be called indirectly (e.g. when
     * {@link #setVisible setVisible(true)} is called on already visible window).
     * In all such cases this property takes effect as well.
     * &lt;p&gt;
     * The value of the property is not inherited by owned windows.
     *
     * @param autoRequestFocus whether this window should be focused on
     *        subsequently being shown or being moved to the front
     * @see #isAutoRequestFocus
     * @see #isFocusableWindow
     * @see #setVisible
     * @see #toFront
     * @since 1.7
     */
    public void setAutoRequestFocus(boolean autoRequestFocus) {
<span class="nc" id="L2617">        this.autoRequestFocus = autoRequestFocus;</span>
<span class="nc" id="L2618">    }</span>

    /**
     * Returns whether this window should receive focus on subsequently being shown
     * (with a call to {@link #setVisible setVisible(true)}), or being moved to the front
     * (with a call to {@link #toFront}).
     * &lt;p&gt;
     * By default, the window has {@code autoRequestFocus} value of {@code true}.
     *
     * @return {@code autoRequestFocus} value
     * @see #setAutoRequestFocus
     * @since 1.7
     */
    public boolean isAutoRequestFocus() {
<span class="nc" id="L2632">        return autoRequestFocus;</span>
    }

    /**
     * Adds a PropertyChangeListener to the listener list. The listener is
     * registered for all bound properties of this class, including the
     * following:
     * &lt;ul&gt;
     *    &lt;li&gt;this Window's font (&quot;font&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's background color (&quot;background&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's foreground color (&quot;foreground&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's focusability (&quot;focusable&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's focus traversal keys enabled state
     *        (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's Set of FORWARD_TRAVERSAL_KEYS
     *        (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's Set of BACKWARD_TRAVERSAL_KEYS
     *        (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's Set of UP_CYCLE_TRAVERSAL_KEYS
     *        (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's Set of DOWN_CYCLE_TRAVERSAL_KEYS
     *        (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's focus traversal policy (&quot;focusTraversalPolicy&quot;)
     *        &lt;/li&gt;
     *    &lt;li&gt;this Window's focusable Window state (&quot;focusableWindowState&quot;)
     *        &lt;/li&gt;
     *    &lt;li&gt;this Window's always-on-top state(&quot;alwaysOnTop&quot;)&lt;/li&gt;
     * &lt;/ul&gt;
     * Note that if this Window is inheriting a bound property, then no
     * event will be fired in response to a change in the inherited property.
     * &lt;p&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param    listener  the PropertyChangeListener to be added
     *
     * @see Component#removePropertyChangeListener
     * @see #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
     */
    public void addPropertyChangeListener(PropertyChangeListener listener) {
<span class="nc" id="L2671">        super.addPropertyChangeListener(listener);</span>
<span class="nc" id="L2672">    }</span>

    /**
     * Adds a PropertyChangeListener to the listener list for a specific
     * property. The specified property may be user-defined, or one of the
     * following:
     * &lt;ul&gt;
     *    &lt;li&gt;this Window's font (&quot;font&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's background color (&quot;background&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's foreground color (&quot;foreground&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's focusability (&quot;focusable&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's focus traversal keys enabled state
     *        (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's Set of FORWARD_TRAVERSAL_KEYS
     *        (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's Set of BACKWARD_TRAVERSAL_KEYS
     *        (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's Set of UP_CYCLE_TRAVERSAL_KEYS
     *        (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's Set of DOWN_CYCLE_TRAVERSAL_KEYS
     *        (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Window's focus traversal policy (&quot;focusTraversalPolicy&quot;)
     *        &lt;/li&gt;
     *    &lt;li&gt;this Window's focusable Window state (&quot;focusableWindowState&quot;)
     *        &lt;/li&gt;
     *    &lt;li&gt;this Window's always-on-top state(&quot;alwaysOnTop&quot;)&lt;/li&gt;
     * &lt;/ul&gt;
     * Note that if this Window is inheriting a bound property, then no
     * event will be fired in response to a change in the inherited property.
     * &lt;p&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param propertyName one of the property names listed above
     * @param listener the PropertyChangeListener to be added
     *
     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)
     * @see Component#removePropertyChangeListener
     */
    public void addPropertyChangeListener(String propertyName,
                                          PropertyChangeListener listener) {
<span class="nc" id="L2712">        super.addPropertyChangeListener(propertyName, listener);</span>
<span class="nc" id="L2713">    }</span>

    /**
     * Indicates if this container is a validate root.
     * &lt;p&gt;
     * {@code Window} objects are the validate roots, and, therefore, they
     * override this method to return {@code true}.
     *
     * @return {@code true}
     * @since 1.7
     * @see java.awt.Container#isValidateRoot
     */
    @Override
    public boolean isValidateRoot() {
<span class="nc" id="L2727">        return true;</span>
    }

    /**
     * Dispatches an event to this window or one of its sub components.
     * @param e the event
     */
    void dispatchEventImpl(AWTEvent e) {
<span class="nc bnc" id="L2735" title="All 2 branches missed.">        if (e.getID() == ComponentEvent.COMPONENT_RESIZED) {</span>
<span class="nc" id="L2736">            invalidate();</span>
<span class="nc" id="L2737">            validate();</span>
        }
<span class="nc" id="L2739">        super.dispatchEventImpl(e);</span>
<span class="nc" id="L2740">    }</span>

    /**
     * @deprecated As of JDK version 1.1
     * replaced by {@code dispatchEvent(AWTEvent)}.
     */
    @Deprecated
    public boolean postEvent(Event e) {
<span class="nc bnc" id="L2748" title="All 2 branches missed.">        if (handleEvent(e)) {</span>
<span class="nc" id="L2749">            e.consume();</span>
<span class="nc" id="L2750">            return true;</span>
        }
<span class="nc" id="L2752">        return false;</span>
    }

    /**
     * Checks if this Window is showing on screen.
     * @see Component#setVisible
    */
    public boolean isShowing() {
<span class="nc" id="L2760">        return visible;</span>
    }

    boolean isDisposing() {
<span class="nc" id="L2764">        return disposing;</span>
    }

    /**
     * @deprecated As of J2SE 1.4, replaced by
     * {@link Component#applyComponentOrientation Component.applyComponentOrientation}.
     */
    @Deprecated
    public void applyResourceBundle(ResourceBundle rb) {
<span class="nc" id="L2773">        applyComponentOrientation(ComponentOrientation.getOrientation(rb));</span>
<span class="nc" id="L2774">    }</span>

    /**
     * @deprecated As of J2SE 1.4, replaced by
     * {@link Component#applyComponentOrientation Component.applyComponentOrientation}.
     */
    @Deprecated
    public void applyResourceBundle(String rbName) {
<span class="nc" id="L2782">        applyResourceBundle(ResourceBundle.getBundle(rbName));</span>
<span class="nc" id="L2783">    }</span>

   /*
    * Support for tracking all windows owned by this window
    */
    void addOwnedWindow(WeakReference&lt;Window&gt; weakWindow) {
<span class="nc bnc" id="L2789" title="All 2 branches missed.">        if (weakWindow != null) {</span>
<span class="nc" id="L2790">            synchronized(ownedWindowList) {</span>
                // this if statement should really be an assert, but we don't
                // have asserts...
<span class="nc bnc" id="L2793" title="All 2 branches missed.">                if (!ownedWindowList.contains(weakWindow)) {</span>
<span class="nc" id="L2794">                    ownedWindowList.addElement(weakWindow);</span>
                }
<span class="nc" id="L2796">            }</span>
        }
<span class="nc" id="L2798">    }</span>

    void removeOwnedWindow(WeakReference&lt;Window&gt; weakWindow) {
<span class="nc bnc" id="L2801" title="All 2 branches missed.">        if (weakWindow != null) {</span>
            // synchronized block not required since removeElement is
            // already synchronized
<span class="nc" id="L2804">            ownedWindowList.removeElement(weakWindow);</span>
        }
<span class="nc" id="L2806">    }</span>

    void connectOwnedWindow(Window child) {
<span class="nc" id="L2809">        child.parent = this;</span>
<span class="nc" id="L2810">        addOwnedWindow(child.weakThis);</span>
<span class="nc" id="L2811">        child.disposerRecord.updateOwner();</span>
<span class="nc" id="L2812">    }</span>

    private void addToWindowList() {
<span class="nc" id="L2815">        synchronized (Window.class) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L2817">            Vector&lt;WeakReference&lt;Window&gt;&gt; windowList = (Vector&lt;WeakReference&lt;Window&gt;&gt;)appContext.get(Window.class);</span>
<span class="nc bnc" id="L2818" title="All 2 branches missed.">            if (windowList == null) {</span>
<span class="nc" id="L2819">                windowList = new Vector&lt;WeakReference&lt;Window&gt;&gt;();</span>
<span class="nc" id="L2820">                appContext.put(Window.class, windowList);</span>
            }
<span class="nc" id="L2822">            windowList.add(weakThis);</span>
<span class="nc" id="L2823">        }</span>
<span class="nc" id="L2824">    }</span>

    private static void removeFromWindowList(AppContext context, WeakReference&lt;Window&gt; weakThis) {
<span class="nc" id="L2827">        synchronized (Window.class) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L2829">            Vector&lt;WeakReference&lt;Window&gt;&gt; windowList = (Vector&lt;WeakReference&lt;Window&gt;&gt;)context.get(Window.class);</span>
<span class="nc bnc" id="L2830" title="All 2 branches missed.">            if (windowList != null) {</span>
<span class="nc" id="L2831">                windowList.remove(weakThis);</span>
            }
<span class="nc" id="L2833">        }</span>
<span class="nc" id="L2834">    }</span>

    private void removeFromWindowList() {
<span class="nc" id="L2837">        removeFromWindowList(appContext, weakThis);</span>
<span class="nc" id="L2838">    }</span>

    /**
     * Window type.
     *
     * Synchronization: ObjectLock
     */
<span class="nc" id="L2845">    private Type type = Type.NORMAL;</span>

    /**
     * Sets the type of the window.
     *
     * This method can only be called while the window is not displayable.
     *
     * @throws IllegalComponentStateException if the window
     *         is displayable.
     * @throws IllegalArgumentException if the type is {@code null}
     * @see    Component#isDisplayable
     * @see    #getType
     * @since 1.7
     */
    public void setType(Type type) {
<span class="nc bnc" id="L2860" title="All 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L2861">            throw new IllegalArgumentException(&quot;type should not be null.&quot;);</span>
        }
<span class="nc" id="L2863">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L2864" title="All 2 branches missed.">            if (isDisplayable()) {</span>
<span class="nc" id="L2865">                throw new IllegalComponentStateException(</span>
                        &quot;The window is displayable.&quot;);
            }
<span class="nc" id="L2868">            synchronized (getObjectLock()) {</span>
<span class="nc" id="L2869">                this.type = type;</span>
<span class="nc" id="L2870">            }</span>
<span class="nc" id="L2871">        }</span>
<span class="nc" id="L2872">    }</span>

    /**
     * Returns the type of the window.
     *
     * @see   #setType
     * @since 1.7
     */
    public Type getType() {
<span class="nc" id="L2881">        synchronized (getObjectLock()) {</span>
<span class="nc" id="L2882">            return type;</span>
<span class="nc" id="L2883">        }</span>
    }

    /**
     * The window serialized data version.
     *
     * @serial
     */
<span class="nc" id="L2891">    private int windowSerializedDataVersion = 2;</span>

    /**
     * Writes default serializable fields to stream.  Writes
     * a list of serializable {@code WindowListener}s and
     * {@code WindowFocusListener}s as optional data.
     * Writes a list of child windows as optional data.
     * Writes a list of icon images as optional data
     *
     * @param s the {@code ObjectOutputStream} to write
     * @serialData {@code null} terminated sequence of
     *    0 or more pairs; the pair consists of a {@code String}
     *    and {@code Object}; the {@code String}
     *    indicates the type of object and is one of the following:
     *    {@code windowListenerK} indicating a
     *      {@code WindowListener} object;
     *    {@code windowFocusWindowK} indicating a
     *      {@code WindowFocusListener} object;
     *    {@code ownedWindowK} indicating a child
     *      {@code Window} object
     *
     * @see AWTEventMulticaster#save(java.io.ObjectOutputStream, java.lang.String, java.util.EventListener)
     * @see Component#windowListenerK
     * @see Component#windowFocusListenerK
     * @see Component#ownedWindowK
     * @see #readObject(ObjectInputStream)
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L2919">        synchronized (this) {</span>
            // Update old focusMgr fields so that our object stream can be read
            // by previous releases
<span class="nc" id="L2922">            focusMgr = new FocusManager();</span>
<span class="nc" id="L2923">            focusMgr.focusRoot = this;</span>
<span class="nc" id="L2924">            focusMgr.focusOwner = getMostRecentFocusOwner();</span>

<span class="nc" id="L2926">            s.defaultWriteObject();</span>

            // Clear fields so that we don't keep extra references around
<span class="nc" id="L2929">            focusMgr = null;</span>

<span class="nc" id="L2931">            AWTEventMulticaster.save(s, windowListenerK, windowListener);</span>
<span class="nc" id="L2932">            AWTEventMulticaster.save(s, windowFocusListenerK, windowFocusListener);</span>
<span class="nc" id="L2933">            AWTEventMulticaster.save(s, windowStateListenerK, windowStateListener);</span>
<span class="nc" id="L2934">        }</span>

<span class="nc" id="L2936">        s.writeObject(null);</span>

<span class="nc" id="L2938">        synchronized (ownedWindowList) {</span>
<span class="nc bnc" id="L2939" title="All 2 branches missed.">            for (int i = 0; i &lt; ownedWindowList.size(); i++) {</span>
<span class="nc" id="L2940">                Window child = ownedWindowList.elementAt(i).get();</span>
<span class="nc bnc" id="L2941" title="All 2 branches missed.">                if (child != null) {</span>
<span class="nc" id="L2942">                    s.writeObject(ownedWindowK);</span>
<span class="nc" id="L2943">                    s.writeObject(child);</span>
                }
            }
<span class="nc" id="L2946">        }</span>
<span class="nc" id="L2947">        s.writeObject(null);</span>

        //write icon array
<span class="nc bnc" id="L2950" title="All 2 branches missed.">        if (icons != null) {</span>
<span class="nc bnc" id="L2951" title="All 2 branches missed.">            for (Image i : icons) {</span>
<span class="nc bnc" id="L2952" title="All 2 branches missed.">                if (i instanceof Serializable) {</span>
<span class="nc" id="L2953">                    s.writeObject(i);</span>
                }
<span class="nc" id="L2955">            }</span>
        }
<span class="nc" id="L2957">        s.writeObject(null);</span>
<span class="nc" id="L2958">    }</span>

    //
    // Part of deserialization procedure to be called before
    // user's code.
    //
    private void initDeserializedWindow() {
<span class="nc" id="L2965">        setWarningString();</span>
<span class="nc" id="L2966">        inputContextLock = new Object();</span>

        // Deserialized Windows are not yet visible.
<span class="nc" id="L2969">        visible = false;</span>

<span class="nc" id="L2971">        weakThis = new WeakReference&lt;&gt;(this);</span>

<span class="nc" id="L2973">        anchor = new Object();</span>
<span class="nc" id="L2974">        disposerRecord = new WindowDisposerRecord(appContext, this);</span>
<span class="nc" id="L2975">        sun.java2d.Disposer.addRecord(anchor, disposerRecord);</span>

<span class="nc" id="L2977">        addToWindowList();</span>
<span class="nc" id="L2978">        initGC(null);</span>
<span class="nc" id="L2979">        ownedWindowList = new Vector&lt;&gt;();</span>
<span class="nc" id="L2980">    }</span>

    private void deserializeResources(ObjectInputStream s)
        throws ClassNotFoundException, IOException, HeadlessException {

<span class="nc bnc" id="L2985" title="All 2 branches missed.">            if (windowSerializedDataVersion &lt; 2) {</span>
                // Translate old-style focus tracking to new model. For 1.4 and
                // later releases, we'll rely on the Window's initial focusable
                // Component.
<span class="nc bnc" id="L2989" title="All 2 branches missed.">                if (focusMgr != null) {</span>
<span class="nc bnc" id="L2990" title="All 2 branches missed.">                    if (focusMgr.focusOwner != null) {</span>
<span class="nc" id="L2991">                        KeyboardFocusManager.</span>
<span class="nc" id="L2992">                            setMostRecentFocusOwner(this, focusMgr.focusOwner);</span>
                    }
                }

                // This field is non-transient and relies on default serialization.
                // However, the default value is insufficient, so we need to set
                // it explicitly for object data streams prior to 1.4.
<span class="nc" id="L2999">                focusableWindowState = true;</span>


            }

        Object keyOrNull;
<span class="nc bnc" id="L3005" title="All 2 branches missed.">        while(null != (keyOrNull = s.readObject())) {</span>
<span class="nc" id="L3006">            String key = ((String)keyOrNull).intern();</span>

<span class="nc bnc" id="L3008" title="All 2 branches missed.">            if (windowListenerK == key) {</span>
<span class="nc" id="L3009">                addWindowListener((WindowListener)(s.readObject()));</span>
<span class="nc bnc" id="L3010" title="All 2 branches missed.">            } else if (windowFocusListenerK == key) {</span>
<span class="nc" id="L3011">                addWindowFocusListener((WindowFocusListener)(s.readObject()));</span>
<span class="nc bnc" id="L3012" title="All 2 branches missed.">            } else if (windowStateListenerK == key) {</span>
<span class="nc" id="L3013">                addWindowStateListener((WindowStateListener)(s.readObject()));</span>
            } else // skip value for unrecognized key
<span class="nc" id="L3015">                s.readObject();</span>
<span class="nc" id="L3016">        }</span>

        try {
<span class="nc bnc" id="L3019" title="All 2 branches missed.">            while (null != (keyOrNull = s.readObject())) {</span>
<span class="nc" id="L3020">                String key = ((String)keyOrNull).intern();</span>

<span class="nc bnc" id="L3022" title="All 2 branches missed.">                if (ownedWindowK == key)</span>
<span class="nc" id="L3023">                    connectOwnedWindow((Window) s.readObject());</span>

                else // skip value for unrecognized key
<span class="nc" id="L3026">                    s.readObject();</span>
<span class="nc" id="L3027">            }</span>

            //read icons
<span class="nc" id="L3030">            Object obj = s.readObject(); //Throws OptionalDataException</span>
                                         //for pre1.6 objects.
<span class="nc" id="L3032">            icons = new ArrayList&lt;Image&gt;(); //Frame.readObject() assumes</span>
                                            //pre1.6 version if icons is null.
<span class="nc bnc" id="L3034" title="All 2 branches missed.">            while (obj != null) {</span>
<span class="nc bnc" id="L3035" title="All 2 branches missed.">                if (obj instanceof Image) {</span>
<span class="nc" id="L3036">                    icons.add((Image)obj);</span>
                }
<span class="nc" id="L3038">                obj = s.readObject();</span>
            }
        }
<span class="nc" id="L3041">        catch (OptionalDataException e) {</span>
            // 1.1 serialized form
            // ownedWindowList will be updated by Frame.readObject
<span class="nc" id="L3044">        }</span>

<span class="nc" id="L3046">    }</span>

    /**
     * Reads the {@code ObjectInputStream} and an optional
     * list of listeners to receive various events fired by
     * the component; also reads a list of
     * (possibly {@code null}) child windows.
     * Unrecognized keys or values will be ignored.
     *
     * @param s the {@code ObjectInputStream} to read
     * @exception HeadlessException if
     *   {@code GraphicsEnvironment.isHeadless} returns
     *   {@code true}
     * @see java.awt.GraphicsEnvironment#isHeadless
     * @see #writeObject
     */
    private void readObject(ObjectInputStream s)
      throws ClassNotFoundException, IOException, HeadlessException
    {
<span class="nc" id="L3065">         GraphicsEnvironment.checkHeadless();</span>
<span class="nc" id="L3066">         initDeserializedWindow();</span>
<span class="nc" id="L3067">         ObjectInputStream.GetField f = s.readFields();</span>

<span class="nc" id="L3069">         syncLWRequests = f.get(&quot;syncLWRequests&quot;, systemSyncLWRequests);</span>
<span class="nc" id="L3070">         state = f.get(&quot;state&quot;, 0);</span>
<span class="nc" id="L3071">         focusableWindowState = f.get(&quot;focusableWindowState&quot;, true);</span>
<span class="nc" id="L3072">         windowSerializedDataVersion = f.get(&quot;windowSerializedDataVersion&quot;, 1);</span>
<span class="nc" id="L3073">         locationByPlatform = f.get(&quot;locationByPlatform&quot;, locationByPlatformProp);</span>
         // Note: 1.4 (or later) doesn't use focusMgr
<span class="nc" id="L3075">         focusMgr = (FocusManager)f.get(&quot;focusMgr&quot;, null);</span>
<span class="nc" id="L3076">         Dialog.ModalExclusionType et = (Dialog.ModalExclusionType)</span>
<span class="nc" id="L3077">             f.get(&quot;modalExclusionType&quot;, Dialog.ModalExclusionType.NO_EXCLUDE);</span>
<span class="nc" id="L3078">         setModalExclusionType(et); // since 6.0</span>
<span class="nc" id="L3079">         boolean aot = f.get(&quot;alwaysOnTop&quot;, false);</span>
<span class="nc bnc" id="L3080" title="All 2 branches missed.">         if(aot) {</span>
<span class="nc" id="L3081">             setAlwaysOnTop(aot); // since 1.5; subject to permission check</span>
         }
<span class="nc" id="L3083">         shape = (Shape)f.get(&quot;shape&quot;, null);</span>
<span class="nc" id="L3084">         opacity = (Float)f.get(&quot;opacity&quot;, 1.0f);</span>

<span class="nc" id="L3086">         this.securityWarningWidth = 0;</span>
<span class="nc" id="L3087">         this.securityWarningHeight = 0;</span>
<span class="nc" id="L3088">         this.securityWarningPointX = 2.0;</span>
<span class="nc" id="L3089">         this.securityWarningPointY = 0.0;</span>
<span class="nc" id="L3090">         this.securityWarningAlignmentX = RIGHT_ALIGNMENT;</span>
<span class="nc" id="L3091">         this.securityWarningAlignmentY = TOP_ALIGNMENT;</span>

<span class="nc" id="L3093">         deserializeResources(s);</span>
<span class="nc" id="L3094">    }</span>

    /*
     * --- Accessibility Support ---
     *
     */

    /**
     * Gets the AccessibleContext associated with this Window.
     * For windows, the AccessibleContext takes the form of an
     * AccessibleAWTWindow.
     * A new AccessibleAWTWindow instance is created if necessary.
     *
     * @return an AccessibleAWTWindow that serves as the
     *         AccessibleContext of this Window
     * @since 1.3
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L3112" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L3113">            accessibleContext = new AccessibleAWTWindow();</span>
        }
<span class="nc" id="L3115">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * {@code Window} class.  It provides an implementation of the
     * Java Accessibility API appropriate to window user-interface elements.
     * @since 1.3
     */
<span class="nc" id="L3124">    protected class AccessibleAWTWindow extends AccessibleAWTContainer</span>
    {
        /*
         * JDK 1.3 serialVersionUID
         */
        private static final long serialVersionUID = 4215068635060671780L;

        /**
         * Get the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of the
         * object
         * @see javax.accessibility.AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L3139">            return AccessibleRole.WINDOW;</span>
        }

        /**
         * Get the state of this object.
         *
         * @return an instance of AccessibleStateSet containing the current
         * state set of the object
         * @see javax.accessibility.AccessibleState
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L3150">            AccessibleStateSet states = super.getAccessibleStateSet();</span>
<span class="nc bnc" id="L3151" title="All 2 branches missed.">            if (getFocusOwner() != null) {</span>
<span class="nc" id="L3152">                states.add(AccessibleState.ACTIVE);</span>
            }
<span class="nc" id="L3154">            return states;</span>
        }

    } // inner class AccessibleAWTWindow

    @Override
    void setGraphicsConfiguration(GraphicsConfiguration gc) {
<span class="nc bnc" id="L3161" title="All 2 branches missed.">        if (gc == null) {</span>
            gc = GraphicsEnvironment.
<span class="nc" id="L3163">                    getLocalGraphicsEnvironment().</span>
<span class="nc" id="L3164">                    getDefaultScreenDevice().</span>
<span class="nc" id="L3165">                    getDefaultConfiguration();</span>
        }
<span class="nc" id="L3167">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L3168">            super.setGraphicsConfiguration(gc);</span>
<span class="nc bnc" id="L3169" title="All 2 branches missed.">            if (log.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L3170">                log.finer(&quot;+ Window.setGraphicsConfiguration(): new GC is \n+ &quot; + getGraphicsConfiguration_NoClientCode() + &quot;\n+ this is &quot; + this);</span>
            }
<span class="nc" id="L3172">        }</span>
<span class="nc" id="L3173">    }</span>

    /**
     * Sets the location of the window relative to the specified
     * component according to the following scenarios.
     * &lt;p&gt;
     * The target screen mentioned below is a screen to which
     * the window should be placed after the setLocationRelativeTo
     * method is called.
     * &lt;ul&gt;
     * &lt;li&gt;If the component is {@code null}, or the {@code
     * GraphicsConfiguration} associated with this component is
     * {@code null}, the window is placed in the center of the
     * screen. The center point can be obtained with the {@link
     * GraphicsEnvironment#getCenterPoint
     * GraphicsEnvironment.getCenterPoint} method.
     * &lt;li&gt;If the component is not {@code null}, but it is not
     * currently showing, the window is placed in the center of
     * the target screen defined by the {@code
     * GraphicsConfiguration} associated with this component.
     * &lt;li&gt;If the component is not {@code null} and is shown on
     * the screen, then the window is located in such a way that
     * the center of the window coincides with the center of the
     * component.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * If the screens configuration does not allow the window to
     * be moved from one screen to another, then the window is
     * only placed at the location determined according to the
     * above conditions and its {@code GraphicsConfiguration} is
     * not changed.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: If the lower edge of the window is out of the screen,
     * then the window is placed to the side of the {@code Component}
     * that is closest to the center of the screen. So if the
     * component is on the right part of the screen, the window
     * is placed to its left, and vice versa.
     * &lt;p&gt;
     * If after the window location has been calculated, the upper,
     * left, or right edge of the window is out of the screen,
     * then the window is located in such a way that the upper,
     * left, or right edge of the window coincides with the
     * corresponding edge of the screen. If both left and right
     * edges of the window are out of the screen, the window is
     * placed at the left side of the screen. The similar placement
     * will occur if both top and bottom edges are out of the screen.
     * In that case, the window is placed at the top side of the screen.
     * &lt;p&gt;
     * The method changes the geometry-related data. Therefore,
     * the native windowing system may ignore such requests, or it may modify
     * the requested data, so that the {@code Window} object is placed and sized
     * in a way that corresponds closely to the desktop settings.
     *
     * @param c  the component in relation to which the window's location
     *           is determined
     * @see java.awt.GraphicsEnvironment#getCenterPoint
     * @since 1.4
     */
    public void setLocationRelativeTo(Component c) {
        // target location
<span class="nc" id="L3233">        int dx = 0, dy = 0;</span>
        // target GC
<span class="nc" id="L3235">        GraphicsConfiguration gc = getGraphicsConfiguration_NoClientCode();</span>
<span class="nc" id="L3236">        Rectangle gcBounds = gc.getBounds();</span>

<span class="nc" id="L3238">        Dimension windowSize = getSize();</span>

        // search a top-level of c
<span class="nc" id="L3241">        Window componentWindow = SunToolkit.getContainingWindow(c);</span>
<span class="nc bnc" id="L3242" title="All 4 branches missed.">        if ((c == null) || (componentWindow == null)) {</span>
<span class="nc" id="L3243">            GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();</span>
<span class="nc" id="L3244">            gc = ge.getDefaultScreenDevice().getDefaultConfiguration();</span>
<span class="nc" id="L3245">            gcBounds = gc.getBounds();</span>
<span class="nc" id="L3246">            Point centerPoint = ge.getCenterPoint();</span>
<span class="nc" id="L3247">            dx = centerPoint.x - windowSize.width / 2;</span>
<span class="nc" id="L3248">            dy = centerPoint.y - windowSize.height / 2;</span>
<span class="nc bnc" id="L3249" title="All 2 branches missed.">        } else if (!c.isShowing()) {</span>
<span class="nc" id="L3250">            gc = componentWindow.getGraphicsConfiguration();</span>
<span class="nc" id="L3251">            gcBounds = gc.getBounds();</span>
<span class="nc" id="L3252">            dx = gcBounds.x + (gcBounds.width - windowSize.width) / 2;</span>
<span class="nc" id="L3253">            dy = gcBounds.y + (gcBounds.height - windowSize.height) / 2;</span>
        } else {
<span class="nc" id="L3255">            gc = componentWindow.getGraphicsConfiguration();</span>
<span class="nc" id="L3256">            gcBounds = gc.getBounds();</span>
<span class="nc" id="L3257">            Dimension compSize = c.getSize();</span>
<span class="nc" id="L3258">            Point compLocation = c.getLocationOnScreen();</span>
<span class="nc" id="L3259">            dx = compLocation.x + ((compSize.width - windowSize.width) / 2);</span>
<span class="nc" id="L3260">            dy = compLocation.y + ((compSize.height - windowSize.height) / 2);</span>

            // Adjust for bottom edge being offscreen
<span class="nc bnc" id="L3263" title="All 2 branches missed.">            if (dy + windowSize.height &gt; gcBounds.y + gcBounds.height) {</span>
<span class="nc" id="L3264">                dy = gcBounds.y + gcBounds.height - windowSize.height;</span>
<span class="nc bnc" id="L3265" title="All 2 branches missed.">                if (compLocation.x - gcBounds.x + compSize.width / 2 &lt; gcBounds.width / 2) {</span>
<span class="nc" id="L3266">                    dx = compLocation.x + compSize.width;</span>
                } else {
<span class="nc" id="L3268">                    dx = compLocation.x - windowSize.width;</span>
                }
            }
        }

        // Avoid being placed off the edge of the screen:
        // bottom
<span class="nc bnc" id="L3275" title="All 2 branches missed.">        if (dy + windowSize.height &gt; gcBounds.y + gcBounds.height) {</span>
<span class="nc" id="L3276">            dy = gcBounds.y + gcBounds.height - windowSize.height;</span>
        }
        // top
<span class="nc bnc" id="L3279" title="All 2 branches missed.">        if (dy &lt; gcBounds.y) {</span>
<span class="nc" id="L3280">            dy = gcBounds.y;</span>
        }
        // right
<span class="nc bnc" id="L3283" title="All 2 branches missed.">        if (dx + windowSize.width &gt; gcBounds.x + gcBounds.width) {</span>
<span class="nc" id="L3284">            dx = gcBounds.x + gcBounds.width - windowSize.width;</span>
        }
        // left
<span class="nc bnc" id="L3287" title="All 2 branches missed.">        if (dx &lt; gcBounds.x) {</span>
<span class="nc" id="L3288">            dx = gcBounds.x;</span>
        }

<span class="nc" id="L3291">        setLocation(dx, dy);</span>
<span class="nc" id="L3292">    }</span>

    /**
     * Overridden from Component.  Top-level Windows should not propagate a
     * MouseWheelEvent beyond themselves into their owning Windows.
     */
<span class="nc" id="L3298">    void deliverMouseWheelToAncestor(MouseWheelEvent e) {}</span>

    /**
     * Overridden from Component.  Top-level Windows don't dispatch to ancestors
     */
<span class="nc" id="L3303">    boolean dispatchMouseWheelToAncestor(MouseWheelEvent e) {return false;}</span>

    /**
     * Creates a new strategy for multi-buffering on this component.
     * Multi-buffering is useful for rendering performance.  This method
     * attempts to create the best strategy available with the number of
     * buffers supplied.  It will always create a {@code BufferStrategy}
     * with that number of buffers.
     * A page-flipping strategy is attempted first, then a blitting strategy
     * using accelerated buffers.  Finally, an unaccelerated blitting
     * strategy is used.
     * &lt;p&gt;
     * Each time this method is called,
     * the existing buffer strategy for this component is discarded.
     * @param numBuffers number of buffers to create
     * @exception IllegalArgumentException if numBuffers is less than 1.
     * @exception IllegalStateException if the component is not displayable
     * @see #isDisplayable
     * @see #getBufferStrategy
     * @since 1.4
     */
    public void createBufferStrategy(int numBuffers) {
<span class="nc" id="L3325">        super.createBufferStrategy(numBuffers);</span>
<span class="nc" id="L3326">    }</span>

    /**
     * Creates a new strategy for multi-buffering on this component with the
     * required buffer capabilities.  This is useful, for example, if only
     * accelerated memory or page flipping is desired (as specified by the
     * buffer capabilities).
     * &lt;p&gt;
     * Each time this method
     * is called, the existing buffer strategy for this component is discarded.
     * @param numBuffers number of buffers to create, including the front buffer
     * @param caps the required capabilities for creating the buffer strategy;
     * cannot be {@code null}
     * @exception AWTException if the capabilities supplied could not be
     * supported or met; this may happen, for example, if there is not enough
     * accelerated memory currently available, or if page flipping is specified
     * but not possible.
     * @exception IllegalArgumentException if numBuffers is less than 1, or if
     * caps is {@code null}
     * @see #getBufferStrategy
     * @since 1.4
     */
    public void createBufferStrategy(int numBuffers,
        BufferCapabilities caps) throws AWTException {
<span class="nc" id="L3350">        super.createBufferStrategy(numBuffers, caps);</span>
<span class="nc" id="L3351">    }</span>

    /**
     * Returns the {@code BufferStrategy} used by this component.  This
     * method will return null if a {@code BufferStrategy} has not yet
     * been created or has been disposed.
     *
     * @return the buffer strategy used by this component
     * @see #createBufferStrategy
     * @since 1.4
     */
    public BufferStrategy getBufferStrategy() {
<span class="nc" id="L3363">        return super.getBufferStrategy();</span>
    }

    Component getTemporaryLostComponent() {
<span class="nc" id="L3367">        return temporaryLostComponent;</span>
    }
    Component setTemporaryLostComponent(Component component) {
<span class="nc" id="L3370">        Component previousComp = temporaryLostComponent;</span>
        // Check that &quot;component&quot; is an acceptable focus owner and don't store it otherwise
        // - or later we will have problems with opposite while handling  WINDOW_GAINED_FOCUS
<span class="nc bnc" id="L3373" title="All 4 branches missed.">        if (component == null || component.canBeFocusOwner()) {</span>
<span class="nc" id="L3374">            temporaryLostComponent = component;</span>
        } else {
<span class="nc" id="L3376">            temporaryLostComponent = null;</span>
        }
<span class="nc" id="L3378">        return previousComp;</span>
    }

    /**
     * Checks whether this window can contain focus owner.
     * Verifies that it is focusable and as container it can container focus owner.
     * @since 1.5
     */
    boolean canContainFocusOwner(Component focusOwnerCandidate) {
<span class="nc bnc" id="L3387" title="All 4 branches missed.">        return super.canContainFocusOwner(focusOwnerCandidate) &amp;&amp; isFocusableWindow();</span>
    }

<span class="nc" id="L3390">    private boolean locationByPlatform = locationByPlatformProp;</span>


    /**
     * Sets whether this Window should appear at the default location for the
     * native windowing system or at the current location (returned by
     * {@code getLocation}) the next time the Window is made visible.
     * This behavior resembles a native window shown without programmatically
     * setting its location.  Most windowing systems cascade windows if their
     * locations are not explicitly set. The actual location is determined once the
     * window is shown on the screen.
     * &lt;p&gt;
     * This behavior can also be enabled by setting the System Property
     * &quot;java.awt.Window.locationByPlatform&quot; to &quot;true&quot;, though calls to this method
     * take precedence.
     * &lt;p&gt;
     * Calls to {@code setVisible}, {@code setLocation} and
     * {@code setBounds} after calling {@code setLocationByPlatform} clear
     * this property of the Window.
     * &lt;p&gt;
     * For example, after the following code is executed:
     * &lt;pre&gt;
     * setLocationByPlatform(true);
     * setVisible(true);
     * boolean flag = isLocationByPlatform();
     * &lt;/pre&gt;
     * The window will be shown at platform's default location and
     * {@code flag} will be {@code false}.
     * &lt;p&gt;
     * In the following sample:
     * &lt;pre&gt;
     * setLocationByPlatform(true);
     * setLocation(10, 10);
     * boolean flag = isLocationByPlatform();
     * setVisible(true);
     * &lt;/pre&gt;
     * The window will be shown at (10, 10) and {@code flag} will be
     * {@code false}.
     *
     * @param locationByPlatform {@code true} if this Window should appear
     *        at the default location, {@code false} if at the current location
     * @throws IllegalComponentStateException if the window
     *         is showing on screen and locationByPlatform is {@code true}.
     * @see #setLocation
     * @see #isShowing
     * @see #setVisible
     * @see #isLocationByPlatform
     * @see java.lang.System#getProperty(String)
     * @since 1.5
     */
    public void setLocationByPlatform(boolean locationByPlatform) {
<span class="nc" id="L3441">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L3442" title="All 4 branches missed.">            if (locationByPlatform &amp;&amp; isShowing()) {</span>
<span class="nc" id="L3443">                throw new IllegalComponentStateException(&quot;The window is showing on screen.&quot;);</span>
            }
<span class="nc" id="L3445">            this.locationByPlatform = locationByPlatform;</span>
<span class="nc" id="L3446">        }</span>
<span class="nc" id="L3447">    }</span>

    /**
     * Returns {@code true} if this Window will appear at the default location
     * for the native windowing system the next time this Window is made visible.
     * This method always returns {@code false} if the Window is showing on the
     * screen.
     *
     * @return whether this Window will appear at the default location
     * @see #setLocationByPlatform
     * @see #isShowing
     * @since 1.5
     */
    public boolean isLocationByPlatform() {
<span class="nc" id="L3461">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L3462">            return locationByPlatform;</span>
<span class="nc" id="L3463">        }</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * The {@code width} or {@code height} values
     * are automatically enlarged if either is less than
     * the minimum size as specified by previous call to
     * {@code setMinimumSize}.
     * &lt;p&gt;
     * The method changes the geometry-related data. Therefore,
     * the native windowing system may ignore such requests, or it may modify
     * the requested data, so that the {@code Window} object is placed and sized
     * in a way that corresponds closely to the desktop settings.
     *
     * @see #getBounds
     * @see #setLocation(int, int)
     * @see #setLocation(Point)
     * @see #setSize(int, int)
     * @see #setSize(Dimension)
     * @see #setMinimumSize
     * @see #setLocationByPlatform
     * @see #isLocationByPlatform
     * @since 1.6
     */
    public void setBounds(int x, int y, int width, int height) {
<span class="nc" id="L3490">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L3491" title="All 2 branches missed.">            if (getBoundsOp() == ComponentPeer.SET_LOCATION ||</span>
<span class="nc bnc" id="L3492" title="All 2 branches missed.">                getBoundsOp() == ComponentPeer.SET_BOUNDS)</span>
            {
<span class="nc" id="L3494">                locationByPlatform = false;</span>
            }
<span class="nc" id="L3496">            super.setBounds(x, y, width, height);</span>
<span class="nc" id="L3497">        }</span>
<span class="nc" id="L3498">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * The {@code r.width} or {@code r.height} values
     * will be automatically enlarged if either is less than
     * the minimum size as specified by previous call to
     * {@code setMinimumSize}.
     * &lt;p&gt;
     * The method changes the geometry-related data. Therefore,
     * the native windowing system may ignore such requests, or it may modify
     * the requested data, so that the {@code Window} object is placed and sized
     * in a way that corresponds closely to the desktop settings.
     *
     * @see #getBounds
     * @see #setLocation(int, int)
     * @see #setLocation(Point)
     * @see #setSize(int, int)
     * @see #setSize(Dimension)
     * @see #setMinimumSize
     * @see #setLocationByPlatform
     * @see #isLocationByPlatform
     * @since 1.6
     */
    public void setBounds(Rectangle r) {
<span class="nc" id="L3524">        setBounds(r.x, r.y, r.width, r.height);</span>
<span class="nc" id="L3525">    }</span>

    /**
     * Determines whether this component will be displayed on the screen.
     * @return {@code true} if the component and all of its ancestors
     *          until a toplevel window are visible, {@code false} otherwise
     */
    boolean isRecursivelyVisible() {
        // 5079694 fix: for a toplevel to be displayed, its parent doesn't have to be visible.
        // We're overriding isRecursivelyVisible to implement this policy.
<span class="nc" id="L3535">        return visible;</span>
    }


    // ******************** SHAPES &amp; TRANSPARENCY CODE ********************

    /**
     * Returns the opacity of the window.
     *
     * @return the opacity of the window
     *
     * @see Window#setOpacity(float)
     * @see GraphicsDevice.WindowTranslucency
     *
     * @since 1.7
     */
    public float getOpacity() {
<span class="nc" id="L3552">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L3553">            return opacity;</span>
<span class="nc" id="L3554">        }</span>
    }

    /**
     * Sets the opacity of the window.
     * &lt;p&gt;
     * The opacity value is in the range [0..1]. Note that setting the opacity
     * level of 0 may or may not disable the mouse event handling on this
     * window. This is a platform-dependent behavior.
     * &lt;p&gt;
     * The following conditions must be met in order to set the opacity value
     * less than {@code 1.0f}:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}
     * translucency must be supported by the underlying system
     * &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}
     * and {@link Dialog#setUndecorated})
     * &lt;li&gt;The window must not be in full-screen mode (see {@link
     * GraphicsDevice#setFullScreenWindow(Window)})
     * &lt;/ul&gt;
     * &lt;p&gt;
     * If the requested opacity value is less than {@code 1.0f}, and any of the
     * above conditions are not met, the window opacity will not change,
     * and the {@code IllegalComponentStateException} will be thrown.
     * &lt;p&gt;
     * The translucency levels of individual pixels may also be effected by the
     * alpha component of their color (see {@link Window#setBackground(Color)}) and the
     * current shape of this window (see {@link #setShape(Shape)}).
     *
     * @param opacity the opacity level to set to the window
     *
     * @throws IllegalArgumentException if the opacity is out of the range
     *     [0..1]
     * @throws IllegalComponentStateException if the window is decorated and
     *     the opacity is less than {@code 1.0f}
     * @throws IllegalComponentStateException if the window is in full screen
     *     mode, and the opacity is less than {@code 1.0f}
     * @throws UnsupportedOperationException if the {@code
     *     GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}
     *     translucency is not supported and the opacity is less than
     *     {@code 1.0f}
     *
     * @see Window#getOpacity
     * @see Window#setBackground(Color)
     * @see Window#setShape(Shape)
     * @see Frame#isUndecorated
     * @see Dialog#isUndecorated
     * @see GraphicsDevice.WindowTranslucency
     * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
     *
     * @since 1.7
     */
    public void setOpacity(float opacity) {
<span class="nc" id="L3607">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L3608" title="All 4 branches missed.">            if (opacity &lt; 0.0f || opacity &gt; 1.0f) {</span>
<span class="nc" id="L3609">                throw new IllegalArgumentException(</span>
                    &quot;The value of opacity should be in the range [0.0f .. 1.0f].&quot;);
            }
<span class="nc bnc" id="L3612" title="All 2 branches missed.">            if (opacity &lt; 1.0f) {</span>
<span class="nc" id="L3613">                GraphicsConfiguration gc = getGraphicsConfiguration();</span>
<span class="nc" id="L3614">                GraphicsDevice gd = gc.getDevice();</span>
<span class="nc bnc" id="L3615" title="All 2 branches missed.">                if (gc.getDevice().getFullScreenWindow() == this) {</span>
<span class="nc" id="L3616">                    throw new IllegalComponentStateException(</span>
                        &quot;Setting opacity for full-screen window is not supported.&quot;);
                }
<span class="nc bnc" id="L3619" title="All 2 branches missed.">                if (!gd.isWindowTranslucencySupported(</span>
                    GraphicsDevice.WindowTranslucency.TRANSLUCENT))
                {
<span class="nc" id="L3622">                    throw new UnsupportedOperationException(</span>
                        &quot;TRANSLUCENT translucency is not supported.&quot;);
                }
            }
<span class="nc" id="L3626">            this.opacity = opacity;</span>
<span class="nc" id="L3627">            WindowPeer peer = (WindowPeer)getPeer();</span>
<span class="nc bnc" id="L3628" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L3629">                peer.setOpacity(opacity);</span>
            }
<span class="nc" id="L3631">        }</span>
<span class="nc" id="L3632">    }</span>

    /**
     * Returns the shape of the window.
     *
     * The value returned by this method may not be the same as
     * previously set with {@code setShape(shape)}, but it is guaranteed
     * to represent the same shape.
     *
     * @return the shape of the window or {@code null} if no
     *     shape is specified for the window
     *
     * @see Window#setShape(Shape)
     * @see GraphicsDevice.WindowTranslucency
     *
     * @since 1.7
     */
    public Shape getShape() {
<span class="nc" id="L3650">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L3651" title="All 2 branches missed.">            return shape == null ? null : new Path2D.Float(shape);</span>
<span class="nc" id="L3652">        }</span>
    }

    /**
     * Sets the shape of the window.
     * &lt;p&gt;
     * Setting a shape cuts off some parts of the window. Only the parts that
     * belong to the given {@link Shape} remain visible and clickable. If
     * the shape argument is {@code null}, this method restores the default
     * shape, making the window rectangular on most platforms.
     * &lt;p&gt;
     * The following conditions must be met to set a non-null shape:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSPARENT
     * PERPIXEL_TRANSPARENT} translucency must be supported by the
     * underlying system
     * &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}
     * and {@link Dialog#setUndecorated})
     * &lt;li&gt;The window must not be in full-screen mode (see {@link
     * GraphicsDevice#setFullScreenWindow(Window)})
     * &lt;/ul&gt;
     * &lt;p&gt;
     * If the requested shape is not {@code null}, and any of the above
     * conditions are not met, the shape of this window will not change,
     * and either the {@code UnsupportedOperationException} or {@code
     * IllegalComponentStateException} will be thrown.
     * &lt;p&gt;
     * The translucency levels of individual pixels may also be effected by the
     * alpha component of their color (see {@link Window#setBackground(Color)}) and the
     * opacity value (see {@link #setOpacity(float)}). See {@link
     * GraphicsDevice.WindowTranslucency} for more details.
     *
     * @param shape the shape to set to the window
     *
     * @throws IllegalComponentStateException if the shape is not {@code
     *     null} and the window is decorated
     * @throws IllegalComponentStateException if the shape is not {@code
     *     null} and the window is in full-screen mode
     * @throws UnsupportedOperationException if the shape is not {@code
     *     null} and {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSPARENT
     *     PERPIXEL_TRANSPARENT} translucency is not supported
     *
     * @see Window#getShape()
     * @see Window#setBackground(Color)
     * @see Window#setOpacity(float)
     * @see Frame#isUndecorated
     * @see Dialog#isUndecorated
     * @see GraphicsDevice.WindowTranslucency
     * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
     *
     * @since 1.7
     */
    public void setShape(Shape shape) {
<span class="nc" id="L3705">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L3706" title="All 2 branches missed.">            if (shape != null) {</span>
<span class="nc" id="L3707">                GraphicsConfiguration gc = getGraphicsConfiguration();</span>
<span class="nc" id="L3708">                GraphicsDevice gd = gc.getDevice();</span>
<span class="nc bnc" id="L3709" title="All 2 branches missed.">                if (gc.getDevice().getFullScreenWindow() == this) {</span>
<span class="nc" id="L3710">                    throw new IllegalComponentStateException(</span>
                        &quot;Setting shape for full-screen window is not supported.&quot;);
                }
<span class="nc bnc" id="L3713" title="All 2 branches missed.">                if (!gd.isWindowTranslucencySupported(</span>
                        GraphicsDevice.WindowTranslucency.PERPIXEL_TRANSPARENT))
                {
<span class="nc" id="L3716">                    throw new UnsupportedOperationException(</span>
                        &quot;PERPIXEL_TRANSPARENT translucency is not supported.&quot;);
                }
            }
<span class="nc bnc" id="L3720" title="All 2 branches missed.">            this.shape = (shape == null) ? null : new Path2D.Float(shape);</span>
<span class="nc" id="L3721">            WindowPeer peer = (WindowPeer)getPeer();</span>
<span class="nc bnc" id="L3722" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc bnc" id="L3723" title="All 2 branches missed.">                peer.applyShape(shape == null ? null : Region.getInstance(shape, null));</span>
            }
<span class="nc" id="L3725">        }</span>
<span class="nc" id="L3726">    }</span>

    /**
     * Gets the background color of this window.
     * &lt;p&gt;
     * Note that the alpha component of the returned color indicates whether
     * the window is in the non-opaque (per-pixel translucent) mode.
     *
     * @return this component's background color
     *
     * @see Window#setBackground(Color)
     * @see Window#isOpaque
     * @see GraphicsDevice.WindowTranslucency
     */
    @Override
    public Color getBackground() {
<span class="nc" id="L3742">        return super.getBackground();</span>
    }

    /**
     * Sets the background color of this window.
     * &lt;p&gt;
     * If the windowing system supports the {@link
     * GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT PERPIXEL_TRANSLUCENT}
     * translucency, the alpha component of the given background color
     * may effect the mode of operation for this window: it indicates whether
     * this window must be opaque (alpha equals {@code 1.0f}) or per-pixel translucent
     * (alpha is less than {@code 1.0f}). If the given background color is
     * {@code null}, the window is considered completely opaque.
     * &lt;p&gt;
     * All the following conditions must be met to enable the per-pixel
     * transparency mode for this window:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT
     * PERPIXEL_TRANSLUCENT} translucency must be supported by the graphics
     * device where this window is located
     * &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}
     * and {@link Dialog#setUndecorated})
     * &lt;li&gt;The window must not be in full-screen mode (see {@link
     * GraphicsDevice#setFullScreenWindow(Window)})
     * &lt;/ul&gt;
     * &lt;p&gt;
     * If the alpha component of the requested background color is less than
     * {@code 1.0f}, and any of the above conditions are not met, the background
     * color of this window will not change, the alpha component of the given
     * background color will not affect the mode of operation for this window,
     * and either the {@code UnsupportedOperationException} or {@code
     * IllegalComponentStateException} will be thrown.
     * &lt;p&gt;
     * When the window is per-pixel translucent, the drawing sub-system
     * respects the alpha value of each individual pixel. If a pixel gets
     * painted with the alpha color component equal to zero, it becomes
     * visually transparent. If the alpha of the pixel is equal to 1.0f, the
     * pixel is fully opaque. Interim values of the alpha color component make
     * the pixel semi-transparent. In this mode, the background of the window
     * gets painted with the alpha value of the given background color. If the
     * alpha value of the argument of this method is equal to {@code 0}, the
     * background is not painted at all.
     * &lt;p&gt;
     * The actual level of translucency of a given pixel also depends on window
     * opacity (see {@link #setOpacity(float)}), as well as the current shape of
     * this window (see {@link #setShape(Shape)}).
     * &lt;p&gt;
     * Note that painting a pixel with the alpha value of {@code 0} may or may
     * not disable the mouse event handling on this pixel. This is a
     * platform-dependent behavior. To make sure the mouse events do not get
     * dispatched to a particular pixel, the pixel must be excluded from the
     * shape of the window.
     * &lt;p&gt;
     * Enabling the per-pixel translucency mode may change the graphics
     * configuration of this window due to the native platform requirements.
     *
     * @param bgColor the color to become this window's background color.
     *
     * @throws IllegalComponentStateException if the alpha value of the given
     *     background color is less than {@code 1.0f} and the window is decorated
     * @throws IllegalComponentStateException if the alpha value of the given
     *     background color is less than {@code 1.0f} and the window is in
     *     full-screen mode
     * @throws UnsupportedOperationException if the alpha value of the given
     *     background color is less than {@code 1.0f} and {@link
     *     GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT
     *     PERPIXEL_TRANSLUCENT} translucency is not supported
     *
     * @see Window#getBackground
     * @see Window#isOpaque
     * @see Window#setOpacity(float)
     * @see Window#setShape(Shape)
     * @see Frame#isUndecorated
     * @see Dialog#isUndecorated
     * @see GraphicsDevice.WindowTranslucency
     * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
     * @see GraphicsConfiguration#isTranslucencyCapable()
     */
    @Override
    public void setBackground(Color bgColor) {
<span class="nc" id="L3822">        Color oldBg = getBackground();</span>
<span class="nc" id="L3823">        super.setBackground(bgColor);</span>
<span class="nc bnc" id="L3824" title="All 4 branches missed.">        if (oldBg != null &amp;&amp; oldBg.equals(bgColor)) {</span>
<span class="nc" id="L3825">            return;</span>
        }
<span class="nc bnc" id="L3827" title="All 2 branches missed.">        int oldAlpha = oldBg != null ? oldBg.getAlpha() : 255;</span>
<span class="nc bnc" id="L3828" title="All 2 branches missed.">        int alpha = bgColor != null ? bgColor.getAlpha() : 255;</span>
<span class="nc bnc" id="L3829" title="All 4 branches missed.">        if ((oldAlpha == 255) &amp;&amp; (alpha &lt; 255)) { // non-opaque window</span>
<span class="nc" id="L3830">            GraphicsConfiguration gc = getGraphicsConfiguration();</span>
<span class="nc" id="L3831">            GraphicsDevice gd = gc.getDevice();</span>
<span class="nc bnc" id="L3832" title="All 2 branches missed.">            if (gc.getDevice().getFullScreenWindow() == this) {</span>
<span class="nc" id="L3833">                throw new IllegalComponentStateException(</span>
                    &quot;Making full-screen window non opaque is not supported.&quot;);
            }
<span class="nc bnc" id="L3836" title="All 2 branches missed.">            if (!gc.isTranslucencyCapable()) {</span>
<span class="nc" id="L3837">                GraphicsConfiguration capableGC = gd.getTranslucencyCapableGC();</span>
<span class="nc bnc" id="L3838" title="All 2 branches missed.">                if (capableGC == null) {</span>
<span class="nc" id="L3839">                    throw new UnsupportedOperationException(</span>
                        &quot;PERPIXEL_TRANSLUCENT translucency is not supported&quot;);
                }
<span class="nc" id="L3842">                setGraphicsConfiguration(capableGC);</span>
            }
<span class="nc" id="L3844">            setLayersOpaque(this, false);</span>
<span class="nc bnc" id="L3845" title="All 4 branches missed.">        } else if ((oldAlpha &lt; 255) &amp;&amp; (alpha == 255)) {</span>
<span class="nc" id="L3846">            setLayersOpaque(this, true);</span>
        }
<span class="nc" id="L3848">        WindowPeer peer = (WindowPeer)getPeer();</span>
<span class="nc bnc" id="L3849" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc bnc" id="L3850" title="All 2 branches missed.">            peer.setOpaque(alpha == 255);</span>
        }
<span class="nc" id="L3852">    }</span>

    /**
     * Indicates if the window is currently opaque.
     * &lt;p&gt;
     * The method returns {@code false} if the background color of the window
     * is not {@code null} and the alpha component of the color is less than
     * {@code 1.0f}. The method returns {@code true} otherwise.
     *
     * @return {@code true} if the window is opaque, {@code false} otherwise
     *
     * @see Window#getBackground
     * @see Window#setBackground(Color)
     * @since 1.7
     */
    @Override
    public boolean isOpaque() {
<span class="nc" id="L3869">        Color bg = getBackground();</span>
<span class="nc bnc" id="L3870" title="All 4 branches missed.">        return bg != null ? bg.getAlpha() == 255 : true;</span>
    }

    private void updateWindow() {
<span class="nc" id="L3874">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L3875">            WindowPeer peer = (WindowPeer)getPeer();</span>
<span class="nc bnc" id="L3876" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L3877">                peer.updateWindow();</span>
            }
<span class="nc" id="L3879">        }</span>
<span class="nc" id="L3880">    }</span>

    /**
     * {@inheritDoc}
     *
     * @since 1.7
     */
    @Override
    public void paint(Graphics g) {
<span class="nc bnc" id="L3889" title="All 2 branches missed.">        if (!isOpaque()) {</span>
<span class="nc" id="L3890">            Graphics gg = g.create();</span>
            try {
<span class="nc bnc" id="L3892" title="All 2 branches missed.">                if (gg instanceof Graphics2D) {</span>
<span class="nc" id="L3893">                    gg.setColor(getBackground());</span>
<span class="nc" id="L3894">                    ((Graphics2D)gg).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));</span>
<span class="nc" id="L3895">                    gg.fillRect(0, 0, getWidth(), getHeight());</span>
                }
            } finally {
<span class="nc" id="L3898">                gg.dispose();</span>
<span class="nc" id="L3899">            }</span>
        }
<span class="nc" id="L3901">        super.paint(g);</span>
<span class="nc" id="L3902">    }</span>

    private static void setLayersOpaque(Component component, boolean isOpaque) {
        // Shouldn't use instanceof to avoid loading Swing classes
        //    if it's a pure AWT application.
<span class="nc bnc" id="L3907" title="All 2 branches missed.">        if (SunToolkit.isInstanceOf(component, &quot;javax.swing.RootPaneContainer&quot;)) {</span>
<span class="nc" id="L3908">            javax.swing.RootPaneContainer rpc = (javax.swing.RootPaneContainer)component;</span>
<span class="nc" id="L3909">            javax.swing.JRootPane root = rpc.getRootPane();</span>
<span class="nc" id="L3910">            javax.swing.JLayeredPane lp = root.getLayeredPane();</span>
<span class="nc" id="L3911">            Container c = root.getContentPane();</span>
<span class="nc bnc" id="L3912" title="All 2 branches missed.">            javax.swing.JComponent content =</span>
                (c instanceof javax.swing.JComponent) ? (javax.swing.JComponent)c : null;
<span class="nc" id="L3914">            lp.setOpaque(isOpaque);</span>
<span class="nc" id="L3915">            root.setOpaque(isOpaque);</span>
<span class="nc bnc" id="L3916" title="All 2 branches missed.">            if (content != null) {</span>
<span class="nc" id="L3917">                content.setOpaque(isOpaque);</span>

                // Iterate down one level to see whether we have a JApplet
                // (which is also a RootPaneContainer) which requires processing
<span class="nc" id="L3921">                int numChildren = content.getComponentCount();</span>
<span class="nc bnc" id="L3922" title="All 2 branches missed.">                if (numChildren &gt; 0) {</span>
<span class="nc" id="L3923">                    Component child = content.getComponent(0);</span>
                    // It's OK to use instanceof here because we've
                    // already loaded the RootPaneContainer class by now
<span class="nc bnc" id="L3926" title="All 2 branches missed.">                    if (child instanceof javax.swing.RootPaneContainer) {</span>
<span class="nc" id="L3927">                        setLayersOpaque(child, isOpaque);</span>
                    }
                }
            }
        }
<span class="nc" id="L3932">    }</span>


    // ************************** MIXING CODE *******************************

    // A window has an owner, but it does NOT have a container
    @Override
    final Container getContainer() {
<span class="nc" id="L3940">        return null;</span>
    }

    /**
     * Applies the shape to the component
     * @param shape Shape to be applied to the component
     */
    @Override
    final void applyCompoundShape(Region shape) {
        // The shape calculated by mixing code is not intended to be applied
        // to windows or frames
<span class="nc" id="L3951">    }</span>

    @Override
    final void applyCurrentShape() {
        // The shape calculated by mixing code is not intended to be applied
        // to windows or frames
<span class="nc" id="L3957">    }</span>

    @Override
    final void mixOnReshaping() {
        // The shape calculated by mixing code is not intended to be applied
        // to windows or frames
<span class="nc" id="L3963">    }</span>

    @Override
    final Point getLocationOnWindow() {
<span class="nc" id="L3967">        return new Point(0, 0);</span>
    }

    // ****************** END OF MIXING CODE ********************************

    /**
     * Limit the given double value with the given range.
     */
    private static double limit(double value, double min, double max) {
<span class="nc" id="L3976">        value = Math.max(value, min);</span>
<span class="nc" id="L3977">        value = Math.min(value, max);</span>
<span class="nc" id="L3978">        return value;</span>
    }

    /**
     * Calculate the position of the security warning.
     *
     * This method gets the window location/size as reported by the native
     * system since the locally cached values may represent outdated data.
     *
     * The method is used from the native code, or via AWTAccessor.
     *
     * NOTE: this method is invoked on the toolkit thread, and therefore is not
     * supposed to become public/user-overridable.
     */
    private Point2D calculateSecurityWarningPosition(double x, double y,
            double w, double h)
    {
        // The position according to the spec of SecurityWarning.setPosition()
<span class="nc" id="L3996">        double wx = x + w * securityWarningAlignmentX + securityWarningPointX;</span>
<span class="nc" id="L3997">        double wy = y + h * securityWarningAlignmentY + securityWarningPointY;</span>

        // First, make sure the warning is not too far from the window bounds
<span class="nc" id="L4000">        wx = Window.limit(wx,</span>
                x - securityWarningWidth - 2,
                x + w + 2);
<span class="nc" id="L4003">        wy = Window.limit(wy,</span>
                y - securityWarningHeight - 2,
                y + h + 2);

        // Now make sure the warning window is visible on the screen
<span class="nc" id="L4008">        GraphicsConfiguration graphicsConfig =</span>
<span class="nc" id="L4009">            getGraphicsConfiguration_NoClientCode();</span>
<span class="nc" id="L4010">        Rectangle screenBounds = graphicsConfig.getBounds();</span>
        Insets screenInsets =
<span class="nc" id="L4012">            Toolkit.getDefaultToolkit().getScreenInsets(graphicsConfig);</span>

<span class="nc" id="L4014">        wx = Window.limit(wx,</span>
                screenBounds.x + screenInsets.left,
                screenBounds.x + screenBounds.width - screenInsets.right
                - securityWarningWidth);
<span class="nc" id="L4018">        wy = Window.limit(wy,</span>
                screenBounds.y + screenInsets.top,
                screenBounds.y + screenBounds.height - screenInsets.bottom
                - securityWarningHeight);

<span class="nc" id="L4023">        return new Point2D.Double(wx, wy);</span>
    }

    static {
<span class="fc" id="L4027">        AWTAccessor.setWindowAccessor(new AWTAccessor.WindowAccessor() {</span>
            public float getOpacity(Window window) {
<span class="nc" id="L4029">                return window.opacity;</span>
            }
            public void setOpacity(Window window, float opacity) {
<span class="nc" id="L4032">                window.setOpacity(opacity);</span>
<span class="nc" id="L4033">            }</span>
            public Shape getShape(Window window) {
<span class="nc" id="L4035">                return window.getShape();</span>
            }
            public void setShape(Window window, Shape shape) {
<span class="nc" id="L4038">                window.setShape(shape);</span>
<span class="nc" id="L4039">            }</span>
            public void setOpaque(Window window, boolean opaque) {
<span class="nc" id="L4041">                Color bg = window.getBackground();</span>
<span class="nc bnc" id="L4042" title="All 2 branches missed.">                if (bg == null) {</span>
<span class="nc" id="L4043">                    bg = new Color(0, 0, 0, 0);</span>
                }
<span class="nc bnc" id="L4045" title="All 2 branches missed.">                window.setBackground(new Color(bg.getRed(), bg.getGreen(), bg.getBlue(),</span>
                                               opaque ? 255 : 0));
<span class="nc" id="L4047">            }</span>
            public void updateWindow(Window window) {
<span class="nc" id="L4049">                window.updateWindow();</span>
<span class="nc" id="L4050">            }</span>

            public Dimension getSecurityWarningSize(Window window) {
<span class="nc" id="L4053">                return new Dimension(window.securityWarningWidth,</span>
<span class="nc" id="L4054">                        window.securityWarningHeight);</span>
            }

            public void setSecurityWarningSize(Window window, int width, int height)
            {
<span class="nc" id="L4059">                window.securityWarningWidth = width;</span>
<span class="nc" id="L4060">                window.securityWarningHeight = height;</span>
<span class="nc" id="L4061">            }</span>

            public void setSecurityWarningPosition(Window window,
                    Point2D point, float alignmentX, float alignmentY)
            {
<span class="nc" id="L4066">                window.securityWarningPointX = point.getX();</span>
<span class="nc" id="L4067">                window.securityWarningPointY = point.getY();</span>
<span class="nc" id="L4068">                window.securityWarningAlignmentX = alignmentX;</span>
<span class="nc" id="L4069">                window.securityWarningAlignmentY = alignmentY;</span>

<span class="nc" id="L4071">                synchronized (window.getTreeLock()) {</span>
<span class="nc" id="L4072">                    WindowPeer peer = (WindowPeer)window.getPeer();</span>
<span class="nc bnc" id="L4073" title="All 2 branches missed.">                    if (peer != null) {</span>
<span class="nc" id="L4074">                        peer.repositionSecurityWarning();</span>
                    }
<span class="nc" id="L4076">                }</span>
<span class="nc" id="L4077">            }</span>

            public Point2D calculateSecurityWarningPosition(Window window,
                    double x, double y, double w, double h)
            {
<span class="nc" id="L4082">                return window.calculateSecurityWarningPosition(x, y, w, h);</span>
            }

            public void setLWRequestStatus(Window changed, boolean status) {
<span class="nc" id="L4086">                changed.syncLWRequests = status;</span>
<span class="nc" id="L4087">            }</span>

            public boolean isAutoRequestFocus(Window w) {
<span class="nc" id="L4090">                return w.autoRequestFocus;</span>
            }

            public boolean isTrayIconWindow(Window w) {
<span class="nc" id="L4094">                return w.isTrayIconWindow;</span>
            }

            public void setTrayIconWindow(Window w, boolean isTrayIconWindow) {
<span class="nc" id="L4098">                w.isTrayIconWindow = isTrayIconWindow;</span>
<span class="nc" id="L4099">            }</span>
        }); // WindowAccessor
<span class="fc" id="L4101">    } // static</span>

    // a window doesn't need to be updated in the Z-order.
    @Override
<span class="nc" id="L4105">    void updateZOrder() {}</span>

} // class Window


/**
 * This class is no longer used, but is maintained for Serialization
 * backward-compatibility.
 */
<span class="nc" id="L4114">class FocusManager implements java.io.Serializable {</span>
    Container focusRoot;
    Component focusOwner;

    /*
     * JDK 1.1 serialVersionUID
     */
    static final long serialVersionUID = 2491878825643557906L;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>