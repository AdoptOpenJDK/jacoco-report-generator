<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Component.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">Component.java</span></div><h1>Component.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt;

import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.Vector;
import java.util.Locale;
import java.util.EventListener;
import java.util.Iterator;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.Collections;
import java.awt.peer.ComponentPeer;
import java.awt.peer.ContainerPeer;
import java.awt.peer.LightweightPeer;
import java.awt.image.BufferStrategy;
import java.awt.image.ImageObserver;
import java.awt.image.ImageProducer;
import java.awt.image.ColorModel;
import java.awt.image.VolatileImage;
import java.awt.event.*;
import java.io.Serializable;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.Transient;
import java.awt.event.InputMethodListener;
import java.awt.event.InputMethodEvent;
import java.awt.im.InputContext;
import java.awt.im.InputMethodRequests;
import java.awt.dnd.DropTarget;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.AccessControlContext;
import javax.accessibility.*;
import java.applet.Applet;

import sun.security.action.GetPropertyAction;
import sun.awt.AppContext;
import sun.awt.AWTAccessor;
import sun.awt.ConstrainableGraphics;
import sun.awt.SubRegionShowable;
import sun.awt.SunToolkit;
import sun.awt.WindowClosingListener;
import sun.awt.CausedFocusEvent;
import sun.awt.EmbeddedFrame;
import sun.awt.dnd.SunDropTargetEvent;
import sun.awt.im.CompositionArea;
import sun.font.FontManager;
import sun.font.FontManagerFactory;
import sun.font.SunFontManager;
import sun.java2d.SunGraphics2D;
import sun.java2d.pipe.Region;
import sun.awt.image.VSyncedBSManager;
import sun.java2d.pipe.hw.ExtendedBufferCapabilities;
import static sun.java2d.pipe.hw.ExtendedBufferCapabilities.VSyncType.*;
import sun.awt.RequestFocusController;
import sun.java2d.SunGraphicsEnvironment;
import sun.util.logging.PlatformLogger;

/**
 * A &lt;em&gt;component&lt;/em&gt; is an object having a graphical representation
 * that can be displayed on the screen and that can interact with the
 * user. Examples of components are the buttons, checkboxes, and scrollbars
 * of a typical graphical user interface. &lt;p&gt;
 * The &lt;code&gt;Component&lt;/code&gt; class is the abstract superclass of
 * the nonmenu-related Abstract Window Toolkit components. Class
 * &lt;code&gt;Component&lt;/code&gt; can also be extended directly to create a
 * lightweight component. A lightweight component is a component that is
 * not associated with a native window. On the contrary, a heavyweight
 * component is associated with a native window. The {@link #isLightweight()}
 * method may be used to distinguish between the two kinds of the components.
 * &lt;p&gt;
 * Lightweight and heavyweight components may be mixed in a single component
 * hierarchy. However, for correct operating of such a mixed hierarchy of
 * components, the whole hierarchy must be valid. When the hierarchy gets
 * invalidated, like after changing the bounds of components, or
 * adding/removing components to/from containers, the whole hierarchy must be
 * validated afterwards by means of the {@link Container#validate()} method
 * invoked on the top-most invalid container of the hierarchy.
 * &lt;p&gt;
 * &lt;h3&gt;Serialization&lt;/h3&gt;
 * It is important to note that only AWT listeners which conform
 * to the &lt;code&gt;Serializable&lt;/code&gt; protocol will be saved when
 * the object is stored.  If an AWT object has listeners that
 * aren't marked serializable, they will be dropped at
 * &lt;code&gt;writeObject&lt;/code&gt; time.  Developers will need, as always,
 * to consider the implications of making an object serializable.
 * One situation to watch out for is this:
 * &lt;pre&gt;
 *    import java.awt.*;
 *    import java.awt.event.*;
 *    import java.io.Serializable;
 *
 *    class MyApp implements ActionListener, Serializable
 *    {
 *        BigObjectThatShouldNotBeSerializedWithAButton bigOne;
 *        Button aButton = new Button();
 *
 *        MyApp()
 *        {
 *            // Oops, now aButton has a listener with a reference
 *            // to bigOne!
 *            aButton.addActionListener(this);
 *        }
 *
 *        public void actionPerformed(ActionEvent e)
 *        {
 *            System.out.println(&quot;Hello There&quot;);
 *        }
 *    }
 * &lt;/pre&gt;
 * In this example, serializing &lt;code&gt;aButton&lt;/code&gt; by itself
 * will cause &lt;code&gt;MyApp&lt;/code&gt; and everything it refers to
 * to be serialized as well.  The problem is that the listener
 * is serializable by coincidence, not by design.  To separate
 * the decisions about &lt;code&gt;MyApp&lt;/code&gt; and the
 * &lt;code&gt;ActionListener&lt;/code&gt; being serializable one can use a
 * nested class, as in the following example:
 * &lt;pre&gt;
 *    import java.awt.*;
 *    import java.awt.event.*;
 *    import java.io.Serializable;
 *
 *    class MyApp implements java.io.Serializable
 *    {
 *         BigObjectThatShouldNotBeSerializedWithAButton bigOne;
 *         Button aButton = new Button();
 *
 *         static class MyActionListener implements ActionListener
 *         {
 *             public void actionPerformed(ActionEvent e)
 *             {
 *                 System.out.println(&quot;Hello There&quot;);
 *             }
 *         }
 *
 *         MyApp()
 *         {
 *             aButton.addActionListener(new MyActionListener());
 *         }
 *    }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
 * by AWT and Swing, including information on how to write the most
 * efficient painting code, see
 * &lt;a href=&quot;http://www.oracle.com/technetwork/java/painting-140037.html&quot;&gt;Painting in AWT and Swing&lt;/a&gt;.
 * &lt;p&gt;
 * For details on the focus subsystem, see
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
 * How to Use the Focus Subsystem&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
 * &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
 * for more information.
 *
 * @author      Arthur van Hoff
 * @author      Sami Shaio
 */
<span class="fc bfc" id="L188" title="All 2 branches covered.">public abstract class Component implements ImageObserver, MenuContainer,</span>
                                           Serializable
{

<span class="fc" id="L192">    private static final PlatformLogger log = PlatformLogger.getLogger(&quot;java.awt.Component&quot;);</span>
<span class="fc" id="L193">    private static final PlatformLogger eventLog = PlatformLogger.getLogger(&quot;java.awt.event.Component&quot;);</span>
<span class="fc" id="L194">    private static final PlatformLogger focusLog = PlatformLogger.getLogger(&quot;java.awt.focus.Component&quot;);</span>
<span class="fc" id="L195">    private static final PlatformLogger mixingLog = PlatformLogger.getLogger(&quot;java.awt.mixing.Component&quot;);</span>

    /**
     * The peer of the component. The peer implements the component's
     * behavior. The peer is set when the &lt;code&gt;Component&lt;/code&gt; is
     * added to a container that also is a peer.
     * @see #addNotify
     * @see #removeNotify
     */
    transient ComponentPeer peer;

    /**
     * The parent of the object. It may be &lt;code&gt;null&lt;/code&gt;
     * for top-level components.
     * @see #getParent
     */
    transient Container parent;

    /**
     * The &lt;code&gt;AppContext&lt;/code&gt; of the component. Applets/Plugin may
     * change the AppContext.
     */
    transient AppContext appContext;

    /**
     * The x position of the component in the parent's coordinate system.
     *
     * @serial
     * @see #getLocation
     */
    int x;

    /**
     * The y position of the component in the parent's coordinate system.
     *
     * @serial
     * @see #getLocation
     */
    int y;

    /**
     * The width of the component.
     *
     * @serial
     * @see #getSize
     */
    int width;

    /**
     * The height of the component.
     *
     * @serial
     * @see #getSize
     */
    int height;

    /**
     * The foreground color for this component.
     * &lt;code&gt;foreground&lt;/code&gt; can be &lt;code&gt;null&lt;/code&gt;.
     *
     * @serial
     * @see #getForeground
     * @see #setForeground
     */
    Color       foreground;

    /**
     * The background color for this component.
     * &lt;code&gt;background&lt;/code&gt; can be &lt;code&gt;null&lt;/code&gt;.
     *
     * @serial
     * @see #getBackground
     * @see #setBackground
     */
    Color       background;

    /**
     * The font used by this component.
     * The &lt;code&gt;font&lt;/code&gt; can be &lt;code&gt;null&lt;/code&gt;.
     *
     * @serial
     * @see #getFont
     * @see #setFont
     */
    volatile Font font;

    /**
     * The font which the peer is currently using.
     * (&lt;code&gt;null&lt;/code&gt; if no peer exists.)
     */
    Font        peerFont;

    /**
     * The cursor displayed when pointer is over this component.
     * This value can be &lt;code&gt;null&lt;/code&gt;.
     *
     * @serial
     * @see #getCursor
     * @see #setCursor
     */
    Cursor      cursor;

    /**
     * The locale for the component.
     *
     * @serial
     * @see #getLocale
     * @see #setLocale
     */
    Locale      locale;

    /**
     * A reference to a &lt;code&gt;GraphicsConfiguration&lt;/code&gt; object
     * used to describe the characteristics of a graphics
     * destination.
     * This value can be &lt;code&gt;null&lt;/code&gt;.
     *
     * @since 1.3
     * @serial
     * @see GraphicsConfiguration
     * @see #getGraphicsConfiguration
     */
<span class="nc" id="L317">    private transient GraphicsConfiguration graphicsConfig = null;</span>

    /**
     * A reference to a &lt;code&gt;BufferStrategy&lt;/code&gt; object
     * used to manipulate the buffers on this component.
     *
     * @since 1.4
     * @see java.awt.image.BufferStrategy
     * @see #getBufferStrategy()
     */
<span class="nc" id="L327">    transient BufferStrategy bufferStrategy = null;</span>

    /**
     * True when the object should ignore all repaint events.
     *
     * @since 1.4
     * @serial
     * @see #setIgnoreRepaint
     * @see #getIgnoreRepaint
     */
<span class="nc" id="L337">    boolean ignoreRepaint = false;</span>

    /**
     * True when the object is visible. An object that is not
     * visible is not drawn on the screen.
     *
     * @serial
     * @see #isVisible
     * @see #setVisible
     */
<span class="nc" id="L347">    boolean visible = true;</span>

    /**
     * True when the object is enabled. An object that is not
     * enabled does not interact with the user.
     *
     * @serial
     * @see #isEnabled
     * @see #setEnabled
     */
<span class="nc" id="L357">    boolean enabled = true;</span>

    /**
     * True when the object is valid. An invalid object needs to
     * be layed out. This flag is set to false when the object
     * size is changed.
     *
     * @serial
     * @see #isValid
     * @see #validate
     * @see #invalidate
     */
<span class="nc" id="L369">    private volatile boolean valid = false;</span>

    /**
     * The &lt;code&gt;DropTarget&lt;/code&gt; associated with this component.
     *
     * @since 1.2
     * @serial
     * @see #setDropTarget
     * @see #getDropTarget
     */
    DropTarget dropTarget;

    /**
     * @serial
     * @see #add
     */
    Vector&lt;PopupMenu&gt; popups;

    /**
     * A component's name.
     * This field can be &lt;code&gt;null&lt;/code&gt;.
     *
     * @serial
     * @see #getName
     * @see #setName(String)
     */
    private String name;

    /**
     * A bool to determine whether the name has
     * been set explicitly. &lt;code&gt;nameExplicitlySet&lt;/code&gt; will
     * be false if the name has not been set and
     * true if it has.
     *
     * @serial
     * @see #getName
     * @see #setName(String)
     */
<span class="nc" id="L407">    private boolean nameExplicitlySet = false;</span>

    /**
     * Indicates whether this Component can be focused.
     *
     * @serial
     * @see #setFocusable
     * @see #isFocusable
     * @since 1.4
     */
<span class="nc" id="L417">    private boolean focusable = true;</span>

    private static final int FOCUS_TRAVERSABLE_UNKNOWN = 0;
    private static final int FOCUS_TRAVERSABLE_DEFAULT = 1;
    private static final int FOCUS_TRAVERSABLE_SET = 2;

    /**
     * Tracks whether this Component is relying on default focus travesability.
     *
     * @serial
     * @since 1.4
     */
<span class="nc" id="L429">    private int isFocusTraversableOverridden = FOCUS_TRAVERSABLE_UNKNOWN;</span>

    /**
     * The focus traversal keys. These keys will generate focus traversal
     * behavior for Components for which focus traversal keys are enabled. If a
     * value of null is specified for a traversal key, this Component inherits
     * that traversal key from its parent. If all ancestors of this Component
     * have null specified for that traversal key, then the current
     * KeyboardFocusManager's default traversal key is used.
     *
     * @serial
     * @see #setFocusTraversalKeys
     * @see #getFocusTraversalKeys
     * @since 1.4
     */
    Set&lt;AWTKeyStroke&gt;[] focusTraversalKeys;

<span class="fc" id="L446">    private static final String[] focusTraversalKeyPropertyNames = {</span>
        &quot;forwardFocusTraversalKeys&quot;,
        &quot;backwardFocusTraversalKeys&quot;,
        &quot;upCycleFocusTraversalKeys&quot;,
        &quot;downCycleFocusTraversalKeys&quot;
    };

    /**
     * Indicates whether focus traversal keys are enabled for this Component.
     * Components for which focus traversal keys are disabled receive key
     * events for focus traversal keys. Components for which focus traversal
     * keys are enabled do not see these events; instead, the events are
     * automatically converted to traversal operations.
     *
     * @serial
     * @see #setFocusTraversalKeysEnabled
     * @see #getFocusTraversalKeysEnabled
     * @since 1.4
     */
<span class="nc" id="L465">    private boolean focusTraversalKeysEnabled = true;</span>

    /**
     * The locking object for AWT component-tree and layout operations.
     *
     * @see #getTreeLock
     */
<span class="fc" id="L472">    static final Object LOCK = new AWTTreeLock();</span>
<span class="fc" id="L473">    static class AWTTreeLock {}</span>

    /*
     * The component's AccessControlContext.
     */
<span class="nc" id="L478">    private transient volatile AccessControlContext acc =</span>
<span class="nc" id="L479">        AccessController.getContext();</span>

    /**
     * Minimum size.
     * (This field perhaps should have been transient).
     *
     * @serial
     */
    Dimension minSize;

    /**
     * Whether or not setMinimumSize has been invoked with a non-null value.
     */
    boolean minSizeSet;

    /**
     * Preferred size.
     * (This field perhaps should have been transient).
     *
     * @serial
     */
    Dimension prefSize;

    /**
     * Whether or not setPreferredSize has been invoked with a non-null value.
     */
    boolean prefSizeSet;

    /**
     * Maximum size
     *
     * @serial
     */
    Dimension maxSize;

    /**
     * Whether or not setMaximumSize has been invoked with a non-null value.
     */
    boolean maxSizeSet;

    /**
     * The orientation for this component.
     * @see #getComponentOrientation
     * @see #setComponentOrientation
     */
<span class="nc" id="L524">    transient ComponentOrientation componentOrientation</span>
    = ComponentOrientation.UNKNOWN;

    /**
     * &lt;code&gt;newEventsOnly&lt;/code&gt; will be true if the event is
     * one of the event types enabled for the component.
     * It will then allow for normal processing to
     * continue.  If it is false the event is passed
     * to the component's parent and up the ancestor
     * tree until the event has been consumed.
     *
     * @serial
     * @see #dispatchEvent
     */
<span class="nc" id="L538">    boolean newEventsOnly = false;</span>
    transient ComponentListener componentListener;
    transient FocusListener focusListener;
    transient HierarchyListener hierarchyListener;
    transient HierarchyBoundsListener hierarchyBoundsListener;
    transient KeyListener keyListener;
    transient MouseListener mouseListener;
    transient MouseMotionListener mouseMotionListener;
    transient MouseWheelListener mouseWheelListener;
    transient InputMethodListener inputMethodListener;

<span class="nc" id="L549">    transient RuntimeException windowClosingException = null;</span>

    /** Internal, constants for serialization */
    final static String actionListenerK = &quot;actionL&quot;;
    final static String adjustmentListenerK = &quot;adjustmentL&quot;;
    final static String componentListenerK = &quot;componentL&quot;;
    final static String containerListenerK = &quot;containerL&quot;;
    final static String focusListenerK = &quot;focusL&quot;;
    final static String itemListenerK = &quot;itemL&quot;;
    final static String keyListenerK = &quot;keyL&quot;;
    final static String mouseListenerK = &quot;mouseL&quot;;
    final static String mouseMotionListenerK = &quot;mouseMotionL&quot;;
    final static String mouseWheelListenerK = &quot;mouseWheelL&quot;;
    final static String textListenerK = &quot;textL&quot;;
    final static String ownedWindowK = &quot;ownedL&quot;;
    final static String windowListenerK = &quot;windowL&quot;;
    final static String inputMethodListenerK = &quot;inputMethodL&quot;;
    final static String hierarchyListenerK = &quot;hierarchyL&quot;;
    final static String hierarchyBoundsListenerK = &quot;hierarchyBoundsL&quot;;
    final static String windowStateListenerK = &quot;windowStateL&quot;;
    final static String windowFocusListenerK = &quot;windowFocusL&quot;;

    /**
     * The &lt;code&gt;eventMask&lt;/code&gt; is ONLY set by subclasses via
     * &lt;code&gt;enableEvents&lt;/code&gt;.
     * The mask should NOT be set when listeners are registered
     * so that we can distinguish the difference between when
     * listeners request events and subclasses request them.
     * One bit is used to indicate whether input methods are
     * enabled; this bit is set by &lt;code&gt;enableInputMethods&lt;/code&gt; and is
     * on by default.
     *
     * @serial
     * @see #enableInputMethods
     * @see AWTEvent
     */
<span class="nc" id="L585">    long eventMask = AWTEvent.INPUT_METHODS_ENABLED_MASK;</span>

    /**
     * Static properties for incremental drawing.
     * @see #imageUpdate
     */
    static boolean isInc;
    static int incRate;
    static {
        /* ensure that the necessary native libraries are loaded */
<span class="fc" id="L595">        Toolkit.loadLibraries();</span>
        /* initialize JNI field and method ids */
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">        if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L598">            initIDs();</span>
        }

<span class="fc" id="L601">        String s = java.security.AccessController.doPrivileged(</span>
                                                               new GetPropertyAction(&quot;awt.image.incrementaldraw&quot;));
<span class="pc bpc" id="L603" title="3 of 4 branches missed.">        isInc = (s == null || s.equals(&quot;true&quot;));</span>

<span class="fc" id="L605">        s = java.security.AccessController.doPrivileged(</span>
                                                        new GetPropertyAction(&quot;awt.image.redrawrate&quot;));
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">        incRate = (s != null) ? Integer.parseInt(s) : 100;</span>
    }

    /**
     * Ease-of-use constant for &lt;code&gt;getAlignmentY()&lt;/code&gt;.
     * Specifies an alignment to the top of the component.
     * @see     #getAlignmentY
     */
    public static final float TOP_ALIGNMENT = 0.0f;

    /**
     * Ease-of-use constant for &lt;code&gt;getAlignmentY&lt;/code&gt; and
     * &lt;code&gt;getAlignmentX&lt;/code&gt;. Specifies an alignment to
     * the center of the component
     * @see     #getAlignmentX
     * @see     #getAlignmentY
     */
    public static final float CENTER_ALIGNMENT = 0.5f;

    /**
     * Ease-of-use constant for &lt;code&gt;getAlignmentY&lt;/code&gt;.
     * Specifies an alignment to the bottom of the component.
     * @see     #getAlignmentY
     */
    public static final float BOTTOM_ALIGNMENT = 1.0f;

    /**
     * Ease-of-use constant for &lt;code&gt;getAlignmentX&lt;/code&gt;.
     * Specifies an alignment to the left side of the component.
     * @see     #getAlignmentX
     */
    public static final float LEFT_ALIGNMENT = 0.0f;

    /**
     * Ease-of-use constant for &lt;code&gt;getAlignmentX&lt;/code&gt;.
     * Specifies an alignment to the right side of the component.
     * @see     #getAlignmentX
     */
    public static final float RIGHT_ALIGNMENT = 1.0f;

    /*
     * JDK 1.1 serialVersionUID
     */
    private static final long serialVersionUID = -7644114512714619750L;

    /**
     * If any &lt;code&gt;PropertyChangeListeners&lt;/code&gt; have been registered,
     * the &lt;code&gt;changeSupport&lt;/code&gt; field describes them.
     *
     * @serial
     * @since 1.2
     * @see #addPropertyChangeListener
     * @see #removePropertyChangeListener
     * @see #firePropertyChange
     */
    private PropertyChangeSupport changeSupport;

    /*
     * In some cases using &quot;this&quot; as an object to synchronize by
     * can lead to a deadlock if client code also uses synchronization
     * by a component object. For every such situation revealed we should
     * consider possibility of replacing &quot;this&quot; with the package private
     * objectLock object introduced below. So far there're 3 issues known:
     * - CR 6708322 (the getName/setName methods);
     * - CR 6608764 (the PropertyChangeListener machinery);
     * - CR 7108598 (the Container.paint/KeyboardFocusManager.clearMostRecentFocusOwner methods).
     *
     * Note: this field is considered final, though readObject() prohibits
     * initializing final fields.
     */
<span class="nc" id="L677">    private transient Object objectLock = new Object();</span>
    Object getObjectLock() {
<span class="nc" id="L679">        return objectLock;</span>
    }

    /*
     * Returns the acc this component was constructed with.
     */
    final AccessControlContext getAccessControlContext() {
<span class="nc bnc" id="L686" title="All 2 branches missed.">        if (acc == null) {</span>
<span class="nc" id="L687">            throw new SecurityException(&quot;Component is missing AccessControlContext&quot;);</span>
        }
<span class="nc" id="L689">        return acc;</span>
    }

<span class="nc" id="L692">    boolean isPacked = false;</span>

    /**
     * Pseudoparameter for direct Geometry API (setLocation, setBounds setSize
     * to signal setBounds what's changing. Should be used under TreeLock.
     * This is only needed due to the inability to change the cross-calling
     * order of public and deprecated methods.
     */
<span class="nc" id="L700">    private int boundsOp = ComponentPeer.DEFAULT_OPERATION;</span>

    /**
     * Enumeration of the common ways the baseline of a component can
     * change as the size changes.  The baseline resize behavior is
     * primarily for layout managers that need to know how the
     * position of the baseline changes as the component size changes.
     * In general the baseline resize behavior will be valid for sizes
     * greater than or equal to the minimum size (the actual minimum
     * size; not a developer specified minimum size).  For sizes
     * smaller than the minimum size the baseline may change in a way
     * other than the baseline resize behavior indicates.  Similarly,
     * as the size approaches &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; and/or
     * &lt;code&gt;Short.MAX_VALUE&lt;/code&gt; the baseline may change in a way
     * other than the baseline resize behavior indicates.
     *
     * @see #getBaselineResizeBehavior
     * @see #getBaseline(int,int)
     * @since 1.6
     */
<span class="nc" id="L720">    public enum BaselineResizeBehavior {</span>
        /**
         * Indicates the baseline remains fixed relative to the
         * y-origin.  That is, &lt;code&gt;getBaseline&lt;/code&gt; returns
         * the same value regardless of the height or width.  For example, a
         * &lt;code&gt;JLabel&lt;/code&gt; containing non-empty text with a
         * vertical alignment of &lt;code&gt;TOP&lt;/code&gt; should have a
         * baseline type of &lt;code&gt;CONSTANT_ASCENT&lt;/code&gt;.
         */
<span class="nc" id="L729">        CONSTANT_ASCENT,</span>

        /**
         * Indicates the baseline remains fixed relative to the height
         * and does not change as the width is varied.  That is, for
         * any height H the difference between H and
         * &lt;code&gt;getBaseline(w, H)&lt;/code&gt; is the same.  For example, a
         * &lt;code&gt;JLabel&lt;/code&gt; containing non-empty text with a
         * vertical alignment of &lt;code&gt;BOTTOM&lt;/code&gt; should have a
         * baseline type of &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt;.
         */
<span class="nc" id="L740">        CONSTANT_DESCENT,</span>

        /**
         * Indicates the baseline remains a fixed distance from
         * the center of the component.  That is, for any height H the
         * difference between &lt;code&gt;getBaseline(w, H)&lt;/code&gt; and
         * &lt;code&gt;H / 2&lt;/code&gt; is the same (plus or minus one depending upon
         * rounding error).
         * &lt;p&gt;
         * Because of possible rounding errors it is recommended
         * you ask for the baseline with two consecutive heights and use
         * the return value to determine if you need to pad calculations
         * by 1.  The following shows how to calculate the baseline for
         * any height:
         * &lt;pre&gt;
         *   Dimension preferredSize = component.getPreferredSize();
         *   int baseline = getBaseline(preferredSize.width,
         *                              preferredSize.height);
         *   int nextBaseline = getBaseline(preferredSize.width,
         *                                  preferredSize.height + 1);
         *   // Amount to add to height when calculating where baseline
         *   // lands for a particular height:
         *   int padding = 0;
         *   // Where the baseline is relative to the mid point
         *   int baselineOffset = baseline - height / 2;
         *   if (preferredSize.height % 2 == 0 &amp;amp;&amp;amp;
         *       baseline != nextBaseline) {
         *       padding = 1;
         *   }
         *   else if (preferredSize.height % 2 == 1 &amp;amp;&amp;amp;
         *            baseline == nextBaseline) {
         *       baselineOffset--;
         *       padding = 1;
         *   }
         *   // The following calculates where the baseline lands for
         *   // the height z:
         *   int calculatedBaseline = (z + padding) / 2 + baselineOffset;
         * &lt;/pre&gt;
         */
<span class="nc" id="L779">        CENTER_OFFSET,</span>

        /**
         * Indicates the baseline resize behavior can not be expressed using
         * any of the other constants.  This may also indicate the baseline
         * varies with the width of the component.  This is also returned
         * by components that do not have a baseline.
         */
<span class="nc" id="L787">        OTHER</span>
    }

    /*
     * The shape set with the applyCompoundShape() method. It uncludes the result
     * of the HW/LW mixing related shape computation. It may also include
     * the user-specified shape of the component.
     * The 'null' value means the component has normal shape (or has no shape at all)
     * and applyCompoundShape() will skip the following shape identical to normal.
     */
<span class="nc" id="L797">    private transient Region compoundShape = null;</span>

    /*
     * Represents the shape of this lightweight component to be cut out from
     * heavyweight components should they intersect. Possible values:
     *    1. null - consider the shape rectangular
     *    2. EMPTY_REGION - nothing gets cut out (children still get cut out)
     *    3. non-empty - this shape gets cut out.
     */
<span class="nc" id="L806">    private transient Region mixingCutoutRegion = null;</span>

    /*
     * Indicates whether addNotify() is complete
     * (i.e. the peer is created).
     */
<span class="nc" id="L812">    private transient boolean isAddNotifyComplete = false;</span>

    /**
     * Should only be used in subclass getBounds to check that part of bounds
     * is actualy changing
     */
    int getBoundsOp() {
<span class="nc bnc" id="L819" title="All 4 branches missed.">        assert Thread.holdsLock(getTreeLock());</span>
<span class="nc" id="L820">        return boundsOp;</span>
    }

    void setBoundsOp(int op) {
<span class="nc bnc" id="L824" title="All 4 branches missed.">        assert Thread.holdsLock(getTreeLock());</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (op == ComponentPeer.RESET_OPERATION) {</span>
<span class="nc" id="L826">            boundsOp = ComponentPeer.DEFAULT_OPERATION;</span>
        } else
<span class="nc bnc" id="L828" title="All 2 branches missed.">            if (boundsOp == ComponentPeer.DEFAULT_OPERATION) {</span>
<span class="nc" id="L829">                boundsOp = op;</span>
            }
<span class="nc" id="L831">    }</span>

    // Whether this Component has had the background erase flag
    // specified via SunToolkit.disableBackgroundErase(). This is
    // needed in order to make this function work on X11 platforms,
    // where currently there is no chance to interpose on the creation
    // of the peer and therefore the call to XSetBackground.
    transient boolean backgroundEraseDisabled;

    static {
<span class="fc" id="L841">        AWTAccessor.setComponentAccessor(new AWTAccessor.ComponentAccessor() {</span>
            public void setBackgroundEraseDisabled(Component comp, boolean disabled) {
<span class="nc" id="L843">                comp.backgroundEraseDisabled = disabled;</span>
<span class="nc" id="L844">            }</span>
            public boolean getBackgroundEraseDisabled(Component comp) {
<span class="nc" id="L846">                return comp.backgroundEraseDisabled;</span>
            }
            public Rectangle getBounds(Component comp) {
<span class="nc" id="L849">                return new Rectangle(comp.x, comp.y, comp.width, comp.height);</span>
            }
            public void setMixingCutoutShape(Component comp, Shape shape) {
<span class="nc bnc" id="L852" title="All 2 branches missed.">                Region region = shape == null ?  null :</span>
<span class="nc" id="L853">                    Region.getInstance(shape, null);</span>

<span class="nc" id="L855">                synchronized (comp.getTreeLock()) {</span>
<span class="nc" id="L856">                    boolean needShowing = false;</span>
<span class="nc" id="L857">                    boolean needHiding = false;</span>

<span class="nc bnc" id="L859" title="All 2 branches missed.">                    if (!comp.isNonOpaqueForMixing()) {</span>
<span class="nc" id="L860">                        needHiding = true;</span>
                    }

<span class="nc" id="L863">                    comp.mixingCutoutRegion = region;</span>

<span class="nc bnc" id="L865" title="All 2 branches missed.">                    if (!comp.isNonOpaqueForMixing()) {</span>
<span class="nc" id="L866">                        needShowing = true;</span>
                    }

<span class="nc bnc" id="L869" title="All 2 branches missed.">                    if (comp.isMixingNeeded()) {</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">                        if (needHiding) {</span>
<span class="nc" id="L871">                            comp.mixOnHiding(comp.isLightweight());</span>
                        }
<span class="nc bnc" id="L873" title="All 2 branches missed.">                        if (needShowing) {</span>
<span class="nc" id="L874">                            comp.mixOnShowing();</span>
                        }
                    }
<span class="nc" id="L877">                }</span>
<span class="nc" id="L878">            }</span>

            public void setGraphicsConfiguration(Component comp,
                    GraphicsConfiguration gc)
            {
<span class="nc" id="L883">                comp.setGraphicsConfiguration(gc);</span>
<span class="nc" id="L884">            }</span>
            public boolean requestFocus(Component comp, CausedFocusEvent.Cause cause) {
<span class="nc" id="L886">                return comp.requestFocus(cause);</span>
            }
            public boolean canBeFocusOwner(Component comp) {
<span class="nc" id="L889">                return comp.canBeFocusOwner();</span>
            }

            public boolean isVisible(Component comp) {
<span class="nc" id="L893">                return comp.isVisible_NoClientCode();</span>
            }
            public void setRequestFocusController
                (RequestFocusController requestController)
            {
<span class="fc" id="L898">                 Component.setRequestFocusController(requestController);</span>
<span class="fc" id="L899">            }</span>
            public AppContext getAppContext(Component comp) {
<span class="nc" id="L901">                 return comp.appContext;</span>
            }
            public void setAppContext(Component comp, AppContext appContext) {
<span class="nc" id="L904">                 comp.appContext = appContext;</span>
<span class="nc" id="L905">            }</span>
            public Container getParent(Component comp) {
<span class="nc" id="L907">                return comp.getParent_NoClientCode();</span>
            }
            public void setParent(Component comp, Container parent) {
<span class="nc" id="L910">                comp.parent = parent;</span>
<span class="nc" id="L911">            }</span>
            public void setSize(Component comp, int width, int height) {
<span class="nc" id="L913">                comp.width = width;</span>
<span class="nc" id="L914">                comp.height = height;</span>
<span class="nc" id="L915">            }</span>
            public Point getLocation(Component comp) {
<span class="nc" id="L917">                return comp.location_NoClientCode();</span>
            }
            public void setLocation(Component comp, int x, int y) {
<span class="nc" id="L920">                comp.x = x;</span>
<span class="nc" id="L921">                comp.y = y;</span>
<span class="nc" id="L922">            }</span>
            public boolean isEnabled(Component comp) {
<span class="nc" id="L924">                return comp.isEnabledImpl();</span>
            }
            public boolean isDisplayable(Component comp) {
<span class="nc bnc" id="L927" title="All 2 branches missed.">                return comp.peer != null;</span>
            }
            public Cursor getCursor(Component comp) {
<span class="nc" id="L930">                return comp.getCursor_NoClientCode();</span>
            }
            public ComponentPeer getPeer(Component comp) {
<span class="nc" id="L933">                return comp.peer;</span>
            }
            public void setPeer(Component comp, ComponentPeer peer) {
<span class="nc" id="L936">                comp.peer = peer;</span>
<span class="nc" id="L937">            }</span>
            public boolean isLightweight(Component comp) {
<span class="nc" id="L939">                return (comp.peer instanceof LightweightPeer);</span>
            }
            public boolean getIgnoreRepaint(Component comp) {
<span class="nc" id="L942">                return comp.ignoreRepaint;</span>
            }
            public int getWidth(Component comp) {
<span class="nc" id="L945">                return comp.width;</span>
            }
            public int getHeight(Component comp) {
<span class="nc" id="L948">                return comp.height;</span>
            }
            public int getX(Component comp) {
<span class="nc" id="L951">                return comp.x;</span>
            }
            public int getY(Component comp) {
<span class="nc" id="L954">                return comp.y;</span>
            }
            public Color getForeground(Component comp) {
<span class="nc" id="L957">                return comp.foreground;</span>
            }
            public Color getBackground(Component comp) {
<span class="nc" id="L960">                return comp.background;</span>
            }
            public void setBackground(Component comp, Color background) {
<span class="nc" id="L963">                comp.background = background;</span>
<span class="nc" id="L964">            }</span>
            public Font getFont(Component comp) {
<span class="nc" id="L966">                return comp.getFont_NoClientCode();</span>
            }
            public void processEvent(Component comp, AWTEvent e) {
<span class="nc" id="L969">                comp.processEvent(e);</span>
<span class="nc" id="L970">            }</span>

            public AccessControlContext getAccessControlContext(Component comp) {
<span class="nc" id="L973">                return comp.getAccessControlContext();</span>
            }

            public void revalidateSynchronously(Component comp) {
<span class="nc" id="L977">                comp.revalidateSynchronously();</span>
<span class="nc" id="L978">            }</span>
        });
    }

    /**
     * Constructs a new component. Class &lt;code&gt;Component&lt;/code&gt; can be
     * extended directly to create a lightweight component that does not
     * utilize an opaque native window. A lightweight component must be
     * hosted by a native container somewhere higher up in the component
     * tree (for example, by a &lt;code&gt;Frame&lt;/code&gt; object).
     */
<span class="nc" id="L989">    protected Component() {</span>
<span class="nc" id="L990">        appContext = AppContext.getAppContext();</span>
<span class="nc" id="L991">    }</span>

    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    void initializeFocusTraversalKeys() {
<span class="nc" id="L995">        focusTraversalKeys = new Set[3];</span>
<span class="nc" id="L996">    }</span>

    /**
     * Constructs a name for this component.  Called by &lt;code&gt;getName&lt;/code&gt;
     * when the name is &lt;code&gt;null&lt;/code&gt;.
     */
    String constructComponentName() {
<span class="nc" id="L1003">        return null; // For strict compliance with prior platform versions, a Component</span>
                     // that doesn't set its name should return null from
                     // getName()
    }

    /**
     * Gets the name of the component.
     * @return this component's name
     * @see    #setName
     * @since JDK1.1
     */
    public String getName() {
<span class="nc bnc" id="L1015" title="All 4 branches missed.">        if (name == null &amp;&amp; !nameExplicitlySet) {</span>
<span class="nc" id="L1016">            synchronized(getObjectLock()) {</span>
<span class="nc bnc" id="L1017" title="All 4 branches missed.">                if (name == null &amp;&amp; !nameExplicitlySet)</span>
<span class="nc" id="L1018">                    name = constructComponentName();</span>
<span class="nc" id="L1019">            }</span>
        }
<span class="nc" id="L1021">        return name;</span>
    }

    /**
     * Sets the name of the component to the specified string.
     * @param name  the string that is to be this
     *           component's name
     * @see #getName
     * @since JDK1.1
     */
    public void setName(String name) {
        String oldName;
<span class="nc" id="L1033">        synchronized(getObjectLock()) {</span>
<span class="nc" id="L1034">            oldName = this.name;</span>
<span class="nc" id="L1035">            this.name = name;</span>
<span class="nc" id="L1036">            nameExplicitlySet = true;</span>
<span class="nc" id="L1037">        }</span>
<span class="nc" id="L1038">        firePropertyChange(&quot;name&quot;, oldName, name);</span>
<span class="nc" id="L1039">    }</span>

    /**
     * Gets the parent of this component.
     * @return the parent container of this component
     * @since JDK1.0
     */
    public Container getParent() {
<span class="nc" id="L1047">        return getParent_NoClientCode();</span>
    }

    // NOTE: This method may be called by privileged threads.
    //       This functionality is implemented in a package-private method
    //       to insure that it cannot be overridden by client subclasses.
    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
    final Container getParent_NoClientCode() {
<span class="nc" id="L1055">        return parent;</span>
    }

    // This method is overridden in the Window class to return null,
    //    because the parent field of the Window object contains
    //    the owner of the window, not its parent.
    Container getContainer() {
<span class="nc" id="L1062">        return getParent_NoClientCode();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * programs should not directly manipulate peers;
     * replaced by &lt;code&gt;boolean isDisplayable()&lt;/code&gt;.
     */
    @Deprecated
    public ComponentPeer getPeer() {
<span class="nc" id="L1072">        return peer;</span>
    }

    /**
     * Associate a &lt;code&gt;DropTarget&lt;/code&gt; with this component.
     * The &lt;code&gt;Component&lt;/code&gt; will receive drops only if it
     * is enabled.
     *
     * @see #isEnabled
     * @param dt The DropTarget
     */

    public synchronized void setDropTarget(DropTarget dt) {
<span class="nc bnc" id="L1085" title="All 6 branches missed.">        if (dt == dropTarget || (dropTarget != null &amp;&amp; dropTarget.equals(dt)))</span>
<span class="nc" id="L1086">            return;</span>

        DropTarget old;

<span class="nc bnc" id="L1090" title="All 2 branches missed.">        if ((old = dropTarget) != null) {</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">            if (peer != null) dropTarget.removeNotify(peer);</span>

<span class="nc" id="L1093">            DropTarget t = dropTarget;</span>

<span class="nc" id="L1095">            dropTarget = null;</span>

            try {
<span class="nc" id="L1098">                t.setComponent(null);</span>
<span class="nc" id="L1099">            } catch (IllegalArgumentException iae) {</span>
                // ignore it.
<span class="nc" id="L1101">            }</span>
        }

        // if we have a new one, and we have a peer, add it!

<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if ((dropTarget = dt) != null) {</span>
            try {
<span class="nc" id="L1108">                dropTarget.setComponent(this);</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">                if (peer != null) dropTarget.addNotify(peer);</span>
<span class="nc" id="L1110">            } catch (IllegalArgumentException iae) {</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">                if (old != null) {</span>
                    try {
<span class="nc" id="L1113">                        old.setComponent(this);</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">                        if (peer != null) dropTarget.addNotify(peer);</span>
<span class="nc" id="L1115">                    } catch (IllegalArgumentException iae1) {</span>
                        // ignore it!
<span class="nc" id="L1117">                    }</span>
                }
<span class="nc" id="L1119">            }</span>
        }
<span class="nc" id="L1121">    }</span>

    /**
     * Gets the &lt;code&gt;DropTarget&lt;/code&gt; associated with this
     * &lt;code&gt;Component&lt;/code&gt;.
     */

<span class="nc" id="L1128">    public synchronized DropTarget getDropTarget() { return dropTarget; }</span>

    /**
     * Gets the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; associated with this
     * &lt;code&gt;Component&lt;/code&gt;.
     * If the &lt;code&gt;Component&lt;/code&gt; has not been assigned a specific
     * &lt;code&gt;GraphicsConfiguration&lt;/code&gt;,
     * the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; of the
     * &lt;code&gt;Component&lt;/code&gt; object's top-level container is
     * returned.
     * If the &lt;code&gt;Component&lt;/code&gt; has been created, but not yet added
     * to a &lt;code&gt;Container&lt;/code&gt;, this method returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; used by this
     *          &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;
     * @since 1.3
     */
    public GraphicsConfiguration getGraphicsConfiguration() {
<span class="nc" id="L1146">        synchronized(getTreeLock()) {</span>
<span class="nc" id="L1147">            return getGraphicsConfiguration_NoClientCode();</span>
<span class="nc" id="L1148">        }</span>
    }

    final GraphicsConfiguration getGraphicsConfiguration_NoClientCode() {
<span class="nc" id="L1152">        return graphicsConfig;</span>
    }

    void setGraphicsConfiguration(GraphicsConfiguration gc) {
<span class="nc" id="L1156">        synchronized(getTreeLock()) {</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">            if (updateGraphicsData(gc)) {</span>
<span class="nc" id="L1158">                removeNotify();</span>
<span class="nc" id="L1159">                addNotify();</span>
            }
<span class="nc" id="L1161">        }</span>
<span class="nc" id="L1162">    }</span>

    boolean updateGraphicsData(GraphicsConfiguration gc) {
<span class="nc" id="L1165">        checkTreeLock();</span>

<span class="nc bnc" id="L1167" title="All 2 branches missed.">        if (graphicsConfig == gc) {</span>
<span class="nc" id="L1168">            return false;</span>
        }

<span class="nc" id="L1171">        graphicsConfig = gc;</span>

<span class="nc" id="L1173">        ComponentPeer peer = getPeer();</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L1175">            return peer.updateGraphicsData(gc);</span>
        }
<span class="nc" id="L1177">        return false;</span>
    }

    /**
     * Checks that this component's &lt;code&gt;GraphicsDevice&lt;/code&gt;
     * &lt;code&gt;idString&lt;/code&gt; matches the string argument.
     */
    void checkGD(String stringID) {
<span class="nc bnc" id="L1185" title="All 2 branches missed.">        if (graphicsConfig != null) {</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if (!graphicsConfig.getDevice().getIDstring().equals(stringID)) {</span>
<span class="nc" id="L1187">                throw new IllegalArgumentException(</span>
                                                   &quot;adding a container to a container on a different GraphicsDevice&quot;);
            }
        }
<span class="nc" id="L1191">    }</span>

    /**
     * Gets this component's locking object (the object that owns the thread
     * synchronization monitor) for AWT component-tree and layout
     * operations.
     * @return this component's locking object
     */
    public final Object getTreeLock() {
<span class="nc" id="L1200">        return LOCK;</span>
    }

    final void checkTreeLock() {
<span class="nc bnc" id="L1204" title="All 2 branches missed.">        if (!Thread.holdsLock(getTreeLock())) {</span>
<span class="nc" id="L1205">            throw new IllegalStateException(&quot;This function should be called while holding treeLock&quot;);</span>
        }
<span class="nc" id="L1207">    }</span>

    /**
     * Gets the toolkit of this component. Note that
     * the frame that contains a component controls which
     * toolkit is used by that component. Therefore if the component
     * is moved from one frame to another, the toolkit it uses may change.
     * @return  the toolkit of this component
     * @since JDK1.0
     */
    public Toolkit getToolkit() {
<span class="nc" id="L1218">        return getToolkitImpl();</span>
    }

    /*
     * This is called by the native code, so client code can't
     * be called on the toolkit thread.
     */
    final Toolkit getToolkitImpl() {
<span class="nc" id="L1226">        Container parent = this.parent;</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L1228">            return parent.getToolkitImpl();</span>
        }
<span class="nc" id="L1230">        return Toolkit.getDefaultToolkit();</span>
    }

    /**
     * Determines whether this component is valid. A component is valid
     * when it is correctly sized and positioned within its parent
     * container and all its children are also valid.
     * In order to account for peers' size requirements, components are invalidated
     * before they are first shown on the screen. By the time the parent container
     * is fully realized, all its components will be valid.
     * @return &lt;code&gt;true&lt;/code&gt; if the component is valid, &lt;code&gt;false&lt;/code&gt;
     * otherwise
     * @see #validate
     * @see #invalidate
     * @since JDK1.0
     */
    public boolean isValid() {
<span class="nc bnc" id="L1247" title="All 4 branches missed.">        return (peer != null) &amp;&amp; valid;</span>
    }

    /**
     * Determines whether this component is displayable. A component is
     * displayable when it is connected to a native screen resource.
     * &lt;p&gt;
     * A component is made displayable either when it is added to
     * a displayable containment hierarchy or when its containment
     * hierarchy is made displayable.
     * A containment hierarchy is made displayable when its ancestor
     * window is either packed or made visible.
     * &lt;p&gt;
     * A component is made undisplayable either when it is removed from
     * a displayable containment hierarchy or when its containment hierarchy
     * is made undisplayable.  A containment hierarchy is made
     * undisplayable when its ancestor window is disposed.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the component is displayable,
     * &lt;code&gt;false&lt;/code&gt; otherwise
     * @see Container#add(Component)
     * @see Window#pack
     * @see Window#show
     * @see Container#remove(Component)
     * @see Window#dispose
     * @since 1.2
     */
    public boolean isDisplayable() {
<span class="nc bnc" id="L1275" title="All 2 branches missed.">        return getPeer() != null;</span>
    }

    /**
     * Determines whether this component should be visible when its
     * parent is visible. Components are
     * initially visible, with the exception of top level components such
     * as &lt;code&gt;Frame&lt;/code&gt; objects.
     * @return &lt;code&gt;true&lt;/code&gt; if the component is visible,
     * &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #setVisible
     * @since JDK1.0
     */
    @Transient
    public boolean isVisible() {
<span class="nc" id="L1290">        return isVisible_NoClientCode();</span>
    }
    final boolean isVisible_NoClientCode() {
<span class="nc" id="L1293">        return visible;</span>
    }

    /**
     * Determines whether this component will be displayed on the screen.
     * @return &lt;code&gt;true&lt;/code&gt; if the component and all of its ancestors
     *          until a toplevel window or null parent are visible,
     *          &lt;code&gt;false&lt;/code&gt; otherwise
     */
    boolean isRecursivelyVisible() {
<span class="nc bnc" id="L1303" title="All 6 branches missed.">        return visible &amp;&amp; (parent == null || parent.isRecursivelyVisible());</span>
    }

    /**
     * Translates absolute coordinates into coordinates in the coordinate
     * space of this component.
     */
    Point pointRelativeToComponent(Point absolute) {
<span class="nc" id="L1311">        Point compCoords = getLocationOnScreen();</span>
<span class="nc" id="L1312">        return new Point(absolute.x - compCoords.x,</span>
                         absolute.y - compCoords.y);
    }

    /**
     * Assuming that mouse location is stored in PointerInfo passed
     * to this method, it finds a Component that is in the same
     * Window as this Component and is located under the mouse pointer.
     * If no such Component exists, null is returned.
     * NOTE: this method should be called under the protection of
     * tree lock, as it is done in Component.getMousePosition() and
     * Container.getMousePosition(boolean).
     */
    Component findUnderMouseInWindow(PointerInfo pi) {
<span class="nc bnc" id="L1326" title="All 2 branches missed.">        if (!isShowing()) {</span>
<span class="nc" id="L1327">            return null;</span>
        }
<span class="nc" id="L1329">        Window win = getContainingWindow();</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">        if (!Toolkit.getDefaultToolkit().getMouseInfoPeer().isWindowUnderMouse(win)) {</span>
<span class="nc" id="L1331">            return null;</span>
        }
        final boolean INCLUDE_DISABLED = true;
<span class="nc" id="L1334">        Point relativeToWindow = win.pointRelativeToComponent(pi.getLocation());</span>
<span class="nc" id="L1335">        Component inTheSameWindow = win.findComponentAt(relativeToWindow.x,</span>
                                                        relativeToWindow.y,
                                                        INCLUDE_DISABLED);
<span class="nc" id="L1338">        return inTheSameWindow;</span>
    }

    /**
     * Returns the position of the mouse pointer in this &lt;code&gt;Component&lt;/code&gt;'s
     * coordinate space if the &lt;code&gt;Component&lt;/code&gt; is directly under the mouse
     * pointer, otherwise returns &lt;code&gt;null&lt;/code&gt;.
     * If the &lt;code&gt;Component&lt;/code&gt; is not showing on the screen, this method
     * returns &lt;code&gt;null&lt;/code&gt; even if the mouse pointer is above the area
     * where the &lt;code&gt;Component&lt;/code&gt; would be displayed.
     * If the &lt;code&gt;Component&lt;/code&gt; is partially or fully obscured by other
     * &lt;code&gt;Component&lt;/code&gt;s or native windows, this method returns a non-null
     * value only if the mouse pointer is located above the unobscured part of the
     * &lt;code&gt;Component&lt;/code&gt;.
     * &lt;p&gt;
     * For &lt;code&gt;Container&lt;/code&gt;s it returns a non-null value if the mouse is
     * above the &lt;code&gt;Container&lt;/code&gt; itself or above any of its descendants.
     * Use {@link Container#getMousePosition(boolean)} if you need to exclude children.
     * &lt;p&gt;
     * Sometimes the exact mouse coordinates are not important, and the only thing
     * that matters is whether a specific &lt;code&gt;Component&lt;/code&gt; is under the mouse
     * pointer. If the return value of this method is &lt;code&gt;null&lt;/code&gt;, mouse
     * pointer is not directly above the &lt;code&gt;Component&lt;/code&gt;.
     *
     * @exception HeadlessException if GraphicsEnvironment.isHeadless() returns true
     * @see       #isShowing
     * @see       Container#getMousePosition
     * @return    mouse coordinates relative to this &lt;code&gt;Component&lt;/code&gt;, or null
     * @since     1.5
     */
    public Point getMousePosition() throws HeadlessException {
<span class="nc bnc" id="L1369" title="All 2 branches missed.">        if (GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L1370">            throw new HeadlessException();</span>
        }

<span class="nc" id="L1373">        PointerInfo pi = java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L1374">                                                                     new java.security.PrivilegedAction&lt;PointerInfo&gt;() {</span>
                                                                         public PointerInfo run() {
<span class="nc" id="L1376">                                                                             return MouseInfo.getPointerInfo();</span>
                                                                         }
                                                                     }
                                                                     );

<span class="nc" id="L1381">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L1382">            Component inTheSameWindow = findUnderMouseInWindow(pi);</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">            if (!isSameOrAncestorOf(inTheSameWindow, true)) {</span>
<span class="nc" id="L1384">                return null;</span>
            }
<span class="nc" id="L1386">            return pointRelativeToComponent(pi.getLocation());</span>
<span class="nc" id="L1387">        }</span>
    }

    /**
     * Overridden in Container. Must be called under TreeLock.
     */
    boolean isSameOrAncestorOf(Component comp, boolean allowChildren) {
<span class="nc bnc" id="L1394" title="All 2 branches missed.">        return comp == this;</span>
    }

    /**
     * Determines whether this component is showing on screen. This means
     * that the component must be visible, and it must be in a container
     * that is visible and showing.
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; sometimes there is no way to detect whether the
     * {@code Component} is actually visible to the user.  This can happen when:
     * &lt;ul&gt;
     * &lt;li&gt;the component has been added to a visible {@code ScrollPane} but
     * the {@code Component} is not currently in the scroll pane's view port.
     * &lt;li&gt;the {@code Component} is obscured by another {@code Component} or
     * {@code Container}.
     * &lt;/ul&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the component is showing,
     *          &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #setVisible
     * @since JDK1.0
     */
    public boolean isShowing() {
<span class="nc bnc" id="L1416" title="All 4 branches missed.">        if (visible &amp;&amp; (peer != null)) {</span>
<span class="nc" id="L1417">            Container parent = this.parent;</span>
<span class="nc bnc" id="L1418" title="All 4 branches missed.">            return (parent == null) || parent.isShowing();</span>
        }
<span class="nc" id="L1420">        return false;</span>
    }

    /**
     * Determines whether this component is enabled. An enabled component
     * can respond to user input and generate events. Components are
     * enabled initially by default. A component may be enabled or disabled by
     * calling its &lt;code&gt;setEnabled&lt;/code&gt; method.
     * @return &lt;code&gt;true&lt;/code&gt; if the component is enabled,
     *          &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #setEnabled
     * @since JDK1.0
     */
    public boolean isEnabled() {
<span class="nc" id="L1434">        return isEnabledImpl();</span>
    }

    /*
     * This is called by the native code, so client code can't
     * be called on the toolkit thread.
     */
    final boolean isEnabledImpl() {
<span class="nc" id="L1442">        return enabled;</span>
    }

    /**
     * Enables or disables this component, depending on the value of the
     * parameter &lt;code&gt;b&lt;/code&gt;. An enabled component can respond to user
     * input and generate events. Components are enabled initially by default.
     *
     * &lt;p&gt;Note: Disabling a lightweight component does not prevent it from
     * receiving MouseEvents.
     * &lt;p&gt;Note: Disabling a heavyweight container prevents all components
     * in this container from receiving any input events.  But disabling a
     * lightweight container affects only this container.
     *
     * @param     b   If &lt;code&gt;true&lt;/code&gt;, this component is
     *            enabled; otherwise this component is disabled
     * @see #isEnabled
     * @see #isLightweight
     * @since JDK1.1
     */
    public void setEnabled(boolean b) {
<span class="nc" id="L1463">        enable(b);</span>
<span class="nc" id="L1464">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setEnabled(boolean)&lt;/code&gt;.
     */
    @Deprecated
    public void enable() {
<span class="nc bnc" id="L1472" title="All 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L1473">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L1474">                enabled = true;</span>
<span class="nc" id="L1475">                ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L1476" title="All 2 branches missed.">                if (peer != null) {</span>
<span class="nc" id="L1477">                    peer.setEnabled(true);</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                    if (visible) {</span>
<span class="nc" id="L1479">                        updateCursorImmediately();</span>
                    }
                }
<span class="nc" id="L1482">            }</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">            if (accessibleContext != null) {</span>
<span class="nc" id="L1484">                accessibleContext.firePropertyChange(</span>
                                                     AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                     null, AccessibleState.ENABLED);
            }
        }
<span class="nc" id="L1489">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setEnabled(boolean)&lt;/code&gt;.
     */
    @Deprecated
    public void enable(boolean b) {
<span class="nc bnc" id="L1497" title="All 2 branches missed.">        if (b) {</span>
<span class="nc" id="L1498">            enable();</span>
        } else {
<span class="nc" id="L1500">            disable();</span>
        }
<span class="nc" id="L1502">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setEnabled(boolean)&lt;/code&gt;.
     */
    @Deprecated
    public void disable() {
<span class="nc bnc" id="L1510" title="All 2 branches missed.">        if (enabled) {</span>
<span class="nc" id="L1511">            KeyboardFocusManager.clearMostRecentFocusOwner(this);</span>
<span class="nc" id="L1512">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L1513">                enabled = false;</span>
                // A disabled lw container is allowed to contain a focus owner.
<span class="nc bnc" id="L1515" title="All 6 branches missed.">                if ((isFocusOwner() || (containsFocus() &amp;&amp; !isLightweight())) &amp;&amp;</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">                    KeyboardFocusManager.isAutoFocusTransferEnabled())</span>
                {
                    // Don't clear the global focus owner. If transferFocus
                    // fails, we want the focus to stay on the disabled
                    // Component so that keyboard traversal, et. al. still
                    // makes sense to the user.
<span class="nc" id="L1522">                    transferFocus(false);</span>
                }
<span class="nc" id="L1524">                ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L1525" title="All 2 branches missed.">                if (peer != null) {</span>
<span class="nc" id="L1526">                    peer.setEnabled(false);</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">                    if (visible) {</span>
<span class="nc" id="L1528">                        updateCursorImmediately();</span>
                    }
                }
<span class="nc" id="L1531">            }</span>
<span class="nc bnc" id="L1532" title="All 2 branches missed.">            if (accessibleContext != null) {</span>
<span class="nc" id="L1533">                accessibleContext.firePropertyChange(</span>
                                                     AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                     null, AccessibleState.ENABLED);
            }
        }
<span class="nc" id="L1538">    }</span>

    /**
     * Returns true if this component is painted to an offscreen image
     * (&quot;buffer&quot;) that's copied to the screen later.  Component
     * subclasses that support double buffering should override this
     * method to return true if double buffering is enabled.
     *
     * @return false by default
     */
    public boolean isDoubleBuffered() {
<span class="nc" id="L1549">        return false;</span>
    }

    /**
     * Enables or disables input method support for this component. If input
     * method support is enabled and the component also processes key events,
     * incoming events are offered to
     * the current input method and will only be processed by the component or
     * dispatched to its listeners if the input method does not consume them.
     * By default, input method support is enabled.
     *
     * @param enable true to enable, false to disable
     * @see #processKeyEvent
     * @since 1.2
     */
    public void enableInputMethods(boolean enable) {
<span class="nc bnc" id="L1565" title="All 2 branches missed.">        if (enable) {</span>
<span class="nc bnc" id="L1566" title="All 2 branches missed.">            if ((eventMask &amp; AWTEvent.INPUT_METHODS_ENABLED_MASK) != 0)</span>
<span class="nc" id="L1567">                return;</span>

            // If this component already has focus, then activate the
            // input method by dispatching a synthesized focus gained
            // event.
<span class="nc bnc" id="L1572" title="All 2 branches missed.">            if (isFocusOwner()) {</span>
<span class="nc" id="L1573">                InputContext inputContext = getInputContext();</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">                if (inputContext != null) {</span>
<span class="nc" id="L1575">                    FocusEvent focusGainedEvent =</span>
                        new FocusEvent(this, FocusEvent.FOCUS_GAINED);
<span class="nc" id="L1577">                    inputContext.dispatchEvent(focusGainedEvent);</span>
                }
            }

<span class="nc" id="L1581">            eventMask |= AWTEvent.INPUT_METHODS_ENABLED_MASK;</span>
        } else {
<span class="nc bnc" id="L1583" title="All 2 branches missed.">            if ((eventMask &amp; AWTEvent.INPUT_METHODS_ENABLED_MASK) != 0) {</span>
<span class="nc" id="L1584">                InputContext inputContext = getInputContext();</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">                if (inputContext != null) {</span>
<span class="nc" id="L1586">                    inputContext.endComposition();</span>
<span class="nc" id="L1587">                    inputContext.removeNotify(this);</span>
                }
            }
<span class="nc" id="L1590">            eventMask &amp;= ~AWTEvent.INPUT_METHODS_ENABLED_MASK;</span>
        }
<span class="nc" id="L1592">    }</span>

    /**
     * Shows or hides this component depending on the value of parameter
     * &lt;code&gt;b&lt;/code&gt;.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param b  if &lt;code&gt;true&lt;/code&gt;, shows this component;
     * otherwise, hides this component
     * @see #isVisible
     * @see #invalidate
     * @since JDK1.1
     */
    public void setVisible(boolean b) {
<span class="nc" id="L1608">        show(b);</span>
<span class="nc" id="L1609">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setVisible(boolean)&lt;/code&gt;.
     */
    @Deprecated
    public void show() {
<span class="nc bnc" id="L1617" title="All 2 branches missed.">        if (!visible) {</span>
<span class="nc" id="L1618">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L1619">                visible = true;</span>
<span class="nc" id="L1620">                mixOnShowing();</span>
<span class="nc" id="L1621">                ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">                if (peer != null) {</span>
<span class="nc" id="L1623">                    peer.setVisible(true);</span>
<span class="nc" id="L1624">                    createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED,</span>
                                          this, parent,
                                          HierarchyEvent.SHOWING_CHANGED,
<span class="nc" id="L1627">                                          Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">                    if (peer instanceof LightweightPeer) {</span>
<span class="nc" id="L1629">                        repaint();</span>
                    }
<span class="nc" id="L1631">                    updateCursorImmediately();</span>
                }

<span class="nc bnc" id="L1634" title="All 4 branches missed.">                if (componentListener != null ||</span>
                    (eventMask &amp; AWTEvent.COMPONENT_EVENT_MASK) != 0 ||
<span class="nc bnc" id="L1636" title="All 2 branches missed.">                    Toolkit.enabledOnToolkit(AWTEvent.COMPONENT_EVENT_MASK)) {</span>
<span class="nc" id="L1637">                    ComponentEvent e = new ComponentEvent(this,</span>
                                                          ComponentEvent.COMPONENT_SHOWN);
<span class="nc" id="L1639">                    Toolkit.getEventQueue().postEvent(e);</span>
                }
<span class="nc" id="L1641">            }</span>
<span class="nc" id="L1642">            Container parent = this.parent;</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L1644">                parent.invalidate();</span>
            }
        }
<span class="nc" id="L1647">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setVisible(boolean)&lt;/code&gt;.
     */
    @Deprecated
    public void show(boolean b) {
<span class="nc bnc" id="L1655" title="All 2 branches missed.">        if (b) {</span>
<span class="nc" id="L1656">            show();</span>
        } else {
<span class="nc" id="L1658">            hide();</span>
        }
<span class="nc" id="L1660">    }</span>

    boolean containsFocus() {
<span class="nc" id="L1663">        return isFocusOwner();</span>
    }

    void clearMostRecentFocusOwnerOnHide() {
<span class="nc" id="L1667">        KeyboardFocusManager.clearMostRecentFocusOwner(this);</span>
<span class="nc" id="L1668">    }</span>

    void clearCurrentFocusCycleRootOnHide() {
        /* do nothing */
<span class="nc" id="L1672">    }</span>

    /*
     * Delete references from LightweithDispatcher of a heavyweight parent
     */
    void clearLightweightDispatcherOnRemove(Component removedComponent) {
<span class="nc bnc" id="L1678" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L1679">            parent.clearLightweightDispatcherOnRemove(removedComponent);</span>
        }
<span class="nc" id="L1681">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setVisible(boolean)&lt;/code&gt;.
     */
    @Deprecated
    public void hide() {
<span class="nc" id="L1689">        isPacked = false;</span>

<span class="nc bnc" id="L1691" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L1692">            clearCurrentFocusCycleRootOnHide();</span>
<span class="nc" id="L1693">            clearMostRecentFocusOwnerOnHide();</span>
<span class="nc" id="L1694">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L1695">                visible = false;</span>
<span class="nc" id="L1696">                mixOnHiding(isLightweight());</span>
<span class="nc bnc" id="L1697" title="All 4 branches missed.">                if (containsFocus() &amp;&amp; KeyboardFocusManager.isAutoFocusTransferEnabled()) {</span>
<span class="nc" id="L1698">                    transferFocus(true);</span>
                }
<span class="nc" id="L1700">                ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">                if (peer != null) {</span>
<span class="nc" id="L1702">                    peer.setVisible(false);</span>
<span class="nc" id="L1703">                    createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED,</span>
                                          this, parent,
                                          HierarchyEvent.SHOWING_CHANGED,
<span class="nc" id="L1706">                                          Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));</span>
<span class="nc bnc" id="L1707" title="All 2 branches missed.">                    if (peer instanceof LightweightPeer) {</span>
<span class="nc" id="L1708">                        repaint();</span>
                    }
<span class="nc" id="L1710">                    updateCursorImmediately();</span>
                }
<span class="nc bnc" id="L1712" title="All 4 branches missed.">                if (componentListener != null ||</span>
                    (eventMask &amp; AWTEvent.COMPONENT_EVENT_MASK) != 0 ||
<span class="nc bnc" id="L1714" title="All 2 branches missed.">                    Toolkit.enabledOnToolkit(AWTEvent.COMPONENT_EVENT_MASK)) {</span>
<span class="nc" id="L1715">                    ComponentEvent e = new ComponentEvent(this,</span>
                                                          ComponentEvent.COMPONENT_HIDDEN);
<span class="nc" id="L1717">                    Toolkit.getEventQueue().postEvent(e);</span>
                }
<span class="nc" id="L1719">            }</span>
<span class="nc" id="L1720">            Container parent = this.parent;</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L1722">                parent.invalidate();</span>
            }
        }
<span class="nc" id="L1725">    }</span>

    /**
     * Gets the foreground color of this component.
     * @return this component's foreground color; if this component does
     * not have a foreground color, the foreground color of its parent
     * is returned
     * @see #setForeground
     * @since JDK1.0
     * @beaninfo
     *       bound: true
     */
    @Transient
    public Color getForeground() {
<span class="nc" id="L1739">        Color foreground = this.foreground;</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">        if (foreground != null) {</span>
<span class="nc" id="L1741">            return foreground;</span>
        }
<span class="nc" id="L1743">        Container parent = this.parent;</span>
<span class="nc bnc" id="L1744" title="All 2 branches missed.">        return (parent != null) ? parent.getForeground() : null;</span>
    }

    /**
     * Sets the foreground color of this component.
     * @param c the color to become this component's
     *          foreground color; if this parameter is &lt;code&gt;null&lt;/code&gt;
     *          then this component will inherit
     *          the foreground color of its parent
     * @see #getForeground
     * @since JDK1.0
     */
    public void setForeground(Color c) {
<span class="nc" id="L1757">        Color oldColor = foreground;</span>
<span class="nc" id="L1758">        ComponentPeer peer = this.peer;</span>
<span class="nc" id="L1759">        foreground = c;</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L1761">            c = getForeground();</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L1763">                peer.setForeground(c);</span>
            }
        }
        // This is a bound property, so report the change to
        // any registered listeners.  (Cheap if there are none.)
<span class="nc" id="L1768">        firePropertyChange(&quot;foreground&quot;, oldColor, c);</span>
<span class="nc" id="L1769">    }</span>

    /**
     * Returns whether the foreground color has been explicitly set for this
     * Component. If this method returns &lt;code&gt;false&lt;/code&gt;, this Component is
     * inheriting its foreground color from an ancestor.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the foreground color has been explicitly
     *         set for this Component; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.4
     */
    public boolean isForegroundSet() {
<span class="nc bnc" id="L1781" title="All 2 branches missed.">        return (foreground != null);</span>
    }

    /**
     * Gets the background color of this component.
     * @return this component's background color; if this component does
     *          not have a background color,
     *          the background color of its parent is returned
     * @see #setBackground
     * @since JDK1.0
     */
    @Transient
    public Color getBackground() {
<span class="nc" id="L1794">        Color background = this.background;</span>
<span class="nc bnc" id="L1795" title="All 2 branches missed.">        if (background != null) {</span>
<span class="nc" id="L1796">            return background;</span>
        }
<span class="nc" id="L1798">        Container parent = this.parent;</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">        return (parent != null) ? parent.getBackground() : null;</span>
    }

    /**
     * Sets the background color of this component.
     * &lt;p&gt;
     * The background color affects each component differently and the
     * parts of the component that are affected by the background color
     * may differ between operating systems.
     *
     * @param c the color to become this component's color;
     *          if this parameter is &lt;code&gt;null&lt;/code&gt;, then this
     *          component will inherit the background color of its parent
     * @see #getBackground
     * @since JDK1.0
     * @beaninfo
     *       bound: true
     */
    public void setBackground(Color c) {
<span class="nc" id="L1818">        Color oldColor = background;</span>
<span class="nc" id="L1819">        ComponentPeer peer = this.peer;</span>
<span class="nc" id="L1820">        background = c;</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L1822">            c = getBackground();</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L1824">                peer.setBackground(c);</span>
            }
        }
        // This is a bound property, so report the change to
        // any registered listeners.  (Cheap if there are none.)
<span class="nc" id="L1829">        firePropertyChange(&quot;background&quot;, oldColor, c);</span>
<span class="nc" id="L1830">    }</span>

    /**
     * Returns whether the background color has been explicitly set for this
     * Component. If this method returns &lt;code&gt;false&lt;/code&gt;, this Component is
     * inheriting its background color from an ancestor.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the background color has been explicitly
     *         set for this Component; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.4
     */
    public boolean isBackgroundSet() {
<span class="nc bnc" id="L1842" title="All 2 branches missed.">        return (background != null);</span>
    }

    /**
     * Gets the font of this component.
     * @return this component's font; if a font has not been set
     * for this component, the font of its parent is returned
     * @see #setFont
     * @since JDK1.0
     */
    @Transient
    public Font getFont() {
<span class="nc" id="L1854">        return getFont_NoClientCode();</span>
    }

    // NOTE: This method may be called by privileged threads.
    //       This functionality is implemented in a package-private method
    //       to insure that it cannot be overridden by client subclasses.
    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
    final Font getFont_NoClientCode() {
<span class="nc" id="L1862">        Font font = this.font;</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">        if (font != null) {</span>
<span class="nc" id="L1864">            return font;</span>
        }
<span class="nc" id="L1866">        Container parent = this.parent;</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">        return (parent != null) ? parent.getFont_NoClientCode() : null;</span>
    }

    /**
     * Sets the font of this component.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param f the font to become this component's font;
     *          if this parameter is &lt;code&gt;null&lt;/code&gt; then this
     *          component will inherit the font of its parent
     * @see #getFont
     * @see #invalidate
     * @since JDK1.0
     * @beaninfo
     *       bound: true
     */
    public void setFont(Font f) {
        Font oldFont, newFont;
<span class="nc" id="L1887">        synchronized(getTreeLock()) {</span>
<span class="nc" id="L1888">            oldFont = font;</span>
<span class="nc" id="L1889">            newFont = font = f;</span>
<span class="nc" id="L1890">            ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L1892">                f = getFont();</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">                if (f != null) {</span>
<span class="nc" id="L1894">                    peer.setFont(f);</span>
<span class="nc" id="L1895">                    peerFont = f;</span>
                }
            }
<span class="nc" id="L1898">        }</span>
        // This is a bound property, so report the change to
        // any registered listeners.  (Cheap if there are none.)
<span class="nc" id="L1901">        firePropertyChange(&quot;font&quot;, oldFont, newFont);</span>

        // This could change the preferred size of the Component.
        // Fix for 6213660. Should compare old and new fonts and do not
        // call invalidate() if they are equal.
<span class="nc bnc" id="L1906" title="All 4 branches missed.">        if (f != oldFont &amp;&amp; (oldFont == null ||</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">                                      !oldFont.equals(f))) {</span>
<span class="nc" id="L1908">            invalidateIfValid();</span>
        }
<span class="nc" id="L1910">    }</span>

    /**
     * Returns whether the font has been explicitly set for this Component. If
     * this method returns &lt;code&gt;false&lt;/code&gt;, this Component is inheriting its
     * font from an ancestor.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the font has been explicitly set for this
     *         Component; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.4
     */
    public boolean isFontSet() {
<span class="nc bnc" id="L1922" title="All 2 branches missed.">        return (font != null);</span>
    }

    /**
     * Gets the locale of this component.
     * @return this component's locale; if this component does not
     *          have a locale, the locale of its parent is returned
     * @see #setLocale
     * @exception IllegalComponentStateException if the &lt;code&gt;Component&lt;/code&gt;
     *          does not have its own locale and has not yet been added to
     *          a containment hierarchy such that the locale can be determined
     *          from the containing parent
     * @since  JDK1.1
     */
    public Locale getLocale() {
<span class="nc" id="L1937">        Locale locale = this.locale;</span>
<span class="nc bnc" id="L1938" title="All 2 branches missed.">        if (locale != null) {</span>
<span class="nc" id="L1939">            return locale;</span>
        }
<span class="nc" id="L1941">        Container parent = this.parent;</span>

<span class="nc bnc" id="L1943" title="All 2 branches missed.">        if (parent == null) {</span>
<span class="nc" id="L1944">            throw new IllegalComponentStateException(&quot;This component must have a parent in order to determine its locale&quot;);</span>
        } else {
<span class="nc" id="L1946">            return parent.getLocale();</span>
        }
    }

    /**
     * Sets the locale of this component.  This is a bound property.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param l the locale to become this component's locale
     * @see #getLocale
     * @see #invalidate
     * @since JDK1.1
     */
    public void setLocale(Locale l) {
<span class="nc" id="L1962">        Locale oldValue = locale;</span>
<span class="nc" id="L1963">        locale = l;</span>

        // This is a bound property, so report the change to
        // any registered listeners.  (Cheap if there are none.)
<span class="nc" id="L1967">        firePropertyChange(&quot;locale&quot;, oldValue, l);</span>

        // This could change the preferred size of the Component.
<span class="nc" id="L1970">        invalidateIfValid();</span>
<span class="nc" id="L1971">    }</span>

    /**
     * Gets the instance of &lt;code&gt;ColorModel&lt;/code&gt; used to display
     * the component on the output device.
     * @return the color model used by this component
     * @see java.awt.image.ColorModel
     * @see java.awt.peer.ComponentPeer#getColorModel()
     * @see Toolkit#getColorModel()
     * @since JDK1.0
     */
    public ColorModel getColorModel() {
<span class="nc" id="L1983">        ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L1984" title="All 4 branches missed.">        if ((peer != null) &amp;&amp; ! (peer instanceof LightweightPeer)) {</span>
<span class="nc" id="L1985">            return peer.getColorModel();</span>
<span class="nc bnc" id="L1986" title="All 2 branches missed.">        } else if (GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L1987">            return ColorModel.getRGBdefault();</span>
        } // else
<span class="nc" id="L1989">        return getToolkit().getColorModel();</span>
    }

    /**
     * Gets the location of this component in the form of a
     * point specifying the component's top-left corner.
     * The location will be relative to the parent's coordinate space.
     * &lt;p&gt;
     * Due to the asynchronous nature of native event handling, this
     * method can return outdated values (for instance, after several calls
     * of &lt;code&gt;setLocation()&lt;/code&gt; in rapid succession).  For this
     * reason, the recommended method of obtaining a component's position is
     * within &lt;code&gt;java.awt.event.ComponentListener.componentMoved()&lt;/code&gt;,
     * which is called after the operating system has finished moving the
     * component.
     * &lt;/p&gt;
     * @return an instance of &lt;code&gt;Point&lt;/code&gt; representing
     *          the top-left corner of the component's bounds in
     *          the coordinate space of the component's parent
     * @see #setLocation
     * @see #getLocationOnScreen
     * @since JDK1.1
     */
    public Point getLocation() {
<span class="nc" id="L2013">        return location();</span>
    }

    /**
     * Gets the location of this component in the form of a point
     * specifying the component's top-left corner in the screen's
     * coordinate space.
     * @return an instance of &lt;code&gt;Point&lt;/code&gt; representing
     *          the top-left corner of the component's bounds in the
     *          coordinate space of the screen
     * @throws IllegalComponentStateException if the
     *          component is not showing on the screen
     * @see #setLocation
     * @see #getLocation
     */
    public Point getLocationOnScreen() {
<span class="nc" id="L2029">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L2030">            return getLocationOnScreen_NoTreeLock();</span>
<span class="nc" id="L2031">        }</span>
    }

    /*
     * a package private version of getLocationOnScreen
     * used by GlobalCursormanager to update cursor
     */
    final Point getLocationOnScreen_NoTreeLock() {

<span class="nc bnc" id="L2040" title="All 4 branches missed.">        if (peer != null &amp;&amp; isShowing()) {</span>
<span class="nc bnc" id="L2041" title="All 2 branches missed.">            if (peer instanceof LightweightPeer) {</span>
                // lightweight component location needs to be translated
                // relative to a native component.
<span class="nc" id="L2044">                Container host = getNativeContainer();</span>
<span class="nc" id="L2045">                Point pt = host.peer.getLocationOnScreen();</span>
<span class="nc bnc" id="L2046" title="All 2 branches missed.">                for(Component c = this; c != host; c = c.getParent()) {</span>
<span class="nc" id="L2047">                    pt.x += c.x;</span>
<span class="nc" id="L2048">                    pt.y += c.y;</span>
                }
<span class="nc" id="L2050">                return pt;</span>
            } else {
<span class="nc" id="L2052">                Point pt = peer.getLocationOnScreen();</span>
<span class="nc" id="L2053">                return pt;</span>
            }
        } else {
<span class="nc" id="L2056">            throw new IllegalComponentStateException(&quot;component must be showing on the screen to determine its location&quot;);</span>
        }
    }


    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getLocation()&lt;/code&gt;.
     */
    @Deprecated
    public Point location() {
<span class="nc" id="L2067">        return location_NoClientCode();</span>
    }

    private Point location_NoClientCode() {
<span class="nc" id="L2071">        return new Point(x, y);</span>
    }

    /**
     * Moves this component to a new location. The top-left corner of
     * the new location is specified by the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;
     * parameters in the coordinate space of this component's parent.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param x the &lt;i&gt;x&lt;/i&gt;-coordinate of the new location's
     *          top-left corner in the parent's coordinate space
     * @param y the &lt;i&gt;y&lt;/i&gt;-coordinate of the new location's
     *          top-left corner in the parent's coordinate space
     * @see #getLocation
     * @see #setBounds
     * @see #invalidate
     * @since JDK1.1
     */
    public void setLocation(int x, int y) {
<span class="nc" id="L2092">        move(x, y);</span>
<span class="nc" id="L2093">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setLocation(int, int)&lt;/code&gt;.
     */
    @Deprecated
    public void move(int x, int y) {
<span class="nc" id="L2101">        synchronized(getTreeLock()) {</span>
<span class="nc" id="L2102">            setBoundsOp(ComponentPeer.SET_LOCATION);</span>
<span class="nc" id="L2103">            setBounds(x, y, width, height);</span>
<span class="nc" id="L2104">        }</span>
<span class="nc" id="L2105">    }</span>

    /**
     * Moves this component to a new location. The top-left corner of
     * the new location is specified by point &lt;code&gt;p&lt;/code&gt;. Point
     * &lt;code&gt;p&lt;/code&gt; is given in the parent's coordinate space.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param p the point defining the top-left corner
     *          of the new location, given in the coordinate space of this
     *          component's parent
     * @see #getLocation
     * @see #setBounds
     * @see #invalidate
     * @since JDK1.1
     */
    public void setLocation(Point p) {
<span class="nc" id="L2124">        setLocation(p.x, p.y);</span>
<span class="nc" id="L2125">    }</span>

    /**
     * Returns the size of this component in the form of a
     * &lt;code&gt;Dimension&lt;/code&gt; object. The &lt;code&gt;height&lt;/code&gt;
     * field of the &lt;code&gt;Dimension&lt;/code&gt; object contains
     * this component's height, and the &lt;code&gt;width&lt;/code&gt;
     * field of the &lt;code&gt;Dimension&lt;/code&gt; object contains
     * this component's width.
     * @return a &lt;code&gt;Dimension&lt;/code&gt; object that indicates the
     *          size of this component
     * @see #setSize
     * @since JDK1.1
     */
    public Dimension getSize() {
<span class="nc" id="L2140">        return size();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getSize()&lt;/code&gt;.
     */
    @Deprecated
    public Dimension size() {
<span class="nc" id="L2149">        return new Dimension(width, height);</span>
    }

    /**
     * Resizes this component so that it has width &lt;code&gt;width&lt;/code&gt;
     * and height &lt;code&gt;height&lt;/code&gt;.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param width the new width of this component in pixels
     * @param height the new height of this component in pixels
     * @see #getSize
     * @see #setBounds
     * @see #invalidate
     * @since JDK1.1
     */
    public void setSize(int width, int height) {
<span class="nc" id="L2167">        resize(width, height);</span>
<span class="nc" id="L2168">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setSize(int, int)&lt;/code&gt;.
     */
    @Deprecated
    public void resize(int width, int height) {
<span class="nc" id="L2176">        synchronized(getTreeLock()) {</span>
<span class="nc" id="L2177">            setBoundsOp(ComponentPeer.SET_SIZE);</span>
<span class="nc" id="L2178">            setBounds(x, y, width, height);</span>
<span class="nc" id="L2179">        }</span>
<span class="nc" id="L2180">    }</span>

    /**
     * Resizes this component so that it has width &lt;code&gt;d.width&lt;/code&gt;
     * and height &lt;code&gt;d.height&lt;/code&gt;.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param d the dimension specifying the new size
     *          of this component
     * @throws NullPointerException if {@code d} is {@code null}
     * @see #setSize
     * @see #setBounds
     * @see #invalidate
     * @since JDK1.1
     */
    public void setSize(Dimension d) {
<span class="nc" id="L2198">        resize(d);</span>
<span class="nc" id="L2199">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setSize(Dimension)&lt;/code&gt;.
     */
    @Deprecated
    public void resize(Dimension d) {
<span class="nc" id="L2207">        setSize(d.width, d.height);</span>
<span class="nc" id="L2208">    }</span>

    /**
     * Gets the bounds of this component in the form of a
     * &lt;code&gt;Rectangle&lt;/code&gt; object. The bounds specify this
     * component's width, height, and location relative to
     * its parent.
     * @return a rectangle indicating this component's bounds
     * @see #setBounds
     * @see #getLocation
     * @see #getSize
     */
    public Rectangle getBounds() {
<span class="nc" id="L2221">        return bounds();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getBounds()&lt;/code&gt;.
     */
    @Deprecated
    public Rectangle bounds() {
<span class="nc" id="L2230">        return new Rectangle(x, y, width, height);</span>
    }

    /**
     * Moves and resizes this component. The new location of the top-left
     * corner is specified by &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and the
     * new size is specified by &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param x the new &lt;i&gt;x&lt;/i&gt;-coordinate of this component
     * @param y the new &lt;i&gt;y&lt;/i&gt;-coordinate of this component
     * @param width the new &lt;code&gt;width&lt;/code&gt; of this component
     * @param height the new &lt;code&gt;height&lt;/code&gt; of this
     *          component
     * @see #getBounds
     * @see #setLocation(int, int)
     * @see #setLocation(Point)
     * @see #setSize(int, int)
     * @see #setSize(Dimension)
     * @see #invalidate
     * @since JDK1.1
     */
    public void setBounds(int x, int y, int width, int height) {
<span class="nc" id="L2255">        reshape(x, y, width, height);</span>
<span class="nc" id="L2256">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setBounds(int, int, int, int)&lt;/code&gt;.
     */
    @Deprecated
    public void reshape(int x, int y, int width, int height) {
<span class="nc" id="L2264">        synchronized (getTreeLock()) {</span>
            try {
<span class="nc" id="L2266">                setBoundsOp(ComponentPeer.SET_BOUNDS);</span>
<span class="nc bnc" id="L2267" title="All 4 branches missed.">                boolean resized = (this.width != width) || (this.height != height);</span>
<span class="nc bnc" id="L2268" title="All 4 branches missed.">                boolean moved = (this.x != x) || (this.y != y);</span>
<span class="nc bnc" id="L2269" title="All 4 branches missed.">                if (!resized &amp;&amp; !moved) {</span>
<span class="nc" id="L2270">                    return;</span>
                }
<span class="nc" id="L2272">                int oldX = this.x;</span>
<span class="nc" id="L2273">                int oldY = this.y;</span>
<span class="nc" id="L2274">                int oldWidth = this.width;</span>
<span class="nc" id="L2275">                int oldHeight = this.height;</span>
<span class="nc" id="L2276">                this.x = x;</span>
<span class="nc" id="L2277">                this.y = y;</span>
<span class="nc" id="L2278">                this.width = width;</span>
<span class="nc" id="L2279">                this.height = height;</span>

<span class="nc bnc" id="L2281" title="All 2 branches missed.">                if (resized) {</span>
<span class="nc" id="L2282">                    isPacked = false;</span>
                }

<span class="nc" id="L2285">                boolean needNotify = true;</span>
<span class="nc" id="L2286">                mixOnReshaping();</span>
<span class="nc bnc" id="L2287" title="All 2 branches missed.">                if (peer != null) {</span>
                    // LightwightPeer is an empty stub so can skip peer.reshape
<span class="nc bnc" id="L2289" title="All 2 branches missed.">                    if (!(peer instanceof LightweightPeer)) {</span>
<span class="nc" id="L2290">                        reshapeNativePeer(x, y, width, height, getBoundsOp());</span>
                        // Check peer actualy changed coordinates
<span class="nc bnc" id="L2292" title="All 4 branches missed.">                        resized = (oldWidth != this.width) || (oldHeight != this.height);</span>
<span class="nc bnc" id="L2293" title="All 4 branches missed.">                        moved = (oldX != this.x) || (oldY != this.y);</span>
                        // fix for 5025858: do not send ComponentEvents for toplevel
                        // windows here as it is done from peer or native code when
                        // the window is really resized or moved, otherwise some
                        // events may be sent twice
<span class="nc bnc" id="L2298" title="All 2 branches missed.">                        if (this instanceof Window) {</span>
<span class="nc" id="L2299">                            needNotify = false;</span>
                        }
                    }
<span class="nc bnc" id="L2302" title="All 2 branches missed.">                    if (resized) {</span>
<span class="nc" id="L2303">                        invalidate();</span>
                    }
<span class="nc bnc" id="L2305" title="All 2 branches missed.">                    if (parent != null) {</span>
<span class="nc" id="L2306">                        parent.invalidateIfValid();</span>
                    }
                }
<span class="nc bnc" id="L2309" title="All 2 branches missed.">                if (needNotify) {</span>
<span class="nc" id="L2310">                    notifyNewBounds(resized, moved);</span>
                }
<span class="nc" id="L2312">                repaintParentIfNeeded(oldX, oldY, oldWidth, oldHeight);</span>
            } finally {
<span class="nc" id="L2314">                setBoundsOp(ComponentPeer.RESET_OPERATION);</span>
<span class="nc" id="L2315">            }</span>
<span class="nc" id="L2316">        }</span>
<span class="nc" id="L2317">    }</span>

    private void repaintParentIfNeeded(int oldX, int oldY, int oldWidth,
                                       int oldHeight)
    {
<span class="nc bnc" id="L2322" title="All 6 branches missed.">        if (parent != null &amp;&amp; peer instanceof LightweightPeer &amp;&amp; isShowing()) {</span>
            // Have the parent redraw the area this component occupied.
<span class="nc" id="L2324">            parent.repaint(oldX, oldY, oldWidth, oldHeight);</span>
            // Have the parent redraw the area this component *now* occupies.
<span class="nc" id="L2326">            repaint();</span>
        }
<span class="nc" id="L2328">    }</span>

    private void reshapeNativePeer(int x, int y, int width, int height, int op) {
        // native peer might be offset by more than direct
        // parent since parent might be lightweight.
<span class="nc" id="L2333">        int nativeX = x;</span>
<span class="nc" id="L2334">        int nativeY = y;</span>
<span class="nc" id="L2335">        for (Component c = parent;</span>
<span class="nc bnc" id="L2336" title="All 4 branches missed.">             (c != null) &amp;&amp; (c.peer instanceof LightweightPeer);</span>
<span class="nc" id="L2337">             c = c.parent)</span>
        {
<span class="nc" id="L2339">            nativeX += c.x;</span>
<span class="nc" id="L2340">            nativeY += c.y;</span>
        }
<span class="nc" id="L2342">        peer.setBounds(nativeX, nativeY, width, height, op);</span>
<span class="nc" id="L2343">    }</span>

    @SuppressWarnings(&quot;deprecation&quot;)
    private void notifyNewBounds(boolean resized, boolean moved) {
<span class="nc bnc" id="L2347" title="All 4 branches missed.">        if (componentListener != null</span>
            || (eventMask &amp; AWTEvent.COMPONENT_EVENT_MASK) != 0
<span class="nc bnc" id="L2349" title="All 2 branches missed.">            || Toolkit.enabledOnToolkit(AWTEvent.COMPONENT_EVENT_MASK))</span>
            {
<span class="nc bnc" id="L2351" title="All 2 branches missed.">                if (resized) {</span>
<span class="nc" id="L2352">                    ComponentEvent e = new ComponentEvent(this,</span>
                                                          ComponentEvent.COMPONENT_RESIZED);
<span class="nc" id="L2354">                    Toolkit.getEventQueue().postEvent(e);</span>
                }
<span class="nc bnc" id="L2356" title="All 2 branches missed.">                if (moved) {</span>
<span class="nc" id="L2357">                    ComponentEvent e = new ComponentEvent(this,</span>
                                                          ComponentEvent.COMPONENT_MOVED);
<span class="nc" id="L2359">                    Toolkit.getEventQueue().postEvent(e);</span>
<span class="nc" id="L2360">                }</span>
            } else {
<span class="nc bnc" id="L2362" title="All 4 branches missed.">                if (this instanceof Container &amp;&amp; ((Container)this).countComponents() &gt; 0) {</span>
<span class="nc" id="L2363">                    boolean enabledOnToolkit =</span>
<span class="nc" id="L2364">                        Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK);</span>
<span class="nc bnc" id="L2365" title="All 2 branches missed.">                    if (resized) {</span>

<span class="nc" id="L2367">                        ((Container)this).createChildHierarchyEvents(</span>
                                                                     HierarchyEvent.ANCESTOR_RESIZED, 0, enabledOnToolkit);
                    }
<span class="nc bnc" id="L2370" title="All 2 branches missed.">                    if (moved) {</span>
<span class="nc" id="L2371">                        ((Container)this).createChildHierarchyEvents(</span>
                                                                     HierarchyEvent.ANCESTOR_MOVED, 0, enabledOnToolkit);
                    }
                }
                }
<span class="nc" id="L2376">    }</span>

    /**
     * Moves and resizes this component to conform to the new
     * bounding rectangle &lt;code&gt;r&lt;/code&gt;. This component's new
     * position is specified by &lt;code&gt;r.x&lt;/code&gt; and &lt;code&gt;r.y&lt;/code&gt;,
     * and its new size is specified by &lt;code&gt;r.width&lt;/code&gt; and
     * &lt;code&gt;r.height&lt;/code&gt;
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param r the new bounding rectangle for this component
     * @throws NullPointerException if {@code r} is {@code null}
     * @see       #getBounds
     * @see       #setLocation(int, int)
     * @see       #setLocation(Point)
     * @see       #setSize(int, int)
     * @see       #setSize(Dimension)
     * @see #invalidate
     * @since     JDK1.1
     */
    public void setBounds(Rectangle r) {
<span class="nc" id="L2399">        setBounds(r.x, r.y, r.width, r.height);</span>
<span class="nc" id="L2400">    }</span>


    /**
     * Returns the current x coordinate of the components origin.
     * This method is preferable to writing
     * &lt;code&gt;component.getBounds().x&lt;/code&gt;,
     * or &lt;code&gt;component.getLocation().x&lt;/code&gt; because it doesn't
     * cause any heap allocations.
     *
     * @return the current x coordinate of the components origin
     * @since 1.2
     */
    public int getX() {
<span class="nc" id="L2414">        return x;</span>
    }


    /**
     * Returns the current y coordinate of the components origin.
     * This method is preferable to writing
     * &lt;code&gt;component.getBounds().y&lt;/code&gt;,
     * or &lt;code&gt;component.getLocation().y&lt;/code&gt; because it
     * doesn't cause any heap allocations.
     *
     * @return the current y coordinate of the components origin
     * @since 1.2
     */
    public int getY() {
<span class="nc" id="L2429">        return y;</span>
    }


    /**
     * Returns the current width of this component.
     * This method is preferable to writing
     * &lt;code&gt;component.getBounds().width&lt;/code&gt;,
     * or &lt;code&gt;component.getSize().width&lt;/code&gt; because it
     * doesn't cause any heap allocations.
     *
     * @return the current width of this component
     * @since 1.2
     */
    public int getWidth() {
<span class="nc" id="L2444">        return width;</span>
    }


    /**
     * Returns the current height of this component.
     * This method is preferable to writing
     * &lt;code&gt;component.getBounds().height&lt;/code&gt;,
     * or &lt;code&gt;component.getSize().height&lt;/code&gt; because it
     * doesn't cause any heap allocations.
     *
     * @return the current height of this component
     * @since 1.2
     */
    public int getHeight() {
<span class="nc" id="L2459">        return height;</span>
    }

    /**
     * Stores the bounds of this component into &quot;return value&quot; &lt;b&gt;rv&lt;/b&gt; and
     * return &lt;b&gt;rv&lt;/b&gt;.  If rv is &lt;code&gt;null&lt;/code&gt; a new
     * &lt;code&gt;Rectangle&lt;/code&gt; is allocated.
     * This version of &lt;code&gt;getBounds&lt;/code&gt; is useful if the caller
     * wants to avoid allocating a new &lt;code&gt;Rectangle&lt;/code&gt; object
     * on the heap.
     *
     * @param rv the return value, modified to the components bounds
     * @return rv
     */
    public Rectangle getBounds(Rectangle rv) {
<span class="nc bnc" id="L2474" title="All 2 branches missed.">        if (rv == null) {</span>
<span class="nc" id="L2475">            return new Rectangle(getX(), getY(), getWidth(), getHeight());</span>
        }
        else {
<span class="nc" id="L2478">            rv.setBounds(getX(), getY(), getWidth(), getHeight());</span>
<span class="nc" id="L2479">            return rv;</span>
        }
    }

    /**
     * Stores the width/height of this component into &quot;return value&quot; &lt;b&gt;rv&lt;/b&gt;
     * and return &lt;b&gt;rv&lt;/b&gt;.   If rv is &lt;code&gt;null&lt;/code&gt; a new
     * &lt;code&gt;Dimension&lt;/code&gt; object is allocated.  This version of
     * &lt;code&gt;getSize&lt;/code&gt; is useful if the caller wants to avoid
     * allocating a new &lt;code&gt;Dimension&lt;/code&gt; object on the heap.
     *
     * @param rv the return value, modified to the components size
     * @return rv
     */
    public Dimension getSize(Dimension rv) {
<span class="nc bnc" id="L2494" title="All 2 branches missed.">        if (rv == null) {</span>
<span class="nc" id="L2495">            return new Dimension(getWidth(), getHeight());</span>
        }
        else {
<span class="nc" id="L2498">            rv.setSize(getWidth(), getHeight());</span>
<span class="nc" id="L2499">            return rv;</span>
        }
    }

    /**
     * Stores the x,y origin of this component into &quot;return value&quot; &lt;b&gt;rv&lt;/b&gt;
     * and return &lt;b&gt;rv&lt;/b&gt;.   If rv is &lt;code&gt;null&lt;/code&gt; a new
     * &lt;code&gt;Point&lt;/code&gt; is allocated.
     * This version of &lt;code&gt;getLocation&lt;/code&gt; is useful if the
     * caller wants to avoid allocating a new &lt;code&gt;Point&lt;/code&gt;
     * object on the heap.
     *
     * @param rv the return value, modified to the components location
     * @return rv
     */
    public Point getLocation(Point rv) {
<span class="nc bnc" id="L2515" title="All 2 branches missed.">        if (rv == null) {</span>
<span class="nc" id="L2516">            return new Point(getX(), getY());</span>
        }
        else {
<span class="nc" id="L2519">            rv.setLocation(getX(), getY());</span>
<span class="nc" id="L2520">            return rv;</span>
        }
    }

    /**
     * Returns true if this component is completely opaque, returns
     * false by default.
     * &lt;p&gt;
     * An opaque component paints every pixel within its
     * rectangular region. A non-opaque component paints only some of
     * its pixels, allowing the pixels underneath it to &quot;show through&quot;.
     * A component that does not fully paint its pixels therefore
     * provides a degree of transparency.
     * &lt;p&gt;
     * Subclasses that guarantee to always completely paint their
     * contents should override this method and return true.
     *
     * @return true if this component is completely opaque
     * @see #isLightweight
     * @since 1.2
     */
    public boolean isOpaque() {
<span class="nc bnc" id="L2542" title="All 2 branches missed.">        if (getPeer() == null) {</span>
<span class="nc" id="L2543">            return false;</span>
        }
        else {
<span class="nc bnc" id="L2546" title="All 2 branches missed.">            return !isLightweight();</span>
        }
    }


    /**
     * A lightweight component doesn't have a native toolkit peer.
     * Subclasses of &lt;code&gt;Component&lt;/code&gt; and &lt;code&gt;Container&lt;/code&gt;,
     * other than the ones defined in this package like &lt;code&gt;Button&lt;/code&gt;
     * or &lt;code&gt;Scrollbar&lt;/code&gt;, are lightweight.
     * All of the Swing components are lightweights.
     * &lt;p&gt;
     * This method will always return &lt;code&gt;false&lt;/code&gt; if this component
     * is not displayable because it is impossible to determine the
     * weight of an undisplayable component.
     *
     * @return true if this component has a lightweight peer; false if
     *         it has a native peer or no peer
     * @see #isDisplayable
     * @since 1.2
     */
    public boolean isLightweight() {
<span class="nc" id="L2568">        return getPeer() instanceof LightweightPeer;</span>
    }


    /**
     * Sets the preferred size of this component to a constant
     * value.  Subsequent calls to &lt;code&gt;getPreferredSize&lt;/code&gt; will always
     * return this value.  Setting the preferred size to &lt;code&gt;null&lt;/code&gt;
     * restores the default behavior.
     *
     * @param preferredSize The new preferred size, or null
     * @see #getPreferredSize
     * @see #isPreferredSizeSet
     * @since 1.5
     */
    public void setPreferredSize(Dimension preferredSize) {
        Dimension old;
        // If the preferred size was set, use it as the old value, otherwise
        // use null to indicate we didn't previously have a set preferred
        // size.
<span class="nc bnc" id="L2588" title="All 2 branches missed.">        if (prefSizeSet) {</span>
<span class="nc" id="L2589">            old = this.prefSize;</span>
        }
        else {
<span class="nc" id="L2592">            old = null;</span>
        }
<span class="nc" id="L2594">        this.prefSize = preferredSize;</span>
<span class="nc bnc" id="L2595" title="All 2 branches missed.">        prefSizeSet = (preferredSize != null);</span>
<span class="nc" id="L2596">        firePropertyChange(&quot;preferredSize&quot;, old, preferredSize);</span>
<span class="nc" id="L2597">    }</span>


    /**
     * Returns true if the preferred size has been set to a
     * non-&lt;code&gt;null&lt;/code&gt; value otherwise returns false.
     *
     * @return true if &lt;code&gt;setPreferredSize&lt;/code&gt; has been invoked
     *         with a non-null value.
     * @since 1.5
     */
    public boolean isPreferredSizeSet() {
<span class="nc" id="L2609">        return prefSizeSet;</span>
    }


    /**
     * Gets the preferred size of this component.
     * @return a dimension object indicating this component's preferred size
     * @see #getMinimumSize
     * @see LayoutManager
     */
    public Dimension getPreferredSize() {
<span class="nc" id="L2620">        return preferredSize();</span>
    }


    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getPreferredSize()&lt;/code&gt;.
     */
    @Deprecated
    public Dimension preferredSize() {
        /* Avoid grabbing the lock if a reasonable cached size value
         * is available.
         */
<span class="nc" id="L2633">        Dimension dim = prefSize;</span>
<span class="nc bnc" id="L2634" title="All 6 branches missed.">        if (dim == null || !(isPreferredSizeSet() || isValid())) {</span>
<span class="nc" id="L2635">            synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L2636" title="All 2 branches missed.">                prefSize = (peer != null) ?</span>
<span class="nc" id="L2637">                    peer.getPreferredSize() :</span>
<span class="nc" id="L2638">                    getMinimumSize();</span>
<span class="nc" id="L2639">                dim = prefSize;</span>
<span class="nc" id="L2640">            }</span>
        }
<span class="nc" id="L2642">        return new Dimension(dim);</span>
    }

    /**
     * Sets the minimum size of this component to a constant
     * value.  Subsequent calls to &lt;code&gt;getMinimumSize&lt;/code&gt; will always
     * return this value.  Setting the minimum size to &lt;code&gt;null&lt;/code&gt;
     * restores the default behavior.
     *
     * @param minimumSize the new minimum size of this component
     * @see #getMinimumSize
     * @see #isMinimumSizeSet
     * @since 1.5
     */
    public void setMinimumSize(Dimension minimumSize) {
        Dimension old;
        // If the minimum size was set, use it as the old value, otherwise
        // use null to indicate we didn't previously have a set minimum
        // size.
<span class="nc bnc" id="L2661" title="All 2 branches missed.">        if (minSizeSet) {</span>
<span class="nc" id="L2662">            old = this.minSize;</span>
        }
        else {
<span class="nc" id="L2665">            old = null;</span>
        }
<span class="nc" id="L2667">        this.minSize = minimumSize;</span>
<span class="nc bnc" id="L2668" title="All 2 branches missed.">        minSizeSet = (minimumSize != null);</span>
<span class="nc" id="L2669">        firePropertyChange(&quot;minimumSize&quot;, old, minimumSize);</span>
<span class="nc" id="L2670">    }</span>

    /**
     * Returns whether or not &lt;code&gt;setMinimumSize&lt;/code&gt; has been
     * invoked with a non-null value.
     *
     * @return true if &lt;code&gt;setMinimumSize&lt;/code&gt; has been invoked with a
     *              non-null value.
     * @since 1.5
     */
    public boolean isMinimumSizeSet() {
<span class="nc" id="L2681">        return minSizeSet;</span>
    }

    /**
     * Gets the minimum size of this component.
     * @return a dimension object indicating this component's minimum size
     * @see #getPreferredSize
     * @see LayoutManager
     */
    public Dimension getMinimumSize() {
<span class="nc" id="L2691">        return minimumSize();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getMinimumSize()&lt;/code&gt;.
     */
    @Deprecated
    public Dimension minimumSize() {
        /* Avoid grabbing the lock if a reasonable cached size value
         * is available.
         */
<span class="nc" id="L2703">        Dimension dim = minSize;</span>
<span class="nc bnc" id="L2704" title="All 6 branches missed.">        if (dim == null || !(isMinimumSizeSet() || isValid())) {</span>
<span class="nc" id="L2705">            synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L2706" title="All 2 branches missed.">                minSize = (peer != null) ?</span>
<span class="nc" id="L2707">                    peer.getMinimumSize() :</span>
<span class="nc" id="L2708">                    size();</span>
<span class="nc" id="L2709">                dim = minSize;</span>
<span class="nc" id="L2710">            }</span>
        }
<span class="nc" id="L2712">        return new Dimension(dim);</span>
    }

    /**
     * Sets the maximum size of this component to a constant
     * value.  Subsequent calls to &lt;code&gt;getMaximumSize&lt;/code&gt; will always
     * return this value.  Setting the maximum size to &lt;code&gt;null&lt;/code&gt;
     * restores the default behavior.
     *
     * @param maximumSize a &lt;code&gt;Dimension&lt;/code&gt; containing the
     *          desired maximum allowable size
     * @see #getMaximumSize
     * @see #isMaximumSizeSet
     * @since 1.5
     */
    public void setMaximumSize(Dimension maximumSize) {
        // If the maximum size was set, use it as the old value, otherwise
        // use null to indicate we didn't previously have a set maximum
        // size.
        Dimension old;
<span class="nc bnc" id="L2732" title="All 2 branches missed.">        if (maxSizeSet) {</span>
<span class="nc" id="L2733">            old = this.maxSize;</span>
        }
        else {
<span class="nc" id="L2736">            old = null;</span>
        }
<span class="nc" id="L2738">        this.maxSize = maximumSize;</span>
<span class="nc bnc" id="L2739" title="All 2 branches missed.">        maxSizeSet = (maximumSize != null);</span>
<span class="nc" id="L2740">        firePropertyChange(&quot;maximumSize&quot;, old, maximumSize);</span>
<span class="nc" id="L2741">    }</span>

    /**
     * Returns true if the maximum size has been set to a non-&lt;code&gt;null&lt;/code&gt;
     * value otherwise returns false.
     *
     * @return true if &lt;code&gt;maximumSize&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;,
     *          false otherwise
     * @since 1.5
     */
    public boolean isMaximumSizeSet() {
<span class="nc" id="L2752">        return maxSizeSet;</span>
    }

    /**
     * Gets the maximum size of this component.
     * @return a dimension object indicating this component's maximum size
     * @see #getMinimumSize
     * @see #getPreferredSize
     * @see LayoutManager
     */
    public Dimension getMaximumSize() {
<span class="nc bnc" id="L2763" title="All 2 branches missed.">        if (isMaximumSizeSet()) {</span>
<span class="nc" id="L2764">            return new Dimension(maxSize);</span>
        }
<span class="nc" id="L2766">        return new Dimension(Short.MAX_VALUE, Short.MAX_VALUE);</span>
    }

    /**
     * Returns the alignment along the x axis.  This specifies how
     * the component would like to be aligned relative to other
     * components.  The value should be a number between 0 and 1
     * where 0 represents alignment along the origin, 1 is aligned
     * the furthest away from the origin, 0.5 is centered, etc.
     */
    public float getAlignmentX() {
<span class="nc" id="L2777">        return CENTER_ALIGNMENT;</span>
    }

    /**
     * Returns the alignment along the y axis.  This specifies how
     * the component would like to be aligned relative to other
     * components.  The value should be a number between 0 and 1
     * where 0 represents alignment along the origin, 1 is aligned
     * the furthest away from the origin, 0.5 is centered, etc.
     */
    public float getAlignmentY() {
<span class="nc" id="L2788">        return CENTER_ALIGNMENT;</span>
    }

    /**
     * Returns the baseline.  The baseline is measured from the top of
     * the component.  This method is primarily meant for
     * &lt;code&gt;LayoutManager&lt;/code&gt;s to align components along their
     * baseline.  A return value less than 0 indicates this component
     * does not have a reasonable baseline and that
     * &lt;code&gt;LayoutManager&lt;/code&gt;s should not align this component on
     * its baseline.
     * &lt;p&gt;
     * The default implementation returns -1.  Subclasses that support
     * baseline should override appropriately.  If a value &amp;gt;= 0 is
     * returned, then the component has a valid baseline for any
     * size &amp;gt;= the minimum size and &lt;code&gt;getBaselineResizeBehavior&lt;/code&gt;
     * can be used to determine how the baseline changes with size.
     *
     * @param width the width to get the baseline for
     * @param height the height to get the baseline for
     * @return the baseline or &amp;lt; 0 indicating there is no reasonable
     *         baseline
     * @throws IllegalArgumentException if width or height is &amp;lt; 0
     * @see #getBaselineResizeBehavior
     * @see java.awt.FontMetrics
     * @since 1.6
     */
    public int getBaseline(int width, int height) {
<span class="nc bnc" id="L2816" title="All 4 branches missed.">        if (width &lt; 0 || height &lt; 0) {</span>
<span class="nc" id="L2817">            throw new IllegalArgumentException(</span>
                    &quot;Width and height must be &gt;= 0&quot;);
        }
<span class="nc" id="L2820">        return -1;</span>
    }

    /**
     * Returns an enum indicating how the baseline of the component
     * changes as the size changes.  This method is primarily meant for
     * layout managers and GUI builders.
     * &lt;p&gt;
     * The default implementation returns
     * &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt;.  Subclasses that have a
     * baseline should override appropriately.  Subclasses should
     * never return &lt;code&gt;null&lt;/code&gt;; if the baseline can not be
     * calculated return &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt;.  Callers
     * should first ask for the baseline using
     * &lt;code&gt;getBaseline&lt;/code&gt; and if a value &amp;gt;= 0 is returned use
     * this method.  It is acceptable for this method to return a
     * value other than &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt; even if
     * &lt;code&gt;getBaseline&lt;/code&gt; returns a value less than 0.
     *
     * @return an enum indicating how the baseline changes as the component
     *         size changes
     * @see #getBaseline(int, int)
     * @since 1.6
     */
    public BaselineResizeBehavior getBaselineResizeBehavior() {
<span class="nc" id="L2845">        return BaselineResizeBehavior.OTHER;</span>
    }

    /**
     * Prompts the layout manager to lay out this component. This is
     * usually called when the component (more specifically, container)
     * is validated.
     * @see #validate
     * @see LayoutManager
     */
    public void doLayout() {
<span class="nc" id="L2856">        layout();</span>
<span class="nc" id="L2857">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;doLayout()&lt;/code&gt;.
     */
    @Deprecated
    public void layout() {
<span class="nc" id="L2865">    }</span>

    /**
     * Validates this component.
     * &lt;p&gt;
     * The meaning of the term &lt;i&gt;validating&lt;/i&gt; is defined by the ancestors of
     * this class. See {@link Container#validate} for more details.
     *
     * @see       #invalidate
     * @see       #doLayout()
     * @see       LayoutManager
     * @see       Container#validate
     * @since     JDK1.0
     */
    public void validate() {
<span class="nc" id="L2880">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L2881">            ComponentPeer peer = this.peer;</span>
<span class="nc" id="L2882">            boolean wasValid = isValid();</span>
<span class="nc bnc" id="L2883" title="All 4 branches missed.">            if (!wasValid &amp;&amp; peer != null) {</span>
<span class="nc" id="L2884">                Font newfont = getFont();</span>
<span class="nc" id="L2885">                Font oldfont = peerFont;</span>
<span class="nc bnc" id="L2886" title="All 4 branches missed.">                if (newfont != oldfont &amp;&amp; (oldfont == null</span>
<span class="nc bnc" id="L2887" title="All 2 branches missed.">                                           || !oldfont.equals(newfont))) {</span>
<span class="nc" id="L2888">                    peer.setFont(newfont);</span>
<span class="nc" id="L2889">                    peerFont = newfont;</span>
                }
<span class="nc" id="L2891">                peer.layout();</span>
            }
<span class="nc" id="L2893">            valid = true;</span>
<span class="nc bnc" id="L2894" title="All 2 branches missed.">            if (!wasValid) {</span>
<span class="nc" id="L2895">                mixOnValidating();</span>
            }
<span class="nc" id="L2897">        }</span>
<span class="nc" id="L2898">    }</span>

    /**
     * Invalidates this component and its ancestors.
     * &lt;p&gt;
     * By default, all the ancestors of the component up to the top-most
     * container of the hierarchy are marked invalid. If the {@code
     * java.awt.smartInvalidate} system property is set to {@code true},
     * invalidation stops on the nearest validate root of this component.
     * Marking a container &lt;i&gt;invalid&lt;/i&gt; indicates that the container needs to
     * be laid out.
     * &lt;p&gt;
     * This method is called automatically when any layout-related information
     * changes (e.g. setting the bounds of the component, or adding the
     * component to a container).
     * &lt;p&gt;
     * This method might be called often, so it should work fast.
     *
     * @see       #validate
     * @see       #doLayout
     * @see       LayoutManager
     * @see       java.awt.Container#isValidateRoot
     * @since     JDK1.0
     */
    public void invalidate() {
<span class="nc" id="L2923">        synchronized (getTreeLock()) {</span>
            /* Nullify cached layout and size information.
             * For efficiency, propagate invalidate() upwards only if
             * some other component hasn't already done so first.
             */
<span class="nc" id="L2928">            valid = false;</span>
<span class="nc bnc" id="L2929" title="All 2 branches missed.">            if (!isPreferredSizeSet()) {</span>
<span class="nc" id="L2930">                prefSize = null;</span>
            }
<span class="nc bnc" id="L2932" title="All 2 branches missed.">            if (!isMinimumSizeSet()) {</span>
<span class="nc" id="L2933">                minSize = null;</span>
            }
<span class="nc bnc" id="L2935" title="All 2 branches missed.">            if (!isMaximumSizeSet()) {</span>
<span class="nc" id="L2936">                maxSize = null;</span>
            }
<span class="nc" id="L2938">            invalidateParent();</span>
<span class="nc" id="L2939">        }</span>
<span class="nc" id="L2940">    }</span>

    /**
     * Invalidates the parent of this component if any.
     *
     * This method MUST BE invoked under the TreeLock.
     */
    void invalidateParent() {
<span class="nc bnc" id="L2948" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L2949">            parent.invalidateIfValid();</span>
        }
<span class="nc" id="L2951">    }</span>

    /** Invalidates the component unless it is already invalid.
     */
    final void invalidateIfValid() {
<span class="nc bnc" id="L2956" title="All 2 branches missed.">        if (isValid()) {</span>
<span class="nc" id="L2957">            invalidate();</span>
        }
<span class="nc" id="L2959">    }</span>

    /**
     * Revalidates the component hierarchy up to the nearest validate root.
     * &lt;p&gt;
     * This method first invalidates the component hierarchy starting from this
     * component up to the nearest validate root. Afterwards, the component
     * hierarchy is validated starting from the nearest validate root.
     * &lt;p&gt;
     * This is a convenience method supposed to help application developers
     * avoid looking for validate roots manually. Basically, it's equivalent to
     * first calling the {@link #invalidate()} method on this component, and
     * then calling the {@link #validate()} method on the nearest validate
     * root.
     *
     * @see Container#isValidateRoot
     * @since 1.7
     */
    public void revalidate() {
<span class="nc" id="L2978">        revalidateSynchronously();</span>
<span class="nc" id="L2979">    }</span>

    /**
     * Revalidates the component synchronously.
     */
    final void revalidateSynchronously() {
<span class="nc" id="L2985">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L2986">            invalidate();</span>

<span class="nc" id="L2988">            Container root = getContainer();</span>
<span class="nc bnc" id="L2989" title="All 2 branches missed.">            if (root == null) {</span>
                // There's no parents. Just validate itself.
<span class="nc" id="L2991">                validate();</span>
            } else {
<span class="nc bnc" id="L2993" title="All 2 branches missed.">                while (!root.isValidateRoot()) {</span>
<span class="nc bnc" id="L2994" title="All 2 branches missed.">                    if (root.getContainer() == null) {</span>
                        // If there's no validate roots, we'll validate the
                        // topmost container
<span class="nc" id="L2997">                        break;</span>
                    }

<span class="nc" id="L3000">                    root = root.getContainer();</span>
                }

<span class="nc" id="L3003">                root.validate();</span>
            }
<span class="nc" id="L3005">        }</span>
<span class="nc" id="L3006">    }</span>

    /**
     * Creates a graphics context for this component. This method will
     * return &lt;code&gt;null&lt;/code&gt; if this component is currently not
     * displayable.
     * @return a graphics context for this component, or &lt;code&gt;null&lt;/code&gt;
     *             if it has none
     * @see       #paint
     * @since     JDK1.0
     */
    public Graphics getGraphics() {
<span class="nc bnc" id="L3018" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
            // This is for a lightweight component, need to
            // translate coordinate spaces and clip relative
            // to the parent.
<span class="nc bnc" id="L3022" title="All 2 branches missed.">            if (parent == null) return null;</span>
<span class="nc" id="L3023">            Graphics g = parent.getGraphics();</span>
<span class="nc bnc" id="L3024" title="All 2 branches missed.">            if (g == null) return null;</span>
<span class="nc bnc" id="L3025" title="All 2 branches missed.">            if (g instanceof ConstrainableGraphics) {</span>
<span class="nc" id="L3026">                ((ConstrainableGraphics) g).constrain(x, y, width, height);</span>
            } else {
<span class="nc" id="L3028">                g.translate(x,y);</span>
<span class="nc" id="L3029">                g.setClip(0, 0, width, height);</span>
            }
<span class="nc" id="L3031">            g.setFont(getFont());</span>
<span class="nc" id="L3032">            return g;</span>
        } else {
<span class="nc" id="L3034">            ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L3035" title="All 2 branches missed.">            return (peer != null) ? peer.getGraphics() : null;</span>
        }
    }

    final Graphics getGraphics_NoClientCode() {
<span class="nc" id="L3040">        ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L3041" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
            // This is for a lightweight component, need to
            // translate coordinate spaces and clip relative
            // to the parent.
<span class="nc" id="L3045">            Container parent = this.parent;</span>
<span class="nc bnc" id="L3046" title="All 2 branches missed.">            if (parent == null) return null;</span>
<span class="nc" id="L3047">            Graphics g = parent.getGraphics_NoClientCode();</span>
<span class="nc bnc" id="L3048" title="All 2 branches missed.">            if (g == null) return null;</span>
<span class="nc bnc" id="L3049" title="All 2 branches missed.">            if (g instanceof ConstrainableGraphics) {</span>
<span class="nc" id="L3050">                ((ConstrainableGraphics) g).constrain(x, y, width, height);</span>
            } else {
<span class="nc" id="L3052">                g.translate(x,y);</span>
<span class="nc" id="L3053">                g.setClip(0, 0, width, height);</span>
            }
<span class="nc" id="L3055">            g.setFont(getFont_NoClientCode());</span>
<span class="nc" id="L3056">            return g;</span>
        } else {
<span class="nc bnc" id="L3058" title="All 2 branches missed.">            return (peer != null) ? peer.getGraphics() : null;</span>
        }
    }

    /**
     * Gets the font metrics for the specified font.
     * Warning: Since Font metrics are affected by the
     * {@link java.awt.font.FontRenderContext FontRenderContext} and
     * this method does not provide one, it can return only metrics for
     * the default render context which may not match that used when
     * rendering on the Component if {@link Graphics2D} functionality is being
     * used. Instead metrics can be obtained at rendering time by calling
     * {@link Graphics#getFontMetrics()} or text measurement APIs on the
     * {@link Font Font} class.
     * @param font the font for which font metrics is to be
     *          obtained
     * @return the font metrics for &lt;code&gt;font&lt;/code&gt;
     * @see       #getFont
     * @see       #getPeer
     * @see       java.awt.peer.ComponentPeer#getFontMetrics(Font)
     * @see       Toolkit#getFontMetrics(Font)
     * @since     JDK1.0
     */
    public FontMetrics getFontMetrics(Font font) {
        // This is an unsupported hack, but left in for a customer.
        // Do not remove.
<span class="nc" id="L3084">        FontManager fm = FontManagerFactory.getInstance();</span>
<span class="nc bnc" id="L3085" title="All 2 branches missed.">        if (fm instanceof SunFontManager</span>
<span class="nc bnc" id="L3086" title="All 2 branches missed.">            &amp;&amp; ((SunFontManager) fm).usePlatformFontMetrics()) {</span>

<span class="nc bnc" id="L3088" title="All 4 branches missed.">            if (peer != null &amp;&amp;</span>
                !(peer instanceof LightweightPeer)) {
<span class="nc" id="L3090">                return peer.getFontMetrics(font);</span>
            }
        }
<span class="nc" id="L3093">        return sun.font.FontDesignMetrics.getMetrics(font);</span>
    }

    /**
     * Sets the cursor image to the specified cursor.  This cursor
     * image is displayed when the &lt;code&gt;contains&lt;/code&gt; method for
     * this component returns true for the current cursor location, and
     * this Component is visible, displayable, and enabled. Setting the
     * cursor of a &lt;code&gt;Container&lt;/code&gt; causes that cursor to be displayed
     * within all of the container's subcomponents, except for those
     * that have a non-&lt;code&gt;null&lt;/code&gt; cursor.
     * &lt;p&gt;
     * The method may have no visual effect if the Java platform
     * implementation and/or the native system do not support
     * changing the mouse cursor shape.
     * @param cursor One of the constants defined
     *          by the &lt;code&gt;Cursor&lt;/code&gt; class;
     *          if this parameter is &lt;code&gt;null&lt;/code&gt;
     *          then this component will inherit
     *          the cursor of its parent
     * @see       #isEnabled
     * @see       #isShowing
     * @see       #getCursor
     * @see       #contains
     * @see       Toolkit#createCustomCursor
     * @see       Cursor
     * @since     JDK1.1
     */
    public void setCursor(Cursor cursor) {
<span class="nc" id="L3122">        this.cursor = cursor;</span>
<span class="nc" id="L3123">        updateCursorImmediately();</span>
<span class="nc" id="L3124">    }</span>

    /**
     * Updates the cursor.  May not be invoked from the native
     * message pump.
     */
    final void updateCursorImmediately() {
<span class="nc bnc" id="L3131" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
<span class="nc" id="L3132">            Container nativeContainer = getNativeContainer();</span>

<span class="nc bnc" id="L3134" title="All 2 branches missed.">            if (nativeContainer == null) return;</span>

<span class="nc" id="L3136">            ComponentPeer cPeer = nativeContainer.getPeer();</span>

<span class="nc bnc" id="L3138" title="All 2 branches missed.">            if (cPeer != null) {</span>
<span class="nc" id="L3139">                cPeer.updateCursorImmediately();</span>
            }
<span class="nc bnc" id="L3141" title="All 2 branches missed.">        } else if (peer != null) {</span>
<span class="nc" id="L3142">            peer.updateCursorImmediately();</span>
        }
<span class="nc" id="L3144">    }</span>

    /**
     * Gets the cursor set in the component. If the component does
     * not have a cursor set, the cursor of its parent is returned.
     * If no cursor is set in the entire hierarchy,
     * &lt;code&gt;Cursor.DEFAULT_CURSOR&lt;/code&gt; is returned.
     * @see #setCursor
     * @since      JDK1.1
     */
    public Cursor getCursor() {
<span class="nc" id="L3155">        return getCursor_NoClientCode();</span>
    }

    final Cursor getCursor_NoClientCode() {
<span class="nc" id="L3159">        Cursor cursor = this.cursor;</span>
<span class="nc bnc" id="L3160" title="All 2 branches missed.">        if (cursor != null) {</span>
<span class="nc" id="L3161">            return cursor;</span>
        }
<span class="nc" id="L3163">        Container parent = this.parent;</span>
<span class="nc bnc" id="L3164" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L3165">            return parent.getCursor_NoClientCode();</span>
        } else {
<span class="nc" id="L3167">            return Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);</span>
        }
    }

    /**
     * Returns whether the cursor has been explicitly set for this Component.
     * If this method returns &lt;code&gt;false&lt;/code&gt;, this Component is inheriting
     * its cursor from an ancestor.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor has been explicitly set for this
     *         Component; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.4
     */
    public boolean isCursorSet() {
<span class="nc bnc" id="L3181" title="All 2 branches missed.">        return (cursor != null);</span>
    }

    /**
     * Paints this component.
     * &lt;p&gt;
     * This method is called when the contents of the component should
     * be painted; such as when the component is first being shown or
     * is damaged and in need of repair.  The clip rectangle in the
     * &lt;code&gt;Graphics&lt;/code&gt; parameter is set to the area
     * which needs to be painted.
     * Subclasses of &lt;code&gt;Component&lt;/code&gt; that override this
     * method need not call &lt;code&gt;super.paint(g)&lt;/code&gt;.
     * &lt;p&gt;
     * For performance reasons, &lt;code&gt;Component&lt;/code&gt;s with zero width
     * or height aren't considered to need painting when they are first shown,
     * and also aren't considered to need repair.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
     * by AWT and Swing, including information on how to write the most
     * efficient painting code, see
     * &lt;a href=&quot;http://www.oracle.com/technetwork/java/painting-140037.html&quot;&gt;Painting in AWT and Swing&lt;/a&gt;.
     *
     * @param g the graphics context to use for painting
     * @see       #update
     * @since     JDK1.0
     */
    public void paint(Graphics g) {
<span class="nc" id="L3209">    }</span>

    /**
     * Updates this component.
     * &lt;p&gt;
     * If this component is not a lightweight component, the
     * AWT calls the &lt;code&gt;update&lt;/code&gt; method in response to
     * a call to &lt;code&gt;repaint&lt;/code&gt;.  You can assume that
     * the background is not cleared.
     * &lt;p&gt;
     * The &lt;code&gt;update&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;
     * calls this component's &lt;code&gt;paint&lt;/code&gt; method to redraw
     * this component.  This method is commonly overridden by subclasses
     * which need to do additional work in response to a call to
     * &lt;code&gt;repaint&lt;/code&gt;.
     * Subclasses of Component that override this method should either
     * call &lt;code&gt;super.update(g)&lt;/code&gt;, or call &lt;code&gt;paint(g)&lt;/code&gt;
     * directly from their &lt;code&gt;update&lt;/code&gt; method.
     * &lt;p&gt;
     * The origin of the graphics context, its
     * (&lt;code&gt;0&lt;/code&gt;,&amp;nbsp;&lt;code&gt;0&lt;/code&gt;) coordinate point, is the
     * top-left corner of this component. The clipping region of the
     * graphics context is the bounding rectangle of this component.
     *
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
     * by AWT and Swing, including information on how to write the most
     * efficient painting code, see
     * &lt;a href=&quot;http://www.oracle.com/technetwork/java/painting-140037.html&quot;&gt;Painting in AWT and Swing&lt;/a&gt;.
     *
     * @param g the specified context to use for updating
     * @see       #paint
     * @see       #repaint()
     * @since     JDK1.0
     */
    public void update(Graphics g) {
<span class="nc" id="L3245">        paint(g);</span>
<span class="nc" id="L3246">    }</span>

    /**
     * Paints this component and all of its subcomponents.
     * &lt;p&gt;
     * The origin of the graphics context, its
     * (&lt;code&gt;0&lt;/code&gt;,&amp;nbsp;&lt;code&gt;0&lt;/code&gt;) coordinate point, is the
     * top-left corner of this component. The clipping region of the
     * graphics context is the bounding rectangle of this component.
     *
     * @param     g   the graphics context to use for painting
     * @see       #paint
     * @since     JDK1.0
     */
    public void paintAll(Graphics g) {
<span class="nc bnc" id="L3261" title="All 2 branches missed.">        if (isShowing()) {</span>
<span class="nc" id="L3262">            GraphicsCallback.PeerPaintCallback.getInstance().</span>
<span class="nc" id="L3263">                runOneComponent(this, new Rectangle(0, 0, width, height),</span>
<span class="nc" id="L3264">                                g, g.getClip(),</span>
                                GraphicsCallback.LIGHTWEIGHTS |
                                GraphicsCallback.HEAVYWEIGHTS);
        }
<span class="nc" id="L3268">    }</span>

    /**
     * Simulates the peer callbacks into java.awt for painting of
     * lightweight Components.
     * @param     g   the graphics context to use for painting
     * @see       #paintAll
     */
    void lightweightPaint(Graphics g) {
<span class="nc" id="L3277">        paint(g);</span>
<span class="nc" id="L3278">    }</span>

    /**
     * Paints all the heavyweight subcomponents.
     */
    void paintHeavyweightComponents(Graphics g) {
<span class="nc" id="L3284">    }</span>

    /**
     * Repaints this component.
     * &lt;p&gt;
     * If this component is a lightweight component, this method
     * causes a call to this component's &lt;code&gt;paint&lt;/code&gt;
     * method as soon as possible.  Otherwise, this method causes
     * a call to this component's &lt;code&gt;update&lt;/code&gt; method as soon
     * as possible.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
     * by AWT and Swing, including information on how to write the most
     * efficient painting code, see
     * &lt;a href=&quot;http://www.oracle.com/technetwork/java/painting-140037.html&quot;&gt;Painting in AWT and Swing&lt;/a&gt;.

     *
     * @see       #update(Graphics)
     * @since     JDK1.0
     */
    public void repaint() {
<span class="nc" id="L3305">        repaint(0, 0, 0, width, height);</span>
<span class="nc" id="L3306">    }</span>

    /**
     * Repaints the component.  If this component is a lightweight
     * component, this results in a call to &lt;code&gt;paint&lt;/code&gt;
     * within &lt;code&gt;tm&lt;/code&gt; milliseconds.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
     * by AWT and Swing, including information on how to write the most
     * efficient painting code, see
     * &lt;a href=&quot;http://www.oracle.com/technetwork/java/painting-140037.html&quot;&gt;Painting in AWT and Swing&lt;/a&gt;.
     *
     * @param tm maximum time in milliseconds before update
     * @see #paint
     * @see #update(Graphics)
     * @since JDK1.0
     */
    public void repaint(long tm) {
<span class="nc" id="L3324">        repaint(tm, 0, 0, width, height);</span>
<span class="nc" id="L3325">    }</span>

    /**
     * Repaints the specified rectangle of this component.
     * &lt;p&gt;
     * If this component is a lightweight component, this method
     * causes a call to this component's &lt;code&gt;paint&lt;/code&gt; method
     * as soon as possible.  Otherwise, this method causes a call to
     * this component's &lt;code&gt;update&lt;/code&gt; method as soon as possible.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
     * by AWT and Swing, including information on how to write the most
     * efficient painting code, see
     * &lt;a href=&quot;http://www.oracle.com/technetwork/java/painting-140037.html&quot;&gt;Painting in AWT and Swing&lt;/a&gt;.
     *
     * @param     x   the &lt;i&gt;x&lt;/i&gt; coordinate
     * @param     y   the &lt;i&gt;y&lt;/i&gt; coordinate
     * @param     width   the width
     * @param     height  the height
     * @see       #update(Graphics)
     * @since     JDK1.0
     */
    public void repaint(int x, int y, int width, int height) {
<span class="nc" id="L3348">        repaint(0, x, y, width, height);</span>
<span class="nc" id="L3349">    }</span>

    /**
     * Repaints the specified rectangle of this component within
     * &lt;code&gt;tm&lt;/code&gt; milliseconds.
     * &lt;p&gt;
     * If this component is a lightweight component, this method causes
     * a call to this component's &lt;code&gt;paint&lt;/code&gt; method.
     * Otherwise, this method causes a call to this component's
     * &lt;code&gt;update&lt;/code&gt; method.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
     * by AWT and Swing, including information on how to write the most
     * efficient painting code, see
     * &lt;a href=&quot;http://www.oracle.com/technetwork/java/painting-140037.html&quot;&gt;Painting in AWT and Swing&lt;/a&gt;.
     *
     * @param     tm   maximum time in milliseconds before update
     * @param     x    the &lt;i&gt;x&lt;/i&gt; coordinate
     * @param     y    the &lt;i&gt;y&lt;/i&gt; coordinate
     * @param     width    the width
     * @param     height   the height
     * @see       #update(Graphics)
     * @since     JDK1.0
     */
    public void repaint(long tm, int x, int y, int width, int height) {
<span class="nc bnc" id="L3374" title="All 2 branches missed.">        if (this.peer instanceof LightweightPeer) {</span>
            // Needs to be translated to parent coordinates since
            // a parent native container provides the actual repaint
            // services.  Additionally, the request is restricted to
            // the bounds of the component.
<span class="nc bnc" id="L3379" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc bnc" id="L3380" title="All 2 branches missed.">                if (x &lt; 0) {</span>
<span class="nc" id="L3381">                    width += x;</span>
<span class="nc" id="L3382">                    x = 0;</span>
                }
<span class="nc bnc" id="L3384" title="All 2 branches missed.">                if (y &lt; 0) {</span>
<span class="nc" id="L3385">                    height += y;</span>
<span class="nc" id="L3386">                    y = 0;</span>
                }

<span class="nc bnc" id="L3389" title="All 2 branches missed.">                int pwidth = (width &gt; this.width) ? this.width : width;</span>
<span class="nc bnc" id="L3390" title="All 2 branches missed.">                int pheight = (height &gt; this.height) ? this.height : height;</span>

<span class="nc bnc" id="L3392" title="All 4 branches missed.">                if (pwidth &lt;= 0 || pheight &lt;= 0) {</span>
<span class="nc" id="L3393">                    return;</span>
                }

<span class="nc" id="L3396">                int px = this.x + x;</span>
<span class="nc" id="L3397">                int py = this.y + y;</span>
<span class="nc" id="L3398">                parent.repaint(tm, px, py, pwidth, pheight);</span>
<span class="nc" id="L3399">            }</span>
        } else {
<span class="nc bnc" id="L3401" title="All 8 branches missed.">            if (isVisible() &amp;&amp; (this.peer != null) &amp;&amp;</span>
                (width &gt; 0) &amp;&amp; (height &gt; 0)) {
<span class="nc" id="L3403">                PaintEvent e = new PaintEvent(this, PaintEvent.UPDATE,</span>
                                              new Rectangle(x, y, width, height));
<span class="nc" id="L3405">                Toolkit.getEventQueue().postEvent(e);</span>
            }
        }
<span class="nc" id="L3408">    }</span>

    /**
     * Prints this component. Applications should override this method
     * for components that must do special processing before being
     * printed or should be printed differently than they are painted.
     * &lt;p&gt;
     * The default implementation of this method calls the
     * &lt;code&gt;paint&lt;/code&gt; method.
     * &lt;p&gt;
     * The origin of the graphics context, its
     * (&lt;code&gt;0&lt;/code&gt;,&amp;nbsp;&lt;code&gt;0&lt;/code&gt;) coordinate point, is the
     * top-left corner of this component. The clipping region of the
     * graphics context is the bounding rectangle of this component.
     * @param     g   the graphics context to use for printing
     * @see       #paint(Graphics)
     * @since     JDK1.0
     */
    public void print(Graphics g) {
<span class="nc" id="L3427">        paint(g);</span>
<span class="nc" id="L3428">    }</span>

    /**
     * Prints this component and all of its subcomponents.
     * &lt;p&gt;
     * The origin of the graphics context, its
     * (&lt;code&gt;0&lt;/code&gt;,&amp;nbsp;&lt;code&gt;0&lt;/code&gt;) coordinate point, is the
     * top-left corner of this component. The clipping region of the
     * graphics context is the bounding rectangle of this component.
     * @param     g   the graphics context to use for printing
     * @see       #print(Graphics)
     * @since     JDK1.0
     */
    public void printAll(Graphics g) {
<span class="nc bnc" id="L3442" title="All 2 branches missed.">        if (isShowing()) {</span>
<span class="nc" id="L3443">            GraphicsCallback.PeerPrintCallback.getInstance().</span>
<span class="nc" id="L3444">                runOneComponent(this, new Rectangle(0, 0, width, height),</span>
<span class="nc" id="L3445">                                g, g.getClip(),</span>
                                GraphicsCallback.LIGHTWEIGHTS |
                                GraphicsCallback.HEAVYWEIGHTS);
        }
<span class="nc" id="L3449">    }</span>

    /**
     * Simulates the peer callbacks into java.awt for printing of
     * lightweight Components.
     * @param     g   the graphics context to use for printing
     * @see       #printAll
     */
    void lightweightPrint(Graphics g) {
<span class="nc" id="L3458">        print(g);</span>
<span class="nc" id="L3459">    }</span>

    /**
     * Prints all the heavyweight subcomponents.
     */
    void printHeavyweightComponents(Graphics g) {
<span class="nc" id="L3465">    }</span>

    private Insets getInsets_NoClientCode() {
<span class="nc" id="L3468">        ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L3469" title="All 2 branches missed.">        if (peer instanceof ContainerPeer) {</span>
<span class="nc" id="L3470">            return (Insets)((ContainerPeer)peer).getInsets().clone();</span>
        }
<span class="nc" id="L3472">        return new Insets(0, 0, 0, 0);</span>
    }

    /**
     * Repaints the component when the image has changed.
     * This &lt;code&gt;imageUpdate&lt;/code&gt; method of an &lt;code&gt;ImageObserver&lt;/code&gt;
     * is called when more information about an
     * image which had been previously requested using an asynchronous
     * routine such as the &lt;code&gt;drawImage&lt;/code&gt; method of
     * &lt;code&gt;Graphics&lt;/code&gt; becomes available.
     * See the definition of &lt;code&gt;imageUpdate&lt;/code&gt; for
     * more information on this method and its arguments.
     * &lt;p&gt;
     * The &lt;code&gt;imageUpdate&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;
     * incrementally draws an image on the component as more of the bits
     * of the image are available.
     * &lt;p&gt;
     * If the system property &lt;code&gt;awt.image.incrementaldraw&lt;/code&gt;
     * is missing or has the value &lt;code&gt;true&lt;/code&gt;, the image is
     * incrementally drawn. If the system property has any other value,
     * then the image is not drawn until it has been completely loaded.
     * &lt;p&gt;
     * Also, if incremental drawing is in effect, the value of the
     * system property &lt;code&gt;awt.image.redrawrate&lt;/code&gt; is interpreted
     * as an integer to give the maximum redraw rate, in milliseconds. If
     * the system property is missing or cannot be interpreted as an
     * integer, the redraw rate is once every 100ms.
     * &lt;p&gt;
     * The interpretation of the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;,
     * &lt;code&gt;width&lt;/code&gt;, and &lt;code&gt;height&lt;/code&gt; arguments depends on
     * the value of the &lt;code&gt;infoflags&lt;/code&gt; argument.
     *
     * @param     img   the image being observed
     * @param     infoflags   see &lt;code&gt;imageUpdate&lt;/code&gt; for more information
     * @param     x   the &lt;i&gt;x&lt;/i&gt; coordinate
     * @param     y   the &lt;i&gt;y&lt;/i&gt; coordinate
     * @param     w   the width
     * @param     h   the height
     * @return    &lt;code&gt;false&lt;/code&gt; if the infoflags indicate that the
     *            image is completely loaded; &lt;code&gt;true&lt;/code&gt; otherwise.
     *
     * @see     java.awt.image.ImageObserver
     * @see     Graphics#drawImage(Image, int, int, Color, java.awt.image.ImageObserver)
     * @see     Graphics#drawImage(Image, int, int, java.awt.image.ImageObserver)
     * @see     Graphics#drawImage(Image, int, int, int, int, Color, java.awt.image.ImageObserver)
     * @see     Graphics#drawImage(Image, int, int, int, int, java.awt.image.ImageObserver)
     * @see     java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int, int, int)
     * @since   JDK1.0
     */
    public boolean imageUpdate(Image img, int infoflags,
                               int x, int y, int w, int h) {
<span class="nc" id="L3523">        int rate = -1;</span>
<span class="nc bnc" id="L3524" title="All 2 branches missed.">        if ((infoflags &amp; (FRAMEBITS|ALLBITS)) != 0) {</span>
<span class="nc" id="L3525">            rate = 0;</span>
<span class="nc bnc" id="L3526" title="All 2 branches missed.">        } else if ((infoflags &amp; SOMEBITS) != 0) {</span>
<span class="nc bnc" id="L3527" title="All 2 branches missed.">            if (isInc) {</span>
<span class="nc" id="L3528">                rate = incRate;</span>
<span class="nc bnc" id="L3529" title="All 2 branches missed.">                if (rate &lt; 0) {</span>
<span class="nc" id="L3530">                    rate = 0;</span>
                }
            }
        }
<span class="nc bnc" id="L3534" title="All 2 branches missed.">        if (rate &gt;= 0) {</span>
<span class="nc" id="L3535">            repaint(rate, 0, 0, width, height);</span>
        }
<span class="nc bnc" id="L3537" title="All 2 branches missed.">        return (infoflags &amp; (ALLBITS|ABORT)) == 0;</span>
    }

    /**
     * Creates an image from the specified image producer.
     * @param     producer  the image producer
     * @return    the image produced
     * @since     JDK1.0
     */
    public Image createImage(ImageProducer producer) {
<span class="nc" id="L3547">        ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L3548" title="All 4 branches missed.">        if ((peer != null) &amp;&amp; ! (peer instanceof LightweightPeer)) {</span>
<span class="nc" id="L3549">            return peer.createImage(producer);</span>
        }
<span class="nc" id="L3551">        return getToolkit().createImage(producer);</span>
    }

    /**
     * Creates an off-screen drawable image
     *     to be used for double buffering.
     * @param     width the specified width
     * @param     height the specified height
     * @return    an off-screen drawable image, which can be used for double
     *    buffering.  The return value may be &lt;code&gt;null&lt;/code&gt; if the
     *    component is not displayable.  This will always happen if
     *    &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt; returns
     *    &lt;code&gt;true&lt;/code&gt;.
     * @see #isDisplayable
     * @see GraphicsEnvironment#isHeadless
     * @since     JDK1.0
     */
    public Image createImage(int width, int height) {
<span class="nc" id="L3569">        ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L3570" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
<span class="nc bnc" id="L3571" title="All 2 branches missed.">            if (parent != null) { return parent.createImage(width, height); }</span>
<span class="nc" id="L3572">            else { return null;}</span>
        } else {
<span class="nc bnc" id="L3574" title="All 2 branches missed.">            return (peer != null) ? peer.createImage(width, height) : null;</span>
        }
    }

    /**
     * Creates a volatile off-screen drawable image
     *     to be used for double buffering.
     * @param     width the specified width.
     * @param     height the specified height.
     * @return    an off-screen drawable image, which can be used for double
     *    buffering.  The return value may be &lt;code&gt;null&lt;/code&gt; if the
     *    component is not displayable.  This will always happen if
     *    &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt; returns
     *    &lt;code&gt;true&lt;/code&gt;.
     * @see java.awt.image.VolatileImage
     * @see #isDisplayable
     * @see GraphicsEnvironment#isHeadless
     * @since     1.4
     */
    public VolatileImage createVolatileImage(int width, int height) {
<span class="nc" id="L3594">        ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L3595" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
<span class="nc bnc" id="L3596" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L3597">                return parent.createVolatileImage(width, height);</span>
            }
<span class="nc" id="L3599">            else { return null;}</span>
        } else {
<span class="nc bnc" id="L3601" title="All 2 branches missed.">            return (peer != null) ?</span>
<span class="nc" id="L3602">                peer.createVolatileImage(width, height) : null;</span>
        }
    }

    /**
     * Creates a volatile off-screen drawable image, with the given capabilities.
     * The contents of this image may be lost at any time due
     * to operating system issues, so the image must be managed
     * via the &lt;code&gt;VolatileImage&lt;/code&gt; interface.
     * @param width the specified width.
     * @param height the specified height.
     * @param caps the image capabilities
     * @exception AWTException if an image with the specified capabilities cannot
     * be created
     * @return a VolatileImage object, which can be used
     * to manage surface contents loss and capabilities.
     * @see java.awt.image.VolatileImage
     * @since 1.4
     */
    public VolatileImage createVolatileImage(int width, int height,
                                             ImageCapabilities caps) throws AWTException {
        // REMIND : check caps
<span class="nc" id="L3624">        return createVolatileImage(width, height);</span>
    }

    /**
     * Prepares an image for rendering on this component.  The image
     * data is downloaded asynchronously in another thread and the
     * appropriate screen representation of the image is generated.
     * @param     image   the &lt;code&gt;Image&lt;/code&gt; for which to
     *                    prepare a screen representation
     * @param     observer   the &lt;code&gt;ImageObserver&lt;/code&gt; object
     *                       to be notified as the image is being prepared
     * @return    &lt;code&gt;true&lt;/code&gt; if the image has already been fully
     *           prepared; &lt;code&gt;false&lt;/code&gt; otherwise
     * @since     JDK1.0
     */
    public boolean prepareImage(Image image, ImageObserver observer) {
<span class="nc" id="L3640">        return prepareImage(image, -1, -1, observer);</span>
    }

    /**
     * Prepares an image for rendering on this component at the
     * specified width and height.
     * &lt;p&gt;
     * The image data is downloaded asynchronously in another thread,
     * and an appropriately scaled screen representation of the image is
     * generated.
     * @param     image    the instance of &lt;code&gt;Image&lt;/code&gt;
     *            for which to prepare a screen representation
     * @param     width    the width of the desired screen representation
     * @param     height   the height of the desired screen representation
     * @param     observer   the &lt;code&gt;ImageObserver&lt;/code&gt; object
     *            to be notified as the image is being prepared
     * @return    &lt;code&gt;true&lt;/code&gt; if the image has already been fully
     *          prepared; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see       java.awt.image.ImageObserver
     * @since     JDK1.0
     */
    public boolean prepareImage(Image image, int width, int height,
                                ImageObserver observer) {
<span class="nc" id="L3663">        ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L3664" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
<span class="nc bnc" id="L3665" title="All 2 branches missed.">            return (parent != null)</span>
<span class="nc" id="L3666">                ? parent.prepareImage(image, width, height, observer)</span>
<span class="nc" id="L3667">                : getToolkit().prepareImage(image, width, height, observer);</span>
        } else {
<span class="nc bnc" id="L3669" title="All 2 branches missed.">            return (peer != null)</span>
<span class="nc" id="L3670">                ? peer.prepareImage(image, width, height, observer)</span>
<span class="nc" id="L3671">                : getToolkit().prepareImage(image, width, height, observer);</span>
        }
    }

    /**
     * Returns the status of the construction of a screen representation
     * of the specified image.
     * &lt;p&gt;
     * This method does not cause the image to begin loading. An
     * application must use the &lt;code&gt;prepareImage&lt;/code&gt; method
     * to force the loading of an image.
     * &lt;p&gt;
     * Information on the flags returned by this method can be found
     * with the discussion of the &lt;code&gt;ImageObserver&lt;/code&gt; interface.
     * @param     image   the &lt;code&gt;Image&lt;/code&gt; object whose status
     *            is being checked
     * @param     observer   the &lt;code&gt;ImageObserver&lt;/code&gt;
     *            object to be notified as the image is being prepared
     * @return  the bitwise inclusive &lt;b&gt;OR&lt;/b&gt; of
     *            &lt;code&gt;ImageObserver&lt;/code&gt; flags indicating what
     *            information about the image is currently available
     * @see      #prepareImage(Image, int, int, java.awt.image.ImageObserver)
     * @see      Toolkit#checkImage(Image, int, int, java.awt.image.ImageObserver)
     * @see      java.awt.image.ImageObserver
     * @since    JDK1.0
     */
    public int checkImage(Image image, ImageObserver observer) {
<span class="nc" id="L3698">        return checkImage(image, -1, -1, observer);</span>
    }

    /**
     * Returns the status of the construction of a screen representation
     * of the specified image.
     * &lt;p&gt;
     * This method does not cause the image to begin loading. An
     * application must use the &lt;code&gt;prepareImage&lt;/code&gt; method
     * to force the loading of an image.
     * &lt;p&gt;
     * The &lt;code&gt;checkImage&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;
     * calls its peer's &lt;code&gt;checkImage&lt;/code&gt; method to calculate
     * the flags. If this component does not yet have a peer, the
     * component's toolkit's &lt;code&gt;checkImage&lt;/code&gt; method is called
     * instead.
     * &lt;p&gt;
     * Information on the flags returned by this method can be found
     * with the discussion of the &lt;code&gt;ImageObserver&lt;/code&gt; interface.
     * @param     image   the &lt;code&gt;Image&lt;/code&gt; object whose status
     *                    is being checked
     * @param     width   the width of the scaled version
     *                    whose status is to be checked
     * @param     height  the height of the scaled version
     *                    whose status is to be checked
     * @param     observer   the &lt;code&gt;ImageObserver&lt;/code&gt; object
     *                    to be notified as the image is being prepared
     * @return    the bitwise inclusive &lt;b&gt;OR&lt;/b&gt; of
     *            &lt;code&gt;ImageObserver&lt;/code&gt; flags indicating what
     *            information about the image is currently available
     * @see      #prepareImage(Image, int, int, java.awt.image.ImageObserver)
     * @see      Toolkit#checkImage(Image, int, int, java.awt.image.ImageObserver)
     * @see      java.awt.image.ImageObserver
     * @since    JDK1.0
     */
    public int checkImage(Image image, int width, int height,
                          ImageObserver observer) {
<span class="nc" id="L3735">        ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L3736" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
<span class="nc bnc" id="L3737" title="All 2 branches missed.">            return (parent != null)</span>
<span class="nc" id="L3738">                ? parent.checkImage(image, width, height, observer)</span>
<span class="nc" id="L3739">                : getToolkit().checkImage(image, width, height, observer);</span>
        } else {
<span class="nc bnc" id="L3741" title="All 2 branches missed.">            return (peer != null)</span>
<span class="nc" id="L3742">                ? peer.checkImage(image, width, height, observer)</span>
<span class="nc" id="L3743">                : getToolkit().checkImage(image, width, height, observer);</span>
        }
    }

    /**
     * Creates a new strategy for multi-buffering on this component.
     * Multi-buffering is useful for rendering performance.  This method
     * attempts to create the best strategy available with the number of
     * buffers supplied.  It will always create a &lt;code&gt;BufferStrategy&lt;/code&gt;
     * with that number of buffers.
     * A page-flipping strategy is attempted first, then a blitting strategy
     * using accelerated buffers.  Finally, an unaccelerated blitting
     * strategy is used.
     * &lt;p&gt;
     * Each time this method is called,
     * the existing buffer strategy for this component is discarded.
     * @param numBuffers number of buffers to create, including the front buffer
     * @exception IllegalArgumentException if numBuffers is less than 1.
     * @exception IllegalStateException if the component is not displayable
     * @see #isDisplayable
     * @see Window#getBufferStrategy()
     * @see Canvas#getBufferStrategy()
     * @since 1.4
     */
    void createBufferStrategy(int numBuffers) {
        BufferCapabilities bufferCaps;
<span class="nc bnc" id="L3769" title="All 2 branches missed.">        if (numBuffers &gt; 1) {</span>
            // Try to create a page-flipping strategy
<span class="nc" id="L3771">            bufferCaps = new BufferCapabilities(new ImageCapabilities(true),</span>
                                                new ImageCapabilities(true),
                                                BufferCapabilities.FlipContents.UNDEFINED);
            try {
<span class="nc" id="L3775">                createBufferStrategy(numBuffers, bufferCaps);</span>
<span class="nc" id="L3776">                return; // Success</span>
<span class="nc" id="L3777">            } catch (AWTException e) {</span>
                // Failed
            }
        }
        // Try a blitting (but still accelerated) strategy
<span class="nc" id="L3782">        bufferCaps = new BufferCapabilities(new ImageCapabilities(true),</span>
                                            new ImageCapabilities(true),
                                            null);
        try {
<span class="nc" id="L3786">            createBufferStrategy(numBuffers, bufferCaps);</span>
<span class="nc" id="L3787">            return; // Success</span>
<span class="nc" id="L3788">        } catch (AWTException e) {</span>
            // Failed
        }
        // Try an unaccelerated blitting strategy
<span class="nc" id="L3792">        bufferCaps = new BufferCapabilities(new ImageCapabilities(false),</span>
                                            new ImageCapabilities(false),
                                            null);
        try {
<span class="nc" id="L3796">            createBufferStrategy(numBuffers, bufferCaps);</span>
<span class="nc" id="L3797">            return; // Success</span>
<span class="nc" id="L3798">        } catch (AWTException e) {</span>
            // Code should never reach here (an unaccelerated blitting
            // strategy should always work)
<span class="nc" id="L3801">            throw new InternalError(&quot;Could not create a buffer strategy&quot;, e);</span>
        }
    }

    /**
     * Creates a new strategy for multi-buffering on this component with the
     * required buffer capabilities.  This is useful, for example, if only
     * accelerated memory or page flipping is desired (as specified by the
     * buffer capabilities).
     * &lt;p&gt;
     * Each time this method
     * is called, &lt;code&gt;dispose&lt;/code&gt; will be invoked on the existing
     * &lt;code&gt;BufferStrategy&lt;/code&gt;.
     * @param numBuffers number of buffers to create
     * @param caps the required capabilities for creating the buffer strategy;
     * cannot be &lt;code&gt;null&lt;/code&gt;
     * @exception AWTException if the capabilities supplied could not be
     * supported or met; this may happen, for example, if there is not enough
     * accelerated memory currently available, or if page flipping is specified
     * but not possible.
     * @exception IllegalArgumentException if numBuffers is less than 1, or if
     * caps is &lt;code&gt;null&lt;/code&gt;
     * @see Window#getBufferStrategy()
     * @see Canvas#getBufferStrategy()
     * @since 1.4
     */
    void createBufferStrategy(int numBuffers,
                              BufferCapabilities caps) throws AWTException {
        // Check arguments
<span class="nc bnc" id="L3830" title="All 2 branches missed.">        if (numBuffers &lt; 1) {</span>
<span class="nc" id="L3831">            throw new IllegalArgumentException(</span>
                &quot;Number of buffers must be at least 1&quot;);
        }
<span class="nc bnc" id="L3834" title="All 2 branches missed.">        if (caps == null) {</span>
<span class="nc" id="L3835">            throw new IllegalArgumentException(&quot;No capabilities specified&quot;);</span>
        }
        // Destroy old buffers
<span class="nc bnc" id="L3838" title="All 2 branches missed.">        if (bufferStrategy != null) {</span>
<span class="nc" id="L3839">            bufferStrategy.dispose();</span>
        }
<span class="nc bnc" id="L3841" title="All 2 branches missed.">        if (numBuffers == 1) {</span>
<span class="nc" id="L3842">            bufferStrategy = new SingleBufferStrategy(caps);</span>
        } else {
            SunGraphicsEnvironment sge = (SunGraphicsEnvironment)
<span class="nc" id="L3845">                GraphicsEnvironment.getLocalGraphicsEnvironment();</span>
<span class="nc bnc" id="L3846" title="All 4 branches missed.">            if (!caps.isPageFlipping() &amp;&amp; sge.isFlipStrategyPreferred(peer)) {</span>
<span class="nc" id="L3847">                caps = new ProxyCapabilities(caps);</span>
            }
            // assert numBuffers &gt; 1;
<span class="nc bnc" id="L3850" title="All 2 branches missed.">            if (caps.isPageFlipping()) {</span>
<span class="nc" id="L3851">                bufferStrategy = new FlipSubRegionBufferStrategy(numBuffers, caps);</span>
            } else {
<span class="nc" id="L3853">                bufferStrategy = new BltSubRegionBufferStrategy(numBuffers, caps);</span>
            }
        }
<span class="nc" id="L3856">    }</span>

    /**
     * This is a proxy capabilities class used when a FlipBufferStrategy
     * is created instead of the requested Blit strategy.
     *
     * @see sun.awt.SunGraphicsEnvironment#isFlipStrategyPreferred(ComponentPeer)
     */
    private class ProxyCapabilities extends ExtendedBufferCapabilities {
        private BufferCapabilities orig;
<span class="nc" id="L3866">        private ProxyCapabilities(BufferCapabilities orig) {</span>
<span class="nc" id="L3867">            super(orig.getFrontBufferCapabilities(),</span>
<span class="nc" id="L3868">                  orig.getBackBufferCapabilities(),</span>
<span class="nc bnc" id="L3869" title="All 2 branches missed.">                  orig.getFlipContents() ==</span>
                      BufferCapabilities.FlipContents.BACKGROUND ?
                      BufferCapabilities.FlipContents.BACKGROUND :
                      BufferCapabilities.FlipContents.COPIED);
<span class="nc" id="L3873">            this.orig = orig;</span>
<span class="nc" id="L3874">        }</span>
    }

    /**
     * @return the buffer strategy used by this component
     * @see Window#createBufferStrategy
     * @see Canvas#createBufferStrategy
     * @since 1.4
     */
    BufferStrategy getBufferStrategy() {
<span class="nc" id="L3884">        return bufferStrategy;</span>
    }

    /**
     * @return the back buffer currently used by this component's
     * BufferStrategy.  If there is no BufferStrategy or no
     * back buffer, this method returns null.
     */
    Image getBackBuffer() {
<span class="nc bnc" id="L3893" title="All 2 branches missed.">        if (bufferStrategy != null) {</span>
<span class="nc bnc" id="L3894" title="All 2 branches missed.">            if (bufferStrategy instanceof BltBufferStrategy) {</span>
<span class="nc" id="L3895">                BltBufferStrategy bltBS = (BltBufferStrategy)bufferStrategy;</span>
<span class="nc" id="L3896">                return bltBS.getBackBuffer();</span>
<span class="nc bnc" id="L3897" title="All 2 branches missed.">            } else if (bufferStrategy instanceof FlipBufferStrategy) {</span>
<span class="nc" id="L3898">                FlipBufferStrategy flipBS = (FlipBufferStrategy)bufferStrategy;</span>
<span class="nc" id="L3899">                return flipBS.getBackBuffer();</span>
            }
        }
<span class="nc" id="L3902">        return null;</span>
    }

    /**
     * Inner class for flipping buffers on a component.  That component must
     * be a &lt;code&gt;Canvas&lt;/code&gt; or &lt;code&gt;Window&lt;/code&gt;.
     * @see Canvas
     * @see Window
     * @see java.awt.image.BufferStrategy
     * @author Michael Martak
     * @since 1.4
     */
    protected class FlipBufferStrategy extends BufferStrategy {
        /**
         * The number of buffers
         */
        protected int numBuffers; // = 0
        /**
         * The buffering capabilities
         */
        protected BufferCapabilities caps; // = null
        /**
         * The drawing buffer
         */
        protected Image drawBuffer; // = null
        /**
         * The drawing buffer as a volatile image
         */
        protected VolatileImage drawVBuffer; // = null
        /**
         * Whether or not the drawing buffer has been recently restored from
         * a lost state.
         */
        protected boolean validatedContents; // = false
        /**
         * Size of the back buffers.  (Note: these fields were added in 6.0
         * but kept package-private to avoid exposing them in the spec.
         * None of these fields/methods really should have been marked
         * protected when they were introduced in 1.4, but now we just have
         * to live with that decision.)
         */
        int width;
        int height;

        /**
         * Creates a new flipping buffer strategy for this component.
         * The component must be a &lt;code&gt;Canvas&lt;/code&gt; or &lt;code&gt;Window&lt;/code&gt;.
         * @see Canvas
         * @see Window
         * @param numBuffers the number of buffers
         * @param caps the capabilities of the buffers
         * @exception AWTException if the capabilities supplied could not be
         * supported or met
         * @exception ClassCastException if the component is not a canvas or
         * window.
         * @exception IllegalStateException if the component has no peer
         * @exception IllegalArgumentException if {@code numBuffers} is less than two,
         * or if {@code BufferCapabilities.isPageFlipping} is not
         * {@code true}.
         * @see #createBuffers(int, BufferCapabilities)
         */
        protected FlipBufferStrategy(int numBuffers, BufferCapabilities caps)
            throws AWTException
<span class="nc" id="L3965">        {</span>
<span class="nc bnc" id="L3966" title="All 4 branches missed.">            if (!(Component.this instanceof Window) &amp;&amp;</span>
                !(Component.this instanceof Canvas))
            {
<span class="nc" id="L3969">                throw new ClassCastException(</span>
                    &quot;Component must be a Canvas or Window&quot;);
            }
<span class="nc" id="L3972">            this.numBuffers = numBuffers;</span>
<span class="nc" id="L3973">            this.caps = caps;</span>
<span class="nc" id="L3974">            createBuffers(numBuffers, caps);</span>
<span class="nc" id="L3975">        }</span>

        /**
         * Creates one or more complex, flipping buffers with the given
         * capabilities.
         * @param numBuffers number of buffers to create; must be greater than
         * one
         * @param caps the capabilities of the buffers.
         * &lt;code&gt;BufferCapabilities.isPageFlipping&lt;/code&gt; must be
         * &lt;code&gt;true&lt;/code&gt;.
         * @exception AWTException if the capabilities supplied could not be
         * supported or met
         * @exception IllegalStateException if the component has no peer
         * @exception IllegalArgumentException if numBuffers is less than two,
         * or if &lt;code&gt;BufferCapabilities.isPageFlipping&lt;/code&gt; is not
         * &lt;code&gt;true&lt;/code&gt;.
         * @see java.awt.BufferCapabilities#isPageFlipping()
         */
        protected void createBuffers(int numBuffers, BufferCapabilities caps)
            throws AWTException
        {
<span class="nc bnc" id="L3996" title="All 2 branches missed.">            if (numBuffers &lt; 2) {</span>
<span class="nc" id="L3997">                throw new IllegalArgumentException(</span>
                    &quot;Number of buffers cannot be less than two&quot;);
<span class="nc bnc" id="L3999" title="All 2 branches missed.">            } else if (peer == null) {</span>
<span class="nc" id="L4000">                throw new IllegalStateException(</span>
                    &quot;Component must have a valid peer&quot;);
<span class="nc bnc" id="L4002" title="All 4 branches missed.">            } else if (caps == null || !caps.isPageFlipping()) {</span>
<span class="nc" id="L4003">                throw new IllegalArgumentException(</span>
                    &quot;Page flipping capabilities must be specified&quot;);
            }

            // save the current bounds
<span class="nc" id="L4008">            width = getWidth();</span>
<span class="nc" id="L4009">            height = getHeight();</span>

<span class="nc bnc" id="L4011" title="All 2 branches missed.">            if (drawBuffer != null) {</span>
                // dispose the existing backbuffers
<span class="nc" id="L4013">                drawBuffer = null;</span>
<span class="nc" id="L4014">                drawVBuffer = null;</span>
<span class="nc" id="L4015">                destroyBuffers();</span>
                // ... then recreate the backbuffers
            }

<span class="nc bnc" id="L4019" title="All 2 branches missed.">            if (caps instanceof ExtendedBufferCapabilities) {</span>
<span class="nc" id="L4020">                ExtendedBufferCapabilities ebc =</span>
                    (ExtendedBufferCapabilities)caps;
<span class="nc bnc" id="L4022" title="All 2 branches missed.">                if (ebc.getVSync() == VSYNC_ON) {</span>
                    // if this buffer strategy is not allowed to be v-synced,
                    // change the caps that we pass to the peer but keep on
                    // trying to create v-synced buffers;
                    // do not throw IAE here in case it is disallowed, see
                    // ExtendedBufferCapabilities for more info
<span class="nc bnc" id="L4028" title="All 2 branches missed.">                    if (!VSyncedBSManager.vsyncAllowed(this)) {</span>
<span class="nc" id="L4029">                        caps = ebc.derive(VSYNC_DEFAULT);</span>
                    }
                }
            }

<span class="nc" id="L4034">            peer.createBuffers(numBuffers, caps);</span>
<span class="nc" id="L4035">            updateInternalBuffers();</span>
<span class="nc" id="L4036">        }</span>

        /**
         * Updates internal buffers (both volatile and non-volatile)
         * by requesting the back-buffer from the peer.
         */
        private void updateInternalBuffers() {
            // get the images associated with the draw buffer
<span class="nc" id="L4044">            drawBuffer = getBackBuffer();</span>
<span class="nc bnc" id="L4045" title="All 2 branches missed.">            if (drawBuffer instanceof VolatileImage) {</span>
<span class="nc" id="L4046">                drawVBuffer = (VolatileImage)drawBuffer;</span>
            } else {
<span class="nc" id="L4048">                drawVBuffer = null;</span>
            }
<span class="nc" id="L4050">        }</span>

        /**
         * @return direct access to the back buffer, as an image.
         * @exception IllegalStateException if the buffers have not yet
         * been created
         */
        protected Image getBackBuffer() {
<span class="nc bnc" id="L4058" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L4059">                return peer.getBackBuffer();</span>
            } else {
<span class="nc" id="L4061">                throw new IllegalStateException(</span>
                    &quot;Component must have a valid peer&quot;);
            }
        }

        /**
         * Flipping moves the contents of the back buffer to the front buffer,
         * either by copying or by moving the video pointer.
         * @param flipAction an integer value describing the flipping action
         * for the contents of the back buffer.  This should be one of the
         * values of the &lt;code&gt;BufferCapabilities.FlipContents&lt;/code&gt;
         * property.
         * @exception IllegalStateException if the buffers have not yet
         * been created
         * @see java.awt.BufferCapabilities#getFlipContents()
         */
        protected void flip(BufferCapabilities.FlipContents flipAction) {
<span class="nc bnc" id="L4078" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L4079">                Image backBuffer = getBackBuffer();</span>
<span class="nc bnc" id="L4080" title="All 2 branches missed.">                if (backBuffer != null) {</span>
<span class="nc" id="L4081">                    peer.flip(0, 0,</span>
<span class="nc" id="L4082">                              backBuffer.getWidth(null),</span>
<span class="nc" id="L4083">                              backBuffer.getHeight(null), flipAction);</span>
                }
<span class="nc" id="L4085">            } else {</span>
<span class="nc" id="L4086">                throw new IllegalStateException(</span>
                    &quot;Component must have a valid peer&quot;);
            }
<span class="nc" id="L4089">        }</span>

        void flipSubRegion(int x1, int y1, int x2, int y2,
                      BufferCapabilities.FlipContents flipAction)
        {
<span class="nc bnc" id="L4094" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L4095">                peer.flip(x1, y1, x2, y2, flipAction);</span>
            } else {
<span class="nc" id="L4097">                throw new IllegalStateException(</span>
                    &quot;Component must have a valid peer&quot;);
            }
<span class="nc" id="L4100">        }</span>

        /**
         * Destroys the buffers created through this object
         */
        protected void destroyBuffers() {
<span class="nc" id="L4106">            VSyncedBSManager.releaseVsync(this);</span>
<span class="nc bnc" id="L4107" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L4108">                peer.destroyBuffers();</span>
            } else {
<span class="nc" id="L4110">                throw new IllegalStateException(</span>
                    &quot;Component must have a valid peer&quot;);
            }
<span class="nc" id="L4113">        }</span>

        /**
         * @return the buffering capabilities of this strategy
         */
        public BufferCapabilities getCapabilities() {
<span class="nc bnc" id="L4119" title="All 2 branches missed.">            if (caps instanceof ProxyCapabilities) {</span>
<span class="nc" id="L4120">                return ((ProxyCapabilities)caps).orig;</span>
            } else {
<span class="nc" id="L4122">                return caps;</span>
            }
        }

        /**
         * @return the graphics on the drawing buffer.  This method may not
         * be synchronized for performance reasons; use of this method by multiple
         * threads should be handled at the application level.  Disposal of the
         * graphics object must be handled by the application.
         */
        public Graphics getDrawGraphics() {
<span class="nc" id="L4133">            revalidate();</span>
<span class="nc" id="L4134">            return drawBuffer.getGraphics();</span>
        }

        /**
         * Restore the drawing buffer if it has been lost
         */
        protected void revalidate() {
<span class="nc" id="L4141">            revalidate(true);</span>
<span class="nc" id="L4142">        }</span>

        void revalidate(boolean checkSize) {
<span class="nc" id="L4145">            validatedContents = false;</span>

<span class="nc bnc" id="L4147" title="All 6 branches missed.">            if (checkSize &amp;&amp; (getWidth() != width || getHeight() != height)) {</span>
                // component has been resized; recreate the backbuffers
                try {
<span class="nc" id="L4150">                    createBuffers(numBuffers, caps);</span>
<span class="nc" id="L4151">                } catch (AWTException e) {</span>
                    // shouldn't be possible
<span class="nc" id="L4153">                }</span>
<span class="nc" id="L4154">                validatedContents = true;</span>
            }

            // get the buffers from the peer every time since they
            // might have been replaced in response to a display change event
<span class="nc" id="L4159">            updateInternalBuffers();</span>

            // now validate the backbuffer
<span class="nc bnc" id="L4162" title="All 2 branches missed.">            if (drawVBuffer != null) {</span>
<span class="nc" id="L4163">                GraphicsConfiguration gc =</span>
<span class="nc" id="L4164">                        getGraphicsConfiguration_NoClientCode();</span>
<span class="nc" id="L4165">                int returnCode = drawVBuffer.validate(gc);</span>
<span class="nc bnc" id="L4166" title="All 2 branches missed.">                if (returnCode == VolatileImage.IMAGE_INCOMPATIBLE) {</span>
                    try {
<span class="nc" id="L4168">                        createBuffers(numBuffers, caps);</span>
<span class="nc" id="L4169">                    } catch (AWTException e) {</span>
                        // shouldn't be possible
<span class="nc" id="L4171">                    }</span>
<span class="nc bnc" id="L4172" title="All 2 branches missed.">                    if (drawVBuffer != null) {</span>
                        // backbuffers were recreated, so validate again
<span class="nc" id="L4174">                        drawVBuffer.validate(gc);</span>
                    }
<span class="nc" id="L4176">                    validatedContents = true;</span>
<span class="nc bnc" id="L4177" title="All 2 branches missed.">                } else if (returnCode == VolatileImage.IMAGE_RESTORED) {</span>
<span class="nc" id="L4178">                    validatedContents = true;</span>
                }
            }
<span class="nc" id="L4181">        }</span>

        /**
         * @return whether the drawing buffer was lost since the last call to
         * &lt;code&gt;getDrawGraphics&lt;/code&gt;
         */
        public boolean contentsLost() {
<span class="nc bnc" id="L4188" title="All 2 branches missed.">            if (drawVBuffer == null) {</span>
<span class="nc" id="L4189">                return false;</span>
            }
<span class="nc" id="L4191">            return drawVBuffer.contentsLost();</span>
        }

        /**
         * @return whether the drawing buffer was recently restored from a lost
         * state and reinitialized to the default background color (white)
         */
        public boolean contentsRestored() {
<span class="nc" id="L4199">            return validatedContents;</span>
        }

        /**
         * Makes the next available buffer visible by either blitting or
         * flipping.
         */
        public void show() {
<span class="nc" id="L4207">            flip(caps.getFlipContents());</span>
<span class="nc" id="L4208">        }</span>

        /**
         * Makes specified region of the the next available buffer visible
         * by either blitting or flipping.
         */
        void showSubRegion(int x1, int y1, int x2, int y2) {
<span class="nc" id="L4215">            flipSubRegion(x1, y1, x2, y2, caps.getFlipContents());</span>
<span class="nc" id="L4216">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public void dispose() {
<span class="nc bnc" id="L4223" title="All 2 branches missed.">            if (Component.this.bufferStrategy == this) {</span>
<span class="nc" id="L4224">                Component.this.bufferStrategy = null;</span>
<span class="nc bnc" id="L4225" title="All 2 branches missed.">                if (peer != null) {</span>
<span class="nc" id="L4226">                    destroyBuffers();</span>
                }
            }
<span class="nc" id="L4229">        }</span>

    } // Inner class FlipBufferStrategy

    /**
     * Inner class for blitting offscreen surfaces to a component.
     *
     * @author Michael Martak
     * @since 1.4
     */
    protected class BltBufferStrategy extends BufferStrategy {

        /**
         * The buffering capabilities
         */
        protected BufferCapabilities caps; // = null
        /**
         * The back buffers
         */
        protected VolatileImage[] backBuffers; // = null
        /**
         * Whether or not the drawing buffer has been recently restored from
         * a lost state.
         */
        protected boolean validatedContents; // = false
        /**
         * Size of the back buffers
         */
        protected int width;
        protected int height;

        /**
         * Insets for the hosting Component.  The size of the back buffer
         * is constrained by these.
         */
        private Insets insets;

        /**
         * Creates a new blt buffer strategy around a component
         * @param numBuffers number of buffers to create, including the
         * front buffer
         * @param caps the capabilities of the buffers
         */
<span class="nc" id="L4272">        protected BltBufferStrategy(int numBuffers, BufferCapabilities caps) {</span>
<span class="nc" id="L4273">            this.caps = caps;</span>
<span class="nc" id="L4274">            createBackBuffers(numBuffers - 1);</span>
<span class="nc" id="L4275">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public void dispose() {
<span class="nc bnc" id="L4282" title="All 2 branches missed.">            if (backBuffers != null) {</span>
<span class="nc bnc" id="L4283" title="All 2 branches missed.">                for (int counter = backBuffers.length - 1; counter &gt;= 0;</span>
<span class="nc" id="L4284">                     counter--) {</span>
<span class="nc bnc" id="L4285" title="All 2 branches missed.">                    if (backBuffers[counter] != null) {</span>
<span class="nc" id="L4286">                        backBuffers[counter].flush();</span>
<span class="nc" id="L4287">                        backBuffers[counter] = null;</span>
                    }
                }
            }
<span class="nc bnc" id="L4291" title="All 2 branches missed.">            if (Component.this.bufferStrategy == this) {</span>
<span class="nc" id="L4292">                Component.this.bufferStrategy = null;</span>
            }
<span class="nc" id="L4294">        }</span>

        /**
         * Creates the back buffers
         */
        protected void createBackBuffers(int numBuffers) {
<span class="nc bnc" id="L4300" title="All 2 branches missed.">            if (numBuffers == 0) {</span>
<span class="nc" id="L4301">                backBuffers = null;</span>
            } else {
                // save the current bounds
<span class="nc" id="L4304">                width = getWidth();</span>
<span class="nc" id="L4305">                height = getHeight();</span>
<span class="nc" id="L4306">                insets = getInsets_NoClientCode();</span>
<span class="nc" id="L4307">                int iWidth = width - insets.left - insets.right;</span>
<span class="nc" id="L4308">                int iHeight = height - insets.top - insets.bottom;</span>

                // It is possible for the component's width and/or height
                // to be 0 here.  Force the size of the backbuffers to
                // be &gt; 0 so that creating the image won't fail.
<span class="nc" id="L4313">                iWidth = Math.max(1, iWidth);</span>
<span class="nc" id="L4314">                iHeight = Math.max(1, iHeight);</span>
<span class="nc bnc" id="L4315" title="All 2 branches missed.">                if (backBuffers == null) {</span>
<span class="nc" id="L4316">                    backBuffers = new VolatileImage[numBuffers];</span>
                } else {
                    // flush any existing backbuffers
<span class="nc bnc" id="L4319" title="All 2 branches missed.">                    for (int i = 0; i &lt; numBuffers; i++) {</span>
<span class="nc bnc" id="L4320" title="All 2 branches missed.">                        if (backBuffers[i] != null) {</span>
<span class="nc" id="L4321">                            backBuffers[i].flush();</span>
<span class="nc" id="L4322">                            backBuffers[i] = null;</span>
                        }
                    }
                }

                // create the backbuffers
<span class="nc bnc" id="L4328" title="All 2 branches missed.">                for (int i = 0; i &lt; numBuffers; i++) {</span>
<span class="nc" id="L4329">                    backBuffers[i] = createVolatileImage(iWidth, iHeight);</span>
                }
            }
<span class="nc" id="L4332">        }</span>

        /**
         * @return the buffering capabilities of this strategy
         */
        public BufferCapabilities getCapabilities() {
<span class="nc" id="L4338">            return caps;</span>
        }

        /**
         * @return the draw graphics
         */
        public Graphics getDrawGraphics() {
<span class="nc" id="L4345">            revalidate();</span>
<span class="nc" id="L4346">            Image backBuffer = getBackBuffer();</span>
<span class="nc bnc" id="L4347" title="All 2 branches missed.">            if (backBuffer == null) {</span>
<span class="nc" id="L4348">                return getGraphics();</span>
            }
<span class="nc" id="L4350">            SunGraphics2D g = (SunGraphics2D)backBuffer.getGraphics();</span>
<span class="nc" id="L4351">            g.constrain(-insets.left, -insets.top,</span>
<span class="nc" id="L4352">                        backBuffer.getWidth(null) + insets.left,</span>
<span class="nc" id="L4353">                        backBuffer.getHeight(null) + insets.top);</span>
<span class="nc" id="L4354">            return g;</span>
        }

        /**
         * @return direct access to the back buffer, as an image.
         * If there is no back buffer, returns null.
         */
        Image getBackBuffer() {
<span class="nc bnc" id="L4362" title="All 2 branches missed.">            if (backBuffers != null) {</span>
<span class="nc" id="L4363">                return backBuffers[backBuffers.length - 1];</span>
            } else {
<span class="nc" id="L4365">                return null;</span>
            }
        }

        /**
         * Makes the next available buffer visible.
         */
        public void show() {
<span class="nc" id="L4373">            showSubRegion(insets.left, insets.top,</span>
                          width - insets.right,
                          height - insets.bottom);
<span class="nc" id="L4376">        }</span>

        /**
         * Package-private method to present a specific rectangular area
         * of this buffer.  This class currently shows only the entire
         * buffer, by calling showSubRegion() with the full dimensions of
         * the buffer.  Subclasses (e.g., BltSubRegionBufferStrategy
         * and FlipSubRegionBufferStrategy) may have region-specific show
         * methods that call this method with actual sub regions of the
         * buffer.
         */
        void showSubRegion(int x1, int y1, int x2, int y2) {
<span class="nc bnc" id="L4388" title="All 2 branches missed.">            if (backBuffers == null) {</span>
<span class="nc" id="L4389">                return;</span>
            }
            // Adjust location to be relative to client area.
<span class="nc" id="L4392">            x1 -= insets.left;</span>
<span class="nc" id="L4393">            x2 -= insets.left;</span>
<span class="nc" id="L4394">            y1 -= insets.top;</span>
<span class="nc" id="L4395">            y2 -= insets.top;</span>
<span class="nc" id="L4396">            Graphics g = getGraphics_NoClientCode();</span>
<span class="nc bnc" id="L4397" title="All 2 branches missed.">            if (g == null) {</span>
                // Not showing, bail
<span class="nc" id="L4399">                return;</span>
            }
            try {
                // First image copy is in terms of Frame's coordinates, need
                // to translate to client area.
<span class="nc" id="L4404">                g.translate(insets.left, insets.top);</span>
<span class="nc bnc" id="L4405" title="All 2 branches missed.">                for (int i = 0; i &lt; backBuffers.length; i++) {</span>
<span class="nc" id="L4406">                    g.drawImage(backBuffers[i],</span>
                                x1, y1, x2, y2,
                                x1, y1, x2, y2,
                                null);
<span class="nc" id="L4410">                    g.dispose();</span>
<span class="nc" id="L4411">                    g = null;</span>
<span class="nc" id="L4412">                    g = backBuffers[i].getGraphics();</span>
                }
            } finally {
<span class="nc bnc" id="L4415" title="All 4 branches missed.">                if (g != null) {</span>
<span class="nc" id="L4416">                    g.dispose();</span>
                }
            }
<span class="nc" id="L4419">        }</span>

        /**
         * Restore the drawing buffer if it has been lost
         */
        protected void revalidate() {
<span class="nc" id="L4425">            revalidate(true);</span>
<span class="nc" id="L4426">        }</span>

        void revalidate(boolean checkSize) {
<span class="nc" id="L4429">            validatedContents = false;</span>

<span class="nc bnc" id="L4431" title="All 2 branches missed.">            if (backBuffers == null) {</span>
<span class="nc" id="L4432">                return;</span>
            }

<span class="nc bnc" id="L4435" title="All 2 branches missed.">            if (checkSize) {</span>
<span class="nc" id="L4436">                Insets insets = getInsets_NoClientCode();</span>
<span class="nc bnc" id="L4437" title="All 4 branches missed.">                if (getWidth() != width || getHeight() != height ||</span>
<span class="nc bnc" id="L4438" title="All 2 branches missed.">                    !insets.equals(this.insets)) {</span>
                    // component has been resized; recreate the backbuffers
<span class="nc" id="L4440">                    createBackBuffers(backBuffers.length);</span>
<span class="nc" id="L4441">                    validatedContents = true;</span>
                }
            }

            // now validate the backbuffer
<span class="nc" id="L4446">            GraphicsConfiguration gc = getGraphicsConfiguration_NoClientCode();</span>
<span class="nc" id="L4447">            int returnCode =</span>
<span class="nc" id="L4448">                backBuffers[backBuffers.length - 1].validate(gc);</span>
<span class="nc bnc" id="L4449" title="All 2 branches missed.">            if (returnCode == VolatileImage.IMAGE_INCOMPATIBLE) {</span>
<span class="nc bnc" id="L4450" title="All 2 branches missed.">                if (checkSize) {</span>
<span class="nc" id="L4451">                    createBackBuffers(backBuffers.length);</span>
                    // backbuffers were recreated, so validate again
<span class="nc" id="L4453">                    backBuffers[backBuffers.length - 1].validate(gc);</span>
                }
                // else case means we're called from Swing on the toolkit
                // thread, don't recreate buffers as that'll deadlock
                // (creating VolatileImages invokes getting GraphicsConfig
                // which grabs treelock).
<span class="nc" id="L4459">                validatedContents = true;</span>
<span class="nc bnc" id="L4460" title="All 2 branches missed.">            } else if (returnCode == VolatileImage.IMAGE_RESTORED) {</span>
<span class="nc" id="L4461">                validatedContents = true;</span>
            }
<span class="nc" id="L4463">        }</span>

        /**
         * @return whether the drawing buffer was lost since the last call to
         * &lt;code&gt;getDrawGraphics&lt;/code&gt;
         */
        public boolean contentsLost() {
<span class="nc bnc" id="L4470" title="All 2 branches missed.">            if (backBuffers == null) {</span>
<span class="nc" id="L4471">                return false;</span>
            } else {
<span class="nc" id="L4473">                return backBuffers[backBuffers.length - 1].contentsLost();</span>
            }
        }

        /**
         * @return whether the drawing buffer was recently restored from a lost
         * state and reinitialized to the default background color (white)
         */
        public boolean contentsRestored() {
<span class="nc" id="L4482">            return validatedContents;</span>
        }
    } // Inner class BltBufferStrategy

    /**
     * Private class to perform sub-region flipping.
     */
    private class FlipSubRegionBufferStrategy extends FlipBufferStrategy
        implements SubRegionShowable
    {

        protected FlipSubRegionBufferStrategy(int numBuffers,
                                              BufferCapabilities caps)
            throws AWTException
<span class="nc" id="L4496">        {</span>
<span class="nc" id="L4497">            super(numBuffers, caps);</span>
<span class="nc" id="L4498">        }</span>

        public void show(int x1, int y1, int x2, int y2) {
<span class="nc" id="L4501">            showSubRegion(x1, y1, x2, y2);</span>
<span class="nc" id="L4502">        }</span>

        // This is invoked by Swing on the toolkit thread.
        public boolean showIfNotLost(int x1, int y1, int x2, int y2) {
<span class="nc bnc" id="L4506" title="All 2 branches missed.">            if (!contentsLost()) {</span>
<span class="nc" id="L4507">                showSubRegion(x1, y1, x2, y2);</span>
<span class="nc bnc" id="L4508" title="All 2 branches missed.">                return !contentsLost();</span>
            }
<span class="nc" id="L4510">            return false;</span>
        }
    }

    /**
     * Private class to perform sub-region blitting.  Swing will use
     * this subclass via the SubRegionShowable interface in order to
     * copy only the area changed during a repaint.
     * @see javax.swing.BufferStrategyPaintManager
     */
    private class BltSubRegionBufferStrategy extends BltBufferStrategy
        implements SubRegionShowable
    {

        protected BltSubRegionBufferStrategy(int numBuffers,
                                             BufferCapabilities caps)
<span class="nc" id="L4526">        {</span>
<span class="nc" id="L4527">            super(numBuffers, caps);</span>
<span class="nc" id="L4528">        }</span>

        public void show(int x1, int y1, int x2, int y2) {
<span class="nc" id="L4531">            showSubRegion(x1, y1, x2, y2);</span>
<span class="nc" id="L4532">        }</span>

        // This method is called by Swing on the toolkit thread.
        public boolean showIfNotLost(int x1, int y1, int x2, int y2) {
<span class="nc bnc" id="L4536" title="All 2 branches missed.">            if (!contentsLost()) {</span>
<span class="nc" id="L4537">                showSubRegion(x1, y1, x2, y2);</span>
<span class="nc bnc" id="L4538" title="All 2 branches missed.">                return !contentsLost();</span>
            }
<span class="nc" id="L4540">            return false;</span>
        }
    }

    /**
     * Inner class for flipping buffers on a component.  That component must
     * be a &lt;code&gt;Canvas&lt;/code&gt; or &lt;code&gt;Window&lt;/code&gt;.
     * @see Canvas
     * @see Window
     * @see java.awt.image.BufferStrategy
     * @author Michael Martak
     * @since 1.4
     */
    private class SingleBufferStrategy extends BufferStrategy {

        private BufferCapabilities caps;

<span class="nc" id="L4557">        public SingleBufferStrategy(BufferCapabilities caps) {</span>
<span class="nc" id="L4558">            this.caps = caps;</span>
<span class="nc" id="L4559">        }</span>
        public BufferCapabilities getCapabilities() {
<span class="nc" id="L4561">            return caps;</span>
        }
        public Graphics getDrawGraphics() {
<span class="nc" id="L4564">            return getGraphics();</span>
        }
        public boolean contentsLost() {
<span class="nc" id="L4567">            return false;</span>
        }
        public boolean contentsRestored() {
<span class="nc" id="L4570">            return false;</span>
        }
        public void show() {
            // Do nothing
<span class="nc" id="L4574">        }</span>
    } // Inner class SingleBufferStrategy

    /**
     * Sets whether or not paint messages received from the operating system
     * should be ignored.  This does not affect paint events generated in
     * software by the AWT, unless they are an immediate response to an
     * OS-level paint message.
     * &lt;p&gt;
     * This is useful, for example, if running under full-screen mode and
     * better performance is desired, or if page-flipping is used as the
     * buffer strategy.
     *
     * @since 1.4
     * @see #getIgnoreRepaint
     * @see Canvas#createBufferStrategy
     * @see Window#createBufferStrategy
     * @see java.awt.image.BufferStrategy
     * @see GraphicsDevice#setFullScreenWindow
     */
    public void setIgnoreRepaint(boolean ignoreRepaint) {
<span class="nc" id="L4595">        this.ignoreRepaint = ignoreRepaint;</span>
<span class="nc" id="L4596">    }</span>

    /**
     * @return whether or not paint messages received from the operating system
     * should be ignored.
     *
     * @since 1.4
     * @see #setIgnoreRepaint
     */
    public boolean getIgnoreRepaint() {
<span class="nc" id="L4606">        return ignoreRepaint;</span>
    }

    /**
     * Checks whether this component &quot;contains&quot; the specified point,
     * where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are defined to be
     * relative to the coordinate system of this component.
     * @param     x   the &lt;i&gt;x&lt;/i&gt; coordinate of the point
     * @param     y   the &lt;i&gt;y&lt;/i&gt; coordinate of the point
     * @see       #getComponentAt(int, int)
     * @since     JDK1.1
     */
    public boolean contains(int x, int y) {
<span class="nc" id="L4619">        return inside(x, y);</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by contains(int, int).
     */
    @Deprecated
    public boolean inside(int x, int y) {
<span class="nc bnc" id="L4628" title="All 8 branches missed.">        return (x &gt;= 0) &amp;&amp; (x &lt; width) &amp;&amp; (y &gt;= 0) &amp;&amp; (y &lt; height);</span>
    }

    /**
     * Checks whether this component &quot;contains&quot; the specified point,
     * where the point's &lt;i&gt;x&lt;/i&gt; and &lt;i&gt;y&lt;/i&gt; coordinates are defined
     * to be relative to the coordinate system of this component.
     * @param     p     the point
     * @throws    NullPointerException if {@code p} is {@code null}
     * @see       #getComponentAt(Point)
     * @since     JDK1.1
     */
    public boolean contains(Point p) {
<span class="nc" id="L4641">        return contains(p.x, p.y);</span>
    }

    /**
     * Determines if this component or one of its immediate
     * subcomponents contains the (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) location,
     * and if so, returns the containing component. This method only
     * looks one level deep. If the point (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) is
     * inside a subcomponent that itself has subcomponents, it does not
     * go looking down the subcomponent tree.
     * &lt;p&gt;
     * The &lt;code&gt;locate&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt; simply
     * returns the component itself if the (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;)
     * coordinate location is inside its bounding box, and &lt;code&gt;null&lt;/code&gt;
     * otherwise.
     * @param     x   the &lt;i&gt;x&lt;/i&gt; coordinate
     * @param     y   the &lt;i&gt;y&lt;/i&gt; coordinate
     * @return    the component or subcomponent that contains the
     *                (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) location;
     *                &lt;code&gt;null&lt;/code&gt; if the location
     *                is outside this component
     * @see       #contains(int, int)
     * @since     JDK1.0
     */
    public Component getComponentAt(int x, int y) {
<span class="nc" id="L4666">        return locate(x, y);</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by getComponentAt(int, int).
     */
    @Deprecated
    public Component locate(int x, int y) {
<span class="nc bnc" id="L4675" title="All 2 branches missed.">        return contains(x, y) ? this : null;</span>
    }

    /**
     * Returns the component or subcomponent that contains the
     * specified point.
     * @param     p   the point
     * @see       java.awt.Component#contains
     * @since     JDK1.1
     */
    public Component getComponentAt(Point p) {
<span class="nc" id="L4686">        return getComponentAt(p.x, p.y);</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;dispatchEvent(AWTEvent e)&lt;/code&gt;.
     */
    @Deprecated
    public void deliverEvent(Event e) {
<span class="nc" id="L4695">        postEvent(e);</span>
<span class="nc" id="L4696">    }</span>

    /**
     * Dispatches an event to this component or one of its sub components.
     * Calls &lt;code&gt;processEvent&lt;/code&gt; before returning for 1.1-style
     * events which have been enabled for the &lt;code&gt;Component&lt;/code&gt;.
     * @param e the event
     */
    public final void dispatchEvent(AWTEvent e) {
<span class="nc" id="L4705">        dispatchEventImpl(e);</span>
<span class="nc" id="L4706">    }</span>

    @SuppressWarnings(&quot;deprecation&quot;)
    void dispatchEventImpl(AWTEvent e) {
<span class="nc" id="L4710">        int id = e.getID();</span>

        // Check that this component belongs to this app-context
<span class="nc" id="L4713">        AppContext compContext = appContext;</span>
<span class="nc bnc" id="L4714" title="All 4 branches missed.">        if (compContext != null &amp;&amp; !compContext.equals(AppContext.getAppContext())) {</span>
<span class="nc bnc" id="L4715" title="All 2 branches missed.">            if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L4716">                eventLog.fine(&quot;Event &quot; + e + &quot; is being dispatched on the wrong AppContext&quot;);</span>
            }
        }

<span class="nc bnc" id="L4720" title="All 2 branches missed.">        if (eventLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L4721">            eventLog.finest(&quot;{0}&quot;, e);</span>
        }

        /*
         * 0. Set timestamp and modifiers of current event.
         */
<span class="nc bnc" id="L4727" title="All 2 branches missed.">        if (!(e instanceof KeyEvent)) {</span>
            // Timestamp of a key event is set later in DKFM.preDispatchKeyEvent(KeyEvent).
<span class="nc" id="L4729">            EventQueue.setCurrentEventAndMostRecentTime(e);</span>
        }

        /*
         * 1. Pre-dispatchers. Do any necessary retargeting/reordering here
         *    before we notify AWTEventListeners.
         */

<span class="nc bnc" id="L4737" title="All 2 branches missed.">        if (e instanceof SunDropTargetEvent) {</span>
<span class="nc" id="L4738">            ((SunDropTargetEvent)e).dispatch();</span>
<span class="nc" id="L4739">            return;</span>
        }

<span class="nc bnc" id="L4742" title="All 2 branches missed.">        if (!e.focusManagerIsDispatching) {</span>
            // Invoke the private focus retargeting method which provides
            // lightweight Component support
<span class="nc bnc" id="L4745" title="All 2 branches missed.">            if (e.isPosted) {</span>
<span class="nc" id="L4746">                e = KeyboardFocusManager.retargetFocusEvent(e);</span>
<span class="nc" id="L4747">                e.isPosted = true;</span>
            }

            // Now, with the event properly targeted to a lightweight
            // descendant if necessary, invoke the public focus retargeting
            // and dispatching function
<span class="nc" id="L4753">            if (KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc bnc" id="L4754" title="All 2 branches missed.">                dispatchEvent(e))</span>
            {
<span class="nc" id="L4756">                return;</span>
            }
        }
<span class="nc bnc" id="L4759" title="All 4 branches missed.">        if ((e instanceof FocusEvent) &amp;&amp; focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L4760">            focusLog.finest(&quot;&quot; + e);</span>
        }
        // MouseWheel may need to be retargeted here so that
        // AWTEventListener sees the event go to the correct
        // Component.  If the MouseWheelEvent needs to go to an ancestor,
        // the event is dispatched to the ancestor, and dispatching here
        // stops.
<span class="nc bnc" id="L4767" title="All 2 branches missed.">        if (id == MouseEvent.MOUSE_WHEEL &amp;&amp;</span>
<span class="nc bnc" id="L4768" title="All 4 branches missed.">            (!eventTypeEnabled(id)) &amp;&amp;</span>
<span class="nc bnc" id="L4769" title="All 2 branches missed.">            (peer != null &amp;&amp; !peer.handlesWheelScrolling()) &amp;&amp;</span>
<span class="nc bnc" id="L4770" title="All 2 branches missed.">            (dispatchMouseWheelToAncestor((MouseWheelEvent)e)))</span>
        {
<span class="nc" id="L4772">            return;</span>
        }

        /*
         * 2. Allow the Toolkit to pass this to AWTEventListeners.
         */
<span class="nc" id="L4778">        Toolkit toolkit = Toolkit.getDefaultToolkit();</span>
<span class="nc" id="L4779">        toolkit.notifyAWTEventListeners(e);</span>


        /*
         * 3. If no one has consumed a key event, allow the
         *    KeyboardFocusManager to process it.
         */
<span class="nc bnc" id="L4786" title="All 2 branches missed.">        if (!e.isConsumed()) {</span>
<span class="nc bnc" id="L4787" title="All 2 branches missed.">            if (e instanceof java.awt.event.KeyEvent) {</span>
<span class="nc" id="L4788">                KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L4789">                    processKeyEvent(this, (KeyEvent)e);</span>
<span class="nc bnc" id="L4790" title="All 2 branches missed.">                if (e.isConsumed()) {</span>
<span class="nc" id="L4791">                    return;</span>
                }
            }
        }

        /*
         * 4. Allow input methods to process the event
         */
<span class="nc bnc" id="L4799" title="All 2 branches missed.">        if (areInputMethodsEnabled()) {</span>
            // We need to pass on InputMethodEvents since some host
            // input method adapters send them through the Java
            // event queue instead of directly to the component,
            // and the input context also handles the Java composition window
<span class="nc bnc" id="L4804" title="All 8 branches missed.">            if(((e instanceof InputMethodEvent) &amp;&amp; !(this instanceof CompositionArea))</span>
               ||
               // Otherwise, we only pass on input and focus events, because
               // a) input methods shouldn't know about semantic or component-level events
               // b) passing on the events takes time
               // c) isConsumed() is always true for semantic events.
               (e instanceof InputEvent) || (e instanceof FocusEvent)) {
<span class="nc" id="L4811">                InputContext inputContext = getInputContext();</span>


<span class="nc bnc" id="L4814" title="All 2 branches missed.">                if (inputContext != null) {</span>
<span class="nc" id="L4815">                    inputContext.dispatchEvent(e);</span>
<span class="nc bnc" id="L4816" title="All 2 branches missed.">                    if (e.isConsumed()) {</span>
<span class="nc bnc" id="L4817" title="All 4 branches missed.">                        if ((e instanceof FocusEvent) &amp;&amp; focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L4818">                            focusLog.finest(&quot;3579: Skipping &quot; + e);</span>
                        }
<span class="nc" id="L4820">                        return;</span>
                    }
                }
<span class="nc" id="L4823">            }</span>
        } else {
            // When non-clients get focus, we need to explicitly disable the native
            // input method. The native input method is actually not disabled when
            // the active/passive/peered clients loose focus.
<span class="nc bnc" id="L4828" title="All 2 branches missed.">            if (id == FocusEvent.FOCUS_GAINED) {</span>
<span class="nc" id="L4829">                InputContext inputContext = getInputContext();</span>
<span class="nc bnc" id="L4830" title="All 4 branches missed.">                if (inputContext != null &amp;&amp; inputContext instanceof sun.awt.im.InputContext) {</span>
<span class="nc" id="L4831">                    ((sun.awt.im.InputContext)inputContext).disableNativeIM();</span>
                }
            }
        }


        /*
         * 5. Pre-process any special events before delivery
         */
<span class="nc bnc" id="L4840" title="All 3 branches missed.">        switch(id) {</span>
            // Handling of the PAINT and UPDATE events is now done in the
            // peer's handleEvent() method so the background can be cleared
            // selectively for non-native components on Windows only.
            // - Fred.Ecks@Eng.sun.com, 5-8-98

          case KeyEvent.KEY_PRESSED:
          case KeyEvent.KEY_RELEASED:
<span class="nc bnc" id="L4848" title="All 2 branches missed.">              Container p = (Container)((this instanceof Container) ? this : parent);</span>
<span class="nc bnc" id="L4849" title="All 2 branches missed.">              if (p != null) {</span>
<span class="nc" id="L4850">                  p.preProcessKeyEvent((KeyEvent)e);</span>
<span class="nc bnc" id="L4851" title="All 2 branches missed.">                  if (e.isConsumed()) {</span>
<span class="nc bnc" id="L4852" title="All 2 branches missed.">                        if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L4853">                            focusLog.finest(&quot;Pre-process consumed event&quot;);</span>
                        }
<span class="nc" id="L4855">                      return;</span>
                  }
              }
              break;

          case WindowEvent.WINDOW_CLOSING:
<span class="nc bnc" id="L4861" title="All 2 branches missed.">              if (toolkit instanceof WindowClosingListener) {</span>
<span class="nc" id="L4862">                  windowClosingException = ((WindowClosingListener)</span>
<span class="nc" id="L4863">                                            toolkit).windowClosingNotify((WindowEvent)e);</span>
<span class="nc bnc" id="L4864" title="All 2 branches missed.">                  if (checkWindowClosingException()) {</span>
<span class="nc" id="L4865">                      return;</span>
                  }
              }
              break;

          default:
              break;
        }

        /*
         * 6. Deliver event for normal processing
         */
<span class="nc bnc" id="L4877" title="All 2 branches missed.">        if (newEventsOnly) {</span>
            // Filtering needs to really be moved to happen at a lower
            // level in order to get maximum performance gain;  it is
            // here temporarily to ensure the API spec is honored.
            //
<span class="nc bnc" id="L4882" title="All 2 branches missed.">            if (eventEnabled(e)) {</span>
<span class="nc" id="L4883">                processEvent(e);</span>
            }
<span class="nc bnc" id="L4885" title="All 2 branches missed.">        } else if (id == MouseEvent.MOUSE_WHEEL) {</span>
            // newEventsOnly will be false for a listenerless ScrollPane, but
            // MouseWheelEvents still need to be dispatched to it so scrolling
            // can be done.
<span class="nc" id="L4889">            autoProcessMouseWheel((MouseWheelEvent)e);</span>
<span class="nc bnc" id="L4890" title="All 4 branches missed.">        } else if (!(e instanceof MouseEvent &amp;&amp; !postsOldMouseEvents())) {</span>
            //
            // backward compatibility
            //
<span class="nc" id="L4894">            Event olde = e.convertToOld();</span>
<span class="nc bnc" id="L4895" title="All 2 branches missed.">            if (olde != null) {</span>
<span class="nc" id="L4896">                int key = olde.key;</span>
<span class="nc" id="L4897">                int modifiers = olde.modifiers;</span>

<span class="nc" id="L4899">                postEvent(olde);</span>
<span class="nc bnc" id="L4900" title="All 2 branches missed.">                if (olde.isConsumed()) {</span>
<span class="nc" id="L4901">                    e.consume();</span>
                }
                // if target changed key or modifier values, copy them
                // back to original event
                //
<span class="nc bnc" id="L4906" title="All 2 branches missed.">                switch(olde.id) {</span>
                  case Event.KEY_PRESS:
                  case Event.KEY_RELEASE:
                  case Event.KEY_ACTION:
                  case Event.KEY_ACTION_RELEASE:
<span class="nc bnc" id="L4911" title="All 2 branches missed.">                      if (olde.key != key) {</span>
<span class="nc" id="L4912">                          ((KeyEvent)e).setKeyChar(olde.getKeyEventChar());</span>
                      }
<span class="nc bnc" id="L4914" title="All 2 branches missed.">                      if (olde.modifiers != modifiers) {</span>
<span class="nc" id="L4915">                          ((KeyEvent)e).setModifiers(olde.modifiers);</span>
                      }
                      break;
                  default:
                      break;
                }
            }
        }

        /*
         * 8. Special handling for 4061116 : Hook for browser to close modal
         *    dialogs.
         */
<span class="nc bnc" id="L4928" title="All 4 branches missed.">        if (id == WindowEvent.WINDOW_CLOSING &amp;&amp; !e.isConsumed()) {</span>
<span class="nc bnc" id="L4929" title="All 2 branches missed.">            if (toolkit instanceof WindowClosingListener) {</span>
<span class="nc" id="L4930">                windowClosingException =</span>
                    ((WindowClosingListener)toolkit).
<span class="nc" id="L4932">                    windowClosingDelivered((WindowEvent)e);</span>
<span class="nc bnc" id="L4933" title="All 2 branches missed.">                if (checkWindowClosingException()) {</span>
<span class="nc" id="L4934">                    return;</span>
                }
            }
        }

        /*
         * 9. Allow the peer to process the event.
         * Except KeyEvents, they will be processed by peer after
         * all KeyEventPostProcessors
         * (see DefaultKeyboardFocusManager.dispatchKeyEvent())
         */
<span class="nc bnc" id="L4945" title="All 2 branches missed.">        if (!(e instanceof KeyEvent)) {</span>
<span class="nc" id="L4946">            ComponentPeer tpeer = peer;</span>
<span class="nc bnc" id="L4947" title="All 6 branches missed.">            if (e instanceof FocusEvent &amp;&amp; (tpeer == null || tpeer instanceof LightweightPeer)) {</span>
                // if focus owner is lightweight then its native container
                // processes event
<span class="nc" id="L4950">                Component source = (Component)e.getSource();</span>
<span class="nc bnc" id="L4951" title="All 2 branches missed.">                if (source != null) {</span>
<span class="nc" id="L4952">                    Container target = source.getNativeContainer();</span>
<span class="nc bnc" id="L4953" title="All 2 branches missed.">                    if (target != null) {</span>
<span class="nc" id="L4954">                        tpeer = target.getPeer();</span>
                    }
                }
            }
<span class="nc bnc" id="L4958" title="All 2 branches missed.">            if (tpeer != null) {</span>
<span class="nc" id="L4959">                tpeer.handleEvent(e);</span>
            }
        }
<span class="nc" id="L4962">    } // dispatchEventImpl()</span>

    /*
     * If newEventsOnly is false, method is called so that ScrollPane can
     * override it and handle common-case mouse wheel scrolling.  NOP
     * for Component.
     */
<span class="nc" id="L4969">    void autoProcessMouseWheel(MouseWheelEvent e) {}</span>

    /*
     * Dispatch given MouseWheelEvent to the first ancestor for which
     * MouseWheelEvents are enabled.
     *
     * Returns whether or not event was dispatched to an ancestor
     */
    boolean dispatchMouseWheelToAncestor(MouseWheelEvent e) {
        int newX, newY;
<span class="nc" id="L4979">        newX = e.getX() + getX(); // Coordinates take into account at least</span>
<span class="nc" id="L4980">        newY = e.getY() + getY(); // the cursor's position relative to this</span>
                                  // Component (e.getX()), and this Component's
                                  // position relative to its parent.
        MouseWheelEvent newMWE;

<span class="nc bnc" id="L4985" title="All 2 branches missed.">        if (eventLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L4986">            eventLog.finest(&quot;dispatchMouseWheelToAncestor&quot;);</span>
<span class="nc" id="L4987">            eventLog.finest(&quot;orig event src is of &quot; + e.getSource().getClass());</span>
        }

        /* parent field for Window refers to the owning Window.
         * MouseWheelEvents should NOT be propagated into owning Windows
         */
<span class="nc" id="L4993">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L4994">            Container anc = getParent();</span>
<span class="nc bnc" id="L4995" title="All 4 branches missed.">            while (anc != null &amp;&amp; !anc.eventEnabled(e)) {</span>
                // fix coordinates to be relative to new event source
<span class="nc" id="L4997">                newX += anc.getX();</span>
<span class="nc" id="L4998">                newY += anc.getY();</span>

<span class="nc bnc" id="L5000" title="All 2 branches missed.">                if (!(anc instanceof Window)) {</span>
<span class="nc" id="L5001">                    anc = anc.getParent();</span>
                }
                else {
                    break;
                }
            }

<span class="nc bnc" id="L5008" title="All 2 branches missed.">            if (eventLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L5009">                eventLog.finest(&quot;new event src is &quot; + anc.getClass());</span>
            }

<span class="nc bnc" id="L5012" title="All 4 branches missed.">            if (anc != null &amp;&amp; anc.eventEnabled(e)) {</span>
                // Change event to be from new source, with new x,y
                // For now, just create a new event - yucky

<span class="nc" id="L5016">                newMWE = new MouseWheelEvent(anc, // new source</span>
<span class="nc" id="L5017">                                             e.getID(),</span>
<span class="nc" id="L5018">                                             e.getWhen(),</span>
<span class="nc" id="L5019">                                             e.getModifiers(),</span>
                                             newX, // x relative to new source
                                             newY, // y relative to new source
<span class="nc" id="L5022">                                             e.getXOnScreen(),</span>
<span class="nc" id="L5023">                                             e.getYOnScreen(),</span>
<span class="nc" id="L5024">                                             e.getClickCount(),</span>
<span class="nc" id="L5025">                                             e.isPopupTrigger(),</span>
<span class="nc" id="L5026">                                             e.getScrollType(),</span>
<span class="nc" id="L5027">                                             e.getScrollAmount(),</span>
<span class="nc" id="L5028">                                             e.getWheelRotation(),</span>
<span class="nc" id="L5029">                                             e.getPreciseWheelRotation());</span>
<span class="nc" id="L5030">                ((AWTEvent)e).copyPrivateDataInto(newMWE);</span>
                // When dispatching a wheel event to
                // ancestor, there is no need trying to find descendant
                // lightweights to dispatch event to.
                // If we dispatch the event to toplevel ancestor,
                // this could encolse the loop: 6480024.
<span class="nc" id="L5036">                anc.dispatchEventToSelf(newMWE);</span>
<span class="nc bnc" id="L5037" title="All 2 branches missed.">                if (newMWE.isConsumed()) {</span>
<span class="nc" id="L5038">                    e.consume();</span>
                }
<span class="nc" id="L5040">                return true;</span>
            }
<span class="nc" id="L5042">        }</span>
<span class="nc" id="L5043">        return false;</span>
    }

    boolean checkWindowClosingException() {
<span class="nc bnc" id="L5047" title="All 2 branches missed.">        if (windowClosingException != null) {</span>
<span class="nc bnc" id="L5048" title="All 2 branches missed.">            if (this instanceof Dialog) {</span>
<span class="nc" id="L5049">                ((Dialog)this).interruptBlocking();</span>
            } else {
<span class="nc" id="L5051">                windowClosingException.fillInStackTrace();</span>
<span class="nc" id="L5052">                windowClosingException.printStackTrace();</span>
<span class="nc" id="L5053">                windowClosingException = null;</span>
            }
<span class="nc" id="L5055">            return true;</span>
        }
<span class="nc" id="L5057">        return false;</span>
    }

    boolean areInputMethodsEnabled() {
        // in 1.2, we assume input method support is required for all
        // components that handle key events, but components can turn off
        // input methods by calling enableInputMethods(false).
<span class="nc bnc" id="L5064" title="All 6 branches missed.">        return ((eventMask &amp; AWTEvent.INPUT_METHODS_ENABLED_MASK) != 0) &amp;&amp;</span>
            ((eventMask &amp; AWTEvent.KEY_EVENT_MASK) != 0 || keyListener != null);
    }

    // REMIND: remove when filtering is handled at lower level
    boolean eventEnabled(AWTEvent e) {
<span class="nc" id="L5070">        return eventTypeEnabled(e.id);</span>
    }

    boolean eventTypeEnabled(int type) {
<span class="nc bnc" id="L5074" title="All 14 branches missed.">        switch(type) {</span>
          case ComponentEvent.COMPONENT_MOVED:
          case ComponentEvent.COMPONENT_RESIZED:
          case ComponentEvent.COMPONENT_SHOWN:
          case ComponentEvent.COMPONENT_HIDDEN:
<span class="nc bnc" id="L5079" title="All 4 branches missed.">              if ((eventMask &amp; AWTEvent.COMPONENT_EVENT_MASK) != 0 ||</span>
                  componentListener != null) {
<span class="nc" id="L5081">                  return true;</span>
              }
              break;
          case FocusEvent.FOCUS_GAINED:
          case FocusEvent.FOCUS_LOST:
<span class="nc bnc" id="L5086" title="All 4 branches missed.">              if ((eventMask &amp; AWTEvent.FOCUS_EVENT_MASK) != 0 ||</span>
                  focusListener != null) {
<span class="nc" id="L5088">                  return true;</span>
              }
              break;
          case KeyEvent.KEY_PRESSED:
          case KeyEvent.KEY_RELEASED:
          case KeyEvent.KEY_TYPED:
<span class="nc bnc" id="L5094" title="All 4 branches missed.">              if ((eventMask &amp; AWTEvent.KEY_EVENT_MASK) != 0 ||</span>
                  keyListener != null) {
<span class="nc" id="L5096">                  return true;</span>
              }
              break;
          case MouseEvent.MOUSE_PRESSED:
          case MouseEvent.MOUSE_RELEASED:
          case MouseEvent.MOUSE_ENTERED:
          case MouseEvent.MOUSE_EXITED:
          case MouseEvent.MOUSE_CLICKED:
<span class="nc bnc" id="L5104" title="All 4 branches missed.">              if ((eventMask &amp; AWTEvent.MOUSE_EVENT_MASK) != 0 ||</span>
                  mouseListener != null) {
<span class="nc" id="L5106">                  return true;</span>
              }
              break;
          case MouseEvent.MOUSE_MOVED:
          case MouseEvent.MOUSE_DRAGGED:
<span class="nc bnc" id="L5111" title="All 4 branches missed.">              if ((eventMask &amp; AWTEvent.MOUSE_MOTION_EVENT_MASK) != 0 ||</span>
                  mouseMotionListener != null) {
<span class="nc" id="L5113">                  return true;</span>
              }
              break;
          case MouseEvent.MOUSE_WHEEL:
<span class="nc bnc" id="L5117" title="All 4 branches missed.">              if ((eventMask &amp; AWTEvent.MOUSE_WHEEL_EVENT_MASK) != 0 ||</span>
                  mouseWheelListener != null) {
<span class="nc" id="L5119">                  return true;</span>
              }
              break;
          case InputMethodEvent.INPUT_METHOD_TEXT_CHANGED:
          case InputMethodEvent.CARET_POSITION_CHANGED:
<span class="nc bnc" id="L5124" title="All 4 branches missed.">              if ((eventMask &amp; AWTEvent.INPUT_METHOD_EVENT_MASK) != 0 ||</span>
                  inputMethodListener != null) {
<span class="nc" id="L5126">                  return true;</span>
              }
              break;
          case HierarchyEvent.HIERARCHY_CHANGED:
<span class="nc bnc" id="L5130" title="All 4 branches missed.">              if ((eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 ||</span>
                  hierarchyListener != null) {
<span class="nc" id="L5132">                  return true;</span>
              }
              break;
          case HierarchyEvent.ANCESTOR_MOVED:
          case HierarchyEvent.ANCESTOR_RESIZED:
<span class="nc bnc" id="L5137" title="All 4 branches missed.">              if ((eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0 ||</span>
                  hierarchyBoundsListener != null) {
<span class="nc" id="L5139">                  return true;</span>
              }
              break;
          case ActionEvent.ACTION_PERFORMED:
<span class="nc bnc" id="L5143" title="All 2 branches missed.">              if ((eventMask &amp; AWTEvent.ACTION_EVENT_MASK) != 0) {</span>
<span class="nc" id="L5144">                  return true;</span>
              }
              break;
          case TextEvent.TEXT_VALUE_CHANGED:
<span class="nc bnc" id="L5148" title="All 2 branches missed.">              if ((eventMask &amp; AWTEvent.TEXT_EVENT_MASK) != 0) {</span>
<span class="nc" id="L5149">                  return true;</span>
              }
              break;
          case ItemEvent.ITEM_STATE_CHANGED:
<span class="nc bnc" id="L5153" title="All 2 branches missed.">              if ((eventMask &amp; AWTEvent.ITEM_EVENT_MASK) != 0) {</span>
<span class="nc" id="L5154">                  return true;</span>
              }
              break;
          case AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED:
<span class="nc bnc" id="L5158" title="All 2 branches missed.">              if ((eventMask &amp; AWTEvent.ADJUSTMENT_EVENT_MASK) != 0) {</span>
<span class="nc" id="L5159">                  return true;</span>
              }
              break;
          default:
              break;
        }
        //
        // Always pass on events defined by external programs.
        //
<span class="nc bnc" id="L5168" title="All 2 branches missed.">        if (type &gt; AWTEvent.RESERVED_ID_MAX) {</span>
<span class="nc" id="L5169">            return true;</span>
        }
<span class="nc" id="L5171">        return false;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by dispatchEvent(AWTEvent).
     */
    @Deprecated
    public boolean postEvent(Event e) {
<span class="nc" id="L5180">        ComponentPeer peer = this.peer;</span>

<span class="nc bnc" id="L5182" title="All 2 branches missed.">        if (handleEvent(e)) {</span>
<span class="nc" id="L5183">            e.consume();</span>
<span class="nc" id="L5184">            return true;</span>
        }

<span class="nc" id="L5187">        Component parent = this.parent;</span>
<span class="nc" id="L5188">        int eventx = e.x;</span>
<span class="nc" id="L5189">        int eventy = e.y;</span>
<span class="nc bnc" id="L5190" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L5191">            e.translate(x, y);</span>
<span class="nc bnc" id="L5192" title="All 2 branches missed.">            if (parent.postEvent(e)) {</span>
<span class="nc" id="L5193">                e.consume();</span>
<span class="nc" id="L5194">                return true;</span>
            }
            // restore coords
<span class="nc" id="L5197">            e.x = eventx;</span>
<span class="nc" id="L5198">            e.y = eventy;</span>
        }
<span class="nc" id="L5200">        return false;</span>
    }

    // Event source interfaces

    /**
     * Adds the specified component listener to receive component events from
     * this component.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the component listener
     * @see      java.awt.event.ComponentEvent
     * @see      java.awt.event.ComponentListener
     * @see      #removeComponentListener
     * @see      #getComponentListeners
     * @since    JDK1.1
     */
    public synchronized void addComponentListener(ComponentListener l) {
<span class="nc bnc" id="L5221" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5222">            return;</span>
        }
<span class="nc" id="L5224">        componentListener = AWTEventMulticaster.add(componentListener, l);</span>
<span class="nc" id="L5225">        newEventsOnly = true;</span>
<span class="nc" id="L5226">    }</span>

    /**
     * Removes the specified component listener so that it no longer
     * receives component events from this component. This method performs
     * no function, nor does it throw an exception, if the listener
     * specified by the argument was not previously added to this component.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     * @param    l   the component listener
     * @see      java.awt.event.ComponentEvent
     * @see      java.awt.event.ComponentListener
     * @see      #addComponentListener
     * @see      #getComponentListeners
     * @since    JDK1.1
     */
    public synchronized void removeComponentListener(ComponentListener l) {
<span class="nc bnc" id="L5245" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5246">            return;</span>
        }
<span class="nc" id="L5248">        componentListener = AWTEventMulticaster.remove(componentListener, l);</span>
<span class="nc" id="L5249">    }</span>

    /**
     * Returns an array of all the component listeners
     * registered on this component.
     *
     * @return all &lt;code&gt;ComponentListener&lt;/code&gt;s of this component
     *         or an empty array if no component
     *         listeners are currently registered
     *
     * @see #addComponentListener
     * @see #removeComponentListener
     * @since 1.4
     */
    public synchronized ComponentListener[] getComponentListeners() {
<span class="nc" id="L5264">        return getListeners(ComponentListener.class);</span>
    }

    /**
     * Adds the specified focus listener to receive focus events from
     * this component when this component gains input focus.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the focus listener
     * @see      java.awt.event.FocusEvent
     * @see      java.awt.event.FocusListener
     * @see      #removeFocusListener
     * @see      #getFocusListeners
     * @since    JDK1.1
     */
    public synchronized void addFocusListener(FocusListener l) {
<span class="nc bnc" id="L5283" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5284">            return;</span>
        }
<span class="nc" id="L5286">        focusListener = AWTEventMulticaster.add(focusListener, l);</span>
<span class="nc" id="L5287">        newEventsOnly = true;</span>

        // if this is a lightweight component, enable focus events
        // in the native container.
<span class="nc bnc" id="L5291" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
<span class="nc" id="L5292">            parent.proxyEnableEvents(AWTEvent.FOCUS_EVENT_MASK);</span>
        }
<span class="nc" id="L5294">    }</span>

    /**
     * Removes the specified focus listener so that it no longer
     * receives focus events from this component. This method performs
     * no function, nor does it throw an exception, if the listener
     * specified by the argument was not previously added to this component.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the focus listener
     * @see      java.awt.event.FocusEvent
     * @see      java.awt.event.FocusListener
     * @see      #addFocusListener
     * @see      #getFocusListeners
     * @since    JDK1.1
     */
    public synchronized void removeFocusListener(FocusListener l) {
<span class="nc bnc" id="L5314" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5315">            return;</span>
        }
<span class="nc" id="L5317">        focusListener = AWTEventMulticaster.remove(focusListener, l);</span>
<span class="nc" id="L5318">    }</span>

    /**
     * Returns an array of all the focus listeners
     * registered on this component.
     *
     * @return all of this component's &lt;code&gt;FocusListener&lt;/code&gt;s
     *         or an empty array if no component
     *         listeners are currently registered
     *
     * @see #addFocusListener
     * @see #removeFocusListener
     * @since 1.4
     */
    public synchronized FocusListener[] getFocusListeners() {
<span class="nc" id="L5333">        return getListeners(FocusListener.class);</span>
    }

    /**
     * Adds the specified hierarchy listener to receive hierarchy changed
     * events from this component when the hierarchy to which this container
     * belongs changes.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the hierarchy listener
     * @see      java.awt.event.HierarchyEvent
     * @see      java.awt.event.HierarchyListener
     * @see      #removeHierarchyListener
     * @see      #getHierarchyListeners
     * @since    1.3
     */
    public void addHierarchyListener(HierarchyListener l) {
<span class="nc bnc" id="L5353" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5354">            return;</span>
        }
        boolean notifyAncestors;
<span class="nc" id="L5357">        synchronized (this) {</span>
<span class="nc bnc" id="L5358" title="All 4 branches missed.">            notifyAncestors =</span>
                (hierarchyListener == null &amp;&amp;
                 (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) == 0);
<span class="nc" id="L5361">            hierarchyListener = AWTEventMulticaster.add(hierarchyListener, l);</span>
<span class="nc bnc" id="L5362" title="All 4 branches missed.">            notifyAncestors = (notifyAncestors &amp;&amp; hierarchyListener != null);</span>
<span class="nc" id="L5363">            newEventsOnly = true;</span>
<span class="nc" id="L5364">        }</span>
<span class="nc bnc" id="L5365" title="All 2 branches missed.">        if (notifyAncestors) {</span>
<span class="nc" id="L5366">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L5367">                adjustListeningChildrenOnParent(AWTEvent.HIERARCHY_EVENT_MASK,</span>
                                                1);
<span class="nc" id="L5369">            }</span>
        }
<span class="nc" id="L5371">    }</span>

    /**
     * Removes the specified hierarchy listener so that it no longer
     * receives hierarchy changed events from this component. This method
     * performs no function, nor does it throw an exception, if the listener
     * specified by the argument was not previously added to this component.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the hierarchy listener
     * @see      java.awt.event.HierarchyEvent
     * @see      java.awt.event.HierarchyListener
     * @see      #addHierarchyListener
     * @see      #getHierarchyListeners
     * @since    1.3
     */
    public void removeHierarchyListener(HierarchyListener l) {
<span class="nc bnc" id="L5391" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5392">            return;</span>
        }
        boolean notifyAncestors;
<span class="nc" id="L5395">        synchronized (this) {</span>
<span class="nc bnc" id="L5396" title="All 4 branches missed.">            notifyAncestors =</span>
                (hierarchyListener != null &amp;&amp;
                 (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) == 0);
<span class="nc" id="L5399">            hierarchyListener =</span>
<span class="nc" id="L5400">                AWTEventMulticaster.remove(hierarchyListener, l);</span>
<span class="nc bnc" id="L5401" title="All 4 branches missed.">            notifyAncestors = (notifyAncestors &amp;&amp; hierarchyListener == null);</span>
<span class="nc" id="L5402">        }</span>
<span class="nc bnc" id="L5403" title="All 2 branches missed.">        if (notifyAncestors) {</span>
<span class="nc" id="L5404">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L5405">                adjustListeningChildrenOnParent(AWTEvent.HIERARCHY_EVENT_MASK,</span>
                                                -1);
<span class="nc" id="L5407">            }</span>
        }
<span class="nc" id="L5409">    }</span>

    /**
     * Returns an array of all the hierarchy listeners
     * registered on this component.
     *
     * @return all of this component's &lt;code&gt;HierarchyListener&lt;/code&gt;s
     *         or an empty array if no hierarchy
     *         listeners are currently registered
     *
     * @see      #addHierarchyListener
     * @see      #removeHierarchyListener
     * @since    1.4
     */
    public synchronized HierarchyListener[] getHierarchyListeners() {
<span class="nc" id="L5424">        return getListeners(HierarchyListener.class);</span>
    }

    /**
     * Adds the specified hierarchy bounds listener to receive hierarchy
     * bounds events from this component when the hierarchy to which this
     * container belongs changes.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the hierarchy bounds listener
     * @see      java.awt.event.HierarchyEvent
     * @see      java.awt.event.HierarchyBoundsListener
     * @see      #removeHierarchyBoundsListener
     * @see      #getHierarchyBoundsListeners
     * @since    1.3
     */
    public void addHierarchyBoundsListener(HierarchyBoundsListener l) {
<span class="nc bnc" id="L5444" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5445">            return;</span>
        }
        boolean notifyAncestors;
<span class="nc" id="L5448">        synchronized (this) {</span>
<span class="nc bnc" id="L5449" title="All 4 branches missed.">            notifyAncestors =</span>
                (hierarchyBoundsListener == null &amp;&amp;
                 (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) == 0);
<span class="nc" id="L5452">            hierarchyBoundsListener =</span>
<span class="nc" id="L5453">                AWTEventMulticaster.add(hierarchyBoundsListener, l);</span>
<span class="nc bnc" id="L5454" title="All 4 branches missed.">            notifyAncestors = (notifyAncestors &amp;&amp;</span>
                               hierarchyBoundsListener != null);
<span class="nc" id="L5456">            newEventsOnly = true;</span>
<span class="nc" id="L5457">        }</span>
<span class="nc bnc" id="L5458" title="All 2 branches missed.">        if (notifyAncestors) {</span>
<span class="nc" id="L5459">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L5460">                adjustListeningChildrenOnParent(</span>
                                                AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK, 1);
<span class="nc" id="L5462">            }</span>
        }
<span class="nc" id="L5464">    }</span>

    /**
     * Removes the specified hierarchy bounds listener so that it no longer
     * receives hierarchy bounds events from this component. This method
     * performs no function, nor does it throw an exception, if the listener
     * specified by the argument was not previously added to this component.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the hierarchy bounds listener
     * @see      java.awt.event.HierarchyEvent
     * @see      java.awt.event.HierarchyBoundsListener
     * @see      #addHierarchyBoundsListener
     * @see      #getHierarchyBoundsListeners
     * @since    1.3
     */
    public void removeHierarchyBoundsListener(HierarchyBoundsListener l) {
<span class="nc bnc" id="L5484" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5485">            return;</span>
        }
        boolean notifyAncestors;
<span class="nc" id="L5488">        synchronized (this) {</span>
<span class="nc bnc" id="L5489" title="All 4 branches missed.">            notifyAncestors =</span>
                (hierarchyBoundsListener != null &amp;&amp;
                 (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) == 0);
<span class="nc" id="L5492">            hierarchyBoundsListener =</span>
<span class="nc" id="L5493">                AWTEventMulticaster.remove(hierarchyBoundsListener, l);</span>
<span class="nc bnc" id="L5494" title="All 4 branches missed.">            notifyAncestors = (notifyAncestors &amp;&amp;</span>
                               hierarchyBoundsListener == null);
<span class="nc" id="L5496">        }</span>
<span class="nc bnc" id="L5497" title="All 2 branches missed.">        if (notifyAncestors) {</span>
<span class="nc" id="L5498">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L5499">                adjustListeningChildrenOnParent(</span>
                                                AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK, -1);
<span class="nc" id="L5501">            }</span>
        }
<span class="nc" id="L5503">    }</span>

    // Should only be called while holding the tree lock
    int numListening(long mask) {
        // One mask or the other, but not neither or both.
<span class="nc bnc" id="L5508" title="All 2 branches missed.">        if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc bnc" id="L5509" title="All 4 branches missed.">            if ((mask != AWTEvent.HIERARCHY_EVENT_MASK) &amp;&amp;</span>
                (mask != AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK))
            {
<span class="nc" id="L5512">                eventLog.fine(&quot;Assertion failed&quot;);</span>
            }
        }
<span class="nc bnc" id="L5515" title="All 12 branches missed.">        if ((mask == AWTEvent.HIERARCHY_EVENT_MASK &amp;&amp;</span>
             (hierarchyListener != null ||
              (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0)) ||
            (mask == AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK &amp;&amp;
             (hierarchyBoundsListener != null ||
              (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0))) {
<span class="nc" id="L5521">            return 1;</span>
        } else {
<span class="nc" id="L5523">            return 0;</span>
        }
    }

    // Should only be called while holding tree lock
    int countHierarchyMembers() {
<span class="nc" id="L5529">        return 1;</span>
    }
    // Should only be called while holding the tree lock
    int createHierarchyEvents(int id, Component changed,
                              Container changedParent, long changeFlags,
                              boolean enabledOnToolkit) {
<span class="nc bnc" id="L5535" title="All 3 branches missed.">        switch (id) {</span>
          case HierarchyEvent.HIERARCHY_CHANGED:
<span class="nc bnc" id="L5537" title="All 6 branches missed.">              if (hierarchyListener != null ||</span>
                  (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 ||
                  enabledOnToolkit) {
<span class="nc" id="L5540">                  HierarchyEvent e = new HierarchyEvent(this, id, changed,</span>
                                                        changedParent,
                                                        changeFlags);
<span class="nc" id="L5543">                  dispatchEvent(e);</span>
<span class="nc" id="L5544">                  return 1;</span>
              }
              break;
          case HierarchyEvent.ANCESTOR_MOVED:
          case HierarchyEvent.ANCESTOR_RESIZED:
<span class="nc bnc" id="L5549" title="All 2 branches missed.">              if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc bnc" id="L5550" title="All 2 branches missed.">                  if (changeFlags != 0) {</span>
<span class="nc" id="L5551">                      eventLog.fine(&quot;Assertion (changeFlags == 0) failed&quot;);</span>
                  }
              }
<span class="nc bnc" id="L5554" title="All 6 branches missed.">              if (hierarchyBoundsListener != null ||</span>
                  (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0 ||
                  enabledOnToolkit) {
<span class="nc" id="L5557">                  HierarchyEvent e = new HierarchyEvent(this, id, changed,</span>
                                                        changedParent);
<span class="nc" id="L5559">                  dispatchEvent(e);</span>
<span class="nc" id="L5560">                  return 1;</span>
              }
              break;
          default:
              // assert false
<span class="nc bnc" id="L5565" title="All 2 branches missed.">              if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L5566">                  eventLog.fine(&quot;This code must never be reached&quot;);</span>
              }
              break;
        }
<span class="nc" id="L5570">        return 0;</span>
    }

    /**
     * Returns an array of all the hierarchy bounds listeners
     * registered on this component.
     *
     * @return all of this component's &lt;code&gt;HierarchyBoundsListener&lt;/code&gt;s
     *         or an empty array if no hierarchy bounds
     *         listeners are currently registered
     *
     * @see      #addHierarchyBoundsListener
     * @see      #removeHierarchyBoundsListener
     * @since    1.4
     */
    public synchronized HierarchyBoundsListener[] getHierarchyBoundsListeners() {
<span class="nc" id="L5586">        return getListeners(HierarchyBoundsListener.class);</span>
    }

    /*
     * Should only be called while holding the tree lock.
     * It's added only for overriding in java.awt.Window
     * because parent in Window is owner.
     */
    void adjustListeningChildrenOnParent(long mask, int num) {
<span class="nc bnc" id="L5595" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L5596">            parent.adjustListeningChildren(mask, num);</span>
        }
<span class="nc" id="L5598">    }</span>

    /**
     * Adds the specified key listener to receive key events from
     * this component.
     * If l is null, no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the key listener.
     * @see      java.awt.event.KeyEvent
     * @see      java.awt.event.KeyListener
     * @see      #removeKeyListener
     * @see      #getKeyListeners
     * @since    JDK1.1
     */
    public synchronized void addKeyListener(KeyListener l) {
<span class="nc bnc" id="L5615" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5616">            return;</span>
        }
<span class="nc" id="L5618">        keyListener = AWTEventMulticaster.add(keyListener, l);</span>
<span class="nc" id="L5619">        newEventsOnly = true;</span>

        // if this is a lightweight component, enable key events
        // in the native container.
<span class="nc bnc" id="L5623" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
<span class="nc" id="L5624">            parent.proxyEnableEvents(AWTEvent.KEY_EVENT_MASK);</span>
        }
<span class="nc" id="L5626">    }</span>

    /**
     * Removes the specified key listener so that it no longer
     * receives key events from this component. This method performs
     * no function, nor does it throw an exception, if the listener
     * specified by the argument was not previously added to this component.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the key listener
     * @see      java.awt.event.KeyEvent
     * @see      java.awt.event.KeyListener
     * @see      #addKeyListener
     * @see      #getKeyListeners
     * @since    JDK1.1
     */
    public synchronized void removeKeyListener(KeyListener l) {
<span class="nc bnc" id="L5646" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5647">            return;</span>
        }
<span class="nc" id="L5649">        keyListener = AWTEventMulticaster.remove(keyListener, l);</span>
<span class="nc" id="L5650">    }</span>

    /**
     * Returns an array of all the key listeners
     * registered on this component.
     *
     * @return all of this component's &lt;code&gt;KeyListener&lt;/code&gt;s
     *         or an empty array if no key
     *         listeners are currently registered
     *
     * @see      #addKeyListener
     * @see      #removeKeyListener
     * @since    1.4
     */
    public synchronized KeyListener[] getKeyListeners() {
<span class="nc" id="L5665">        return getListeners(KeyListener.class);</span>
    }

    /**
     * Adds the specified mouse listener to receive mouse events from
     * this component.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the mouse listener
     * @see      java.awt.event.MouseEvent
     * @see      java.awt.event.MouseListener
     * @see      #removeMouseListener
     * @see      #getMouseListeners
     * @since    JDK1.1
     */
    public synchronized void addMouseListener(MouseListener l) {
<span class="nc bnc" id="L5684" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5685">            return;</span>
        }
<span class="nc" id="L5687">        mouseListener = AWTEventMulticaster.add(mouseListener,l);</span>
<span class="nc" id="L5688">        newEventsOnly = true;</span>

        // if this is a lightweight component, enable mouse events
        // in the native container.
<span class="nc bnc" id="L5692" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
<span class="nc" id="L5693">            parent.proxyEnableEvents(AWTEvent.MOUSE_EVENT_MASK);</span>
        }
<span class="nc" id="L5695">    }</span>

    /**
     * Removes the specified mouse listener so that it no longer
     * receives mouse events from this component. This method performs
     * no function, nor does it throw an exception, if the listener
     * specified by the argument was not previously added to this component.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the mouse listener
     * @see      java.awt.event.MouseEvent
     * @see      java.awt.event.MouseListener
     * @see      #addMouseListener
     * @see      #getMouseListeners
     * @since    JDK1.1
     */
    public synchronized void removeMouseListener(MouseListener l) {
<span class="nc bnc" id="L5715" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5716">            return;</span>
        }
<span class="nc" id="L5718">        mouseListener = AWTEventMulticaster.remove(mouseListener, l);</span>
<span class="nc" id="L5719">    }</span>

    /**
     * Returns an array of all the mouse listeners
     * registered on this component.
     *
     * @return all of this component's &lt;code&gt;MouseListener&lt;/code&gt;s
     *         or an empty array if no mouse
     *         listeners are currently registered
     *
     * @see      #addMouseListener
     * @see      #removeMouseListener
     * @since    1.4
     */
    public synchronized MouseListener[] getMouseListeners() {
<span class="nc" id="L5734">        return getListeners(MouseListener.class);</span>
    }

    /**
     * Adds the specified mouse motion listener to receive mouse motion
     * events from this component.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the mouse motion listener
     * @see      java.awt.event.MouseEvent
     * @see      java.awt.event.MouseMotionListener
     * @see      #removeMouseMotionListener
     * @see      #getMouseMotionListeners
     * @since    JDK1.1
     */
    public synchronized void addMouseMotionListener(MouseMotionListener l) {
<span class="nc bnc" id="L5753" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5754">            return;</span>
        }
<span class="nc" id="L5756">        mouseMotionListener = AWTEventMulticaster.add(mouseMotionListener,l);</span>
<span class="nc" id="L5757">        newEventsOnly = true;</span>

        // if this is a lightweight component, enable mouse events
        // in the native container.
<span class="nc bnc" id="L5761" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
<span class="nc" id="L5762">            parent.proxyEnableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);</span>
        }
<span class="nc" id="L5764">    }</span>

    /**
     * Removes the specified mouse motion listener so that it no longer
     * receives mouse motion events from this component. This method performs
     * no function, nor does it throw an exception, if the listener
     * specified by the argument was not previously added to this component.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the mouse motion listener
     * @see      java.awt.event.MouseEvent
     * @see      java.awt.event.MouseMotionListener
     * @see      #addMouseMotionListener
     * @see      #getMouseMotionListeners
     * @since    JDK1.1
     */
    public synchronized void removeMouseMotionListener(MouseMotionListener l) {
<span class="nc bnc" id="L5784" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5785">            return;</span>
        }
<span class="nc" id="L5787">        mouseMotionListener = AWTEventMulticaster.remove(mouseMotionListener, l);</span>
<span class="nc" id="L5788">    }</span>

    /**
     * Returns an array of all the mouse motion listeners
     * registered on this component.
     *
     * @return all of this component's &lt;code&gt;MouseMotionListener&lt;/code&gt;s
     *         or an empty array if no mouse motion
     *         listeners are currently registered
     *
     * @see      #addMouseMotionListener
     * @see      #removeMouseMotionListener
     * @since    1.4
     */
    public synchronized MouseMotionListener[] getMouseMotionListeners() {
<span class="nc" id="L5803">        return getListeners(MouseMotionListener.class);</span>
    }

    /**
     * Adds the specified mouse wheel listener to receive mouse wheel events
     * from this component.  Containers also receive mouse wheel events from
     * sub-components.
     * &lt;p&gt;
     * For information on how mouse wheel events are dispatched, see
     * the class description for {@link MouseWheelEvent}.
     * &lt;p&gt;
     * If l is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no
     * action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the mouse wheel listener
     * @see      java.awt.event.MouseWheelEvent
     * @see      java.awt.event.MouseWheelListener
     * @see      #removeMouseWheelListener
     * @see      #getMouseWheelListeners
     * @since    1.4
     */
    public synchronized void addMouseWheelListener(MouseWheelListener l) {
<span class="nc bnc" id="L5827" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5828">            return;</span>
        }
<span class="nc" id="L5830">        mouseWheelListener = AWTEventMulticaster.add(mouseWheelListener,l);</span>
<span class="nc" id="L5831">        newEventsOnly = true;</span>

        // if this is a lightweight component, enable mouse events
        // in the native container.
<span class="nc bnc" id="L5835" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
<span class="nc" id="L5836">            parent.proxyEnableEvents(AWTEvent.MOUSE_WHEEL_EVENT_MASK);</span>
        }
<span class="nc" id="L5838">    }</span>

    /**
     * Removes the specified mouse wheel listener so that it no longer
     * receives mouse wheel events from this component. This method performs
     * no function, nor does it throw an exception, if the listener
     * specified by the argument was not previously added to this component.
     * If l is null, no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the mouse wheel listener.
     * @see      java.awt.event.MouseWheelEvent
     * @see      java.awt.event.MouseWheelListener
     * @see      #addMouseWheelListener
     * @see      #getMouseWheelListeners
     * @since    1.4
     */
    public synchronized void removeMouseWheelListener(MouseWheelListener l) {
<span class="nc bnc" id="L5857" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5858">            return;</span>
        }
<span class="nc" id="L5860">        mouseWheelListener = AWTEventMulticaster.remove(mouseWheelListener, l);</span>
<span class="nc" id="L5861">    }</span>

    /**
     * Returns an array of all the mouse wheel listeners
     * registered on this component.
     *
     * @return all of this component's &lt;code&gt;MouseWheelListener&lt;/code&gt;s
     *         or an empty array if no mouse wheel
     *         listeners are currently registered
     *
     * @see      #addMouseWheelListener
     * @see      #removeMouseWheelListener
     * @since    1.4
     */
    public synchronized MouseWheelListener[] getMouseWheelListeners() {
<span class="nc" id="L5876">        return getListeners(MouseWheelListener.class);</span>
    }

    /**
     * Adds the specified input method listener to receive
     * input method events from this component. A component will
     * only receive input method events from input methods
     * if it also overrides &lt;code&gt;getInputMethodRequests&lt;/code&gt; to return an
     * &lt;code&gt;InputMethodRequests&lt;/code&gt; instance.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;{@docRoot}/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the input method listener
     * @see      java.awt.event.InputMethodEvent
     * @see      java.awt.event.InputMethodListener
     * @see      #removeInputMethodListener
     * @see      #getInputMethodListeners
     * @see      #getInputMethodRequests
     * @since    1.2
     */
    public synchronized void addInputMethodListener(InputMethodListener l) {
<span class="nc bnc" id="L5899" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5900">            return;</span>
        }
<span class="nc" id="L5902">        inputMethodListener = AWTEventMulticaster.add(inputMethodListener, l);</span>
<span class="nc" id="L5903">        newEventsOnly = true;</span>
<span class="nc" id="L5904">    }</span>

    /**
     * Removes the specified input method listener so that it no longer
     * receives input method events from this component. This method performs
     * no function, nor does it throw an exception, if the listener
     * specified by the argument was not previously added to this component.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param    l   the input method listener
     * @see      java.awt.event.InputMethodEvent
     * @see      java.awt.event.InputMethodListener
     * @see      #addInputMethodListener
     * @see      #getInputMethodListeners
     * @since    1.2
     */
    public synchronized void removeInputMethodListener(InputMethodListener l) {
<span class="nc bnc" id="L5924" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L5925">            return;</span>
        }
<span class="nc" id="L5927">        inputMethodListener = AWTEventMulticaster.remove(inputMethodListener, l);</span>
<span class="nc" id="L5928">    }</span>

    /**
     * Returns an array of all the input method listeners
     * registered on this component.
     *
     * @return all of this component's &lt;code&gt;InputMethodListener&lt;/code&gt;s
     *         or an empty array if no input method
     *         listeners are currently registered
     *
     * @see      #addInputMethodListener
     * @see      #removeInputMethodListener
     * @since    1.4
     */
    public synchronized InputMethodListener[] getInputMethodListeners() {
<span class="nc" id="L5943">        return getListeners(InputMethodListener.class);</span>
    }

    /**
     * Returns an array of all the objects currently registered
     * as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
     * upon this &lt;code&gt;Component&lt;/code&gt;.
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
     * &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
     *
     * &lt;p&gt;
     * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
     * with a class literal, such as
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
     * For example, you can query a
     * &lt;code&gt;Component&lt;/code&gt; &lt;code&gt;c&lt;/code&gt;
     * for its mouse listeners with the following code:
     *
     * &lt;pre&gt;MouseListener[] mls = (MouseListener[])(c.getListeners(MouseListener.class));&lt;/pre&gt;
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @return an array of all objects registered as
     *          &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s on this component,
     *          or an empty array if no such listeners have been added
     * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt;
     *          doesn't specify a class or interface that implements
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @throws NullPointerException if {@code listenerType} is {@code null}
     * @see #getComponentListeners
     * @see #getFocusListeners
     * @see #getHierarchyListeners
     * @see #getHierarchyBoundsListeners
     * @see #getKeyListeners
     * @see #getMouseListeners
     * @see #getMouseMotionListeners
     * @see #getMouseWheelListeners
     * @see #getInputMethodListeners
     * @see #getPropertyChangeListeners
     *
     * @since 1.3
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<span class="nc" id="L5990">        EventListener l = null;</span>
<span class="nc bnc" id="L5991" title="All 2 branches missed.">        if  (listenerType == ComponentListener.class) {</span>
<span class="nc" id="L5992">            l = componentListener;</span>
<span class="nc bnc" id="L5993" title="All 2 branches missed.">        } else if (listenerType == FocusListener.class) {</span>
<span class="nc" id="L5994">            l = focusListener;</span>
<span class="nc bnc" id="L5995" title="All 2 branches missed.">        } else if (listenerType == HierarchyListener.class) {</span>
<span class="nc" id="L5996">            l = hierarchyListener;</span>
<span class="nc bnc" id="L5997" title="All 2 branches missed.">        } else if (listenerType == HierarchyBoundsListener.class) {</span>
<span class="nc" id="L5998">            l = hierarchyBoundsListener;</span>
<span class="nc bnc" id="L5999" title="All 2 branches missed.">        } else if (listenerType == KeyListener.class) {</span>
<span class="nc" id="L6000">            l = keyListener;</span>
<span class="nc bnc" id="L6001" title="All 2 branches missed.">        } else if (listenerType == MouseListener.class) {</span>
<span class="nc" id="L6002">            l = mouseListener;</span>
<span class="nc bnc" id="L6003" title="All 2 branches missed.">        } else if (listenerType == MouseMotionListener.class) {</span>
<span class="nc" id="L6004">            l = mouseMotionListener;</span>
<span class="nc bnc" id="L6005" title="All 2 branches missed.">        } else if (listenerType == MouseWheelListener.class) {</span>
<span class="nc" id="L6006">            l = mouseWheelListener;</span>
<span class="nc bnc" id="L6007" title="All 2 branches missed.">        } else if (listenerType == InputMethodListener.class) {</span>
<span class="nc" id="L6008">            l = inputMethodListener;</span>
<span class="nc bnc" id="L6009" title="All 2 branches missed.">        } else if (listenerType == PropertyChangeListener.class) {</span>
<span class="nc" id="L6010">            return (T[])getPropertyChangeListeners();</span>
        }
<span class="nc" id="L6012">        return AWTEventMulticaster.getListeners(l, listenerType);</span>
    }

    /**
     * Gets the input method request handler which supports
     * requests from input methods for this component. A component
     * that supports on-the-spot text input must override this
     * method to return an &lt;code&gt;InputMethodRequests&lt;/code&gt; instance.
     * At the same time, it also has to handle input method events.
     *
     * @return the input method request handler for this component,
     *          &lt;code&gt;null&lt;/code&gt; by default
     * @see #addInputMethodListener
     * @since 1.2
     */
    public InputMethodRequests getInputMethodRequests() {
<span class="nc" id="L6028">        return null;</span>
    }

    /**
     * Gets the input context used by this component for handling
     * the communication with input methods when text is entered
     * in this component. By default, the input context used for
     * the parent component is returned. Components may
     * override this to return a private input context.
     *
     * @return the input context used by this component;
     *          &lt;code&gt;null&lt;/code&gt; if no context can be determined
     * @since 1.2
     */
    public InputContext getInputContext() {
<span class="nc" id="L6043">        Container parent = this.parent;</span>
<span class="nc bnc" id="L6044" title="All 2 branches missed.">        if (parent == null) {</span>
<span class="nc" id="L6045">            return null;</span>
        } else {
<span class="nc" id="L6047">            return parent.getInputContext();</span>
        }
    }

    /**
     * Enables the events defined by the specified event mask parameter
     * to be delivered to this component.
     * &lt;p&gt;
     * Event types are automatically enabled when a listener for
     * that event type is added to the component.
     * &lt;p&gt;
     * This method only needs to be invoked by subclasses of
     * &lt;code&gt;Component&lt;/code&gt; which desire to have the specified event
     * types delivered to &lt;code&gt;processEvent&lt;/code&gt; regardless of whether
     * or not a listener is registered.
     * @param      eventsToEnable   the event mask defining the event types
     * @see        #processEvent
     * @see        #disableEvents
     * @see        AWTEvent
     * @since      JDK1.1
     */
    protected final void enableEvents(long eventsToEnable) {
<span class="nc" id="L6069">        long notifyAncestors = 0;</span>
<span class="nc" id="L6070">        synchronized (this) {</span>
<span class="nc bnc" id="L6071" title="All 6 branches missed.">            if ((eventsToEnable &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 &amp;&amp;</span>
                hierarchyListener == null &amp;&amp;
                (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) == 0) {
<span class="nc" id="L6074">                notifyAncestors |= AWTEvent.HIERARCHY_EVENT_MASK;</span>
            }
<span class="nc bnc" id="L6076" title="All 6 branches missed.">            if ((eventsToEnable &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0 &amp;&amp;</span>
                hierarchyBoundsListener == null &amp;&amp;
                (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) == 0) {
<span class="nc" id="L6079">                notifyAncestors |= AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK;</span>
            }
<span class="nc" id="L6081">            eventMask |= eventsToEnable;</span>
<span class="nc" id="L6082">            newEventsOnly = true;</span>
<span class="nc" id="L6083">        }</span>

        // if this is a lightweight component, enable mouse events
        // in the native container.
<span class="nc bnc" id="L6087" title="All 2 branches missed.">        if (peer instanceof LightweightPeer) {</span>
<span class="nc" id="L6088">            parent.proxyEnableEvents(eventMask);</span>
        }
<span class="nc bnc" id="L6090" title="All 2 branches missed.">        if (notifyAncestors != 0) {</span>
<span class="nc" id="L6091">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L6092">                adjustListeningChildrenOnParent(notifyAncestors, 1);</span>
<span class="nc" id="L6093">            }</span>
        }
<span class="nc" id="L6095">    }</span>

    /**
     * Disables the events defined by the specified event mask parameter
     * from being delivered to this component.
     * @param      eventsToDisable   the event mask defining the event types
     * @see        #enableEvents
     * @since      JDK1.1
     */
    protected final void disableEvents(long eventsToDisable) {
<span class="nc" id="L6105">        long notifyAncestors = 0;</span>
<span class="nc" id="L6106">        synchronized (this) {</span>
<span class="nc bnc" id="L6107" title="All 6 branches missed.">            if ((eventsToDisable &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 &amp;&amp;</span>
                hierarchyListener == null &amp;&amp;
                (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0) {
<span class="nc" id="L6110">                notifyAncestors |= AWTEvent.HIERARCHY_EVENT_MASK;</span>
            }
<span class="nc bnc" id="L6112" title="All 6 branches missed.">            if ((eventsToDisable &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK)!=0 &amp;&amp;</span>
                hierarchyBoundsListener == null &amp;&amp;
                (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0) {
<span class="nc" id="L6115">                notifyAncestors |= AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK;</span>
            }
<span class="nc" id="L6117">            eventMask &amp;= ~eventsToDisable;</span>
<span class="nc" id="L6118">        }</span>
<span class="nc bnc" id="L6119" title="All 2 branches missed.">        if (notifyAncestors != 0) {</span>
<span class="nc" id="L6120">            synchronized (getTreeLock()) {</span>
<span class="nc" id="L6121">                adjustListeningChildrenOnParent(notifyAncestors, -1);</span>
<span class="nc" id="L6122">            }</span>
        }
<span class="nc" id="L6124">    }</span>

    transient sun.awt.EventQueueItem[] eventCache;

    /**
     * @see #isCoalescingEnabled
     * @see #checkCoalescing
     */
<span class="nc" id="L6132">    transient private boolean coalescingEnabled = checkCoalescing();</span>

    /**
     * Weak map of known coalesceEvent overriders.
     * Value indicates whether overriden.
     * Bootstrap classes are not included.
     */
<span class="fc" id="L6139">    private static final Map&lt;Class&lt;?&gt;, Boolean&gt; coalesceMap =</span>
        new java.util.WeakHashMap&lt;Class&lt;?&gt;, Boolean&gt;();

    /**
     * Indicates whether this class overrides coalesceEvents.
     * It is assumed that all classes that are loaded from the bootstrap
     *   do not.
     * The boostrap class loader is assumed to be represented by null.
     * We do not check that the method really overrides
     *   (it might be static, private or package private).
     */
     private boolean checkCoalescing() {
<span class="nc bnc" id="L6151" title="All 2 branches missed.">         if (getClass().getClassLoader()==null) {</span>
<span class="nc" id="L6152">             return false;</span>
         }
<span class="nc" id="L6154">         final Class&lt;? extends Component&gt; clazz = getClass();</span>
<span class="nc" id="L6155">         synchronized (coalesceMap) {</span>
             // Check cache.
<span class="nc" id="L6157">             Boolean value = coalesceMap.get(clazz);</span>
<span class="nc bnc" id="L6158" title="All 2 branches missed.">             if (value != null) {</span>
<span class="nc" id="L6159">                 return value;</span>
             }

             // Need to check non-bootstraps.
<span class="nc" id="L6163">             Boolean enabled = java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L6164">                 new java.security.PrivilegedAction&lt;Boolean&gt;() {</span>
                     public Boolean run() {
<span class="nc" id="L6166">                         return isCoalesceEventsOverriden(clazz);</span>
                     }
                 }
                 );
<span class="nc" id="L6170">             coalesceMap.put(clazz, enabled);</span>
<span class="nc" id="L6171">             return enabled;</span>
<span class="nc" id="L6172">         }</span>
     }

    /**
     * Parameter types of coalesceEvents(AWTEvent,AWTEVent).
     */
<span class="fc" id="L6178">    private static final Class[] coalesceEventsParams = {</span>
        AWTEvent.class, AWTEvent.class
    };

    /**
     * Indicates whether a class or its superclasses override coalesceEvents.
     * Must be called with lock on coalesceMap and privileged.
     * @see checkCoalsecing
     */
    private static boolean isCoalesceEventsOverriden(Class&lt;?&gt; clazz) {
<span class="nc bnc" id="L6188" title="All 4 branches missed.">        assert Thread.holdsLock(coalesceMap);</span>

        // First check superclass - we may not need to bother ourselves.
<span class="nc" id="L6191">        Class&lt;?&gt; superclass = clazz.getSuperclass();</span>
<span class="nc bnc" id="L6192" title="All 2 branches missed.">        if (superclass == null) {</span>
            // Only occurs on implementations that
            //   do not use null to represent the bootsrap class loader.
<span class="nc" id="L6195">            return false;</span>
        }
<span class="nc bnc" id="L6197" title="All 2 branches missed.">        if (superclass.getClassLoader() != null) {</span>
<span class="nc" id="L6198">            Boolean value = coalesceMap.get(superclass);</span>
<span class="nc bnc" id="L6199" title="All 2 branches missed.">            if (value == null) {</span>
                // Not done already - recurse.
<span class="nc bnc" id="L6201" title="All 2 branches missed.">                if (isCoalesceEventsOverriden(superclass)) {</span>
<span class="nc" id="L6202">                    coalesceMap.put(superclass, true);</span>
<span class="nc" id="L6203">                    return true;</span>
                }
<span class="nc bnc" id="L6205" title="All 2 branches missed.">            } else if (value) {</span>
<span class="nc" id="L6206">                return true;</span>
            }
        }

        try {
            // Throws if not overriden.
<span class="nc" id="L6212">            clazz.getDeclaredMethod(</span>
                &quot;coalesceEvents&quot;, coalesceEventsParams
                );
<span class="nc" id="L6215">            return true;</span>
<span class="nc" id="L6216">        } catch (NoSuchMethodException e) {</span>
            // Not present in this class.
<span class="nc" id="L6218">            return false;</span>
        }
    }

    /**
     * Indicates whether coalesceEvents may do something.
     */
    final boolean isCoalescingEnabled() {
<span class="nc" id="L6226">        return coalescingEnabled;</span>
     }


    /**
     * Potentially coalesce an event being posted with an existing
     * event.  This method is called by &lt;code&gt;EventQueue.postEvent&lt;/code&gt;
     * if an event with the same ID as the event to be posted is found in
     * the queue (both events must have this component as their source).
     * This method either returns a coalesced event which replaces
     * the existing event (and the new event is then discarded), or
     * &lt;code&gt;null&lt;/code&gt; to indicate that no combining should be done
     * (add the second event to the end of the queue).  Either event
     * parameter may be modified and returned, as the other one is discarded
     * unless &lt;code&gt;null&lt;/code&gt; is returned.
     * &lt;p&gt;
     * This implementation of &lt;code&gt;coalesceEvents&lt;/code&gt; coalesces
     * two event types: mouse move (and drag) events,
     * and paint (and update) events.
     * For mouse move events the last event is always returned, causing
     * intermediate moves to be discarded.  For paint events, the new
     * event is coalesced into a complex &lt;code&gt;RepaintArea&lt;/code&gt; in the peer.
     * The new &lt;code&gt;AWTEvent&lt;/code&gt; is always returned.
     *
     * @param  existingEvent  the event already on the &lt;code&gt;EventQueue&lt;/code&gt;
     * @param  newEvent       the event being posted to the
     *          &lt;code&gt;EventQueue&lt;/code&gt;
     * @return a coalesced event, or &lt;code&gt;null&lt;/code&gt; indicating that no
     *          coalescing was done
     */
    protected AWTEvent coalesceEvents(AWTEvent existingEvent,
                                      AWTEvent newEvent) {
<span class="nc" id="L6258">        return null;</span>
    }

    /**
     * Processes events occurring on this component. By default this
     * method calls the appropriate
     * &lt;code&gt;process&amp;lt;event&amp;nbsp;type&amp;gt;Event&lt;/code&gt;
     * method for the given class of event.
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param     e the event
     * @see       #processComponentEvent
     * @see       #processFocusEvent
     * @see       #processKeyEvent
     * @see       #processMouseEvent
     * @see       #processMouseMotionEvent
     * @see       #processInputMethodEvent
     * @see       #processHierarchyEvent
     * @see       #processMouseWheelEvent
     * @since     JDK1.1
     */
    protected void processEvent(AWTEvent e) {
<span class="nc bnc" id="L6282" title="All 2 branches missed.">        if (e instanceof FocusEvent) {</span>
<span class="nc" id="L6283">            processFocusEvent((FocusEvent)e);</span>

<span class="nc bnc" id="L6285" title="All 2 branches missed.">        } else if (e instanceof MouseEvent) {</span>
<span class="nc bnc" id="L6286" title="All 4 branches missed.">            switch(e.getID()) {</span>
              case MouseEvent.MOUSE_PRESSED:
              case MouseEvent.MOUSE_RELEASED:
              case MouseEvent.MOUSE_CLICKED:
              case MouseEvent.MOUSE_ENTERED:
              case MouseEvent.MOUSE_EXITED:
<span class="nc" id="L6292">                  processMouseEvent((MouseEvent)e);</span>
<span class="nc" id="L6293">                  break;</span>
              case MouseEvent.MOUSE_MOVED:
              case MouseEvent.MOUSE_DRAGGED:
<span class="nc" id="L6296">                  processMouseMotionEvent((MouseEvent)e);</span>
<span class="nc" id="L6297">                  break;</span>
              case MouseEvent.MOUSE_WHEEL:
<span class="nc" id="L6299">                  processMouseWheelEvent((MouseWheelEvent)e);</span>
<span class="nc" id="L6300">                  break;</span>
            }

<span class="nc bnc" id="L6303" title="All 2 branches missed.">        } else if (e instanceof KeyEvent) {</span>
<span class="nc" id="L6304">            processKeyEvent((KeyEvent)e);</span>

<span class="nc bnc" id="L6306" title="All 2 branches missed.">        } else if (e instanceof ComponentEvent) {</span>
<span class="nc" id="L6307">            processComponentEvent((ComponentEvent)e);</span>
<span class="nc bnc" id="L6308" title="All 2 branches missed.">        } else if (e instanceof InputMethodEvent) {</span>
<span class="nc" id="L6309">            processInputMethodEvent((InputMethodEvent)e);</span>
<span class="nc bnc" id="L6310" title="All 2 branches missed.">        } else if (e instanceof HierarchyEvent) {</span>
<span class="nc bnc" id="L6311" title="All 3 branches missed.">            switch (e.getID()) {</span>
              case HierarchyEvent.HIERARCHY_CHANGED:
<span class="nc" id="L6313">                  processHierarchyEvent((HierarchyEvent)e);</span>
<span class="nc" id="L6314">                  break;</span>
              case HierarchyEvent.ANCESTOR_MOVED:
              case HierarchyEvent.ANCESTOR_RESIZED:
<span class="nc" id="L6317">                  processHierarchyBoundsEvent((HierarchyEvent)e);</span>
                  break;
            }
        }
<span class="nc" id="L6321">    }</span>

    /**
     * Processes component events occurring on this component by
     * dispatching them to any registered
     * &lt;code&gt;ComponentListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * This method is not called unless component events are
     * enabled for this component. Component events are enabled
     * when one of the following occurs:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;A &lt;code&gt;ComponentListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addComponentListener&lt;/code&gt;.
     * &lt;li&gt;Component events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the component event
     * @see         java.awt.event.ComponentEvent
     * @see         java.awt.event.ComponentListener
     * @see         #addComponentListener
     * @see         #enableEvents
     * @since       JDK1.1
     */
    protected void processComponentEvent(ComponentEvent e) {
<span class="nc" id="L6348">        ComponentListener listener = componentListener;</span>
<span class="nc bnc" id="L6349" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L6350">            int id = e.getID();</span>
<span class="nc bnc" id="L6351" title="All 5 branches missed.">            switch(id) {</span>
              case ComponentEvent.COMPONENT_RESIZED:
<span class="nc" id="L6353">                  listener.componentResized(e);</span>
<span class="nc" id="L6354">                  break;</span>
              case ComponentEvent.COMPONENT_MOVED:
<span class="nc" id="L6356">                  listener.componentMoved(e);</span>
<span class="nc" id="L6357">                  break;</span>
              case ComponentEvent.COMPONENT_SHOWN:
<span class="nc" id="L6359">                  listener.componentShown(e);</span>
<span class="nc" id="L6360">                  break;</span>
              case ComponentEvent.COMPONENT_HIDDEN:
<span class="nc" id="L6362">                  listener.componentHidden(e);</span>
                  break;
            }
        }
<span class="nc" id="L6366">    }</span>

    /**
     * Processes focus events occurring on this component by
     * dispatching them to any registered
     * &lt;code&gt;FocusListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * This method is not called unless focus events are
     * enabled for this component. Focus events are enabled
     * when one of the following occurs:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;A &lt;code&gt;FocusListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addFocusListener&lt;/code&gt;.
     * &lt;li&gt;Focus events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * If focus events are enabled for a &lt;code&gt;Component&lt;/code&gt;,
     * the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; determines
     * whether or not a focus event should be dispatched to
     * registered &lt;code&gt;FocusListener&lt;/code&gt; objects.  If the
     * events are to be dispatched, the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
     * calls the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt;
     * method, which results in a call to the &lt;code&gt;Component&lt;/code&gt;'s
     * &lt;code&gt;processFocusEvent&lt;/code&gt; method.
     * &lt;p&gt;
     * If focus events are enabled for a &lt;code&gt;Component&lt;/code&gt;, calling
     * the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt; method
     * with a &lt;code&gt;FocusEvent&lt;/code&gt; as the argument will result in a
     * call to the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;processFocusEvent&lt;/code&gt;
     * method regardless of the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the focus event
     * @see         java.awt.event.FocusEvent
     * @see         java.awt.event.FocusListener
     * @see         java.awt.KeyboardFocusManager
     * @see         #addFocusListener
     * @see         #enableEvents
     * @see         #dispatchEvent
     * @since       JDK1.1
     */
    protected void processFocusEvent(FocusEvent e) {
<span class="nc" id="L6411">        FocusListener listener = focusListener;</span>
<span class="nc bnc" id="L6412" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L6413">            int id = e.getID();</span>
<span class="nc bnc" id="L6414" title="All 3 branches missed.">            switch(id) {</span>
              case FocusEvent.FOCUS_GAINED:
<span class="nc" id="L6416">                  listener.focusGained(e);</span>
<span class="nc" id="L6417">                  break;</span>
              case FocusEvent.FOCUS_LOST:
<span class="nc" id="L6419">                  listener.focusLost(e);</span>
                  break;
            }
        }
<span class="nc" id="L6423">    }</span>

    /**
     * Processes key events occurring on this component by
     * dispatching them to any registered
     * &lt;code&gt;KeyListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * This method is not called unless key events are
     * enabled for this component. Key events are enabled
     * when one of the following occurs:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;A &lt;code&gt;KeyListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addKeyListener&lt;/code&gt;.
     * &lt;li&gt;Key events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * If key events are enabled for a &lt;code&gt;Component&lt;/code&gt;,
     * the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; determines
     * whether or not a key event should be dispatched to
     * registered &lt;code&gt;KeyListener&lt;/code&gt; objects.  The
     * &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; will not dispatch
     * key events to a &lt;code&gt;Component&lt;/code&gt; that is not the focus
     * owner or is not showing.
     * &lt;p&gt;
     * As of J2SE 1.4, &lt;code&gt;KeyEvent&lt;/code&gt;s are redirected to
     * the focus owner. Please see the
     * &lt;a href=&quot;doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
     * for further information.
     * &lt;p&gt;
     * Calling a &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt;
     * method with a &lt;code&gt;KeyEvent&lt;/code&gt; as the argument will
     * result in a call to the &lt;code&gt;Component&lt;/code&gt;'s
     * &lt;code&gt;processKeyEvent&lt;/code&gt; method regardless of the
     * current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; as long as the
     * component is showing, focused, and enabled, and key events
     * are enabled on it.
     * &lt;p&gt;If the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the key event
     * @see         java.awt.event.KeyEvent
     * @see         java.awt.event.KeyListener
     * @see         java.awt.KeyboardFocusManager
     * @see         java.awt.DefaultKeyboardFocusManager
     * @see         #processEvent
     * @see         #dispatchEvent
     * @see         #addKeyListener
     * @see         #enableEvents
     * @see         #isShowing
     * @since       JDK1.1
     */
    protected void processKeyEvent(KeyEvent e) {
<span class="nc" id="L6477">        KeyListener listener = keyListener;</span>
<span class="nc bnc" id="L6478" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L6479">            int id = e.getID();</span>
<span class="nc bnc" id="L6480" title="All 4 branches missed.">            switch(id) {</span>
              case KeyEvent.KEY_TYPED:
<span class="nc" id="L6482">                  listener.keyTyped(e);</span>
<span class="nc" id="L6483">                  break;</span>
              case KeyEvent.KEY_PRESSED:
<span class="nc" id="L6485">                  listener.keyPressed(e);</span>
<span class="nc" id="L6486">                  break;</span>
              case KeyEvent.KEY_RELEASED:
<span class="nc" id="L6488">                  listener.keyReleased(e);</span>
                  break;
            }
        }
<span class="nc" id="L6492">    }</span>

    /**
     * Processes mouse events occurring on this component by
     * dispatching them to any registered
     * &lt;code&gt;MouseListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * This method is not called unless mouse events are
     * enabled for this component. Mouse events are enabled
     * when one of the following occurs:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;A &lt;code&gt;MouseListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addMouseListener&lt;/code&gt;.
     * &lt;li&gt;Mouse events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the mouse event
     * @see         java.awt.event.MouseEvent
     * @see         java.awt.event.MouseListener
     * @see         #addMouseListener
     * @see         #enableEvents
     * @since       JDK1.1
     */
    protected void processMouseEvent(MouseEvent e) {
<span class="nc" id="L6519">        MouseListener listener = mouseListener;</span>
<span class="nc bnc" id="L6520" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L6521">            int id = e.getID();</span>
<span class="nc bnc" id="L6522" title="All 6 branches missed.">            switch(id) {</span>
              case MouseEvent.MOUSE_PRESSED:
<span class="nc" id="L6524">                  listener.mousePressed(e);</span>
<span class="nc" id="L6525">                  break;</span>
              case MouseEvent.MOUSE_RELEASED:
<span class="nc" id="L6527">                  listener.mouseReleased(e);</span>
<span class="nc" id="L6528">                  break;</span>
              case MouseEvent.MOUSE_CLICKED:
<span class="nc" id="L6530">                  listener.mouseClicked(e);</span>
<span class="nc" id="L6531">                  break;</span>
              case MouseEvent.MOUSE_EXITED:
<span class="nc" id="L6533">                  listener.mouseExited(e);</span>
<span class="nc" id="L6534">                  break;</span>
              case MouseEvent.MOUSE_ENTERED:
<span class="nc" id="L6536">                  listener.mouseEntered(e);</span>
                  break;
            }
        }
<span class="nc" id="L6540">    }</span>

    /**
     * Processes mouse motion events occurring on this component by
     * dispatching them to any registered
     * &lt;code&gt;MouseMotionListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * This method is not called unless mouse motion events are
     * enabled for this component. Mouse motion events are enabled
     * when one of the following occurs:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;A &lt;code&gt;MouseMotionListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addMouseMotionListener&lt;/code&gt;.
     * &lt;li&gt;Mouse motion events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the mouse motion event
     * @see         java.awt.event.MouseEvent
     * @see         java.awt.event.MouseMotionListener
     * @see         #addMouseMotionListener
     * @see         #enableEvents
     * @since       JDK1.1
     */
    protected void processMouseMotionEvent(MouseEvent e) {
<span class="nc" id="L6567">        MouseMotionListener listener = mouseMotionListener;</span>
<span class="nc bnc" id="L6568" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L6569">            int id = e.getID();</span>
<span class="nc bnc" id="L6570" title="All 3 branches missed.">            switch(id) {</span>
              case MouseEvent.MOUSE_MOVED:
<span class="nc" id="L6572">                  listener.mouseMoved(e);</span>
<span class="nc" id="L6573">                  break;</span>
              case MouseEvent.MOUSE_DRAGGED:
<span class="nc" id="L6575">                  listener.mouseDragged(e);</span>
                  break;
            }
        }
<span class="nc" id="L6579">    }</span>

    /**
     * Processes mouse wheel events occurring on this component by
     * dispatching them to any registered
     * &lt;code&gt;MouseWheelListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * This method is not called unless mouse wheel events are
     * enabled for this component. Mouse wheel events are enabled
     * when one of the following occurs:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;A &lt;code&gt;MouseWheelListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addMouseWheelListener&lt;/code&gt;.
     * &lt;li&gt;Mouse wheel events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * For information on how mouse wheel events are dispatched, see
     * the class description for {@link MouseWheelEvent}.
     * &lt;p&gt;
     * Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the mouse wheel event
     * @see         java.awt.event.MouseWheelEvent
     * @see         java.awt.event.MouseWheelListener
     * @see         #addMouseWheelListener
     * @see         #enableEvents
     * @since       1.4
     */
    protected void processMouseWheelEvent(MouseWheelEvent e) {
<span class="nc" id="L6610">        MouseWheelListener listener = mouseWheelListener;</span>
<span class="nc bnc" id="L6611" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L6612">            int id = e.getID();</span>
<span class="nc bnc" id="L6613" title="All 2 branches missed.">            switch(id) {</span>
              case MouseEvent.MOUSE_WHEEL:
<span class="nc" id="L6615">                  listener.mouseWheelMoved(e);</span>
                  break;
            }
        }
<span class="nc" id="L6619">    }</span>

    boolean postsOldMouseEvents() {
<span class="nc" id="L6622">        return false;</span>
    }

    /**
     * Processes input method events occurring on this component by
     * dispatching them to any registered
     * &lt;code&gt;InputMethodListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * This method is not called unless input method events
     * are enabled for this component. Input method events are enabled
     * when one of the following occurs:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;An &lt;code&gt;InputMethodListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addInputMethodListener&lt;/code&gt;.
     * &lt;li&gt;Input method events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the input method event
     * @see         java.awt.event.InputMethodEvent
     * @see         java.awt.event.InputMethodListener
     * @see         #addInputMethodListener
     * @see         #enableEvents
     * @since       1.2
     */
    protected void processInputMethodEvent(InputMethodEvent e) {
<span class="nc" id="L6650">        InputMethodListener listener = inputMethodListener;</span>
<span class="nc bnc" id="L6651" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L6652">            int id = e.getID();</span>
<span class="nc bnc" id="L6653" title="All 3 branches missed.">            switch (id) {</span>
              case InputMethodEvent.INPUT_METHOD_TEXT_CHANGED:
<span class="nc" id="L6655">                  listener.inputMethodTextChanged(e);</span>
<span class="nc" id="L6656">                  break;</span>
              case InputMethodEvent.CARET_POSITION_CHANGED:
<span class="nc" id="L6658">                  listener.caretPositionChanged(e);</span>
                  break;
            }
        }
<span class="nc" id="L6662">    }</span>

    /**
     * Processes hierarchy events occurring on this component by
     * dispatching them to any registered
     * &lt;code&gt;HierarchyListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * This method is not called unless hierarchy events
     * are enabled for this component. Hierarchy events are enabled
     * when one of the following occurs:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;An &lt;code&gt;HierarchyListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addHierarchyListener&lt;/code&gt;.
     * &lt;li&gt;Hierarchy events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the hierarchy event
     * @see         java.awt.event.HierarchyEvent
     * @see         java.awt.event.HierarchyListener
     * @see         #addHierarchyListener
     * @see         #enableEvents
     * @since       1.3
     */
    protected void processHierarchyEvent(HierarchyEvent e) {
<span class="nc" id="L6689">        HierarchyListener listener = hierarchyListener;</span>
<span class="nc bnc" id="L6690" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L6691">            int id = e.getID();</span>
<span class="nc bnc" id="L6692" title="All 2 branches missed.">            switch (id) {</span>
              case HierarchyEvent.HIERARCHY_CHANGED:
<span class="nc" id="L6694">                  listener.hierarchyChanged(e);</span>
                  break;
            }
        }
<span class="nc" id="L6698">    }</span>

    /**
     * Processes hierarchy bounds events occurring on this component by
     * dispatching them to any registered
     * &lt;code&gt;HierarchyBoundsListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * This method is not called unless hierarchy bounds events
     * are enabled for this component. Hierarchy bounds events are enabled
     * when one of the following occurs:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;An &lt;code&gt;HierarchyBoundsListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addHierarchyBoundsListener&lt;/code&gt;.
     * &lt;li&gt;Hierarchy bounds events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the hierarchy event
     * @see         java.awt.event.HierarchyEvent
     * @see         java.awt.event.HierarchyBoundsListener
     * @see         #addHierarchyBoundsListener
     * @see         #enableEvents
     * @since       1.3
     */
    protected void processHierarchyBoundsEvent(HierarchyEvent e) {
<span class="nc" id="L6725">        HierarchyBoundsListener listener = hierarchyBoundsListener;</span>
<span class="nc bnc" id="L6726" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L6727">            int id = e.getID();</span>
<span class="nc bnc" id="L6728" title="All 3 branches missed.">            switch (id) {</span>
              case HierarchyEvent.ANCESTOR_MOVED:
<span class="nc" id="L6730">                  listener.ancestorMoved(e);</span>
<span class="nc" id="L6731">                  break;</span>
              case HierarchyEvent.ANCESTOR_RESIZED:
<span class="nc" id="L6733">                  listener.ancestorResized(e);</span>
                  break;
            }
        }
<span class="nc" id="L6737">    }</span>

    /**
     * @deprecated As of JDK version 1.1
     * replaced by processEvent(AWTEvent).
     */
    @Deprecated
    public boolean handleEvent(Event evt) {
<span class="nc bnc" id="L6745" title="All 12 branches missed.">        switch (evt.id) {</span>
          case Event.MOUSE_ENTER:
<span class="nc" id="L6747">              return mouseEnter(evt, evt.x, evt.y);</span>

          case Event.MOUSE_EXIT:
<span class="nc" id="L6750">              return mouseExit(evt, evt.x, evt.y);</span>

          case Event.MOUSE_MOVE:
<span class="nc" id="L6753">              return mouseMove(evt, evt.x, evt.y);</span>

          case Event.MOUSE_DOWN:
<span class="nc" id="L6756">              return mouseDown(evt, evt.x, evt.y);</span>

          case Event.MOUSE_DRAG:
<span class="nc" id="L6759">              return mouseDrag(evt, evt.x, evt.y);</span>

          case Event.MOUSE_UP:
<span class="nc" id="L6762">              return mouseUp(evt, evt.x, evt.y);</span>

          case Event.KEY_PRESS:
          case Event.KEY_ACTION:
<span class="nc" id="L6766">              return keyDown(evt, evt.key);</span>

          case Event.KEY_RELEASE:
          case Event.KEY_ACTION_RELEASE:
<span class="nc" id="L6770">              return keyUp(evt, evt.key);</span>

          case Event.ACTION_EVENT:
<span class="nc" id="L6773">              return action(evt, evt.arg);</span>
          case Event.GOT_FOCUS:
<span class="nc" id="L6775">              return gotFocus(evt, evt.arg);</span>
          case Event.LOST_FOCUS:
<span class="nc" id="L6777">              return lostFocus(evt, evt.arg);</span>
        }
<span class="nc" id="L6779">        return false;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by processMouseEvent(MouseEvent).
     */
    @Deprecated
    public boolean mouseDown(Event evt, int x, int y) {
<span class="nc" id="L6788">        return false;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by processMouseMotionEvent(MouseEvent).
     */
    @Deprecated
    public boolean mouseDrag(Event evt, int x, int y) {
<span class="nc" id="L6797">        return false;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by processMouseEvent(MouseEvent).
     */
    @Deprecated
    public boolean mouseUp(Event evt, int x, int y) {
<span class="nc" id="L6806">        return false;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by processMouseMotionEvent(MouseEvent).
     */
    @Deprecated
    public boolean mouseMove(Event evt, int x, int y) {
<span class="nc" id="L6815">        return false;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by processMouseEvent(MouseEvent).
     */
    @Deprecated
    public boolean mouseEnter(Event evt, int x, int y) {
<span class="nc" id="L6824">        return false;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by processMouseEvent(MouseEvent).
     */
    @Deprecated
    public boolean mouseExit(Event evt, int x, int y) {
<span class="nc" id="L6833">        return false;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by processKeyEvent(KeyEvent).
     */
    @Deprecated
    public boolean keyDown(Event evt, int key) {
<span class="nc" id="L6842">        return false;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by processKeyEvent(KeyEvent).
     */
    @Deprecated
    public boolean keyUp(Event evt, int key) {
<span class="nc" id="L6851">        return false;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * should register this component as ActionListener on component
     * which fires action events.
     */
    @Deprecated
    public boolean action(Event evt, Object what) {
<span class="nc" id="L6861">        return false;</span>
    }

    /**
     * Makes this &lt;code&gt;Component&lt;/code&gt; displayable by connecting it to a
     * native screen resource.
     * This method is called internally by the toolkit and should
     * not be called directly by programs.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @see       #isDisplayable
     * @see       #removeNotify
     * @see #invalidate
     * @since JDK1.0
     */
    public void addNotify() {
<span class="nc" id="L6879">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L6880">            ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L6881" title="All 4 branches missed.">            if (peer == null || peer instanceof LightweightPeer){</span>
<span class="nc bnc" id="L6882" title="All 2 branches missed.">                if (peer == null) {</span>
                    // Update both the Component's peer variable and the local
                    // variable we use for thread safety.
<span class="nc" id="L6885">                    this.peer = peer = getToolkit().createComponent(this);</span>
                }

                // This is a lightweight component which means it won't be
                // able to get window-related events by itself.  If any
                // have been enabled, then the nearest native container must
                // be enabled.
<span class="nc bnc" id="L6892" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L6893">                    long mask = 0;</span>
<span class="nc bnc" id="L6894" title="All 4 branches missed.">                    if ((mouseListener != null) || ((eventMask &amp; AWTEvent.MOUSE_EVENT_MASK) != 0)) {</span>
<span class="nc" id="L6895">                        mask |= AWTEvent.MOUSE_EVENT_MASK;</span>
                    }
<span class="nc bnc" id="L6897" title="All 4 branches missed.">                    if ((mouseMotionListener != null) ||</span>
                        ((eventMask &amp; AWTEvent.MOUSE_MOTION_EVENT_MASK) != 0)) {
<span class="nc" id="L6899">                        mask |= AWTEvent.MOUSE_MOTION_EVENT_MASK;</span>
                    }
<span class="nc bnc" id="L6901" title="All 4 branches missed.">                    if ((mouseWheelListener != null ) ||</span>
                        ((eventMask &amp; AWTEvent.MOUSE_WHEEL_EVENT_MASK) != 0)) {
<span class="nc" id="L6903">                        mask |= AWTEvent.MOUSE_WHEEL_EVENT_MASK;</span>
                    }
<span class="nc bnc" id="L6905" title="All 4 branches missed.">                    if (focusListener != null || (eventMask &amp; AWTEvent.FOCUS_EVENT_MASK) != 0) {</span>
<span class="nc" id="L6906">                        mask |= AWTEvent.FOCUS_EVENT_MASK;</span>
                    }
<span class="nc bnc" id="L6908" title="All 4 branches missed.">                    if (keyListener != null || (eventMask &amp; AWTEvent.KEY_EVENT_MASK) != 0) {</span>
<span class="nc" id="L6909">                        mask |= AWTEvent.KEY_EVENT_MASK;</span>
                    }
<span class="nc bnc" id="L6911" title="All 2 branches missed.">                    if (mask != 0) {</span>
<span class="nc" id="L6912">                        parent.proxyEnableEvents(mask);</span>
                    }
<span class="nc" id="L6914">                }</span>
            } else {
                // It's native. If the parent is lightweight it will need some
                // help.
<span class="nc" id="L6918">                Container parent = getContainer();</span>
<span class="nc bnc" id="L6919" title="All 4 branches missed.">                if (parent != null &amp;&amp; parent.isLightweight()) {</span>
<span class="nc" id="L6920">                    relocateComponent();</span>
<span class="nc bnc" id="L6921" title="All 2 branches missed.">                    if (!parent.isRecursivelyVisibleUpToHeavyweightContainer())</span>
                    {
<span class="nc" id="L6923">                        peer.setVisible(false);</span>
                    }
                }
            }
<span class="nc" id="L6927">            invalidate();</span>

<span class="nc bnc" id="L6929" title="All 2 branches missed.">            int npopups = (popups != null? popups.size() : 0);</span>
<span class="nc bnc" id="L6930" title="All 2 branches missed.">            for (int i = 0 ; i &lt; npopups ; i++) {</span>
<span class="nc" id="L6931">                PopupMenu popup = popups.elementAt(i);</span>
<span class="nc" id="L6932">                popup.addNotify();</span>
            }

<span class="nc bnc" id="L6935" title="All 2 branches missed.">            if (dropTarget != null) dropTarget.addNotify(peer);</span>

<span class="nc" id="L6937">            peerFont = getFont();</span>

<span class="nc bnc" id="L6939" title="All 4 branches missed.">            if (getContainer() != null &amp;&amp; !isAddNotifyComplete) {</span>
<span class="nc" id="L6940">                getContainer().increaseComponentCount(this);</span>
            }


            // Update stacking order
<span class="nc" id="L6945">            updateZOrder();</span>

<span class="nc bnc" id="L6947" title="All 2 branches missed.">            if (!isAddNotifyComplete) {</span>
<span class="nc" id="L6948">                mixOnShowing();</span>
            }

<span class="nc" id="L6951">            isAddNotifyComplete = true;</span>

<span class="nc bnc" id="L6953" title="All 4 branches missed.">            if (hierarchyListener != null ||</span>
                (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 ||
<span class="nc bnc" id="L6955" title="All 2 branches missed.">                Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK)) {</span>
<span class="nc" id="L6956">                HierarchyEvent e =</span>
                    new HierarchyEvent(this, HierarchyEvent.HIERARCHY_CHANGED,
                                       this, parent,
                                       HierarchyEvent.DISPLAYABILITY_CHANGED |
<span class="nc bnc" id="L6960" title="All 2 branches missed.">                                       ((isRecursivelyVisible())</span>
                                        ? HierarchyEvent.SHOWING_CHANGED
                                        : 0));
<span class="nc" id="L6963">                dispatchEvent(e);</span>
            }
<span class="nc" id="L6965">        }</span>
<span class="nc" id="L6966">    }</span>

    /**
     * Makes this &lt;code&gt;Component&lt;/code&gt; undisplayable by destroying it native
     * screen resource.
     * &lt;p&gt;
     * This method is called by the toolkit internally and should
     * not be called directly by programs. Code overriding
     * this method should call &lt;code&gt;super.removeNotify&lt;/code&gt; as
     * the first line of the overriding method.
     *
     * @see       #isDisplayable
     * @see       #addNotify
     * @since JDK1.0
     */
    public void removeNotify() {
<span class="nc" id="L6982">        KeyboardFocusManager.clearMostRecentFocusOwner(this);</span>
<span class="nc" id="L6983">        if (KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc bnc" id="L6984" title="All 2 branches missed.">            getPermanentFocusOwner() == this)</span>
        {
<span class="nc" id="L6986">            KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L6987">                setGlobalPermanentFocusOwner(null);</span>
        }

<span class="nc" id="L6990">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L6991">            clearLightweightDispatcherOnRemove(this);</span>

<span class="nc bnc" id="L6993" title="All 4 branches missed.">            if (isFocusOwner() &amp;&amp; KeyboardFocusManager.isAutoFocusTransferEnabledFor(this)) {</span>
<span class="nc" id="L6994">                transferFocus(true);</span>
            }

<span class="nc bnc" id="L6997" title="All 4 branches missed.">            if (getContainer() != null &amp;&amp; isAddNotifyComplete) {</span>
<span class="nc" id="L6998">                getContainer().decreaseComponentCount(this);</span>
            }

<span class="nc bnc" id="L7001" title="All 2 branches missed.">            int npopups = (popups != null? popups.size() : 0);</span>
<span class="nc bnc" id="L7002" title="All 2 branches missed.">            for (int i = 0 ; i &lt; npopups ; i++) {</span>
<span class="nc" id="L7003">                PopupMenu popup = popups.elementAt(i);</span>
<span class="nc" id="L7004">                popup.removeNotify();</span>
            }
            // If there is any input context for this component, notify
            // that this component is being removed. (This has to be done
            // before hiding peer.)
<span class="nc bnc" id="L7009" title="All 2 branches missed.">            if ((eventMask &amp; AWTEvent.INPUT_METHODS_ENABLED_MASK) != 0) {</span>
<span class="nc" id="L7010">                InputContext inputContext = getInputContext();</span>
<span class="nc bnc" id="L7011" title="All 2 branches missed.">                if (inputContext != null) {</span>
<span class="nc" id="L7012">                    inputContext.removeNotify(this);</span>
                }
            }

<span class="nc" id="L7016">            ComponentPeer p = peer;</span>
<span class="nc bnc" id="L7017" title="All 2 branches missed.">            if (p != null) {</span>
<span class="nc" id="L7018">                boolean isLightweight = isLightweight();</span>

<span class="nc bnc" id="L7020" title="All 2 branches missed.">                if (bufferStrategy instanceof FlipBufferStrategy) {</span>
<span class="nc" id="L7021">                    ((FlipBufferStrategy)bufferStrategy).destroyBuffers();</span>
                }

<span class="nc bnc" id="L7024" title="All 2 branches missed.">                if (dropTarget != null) dropTarget.removeNotify(peer);</span>

                // Hide peer first to stop system events such as cursor moves.
<span class="nc bnc" id="L7027" title="All 2 branches missed.">                if (visible) {</span>
<span class="nc" id="L7028">                    p.setVisible(false);</span>
                }

<span class="nc" id="L7031">                peer = null; // Stop peer updates.</span>
<span class="nc" id="L7032">                peerFont = null;</span>

<span class="nc" id="L7034">                Toolkit.getEventQueue().removeSourceEvents(this, false);</span>
<span class="nc" id="L7035">                KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L7036">                    discardKeyEvents(this);</span>

<span class="nc" id="L7038">                p.dispose();</span>

<span class="nc" id="L7040">                mixOnHiding(isLightweight);</span>

<span class="nc" id="L7042">                isAddNotifyComplete = false;</span>
                // Nullifying compoundShape means that the component has normal shape
                // (or has no shape at all).
<span class="nc" id="L7045">                this.compoundShape = null;</span>
            }

<span class="nc bnc" id="L7048" title="All 4 branches missed.">            if (hierarchyListener != null ||</span>
                (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 ||
<span class="nc bnc" id="L7050" title="All 2 branches missed.">                Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK)) {</span>
<span class="nc" id="L7051">                HierarchyEvent e =</span>
                    new HierarchyEvent(this, HierarchyEvent.HIERARCHY_CHANGED,
                                       this, parent,
                                       HierarchyEvent.DISPLAYABILITY_CHANGED |
<span class="nc bnc" id="L7055" title="All 2 branches missed.">                                       ((isRecursivelyVisible())</span>
                                        ? HierarchyEvent.SHOWING_CHANGED
                                        : 0));
<span class="nc" id="L7058">                dispatchEvent(e);</span>
            }
<span class="nc" id="L7060">        }</span>
<span class="nc" id="L7061">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by processFocusEvent(FocusEvent).
     */
    @Deprecated
    public boolean gotFocus(Event evt, Object what) {
<span class="nc" id="L7069">        return false;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by processFocusEvent(FocusEvent).
     */
    @Deprecated
    public boolean lostFocus(Event evt, Object what) {
<span class="nc" id="L7078">        return false;</span>
    }

    /**
     * Returns whether this &lt;code&gt;Component&lt;/code&gt; can become the focus
     * owner.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Component&lt;/code&gt; is
     * focusable; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #setFocusable
     * @since JDK1.1
     * @deprecated As of 1.4, replaced by &lt;code&gt;isFocusable()&lt;/code&gt;.
     */
    @Deprecated
    public boolean isFocusTraversable() {
<span class="nc bnc" id="L7093" title="All 2 branches missed.">        if (isFocusTraversableOverridden == FOCUS_TRAVERSABLE_UNKNOWN) {</span>
<span class="nc" id="L7094">            isFocusTraversableOverridden = FOCUS_TRAVERSABLE_DEFAULT;</span>
        }
<span class="nc" id="L7096">        return focusable;</span>
    }

    /**
     * Returns whether this Component can be focused.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this Component is focusable;
     *         &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see #setFocusable
     * @since 1.4
     */
    public boolean isFocusable() {
<span class="nc" id="L7108">        return isFocusTraversable();</span>
    }

    /**
     * Sets the focusable state of this Component to the specified value. This
     * value overrides the Component's default focusability.
     *
     * @param focusable indicates whether this Component is focusable
     * @see #isFocusable
     * @since 1.4
     * @beaninfo
     *       bound: true
     */
    public void setFocusable(boolean focusable) {
        boolean oldFocusable;
<span class="nc" id="L7123">        synchronized (this) {</span>
<span class="nc" id="L7124">            oldFocusable = this.focusable;</span>
<span class="nc" id="L7125">            this.focusable = focusable;</span>
<span class="nc" id="L7126">        }</span>
<span class="nc" id="L7127">        isFocusTraversableOverridden = FOCUS_TRAVERSABLE_SET;</span>

<span class="nc" id="L7129">        firePropertyChange(&quot;focusable&quot;, oldFocusable, focusable);</span>
<span class="nc bnc" id="L7130" title="All 4 branches missed.">        if (oldFocusable &amp;&amp; !focusable) {</span>
<span class="nc bnc" id="L7131" title="All 4 branches missed.">            if (isFocusOwner() &amp;&amp; KeyboardFocusManager.isAutoFocusTransferEnabled()) {</span>
<span class="nc" id="L7132">                transferFocus(true);</span>
            }
<span class="nc" id="L7134">            KeyboardFocusManager.clearMostRecentFocusOwner(this);</span>
        }
<span class="nc" id="L7136">    }</span>

    final boolean isFocusTraversableOverridden() {
<span class="nc bnc" id="L7139" title="All 2 branches missed.">        return (isFocusTraversableOverridden != FOCUS_TRAVERSABLE_DEFAULT);</span>
    }

    /**
     * Sets the focus traversal keys for a given traversal operation for this
     * Component.
     * &lt;p&gt;
     * The default values for a Component's focus traversal keys are
     * implementation-dependent. Sun recommends that all implementations for a
     * particular native platform use the same default values. The
     * recommendations for Windows and Unix are listed below. These
     * recommendations are used in the Sun AWT implementations.
     *
     * &lt;table border=1 summary=&quot;Recommended default values for a Component's focus traversal keys&quot;&gt;
     * &lt;tr&gt;
     *    &lt;th&gt;Identifier&lt;/th&gt;
     *    &lt;th&gt;Meaning&lt;/th&gt;
     *    &lt;th&gt;Default&lt;/th&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *    &lt;td&gt;KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS&lt;/td&gt;
     *    &lt;td&gt;Normal forward keyboard traversal&lt;/td&gt;
     *    &lt;td&gt;TAB on KEY_PRESSED, CTRL-TAB on KEY_PRESSED&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *    &lt;td&gt;KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS&lt;/td&gt;
     *    &lt;td&gt;Normal reverse keyboard traversal&lt;/td&gt;
     *    &lt;td&gt;SHIFT-TAB on KEY_PRESSED, CTRL-SHIFT-TAB on KEY_PRESSED&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *    &lt;td&gt;KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS&lt;/td&gt;
     *    &lt;td&gt;Go up one focus traversal cycle&lt;/td&gt;
     *    &lt;td&gt;none&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;/table&gt;
     *
     * To disable a traversal key, use an empty Set; Collections.EMPTY_SET is
     * recommended.
     * &lt;p&gt;
     * Using the AWTKeyStroke API, client code can specify on which of two
     * specific KeyEvents, KEY_PRESSED or KEY_RELEASED, the focus traversal
     * operation will occur. Regardless of which KeyEvent is specified,
     * however, all KeyEvents related to the focus traversal key, including the
     * associated KEY_TYPED event, will be consumed, and will not be dispatched
     * to any Component. It is a runtime error to specify a KEY_TYPED event as
     * mapping to a focus traversal operation, or to map the same event to
     * multiple default focus traversal operations.
     * &lt;p&gt;
     * If a value of null is specified for the Set, this Component inherits the
     * Set from its parent. If all ancestors of this Component have null
     * specified for the Set, then the current KeyboardFocusManager's default
     * Set is used.
     * &lt;p&gt;
     * This method may throw a {@code ClassCastException} if any {@code Object}
     * in {@code keystrokes} is not an {@code AWTKeyStroke}.
     *
     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
     * @param keystrokes the Set of AWTKeyStroke for the specified operation
     * @see #getFocusTraversalKeys
     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
     * @throws IllegalArgumentException if id is not one of
     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or if keystrokes
     *         contains null, or if any keystroke represents a KEY_TYPED event,
     *         or if any keystroke already maps to another focus traversal
     *         operation for this Component
     * @since 1.4
     * @beaninfo
     *       bound: true
     */
    public void setFocusTraversalKeys(int id,
                                      Set&lt;? extends AWTKeyStroke&gt; keystrokes)
    {
<span class="nc bnc" id="L7217" title="All 4 branches missed.">        if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH - 1) {</span>
<span class="nc" id="L7218">            throw new IllegalArgumentException(&quot;invalid focus traversal key identifier&quot;);</span>
        }

<span class="nc" id="L7221">        setFocusTraversalKeys_NoIDCheck(id, keystrokes);</span>
<span class="nc" id="L7222">    }</span>

    /**
     * Returns the Set of focus traversal keys for a given traversal operation
     * for this Component. (See
     * &lt;code&gt;setFocusTraversalKeys&lt;/code&gt; for a full description of each key.)
     * &lt;p&gt;
     * If a Set of traversal keys has not been explicitly defined for this
     * Component, then this Component's parent's Set is returned. If no Set
     * has been explicitly defined for any of this Component's ancestors, then
     * the current KeyboardFocusManager's default Set is returned.
     *
     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
     * @return the Set of AWTKeyStrokes for the specified operation. The Set
     *         will be unmodifiable, and may be empty. null will never be
     *         returned.
     * @see #setFocusTraversalKeys
     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
     * @throws IllegalArgumentException if id is not one of
     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
     * @since 1.4
     */
    public Set&lt;AWTKeyStroke&gt; getFocusTraversalKeys(int id) {
<span class="nc bnc" id="L7251" title="All 4 branches missed.">        if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH - 1) {</span>
<span class="nc" id="L7252">            throw new IllegalArgumentException(&quot;invalid focus traversal key identifier&quot;);</span>
        }

<span class="nc" id="L7255">        return getFocusTraversalKeys_NoIDCheck(id);</span>
    }

    // We define these methods so that Container does not need to repeat this
    // code. Container cannot call super.&lt;method&gt; because Container allows
    // DOWN_CYCLE_TRAVERSAL_KEY while Component does not. The Component method
    // would erroneously generate an IllegalArgumentException for
    // DOWN_CYCLE_TRAVERSAL_KEY.
    final void setFocusTraversalKeys_NoIDCheck(int id, Set&lt;? extends AWTKeyStroke&gt; keystrokes) {
        Set&lt;AWTKeyStroke&gt; oldKeys;

<span class="nc" id="L7266">        synchronized (this) {</span>
<span class="nc bnc" id="L7267" title="All 2 branches missed.">            if (focusTraversalKeys == null) {</span>
<span class="nc" id="L7268">                initializeFocusTraversalKeys();</span>
            }

<span class="nc bnc" id="L7271" title="All 2 branches missed.">            if (keystrokes != null) {</span>
<span class="nc bnc" id="L7272" title="All 2 branches missed.">                for (AWTKeyStroke keystroke : keystrokes ) {</span>

<span class="nc bnc" id="L7274" title="All 2 branches missed.">                    if (keystroke == null) {</span>
<span class="nc" id="L7275">                        throw new IllegalArgumentException(&quot;cannot set null focus traversal key&quot;);</span>
                    }

<span class="nc bnc" id="L7278" title="All 2 branches missed.">                    if (keystroke.getKeyChar() != KeyEvent.CHAR_UNDEFINED) {</span>
<span class="nc" id="L7279">                        throw new IllegalArgumentException(&quot;focus traversal keys cannot map to KEY_TYPED events&quot;);</span>
                    }

<span class="nc bnc" id="L7282" title="All 2 branches missed.">                    for (int i = 0; i &lt; focusTraversalKeys.length; i++) {</span>
<span class="nc bnc" id="L7283" title="All 2 branches missed.">                        if (i == id) {</span>
<span class="nc" id="L7284">                            continue;</span>
                        }

<span class="nc bnc" id="L7287" title="All 2 branches missed.">                        if (getFocusTraversalKeys_NoIDCheck(i).contains(keystroke))</span>
                        {
<span class="nc" id="L7289">                            throw new IllegalArgumentException(&quot;focus traversal keys must be unique for a Component&quot;);</span>
                        }
                    }
<span class="nc" id="L7292">                }</span>
            }

<span class="nc" id="L7295">            oldKeys = focusTraversalKeys[id];</span>
<span class="nc bnc" id="L7296" title="All 2 branches missed.">            focusTraversalKeys[id] = (keystrokes != null)</span>
<span class="nc" id="L7297">                ? Collections.unmodifiableSet(new HashSet&lt;AWTKeyStroke&gt;(keystrokes))</span>
                : null;
<span class="nc" id="L7299">        }</span>

<span class="nc" id="L7301">        firePropertyChange(focusTraversalKeyPropertyNames[id], oldKeys,</span>
                           keystrokes);
<span class="nc" id="L7303">    }</span>
    final Set&lt;AWTKeyStroke&gt; getFocusTraversalKeys_NoIDCheck(int id) {
        // Okay to return Set directly because it is an unmodifiable view
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc bnc" id="L7307" title="All 2 branches missed.">        Set&lt;AWTKeyStroke&gt; keystrokes = (focusTraversalKeys != null)</span>
            ? focusTraversalKeys[id]
            : null;

<span class="nc bnc" id="L7311" title="All 2 branches missed.">        if (keystrokes != null) {</span>
<span class="nc" id="L7312">            return keystrokes;</span>
        } else {
<span class="nc" id="L7314">            Container parent = this.parent;</span>
<span class="nc bnc" id="L7315" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L7316">                return parent.getFocusTraversalKeys(id);</span>
            } else {
<span class="nc" id="L7318">                return KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L7319">                    getDefaultFocusTraversalKeys(id);</span>
            }
        }
    }

    /**
     * Returns whether the Set of focus traversal keys for the given focus
     * traversal operation has been explicitly defined for this Component. If
     * this method returns &lt;code&gt;false&lt;/code&gt;, this Component is inheriting the
     * Set from an ancestor, or from the current KeyboardFocusManager.
     *
     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
     * @return &lt;code&gt;true&lt;/code&gt; if the the Set of focus traversal keys for the
     *         given focus traversal operation has been explicitly defined for
     *         this Component; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @throws IllegalArgumentException if id is not one of
     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
     * @since 1.4
     */
    public boolean areFocusTraversalKeysSet(int id) {
<span class="nc bnc" id="L7343" title="All 4 branches missed.">        if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH - 1) {</span>
<span class="nc" id="L7344">            throw new IllegalArgumentException(&quot;invalid focus traversal key identifier&quot;);</span>
        }

<span class="nc bnc" id="L7347" title="All 4 branches missed.">        return (focusTraversalKeys != null &amp;&amp; focusTraversalKeys[id] != null);</span>
    }

    /**
     * Sets whether focus traversal keys are enabled for this Component.
     * Components for which focus traversal keys are disabled receive key
     * events for focus traversal keys. Components for which focus traversal
     * keys are enabled do not see these events; instead, the events are
     * automatically converted to traversal operations.
     *
     * @param focusTraversalKeysEnabled whether focus traversal keys are
     *        enabled for this Component
     * @see #getFocusTraversalKeysEnabled
     * @see #setFocusTraversalKeys
     * @see #getFocusTraversalKeys
     * @since 1.4
     * @beaninfo
     *       bound: true
     */
    public void setFocusTraversalKeysEnabled(boolean
                                             focusTraversalKeysEnabled) {
        boolean oldFocusTraversalKeysEnabled;
<span class="nc" id="L7369">        synchronized (this) {</span>
<span class="nc" id="L7370">            oldFocusTraversalKeysEnabled = this.focusTraversalKeysEnabled;</span>
<span class="nc" id="L7371">            this.focusTraversalKeysEnabled = focusTraversalKeysEnabled;</span>
<span class="nc" id="L7372">        }</span>
<span class="nc" id="L7373">        firePropertyChange(&quot;focusTraversalKeysEnabled&quot;,</span>
                           oldFocusTraversalKeysEnabled,
                           focusTraversalKeysEnabled);
<span class="nc" id="L7376">    }</span>

    /**
     * Returns whether focus traversal keys are enabled for this Component.
     * Components for which focus traversal keys are disabled receive key
     * events for focus traversal keys. Components for which focus traversal
     * keys are enabled do not see these events; instead, the events are
     * automatically converted to traversal operations.
     *
     * @return whether focus traversal keys are enabled for this Component
     * @see #setFocusTraversalKeysEnabled
     * @see #setFocusTraversalKeys
     * @see #getFocusTraversalKeys
     * @since 1.4
     */
    public boolean getFocusTraversalKeysEnabled() {
<span class="nc" id="L7392">        return focusTraversalKeysEnabled;</span>
    }

    /**
     * Requests that this Component get the input focus, and that this
     * Component's top-level ancestor become the focused Window. This
     * component must be displayable, focusable, visible and all of
     * its ancestors (with the exception of the top-level Window) must
     * be visible for the request to be granted. Every effort will be
     * made to honor the request; however, in some cases it may be
     * impossible to do so. Developers must never assume that this
     * Component is the focus owner until this Component receives a
     * FOCUS_GAINED event. If this request is denied because this
     * Component's top-level Window cannot become the focused Window,
     * the request will be remembered and will be granted when the
     * Window is later focused by the user.
     * &lt;p&gt;
     * This method cannot be used to set the focus owner to no Component at
     * all. Use &lt;code&gt;KeyboardFocusManager.clearGlobalFocusOwner()&lt;/code&gt;
     * instead.
     * &lt;p&gt;
     * Because the focus behavior of this method is platform-dependent,
     * developers are strongly encouraged to use
     * &lt;code&gt;requestFocusInWindow&lt;/code&gt; when possible.
     *
     * &lt;p&gt;Note: Not all focus transfers result from invoking this method. As
     * such, a component may receive focus without this or any of the other
     * {@code requestFocus} methods of {@code Component} being invoked.
     *
     * @see #requestFocusInWindow
     * @see java.awt.event.FocusEvent
     * @see #addFocusListener
     * @see #isFocusable
     * @see #isDisplayable
     * @see KeyboardFocusManager#clearGlobalFocusOwner
     * @since JDK1.0
     */
    public void requestFocus() {
<span class="nc" id="L7430">        requestFocusHelper(false, true);</span>
<span class="nc" id="L7431">    }</span>

    boolean requestFocus(CausedFocusEvent.Cause cause) {
<span class="nc" id="L7434">        return requestFocusHelper(false, true, cause);</span>
    }

    /**
     * Requests that this &lt;code&gt;Component&lt;/code&gt; get the input focus,
     * and that this &lt;code&gt;Component&lt;/code&gt;'s top-level ancestor
     * become the focused &lt;code&gt;Window&lt;/code&gt;. This component must be
     * displayable, focusable, visible and all of its ancestors (with
     * the exception of the top-level Window) must be visible for the
     * request to be granted. Every effort will be made to honor the
     * request; however, in some cases it may be impossible to do
     * so. Developers must never assume that this component is the
     * focus owner until this component receives a FOCUS_GAINED
     * event. If this request is denied because this component's
     * top-level window cannot become the focused window, the request
     * will be remembered and will be granted when the window is later
     * focused by the user.
     * &lt;p&gt;
     * This method returns a boolean value. If &lt;code&gt;false&lt;/code&gt; is returned,
     * the request is &lt;b&gt;guaranteed to fail&lt;/b&gt;. If &lt;code&gt;true&lt;/code&gt; is
     * returned, the request will succeed &lt;b&gt;unless&lt;/b&gt; it is vetoed, or an
     * extraordinary event, such as disposal of the component's peer, occurs
     * before the request can be granted by the native windowing system. Again,
     * while a return value of &lt;code&gt;true&lt;/code&gt; indicates that the request is
     * likely to succeed, developers must never assume that this component is
     * the focus owner until this component receives a FOCUS_GAINED event.
     * &lt;p&gt;
     * This method cannot be used to set the focus owner to no component at
     * all. Use &lt;code&gt;KeyboardFocusManager.clearGlobalFocusOwner&lt;/code&gt;
     * instead.
     * &lt;p&gt;
     * Because the focus behavior of this method is platform-dependent,
     * developers are strongly encouraged to use
     * &lt;code&gt;requestFocusInWindow&lt;/code&gt; when possible.
     * &lt;p&gt;
     * Every effort will be made to ensure that &lt;code&gt;FocusEvent&lt;/code&gt;s
     * generated as a
     * result of this request will have the specified temporary value. However,
     * because specifying an arbitrary temporary state may not be implementable
     * on all native windowing systems, correct behavior for this method can be
     * guaranteed only for lightweight &lt;code&gt;Component&lt;/code&gt;s.
     * This method is not intended
     * for general use, but exists instead as a hook for lightweight component
     * libraries, such as Swing.
     *
     * &lt;p&gt;Note: Not all focus transfers result from invoking this method. As
     * such, a component may receive focus without this or any of the other
     * {@code requestFocus} methods of {@code Component} being invoked.
     *
     * @param temporary true if the focus change is temporary,
     *        such as when the window loses the focus; for
     *        more information on temporary focus changes see the
     *&lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
     * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
     *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
     * @see java.awt.event.FocusEvent
     * @see #addFocusListener
     * @see #isFocusable
     * @see #isDisplayable
     * @see KeyboardFocusManager#clearGlobalFocusOwner
     * @since 1.4
     */
    protected boolean requestFocus(boolean temporary) {
<span class="nc" id="L7497">        return requestFocusHelper(temporary, true);</span>
    }

    boolean requestFocus(boolean temporary, CausedFocusEvent.Cause cause) {
<span class="nc" id="L7501">        return requestFocusHelper(temporary, true, cause);</span>
    }
    /**
     * Requests that this Component get the input focus, if this
     * Component's top-level ancestor is already the focused
     * Window. This component must be displayable, focusable, visible
     * and all of its ancestors (with the exception of the top-level
     * Window) must be visible for the request to be granted. Every
     * effort will be made to honor the request; however, in some
     * cases it may be impossible to do so. Developers must never
     * assume that this Component is the focus owner until this
     * Component receives a FOCUS_GAINED event.
     * &lt;p&gt;
     * This method returns a boolean value. If &lt;code&gt;false&lt;/code&gt; is returned,
     * the request is &lt;b&gt;guaranteed to fail&lt;/b&gt;. If &lt;code&gt;true&lt;/code&gt; is
     * returned, the request will succeed &lt;b&gt;unless&lt;/b&gt; it is vetoed, or an
     * extraordinary event, such as disposal of the Component's peer, occurs
     * before the request can be granted by the native windowing system. Again,
     * while a return value of &lt;code&gt;true&lt;/code&gt; indicates that the request is
     * likely to succeed, developers must never assume that this Component is
     * the focus owner until this Component receives a FOCUS_GAINED event.
     * &lt;p&gt;
     * This method cannot be used to set the focus owner to no Component at
     * all. Use &lt;code&gt;KeyboardFocusManager.clearGlobalFocusOwner()&lt;/code&gt;
     * instead.
     * &lt;p&gt;
     * The focus behavior of this method can be implemented uniformly across
     * platforms, and thus developers are strongly encouraged to use this
     * method over &lt;code&gt;requestFocus&lt;/code&gt; when possible. Code which relies
     * on &lt;code&gt;requestFocus&lt;/code&gt; may exhibit different focus behavior on
     * different platforms.
     *
     * &lt;p&gt;Note: Not all focus transfers result from invoking this method. As
     * such, a component may receive focus without this or any of the other
     * {@code requestFocus} methods of {@code Component} being invoked.
     *
     * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
     *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
     * @see #requestFocus
     * @see java.awt.event.FocusEvent
     * @see #addFocusListener
     * @see #isFocusable
     * @see #isDisplayable
     * @see KeyboardFocusManager#clearGlobalFocusOwner
     * @since 1.4
     */
    public boolean requestFocusInWindow() {
<span class="nc" id="L7548">        return requestFocusHelper(false, false);</span>
    }

    boolean requestFocusInWindow(CausedFocusEvent.Cause cause) {
<span class="nc" id="L7552">        return requestFocusHelper(false, false, cause);</span>
    }

    /**
     * Requests that this &lt;code&gt;Component&lt;/code&gt; get the input focus,
     * if this &lt;code&gt;Component&lt;/code&gt;'s top-level ancestor is already
     * the focused &lt;code&gt;Window&lt;/code&gt;.  This component must be
     * displayable, focusable, visible and all of its ancestors (with
     * the exception of the top-level Window) must be visible for the
     * request to be granted. Every effort will be made to honor the
     * request; however, in some cases it may be impossible to do
     * so. Developers must never assume that this component is the
     * focus owner until this component receives a FOCUS_GAINED event.
     * &lt;p&gt;
     * This method returns a boolean value. If &lt;code&gt;false&lt;/code&gt; is returned,
     * the request is &lt;b&gt;guaranteed to fail&lt;/b&gt;. If &lt;code&gt;true&lt;/code&gt; is
     * returned, the request will succeed &lt;b&gt;unless&lt;/b&gt; it is vetoed, or an
     * extraordinary event, such as disposal of the component's peer, occurs
     * before the request can be granted by the native windowing system. Again,
     * while a return value of &lt;code&gt;true&lt;/code&gt; indicates that the request is
     * likely to succeed, developers must never assume that this component is
     * the focus owner until this component receives a FOCUS_GAINED event.
     * &lt;p&gt;
     * This method cannot be used to set the focus owner to no component at
     * all. Use &lt;code&gt;KeyboardFocusManager.clearGlobalFocusOwner&lt;/code&gt;
     * instead.
     * &lt;p&gt;
     * The focus behavior of this method can be implemented uniformly across
     * platforms, and thus developers are strongly encouraged to use this
     * method over &lt;code&gt;requestFocus&lt;/code&gt; when possible. Code which relies
     * on &lt;code&gt;requestFocus&lt;/code&gt; may exhibit different focus behavior on
     * different platforms.
     * &lt;p&gt;
     * Every effort will be made to ensure that &lt;code&gt;FocusEvent&lt;/code&gt;s
     * generated as a
     * result of this request will have the specified temporary value. However,
     * because specifying an arbitrary temporary state may not be implementable
     * on all native windowing systems, correct behavior for this method can be
     * guaranteed only for lightweight components. This method is not intended
     * for general use, but exists instead as a hook for lightweight component
     * libraries, such as Swing.
     *
     * &lt;p&gt;Note: Not all focus transfers result from invoking this method. As
     * such, a component may receive focus without this or any of the other
     * {@code requestFocus} methods of {@code Component} being invoked.
     *
     * @param temporary true if the focus change is temporary,
     *        such as when the window loses the focus; for
     *        more information on temporary focus changes see the
     *&lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
     * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
     *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
     * @see #requestFocus
     * @see java.awt.event.FocusEvent
     * @see #addFocusListener
     * @see #isFocusable
     * @see #isDisplayable
     * @see KeyboardFocusManager#clearGlobalFocusOwner
     * @since 1.4
     */
    protected boolean requestFocusInWindow(boolean temporary) {
<span class="nc" id="L7613">        return requestFocusHelper(temporary, false);</span>
    }

    boolean requestFocusInWindow(boolean temporary, CausedFocusEvent.Cause cause) {
<span class="nc" id="L7617">        return requestFocusHelper(temporary, false, cause);</span>
    }

    final boolean requestFocusHelper(boolean temporary,
                                     boolean focusedWindowChangeAllowed) {
<span class="nc" id="L7622">        return requestFocusHelper(temporary, focusedWindowChangeAllowed, CausedFocusEvent.Cause.UNKNOWN);</span>
    }

    final boolean requestFocusHelper(boolean temporary,
                                     boolean focusedWindowChangeAllowed,
                                     CausedFocusEvent.Cause cause)
    {
        // 1) Check if the event being dispatched is a system-generated mouse event.
<span class="nc" id="L7630">        AWTEvent currentEvent = EventQueue.getCurrentEvent();</span>
<span class="nc bnc" id="L7631" title="All 2 branches missed.">        if (currentEvent instanceof MouseEvent &amp;&amp;</span>
<span class="nc bnc" id="L7632" title="All 2 branches missed.">            SunToolkit.isSystemGenerated(currentEvent))</span>
        {
            // 2) Sanity check: if the mouse event component source belongs to the same containing window.
<span class="nc" id="L7635">            Component source = ((MouseEvent)currentEvent).getComponent();</span>
<span class="nc bnc" id="L7636" title="All 4 branches missed.">            if (source == null || source.getContainingWindow() == getContainingWindow()) {</span>
<span class="nc" id="L7637">                focusLog.finest(&quot;requesting focus by mouse event \&quot;in window\&quot;&quot;);</span>

                // If both the conditions are fulfilled the focus request should be strictly
                // bounded by the toplevel window. It's assumed that the mouse event activates
                // the window (if it wasn't active) and this makes it possible for a focus
                // request with a strong in-window requirement to change focus in the bounds
                // of the toplevel. If, by any means, due to asynchronous nature of the event
                // dispatching mechanism, the window happens to be natively inactive by the time
                // this focus request is eventually handled, it should not re-activate the
                // toplevel. Otherwise the result may not meet user expectations. See 6981400.
<span class="nc" id="L7647">                focusedWindowChangeAllowed = false;</span>
            }
        }
<span class="nc bnc" id="L7650" title="All 2 branches missed.">        if (!isRequestFocusAccepted(temporary, focusedWindowChangeAllowed, cause)) {</span>
<span class="nc bnc" id="L7651" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7652">                focusLog.finest(&quot;requestFocus is not accepted&quot;);</span>
            }
<span class="nc" id="L7654">            return false;</span>
        }
        // Update most-recent map
<span class="nc" id="L7657">        KeyboardFocusManager.setMostRecentFocusOwner(this);</span>

<span class="nc" id="L7659">        Component window = this;</span>
<span class="nc bnc" id="L7660" title="All 4 branches missed.">        while ( (window != null) &amp;&amp; !(window instanceof Window)) {</span>
<span class="nc bnc" id="L7661" title="All 2 branches missed.">            if (!window.isVisible()) {</span>
<span class="nc bnc" id="L7662" title="All 2 branches missed.">                if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7663">                    focusLog.finest(&quot;component is recurively invisible&quot;);</span>
                }
<span class="nc" id="L7665">                return false;</span>
            }
<span class="nc" id="L7667">            window = window.parent;</span>
        }

<span class="nc" id="L7670">        ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L7671" title="All 2 branches missed.">        Component heavyweight = (peer instanceof LightweightPeer)</span>
<span class="nc" id="L7672">            ? getNativeContainer() : this;</span>
<span class="nc bnc" id="L7673" title="All 4 branches missed.">        if (heavyweight == null || !heavyweight.isVisible()) {</span>
<span class="nc bnc" id="L7674" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7675">                focusLog.finest(&quot;Component is not a part of visible hierarchy&quot;);</span>
            }
<span class="nc" id="L7677">            return false;</span>
        }
<span class="nc" id="L7679">        peer = heavyweight.peer;</span>
<span class="nc bnc" id="L7680" title="All 2 branches missed.">        if (peer == null) {</span>
<span class="nc bnc" id="L7681" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7682">                focusLog.finest(&quot;Peer is null&quot;);</span>
            }
<span class="nc" id="L7684">            return false;</span>
        }

        // Focus this Component
<span class="nc" id="L7688">        long time = 0;</span>
<span class="nc bnc" id="L7689" title="All 2 branches missed.">        if (EventQueue.isDispatchThread()) {</span>
<span class="nc" id="L7690">            time = Toolkit.getEventQueue().getMostRecentKeyEventTime();</span>
        } else {
            // A focus request made from outside EDT should not be associated with any event
            // and so its time stamp is simply set to the current time.
<span class="nc" id="L7694">            time = System.currentTimeMillis();</span>
        }

<span class="nc" id="L7697">        boolean success = peer.requestFocus</span>
<span class="nc" id="L7698">            (this, temporary, focusedWindowChangeAllowed, time, cause);</span>
<span class="nc bnc" id="L7699" title="All 2 branches missed.">        if (!success) {</span>
<span class="nc" id="L7700">            KeyboardFocusManager.getCurrentKeyboardFocusManager</span>
<span class="nc" id="L7701">                (appContext).dequeueKeyEvents(time, this);</span>
<span class="nc bnc" id="L7702" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7703">                focusLog.finest(&quot;Peer request failed&quot;);</span>
            }
        } else {
<span class="nc bnc" id="L7706" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7707">                focusLog.finest(&quot;Pass for &quot; + this);</span>
            }
        }
<span class="nc" id="L7710">        return success;</span>
    }

    private boolean isRequestFocusAccepted(boolean temporary,
                                           boolean focusedWindowChangeAllowed,
                                           CausedFocusEvent.Cause cause)
    {
<span class="nc bnc" id="L7717" title="All 4 branches missed.">        if (!isFocusable() || !isVisible()) {</span>
<span class="nc bnc" id="L7718" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7719">                focusLog.finest(&quot;Not focusable or not visible&quot;);</span>
            }
<span class="nc" id="L7721">            return false;</span>
        }

<span class="nc" id="L7724">        ComponentPeer peer = this.peer;</span>
<span class="nc bnc" id="L7725" title="All 2 branches missed.">        if (peer == null) {</span>
<span class="nc bnc" id="L7726" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7727">                focusLog.finest(&quot;peer is null&quot;);</span>
            }
<span class="nc" id="L7729">            return false;</span>
        }

<span class="nc" id="L7732">        Window window = getContainingWindow();</span>
<span class="nc bnc" id="L7733" title="All 4 branches missed.">        if (window == null || !window.isFocusableWindow()) {</span>
<span class="nc bnc" id="L7734" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7735">                focusLog.finest(&quot;Component doesn't have toplevel&quot;);</span>
            }
<span class="nc" id="L7737">            return false;</span>
        }

        // We have passed all regular checks for focus request,
        // now let's call RequestFocusController and see what it says.
<span class="nc" id="L7742">        Component focusOwner = KeyboardFocusManager.getMostRecentFocusOwner(window);</span>
<span class="nc bnc" id="L7743" title="All 2 branches missed.">        if (focusOwner == null) {</span>
            // sometimes most recent focus owner may be null, but focus owner is not
            // e.g. we reset most recent focus owner if user removes focus owner
<span class="nc" id="L7746">            focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();</span>
<span class="nc bnc" id="L7747" title="All 4 branches missed.">            if (focusOwner != null &amp;&amp; focusOwner.getContainingWindow() != window) {</span>
<span class="nc" id="L7748">                focusOwner = null;</span>
            }
        }

<span class="nc bnc" id="L7752" title="All 4 branches missed.">        if (focusOwner == this || focusOwner == null) {</span>
            // Controller is supposed to verify focus transfers and for this it
            // should know both from and to components.  And it shouldn't verify
            // transfers from when these components are equal.
<span class="nc bnc" id="L7756" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7757">                focusLog.finest(&quot;focus owner is null or this&quot;);</span>
            }
<span class="nc" id="L7759">            return true;</span>
        }

<span class="nc bnc" id="L7762" title="All 2 branches missed.">        if (CausedFocusEvent.Cause.ACTIVATION == cause) {</span>
            // we shouldn't call RequestFocusController in case we are
            // in activation.  We do request focus on component which
            // has got temporary focus lost and then on component which is
            // most recent focus owner.  But most recent focus owner can be
            // changed by requestFocsuXXX() call only, so this transfer has
            // been already approved.
<span class="nc bnc" id="L7769" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7770">                focusLog.finest(&quot;cause is activation&quot;);</span>
            }
<span class="nc" id="L7772">            return true;</span>
        }

<span class="nc" id="L7775">        boolean ret = Component.requestFocusController.acceptRequestFocus(focusOwner,</span>
                                                                          this,
                                                                          temporary,
                                                                          focusedWindowChangeAllowed,
                                                                          cause);
<span class="nc bnc" id="L7780" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L7781">            focusLog.finest(&quot;RequestFocusController returns {0}&quot;, ret);</span>
        }

<span class="nc" id="L7784">        return ret;</span>
    }

<span class="fc" id="L7787">    private static RequestFocusController requestFocusController = new DummyRequestFocusController();</span>

    // Swing access this method through reflection to implement InputVerifier's functionality.
    // Perhaps, we should make this method public (later ;)
<span class="fc" id="L7791">    private static class DummyRequestFocusController implements RequestFocusController {</span>
        public boolean acceptRequestFocus(Component from, Component to,
                                          boolean temporary, boolean focusedWindowChangeAllowed,
                                          CausedFocusEvent.Cause cause)
        {
<span class="nc" id="L7796">            return true;</span>
        }
    };

    synchronized static void setRequestFocusController(RequestFocusController requestController)
    {
<span class="pc bpc" id="L7802" title="1 of 2 branches missed.">        if (requestController == null) {</span>
<span class="nc" id="L7803">            requestFocusController = new DummyRequestFocusController();</span>
        } else {
<span class="fc" id="L7805">            requestFocusController = requestController;</span>
        }
<span class="fc" id="L7807">    }</span>

    /**
     * Returns the Container which is the focus cycle root of this Component's
     * focus traversal cycle. Each focus traversal cycle has only a single
     * focus cycle root and each Component which is not a Container belongs to
     * only a single focus traversal cycle. Containers which are focus cycle
     * roots belong to two cycles: one rooted at the Container itself, and one
     * rooted at the Container's nearest focus-cycle-root ancestor. For such
     * Containers, this method will return the Container's nearest focus-cycle-
     * root ancestor.
     *
     * @return this Component's nearest focus-cycle-root ancestor
     * @see Container#isFocusCycleRoot()
     * @since 1.4
     */
    public Container getFocusCycleRootAncestor() {
<span class="nc" id="L7824">        Container rootAncestor = this.parent;</span>
<span class="nc bnc" id="L7825" title="All 4 branches missed.">        while (rootAncestor != null &amp;&amp; !rootAncestor.isFocusCycleRoot()) {</span>
<span class="nc" id="L7826">            rootAncestor = rootAncestor.parent;</span>
        }
<span class="nc" id="L7828">        return rootAncestor;</span>
    }

    /**
     * Returns whether the specified Container is the focus cycle root of this
     * Component's focus traversal cycle. Each focus traversal cycle has only
     * a single focus cycle root and each Component which is not a Container
     * belongs to only a single focus traversal cycle.
     *
     * @param container the Container to be tested
     * @return &lt;code&gt;true&lt;/code&gt; if the specified Container is a focus-cycle-
     *         root of this Component; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see Container#isFocusCycleRoot()
     * @since 1.4
     */
    public boolean isFocusCycleRoot(Container container) {
<span class="nc" id="L7844">        Container rootAncestor = getFocusCycleRootAncestor();</span>
<span class="nc bnc" id="L7845" title="All 2 branches missed.">        return (rootAncestor == container);</span>
    }

    Container getTraversalRoot() {
<span class="nc" id="L7849">        return getFocusCycleRootAncestor();</span>
    }

    /**
     * Transfers the focus to the next component, as though this Component were
     * the focus owner.
     * @see       #requestFocus()
     * @since     JDK1.1
     */
    public void transferFocus() {
<span class="nc" id="L7859">        nextFocus();</span>
<span class="nc" id="L7860">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by transferFocus().
     */
    @Deprecated
    public void nextFocus() {
<span class="nc" id="L7868">        transferFocus(false);</span>
<span class="nc" id="L7869">    }</span>

    boolean transferFocus(boolean clearOnFailure) {
<span class="nc bnc" id="L7872" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L7873">            focusLog.finer(&quot;clearOnFailure = &quot; + clearOnFailure);</span>
        }
<span class="nc" id="L7875">        Component toFocus = getNextFocusCandidate();</span>
<span class="nc" id="L7876">        boolean res = false;</span>
<span class="nc bnc" id="L7877" title="All 6 branches missed.">        if (toFocus != null &amp;&amp; !toFocus.isFocusOwner() &amp;&amp; toFocus != this) {</span>
<span class="nc" id="L7878">            res = toFocus.requestFocusInWindow(CausedFocusEvent.Cause.TRAVERSAL_FORWARD);</span>
        }
<span class="nc bnc" id="L7880" title="All 4 branches missed.">        if (clearOnFailure &amp;&amp; !res) {</span>
<span class="nc bnc" id="L7881" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L7882">                focusLog.finer(&quot;clear global focus owner&quot;);</span>
            }
<span class="nc" id="L7884">            KeyboardFocusManager.getCurrentKeyboardFocusManager().clearGlobalFocusOwnerPriv();</span>
        }
<span class="nc bnc" id="L7886" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L7887">            focusLog.finer(&quot;returning result: &quot; + res);</span>
        }
<span class="nc" id="L7889">        return res;</span>
    }

    final Component getNextFocusCandidate() {
<span class="nc" id="L7893">        Container rootAncestor = getTraversalRoot();</span>
<span class="nc" id="L7894">        Component comp = this;</span>
<span class="nc bnc" id="L7895" title="All 2 branches missed.">        while (rootAncestor != null &amp;&amp;</span>
<span class="nc bnc" id="L7896" title="All 4 branches missed.">               !(rootAncestor.isShowing() &amp;&amp; rootAncestor.canBeFocusOwner()))</span>
        {
<span class="nc" id="L7898">            comp = rootAncestor;</span>
<span class="nc" id="L7899">            rootAncestor = comp.getFocusCycleRootAncestor();</span>
        }
<span class="nc bnc" id="L7901" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L7902">            focusLog.finer(&quot;comp = &quot; + comp + &quot;, root = &quot; + rootAncestor);</span>
        }
<span class="nc" id="L7904">        Component candidate = null;</span>
<span class="nc bnc" id="L7905" title="All 2 branches missed.">        if (rootAncestor != null) {</span>
<span class="nc" id="L7906">            FocusTraversalPolicy policy = rootAncestor.getFocusTraversalPolicy();</span>
<span class="nc" id="L7907">            Component toFocus = policy.getComponentAfter(rootAncestor, comp);</span>
<span class="nc bnc" id="L7908" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L7909">                focusLog.finer(&quot;component after is &quot; + toFocus);</span>
            }
<span class="nc bnc" id="L7911" title="All 2 branches missed.">            if (toFocus == null) {</span>
<span class="nc" id="L7912">                toFocus = policy.getDefaultComponent(rootAncestor);</span>
<span class="nc bnc" id="L7913" title="All 2 branches missed.">                if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L7914">                    focusLog.finer(&quot;default component is &quot; + toFocus);</span>
                }
            }
<span class="nc bnc" id="L7917" title="All 2 branches missed.">            if (toFocus == null) {</span>
<span class="nc" id="L7918">                Applet applet = EmbeddedFrame.getAppletIfAncestorOf(this);</span>
<span class="nc bnc" id="L7919" title="All 2 branches missed.">                if (applet != null) {</span>
<span class="nc" id="L7920">                    toFocus = applet;</span>
                }
            }
<span class="nc" id="L7923">            candidate = toFocus;</span>
        }
<span class="nc bnc" id="L7925" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L7926">            focusLog.finer(&quot;Focus transfer candidate: &quot; + candidate);</span>
        }
<span class="nc" id="L7928">        return candidate;</span>
    }

    /**
     * Transfers the focus to the previous component, as though this Component
     * were the focus owner.
     * @see       #requestFocus()
     * @since     1.4
     */
    public void transferFocusBackward() {
<span class="nc" id="L7938">        transferFocusBackward(false);</span>
<span class="nc" id="L7939">    }</span>

    boolean transferFocusBackward(boolean clearOnFailure) {
<span class="nc" id="L7942">        Container rootAncestor = getTraversalRoot();</span>
<span class="nc" id="L7943">        Component comp = this;</span>
<span class="nc bnc" id="L7944" title="All 2 branches missed.">        while (rootAncestor != null &amp;&amp;</span>
<span class="nc bnc" id="L7945" title="All 4 branches missed.">               !(rootAncestor.isShowing() &amp;&amp; rootAncestor.canBeFocusOwner()))</span>
        {
<span class="nc" id="L7947">            comp = rootAncestor;</span>
<span class="nc" id="L7948">            rootAncestor = comp.getFocusCycleRootAncestor();</span>
        }
<span class="nc" id="L7950">        boolean res = false;</span>
<span class="nc bnc" id="L7951" title="All 2 branches missed.">        if (rootAncestor != null) {</span>
<span class="nc" id="L7952">            FocusTraversalPolicy policy = rootAncestor.getFocusTraversalPolicy();</span>
<span class="nc" id="L7953">            Component toFocus = policy.getComponentBefore(rootAncestor, comp);</span>
<span class="nc bnc" id="L7954" title="All 2 branches missed.">            if (toFocus == null) {</span>
<span class="nc" id="L7955">                toFocus = policy.getDefaultComponent(rootAncestor);</span>
            }
<span class="nc bnc" id="L7957" title="All 2 branches missed.">            if (toFocus != null) {</span>
<span class="nc" id="L7958">                res = toFocus.requestFocusInWindow(CausedFocusEvent.Cause.TRAVERSAL_BACKWARD);</span>
            }
        }
<span class="nc bnc" id="L7961" title="All 4 branches missed.">        if (clearOnFailure &amp;&amp; !res) {</span>
<span class="nc bnc" id="L7962" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L7963">                focusLog.finer(&quot;clear global focus owner&quot;);</span>
            }
<span class="nc" id="L7965">            KeyboardFocusManager.getCurrentKeyboardFocusManager().clearGlobalFocusOwnerPriv();</span>
        }
<span class="nc bnc" id="L7967" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L7968">            focusLog.finer(&quot;returning result: &quot; + res);</span>
        }
<span class="nc" id="L7970">        return res;</span>
    }

    /**
     * Transfers the focus up one focus traversal cycle. Typically, the focus
     * owner is set to this Component's focus cycle root, and the current focus
     * cycle root is set to the new focus owner's focus cycle root. If,
     * however, this Component's focus cycle root is a Window, then the focus
     * owner is set to the focus cycle root's default Component to focus, and
     * the current focus cycle root is unchanged.
     *
     * @see       #requestFocus()
     * @see       Container#isFocusCycleRoot()
     * @see       Container#setFocusCycleRoot(boolean)
     * @since     1.4
     */
    public void transferFocusUpCycle() {
        Container rootAncestor;
<span class="nc" id="L7988">        for (rootAncestor = getFocusCycleRootAncestor();</span>
<span class="nc bnc" id="L7989" title="All 4 branches missed.">             rootAncestor != null &amp;&amp; !(rootAncestor.isShowing() &amp;&amp;</span>
<span class="nc bnc" id="L7990" title="All 2 branches missed.">                                       rootAncestor.isFocusable() &amp;&amp;</span>
<span class="nc bnc" id="L7991" title="All 2 branches missed.">                                       rootAncestor.isEnabled());</span>
<span class="nc" id="L7992">             rootAncestor = rootAncestor.getFocusCycleRootAncestor()) {</span>
        }

<span class="nc bnc" id="L7995" title="All 2 branches missed.">        if (rootAncestor != null) {</span>
<span class="nc" id="L7996">            Container rootAncestorRootAncestor =</span>
<span class="nc" id="L7997">                rootAncestor.getFocusCycleRootAncestor();</span>
<span class="nc bnc" id="L7998" title="All 2 branches missed.">            Container fcr = (rootAncestorRootAncestor != null) ?</span>
                rootAncestorRootAncestor : rootAncestor;

<span class="nc" id="L8001">            KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L8002">                setGlobalCurrentFocusCycleRootPriv(fcr);</span>
<span class="nc" id="L8003">            rootAncestor.requestFocus(CausedFocusEvent.Cause.TRAVERSAL_UP);</span>
<span class="nc" id="L8004">        } else {</span>
<span class="nc" id="L8005">            Window window = getContainingWindow();</span>

<span class="nc bnc" id="L8007" title="All 2 branches missed.">            if (window != null) {</span>
<span class="nc" id="L8008">                Component toFocus = window.getFocusTraversalPolicy().</span>
<span class="nc" id="L8009">                    getDefaultComponent(window);</span>
<span class="nc bnc" id="L8010" title="All 2 branches missed.">                if (toFocus != null) {</span>
<span class="nc" id="L8011">                    KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L8012">                        setGlobalCurrentFocusCycleRootPriv(window);</span>
<span class="nc" id="L8013">                    toFocus.requestFocus(CausedFocusEvent.Cause.TRAVERSAL_UP);</span>
                }
            }
        }
<span class="nc" id="L8017">    }</span>

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Component&lt;/code&gt; is the
     * focus owner.  This method is obsolete, and has been replaced by
     * &lt;code&gt;isFocusOwner()&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Component&lt;/code&gt; is the
     *         focus owner; &lt;code&gt;false&lt;/code&gt; otherwise
     * @since 1.2
     */
    public boolean hasFocus() {
<span class="nc" id="L8029">        return (KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc bnc" id="L8030" title="All 2 branches missed.">                getFocusOwner() == this);</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Component&lt;/code&gt; is the
     *    focus owner.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Component&lt;/code&gt; is the
     *     focus owner; &lt;code&gt;false&lt;/code&gt; otherwise
     * @since 1.4
     */
    public boolean isFocusOwner() {
<span class="nc" id="L8042">        return hasFocus();</span>
    }

    /*
     * Used to disallow auto-focus-transfer on disposal of the focus owner
     * in the process of disposing its parent container.
     */
<span class="nc" id="L8049">    private boolean autoFocusTransferOnDisposal = true;</span>

    void setAutoFocusTransferOnDisposal(boolean value) {
<span class="nc" id="L8052">        autoFocusTransferOnDisposal = value;</span>
<span class="nc" id="L8053">    }</span>

    boolean isAutoFocusTransferOnDisposal() {
<span class="nc" id="L8056">        return autoFocusTransferOnDisposal;</span>
    }

    /**
     * Adds the specified popup menu to the component.
     * @param     popup the popup menu to be added to the component.
     * @see       #remove(MenuComponent)
     * @exception NullPointerException if {@code popup} is {@code null}
     * @since     JDK1.1
     */
    public void add(PopupMenu popup) {
<span class="nc" id="L8067">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L8068" title="All 2 branches missed.">            if (popup.parent != null) {</span>
<span class="nc" id="L8069">                popup.parent.remove(popup);</span>
            }
<span class="nc bnc" id="L8071" title="All 2 branches missed.">            if (popups == null) {</span>
<span class="nc" id="L8072">                popups = new Vector&lt;PopupMenu&gt;();</span>
            }
<span class="nc" id="L8074">            popups.addElement(popup);</span>
<span class="nc" id="L8075">            popup.parent = this;</span>

<span class="nc bnc" id="L8077" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc bnc" id="L8078" title="All 2 branches missed.">                if (popup.peer == null) {</span>
<span class="nc" id="L8079">                    popup.addNotify();</span>
                }
            }
<span class="nc" id="L8082">        }</span>
<span class="nc" id="L8083">    }</span>

    /**
     * Removes the specified popup menu from the component.
     * @param     popup the popup menu to be removed
     * @see       #add(PopupMenu)
     * @since     JDK1.1
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void remove(MenuComponent popup) {
<span class="nc" id="L8093">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L8094" title="All 2 branches missed.">            if (popups == null) {</span>
<span class="nc" id="L8095">                return;</span>
            }
<span class="nc" id="L8097">            int index = popups.indexOf(popup);</span>
<span class="nc bnc" id="L8098" title="All 2 branches missed.">            if (index &gt;= 0) {</span>
<span class="nc" id="L8099">                PopupMenu pmenu = (PopupMenu)popup;</span>
<span class="nc bnc" id="L8100" title="All 2 branches missed.">                if (pmenu.peer != null) {</span>
<span class="nc" id="L8101">                    pmenu.removeNotify();</span>
                }
<span class="nc" id="L8103">                pmenu.parent = null;</span>
<span class="nc" id="L8104">                popups.removeElementAt(index);</span>
<span class="nc bnc" id="L8105" title="All 2 branches missed.">                if (popups.size() == 0) {</span>
<span class="nc" id="L8106">                    popups = null;</span>
                }
            }
<span class="nc" id="L8109">        }</span>
<span class="nc" id="L8110">    }</span>

    /**
     * Returns a string representing the state of this component. This
     * method is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not be
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this component's state
     * @since     JDK1.0
     */
    protected String paramString() {
<span class="nc" id="L8123">        String thisName = getName();</span>
<span class="nc bnc" id="L8124" title="All 2 branches missed.">        String str = (thisName != null? thisName : &quot;&quot;) + &quot;,&quot; + x + &quot;,&quot; + y + &quot;,&quot; + width + &quot;x&quot; + height;</span>
<span class="nc bnc" id="L8125" title="All 2 branches missed.">        if (!isValid()) {</span>
<span class="nc" id="L8126">            str += &quot;,invalid&quot;;</span>
        }
<span class="nc bnc" id="L8128" title="All 2 branches missed.">        if (!visible) {</span>
<span class="nc" id="L8129">            str += &quot;,hidden&quot;;</span>
        }
<span class="nc bnc" id="L8131" title="All 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L8132">            str += &quot;,disabled&quot;;</span>
        }
<span class="nc" id="L8134">        return str;</span>
    }

    /**
     * Returns a string representation of this component and its values.
     * @return    a string representation of this component
     * @since     JDK1.0
     */
    public String toString() {
<span class="nc" id="L8143">        return getClass().getName() + &quot;[&quot; + paramString() + &quot;]&quot;;</span>
    }

    /**
     * Prints a listing of this component to the standard system output
     * stream &lt;code&gt;System.out&lt;/code&gt;.
     * @see       java.lang.System#out
     * @since     JDK1.0
     */
    public void list() {
<span class="nc" id="L8153">        list(System.out, 0);</span>
<span class="nc" id="L8154">    }</span>

    /**
     * Prints a listing of this component to the specified output
     * stream.
     * @param    out   a print stream
     * @throws   NullPointerException if {@code out} is {@code null}
     * @since    JDK1.0
     */
    public void list(PrintStream out) {
<span class="nc" id="L8164">        list(out, 0);</span>
<span class="nc" id="L8165">    }</span>

    /**
     * Prints out a list, starting at the specified indentation, to the
     * specified print stream.
     * @param     out      a print stream
     * @param     indent   number of spaces to indent
     * @see       java.io.PrintStream#println(java.lang.Object)
     * @throws    NullPointerException if {@code out} is {@code null}
     * @since     JDK1.0
     */
    public void list(PrintStream out, int indent) {
<span class="nc bnc" id="L8177" title="All 2 branches missed.">        for (int i = 0 ; i &lt; indent ; i++) {</span>
<span class="nc" id="L8178">            out.print(&quot; &quot;);</span>
        }
<span class="nc" id="L8180">        out.println(this);</span>
<span class="nc" id="L8181">    }</span>

    /**
     * Prints a listing to the specified print writer.
     * @param  out  the print writer to print to
     * @throws NullPointerException if {@code out} is {@code null}
     * @since JDK1.1
     */
    public void list(PrintWriter out) {
<span class="nc" id="L8190">        list(out, 0);</span>
<span class="nc" id="L8191">    }</span>

    /**
     * Prints out a list, starting at the specified indentation, to
     * the specified print writer.
     * @param out the print writer to print to
     * @param indent the number of spaces to indent
     * @throws NullPointerException if {@code out} is {@code null}
     * @see       java.io.PrintStream#println(java.lang.Object)
     * @since JDK1.1
     */
    public void list(PrintWriter out, int indent) {
<span class="nc bnc" id="L8203" title="All 2 branches missed.">        for (int i = 0 ; i &lt; indent ; i++) {</span>
<span class="nc" id="L8204">            out.print(&quot; &quot;);</span>
        }
<span class="nc" id="L8206">        out.println(this);</span>
<span class="nc" id="L8207">    }</span>

    /*
     * Fetches the native container somewhere higher up in the component
     * tree that contains this component.
     */
    final Container getNativeContainer() {
<span class="nc" id="L8214">        Container p = getContainer();</span>
<span class="nc bnc" id="L8215" title="All 4 branches missed.">        while (p != null &amp;&amp; p.peer instanceof LightweightPeer) {</span>
<span class="nc" id="L8216">            p = p.getContainer();</span>
        }
<span class="nc" id="L8218">        return p;</span>
    }

    /**
     * Adds a PropertyChangeListener to the listener list. The listener is
     * registered for all bound properties of this class, including the
     * following:
     * &lt;ul&gt;
     *    &lt;li&gt;this Component's font (&quot;font&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's background color (&quot;background&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's foreground color (&quot;foreground&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's focusability (&quot;focusable&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's focus traversal keys enabled state
     *        (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's Set of FORWARD_TRAVERSAL_KEYS
     *        (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's Set of BACKWARD_TRAVERSAL_KEYS
     *        (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's Set of UP_CYCLE_TRAVERSAL_KEYS
     *        (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's preferred size (&quot;preferredSize&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's minimum size (&quot;minimumSize&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's maximum size (&quot;maximumSize&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's name (&quot;name&quot;)&lt;/li&gt;
     * &lt;/ul&gt;
     * Note that if this &lt;code&gt;Component&lt;/code&gt; is inheriting a bound property, then no
     * event will be fired in response to a change in the inherited property.
     * &lt;p&gt;
     * If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     *
     * @param    listener  the property change listener to be added
     *
     * @see #removePropertyChangeListener
     * @see #getPropertyChangeListeners
     * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
     */
    public void addPropertyChangeListener(
                                                       PropertyChangeListener listener) {
<span class="nc" id="L8257">        synchronized (getObjectLock()) {</span>
<span class="nc bnc" id="L8258" title="All 2 branches missed.">            if (listener == null) {</span>
<span class="nc" id="L8259">                return;</span>
            }
<span class="nc bnc" id="L8261" title="All 2 branches missed.">            if (changeSupport == null) {</span>
<span class="nc" id="L8262">                changeSupport = new PropertyChangeSupport(this);</span>
            }
<span class="nc" id="L8264">            changeSupport.addPropertyChangeListener(listener);</span>
<span class="nc" id="L8265">        }</span>
<span class="nc" id="L8266">    }</span>

    /**
     * Removes a PropertyChangeListener from the listener list. This method
     * should be used to remove PropertyChangeListeners that were registered
     * for all bound properties of this class.
     * &lt;p&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param listener the PropertyChangeListener to be removed
     *
     * @see #addPropertyChangeListener
     * @see #getPropertyChangeListeners
     * @see #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
     */
    public void removePropertyChangeListener(
                                                          PropertyChangeListener listener) {
<span class="nc" id="L8283">        synchronized (getObjectLock()) {</span>
<span class="nc bnc" id="L8284" title="All 4 branches missed.">            if (listener == null || changeSupport == null) {</span>
<span class="nc" id="L8285">                return;</span>
            }
<span class="nc" id="L8287">            changeSupport.removePropertyChangeListener(listener);</span>
<span class="nc" id="L8288">        }</span>
<span class="nc" id="L8289">    }</span>

    /**
     * Returns an array of all the property change listeners
     * registered on this component.
     *
     * @return all of this component's &lt;code&gt;PropertyChangeListener&lt;/code&gt;s
     *         or an empty array if no property change
     *         listeners are currently registered
     *
     * @see      #addPropertyChangeListener
     * @see      #removePropertyChangeListener
     * @see      #getPropertyChangeListeners(java.lang.String)
     * @see      java.beans.PropertyChangeSupport#getPropertyChangeListeners
     * @since    1.4
     */
    public PropertyChangeListener[] getPropertyChangeListeners() {
<span class="nc" id="L8306">        synchronized (getObjectLock()) {</span>
<span class="nc bnc" id="L8307" title="All 2 branches missed.">            if (changeSupport == null) {</span>
<span class="nc" id="L8308">                return new PropertyChangeListener[0];</span>
            }
<span class="nc" id="L8310">            return changeSupport.getPropertyChangeListeners();</span>
<span class="nc" id="L8311">        }</span>
    }

    /**
     * Adds a PropertyChangeListener to the listener list for a specific
     * property. The specified property may be user-defined, or one of the
     * following:
     * &lt;ul&gt;
     *    &lt;li&gt;this Component's font (&quot;font&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's background color (&quot;background&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's foreground color (&quot;foreground&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's focusability (&quot;focusable&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's focus traversal keys enabled state
     *        (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's Set of FORWARD_TRAVERSAL_KEYS
     *        (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's Set of BACKWARD_TRAVERSAL_KEYS
     *        (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;this Component's Set of UP_CYCLE_TRAVERSAL_KEYS
     *        (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
     * &lt;/ul&gt;
     * Note that if this &lt;code&gt;Component&lt;/code&gt; is inheriting a bound property, then no
     * event will be fired in response to a change in the inherited property.
     * &lt;p&gt;
     * If &lt;code&gt;propertyName&lt;/code&gt; or &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is taken.
     *
     * @param propertyName one of the property names listed above
     * @param listener the property change listener to be added
     *
     * @see #removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
     * @see #getPropertyChangeListeners(java.lang.String)
     * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
     */
    public void addPropertyChangeListener(
                                                       String propertyName,
                                                       PropertyChangeListener listener) {
<span class="nc" id="L8348">        synchronized (getObjectLock()) {</span>
<span class="nc bnc" id="L8349" title="All 2 branches missed.">            if (listener == null) {</span>
<span class="nc" id="L8350">                return;</span>
            }
<span class="nc bnc" id="L8352" title="All 2 branches missed.">            if (changeSupport == null) {</span>
<span class="nc" id="L8353">                changeSupport = new PropertyChangeSupport(this);</span>
            }
<span class="nc" id="L8355">            changeSupport.addPropertyChangeListener(propertyName, listener);</span>
<span class="nc" id="L8356">        }</span>
<span class="nc" id="L8357">    }</span>

    /**
     * Removes a &lt;code&gt;PropertyChangeListener&lt;/code&gt; from the listener
     * list for a specific property. This method should be used to remove
     * &lt;code&gt;PropertyChangeListener&lt;/code&gt;s
     * that were registered for a specific bound property.
     * &lt;p&gt;
     * If &lt;code&gt;propertyName&lt;/code&gt; or &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is taken.
     *
     * @param propertyName a valid property name
     * @param listener the PropertyChangeListener to be removed
     *
     * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
     * @see #getPropertyChangeListeners(java.lang.String)
     * @see #removePropertyChangeListener(java.beans.PropertyChangeListener)
     */
    public void removePropertyChangeListener(
                                                          String propertyName,
                                                          PropertyChangeListener listener) {
<span class="nc" id="L8378">        synchronized (getObjectLock()) {</span>
<span class="nc bnc" id="L8379" title="All 4 branches missed.">            if (listener == null || changeSupport == null) {</span>
<span class="nc" id="L8380">                return;</span>
            }
<span class="nc" id="L8382">            changeSupport.removePropertyChangeListener(propertyName, listener);</span>
<span class="nc" id="L8383">        }</span>
<span class="nc" id="L8384">    }</span>

    /**
     * Returns an array of all the listeners which have been associated
     * with the named property.
     *
     * @return all of the &lt;code&gt;PropertyChangeListener&lt;/code&gt;s associated with
     *         the named property; if no such listeners have been added or
     *         if &lt;code&gt;propertyName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, an empty
     *         array is returned
     *
     * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
     * @see #removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
     * @see #getPropertyChangeListeners
     * @since 1.4
     */
    public PropertyChangeListener[] getPropertyChangeListeners(
                                                                            String propertyName) {
<span class="nc" id="L8402">        synchronized (getObjectLock()) {</span>
<span class="nc bnc" id="L8403" title="All 2 branches missed.">            if (changeSupport == null) {</span>
<span class="nc" id="L8404">                return new PropertyChangeListener[0];</span>
            }
<span class="nc" id="L8406">            return changeSupport.getPropertyChangeListeners(propertyName);</span>
<span class="nc" id="L8407">        }</span>
    }

    /**
     * Support for reporting bound property changes for Object properties.
     * This method can be called when a bound property has changed and it will
     * send the appropriate PropertyChangeEvent to any registered
     * PropertyChangeListeners.
     *
     * @param propertyName the property whose value has changed
     * @param oldValue the property's previous value
     * @param newValue the property's new value
     */
    protected void firePropertyChange(String propertyName,
                                      Object oldValue, Object newValue) {
        PropertyChangeSupport changeSupport;
<span class="nc" id="L8423">        synchronized (getObjectLock()) {</span>
<span class="nc" id="L8424">            changeSupport = this.changeSupport;</span>
<span class="nc" id="L8425">        }</span>
<span class="nc bnc" id="L8426" title="All 6 branches missed.">        if (changeSupport == null ||</span>
<span class="nc bnc" id="L8427" title="All 2 branches missed.">            (oldValue != null &amp;&amp; newValue != null &amp;&amp; oldValue.equals(newValue))) {</span>
<span class="nc" id="L8428">            return;</span>
        }
<span class="nc" id="L8430">        changeSupport.firePropertyChange(propertyName, oldValue, newValue);</span>
<span class="nc" id="L8431">    }</span>

    /**
     * Support for reporting bound property changes for boolean properties.
     * This method can be called when a bound property has changed and it will
     * send the appropriate PropertyChangeEvent to any registered
     * PropertyChangeListeners.
     *
     * @param propertyName the property whose value has changed
     * @param oldValue the property's previous value
     * @param newValue the property's new value
     * @since 1.4
     */
    protected void firePropertyChange(String propertyName,
                                      boolean oldValue, boolean newValue) {
<span class="nc" id="L8446">        PropertyChangeSupport changeSupport = this.changeSupport;</span>
<span class="nc bnc" id="L8447" title="All 4 branches missed.">        if (changeSupport == null || oldValue == newValue) {</span>
<span class="nc" id="L8448">            return;</span>
        }
<span class="nc" id="L8450">        changeSupport.firePropertyChange(propertyName, oldValue, newValue);</span>
<span class="nc" id="L8451">    }</span>

    /**
     * Support for reporting bound property changes for integer properties.
     * This method can be called when a bound property has changed and it will
     * send the appropriate PropertyChangeEvent to any registered
     * PropertyChangeListeners.
     *
     * @param propertyName the property whose value has changed
     * @param oldValue the property's previous value
     * @param newValue the property's new value
     * @since 1.4
     */
    protected void firePropertyChange(String propertyName,
                                      int oldValue, int newValue) {
<span class="nc" id="L8466">        PropertyChangeSupport changeSupport = this.changeSupport;</span>
<span class="nc bnc" id="L8467" title="All 4 branches missed.">        if (changeSupport == null || oldValue == newValue) {</span>
<span class="nc" id="L8468">            return;</span>
        }
<span class="nc" id="L8470">        changeSupport.firePropertyChange(propertyName, oldValue, newValue);</span>
<span class="nc" id="L8471">    }</span>

    /**
     * Reports a bound property change.
     *
     * @param propertyName the programmatic name of the property
     *          that was changed
     * @param oldValue the old value of the property (as a byte)
     * @param newValue the new value of the property (as a byte)
     * @see #firePropertyChange(java.lang.String, java.lang.Object,
     *          java.lang.Object)
     * @since 1.5
     */
    public void firePropertyChange(String propertyName, byte oldValue, byte newValue) {
<span class="nc bnc" id="L8485" title="All 4 branches missed.">        if (changeSupport == null || oldValue == newValue) {</span>
<span class="nc" id="L8486">            return;</span>
        }
<span class="nc" id="L8488">        firePropertyChange(propertyName, Byte.valueOf(oldValue), Byte.valueOf(newValue));</span>
<span class="nc" id="L8489">    }</span>

    /**
     * Reports a bound property change.
     *
     * @param propertyName the programmatic name of the property
     *          that was changed
     * @param oldValue the old value of the property (as a char)
     * @param newValue the new value of the property (as a char)
     * @see #firePropertyChange(java.lang.String, java.lang.Object,
     *          java.lang.Object)
     * @since 1.5
     */
    public void firePropertyChange(String propertyName, char oldValue, char newValue) {
<span class="nc bnc" id="L8503" title="All 4 branches missed.">        if (changeSupport == null || oldValue == newValue) {</span>
<span class="nc" id="L8504">            return;</span>
        }
<span class="nc" id="L8506">        firePropertyChange(propertyName, new Character(oldValue), new Character(newValue));</span>
<span class="nc" id="L8507">    }</span>

    /**
     * Reports a bound property change.
     *
     * @param propertyName the programmatic name of the property
     *          that was changed
     * @param oldValue the old value of the property (as a short)
     * @param newValue the old value of the property (as a short)
     * @see #firePropertyChange(java.lang.String, java.lang.Object,
     *          java.lang.Object)
     * @since 1.5
     */
    public void firePropertyChange(String propertyName, short oldValue, short newValue) {
<span class="nc bnc" id="L8521" title="All 4 branches missed.">        if (changeSupport == null || oldValue == newValue) {</span>
<span class="nc" id="L8522">            return;</span>
        }
<span class="nc" id="L8524">        firePropertyChange(propertyName, Short.valueOf(oldValue), Short.valueOf(newValue));</span>
<span class="nc" id="L8525">    }</span>


    /**
     * Reports a bound property change.
     *
     * @param propertyName the programmatic name of the property
     *          that was changed
     * @param oldValue the old value of the property (as a long)
     * @param newValue the new value of the property (as a long)
     * @see #firePropertyChange(java.lang.String, java.lang.Object,
     *          java.lang.Object)
     * @since 1.5
     */
    public void firePropertyChange(String propertyName, long oldValue, long newValue) {
<span class="nc bnc" id="L8540" title="All 4 branches missed.">        if (changeSupport == null || oldValue == newValue) {</span>
<span class="nc" id="L8541">            return;</span>
        }
<span class="nc" id="L8543">        firePropertyChange(propertyName, Long.valueOf(oldValue), Long.valueOf(newValue));</span>
<span class="nc" id="L8544">    }</span>

    /**
     * Reports a bound property change.
     *
     * @param propertyName the programmatic name of the property
     *          that was changed
     * @param oldValue the old value of the property (as a float)
     * @param newValue the new value of the property (as a float)
     * @see #firePropertyChange(java.lang.String, java.lang.Object,
     *          java.lang.Object)
     * @since 1.5
     */
    public void firePropertyChange(String propertyName, float oldValue, float newValue) {
<span class="nc bnc" id="L8558" title="All 4 branches missed.">        if (changeSupport == null || oldValue == newValue) {</span>
<span class="nc" id="L8559">            return;</span>
        }
<span class="nc" id="L8561">        firePropertyChange(propertyName, Float.valueOf(oldValue), Float.valueOf(newValue));</span>
<span class="nc" id="L8562">    }</span>

    /**
     * Reports a bound property change.
     *
     * @param propertyName the programmatic name of the property
     *          that was changed
     * @param oldValue the old value of the property (as a double)
     * @param newValue the new value of the property (as a double)
     * @see #firePropertyChange(java.lang.String, java.lang.Object,
     *          java.lang.Object)
     * @since 1.5
     */
    public void firePropertyChange(String propertyName, double oldValue, double newValue) {
<span class="nc bnc" id="L8576" title="All 4 branches missed.">        if (changeSupport == null || oldValue == newValue) {</span>
<span class="nc" id="L8577">            return;</span>
        }
<span class="nc" id="L8579">        firePropertyChange(propertyName, Double.valueOf(oldValue), Double.valueOf(newValue));</span>
<span class="nc" id="L8580">    }</span>


    // Serialization support.

    /**
     * Component Serialized Data Version.
     *
     * @serial
     */
<span class="nc" id="L8590">    private int componentSerializedDataVersion = 4;</span>

    /**
     * This hack is for Swing serialization. It will invoke
     * the Swing package private method &lt;code&gt;compWriteObjectNotify&lt;/code&gt;.
     */
    private void doSwingSerialization() {
<span class="nc" id="L8597">        Package swingPackage = Package.getPackage(&quot;javax.swing&quot;);</span>
        // For Swing serialization to correctly work Swing needs to
        // be notified before Component does it's serialization.  This
        // hack accomodates this.
        //
        // Swing classes MUST be loaded by the bootstrap class loader,
        // otherwise we don't consider them.
<span class="nc bnc" id="L8604" title="All 2 branches missed.">        for (Class&lt;?&gt; klass = Component.this.getClass(); klass != null;</span>
<span class="nc" id="L8605">                   klass = klass.getSuperclass()) {</span>
<span class="nc bnc" id="L8606" title="All 2 branches missed.">            if (klass.getPackage() == swingPackage &amp;&amp;</span>
<span class="nc bnc" id="L8607" title="All 2 branches missed.">                      klass.getClassLoader() == null) {</span>
<span class="nc" id="L8608">                final Class&lt;?&gt; swingClass = klass;</span>
                // Find the first override of the compWriteObjectNotify method
<span class="nc" id="L8610">                Method[] methods = AccessController.doPrivileged(</span>
<span class="nc" id="L8611">                                                                 new PrivilegedAction&lt;Method[]&gt;() {</span>
                                                                     public Method[] run() {
<span class="nc" id="L8613">                                                                         return swingClass.getDeclaredMethods();</span>
                                                                     }
                                                                 });
<span class="nc bnc" id="L8616" title="All 2 branches missed.">                for (int counter = methods.length - 1; counter &gt;= 0;</span>
<span class="nc" id="L8617">                     counter--) {</span>
<span class="nc" id="L8618">                    final Method method = methods[counter];</span>
<span class="nc bnc" id="L8619" title="All 2 branches missed.">                    if (method.getName().equals(&quot;compWriteObjectNotify&quot;)){</span>
                        // We found it, use doPrivileged to make it accessible
                        // to use.
<span class="nc" id="L8622">                        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                                public Void run() {
<span class="nc" id="L8624">                                    method.setAccessible(true);</span>
<span class="nc" id="L8625">                                    return null;</span>
                                }
                            });
                        // Invoke the method
                        try {
<span class="nc" id="L8630">                            method.invoke(this, (Object[]) null);</span>
<span class="nc" id="L8631">                        } catch (IllegalAccessException iae) {</span>
<span class="nc" id="L8632">                        } catch (InvocationTargetException ite) {</span>
<span class="nc" id="L8633">                        }</span>
                        // We're done, bail.
<span class="nc" id="L8635">                        return;</span>
                    }
                }
            }
        }
<span class="nc" id="L8640">    }</span>

    /**
     * Writes default serializable fields to stream.  Writes
     * a variety of serializable listeners as optional data.
     * The non-serializable listeners are detected and
     * no attempt is made to serialize them.
     *
     * @param s the &lt;code&gt;ObjectOutputStream&lt;/code&gt; to write
     * @serialData &lt;code&gt;null&lt;/code&gt; terminated sequence of
     *   0 or more pairs; the pair consists of a &lt;code&gt;String&lt;/code&gt;
     *   and an &lt;code&gt;Object&lt;/code&gt;; the &lt;code&gt;String&lt;/code&gt; indicates
     *   the type of object and is one of the following (as of 1.4):
     *   &lt;code&gt;componentListenerK&lt;/code&gt; indicating an
     *     &lt;code&gt;ComponentListener&lt;/code&gt; object;
     *   &lt;code&gt;focusListenerK&lt;/code&gt; indicating an
     *     &lt;code&gt;FocusListener&lt;/code&gt; object;
     *   &lt;code&gt;keyListenerK&lt;/code&gt; indicating an
     *     &lt;code&gt;KeyListener&lt;/code&gt; object;
     *   &lt;code&gt;mouseListenerK&lt;/code&gt; indicating an
     *     &lt;code&gt;MouseListener&lt;/code&gt; object;
     *   &lt;code&gt;mouseMotionListenerK&lt;/code&gt; indicating an
     *     &lt;code&gt;MouseMotionListener&lt;/code&gt; object;
     *   &lt;code&gt;inputMethodListenerK&lt;/code&gt; indicating an
     *     &lt;code&gt;InputMethodListener&lt;/code&gt; object;
     *   &lt;code&gt;hierarchyListenerK&lt;/code&gt; indicating an
     *     &lt;code&gt;HierarchyListener&lt;/code&gt; object;
     *   &lt;code&gt;hierarchyBoundsListenerK&lt;/code&gt; indicating an
     *     &lt;code&gt;HierarchyBoundsListener&lt;/code&gt; object;
     *   &lt;code&gt;mouseWheelListenerK&lt;/code&gt; indicating an
     *     &lt;code&gt;MouseWheelListener&lt;/code&gt; object
     * @serialData an optional &lt;code&gt;ComponentOrientation&lt;/code&gt;
     *    (after &lt;code&gt;inputMethodListener&lt;/code&gt;, as of 1.2)
     *
     * @see AWTEventMulticaster#save(java.io.ObjectOutputStream, java.lang.String, java.util.EventListener)
     * @see #componentListenerK
     * @see #focusListenerK
     * @see #keyListenerK
     * @see #mouseListenerK
     * @see #mouseMotionListenerK
     * @see #inputMethodListenerK
     * @see #hierarchyListenerK
     * @see #hierarchyBoundsListenerK
     * @see #mouseWheelListenerK
     * @see #readObject(ObjectInputStream)
     */
    private void writeObject(ObjectOutputStream s)
      throws IOException
    {
<span class="nc" id="L8689">        doSwingSerialization();</span>

<span class="nc" id="L8691">        s.defaultWriteObject();</span>

<span class="nc" id="L8693">        AWTEventMulticaster.save(s, componentListenerK, componentListener);</span>
<span class="nc" id="L8694">        AWTEventMulticaster.save(s, focusListenerK, focusListener);</span>
<span class="nc" id="L8695">        AWTEventMulticaster.save(s, keyListenerK, keyListener);</span>
<span class="nc" id="L8696">        AWTEventMulticaster.save(s, mouseListenerK, mouseListener);</span>
<span class="nc" id="L8697">        AWTEventMulticaster.save(s, mouseMotionListenerK, mouseMotionListener);</span>
<span class="nc" id="L8698">        AWTEventMulticaster.save(s, inputMethodListenerK, inputMethodListener);</span>

<span class="nc" id="L8700">        s.writeObject(null);</span>
<span class="nc" id="L8701">        s.writeObject(componentOrientation);</span>

<span class="nc" id="L8703">        AWTEventMulticaster.save(s, hierarchyListenerK, hierarchyListener);</span>
<span class="nc" id="L8704">        AWTEventMulticaster.save(s, hierarchyBoundsListenerK,</span>
                                 hierarchyBoundsListener);
<span class="nc" id="L8706">        s.writeObject(null);</span>

<span class="nc" id="L8708">        AWTEventMulticaster.save(s, mouseWheelListenerK, mouseWheelListener);</span>
<span class="nc" id="L8709">        s.writeObject(null);</span>

<span class="nc" id="L8711">    }</span>

    /**
     * Reads the &lt;code&gt;ObjectInputStream&lt;/code&gt; and if it isn't
     * &lt;code&gt;null&lt;/code&gt; adds a listener to receive a variety
     * of events fired by the component.
     * Unrecognized keys or values will be ignored.
     *
     * @param s the &lt;code&gt;ObjectInputStream&lt;/code&gt; to read
     * @see #writeObject(ObjectOutputStream)
     */
    private void readObject(ObjectInputStream s)
      throws ClassNotFoundException, IOException
    {
<span class="nc" id="L8725">        objectLock = new Object();</span>

<span class="nc" id="L8727">        acc = AccessController.getContext();</span>

<span class="nc" id="L8729">        s.defaultReadObject();</span>

<span class="nc" id="L8731">        appContext = AppContext.getAppContext();</span>
<span class="nc" id="L8732">        coalescingEnabled = checkCoalescing();</span>
<span class="nc bnc" id="L8733" title="All 2 branches missed.">        if (componentSerializedDataVersion &lt; 4) {</span>
            // These fields are non-transient and rely on default
            // serialization. However, the default values are insufficient,
            // so we need to set them explicitly for object data streams prior
            // to 1.4.
<span class="nc" id="L8738">            focusable = true;</span>
<span class="nc" id="L8739">            isFocusTraversableOverridden = FOCUS_TRAVERSABLE_UNKNOWN;</span>
<span class="nc" id="L8740">            initializeFocusTraversalKeys();</span>
<span class="nc" id="L8741">            focusTraversalKeysEnabled = true;</span>
        }

        Object keyOrNull;
<span class="nc bnc" id="L8745" title="All 2 branches missed.">        while(null != (keyOrNull = s.readObject())) {</span>
<span class="nc" id="L8746">            String key = ((String)keyOrNull).intern();</span>

<span class="nc bnc" id="L8748" title="All 2 branches missed.">            if (componentListenerK == key)</span>
<span class="nc" id="L8749">                addComponentListener((ComponentListener)(s.readObject()));</span>

<span class="nc bnc" id="L8751" title="All 2 branches missed.">            else if (focusListenerK == key)</span>
<span class="nc" id="L8752">                addFocusListener((FocusListener)(s.readObject()));</span>

<span class="nc bnc" id="L8754" title="All 2 branches missed.">            else if (keyListenerK == key)</span>
<span class="nc" id="L8755">                addKeyListener((KeyListener)(s.readObject()));</span>

<span class="nc bnc" id="L8757" title="All 2 branches missed.">            else if (mouseListenerK == key)</span>
<span class="nc" id="L8758">                addMouseListener((MouseListener)(s.readObject()));</span>

<span class="nc bnc" id="L8760" title="All 2 branches missed.">            else if (mouseMotionListenerK == key)</span>
<span class="nc" id="L8761">                addMouseMotionListener((MouseMotionListener)(s.readObject()));</span>

<span class="nc bnc" id="L8763" title="All 2 branches missed.">            else if (inputMethodListenerK == key)</span>
<span class="nc" id="L8764">                addInputMethodListener((InputMethodListener)(s.readObject()));</span>

            else // skip value for unrecognized key
<span class="nc" id="L8767">                s.readObject();</span>

<span class="nc" id="L8769">        }</span>

        // Read the component's orientation if it's present
<span class="nc" id="L8772">        Object orient = null;</span>

        try {
<span class="nc" id="L8775">            orient = s.readObject();</span>
<span class="nc" id="L8776">        } catch (java.io.OptionalDataException e) {</span>
            // JDK 1.1 instances will not have this optional data.
            // e.eof will be true to indicate that there is no more
            // data available for this object.
            // If e.eof is not true, throw the exception as it
            // might have been caused by reasons unrelated to
            // componentOrientation.

<span class="nc bnc" id="L8784" title="All 2 branches missed.">            if (!e.eof)  {</span>
<span class="nc" id="L8785">                throw (e);</span>
            }
<span class="nc" id="L8787">        }</span>

<span class="nc bnc" id="L8789" title="All 2 branches missed.">        if (orient != null) {</span>
<span class="nc" id="L8790">            componentOrientation = (ComponentOrientation)orient;</span>
        } else {
<span class="nc" id="L8792">            componentOrientation = ComponentOrientation.UNKNOWN;</span>
        }

        try {
<span class="nc bnc" id="L8796" title="All 2 branches missed.">            while(null != (keyOrNull = s.readObject())) {</span>
<span class="nc" id="L8797">                String key = ((String)keyOrNull).intern();</span>

<span class="nc bnc" id="L8799" title="All 2 branches missed.">                if (hierarchyListenerK == key) {</span>
<span class="nc" id="L8800">                    addHierarchyListener((HierarchyListener)(s.readObject()));</span>
                }
<span class="nc bnc" id="L8802" title="All 2 branches missed.">                else if (hierarchyBoundsListenerK == key) {</span>
<span class="nc" id="L8803">                    addHierarchyBoundsListener((HierarchyBoundsListener)</span>
<span class="nc" id="L8804">                                               (s.readObject()));</span>
                }
                else {
                    // skip value for unrecognized key
<span class="nc" id="L8808">                    s.readObject();</span>
                }
<span class="nc" id="L8810">            }</span>
<span class="nc" id="L8811">        } catch (java.io.OptionalDataException e) {</span>
            // JDK 1.1/1.2 instances will not have this optional data.
            // e.eof will be true to indicate that there is no more
            // data available for this object.
            // If e.eof is not true, throw the exception as it
            // might have been caused by reasons unrelated to
            // hierarchy and hierarchyBounds listeners.

<span class="nc bnc" id="L8819" title="All 2 branches missed.">            if (!e.eof)  {</span>
<span class="nc" id="L8820">                throw (e);</span>
            }
<span class="nc" id="L8822">        }</span>

        try {
<span class="nc bnc" id="L8825" title="All 2 branches missed.">            while (null != (keyOrNull = s.readObject())) {</span>
<span class="nc" id="L8826">                String key = ((String)keyOrNull).intern();</span>

<span class="nc bnc" id="L8828" title="All 2 branches missed.">                if (mouseWheelListenerK == key) {</span>
<span class="nc" id="L8829">                    addMouseWheelListener((MouseWheelListener)(s.readObject()));</span>
                }
                else {
                    // skip value for unrecognized key
<span class="nc" id="L8833">                    s.readObject();</span>
                }
<span class="nc" id="L8835">            }</span>
<span class="nc" id="L8836">        } catch (java.io.OptionalDataException e) {</span>
            // pre-1.3 instances will not have this optional data.
            // e.eof will be true to indicate that there is no more
            // data available for this object.
            // If e.eof is not true, throw the exception as it
            // might have been caused by reasons unrelated to
            // mouse wheel listeners

<span class="nc bnc" id="L8844" title="All 2 branches missed.">            if (!e.eof)  {</span>
<span class="nc" id="L8845">                throw (e);</span>
            }
<span class="nc" id="L8847">        }</span>

<span class="nc bnc" id="L8849" title="All 2 branches missed.">        if (popups != null) {</span>
<span class="nc" id="L8850">            int npopups = popups.size();</span>
<span class="nc bnc" id="L8851" title="All 2 branches missed.">            for (int i = 0 ; i &lt; npopups ; i++) {</span>
<span class="nc" id="L8852">                PopupMenu popup = popups.elementAt(i);</span>
<span class="nc" id="L8853">                popup.parent = this;</span>
            }
        }
<span class="nc" id="L8856">    }</span>

    /**
     * Sets the language-sensitive orientation that is to be used to order
     * the elements or text within this component.  Language-sensitive
     * &lt;code&gt;LayoutManager&lt;/code&gt; and &lt;code&gt;Component&lt;/code&gt;
     * subclasses will use this property to
     * determine how to lay out and draw components.
     * &lt;p&gt;
     * At construction time, a component's orientation is set to
     * &lt;code&gt;ComponentOrientation.UNKNOWN&lt;/code&gt;,
     * indicating that it has not been specified
     * explicitly.  The UNKNOWN orientation behaves the same as
     * &lt;code&gt;ComponentOrientation.LEFT_TO_RIGHT&lt;/code&gt;.
     * &lt;p&gt;
     * To set the orientation of a single component, use this method.
     * To set the orientation of an entire component
     * hierarchy, use
     * {@link #applyComponentOrientation applyComponentOrientation}.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     *
     * @see ComponentOrientation
     * @see #invalidate
     *
     * @author Laura Werner, IBM
     * @beaninfo
     *       bound: true
     */
    public void setComponentOrientation(ComponentOrientation o) {
<span class="nc" id="L8888">        ComponentOrientation oldValue = componentOrientation;</span>
<span class="nc" id="L8889">        componentOrientation = o;</span>

        // This is a bound property, so report the change to
        // any registered listeners.  (Cheap if there are none.)
<span class="nc" id="L8893">        firePropertyChange(&quot;componentOrientation&quot;, oldValue, o);</span>

        // This could change the preferred size of the Component.
<span class="nc" id="L8896">        invalidateIfValid();</span>
<span class="nc" id="L8897">    }</span>

    /**
     * Retrieves the language-sensitive orientation that is to be used to order
     * the elements or text within this component.  &lt;code&gt;LayoutManager&lt;/code&gt;
     * and &lt;code&gt;Component&lt;/code&gt;
     * subclasses that wish to respect orientation should call this method to
     * get the component's orientation before performing layout or drawing.
     *
     * @see ComponentOrientation
     *
     * @author Laura Werner, IBM
     */
    public ComponentOrientation getComponentOrientation() {
<span class="nc" id="L8911">        return componentOrientation;</span>
    }

    /**
     * Sets the &lt;code&gt;ComponentOrientation&lt;/code&gt; property of this component
     * and all components contained within it.
     * &lt;p&gt;
     * This method changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     *
     * @param orientation the new component orientation of this component and
     *        the components contained within it.
     * @exception NullPointerException if &lt;code&gt;orientation&lt;/code&gt; is null.
     * @see #setComponentOrientation
     * @see #getComponentOrientation
     * @see #invalidate
     * @since 1.4
     */
    public void applyComponentOrientation(ComponentOrientation orientation) {
<span class="nc bnc" id="L8931" title="All 2 branches missed.">        if (orientation == null) {</span>
<span class="nc" id="L8932">            throw new NullPointerException();</span>
        }
<span class="nc" id="L8934">        setComponentOrientation(orientation);</span>
<span class="nc" id="L8935">    }</span>

    final boolean canBeFocusOwner() {
        // It is enabled, visible, focusable.
<span class="nc bnc" id="L8939" title="All 8 branches missed.">        if (isEnabled() &amp;&amp; isDisplayable() &amp;&amp; isVisible() &amp;&amp; isFocusable()) {</span>
<span class="nc" id="L8940">            return true;</span>
        }
<span class="nc" id="L8942">        return false;</span>
    }

    /**
     * Checks that this component meets the prerequesites to be focus owner:
     * - it is enabled, visible, focusable
     * - it's parents are all enabled and showing
     * - top-level window is focusable
     * - if focus cycle root has DefaultFocusTraversalPolicy then it also checks that this policy accepts
     * this component as focus owner
     * @since 1.5
     */
    final boolean canBeFocusOwnerRecursively() {
        // - it is enabled, visible, focusable
<span class="nc bnc" id="L8956" title="All 2 branches missed.">        if (!canBeFocusOwner()) {</span>
<span class="nc" id="L8957">            return false;</span>
        }

        // - it's parents are all enabled and showing
<span class="nc" id="L8961">        synchronized(getTreeLock()) {</span>
<span class="nc bnc" id="L8962" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L8963">                return parent.canContainFocusOwner(this);</span>
            }
<span class="nc" id="L8965">        }</span>
<span class="nc" id="L8966">        return true;</span>
    }

    /**
     * Fix the location of the HW component in a LW container hierarchy.
     */
    final void relocateComponent() {
<span class="nc" id="L8973">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L8974" title="All 2 branches missed.">            if (peer == null) {</span>
<span class="nc" id="L8975">                return;</span>
            }
<span class="nc" id="L8977">            int nativeX = x;</span>
<span class="nc" id="L8978">            int nativeY = y;</span>
<span class="nc" id="L8979">            for (Component cont = getContainer();</span>
<span class="nc bnc" id="L8980" title="All 4 branches missed.">                    cont != null &amp;&amp; cont.isLightweight();</span>
<span class="nc" id="L8981">                    cont = cont.getContainer())</span>
            {
<span class="nc" id="L8983">                nativeX += cont.x;</span>
<span class="nc" id="L8984">                nativeY += cont.y;</span>
            }
<span class="nc" id="L8986">            peer.setBounds(nativeX, nativeY, width, height,</span>
                    ComponentPeer.SET_LOCATION);
<span class="nc" id="L8988">        }</span>
<span class="nc" id="L8989">    }</span>

    /**
     * Returns the &lt;code&gt;Window&lt;/code&gt; ancestor of the component.
     * @return Window ancestor of the component or component by itself if it is Window;
     *         null, if component is not a part of window hierarchy
     */
    Window getContainingWindow() {
<span class="nc" id="L8997">        return SunToolkit.getContainingWindow(this);</span>
    }

    /**
     * Initialize JNI field and method IDs
     */
    private static native void initIDs();

    /*
     * --- Accessibility Support ---
     *
     *  Component will contain all of the methods in interface Accessible,
     *  though it won't actually implement the interface - that will be up
     *  to the individual objects which extend Component.
     */

    /**
     * The {@code AccessibleContext} associated with this {@code Component}.
     */
<span class="nc" id="L9016">    protected AccessibleContext accessibleContext = null;</span>

    /**
     * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated
     * with this &lt;code&gt;Component&lt;/code&gt;.
     * The method implemented by this base
     * class returns null.  Classes that extend &lt;code&gt;Component&lt;/code&gt;
     * should implement this method to return the
     * &lt;code&gt;AccessibleContext&lt;/code&gt; associated with the subclass.
     *
     *
     * @return the &lt;code&gt;AccessibleContext&lt;/code&gt; of this
     *    &lt;code&gt;Component&lt;/code&gt;
     * @since 1.3
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc" id="L9032">        return accessibleContext;</span>
    }

    /**
     * Inner class of Component used to provide default support for
     * accessibility.  This class is not meant to be used directly by
     * application developers, but is instead meant only to be
     * subclassed by component developers.
     * &lt;p&gt;
     * The class used to obtain the accessible role for this object.
     * @since 1.3
     */
    protected abstract class AccessibleAWTComponent extends AccessibleContext
        implements Serializable, AccessibleComponent {

        private static final long serialVersionUID = 642321655757800191L;

        /**
         * Though the class is abstract, this should be called by
         * all sub-classes.
         */
<span class="nc" id="L9053">        protected AccessibleAWTComponent() {</span>
<span class="nc" id="L9054">        }</span>

        /**
         * Number of PropertyChangeListener objects registered. It's used
         * to add/remove ComponentListener and FocusListener to track
         * target Component's state.
         */
<span class="nc" id="L9061">        private volatile transient int propertyListenersCount = 0;</span>

<span class="nc" id="L9063">        protected ComponentListener accessibleAWTComponentHandler = null;</span>
<span class="nc" id="L9064">        protected FocusListener accessibleAWTFocusHandler = null;</span>

        /**
         * Fire PropertyChange listener, if one is registered,
         * when shown/hidden..
         * @since 1.3
         */
<span class="nc" id="L9071">        protected class AccessibleAWTComponentHandler implements ComponentListener {</span>
            public void componentHidden(ComponentEvent e)  {
<span class="nc bnc" id="L9073" title="All 2 branches missed.">                if (accessibleContext != null) {</span>
<span class="nc" id="L9074">                    accessibleContext.firePropertyChange(</span>
                                                         AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                         AccessibleState.VISIBLE, null);
                }
<span class="nc" id="L9078">            }</span>

            public void componentShown(ComponentEvent e)  {
<span class="nc bnc" id="L9081" title="All 2 branches missed.">                if (accessibleContext != null) {</span>
<span class="nc" id="L9082">                    accessibleContext.firePropertyChange(</span>
                                                         AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                         null, AccessibleState.VISIBLE);
                }
<span class="nc" id="L9086">            }</span>

            public void componentMoved(ComponentEvent e)  {
<span class="nc" id="L9089">            }</span>

            public void componentResized(ComponentEvent e)  {
<span class="nc" id="L9092">            }</span>
        } // inner class AccessibleAWTComponentHandler


        /**
         * Fire PropertyChange listener, if one is registered,
         * when focus events happen
         * @since 1.3
         */
<span class="nc" id="L9101">        protected class AccessibleAWTFocusHandler implements FocusListener {</span>
            public void focusGained(FocusEvent event) {
<span class="nc bnc" id="L9103" title="All 2 branches missed.">                if (accessibleContext != null) {</span>
<span class="nc" id="L9104">                    accessibleContext.firePropertyChange(</span>
                                                         AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                         null, AccessibleState.FOCUSED);
                }
<span class="nc" id="L9108">            }</span>
            public void focusLost(FocusEvent event) {
<span class="nc bnc" id="L9110" title="All 2 branches missed.">                if (accessibleContext != null) {</span>
<span class="nc" id="L9111">                    accessibleContext.firePropertyChange(</span>
                                                         AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                         AccessibleState.FOCUSED, null);
                }
<span class="nc" id="L9115">            }</span>
        }  // inner class AccessibleAWTFocusHandler


        /**
         * Adds a &lt;code&gt;PropertyChangeListener&lt;/code&gt; to the listener list.
         *
         * @param listener  the property change listener to be added
         */
        public void addPropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L9125" title="All 2 branches missed.">            if (accessibleAWTComponentHandler == null) {</span>
<span class="nc" id="L9126">                accessibleAWTComponentHandler = new AccessibleAWTComponentHandler();</span>
            }
<span class="nc bnc" id="L9128" title="All 2 branches missed.">            if (accessibleAWTFocusHandler == null) {</span>
<span class="nc" id="L9129">                accessibleAWTFocusHandler = new AccessibleAWTFocusHandler();</span>
            }
<span class="nc bnc" id="L9131" title="All 2 branches missed.">            if (propertyListenersCount++ == 0) {</span>
<span class="nc" id="L9132">                Component.this.addComponentListener(accessibleAWTComponentHandler);</span>
<span class="nc" id="L9133">                Component.this.addFocusListener(accessibleAWTFocusHandler);</span>
            }
<span class="nc" id="L9135">            super.addPropertyChangeListener(listener);</span>
<span class="nc" id="L9136">        }</span>

        /**
         * Remove a PropertyChangeListener from the listener list.
         * This removes a PropertyChangeListener that was registered
         * for all properties.
         *
         * @param listener  The PropertyChangeListener to be removed
         */
        public void removePropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L9146" title="All 2 branches missed.">            if (--propertyListenersCount == 0) {</span>
<span class="nc" id="L9147">                Component.this.removeComponentListener(accessibleAWTComponentHandler);</span>
<span class="nc" id="L9148">                Component.this.removeFocusListener(accessibleAWTFocusHandler);</span>
            }
<span class="nc" id="L9150">            super.removePropertyChangeListener(listener);</span>
<span class="nc" id="L9151">        }</span>

        // AccessibleContext methods
        //
        /**
         * Gets the accessible name of this object.  This should almost never
         * return &lt;code&gt;java.awt.Component.getName()&lt;/code&gt;,
         * as that generally isn't a localized name,
         * and doesn't have meaning for the user.  If the
         * object is fundamentally a text object (e.g. a menu item), the
         * accessible name should be the text of the object (e.g. &quot;save&quot;).
         * If the object has a tooltip, the tooltip text may also be an
         * appropriate String to return.
         *
         * @return the localized name of the object -- can be
         *         &lt;code&gt;null&lt;/code&gt; if this
         *         object does not have a name
         * @see javax.accessibility.AccessibleContext#setAccessibleName
         */
        public String getAccessibleName() {
<span class="nc" id="L9171">            return accessibleName;</span>
        }

        /**
         * Gets the accessible description of this object.  This should be
         * a concise, localized description of what this object is - what
         * is its meaning to the user.  If the object has a tooltip, the
         * tooltip text may be an appropriate string to return, assuming
         * it contains a concise description of the object (instead of just
         * the name of the object - e.g. a &quot;Save&quot; icon on a toolbar that
         * had &quot;save&quot; as the tooltip text shouldn't return the tooltip
         * text as the description, but something like &quot;Saves the current
         * text document&quot; instead).
         *
         * @return the localized description of the object -- can be
         *        &lt;code&gt;null&lt;/code&gt; if this object does not have a description
         * @see javax.accessibility.AccessibleContext#setAccessibleDescription
         */
        public String getAccessibleDescription() {
<span class="nc" id="L9190">            return accessibleDescription;</span>
        }

        /**
         * Gets the role of this object.
         *
         * @return an instance of &lt;code&gt;AccessibleRole&lt;/code&gt;
         *      describing the role of the object
         * @see javax.accessibility.AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L9201">            return AccessibleRole.AWT_COMPONENT;</span>
        }

        /**
         * Gets the state of this object.
         *
         * @return an instance of &lt;code&gt;AccessibleStateSet&lt;/code&gt;
         *       containing the current state set of the object
         * @see javax.accessibility.AccessibleState
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L9212">            return Component.this.getAccessibleStateSet();</span>
        }

        /**
         * Gets the &lt;code&gt;Accessible&lt;/code&gt; parent of this object.
         * If the parent of this object implements &lt;code&gt;Accessible&lt;/code&gt;,
         * this method should simply return &lt;code&gt;getParent&lt;/code&gt;.
         *
         * @return the &lt;code&gt;Accessible&lt;/code&gt; parent of this
         *      object -- can be &lt;code&gt;null&lt;/code&gt; if this
         *      object does not have an &lt;code&gt;Accessible&lt;/code&gt; parent
         */
        public Accessible getAccessibleParent() {
<span class="nc bnc" id="L9225" title="All 2 branches missed.">            if (accessibleParent != null) {</span>
<span class="nc" id="L9226">                return accessibleParent;</span>
            } else {
<span class="nc" id="L9228">                Container parent = getParent();</span>
<span class="nc bnc" id="L9229" title="All 2 branches missed.">                if (parent instanceof Accessible) {</span>
<span class="nc" id="L9230">                    return (Accessible) parent;</span>
                }
            }
<span class="nc" id="L9233">            return null;</span>
        }

        /**
         * Gets the index of this object in its accessible parent.
         *
         * @return the index of this object in its parent; or -1 if this
         *    object does not have an accessible parent
         * @see #getAccessibleParent
         */
        public int getAccessibleIndexInParent() {
<span class="nc" id="L9244">            return Component.this.getAccessibleIndexInParent();</span>
        }

        /**
         * Returns the number of accessible children in the object.  If all
         * of the children of this object implement &lt;code&gt;Accessible&lt;/code&gt;,
         * then this method should return the number of children of this object.
         *
         * @return the number of accessible children in the object
         */
        public int getAccessibleChildrenCount() {
<span class="nc" id="L9255">            return 0; // Components don't have children</span>
        }

        /**
         * Returns the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object.
         *
         * @param i zero-based index of child
         * @return the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object
         */
        public Accessible getAccessibleChild(int i) {
<span class="nc" id="L9265">            return null; // Components don't have children</span>
        }

        /**
         * Returns the locale of this object.
         *
         * @return the locale of this object
         */
        public Locale getLocale() {
<span class="nc" id="L9274">            return Component.this.getLocale();</span>
        }

        /**
         * Gets the &lt;code&gt;AccessibleComponent&lt;/code&gt; associated
         * with this object if one exists.
         * Otherwise return &lt;code&gt;null&lt;/code&gt;.
         *
         * @return the component
         */
        public AccessibleComponent getAccessibleComponent() {
<span class="nc" id="L9285">            return this;</span>
        }


        // AccessibleComponent methods
        //
        /**
         * Gets the background color of this object.
         *
         * @return the background color, if supported, of the object;
         *      otherwise, &lt;code&gt;null&lt;/code&gt;
         */
        public Color getBackground() {
<span class="nc" id="L9298">            return Component.this.getBackground();</span>
        }

        /**
         * Sets the background color of this object.
         * (For transparency, see &lt;code&gt;isOpaque&lt;/code&gt;.)
         *
         * @param c the new &lt;code&gt;Color&lt;/code&gt; for the background
         * @see Component#isOpaque
         */
        public void setBackground(Color c) {
<span class="nc" id="L9309">            Component.this.setBackground(c);</span>
<span class="nc" id="L9310">        }</span>

        /**
         * Gets the foreground color of this object.
         *
         * @return the foreground color, if supported, of the object;
         *     otherwise, &lt;code&gt;null&lt;/code&gt;
         */
        public Color getForeground() {
<span class="nc" id="L9319">            return Component.this.getForeground();</span>
        }

        /**
         * Sets the foreground color of this object.
         *
         * @param c the new &lt;code&gt;Color&lt;/code&gt; for the foreground
         */
        public void setForeground(Color c) {
<span class="nc" id="L9328">            Component.this.setForeground(c);</span>
<span class="nc" id="L9329">        }</span>

        /**
         * Gets the &lt;code&gt;Cursor&lt;/code&gt; of this object.
         *
         * @return the &lt;code&gt;Cursor&lt;/code&gt;, if supported,
         *     of the object; otherwise, &lt;code&gt;null&lt;/code&gt;
         */
        public Cursor getCursor() {
<span class="nc" id="L9338">            return Component.this.getCursor();</span>
        }

        /**
         * Sets the &lt;code&gt;Cursor&lt;/code&gt; of this object.
         * &lt;p&gt;
         * The method may have no visual effect if the Java platform
         * implementation and/or the native system do not support
         * changing the mouse cursor shape.
         * @param cursor the new &lt;code&gt;Cursor&lt;/code&gt; for the object
         */
        public void setCursor(Cursor cursor) {
<span class="nc" id="L9350">            Component.this.setCursor(cursor);</span>
<span class="nc" id="L9351">        }</span>

        /**
         * Gets the &lt;code&gt;Font&lt;/code&gt; of this object.
         *
         * @return the &lt;code&gt;Font&lt;/code&gt;, if supported,
         *    for the object; otherwise, &lt;code&gt;null&lt;/code&gt;
         */
        public Font getFont() {
<span class="nc" id="L9360">            return Component.this.getFont();</span>
        }

        /**
         * Sets the &lt;code&gt;Font&lt;/code&gt; of this object.
         *
         * @param f the new &lt;code&gt;Font&lt;/code&gt; for the object
         */
        public void setFont(Font f) {
<span class="nc" id="L9369">            Component.this.setFont(f);</span>
<span class="nc" id="L9370">        }</span>

        /**
         * Gets the &lt;code&gt;FontMetrics&lt;/code&gt; of this object.
         *
         * @param f the &lt;code&gt;Font&lt;/code&gt;
         * @return the &lt;code&gt;FontMetrics&lt;/code&gt;, if supported,
         *     the object; otherwise, &lt;code&gt;null&lt;/code&gt;
         * @see #getFont
         */
        public FontMetrics getFontMetrics(Font f) {
<span class="nc bnc" id="L9381" title="All 2 branches missed.">            if (f == null) {</span>
<span class="nc" id="L9382">                return null;</span>
            } else {
<span class="nc" id="L9384">                return Component.this.getFontMetrics(f);</span>
            }
        }

        /**
         * Determines if the object is enabled.
         *
         * @return true if object is enabled; otherwise, false
         */
        public boolean isEnabled() {
<span class="nc" id="L9394">            return Component.this.isEnabled();</span>
        }

        /**
         * Sets the enabled state of the object.
         *
         * @param b if true, enables this object; otherwise, disables it
         */
        public void setEnabled(boolean b) {
<span class="nc" id="L9403">            boolean old = Component.this.isEnabled();</span>
<span class="nc" id="L9404">            Component.this.setEnabled(b);</span>
<span class="nc bnc" id="L9405" title="All 2 branches missed.">            if (b != old) {</span>
<span class="nc bnc" id="L9406" title="All 2 branches missed.">                if (accessibleContext != null) {</span>
<span class="nc bnc" id="L9407" title="All 2 branches missed.">                    if (b) {</span>
<span class="nc" id="L9408">                        accessibleContext.firePropertyChange(</span>
                                                             AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                             null, AccessibleState.ENABLED);
                    } else {
<span class="nc" id="L9412">                        accessibleContext.firePropertyChange(</span>
                                                             AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                             AccessibleState.ENABLED, null);
                    }
                }
            }
<span class="nc" id="L9418">        }</span>

        /**
         * Determines if the object is visible.  Note: this means that the
         * object intends to be visible; however, it may not in fact be
         * showing on the screen because one of the objects that this object
         * is contained by is not visible.  To determine if an object is
         * showing on the screen, use &lt;code&gt;isShowing&lt;/code&gt;.
         *
         * @return true if object is visible; otherwise, false
         */
        public boolean isVisible() {
<span class="nc" id="L9430">            return Component.this.isVisible();</span>
        }

        /**
         * Sets the visible state of the object.
         *
         * @param b if true, shows this object; otherwise, hides it
         */
        public void setVisible(boolean b) {
<span class="nc" id="L9439">            boolean old = Component.this.isVisible();</span>
<span class="nc" id="L9440">            Component.this.setVisible(b);</span>
<span class="nc bnc" id="L9441" title="All 2 branches missed.">            if (b != old) {</span>
<span class="nc bnc" id="L9442" title="All 2 branches missed.">                if (accessibleContext != null) {</span>
<span class="nc bnc" id="L9443" title="All 2 branches missed.">                    if (b) {</span>
<span class="nc" id="L9444">                        accessibleContext.firePropertyChange(</span>
                                                             AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                             null, AccessibleState.VISIBLE);
                    } else {
<span class="nc" id="L9448">                        accessibleContext.firePropertyChange(</span>
                                                             AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                             AccessibleState.VISIBLE, null);
                    }
                }
            }
<span class="nc" id="L9454">        }</span>

        /**
         * Determines if the object is showing.  This is determined by checking
         * the visibility of the object and ancestors of the object.  Note:
         * this will return true even if the object is obscured by another
         * (for example, it happens to be underneath a menu that was pulled
         * down).
         *
         * @return true if object is showing; otherwise, false
         */
        public boolean isShowing() {
<span class="nc" id="L9466">            return Component.this.isShowing();</span>
        }

        /**
         * Checks whether the specified point is within this object's bounds,
         * where the point's x and y coordinates are defined to be relative to
         * the coordinate system of the object.
         *
         * @param p the &lt;code&gt;Point&lt;/code&gt; relative to the
         *     coordinate system of the object
         * @return true if object contains &lt;code&gt;Point&lt;/code&gt;; otherwise false
         */
        public boolean contains(Point p) {
<span class="nc" id="L9479">            return Component.this.contains(p);</span>
        }

        /**
         * Returns the location of the object on the screen.
         *
         * @return location of object on screen -- can be
         *    &lt;code&gt;null&lt;/code&gt; if this object is not on the screen
         */
        public Point getLocationOnScreen() {
<span class="nc" id="L9489">            synchronized (Component.this.getTreeLock()) {</span>
<span class="nc bnc" id="L9490" title="All 2 branches missed.">                if (Component.this.isShowing()) {</span>
<span class="nc" id="L9491">                    return Component.this.getLocationOnScreen();</span>
                } else {
<span class="nc" id="L9493">                    return null;</span>
                }
<span class="nc" id="L9495">            }</span>
        }

        /**
         * Gets the location of the object relative to the parent in the form
         * of a point specifying the object's top-left corner in the screen's
         * coordinate space.
         *
         * @return an instance of Point representing the top-left corner of
         * the object's bounds in the coordinate space of the screen;
         * &lt;code&gt;null&lt;/code&gt; if this object or its parent are not on the screen
         */
        public Point getLocation() {
<span class="nc" id="L9508">            return Component.this.getLocation();</span>
        }

        /**
         * Sets the location of the object relative to the parent.
         * @param p  the coordinates of the object
         */
        public void setLocation(Point p) {
<span class="nc" id="L9516">            Component.this.setLocation(p);</span>
<span class="nc" id="L9517">        }</span>

        /**
         * Gets the bounds of this object in the form of a Rectangle object.
         * The bounds specify this object's width, height, and location
         * relative to its parent.
         *
         * @return a rectangle indicating this component's bounds;
         *   &lt;code&gt;null&lt;/code&gt; if this object is not on the screen
         */
        public Rectangle getBounds() {
<span class="nc" id="L9528">            return Component.this.getBounds();</span>
        }

        /**
         * Sets the bounds of this object in the form of a
         * &lt;code&gt;Rectangle&lt;/code&gt; object.
         * The bounds specify this object's width, height, and location
         * relative to its parent.
         *
         * @param r a rectangle indicating this component's bounds
         */
        public void setBounds(Rectangle r) {
<span class="nc" id="L9540">            Component.this.setBounds(r);</span>
<span class="nc" id="L9541">        }</span>

        /**
         * Returns the size of this object in the form of a
         * &lt;code&gt;Dimension&lt;/code&gt; object. The height field of the
         * &lt;code&gt;Dimension&lt;/code&gt; object contains this objects's
         * height, and the width field of the &lt;code&gt;Dimension&lt;/code&gt;
         * object contains this object's width.
         *
         * @return a &lt;code&gt;Dimension&lt;/code&gt; object that indicates
         *     the size of this component; &lt;code&gt;null&lt;/code&gt; if
         *     this object is not on the screen
         */
        public Dimension getSize() {
<span class="nc" id="L9555">            return Component.this.getSize();</span>
        }

        /**
         * Resizes this object so that it has width and height.
         *
         * @param d - the dimension specifying the new size of the object
         */
        public void setSize(Dimension d) {
<span class="nc" id="L9564">            Component.this.setSize(d);</span>
<span class="nc" id="L9565">        }</span>

        /**
         * Returns the &lt;code&gt;Accessible&lt;/code&gt; child,
         * if one exists, contained at the local
         * coordinate &lt;code&gt;Point&lt;/code&gt;.  Otherwise returns
         * &lt;code&gt;null&lt;/code&gt;.
         *
         * @param p the point defining the top-left corner of
         *      the &lt;code&gt;Accessible&lt;/code&gt;, given in the
         *      coordinate space of the object's parent
         * @return the &lt;code&gt;Accessible&lt;/code&gt;, if it exists,
         *      at the specified location; else &lt;code&gt;null&lt;/code&gt;
         */
        public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L9580">            return null; // Components don't have children</span>
        }

        /**
         * Returns whether this object can accept focus or not.
         *
         * @return true if object can accept focus; otherwise false
         */
        public boolean isFocusTraversable() {
<span class="nc" id="L9589">            return Component.this.isFocusTraversable();</span>
        }

        /**
         * Requests focus for this object.
         */
        public void requestFocus() {
<span class="nc" id="L9596">            Component.this.requestFocus();</span>
<span class="nc" id="L9597">        }</span>

        /**
         * Adds the specified focus listener to receive focus events from this
         * component.
         *
         * @param l the focus listener
         */
        public void addFocusListener(FocusListener l) {
<span class="nc" id="L9606">            Component.this.addFocusListener(l);</span>
<span class="nc" id="L9607">        }</span>

        /**
         * Removes the specified focus listener so it no longer receives focus
         * events from this component.
         *
         * @param l the focus listener
         */
        public void removeFocusListener(FocusListener l) {
<span class="nc" id="L9616">            Component.this.removeFocusListener(l);</span>
<span class="nc" id="L9617">        }</span>

    } // inner class AccessibleAWTComponent


    /**
     * Gets the index of this object in its accessible parent.
     * If this object does not have an accessible parent, returns
     * -1.
     *
     * @return the index of this object in its accessible parent
     */
    int getAccessibleIndexInParent() {
<span class="nc" id="L9630">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L9631">            int index = -1;</span>
<span class="nc" id="L9632">            Container parent = this.getParent();</span>
<span class="nc bnc" id="L9633" title="All 4 branches missed.">            if (parent != null &amp;&amp; parent instanceof Accessible) {</span>
<span class="nc" id="L9634">                Component ca[] = parent.getComponents();</span>
<span class="nc bnc" id="L9635" title="All 2 branches missed.">                for (int i = 0; i &lt; ca.length; i++) {</span>
<span class="nc bnc" id="L9636" title="All 2 branches missed.">                    if (ca[i] instanceof Accessible) {</span>
<span class="nc" id="L9637">                        index++;</span>
                    }
<span class="nc bnc" id="L9639" title="All 2 branches missed.">                    if (this.equals(ca[i])) {</span>
<span class="nc" id="L9640">                        return index;</span>
                    }
                }
            }
<span class="nc" id="L9644">            return -1;</span>
<span class="nc" id="L9645">        }</span>
    }

    /**
     * Gets the current state set of this object.
     *
     * @return an instance of &lt;code&gt;AccessibleStateSet&lt;/code&gt;
     *    containing the current state set of the object
     * @see AccessibleState
     */
    AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L9656">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L9657">            AccessibleStateSet states = new AccessibleStateSet();</span>
<span class="nc bnc" id="L9658" title="All 2 branches missed.">            if (this.isEnabled()) {</span>
<span class="nc" id="L9659">                states.add(AccessibleState.ENABLED);</span>
            }
<span class="nc bnc" id="L9661" title="All 2 branches missed.">            if (this.isFocusTraversable()) {</span>
<span class="nc" id="L9662">                states.add(AccessibleState.FOCUSABLE);</span>
            }
<span class="nc bnc" id="L9664" title="All 2 branches missed.">            if (this.isVisible()) {</span>
<span class="nc" id="L9665">                states.add(AccessibleState.VISIBLE);</span>
            }
<span class="nc bnc" id="L9667" title="All 2 branches missed.">            if (this.isShowing()) {</span>
<span class="nc" id="L9668">                states.add(AccessibleState.SHOWING);</span>
            }
<span class="nc bnc" id="L9670" title="All 2 branches missed.">            if (this.isFocusOwner()) {</span>
<span class="nc" id="L9671">                states.add(AccessibleState.FOCUSED);</span>
            }
<span class="nc bnc" id="L9673" title="All 2 branches missed.">            if (this instanceof Accessible) {</span>
<span class="nc" id="L9674">                AccessibleContext ac = ((Accessible) this).getAccessibleContext();</span>
<span class="nc bnc" id="L9675" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L9676">                    Accessible ap = ac.getAccessibleParent();</span>
<span class="nc bnc" id="L9677" title="All 2 branches missed.">                    if (ap != null) {</span>
<span class="nc" id="L9678">                        AccessibleContext pac = ap.getAccessibleContext();</span>
<span class="nc bnc" id="L9679" title="All 2 branches missed.">                        if (pac != null) {</span>
<span class="nc" id="L9680">                            AccessibleSelection as = pac.getAccessibleSelection();</span>
<span class="nc bnc" id="L9681" title="All 2 branches missed.">                            if (as != null) {</span>
<span class="nc" id="L9682">                                states.add(AccessibleState.SELECTABLE);</span>
<span class="nc" id="L9683">                                int i = ac.getAccessibleIndexInParent();</span>
<span class="nc bnc" id="L9684" title="All 2 branches missed.">                                if (i &gt;= 0) {</span>
<span class="nc bnc" id="L9685" title="All 2 branches missed.">                                    if (as.isAccessibleChildSelected(i)) {</span>
<span class="nc" id="L9686">                                        states.add(AccessibleState.SELECTED);</span>
                                    }
                                }
                            }
                        }
                    }
                }
            }
<span class="nc bnc" id="L9694" title="All 2 branches missed.">            if (Component.isInstanceOf(this, &quot;javax.swing.JComponent&quot;)) {</span>
<span class="nc bnc" id="L9695" title="All 2 branches missed.">                if (((javax.swing.JComponent) this).isOpaque()) {</span>
<span class="nc" id="L9696">                    states.add(AccessibleState.OPAQUE);</span>
                }
            }
<span class="nc" id="L9699">            return states;</span>
<span class="nc" id="L9700">        }</span>
    }

    /**
     * Checks that the given object is instance of the given class.
     * @param obj Object to be checked
     * @param className The name of the class. Must be fully-qualified class name.
     * @return true, if this object is instanceof given class,
     *         false, otherwise, or if obj or className is null
     */
    static boolean isInstanceOf(Object obj, String className) {
<span class="nc bnc" id="L9711" title="All 2 branches missed.">        if (obj == null) return false;</span>
<span class="nc bnc" id="L9712" title="All 2 branches missed.">        if (className == null) return false;</span>

<span class="nc" id="L9714">        Class&lt;?&gt; cls = obj.getClass();</span>
<span class="nc bnc" id="L9715" title="All 2 branches missed.">        while (cls != null) {</span>
<span class="nc bnc" id="L9716" title="All 2 branches missed.">            if (cls.getName().equals(className)) {</span>
<span class="nc" id="L9717">                return true;</span>
            }
<span class="nc" id="L9719">            cls = cls.getSuperclass();</span>
        }
<span class="nc" id="L9721">        return false;</span>
    }


    // ************************** MIXING CODE *******************************

    /**
     * Check whether we can trust the current bounds of the component.
     * The return value of false indicates that the container of the
     * component is invalid, and therefore needs to be layed out, which would
     * probably mean changing the bounds of its children.
     * Null-layout of the container or absence of the container mean
     * the bounds of the component are final and can be trusted.
     */
    final boolean areBoundsValid() {
<span class="nc" id="L9736">        Container cont = getContainer();</span>
<span class="nc bnc" id="L9737" title="All 6 branches missed.">        return cont == null || cont.isValid() || cont.getLayout() == null;</span>
    }

    /**
     * Applies the shape to the component
     * @param shape Shape to be applied to the component
     */
    void applyCompoundShape(Region shape) {
<span class="nc" id="L9745">        checkTreeLock();</span>

<span class="nc bnc" id="L9747" title="All 2 branches missed.">        if (!areBoundsValid()) {</span>
<span class="nc bnc" id="L9748" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L9749">                mixingLog.fine(&quot;this = &quot; + this + &quot;; areBoundsValid = &quot; + areBoundsValid());</span>
            }
<span class="nc" id="L9751">            return;</span>
        }

<span class="nc bnc" id="L9754" title="All 2 branches missed.">        if (!isLightweight()) {</span>
<span class="nc" id="L9755">            ComponentPeer peer = getPeer();</span>
<span class="nc bnc" id="L9756" title="All 2 branches missed.">            if (peer != null) {</span>
                // The Region class has some optimizations. That's why
                // we should manually check whether it's empty and
                // substitute the object ourselves. Otherwise we end up
                // with some incorrect Region object with loX being
                // greater than the hiX for instance.
<span class="nc bnc" id="L9762" title="All 2 branches missed.">                if (shape.isEmpty()) {</span>
<span class="nc" id="L9763">                    shape = Region.EMPTY_REGION;</span>
                }


                // Note: the shape is not really copied/cloned. We create
                // the Region object ourselves, so there's no any possibility
                // to modify the object outside of the mixing code.
                // Nullifying compoundShape means that the component has normal shape
                // (or has no shape at all).
<span class="nc bnc" id="L9772" title="All 2 branches missed.">                if (shape.equals(getNormalShape())) {</span>
<span class="nc bnc" id="L9773" title="All 2 branches missed.">                    if (this.compoundShape == null) {</span>
<span class="nc" id="L9774">                        return;</span>
                    }
<span class="nc" id="L9776">                    this.compoundShape = null;</span>
<span class="nc" id="L9777">                    peer.applyShape(null);</span>
                } else {
<span class="nc bnc" id="L9779" title="All 2 branches missed.">                    if (shape.equals(getAppliedShape())) {</span>
<span class="nc" id="L9780">                        return;</span>
                    }
<span class="nc" id="L9782">                    this.compoundShape = shape;</span>
<span class="nc" id="L9783">                    Point compAbsolute = getLocationOnWindow();</span>
<span class="nc bnc" id="L9784" title="All 2 branches missed.">                    if (mixingLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L9785">                        mixingLog.fine(&quot;this = &quot; + this +</span>
                                &quot;; compAbsolute=&quot; + compAbsolute + &quot;; shape=&quot; + shape);
                    }
<span class="nc" id="L9788">                    peer.applyShape(shape.getTranslatedRegion(-compAbsolute.x, -compAbsolute.y));</span>
                }
            }
        }
<span class="nc" id="L9792">    }</span>

    /**
     * Returns the shape previously set with applyCompoundShape().
     * If the component is LW or no shape was applied yet,
     * the method returns the normal shape.
     */
    private Region getAppliedShape() {
<span class="nc" id="L9800">        checkTreeLock();</span>
        //XXX: if we allow LW components to have a shape, this must be changed
<span class="nc bnc" id="L9802" title="All 4 branches missed.">        return (this.compoundShape == null || isLightweight()) ? getNormalShape() : this.compoundShape;</span>
    }

    Point getLocationOnWindow() {
<span class="nc" id="L9806">        checkTreeLock();</span>
<span class="nc" id="L9807">        Point curLocation = getLocation();</span>

<span class="nc" id="L9809">        for (Container parent = getContainer();</span>
<span class="nc bnc" id="L9810" title="All 4 branches missed.">                parent != null &amp;&amp; !(parent instanceof Window);</span>
<span class="nc" id="L9811">                parent = parent.getContainer())</span>
        {
<span class="nc" id="L9813">            curLocation.x += parent.getX();</span>
<span class="nc" id="L9814">            curLocation.y += parent.getY();</span>
        }

<span class="nc" id="L9817">        return curLocation;</span>
    }

    /**
     * Returns the full shape of the component located in window coordinates
     */
    final Region getNormalShape() {
<span class="nc" id="L9824">        checkTreeLock();</span>
        //XXX: we may take into account a user-specified shape for this component
<span class="nc" id="L9826">        Point compAbsolute = getLocationOnWindow();</span>
<span class="nc" id="L9827">        return</span>
<span class="nc" id="L9828">            Region.getInstanceXYWH(</span>
                    compAbsolute.x,
                    compAbsolute.y,
<span class="nc" id="L9831">                    getWidth(),</span>
<span class="nc" id="L9832">                    getHeight()</span>
            );
    }

    /**
     * Returns the &quot;opaque shape&quot; of the component.
     *
     * The opaque shape of a lightweight components is the actual shape that
     * needs to be cut off of the heavyweight components in order to mix this
     * lightweight component correctly with them.
     *
     * The method is overriden in the java.awt.Container to handle non-opaque
     * containers containing opaque children.
     *
     * See 6637655 for details.
     */
    Region getOpaqueShape() {
<span class="nc" id="L9849">        checkTreeLock();</span>
<span class="nc bnc" id="L9850" title="All 2 branches missed.">        if (mixingCutoutRegion != null) {</span>
<span class="nc" id="L9851">            return mixingCutoutRegion;</span>
        } else {
<span class="nc" id="L9853">            return getNormalShape();</span>
        }
    }

    final int getSiblingIndexAbove() {
<span class="nc" id="L9858">        checkTreeLock();</span>
<span class="nc" id="L9859">        Container parent = getContainer();</span>
<span class="nc bnc" id="L9860" title="All 2 branches missed.">        if (parent == null) {</span>
<span class="nc" id="L9861">            return -1;</span>
        }

<span class="nc" id="L9864">        int nextAbove = parent.getComponentZOrder(this) - 1;</span>

<span class="nc bnc" id="L9866" title="All 2 branches missed.">        return nextAbove &lt; 0 ? -1 : nextAbove;</span>
    }

    final ComponentPeer getHWPeerAboveMe() {
<span class="nc" id="L9870">        checkTreeLock();</span>

<span class="nc" id="L9872">        Container cont = getContainer();</span>
<span class="nc" id="L9873">        int indexAbove = getSiblingIndexAbove();</span>

<span class="nc bnc" id="L9875" title="All 2 branches missed.">        while (cont != null) {</span>
<span class="nc bnc" id="L9876" title="All 2 branches missed.">            for (int i = indexAbove; i &gt; -1; i--) {</span>
<span class="nc" id="L9877">                Component comp = cont.getComponent(i);</span>
<span class="nc bnc" id="L9878" title="All 6 branches missed.">                if (comp != null &amp;&amp; comp.isDisplayable() &amp;&amp; !comp.isLightweight()) {</span>
<span class="nc" id="L9879">                    return comp.getPeer();</span>
                }
            }
            // traversing the hierarchy up to the closest HW container;
            // further traversing may return a component that is not actually
            // a native sibling of this component and this kind of z-order
            // request may not be allowed by the underlying system (6852051).
<span class="nc bnc" id="L9886" title="All 2 branches missed.">            if (!cont.isLightweight()) {</span>
<span class="nc" id="L9887">                break;</span>
            }

<span class="nc" id="L9890">            indexAbove = cont.getSiblingIndexAbove();</span>
<span class="nc" id="L9891">            cont = cont.getContainer();</span>
        }

<span class="nc" id="L9894">        return null;</span>
    }

    final int getSiblingIndexBelow() {
<span class="nc" id="L9898">        checkTreeLock();</span>
<span class="nc" id="L9899">        Container parent = getContainer();</span>
<span class="nc bnc" id="L9900" title="All 2 branches missed.">        if (parent == null) {</span>
<span class="nc" id="L9901">            return -1;</span>
        }

<span class="nc" id="L9904">        int nextBelow = parent.getComponentZOrder(this) + 1;</span>

<span class="nc bnc" id="L9906" title="All 2 branches missed.">        return nextBelow &gt;= parent.getComponentCount() ? -1 : nextBelow;</span>
    }

    final boolean isNonOpaqueForMixing() {
<span class="nc bnc" id="L9910" title="All 2 branches missed.">        return mixingCutoutRegion != null &amp;&amp;</span>
<span class="nc bnc" id="L9911" title="All 2 branches missed.">            mixingCutoutRegion.isEmpty();</span>
    }

    private Region calculateCurrentShape() {
<span class="nc" id="L9915">        checkTreeLock();</span>
<span class="nc" id="L9916">        Region s = getNormalShape();</span>

<span class="nc bnc" id="L9918" title="All 2 branches missed.">        if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L9919">            mixingLog.fine(&quot;this = &quot; + this + &quot;; normalShape=&quot; + s);</span>
        }

<span class="nc bnc" id="L9922" title="All 2 branches missed.">        if (getContainer() != null) {</span>
<span class="nc" id="L9923">            Component comp = this;</span>
<span class="nc" id="L9924">            Container cont = comp.getContainer();</span>

<span class="nc bnc" id="L9926" title="All 2 branches missed.">            while (cont != null) {</span>
<span class="nc bnc" id="L9927" title="All 2 branches missed.">                for (int index = comp.getSiblingIndexAbove(); index != -1; --index) {</span>
                    /* It is assumed that:
                     *
                     *    getComponent(getContainer().getComponentZOrder(comp)) == comp
                     *
                     * The assumption has been made according to the current
                     * implementation of the Container class.
                     */
<span class="nc" id="L9935">                    Component c = cont.getComponent(index);</span>
<span class="nc bnc" id="L9936" title="All 4 branches missed.">                    if (c.isLightweight() &amp;&amp; c.isShowing()) {</span>
<span class="nc" id="L9937">                        s = s.getDifference(c.getOpaqueShape());</span>
                    }
                }

<span class="nc bnc" id="L9941" title="All 2 branches missed.">                if (cont.isLightweight()) {</span>
<span class="nc" id="L9942">                    s = s.getIntersection(cont.getNormalShape());</span>
                } else {
                    break;
                }

<span class="nc" id="L9947">                comp = cont;</span>
<span class="nc" id="L9948">                cont = cont.getContainer();</span>
            }
        }

<span class="nc bnc" id="L9952" title="All 2 branches missed.">        if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L9953">            mixingLog.fine(&quot;currentShape=&quot; + s);</span>
        }

<span class="nc" id="L9956">        return s;</span>
    }

    void applyCurrentShape() {
<span class="nc" id="L9960">        checkTreeLock();</span>
<span class="nc bnc" id="L9961" title="All 2 branches missed.">        if (!areBoundsValid()) {</span>
<span class="nc bnc" id="L9962" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L9963">                mixingLog.fine(&quot;this = &quot; + this + &quot;; areBoundsValid = &quot; + areBoundsValid());</span>
            }
<span class="nc" id="L9965">            return; // Because applyCompoundShape() ignores such components anyway</span>
        }
<span class="nc bnc" id="L9967" title="All 2 branches missed.">        if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L9968">            mixingLog.fine(&quot;this = &quot; + this);</span>
        }
<span class="nc" id="L9970">        applyCompoundShape(calculateCurrentShape());</span>
<span class="nc" id="L9971">    }</span>

    final void subtractAndApplyShape(Region s) {
<span class="nc" id="L9974">        checkTreeLock();</span>

<span class="nc bnc" id="L9976" title="All 2 branches missed.">        if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L9977">            mixingLog.fine(&quot;this = &quot; + this + &quot;; s=&quot; + s);</span>
        }

<span class="nc" id="L9980">        applyCompoundShape(getAppliedShape().getDifference(s));</span>
<span class="nc" id="L9981">    }</span>

    private final void applyCurrentShapeBelowMe() {
<span class="nc" id="L9984">        checkTreeLock();</span>
<span class="nc" id="L9985">        Container parent = getContainer();</span>
<span class="nc bnc" id="L9986" title="All 4 branches missed.">        if (parent != null &amp;&amp; parent.isShowing()) {</span>
            // First, reapply shapes of my siblings
<span class="nc" id="L9988">            parent.recursiveApplyCurrentShape(getSiblingIndexBelow());</span>

            // Second, if my container is non-opaque, reapply shapes of siblings of my container
<span class="nc" id="L9991">            Container parent2 = parent.getContainer();</span>
<span class="nc bnc" id="L9992" title="All 4 branches missed.">            while (!parent.isOpaque() &amp;&amp; parent2 != null) {</span>
<span class="nc" id="L9993">                parent2.recursiveApplyCurrentShape(parent.getSiblingIndexBelow());</span>

<span class="nc" id="L9995">                parent = parent2;</span>
<span class="nc" id="L9996">                parent2 = parent.getContainer();</span>
            }
        }
<span class="nc" id="L9999">    }</span>

    final void subtractAndApplyShapeBelowMe() {
<span class="nc" id="L10002">        checkTreeLock();</span>
<span class="nc" id="L10003">        Container parent = getContainer();</span>
<span class="nc bnc" id="L10004" title="All 4 branches missed.">        if (parent != null &amp;&amp; isShowing()) {</span>
<span class="nc" id="L10005">            Region opaqueShape = getOpaqueShape();</span>

            // First, cut my siblings
<span class="nc" id="L10008">            parent.recursiveSubtractAndApplyShape(opaqueShape, getSiblingIndexBelow());</span>

            // Second, if my container is non-opaque, cut siblings of my container
<span class="nc" id="L10011">            Container parent2 = parent.getContainer();</span>
<span class="nc bnc" id="L10012" title="All 4 branches missed.">            while (!parent.isOpaque() &amp;&amp; parent2 != null) {</span>
<span class="nc" id="L10013">                parent2.recursiveSubtractAndApplyShape(opaqueShape, parent.getSiblingIndexBelow());</span>

<span class="nc" id="L10015">                parent = parent2;</span>
<span class="nc" id="L10016">                parent2 = parent.getContainer();</span>
            }
        }
<span class="nc" id="L10019">    }</span>

    void mixOnShowing() {
<span class="nc" id="L10022">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L10023" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L10024">                mixingLog.fine(&quot;this = &quot; + this);</span>
            }
<span class="nc bnc" id="L10026" title="All 2 branches missed.">            if (!isMixingNeeded()) {</span>
<span class="nc" id="L10027">                return;</span>
            }
<span class="nc bnc" id="L10029" title="All 2 branches missed.">            if (isLightweight()) {</span>
<span class="nc" id="L10030">                subtractAndApplyShapeBelowMe();</span>
            } else {
<span class="nc" id="L10032">                applyCurrentShape();</span>
            }
<span class="nc" id="L10034">        }</span>
<span class="nc" id="L10035">    }</span>

    void mixOnHiding(boolean isLightweight) {
        // We cannot be sure that the peer exists at this point, so we need the argument
        //    to find out whether the hiding component is (well, actually was) a LW or a HW.
<span class="nc" id="L10040">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L10041" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L10042">                mixingLog.fine(&quot;this = &quot; + this + &quot;; isLightweight = &quot; + isLightweight);</span>
            }
<span class="nc bnc" id="L10044" title="All 2 branches missed.">            if (!isMixingNeeded()) {</span>
<span class="nc" id="L10045">                return;</span>
            }
<span class="nc bnc" id="L10047" title="All 2 branches missed.">            if (isLightweight) {</span>
<span class="nc" id="L10048">                applyCurrentShapeBelowMe();</span>
            }
<span class="nc" id="L10050">        }</span>
<span class="nc" id="L10051">    }</span>

    void mixOnReshaping() {
<span class="nc" id="L10054">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L10055" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L10056">                mixingLog.fine(&quot;this = &quot; + this);</span>
            }
<span class="nc bnc" id="L10058" title="All 2 branches missed.">            if (!isMixingNeeded()) {</span>
<span class="nc" id="L10059">                return;</span>
            }
<span class="nc bnc" id="L10061" title="All 2 branches missed.">            if (isLightweight()) {</span>
<span class="nc" id="L10062">                applyCurrentShapeBelowMe();</span>
            } else {
<span class="nc" id="L10064">                applyCurrentShape();</span>
            }
<span class="nc" id="L10066">        }</span>
<span class="nc" id="L10067">    }</span>

    void mixOnZOrderChanging(int oldZorder, int newZorder) {
<span class="nc" id="L10070">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L10071" title="All 2 branches missed.">            boolean becameHigher = newZorder &lt; oldZorder;</span>
<span class="nc" id="L10072">            Container parent = getContainer();</span>

<span class="nc bnc" id="L10074" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L10075">                mixingLog.fine(&quot;this = &quot; + this +</span>
                    &quot;; oldZorder=&quot; + oldZorder + &quot;; newZorder=&quot; + newZorder + &quot;; parent=&quot; + parent);
            }
<span class="nc bnc" id="L10078" title="All 2 branches missed.">            if (!isMixingNeeded()) {</span>
<span class="nc" id="L10079">                return;</span>
            }
<span class="nc bnc" id="L10081" title="All 2 branches missed.">            if (isLightweight()) {</span>
<span class="nc bnc" id="L10082" title="All 2 branches missed.">                if (becameHigher) {</span>
<span class="nc bnc" id="L10083" title="All 4 branches missed.">                    if (parent != null &amp;&amp; isShowing()) {</span>
<span class="nc" id="L10084">                        parent.recursiveSubtractAndApplyShape(getOpaqueShape(), getSiblingIndexBelow(), oldZorder);</span>
                    }
                } else {
<span class="nc bnc" id="L10087" title="All 2 branches missed.">                    if (parent != null) {</span>
<span class="nc" id="L10088">                        parent.recursiveApplyCurrentShape(oldZorder, newZorder);</span>
                    }
                }
            } else {
<span class="nc bnc" id="L10092" title="All 2 branches missed.">                if (becameHigher) {</span>
<span class="nc" id="L10093">                    applyCurrentShape();</span>
                } else {
<span class="nc bnc" id="L10095" title="All 2 branches missed.">                    if (parent != null) {</span>
<span class="nc" id="L10096">                        Region shape = getAppliedShape();</span>

<span class="nc bnc" id="L10098" title="All 2 branches missed.">                        for (int index = oldZorder; index &lt; newZorder; index++) {</span>
<span class="nc" id="L10099">                            Component c = parent.getComponent(index);</span>
<span class="nc bnc" id="L10100" title="All 4 branches missed.">                            if (c.isLightweight() &amp;&amp; c.isShowing()) {</span>
<span class="nc" id="L10101">                                shape = shape.getDifference(c.getOpaqueShape());</span>
                            }
                        }
<span class="nc" id="L10104">                        applyCompoundShape(shape);</span>
                    }
                }
            }
<span class="nc" id="L10108">        }</span>
<span class="nc" id="L10109">    }</span>

    void mixOnValidating() {
        // This method gets overriden in the Container. Obviously, a plain
        // non-container components don't need to handle validation.
<span class="nc" id="L10114">    }</span>

    final boolean isMixingNeeded() {
<span class="nc bnc" id="L10117" title="All 2 branches missed.">        if (SunToolkit.getSunAwtDisableMixing()) {</span>
<span class="nc bnc" id="L10118" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L10119">                mixingLog.finest(&quot;this = &quot; + this + &quot;; Mixing disabled via sun.awt.disableMixing&quot;);</span>
            }
<span class="nc" id="L10121">            return false;</span>
        }
<span class="nc bnc" id="L10123" title="All 2 branches missed.">        if (!areBoundsValid()) {</span>
<span class="nc bnc" id="L10124" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L10125">                mixingLog.fine(&quot;this = &quot; + this + &quot;; areBoundsValid = &quot; + areBoundsValid());</span>
            }
<span class="nc" id="L10127">            return false;</span>
        }
<span class="nc" id="L10129">        Window window = getContainingWindow();</span>
<span class="nc bnc" id="L10130" title="All 2 branches missed.">        if (window != null) {</span>
<span class="nc bnc" id="L10131" title="All 6 branches missed.">            if (!window.hasHeavyweightDescendants() || !window.hasLightweightDescendants() || window.isDisposing()) {</span>
<span class="nc bnc" id="L10132" title="All 2 branches missed.">                if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L10133">                    mixingLog.fine(&quot;containing window = &quot; + window +</span>
<span class="nc" id="L10134">                            &quot;; has h/w descendants = &quot; + window.hasHeavyweightDescendants() +</span>
<span class="nc" id="L10135">                            &quot;; has l/w descendants = &quot; + window.hasLightweightDescendants() +</span>
<span class="nc" id="L10136">                            &quot;; disposing = &quot; + window.isDisposing());</span>
                }
<span class="nc" id="L10138">                return false;</span>
            }
        } else {
<span class="nc bnc" id="L10141" title="All 2 branches missed.">            if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L10142">                mixingLog.fine(&quot;this = &quot; + this + &quot;; containing window is null&quot;);</span>
            }
<span class="nc" id="L10144">            return false;</span>
        }
<span class="nc" id="L10146">        return true;</span>
    }

    // ****************** END OF MIXING CODE ********************************

    // Note that the method is overriden in the Window class,
    // a window doesn't need to be updated in the Z-order.
    void updateZOrder() {
<span class="nc" id="L10154">        peer.setZOrder(getHWPeerAboveMe());</span>
<span class="nc" id="L10155">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>