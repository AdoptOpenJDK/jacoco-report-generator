<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>KeyboardFocusManager.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">KeyboardFocusManager.java</span></div><h1>KeyboardFocusManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt;

import java.awt.event.FocusEvent;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowEvent;

import java.awt.peer.KeyboardFocusManagerPeer;
import java.awt.peer.LightweightPeer;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.PropertyVetoException;
import java.beans.VetoableChangeListener;
import java.beans.VetoableChangeSupport;

import java.lang.ref.WeakReference;

import java.lang.reflect.Field;

import java.security.AccessController;
import java.security.PrivilegedAction;

import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.WeakHashMap;

import sun.util.logging.PlatformLogger;

import sun.awt.AppContext;
import sun.awt.SunToolkit;
import sun.awt.CausedFocusEvent;
import sun.awt.KeyboardFocusManagerPeerProvider;
import sun.awt.AWTAccessor;

/**
 * The KeyboardFocusManager is responsible for managing the active and focused
 * Windows, and the current focus owner. The focus owner is defined as the
 * Component in an application that will typically receive all KeyEvents
 * generated by the user. The focused Window is the Window that is, or
 * contains, the focus owner. Only a Frame or a Dialog can be the active
 * Window. The native windowing system may denote the active Window or its
 * children with special decorations, such as a highlighted title bar. The
 * active Window is always either the focused Window, or the first Frame or
 * Dialog that is an owner of the focused Window.
 * &lt;p&gt;
 * The KeyboardFocusManager is both a centralized location for client code to
 * query for the focus owner and initiate focus changes, and an event
 * dispatcher for all FocusEvents, WindowEvents related to focus, and
 * KeyEvents.
 * &lt;p&gt;
 * Some browsers partition applets in different code bases into separate
 * contexts, and establish walls between these contexts. In such a scenario,
 * there will be one KeyboardFocusManager per context. Other browsers place all
 * applets into the same context, implying that there will be only a single,
 * global KeyboardFocusManager for all applets. This behavior is
 * implementation-dependent. Consult your browser's documentation for more
 * information. No matter how many contexts there may be, however, there can
 * never be more than one focus owner, focused Window, or active Window, per
 * ClassLoader.
 * &lt;p&gt;
 * Please see
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
 * How to Use the Focus Subsystem&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
 * &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
 * for more information.
 *
 * @author David Mendenhall
 *
 * @see Window
 * @see Frame
 * @see Dialog
 * @see java.awt.event.FocusEvent
 * @see java.awt.event.WindowEvent
 * @see java.awt.event.KeyEvent
 * @since 1.4
 */
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">public abstract class KeyboardFocusManager</span>
    implements KeyEventDispatcher, KeyEventPostProcessor
{

    // Shared focus engine logger
<span class="fc" id="L112">    private static final PlatformLogger focusLog = PlatformLogger.getLogger(&quot;java.awt.focus.KeyboardFocusManager&quot;);</span>

    static {
        /* ensure that the necessary native libraries are loaded */
<span class="fc" id="L116">        Toolkit.loadLibraries();</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L118">            initIDs();</span>
        }
<span class="fc" id="L120">        AWTAccessor.setKeyboardFocusManagerAccessor(</span>
<span class="fc" id="L121">            new AWTAccessor.KeyboardFocusManagerAccessor() {</span>
                public int shouldNativelyFocusHeavyweight(Component heavyweight,
                                                   Component descendant,
                                                   boolean temporary,
                                                   boolean focusedWindowChangeAllowed,
                                                   long time,
                                                   CausedFocusEvent.Cause cause)
                {
<span class="nc" id="L129">                    return KeyboardFocusManager.shouldNativelyFocusHeavyweight(</span>
                        heavyweight, descendant, temporary, focusedWindowChangeAllowed, time, cause);
                }
                public boolean processSynchronousLightweightTransfer(Component heavyweight,
                                                              Component descendant,
                                                              boolean temporary,
                                                              boolean focusedWindowChangeAllowed,
                                                              long time)
                {
<span class="nc" id="L138">                    return KeyboardFocusManager.processSynchronousLightweightTransfer(</span>
                        heavyweight, descendant, temporary, focusedWindowChangeAllowed, time);
                }
                public void removeLastFocusRequest(Component heavyweight) {
<span class="nc" id="L142">                    KeyboardFocusManager.removeLastFocusRequest(heavyweight);</span>
<span class="nc" id="L143">                }</span>
                public void setMostRecentFocusOwner(Window window, Component component) {
<span class="nc" id="L145">                    KeyboardFocusManager.setMostRecentFocusOwner(window, component);</span>
<span class="nc" id="L146">                }</span>
                public KeyboardFocusManager getCurrentKeyboardFocusManager(AppContext ctx) {
<span class="nc" id="L148">                    return KeyboardFocusManager.getCurrentKeyboardFocusManager(ctx);</span>
                }
                public Container getCurrentFocusCycleRoot() {
<span class="nc" id="L151">                    return KeyboardFocusManager.currentFocusCycleRoot;</span>
                }
            }
        );
    }

    transient KeyboardFocusManagerPeer peer;

    /**
     * Initialize JNI field and method IDs
     */
    private static native void initIDs();

<span class="fc" id="L164">    private static final PlatformLogger log = PlatformLogger.getLogger(&quot;java.awt.KeyboardFocusManager&quot;);</span>

    /**
     * The identifier for the Forward focus traversal keys.
     *
     * @see #setDefaultFocusTraversalKeys
     * @see #getDefaultFocusTraversalKeys
     * @see Component#setFocusTraversalKeys
     * @see Component#getFocusTraversalKeys
     */
    public static final int FORWARD_TRAVERSAL_KEYS = 0;

    /**
     * The identifier for the Backward focus traversal keys.
     *
     * @see #setDefaultFocusTraversalKeys
     * @see #getDefaultFocusTraversalKeys
     * @see Component#setFocusTraversalKeys
     * @see Component#getFocusTraversalKeys
     */
    public static final int BACKWARD_TRAVERSAL_KEYS = 1;

    /**
     * The identifier for the Up Cycle focus traversal keys.
     *
     * @see #setDefaultFocusTraversalKeys
     * @see #getDefaultFocusTraversalKeys
     * @see Component#setFocusTraversalKeys
     * @see Component#getFocusTraversalKeys
     */
    public static final int UP_CYCLE_TRAVERSAL_KEYS = 2;

    /**
     * The identifier for the Down Cycle focus traversal keys.
     *
     * @see #setDefaultFocusTraversalKeys
     * @see #getDefaultFocusTraversalKeys
     * @see Component#setFocusTraversalKeys
     * @see Component#getFocusTraversalKeys
     */
    public static final int DOWN_CYCLE_TRAVERSAL_KEYS = 3;

    static final int TRAVERSAL_KEY_LENGTH = DOWN_CYCLE_TRAVERSAL_KEYS + 1;

    /**
     * Returns the current KeyboardFocusManager instance for the calling
     * thread's context.
     *
     * @return this thread's context's KeyboardFocusManager
     * @see #setCurrentKeyboardFocusManager
     */
    public static KeyboardFocusManager getCurrentKeyboardFocusManager() {
<span class="fc" id="L216">        return getCurrentKeyboardFocusManager(AppContext.getAppContext());</span>
    }

    synchronized static KeyboardFocusManager
        getCurrentKeyboardFocusManager(AppContext appcontext)
    {
<span class="fc" id="L222">        KeyboardFocusManager manager = (KeyboardFocusManager)</span>
<span class="fc" id="L223">            appcontext.get(KeyboardFocusManager.class);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (manager == null) {</span>
<span class="fc" id="L225">            manager = new DefaultKeyboardFocusManager();</span>
<span class="fc" id="L226">            appcontext.put(KeyboardFocusManager.class, manager);</span>
        }
<span class="fc" id="L228">        return manager;</span>
    }

    /**
     * Sets the current KeyboardFocusManager instance for the calling thread's
     * context. If null is specified, then the current KeyboardFocusManager
     * is replaced with a new instance of DefaultKeyboardFocusManager.
     * &lt;p&gt;
     * If a SecurityManager is installed, the calling thread must be granted
     * the AWTPermission &quot;replaceKeyboardFocusManager&quot; in order to replace the
     * the current KeyboardFocusManager. If this permission is not granted,
     * this method will throw a SecurityException, and the current
     * KeyboardFocusManager will be unchanged.
     *
     * @param newManager the new KeyboardFocusManager for this thread's context
     * @see #getCurrentKeyboardFocusManager
     * @see DefaultKeyboardFocusManager
     * @throws SecurityException if the calling thread does not have permission
     *         to replace the current KeyboardFocusManager
     */
    public static void setCurrentKeyboardFocusManager(
        KeyboardFocusManager newManager) throws SecurityException
    {
<span class="nc" id="L251">        checkReplaceKFMPermission();</span>

<span class="nc" id="L253">        KeyboardFocusManager oldManager = null;</span>

<span class="nc" id="L255">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc" id="L256">            AppContext appcontext = AppContext.getAppContext();</span>

<span class="nc bnc" id="L258" title="All 2 branches missed.">            if (newManager != null) {</span>
<span class="nc" id="L259">                oldManager = getCurrentKeyboardFocusManager(appcontext);</span>

<span class="nc" id="L261">                appcontext.put(KeyboardFocusManager.class, newManager);</span>
            } else {
<span class="nc" id="L263">                oldManager = getCurrentKeyboardFocusManager(appcontext);</span>
<span class="nc" id="L264">                appcontext.remove(KeyboardFocusManager.class);</span>
            }
<span class="nc" id="L266">        }</span>

<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (oldManager != null) {</span>
<span class="nc" id="L269">            oldManager.firePropertyChange(&quot;managingFocus&quot;,</span>
                                          Boolean.TRUE,
                                          Boolean.FALSE);
        }
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (newManager != null) {</span>
<span class="nc" id="L274">            newManager.firePropertyChange(&quot;managingFocus&quot;,</span>
                                          Boolean.FALSE,
                                          Boolean.TRUE);
        }
<span class="nc" id="L278">    }</span>

    /**
     * The Component in an application that will typically receive all
     * KeyEvents generated by the user.
     */
    private static Component focusOwner;

    /**
     * The Component in an application that will regain focus when an
     * outstanding temporary focus transfer has completed, or the focus owner,
     * if no outstanding temporary transfer exists.
     */
    private static Component permanentFocusOwner;

    /**
     * The Window which is, or contains, the focus owner.
     */
    private static Window focusedWindow;

    /**
     * Only a Frame or a Dialog can be the active Window. The native windowing
     * system may denote the active Window with a special decoration, such as a
     * highlighted title bar. The active Window is always either the focused
     * Window, or the first Frame or Dialog which is an owner of the focused
     * Window.
     */
    private static Window activeWindow;

    /**
     * The default FocusTraversalPolicy for all Windows that have no policy of
     * their own set. If those Windows have focus-cycle-root children that have
     * no keyboard-traversal policy of their own, then those children will also
     * inherit this policy (as will, recursively, their focus-cycle-root
     * children).
     */
<span class="fc" id="L314">    private FocusTraversalPolicy defaultPolicy =</span>
        new DefaultFocusTraversalPolicy();

    /**
     * The bound property names of each focus traversal key.
     */
<span class="fc" id="L320">    private static final String[] defaultFocusTraversalKeyPropertyNames = {</span>
        &quot;forwardDefaultFocusTraversalKeys&quot;,
        &quot;backwardDefaultFocusTraversalKeys&quot;,
        &quot;upCycleDefaultFocusTraversalKeys&quot;,
        &quot;downCycleDefaultFocusTraversalKeys&quot;
    };

    /**
     * The default strokes for initializing the default focus traversal keys.
     */
<span class="fc" id="L330">    private static final AWTKeyStroke[][] defaultFocusTraversalKeyStrokes = {</span>
        {
<span class="fc" id="L332">            AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB, 0, false),</span>
<span class="fc" id="L333">            AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB, InputEvent.CTRL_DOWN_MASK | InputEvent.CTRL_MASK, false),</span>
        },
        {
<span class="fc" id="L336">            AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB, InputEvent.SHIFT_DOWN_MASK | InputEvent.SHIFT_MASK, false),</span>
<span class="fc" id="L337">            AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB,</span>
                                         InputEvent.SHIFT_DOWN_MASK | InputEvent.SHIFT_MASK | InputEvent.CTRL_DOWN_MASK | InputEvent.CTRL_MASK,
                                         false),
        },
        {},
        {},
      };
    /**
     * The default focus traversal keys. Each array of traversal keys will be
     * in effect on all Windows that have no such array of their own explicitly
     * set. Each array will also be inherited, recursively, by any child
     * Component of those Windows that has no such array of its own explicitly
     * set.
     */
<span class="fc" id="L351">    private Set&lt;AWTKeyStroke&gt;[] defaultFocusTraversalKeys = new Set[4];</span>

    /**
     * The current focus cycle root. If the focus owner is itself a focus cycle
     * root, then it may be ambiguous as to which Components represent the next
     * and previous Components to focus during normal focus traversal. In that
     * case, the current focus cycle root is used to differentiate among the
     * possibilities.
     */
    private static Container currentFocusCycleRoot;

    /**
     * A description of any VetoableChangeListeners which have been registered.
     */
    private VetoableChangeSupport vetoableSupport;

    /**
     * A description of any PropertyChangeListeners which have been registered.
     */
    private PropertyChangeSupport changeSupport;

    /**
     * This KeyboardFocusManager's KeyEventDispatcher chain. The List does not
     * include this KeyboardFocusManager unless it was explicitly re-registered
     * via a call to &lt;code&gt;addKeyEventDispatcher&lt;/code&gt;. If no other
     * KeyEventDispatchers are registered, this field may be null or refer to
     * a List of length 0.
     */
    private java.util.LinkedList&lt;KeyEventDispatcher&gt; keyEventDispatchers;

    /**
     * This KeyboardFocusManager's KeyEventPostProcessor chain. The List does
     * not include this KeyboardFocusManager unless it was explicitly
     * re-registered via a call to &lt;code&gt;addKeyEventPostProcessor&lt;/code&gt;.
     * If no other KeyEventPostProcessors are registered, this field may be
     * null or refer to a List of length 0.
     */
    private java.util.LinkedList&lt;KeyEventPostProcessor&gt; keyEventPostProcessors;

    /**
     * Maps Windows to those Windows' most recent focus owners.
     */
<span class="fc" id="L393">    private static java.util.Map&lt;Window, WeakReference&lt;Component&gt;&gt; mostRecentFocusOwners = new WeakHashMap&lt;&gt;();</span>

    /**
     * We cache the permission used to verify that the calling thread is
     * permitted to access the global focus state.
     */
    private static AWTPermission replaceKeyboardFocusManagerPermission;

    /*
     * SequencedEvent which is currently dispatched in AppContext.
     */
<span class="fc" id="L404">    transient SequencedEvent currentSequencedEvent = null;</span>

    final void setCurrentSequencedEvent(SequencedEvent current) {
<span class="nc" id="L407">        synchronized (SequencedEvent.class) {</span>
<span class="nc bnc" id="L408" title="All 6 branches missed.">            assert(current == null || currentSequencedEvent == null);</span>
<span class="nc" id="L409">            currentSequencedEvent = current;</span>
<span class="nc" id="L410">        }</span>
<span class="nc" id="L411">    }</span>

    final SequencedEvent getCurrentSequencedEvent() {
<span class="nc" id="L414">        synchronized (SequencedEvent.class) {</span>
<span class="nc" id="L415">            return currentSequencedEvent;</span>
<span class="nc" id="L416">        }</span>
    }

    static Set&lt;AWTKeyStroke&gt; initFocusTraversalKeysSet(String value, Set&lt;AWTKeyStroke&gt; targetSet) {
<span class="nc" id="L420">        StringTokenizer tokens = new StringTokenizer(value, &quot;,&quot;);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        while (tokens.hasMoreTokens()) {</span>
<span class="nc" id="L422">            targetSet.add(AWTKeyStroke.getAWTKeyStroke(tokens.nextToken()));</span>
        }
<span class="nc bnc" id="L424" title="All 2 branches missed.">        return (targetSet.isEmpty())</span>
            ? Collections.EMPTY_SET
<span class="nc" id="L426">            : Collections.unmodifiableSet(targetSet);</span>
    }

    /**
     * Initializes a KeyboardFocusManager.
     */
<span class="fc" id="L432">    public KeyboardFocusManager() {</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">        for (int i = 0; i &lt; TRAVERSAL_KEY_LENGTH; i++) {</span>
<span class="fc" id="L434">            Set&lt;AWTKeyStroke&gt; work_set = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">            for (int j = 0; j &lt; defaultFocusTraversalKeyStrokes[i].length; j++) {</span>
<span class="fc" id="L436">                work_set.add(defaultFocusTraversalKeyStrokes[i][j]);</span>
            }
<span class="fc bfc" id="L438" title="All 2 branches covered.">            defaultFocusTraversalKeys[i] = (work_set.isEmpty())</span>
                ? Collections.EMPTY_SET
<span class="fc" id="L440">                : Collections.unmodifiableSet(work_set);</span>
        }
<span class="fc" id="L442">        initPeer();</span>
<span class="fc" id="L443">    }</span>

    private void initPeer() {
<span class="fc" id="L446">        Toolkit tk = Toolkit.getDefaultToolkit();</span>
<span class="fc" id="L447">        KeyboardFocusManagerPeerProvider peerProvider = (KeyboardFocusManagerPeerProvider)tk;</span>
<span class="fc" id="L448">        peer = peerProvider.getKeyboardFocusManagerPeer();</span>
<span class="fc" id="L449">    }</span>

    /**
     * Returns the focus owner, if the focus owner is in the same context as
     * the calling thread. The focus owner is defined as the Component in an
     * application that will typically receive all KeyEvents generated by the
     * user. KeyEvents which map to the focus owner's focus traversal keys will
     * not be delivered if focus traversal keys are enabled for the focus
     * owner. In addition, KeyEventDispatchers may retarget or consume
     * KeyEvents before they reach the focus owner.
     *
     * @return the focus owner, or null if the focus owner is not a member of
     *         the calling thread's context
     * @see #getGlobalFocusOwner
     * @see #setGlobalFocusOwner
     */
    public Component getFocusOwner() {
<span class="nc" id="L466">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">            if (focusOwner == null) {</span>
<span class="nc" id="L468">                return null;</span>
            }

<span class="nc bnc" id="L471" title="All 2 branches missed.">            return (focusOwner.appContext == AppContext.getAppContext())</span>
                ? focusOwner
                : null;
<span class="nc" id="L474">        }</span>
    }

    /**
     * Returns the focus owner, even if the calling thread is in a different
     * context than the focus owner. The focus owner is defined as the
     * Component in an application that will typically receive all KeyEvents
     * generated by the user. KeyEvents which map to the focus owner's focus
     * traversal keys will not be delivered if focus traversal keys are enabled
     * for the focus owner. In addition, KeyEventDispatchers may retarget or
     * consume KeyEvents before they reach the focus owner.
     * &lt;p&gt;
     * This method will throw a SecurityException if this KeyboardFocusManager
     * is not the current KeyboardFocusManager for the calling thread's
     * context.
     *
     * @return the focus owner
     * @see #getFocusOwner
     * @see #setGlobalFocusOwner
     * @throws SecurityException if this KeyboardFocusManager is not the
     *         current KeyboardFocusManager for the calling thread's context
     *         and if the calling thread does not have &quot;replaceKeyboardFocusManager&quot;
     *         permission
     */
    protected Component getGlobalFocusOwner() throws SecurityException {
<span class="nc" id="L499">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc" id="L500">            checkKFMSecurity();</span>
<span class="nc" id="L501">            return focusOwner;</span>
<span class="nc" id="L502">        }</span>
    }

    /**
     * Sets the focus owner. The operation will be cancelled if the Component
     * is not focusable. The focus owner is defined as the Component in an
     * application that will typically receive all KeyEvents generated by the
     * user. KeyEvents which map to the focus owner's focus traversal keys will
     * not be delivered if focus traversal keys are enabled for the focus
     * owner. In addition, KeyEventDispatchers may retarget or consume
     * KeyEvents before they reach the focus owner.
     * &lt;p&gt;
     * This method does not actually set the focus to the specified Component.
     * It merely stores the value to be subsequently returned by
     * &lt;code&gt;getFocusOwner()&lt;/code&gt;. Use &lt;code&gt;Component.requestFocus()&lt;/code&gt;
     * or &lt;code&gt;Component.requestFocusInWindow()&lt;/code&gt; to change the focus
     * owner, subject to platform limitations.
     *
     * @param focusOwner the focus owner
     * @see #getFocusOwner
     * @see #getGlobalFocusOwner
     * @see Component#requestFocus()
     * @see Component#requestFocusInWindow()
     * @see Component#isFocusable
     * @throws SecurityException if this KeyboardFocusManager is not the
     *         current KeyboardFocusManager for the calling thread's context
     *         and if the calling thread does not have &quot;replaceKeyboardFocusManager&quot;
     *         permission
     * @beaninfo
     *       bound: true
     */
    protected void setGlobalFocusOwner(Component focusOwner)
        throws SecurityException
    {
<span class="nc" id="L536">        Component oldFocusOwner = null;</span>
<span class="nc" id="L537">        boolean shouldFire = false;</span>

<span class="nc bnc" id="L539" title="All 4 branches missed.">        if (focusOwner == null || focusOwner.isFocusable()) {</span>
<span class="nc" id="L540">            synchronized (KeyboardFocusManager.class) {</span>
<span class="nc" id="L541">                checkKFMSecurity();</span>

<span class="nc" id="L543">                oldFocusOwner = getFocusOwner();</span>

                try {
<span class="nc" id="L546">                    fireVetoableChange(&quot;focusOwner&quot;, oldFocusOwner,</span>
                                       focusOwner);
<span class="nc" id="L548">                } catch (PropertyVetoException e) {</span>
                    // rejected
<span class="nc" id="L550">                    return;</span>
<span class="nc" id="L551">                }</span>

<span class="nc" id="L553">                KeyboardFocusManager.focusOwner = focusOwner;</span>

<span class="nc bnc" id="L555" title="All 2 branches missed.">                if (focusOwner != null &amp;&amp;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                    (getCurrentFocusCycleRoot() == null ||</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                     !focusOwner.isFocusCycleRoot(getCurrentFocusCycleRoot())))</span>
                {
<span class="nc" id="L559">                    Container rootAncestor =</span>
<span class="nc" id="L560">                        focusOwner.getFocusCycleRootAncestor();</span>
<span class="nc bnc" id="L561" title="All 4 branches missed.">                    if (rootAncestor == null &amp;&amp; (focusOwner instanceof Window))</span>
                    {
<span class="nc" id="L563">                        rootAncestor = (Container)focusOwner;</span>
                    }
<span class="nc bnc" id="L565" title="All 2 branches missed.">                    if (rootAncestor != null) {</span>
<span class="nc" id="L566">                        setGlobalCurrentFocusCycleRootPriv(rootAncestor);</span>
                    }
                }

<span class="nc" id="L570">                shouldFire = true;</span>
<span class="nc" id="L571">            }</span>
        }

<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (shouldFire) {</span>
<span class="nc" id="L575">            firePropertyChange(&quot;focusOwner&quot;, oldFocusOwner, focusOwner);</span>
        }
<span class="nc" id="L577">    }</span>

    /**
     * Clears the focus owner at both the Java and native levels if the
     * focus owner exists and resides in the same context as the calling thread,
     * otherwise the method returns silently.
     * &lt;p&gt;
     * The focus owner component will receive a permanent FOCUS_LOST event.
     * After this operation completes, the native windowing system will discard
     * all user-generated KeyEvents until the user selects a new Component to
     * receive focus, or a Component is given focus explicitly via a call to
     * {@code requestFocus()}. This operation does not change the focused or
     * active Windows.
     *
     * @see Component#requestFocus()
     * @see java.awt.event.FocusEvent#FOCUS_LOST
     * @since 1.8
     */
    public void clearFocusOwner() {
<span class="nc bnc" id="L596" title="All 2 branches missed.">        if (getFocusOwner() != null) {</span>
<span class="nc" id="L597">            clearGlobalFocusOwner();</span>
        }
<span class="nc" id="L599">    }</span>

    /**
     * Clears the global focus owner at both the Java and native levels. If
     * there exists a focus owner, that Component will receive a permanent
     * FOCUS_LOST event. After this operation completes, the native windowing
     * system will discard all user-generated KeyEvents until the user selects
     * a new Component to receive focus, or a Component is given focus
     * explicitly via a call to &lt;code&gt;requestFocus()&lt;/code&gt;. This operation
     * does not change the focused or active Windows.
     * &lt;p&gt;
     * If a SecurityManager is installed, the calling thread must be granted
     * the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is
     * not granted, this method will throw a SecurityException, and the current
     * focus owner will not be cleared.
     * &lt;p&gt;
     * This method is intended to be used only by KeyboardFocusManager set as
     * current KeyboardFocusManager for the calling thread's context. It is not
     * for general client use.
     *
     * @see KeyboardFocusManager#clearFocusOwner
     * @see Component#requestFocus()
     * @see java.awt.event.FocusEvent#FOCUS_LOST
     * @throws SecurityException if the calling thread does not have
     *         &quot;replaceKeyboardFocusManager&quot; permission
     */
    public void clearGlobalFocusOwner()
        throws SecurityException
    {
<span class="nc" id="L628">        checkReplaceKFMPermission();</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">        if (!GraphicsEnvironment.isHeadless()) {</span>
            // Toolkit must be fully initialized, otherwise
            // _clearGlobalFocusOwner will crash or throw an exception
<span class="nc" id="L632">            Toolkit.getDefaultToolkit();</span>

<span class="nc" id="L634">            _clearGlobalFocusOwner();</span>
        }
<span class="nc" id="L636">    }</span>
    private void _clearGlobalFocusOwner() {
<span class="nc" id="L638">        Window activeWindow = markClearGlobalFocusOwner();</span>
<span class="nc" id="L639">        peer.clearGlobalFocusOwner(activeWindow);</span>
<span class="nc" id="L640">    }</span>

    void clearGlobalFocusOwnerPriv() {
<span class="nc" id="L643">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
            public Void run() {
<span class="nc" id="L645">                clearGlobalFocusOwner();</span>
<span class="nc" id="L646">                return null;</span>
            }
        });
<span class="nc" id="L649">    }</span>

    Component getNativeFocusOwner() {
<span class="nc" id="L652">        return peer.getCurrentFocusOwner();</span>
    }

    void setNativeFocusOwner(Component comp) {
<span class="nc bnc" id="L656" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L657">            focusLog.finest(&quot;Calling peer {0} setCurrentFocusOwner for {1}&quot;,</span>
<span class="nc" id="L658">                            String.valueOf(peer), String.valueOf(comp));</span>
        }
<span class="nc" id="L660">        peer.setCurrentFocusOwner(comp);</span>
<span class="nc" id="L661">    }</span>

    Window getNativeFocusedWindow() {
<span class="nc" id="L664">        return peer.getCurrentFocusedWindow();</span>
    }

    /**
     * Returns the permanent focus owner, if the permanent focus owner is in
     * the same context as the calling thread. The permanent focus owner is
     * defined as the last Component in an application to receive a permanent
     * FOCUS_GAINED event. The focus owner and permanent focus owner are
     * equivalent unless a temporary focus change is currently in effect. In
     * such a situation, the permanent focus owner will again be the focus
     * owner when the temporary focus change ends.
     *
     * @return the permanent focus owner, or null if the permanent focus owner
     *         is not a member of the calling thread's context
     * @see #getGlobalPermanentFocusOwner
     * @see #setGlobalPermanentFocusOwner
     */
    public Component getPermanentFocusOwner() {
<span class="nc" id="L682">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">            if (permanentFocusOwner == null) {</span>
<span class="nc" id="L684">                return null;</span>
            }

<span class="nc" id="L687">            return (permanentFocusOwner.appContext ==</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">                    AppContext.getAppContext())</span>
                ? permanentFocusOwner
                : null;
<span class="nc" id="L691">        }</span>
    }

    /**
     * Returns the permanent focus owner, even if the calling thread is in a
     * different context than the permanent focus owner. The permanent focus
     * owner is defined as the last Component in an application to receive a
     * permanent FOCUS_GAINED event. The focus owner and permanent focus owner
     * are equivalent unless a temporary focus change is currently in effect.
     * In such a situation, the permanent focus owner will again be the focus
     * owner when the temporary focus change ends.
     *
     * @return the permanent focus owner
     * @see #getPermanentFocusOwner
     * @see #setGlobalPermanentFocusOwner
     * @throws SecurityException if this KeyboardFocusManager is not the
     *         current KeyboardFocusManager for the calling thread's context
     *         and if the calling thread does not have &quot;replaceKeyboardFocusManager&quot;
     *         permission
     */
    protected Component getGlobalPermanentFocusOwner()
        throws SecurityException
    {
<span class="nc" id="L714">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc" id="L715">            checkKFMSecurity();</span>
<span class="nc" id="L716">            return permanentFocusOwner;</span>
<span class="nc" id="L717">        }</span>
    }

    /**
     * Sets the permanent focus owner. The operation will be cancelled if the
     * Component is not focusable. The permanent focus owner is defined as the
     * last Component in an application to receive a permanent FOCUS_GAINED
     * event. The focus owner and permanent focus owner are equivalent unless
     * a temporary focus change is currently in effect. In such a situation,
     * the permanent focus owner will again be the focus owner when the
     * temporary focus change ends.
     * &lt;p&gt;
     * This method does not actually set the focus to the specified Component.
     * It merely stores the value to be subsequently returned by
     * &lt;code&gt;getPermanentFocusOwner()&lt;/code&gt;. Use
     * &lt;code&gt;Component.requestFocus()&lt;/code&gt; or
     * &lt;code&gt;Component.requestFocusInWindow()&lt;/code&gt; to change the focus owner,
     * subject to platform limitations.
     *
     * @param permanentFocusOwner the permanent focus owner
     * @see #getPermanentFocusOwner
     * @see #getGlobalPermanentFocusOwner
     * @see Component#requestFocus()
     * @see Component#requestFocusInWindow()
     * @see Component#isFocusable
     * @throws SecurityException if this KeyboardFocusManager is not the
     *         current KeyboardFocusManager for the calling thread's context
     *         and if the calling thread does not have &quot;replaceKeyboardFocusManager&quot;
     *         permission
     * @beaninfo
     *       bound: true
     */
    protected void setGlobalPermanentFocusOwner(Component permanentFocusOwner)
        throws SecurityException
    {
<span class="nc" id="L752">        Component oldPermanentFocusOwner = null;</span>
<span class="nc" id="L753">        boolean shouldFire = false;</span>

<span class="nc bnc" id="L755" title="All 4 branches missed.">        if (permanentFocusOwner == null || permanentFocusOwner.isFocusable()) {</span>
<span class="nc" id="L756">            synchronized (KeyboardFocusManager.class) {</span>
<span class="nc" id="L757">                checkKFMSecurity();</span>

<span class="nc" id="L759">                oldPermanentFocusOwner = getPermanentFocusOwner();</span>

                try {
<span class="nc" id="L762">                    fireVetoableChange(&quot;permanentFocusOwner&quot;,</span>
                                       oldPermanentFocusOwner,
                                       permanentFocusOwner);
<span class="nc" id="L765">                } catch (PropertyVetoException e) {</span>
                    // rejected
<span class="nc" id="L767">                    return;</span>
<span class="nc" id="L768">                }</span>

<span class="nc" id="L770">                KeyboardFocusManager.permanentFocusOwner = permanentFocusOwner;</span>

<span class="nc" id="L772">                KeyboardFocusManager.</span>
<span class="nc" id="L773">                    setMostRecentFocusOwner(permanentFocusOwner);</span>

<span class="nc" id="L775">                shouldFire = true;</span>
<span class="nc" id="L776">            }</span>
        }

<span class="nc bnc" id="L779" title="All 2 branches missed.">        if (shouldFire) {</span>
<span class="nc" id="L780">            firePropertyChange(&quot;permanentFocusOwner&quot;, oldPermanentFocusOwner,</span>
                               permanentFocusOwner);
        }
<span class="nc" id="L783">    }</span>

    /**
     * Returns the focused Window, if the focused Window is in the same context
     * as the calling thread. The focused Window is the Window that is or
     * contains the focus owner.
     *
     * @return the focused Window, or null if the focused Window is not a
     *         member of the calling thread's context
     * @see #getGlobalFocusedWindow
     * @see #setGlobalFocusedWindow
     */
    public Window getFocusedWindow() {
<span class="nc" id="L796">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">            if (focusedWindow == null) {</span>
<span class="nc" id="L798">                return null;</span>
            }

<span class="nc bnc" id="L801" title="All 2 branches missed.">            return (focusedWindow.appContext == AppContext.getAppContext())</span>
                ? focusedWindow
                : null;
<span class="nc" id="L804">        }</span>
    }

    /**
     * Returns the focused Window, even if the calling thread is in a different
     * context than the focused Window. The focused Window is the Window that
     * is or contains the focus owner.
     *
     * @return the focused Window
     * @see #getFocusedWindow
     * @see #setGlobalFocusedWindow
     * @throws SecurityException if this KeyboardFocusManager is not the
     *         current KeyboardFocusManager for the calling thread's context
     *         and if the calling thread does not have &quot;replaceKeyboardFocusManager&quot;
     *         permission
     */
    protected Window getGlobalFocusedWindow() throws SecurityException {
<span class="nc" id="L821">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc" id="L822">            checkKFMSecurity();</span>
<span class="nc" id="L823">            return focusedWindow;</span>
<span class="nc" id="L824">        }</span>
    }

    /**
     * Sets the focused Window. The focused Window is the Window that is or
     * contains the focus owner. The operation will be cancelled if the
     * specified Window to focus is not a focusable Window.
     * &lt;p&gt;
     * This method does not actually change the focused Window as far as the
     * native windowing system is concerned. It merely stores the value to be
     * subsequently returned by &lt;code&gt;getFocusedWindow()&lt;/code&gt;. Use
     * &lt;code&gt;Component.requestFocus()&lt;/code&gt; or
     * &lt;code&gt;Component.requestFocusInWindow()&lt;/code&gt; to change the focused
     * Window, subject to platform limitations.
     *
     * @param focusedWindow the focused Window
     * @see #getFocusedWindow
     * @see #getGlobalFocusedWindow
     * @see Component#requestFocus()
     * @see Component#requestFocusInWindow()
     * @see Window#isFocusableWindow
     * @throws SecurityException if this KeyboardFocusManager is not the
     *         current KeyboardFocusManager for the calling thread's context
     *         and if the calling thread does not have &quot;replaceKeyboardFocusManager&quot;
     *         permission
     * @beaninfo
     *       bound: true
     */
    protected void setGlobalFocusedWindow(Window focusedWindow)
        throws SecurityException
    {
<span class="nc" id="L855">        Window oldFocusedWindow = null;</span>
<span class="nc" id="L856">        boolean shouldFire = false;</span>

<span class="nc bnc" id="L858" title="All 4 branches missed.">        if (focusedWindow == null || focusedWindow.isFocusableWindow()) {</span>
<span class="nc" id="L859">            synchronized (KeyboardFocusManager.class) {</span>
<span class="nc" id="L860">                checkKFMSecurity();</span>

<span class="nc" id="L862">                oldFocusedWindow = getFocusedWindow();</span>

                try {
<span class="nc" id="L865">                    fireVetoableChange(&quot;focusedWindow&quot;, oldFocusedWindow,</span>
                                       focusedWindow);
<span class="nc" id="L867">                } catch (PropertyVetoException e) {</span>
                    // rejected
<span class="nc" id="L869">                    return;</span>
<span class="nc" id="L870">                }</span>

<span class="nc" id="L872">                KeyboardFocusManager.focusedWindow = focusedWindow;</span>
<span class="nc" id="L873">                shouldFire = true;</span>
<span class="nc" id="L874">            }</span>
        }

<span class="nc bnc" id="L877" title="All 2 branches missed.">        if (shouldFire) {</span>
<span class="nc" id="L878">            firePropertyChange(&quot;focusedWindow&quot;, oldFocusedWindow,</span>
                               focusedWindow);
        }
<span class="nc" id="L881">    }</span>

    /**
     * Returns the active Window, if the active Window is in the same context
     * as the calling thread. Only a Frame or a Dialog can be the active
     * Window. The native windowing system may denote the active Window or its
     * children with special decorations, such as a highlighted title bar.
     * The active Window is always either the focused Window, or the first
     * Frame or Dialog that is an owner of the focused Window.
     *
     * @return the active Window, or null if the active Window is not a member
     *         of the calling thread's context
     * @see #getGlobalActiveWindow
     * @see #setGlobalActiveWindow
     */
    public Window getActiveWindow() {
<span class="nc" id="L897">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">            if (activeWindow == null) {</span>
<span class="nc" id="L899">                return null;</span>
            }

<span class="nc bnc" id="L902" title="All 2 branches missed.">            return (activeWindow.appContext == AppContext.getAppContext())</span>
                ? activeWindow
                : null;
<span class="nc" id="L905">        }</span>
    }

    /**
     * Returns the active Window, even if the calling thread is in a different
     * context than the active Window. Only a Frame or a Dialog can be the
     * active Window. The native windowing system may denote the active Window
     * or its children with special decorations, such as a highlighted title
     * bar. The active Window is always either the focused Window, or the first
     * Frame or Dialog that is an owner of the focused Window.
     *
     * @return the active Window
     * @see #getActiveWindow
     * @see #setGlobalActiveWindow
     * @throws SecurityException if this KeyboardFocusManager is not the
     *         current KeyboardFocusManager for the calling thread's context
     *         and if the calling thread does not have &quot;replaceKeyboardFocusManager&quot;
     *         permission
     */
    protected Window getGlobalActiveWindow() throws SecurityException {
<span class="nc" id="L925">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc" id="L926">            checkKFMSecurity();</span>
<span class="nc" id="L927">            return activeWindow;</span>
<span class="nc" id="L928">        }</span>
    }

    /**
     * Sets the active Window. Only a Frame or a Dialog can be the active
     * Window. The native windowing system may denote the active Window or its
     * children with special decorations, such as a highlighted title bar. The
     * active Window is always either the focused Window, or the first Frame or
     * Dialog that is an owner of the focused Window.
     * &lt;p&gt;
     * This method does not actually change the active Window as far as the
     * native windowing system is concerned. It merely stores the value to be
     * subsequently returned by &lt;code&gt;getActiveWindow()&lt;/code&gt;. Use
     * &lt;code&gt;Component.requestFocus()&lt;/code&gt; or
     * &lt;code&gt;Component.requestFocusInWindow()&lt;/code&gt;to change the active
     * Window, subject to platform limitations.
     *
     * @param activeWindow the active Window
     * @see #getActiveWindow
     * @see #getGlobalActiveWindow
     * @see Component#requestFocus()
     * @see Component#requestFocusInWindow()
     * @throws SecurityException if this KeyboardFocusManager is not the
     *         current KeyboardFocusManager for the calling thread's context
     *         and if the calling thread does not have &quot;replaceKeyboardFocusManager&quot;
     *         permission
     * @beaninfo
     *       bound: true
     */
    protected void setGlobalActiveWindow(Window activeWindow)
        throws SecurityException
    {
        Window oldActiveWindow;
<span class="nc" id="L961">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc" id="L962">            checkKFMSecurity();</span>

<span class="nc" id="L964">            oldActiveWindow = getActiveWindow();</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L966">                focusLog.finer(&quot;Setting global active window to &quot; + activeWindow + &quot;, old active &quot; + oldActiveWindow);</span>
            }

            try {
<span class="nc" id="L970">                fireVetoableChange(&quot;activeWindow&quot;, oldActiveWindow,</span>
                                   activeWindow);
<span class="nc" id="L972">            } catch (PropertyVetoException e) {</span>
                // rejected
<span class="nc" id="L974">                return;</span>
<span class="nc" id="L975">            }</span>

<span class="nc" id="L977">            KeyboardFocusManager.activeWindow = activeWindow;</span>
<span class="nc" id="L978">        }</span>

<span class="nc" id="L980">        firePropertyChange(&quot;activeWindow&quot;, oldActiveWindow, activeWindow);</span>
<span class="nc" id="L981">    }</span>

    /**
     * Returns the default FocusTraversalPolicy. Top-level components
     * use this value on their creation to initialize their own focus traversal
     * policy by explicit call to Container.setFocusTraversalPolicy.
     *
     * @return the default FocusTraversalPolicy. null will never be returned.
     * @see #setDefaultFocusTraversalPolicy
     * @see Container#setFocusTraversalPolicy
     * @see Container#getFocusTraversalPolicy
     */
    public synchronized FocusTraversalPolicy getDefaultFocusTraversalPolicy() {
<span class="nc" id="L994">        return defaultPolicy;</span>
    }

    /**
     * Sets the default FocusTraversalPolicy. Top-level components
     * use this value on their creation to initialize their own focus traversal
     * policy by explicit call to Container.setFocusTraversalPolicy.
     * Note: this call doesn't affect already created components as they have
     * their policy initialized. Only new components will use this policy as
     * their default policy.
     *
     * @param defaultPolicy the new, default FocusTraversalPolicy
     * @see #getDefaultFocusTraversalPolicy
     * @see Container#setFocusTraversalPolicy
     * @see Container#getFocusTraversalPolicy
     * @throws IllegalArgumentException if defaultPolicy is null
     * @beaninfo
     *       bound: true
     */
    public void setDefaultFocusTraversalPolicy(FocusTraversalPolicy
                                               defaultPolicy) {
<span class="nc bnc" id="L1015" title="All 2 branches missed.">        if (defaultPolicy == null) {</span>
<span class="nc" id="L1016">            throw new IllegalArgumentException(&quot;default focus traversal policy cannot be null&quot;);</span>
        }

        FocusTraversalPolicy oldPolicy;

<span class="nc" id="L1021">        synchronized (this) {</span>
<span class="nc" id="L1022">            oldPolicy = this.defaultPolicy;</span>
<span class="nc" id="L1023">            this.defaultPolicy = defaultPolicy;</span>
<span class="nc" id="L1024">        }</span>

<span class="nc" id="L1026">        firePropertyChange(&quot;defaultFocusTraversalPolicy&quot;, oldPolicy,</span>
                           defaultPolicy);
<span class="nc" id="L1028">    }</span>

    /**
     * Sets the default focus traversal keys for a given traversal operation.
     * This traversal key {@code Set} will be in effect on all
     * {@code Window}s that have no such {@code Set} of
     * their own explicitly defined. This {@code Set} will also be
     * inherited, recursively, by any child {@code Component} of
     * those {@code Windows} that has
     * no such {@code Set} of its own explicitly defined.
     * &lt;p&gt;
     * The default values for the default focus traversal keys are
     * implementation-dependent. Sun recommends that all implementations for a
     * particular native platform use the same default values. The
     * recommendations for Windows and Unix are listed below. These
     * recommendations are used in the Sun AWT implementations.
     *
     * &lt;table border=1 summary=&quot;Recommended default values for focus traversal keys&quot;&gt;
     * &lt;tr&gt;
     *    &lt;th&gt;Identifier&lt;/th&gt;
     *    &lt;th&gt;Meaning&lt;/th&gt;
     *    &lt;th&gt;Default&lt;/th&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *    &lt;td&gt;{@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS}&lt;/td&gt;
     *    &lt;td&gt;Normal forward keyboard traversal&lt;/td&gt;
     *    &lt;td&gt;{@code TAB} on {@code KEY_PRESSED},
     *        {@code CTRL-TAB} on {@code KEY_PRESSED}&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *    &lt;td&gt;{@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS}&lt;/td&gt;
     *    &lt;td&gt;Normal reverse keyboard traversal&lt;/td&gt;
     *    &lt;td&gt;{@code SHIFT-TAB} on {@code KEY_PRESSED},
     *        {@code CTRL-SHIFT-TAB} on {@code KEY_PRESSED}&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *    &lt;td&gt;{@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}&lt;/td&gt;
     *    &lt;td&gt;Go up one focus traversal cycle&lt;/td&gt;
     *    &lt;td&gt;none&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *    &lt;td&gt;{@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS}&lt;/td&gt;
     *    &lt;td&gt;Go down one focus traversal cycle&lt;/td&gt;
     *    &lt;td&gt;none&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;/table&gt;
     *
     * To disable a traversal key, use an empty {@code Set};
     * {@code Collections.EMPTY_SET} is recommended.
     * &lt;p&gt;
     * Using the {@code AWTKeyStroke} API, client code can
     * specify on which of two
     * specific {@code KeyEvent}s, {@code KEY_PRESSED} or
     * {@code KEY_RELEASED}, the focus traversal operation will
     * occur. Regardless of which {@code KeyEvent} is specified,
     * however, all {@code KeyEvent}s related to the focus
     * traversal key, including the associated {@code KEY_TYPED}
     * event, will be consumed, and will not be dispatched
     * to any {@code Component}. It is a runtime error to
     * specify a {@code KEY_TYPED} event as
     * mapping to a focus traversal operation, or to map the same event to
     * multiple default focus traversal operations.
     * &lt;p&gt;
     * This method may throw a {@code ClassCastException} if any {@code Object}
     * in {@code keystrokes} is not an {@code AWTKeyStroke}.
     *
     * @param id one of
     *        {@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS},
     *        {@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS},
     *        {@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}, or
     *        {@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS}
     * @param keystrokes the Set of {@code AWTKeyStroke}s for the
     *        specified operation
     * @see #getDefaultFocusTraversalKeys
     * @see Component#setFocusTraversalKeys
     * @see Component#getFocusTraversalKeys
     * @throws IllegalArgumentException if id is not one of
     *         {@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS},
     *         {@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS},
     *         {@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}, or
     *         {@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS},
     *         or if keystrokes is {@code null},
     *         or if keystrokes contains {@code null},
     *         or if any keystroke
     *         represents a {@code KEY_TYPED} event,
     *         or if any keystroke already maps
     *         to another default focus traversal operation
     * @beaninfo
     *       bound: true
     */
    public void
        setDefaultFocusTraversalKeys(int id,
                                     Set&lt;? extends AWTKeyStroke&gt; keystrokes)
    {
<span class="nc bnc" id="L1122" title="All 4 branches missed.">        if (id &lt; 0 || id &gt;= TRAVERSAL_KEY_LENGTH) {</span>
<span class="nc" id="L1123">            throw new IllegalArgumentException(&quot;invalid focus traversal key identifier&quot;);</span>
        }
<span class="nc bnc" id="L1125" title="All 2 branches missed.">        if (keystrokes == null) {</span>
<span class="nc" id="L1126">            throw new IllegalArgumentException(&quot;cannot set null Set of default focus traversal keys&quot;);</span>
        }

        Set&lt;AWTKeyStroke&gt; oldKeys;

<span class="nc" id="L1131">        synchronized (this) {</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">            for (AWTKeyStroke keystroke : keystrokes) {</span>

<span class="nc bnc" id="L1134" title="All 2 branches missed.">                if (keystroke == null) {</span>
<span class="nc" id="L1135">                    throw new IllegalArgumentException(&quot;cannot set null focus traversal key&quot;);</span>
                }

<span class="nc bnc" id="L1138" title="All 2 branches missed.">                if (keystroke.getKeyChar() != KeyEvent.CHAR_UNDEFINED) {</span>
<span class="nc" id="L1139">                    throw new IllegalArgumentException(&quot;focus traversal keys cannot map to KEY_TYPED events&quot;);</span>
                }

                // Check to see if key already maps to another traversal
                // operation
<span class="nc bnc" id="L1144" title="All 2 branches missed.">                for (int i = 0; i &lt; TRAVERSAL_KEY_LENGTH; i++) {</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">                    if (i == id) {</span>
<span class="nc" id="L1146">                        continue;</span>
                    }

<span class="nc bnc" id="L1149" title="All 2 branches missed.">                    if (defaultFocusTraversalKeys[i].contains(keystroke)) {</span>
<span class="nc" id="L1150">                        throw new IllegalArgumentException(&quot;focus traversal keys must be unique for a Component&quot;);</span>
                    }
                }
<span class="nc" id="L1153">            }</span>

<span class="nc" id="L1155">            oldKeys = defaultFocusTraversalKeys[id];</span>
<span class="nc" id="L1156">            defaultFocusTraversalKeys[id] =</span>
<span class="nc" id="L1157">                Collections.unmodifiableSet(new HashSet&lt;&gt;(keystrokes));</span>
<span class="nc" id="L1158">        }</span>

<span class="nc" id="L1160">        firePropertyChange(defaultFocusTraversalKeyPropertyNames[id],</span>
                           oldKeys, keystrokes);
<span class="nc" id="L1162">    }</span>

    /**
     * Returns a Set of default focus traversal keys for a given traversal
     * operation. This traversal key Set will be in effect on all Windows that
     * have no such Set of their own explicitly defined. This Set will also be
     * inherited, recursively, by any child Component of those Windows that has
     * no such Set of its own explicitly defined. (See
     * &lt;code&gt;setDefaultFocusTraversalKeys&lt;/code&gt; for a full description of each
     * operation.)
     *
     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
     * @return the &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;AWTKeyStroke&lt;/code&gt;s
     *         for the specified operation; the &lt;code&gt;Set&lt;/code&gt;
     *         will be unmodifiable, and may be empty; &lt;code&gt;null&lt;/code&gt;
     *         will never be returned
     * @see #setDefaultFocusTraversalKeys
     * @see Component#setFocusTraversalKeys
     * @see Component#getFocusTraversalKeys
     * @throws IllegalArgumentException if id is not one of
     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
     */
    public Set&lt;AWTKeyStroke&gt; getDefaultFocusTraversalKeys(int id) {
<span class="nc bnc" id="L1191" title="All 4 branches missed.">        if (id &lt; 0 || id &gt;= TRAVERSAL_KEY_LENGTH) {</span>
<span class="nc" id="L1192">            throw new IllegalArgumentException(&quot;invalid focus traversal key identifier&quot;);</span>
        }

        // Okay to return Set directly because it is an unmodifiable view
<span class="nc" id="L1196">        return defaultFocusTraversalKeys[id];</span>
    }

    /**
     * Returns the current focus cycle root, if the current focus cycle root is
     * in the same context as the calling thread. If the focus owner is itself
     * a focus cycle root, then it may be ambiguous as to which Components
     * represent the next and previous Components to focus during normal focus
     * traversal. In that case, the current focus cycle root is used to
     * differentiate among the possibilities.
     * &lt;p&gt;
     * This method is intended to be used only by KeyboardFocusManagers and
     * focus implementations. It is not for general client use.
     *
     * @return the current focus cycle root, or null if the current focus cycle
     *         root is not a member of the calling thread's context
     * @see #getGlobalCurrentFocusCycleRoot
     * @see #setGlobalCurrentFocusCycleRoot
     */
    public Container getCurrentFocusCycleRoot() {
<span class="nc" id="L1216">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">            if (currentFocusCycleRoot == null) {</span>
<span class="nc" id="L1218">                return null;</span>
            }

<span class="nc" id="L1221">            return (currentFocusCycleRoot.appContext ==</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">                    AppContext.getAppContext())</span>
                ? currentFocusCycleRoot
                : null;
<span class="nc" id="L1225">        }</span>
    }

    /**
     * Returns the current focus cycle root, even if the calling thread is in a
     * different context than the current focus cycle root. If the focus owner
     * is itself a focus cycle root, then it may be ambiguous as to which
     * Components represent the next and previous Components to focus during
     * normal focus traversal. In that case, the current focus cycle root is
     * used to differentiate among the possibilities.
     *
     * @return the current focus cycle root, or null if the current focus cycle
     *         root is not a member of the calling thread's context
     * @see #getCurrentFocusCycleRoot
     * @see #setGlobalCurrentFocusCycleRoot
     * @throws SecurityException if this KeyboardFocusManager is not the
     *         current KeyboardFocusManager for the calling thread's context
     *         and if the calling thread does not have &quot;replaceKeyboardFocusManager&quot;
     *         permission
     */
    protected Container getGlobalCurrentFocusCycleRoot()
        throws SecurityException
    {
<span class="nc" id="L1248">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc" id="L1249">            checkKFMSecurity();</span>
<span class="nc" id="L1250">            return currentFocusCycleRoot;</span>
<span class="nc" id="L1251">        }</span>
    }

    /**
     * Sets the current focus cycle root. If the focus owner is itself a focus
     * cycle root, then it may be ambiguous as to which Components represent
     * the next and previous Components to focus during normal focus traversal.
     * In that case, the current focus cycle root is used to differentiate
     * among the possibilities.
     * &lt;p&gt;
     * If a SecurityManager is installed, the calling thread must be granted
     * the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is
     * not granted, this method will throw a SecurityException, and the current
     * focus cycle root will not be changed.
     * &lt;p&gt;
     * This method is intended to be used only by KeyboardFocusManagers and
     * focus implementations. It is not for general client use.
     *
     * @param newFocusCycleRoot the new focus cycle root
     * @see #getCurrentFocusCycleRoot
     * @see #getGlobalCurrentFocusCycleRoot
     * @throws SecurityException if the calling thread does not have
     *         &quot;replaceKeyboardFocusManager&quot; permission
     * @beaninfo
     *       bound: true
     */
    public void setGlobalCurrentFocusCycleRoot(Container newFocusCycleRoot)
        throws SecurityException
    {
<span class="nc" id="L1280">        checkReplaceKFMPermission();</span>

        Container oldFocusCycleRoot;

<span class="nc" id="L1284">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc" id="L1285">            oldFocusCycleRoot  = getCurrentFocusCycleRoot();</span>
<span class="nc" id="L1286">            currentFocusCycleRoot = newFocusCycleRoot;</span>
<span class="nc" id="L1287">        }</span>

<span class="nc" id="L1289">        firePropertyChange(&quot;currentFocusCycleRoot&quot;, oldFocusCycleRoot,</span>
                           newFocusCycleRoot);
<span class="nc" id="L1291">    }</span>

    void setGlobalCurrentFocusCycleRootPriv(final Container newFocusCycleRoot) {
<span class="nc" id="L1294">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
            public Void run() {
<span class="nc" id="L1296">                setGlobalCurrentFocusCycleRoot(newFocusCycleRoot);</span>
<span class="nc" id="L1297">                return null;</span>
            }
        });
<span class="nc" id="L1300">    }</span>

    /**
     * Adds a PropertyChangeListener to the listener list. The listener is
     * registered for all bound properties of this class, including the
     * following:
     * &lt;ul&gt;
     *    &lt;li&gt;whether the KeyboardFocusManager is currently managing focus
     *        for this application or applet's browser context
     *        (&quot;managingFocus&quot;)&lt;/li&gt;
     *    &lt;li&gt;the focus owner (&quot;focusOwner&quot;)&lt;/li&gt;
     *    &lt;li&gt;the permanent focus owner (&quot;permanentFocusOwner&quot;)&lt;/li&gt;
     *    &lt;li&gt;the focused Window (&quot;focusedWindow&quot;)&lt;/li&gt;
     *    &lt;li&gt;the active Window (&quot;activeWindow&quot;)&lt;/li&gt;
     *    &lt;li&gt;the default focus traversal policy
     *        (&quot;defaultFocusTraversalPolicy&quot;)&lt;/li&gt;
     *    &lt;li&gt;the Set of default FORWARD_TRAVERSAL_KEYS
     *        (&quot;forwardDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;the Set of default BACKWARD_TRAVERSAL_KEYS
     *        (&quot;backwardDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;the Set of default UP_CYCLE_TRAVERSAL_KEYS
     *        (&quot;upCycleDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;the Set of default DOWN_CYCLE_TRAVERSAL_KEYS
     *        (&quot;downCycleDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;the current focus cycle root (&quot;currentFocusCycleRoot&quot;)&lt;/li&gt;
     * &lt;/ul&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param listener the PropertyChangeListener to be added
     * @see #removePropertyChangeListener
     * @see #getPropertyChangeListeners
     * @see #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
     */
    public void addPropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L1334" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L1335">            synchronized (this) {</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">                if (changeSupport == null) {</span>
<span class="nc" id="L1337">                    changeSupport = new PropertyChangeSupport(this);</span>
                }
<span class="nc" id="L1339">                changeSupport.addPropertyChangeListener(listener);</span>
<span class="nc" id="L1340">            }</span>
        }
<span class="nc" id="L1342">    }</span>

    /**
     * Removes a PropertyChangeListener from the listener list. This method
     * should be used to remove the PropertyChangeListeners that were
     * registered for all bound properties of this class.
     * &lt;p&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param listener the PropertyChangeListener to be removed
     * @see #addPropertyChangeListener
     * @see #getPropertyChangeListeners
     * @see #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
     */
    public void removePropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L1357" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L1358">            synchronized (this) {</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">                if (changeSupport != null) {</span>
<span class="nc" id="L1360">                    changeSupport.removePropertyChangeListener(listener);</span>
                }
<span class="nc" id="L1362">            }</span>
        }
<span class="nc" id="L1364">    }</span>

    /**
     * Returns an array of all the property change listeners
     * registered on this keyboard focus manager.
     *
     * @return all of this keyboard focus manager's
     *         &lt;code&gt;PropertyChangeListener&lt;/code&gt;s
     *         or an empty array if no property change
     *         listeners are currently registered
     *
     * @see #addPropertyChangeListener
     * @see #removePropertyChangeListener
     * @see #getPropertyChangeListeners(java.lang.String)
     * @since 1.4
     */
    public synchronized PropertyChangeListener[] getPropertyChangeListeners() {
<span class="nc bnc" id="L1381" title="All 2 branches missed.">        if (changeSupport == null) {</span>
<span class="nc" id="L1382">            changeSupport = new PropertyChangeSupport(this);</span>
        }
<span class="nc" id="L1384">        return changeSupport.getPropertyChangeListeners();</span>
    }

    /**
     * Adds a PropertyChangeListener to the listener list for a specific
     * property. The specified property may be user-defined, or one of the
     * following:
     * &lt;ul&gt;
     *    &lt;li&gt;whether the KeyboardFocusManager is currently managing focus
     *        for this application or applet's browser context
     *        (&quot;managingFocus&quot;)&lt;/li&gt;
     *    &lt;li&gt;the focus owner (&quot;focusOwner&quot;)&lt;/li&gt;
     *    &lt;li&gt;the permanent focus owner (&quot;permanentFocusOwner&quot;)&lt;/li&gt;
     *    &lt;li&gt;the focused Window (&quot;focusedWindow&quot;)&lt;/li&gt;
     *    &lt;li&gt;the active Window (&quot;activeWindow&quot;)&lt;/li&gt;
     *    &lt;li&gt;the default focus traversal policy
     *        (&quot;defaultFocusTraversalPolicy&quot;)&lt;/li&gt;
     *    &lt;li&gt;the Set of default FORWARD_TRAVERSAL_KEYS
     *        (&quot;forwardDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;the Set of default BACKWARD_TRAVERSAL_KEYS
     *        (&quot;backwardDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;the Set of default UP_CYCLE_TRAVERSAL_KEYS
     *        (&quot;upCycleDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;the Set of default DOWN_CYCLE_TRAVERSAL_KEYS
     *        (&quot;downCycleDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
     *    &lt;li&gt;the current focus cycle root (&quot;currentFocusCycleRoot&quot;)&lt;/li&gt;
     * &lt;/ul&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param propertyName one of the property names listed above
     * @param listener the PropertyChangeListener to be added
     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)
     * @see #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
     * @see #getPropertyChangeListeners(java.lang.String)
     */
    public void addPropertyChangeListener(String propertyName,
                                          PropertyChangeListener listener) {
<span class="nc bnc" id="L1421" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L1422">            synchronized (this) {</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">                if (changeSupport == null) {</span>
<span class="nc" id="L1424">                    changeSupport = new PropertyChangeSupport(this);</span>
                }
<span class="nc" id="L1426">                changeSupport.addPropertyChangeListener(propertyName,</span>
                                                        listener);
<span class="nc" id="L1428">            }</span>
        }
<span class="nc" id="L1430">    }</span>

    /**
     * Removes a PropertyChangeListener from the listener list for a specific
     * property. This method should be used to remove PropertyChangeListeners
     * that were registered for a specific bound property.
     * &lt;p&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param propertyName a valid property name
     * @param listener the PropertyChangeListener to be removed
     * @see #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
     * @see #getPropertyChangeListeners(java.lang.String)
     * @see #removePropertyChangeListener(java.beans.PropertyChangeListener)
     */
    public void removePropertyChangeListener(String propertyName,
                                             PropertyChangeListener listener) {
<span class="nc bnc" id="L1447" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L1448">            synchronized (this) {</span>
<span class="nc bnc" id="L1449" title="All 2 branches missed.">                if (changeSupport != null) {</span>
<span class="nc" id="L1450">                    changeSupport.removePropertyChangeListener(propertyName,</span>
                                                               listener);
                }
<span class="nc" id="L1453">            }</span>
        }
<span class="nc" id="L1455">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;PropertyChangeListener&lt;/code&gt;s
     * associated with the named property.
     *
     * @return all of the &lt;code&gt;PropertyChangeListener&lt;/code&gt;s associated with
     *         the named property or an empty array if no such listeners have
     *         been added.
     *
     * @see #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
     * @see #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
     * @since 1.4
     */
    public synchronized PropertyChangeListener[] getPropertyChangeListeners(String propertyName) {
<span class="nc bnc" id="L1470" title="All 2 branches missed.">        if (changeSupport == null) {</span>
<span class="nc" id="L1471">            changeSupport = new PropertyChangeSupport(this);</span>
        }
<span class="nc" id="L1473">        return changeSupport.getPropertyChangeListeners(propertyName);</span>
    }

    /**
     * Fires a PropertyChangeEvent in response to a change in a bound property.
     * The event will be delivered to all registered PropertyChangeListeners.
     * No event will be delivered if oldValue and newValue are the same.
     *
     * @param propertyName the name of the property that has changed
     * @param oldValue the property's previous value
     * @param newValue the property's new value
     */
    protected void firePropertyChange(String propertyName, Object oldValue,
                                      Object newValue)
    {
<span class="nc bnc" id="L1488" title="All 2 branches missed.">        if (oldValue == newValue) {</span>
<span class="nc" id="L1489">            return;</span>
        }
<span class="nc" id="L1491">        PropertyChangeSupport changeSupport = this.changeSupport;</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">        if (changeSupport != null) {</span>
<span class="nc" id="L1493">            changeSupport.firePropertyChange(propertyName, oldValue, newValue);</span>
        }
<span class="nc" id="L1495">    }</span>

    /**
     * Adds a VetoableChangeListener to the listener list. The listener is
     * registered for all vetoable properties of this class, including the
     * following:
     * &lt;ul&gt;
     *    &lt;li&gt;the focus owner (&quot;focusOwner&quot;)&lt;/li&gt;
     *    &lt;li&gt;the permanent focus owner (&quot;permanentFocusOwner&quot;)&lt;/li&gt;
     *    &lt;li&gt;the focused Window (&quot;focusedWindow&quot;)&lt;/li&gt;
     *    &lt;li&gt;the active Window (&quot;activeWindow&quot;)&lt;/li&gt;
     * &lt;/ul&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param listener the VetoableChangeListener to be added
     * @see #removeVetoableChangeListener
     * @see #getVetoableChangeListeners
     * @see #addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)
     */
    public void addVetoableChangeListener(VetoableChangeListener listener) {
<span class="nc bnc" id="L1515" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L1516">            synchronized (this) {</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">                if (vetoableSupport == null) {</span>
<span class="nc" id="L1518">                    vetoableSupport =</span>
                        new VetoableChangeSupport(this);
                }
<span class="nc" id="L1521">                vetoableSupport.addVetoableChangeListener(listener);</span>
<span class="nc" id="L1522">            }</span>
        }
<span class="nc" id="L1524">    }</span>

    /**
     * Removes a VetoableChangeListener from the listener list. This method
     * should be used to remove the VetoableChangeListeners that were
     * registered for all vetoable properties of this class.
     * &lt;p&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param listener the VetoableChangeListener to be removed
     * @see #addVetoableChangeListener
     * @see #getVetoableChangeListeners
     * @see #removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)
     */
    public void removeVetoableChangeListener(VetoableChangeListener listener) {
<span class="nc bnc" id="L1539" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L1540">            synchronized (this) {</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">                if (vetoableSupport != null) {</span>
<span class="nc" id="L1542">                    vetoableSupport.removeVetoableChangeListener(listener);</span>
                }
<span class="nc" id="L1544">            }</span>
        }
<span class="nc" id="L1546">    }</span>

    /**
     * Returns an array of all the vetoable change listeners
     * registered on this keyboard focus manager.
     *
     * @return all of this keyboard focus manager's
     *         &lt;code&gt;VetoableChangeListener&lt;/code&gt;s
     *         or an empty array if no vetoable change
     *         listeners are currently registered
     *
     * @see #addVetoableChangeListener
     * @see #removeVetoableChangeListener
     * @see #getVetoableChangeListeners(java.lang.String)
     * @since 1.4
     */
    public synchronized VetoableChangeListener[] getVetoableChangeListeners() {
<span class="nc bnc" id="L1563" title="All 2 branches missed.">        if (vetoableSupport == null) {</span>
<span class="nc" id="L1564">            vetoableSupport = new VetoableChangeSupport(this);</span>
        }
<span class="nc" id="L1566">        return vetoableSupport.getVetoableChangeListeners();</span>
    }

    /**
     * Adds a VetoableChangeListener to the listener list for a specific
     * property. The specified property may be user-defined, or one of the
     * following:
     * &lt;ul&gt;
     *    &lt;li&gt;the focus owner (&quot;focusOwner&quot;)&lt;/li&gt;
     *    &lt;li&gt;the permanent focus owner (&quot;permanentFocusOwner&quot;)&lt;/li&gt;
     *    &lt;li&gt;the focused Window (&quot;focusedWindow&quot;)&lt;/li&gt;
     *    &lt;li&gt;the active Window (&quot;activeWindow&quot;)&lt;/li&gt;
     * &lt;/ul&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param propertyName one of the property names listed above
     * @param listener the VetoableChangeListener to be added
     * @see #addVetoableChangeListener(java.beans.VetoableChangeListener)
     * @see #removeVetoableChangeListener
     * @see #getVetoableChangeListeners
     */
    public void addVetoableChangeListener(String propertyName,
                                          VetoableChangeListener listener) {
<span class="nc bnc" id="L1589" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L1590">            synchronized (this) {</span>
<span class="nc bnc" id="L1591" title="All 2 branches missed.">                if (vetoableSupport == null) {</span>
<span class="nc" id="L1592">                    vetoableSupport =</span>
                        new VetoableChangeSupport(this);
                }
<span class="nc" id="L1595">                vetoableSupport.addVetoableChangeListener(propertyName,</span>
                                                          listener);
<span class="nc" id="L1597">            }</span>
        }
<span class="nc" id="L1599">    }</span>

    /**
     * Removes a VetoableChangeListener from the listener list for a specific
     * property. This method should be used to remove VetoableChangeListeners
     * that were registered for a specific bound property.
     * &lt;p&gt;
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @param propertyName a valid property name
     * @param listener the VetoableChangeListener to be removed
     * @see #addVetoableChangeListener
     * @see #getVetoableChangeListeners
     * @see #removeVetoableChangeListener(java.beans.VetoableChangeListener)
     */
    public void removeVetoableChangeListener(String propertyName,
                                             VetoableChangeListener listener) {
<span class="nc bnc" id="L1616" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L1617">            synchronized (this) {</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">                if (vetoableSupport != null) {</span>
<span class="nc" id="L1619">                    vetoableSupport.removeVetoableChangeListener(propertyName,</span>
                                                                 listener);
                }
<span class="nc" id="L1622">            }</span>
        }
<span class="nc" id="L1624">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;VetoableChangeListener&lt;/code&gt;s
     * associated with the named property.
     *
     * @return all of the &lt;code&gt;VetoableChangeListener&lt;/code&gt;s associated with
     *         the named property or an empty array if no such listeners have
     *         been added.
     *
     * @see #addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)
     * @see #removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)
     * @see #getVetoableChangeListeners
     * @since 1.4
     */
    public synchronized VetoableChangeListener[] getVetoableChangeListeners(String propertyName) {
<span class="nc bnc" id="L1640" title="All 2 branches missed.">        if (vetoableSupport == null) {</span>
<span class="nc" id="L1641">            vetoableSupport = new VetoableChangeSupport(this);</span>
        }
<span class="nc" id="L1643">        return vetoableSupport.getVetoableChangeListeners(propertyName);</span>
    }

    /**
     * Fires a PropertyChangeEvent in response to a change in a vetoable
     * property. The event will be delivered to all registered
     * VetoableChangeListeners. If a VetoableChangeListener throws a
     * PropertyVetoException, a new event is fired reverting all
     * VetoableChangeListeners to the old value and the exception is then
     * rethrown. No event will be delivered if oldValue and newValue are the
     * same.
     *
     * @param propertyName the name of the property that has changed
     * @param oldValue the property's previous value
     * @param newValue the property's new value
     * @throws java.beans.PropertyVetoException if a
     *         &lt;code&gt;VetoableChangeListener&lt;/code&gt; threw
     *         &lt;code&gt;PropertyVetoException&lt;/code&gt;
     */
    protected void fireVetoableChange(String propertyName, Object oldValue,
                                      Object newValue)
        throws PropertyVetoException
    {
<span class="nc bnc" id="L1666" title="All 2 branches missed.">        if (oldValue == newValue) {</span>
<span class="nc" id="L1667">            return;</span>
        }
<span class="nc" id="L1669">        VetoableChangeSupport vetoableSupport =</span>
            this.vetoableSupport;
<span class="nc bnc" id="L1671" title="All 2 branches missed.">        if (vetoableSupport != null) {</span>
<span class="nc" id="L1672">            vetoableSupport.fireVetoableChange(propertyName, oldValue,</span>
                                               newValue);
        }
<span class="nc" id="L1675">    }</span>

    /**
     * Adds a KeyEventDispatcher to this KeyboardFocusManager's dispatcher
     * chain. This KeyboardFocusManager will request that each
     * KeyEventDispatcher dispatch KeyEvents generated by the user before
     * finally dispatching the KeyEvent itself. KeyEventDispatchers will be
     * notified in the order in which they were added. Notifications will halt
     * as soon as one KeyEventDispatcher returns &lt;code&gt;true&lt;/code&gt; from its
     * &lt;code&gt;dispatchKeyEvent&lt;/code&gt; method. There is no limit to the total
     * number of KeyEventDispatchers which can be added, nor to the number of
     * times which a particular KeyEventDispatcher instance can be added.
     * &lt;p&gt;
     * If a null dispatcher is specified, no action is taken and no exception
     * is thrown.
     * &lt;p&gt;
     * In a multithreaded application, {@link KeyEventDispatcher} behaves
     * the same as other AWT listeners.  See
     * &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for more details.
     *
     * @param dispatcher the KeyEventDispatcher to add to the dispatcher chain
     * @see #removeKeyEventDispatcher
     */
    public void addKeyEventDispatcher(KeyEventDispatcher dispatcher) {
<span class="nc bnc" id="L1700" title="All 2 branches missed.">        if (dispatcher != null) {</span>
<span class="nc" id="L1701">            synchronized (this) {</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">                if (keyEventDispatchers == null) {</span>
<span class="nc" id="L1703">                    keyEventDispatchers = new java.util.LinkedList&lt;&gt;();</span>
                }
<span class="nc" id="L1705">                keyEventDispatchers.add(dispatcher);</span>
<span class="nc" id="L1706">            }</span>
        }
<span class="nc" id="L1708">    }</span>

    /**
     * Removes a KeyEventDispatcher which was previously added to this
     * KeyboardFocusManager's dispatcher chain. This KeyboardFocusManager
     * cannot itself be removed, unless it was explicitly re-registered via a
     * call to &lt;code&gt;addKeyEventDispatcher&lt;/code&gt;.
     * &lt;p&gt;
     * If a null dispatcher is specified, if the specified dispatcher is not
     * in the dispatcher chain, or if this KeyboardFocusManager is specified
     * without having been explicitly re-registered, no action is taken and no
     * exception is thrown.
     * &lt;p&gt;
     * In a multithreaded application, {@link KeyEventDispatcher} behaves
     * the same as other AWT listeners.  See
     * &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for more details.
     *
     * @param dispatcher the KeyEventDispatcher to remove from the dispatcher
     *        chain
     * @see #addKeyEventDispatcher
     */
    public void removeKeyEventDispatcher(KeyEventDispatcher dispatcher) {
<span class="nc bnc" id="L1731" title="All 2 branches missed.">        if (dispatcher != null) {</span>
<span class="nc" id="L1732">            synchronized (this) {</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">                if (keyEventDispatchers != null) {</span>
<span class="nc" id="L1734">                    keyEventDispatchers.remove(dispatcher);</span>
                }
<span class="nc" id="L1736">            }</span>
        }
<span class="nc" id="L1738">    }</span>

    /**
     * Returns this KeyboardFocusManager's KeyEventDispatcher chain as a List.
     * The List will not include this KeyboardFocusManager unless it was
     * explicitly re-registered via a call to
     * &lt;code&gt;addKeyEventDispatcher&lt;/code&gt;. If no other KeyEventDispatchers are
     * registered, implementations are free to return null or a List of length
     * 0. Client code should not assume one behavior over another, nor should
     * it assume that the behavior, once established, will not change.
     *
     * @return a possibly null or empty List of KeyEventDispatchers
     * @see #addKeyEventDispatcher
     * @see #removeKeyEventDispatcher
     */
    protected synchronized java.util.List&lt;KeyEventDispatcher&gt;
        getKeyEventDispatchers()
    {
<span class="nc bnc" id="L1756" title="All 2 branches missed.">        return (keyEventDispatchers != null)</span>
<span class="nc" id="L1757">            ? (java.util.List)keyEventDispatchers.clone()</span>
            : null;
    }

    /**
     * Adds a KeyEventPostProcessor to this KeyboardFocusManager's post-
     * processor chain. After a KeyEvent has been dispatched to and handled by
     * its target, KeyboardFocusManager will request that each
     * KeyEventPostProcessor perform any necessary post-processing as part
     * of the KeyEvent's final resolution. KeyEventPostProcessors
     * will be notified in the order in which they were added; the current
     * KeyboardFocusManager will be notified last. Notifications will halt
     * as soon as one KeyEventPostProcessor returns &lt;code&gt;true&lt;/code&gt; from its
     * &lt;code&gt;postProcessKeyEvent&lt;/code&gt; method. There is no limit to the the
     * total number of KeyEventPostProcessors that can be added, nor to the
     * number of times that a particular KeyEventPostProcessor instance can be
     * added.
     * &lt;p&gt;
     * If a null post-processor is specified, no action is taken and no
     * exception is thrown.
     * &lt;p&gt;
     * In a multithreaded application, {@link KeyEventPostProcessor} behaves
     * the same as other AWT listeners.  See
     * &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for more details.
     *
     * @param processor the KeyEventPostProcessor to add to the post-processor
     *        chain
     * @see #removeKeyEventPostProcessor
     */
    public void addKeyEventPostProcessor(KeyEventPostProcessor processor) {
<span class="pc bpc" id="L1788" title="1 of 2 branches missed.">        if (processor != null) {</span>
<span class="fc" id="L1789">            synchronized (this) {</span>
<span class="pc bpc" id="L1790" title="1 of 2 branches missed.">                if (keyEventPostProcessors == null) {</span>
<span class="fc" id="L1791">                    keyEventPostProcessors = new java.util.LinkedList&lt;&gt;();</span>
                }
<span class="fc" id="L1793">                keyEventPostProcessors.add(processor);</span>
<span class="pc" id="L1794">            }</span>
        }
<span class="fc" id="L1796">    }</span>


    /**
     * Removes a previously added KeyEventPostProcessor from this
     * KeyboardFocusManager's post-processor chain. This KeyboardFocusManager
     * cannot itself be entirely removed from the chain. Only additional
     * references added via &lt;code&gt;addKeyEventPostProcessor&lt;/code&gt; can be
     * removed.
     * &lt;p&gt;
     * If a null post-processor is specified, if the specified post-processor
     * is not in the post-processor chain, or if this KeyboardFocusManager is
     * specified without having been explicitly added, no action is taken and
     * no exception is thrown.
     * &lt;p&gt;
     * In a multithreaded application, {@link KeyEventPostProcessor} behaves
     * the same as other AWT listeners.  See
     * &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for more details.
     *
     * @param processor the KeyEventPostProcessor to remove from the post-
     *        processor chain
     * @see #addKeyEventPostProcessor
     */
    public void removeKeyEventPostProcessor(KeyEventPostProcessor processor) {
<span class="nc bnc" id="L1821" title="All 2 branches missed.">        if (processor != null) {</span>
<span class="nc" id="L1822">            synchronized (this) {</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">                if (keyEventPostProcessors != null) {</span>
<span class="nc" id="L1824">                    keyEventPostProcessors.remove(processor);</span>
                }
<span class="nc" id="L1826">            }</span>
        }
<span class="nc" id="L1828">    }</span>


    /**
     * Returns this KeyboardFocusManager's KeyEventPostProcessor chain as a
     * List. The List will not include this KeyboardFocusManager unless it was
     * explicitly added via a call to &lt;code&gt;addKeyEventPostProcessor&lt;/code&gt;. If
     * no KeyEventPostProcessors are registered, implementations are free to
     * return null or a List of length 0. Client code should not assume one
     * behavior over another, nor should it assume that the behavior, once
     * established, will not change.
     *
     * @return a possibly null or empty List of KeyEventPostProcessors
     * @see #addKeyEventPostProcessor
     * @see #removeKeyEventPostProcessor
     */
    protected java.util.List&lt;KeyEventPostProcessor&gt;
        getKeyEventPostProcessors()
    {
<span class="nc bnc" id="L1847" title="All 2 branches missed.">        return (keyEventPostProcessors != null)</span>
<span class="nc" id="L1848">            ? (java.util.List)keyEventPostProcessors.clone()</span>
            : null;
    }



    static void setMostRecentFocusOwner(Component component) {
<span class="nc" id="L1855">        Component window = component;</span>
<span class="nc bnc" id="L1856" title="All 4 branches missed.">        while (window != null &amp;&amp; !(window instanceof Window)) {</span>
<span class="nc" id="L1857">            window = window.parent;</span>
        }
<span class="nc bnc" id="L1859" title="All 2 branches missed.">        if (window != null) {</span>
<span class="nc" id="L1860">            setMostRecentFocusOwner((Window)window, component);</span>
        }
<span class="nc" id="L1862">    }</span>
    static synchronized void setMostRecentFocusOwner(Window window,
                                                     Component component) {
        // ATTN: component has a strong reference to window via chain
        // of Component.parent fields.  Since WeakHasMap refers to its
        // values strongly, we need to break the strong link from the
        // value (component) back to its key (window).
<span class="nc" id="L1869">        WeakReference&lt;Component&gt; weakValue = null;</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">        if (component != null) {</span>
<span class="nc" id="L1871">            weakValue = new WeakReference&lt;&gt;(component);</span>
        }
<span class="nc" id="L1873">        mostRecentFocusOwners.put(window, weakValue);</span>
<span class="nc" id="L1874">    }</span>
    static void clearMostRecentFocusOwner(Component comp) {
        Container window;

<span class="nc bnc" id="L1878" title="All 2 branches missed.">        if (comp == null) {</span>
<span class="nc" id="L1879">            return;</span>
        }

<span class="nc" id="L1882">        synchronized (comp.getTreeLock()) {</span>
<span class="nc" id="L1883">            window = comp.getParent();</span>
<span class="nc bnc" id="L1884" title="All 4 branches missed.">            while (window != null &amp;&amp; !(window instanceof Window)) {</span>
<span class="nc" id="L1885">                window = window.getParent();</span>
            }
<span class="nc" id="L1887">        }</span>

<span class="nc" id="L1889">        synchronized (KeyboardFocusManager.class) {</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">            if ((window != null)</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">                &amp;&amp; (getMostRecentFocusOwner((Window)window) == comp))</span>
            {
<span class="nc" id="L1893">                setMostRecentFocusOwner((Window)window, null);</span>
            }
            // Also clear temporary lost component stored in Window
<span class="nc bnc" id="L1896" title="All 2 branches missed.">            if (window != null) {</span>
<span class="nc" id="L1897">                Window realWindow = (Window)window;</span>
<span class="nc bnc" id="L1898" title="All 2 branches missed.">                if (realWindow.getTemporaryLostComponent() == comp) {</span>
<span class="nc" id="L1899">                    realWindow.setTemporaryLostComponent(null);</span>
                }
            }
<span class="nc" id="L1902">        }</span>
<span class="nc" id="L1903">    }</span>

    /*
     * Please be careful changing this method! It is called from
     * javax.swing.JComponent.runInputVerifier() using reflection.
     */
    static synchronized Component getMostRecentFocusOwner(Window window) {
<span class="nc" id="L1910">        WeakReference&lt;Component&gt; weakValue =</span>
<span class="nc" id="L1911">            (WeakReference)mostRecentFocusOwners.get(window);</span>
<span class="nc bnc" id="L1912" title="All 2 branches missed.">        return weakValue == null ? null : (Component)weakValue.get();</span>
    }

    /**
     * This method is called by the AWT event dispatcher requesting that the
     * current KeyboardFocusManager dispatch the specified event on its behalf.
     * It is expected that all KeyboardFocusManagers will dispatch all
     * FocusEvents, all WindowEvents related to focus, and all KeyEvents.
     * These events should be dispatched based on the KeyboardFocusManager's
     * notion of the focus owner and the focused and active Windows, sometimes
     * overriding the source of the specified AWTEvent. Dispatching must be
     * done using &lt;code&gt;redispatchEvent&lt;/code&gt; to prevent the AWT event
     * dispatcher from recursively requesting that the KeyboardFocusManager
     * dispatch the event again. If this method returns &lt;code&gt;false&lt;/code&gt;,
     * then the AWT event dispatcher will attempt to dispatch the event itself.
     *
     * @param e the AWTEvent to be dispatched
     * @return &lt;code&gt;true&lt;/code&gt; if this method dispatched the event;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #redispatchEvent
     * @see #dispatchKeyEvent
     */
    public abstract boolean dispatchEvent(AWTEvent e);

    /**
     * Redispatches an AWTEvent in such a way that the AWT event dispatcher
     * will not recursively request that the KeyboardFocusManager, or any
     * installed KeyEventDispatchers, dispatch the event again. Client
     * implementations of &lt;code&gt;dispatchEvent&lt;/code&gt; and client-defined
     * KeyEventDispatchers must call &lt;code&gt;redispatchEvent(target, e)&lt;/code&gt;
     * instead of &lt;code&gt;target.dispatchEvent(e)&lt;/code&gt; to dispatch an event.
     * &lt;p&gt;
     * This method is intended to be used only by KeyboardFocusManagers and
     * KeyEventDispatchers. It is not for general client use.
     *
     * @param target the Component to which the event should be dispatched
     * @param e the event to dispatch
     * @see #dispatchEvent
     * @see KeyEventDispatcher
     */
    public final void redispatchEvent(Component target, AWTEvent e) {
<span class="nc" id="L1953">        e.focusManagerIsDispatching = true;</span>
<span class="nc" id="L1954">        target.dispatchEvent(e);</span>
<span class="nc" id="L1955">        e.focusManagerIsDispatching = false;</span>
<span class="nc" id="L1956">    }</span>

    /**
     * Typically this method will be called by &lt;code&gt;dispatchEvent&lt;/code&gt; if no
     * other KeyEventDispatcher in the dispatcher chain dispatched the
     * KeyEvent, or if no other KeyEventDispatchers are registered. If an
     * implementation of this method returns &lt;code&gt;false&lt;/code&gt;,
     * &lt;code&gt;dispatchEvent&lt;/code&gt; may try to dispatch the KeyEvent itself, or
     * may simply return &lt;code&gt;false&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt; is returned,
     * &lt;code&gt;dispatchEvent&lt;/code&gt; should return &lt;code&gt;true&lt;/code&gt; as well.
     *
     * @param e the KeyEvent which the current KeyboardFocusManager has
     *        requested that this KeyEventDispatcher dispatch
     * @return &lt;code&gt;true&lt;/code&gt; if the KeyEvent was dispatched;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #dispatchEvent
     */
    public abstract boolean dispatchKeyEvent(KeyEvent e);

    /**
     * This method will be called by &lt;code&gt;dispatchKeyEvent&lt;/code&gt;.
     * By default, this method will handle any unconsumed KeyEvents that
     * map to an AWT &lt;code&gt;MenuShortcut&lt;/code&gt; by consuming the event
     * and activating the shortcut.
     *
     * @param e the KeyEvent to post-process
     * @return &lt;code&gt;true&lt;/code&gt; to indicate that no other
     *         KeyEventPostProcessor will be notified of the KeyEvent.
     * @see #dispatchKeyEvent
     * @see MenuShortcut
     */
    public abstract boolean postProcessKeyEvent(KeyEvent e);

    /**
     * This method initiates a focus traversal operation if and only if the
     * KeyEvent represents a focus traversal key for the specified
     * focusedComponent. It is expected that focusedComponent is the current
     * focus owner, although this need not be the case. If it is not,
     * focus traversal will nevertheless proceed as if focusedComponent
     * were the current focus owner.
     *
     * @param focusedComponent the Component that will be the basis for a focus
     *        traversal operation if the specified event represents a focus
     *        traversal key for the Component
     * @param e the event that may represent a focus traversal key
     */
    public abstract void processKeyEvent(Component focusedComponent,
                                         KeyEvent e);

    /**
     * Called by the AWT to notify the KeyboardFocusManager that it should
     * delay dispatching of KeyEvents until the specified Component becomes
     * the focus owner. If client code requests a focus change, and the AWT
     * determines that this request might be granted by the native windowing
     * system, then the AWT will call this method. It is the responsibility of
     * the KeyboardFocusManager to delay dispatching of KeyEvents with
     * timestamps later than the specified time stamp until the specified
     * Component receives a FOCUS_GAINED event, or the AWT cancels the delay
     * request by invoking &lt;code&gt;dequeueKeyEvents&lt;/code&gt; or
     * &lt;code&gt;discardKeyEvents&lt;/code&gt;.
     *
     * @param after timestamp of current event, or the current, system time if
     *        the current event has no timestamp, or the AWT cannot determine
     *        which event is currently being handled
     * @param untilFocused Component which should receive a FOCUS_GAINED event
     *        before any pending KeyEvents
     * @see #dequeueKeyEvents
     * @see #discardKeyEvents
     */
    protected abstract void enqueueKeyEvents(long after,
                                             Component untilFocused);

    /**
     * Called by the AWT to notify the KeyboardFocusManager that it should
     * cancel delayed dispatching of KeyEvents. All KeyEvents which were
     * enqueued because of a call to &lt;code&gt;enqueueKeyEvents&lt;/code&gt; with the
     * same timestamp and Component should be released for normal dispatching
     * to the current focus owner. If the given timestamp is less than zero,
     * the outstanding enqueue request for the given Component with the &lt;b&gt;
     * oldest&lt;/b&gt; timestamp (if any) should be cancelled.
     *
     * @param after the timestamp specified in the call to
     *        &lt;code&gt;enqueueKeyEvents&lt;/code&gt;, or any value &amp;lt; 0
     * @param untilFocused the Component specified in the call to
     *        &lt;code&gt;enqueueKeyEvents&lt;/code&gt;
     * @see #enqueueKeyEvents
     * @see #discardKeyEvents
     */
    protected abstract void dequeueKeyEvents(long after,
                                             Component untilFocused);

    /**
     * Called by the AWT to notify the KeyboardFocusManager that it should
     * cancel delayed dispatching of KeyEvents. All KeyEvents which were
     * enqueued because of one or more calls to &lt;code&gt;enqueueKeyEvents&lt;/code&gt;
     * with the same Component should be discarded.
     *
     * @param comp the Component specified in one or more calls to
     *        &lt;code&gt;enqueueKeyEvents&lt;/code&gt;
     * @see #enqueueKeyEvents
     * @see #dequeueKeyEvents
     */
    protected abstract void discardKeyEvents(Component comp);

    /**
     * Focuses the Component after aComponent, typically based on a
     * FocusTraversalPolicy.
     *
     * @param aComponent the Component that is the basis for the focus
     *        traversal operation
     * @see FocusTraversalPolicy
     */
    public abstract void focusNextComponent(Component aComponent);

    /**
     * Focuses the Component before aComponent, typically based on a
     * FocusTraversalPolicy.
     *
     * @param aComponent the Component that is the basis for the focus
     *        traversal operation
     * @see FocusTraversalPolicy
     */
    public abstract void focusPreviousComponent(Component aComponent);

    /**
     * Moves the focus up one focus traversal cycle. Typically, the focus owner
     * is set to aComponent's focus cycle root, and the current focus cycle
     * root is set to the new focus owner's focus cycle root. If, however,
     * aComponent's focus cycle root is a Window, then typically the focus
     * owner is set to the Window's default Component to focus, and the current
     * focus cycle root is unchanged.
     *
     * @param aComponent the Component that is the basis for the focus
     *        traversal operation
     */
    public abstract void upFocusCycle(Component aComponent);

    /**
     * Moves the focus down one focus traversal cycle. Typically, if
     * aContainer is a focus cycle root, then the focus owner is set to
     * aContainer's default Component to focus, and the current focus cycle
     * root is set to aContainer. If aContainer is not a focus cycle root, then
     * no focus traversal operation occurs.
     *
     * @param aContainer the Container that is the basis for the focus
     *        traversal operation
     */
    public abstract void downFocusCycle(Container aContainer);

    /**
     * Focuses the Component after the current focus owner.
     */
    public final void focusNextComponent() {
<span class="nc" id="L2109">        Component focusOwner = getFocusOwner();</span>
<span class="nc bnc" id="L2110" title="All 2 branches missed.">        if (focusOwner != null) {</span>
<span class="nc" id="L2111">            focusNextComponent(focusOwner);</span>
        }
<span class="nc" id="L2113">    }</span>

    /**
     * Focuses the Component before the current focus owner.
     */
    public final void focusPreviousComponent() {
<span class="nc" id="L2119">        Component focusOwner = getFocusOwner();</span>
<span class="nc bnc" id="L2120" title="All 2 branches missed.">        if (focusOwner != null) {</span>
<span class="nc" id="L2121">            focusPreviousComponent(focusOwner);</span>
        }
<span class="nc" id="L2123">    }</span>

    /**
     * Moves the focus up one focus traversal cycle from the current focus
     * owner. Typically, the new focus owner is set to the current focus
     * owner's focus cycle root, and the current focus cycle root is set to the
     * new focus owner's focus cycle root. If, however, the current focus
     * owner's focus cycle root is a Window, then typically the focus owner is
     * set to the focus cycle root's default Component to focus, and the
     * current focus cycle root is unchanged.
     */
    public final void upFocusCycle() {
<span class="nc" id="L2135">        Component focusOwner = getFocusOwner();</span>
<span class="nc bnc" id="L2136" title="All 2 branches missed.">        if (focusOwner != null) {</span>
<span class="nc" id="L2137">            upFocusCycle(focusOwner);</span>
        }
<span class="nc" id="L2139">    }</span>

    /**
     * Moves the focus down one focus traversal cycle from the current focus
     * owner, if and only if the current focus owner is a Container that is a
     * focus cycle root. Typically, the focus owner is set to the current focus
     * owner's default Component to focus, and the current focus cycle root is
     * set to the current focus owner. If the current focus owner is not a
     * Container that is a focus cycle root, then no focus traversal operation
     * occurs.
     */
    public final void downFocusCycle() {
<span class="nc" id="L2151">        Component focusOwner = getFocusOwner();</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">        if (focusOwner instanceof Container) {</span>
<span class="nc" id="L2153">            downFocusCycle((Container)focusOwner);</span>
        }
<span class="nc" id="L2155">    }</span>

    /**
     * Dumps the list of focus requests to stderr
     */
    void dumpRequests() {
<span class="nc" id="L2161">        System.err.println(&quot;&gt;&gt;&gt; Requests dump, time: &quot; + System.currentTimeMillis());</span>
<span class="nc" id="L2162">        synchronized (heavyweightRequests) {</span>
<span class="nc bnc" id="L2163" title="All 2 branches missed.">            for (HeavyweightFocusRequest req : heavyweightRequests) {</span>
<span class="nc" id="L2164">                System.err.println(&quot;&gt;&gt;&gt; Req: &quot; + req);</span>
<span class="nc" id="L2165">            }</span>
<span class="nc" id="L2166">        }</span>
<span class="nc" id="L2167">        System.err.println(&quot;&quot;);</span>
<span class="nc" id="L2168">    }</span>

    private static final class LightweightFocusRequest {
        final Component component;
        final boolean temporary;
        final CausedFocusEvent.Cause cause;

<span class="nc" id="L2175">        LightweightFocusRequest(Component component, boolean temporary, CausedFocusEvent.Cause cause) {</span>
<span class="nc" id="L2176">            this.component = component;</span>
<span class="nc" id="L2177">            this.temporary = temporary;</span>
<span class="nc" id="L2178">            this.cause = cause;</span>
<span class="nc" id="L2179">        }</span>
        public String toString() {
<span class="nc" id="L2181">            return &quot;LightweightFocusRequest[component=&quot; + component +</span>
                &quot;,temporary=&quot; + temporary + &quot;, cause=&quot; + cause + &quot;]&quot;;
        }
    }

    private static final class HeavyweightFocusRequest {
        final Component heavyweight;
        final LinkedList&lt;LightweightFocusRequest&gt; lightweightRequests;

<span class="nc" id="L2190">        static final HeavyweightFocusRequest CLEAR_GLOBAL_FOCUS_OWNER =</span>
            new HeavyweightFocusRequest();

<span class="nc" id="L2193">        private HeavyweightFocusRequest() {</span>
<span class="nc" id="L2194">            heavyweight = null;</span>
<span class="nc" id="L2195">            lightweightRequests = null;</span>
<span class="nc" id="L2196">        }</span>

        HeavyweightFocusRequest(Component heavyweight, Component descendant,
<span class="nc" id="L2199">                                boolean temporary, CausedFocusEvent.Cause cause) {</span>
<span class="nc bnc" id="L2200" title="All 2 branches missed.">            if (log.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc bnc" id="L2201" title="All 2 branches missed.">                if (heavyweight == null) {</span>
<span class="nc" id="L2202">                    log.fine(&quot;Assertion (heavyweight != null) failed&quot;);</span>
                }
            }

<span class="nc" id="L2206">            this.heavyweight = heavyweight;</span>
<span class="nc" id="L2207">            this.lightweightRequests = new LinkedList&lt;LightweightFocusRequest&gt;();</span>
<span class="nc" id="L2208">            addLightweightRequest(descendant, temporary, cause);</span>
<span class="nc" id="L2209">        }</span>
        boolean addLightweightRequest(Component descendant,
                                      boolean temporary, CausedFocusEvent.Cause cause) {
<span class="nc bnc" id="L2212" title="All 2 branches missed.">            if (log.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc bnc" id="L2213" title="All 2 branches missed.">                if (this == HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER) {</span>
<span class="nc" id="L2214">                    log.fine(&quot;Assertion (this != HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER) failed&quot;);</span>
                }
<span class="nc bnc" id="L2216" title="All 2 branches missed.">                if (descendant == null) {</span>
<span class="nc" id="L2217">                    log.fine(&quot;Assertion (descendant != null) failed&quot;);</span>
                }
            }

<span class="nc bnc" id="L2221" title="All 2 branches missed.">            Component lastDescendant = ((lightweightRequests.size() &gt; 0)</span>
<span class="nc" id="L2222">                ? lightweightRequests.getLast().component</span>
                : null);

<span class="nc bnc" id="L2225" title="All 2 branches missed.">            if (descendant != lastDescendant) {</span>
                // Not a duplicate request
<span class="nc" id="L2227">                lightweightRequests.add</span>
<span class="nc" id="L2228">                    (new LightweightFocusRequest(descendant, temporary, cause));</span>
<span class="nc" id="L2229">                return true;</span>
            } else {
<span class="nc" id="L2231">                return false;</span>
            }
        }

        LightweightFocusRequest getFirstLightweightRequest() {
<span class="nc bnc" id="L2236" title="All 2 branches missed.">            if (this == CLEAR_GLOBAL_FOCUS_OWNER) {</span>
<span class="nc" id="L2237">                return null;</span>
            }
<span class="nc" id="L2239">            return lightweightRequests.getFirst();</span>
        }
        public String toString() {
<span class="nc" id="L2242">            boolean first = true;</span>
<span class="nc" id="L2243">            String str = &quot;HeavyweightFocusRequest[heavweight=&quot; + heavyweight +</span>
                &quot;,lightweightRequests=&quot;;
<span class="nc bnc" id="L2245" title="All 2 branches missed.">            if (lightweightRequests == null) {</span>
<span class="nc" id="L2246">                str += null;</span>
            } else {
<span class="nc" id="L2248">                str += &quot;[&quot;;</span>

<span class="nc bnc" id="L2250" title="All 2 branches missed.">                for (LightweightFocusRequest lwRequest : lightweightRequests) {</span>
<span class="nc bnc" id="L2251" title="All 2 branches missed.">                    if (first) {</span>
<span class="nc" id="L2252">                        first = false;</span>
                    } else {
<span class="nc" id="L2254">                        str += &quot;,&quot;;</span>
                    }
<span class="nc" id="L2256">                    str += lwRequest;</span>
<span class="nc" id="L2257">                }</span>
<span class="nc" id="L2258">                str += &quot;]&quot;;</span>
            }
<span class="nc" id="L2260">            str += &quot;]&quot;;</span>
<span class="nc" id="L2261">            return str;</span>
        }
    }

    /*
     * heavyweightRequests is used as a monitor for synchronized changes of
     * currentLightweightRequests, clearingCurrentLightweightRequests and
     * newFocusOwner.
     */
<span class="fc" id="L2270">    private static LinkedList&lt;HeavyweightFocusRequest&gt; heavyweightRequests =</span>
        new LinkedList&lt;HeavyweightFocusRequest&gt;();
    private static LinkedList&lt;LightweightFocusRequest&gt; currentLightweightRequests;
    private static boolean clearingCurrentLightweightRequests;
<span class="fc" id="L2274">    private static boolean allowSyncFocusRequests = true;</span>
<span class="fc" id="L2275">    private static Component newFocusOwner = null;</span>
    private static volatile boolean disableRestoreFocus;

    static final int SNFH_FAILURE = 0;
    static final int SNFH_SUCCESS_HANDLED = 1;
    static final int SNFH_SUCCESS_PROCEED = 2;

    static boolean processSynchronousLightweightTransfer(Component heavyweight, Component descendant,
                                                  boolean temporary, boolean focusedWindowChangeAllowed,
                                                  long time)
    {
<span class="nc" id="L2286">        Window parentWindow = SunToolkit.getContainingWindow(heavyweight);</span>
<span class="nc bnc" id="L2287" title="All 4 branches missed.">        if (parentWindow == null || !parentWindow.syncLWRequests) {</span>
<span class="nc" id="L2288">            return false;</span>
        }
<span class="nc bnc" id="L2290" title="All 2 branches missed.">        if (descendant == null) {</span>
            // Focus transfers from a lightweight child back to the
            // heavyweight Container should be treated like lightweight
            // focus transfers.
<span class="nc" id="L2294">            descendant = heavyweight;</span>
        }

<span class="nc" id="L2297">        KeyboardFocusManager manager = getCurrentKeyboardFocusManager(SunToolkit.targetToAppContext(descendant));</span>

<span class="nc" id="L2299">        FocusEvent currentFocusOwnerEvent = null;</span>
<span class="nc" id="L2300">        FocusEvent newFocusOwnerEvent = null;</span>
<span class="nc" id="L2301">        Component currentFocusOwner = manager.getGlobalFocusOwner();</span>

<span class="nc" id="L2303">        synchronized (heavyweightRequests) {</span>
<span class="nc" id="L2304">            HeavyweightFocusRequest hwFocusRequest = getLastHWRequest();</span>
<span class="nc bnc" id="L2305" title="All 2 branches missed.">            if (hwFocusRequest == null &amp;&amp;</span>
<span class="nc bnc" id="L2306" title="All 4 branches missed.">                heavyweight == manager.getNativeFocusOwner() &amp;&amp;</span>
                allowSyncFocusRequests)
            {

<span class="nc bnc" id="L2310" title="All 2 branches missed.">                if (descendant == currentFocusOwner) {</span>
                    // Redundant request.
<span class="nc" id="L2312">                    return true;</span>
                }

                // 'heavyweight' owns the native focus and there are no pending
                // requests. 'heavyweight' must be a Container and
                // 'descendant' must not be the focus owner. Otherwise,
                // we would never have gotten this far.
<span class="nc" id="L2319">                manager.enqueueKeyEvents(time, descendant);</span>

<span class="nc" id="L2321">                hwFocusRequest =</span>
                    new HeavyweightFocusRequest(heavyweight, descendant,
                                                temporary, CausedFocusEvent.Cause.UNKNOWN);
<span class="nc" id="L2324">                heavyweightRequests.add(hwFocusRequest);</span>

<span class="nc bnc" id="L2326" title="All 2 branches missed.">                if (currentFocusOwner != null) {</span>
<span class="nc" id="L2327">                    currentFocusOwnerEvent =</span>
                        new FocusEvent(currentFocusOwner,
                                       FocusEvent.FOCUS_LOST,
                                       temporary, descendant);
                }
<span class="nc" id="L2332">                newFocusOwnerEvent =</span>
                    new FocusEvent(descendant, FocusEvent.FOCUS_GAINED,
                                   temporary, currentFocusOwner);
            }
<span class="nc" id="L2336">        }</span>
<span class="nc" id="L2337">        boolean result = false;</span>
<span class="nc" id="L2338">        final boolean clearing = clearingCurrentLightweightRequests;</span>

<span class="nc" id="L2340">        Throwable caughtEx = null;</span>
        try {
<span class="nc" id="L2342">            clearingCurrentLightweightRequests = false;</span>
<span class="nc" id="L2343">            synchronized(Component.LOCK) {</span>

<span class="nc bnc" id="L2345" title="All 4 branches missed.">                if (currentFocusOwnerEvent != null &amp;&amp; currentFocusOwner != null) {</span>
<span class="nc" id="L2346">                    ((AWTEvent) currentFocusOwnerEvent).isPosted = true;</span>
<span class="nc" id="L2347">                    caughtEx = dispatchAndCatchException(caughtEx, currentFocusOwner, currentFocusOwnerEvent);</span>
<span class="nc" id="L2348">                    result = true;</span>
                }

<span class="nc bnc" id="L2351" title="All 4 branches missed.">                if (newFocusOwnerEvent != null &amp;&amp; descendant != null) {</span>
<span class="nc" id="L2352">                    ((AWTEvent) newFocusOwnerEvent).isPosted = true;</span>
<span class="nc" id="L2353">                    caughtEx = dispatchAndCatchException(caughtEx, descendant, newFocusOwnerEvent);</span>
<span class="nc" id="L2354">                    result = true;</span>
                }
<span class="nc" id="L2356">            }</span>
        } finally {
<span class="nc" id="L2358">            clearingCurrentLightweightRequests = clearing;</span>
<span class="nc" id="L2359">        }</span>
<span class="nc bnc" id="L2360" title="All 2 branches missed.">        if (caughtEx instanceof RuntimeException) {</span>
<span class="nc" id="L2361">            throw (RuntimeException)caughtEx;</span>
<span class="nc bnc" id="L2362" title="All 2 branches missed.">        } else if (caughtEx instanceof Error) {</span>
<span class="nc" id="L2363">            throw (Error)caughtEx;</span>
        }
<span class="nc" id="L2365">        return result;</span>
    }

    /**
     * Indicates whether the native implementation should proceed with a
     * pending, native focus request. Before changing the focus at the native
     * level, the AWT implementation should always call this function for
     * permission. This function will reject the request if a duplicate request
     * preceded it, or if the specified heavyweight Component already owns the
     * focus and no native focus changes are pending. Otherwise, the request
     * will be approved and the focus request list will be updated so that,
     * if necessary, the proper descendant will be focused when the
     * corresponding FOCUS_GAINED event on the heavyweight is received.
     *
     * An implementation must ensure that calls to this method and native
     * focus changes are atomic. If this is not guaranteed, then the ordering
     * of the focus request list may be incorrect, leading to errors in the
     * type-ahead mechanism. Typically this is accomplished by only calling
     * this function from the native event pumping thread, or by holding a
     * global, native lock during invocation.
     */
    static int shouldNativelyFocusHeavyweight
        (Component heavyweight, Component descendant, boolean temporary,
         boolean focusedWindowChangeAllowed, long time, CausedFocusEvent.Cause cause)
    {
<span class="nc bnc" id="L2390" title="All 2 branches missed.">        if (log.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc bnc" id="L2391" title="All 2 branches missed.">            if (heavyweight == null) {</span>
<span class="nc" id="L2392">                log.fine(&quot;Assertion (heavyweight != null) failed&quot;);</span>
            }
<span class="nc bnc" id="L2394" title="All 2 branches missed.">            if (time == 0) {</span>
<span class="nc" id="L2395">                log.fine(&quot;Assertion (time != 0) failed&quot;);</span>
            }
        }

<span class="nc bnc" id="L2399" title="All 2 branches missed.">        if (descendant == null) {</span>
            // Focus transfers from a lightweight child back to the
            // heavyweight Container should be treated like lightweight
            // focus transfers.
<span class="nc" id="L2403">            descendant = heavyweight;</span>
        }

<span class="nc" id="L2406">        KeyboardFocusManager manager =</span>
<span class="nc" id="L2407">            getCurrentKeyboardFocusManager(SunToolkit.targetToAppContext(descendant));</span>
<span class="nc" id="L2408">        KeyboardFocusManager thisManager = getCurrentKeyboardFocusManager();</span>
<span class="nc" id="L2409">        Component currentFocusOwner = thisManager.getGlobalFocusOwner();</span>
<span class="nc" id="L2410">        Component nativeFocusOwner = thisManager.getNativeFocusOwner();</span>
<span class="nc" id="L2411">        Window nativeFocusedWindow = thisManager.getNativeFocusedWindow();</span>
<span class="nc bnc" id="L2412" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L2413">            focusLog.finer(&quot;SNFH for {0} in {1}&quot;,</span>
<span class="nc" id="L2414">                       String.valueOf(descendant), String.valueOf(heavyweight));</span>
        }
<span class="nc bnc" id="L2416" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L2417">            focusLog.finest(&quot;0. Current focus owner {0}&quot;,</span>
<span class="nc" id="L2418">                            String.valueOf(currentFocusOwner));</span>
<span class="nc" id="L2419">            focusLog.finest(&quot;0. Native focus owner {0}&quot;,</span>
<span class="nc" id="L2420">                            String.valueOf(nativeFocusOwner));</span>
<span class="nc" id="L2421">            focusLog.finest(&quot;0. Native focused window {0}&quot;,</span>
<span class="nc" id="L2422">                            String.valueOf(nativeFocusedWindow));</span>
        }
<span class="nc" id="L2424">        synchronized (heavyweightRequests) {</span>
<span class="nc" id="L2425">            HeavyweightFocusRequest hwFocusRequest = getLastHWRequest();</span>
<span class="nc bnc" id="L2426" title="All 2 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L2427">                focusLog.finest(&quot;Request {0}&quot;, String.valueOf(hwFocusRequest));</span>
            }
<span class="nc bnc" id="L2429" title="All 4 branches missed.">            if (hwFocusRequest == null &amp;&amp;</span>
                heavyweight == nativeFocusOwner &amp;&amp;
<span class="nc bnc" id="L2431" title="All 2 branches missed.">                heavyweight.getContainingWindow() == nativeFocusedWindow)</span>
            {
<span class="nc bnc" id="L2433" title="All 2 branches missed.">                if (descendant == currentFocusOwner) {</span>
                    // Redundant request.
<span class="nc bnc" id="L2435" title="All 2 branches missed.">                    if (focusLog.isLoggable(PlatformLogger.Level.FINEST))</span>
<span class="nc" id="L2436">                        focusLog.finest(&quot;1. SNFH_FAILURE for {0}&quot;,</span>
<span class="nc" id="L2437">                                        String.valueOf(descendant));</span>
<span class="nc" id="L2438">                    return SNFH_FAILURE;</span>
                }

                // 'heavyweight' owns the native focus and there are no pending
                // requests. 'heavyweight' must be a Container and
                // 'descendant' must not be the focus owner. Otherwise,
                // we would never have gotten this far.
<span class="nc" id="L2445">                manager.enqueueKeyEvents(time, descendant);</span>

<span class="nc" id="L2447">                hwFocusRequest =</span>
                    new HeavyweightFocusRequest(heavyweight, descendant,
                                                temporary, cause);
<span class="nc" id="L2450">                heavyweightRequests.add(hwFocusRequest);</span>

<span class="nc bnc" id="L2452" title="All 2 branches missed.">                if (currentFocusOwner != null) {</span>
<span class="nc" id="L2453">                    FocusEvent currentFocusOwnerEvent =</span>
                        new CausedFocusEvent(currentFocusOwner,
                                       FocusEvent.FOCUS_LOST,
                                       temporary, descendant, cause);
                    // Fix 5028014. Rolled out.
                    // SunToolkit.postPriorityEvent(currentFocusOwnerEvent);
<span class="nc" id="L2459">                    SunToolkit.postEvent(currentFocusOwner.appContext,</span>
                                         currentFocusOwnerEvent);
                }
<span class="nc" id="L2462">                FocusEvent newFocusOwnerEvent =</span>
                    new CausedFocusEvent(descendant, FocusEvent.FOCUS_GAINED,
                                   temporary, currentFocusOwner, cause);
                // Fix 5028014. Rolled out.
                // SunToolkit.postPriorityEvent(newFocusOwnerEvent);
<span class="nc" id="L2467">                SunToolkit.postEvent(descendant.appContext, newFocusOwnerEvent);</span>

<span class="nc bnc" id="L2469" title="All 2 branches missed.">                if (focusLog.isLoggable(PlatformLogger.Level.FINEST))</span>
<span class="nc" id="L2470">                    focusLog.finest(&quot;2. SNFH_HANDLED for {0}&quot;, String.valueOf(descendant));</span>
<span class="nc" id="L2471">                return SNFH_SUCCESS_HANDLED;</span>
<span class="nc bnc" id="L2472" title="All 4 branches missed.">            } else if (hwFocusRequest != null &amp;&amp;</span>
                       hwFocusRequest.heavyweight == heavyweight) {
                // 'heavyweight' doesn't have the native focus right now, but
                // if all pending requests were completed, it would. Add
                // descendant to the heavyweight's list of pending
                // lightweight focus transfers.
<span class="nc bnc" id="L2478" title="All 2 branches missed.">                if (hwFocusRequest.addLightweightRequest(descendant,</span>
                                                         temporary, cause)) {
<span class="nc" id="L2480">                    manager.enqueueKeyEvents(time, descendant);</span>
                }

<span class="nc bnc" id="L2483" title="All 2 branches missed.">                if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L2484">                    focusLog.finest(&quot;3. SNFH_HANDLED for lightweight&quot; +</span>
                                    descendant + &quot; in &quot; + heavyweight);
                }
<span class="nc" id="L2487">                return SNFH_SUCCESS_HANDLED;</span>
            } else {
<span class="nc bnc" id="L2489" title="All 2 branches missed.">                if (!focusedWindowChangeAllowed) {</span>
                    // For purposes of computing oldFocusedWindow, we should look at
                    // the second to last HeavyweightFocusRequest on the queue iff the
                    // last HeavyweightFocusRequest is CLEAR_GLOBAL_FOCUS_OWNER. If
                    // there is no second to last HeavyweightFocusRequest, null is an
                    // acceptable value.
<span class="nc bnc" id="L2495" title="All 2 branches missed.">                    if (hwFocusRequest ==</span>
                        HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER)
                    {
<span class="nc" id="L2498">                        int size = heavyweightRequests.size();</span>
<span class="nc bnc" id="L2499" title="All 2 branches missed.">                        hwFocusRequest = (HeavyweightFocusRequest)((size &gt;= 2)</span>
<span class="nc" id="L2500">                            ? heavyweightRequests.get(size - 2)</span>
                            : null);
                    }
<span class="nc bnc" id="L2503" title="All 4 branches missed.">                    if (focusedWindowChanged(heavyweight,</span>
                                             (hwFocusRequest != null)
                                             ? hwFocusRequest.heavyweight
                                             : nativeFocusedWindow)) {
<span class="nc bnc" id="L2507" title="All 2 branches missed.">                        if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L2508">                            focusLog.finest(&quot;4. SNFH_FAILURE for &quot; + descendant);</span>
                        }
<span class="nc" id="L2510">                        return SNFH_FAILURE;</span>
                    }
                }

<span class="nc" id="L2514">                manager.enqueueKeyEvents(time, descendant);</span>
<span class="nc" id="L2515">                heavyweightRequests.add</span>
<span class="nc" id="L2516">                    (new HeavyweightFocusRequest(heavyweight, descendant,</span>
                                                 temporary, cause));
<span class="nc bnc" id="L2518" title="All 2 branches missed.">                if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L2519">                    focusLog.finest(&quot;5. SNFH_PROCEED for &quot; + descendant);</span>
                }
<span class="nc" id="L2521">                return SNFH_SUCCESS_PROCEED;</span>
            }
<span class="nc" id="L2523">        }</span>
    }

    /**
     * Returns the Window which will be active after processing this request,
     * or null if this is a duplicate request. The active Window is useful
     * because some native platforms do not support setting the native focus
     * owner to null. On these platforms, the obvious choice is to set the
     * focus owner to the focus proxy of the active Window.
     */
    static Window markClearGlobalFocusOwner() {
        // need to call this out of synchronized block to avoid possible deadlock
        // see 6454631.
        final Component nativeFocusedWindow =
<span class="nc" id="L2537">                getCurrentKeyboardFocusManager().getNativeFocusedWindow();</span>

<span class="nc" id="L2539">        synchronized (heavyweightRequests) {</span>
<span class="nc" id="L2540">            HeavyweightFocusRequest hwFocusRequest = getLastHWRequest();</span>
<span class="nc bnc" id="L2541" title="All 2 branches missed.">            if (hwFocusRequest ==</span>
                HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER)
            {
                // duplicate request
<span class="nc" id="L2545">                return null;</span>
            }

<span class="nc" id="L2548">            heavyweightRequests.add</span>
<span class="nc" id="L2549">                (HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER);</span>

<span class="nc bnc" id="L2551" title="All 2 branches missed.">            Component activeWindow = ((hwFocusRequest != null)</span>
<span class="nc" id="L2552">                ? SunToolkit.getContainingWindow(hwFocusRequest.heavyweight)</span>
                : nativeFocusedWindow);
<span class="nc bnc" id="L2554" title="All 6 branches missed.">            while (activeWindow != null &amp;&amp;</span>
                   !((activeWindow instanceof Frame) ||
                     (activeWindow instanceof Dialog)))
            {
<span class="nc" id="L2558">                activeWindow = activeWindow.getParent_NoClientCode();</span>
            }

<span class="nc" id="L2561">            return (Window) activeWindow;</span>
<span class="nc" id="L2562">        }</span>
    }
    Component getCurrentWaitingRequest(Component parent) {
<span class="nc" id="L2565">        synchronized (heavyweightRequests) {</span>
<span class="nc" id="L2566">            HeavyweightFocusRequest hwFocusRequest = getFirstHWRequest();</span>
<span class="nc bnc" id="L2567" title="All 2 branches missed.">            if (hwFocusRequest != null) {</span>
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                if (hwFocusRequest.heavyweight == parent) {</span>
<span class="nc" id="L2569">                    LightweightFocusRequest lwFocusRequest =</span>
<span class="nc" id="L2570">                        hwFocusRequest.lightweightRequests.getFirst();</span>
<span class="nc bnc" id="L2571" title="All 2 branches missed.">                    if (lwFocusRequest != null) {</span>
<span class="nc" id="L2572">                        return lwFocusRequest.component;</span>
                    }
                }
            }
<span class="nc" id="L2576">        }</span>
<span class="nc" id="L2577">        return null;</span>
    }

    static boolean isAutoFocusTransferEnabled() {
<span class="nc" id="L2581">        synchronized (heavyweightRequests) {</span>
<span class="nc bnc" id="L2582" title="All 6 branches missed.">            return (heavyweightRequests.size() == 0)</span>
                    &amp;&amp; !disableRestoreFocus
                    &amp;&amp; (null == currentLightweightRequests);
<span class="nc" id="L2585">        }</span>
    }

    static boolean isAutoFocusTransferEnabledFor(Component comp) {
<span class="nc bnc" id="L2589" title="All 4 branches missed.">        return isAutoFocusTransferEnabled() &amp;&amp; comp.isAutoFocusTransferOnDisposal();</span>
    }

    /*
     * Used to process exceptions in dispatching focus event (in focusLost/focusGained callbacks).
     * @param ex previously caught exception that may be processed right here, or null
     * @param comp the component to dispatch the event to
     * @param event the event to dispatch to the component
     */
    static private Throwable dispatchAndCatchException(Throwable ex, Component comp, FocusEvent event) {
<span class="nc" id="L2599">        Throwable retEx = null;</span>
        try {
<span class="nc" id="L2601">            comp.dispatchEvent(event);</span>
<span class="nc" id="L2602">        } catch (RuntimeException re) {</span>
<span class="nc" id="L2603">            retEx = re;</span>
<span class="nc" id="L2604">        } catch (Error er) {</span>
<span class="nc" id="L2605">            retEx = er;</span>
<span class="nc" id="L2606">        }</span>
<span class="nc bnc" id="L2607" title="All 2 branches missed.">        if (retEx != null) {</span>
<span class="nc bnc" id="L2608" title="All 2 branches missed.">            if (ex != null) {</span>
<span class="nc" id="L2609">                handleException(ex);</span>
            }
<span class="nc" id="L2611">            return retEx;</span>
        }
<span class="nc" id="L2613">        return ex;</span>
    }

    static private void handleException(Throwable ex) {
<span class="nc" id="L2617">        ex.printStackTrace();</span>
<span class="nc" id="L2618">    }</span>

    static void processCurrentLightweightRequests() {
<span class="nc" id="L2621">        KeyboardFocusManager manager = getCurrentKeyboardFocusManager();</span>
<span class="nc" id="L2622">        LinkedList&lt;LightweightFocusRequest&gt; localLightweightRequests = null;</span>

<span class="nc" id="L2624">        Component globalFocusOwner = manager.getGlobalFocusOwner();</span>
<span class="nc bnc" id="L2625" title="All 2 branches missed.">        if ((globalFocusOwner != null) &amp;&amp;</span>
<span class="nc bnc" id="L2626" title="All 2 branches missed.">            (globalFocusOwner.appContext != AppContext.getAppContext()))</span>
        {
            // The current app context differs from the app context of a focus
            // owner (and all pending lightweight requests), so we do nothing
            // now and wait for a next event.
<span class="nc" id="L2631">            return;</span>
        }

<span class="nc" id="L2634">        synchronized(heavyweightRequests) {</span>
<span class="nc bnc" id="L2635" title="All 2 branches missed.">            if (currentLightweightRequests != null) {</span>
<span class="nc" id="L2636">                clearingCurrentLightweightRequests = true;</span>
<span class="nc" id="L2637">                disableRestoreFocus = true;</span>
<span class="nc" id="L2638">                localLightweightRequests = currentLightweightRequests;</span>
<span class="nc bnc" id="L2639" title="All 2 branches missed.">                allowSyncFocusRequests = (localLightweightRequests.size() &lt; 2);</span>
<span class="nc" id="L2640">                currentLightweightRequests = null;</span>
            } else {
                // do nothing
<span class="nc" id="L2643">                return;</span>
            }
<span class="nc" id="L2645">        }</span>

<span class="nc" id="L2647">        Throwable caughtEx = null;</span>
        try {
<span class="nc bnc" id="L2649" title="All 2 branches missed.">            if (localLightweightRequests != null) {</span>
<span class="nc" id="L2650">                Component lastFocusOwner = null;</span>
<span class="nc" id="L2651">                Component currentFocusOwner = null;</span>

<span class="nc bnc" id="L2653" title="All 2 branches missed.">                for (Iterator&lt;KeyboardFocusManager.LightweightFocusRequest&gt; iter = localLightweightRequests.iterator(); iter.hasNext(); ) {</span>

<span class="nc" id="L2655">                    currentFocusOwner = manager.getGlobalFocusOwner();</span>
<span class="nc" id="L2656">                    LightweightFocusRequest lwFocusRequest =</span>
<span class="nc" id="L2657">                        iter.next();</span>

                    /*
                     * WARNING: This is based on DKFM's logic solely!
                     *
                     * We allow to trigger restoreFocus() in the dispatching process
                     * only if we have the last request to dispatch. If the last request
                     * fails, focus will be restored to either the component of the last
                     * previously succedded request, or to to the focus owner that was
                     * before this clearing process.
                     */
<span class="nc bnc" id="L2668" title="All 2 branches missed.">                    if (!iter.hasNext()) {</span>
<span class="nc" id="L2669">                        disableRestoreFocus = false;</span>
                    }

<span class="nc" id="L2672">                    FocusEvent currentFocusOwnerEvent = null;</span>
                    /*
                     * We're not dispatching FOCUS_LOST while the current focus owner is null.
                     * But regardless of whether it's null or not, we're clearing ALL the local
                     * lw requests.
                     */
<span class="nc bnc" id="L2678" title="All 2 branches missed.">                    if (currentFocusOwner != null) {</span>
<span class="nc" id="L2679">                        currentFocusOwnerEvent = new CausedFocusEvent(currentFocusOwner,</span>
                                       FocusEvent.FOCUS_LOST,
                                       lwFocusRequest.temporary,
                                       lwFocusRequest.component, lwFocusRequest.cause);
                    }
<span class="nc bnc" id="L2684" title="All 2 branches missed.">                    FocusEvent newFocusOwnerEvent =</span>
                        new CausedFocusEvent(lwFocusRequest.component,
                                       FocusEvent.FOCUS_GAINED,
                                       lwFocusRequest.temporary,
                                       currentFocusOwner == null ? lastFocusOwner : currentFocusOwner,
                                       lwFocusRequest.cause);

<span class="nc bnc" id="L2691" title="All 2 branches missed.">                    if (currentFocusOwner != null) {</span>
<span class="nc" id="L2692">                        ((AWTEvent) currentFocusOwnerEvent).isPosted = true;</span>
<span class="nc" id="L2693">                        caughtEx = dispatchAndCatchException(caughtEx, currentFocusOwner, currentFocusOwnerEvent);</span>
                    }

<span class="nc" id="L2696">                    ((AWTEvent) newFocusOwnerEvent).isPosted = true;</span>
<span class="nc" id="L2697">                    caughtEx = dispatchAndCatchException(caughtEx, lwFocusRequest.component, newFocusOwnerEvent);</span>

<span class="nc bnc" id="L2699" title="All 2 branches missed.">                    if (manager.getGlobalFocusOwner() == lwFocusRequest.component) {</span>
<span class="nc" id="L2700">                        lastFocusOwner = lwFocusRequest.component;</span>
                    }
<span class="nc" id="L2702">                }</span>
            }
        } finally {
<span class="nc" id="L2705">            clearingCurrentLightweightRequests = false;</span>
<span class="nc" id="L2706">            disableRestoreFocus = false;</span>
<span class="nc" id="L2707">            localLightweightRequests = null;</span>
<span class="nc" id="L2708">            allowSyncFocusRequests = true;</span>
<span class="nc" id="L2709">        }</span>
<span class="nc bnc" id="L2710" title="All 2 branches missed.">        if (caughtEx instanceof RuntimeException) {</span>
<span class="nc" id="L2711">            throw (RuntimeException)caughtEx;</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">        } else if (caughtEx instanceof Error) {</span>
<span class="nc" id="L2713">            throw (Error)caughtEx;</span>
        }
<span class="nc" id="L2715">    }</span>

    static FocusEvent retargetUnexpectedFocusEvent(FocusEvent fe) {
<span class="nc" id="L2718">        synchronized (heavyweightRequests) {</span>
            // Any other case represents a failure condition which we did
            // not expect. We need to clearFocusRequestList() and patch up
            // the event as best as possible.

<span class="nc bnc" id="L2723" title="All 2 branches missed.">            if (removeFirstRequest()) {</span>
<span class="nc" id="L2724">                return (FocusEvent)retargetFocusEvent(fe);</span>
            }

<span class="nc" id="L2727">            Component source = fe.getComponent();</span>
<span class="nc" id="L2728">            Component opposite = fe.getOppositeComponent();</span>
<span class="nc" id="L2729">            boolean temporary = false;</span>
<span class="nc bnc" id="L2730" title="All 4 branches missed.">            if (fe.getID() == FocusEvent.FOCUS_LOST &amp;&amp;</span>
<span class="nc bnc" id="L2731" title="All 2 branches missed.">                (opposite == null || isTemporary(opposite, source)))</span>
            {
<span class="nc" id="L2733">                temporary = true;</span>
            }
<span class="nc" id="L2735">            return new CausedFocusEvent(source, fe.getID(), temporary, opposite,</span>
                                        CausedFocusEvent.Cause.NATIVE_SYSTEM);
<span class="nc" id="L2737">        }</span>
    }

    static FocusEvent retargetFocusGained(FocusEvent fe) {
<span class="nc bnc" id="L2741" title="All 4 branches missed.">        assert (fe.getID() == FocusEvent.FOCUS_GAINED);</span>

<span class="nc" id="L2743">        Component currentFocusOwner = getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L2744">            getGlobalFocusOwner();</span>
<span class="nc" id="L2745">        Component source = fe.getComponent();</span>
<span class="nc" id="L2746">        Component opposite = fe.getOppositeComponent();</span>
<span class="nc" id="L2747">        Component nativeSource = getHeavyweight(source);</span>

<span class="nc" id="L2749">        synchronized (heavyweightRequests) {</span>
<span class="nc" id="L2750">            HeavyweightFocusRequest hwFocusRequest = getFirstHWRequest();</span>

<span class="nc bnc" id="L2752" title="All 2 branches missed.">            if (hwFocusRequest == HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER)</span>
            {
<span class="nc" id="L2754">                return retargetUnexpectedFocusEvent(fe);</span>
            }

<span class="nc bnc" id="L2757" title="All 6 branches missed.">            if (source != null &amp;&amp; nativeSource == null &amp;&amp; hwFocusRequest != null) {</span>
                // if source w/o peer and
                // if source is equal to first lightweight
                // then we should correct source and nativeSource
<span class="nc bnc" id="L2761" title="All 2 branches missed.">                if (source == hwFocusRequest.getFirstLightweightRequest().component)</span>
                {
<span class="nc" id="L2763">                    source = hwFocusRequest.heavyweight;</span>
<span class="nc" id="L2764">                    nativeSource = source; // source is heavuweight itself</span>
                }
            }
<span class="nc bnc" id="L2767" title="All 4 branches missed.">            if (hwFocusRequest != null &amp;&amp;</span>
                nativeSource == hwFocusRequest.heavyweight)
            {
                // Focus change as a result of a known call to requestFocus(),
                // or known click on a peer focusable heavyweight Component.

<span class="nc" id="L2773">                heavyweightRequests.removeFirst();</span>

<span class="nc" id="L2775">                LightweightFocusRequest lwFocusRequest =</span>
<span class="nc" id="L2776">                    hwFocusRequest.lightweightRequests.removeFirst();</span>

<span class="nc" id="L2778">                Component newSource = lwFocusRequest.component;</span>
<span class="nc bnc" id="L2779" title="All 2 branches missed.">                if (currentFocusOwner != null) {</span>
                    /*
                     * Since we receive FOCUS_GAINED when current focus
                     * owner is not null, correcponding FOCUS_LOST is supposed
                     * to be lost.  And so,  we keep new focus owner
                     * to determine synthetic FOCUS_LOST event which will be
                     * generated by KeyboardFocusManager for this FOCUS_GAINED.
                     *
                     * This code based on knowledge of
                     * DefaultKeyboardFocusManager's implementation and might
                     * be not applicable for another KeyboardFocusManager.
                     */
<span class="nc" id="L2791">                    newFocusOwner = newSource;</span>
                }

<span class="nc bnc" id="L2794" title="All 2 branches missed.">                boolean temporary = (opposite == null ||</span>
<span class="nc bnc" id="L2795" title="All 2 branches missed.">                                     isTemporary(newSource, opposite))</span>
                        ? false
                        : lwFocusRequest.temporary;

<span class="nc bnc" id="L2799" title="All 2 branches missed.">                if (hwFocusRequest.lightweightRequests.size() &gt; 0) {</span>
<span class="nc" id="L2800">                    currentLightweightRequests =</span>
                        hwFocusRequest.lightweightRequests;
<span class="nc" id="L2802">                    EventQueue.invokeLater(new Runnable() {</span>
                            public void run() {
<span class="nc" id="L2804">                                processCurrentLightweightRequests();</span>
<span class="nc" id="L2805">                            }</span>
                        });
                }

                // 'opposite' will be fixed by
                // DefaultKeyboardFocusManager.realOppositeComponent
<span class="nc" id="L2811">                return new CausedFocusEvent(newSource,</span>
                                      FocusEvent.FOCUS_GAINED, temporary,
                                      opposite, lwFocusRequest.cause);
            }

<span class="nc bnc" id="L2816" title="All 2 branches missed.">            if (currentFocusOwner != null</span>
<span class="nc bnc" id="L2817" title="All 6 branches missed.">                &amp;&amp; currentFocusOwner.getContainingWindow() == source</span>
                &amp;&amp; (hwFocusRequest == null || source != hwFocusRequest.heavyweight))
            {
                // Special case for FOCUS_GAINED in top-levels
                // If it arrives as the result of activation we should skip it
                // This event will not have appropriate request record and
                // on arrival there will be already some focus owner set.
<span class="nc" id="L2824">                return new CausedFocusEvent(currentFocusOwner, FocusEvent.FOCUS_GAINED, false,</span>
                                            null, CausedFocusEvent.Cause.ACTIVATION);
            }

<span class="nc" id="L2828">            return retargetUnexpectedFocusEvent(fe);</span>
<span class="nc" id="L2829">        } // end synchronized(heavyweightRequests)</span>
    }

    static FocusEvent retargetFocusLost(FocusEvent fe) {
<span class="nc bnc" id="L2833" title="All 4 branches missed.">        assert (fe.getID() == FocusEvent.FOCUS_LOST);</span>

<span class="nc" id="L2835">        Component currentFocusOwner = getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L2836">            getGlobalFocusOwner();</span>
<span class="nc" id="L2837">        Component opposite = fe.getOppositeComponent();</span>
<span class="nc" id="L2838">        Component nativeOpposite = getHeavyweight(opposite);</span>

<span class="nc" id="L2840">        synchronized (heavyweightRequests) {</span>
<span class="nc" id="L2841">            HeavyweightFocusRequest hwFocusRequest = getFirstHWRequest();</span>

<span class="nc bnc" id="L2843" title="All 2 branches missed.">            if (hwFocusRequest == HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER)</span>
            {
<span class="nc bnc" id="L2845" title="All 2 branches missed.">                if (currentFocusOwner != null) {</span>
                    // Call to KeyboardFocusManager.clearGlobalFocusOwner()
<span class="nc" id="L2847">                    heavyweightRequests.removeFirst();</span>
<span class="nc" id="L2848">                    return new CausedFocusEvent(currentFocusOwner,</span>
                                                FocusEvent.FOCUS_LOST, false, null,
                                                CausedFocusEvent.Cause.CLEAR_GLOBAL_FOCUS_OWNER);
                }

                // Otherwise, fall through to failure case below

<span class="nc bnc" id="L2855" title="All 2 branches missed.">            } else if (opposite == null)</span>
            {
                // Focus leaving application
<span class="nc bnc" id="L2858" title="All 2 branches missed.">                if (currentFocusOwner != null) {</span>
<span class="nc" id="L2859">                    return new CausedFocusEvent(currentFocusOwner,</span>
                                                FocusEvent.FOCUS_LOST,
                                                true, null, CausedFocusEvent.Cause.ACTIVATION);
                } else {
<span class="nc" id="L2863">                    return fe;</span>
                }
<span class="nc bnc" id="L2865" title="All 6 branches missed.">            } else if (hwFocusRequest != null &amp;&amp;</span>
                       (nativeOpposite == hwFocusRequest.heavyweight ||
                        nativeOpposite == null &amp;&amp;
<span class="nc bnc" id="L2868" title="All 2 branches missed.">                        opposite == hwFocusRequest.getFirstLightweightRequest().component))</span>
            {
<span class="nc bnc" id="L2870" title="All 2 branches missed.">                if (currentFocusOwner == null) {</span>
<span class="nc" id="L2871">                    return fe;</span>
                }
                // Focus change as a result of a known call to requestFocus(),
                // or click on a peer focusable heavyweight Component.
                // If a focus transfer is made across top-levels, then the
                // FOCUS_LOST event is always temporary, and the FOCUS_GAINED
                // event is always permanent. Otherwise, the stored temporary
                // value is honored.

<span class="nc" id="L2880">                LightweightFocusRequest lwFocusRequest =</span>
<span class="nc" id="L2881">                    hwFocusRequest.lightweightRequests.getFirst();</span>

<span class="nc bnc" id="L2883" title="All 2 branches missed.">                boolean temporary = isTemporary(opposite, currentFocusOwner)</span>
                    ? true
                    : lwFocusRequest.temporary;

<span class="nc" id="L2887">                return new CausedFocusEvent(currentFocusOwner, FocusEvent.FOCUS_LOST,</span>
                                            temporary, lwFocusRequest.component, lwFocusRequest.cause);
<span class="nc bnc" id="L2889" title="All 2 branches missed.">            } else if (focusedWindowChanged(opposite, currentFocusOwner)) {</span>
                // If top-level changed there might be no focus request in a list
                // But we know the opposite, we now it is temporary - dispatch the event.
<span class="nc bnc" id="L2892" title="All 4 branches missed.">                if (!fe.isTemporary() &amp;&amp; currentFocusOwner != null) {</span>
                    // Create copy of the event with only difference in temporary parameter.
<span class="nc" id="L2894">                    fe = new CausedFocusEvent(currentFocusOwner, FocusEvent.FOCUS_LOST,</span>
                                              true, opposite, CausedFocusEvent.Cause.ACTIVATION);
                }
<span class="nc" id="L2897">                return fe;</span>
            }

<span class="nc" id="L2900">            return retargetUnexpectedFocusEvent(fe);</span>
<span class="nc" id="L2901">        }  // end synchronized(heavyweightRequests)</span>
    }

    static AWTEvent retargetFocusEvent(AWTEvent event) {
<span class="nc bnc" id="L2905" title="All 2 branches missed.">        if (clearingCurrentLightweightRequests) {</span>
<span class="nc" id="L2906">            return event;</span>
        }

<span class="nc" id="L2909">        KeyboardFocusManager manager = getCurrentKeyboardFocusManager();</span>
<span class="nc bnc" id="L2910" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc bnc" id="L2911" title="All 4 branches missed.">            if (event instanceof FocusEvent || event instanceof WindowEvent) {</span>
<span class="nc" id="L2912">                focusLog.finer(&quot;&gt;&gt;&gt; {0}&quot;, String.valueOf(event));</span>
            }
<span class="nc bnc" id="L2914" title="All 4 branches missed.">            if (focusLog.isLoggable(PlatformLogger.Level.FINER) &amp;&amp; event instanceof KeyEvent) {</span>
<span class="nc" id="L2915">                focusLog.finer(&quot;    focus owner is {0}&quot;,</span>
<span class="nc" id="L2916">                               String.valueOf(manager.getGlobalFocusOwner()));</span>
<span class="nc" id="L2917">                focusLog.finer(&quot;&gt;&gt;&gt; {0}&quot;, String.valueOf(event));</span>
            }
        }

<span class="nc" id="L2921">        synchronized(heavyweightRequests) {</span>
            /*
             * This code handles FOCUS_LOST event which is generated by
             * DefaultKeyboardFocusManager for FOCUS_GAINED.
             *
             * This code based on knowledge of DefaultKeyboardFocusManager's
             * implementation and might be not applicable for another
             * KeyboardFocusManager.
             *
             * Fix for 4472032
             */
<span class="nc bnc" id="L2932" title="All 2 branches missed.">            if (newFocusOwner != null &amp;&amp;</span>
<span class="nc bnc" id="L2933" title="All 2 branches missed.">                event.getID() == FocusEvent.FOCUS_LOST)</span>
            {
<span class="nc" id="L2935">                FocusEvent fe = (FocusEvent)event;</span>

<span class="nc bnc" id="L2937" title="All 2 branches missed.">                if (manager.getGlobalFocusOwner() == fe.getComponent() &amp;&amp;</span>
<span class="nc bnc" id="L2938" title="All 2 branches missed.">                    fe.getOppositeComponent() == newFocusOwner)</span>
                {
<span class="nc" id="L2940">                    newFocusOwner = null;</span>
<span class="nc" id="L2941">                    return event;</span>
                }
            }
<span class="nc" id="L2944">        }</span>

<span class="nc" id="L2946">        processCurrentLightweightRequests();</span>

<span class="nc bnc" id="L2948" title="All 3 branches missed.">        switch (event.getID()) {</span>
            case FocusEvent.FOCUS_GAINED: {
<span class="nc" id="L2950">                event = retargetFocusGained((FocusEvent)event);</span>
<span class="nc" id="L2951">                break;</span>
            }
            case FocusEvent.FOCUS_LOST: {
<span class="nc" id="L2954">                event = retargetFocusLost((FocusEvent)event);</span>
<span class="nc" id="L2955">                break;</span>
            }
            default:
                /* do nothing */
        }
<span class="nc" id="L2960">        return event;</span>
    }

    /**
     * Clears markers queue
     * This method is not intended to be overridden by KFM's.
     * Only DefaultKeyboardFocusManager can implement it.
     * @since 1.5
     */
    void clearMarkers() {
<span class="nc" id="L2970">    }</span>

    static boolean removeFirstRequest() {
        KeyboardFocusManager manager =
<span class="nc" id="L2974">            KeyboardFocusManager.getCurrentKeyboardFocusManager();</span>

<span class="nc" id="L2976">        synchronized(heavyweightRequests) {</span>
<span class="nc" id="L2977">            HeavyweightFocusRequest hwFocusRequest = getFirstHWRequest();</span>

<span class="nc bnc" id="L2979" title="All 2 branches missed.">            if (hwFocusRequest != null) {</span>
<span class="nc" id="L2980">                heavyweightRequests.removeFirst();</span>
<span class="nc bnc" id="L2981" title="All 2 branches missed.">                if (hwFocusRequest.lightweightRequests != null) {</span>
<span class="nc" id="L2982">                    for (Iterator&lt;KeyboardFocusManager.LightweightFocusRequest&gt; lwIter = hwFocusRequest.lightweightRequests.</span>
<span class="nc" id="L2983">                             iterator();</span>
<span class="nc bnc" id="L2984" title="All 2 branches missed.">                         lwIter.hasNext(); )</span>
                    {
<span class="nc" id="L2986">                        manager.dequeueKeyEvents</span>
<span class="nc" id="L2987">                            (-1, lwIter.next().</span>
                             component);
                    }
                }
            }
            // Fix for 4799136 - clear type-ahead markers if requests queue is empty
            // We do it here because this method is called only when problems happen
<span class="nc bnc" id="L2994" title="All 2 branches missed.">            if (heavyweightRequests.size() == 0) {</span>
<span class="nc" id="L2995">                manager.clearMarkers();</span>
            }
<span class="nc bnc" id="L2997" title="All 2 branches missed.">            return (heavyweightRequests.size() &gt; 0);</span>
<span class="nc" id="L2998">        }</span>
    }
    static void removeLastFocusRequest(Component heavyweight) {
<span class="nc bnc" id="L3001" title="All 2 branches missed.">        if (log.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc bnc" id="L3002" title="All 2 branches missed.">            if (heavyweight == null) {</span>
<span class="nc" id="L3003">                log.fine(&quot;Assertion (heavyweight != null) failed&quot;);</span>
            }
        }

        KeyboardFocusManager manager =
<span class="nc" id="L3008">            KeyboardFocusManager.getCurrentKeyboardFocusManager();</span>
<span class="nc" id="L3009">        synchronized(heavyweightRequests) {</span>
<span class="nc" id="L3010">            HeavyweightFocusRequest hwFocusRequest = getLastHWRequest();</span>
<span class="nc bnc" id="L3011" title="All 4 branches missed.">            if (hwFocusRequest != null &amp;&amp;</span>
                hwFocusRequest.heavyweight == heavyweight) {
<span class="nc" id="L3013">                heavyweightRequests.removeLast();</span>
            }
            // Fix for 4799136 - clear type-ahead markers if requests queue is empty
            // We do it here because this method is called only when problems happen
<span class="nc bnc" id="L3017" title="All 2 branches missed.">            if (heavyweightRequests.size() == 0) {</span>
<span class="nc" id="L3018">                manager.clearMarkers();</span>
            }
<span class="nc" id="L3020">        }</span>
<span class="nc" id="L3021">    }</span>

    private static boolean focusedWindowChanged(Component to, Component from) {
<span class="nc" id="L3024">        Window wto = SunToolkit.getContainingWindow(to);</span>
<span class="nc" id="L3025">        Window wfrom = SunToolkit.getContainingWindow(from);</span>
<span class="nc bnc" id="L3026" title="All 4 branches missed.">        if (wto == null &amp;&amp; wfrom == null) {</span>
<span class="nc" id="L3027">            return true;</span>
        }
<span class="nc bnc" id="L3029" title="All 2 branches missed.">        if (wto == null) {</span>
<span class="nc" id="L3030">            return true;</span>
        }
<span class="nc bnc" id="L3032" title="All 2 branches missed.">        if (wfrom == null) {</span>
<span class="nc" id="L3033">            return true;</span>
        }
<span class="nc bnc" id="L3035" title="All 2 branches missed.">        return (wto != wfrom);</span>
    }

    private static boolean isTemporary(Component to, Component from) {
<span class="nc" id="L3039">        Window wto = SunToolkit.getContainingWindow(to);</span>
<span class="nc" id="L3040">        Window wfrom = SunToolkit.getContainingWindow(from);</span>
<span class="nc bnc" id="L3041" title="All 4 branches missed.">        if (wto == null &amp;&amp; wfrom == null) {</span>
<span class="nc" id="L3042">            return false;</span>
        }
<span class="nc bnc" id="L3044" title="All 2 branches missed.">        if (wto == null) {</span>
<span class="nc" id="L3045">            return true;</span>
        }
<span class="nc bnc" id="L3047" title="All 2 branches missed.">        if (wfrom == null) {</span>
<span class="nc" id="L3048">            return false;</span>
        }
<span class="nc bnc" id="L3050" title="All 2 branches missed.">        return (wto != wfrom);</span>
    }

    static Component getHeavyweight(Component comp) {
<span class="nc bnc" id="L3054" title="All 4 branches missed.">        if (comp == null || comp.getPeer() == null) {</span>
<span class="nc" id="L3055">            return null;</span>
<span class="nc bnc" id="L3056" title="All 2 branches missed.">        } else if (comp.getPeer() instanceof LightweightPeer) {</span>
<span class="nc" id="L3057">            return comp.getNativeContainer();</span>
        } else {
<span class="nc" id="L3059">            return comp;</span>
        }
    }

    static Field proxyActive;
    // Accessor to private field isProxyActive of KeyEvent
    private static boolean isProxyActiveImpl(KeyEvent e) {
<span class="nc bnc" id="L3066" title="All 2 branches missed.">        if (proxyActive == null) {</span>
<span class="nc bnc" id="L3067" title="All 2 branches missed.">            proxyActive =  AccessController.doPrivileged(new PrivilegedAction&lt;Field&gt;() {</span>
                    public Field run() {
<span class="nc" id="L3069">                        Field field = null;</span>
                        try {
<span class="nc" id="L3071">                            field = KeyEvent.class.getDeclaredField(&quot;isProxyActive&quot;);</span>
<span class="nc bnc" id="L3072" title="All 2 branches missed.">                            if (field != null) {</span>
<span class="nc" id="L3073">                                field.setAccessible(true);</span>
                            }
<span class="nc" id="L3075">                        } catch (NoSuchFieldException nsf) {</span>
<span class="nc bnc" id="L3076" title="All 2 branches missed.">                            assert(false);</span>
<span class="nc" id="L3077">                        }</span>
<span class="nc" id="L3078">                        return field;</span>
                    }
                });
        }

        try {
<span class="nc" id="L3084">            return proxyActive.getBoolean(e);</span>
<span class="nc" id="L3085">        } catch (IllegalAccessException iae) {</span>
<span class="nc bnc" id="L3086" title="All 2 branches missed.">            assert(false);</span>
        }
<span class="nc" id="L3088">        return false;</span>
    }

    // Returns the value of this KeyEvent's field isProxyActive
    static boolean isProxyActive(KeyEvent e) {
<span class="nc bnc" id="L3093" title="All 2 branches missed.">        if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L3094">            return isProxyActiveImpl(e);</span>
        } else {
<span class="nc" id="L3096">            return false;</span>
        }
    }

    private static HeavyweightFocusRequest getLastHWRequest() {
<span class="nc" id="L3101">        synchronized(heavyweightRequests) {</span>
<span class="nc bnc" id="L3102" title="All 2 branches missed.">            return (heavyweightRequests.size() &gt; 0)</span>
<span class="nc" id="L3103">                ? heavyweightRequests.getLast()</span>
                : null;
<span class="nc" id="L3105">        }</span>
    }

    private static HeavyweightFocusRequest getFirstHWRequest() {
<span class="nc" id="L3109">        synchronized(heavyweightRequests) {</span>
<span class="nc bnc" id="L3110" title="All 2 branches missed.">            return (heavyweightRequests.size() &gt; 0)</span>
<span class="nc" id="L3111">                ? heavyweightRequests.getFirst()</span>
                : null;
<span class="nc" id="L3113">        }</span>
    }

    private static void checkReplaceKFMPermission()
        throws SecurityException
    {
<span class="nc" id="L3119">        SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L3120" title="All 2 branches missed.">        if (security != null) {</span>
<span class="nc bnc" id="L3121" title="All 2 branches missed.">            if (replaceKeyboardFocusManagerPermission == null) {</span>
<span class="nc" id="L3122">                replaceKeyboardFocusManagerPermission =</span>
                    new AWTPermission(&quot;replaceKeyboardFocusManager&quot;);
            }
<span class="nc" id="L3125">            security.</span>
<span class="nc" id="L3126">                checkPermission(replaceKeyboardFocusManagerPermission);</span>
        }
<span class="nc" id="L3128">    }</span>

    // Checks if this KeyboardFocusManager instance is the current KFM,
    // or otherwise checks if the calling thread has &quot;replaceKeyboardFocusManager&quot;
    // permission. Here's the reasoning to do so:
    //
    // A system KFM instance (which is the current KFM by default) may have no
    // &quot;replaceKFM&quot; permission when a client code is on the call stack beneath,
    // but still it should be able to execute the methods protected by this check
    // due to the system KFM is trusted (and so it does like &quot;privileged&quot;).
    //
    // If this KFM instance is not the current KFM but the client code has all
    // permissions we can't throw SecurityException because it would contradict
    // the security concepts. In this case the trusted client code is responsible
    // for calling the secured methods from KFM instance which is not current.
    private void checkKFMSecurity()
        throws SecurityException
    {
<span class="nc bnc" id="L3146" title="All 2 branches missed.">        if (this != getCurrentKeyboardFocusManager()) {</span>
<span class="nc" id="L3147">            checkReplaceKFMPermission();</span>
        }
<span class="nc" id="L3149">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>