<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TextComponent.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">TextComponent.java</span></div><h1>TextComponent.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt;

import java.awt.peer.TextComponentPeer;
import java.awt.event.*;
import java.util.EventListener;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import sun.awt.InputMethodSupport;
import java.text.BreakIterator;
import javax.swing.text.AttributeSet;
import javax.accessibility.*;
import java.awt.im.InputMethodRequests;
import sun.security.util.SecurityConstants;

/**
 * The &lt;code&gt;TextComponent&lt;/code&gt; class is the superclass of
 * any component that allows the editing of some text.
 * &lt;p&gt;
 * A text component embodies a string of text.  The
 * &lt;code&gt;TextComponent&lt;/code&gt; class defines a set of methods
 * that determine whether or not this text is editable. If the
 * component is editable, it defines another set of methods
 * that supports a text insertion caret.
 * &lt;p&gt;
 * In addition, the class defines methods that are used
 * to maintain a current &lt;em&gt;selection&lt;/em&gt; from the text.
 * The text selection, a substring of the component's text,
 * is the target of editing operations. It is also referred
 * to as the &lt;em&gt;selected text&lt;/em&gt;.
 *
 * @author      Sami Shaio
 * @author      Arthur van Hoff
 * @since       JDK1.0
 */
public class TextComponent extends Component implements Accessible {

    /**
     * The value of the text.
     * A &lt;code&gt;null&lt;/code&gt; value is the same as &quot;&quot;.
     *
     * @serial
     * @see #setText(String)
     * @see #getText()
     */
    String text;

    /**
     * A boolean indicating whether or not this
     * &lt;code&gt;TextComponent&lt;/code&gt; is editable.
     * It will be &lt;code&gt;true&lt;/code&gt; if the text component
     * is editable and &lt;code&gt;false&lt;/code&gt; if not.
     *
     * @serial
     * @see #isEditable()
     */
<span class="nc" id="L81">    boolean editable = true;</span>

    /**
     * The selection refers to the selected text, and the
     * &lt;code&gt;selectionStart&lt;/code&gt; is the start position
     * of the selected text.
     *
     * @serial
     * @see #getSelectionStart()
     * @see #setSelectionStart(int)
     */
    int selectionStart;

    /**
     * The selection refers to the selected text, and the
     * &lt;code&gt;selectionEnd&lt;/code&gt;
     * is the end position of the selected text.
     *
     * @serial
     * @see #getSelectionEnd()
     * @see #setSelectionEnd(int)
     */
    int selectionEnd;

    // A flag used to tell whether the background has been set by
    // developer code (as opposed to AWT code).  Used to determine
    // the background color of non-editable TextComponents.
<span class="nc" id="L108">    boolean backgroundSetByClientCode = false;</span>

    transient protected TextListener textListener;

    /*
     * JDK 1.1 serialVersionUID
     */
    private static final long serialVersionUID = -2214773872412987419L;

    /**
     * Constructs a new text component initialized with the
     * specified text. Sets the value of the cursor to
     * &lt;code&gt;Cursor.TEXT_CURSOR&lt;/code&gt;.
     * @param      text       the text to be displayed; if
     *             &lt;code&gt;text&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the empty
     *             string &lt;code&gt;&quot;&quot;&lt;/code&gt; will be displayed
     * @exception  HeadlessException if
     *             &lt;code&gt;GraphicsEnvironment.isHeadless&lt;/code&gt;
     *             returns true
     * @see        java.awt.GraphicsEnvironment#isHeadless
     * @see        java.awt.Cursor
     */
<span class="nc" id="L130">    TextComponent(String text) throws HeadlessException {</span>
<span class="nc" id="L131">        GraphicsEnvironment.checkHeadless();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        this.text = (text != null) ? text : &quot;&quot;;</span>
<span class="nc" id="L133">        setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));</span>
<span class="nc" id="L134">    }</span>

    private void enableInputMethodsIfNecessary() {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (checkForEnableIM) {</span>
<span class="nc" id="L138">            checkForEnableIM = false;</span>
            try {
<span class="nc" id="L140">                Toolkit toolkit = Toolkit.getDefaultToolkit();</span>
<span class="nc" id="L141">                boolean shouldEnable = false;</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                if (toolkit instanceof InputMethodSupport) {</span>
<span class="nc" id="L143">                    shouldEnable = ((InputMethodSupport)toolkit)</span>
<span class="nc" id="L144">                      .enableInputMethodsForTextComponent();</span>
                }
<span class="nc" id="L146">                enableInputMethods(shouldEnable);</span>
<span class="nc" id="L147">            } catch (Exception e) {</span>
                // if something bad happens, just don't enable input methods
<span class="nc" id="L149">            }</span>
        }
<span class="nc" id="L151">    }</span>

    /**
     * Enables or disables input method support for this text component. If input
     * method support is enabled and the text component also processes key events,
     * incoming events are offered to the current input method and will only be
     * processed by the component or dispatched to its listeners if the input method
     * does not consume them. Whether and how input method support for this text
     * component is enabled or disabled by default is implementation dependent.
     *
     * @param enable true to enable, false to disable
     * @see #processKeyEvent
     * @since 1.2
     */
    public void enableInputMethods(boolean enable) {
<span class="nc" id="L166">        checkForEnableIM = false;</span>
<span class="nc" id="L167">        super.enableInputMethods(enable);</span>
<span class="nc" id="L168">    }</span>

    boolean areInputMethodsEnabled() {
        // moved from the constructor above to here and addNotify below,
        // this call will initialize the toolkit if not already initialized.
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (checkForEnableIM) {</span>
<span class="nc" id="L174">            enableInputMethodsIfNecessary();</span>
        }

        // TextComponent handles key events without touching the eventMask or
        // having a key listener, so just check whether the flag is set
<span class="nc bnc" id="L179" title="All 2 branches missed.">        return (eventMask &amp; AWTEvent.INPUT_METHODS_ENABLED_MASK) != 0;</span>
    }

    public InputMethodRequests getInputMethodRequests() {
<span class="nc" id="L183">        TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (peer != null) return peer.getInputMethodRequests();</span>
<span class="nc" id="L185">        else return null;</span>
    }



    /**
     * Makes this Component displayable by connecting it to a
     * native screen resource.
     * This method is called internally by the toolkit and should
     * not be called directly by programs.
     * @see       java.awt.TextComponent#removeNotify
     */
    public void addNotify() {
<span class="nc" id="L198">        super.addNotify();</span>
<span class="nc" id="L199">        enableInputMethodsIfNecessary();</span>
<span class="nc" id="L200">    }</span>

    /**
     * Removes the &lt;code&gt;TextComponent&lt;/code&gt;'s peer.
     * The peer allows us to modify the appearance of the
     * &lt;code&gt;TextComponent&lt;/code&gt; without changing its
     * functionality.
     */
    public void removeNotify() {
<span class="nc" id="L209">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L210">            TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L212">                text = peer.getText();</span>
<span class="nc" id="L213">                selectionStart = peer.getSelectionStart();</span>
<span class="nc" id="L214">                selectionEnd = peer.getSelectionEnd();</span>
            }
<span class="nc" id="L216">            super.removeNotify();</span>
<span class="nc" id="L217">        }</span>
<span class="nc" id="L218">    }</span>

    /**
     * Sets the text that is presented by this
     * text component to be the specified text.
     * @param       t   the new text;
     *                  if this parameter is &lt;code&gt;null&lt;/code&gt; then
     *                  the text is set to the empty string &quot;&quot;
     * @see         java.awt.TextComponent#getText
     */
    public synchronized void setText(String t) {
<span class="nc bnc" id="L229" title="All 6 branches missed.">        boolean skipTextEvent = (text == null || text.isEmpty())</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">                &amp;&amp; (t == null || t.isEmpty());</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        text = (t != null) ? t : &quot;&quot;;</span>
<span class="nc" id="L232">        TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
        // Please note that we do not want to post an event
        // if TextArea.setText() or TextField.setText() replaces an empty text
        // by an empty text, that is, if component's text remains unchanged.
<span class="nc bnc" id="L236" title="All 4 branches missed.">        if (peer != null &amp;&amp; !skipTextEvent) {</span>
<span class="nc" id="L237">            peer.setText(text);</span>
        }
<span class="nc" id="L239">    }</span>

    /**
     * Returns the text that is presented by this text component.
     * By default, this is an empty string.
     *
     * @return the value of this &lt;code&gt;TextComponent&lt;/code&gt;
     * @see     java.awt.TextComponent#setText
     */
    public synchronized String getText() {
<span class="nc" id="L249">        TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L251">            text = peer.getText();</span>
        }
<span class="nc" id="L253">        return text;</span>
    }

    /**
     * Returns the selected text from the text that is
     * presented by this text component.
     * @return      the selected text of this text component
     * @see         java.awt.TextComponent#select
     */
    public synchronized String getSelectedText() {
<span class="nc" id="L263">        return getText().substring(getSelectionStart(), getSelectionEnd());</span>
    }

    /**
     * Indicates whether or not this text component is editable.
     * @return     &lt;code&gt;true&lt;/code&gt; if this text component is
     *                  editable; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see        java.awt.TextComponent#setEditable
     * @since      JDK1.0
     */
    public boolean isEditable() {
<span class="nc" id="L274">        return editable;</span>
    }

    /**
     * Sets the flag that determines whether or not this
     * text component is editable.
     * &lt;p&gt;
     * If the flag is set to &lt;code&gt;true&lt;/code&gt;, this text component
     * becomes user editable. If the flag is set to &lt;code&gt;false&lt;/code&gt;,
     * the user cannot change the text of this text component.
     * By default, non-editable text components have a background color
     * of SystemColor.control.  This default can be overridden by
     * calling setBackground.
     *
     * @param     b   a flag indicating whether this text component
     *                      is user editable.
     * @see       java.awt.TextComponent#isEditable
     * @since     JDK1.0
     */
    public synchronized void setEditable(boolean b) {
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (editable == b) {</span>
<span class="nc" id="L295">            return;</span>
        }

<span class="nc" id="L298">        editable = b;</span>
<span class="nc" id="L299">        TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L301">            peer.setEditable(b);</span>
        }
<span class="nc" id="L303">    }</span>

    /**
     * Gets the background color of this text component.
     *
     * By default, non-editable text components have a background color
     * of SystemColor.control.  This default can be overridden by
     * calling setBackground.
     *
     * @return This text component's background color.
     *         If this text component does not have a background color,
     *         the background color of its parent is returned.
     * @see #setBackground(Color)
     * @since JDK1.0
     */
    public Color getBackground() {
<span class="nc bnc" id="L319" title="All 4 branches missed.">        if (!editable &amp;&amp; !backgroundSetByClientCode) {</span>
<span class="nc" id="L320">            return SystemColor.control;</span>
        }

<span class="nc" id="L323">        return super.getBackground();</span>
    }

    /**
     * Sets the background color of this text component.
     *
     * @param c The color to become this text component's color.
     *        If this parameter is null then this text component
     *        will inherit the background color of its parent.
     * @see #getBackground()
     * @since JDK1.0
     */
    public void setBackground(Color c) {
<span class="nc" id="L336">        backgroundSetByClientCode = true;</span>
<span class="nc" id="L337">        super.setBackground(c);</span>
<span class="nc" id="L338">    }</span>

    /**
     * Gets the start position of the selected text in
     * this text component.
     * @return      the start position of the selected text
     * @see         java.awt.TextComponent#setSelectionStart
     * @see         java.awt.TextComponent#getSelectionEnd
     */
    public synchronized int getSelectionStart() {
<span class="nc" id="L348">        TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L350">            selectionStart = peer.getSelectionStart();</span>
        }
<span class="nc" id="L352">        return selectionStart;</span>
    }

    /**
     * Sets the selection start for this text component to
     * the specified position. The new start point is constrained
     * to be at or before the current selection end. It also
     * cannot be set to less than zero, the beginning of the
     * component's text.
     * If the caller supplies a value for &lt;code&gt;selectionStart&lt;/code&gt;
     * that is out of bounds, the method enforces these constraints
     * silently, and without failure.
     * @param       selectionStart   the start position of the
     *                        selected text
     * @see         java.awt.TextComponent#getSelectionStart
     * @see         java.awt.TextComponent#setSelectionEnd
     * @since       JDK1.1
     */
    public synchronized void setSelectionStart(int selectionStart) {
        /* Route through select method to enforce consistent policy
         * between selectionStart and selectionEnd.
         */
<span class="nc" id="L374">        select(selectionStart, getSelectionEnd());</span>
<span class="nc" id="L375">    }</span>

    /**
     * Gets the end position of the selected text in
     * this text component.
     * @return      the end position of the selected text
     * @see         java.awt.TextComponent#setSelectionEnd
     * @see         java.awt.TextComponent#getSelectionStart
     */
    public synchronized int getSelectionEnd() {
<span class="nc" id="L385">        TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L387">            selectionEnd = peer.getSelectionEnd();</span>
        }
<span class="nc" id="L389">        return selectionEnd;</span>
    }

    /**
     * Sets the selection end for this text component to
     * the specified position. The new end point is constrained
     * to be at or after the current selection start. It also
     * cannot be set beyond the end of the component's text.
     * If the caller supplies a value for &lt;code&gt;selectionEnd&lt;/code&gt;
     * that is out of bounds, the method enforces these constraints
     * silently, and without failure.
     * @param       selectionEnd   the end position of the
     *                        selected text
     * @see         java.awt.TextComponent#getSelectionEnd
     * @see         java.awt.TextComponent#setSelectionStart
     * @since       JDK1.1
     */
    public synchronized void setSelectionEnd(int selectionEnd) {
        /* Route through select method to enforce consistent policy
         * between selectionStart and selectionEnd.
         */
<span class="nc" id="L410">        select(getSelectionStart(), selectionEnd);</span>
<span class="nc" id="L411">    }</span>

    /**
     * Selects the text between the specified start and end positions.
     * &lt;p&gt;
     * This method sets the start and end positions of the
     * selected text, enforcing the restriction that the start position
     * must be greater than or equal to zero.  The end position must be
     * greater than or equal to the start position, and less than or
     * equal to the length of the text component's text.  The
     * character positions are indexed starting with zero.
     * The length of the selection is
     * &lt;code&gt;endPosition&lt;/code&gt; - &lt;code&gt;startPosition&lt;/code&gt;, so the
     * character at &lt;code&gt;endPosition&lt;/code&gt; is not selected.
     * If the start and end positions of the selected text are equal,
     * all text is deselected.
     * &lt;p&gt;
     * If the caller supplies values that are inconsistent or out of
     * bounds, the method enforces these constraints silently, and
     * without failure. Specifically, if the start position or end
     * position is greater than the length of the text, it is reset to
     * equal the text length. If the start position is less than zero,
     * it is reset to zero, and if the end position is less than the
     * start position, it is reset to the start position.
     *
     * @param        selectionStart the zero-based index of the first
                       character (&lt;code&gt;char&lt;/code&gt; value) to be selected
     * @param        selectionEnd the zero-based end position of the
                       text to be selected; the character (&lt;code&gt;char&lt;/code&gt; value) at
                       &lt;code&gt;selectionEnd&lt;/code&gt; is not selected
     * @see          java.awt.TextComponent#setSelectionStart
     * @see          java.awt.TextComponent#setSelectionEnd
     * @see          java.awt.TextComponent#selectAll
     */
    public synchronized void select(int selectionStart, int selectionEnd) {
<span class="nc" id="L446">        String text = getText();</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (selectionStart &lt; 0) {</span>
<span class="nc" id="L448">            selectionStart = 0;</span>
        }
<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (selectionStart &gt; text.length()) {</span>
<span class="nc" id="L451">            selectionStart = text.length();</span>
        }
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (selectionEnd &gt; text.length()) {</span>
<span class="nc" id="L454">            selectionEnd = text.length();</span>
        }
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (selectionEnd &lt; selectionStart) {</span>
<span class="nc" id="L457">            selectionEnd = selectionStart;</span>
        }

<span class="nc" id="L460">        this.selectionStart = selectionStart;</span>
<span class="nc" id="L461">        this.selectionEnd = selectionEnd;</span>

<span class="nc" id="L463">        TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L465">            peer.select(selectionStart, selectionEnd);</span>
        }
<span class="nc" id="L467">    }</span>

    /**
     * Selects all the text in this text component.
     * @see        java.awt.TextComponent#select
     */
    public synchronized void selectAll() {
<span class="nc" id="L474">        this.selectionStart = 0;</span>
<span class="nc" id="L475">        this.selectionEnd = getText().length();</span>

<span class="nc" id="L477">        TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L479">            peer.select(selectionStart, selectionEnd);</span>
        }
<span class="nc" id="L481">    }</span>

    /**
     * Sets the position of the text insertion caret.
     * The caret position is constrained to be between 0
     * and the last character of the text, inclusive.
     * If the passed-in value is greater than this range,
     * the value is set to the last character (or 0 if
     * the &lt;code&gt;TextComponent&lt;/code&gt; contains no text)
     * and no error is returned.  If the passed-in value is
     * less than 0, an &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * is thrown.
     *
     * @param        position the position of the text insertion caret
     * @exception    IllegalArgumentException if &lt;code&gt;position&lt;/code&gt;
     *               is less than zero
     * @since        JDK1.1
     */
    public synchronized void setCaretPosition(int position) {
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (position &lt; 0) {</span>
<span class="nc" id="L501">            throw new IllegalArgumentException(&quot;position less than zero.&quot;);</span>
        }

<span class="nc" id="L504">        int maxposition = getText().length();</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (position &gt; maxposition) {</span>
<span class="nc" id="L506">            position = maxposition;</span>
        }

<span class="nc" id="L509">        TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L511">            peer.setCaretPosition(position);</span>
        } else {
<span class="nc" id="L513">            select(position, position);</span>
        }
<span class="nc" id="L515">    }</span>

    /**
     * Returns the position of the text insertion caret.
     * The caret position is constrained to be between 0
     * and the last character of the text, inclusive.
     * If the text or caret have not been set, the default
     * caret position is 0.
     *
     * @return       the position of the text insertion caret
     * @see #setCaretPosition(int)
     * @since        JDK1.1
     */
    public synchronized int getCaretPosition() {
<span class="nc" id="L529">        TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
<span class="nc" id="L530">        int position = 0;</span>

<span class="nc bnc" id="L532" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L533">            position = peer.getCaretPosition();</span>
        } else {
<span class="nc" id="L535">            position = selectionStart;</span>
        }
<span class="nc" id="L537">        int maxposition = getText().length();</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (position &gt; maxposition) {</span>
<span class="nc" id="L539">            position = maxposition;</span>
        }
<span class="nc" id="L541">        return position;</span>
    }

    /**
     * Adds the specified text event listener to receive text events
     * from this text component.
     * If &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is
     * thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param l the text event listener
     * @see             #removeTextListener
     * @see             #getTextListeners
     * @see             java.awt.event.TextListener
     */
    public synchronized void addTextListener(TextListener l) {
<span class="nc bnc" id="L558" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L559">            return;</span>
        }
<span class="nc" id="L561">        textListener = AWTEventMulticaster.add(textListener, l);</span>
<span class="nc" id="L562">        newEventsOnly = true;</span>
<span class="nc" id="L563">    }</span>

    /**
     * Removes the specified text event listener so that it no longer
     * receives text events from this text component
     * If &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is
     * thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param           l     the text listener
     * @see             #addTextListener
     * @see             #getTextListeners
     * @see             java.awt.event.TextListener
     * @since           JDK1.1
     */
    public synchronized void removeTextListener(TextListener l) {
<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L581">            return;</span>
        }
<span class="nc" id="L583">        textListener = AWTEventMulticaster.remove(textListener, l);</span>
<span class="nc" id="L584">    }</span>

    /**
     * Returns an array of all the text listeners
     * registered on this text component.
     *
     * @return all of this text component's &lt;code&gt;TextListener&lt;/code&gt;s
     *         or an empty array if no text
     *         listeners are currently registered
     *
     *
     * @see #addTextListener
     * @see #removeTextListener
     * @since 1.4
     */
    public synchronized TextListener[] getTextListeners() {
<span class="nc" id="L600">        return getListeners(TextListener.class);</span>
    }

    /**
     * Returns an array of all the objects currently registered
     * as &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s
     * upon this &lt;code&gt;TextComponent&lt;/code&gt;.
     * &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
     * &lt;code&gt;add&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt; method.
     *
     * &lt;p&gt;
     * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
     * with a class literal, such as
     * &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener.class&lt;/code&gt;.
     * For example, you can query a
     * &lt;code&gt;TextComponent&lt;/code&gt; &lt;code&gt;t&lt;/code&gt;
     * for its text listeners with the following code:
     *
     * &lt;pre&gt;TextListener[] tls = (TextListener[])(t.getListeners(TextListener.class));&lt;/pre&gt;
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @return an array of all objects registered as
     *          &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s on this text component,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt;
     *          doesn't specify a class or interface that implements
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     *
     * @see #getTextListeners
     * @since 1.3
     */
    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<span class="nc" id="L637">        EventListener l = null;</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">        if  (listenerType == TextListener.class) {</span>
<span class="nc" id="L639">            l = textListener;</span>
        } else {
<span class="nc" id="L641">            return super.getListeners(listenerType);</span>
        }
<span class="nc" id="L643">        return AWTEventMulticaster.getListeners(l, listenerType);</span>
    }

    // REMIND: remove when filtering is done at lower level
    boolean eventEnabled(AWTEvent e) {
<span class="nc bnc" id="L648" title="All 2 branches missed.">        if (e.id == TextEvent.TEXT_VALUE_CHANGED) {</span>
<span class="nc bnc" id="L649" title="All 4 branches missed.">            if ((eventMask &amp; AWTEvent.TEXT_EVENT_MASK) != 0 ||</span>
                textListener != null) {
<span class="nc" id="L651">                return true;</span>
            }
<span class="nc" id="L653">            return false;</span>
        }
<span class="nc" id="L655">        return super.eventEnabled(e);</span>
    }

    /**
     * Processes events on this text component. If the event is a
     * &lt;code&gt;TextEvent&lt;/code&gt;, it invokes the &lt;code&gt;processTextEvent&lt;/code&gt;
     * method else it invokes its superclass's &lt;code&gt;processEvent&lt;/code&gt;.
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param e the event
     */
    protected void processEvent(AWTEvent e) {
<span class="nc bnc" id="L669" title="All 2 branches missed.">        if (e instanceof TextEvent) {</span>
<span class="nc" id="L670">            processTextEvent((TextEvent)e);</span>
<span class="nc" id="L671">            return;</span>
        }
<span class="nc" id="L673">        super.processEvent(e);</span>
<span class="nc" id="L674">    }</span>

    /**
     * Processes text events occurring on this text component by
     * dispatching them to any registered &lt;code&gt;TextListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * NOTE: This method will not be called unless text events
     * are enabled for this component. This happens when one of the
     * following occurs:
     * &lt;ul&gt;
     * &lt;li&gt;A &lt;code&gt;TextListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addTextListener&lt;/code&gt;
     * &lt;li&gt;Text events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param e the text event
     * @see Component#enableEvents
     */
    protected void processTextEvent(TextEvent e) {
<span class="nc" id="L696">        TextListener listener = textListener;</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L698">            int id = e.getID();</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">            switch (id) {</span>
            case TextEvent.TEXT_VALUE_CHANGED:
<span class="nc" id="L701">                listener.textValueChanged(e);</span>
                break;
            }
        }
<span class="nc" id="L705">    }</span>

    /**
     * Returns a string representing the state of this
     * &lt;code&gt;TextComponent&lt;/code&gt;. This
     * method is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not be
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @return      the parameter string of this text component
     */
    protected String paramString() {
<span class="nc" id="L718">        String str = super.paramString() + &quot;,text=&quot; + getText();</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (editable) {</span>
<span class="nc" id="L720">            str += &quot;,editable&quot;;</span>
        }
<span class="nc" id="L722">        return str + &quot;,selection=&quot; + getSelectionStart() + &quot;-&quot; + getSelectionEnd();</span>
    }

    /**
     * Assigns a valid value to the canAccessClipboard instance variable.
     */
    private boolean canAccessClipboard() {
<span class="nc" id="L729">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">        if (sm == null) return true;</span>
        try {
<span class="nc" id="L732">            sm.checkPermission(SecurityConstants.AWT.ACCESS_CLIPBOARD_PERMISSION);</span>
<span class="nc" id="L733">            return true;</span>
<span class="nc" id="L734">        } catch (SecurityException e) {}</span>
<span class="nc" id="L735">        return false;</span>
    }

    /*
     * Serialization support.
     */
    /**
     * The textComponent SerializedDataVersion.
     *
     * @serial
     */
<span class="nc" id="L746">    private int textComponentSerializedDataVersion = 1;</span>

    /**
     * Writes default serializable fields to stream.  Writes
     * a list of serializable TextListener(s) as optional data.
     * The non-serializable TextListener(s) are detected and
     * no attempt is made to serialize them.
     *
     * @serialData Null terminated sequence of zero or more pairs.
     *             A pair consists of a String and Object.
     *             The String indicates the type of object and
     *             is one of the following :
     *             textListenerK indicating and TextListener object.
     *
     * @see AWTEventMulticaster#save(ObjectOutputStream, String, EventListener)
     * @see java.awt.Component#textListenerK
     */
    private void writeObject(java.io.ObjectOutputStream s)
      throws IOException
    {
        // Serialization support.  Since the value of the fields
        // selectionStart, selectionEnd, and text aren't necessarily
        // up to date, we sync them up with the peer before serializing.
<span class="nc" id="L769">        TextComponentPeer peer = (TextComponentPeer)this.peer;</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L771">            text = peer.getText();</span>
<span class="nc" id="L772">            selectionStart = peer.getSelectionStart();</span>
<span class="nc" id="L773">            selectionEnd = peer.getSelectionEnd();</span>
        }

<span class="nc" id="L776">        s.defaultWriteObject();</span>

<span class="nc" id="L778">        AWTEventMulticaster.save(s, textListenerK, textListener);</span>
<span class="nc" id="L779">        s.writeObject(null);</span>
<span class="nc" id="L780">    }</span>

    /**
     * Read the ObjectInputStream, and if it isn't null,
     * add a listener to receive text events fired by the
     * TextComponent.  Unrecognized keys or values will be
     * ignored.
     *
     * @exception HeadlessException if
     * &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt; returns
     * &lt;code&gt;true&lt;/code&gt;
     * @see #removeTextListener
     * @see #addTextListener
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    private void readObject(ObjectInputStream s)
        throws ClassNotFoundException, IOException, HeadlessException
    {
<span class="nc" id="L798">        GraphicsEnvironment.checkHeadless();</span>
<span class="nc" id="L799">        s.defaultReadObject();</span>

        // Make sure the state we just read in for text,
        // selectionStart and selectionEnd has legal values
<span class="nc bnc" id="L803" title="All 2 branches missed.">        this.text = (text != null) ? text : &quot;&quot;;</span>
<span class="nc" id="L804">        select(selectionStart, selectionEnd);</span>

        Object keyOrNull;
<span class="nc bnc" id="L807" title="All 2 branches missed.">        while(null != (keyOrNull = s.readObject())) {</span>
<span class="nc" id="L808">            String key = ((String)keyOrNull).intern();</span>

<span class="nc bnc" id="L810" title="All 2 branches missed.">            if (textListenerK == key) {</span>
<span class="nc" id="L811">                addTextListener((TextListener)(s.readObject()));</span>
            } else {
                // skip value for unrecognized key
<span class="nc" id="L814">                s.readObject();</span>
            }
<span class="nc" id="L816">        }</span>
<span class="nc" id="L817">        enableInputMethodsIfNecessary();</span>
<span class="nc" id="L818">    }</span>


/////////////////
// Accessibility support
////////////////

    /**
     * Gets the AccessibleContext associated with this TextComponent.
     * For text components, the AccessibleContext takes the form of an
     * AccessibleAWTTextComponent.
     * A new AccessibleAWTTextComponent instance is created if necessary.
     *
     * @return an AccessibleAWTTextComponent that serves as the
     *         AccessibleContext of this TextComponent
     * @since 1.3
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L836" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L837">            accessibleContext = new AccessibleAWTTextComponent();</span>
        }
<span class="nc" id="L839">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;TextComponent&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to text component user-interface
     * elements.
     * @since 1.3
     */
    protected class AccessibleAWTTextComponent extends AccessibleAWTComponent
        implements AccessibleText, TextListener
    {
        /*
         * JDK 1.3 serialVersionUID
         */
        private static final long serialVersionUID = 3631432373506317811L;

        /**
         * Constructs an AccessibleAWTTextComponent.  Adds a listener to track
         * caret change.
         */
<span class="nc" id="L861">        public AccessibleAWTTextComponent() {</span>
<span class="nc" id="L862">            TextComponent.this.addTextListener(this);</span>
<span class="nc" id="L863">        }</span>

        /**
         * TextListener notification of a text value change.
         */
        public void textValueChanged(TextEvent textEvent)  {
<span class="nc" id="L869">            Integer cpos = Integer.valueOf(TextComponent.this.getCaretPosition());</span>
<span class="nc" id="L870">            firePropertyChange(ACCESSIBLE_TEXT_PROPERTY, null, cpos);</span>
<span class="nc" id="L871">        }</span>

        /**
         * Gets the state set of the TextComponent.
         * The AccessibleStateSet of an object is composed of a set of
         * unique AccessibleStates.  A change in the AccessibleStateSet
         * of an object will cause a PropertyChangeEvent to be fired
         * for the AccessibleContext.ACCESSIBLE_STATE_PROPERTY property.
         *
         * @return an instance of AccessibleStateSet containing the
         * current state set of the object
         * @see AccessibleStateSet
         * @see AccessibleState
         * @see #addPropertyChangeListener
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L887">            AccessibleStateSet states = super.getAccessibleStateSet();</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">            if (TextComponent.this.isEditable()) {</span>
<span class="nc" id="L889">                states.add(AccessibleState.EDITABLE);</span>
            }
<span class="nc" id="L891">            return states;</span>
        }


        /**
         * Gets the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of the
         * object (AccessibleRole.TEXT)
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L903">            return AccessibleRole.TEXT;</span>
        }

        /**
         * Get the AccessibleText associated with this object.  In the
         * implementation of the Java Accessibility API for this class,
         * return this object, which is responsible for implementing the
         * AccessibleText interface on behalf of itself.
         *
         * @return this object
         */
        public AccessibleText getAccessibleText() {
<span class="nc" id="L915">            return this;</span>
        }


        // --- interface AccessibleText methods ------------------------

        /**
         * Many of these methods are just convenience methods; they
         * just call the equivalent on the parent
         */

        /**
         * Given a point in local coordinates, return the zero-based index
         * of the character under that Point.  If the point is invalid,
         * this method returns -1.
         *
         * @param p the Point in local coordinates
         * @return the zero-based index of the character under Point p.
         */
        public int getIndexAtPoint(Point p) {
<span class="nc" id="L935">            return -1;</span>
        }

        /**
         * Determines the bounding box of the character at the given
         * index into the string.  The bounds are returned in local
         * coordinates.  If the index is invalid a null rectangle
         * is returned.
         *
         * @param i the index into the String &amp;gt;= 0
         * @return the screen coordinates of the character's bounding box
         */
        public Rectangle getCharacterBounds(int i) {
<span class="nc" id="L948">            return null;</span>
        }

        /**
         * Returns the number of characters (valid indicies)
         *
         * @return the number of characters &amp;gt;= 0
         */
        public int getCharCount() {
<span class="nc" id="L957">            return TextComponent.this.getText().length();</span>
        }

        /**
         * Returns the zero-based offset of the caret.
         *
         * Note: The character to the right of the caret will have the
         * same index value as the offset (the caret is between
         * two characters).
         *
         * @return the zero-based offset of the caret.
         */
        public int getCaretPosition() {
<span class="nc" id="L970">            return TextComponent.this.getCaretPosition();</span>
        }

        /**
         * Returns the AttributeSet for a given character (at a given index).
         *
         * @param i the zero-based index into the text
         * @return the AttributeSet of the character
         */
        public AttributeSet getCharacterAttribute(int i) {
<span class="nc" id="L980">            return null; // No attributes in TextComponent</span>
        }

        /**
         * Returns the start offset within the selected text.
         * If there is no selection, but there is
         * a caret, the start and end offsets will be the same.
         * Return 0 if the text is empty, or the caret position
         * if no selection.
         *
         * @return the index into the text of the start of the selection &amp;gt;= 0
         */
        public int getSelectionStart() {
<span class="nc" id="L993">            return TextComponent.this.getSelectionStart();</span>
        }

        /**
         * Returns the end offset within the selected text.
         * If there is no selection, but there is
         * a caret, the start and end offsets will be the same.
         * Return 0 if the text is empty, or the caret position
         * if no selection.
         *
         * @return the index into the text of the end of the selection &amp;gt;= 0
         */
        public int getSelectionEnd() {
<span class="nc" id="L1006">            return TextComponent.this.getSelectionEnd();</span>
        }

        /**
         * Returns the portion of the text that is selected.
         *
         * @return the text, null if no selection
         */
        public String getSelectedText() {
<span class="nc" id="L1015">            String selText = TextComponent.this.getSelectedText();</span>
            // Fix for 4256662
<span class="nc bnc" id="L1017" title="All 4 branches missed.">            if (selText == null || selText.equals(&quot;&quot;)) {</span>
<span class="nc" id="L1018">                return null;</span>
            }
<span class="nc" id="L1020">            return selText;</span>
        }

        /**
         * Returns the String at a given index.
         *
         * @param part the AccessibleText.CHARACTER, AccessibleText.WORD,
         * or AccessibleText.SENTENCE to retrieve
         * @param index an index within the text &amp;gt;= 0
         * @return the letter, word, or sentence,
         *   null for an invalid index or part
         */
        public String getAtIndex(int part, int index) {
<span class="nc bnc" id="L1033" title="All 4 branches missed.">            if (index &lt; 0 || index &gt;= TextComponent.this.getText().length()) {</span>
<span class="nc" id="L1034">                return null;</span>
            }
<span class="nc bnc" id="L1036" title="All 4 branches missed.">            switch (part) {</span>
            case AccessibleText.CHARACTER:
<span class="nc" id="L1038">                return TextComponent.this.getText().substring(index, index+1);</span>
            case AccessibleText.WORD:  {
<span class="nc" id="L1040">                    String s = TextComponent.this.getText();</span>
<span class="nc" id="L1041">                    BreakIterator words = BreakIterator.getWordInstance();</span>
<span class="nc" id="L1042">                    words.setText(s);</span>
<span class="nc" id="L1043">                    int end = words.following(index);</span>
<span class="nc" id="L1044">                    return s.substring(words.previous(), end);</span>
                }
            case AccessibleText.SENTENCE:  {
<span class="nc" id="L1047">                    String s = TextComponent.this.getText();</span>
<span class="nc" id="L1048">                    BreakIterator sentence = BreakIterator.getSentenceInstance();</span>
<span class="nc" id="L1049">                    sentence.setText(s);</span>
<span class="nc" id="L1050">                    int end = sentence.following(index);</span>
<span class="nc" id="L1051">                    return s.substring(sentence.previous(), end);</span>
                }
            default:
<span class="nc" id="L1054">                return null;</span>
            }
        }

        private static final boolean NEXT = true;
        private static final boolean PREVIOUS = false;

        /**
         * Needed to unify forward and backward searching.
         * The method assumes that s is the text assigned to words.
         */
        private int findWordLimit(int index, BreakIterator words, boolean direction,
                                         String s) {
            // Fix for 4256660 and 4256661.
            // Words iterator is different from character and sentence iterators
            // in that end of one word is not necessarily start of another word.
            // Please see java.text.BreakIterator JavaDoc. The code below is
            // based on nextWordStartAfter example from BreakIterator.java.
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            int last = (direction == NEXT) ? words.following(index)</span>
<span class="nc" id="L1073">                                           : words.preceding(index);</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">            int current = (direction == NEXT) ? words.next()</span>
<span class="nc" id="L1075">                                              : words.previous();</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">            while (current != BreakIterator.DONE) {</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">                for (int p = Math.min(last, current); p &lt; Math.max(last, current); p++) {</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">                    if (Character.isLetter(s.charAt(p))) {</span>
<span class="nc" id="L1079">                        return last;</span>
                    }
                }
<span class="nc" id="L1082">                last = current;</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">                current = (direction == NEXT) ? words.next()</span>
<span class="nc" id="L1084">                                              : words.previous();</span>
            }
<span class="nc" id="L1086">            return BreakIterator.DONE;</span>
        }

        /**
         * Returns the String after a given index.
         *
         * @param part the AccessibleText.CHARACTER, AccessibleText.WORD,
         * or AccessibleText.SENTENCE to retrieve
         * @param index an index within the text &amp;gt;= 0
         * @return the letter, word, or sentence, null for an invalid
         *  index or part
         */
        public String getAfterIndex(int part, int index) {
<span class="nc bnc" id="L1099" title="All 4 branches missed.">            if (index &lt; 0 || index &gt;= TextComponent.this.getText().length()) {</span>
<span class="nc" id="L1100">                return null;</span>
            }
<span class="nc bnc" id="L1102" title="All 4 branches missed.">            switch (part) {</span>
            case AccessibleText.CHARACTER:
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                if (index+1 &gt;= TextComponent.this.getText().length()) {</span>
<span class="nc" id="L1105">                   return null;</span>
                }
<span class="nc" id="L1107">                return TextComponent.this.getText().substring(index+1, index+2);</span>
            case AccessibleText.WORD:  {
<span class="nc" id="L1109">                    String s = TextComponent.this.getText();</span>
<span class="nc" id="L1110">                    BreakIterator words = BreakIterator.getWordInstance();</span>
<span class="nc" id="L1111">                    words.setText(s);</span>
<span class="nc" id="L1112">                    int start = findWordLimit(index, words, NEXT, s);</span>
<span class="nc bnc" id="L1113" title="All 4 branches missed.">                    if (start == BreakIterator.DONE || start &gt;= s.length()) {</span>
<span class="nc" id="L1114">                        return null;</span>
                    }
<span class="nc" id="L1116">                    int end = words.following(start);</span>
<span class="nc bnc" id="L1117" title="All 4 branches missed.">                    if (end == BreakIterator.DONE || end &gt;= s.length()) {</span>
<span class="nc" id="L1118">                        return null;</span>
                    }
<span class="nc" id="L1120">                    return s.substring(start, end);</span>
                }
            case AccessibleText.SENTENCE:  {
<span class="nc" id="L1123">                    String s = TextComponent.this.getText();</span>
<span class="nc" id="L1124">                    BreakIterator sentence = BreakIterator.getSentenceInstance();</span>
<span class="nc" id="L1125">                    sentence.setText(s);</span>
<span class="nc" id="L1126">                    int start = sentence.following(index);</span>
<span class="nc bnc" id="L1127" title="All 4 branches missed.">                    if (start == BreakIterator.DONE || start &gt;= s.length()) {</span>
<span class="nc" id="L1128">                        return null;</span>
                    }
<span class="nc" id="L1130">                    int end = sentence.following(start);</span>
<span class="nc bnc" id="L1131" title="All 4 branches missed.">                    if (end == BreakIterator.DONE || end &gt;= s.length()) {</span>
<span class="nc" id="L1132">                        return null;</span>
                    }
<span class="nc" id="L1134">                    return s.substring(start, end);</span>
                }
            default:
<span class="nc" id="L1137">                return null;</span>
            }
        }


        /**
         * Returns the String before a given index.
         *
         * @param part the AccessibleText.CHARACTER, AccessibleText.WORD,
         *   or AccessibleText.SENTENCE to retrieve
         * @param index an index within the text &amp;gt;= 0
         * @return the letter, word, or sentence, null for an invalid index
         *  or part
         */
        public String getBeforeIndex(int part, int index) {
<span class="nc bnc" id="L1152" title="All 4 branches missed.">            if (index &lt; 0 || index &gt; TextComponent.this.getText().length()-1) {</span>
<span class="nc" id="L1153">                return null;</span>
            }
<span class="nc bnc" id="L1155" title="All 4 branches missed.">            switch (part) {</span>
            case AccessibleText.CHARACTER:
<span class="nc bnc" id="L1157" title="All 2 branches missed.">                if (index == 0) {</span>
<span class="nc" id="L1158">                    return null;</span>
                }
<span class="nc" id="L1160">                return TextComponent.this.getText().substring(index-1, index);</span>
            case AccessibleText.WORD:  {
<span class="nc" id="L1162">                    String s = TextComponent.this.getText();</span>
<span class="nc" id="L1163">                    BreakIterator words = BreakIterator.getWordInstance();</span>
<span class="nc" id="L1164">                    words.setText(s);</span>
<span class="nc" id="L1165">                    int end = findWordLimit(index, words, PREVIOUS, s);</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                    if (end == BreakIterator.DONE) {</span>
<span class="nc" id="L1167">                        return null;</span>
                    }
<span class="nc" id="L1169">                    int start = words.preceding(end);</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">                    if (start == BreakIterator.DONE) {</span>
<span class="nc" id="L1171">                        return null;</span>
                    }
<span class="nc" id="L1173">                    return s.substring(start, end);</span>
                }
            case AccessibleText.SENTENCE:  {
<span class="nc" id="L1176">                    String s = TextComponent.this.getText();</span>
<span class="nc" id="L1177">                    BreakIterator sentence = BreakIterator.getSentenceInstance();</span>
<span class="nc" id="L1178">                    sentence.setText(s);</span>
<span class="nc" id="L1179">                    int end = sentence.following(index);</span>
<span class="nc" id="L1180">                    end = sentence.previous();</span>
<span class="nc" id="L1181">                    int start = sentence.previous();</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">                    if (start == BreakIterator.DONE) {</span>
<span class="nc" id="L1183">                        return null;</span>
                    }
<span class="nc" id="L1185">                    return s.substring(start, end);</span>
                }
            default:
<span class="nc" id="L1188">                return null;</span>
            }
        }
    }  // end of AccessibleAWTTextComponent

<span class="nc" id="L1193">    private boolean checkForEnableIM = true;</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>