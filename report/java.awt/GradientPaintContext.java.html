<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GradientPaintContext.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">GradientPaintContext.java</span></div><h1>GradientPaintContext.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt;

import java.awt.image.Raster;
import sun.awt.image.IntegerComponentRaster;
import java.awt.image.ColorModel;
import java.awt.image.DirectColorModel;
import java.awt.geom.Point2D;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.lang.ref.WeakReference;

class GradientPaintContext implements PaintContext {
<span class="nc" id="L38">    static ColorModel xrgbmodel =</span>
        new DirectColorModel(24, 0x00ff0000, 0x0000ff00, 0x000000ff);
<span class="nc" id="L40">    static ColorModel xbgrmodel =</span>
        new DirectColorModel(24, 0x000000ff, 0x0000ff00, 0x00ff0000);

    static ColorModel cachedModel;
    static WeakReference&lt;Raster&gt; cached;

    static synchronized Raster getCachedRaster(ColorModel cm, int w, int h) {
<span class="nc bnc" id="L47" title="All 2 branches missed.">        if (cm == cachedModel) {</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">            if (cached != null) {</span>
<span class="nc" id="L49">                Raster ras = (Raster) cached.get();</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">                if (ras != null &amp;&amp;</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">                    ras.getWidth() &gt;= w &amp;&amp;</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">                    ras.getHeight() &gt;= h)</span>
                {
<span class="nc" id="L54">                    cached = null;</span>
<span class="nc" id="L55">                    return ras;</span>
                }
            }
        }
<span class="nc" id="L59">        return cm.createCompatibleWritableRaster(w, h);</span>
    }

    static synchronized void putCachedRaster(ColorModel cm, Raster ras) {
<span class="nc bnc" id="L63" title="All 2 branches missed.">        if (cached != null) {</span>
<span class="nc" id="L64">            Raster cras = (Raster) cached.get();</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">            if (cras != null) {</span>
<span class="nc" id="L66">                int cw = cras.getWidth();</span>
<span class="nc" id="L67">                int ch = cras.getHeight();</span>
<span class="nc" id="L68">                int iw = ras.getWidth();</span>
<span class="nc" id="L69">                int ih = ras.getHeight();</span>
<span class="nc bnc" id="L70" title="All 4 branches missed.">                if (cw &gt;= iw &amp;&amp; ch &gt;= ih) {</span>
<span class="nc" id="L71">                    return;</span>
                }
<span class="nc bnc" id="L73" title="All 2 branches missed.">                if (cw * ch &gt;= iw * ih) {</span>
<span class="nc" id="L74">                    return;</span>
                }
            }
        }
<span class="nc" id="L78">        cachedModel = cm;</span>
<span class="nc" id="L79">        cached = new WeakReference&lt;&gt;(ras);</span>
<span class="nc" id="L80">    }</span>

    double x1;
    double y1;
    double dx;
    double dy;
    boolean cyclic;
    int interp[];
    Raster saved;
    ColorModel model;

    public GradientPaintContext(ColorModel cm,
                                Point2D p1, Point2D p2, AffineTransform xform,
<span class="nc" id="L93">                                Color c1, Color c2, boolean cyclic) {</span>
        // First calculate the distance moved in user space when
        // we move a single unit along the X &amp; Y axes in device space.
<span class="nc" id="L96">        Point2D xvec = new Point2D.Double(1, 0);</span>
<span class="nc" id="L97">        Point2D yvec = new Point2D.Double(0, 1);</span>
        try {
<span class="nc" id="L99">            AffineTransform inverse = xform.createInverse();</span>
<span class="nc" id="L100">            inverse.deltaTransform(xvec, xvec);</span>
<span class="nc" id="L101">            inverse.deltaTransform(yvec, yvec);</span>
<span class="nc" id="L102">        } catch (NoninvertibleTransformException e) {</span>
<span class="nc" id="L103">            xvec.setLocation(0, 0);</span>
<span class="nc" id="L104">            yvec.setLocation(0, 0);</span>
<span class="nc" id="L105">        }</span>

        // Now calculate the (square of the) user space distance
        // between the anchor points. This value equals:
        //     (UserVec . UserVec)
<span class="nc" id="L110">        double udx = p2.getX() - p1.getX();</span>
<span class="nc" id="L111">        double udy = p2.getY() - p1.getY();</span>
<span class="nc" id="L112">        double ulenSq = udx * udx + udy * udy;</span>

<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (ulenSq &lt;= Double.MIN_VALUE) {</span>
<span class="nc" id="L115">            dx = 0;</span>
<span class="nc" id="L116">            dy = 0;</span>
        } else {
            // Now calculate the proportional distance moved along the
            // vector from p1 to p2 when we move a unit along X &amp; Y in
            // device space.
            //
            // The length of the projection of the Device Axis Vector is
            // its dot product with the Unit User Vector:
            //     (DevAxisVec . (UserVec / Len(UserVec))
            //
            // The &quot;proportional&quot; length is that length divided again
            // by the length of the User Vector:
            //     (DevAxisVec . (UserVec / Len(UserVec))) / Len(UserVec)
            // which simplifies to:
            //     ((DevAxisVec . UserVec) / Len(UserVec)) / Len(UserVec)
            // which simplifies to:
            //     (DevAxisVec . UserVec) / LenSquared(UserVec)
<span class="nc" id="L133">            dx = (xvec.getX() * udx + xvec.getY() * udy) / ulenSq;</span>
<span class="nc" id="L134">            dy = (yvec.getX() * udx + yvec.getY() * udy) / ulenSq;</span>

<span class="nc bnc" id="L136" title="All 2 branches missed.">            if (cyclic) {</span>
<span class="nc" id="L137">                dx = dx % 1.0;</span>
<span class="nc" id="L138">                dy = dy % 1.0;</span>
            } else {
                // We are acyclic
<span class="nc bnc" id="L141" title="All 2 branches missed.">                if (dx &lt; 0) {</span>
                    // If we are using the acyclic form below, we need
                    // dx to be non-negative for simplicity of scanning
                    // across the scan lines for the transition points.
                    // To ensure that constraint, we negate the dx/dy
                    // values and swap the points and colors.
<span class="nc" id="L147">                    Point2D p = p1; p1 = p2; p2 = p;</span>
<span class="nc" id="L148">                    Color c = c1; c1 = c2; c2 = c;</span>
<span class="nc" id="L149">                    dx = -dx;</span>
<span class="nc" id="L150">                    dy = -dy;</span>
                }
            }
        }

<span class="nc" id="L155">        Point2D dp1 = xform.transform(p1, null);</span>
<span class="nc" id="L156">        this.x1 = dp1.getX();</span>
<span class="nc" id="L157">        this.y1 = dp1.getY();</span>

<span class="nc" id="L159">        this.cyclic = cyclic;</span>
<span class="nc" id="L160">        int rgb1 = c1.getRGB();</span>
<span class="nc" id="L161">        int rgb2 = c2.getRGB();</span>
<span class="nc" id="L162">        int a1 = (rgb1 &gt;&gt; 24) &amp; 0xff;</span>
<span class="nc" id="L163">        int r1 = (rgb1 &gt;&gt; 16) &amp; 0xff;</span>
<span class="nc" id="L164">        int g1 = (rgb1 &gt;&gt;  8) &amp; 0xff;</span>
<span class="nc" id="L165">        int b1 = (rgb1      ) &amp; 0xff;</span>
<span class="nc" id="L166">        int da = ((rgb2 &gt;&gt; 24) &amp; 0xff) - a1;</span>
<span class="nc" id="L167">        int dr = ((rgb2 &gt;&gt; 16) &amp; 0xff) - r1;</span>
<span class="nc" id="L168">        int dg = ((rgb2 &gt;&gt;  8) &amp; 0xff) - g1;</span>
<span class="nc" id="L169">        int db = ((rgb2      ) &amp; 0xff) - b1;</span>
<span class="nc bnc" id="L170" title="All 4 branches missed.">        if (a1 == 0xff &amp;&amp; da == 0) {</span>
<span class="nc" id="L171">            model = xrgbmodel;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">            if (cm instanceof DirectColorModel) {</span>
<span class="nc" id="L173">                DirectColorModel dcm = (DirectColorModel) cm;</span>
<span class="nc" id="L174">                int tmp = dcm.getAlphaMask();</span>
<span class="nc bnc" id="L175" title="All 4 branches missed.">                if ((tmp == 0 || tmp == 0xff) &amp;&amp;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">                    dcm.getRedMask() == 0xff &amp;&amp;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                    dcm.getGreenMask() == 0xff00 &amp;&amp;</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                    dcm.getBlueMask() == 0xff0000)</span>
                {
<span class="nc" id="L180">                    model = xbgrmodel;</span>
<span class="nc" id="L181">                    tmp = r1; r1 = b1; b1 = tmp;</span>
<span class="nc" id="L182">                    tmp = dr; dr = db; db = tmp;</span>
                }
<span class="nc" id="L184">            }</span>
        } else {
<span class="nc" id="L186">            model = ColorModel.getRGBdefault();</span>
        }
<span class="nc bnc" id="L188" title="All 2 branches missed.">        interp = new int[cyclic ? 513 : 257];</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        for (int i = 0; i &lt;= 256; i++) {</span>
<span class="nc" id="L190">            float rel = i / 256.0f;</span>
<span class="nc" id="L191">            int rgb =</span>
                (((int) (a1 + da * rel)) &lt;&lt; 24) |
                (((int) (r1 + dr * rel)) &lt;&lt; 16) |
                (((int) (g1 + dg * rel)) &lt;&lt;  8) |
                (((int) (b1 + db * rel))      );
<span class="nc" id="L196">            interp[i] = rgb;</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (cyclic) {</span>
<span class="nc" id="L198">                interp[512 - i] = rgb;</span>
            }
        }
<span class="nc" id="L201">    }</span>

    /**
     * Release the resources allocated for the operation.
     */
    public void dispose() {
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (saved != null) {</span>
<span class="nc" id="L208">            putCachedRaster(model, saved);</span>
<span class="nc" id="L209">            saved = null;</span>
        }
<span class="nc" id="L211">    }</span>

    /**
     * Return the ColorModel of the output.
     */
    public ColorModel getColorModel() {
<span class="nc" id="L217">        return model;</span>
    }

    /**
     * Return a Raster containing the colors generated for the graphics
     * operation.
     * @param x,y,w,h The area in device space for which colors are
     * generated.
     */
    public Raster getRaster(int x, int y, int w, int h) {
<span class="nc" id="L227">        double rowrel = (x - x1) * dx + (y - y1) * dy;</span>

<span class="nc" id="L229">        Raster rast = saved;</span>
<span class="nc bnc" id="L230" title="All 6 branches missed.">        if (rast == null || rast.getWidth() &lt; w || rast.getHeight() &lt; h) {</span>
<span class="nc" id="L231">            rast = getCachedRaster(model, w, h);</span>
<span class="nc" id="L232">            saved = rast;</span>
        }
<span class="nc" id="L234">        IntegerComponentRaster irast = (IntegerComponentRaster) rast;</span>
<span class="nc" id="L235">        int off = irast.getDataOffset(0);</span>
<span class="nc" id="L236">        int adjust = irast.getScanlineStride() - w;</span>
<span class="nc" id="L237">        int[] pixels = irast.getDataStorage();</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (cyclic) {</span>
<span class="nc" id="L240">            cycleFillRaster(pixels, off, adjust, w, h, rowrel, dx, dy);</span>
        } else {
<span class="nc" id="L242">            clipFillRaster(pixels, off, adjust, w, h, rowrel, dx, dy);</span>
        }

<span class="nc" id="L245">        irast.markDirty();</span>

<span class="nc" id="L247">        return rast;</span>
    }

    void cycleFillRaster(int[] pixels, int off, int adjust, int w, int h,
                         double rowrel, double dx, double dy) {
<span class="nc" id="L252">        rowrel = rowrel % 2.0;</span>
<span class="nc" id="L253">        int irowrel = ((int) (rowrel * (1 &lt;&lt; 30))) &lt;&lt; 1;</span>
<span class="nc" id="L254">        int idx = (int) (-dx * (1 &lt;&lt; 31));</span>
<span class="nc" id="L255">        int idy = (int) (-dy * (1 &lt;&lt; 31));</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        while (--h &gt;= 0) {</span>
<span class="nc" id="L257">            int icolrel = irowrel;</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">            for (int j = w; j &gt; 0; j--) {</span>
<span class="nc" id="L259">                pixels[off++] = interp[icolrel &gt;&gt;&gt; 23];</span>
<span class="nc" id="L260">                icolrel += idx;</span>
            }

<span class="nc" id="L263">            off += adjust;</span>
<span class="nc" id="L264">            irowrel += idy;</span>
<span class="nc" id="L265">        }</span>
<span class="nc" id="L266">    }</span>

    void clipFillRaster(int[] pixels, int off, int adjust, int w, int h,
                        double rowrel, double dx, double dy) {
<span class="nc bnc" id="L270" title="All 2 branches missed.">        while (--h &gt;= 0) {</span>
<span class="nc" id="L271">            double colrel = rowrel;</span>
<span class="nc" id="L272">            int j = w;</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (colrel &lt;= 0.0) {</span>
<span class="nc" id="L274">                int rgb = interp[0];</span>
                do {
<span class="nc" id="L276">                    pixels[off++] = rgb;</span>
<span class="nc" id="L277">                    colrel += dx;</span>
<span class="nc bnc" id="L278" title="All 4 branches missed.">                } while (--j &gt; 0 &amp;&amp; colrel &lt;= 0.0);</span>
            }
<span class="nc bnc" id="L280" title="All 4 branches missed.">            while (colrel &lt; 1.0 &amp;&amp; --j &gt;= 0) {</span>
<span class="nc" id="L281">                pixels[off++] = interp[(int) (colrel * 256)];</span>
<span class="nc" id="L282">                colrel += dx;</span>
            }
<span class="nc bnc" id="L284" title="All 2 branches missed.">            if (j &gt; 0) {</span>
<span class="nc" id="L285">                int rgb = interp[256];</span>
                do {
<span class="nc" id="L287">                    pixels[off++] = rgb;</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">                } while (--j &gt; 0);</span>
            }

<span class="nc" id="L291">            off += adjust;</span>
<span class="nc" id="L292">            rowrel += dy;</span>
<span class="nc" id="L293">        }</span>
<span class="nc" id="L294">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>