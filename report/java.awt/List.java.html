<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>List.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">List.java</span></div><h1>List.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt;

import java.util.Vector;
import java.util.Locale;
import java.util.EventListener;
import java.awt.peer.ListPeer;
import java.awt.event.*;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import javax.accessibility.*;


/**
 * The &lt;code&gt;List&lt;/code&gt; component presents the user with a
 * scrolling list of text items. The list can be set up so that
 * the user can choose either one item or multiple items.
 * &lt;p&gt;
 * For example, the code&amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
 * &lt;p&gt;
 * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
 * List lst = new List(4, false);
 * lst.add(&quot;Mercury&quot;);
 * lst.add(&quot;Venus&quot;);
 * lst.add(&quot;Earth&quot;);
 * lst.add(&quot;JavaSoft&quot;);
 * lst.add(&quot;Mars&quot;);
 * lst.add(&quot;Jupiter&quot;);
 * lst.add(&quot;Saturn&quot;);
 * lst.add(&quot;Uranus&quot;);
 * lst.add(&quot;Neptune&quot;);
 * lst.add(&quot;Pluto&quot;);
 * cnt.add(lst);
 * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
 * &lt;p&gt;
 * where &lt;code&gt;cnt&lt;/code&gt; is a container, produces the following
 * scrolling list:
 * &lt;p&gt;
 * &lt;img src=&quot;doc-files/List-1.gif&quot;
 * alt=&quot;Shows a list containing: Venus, Earth, JavaSoft, and Mars. Javasoft is selected.&quot; style=&quot;float:center; margin: 7px 10px;&quot;&gt;
 * &lt;p&gt;
 * If the List allows multiple selections, then clicking on
 * an item that is already selected deselects it. In the preceding
 * example, only one item from the scrolling list can be selected
 * at a time, since the second argument when creating the new scrolling
 * list is &lt;code&gt;false&lt;/code&gt;. If the List does not allow multiple
 * selections, selecting an item causes any other selected item
 * to be deselected.
 * &lt;p&gt;
 * Note that the list in the example shown was created with four visible
 * rows.  Once the list has been created, the number of visible rows
 * cannot be changed.  A default &lt;code&gt;List&lt;/code&gt; is created with
 * four rows, so that &lt;code&gt;lst = new List()&lt;/code&gt; is equivalent to
 * &lt;code&gt;list = new List(4, false)&lt;/code&gt;.
 * &lt;p&gt;
 * Beginning with Java&amp;nbsp;1.1, the Abstract Window Toolkit
 * sends the &lt;code&gt;List&lt;/code&gt; object all mouse, keyboard, and focus events
 * that occur over it. (The old AWT event model is being maintained
 * only for backwards compatibility, and its use is discouraged.)
 * &lt;p&gt;
 * When an item is selected or deselected by the user, AWT sends an instance
 * of &lt;code&gt;ItemEvent&lt;/code&gt; to the list.
 * When the user double-clicks on an item in a scrolling list,
 * AWT sends an instance of &lt;code&gt;ActionEvent&lt;/code&gt; to the
 * list following the item event. AWT also generates an action event
 * when the user presses the return key while an item in the
 * list is selected.
 * &lt;p&gt;
 * If an application wants to perform some action based on an item
 * in this list being selected or activated by the user, it should implement
 * &lt;code&gt;ItemListener&lt;/code&gt; or &lt;code&gt;ActionListener&lt;/code&gt;
 * as appropriate and register the new listener to receive
 * events from this list.
 * &lt;p&gt;
 * For multiple-selection scrolling lists, it is considered a better
 * user interface to use an external gesture (such as clicking on a
 * button) to trigger the action.
 * @author      Sami Shaio
 * @see         java.awt.event.ItemEvent
 * @see         java.awt.event.ItemListener
 * @see         java.awt.event.ActionEvent
 * @see         java.awt.event.ActionListener
 * @since       JDK1.0
 */
public class List extends Component implements ItemSelectable, Accessible {
    /**
     * A vector created to contain items which will become
     * part of the List Component.
     *
     * @serial
     * @see #addItem(String)
     * @see #getItem(int)
     */
<span class="nc" id="L118">    Vector&lt;String&gt;      items = new Vector&lt;&gt;();</span>

    /**
     * This field will represent the number of visible rows in the
     * &lt;code&gt;List&lt;/code&gt; Component.  It is specified only once, and
     * that is when the list component is actually
     * created.  It will never change.
     *
     * @serial
     * @see #getRows()
     */
<span class="nc" id="L129">    int         rows = 0;</span>

    /**
     * &lt;code&gt;multipleMode&lt;/code&gt; is a variable that will
     * be set to &lt;code&gt;true&lt;/code&gt; if a list component is to be set to
     * multiple selection mode, that is where the user can
     * select more than one item in a list at one time.
     * &lt;code&gt;multipleMode&lt;/code&gt; will be set to false if the
     * list component is set to single selection, that is where
     * the user can only select one item on the list at any
     * one time.
     *
     * @serial
     * @see #isMultipleMode()
     * @see #setMultipleMode(boolean)
     */
<span class="nc" id="L145">    boolean     multipleMode = false;</span>

    /**
     * &lt;code&gt;selected&lt;/code&gt; is an array that will contain
     * the indices of items that have been selected.
     *
     * @serial
     * @see #getSelectedIndexes()
     * @see #getSelectedIndex()
     */
<span class="nc" id="L155">    int         selected[] = new int[0];</span>

    /**
     * This variable contains the value that will be used
     * when trying to make a particular list item visible.
     *
     * @serial
     * @see #makeVisible(int)
     */
<span class="nc" id="L164">    int         visibleIndex = -1;</span>

    transient ActionListener actionListener;
    transient ItemListener itemListener;

    private static final String base = &quot;list&quot;;
<span class="nc" id="L170">    private static int nameCounter = 0;</span>

    /*
     * JDK 1.1 serialVersionUID
     */
     private static final long serialVersionUID = -3304312411574666869L;

    /**
     * Creates a new scrolling list.
     * By default, there are four visible lines and multiple selections are
     * not allowed.  Note that this is a convenience method for
     * &lt;code&gt;List(0, false)&lt;/code&gt;.  Also note that the number of visible
     * lines in the list cannot be changed after it has been created.
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    public List() throws HeadlessException {
<span class="nc" id="L188">        this(0, false);</span>
<span class="nc" id="L189">    }</span>

    /**
     * Creates a new scrolling list initialized with the specified
     * number of visible lines. By default, multiple selections are
     * not allowed.  Note that this is a convenience method for
     * &lt;code&gt;List(rows, false)&lt;/code&gt;.  Also note that the number
     * of visible rows in the list cannot be changed after it has
     * been created.
     * @param       rows the number of items to show.
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     * @since       JDK1.1
     */
    public List(int rows) throws HeadlessException {
<span class="nc" id="L205">        this(rows, false);</span>
<span class="nc" id="L206">    }</span>

    /**
     * The default number of visible rows is 4.  A list with
     * zero rows is unusable and unsightly.
     */
    final static int    DEFAULT_VISIBLE_ROWS = 4;

    /**
     * Creates a new scrolling list initialized to display the specified
     * number of rows. Note that if zero rows are specified, then
     * the list will be created with a default of four rows.
     * Also note that the number of visible rows in the list cannot
     * be changed after it has been created.
     * If the value of &lt;code&gt;multipleMode&lt;/code&gt; is
     * &lt;code&gt;true&lt;/code&gt;, then the user can select multiple items from
     * the list. If it is &lt;code&gt;false&lt;/code&gt;, only one item at a time
     * can be selected.
     * @param       rows   the number of items to show.
     * @param       multipleMode   if &lt;code&gt;true&lt;/code&gt;,
     *                     then multiple selections are allowed;
     *                     otherwise, only one item can be selected at a time.
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
<span class="nc" id="L232">    public List(int rows, boolean multipleMode) throws HeadlessException {</span>
<span class="nc" id="L233">        GraphicsEnvironment.checkHeadless();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        this.rows = (rows != 0) ? rows : DEFAULT_VISIBLE_ROWS;</span>
<span class="nc" id="L235">        this.multipleMode = multipleMode;</span>
<span class="nc" id="L236">    }</span>

    /**
     * Construct a name for this component.  Called by
     * &lt;code&gt;getName&lt;/code&gt; when the name is &lt;code&gt;null&lt;/code&gt;.
     */
    String constructComponentName() {
<span class="nc" id="L243">        synchronized (List.class) {</span>
<span class="nc" id="L244">            return base + nameCounter++;</span>
<span class="nc" id="L245">        }</span>
    }

    /**
     * Creates the peer for the list.  The peer allows us to modify the
     * list's appearance without changing its functionality.
     */
    public void addNotify() {
<span class="nc" id="L253">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (peer == null)</span>
<span class="nc" id="L255">                peer = getToolkit().createList(this);</span>
<span class="nc" id="L256">            super.addNotify();</span>
<span class="nc" id="L257">        }</span>
<span class="nc" id="L258">    }</span>

    /**
     * Removes the peer for this list.  The peer allows us to modify the
     * list's appearance without changing its functionality.
     */
    public void removeNotify() {
<span class="nc" id="L265">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L266">            ListPeer peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L268">                selected = peer.getSelectedIndexes();</span>
            }
<span class="nc" id="L270">            super.removeNotify();</span>
<span class="nc" id="L271">        }</span>
<span class="nc" id="L272">    }</span>

    /**
     * Gets the number of items in the list.
     * @return     the number of items in the list
     * @see        #getItem
     * @since      JDK1.1
     */
    public int getItemCount() {
<span class="nc" id="L281">        return countItems();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getItemCount()&lt;/code&gt;.
     */
    @Deprecated
    public int countItems() {
<span class="nc" id="L290">        return items.size();</span>
    }

    /**
     * Gets the item associated with the specified index.
     * @return       an item that is associated with
     *                    the specified index
     * @param        index the position of the item
     * @see          #getItemCount
     */
    public String getItem(int index) {
<span class="nc" id="L301">        return getItemImpl(index);</span>
    }

    // NOTE: This method may be called by privileged threads.
    //       We implement this functionality in a package-private method
    //       to insure that it cannot be overridden by client subclasses.
    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
    final String getItemImpl(int index) {
<span class="nc" id="L309">        return items.elementAt(index);</span>
    }

    /**
     * Gets the items in the list.
     * @return       a string array containing items of the list
     * @see          #select
     * @see          #deselect
     * @see          #isIndexSelected
     * @since        JDK1.1
     */
    public synchronized String[] getItems() {
<span class="nc" id="L321">        String itemCopies[] = new String[items.size()];</span>
<span class="nc" id="L322">        items.copyInto(itemCopies);</span>
<span class="nc" id="L323">        return itemCopies;</span>
    }

    /**
     * Adds the specified item to the end of scrolling list.
     * @param item the item to be added
     * @since JDK1.1
     */
    public void add(String item) {
<span class="nc" id="L332">        addItem(item);</span>
<span class="nc" id="L333">    }</span>

    /**
     * @deprecated      replaced by &lt;code&gt;add(String)&lt;/code&gt;.
     */
    @Deprecated
    public void addItem(String item) {
<span class="nc" id="L340">        addItem(item, -1);</span>
<span class="nc" id="L341">    }</span>

    /**
     * Adds the specified item to the the scrolling list
     * at the position indicated by the index.  The index is
     * zero-based.  If the value of the index is less than zero,
     * or if the value of the index is greater than or equal to
     * the number of items in the list, then the item is added
     * to the end of the list.
     * @param       item   the item to be added;
     *              if this parameter is &lt;code&gt;null&lt;/code&gt; then the item is
     *              treated as an empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;
     * @param       index  the position at which to add the item
     * @since       JDK1.1
     */
    public void add(String item, int index) {
<span class="nc" id="L357">        addItem(item, index);</span>
<span class="nc" id="L358">    }</span>

    /**
     * @deprecated      replaced by &lt;code&gt;add(String, int)&lt;/code&gt;.
     */
    @Deprecated
    public synchronized void addItem(String item, int index) {
<span class="nc bnc" id="L365" title="All 4 branches missed.">        if (index &lt; -1 || index &gt;= items.size()) {</span>
<span class="nc" id="L366">            index = -1;</span>
        }

<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (item == null) {</span>
<span class="nc" id="L370">            item = &quot;&quot;;</span>
        }

<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (index == -1) {</span>
<span class="nc" id="L374">            items.addElement(item);</span>
        } else {
<span class="nc" id="L376">            items.insertElementAt(item, index);</span>
        }

<span class="nc" id="L379">        ListPeer peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L381">            peer.add(item, index);</span>
        }
<span class="nc" id="L383">    }</span>

    /**
     * Replaces the item at the specified index in the scrolling list
     * with the new string.
     * @param       newValue   a new string to replace an existing item
     * @param       index      the position of the item to replace
     * @exception ArrayIndexOutOfBoundsException if &lt;code&gt;index&lt;/code&gt;
     *          is out of range
     */
    public synchronized void replaceItem(String newValue, int index) {
<span class="nc" id="L394">        remove(index);</span>
<span class="nc" id="L395">        add(newValue, index);</span>
<span class="nc" id="L396">    }</span>

    /**
     * Removes all items from this list.
     * @see #remove
     * @see #delItems
     * @since JDK1.1
     */
    public void removeAll() {
<span class="nc" id="L405">        clear();</span>
<span class="nc" id="L406">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;removeAll()&lt;/code&gt;.
     */
    @Deprecated
    public synchronized void clear() {
<span class="nc" id="L414">        ListPeer peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L416">            peer.removeAll();</span>
        }
<span class="nc" id="L418">        items = new Vector&lt;&gt;();</span>
<span class="nc" id="L419">        selected = new int[0];</span>
<span class="nc" id="L420">    }</span>

    /**
     * Removes the first occurrence of an item from the list.
     * If the specified item is selected, and is the only selected
     * item in the list, the list is set to have no selection.
     * @param        item  the item to remove from the list
     * @exception    IllegalArgumentException
     *                     if the item doesn't exist in the list
     * @since        JDK1.1
     */
    public synchronized void remove(String item) {
<span class="nc" id="L432">        int index = items.indexOf(item);</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L434">            throw new IllegalArgumentException(&quot;item &quot; + item +</span>
                                               &quot; not found in list&quot;);
        } else {
<span class="nc" id="L437">            remove(index);</span>
        }
<span class="nc" id="L439">    }</span>

    /**
     * Removes the item at the specified position
     * from this scrolling list.
     * If the item with the specified position is selected, and is the
     * only selected item in the list, the list is set to have no selection.
     * @param      position   the index of the item to delete
     * @see        #add(String, int)
     * @since      JDK1.1
     * @exception    ArrayIndexOutOfBoundsException
     *               if the &lt;code&gt;position&lt;/code&gt; is less than 0 or
     *               greater than &lt;code&gt;getItemCount()-1&lt;/code&gt;
     */
    public void remove(int position) {
<span class="nc" id="L454">        delItem(position);</span>
<span class="nc" id="L455">    }</span>

    /**
     * @deprecated     replaced by &lt;code&gt;remove(String)&lt;/code&gt;
     *                         and &lt;code&gt;remove(int)&lt;/code&gt;.
     */
    @Deprecated
    public void delItem(int position) {
<span class="nc" id="L463">        delItems(position, position);</span>
<span class="nc" id="L464">    }</span>

    /**
     * Gets the index of the selected item on the list,
     *
     * @return        the index of the selected item;
     *                if no item is selected, or if multiple items are
     *                selected, &lt;code&gt;-1&lt;/code&gt; is returned.
     * @see           #select
     * @see           #deselect
     * @see           #isIndexSelected
     */
    public synchronized int getSelectedIndex() {
<span class="nc" id="L477">        int sel[] = getSelectedIndexes();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        return (sel.length == 1) ? sel[0] : -1;</span>
    }

    /**
     * Gets the selected indexes on the list.
     *
     * @return        an array of the selected indexes on this scrolling list;
     *                if no item is selected, a zero-length array is returned.
     * @see           #select
     * @see           #deselect
     * @see           #isIndexSelected
     */
    public synchronized int[] getSelectedIndexes() {
<span class="nc" id="L491">        ListPeer peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L493">            selected = peer.getSelectedIndexes();</span>
        }
<span class="nc" id="L495">        return selected.clone();</span>
    }

    /**
     * Gets the selected item on this scrolling list.
     *
     * @return        the selected item on the list;
     *                if no item is selected, or if multiple items are
     *                selected, &lt;code&gt;null&lt;/code&gt; is returned.
     * @see           #select
     * @see           #deselect
     * @see           #isIndexSelected
     */
    public synchronized String getSelectedItem() {
<span class="nc" id="L509">        int index = getSelectedIndex();</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">        return (index &lt; 0) ? null : getItem(index);</span>
    }

    /**
     * Gets the selected items on this scrolling list.
     *
     * @return        an array of the selected items on this scrolling list;
     *                if no item is selected, a zero-length array is returned.
     * @see           #select
     * @see           #deselect
     * @see           #isIndexSelected
     */
    public synchronized String[] getSelectedItems() {
<span class="nc" id="L523">        int sel[] = getSelectedIndexes();</span>
<span class="nc" id="L524">        String str[] = new String[sel.length];</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">        for (int i = 0 ; i &lt; sel.length ; i++) {</span>
<span class="nc" id="L526">            str[i] = getItem(sel[i]);</span>
        }
<span class="nc" id="L528">        return str;</span>
    }

    /**
     * Gets the selected items on this scrolling list in an array of Objects.
     * @return        an array of &lt;code&gt;Object&lt;/code&gt;s representing the
     *                selected items on this scrolling list;
     *                if no item is selected, a zero-length array is returned.
     * @see #getSelectedItems
     * @see ItemSelectable
     */
    public Object[] getSelectedObjects() {
<span class="nc" id="L540">        return getSelectedItems();</span>
    }

    /**
     * Selects the item at the specified index in the scrolling list.
     *&lt;p&gt;
     * Note that passing out of range parameters is invalid,
     * and will result in unspecified behavior.
     *
     * &lt;p&gt;Note that this method should be primarily used to
     * initially select an item in this component.
     * Programmatically calling this method will &lt;i&gt;not&lt;/i&gt; trigger
     * an &lt;code&gt;ItemEvent&lt;/code&gt;.  The only way to trigger an
     * &lt;code&gt;ItemEvent&lt;/code&gt; is by user interaction.
     *
     * @param        index the position of the item to select
     * @see          #getSelectedItem
     * @see          #deselect
     * @see          #isIndexSelected
     */
    public void select(int index) {
        // Bug #4059614: select can't be synchronized while calling the peer,
        // because it is called from the Window Thread.  It is sufficient to
        // synchronize the code that manipulates 'selected' except for the
        // case where the peer changes.  To handle this case, we simply
        // repeat the selection process.

        ListPeer peer;
        do {
<span class="nc" id="L569">            peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L571">                peer.select(index);</span>
<span class="nc" id="L572">                return;</span>
            }

<span class="nc" id="L575">            synchronized(this)</span>
            {
<span class="nc" id="L577">                boolean alreadySelected = false;</span>

<span class="nc bnc" id="L579" title="All 2 branches missed.">                for (int i = 0 ; i &lt; selected.length ; i++) {</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                    if (selected[i] == index) {</span>
<span class="nc" id="L581">                        alreadySelected = true;</span>
<span class="nc" id="L582">                        break;</span>
                    }
                }

<span class="nc bnc" id="L586" title="All 2 branches missed.">                if (!alreadySelected) {</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">                    if (!multipleMode) {</span>
<span class="nc" id="L588">                        selected = new int[1];</span>
<span class="nc" id="L589">                        selected[0] = index;</span>
                    } else {
<span class="nc" id="L591">                        int newsel[] = new int[selected.length + 1];</span>
<span class="nc" id="L592">                        System.arraycopy(selected, 0, newsel, 0,</span>
                                         selected.length);
<span class="nc" id="L594">                        newsel[selected.length] = index;</span>
<span class="nc" id="L595">                        selected = newsel;</span>
                    }
                }
<span class="nc" id="L598">            }</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        } while (peer != this.peer);</span>
<span class="nc" id="L600">    }</span>

    /**
     * Deselects the item at the specified index.
     * &lt;p&gt;
     * Note that passing out of range parameters is invalid,
     * and will result in unspecified behavior.
     * &lt;p&gt;
     * If the item at the specified index is not selected,
     * then the operation is ignored.
     * @param        index the position of the item to deselect
     * @see          #select
     * @see          #getSelectedItem
     * @see          #isIndexSelected
     */
    public synchronized void deselect(int index) {
<span class="nc" id="L616">        ListPeer peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc bnc" id="L618" title="All 4 branches missed.">            if (isMultipleMode() || (getSelectedIndex() == index)) {</span>
<span class="nc" id="L619">                peer.deselect(index);</span>
            }
        }

<span class="nc bnc" id="L623" title="All 2 branches missed.">        for (int i = 0 ; i &lt; selected.length ; i++) {</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">            if (selected[i] == index) {</span>
<span class="nc" id="L625">                int newsel[] = new int[selected.length - 1];</span>
<span class="nc" id="L626">                System.arraycopy(selected, 0, newsel, 0, i);</span>
<span class="nc" id="L627">                System.arraycopy(selected, i+1, newsel, i, selected.length - (i+1));</span>
<span class="nc" id="L628">                selected = newsel;</span>
<span class="nc" id="L629">                return;</span>
            }
        }
<span class="nc" id="L632">    }</span>

    /**
     * Determines if the specified item in this scrolling list is
     * selected.
     * @param      index   the item to be checked
     * @return     &lt;code&gt;true&lt;/code&gt; if the specified item has been
     *                       selected; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see        #select
     * @see        #deselect
     * @since      JDK1.1
     */
    public boolean isIndexSelected(int index) {
<span class="nc" id="L645">        return isSelected(index);</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;isIndexSelected(int)&lt;/code&gt;.
     */
    @Deprecated
    public boolean isSelected(int index) {
<span class="nc" id="L654">        int sel[] = getSelectedIndexes();</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">        for (int i = 0 ; i &lt; sel.length ; i++) {</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">            if (sel[i] == index) {</span>
<span class="nc" id="L657">                return true;</span>
            }
        }
<span class="nc" id="L660">        return false;</span>
    }

    /**
     * Gets the number of visible lines in this list.  Note that
     * once the &lt;code&gt;List&lt;/code&gt; has been created, this number
     * will never change.
     * @return     the number of visible lines in this scrolling list
     */
    public int getRows() {
<span class="nc" id="L670">        return rows;</span>
    }

    /**
     * Determines whether this list allows multiple selections.
     * @return     &lt;code&gt;true&lt;/code&gt; if this list allows multiple
     *                 selections; otherwise, &lt;code&gt;false&lt;/code&gt;
     * @see        #setMultipleMode
     * @since      JDK1.1
     */
    public boolean isMultipleMode() {
<span class="nc" id="L681">        return allowsMultipleSelections();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;isMultipleMode()&lt;/code&gt;.
     */
    @Deprecated
    public boolean allowsMultipleSelections() {
<span class="nc" id="L690">        return multipleMode;</span>
    }

    /**
     * Sets the flag that determines whether this list
     * allows multiple selections.
     * When the selection mode is changed from multiple-selection to
     * single-selection, the selected items change as follows:
     * If a selected item has the location cursor, only that
     * item will remain selected.  If no selected item has the
     * location cursor, all items will be deselected.
     * @param       b   if &lt;code&gt;true&lt;/code&gt; then multiple selections
     *                      are allowed; otherwise, only one item from
     *                      the list can be selected at once
     * @see         #isMultipleMode
     * @since       JDK1.1
     */
    public void setMultipleMode(boolean b) {
<span class="nc" id="L708">        setMultipleSelections(b);</span>
<span class="nc" id="L709">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;setMultipleMode(boolean)&lt;/code&gt;.
     */
    @Deprecated
    public synchronized void setMultipleSelections(boolean b) {
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (b != multipleMode) {</span>
<span class="nc" id="L718">            multipleMode = b;</span>
<span class="nc" id="L719">            ListPeer peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L721">                peer.setMultipleMode(b);</span>
            }
        }
<span class="nc" id="L724">    }</span>

    /**
     * Gets the index of the item that was last made visible by
     * the method &lt;code&gt;makeVisible&lt;/code&gt;.
     * @return      the index of the item that was last made visible
     * @see         #makeVisible
     */
    public int getVisibleIndex() {
<span class="nc" id="L733">        return visibleIndex;</span>
    }

    /**
     * Makes the item at the specified index visible.
     * @param       index    the position of the item
     * @see         #getVisibleIndex
     */
    public synchronized void makeVisible(int index) {
<span class="nc" id="L742">        visibleIndex = index;</span>
<span class="nc" id="L743">        ListPeer peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L745">            peer.makeVisible(index);</span>
        }
<span class="nc" id="L747">    }</span>

    /**
     * Gets the preferred dimensions for a list with the specified
     * number of rows.
     * @param      rows    number of rows in the list
     * @return     the preferred dimensions for displaying this scrolling list
     *             given that the specified number of rows must be visible
     * @see        java.awt.Component#getPreferredSize
     * @since      JDK1.1
     */
    public Dimension getPreferredSize(int rows) {
<span class="nc" id="L759">        return preferredSize(rows);</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getPreferredSize(int)&lt;/code&gt;.
     */
    @Deprecated
    public Dimension preferredSize(int rows) {
<span class="nc" id="L768">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L769">            ListPeer peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">            return (peer != null) ?</span>
<span class="nc" id="L771">                       peer.getPreferredSize(rows) :</span>
<span class="nc" id="L772">                       super.preferredSize();</span>
<span class="nc" id="L773">        }</span>
    }

    /**
     * Gets the preferred size of this scrolling list.
     * @return     the preferred dimensions for displaying this scrolling list
     * @see        java.awt.Component#getPreferredSize
     * @since      JDK1.1
     */
    public Dimension getPreferredSize() {
<span class="nc" id="L783">        return preferredSize();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getPreferredSize()&lt;/code&gt;.
     */
    @Deprecated
    public Dimension preferredSize() {
<span class="nc" id="L792">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">            return (rows &gt; 0) ?</span>
<span class="nc" id="L794">                       preferredSize(rows) :</span>
<span class="nc" id="L795">                       super.preferredSize();</span>
<span class="nc" id="L796">        }</span>
    }

    /**
     * Gets the minimum dimensions for a list with the specified
     * number of rows.
     * @param      rows    number of rows in the list
     * @return     the minimum dimensions for displaying this scrolling list
     *             given that the specified number of rows must be visible
     * @see        java.awt.Component#getMinimumSize
     * @since      JDK1.1
     */
    public Dimension getMinimumSize(int rows) {
<span class="nc" id="L809">        return minimumSize(rows);</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getMinimumSize(int)&lt;/code&gt;.
     */
    @Deprecated
    public Dimension minimumSize(int rows) {
<span class="nc" id="L818">        synchronized (getTreeLock()) {</span>
<span class="nc" id="L819">            ListPeer peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">            return (peer != null) ?</span>
<span class="nc" id="L821">                       peer.getMinimumSize(rows) :</span>
<span class="nc" id="L822">                       super.minimumSize();</span>
<span class="nc" id="L823">        }</span>
    }

    /**
     * Determines the minimum size of this scrolling list.
     * @return       the minimum dimensions needed
     *                        to display this scrolling list
     * @see          java.awt.Component#getMinimumSize()
     * @since        JDK1.1
     */
    public Dimension getMinimumSize() {
<span class="nc" id="L834">        return minimumSize();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getMinimumSize()&lt;/code&gt;.
     */
    @Deprecated
    public Dimension minimumSize() {
<span class="nc" id="L843">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">            return (rows &gt; 0) ? minimumSize(rows) : super.minimumSize();</span>
<span class="nc" id="L845">        }</span>
    }

    /**
     * Adds the specified item listener to receive item events from
     * this list.  Item events are sent in response to user input, but not
     * in response to calls to &lt;code&gt;select&lt;/code&gt; or &lt;code&gt;deselect&lt;/code&gt;.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param         l the item listener
     * @see           #removeItemListener
     * @see           #getItemListeners
     * @see           #select
     * @see           #deselect
     * @see           java.awt.event.ItemEvent
     * @see           java.awt.event.ItemListener
     * @since         JDK1.1
     */
    public synchronized void addItemListener(ItemListener l) {
<span class="nc bnc" id="L867" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L868">            return;</span>
        }
<span class="nc" id="L870">        itemListener = AWTEventMulticaster.add(itemListener, l);</span>
<span class="nc" id="L871">        newEventsOnly = true;</span>
<span class="nc" id="L872">    }</span>

    /**
     * Removes the specified item listener so that it no longer
     * receives item events from this list.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param           l the item listener
     * @see             #addItemListener
     * @see             #getItemListeners
     * @see             java.awt.event.ItemEvent
     * @see             java.awt.event.ItemListener
     * @since           JDK1.1
     */
    public synchronized void removeItemListener(ItemListener l) {
<span class="nc bnc" id="L890" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L891">            return;</span>
        }
<span class="nc" id="L893">        itemListener = AWTEventMulticaster.remove(itemListener, l);</span>
<span class="nc" id="L894">    }</span>

    /**
     * Returns an array of all the item listeners
     * registered on this list.
     *
     * @return all of this list's &lt;code&gt;ItemListener&lt;/code&gt;s
     *         or an empty array if no item
     *         listeners are currently registered
     *
     * @see             #addItemListener
     * @see             #removeItemListener
     * @see             java.awt.event.ItemEvent
     * @see             java.awt.event.ItemListener
     * @since 1.4
     */
    public synchronized ItemListener[] getItemListeners() {
<span class="nc" id="L911">        return getListeners(ItemListener.class);</span>
    }

    /**
     * Adds the specified action listener to receive action events from
     * this list. Action events occur when a user double-clicks
     * on a list item or types Enter when the list has the keyboard
     * focus.
     * &lt;p&gt;
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param         l the action listener
     * @see           #removeActionListener
     * @see           #getActionListeners
     * @see           java.awt.event.ActionEvent
     * @see           java.awt.event.ActionListener
     * @since         JDK1.1
     */
    public synchronized void addActionListener(ActionListener l) {
<span class="nc bnc" id="L933" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L934">            return;</span>
        }
<span class="nc" id="L936">        actionListener = AWTEventMulticaster.add(actionListener, l);</span>
<span class="nc" id="L937">        newEventsOnly = true;</span>
<span class="nc" id="L938">    }</span>

    /**
     * Removes the specified action listener so that it no longer
     * receives action events from this list. Action events
     * occur when a user double-clicks on a list item.
     * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception is thrown and no action is performed.
     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
     *
     * @param           l     the action listener
     * @see             #addActionListener
     * @see             #getActionListeners
     * @see             java.awt.event.ActionEvent
     * @see             java.awt.event.ActionListener
     * @since           JDK1.1
     */
    public synchronized void removeActionListener(ActionListener l) {
<span class="nc bnc" id="L957" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L958">            return;</span>
        }
<span class="nc" id="L960">        actionListener = AWTEventMulticaster.remove(actionListener, l);</span>
<span class="nc" id="L961">    }</span>

    /**
     * Returns an array of all the action listeners
     * registered on this list.
     *
     * @return all of this list's &lt;code&gt;ActionListener&lt;/code&gt;s
     *         or an empty array if no action
     *         listeners are currently registered
     *
     * @see             #addActionListener
     * @see             #removeActionListener
     * @see             java.awt.event.ActionEvent
     * @see             java.awt.event.ActionListener
     * @since 1.4
     */
    public synchronized ActionListener[] getActionListeners() {
<span class="nc" id="L978">        return getListeners(ActionListener.class);</span>
    }

    /**
     * Returns an array of all the objects currently registered
     * as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
     * upon this &lt;code&gt;List&lt;/code&gt;.
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
     * &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
     *
     * &lt;p&gt;
     * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
     * with a class literal, such as
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
     * For example, you can query a
     * &lt;code&gt;List&lt;/code&gt; &lt;code&gt;l&lt;/code&gt;
     * for its item listeners with the following code:
     *
     * &lt;pre&gt;ItemListener[] ils = (ItemListener[])(l.getListeners(ItemListener.class));&lt;/pre&gt;
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @return an array of all objects registered as
     *          &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s on this list,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt;
     *          doesn't specify a class or interface that implements
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     *
     * @see #getItemListeners
     * @since 1.3
     */
    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<span class="nc" id="L1015">        EventListener l = null;</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">        if  (listenerType == ActionListener.class) {</span>
<span class="nc" id="L1017">            l = actionListener;</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">        } else if  (listenerType == ItemListener.class) {</span>
<span class="nc" id="L1019">            l = itemListener;</span>
        } else {
<span class="nc" id="L1021">            return super.getListeners(listenerType);</span>
        }
<span class="nc" id="L1023">        return AWTEventMulticaster.getListeners(l, listenerType);</span>
    }

    // REMIND: remove when filtering is done at lower level
    boolean eventEnabled(AWTEvent e) {
<span class="nc bnc" id="L1028" title="All 3 branches missed.">        switch(e.id) {</span>
          case ActionEvent.ACTION_PERFORMED:
<span class="nc bnc" id="L1030" title="All 4 branches missed.">            if ((eventMask &amp; AWTEvent.ACTION_EVENT_MASK) != 0 ||</span>
                actionListener != null) {
<span class="nc" id="L1032">                return true;</span>
            }
<span class="nc" id="L1034">            return false;</span>
          case ItemEvent.ITEM_STATE_CHANGED:
<span class="nc bnc" id="L1036" title="All 4 branches missed.">            if ((eventMask &amp; AWTEvent.ITEM_EVENT_MASK) != 0 ||</span>
                itemListener != null) {
<span class="nc" id="L1038">                return true;</span>
            }
<span class="nc" id="L1040">            return false;</span>
          default:
            break;
        }
<span class="nc" id="L1044">        return super.eventEnabled(e);</span>
    }

    /**
     * Processes events on this scrolling list. If an event is
     * an instance of &lt;code&gt;ItemEvent&lt;/code&gt;, it invokes the
     * &lt;code&gt;processItemEvent&lt;/code&gt; method. Else, if the
     * event is an instance of &lt;code&gt;ActionEvent&lt;/code&gt;,
     * it invokes &lt;code&gt;processActionEvent&lt;/code&gt;.
     * If the event is not an item event or an action event,
     * it invokes &lt;code&gt;processEvent&lt;/code&gt; on the superclass.
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param        e the event
     * @see          java.awt.event.ActionEvent
     * @see          java.awt.event.ItemEvent
     * @see          #processActionEvent
     * @see          #processItemEvent
     * @since        JDK1.1
     */
    protected void processEvent(AWTEvent e) {
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        if (e instanceof ItemEvent) {</span>
<span class="nc" id="L1068">            processItemEvent((ItemEvent)e);</span>
<span class="nc" id="L1069">            return;</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">        } else if (e instanceof ActionEvent) {</span>
<span class="nc" id="L1071">            processActionEvent((ActionEvent)e);</span>
<span class="nc" id="L1072">            return;</span>
        }
<span class="nc" id="L1074">        super.processEvent(e);</span>
<span class="nc" id="L1075">    }</span>

    /**
     * Processes item events occurring on this list by
     * dispatching them to any registered
     * &lt;code&gt;ItemListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * This method is not called unless item events are
     * enabled for this component. Item events are enabled
     * when one of the following occurs:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;An &lt;code&gt;ItemListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addItemListener&lt;/code&gt;.
     * &lt;li&gt;Item events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the item event
     * @see         java.awt.event.ItemEvent
     * @see         java.awt.event.ItemListener
     * @see         #addItemListener
     * @see         java.awt.Component#enableEvents
     * @since       JDK1.1
     */
    protected void processItemEvent(ItemEvent e) {
<span class="nc" id="L1102">        ItemListener listener = itemListener;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L1104">            listener.itemStateChanged(e);</span>
        }
<span class="nc" id="L1106">    }</span>

    /**
     * Processes action events occurring on this component
     * by dispatching them to any registered
     * &lt;code&gt;ActionListener&lt;/code&gt; objects.
     * &lt;p&gt;
     * This method is not called unless action events are
     * enabled for this component. Action events are enabled
     * when one of the following occurs:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;An &lt;code&gt;ActionListener&lt;/code&gt; object is registered
     * via &lt;code&gt;addActionListener&lt;/code&gt;.
     * &lt;li&gt;Action events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the action event
     * @see         java.awt.event.ActionEvent
     * @see         java.awt.event.ActionListener
     * @see         #addActionListener
     * @see         java.awt.Component#enableEvents
     * @since       JDK1.1
     */
    protected void processActionEvent(ActionEvent e) {
<span class="nc" id="L1133">        ActionListener listener = actionListener;</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L1135">            listener.actionPerformed(e);</span>
        }
<span class="nc" id="L1137">    }</span>

    /**
     * Returns the parameter string representing the state of this
     * scrolling list. This string is useful for debugging.
     * @return    the parameter string of this scrolling list
     */
    protected String paramString() {
<span class="nc" id="L1145">        return super.paramString() + &quot;,selected=&quot; + getSelectedItem();</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * Not for public use in the future.
     * This method is expected to be retained only as a package
     * private method.
     */
    @Deprecated
    public synchronized void delItems(int start, int end) {
<span class="nc bnc" id="L1156" title="All 2 branches missed.">        for (int i = end; i &gt;= start; i--) {</span>
<span class="nc" id="L1157">            items.removeElementAt(i);</span>
        }
<span class="nc" id="L1159">        ListPeer peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L1161">            peer.delItems(start, end);</span>
        }
<span class="nc" id="L1163">    }</span>

    /*
     * Serialization support.  Since the value of the selected
     * field isn't necessarily up to date, we sync it up with the
     * peer before serializing.
     */

    /**
     * The &lt;code&gt;List&lt;/code&gt; component's
     * Serialized Data Version.
     *
     * @serial
     */
<span class="nc" id="L1177">    private int listSerializedDataVersion = 1;</span>

    /**
     * Writes default serializable fields to stream.  Writes
     * a list of serializable &lt;code&gt;ItemListeners&lt;/code&gt;
     * and &lt;code&gt;ActionListeners&lt;/code&gt; as optional data.
     * The non-serializable listeners are detected and
     * no attempt is made to serialize them.
     *
     * @serialData &lt;code&gt;null&lt;/code&gt; terminated sequence of 0
     *  or more pairs; the pair consists of a &lt;code&gt;String&lt;/code&gt;
     *  and an &lt;code&gt;Object&lt;/code&gt;; the &lt;code&gt;String&lt;/code&gt;
     *  indicates the type of object and is one of the
     *  following:
     *  &lt;code&gt;itemListenerK&lt;/code&gt; indicating an
     *    &lt;code&gt;ItemListener&lt;/code&gt; object;
     *  &lt;code&gt;actionListenerK&lt;/code&gt; indicating an
     *    &lt;code&gt;ActionListener&lt;/code&gt; object
     *
     * @param s the &lt;code&gt;ObjectOutputStream&lt;/code&gt; to write
     * @see AWTEventMulticaster#save(ObjectOutputStream, String, EventListener)
     * @see java.awt.Component#itemListenerK
     * @see java.awt.Component#actionListenerK
     * @see #readObject(ObjectInputStream)
     */
    private void writeObject(ObjectOutputStream s)
      throws IOException
    {
<span class="nc" id="L1205">      synchronized (this) {</span>
<span class="nc" id="L1206">        ListPeer peer = (ListPeer)this.peer;</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L1208">          selected = peer.getSelectedIndexes();</span>
        }
<span class="nc" id="L1210">      }</span>
<span class="nc" id="L1211">      s.defaultWriteObject();</span>

<span class="nc" id="L1213">      AWTEventMulticaster.save(s, itemListenerK, itemListener);</span>
<span class="nc" id="L1214">      AWTEventMulticaster.save(s, actionListenerK, actionListener);</span>
<span class="nc" id="L1215">      s.writeObject(null);</span>
<span class="nc" id="L1216">    }</span>

    /**
     * Reads the &lt;code&gt;ObjectInputStream&lt;/code&gt; and if it
     * isn't &lt;code&gt;null&lt;/code&gt; adds a listener to receive
     * both item events and action events (as specified
     * by the key stored in the stream) fired by the
     * &lt;code&gt;List&lt;/code&gt;.
     * Unrecognized keys or values will be ignored.
     *
     * @param s the &lt;code&gt;ObjectInputStream&lt;/code&gt; to write
     * @exception HeadlessException if
     *   &lt;code&gt;GraphicsEnvironment.isHeadless&lt;/code&gt; returns
     *   &lt;code&gt;true&lt;/code&gt;
     * @see #removeItemListener(ItemListener)
     * @see #addItemListener(ItemListener)
     * @see java.awt.GraphicsEnvironment#isHeadless
     * @see #writeObject(ObjectOutputStream)
     */
    private void readObject(ObjectInputStream s)
      throws ClassNotFoundException, IOException, HeadlessException
    {
<span class="nc" id="L1238">      GraphicsEnvironment.checkHeadless();</span>
<span class="nc" id="L1239">      s.defaultReadObject();</span>

      Object keyOrNull;
<span class="nc bnc" id="L1242" title="All 2 branches missed.">      while(null != (keyOrNull = s.readObject())) {</span>
<span class="nc" id="L1243">        String key = ((String)keyOrNull).intern();</span>

<span class="nc bnc" id="L1245" title="All 2 branches missed.">        if (itemListenerK == key)</span>
<span class="nc" id="L1246">          addItemListener((ItemListener)(s.readObject()));</span>

<span class="nc bnc" id="L1248" title="All 2 branches missed.">        else if (actionListenerK == key)</span>
<span class="nc" id="L1249">          addActionListener((ActionListener)(s.readObject()));</span>

        else // skip value for unrecognized key
<span class="nc" id="L1252">          s.readObject();</span>
<span class="nc" id="L1253">      }</span>
<span class="nc" id="L1254">    }</span>


/////////////////
// Accessibility support
////////////////


    /**
     * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
     * &lt;code&gt;List&lt;/code&gt;. For lists, the &lt;code&gt;AccessibleContext&lt;/code&gt;
     * takes the form of an &lt;code&gt;AccessibleAWTList&lt;/code&gt;.
     * A new &lt;code&gt;AccessibleAWTList&lt;/code&gt; instance is created, if necessary.
     *
     * @return an &lt;code&gt;AccessibleAWTList&lt;/code&gt; that serves as the
     *         &lt;code&gt;AccessibleContext&lt;/code&gt; of this &lt;code&gt;List&lt;/code&gt;
     * @since 1.3
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L1273" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L1274">            accessibleContext = new AccessibleAWTList();</span>
        }
<span class="nc" id="L1276">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;List&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to list user-interface elements.
     * @since 1.3
     */
    protected class AccessibleAWTList extends AccessibleAWTComponent
        implements AccessibleSelection, ItemListener, ActionListener
    {
        /*
         * JDK 1.3 serialVersionUID
         */
        private static final long serialVersionUID = 7924617370136012829L;

<span class="nc" id="L1293">        public AccessibleAWTList() {</span>
<span class="nc" id="L1294">            super();</span>
<span class="nc" id="L1295">            List.this.addActionListener(this);</span>
<span class="nc" id="L1296">            List.this.addItemListener(this);</span>
<span class="nc" id="L1297">        }</span>

        public void actionPerformed(ActionEvent event)  {
<span class="nc" id="L1300">        }</span>

        public void itemStateChanged(ItemEvent event)  {
<span class="nc" id="L1303">        }</span>

        /**
         * Get the state set of this object.
         *
         * @return an instance of AccessibleState containing the current state
         * of the object
         * @see AccessibleState
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L1313">            AccessibleStateSet states = super.getAccessibleStateSet();</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">            if (List.this.isMultipleMode())  {</span>
<span class="nc" id="L1315">                states.add(AccessibleState.MULTISELECTABLE);</span>
            }
<span class="nc" id="L1317">            return states;</span>
        }

        /**
         * Get the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of the
         * object
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L1328">            return AccessibleRole.LIST;</span>
        }

        /**
         * Returns the Accessible child contained at the local coordinate
         * Point, if one exists.
         *
         * @return the Accessible at the specified location, if it exists
         */
        public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L1338">            return null; // fredxFIXME Not implemented yet</span>
        }

        /**
         * Returns the number of accessible children in the object.  If all
         * of the children of this object implement Accessible, than this
         * method should return the number of children of this object.
         *
         * @return the number of accessible children in the object.
         */
        public int getAccessibleChildrenCount() {
<span class="nc" id="L1349">            return List.this.getItemCount();</span>
        }

        /**
         * Return the nth Accessible child of the object.
         *
         * @param i zero-based index of child
         * @return the nth Accessible child of the object
         */
        public Accessible getAccessibleChild(int i) {
<span class="nc" id="L1359">            synchronized(List.this)  {</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">                if (i &gt;= List.this.getItemCount()) {</span>
<span class="nc" id="L1361">                    return null;</span>
                } else {
<span class="nc" id="L1363">                    return new AccessibleAWTListChild(List.this, i);</span>
                }
<span class="nc" id="L1365">            }</span>
        }

        /**
         * Get the AccessibleSelection associated with this object.  In the
         * implementation of the Java Accessibility API for this class,
         * return this object, which is responsible for implementing the
         * AccessibleSelection interface on behalf of itself.
         *
         * @return this object
         */
        public AccessibleSelection getAccessibleSelection() {
<span class="nc" id="L1377">            return this;</span>
        }

    // AccessibleSelection methods

        /**
         * Returns the number of items currently selected.
         * If no items are selected, the return value will be 0.
         *
         * @return the number of items currently selected.
         */
         public int getAccessibleSelectionCount() {
<span class="nc" id="L1389">             return List.this.getSelectedIndexes().length;</span>
         }

        /**
         * Returns an Accessible representing the specified selected item
         * in the object.  If there isn't a selection, or there are
         * fewer items selected than the integer passed in, the return
         * value will be null.
         *
         * @param i the zero-based index of selected items
         * @return an Accessible containing the selected item
         */
         public Accessible getAccessibleSelection(int i) {
<span class="nc" id="L1402">             synchronized(List.this)  {</span>
<span class="nc" id="L1403">                 int len = getAccessibleSelectionCount();</span>
<span class="nc bnc" id="L1404" title="All 4 branches missed.">                 if (i &lt; 0 || i &gt;= len) {</span>
<span class="nc" id="L1405">                     return null;</span>
                 } else {
<span class="nc" id="L1407">                     return getAccessibleChild(List.this.getSelectedIndexes()[i]);</span>
                 }
<span class="nc" id="L1409">             }</span>
         }

        /**
         * Returns true if the current child of this object is selected.
         *
         * @param i the zero-based index of the child in this Accessible
         * object.
         * @see AccessibleContext#getAccessibleChild
         */
        public boolean isAccessibleChildSelected(int i) {
<span class="nc" id="L1420">            return List.this.isIndexSelected(i);</span>
        }

        /**
         * Adds the specified selected item in the object to the object's
         * selection.  If the object supports multiple selections,
         * the specified item is added to any existing selection, otherwise
         * it replaces any existing selection in the object.  If the
         * specified item is already selected, this method has no effect.
         *
         * @param i the zero-based index of selectable items
         */
         public void addAccessibleSelection(int i) {
<span class="nc" id="L1433">             List.this.select(i);</span>
<span class="nc" id="L1434">         }</span>

        /**
         * Removes the specified selected item in the object from the object's
         * selection.  If the specified item isn't currently selected, this
         * method has no effect.
         *
         * @param i the zero-based index of selectable items
         */
         public void removeAccessibleSelection(int i) {
<span class="nc" id="L1444">             List.this.deselect(i);</span>
<span class="nc" id="L1445">         }</span>

        /**
         * Clears the selection in the object, so that nothing in the
         * object is selected.
         */
         public void clearAccessibleSelection() {
<span class="nc" id="L1452">             synchronized(List.this)  {</span>
<span class="nc" id="L1453">                 int selectedIndexes[] = List.this.getSelectedIndexes();</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">                 if (selectedIndexes == null)</span>
<span class="nc" id="L1455">                     return;</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">                 for (int i = selectedIndexes.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L1457">                     List.this.deselect(selectedIndexes[i]);</span>
                 }
<span class="nc" id="L1459">             }</span>
<span class="nc" id="L1460">         }</span>

        /**
         * Causes every selected item in the object to be selected
         * if the object supports multiple selections.
         */
         public void selectAllAccessibleSelection() {
<span class="nc" id="L1467">             synchronized(List.this)  {</span>
<span class="nc bnc" id="L1468" title="All 2 branches missed.">                 for (int i = List.this.getItemCount() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L1469">                     List.this.select(i);</span>
                 }
<span class="nc" id="L1471">             }</span>
<span class="nc" id="L1472">         }</span>

       /**
        * This class implements accessibility support for
        * List children.  It provides an implementation of the
        * Java Accessibility API appropriate to list children
        * user-interface elements.
        * @since 1.3
        */
        protected class AccessibleAWTListChild extends AccessibleAWTComponent
            implements Accessible
        {
            /*
             * JDK 1.3 serialVersionUID
             */
            private static final long serialVersionUID = 4412022926028300317L;

        // [[[FIXME]]] need to finish implementing this!!!

            private List parent;
            private int  indexInParent;

<span class="nc" id="L1494">            public AccessibleAWTListChild(List parent, int indexInParent)  {</span>
<span class="nc" id="L1495">                this.parent = parent;</span>
<span class="nc" id="L1496">                this.setAccessibleParent(parent);</span>
<span class="nc" id="L1497">                this.indexInParent = indexInParent;</span>
<span class="nc" id="L1498">            }</span>

            //
            // required Accessible methods
            //
          /**
           * Gets the AccessibleContext for this object.  In the
           * implementation of the Java Accessibility API for this class,
           * return this object, which acts as its own AccessibleContext.
           *
           * @return this object
           */
            public AccessibleContext getAccessibleContext() {
<span class="nc" id="L1511">                return this;</span>
            }

            //
            // required AccessibleContext methods
            //

            /**
             * Get the role of this object.
             *
             * @return an instance of AccessibleRole describing the role of
             * the object
             * @see AccessibleRole
             */
            public AccessibleRole getAccessibleRole() {
<span class="nc" id="L1526">                return AccessibleRole.LIST_ITEM;</span>
            }

            /**
             * Get the state set of this object.  The AccessibleStateSet of an
             * object is composed of a set of unique AccessibleState's.  A
             * change in the AccessibleStateSet of an object will cause a
             * PropertyChangeEvent to be fired for the
             * ACCESSIBLE_STATE_PROPERTY property.
             *
             * @return an instance of AccessibleStateSet containing the
             * current state set of the object
             * @see AccessibleStateSet
             * @see AccessibleState
             * @see #addPropertyChangeListener
             */
            public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L1543">                AccessibleStateSet states = super.getAccessibleStateSet();</span>
<span class="nc bnc" id="L1544" title="All 2 branches missed.">                if (parent.isIndexSelected(indexInParent)) {</span>
<span class="nc" id="L1545">                    states.add(AccessibleState.SELECTED);</span>
                }
<span class="nc" id="L1547">                return states;</span>
            }

            /**
             * Gets the locale of the component. If the component does not
             * have a locale, then the locale of its parent is returned.
             *
             * @return This component's locale.  If this component does not have
             * a locale, the locale of its parent is returned.
             *
             * @exception IllegalComponentStateException
             * If the Component does not have its own locale and has not yet
             * been added to a containment hierarchy such that the locale can
             * be determined from the containing parent.
             */
            public Locale getLocale() {
<span class="nc" id="L1563">                return parent.getLocale();</span>
            }

            /**
             * Get the 0-based index of this object in its accessible parent.
             *
             * @return the 0-based index of this object in its parent; -1 if
             * this object does not have an accessible parent.
             *
             * @see #getAccessibleParent
             * @see #getAccessibleChildrenCount
             * @see #getAccessibleChild
             */
            public int getAccessibleIndexInParent() {
<span class="nc" id="L1577">                return indexInParent;</span>
            }

            /**
             * Returns the number of accessible children of the object.
             *
             * @return the number of accessible children of the object.
             */
            public int getAccessibleChildrenCount() {
<span class="nc" id="L1586">                return 0;       // list elements can't have children</span>
            }

            /**
             * Return the specified Accessible child of the object.  The
             * Accessible children of an Accessible object are zero-based,
             * so the first child of an Accessible child is at index 0, the
             * second child is at index 1, and so on.
             *
             * @param i zero-based index of child
             * @return the Accessible child of the object
             * @see #getAccessibleChildrenCount
             */
            public Accessible getAccessibleChild(int i) {
<span class="nc" id="L1600">                return null;    // list elements can't have children</span>
            }


            //
            // AccessibleComponent delegatation to parent List
            //

            /**
             * Get the background color of this object.
             *
             * @return the background color, if supported, of the object;
             * otherwise, null
             * @see #setBackground
             */
            public Color getBackground() {
<span class="nc" id="L1616">                return parent.getBackground();</span>
            }

            /**
             * Set the background color of this object.
             *
             * @param c the new Color for the background
             * @see #setBackground
             */
            public void setBackground(Color c) {
<span class="nc" id="L1626">                parent.setBackground(c);</span>
<span class="nc" id="L1627">            }</span>

            /**
             * Get the foreground color of this object.
             *
             * @return the foreground color, if supported, of the object;
             * otherwise, null
             * @see #setForeground
             */
            public Color getForeground() {
<span class="nc" id="L1637">                return parent.getForeground();</span>
            }

            /**
             * Set the foreground color of this object.
             *
             * @param c the new Color for the foreground
             * @see #getForeground
             */
            public void setForeground(Color c) {
<span class="nc" id="L1647">                parent.setForeground(c);</span>
<span class="nc" id="L1648">            }</span>

            /**
             * Get the Cursor of this object.
             *
             * @return the Cursor, if supported, of the object; otherwise, null
             * @see #setCursor
             */
            public Cursor getCursor() {
<span class="nc" id="L1657">                return parent.getCursor();</span>
            }

            /**
             * Set the Cursor of this object.
             * &lt;p&gt;
             * The method may have no visual effect if the Java platform
             * implementation and/or the native system do not support
             * changing the mouse cursor shape.
             * @param cursor the new Cursor for the object
             * @see #getCursor
             */
            public void setCursor(Cursor cursor) {
<span class="nc" id="L1670">                parent.setCursor(cursor);</span>
<span class="nc" id="L1671">            }</span>

            /**
             * Get the Font of this object.
             *
             * @return the Font,if supported, for the object; otherwise, null
             * @see #setFont
             */
            public Font getFont() {
<span class="nc" id="L1680">                return parent.getFont();</span>
            }

            /**
             * Set the Font of this object.
             *
             * @param f the new Font for the object
             * @see #getFont
             */
            public void setFont(Font f) {
<span class="nc" id="L1690">                parent.setFont(f);</span>
<span class="nc" id="L1691">            }</span>

            /**
             * Get the FontMetrics of this object.
             *
             * @param f the Font
             * @return the FontMetrics, if supported, the object; otherwise, null
             * @see #getFont
             */
            public FontMetrics getFontMetrics(Font f) {
<span class="nc" id="L1701">                return parent.getFontMetrics(f);</span>
            }

            /**
             * Determine if the object is enabled.  Objects that are enabled
             * will also have the AccessibleState.ENABLED state set in their
             * AccessibleStateSet.
             *
             * @return true if object is enabled; otherwise, false
             * @see #setEnabled
             * @see AccessibleContext#getAccessibleStateSet
             * @see AccessibleState#ENABLED
             * @see AccessibleStateSet
             */
            public boolean isEnabled() {
<span class="nc" id="L1716">                return parent.isEnabled();</span>
            }

            /**
             * Set the enabled state of the object.
             *
             * @param b if true, enables this object; otherwise, disables it
             * @see #isEnabled
             */
            public void setEnabled(boolean b) {
<span class="nc" id="L1726">                parent.setEnabled(b);</span>
<span class="nc" id="L1727">            }</span>

            /**
             * Determine if the object is visible.  Note: this means that the
             * object intends to be visible; however, it may not be
             * showing on the screen because one of the objects that this object
             * is contained by is currently not visible.  To determine if an
             * object is showing on the screen, use isShowing().
             * &lt;p&gt;Objects that are visible will also have the
             * AccessibleState.VISIBLE state set in their AccessibleStateSet.
             *
             * @return true if object is visible; otherwise, false
             * @see #setVisible
             * @see AccessibleContext#getAccessibleStateSet
             * @see AccessibleState#VISIBLE
             * @see AccessibleStateSet
             */
            public boolean isVisible() {
                // [[[FIXME]]] needs to work like isShowing() below
<span class="nc" id="L1746">                return false;</span>
                // return parent.isVisible();
            }

            /**
             * Set the visible state of the object.
             *
             * @param b if true, shows this object; otherwise, hides it
             * @see #isVisible
             */
            public void setVisible(boolean b) {
                // [[[FIXME]]] should scroll to item to make it show!
<span class="nc" id="L1758">                parent.setVisible(b);</span>
<span class="nc" id="L1759">            }</span>

            /**
             * Determine if the object is showing.  This is determined by
             * checking the visibility of the object and visibility of the
             * object ancestors.
             * Note: this will return true even if the object is obscured
             * by another (for example, it to object is underneath a menu
             * that was pulled down).
             *
             * @return true if object is showing; otherwise, false
             */
            public boolean isShowing() {
                // [[[FIXME]]] only if it's showing!!!
<span class="nc" id="L1773">                return false;</span>
                // return parent.isShowing();
            }

            /**
             * Checks whether the specified point is within this object's
             * bounds, where the point's x and y coordinates are defined to
             * be relative to the coordinate system of the object.
             *
             * @param p the Point relative to the coordinate system of the
             * object
             * @return true if object contains Point; otherwise false
             * @see #getBounds
             */
            public boolean contains(Point p) {
                // [[[FIXME]]] - only if p is within the list element!!!
<span class="nc" id="L1789">                return false;</span>
                // return parent.contains(p);
            }

            /**
             * Returns the location of the object on the screen.
             *
             * @return location of object on screen; null if this object
             * is not on the screen
             * @see #getBounds
             * @see #getLocation
             */
            public Point getLocationOnScreen() {
                // [[[FIXME]]] sigh
<span class="nc" id="L1803">                return null;</span>
            }

            /**
             * Gets the location of the object relative to the parent in the
             * form of a point specifying the object's top-left corner in the
             * screen's coordinate space.
             *
             * @return An instance of Point representing the top-left corner of
             * the objects's bounds in the coordinate space of the screen; null
             * if this object or its parent are not on the screen
             * @see #getBounds
             * @see #getLocationOnScreen
             */
            public Point getLocation() {
                // [[[FIXME]]]
<span class="nc" id="L1819">                return null;</span>
            }

            /**
             * Sets the location of the object relative to the parent.
             * @param p the new position for the top-left corner
             * @see #getLocation
             */
            public void setLocation(Point p) {
                // [[[FIXME]]] maybe - can simply return as no-op
<span class="nc" id="L1829">            }</span>

            /**
             * Gets the bounds of this object in the form of a Rectangle object.
             * The bounds specify this object's width, height, and location
             * relative to its parent.
             *
             * @return A rectangle indicating this component's bounds; null if
             * this object is not on the screen.
             * @see #contains
             */
            public Rectangle getBounds() {
                // [[[FIXME]]]
<span class="nc" id="L1842">                return null;</span>
            }

            /**
             * Sets the bounds of this object in the form of a Rectangle
             * object.  The bounds specify this object's width, height, and
             * location relative to its parent.
             *
             * @param r rectangle indicating this component's bounds
             * @see #getBounds
             */
            public void setBounds(Rectangle r) {
                // no-op; not supported
<span class="nc" id="L1855">            }</span>

            /**
             * Returns the size of this object in the form of a Dimension
             * object.  The height field of the Dimension object contains this
             * objects's height, and the width field of the Dimension object
             * contains this object's width.
             *
             * @return A Dimension object that indicates the size of this
             * component; null if this object is not on the screen
             * @see #setSize
             */
            public Dimension getSize() {
                // [[[FIXME]]]
<span class="nc" id="L1869">                return null;</span>
            }

            /**
             * Resizes this object so that it has width and height.
             *
             * @param d - The dimension specifying the new size of the object.
             * @see #getSize
             */
            public void setSize(Dimension d) {
                // not supported; no-op
<span class="nc" id="L1880">            }</span>

            /**
             * Returns the &lt;code&gt;Accessible&lt;/code&gt; child, if one exists,
             * contained at the local coordinate &lt;code&gt;Point&lt;/code&gt;.
             *
             * @param p the point relative to the coordinate system of this
             *     object
             * @return the &lt;code&gt;Accessible&lt;/code&gt;, if it exists,
             *     at the specified location; otherwise &lt;code&gt;null&lt;/code&gt;
             */
            public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L1892">                return null;    // object cannot have children!</span>
            }

            /**
             * Returns whether this object can accept focus or not.   Objects
             * that can accept focus will also have the
             * &lt;code&gt;AccessibleState.FOCUSABLE&lt;/code&gt; state set in their
             * &lt;code&gt;AccessibleStateSet&lt;/code&gt;.
             *
             * @return true if object can accept focus; otherwise false
             * @see AccessibleContext#getAccessibleStateSet
             * @see AccessibleState#FOCUSABLE
             * @see AccessibleState#FOCUSED
             * @see AccessibleStateSet
             */
            public boolean isFocusTraversable() {
<span class="nc" id="L1908">                return false;   // list element cannot receive focus!</span>
            }

            /**
             * Requests focus for this object.  If this object cannot accept
             * focus, nothing will happen.  Otherwise, the object will attempt
             * to take focus.
             * @see #isFocusTraversable
             */
            public void requestFocus() {
                // nothing to do; a no-op
<span class="nc" id="L1919">            }</span>

            /**
             * Adds the specified focus listener to receive focus events from
             * this component.
             *
             * @param l the focus listener
             * @see #removeFocusListener
             */
            public void addFocusListener(FocusListener l) {
                // nothing to do; a no-op
<span class="nc" id="L1930">            }</span>

            /**
             * Removes the specified focus listener so it no longer receives
             * focus events from this component.
             *
             * @param l the focus listener
             * @see #addFocusListener
             */
            public void removeFocusListener(FocusListener l) {
                // nothing to do; a no-op
<span class="nc" id="L1941">            }</span>



        } // inner class AccessibleAWTListChild

    } // inner class AccessibleAWTList

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>