<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ScrollPane.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">ScrollPane.java</span></div><h1>ScrollPane.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt;

import java.awt.peer.LightweightPeer;
import java.awt.peer.ScrollPanePeer;
import java.awt.event.*;
import javax.accessibility.*;
import sun.awt.ScrollPaneWheelScroller;
import sun.awt.SunToolkit;

import java.beans.ConstructorProperties;
import java.beans.Transient;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.IOException;

/**
 * A container class which implements automatic horizontal and/or
 * vertical scrolling for a single child component.  The display
 * policy for the scrollbars can be set to:
 * &lt;OL&gt;
 * &lt;LI&gt;as needed: scrollbars created and shown only when needed by scrollpane
 * &lt;LI&gt;always: scrollbars created and always shown by the scrollpane
 * &lt;LI&gt;never: scrollbars never created or shown by the scrollpane
 * &lt;/OL&gt;
 * &lt;P&gt;
 * The state of the horizontal and vertical scrollbars is represented
 * by two &lt;code&gt;ScrollPaneAdjustable&lt;/code&gt; objects (one for each
 * dimension) which implement the &lt;code&gt;Adjustable&lt;/code&gt; interface.
 * The API provides methods to access those objects such that the
 * attributes on the Adjustable object (such as unitIncrement, value,
 * etc.) can be manipulated.
 * &lt;P&gt;
 * Certain adjustable properties (minimum, maximum, blockIncrement,
 * and visibleAmount) are set internally by the scrollpane in accordance
 * with the geometry of the scrollpane and its child and these should
 * not be set by programs using the scrollpane.
 * &lt;P&gt;
 * If the scrollbar display policy is defined as &quot;never&quot;, then the
 * scrollpane can still be programmatically scrolled using the
 * setScrollPosition() method and the scrollpane will move and clip
 * the child's contents appropriately.  This policy is useful if the
 * program needs to create and manage its own adjustable controls.
 * &lt;P&gt;
 * The placement of the scrollbars is controlled by platform-specific
 * properties set by the user outside of the program.
 * &lt;P&gt;
 * The initial size of this container is set to 100x100, but can
 * be reset using setSize().
 * &lt;P&gt;
 * Scrolling with the wheel on a wheel-equipped mouse is enabled by default.
 * This can be disabled using &lt;code&gt;setWheelScrollingEnabled&lt;/code&gt;.
 * Wheel scrolling can be customized by setting the block and
 * unit increment of the horizontal and vertical Adjustables.
 * For information on how mouse wheel events are dispatched, see
 * the class description for {@link MouseWheelEvent}.
 * &lt;P&gt;
 * Insets are used to define any space used by scrollbars and any
 * borders created by the scroll pane. getInsets() can be used
 * to get the current value for the insets.  If the value of
 * scrollbarsAlwaysVisible is false, then the value of the insets
 * will change dynamically depending on whether the scrollbars are
 * currently visible or not.
 *
 * @author      Tom Ball
 * @author      Amy Fowler
 * @author      Tim Prinzing
 */
public class ScrollPane extends Container implements Accessible {


    /**
     * Initialize JNI field and method IDs
     */
    private static native void initIDs();

    static {
        /* ensure that the necessary native libraries are loaded */
<span class="nc" id="L102">        Toolkit.loadLibraries();</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L104">            initIDs();</span>
        }
    }

    /**
     * Specifies that horizontal/vertical scrollbar should be shown
     * only when the size of the child exceeds the size of the scrollpane
     * in the horizontal/vertical dimension.
     */
    public static final int SCROLLBARS_AS_NEEDED = 0;

    /**
     * Specifies that horizontal/vertical scrollbars should always be
     * shown regardless of the respective sizes of the scrollpane and child.
     */
    public static final int SCROLLBARS_ALWAYS = 1;

    /**
     * Specifies that horizontal/vertical scrollbars should never be shown
     * regardless of the respective sizes of the scrollpane and child.
     */
    public static final int SCROLLBARS_NEVER = 2;

    /**
     * There are 3 ways in which a scroll bar can be displayed.
     * This integer will represent one of these 3 displays -
     * (SCROLLBARS_ALWAYS, SCROLLBARS_AS_NEEDED, SCROLLBARS_NEVER)
     *
     * @serial
     * @see #getScrollbarDisplayPolicy
     */
    private int scrollbarDisplayPolicy;

    /**
     * An adjustable vertical scrollbar.
     * It is important to note that you must &lt;em&gt;NOT&lt;/em&gt; call 3
     * &lt;code&gt;Adjustable&lt;/code&gt; methods, namely:
     * &lt;code&gt;setMinimum()&lt;/code&gt;, &lt;code&gt;setMaximum()&lt;/code&gt;,
     * &lt;code&gt;setVisibleAmount()&lt;/code&gt;.
     *
     * @serial
     * @see #getVAdjustable
     */
    private ScrollPaneAdjustable vAdjustable;

    /**
     * An adjustable horizontal scrollbar.
     * It is important to note that you must &lt;em&gt;NOT&lt;/em&gt; call 3
     * &lt;code&gt;Adjustable&lt;/code&gt; methods, namely:
     * &lt;code&gt;setMinimum()&lt;/code&gt;, &lt;code&gt;setMaximum()&lt;/code&gt;,
     * &lt;code&gt;setVisibleAmount()&lt;/code&gt;.
     *
     * @serial
     * @see #getHAdjustable
     */
    private ScrollPaneAdjustable hAdjustable;

    private static final String base = &quot;scrollpane&quot;;
<span class="nc" id="L162">    private static int nameCounter = 0;</span>

    private static final boolean defaultWheelScroll = true;

    /**
     * Indicates whether or not scrolling should take place when a
     * MouseWheelEvent is received.
     *
     * @serial
     * @since 1.4
     */
<span class="nc" id="L173">    private boolean wheelScrollingEnabled = defaultWheelScroll;</span>

    /*
     * JDK 1.1 serialVersionUID
     */
    private static final long serialVersionUID = 7956609840827222915L;

    /**
     * Create a new scrollpane container with a scrollbar display
     * policy of &quot;as needed&quot;.
     * @throws HeadlessException if GraphicsEnvironment.isHeadless()
     *     returns true
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    public ScrollPane() throws HeadlessException {
<span class="nc" id="L188">        this(SCROLLBARS_AS_NEEDED);</span>
<span class="nc" id="L189">    }</span>

    /**
     * Create a new scrollpane container.
     * @param scrollbarDisplayPolicy policy for when scrollbars should be shown
     * @throws IllegalArgumentException if the specified scrollbar
     *     display policy is invalid
     * @throws HeadlessException if GraphicsEnvironment.isHeadless()
     *     returns true
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    @ConstructorProperties({&quot;scrollbarDisplayPolicy&quot;})
<span class="nc" id="L201">    public ScrollPane(int scrollbarDisplayPolicy) throws HeadlessException {</span>
<span class="nc" id="L202">        GraphicsEnvironment.checkHeadless();</span>
<span class="nc" id="L203">        this.layoutMgr = null;</span>
<span class="nc" id="L204">        this.width = 100;</span>
<span class="nc" id="L205">        this.height = 100;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        switch (scrollbarDisplayPolicy) {</span>
            case SCROLLBARS_NEVER:
            case SCROLLBARS_AS_NEEDED:
            case SCROLLBARS_ALWAYS:
<span class="nc" id="L210">                this.scrollbarDisplayPolicy = scrollbarDisplayPolicy;</span>
<span class="nc" id="L211">                break;</span>
            default:
<span class="nc" id="L213">                throw new IllegalArgumentException(&quot;illegal scrollbar display policy&quot;);</span>
        }

<span class="nc" id="L216">        vAdjustable = new ScrollPaneAdjustable(this, new PeerFixer(this),</span>
                                               Adjustable.VERTICAL);
<span class="nc" id="L218">        hAdjustable = new ScrollPaneAdjustable(this, new PeerFixer(this),</span>
                                               Adjustable.HORIZONTAL);
<span class="nc" id="L220">        setWheelScrollingEnabled(defaultWheelScroll);</span>
<span class="nc" id="L221">    }</span>

    /**
     * Construct a name for this component.  Called by getName() when the
     * name is null.
     */
    String constructComponentName() {
<span class="nc" id="L228">        synchronized (ScrollPane.class) {</span>
<span class="nc" id="L229">            return base + nameCounter++;</span>
<span class="nc" id="L230">        }</span>
    }

    // The scrollpane won't work with a windowless child... it assumes
    // it is moving a child window around so the windowless child is
    // wrapped with a window.
    private void addToPanel(Component comp, Object constraints, int index) {
<span class="nc" id="L237">        Panel child = new Panel();</span>
<span class="nc" id="L238">        child.setLayout(new BorderLayout());</span>
<span class="nc" id="L239">        child.add(comp);</span>
<span class="nc" id="L240">        super.addImpl(child, constraints, index);</span>
<span class="nc" id="L241">        validate();</span>
<span class="nc" id="L242">    }</span>

    /**
     * Adds the specified component to this scroll pane container.
     * If the scroll pane has an existing child component, that
     * component is removed and the new one is added.
     * @param comp the component to be added
     * @param constraints  not applicable
     * @param index position of child component (must be &amp;lt;= 0)
     */
    protected final void addImpl(Component comp, Object constraints, int index) {
<span class="nc" id="L253">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (getComponentCount() &gt; 0) {</span>
<span class="nc" id="L255">                remove(0);</span>
            }
<span class="nc bnc" id="L257" title="All 2 branches missed.">            if (index &gt; 0) {</span>
<span class="nc" id="L258">                throw new IllegalArgumentException(&quot;position greater than 0&quot;);</span>
            }

<span class="nc bnc" id="L261" title="All 2 branches missed.">            if (!SunToolkit.isLightweightOrUnknown(comp)) {</span>
<span class="nc" id="L262">                super.addImpl(comp, constraints, index);</span>
            } else {
<span class="nc" id="L264">                addToPanel(comp, constraints, index);</span>
            }
<span class="nc" id="L266">        }</span>
<span class="nc" id="L267">    }</span>

    /**
     * Returns the display policy for the scrollbars.
     * @return the display policy for the scrollbars
     */
    public int getScrollbarDisplayPolicy() {
<span class="nc" id="L274">        return scrollbarDisplayPolicy;</span>
    }

    /**
     * Returns the current size of the scroll pane's view port.
     * @return the size of the view port in pixels
     */
    public Dimension getViewportSize() {
<span class="nc" id="L282">        Insets i = getInsets();</span>
<span class="nc" id="L283">        return new Dimension(width - i.right - i.left,</span>
                             height - i.top - i.bottom);
    }

    /**
     * Returns the height that would be occupied by a horizontal
     * scrollbar, which is independent of whether it is currently
     * displayed by the scroll pane or not.
     * @return the height of a horizontal scrollbar in pixels
     */
    public int getHScrollbarHeight() {
<span class="nc" id="L294">        int h = 0;</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (scrollbarDisplayPolicy != SCROLLBARS_NEVER) {</span>
<span class="nc" id="L296">            ScrollPanePeer peer = (ScrollPanePeer)this.peer;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L298">                h = peer.getHScrollbarHeight();</span>
            }
        }
<span class="nc" id="L301">        return h;</span>
    }

    /**
     * Returns the width that would be occupied by a vertical
     * scrollbar, which is independent of whether it is currently
     * displayed by the scroll pane or not.
     * @return the width of a vertical scrollbar in pixels
     */
    public int getVScrollbarWidth() {
<span class="nc" id="L311">        int w = 0;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">        if (scrollbarDisplayPolicy != SCROLLBARS_NEVER) {</span>
<span class="nc" id="L313">            ScrollPanePeer peer = (ScrollPanePeer)this.peer;</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L315">                w = peer.getVScrollbarWidth();</span>
            }
        }
<span class="nc" id="L318">        return w;</span>
    }

    /**
     * Returns the &lt;code&gt;ScrollPaneAdjustable&lt;/code&gt; object which
     * represents the state of the vertical scrollbar.
     * The declared return type of this method is
     * &lt;code&gt;Adjustable&lt;/code&gt; to maintain backward compatibility.
     * @see java.awt.ScrollPaneAdjustable
     */
    public Adjustable getVAdjustable() {
<span class="nc" id="L329">        return vAdjustable;</span>
    }

    /**
     * Returns the &lt;code&gt;ScrollPaneAdjustable&lt;/code&gt; object which
     * represents the state of the horizontal scrollbar.
     * The declared return type of this method is
     * &lt;code&gt;Adjustable&lt;/code&gt; to maintain backward compatibility.
     * @see java.awt.ScrollPaneAdjustable
     */
    public Adjustable getHAdjustable() {
<span class="nc" id="L340">        return hAdjustable;</span>
    }

    /**
     * Scrolls to the specified position within the child component.
     * A call to this method is only valid if the scroll pane contains
     * a child.  Specifying a position outside of the legal scrolling bounds
     * of the child will scroll to the closest legal position.
     * Legal bounds are defined to be the rectangle:
     * x = 0, y = 0, width = (child width - view port width),
     * height = (child height - view port height).
     * This is a convenience method which interfaces with the Adjustable
     * objects which represent the state of the scrollbars.
     * @param x the x position to scroll to
     * @param y the y position to scroll to
     * @throws NullPointerException if the scrollpane does not contain
     *     a child
     */
    public void setScrollPosition(int x, int y) {
<span class="nc" id="L359">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (getComponentCount()==0) {</span>
<span class="nc" id="L361">                throw new NullPointerException(&quot;child is null&quot;);</span>
            }
<span class="nc" id="L363">            hAdjustable.setValue(x);</span>
<span class="nc" id="L364">            vAdjustable.setValue(y);</span>
<span class="nc" id="L365">        }</span>
<span class="nc" id="L366">    }</span>

    /**
     * Scrolls to the specified position within the child component.
     * A call to this method is only valid if the scroll pane contains
     * a child and the specified position is within legal scrolling bounds
     * of the child.  Specifying a position outside of the legal scrolling
     * bounds of the child will scroll to the closest legal position.
     * Legal bounds are defined to be the rectangle:
     * x = 0, y = 0, width = (child width - view port width),
     * height = (child height - view port height).
     * This is a convenience method which interfaces with the Adjustable
     * objects which represent the state of the scrollbars.
     * @param p the Point representing the position to scroll to
     * @throws NullPointerException if {@code p} is {@code null}
     */
    public void setScrollPosition(Point p) {
<span class="nc" id="L383">        setScrollPosition(p.x, p.y);</span>
<span class="nc" id="L384">    }</span>

    /**
     * Returns the current x,y position within the child which is displayed
     * at the 0,0 location of the scrolled panel's view port.
     * This is a convenience method which interfaces with the adjustable
     * objects which represent the state of the scrollbars.
     * @return the coordinate position for the current scroll position
     * @throws NullPointerException if the scrollpane does not contain
     *     a child
     */
    @Transient
    public Point getScrollPosition() {
<span class="nc" id="L397">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            if (getComponentCount()==0) {</span>
<span class="nc" id="L399">                throw new NullPointerException(&quot;child is null&quot;);</span>
            }
<span class="nc" id="L401">            return new Point(hAdjustable.getValue(), vAdjustable.getValue());</span>
<span class="nc" id="L402">        }</span>
    }

    /**
     * Sets the layout manager for this container.  This method is
     * overridden to prevent the layout mgr from being set.
     * @param mgr the specified layout manager
     */
    public final void setLayout(LayoutManager mgr) {
<span class="nc" id="L411">        throw new AWTError(&quot;ScrollPane controls layout&quot;);</span>
    }

    /**
     * Lays out this container by resizing its child to its preferred size.
     * If the new preferred size of the child causes the current scroll
     * position to be invalid, the scroll position is set to the closest
     * valid position.
     *
     * @see Component#validate
     */
    public void doLayout() {
<span class="nc" id="L423">        layout();</span>
<span class="nc" id="L424">    }</span>

    /**
     * Determine the size to allocate the child component.
     * If the viewport area is bigger than the preferred size
     * of the child then the child is allocated enough
     * to fill the viewport, otherwise the child is given
     * it's preferred size.
     */
    Dimension calculateChildSize() {
        //
        // calculate the view size, accounting for border but not scrollbars
        // - don't use right/bottom insets since they vary depending
        //   on whether or not scrollbars were displayed on last resize
        //
<span class="nc" id="L439">        Dimension       size = getSize();</span>
<span class="nc" id="L440">        Insets          insets = getInsets();</span>
<span class="nc" id="L441">        int             viewWidth = size.width - insets.left*2;</span>
<span class="nc" id="L442">        int             viewHeight = size.height - insets.top*2;</span>

        //
        // determine whether or not horz or vert scrollbars will be displayed
        //
        boolean vbarOn;
        boolean hbarOn;
<span class="nc" id="L449">        Component child = getComponent(0);</span>
<span class="nc" id="L450">        Dimension childSize = new Dimension(child.getPreferredSize());</span>

<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (scrollbarDisplayPolicy == SCROLLBARS_AS_NEEDED) {</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">            vbarOn = childSize.height &gt; viewHeight;</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">            hbarOn = childSize.width  &gt; viewWidth;</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        } else if (scrollbarDisplayPolicy == SCROLLBARS_ALWAYS) {</span>
<span class="nc" id="L456">            vbarOn = hbarOn = true;</span>
        } else { // SCROLLBARS_NEVER
<span class="nc" id="L458">            vbarOn = hbarOn = false;</span>
        }

        //
        // adjust predicted view size to account for scrollbars
        //
<span class="nc" id="L464">        int vbarWidth = getVScrollbarWidth();</span>
<span class="nc" id="L465">        int hbarHeight = getHScrollbarHeight();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (vbarOn) {</span>
<span class="nc" id="L467">            viewWidth -= vbarWidth;</span>
        }
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if(hbarOn) {</span>
<span class="nc" id="L470">            viewHeight -= hbarHeight;</span>
        }

        //
        // if child is smaller than view, size it up
        //
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (childSize.width &lt; viewWidth) {</span>
<span class="nc" id="L477">            childSize.width = viewWidth;</span>
        }
<span class="nc bnc" id="L479" title="All 2 branches missed.">        if (childSize.height &lt; viewHeight) {</span>
<span class="nc" id="L480">            childSize.height = viewHeight;</span>
        }

<span class="nc" id="L483">        return childSize;</span>
    }

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;doLayout()&lt;/code&gt;.
     */
    @Deprecated
    public void layout() {
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (getComponentCount()==0) {</span>
<span class="nc" id="L493">            return;</span>
        }
<span class="nc" id="L495">        Component c = getComponent(0);</span>
<span class="nc" id="L496">        Point p = getScrollPosition();</span>
<span class="nc" id="L497">        Dimension cs = calculateChildSize();</span>
<span class="nc" id="L498">        Dimension vs = getViewportSize();</span>
<span class="nc" id="L499">        Insets i = getInsets();</span>

<span class="nc" id="L501">        c.reshape(i.left - p.x, i.top - p.y, cs.width, cs.height);</span>
<span class="nc" id="L502">        ScrollPanePeer peer = (ScrollPanePeer)this.peer;</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L504">            peer.childResized(cs.width, cs.height);</span>
        }

        // update adjustables... the viewport size may have changed
        // with the scrollbars coming or going so the viewport size
        // is updated before the adjustables.
<span class="nc" id="L510">        vs = getViewportSize();</span>
<span class="nc" id="L511">        hAdjustable.setSpan(0, cs.width, vs.width);</span>
<span class="nc" id="L512">        vAdjustable.setSpan(0, cs.height, vs.height);</span>
<span class="nc" id="L513">    }</span>

    /**
     * Prints the component in this scroll pane.
     * @param g the specified Graphics window
     * @see Component#print
     * @see Component#printAll
     */
    public void printComponents(Graphics g) {
<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (getComponentCount()==0) {</span>
<span class="nc" id="L523">            return;</span>
        }
<span class="nc" id="L525">        Component c = getComponent(0);</span>
<span class="nc" id="L526">        Point p = c.getLocation();</span>
<span class="nc" id="L527">        Dimension vs = getViewportSize();</span>
<span class="nc" id="L528">        Insets i = getInsets();</span>

<span class="nc" id="L530">        Graphics cg = g.create();</span>
        try {
<span class="nc" id="L532">            cg.clipRect(i.left, i.top, vs.width, vs.height);</span>
<span class="nc" id="L533">            cg.translate(p.x, p.y);</span>
<span class="nc" id="L534">            c.printAll(cg);</span>
        } finally {
<span class="nc" id="L536">            cg.dispose();</span>
<span class="nc" id="L537">        }</span>
<span class="nc" id="L538">    }</span>

    /**
     * Creates the scroll pane's peer.
     */
    public void addNotify() {
<span class="nc" id="L544">        synchronized (getTreeLock()) {</span>

<span class="nc" id="L546">            int vAdjustableValue = 0;</span>
<span class="nc" id="L547">            int hAdjustableValue = 0;</span>

            // Bug 4124460. Save the current adjustable values,
            // so they can be restored after addnotify. Set the
            // adjustables to 0, to prevent crashes for possible
            // negative values.
<span class="nc bnc" id="L553" title="All 2 branches missed.">            if (getComponentCount() &gt; 0) {</span>
<span class="nc" id="L554">                vAdjustableValue = vAdjustable.getValue();</span>
<span class="nc" id="L555">                hAdjustableValue = hAdjustable.getValue();</span>
<span class="nc" id="L556">                vAdjustable.setValue(0);</span>
<span class="nc" id="L557">                hAdjustable.setValue(0);</span>
            }

<span class="nc bnc" id="L560" title="All 2 branches missed.">            if (peer == null)</span>
<span class="nc" id="L561">                peer = getToolkit().createScrollPane(this);</span>
<span class="nc" id="L562">            super.addNotify();</span>

            // Bug 4124460. Restore the adjustable values.
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if (getComponentCount() &gt; 0) {</span>
<span class="nc" id="L566">                vAdjustable.setValue(vAdjustableValue);</span>
<span class="nc" id="L567">                hAdjustable.setValue(hAdjustableValue);</span>
            }
<span class="nc" id="L569">        }</span>
<span class="nc" id="L570">    }</span>

    /**
     * Returns a string representing the state of this
     * &lt;code&gt;ScrollPane&lt;/code&gt;. This
     * method is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not be
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @return the parameter string of this scroll pane
     */
    public String paramString() {
        String sdpStr;
<span class="nc bnc" id="L584" title="All 4 branches missed.">        switch (scrollbarDisplayPolicy) {</span>
            case SCROLLBARS_AS_NEEDED:
<span class="nc" id="L586">                sdpStr = &quot;as-needed&quot;;</span>
<span class="nc" id="L587">                break;</span>
            case SCROLLBARS_ALWAYS:
<span class="nc" id="L589">                sdpStr = &quot;always&quot;;</span>
<span class="nc" id="L590">                break;</span>
            case SCROLLBARS_NEVER:
<span class="nc" id="L592">                sdpStr = &quot;never&quot;;</span>
<span class="nc" id="L593">                break;</span>
            default:
<span class="nc" id="L595">                sdpStr = &quot;invalid display policy&quot;;</span>
        }
<span class="nc bnc" id="L597" title="All 2 branches missed.">        Point p = (getComponentCount()&gt;0)? getScrollPosition() : new Point(0,0);</span>
<span class="nc" id="L598">        Insets i = getInsets();</span>
<span class="nc" id="L599">        return super.paramString()+&quot;,ScrollPosition=(&quot;+p.x+&quot;,&quot;+p.y+&quot;)&quot;+</span>
            &quot;,Insets=(&quot;+i.top+&quot;,&quot;+i.left+&quot;,&quot;+i.bottom+&quot;,&quot;+i.right+&quot;)&quot;+
            &quot;,ScrollbarDisplayPolicy=&quot;+sdpStr+
<span class="nc" id="L602">        &quot;,wheelScrollingEnabled=&quot;+isWheelScrollingEnabled();</span>
    }

    void autoProcessMouseWheel(MouseWheelEvent e) {
<span class="nc" id="L606">        processMouseWheelEvent(e);</span>
<span class="nc" id="L607">    }</span>

    /**
     * Process mouse wheel events that are delivered to this
     * &lt;code&gt;ScrollPane&lt;/code&gt; by scrolling an appropriate amount.
     * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param e  the mouse wheel event
     * @since 1.4
     */
    protected void processMouseWheelEvent(MouseWheelEvent e) {
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (isWheelScrollingEnabled()) {</span>
<span class="nc" id="L621">            ScrollPaneWheelScroller.handleWheelScrolling(this, e);</span>
<span class="nc" id="L622">            e.consume();</span>
        }
<span class="nc" id="L624">        super.processMouseWheelEvent(e);</span>
<span class="nc" id="L625">    }</span>

    /**
     * If wheel scrolling is enabled, we return true for MouseWheelEvents
     * @since 1.4
     */
    protected boolean eventTypeEnabled(int type) {
<span class="nc bnc" id="L632" title="All 4 branches missed.">        if (type == MouseEvent.MOUSE_WHEEL &amp;&amp; isWheelScrollingEnabled()) {</span>
<span class="nc" id="L633">            return true;</span>
        }
        else {
<span class="nc" id="L636">            return super.eventTypeEnabled(type);</span>
        }
    }

    /**
     * Enables/disables scrolling in response to movement of the mouse wheel.
     * Wheel scrolling is enabled by default.
     *
     * @param handleWheel   &lt;code&gt;true&lt;/code&gt; if scrolling should be done
     *                      automatically for a MouseWheelEvent,
     *                      &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see #isWheelScrollingEnabled
     * @see java.awt.event.MouseWheelEvent
     * @see java.awt.event.MouseWheelListener
     * @since 1.4
     */
    public void setWheelScrollingEnabled(boolean handleWheel) {
<span class="nc" id="L653">        wheelScrollingEnabled = handleWheel;</span>
<span class="nc" id="L654">    }</span>

    /**
     * Indicates whether or not scrolling will take place in response to
     * the mouse wheel.  Wheel scrolling is enabled by default.
     *
     * @see #setWheelScrollingEnabled(boolean)
     * @since 1.4
     */
    public boolean isWheelScrollingEnabled() {
<span class="nc" id="L664">        return wheelScrollingEnabled;</span>
    }


    /**
     * Writes default serializable fields to stream.
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
        // 4352819: We only need this degenerate writeObject to make
        // it safe for future versions of this class to write optional
        // data to the stream.
<span class="nc" id="L675">        s.defaultWriteObject();</span>
<span class="nc" id="L676">    }</span>

    /**
     * Reads default serializable fields to stream.
     * @exception HeadlessException if
     * &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt; returns
     * &lt;code&gt;true&lt;/code&gt;
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    private void readObject(ObjectInputStream s)
        throws ClassNotFoundException, IOException, HeadlessException
    {
<span class="nc" id="L688">        GraphicsEnvironment.checkHeadless();</span>
        // 4352819: Gotcha!  Cannot use s.defaultReadObject here and
        // then continue with reading optional data.  Use GetField instead.
<span class="nc" id="L691">        ObjectInputStream.GetField f = s.readFields();</span>

        // Old fields
<span class="nc" id="L694">        scrollbarDisplayPolicy = f.get(&quot;scrollbarDisplayPolicy&quot;,</span>
                                       SCROLLBARS_AS_NEEDED);
<span class="nc" id="L696">        hAdjustable = (ScrollPaneAdjustable)f.get(&quot;hAdjustable&quot;, null);</span>
<span class="nc" id="L697">        vAdjustable = (ScrollPaneAdjustable)f.get(&quot;vAdjustable&quot;, null);</span>

        // Since 1.4
<span class="nc" id="L700">        wheelScrollingEnabled = f.get(&quot;wheelScrollingEnabled&quot;,</span>
                                      defaultWheelScroll);

//      // Note to future maintainers
//      if (f.defaulted(&quot;wheelScrollingEnabled&quot;)) {
//          // We are reading pre-1.4 stream that doesn't have
//          // optional data, not even the TC_ENDBLOCKDATA marker.
//          // Reading anything after this point is unsafe as we will
//          // read unrelated objects further down the stream (4352819).
//      }
//      else {
//          // Reading data from 1.4 or later, it's ok to try to read
//          // optional data as OptionalDataException with eof == true
//          // will be correctly reported
//      }
<span class="nc" id="L715">    }</span>

    class PeerFixer implements AdjustmentListener, java.io.Serializable
    {
        private static final long serialVersionUID = 1043664721353696630L;

<span class="nc" id="L721">        PeerFixer(ScrollPane scroller) {</span>
<span class="nc" id="L722">            this.scroller = scroller;</span>
<span class="nc" id="L723">        }</span>

        /**
         * Invoked when the value of the adjustable has changed.
         */
        public void adjustmentValueChanged(AdjustmentEvent e) {
<span class="nc" id="L729">            Adjustable adj = e.getAdjustable();</span>
<span class="nc" id="L730">            int value = e.getValue();</span>
<span class="nc" id="L731">            ScrollPanePeer peer = (ScrollPanePeer) scroller.peer;</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">            if (peer != null) {</span>
<span class="nc" id="L733">                peer.setValue(adj, value);</span>
            }

<span class="nc" id="L736">            Component c = scroller.getComponent(0);</span>
<span class="nc bnc" id="L737" title="All 3 branches missed.">            switch(adj.getOrientation()) {</span>
            case Adjustable.VERTICAL:
<span class="nc" id="L739">                c.move(c.getLocation().x, -(value));</span>
<span class="nc" id="L740">                break;</span>
            case Adjustable.HORIZONTAL:
<span class="nc" id="L742">                c.move(-(value), c.getLocation().y);</span>
<span class="nc" id="L743">                break;</span>
            default:
<span class="nc" id="L745">                throw new IllegalArgumentException(&quot;Illegal adjustable orientation&quot;);</span>
            }
<span class="nc" id="L747">        }</span>

        private ScrollPane scroller;
    }


/////////////////
// Accessibility support
////////////////

    /**
     * Gets the AccessibleContext associated with this ScrollPane.
     * For scroll panes, the AccessibleContext takes the form of an
     * AccessibleAWTScrollPane.
     * A new AccessibleAWTScrollPane instance is created if necessary.
     *
     * @return an AccessibleAWTScrollPane that serves as the
     *         AccessibleContext of this ScrollPane
     * @since 1.3
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L768" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L769">            accessibleContext = new AccessibleAWTScrollPane();</span>
        }
<span class="nc" id="L771">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;ScrollPane&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to scroll pane user-interface
     * elements.
     * @since 1.3
     */
<span class="nc" id="L781">    protected class AccessibleAWTScrollPane extends AccessibleAWTContainer</span>
    {
        /*
         * JDK 1.3 serialVersionUID
         */
        private static final long serialVersionUID = 6100703663886637L;

        /**
         * Get the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of the
         * object
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L796">            return AccessibleRole.SCROLL_PANE;</span>
        }

    } // class AccessibleAWTScrollPane

}

/*
 * In JDK 1.1.1, the pkg private class java.awt.PeerFixer was moved to
 * become an inner class of ScrollPane, which broke serialization
 * for ScrollPane objects using JDK 1.1.
 * Instead of moving it back out here, which would break all JDK 1.1.x
 * releases, we keep PeerFixer in both places. Because of the scoping rules,
 * the PeerFixer that is used in ScrollPane will be the one that is the
 * inner class. This pkg private PeerFixer class below will only be used
 * if the Java 2 platform is used to deserialize ScrollPane objects that were serialized
 * using JDK1.1
 */
class PeerFixer implements AdjustmentListener, java.io.Serializable {
    /*
     * serialVersionUID
     */
    private static final long serialVersionUID = 7051237413532574756L;

<span class="nc" id="L820">    PeerFixer(ScrollPane scroller) {</span>
<span class="nc" id="L821">        this.scroller = scroller;</span>
<span class="nc" id="L822">    }</span>

    /**
     * Invoked when the value of the adjustable has changed.
     */
    public void adjustmentValueChanged(AdjustmentEvent e) {
<span class="nc" id="L828">        Adjustable adj = e.getAdjustable();</span>
<span class="nc" id="L829">        int value = e.getValue();</span>
<span class="nc" id="L830">        ScrollPanePeer peer = (ScrollPanePeer) scroller.peer;</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L832">            peer.setValue(adj, value);</span>
        }

<span class="nc" id="L835">        Component c = scroller.getComponent(0);</span>
<span class="nc bnc" id="L836" title="All 3 branches missed.">        switch(adj.getOrientation()) {</span>
        case Adjustable.VERTICAL:
<span class="nc" id="L838">            c.move(c.getLocation().x, -(value));</span>
<span class="nc" id="L839">            break;</span>
        case Adjustable.HORIZONTAL:
<span class="nc" id="L841">            c.move(-(value), c.getLocation().y);</span>
<span class="nc" id="L842">            break;</span>
        default:
<span class="nc" id="L844">            throw new IllegalArgumentException(&quot;Illegal adjustable orientation&quot;);</span>
        }
<span class="nc" id="L846">    }</span>

    private ScrollPane scroller;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>