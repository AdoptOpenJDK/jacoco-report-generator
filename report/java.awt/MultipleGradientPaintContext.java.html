<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MultipleGradientPaintContext.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">MultipleGradientPaintContext.java</span></div><h1>MultipleGradientPaintContext.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2006, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt;

import java.awt.MultipleGradientPaint.CycleMethod;
import java.awt.MultipleGradientPaint.ColorSpaceType;
import java.awt.color.ColorSpace;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Rectangle2D;
import java.awt.image.ColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferInt;
import java.awt.image.DirectColorModel;
import java.awt.image.Raster;
import java.awt.image.SinglePixelPackedSampleModel;
import java.awt.image.WritableRaster;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.Arrays;

/**
 * This is the superclass for all PaintContexts which use a multiple color
 * gradient to fill in their raster.  It provides the actual color
 * interpolation functionality.  Subclasses only have to deal with using
 * the gradient to fill pixels in a raster.
 *
 * @author Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans
 */
abstract class MultipleGradientPaintContext implements PaintContext {

    /**
     * The PaintContext's ColorModel.  This is ARGB if colors are not all
     * opaque, otherwise it is RGB.
     */
    protected ColorModel model;

    /** Color model used if gradient colors are all opaque. */
<span class="nc" id="L62">    private static ColorModel xrgbmodel =</span>
        new DirectColorModel(24, 0x00ff0000, 0x0000ff00, 0x000000ff);

    /** The cached ColorModel. */
    protected static ColorModel cachedModel;

    /** The cached raster, which is reusable among instances. */
    protected static WeakReference&lt;Raster&gt; cached;

    /** Raster is reused whenever possible. */
    protected Raster saved;

    /** The method to use when painting out of the gradient bounds. */
    protected CycleMethod cycleMethod;

    /** The ColorSpace in which to perform the interpolation */
    protected ColorSpaceType colorSpace;

    /** Elements of the inverse transform matrix. */
    protected float a00, a01, a10, a11, a02, a12;

    /**
     * This boolean specifies whether we are in simple lookup mode, where an
     * input value between 0 and 1 may be used to directly index into a single
     * array of gradient colors.  If this boolean value is false, then we have
     * to use a 2-step process where we have to determine which gradient array
     * we fall into, then determine the index into that array.
     */
    protected boolean isSimpleLookup;

    /**
     * Size of gradients array for scaling the 0-1 index when looking up
     * colors the fast way.
     */
    protected int fastGradientArraySize;

    /**
     * Array which contains the interpolated color values for each interval,
     * used by calculateSingleArrayGradient().  It is protected for possible
     * direct access by subclasses.
     */
    protected int[] gradient;

    /**
     * Array of gradient arrays, one array for each interval.  Used by
     * calculateMultipleArrayGradient().
     */
    private int[][] gradients;

    /** Normalized intervals array. */
    private float[] normalizedIntervals;

    /** Fractions array. */
    private float[] fractions;

    /** Used to determine if gradient colors are all opaque. */
    private int transparencyTest;

    /** Color space conversion lookup tables. */
<span class="nc" id="L121">    private static final int SRGBtoLinearRGB[] = new int[256];</span>
<span class="nc" id="L122">    private static final int LinearRGBtoSRGB[] = new int[256];</span>

    static {
        // build the tables
<span class="nc bnc" id="L126" title="All 2 branches missed.">        for (int k = 0; k &lt; 256; k++) {</span>
<span class="nc" id="L127">            SRGBtoLinearRGB[k] = convertSRGBtoLinearRGB(k);</span>
<span class="nc" id="L128">            LinearRGBtoSRGB[k] = convertLinearRGBtoSRGB(k);</span>
        }
<span class="nc" id="L130">    }</span>

    /**
     * Constant number of max colors between any 2 arbitrary colors.
     * Used for creating and indexing gradients arrays.
     */
    protected static final int GRADIENT_SIZE = 256;
    protected static final int GRADIENT_SIZE_INDEX = GRADIENT_SIZE -1;

    /**
     * Maximum length of the fast single-array.  If the estimated array size
     * is greater than this, switch over to the slow lookup method.
     * No particular reason for choosing this number, but it seems to provide
     * satisfactory performance for the common case (fast lookup).
     */
    private static final int MAX_GRADIENT_ARRAY_SIZE = 5000;

    /**
     * Constructor for MultipleGradientPaintContext superclass.
     */
    protected MultipleGradientPaintContext(MultipleGradientPaint mgp,
                                           ColorModel cm,
                                           Rectangle deviceBounds,
                                           Rectangle2D userBounds,
                                           AffineTransform t,
                                           RenderingHints hints,
                                           float[] fractions,
                                           Color[] colors,
                                           CycleMethod cycleMethod,
                                           ColorSpaceType colorSpace)
<span class="nc" id="L160">    {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (deviceBounds == null) {</span>
<span class="nc" id="L162">            throw new NullPointerException(&quot;Device bounds cannot be null&quot;);</span>
        }

<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (userBounds == null) {</span>
<span class="nc" id="L166">            throw new NullPointerException(&quot;User bounds cannot be null&quot;);</span>
        }

<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (t == null) {</span>
<span class="nc" id="L170">            throw new NullPointerException(&quot;Transform cannot be null&quot;);</span>
        }

<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (hints == null) {</span>
<span class="nc" id="L174">            throw new NullPointerException(&quot;RenderingHints cannot be null&quot;);</span>
        }

        // The inverse transform is needed to go from device to user space.
        // Get all the components of the inverse transform matrix.
        AffineTransform tInv;
        try {
            // the following assumes that the caller has copied the incoming
            // transform and is not concerned about it being modified
<span class="nc" id="L183">            t.invert();</span>
<span class="nc" id="L184">            tInv = t;</span>
<span class="nc" id="L185">        } catch (NoninvertibleTransformException e) {</span>
            // just use identity transform in this case; better to show
            // (incorrect) results than to throw an exception and/or no-op
<span class="nc" id="L188">            tInv = new AffineTransform();</span>
<span class="nc" id="L189">        }</span>
<span class="nc" id="L190">        double m[] = new double[6];</span>
<span class="nc" id="L191">        tInv.getMatrix(m);</span>
<span class="nc" id="L192">        a00 = (float)m[0];</span>
<span class="nc" id="L193">        a10 = (float)m[1];</span>
<span class="nc" id="L194">        a01 = (float)m[2];</span>
<span class="nc" id="L195">        a11 = (float)m[3];</span>
<span class="nc" id="L196">        a02 = (float)m[4];</span>
<span class="nc" id="L197">        a12 = (float)m[5];</span>

        // copy some flags
<span class="nc" id="L200">        this.cycleMethod = cycleMethod;</span>
<span class="nc" id="L201">        this.colorSpace = colorSpace;</span>

        // we can avoid copying this array since we do not modify its values
<span class="nc" id="L204">        this.fractions = fractions;</span>

        // note that only one of these values can ever be non-null (we either
        // store the fast gradient array or the slow one, but never both
        // at the same time)
<span class="nc bnc" id="L209" title="All 2 branches missed.">        int[] gradient =</span>
<span class="nc" id="L210">            (mgp.gradient != null) ? mgp.gradient.get() : null;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        int[][] gradients =</span>
<span class="nc" id="L212">            (mgp.gradients != null) ? mgp.gradients.get() : null;</span>

<span class="nc bnc" id="L214" title="All 4 branches missed.">        if (gradient == null &amp;&amp; gradients == null) {</span>
            // we need to (re)create the appropriate values
<span class="nc" id="L216">            calculateLookupData(colors);</span>

            // now cache the calculated values in the
            // MultipleGradientPaint instance for future use
<span class="nc" id="L220">            mgp.model               = this.model;</span>
<span class="nc" id="L221">            mgp.normalizedIntervals = this.normalizedIntervals;</span>
<span class="nc" id="L222">            mgp.isSimpleLookup      = this.isSimpleLookup;</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            if (isSimpleLookup) {</span>
                // only cache the fast array
<span class="nc" id="L225">                mgp.fastGradientArraySize = this.fastGradientArraySize;</span>
<span class="nc" id="L226">                mgp.gradient = new SoftReference&lt;int[]&gt;(this.gradient);</span>
            } else {
                // only cache the slow array
<span class="nc" id="L229">                mgp.gradients = new SoftReference&lt;int[][]&gt;(this.gradients);</span>
            }
        } else {
            // use the values cached in the MultipleGradientPaint instance
<span class="nc" id="L233">            this.model                 = mgp.model;</span>
<span class="nc" id="L234">            this.normalizedIntervals   = mgp.normalizedIntervals;</span>
<span class="nc" id="L235">            this.isSimpleLookup        = mgp.isSimpleLookup;</span>
<span class="nc" id="L236">            this.gradient              = gradient;</span>
<span class="nc" id="L237">            this.fastGradientArraySize = mgp.fastGradientArraySize;</span>
<span class="nc" id="L238">            this.gradients             = gradients;</span>
        }
<span class="nc" id="L240">    }</span>

    /**
     * This function is the meat of this class.  It calculates an array of
     * gradient colors based on an array of fractions and color values at
     * those fractions.
     */
    private void calculateLookupData(Color[] colors) {
        Color[] normalizedColors;
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (colorSpace == ColorSpaceType.LINEAR_RGB) {</span>
            // create a new colors array
<span class="nc" id="L251">            normalizedColors = new Color[colors.length];</span>
            // convert the colors using the lookup table
<span class="nc bnc" id="L253" title="All 2 branches missed.">            for (int i = 0; i &lt; colors.length; i++) {</span>
<span class="nc" id="L254">                int argb = colors[i].getRGB();</span>
<span class="nc" id="L255">                int a = argb &gt;&gt;&gt; 24;</span>
<span class="nc" id="L256">                int r = SRGBtoLinearRGB[(argb &gt;&gt; 16) &amp; 0xff];</span>
<span class="nc" id="L257">                int g = SRGBtoLinearRGB[(argb &gt;&gt;  8) &amp; 0xff];</span>
<span class="nc" id="L258">                int b = SRGBtoLinearRGB[(argb      ) &amp; 0xff];</span>
<span class="nc" id="L259">                normalizedColors[i] = new Color(r, g, b, a);</span>
            }
        } else {
            // we can just use this array by reference since we do not
            // modify its values in the case of SRGB
<span class="nc" id="L264">            normalizedColors = colors;</span>
        }

        // this will store the intervals (distances) between gradient stops
<span class="nc" id="L268">        normalizedIntervals = new float[fractions.length-1];</span>

        // convert from fractions into intervals
<span class="nc bnc" id="L271" title="All 2 branches missed.">        for (int i = 0; i &lt; normalizedIntervals.length; i++) {</span>
            // interval distance is equal to the difference in positions
<span class="nc" id="L273">            normalizedIntervals[i] = this.fractions[i+1] - this.fractions[i];</span>
        }

        // initialize to be fully opaque for ANDing with colors
<span class="nc" id="L277">        transparencyTest = 0xff000000;</span>

        // array of interpolation arrays
<span class="nc" id="L280">        gradients = new int[normalizedIntervals.length][];</span>

        // find smallest interval
<span class="nc" id="L283">        float Imin = 1;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        for (int i = 0; i &lt; normalizedIntervals.length; i++) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">            Imin = (Imin &gt; normalizedIntervals[i]) ?</span>
                normalizedIntervals[i] : Imin;
        }

        // Estimate the size of the entire gradients array.
        // This is to prevent a tiny interval from causing the size of array
        // to explode.  If the estimated size is too large, break to using
        // separate arrays for each interval, and using an indexing scheme at
        // look-up time.
<span class="nc" id="L294">        int estimatedSize = 0;</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        for (int i = 0; i &lt; normalizedIntervals.length; i++) {</span>
<span class="nc" id="L296">            estimatedSize += (normalizedIntervals[i]/Imin) * GRADIENT_SIZE;</span>
        }

<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (estimatedSize &gt; MAX_GRADIENT_ARRAY_SIZE) {</span>
            // slow method
<span class="nc" id="L301">            calculateMultipleArrayGradient(normalizedColors);</span>
        } else {
            // fast method
<span class="nc" id="L304">            calculateSingleArrayGradient(normalizedColors, Imin);</span>
        }

        // use the most &quot;economical&quot; model
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if ((transparencyTest &gt;&gt;&gt; 24) == 0xff) {</span>
<span class="nc" id="L309">            model = xrgbmodel;</span>
        } else {
<span class="nc" id="L311">            model = ColorModel.getRGBdefault();</span>
        }
<span class="nc" id="L313">    }</span>

    /**
     * FAST LOOKUP METHOD
     *
     * This method calculates the gradient color values and places them in a
     * single int array, gradient[].  It does this by allocating space for
     * each interval based on its size relative to the smallest interval in
     * the array.  The smallest interval is allocated 255 interpolated values
     * (the maximum number of unique in-between colors in a 24 bit color
     * system), and all other intervals are allocated
     * size = (255 * the ratio of their size to the smallest interval).
     *
     * This scheme expedites a speedy retrieval because the colors are
     * distributed along the array according to their user-specified
     * distribution.  All that is needed is a relative index from 0 to 1.
     *
     * The only problem with this method is that the possibility exists for
     * the array size to balloon in the case where there is a
     * disproportionately small gradient interval.  In this case the other
     * intervals will be allocated huge space, but much of that data is
     * redundant.  We thus need to use the space conserving scheme below.
     *
     * @param Imin the size of the smallest interval
     */
    private void calculateSingleArrayGradient(Color[] colors, float Imin) {
        // set the flag so we know later it is a simple (fast) lookup
<span class="nc" id="L340">        isSimpleLookup = true;</span>

        // 2 colors to interpolate
        int rgb1, rgb2;

        //the eventual size of the single array
<span class="nc" id="L346">        int gradientsTot = 1;</span>

        // for every interval (transition between 2 colors)
<span class="nc bnc" id="L349" title="All 2 branches missed.">        for (int i = 0; i &lt; gradients.length; i++) {</span>
            // create an array whose size is based on the ratio to the
            // smallest interval
<span class="nc" id="L352">            int nGradients = (int)((normalizedIntervals[i]/Imin)*255f);</span>
<span class="nc" id="L353">            gradientsTot += nGradients;</span>
<span class="nc" id="L354">            gradients[i] = new int[nGradients];</span>

            // the 2 colors (keyframes) to interpolate between
<span class="nc" id="L357">            rgb1 = colors[i].getRGB();</span>
<span class="nc" id="L358">            rgb2 = colors[i+1].getRGB();</span>

            // fill this array with the colors in between rgb1 and rgb2
<span class="nc" id="L361">            interpolate(rgb1, rgb2, gradients[i]);</span>

            // if the colors are opaque, transparency should still
            // be 0xff000000
<span class="nc" id="L365">            transparencyTest &amp;= rgb1;</span>
<span class="nc" id="L366">            transparencyTest &amp;= rgb2;</span>
        }

        // put all gradients in a single array
<span class="nc" id="L370">        gradient = new int[gradientsTot];</span>
<span class="nc" id="L371">        int curOffset = 0;</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">        for (int i = 0; i &lt; gradients.length; i++){</span>
<span class="nc" id="L373">            System.arraycopy(gradients[i], 0, gradient,</span>
                             curOffset, gradients[i].length);
<span class="nc" id="L375">            curOffset += gradients[i].length;</span>
        }
<span class="nc" id="L377">        gradient[gradient.length-1] = colors[colors.length-1].getRGB();</span>

        // if interpolation occurred in Linear RGB space, convert the
        // gradients back to sRGB using the lookup table
<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (colorSpace == ColorSpaceType.LINEAR_RGB) {</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            for (int i = 0; i &lt; gradient.length; i++) {</span>
<span class="nc" id="L383">                gradient[i] = convertEntireColorLinearRGBtoSRGB(gradient[i]);</span>
            }
        }

<span class="nc" id="L387">        fastGradientArraySize = gradient.length - 1;</span>
<span class="nc" id="L388">    }</span>

    /**
     * SLOW LOOKUP METHOD
     *
     * This method calculates the gradient color values for each interval and
     * places each into its own 255 size array.  The arrays are stored in
     * gradients[][].  (255 is used because this is the maximum number of
     * unique colors between 2 arbitrary colors in a 24 bit color system.)
     *
     * This method uses the minimum amount of space (only 255 * number of
     * intervals), but it aggravates the lookup procedure, because now we
     * have to find out which interval to select, then calculate the index
     * within that interval.  This causes a significant performance hit,
     * because it requires this calculation be done for every point in
     * the rendering loop.
     *
     * For those of you who are interested, this is a classic example of the
     * time-space tradeoff.
     */
    private void calculateMultipleArrayGradient(Color[] colors) {
        // set the flag so we know later it is a non-simple lookup
<span class="nc" id="L410">        isSimpleLookup = false;</span>

        // 2 colors to interpolate
        int rgb1, rgb2;

        // for every interval (transition between 2 colors)
<span class="nc bnc" id="L416" title="All 2 branches missed.">        for (int i = 0; i &lt; gradients.length; i++){</span>
            // create an array of the maximum theoretical size for
            // each interval
<span class="nc" id="L419">            gradients[i] = new int[GRADIENT_SIZE];</span>

            // get the the 2 colors
<span class="nc" id="L422">            rgb1 = colors[i].getRGB();</span>
<span class="nc" id="L423">            rgb2 = colors[i+1].getRGB();</span>

            // fill this array with the colors in between rgb1 and rgb2
<span class="nc" id="L426">            interpolate(rgb1, rgb2, gradients[i]);</span>

            // if the colors are opaque, transparency should still
            // be 0xff000000
<span class="nc" id="L430">            transparencyTest &amp;= rgb1;</span>
<span class="nc" id="L431">            transparencyTest &amp;= rgb2;</span>
        }

        // if interpolation occurred in Linear RGB space, convert the
        // gradients back to SRGB using the lookup table
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (colorSpace == ColorSpaceType.LINEAR_RGB) {</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            for (int j = 0; j &lt; gradients.length; j++) {</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">                for (int i = 0; i &lt; gradients[j].length; i++) {</span>
<span class="nc" id="L439">                    gradients[j][i] =</span>
<span class="nc" id="L440">                        convertEntireColorLinearRGBtoSRGB(gradients[j][i]);</span>
                }
            }
        }
<span class="nc" id="L444">    }</span>

    /**
     * Yet another helper function.  This one linearly interpolates between
     * 2 colors, filling up the output array.
     *
     * @param rgb1 the start color
     * @param rgb2 the end color
     * @param output the output array of colors; must not be null
     */
    private void interpolate(int rgb1, int rgb2, int[] output) {
        // color components
        int a1, r1, g1, b1, da, dr, dg, db;

        // step between interpolated values
<span class="nc" id="L459">        float stepSize = 1.0f / output.length;</span>

        // extract color components from packed integer
<span class="nc" id="L462">        a1 = (rgb1 &gt;&gt; 24) &amp; 0xff;</span>
<span class="nc" id="L463">        r1 = (rgb1 &gt;&gt; 16) &amp; 0xff;</span>
<span class="nc" id="L464">        g1 = (rgb1 &gt;&gt;  8) &amp; 0xff;</span>
<span class="nc" id="L465">        b1 = (rgb1      ) &amp; 0xff;</span>

        // calculate the total change in alpha, red, green, blue
<span class="nc" id="L468">        da = ((rgb2 &gt;&gt; 24) &amp; 0xff) - a1;</span>
<span class="nc" id="L469">        dr = ((rgb2 &gt;&gt; 16) &amp; 0xff) - r1;</span>
<span class="nc" id="L470">        dg = ((rgb2 &gt;&gt;  8) &amp; 0xff) - g1;</span>
<span class="nc" id="L471">        db = ((rgb2      ) &amp; 0xff) - b1;</span>

        // for each step in the interval calculate the in-between color by
        // multiplying the normalized current position by the total color
        // change (0.5 is added to prevent truncation round-off error)
<span class="nc bnc" id="L476" title="All 2 branches missed.">        for (int i = 0; i &lt; output.length; i++) {</span>
<span class="nc" id="L477">            output[i] =</span>
                (((int) ((a1 + i * da * stepSize) + 0.5) &lt;&lt; 24)) |
                (((int) ((r1 + i * dr * stepSize) + 0.5) &lt;&lt; 16)) |
                (((int) ((g1 + i * dg * stepSize) + 0.5) &lt;&lt;  8)) |
                (((int) ((b1 + i * db * stepSize) + 0.5)      ));
        }
<span class="nc" id="L483">    }</span>

    /**
     * Yet another helper function.  This one extracts the color components
     * of an integer RGB triple, converts them from LinearRGB to SRGB, then
     * recompacts them into an int.
     */
    private int convertEntireColorLinearRGBtoSRGB(int rgb) {
        // color components
        int a1, r1, g1, b1;

        // extract red, green, blue components
<span class="nc" id="L495">        a1 = (rgb &gt;&gt; 24) &amp; 0xff;</span>
<span class="nc" id="L496">        r1 = (rgb &gt;&gt; 16) &amp; 0xff;</span>
<span class="nc" id="L497">        g1 = (rgb &gt;&gt;  8) &amp; 0xff;</span>
<span class="nc" id="L498">        b1 = (rgb      ) &amp; 0xff;</span>

        // use the lookup table
<span class="nc" id="L501">        r1 = LinearRGBtoSRGB[r1];</span>
<span class="nc" id="L502">        g1 = LinearRGBtoSRGB[g1];</span>
<span class="nc" id="L503">        b1 = LinearRGBtoSRGB[b1];</span>

        // re-compact the components
<span class="nc" id="L506">        return ((a1 &lt;&lt; 24) |</span>
                (r1 &lt;&lt; 16) |
                (g1 &lt;&lt;  8) |
                (b1      ));
    }

    /**
     * Helper function to index into the gradients array.  This is necessary
     * because each interval has an array of colors with uniform size 255.
     * However, the color intervals are not necessarily of uniform length, so
     * a conversion is required.
     *
     * @param position the unmanipulated position, which will be mapped
     *                 into the range 0 to 1
     * @returns integer color to display
     */
    protected final int indexIntoGradientsArrays(float position) {
        // first, manipulate position value depending on the cycle method
<span class="nc bnc" id="L524" title="All 2 branches missed.">        if (cycleMethod == CycleMethod.NO_CYCLE) {</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (position &gt; 1) {</span>
                // upper bound is 1
<span class="nc" id="L527">                position = 1;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            } else if (position &lt; 0) {</span>
                // lower bound is 0
<span class="nc" id="L530">                position = 0;</span>
            }
<span class="nc bnc" id="L532" title="All 2 branches missed.">        } else if (cycleMethod == CycleMethod.REPEAT) {</span>
            // get the fractional part
            // (modulo behavior discards integer component)
<span class="nc" id="L535">            position = position - (int)position;</span>

            //position should now be between -1 and 1
<span class="nc bnc" id="L538" title="All 2 branches missed.">            if (position &lt; 0) {</span>
                // force it to be in the range 0-1
<span class="nc" id="L540">                position = position + 1;</span>
            }
        } else { // cycleMethod == CycleMethod.REFLECT
<span class="nc bnc" id="L543" title="All 2 branches missed.">            if (position &lt; 0) {</span>
                // take absolute value
<span class="nc" id="L545">                position = -position;</span>
            }

            // get the integer part
<span class="nc" id="L549">            int part = (int)position;</span>

            // get the fractional part
<span class="nc" id="L552">            position = position - part;</span>

<span class="nc bnc" id="L554" title="All 2 branches missed.">            if ((part &amp; 1) == 1) {</span>
                // integer part is odd, get reflected color instead
<span class="nc" id="L556">                position = 1 - position;</span>
            }
        }

        // now, get the color based on this 0-1 position...

<span class="nc bnc" id="L562" title="All 2 branches missed.">        if (isSimpleLookup) {</span>
            // easy to compute: just scale index by array size
<span class="nc" id="L564">            return gradient[(int)(position * fastGradientArraySize)];</span>
        } else {
            // more complicated computation, to save space

            // for all the gradient interval arrays
<span class="nc bnc" id="L569" title="All 2 branches missed.">            for (int i = 0; i &lt; gradients.length; i++) {</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">                if (position &lt; fractions[i+1]) {</span>
                    // this is the array we want
<span class="nc" id="L572">                    float delta = position - fractions[i];</span>

                    // this is the interval we want
<span class="nc" id="L575">                    int index = (int)((delta / normalizedIntervals[i])</span>
                                      * (GRADIENT_SIZE_INDEX));

<span class="nc" id="L578">                    return gradients[i][index];</span>
                }
            }
        }

<span class="nc" id="L583">        return gradients[gradients.length - 1][GRADIENT_SIZE_INDEX];</span>
    }

    /**
     * Helper function to convert a color component in sRGB space to linear
     * RGB space.  Used to build a static lookup table.
     */
    private static int convertSRGBtoLinearRGB(int color) {
        float input, output;

<span class="nc" id="L593">        input = color / 255.0f;</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (input &lt;= 0.04045f) {</span>
<span class="nc" id="L595">            output = input / 12.92f;</span>
        } else {
<span class="nc" id="L597">            output = (float)Math.pow((input + 0.055) / 1.055, 2.4);</span>
        }

<span class="nc" id="L600">        return Math.round(output * 255.0f);</span>
    }

    /**
     * Helper function to convert a color component in linear RGB space to
     * SRGB space.  Used to build a static lookup table.
     */
    private static int convertLinearRGBtoSRGB(int color) {
        float input, output;

<span class="nc" id="L610">        input = color/255.0f;</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">        if (input &lt;= 0.0031308) {</span>
<span class="nc" id="L612">            output = input * 12.92f;</span>
        } else {
<span class="nc" id="L614">            output = (1.055f *</span>
<span class="nc" id="L615">                ((float) Math.pow(input, (1.0 / 2.4)))) - 0.055f;</span>
        }

<span class="nc" id="L618">        return Math.round(output * 255.0f);</span>
    }

    /**
     * {@inheritDoc}
     */
    public final Raster getRaster(int x, int y, int w, int h) {
        // If working raster is big enough, reuse it. Otherwise,
        // build a large enough new one.
<span class="nc" id="L627">        Raster raster = saved;</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">        if (raster == null ||</span>
<span class="nc bnc" id="L629" title="All 4 branches missed.">            raster.getWidth() &lt; w || raster.getHeight() &lt; h)</span>
        {
<span class="nc" id="L631">            raster = getCachedRaster(model, w, h);</span>
<span class="nc" id="L632">            saved = raster;</span>
        }

        // Access raster internal int array. Because we use a DirectColorModel,
        // we know the DataBuffer is of type DataBufferInt and the SampleModel
        // is SinglePixelPackedSampleModel.
        // Adjust for initial offset in DataBuffer and also for the scanline
        // stride.
        // These calls make the DataBuffer non-acceleratable, but the
        // Raster is never Stable long enough to accelerate anyway...
<span class="nc" id="L642">        DataBufferInt rasterDB = (DataBufferInt)raster.getDataBuffer();</span>
<span class="nc" id="L643">        int[] pixels = rasterDB.getData(0);</span>
<span class="nc" id="L644">        int off = rasterDB.getOffset();</span>
<span class="nc" id="L645">        int scanlineStride = ((SinglePixelPackedSampleModel)</span>
<span class="nc" id="L646">                              raster.getSampleModel()).getScanlineStride();</span>
<span class="nc" id="L647">        int adjust = scanlineStride - w;</span>

<span class="nc" id="L649">        fillRaster(pixels, off, adjust, x, y, w, h); // delegate to subclass</span>

<span class="nc" id="L651">        return raster;</span>
    }

    protected abstract void fillRaster(int pixels[], int off, int adjust,
                                       int x, int y, int w, int h);


    /**
     * Took this cacheRaster code from GradientPaint. It appears to recycle
     * rasters for use by any other instance, as long as they are sufficiently
     * large.
     */
    private static synchronized Raster getCachedRaster(ColorModel cm,
                                                       int w, int h)
    {
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (cm == cachedModel) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">            if (cached != null) {</span>
<span class="nc" id="L668">                Raster ras = (Raster) cached.get();</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">                if (ras != null &amp;&amp;</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">                    ras.getWidth() &gt;= w &amp;&amp;</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">                    ras.getHeight() &gt;= h)</span>
                {
<span class="nc" id="L673">                    cached = null;</span>
<span class="nc" id="L674">                    return ras;</span>
                }
            }
        }
<span class="nc" id="L678">        return cm.createCompatibleWritableRaster(w, h);</span>
    }

    /**
     * Took this cacheRaster code from GradientPaint. It appears to recycle
     * rasters for use by any other instance, as long as they are sufficiently
     * large.
     */
    private static synchronized void putCachedRaster(ColorModel cm,
                                                     Raster ras)
    {
<span class="nc bnc" id="L689" title="All 2 branches missed.">        if (cached != null) {</span>
<span class="nc" id="L690">            Raster cras = (Raster) cached.get();</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">            if (cras != null) {</span>
<span class="nc" id="L692">                int cw = cras.getWidth();</span>
<span class="nc" id="L693">                int ch = cras.getHeight();</span>
<span class="nc" id="L694">                int iw = ras.getWidth();</span>
<span class="nc" id="L695">                int ih = ras.getHeight();</span>
<span class="nc bnc" id="L696" title="All 4 branches missed.">                if (cw &gt;= iw &amp;&amp; ch &gt;= ih) {</span>
<span class="nc" id="L697">                    return;</span>
                }
<span class="nc bnc" id="L699" title="All 2 branches missed.">                if (cw * ch &gt;= iw * ih) {</span>
<span class="nc" id="L700">                    return;</span>
                }
            }
        }
<span class="nc" id="L704">        cachedModel = cm;</span>
<span class="nc" id="L705">        cached = new WeakReference&lt;Raster&gt;(ras);</span>
<span class="nc" id="L706">    }</span>

    /**
     * {@inheritDoc}
     */
    public final void dispose() {
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (saved != null) {</span>
<span class="nc" id="L713">            putCachedRaster(model, saved);</span>
<span class="nc" id="L714">            saved = null;</span>
        }
<span class="nc" id="L716">    }</span>

    /**
     * {@inheritDoc}
     */
    public final ColorModel getColorModel() {
<span class="nc" id="L722">        return model;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>