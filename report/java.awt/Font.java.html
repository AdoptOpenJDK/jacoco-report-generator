<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Font.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">Font.java</span></div><h1>Font.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt;

import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.awt.font.LineMetrics;
import java.awt.font.TextAttribute;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.peer.FontPeer;
import java.io.*;
import java.lang.ref.SoftReference;
import java.nio.file.Files;
import java.security.AccessController;
import java.security.PrivilegedExceptionAction;
import java.text.AttributedCharacterIterator.Attribute;
import java.text.CharacterIterator;
import java.text.StringCharacterIterator;
import java.util.Hashtable;
import java.util.Locale;
import java.util.Map;
import sun.font.StandardGlyphVector;

import sun.font.AttributeMap;
import sun.font.AttributeValues;
import sun.font.CompositeFont;
import sun.font.CreatedFontTracker;
import sun.font.Font2D;
import sun.font.Font2DHandle;
import sun.font.FontAccess;
import sun.font.FontManager;
import sun.font.FontManagerFactory;
import sun.font.FontUtilities;
import sun.font.GlyphLayout;
import sun.font.FontLineMetrics;
import sun.font.CoreMetrics;

import static sun.font.EAttribute.*;

/**
 * The &lt;code&gt;Font&lt;/code&gt; class represents fonts, which are used to
 * render text in a visible way.
 * A font provides the information needed to map sequences of
 * &lt;em&gt;characters&lt;/em&gt; to sequences of &lt;em&gt;glyphs&lt;/em&gt;
 * and to render sequences of glyphs on &lt;code&gt;Graphics&lt;/code&gt; and
 * &lt;code&gt;Component&lt;/code&gt; objects.
 *
 * &lt;h4&gt;Characters and Glyphs&lt;/h4&gt;
 *
 * A &lt;em&gt;character&lt;/em&gt; is a symbol that represents an item such as a letter,
 * a digit, or punctuation in an abstract way. For example, &lt;code&gt;'g'&lt;/code&gt;,
 * &lt;font size=-1&gt;LATIN SMALL LETTER G&lt;/font&gt;, is a character.
 * &lt;p&gt;
 * A &lt;em&gt;glyph&lt;/em&gt; is a shape used to render a character or a sequence of
 * characters. In simple writing systems, such as Latin, typically one glyph
 * represents one character. In general, however, characters and glyphs do not
 * have one-to-one correspondence. For example, the character '&amp;aacute;'
 * &lt;font size=-1&gt;LATIN SMALL LETTER A WITH ACUTE&lt;/font&gt;, can be represented by
 * two glyphs: one for 'a' and one for '&amp;acute;'. On the other hand, the
 * two-character string &quot;fi&quot; can be represented by a single glyph, an
 * &quot;fi&quot; ligature. In complex writing systems, such as Arabic or the South
 * and South-East Asian writing systems, the relationship between characters
 * and glyphs can be more complicated and involve context-dependent selection
 * of glyphs as well as glyph reordering.
 *
 * A font encapsulates the collection of glyphs needed to render a selected set
 * of characters as well as the tables needed to map sequences of characters to
 * corresponding sequences of glyphs.
 *
 * &lt;h4&gt;Physical and Logical Fonts&lt;/h4&gt;
 *
 * The Java Platform distinguishes between two kinds of fonts:
 * &lt;em&gt;physical&lt;/em&gt; fonts and &lt;em&gt;logical&lt;/em&gt; fonts.
 * &lt;p&gt;
 * &lt;em&gt;Physical&lt;/em&gt; fonts are the actual font libraries containing glyph data
 * and tables to map from character sequences to glyph sequences, using a font
 * technology such as TrueType or PostScript Type 1.
 * All implementations of the Java Platform must support TrueType fonts;
 * support for other font technologies is implementation dependent.
 * Physical fonts may use names such as Helvetica, Palatino, HonMincho, or
 * any number of other font names.
 * Typically, each physical font supports only a limited set of writing
 * systems, for example, only Latin characters or only Japanese and Basic
 * Latin.
 * The set of available physical fonts varies between configurations.
 * Applications that require specific fonts can bundle them and instantiate
 * them using the {@link #createFont createFont} method.
 * &lt;p&gt;
 * &lt;em&gt;Logical&lt;/em&gt; fonts are the five font families defined by the Java
 * platform which must be supported by any Java runtime environment:
 * Serif, SansSerif, Monospaced, Dialog, and DialogInput.
 * These logical fonts are not actual font libraries. Instead, the logical
 * font names are mapped to physical fonts by the Java runtime environment.
 * The mapping is implementation and usually locale dependent, so the look
 * and the metrics provided by them vary.
 * Typically, each logical font name maps to several physical fonts in order to
 * cover a large range of characters.
 * &lt;p&gt;
 * Peered AWT components, such as {@link Label Label} and
 * {@link TextField TextField}, can only use logical fonts.
 * &lt;p&gt;
 * For a discussion of the relative advantages and disadvantages of using
 * physical or logical fonts, see the
 * &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/tech/faq-jsp-138165.html&quot;&gt;Internationalization FAQ&lt;/a&gt;
 * document.
 *
 * &lt;h4&gt;Font Faces and Names&lt;/h4&gt;
 *
 * A &lt;code&gt;Font&lt;/code&gt;
 * can have many faces, such as heavy, medium, oblique, gothic and
 * regular. All of these faces have similar typographic design.
 * &lt;p&gt;
 * There are three different names that you can get from a
 * &lt;code&gt;Font&lt;/code&gt; object.  The &lt;em&gt;logical font name&lt;/em&gt; is simply the
 * name that was used to construct the font.
 * The &lt;em&gt;font face name&lt;/em&gt;, or just &lt;em&gt;font name&lt;/em&gt; for
 * short, is the name of a particular font face, like Helvetica Bold. The
 * &lt;em&gt;family name&lt;/em&gt; is the name of the font family that determines the
 * typographic design across several faces, like Helvetica.
 * &lt;p&gt;
 * The &lt;code&gt;Font&lt;/code&gt; class represents an instance of a font face from
 * a collection of  font faces that are present in the system resources
 * of the host system.  As examples, Arial Bold and Courier Bold Italic
 * are font faces.  There can be several &lt;code&gt;Font&lt;/code&gt; objects
 * associated with a font face, each differing in size, style, transform
 * and font features.
 * &lt;p&gt;
 * The {@link GraphicsEnvironment#getAllFonts() getAllFonts} method
 * of the &lt;code&gt;GraphicsEnvironment&lt;/code&gt; class returns an
 * array of all font faces available in the system. These font faces are
 * returned as &lt;code&gt;Font&lt;/code&gt; objects with a size of 1, identity
 * transform and default font features. These
 * base fonts can then be used to derive new &lt;code&gt;Font&lt;/code&gt; objects
 * with varying sizes, styles, transforms and font features via the
 * &lt;code&gt;deriveFont&lt;/code&gt; methods in this class.
 *
 * &lt;h4&gt;Font and TextAttribute&lt;/h4&gt;
 *
 * &lt;p&gt;&lt;code&gt;Font&lt;/code&gt; supports most
 * &lt;code&gt;TextAttribute&lt;/code&gt;s.  This makes some operations, such as
 * rendering underlined text, convenient since it is not
 * necessary to explicitly construct a &lt;code&gt;TextLayout&lt;/code&gt; object.
 * Attributes can be set on a Font by constructing or deriving it
 * using a &lt;code&gt;Map&lt;/code&gt; of &lt;code&gt;TextAttribute&lt;/code&gt; values.
 *
 * &lt;p&gt;The values of some &lt;code&gt;TextAttributes&lt;/code&gt; are not
 * serializable, and therefore attempting to serialize an instance of
 * &lt;code&gt;Font&lt;/code&gt; that has such values will not serialize them.
 * This means a Font deserialized from such a stream will not compare
 * equal to the original Font that contained the non-serializable
 * attributes.  This should very rarely pose a problem
 * since these attributes are typically used only in special
 * circumstances and are unlikely to be serialized.
 *
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;FOREGROUND&lt;/code&gt; and &lt;code&gt;BACKGROUND&lt;/code&gt; use
 * &lt;code&gt;Paint&lt;/code&gt; values. The subclass &lt;code&gt;Color&lt;/code&gt; is
 * serializable, while &lt;code&gt;GradientPaint&lt;/code&gt; and
 * &lt;code&gt;TexturePaint&lt;/code&gt; are not.&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;CHAR_REPLACEMENT&lt;/code&gt; uses
 * &lt;code&gt;GraphicAttribute&lt;/code&gt; values.  The subclasses
 * &lt;code&gt;ShapeGraphicAttribute&lt;/code&gt; and
 * &lt;code&gt;ImageGraphicAttribute&lt;/code&gt; are not serializable.&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;INPUT_METHOD_HIGHLIGHT&lt;/code&gt; uses
 * &lt;code&gt;InputMethodHighlight&lt;/code&gt; values, which are
 * not serializable.  See {@link java.awt.im.InputMethodHighlight}.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Clients who create custom subclasses of &lt;code&gt;Paint&lt;/code&gt; and
 * &lt;code&gt;GraphicAttribute&lt;/code&gt; can make them serializable and
 * avoid this problem.  Clients who use input method highlights can
 * convert these to the platform-specific attributes for that
 * highlight on the current platform and set them on the Font as
 * a workaround.&lt;/p&gt;
 *
 * &lt;p&gt;The &lt;code&gt;Map&lt;/code&gt;-based constructor and
 * &lt;code&gt;deriveFont&lt;/code&gt; APIs ignore the FONT attribute, and it is
 * not retained by the Font; the static {@link #getFont} method should
 * be used if the FONT attribute might be present.  See {@link
 * java.awt.font.TextAttribute#FONT} for more information.&lt;/p&gt;
 *
 * &lt;p&gt;Several attributes will cause additional rendering overhead
 * and potentially invoke layout.  If a &lt;code&gt;Font&lt;/code&gt; has such
 * attributes, the &lt;code&gt;{@link #hasLayoutAttributes()}&lt;/code&gt; method
 * will return true.&lt;/p&gt;
 *
 * &lt;p&gt;Note: Font rotations can cause text baselines to be rotated.  In
 * order to account for this (rare) possibility, font APIs are
 * specified to return metrics and take parameters 'in
 * baseline-relative coordinates'.  This maps the 'x' coordinate to
 * the advance along the baseline, (positive x is forward along the
 * baseline), and the 'y' coordinate to a distance along the
 * perpendicular to the baseline at 'x' (positive y is 90 degrees
 * clockwise from the baseline vector).  APIs for which this is
 * especially important are called out as having 'baseline-relative
 * coordinates.'
 */
public class Font implements java.io.Serializable
{
<span class="fc" id="L226">    private static class FontAccessImpl extends FontAccess {</span>
        public Font2D getFont2D(Font font) {
<span class="nc" id="L228">            return font.getFont2D();</span>
        }

        public void setFont2D(Font font, Font2DHandle handle) {
<span class="nc" id="L232">            font.font2DHandle = handle;</span>
<span class="nc" id="L233">        }</span>

        public void setCreatedFont(Font font) {
<span class="nc" id="L236">            font.createdFont = true;</span>
<span class="nc" id="L237">        }</span>

        public boolean isCreatedFont(Font font) {
<span class="nc" id="L240">            return font.createdFont;</span>
        }
    }

    static {
        /* ensure that the necessary native libraries are loaded */
<span class="fc" id="L246">        Toolkit.loadLibraries();</span>
<span class="fc" id="L247">        initIDs();</span>
<span class="fc" id="L248">        FontAccess.setFontAccess(new FontAccessImpl());</span>
    }

    /**
     * This is now only used during serialization.  Typically
     * it is null.
     *
     * @serial
     * @see #getAttributes()
     */
    private Hashtable&lt;Object, Object&gt; fRequestedAttributes;

    /*
     * Constants to be used for logical font family names.
     */

    /**
     * A String constant for the canonical family name of the
     * logical font &quot;Dialog&quot;. It is useful in Font construction
     * to provide compile-time verification of the name.
     * @since 1.6
     */
    public static final String DIALOG = &quot;Dialog&quot;;

    /**
     * A String constant for the canonical family name of the
     * logical font &quot;DialogInput&quot;. It is useful in Font construction
     * to provide compile-time verification of the name.
     * @since 1.6
     */
    public static final String DIALOG_INPUT = &quot;DialogInput&quot;;

    /**
     * A String constant for the canonical family name of the
     * logical font &quot;SansSerif&quot;. It is useful in Font construction
     * to provide compile-time verification of the name.
     * @since 1.6
     */
    public static final String SANS_SERIF = &quot;SansSerif&quot;;

    /**
     * A String constant for the canonical family name of the
     * logical font &quot;Serif&quot;. It is useful in Font construction
     * to provide compile-time verification of the name.
     * @since 1.6
     */
    public static final String SERIF = &quot;Serif&quot;;

    /**
     * A String constant for the canonical family name of the
     * logical font &quot;Monospaced&quot;. It is useful in Font construction
     * to provide compile-time verification of the name.
     * @since 1.6
     */
    public static final String MONOSPACED = &quot;Monospaced&quot;;

    /*
     * Constants to be used for styles. Can be combined to mix
     * styles.
     */

    /**
     * The plain style constant.
     */
    public static final int PLAIN       = 0;

    /**
     * The bold style constant.  This can be combined with the other style
     * constants (except PLAIN) for mixed styles.
     */
    public static final int BOLD        = 1;

    /**
     * The italicized style constant.  This can be combined with the other
     * style constants (except PLAIN) for mixed styles.
     */
    public static final int ITALIC      = 2;

    /**
     * The baseline used in most Roman scripts when laying out text.
     */
    public static final int ROMAN_BASELINE = 0;

    /**
     * The baseline used in ideographic scripts like Chinese, Japanese,
     * and Korean when laying out text.
     */
    public static final int CENTER_BASELINE = 1;

    /**
     * The baseline used in Devanigiri and similar scripts when laying
     * out text.
     */
    public static final int HANGING_BASELINE = 2;

    /**
     * Identify a font resource of type TRUETYPE.
     * Used to specify a TrueType font resource to the
     * {@link #createFont} method.
     * The TrueType format was extended to become the OpenType
     * format, which adds support for fonts with Postscript outlines,
     * this tag therefore references these fonts, as well as those
     * with TrueType outlines.
     * @since 1.3
     */

    public static final int TRUETYPE_FONT = 0;

    /**
     * Identify a font resource of type TYPE1.
     * Used to specify a Type1 font resource to the
     * {@link #createFont} method.
     * @since 1.5
     */
    public static final int TYPE1_FONT = 1;

    /**
     * The logical name of this &lt;code&gt;Font&lt;/code&gt;, as passed to the
     * constructor.
     * @since JDK1.0
     *
     * @serial
     * @see #getName
     */
    protected String name;

    /**
     * The style of this &lt;code&gt;Font&lt;/code&gt;, as passed to the constructor.
     * This style can be PLAIN, BOLD, ITALIC, or BOLD+ITALIC.
     * @since JDK1.0
     *
     * @serial
     * @see #getStyle()
     */
    protected int style;

    /**
     * The point size of this &lt;code&gt;Font&lt;/code&gt;, rounded to integer.
     * @since JDK1.0
     *
     * @serial
     * @see #getSize()
     */
    protected int size;

    /**
     * The point size of this &lt;code&gt;Font&lt;/code&gt; in &lt;code&gt;float&lt;/code&gt;.
     *
     * @serial
     * @see #getSize()
     * @see #getSize2D()
     */
    protected float pointSize;

    /**
     * The platform specific font information.
     */
    private transient FontPeer peer;
    private transient long pData;       // native JDK1.1 font pointer
    private transient Font2DHandle font2DHandle;

    private transient AttributeValues values;
    private transient boolean hasLayoutAttributes;

    /*
     * If the origin of a Font is a created font then this attribute
     * must be set on all derived fonts too.
     */
<span class="pc" id="L416">    private transient boolean createdFont = false;</span>

    /*
     * This is true if the font transform is not identity.  It
     * is used to avoid unnecessary instantiation of an AffineTransform.
     */
    private transient boolean nonIdentityTx;

    /*
     * A cached value used when a transform is required for internal
     * use.  This must not be exposed to callers since AffineTransform
     * is mutable.
     */
<span class="fc" id="L429">    private static final AffineTransform identityTx = new AffineTransform();</span>

    /*
     * JDK 1.1 serialVersionUID
     */
    private static final long serialVersionUID = -4206021311591459213L;

    /**
     * Gets the peer of this &lt;code&gt;Font&lt;/code&gt;.
     * @return  the peer of the &lt;code&gt;Font&lt;/code&gt;.
     * @since JDK1.1
     * @deprecated Font rendering is now platform independent.
     */
    @Deprecated
    public FontPeer getPeer(){
<span class="nc" id="L444">        return getPeer_NoClientCode();</span>
    }
    // NOTE: This method is called by privileged threads.
    //       We implement this functionality in a package-private method
    //       to insure that it cannot be overridden by client subclasses.
    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
    @SuppressWarnings(&quot;deprecation&quot;)
    final FontPeer getPeer_NoClientCode() {
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if(peer == null) {</span>
<span class="nc" id="L453">            Toolkit tk = Toolkit.getDefaultToolkit();</span>
<span class="nc" id="L454">            this.peer = tk.getFontPeer(name, style);</span>
        }
<span class="nc" id="L456">        return peer;</span>
    }

    /**
     * Return the AttributeValues object associated with this
     * font.  Most of the time, the internal object is null.
     * If required, it will be created from the 'standard'
     * state on the font.  Only non-default values will be
     * set in the AttributeValues object.
     *
     * &lt;p&gt;Since the AttributeValues object is mutable, and it
     * is cached in the font, care must be taken to ensure that
     * it is not mutated.
     */
    private AttributeValues getAttributeValues() {
<span class="nc bnc" id="L471" title="All 2 branches missed.">        if (values == null) {</span>
<span class="nc" id="L472">            AttributeValues valuesTmp = new AttributeValues();</span>
<span class="nc" id="L473">            valuesTmp.setFamily(name);</span>
<span class="nc" id="L474">            valuesTmp.setSize(pointSize); // expects the float value.</span>

<span class="nc bnc" id="L476" title="All 2 branches missed.">            if ((style &amp; BOLD) != 0) {</span>
<span class="nc" id="L477">                valuesTmp.setWeight(2); // WEIGHT_BOLD</span>
            }

<span class="nc bnc" id="L480" title="All 2 branches missed.">            if ((style &amp; ITALIC) != 0) {</span>
<span class="nc" id="L481">                valuesTmp.setPosture(.2f); // POSTURE_OBLIQUE</span>
            }
<span class="nc" id="L483">            valuesTmp.defineAll(PRIMARY_MASK); // for streaming compatibility</span>
<span class="nc" id="L484">            values = valuesTmp;</span>
        }

<span class="nc" id="L487">        return values;</span>
    }

    private Font2D getFont2D() {
<span class="nc" id="L491">        FontManager fm = FontManagerFactory.getInstance();</span>
<span class="nc bnc" id="L492" title="All 6 branches missed.">        if (fm.usingPerAppContextComposites() &amp;&amp;</span>
            font2DHandle != null &amp;&amp;
            font2DHandle.font2D instanceof CompositeFont &amp;&amp;
<span class="nc bnc" id="L495" title="All 2 branches missed.">            ((CompositeFont)(font2DHandle.font2D)).isStdComposite()) {</span>
<span class="nc" id="L496">            return fm.findFont2D(name, style,</span>
                                          FontManager.LOGICAL_FALLBACK);
<span class="nc bnc" id="L498" title="All 2 branches missed.">        } else if (font2DHandle == null) {</span>
<span class="nc" id="L499">            font2DHandle =</span>
<span class="nc" id="L500">                fm.findFont2D(name, style,</span>
                              FontManager.LOGICAL_FALLBACK).handle;
        }
        /* Do not cache the de-referenced font2D. It must be explicitly
         * de-referenced to pick up a valid font in the event that the
         * original one is marked invalid
         */
<span class="nc" id="L507">        return font2DHandle.font2D;</span>
    }

    /**
     * Creates a new &lt;code&gt;Font&lt;/code&gt; from the specified name, style and
     * point size.
     * &lt;p&gt;
     * The font name can be a font face name or a font family name.
     * It is used together with the style to find an appropriate font face.
     * When a font family name is specified, the style argument is used to
     * select the most appropriate face from the family. When a font face
     * name is specified, the face's style and the style argument are
     * merged to locate the best matching font from the same family.
     * For example if face name &quot;Arial Bold&quot; is specified with style
     * &lt;code&gt;Font.ITALIC&lt;/code&gt;, the font system looks for a face in the
     * &quot;Arial&quot; family that is bold and italic, and may associate the font
     * instance with the physical font face &quot;Arial Bold Italic&quot;.
     * The style argument is merged with the specified face's style, not
     * added or subtracted.
     * This means, specifying a bold face and a bold style does not
     * double-embolden the font, and specifying a bold face and a plain
     * style does not lighten the font.
     * &lt;p&gt;
     * If no face for the requested style can be found, the font system
     * may apply algorithmic styling to achieve the desired style.
     * For example, if &lt;code&gt;ITALIC&lt;/code&gt; is requested, but no italic
     * face is available, glyphs from the plain face may be algorithmically
     * obliqued (slanted).
     * &lt;p&gt;
     * Font name lookup is case insensitive, using the case folding
     * rules of the US locale.
     * &lt;p&gt;
     * If the &lt;code&gt;name&lt;/code&gt; parameter represents something other than a
     * logical font, i.e. is interpreted as a physical font face or family, and
     * this cannot be mapped by the implementation to a physical font or a
     * compatible alternative, then the font system will map the Font
     * instance to &quot;Dialog&quot;, such that for example, the family as reported
     * by {@link #getFamily() getFamily} will be &quot;Dialog&quot;.
     * &lt;p&gt;
     *
     * @param name the font name.  This can be a font face name or a font
     * family name, and may represent either a logical font or a physical
     * font found in this {@code GraphicsEnvironment}.
     * The family names for logical fonts are: Dialog, DialogInput,
     * Monospaced, Serif, or SansSerif. Pre-defined String constants exist
     * for all of these names, for example, {@code DIALOG}. If {@code name} is
     * {@code null}, the &lt;em&gt;logical font name&lt;/em&gt; of the new
     * {@code Font} as returned by {@code getName()} is set to
     * the name &quot;Default&quot;.
     * @param style the style constant for the {@code Font}
     * The style argument is an integer bitmask that may
     * be {@code PLAIN}, or a bitwise union of {@code BOLD} and/or
     * {@code ITALIC} (for example, {@code ITALIC} or {@code BOLD|ITALIC}).
     * If the style argument does not conform to one of the expected
     * integer bitmasks then the style is set to {@code PLAIN}.
     * @param size the point size of the {@code Font}
     * @see GraphicsEnvironment#getAllFonts
     * @see GraphicsEnvironment#getAvailableFontFamilyNames
     * @since JDK1.0
     */
<span class="fc" id="L567">    public Font(String name, int style, int size) {</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">        this.name = (name != null) ? name : &quot;Default&quot;;</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">        this.style = (style &amp; ~0x03) == 0 ? style : 0;</span>
<span class="fc" id="L570">        this.size = size;</span>
<span class="fc" id="L571">        this.pointSize = size;</span>
<span class="fc" id="L572">    }</span>

<span class="nc" id="L574">    private Font(String name, int style, float sizePts) {</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">        this.name = (name != null) ? name : &quot;Default&quot;;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">        this.style = (style &amp; ~0x03) == 0 ? style : 0;</span>
<span class="nc" id="L577">        this.size = (int)(sizePts + 0.5);</span>
<span class="nc" id="L578">        this.pointSize = sizePts;</span>
<span class="nc" id="L579">    }</span>

    /* This constructor is used by deriveFont when attributes is null */
    private Font(String name, int style, float sizePts,
                 boolean created, Font2DHandle handle) {
<span class="nc" id="L584">        this(name, style, sizePts);</span>
<span class="nc" id="L585">        this.createdFont = created;</span>
        /* Fonts created from a stream will use the same font2D instance
         * as the parent.
         * One exception is that if the derived font is requested to be
         * in a different style, then also check if its a CompositeFont
         * and if so build a new CompositeFont from components of that style.
         * CompositeFonts can only be marked as &quot;created&quot; if they are used
         * to add fall backs to a physical font. And non-composites are
         * always from &quot;Font.createFont()&quot; and shouldn't get this treatment.
         */
<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (created) {</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">            if (handle.font2D instanceof CompositeFont &amp;&amp;</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">                handle.font2D.getStyle() != style) {</span>
<span class="nc" id="L598">                FontManager fm = FontManagerFactory.getInstance();</span>
<span class="nc" id="L599">                this.font2DHandle = fm.getNewComposite(null, style, handle);</span>
<span class="nc" id="L600">            } else {</span>
<span class="nc" id="L601">                this.font2DHandle = handle;</span>
            }
        }
<span class="nc" id="L604">    }</span>

    /* used to implement Font.createFont */
    private Font(File fontFile, int fontFormat,
                 boolean isCopy, CreatedFontTracker tracker)
<span class="nc" id="L609">        throws FontFormatException {</span>
<span class="nc" id="L610">        this.createdFont = true;</span>
        /* Font2D instances created by this method track their font file
         * so that when the Font2D is GC'd it can also remove the file.
         */
<span class="nc" id="L614">        FontManager fm = FontManagerFactory.getInstance();</span>
<span class="nc" id="L615">        this.font2DHandle = fm.createFont2D(fontFile, fontFormat, isCopy,</span>
                                            tracker).handle;
<span class="nc" id="L617">        this.name = this.font2DHandle.font2D.getFontName(Locale.getDefault());</span>
<span class="nc" id="L618">        this.style = Font.PLAIN;</span>
<span class="nc" id="L619">        this.size = 1;</span>
<span class="nc" id="L620">        this.pointSize = 1f;</span>
<span class="nc" id="L621">    }</span>

    /* This constructor is used when one font is derived from another.
     * Fonts created from a stream will use the same font2D instance as the
     * parent. They can be distinguished because the &quot;created&quot; argument
     * will be &quot;true&quot;. Since there is no way to recreate these fonts they
     * need to have the handle to the underlying font2D passed in.
     * &quot;created&quot; is also true when a special composite is referenced by the
     * handle for essentially the same reasons.
     * But when deriving a font in these cases two particular attributes
     * need special attention: family/face and style.
     * The &quot;composites&quot; in these cases need to be recreated with optimal
     * fonts for the new values of family and style.
     * For fonts created with createFont() these are treated differently.
     * JDK can often synthesise a different style (bold from plain
     * for example). For fonts created with &quot;createFont&quot; this is a reasonable
     * solution but its also possible (although rare) to derive a font with a
     * different family attribute. In this case JDK needs
     * to break the tie with the original Font2D and find a new Font.
     * The oldName and oldStyle are supplied so they can be compared with
     * what the Font2D and the values. To speed things along :
     * oldName == null will be interpreted as the name is unchanged.
     * oldStyle = -1 will be interpreted as the style is unchanged.
     * In these cases there is no need to interrogate &quot;values&quot;.
     */
    private Font(AttributeValues values, String oldName, int oldStyle,
<span class="nc" id="L647">                 boolean created, Font2DHandle handle) {</span>

<span class="nc" id="L649">        this.createdFont = created;</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">        if (created) {</span>
<span class="nc" id="L651">            this.font2DHandle = handle;</span>

<span class="nc" id="L653">            String newName = null;</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">            if (oldName != null) {</span>
<span class="nc" id="L655">                newName = values.getFamily();</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                if (oldName.equals(newName)) newName = null;</span>
            }
<span class="nc" id="L658">            int newStyle = 0;</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">            if (oldStyle == -1) {</span>
<span class="nc" id="L660">                newStyle = -1;</span>
            } else {
<span class="nc bnc" id="L662" title="All 2 branches missed.">                if (values.getWeight() &gt;= 2f)   newStyle  = BOLD;</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">                if (values.getPosture() &gt;= .2f) newStyle |= ITALIC;</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">                if (oldStyle == newStyle)       newStyle  = -1;</span>
            }
<span class="nc bnc" id="L666" title="All 2 branches missed.">            if (handle.font2D instanceof CompositeFont) {</span>
<span class="nc bnc" id="L667" title="All 4 branches missed.">                if (newStyle != -1 || newName != null) {</span>
<span class="nc" id="L668">                    FontManager fm = FontManagerFactory.getInstance();</span>
<span class="nc" id="L669">                    this.font2DHandle =</span>
<span class="nc" id="L670">                        fm.getNewComposite(newName, newStyle, handle);</span>
<span class="nc" id="L671">                }</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">            } else if (newName != null) {</span>
<span class="nc" id="L673">                this.createdFont = false;</span>
<span class="nc" id="L674">                this.font2DHandle = null;</span>
            }
        }
<span class="nc" id="L677">        initFromValues(values);</span>
<span class="nc" id="L678">    }</span>

    /**
     * Creates a new &lt;code&gt;Font&lt;/code&gt; with the specified attributes.
     * Only keys defined in {@link java.awt.font.TextAttribute TextAttribute}
     * are recognized.  In addition the FONT attribute is
     *  not recognized by this constructor
     * (see {@link #getAvailableAttributes}). Only attributes that have
     * values of valid types will affect the new &lt;code&gt;Font&lt;/code&gt;.
     * &lt;p&gt;
     * If &lt;code&gt;attributes&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a new
     * &lt;code&gt;Font&lt;/code&gt; is initialized with default values.
     * @see java.awt.font.TextAttribute
     * @param attributes the attributes to assign to the new
     *          &lt;code&gt;Font&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
     */
<span class="nc" id="L694">    public Font(Map&lt;? extends Attribute, ?&gt; attributes) {</span>
<span class="nc" id="L695">        initFromValues(AttributeValues.fromMap(attributes, RECOGNIZED_MASK));</span>
<span class="nc" id="L696">    }</span>

    /**
     * Creates a new &lt;code&gt;Font&lt;/code&gt; from the specified &lt;code&gt;font&lt;/code&gt;.
     * This constructor is intended for use by subclasses.
     * @param font from which to create this &lt;code&gt;Font&lt;/code&gt;.
     * @throws NullPointerException if &lt;code&gt;font&lt;/code&gt; is null
     * @since 1.6
     */
<span class="nc" id="L705">    protected Font(Font font) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">        if (font.values != null) {</span>
<span class="nc" id="L707">            initFromValues(font.getAttributeValues().clone());</span>
        } else {
<span class="nc" id="L709">            this.name = font.name;</span>
<span class="nc" id="L710">            this.style = font.style;</span>
<span class="nc" id="L711">            this.size = font.size;</span>
<span class="nc" id="L712">            this.pointSize = font.pointSize;</span>
        }
<span class="nc" id="L714">        this.font2DHandle = font.font2DHandle;</span>
<span class="nc" id="L715">        this.createdFont = font.createdFont;</span>
<span class="nc" id="L716">    }</span>

    /**
     * Font recognizes all attributes except FONT.
     */
<span class="fc" id="L721">    private static final int RECOGNIZED_MASK = AttributeValues.MASK_ALL</span>
<span class="fc" id="L722">        &amp; ~AttributeValues.getMask(EFONT);</span>

    /**
     * These attributes are considered primary by the FONT attribute.
     */
<span class="fc" id="L727">    private static final int PRIMARY_MASK =</span>
<span class="fc" id="L728">        AttributeValues.getMask(EFAMILY, EWEIGHT, EWIDTH, EPOSTURE, ESIZE,</span>
                                ETRANSFORM, ESUPERSCRIPT, ETRACKING);

    /**
     * These attributes are considered secondary by the FONT attribute.
     */
<span class="fc" id="L734">    private static final int SECONDARY_MASK =</span>
        RECOGNIZED_MASK &amp; ~PRIMARY_MASK;

    /**
     * These attributes are handled by layout.
     */
<span class="fc" id="L740">    private static final int LAYOUT_MASK =</span>
<span class="fc" id="L741">        AttributeValues.getMask(ECHAR_REPLACEMENT, EFOREGROUND, EBACKGROUND,</span>
                                EUNDERLINE, ESTRIKETHROUGH, ERUN_DIRECTION,
                                EBIDI_EMBEDDING, EJUSTIFICATION,
                                EINPUT_METHOD_HIGHLIGHT, EINPUT_METHOD_UNDERLINE,
                                ESWAP_COLORS, ENUMERIC_SHAPING, EKERNING,
                                ELIGATURES, ETRACKING, ESUPERSCRIPT);

<span class="fc" id="L748">    private static final int EXTRA_MASK =</span>
<span class="fc" id="L749">            AttributeValues.getMask(ETRANSFORM, ESUPERSCRIPT, EWIDTH);</span>

    /**
     * Initialize the standard Font fields from the values object.
     */
    private void initFromValues(AttributeValues values) {
<span class="nc" id="L755">        this.values = values;</span>
<span class="nc" id="L756">        values.defineAll(PRIMARY_MASK); // for 1.5 streaming compatibility</span>

<span class="nc" id="L758">        this.name = values.getFamily();</span>
<span class="nc" id="L759">        this.pointSize = values.getSize();</span>
<span class="nc" id="L760">        this.size = (int)(values.getSize() + 0.5);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">        if (values.getWeight() &gt;= 2f) this.style |= BOLD; // not == 2f</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">        if (values.getPosture() &gt;= .2f) this.style |= ITALIC; // not  == .2f</span>

<span class="nc" id="L764">        this.nonIdentityTx = values.anyNonDefault(EXTRA_MASK);</span>
<span class="nc" id="L765">        this.hasLayoutAttributes =  values.anyNonDefault(LAYOUT_MASK);</span>
<span class="nc" id="L766">    }</span>

    /**
     * Returns a &lt;code&gt;Font&lt;/code&gt; appropriate to the attributes.
     * If &lt;code&gt;attributes&lt;/code&gt;contains a &lt;code&gt;FONT&lt;/code&gt; attribute
     * with a valid &lt;code&gt;Font&lt;/code&gt; as its value, it will be
     * merged with any remaining attributes.  See
     * {@link java.awt.font.TextAttribute#FONT} for more
     * information.
     *
     * @param attributes the attributes to assign to the new
     *          &lt;code&gt;Font&lt;/code&gt;
     * @return a new &lt;code&gt;Font&lt;/code&gt; created with the specified
     *          attributes
     * @throws NullPointerException if &lt;code&gt;attributes&lt;/code&gt; is null.
     * @since 1.2
     * @see java.awt.font.TextAttribute
     */
    public static Font getFont(Map&lt;? extends Attribute, ?&gt; attributes) {
        // optimize for two cases:
        // 1) FONT attribute, and nothing else
        // 2) attributes, but no FONT

        // avoid turning the attributemap into a regular map for no reason
<span class="nc bnc" id="L790" title="All 2 branches missed.">        if (attributes instanceof AttributeMap &amp;&amp;</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">            ((AttributeMap)attributes).getValues() != null) {</span>
<span class="nc" id="L792">            AttributeValues values = ((AttributeMap)attributes).getValues();</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">            if (values.isNonDefault(EFONT)) {</span>
<span class="nc" id="L794">                Font font = values.getFont();</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">                if (!values.anyDefined(SECONDARY_MASK)) {</span>
<span class="nc" id="L796">                    return font;</span>
                }
                // merge
<span class="nc" id="L799">                values = font.getAttributeValues().clone();</span>
<span class="nc" id="L800">                values.merge(attributes, SECONDARY_MASK);</span>
<span class="nc" id="L801">                return new Font(values, font.name, font.style,</span>
                                font.createdFont, font.font2DHandle);
            }
<span class="nc" id="L804">            return new Font(attributes);</span>
        }

<span class="nc" id="L807">        Font font = (Font)attributes.get(TextAttribute.FONT);</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">        if (font != null) {</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">            if (attributes.size() &gt; 1) { // oh well, check for anything else</span>
<span class="nc" id="L810">                AttributeValues values = font.getAttributeValues().clone();</span>
<span class="nc" id="L811">                values.merge(attributes, SECONDARY_MASK);</span>
<span class="nc" id="L812">                return new Font(values, font.name, font.style,</span>
                                font.createdFont, font.font2DHandle);
            }

<span class="nc" id="L816">            return font;</span>
        }

<span class="nc" id="L819">        return new Font(attributes);</span>
    }

    /**
     * Used with the byte count tracker for fonts created from streams.
     * If a thread can create temp files anyway, no point in counting
     * font bytes.
     */
    private static boolean hasTempPermission() {

<span class="nc bnc" id="L829" title="All 2 branches missed.">        if (System.getSecurityManager() == null) {</span>
<span class="nc" id="L830">            return true;</span>
        }
<span class="nc" id="L832">        File f = null;</span>
<span class="nc" id="L833">        boolean hasPerm = false;</span>
        try {
<span class="nc" id="L835">            f = Files.createTempFile(&quot;+~JT&quot;, &quot;.tmp&quot;).toFile();</span>
<span class="nc" id="L836">            f.delete();</span>
<span class="nc" id="L837">            f = null;</span>
<span class="nc" id="L838">            hasPerm = true;</span>
<span class="nc" id="L839">        } catch (Throwable t) {</span>
            /* inc. any kind of SecurityException */
<span class="nc" id="L841">        }</span>
<span class="nc" id="L842">        return hasPerm;</span>
    }

    /**
     * Returns a new &lt;code&gt;Font&lt;/code&gt; using the specified font type
     * and input data.  The new &lt;code&gt;Font&lt;/code&gt; is
     * created with a point size of 1 and style {@link #PLAIN PLAIN}.
     * This base font can then be used with the &lt;code&gt;deriveFont&lt;/code&gt;
     * methods in this class to derive new &lt;code&gt;Font&lt;/code&gt; objects with
     * varying sizes, styles, transforms and font features.  This
     * method does not close the {@link InputStream}.
     * &lt;p&gt;
     * To make the &lt;code&gt;Font&lt;/code&gt; available to Font constructors the
     * returned &lt;code&gt;Font&lt;/code&gt; must be registered in the
     * &lt;code&gt;GraphicsEnviroment&lt;/code&gt; by calling
     * {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)}.
     * @param fontFormat the type of the &lt;code&gt;Font&lt;/code&gt;, which is
     * {@link #TRUETYPE_FONT TRUETYPE_FONT} if a TrueType resource is specified.
     * or {@link #TYPE1_FONT TYPE1_FONT} if a Type 1 resource is specified.
     * @param fontStream an &lt;code&gt;InputStream&lt;/code&gt; object representing the
     * input data for the font.
     * @return a new &lt;code&gt;Font&lt;/code&gt; created with the specified font type.
     * @throws IllegalArgumentException if &lt;code&gt;fontFormat&lt;/code&gt; is not
     *     &lt;code&gt;TRUETYPE_FONT&lt;/code&gt;or&lt;code&gt;TYPE1_FONT&lt;/code&gt;.
     * @throws FontFormatException if the &lt;code&gt;fontStream&lt;/code&gt; data does
     *     not contain the required font tables for the specified format.
     * @throws IOException if the &lt;code&gt;fontStream&lt;/code&gt;
     *     cannot be completely read.
     * @see GraphicsEnvironment#registerFont(Font)
     * @since 1.3
     */
    public static Font createFont(int fontFormat, InputStream fontStream)
        throws java.awt.FontFormatException, java.io.IOException {

<span class="nc bnc" id="L876" title="All 2 branches missed.">        if (hasTempPermission()) {</span>
<span class="nc" id="L877">            return createFont0(fontFormat, fontStream, null);</span>
        }

        // Otherwise, be extra conscious of pending temp file creation and
        // resourcefully handle the temp file resources, among other things.
<span class="nc" id="L882">        CreatedFontTracker tracker = CreatedFontTracker.getTracker();</span>
<span class="nc" id="L883">        boolean acquired = false;</span>
        try {
<span class="nc" id="L885">            acquired = tracker.acquirePermit();</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">            if (!acquired) {</span>
<span class="nc" id="L887">                throw new IOException(&quot;Timed out waiting for resources.&quot;);</span>
            }
<span class="nc" id="L889">            return createFont0(fontFormat, fontStream, tracker);</span>
<span class="nc" id="L890">        } catch (InterruptedException e) {</span>
<span class="nc" id="L891">            throw new IOException(&quot;Problem reading font data.&quot;);</span>
        } finally {
<span class="nc bnc" id="L893" title="All 4 branches missed.">            if (acquired) {</span>
<span class="nc" id="L894">                tracker.releasePermit();</span>
            }
        }
    }

    private static Font createFont0(int fontFormat, InputStream fontStream,
                                    CreatedFontTracker tracker)
        throws java.awt.FontFormatException, java.io.IOException {

<span class="nc bnc" id="L903" title="All 4 branches missed.">        if (fontFormat != Font.TRUETYPE_FONT &amp;&amp;</span>
            fontFormat != Font.TYPE1_FONT) {
<span class="nc" id="L905">            throw new IllegalArgumentException (&quot;font format not recognized&quot;);</span>
        }
<span class="nc" id="L907">        boolean copiedFontData = false;</span>
        try {
<span class="nc" id="L909">            final File tFile = AccessController.doPrivileged(</span>
<span class="nc" id="L910">                new PrivilegedExceptionAction&lt;File&gt;() {</span>
                    public File run() throws IOException {
<span class="nc" id="L912">                        return Files.createTempFile(&quot;+~JF&quot;, &quot;.tmp&quot;).toFile();</span>
                    }
                }
            );
<span class="nc bnc" id="L916" title="All 2 branches missed.">            if (tracker != null) {</span>
<span class="nc" id="L917">                tracker.add(tFile);</span>
            }

<span class="nc" id="L920">            int totalSize = 0;</span>
            try {
<span class="nc" id="L922">                final OutputStream outStream =</span>
<span class="nc" id="L923">                    AccessController.doPrivileged(</span>
<span class="nc" id="L924">                        new PrivilegedExceptionAction&lt;OutputStream&gt;() {</span>
                            public OutputStream run() throws IOException {
<span class="nc" id="L926">                                return new FileOutputStream(tFile);</span>
                            }
                        }
                    );
<span class="nc bnc" id="L930" title="All 2 branches missed.">                if (tracker != null) {</span>
<span class="nc" id="L931">                    tracker.set(tFile, outStream);</span>
                }
                try {
<span class="nc" id="L934">                    byte[] buf = new byte[8192];</span>
                    for (;;) {
<span class="nc" id="L936">                        int bytesRead = fontStream.read(buf);</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">                        if (bytesRead &lt; 0) {</span>
<span class="nc" id="L938">                            break;</span>
                        }
<span class="nc bnc" id="L940" title="All 2 branches missed.">                        if (tracker != null) {</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">                            if (totalSize+bytesRead &gt; CreatedFontTracker.MAX_FILE_SIZE) {</span>
<span class="nc" id="L942">                                throw new IOException(&quot;File too big.&quot;);</span>
                            }
<span class="nc bnc" id="L944" title="All 2 branches missed.">                            if (totalSize+tracker.getNumBytes() &gt;</span>
                                CreatedFontTracker.MAX_TOTAL_BYTES)
                              {
<span class="nc" id="L947">                                throw new IOException(&quot;Total files too big.&quot;);</span>
                            }
<span class="nc" id="L949">                            totalSize += bytesRead;</span>
<span class="nc" id="L950">                            tracker.addBytes(bytesRead);</span>
                        }
<span class="nc" id="L952">                        outStream.write(buf, 0, bytesRead);</span>
<span class="nc" id="L953">                    }</span>
                    /* don't close the input stream */
                } finally {
<span class="nc" id="L956">                    outStream.close();</span>
<span class="nc" id="L957">                }</span>
                /* After all references to a Font2D are dropped, the file
                 * will be removed. To support long-lived AppContexts,
                 * we need to then decrement the byte count by the size
                 * of the file.
                 * If the data isn't a valid font, the implementation will
                 * delete the tmp file and decrement the byte count
                 * in the tracker object before returning from the
                 * constructor, so we can set 'copiedFontData' to true here
                 * without waiting for the results of that constructor.
                 */
<span class="nc" id="L968">                copiedFontData = true;</span>
<span class="nc" id="L969">                Font font = new Font(tFile, fontFormat, true, tracker);</span>
<span class="nc" id="L970">                return font;</span>
            } finally {
<span class="nc bnc" id="L972" title="All 4 branches missed.">                if (tracker != null) {</span>
<span class="nc" id="L973">                    tracker.remove(tFile);</span>
                }
<span class="nc bnc" id="L975" title="All 4 branches missed.">                if (!copiedFontData) {</span>
<span class="nc bnc" id="L976" title="All 4 branches missed.">                    if (tracker != null) {</span>
<span class="nc" id="L977">                        tracker.subBytes(totalSize);</span>
                    }
<span class="nc" id="L979">                    AccessController.doPrivileged(</span>
<span class="nc" id="L980">                        new PrivilegedExceptionAction&lt;Void&gt;() {</span>
                            public Void run() {
<span class="nc" id="L982">                                tFile.delete();</span>
<span class="nc" id="L983">                                return null;</span>
                            }
                        }
                    );
                }
            }
<span class="nc" id="L989">        } catch (Throwable t) {</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">            if (t instanceof FontFormatException) {</span>
<span class="nc" id="L991">                throw (FontFormatException)t;</span>
            }
<span class="nc bnc" id="L993" title="All 2 branches missed.">            if (t instanceof IOException) {</span>
<span class="nc" id="L994">                throw (IOException)t;</span>
            }
<span class="nc" id="L996">            Throwable cause = t.getCause();</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">            if (cause instanceof FontFormatException) {</span>
<span class="nc" id="L998">                throw (FontFormatException)cause;</span>
            }
<span class="nc" id="L1000">            throw new IOException(&quot;Problem reading font data.&quot;);</span>
        }
    }

    /**
     * Returns a new &lt;code&gt;Font&lt;/code&gt; using the specified font type
     * and the specified font file.  The new &lt;code&gt;Font&lt;/code&gt; is
     * created with a point size of 1 and style {@link #PLAIN PLAIN}.
     * This base font can then be used with the &lt;code&gt;deriveFont&lt;/code&gt;
     * methods in this class to derive new &lt;code&gt;Font&lt;/code&gt; objects with
     * varying sizes, styles, transforms and font features.
     * @param fontFormat the type of the &lt;code&gt;Font&lt;/code&gt;, which is
     * {@link #TRUETYPE_FONT TRUETYPE_FONT} if a TrueType resource is
     * specified or {@link #TYPE1_FONT TYPE1_FONT} if a Type 1 resource is
     * specified.
     * So long as the returned font, or its derived fonts are referenced
     * the implementation may continue to access &lt;code&gt;fontFile&lt;/code&gt;
     * to retrieve font data. Thus the results are undefined if the file
     * is changed, or becomes inaccessible.
     * &lt;p&gt;
     * To make the &lt;code&gt;Font&lt;/code&gt; available to Font constructors the
     * returned &lt;code&gt;Font&lt;/code&gt; must be registered in the
     * &lt;code&gt;GraphicsEnviroment&lt;/code&gt; by calling
     * {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)}.
     * @param fontFile a &lt;code&gt;File&lt;/code&gt; object representing the
     * input data for the font.
     * @return a new &lt;code&gt;Font&lt;/code&gt; created with the specified font type.
     * @throws IllegalArgumentException if &lt;code&gt;fontFormat&lt;/code&gt; is not
     *     &lt;code&gt;TRUETYPE_FONT&lt;/code&gt;or&lt;code&gt;TYPE1_FONT&lt;/code&gt;.
     * @throws NullPointerException if &lt;code&gt;fontFile&lt;/code&gt; is null.
     * @throws IOException if the &lt;code&gt;fontFile&lt;/code&gt; cannot be read.
     * @throws FontFormatException if &lt;code&gt;fontFile&lt;/code&gt; does
     *     not contain the required font tables for the specified format.
     * @throws SecurityException if the executing code does not have
     * permission to read from the file.
     * @see GraphicsEnvironment#registerFont(Font)
     * @since 1.5
     */
    public static Font createFont(int fontFormat, File fontFile)
        throws java.awt.FontFormatException, java.io.IOException {

<span class="nc" id="L1041">        fontFile = new File(fontFile.getPath());</span>

<span class="nc bnc" id="L1043" title="All 4 branches missed.">        if (fontFormat != Font.TRUETYPE_FONT &amp;&amp;</span>
            fontFormat != Font.TYPE1_FONT) {
<span class="nc" id="L1045">            throw new IllegalArgumentException (&quot;font format not recognized&quot;);</span>
        }
<span class="nc" id="L1047">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L1049">            FilePermission filePermission =</span>
<span class="nc" id="L1050">                new FilePermission(fontFile.getPath(), &quot;read&quot;);</span>
<span class="nc" id="L1051">            sm.checkPermission(filePermission);</span>
        }
<span class="nc bnc" id="L1053" title="All 2 branches missed.">        if (!fontFile.canRead()) {</span>
<span class="nc" id="L1054">            throw new IOException(&quot;Can't read &quot; + fontFile);</span>
        }
<span class="nc" id="L1056">        return new Font(fontFile, fontFormat, false, null);</span>
    }

    /**
     * Returns a copy of the transform associated with this
     * &lt;code&gt;Font&lt;/code&gt;.  This transform is not necessarily the one
     * used to construct the font.  If the font has algorithmic
     * superscripting or width adjustment, this will be incorporated
     * into the returned &lt;code&gt;AffineTransform&lt;/code&gt;.
     * &lt;p&gt;
     * Typically, fonts will not be transformed.  Clients generally
     * should call {@link #isTransformed} first, and only call this
     * method if &lt;code&gt;isTransformed&lt;/code&gt; returns true.
     *
     * @return an {@link AffineTransform} object representing the
     *          transform attribute of this &lt;code&gt;Font&lt;/code&gt; object.
     */
    public AffineTransform getTransform() {
        /* The most common case is the identity transform.  Most callers
         * should call isTransformed() first, to decide if they need to
         * get the transform, but some may not.  Here we check to see
         * if we have a nonidentity transform, and only do the work to
         * fetch and/or compute it if so, otherwise we return a new
         * identity transform.
         *
         * Note that the transform is _not_ necessarily the same as
         * the transform passed in as an Attribute in a Map, as the
         * transform returned will also reflect the effects of WIDTH and
         * SUPERSCRIPT attributes.  Clients who want the actual transform
         * need to call getRequestedAttributes.
         */
<span class="nc bnc" id="L1087" title="All 2 branches missed.">        if (nonIdentityTx) {</span>
<span class="nc" id="L1088">            AttributeValues values = getAttributeValues();</span>

<span class="nc bnc" id="L1090" title="All 2 branches missed.">            AffineTransform at = values.isNonDefault(ETRANSFORM)</span>
<span class="nc" id="L1091">                ? new AffineTransform(values.getTransform())</span>
                : new AffineTransform();

<span class="nc bnc" id="L1094" title="All 2 branches missed.">            if (values.getSuperscript() != 0) {</span>
                // can't get ascent and descent here, recursive call to this fn,
                // so use pointsize
                // let users combine super- and sub-scripting

<span class="nc" id="L1099">                int superscript = values.getSuperscript();</span>

<span class="nc" id="L1101">                double trans = 0;</span>
<span class="nc" id="L1102">                int n = 0;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">                boolean up = superscript &gt; 0;</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                int sign = up ? -1 : 1;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">                int ss = up ? superscript : -superscript;</span>

<span class="nc bnc" id="L1107" title="All 2 branches missed.">                while ((ss &amp; 7) &gt; n) {</span>
<span class="nc" id="L1108">                    int newn = ss &amp; 7;</span>
<span class="nc" id="L1109">                    trans += sign * (ssinfo[newn] - ssinfo[n]);</span>
<span class="nc" id="L1110">                    ss &gt;&gt;= 3;</span>
<span class="nc" id="L1111">                    sign = -sign;</span>
<span class="nc" id="L1112">                    n = newn;</span>
<span class="nc" id="L1113">                }</span>
<span class="nc" id="L1114">                trans *= pointSize;</span>
<span class="nc" id="L1115">                double scale = Math.pow(2./3., n);</span>

<span class="nc" id="L1117">                at.preConcatenate(AffineTransform.getTranslateInstance(0, trans));</span>
<span class="nc" id="L1118">                at.scale(scale, scale);</span>

                // note on placement and italics
                // We preconcatenate the transform because we don't want to translate along
                // the italic angle, but purely perpendicular to the baseline.  While this
                // looks ok for superscripts, it can lead subscripts to stack on each other
                // and bring the following text too close.  The way we deal with potential
                // collisions that can occur in the case of italics is by adjusting the
                // horizontal spacing of the adjacent glyphvectors.  Examine the italic
                // angle of both vectors, if one is non-zero, compute the minimum ascent
                // and descent, and then the x position at each for each vector along its
                // italic angle starting from its (offset) baseline.  Compute the difference
                // between the x positions and use the maximum difference to adjust the
                // position of the right gv.
            }

<span class="nc bnc" id="L1134" title="All 2 branches missed.">            if (values.isNonDefault(EWIDTH)) {</span>
<span class="nc" id="L1135">                at.scale(values.getWidth(), 1f);</span>
            }

<span class="nc" id="L1138">            return at;</span>
        }

<span class="nc" id="L1141">        return new AffineTransform();</span>
    }

    // x = r^0 + r^1 + r^2... r^n
    // rx = r^1 + r^2 + r^3... r^(n+1)
    // x - rx = r^0 - r^(n+1)
    // x (1 - r) = r^0 - r^(n+1)
    // x = (r^0 - r^(n+1)) / (1 - r)
    // x = (1 - r^(n+1)) / (1 - r)

    // scale ratio is 2/3
    // trans = 1/2 of ascent * x
    // assume ascent is 3/4 of point size

<span class="fc" id="L1155">    private static final float[] ssinfo = {</span>
        0.0f,
        0.375f,
        0.625f,
        0.7916667f,
        0.9027778f,
        0.9768519f,
        1.0262346f,
        1.0591564f,
    };

    /**
     * Returns the family name of this &lt;code&gt;Font&lt;/code&gt;.
     *
     * &lt;p&gt;The family name of a font is font specific. Two fonts such as
     * Helvetica Italic and Helvetica Bold have the same family name,
     * &lt;i&gt;Helvetica&lt;/i&gt;, whereas their font face names are
     * &lt;i&gt;Helvetica Bold&lt;/i&gt; and &lt;i&gt;Helvetica Italic&lt;/i&gt;. The list of
     * available family names may be obtained by using the
     * {@link GraphicsEnvironment#getAvailableFontFamilyNames()} method.
     *
     * &lt;p&gt;Use &lt;code&gt;getName&lt;/code&gt; to get the logical name of the font.
     * Use &lt;code&gt;getFontName&lt;/code&gt; to get the font face name of the font.
     * @return a &lt;code&gt;String&lt;/code&gt; that is the family name of this
     *          &lt;code&gt;Font&lt;/code&gt;.
     *
     * @see #getName
     * @see #getFontName
     * @since JDK1.1
     */
    public String getFamily() {
<span class="nc" id="L1186">        return getFamily_NoClientCode();</span>
    }
    // NOTE: This method is called by privileged threads.
    //       We implement this functionality in a package-private
    //       method to insure that it cannot be overridden by client
    //       subclasses.
    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
    final String getFamily_NoClientCode() {
<span class="nc" id="L1194">        return getFamily(Locale.getDefault());</span>
    }

    /**
     * Returns the family name of this &lt;code&gt;Font&lt;/code&gt;, localized for
     * the specified locale.
     *
     * &lt;p&gt;The family name of a font is font specific. Two fonts such as
     * Helvetica Italic and Helvetica Bold have the same family name,
     * &lt;i&gt;Helvetica&lt;/i&gt;, whereas their font face names are
     * &lt;i&gt;Helvetica Bold&lt;/i&gt; and &lt;i&gt;Helvetica Italic&lt;/i&gt;. The list of
     * available family names may be obtained by using the
     * {@link GraphicsEnvironment#getAvailableFontFamilyNames()} method.
     *
     * &lt;p&gt;Use &lt;code&gt;getFontName&lt;/code&gt; to get the font face name of the font.
     * @param l locale for which to get the family name
     * @return a &lt;code&gt;String&lt;/code&gt; representing the family name of the
     *          font, localized for the specified locale.
     * @see #getFontName
     * @see java.util.Locale
     * @since 1.2
     */
    public String getFamily(Locale l) {
<span class="nc bnc" id="L1217" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L1218">            throw new NullPointerException(&quot;null locale doesn't mean default&quot;);</span>
        }
<span class="nc" id="L1220">        return getFont2D().getFamilyName(l);</span>
    }

    /**
     * Returns the postscript name of this &lt;code&gt;Font&lt;/code&gt;.
     * Use &lt;code&gt;getFamily&lt;/code&gt; to get the family name of the font.
     * Use &lt;code&gt;getFontName&lt;/code&gt; to get the font face name of the font.
     * @return a &lt;code&gt;String&lt;/code&gt; representing the postscript name of
     *          this &lt;code&gt;Font&lt;/code&gt;.
     * @since 1.2
     */
    public String getPSName() {
<span class="nc" id="L1232">        return getFont2D().getPostscriptName();</span>
    }

    /**
     * Returns the logical name of this &lt;code&gt;Font&lt;/code&gt;.
     * Use &lt;code&gt;getFamily&lt;/code&gt; to get the family name of the font.
     * Use &lt;code&gt;getFontName&lt;/code&gt; to get the font face name of the font.
     * @return a &lt;code&gt;String&lt;/code&gt; representing the logical name of
     *          this &lt;code&gt;Font&lt;/code&gt;.
     * @see #getFamily
     * @see #getFontName
     * @since JDK1.0
     */
    public String getName() {
<span class="nc" id="L1246">        return name;</span>
    }

    /**
     * Returns the font face name of this &lt;code&gt;Font&lt;/code&gt;.  For example,
     * Helvetica Bold could be returned as a font face name.
     * Use &lt;code&gt;getFamily&lt;/code&gt; to get the family name of the font.
     * Use &lt;code&gt;getName&lt;/code&gt; to get the logical name of the font.
     * @return a &lt;code&gt;String&lt;/code&gt; representing the font face name of
     *          this &lt;code&gt;Font&lt;/code&gt;.
     * @see #getFamily
     * @see #getName
     * @since 1.2
     */
    public String getFontName() {
<span class="nc" id="L1261">      return getFontName(Locale.getDefault());</span>
    }

    /**
     * Returns the font face name of the &lt;code&gt;Font&lt;/code&gt;, localized
     * for the specified locale. For example, Helvetica Fett could be
     * returned as the font face name.
     * Use &lt;code&gt;getFamily&lt;/code&gt; to get the family name of the font.
     * @param l a locale for which to get the font face name
     * @return a &lt;code&gt;String&lt;/code&gt; representing the font face name,
     *          localized for the specified locale.
     * @see #getFamily
     * @see java.util.Locale
     */
    public String getFontName(Locale l) {
<span class="nc bnc" id="L1276" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L1277">            throw new NullPointerException(&quot;null locale doesn't mean default&quot;);</span>
        }
<span class="nc" id="L1279">        return getFont2D().getFontName(l);</span>
    }

    /**
     * Returns the style of this &lt;code&gt;Font&lt;/code&gt;.  The style can be
     * PLAIN, BOLD, ITALIC, or BOLD+ITALIC.
     * @return the style of this &lt;code&gt;Font&lt;/code&gt;
     * @see #isPlain
     * @see #isBold
     * @see #isItalic
     * @since JDK1.0
     */
    public int getStyle() {
<span class="nc" id="L1292">        return style;</span>
    }

    /**
     * Returns the point size of this &lt;code&gt;Font&lt;/code&gt;, rounded to
     * an integer.
     * Most users are familiar with the idea of using &lt;i&gt;point size&lt;/i&gt; to
     * specify the size of glyphs in a font. This point size defines a
     * measurement between the baseline of one line to the baseline of the
     * following line in a single spaced text document. The point size is
     * based on &lt;i&gt;typographic points&lt;/i&gt;, approximately 1/72 of an inch.
     * &lt;p&gt;
     * The Java(tm)2D API adopts the convention that one point is
     * equivalent to one unit in user coordinates.  When using a
     * normalized transform for converting user space coordinates to
     * device space coordinates 72 user
     * space units equal 1 inch in device space.  In this case one point
     * is 1/72 of an inch.
     * @return the point size of this &lt;code&gt;Font&lt;/code&gt; in 1/72 of an
     *          inch units.
     * @see #getSize2D
     * @see GraphicsConfiguration#getDefaultTransform
     * @see GraphicsConfiguration#getNormalizingTransform
     * @since JDK1.0
     */
    public int getSize() {
<span class="nc" id="L1318">        return size;</span>
    }

    /**
     * Returns the point size of this &lt;code&gt;Font&lt;/code&gt; in
     * &lt;code&gt;float&lt;/code&gt; value.
     * @return the point size of this &lt;code&gt;Font&lt;/code&gt; as a
     * &lt;code&gt;float&lt;/code&gt; value.
     * @see #getSize
     * @since 1.2
     */
    public float getSize2D() {
<span class="nc" id="L1330">        return pointSize;</span>
    }

    /**
     * Indicates whether or not this &lt;code&gt;Font&lt;/code&gt; object's style is
     * PLAIN.
     * @return    &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Font&lt;/code&gt; has a
     *            PLAIN style;
     *            &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see       java.awt.Font#getStyle
     * @since     JDK1.0
     */
    public boolean isPlain() {
<span class="nc bnc" id="L1343" title="All 2 branches missed.">        return style == 0;</span>
    }

    /**
     * Indicates whether or not this &lt;code&gt;Font&lt;/code&gt; object's style is
     * BOLD.
     * @return    &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Font&lt;/code&gt; object's
     *            style is BOLD;
     *            &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see       java.awt.Font#getStyle
     * @since     JDK1.0
     */
    public boolean isBold() {
<span class="nc bnc" id="L1356" title="All 2 branches missed.">        return (style &amp; BOLD) != 0;</span>
    }

    /**
     * Indicates whether or not this &lt;code&gt;Font&lt;/code&gt; object's style is
     * ITALIC.
     * @return    &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Font&lt;/code&gt; object's
     *            style is ITALIC;
     *            &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see       java.awt.Font#getStyle
     * @since     JDK1.0
     */
    public boolean isItalic() {
<span class="nc bnc" id="L1369" title="All 2 branches missed.">        return (style &amp; ITALIC) != 0;</span>
    }

    /**
     * Indicates whether or not this &lt;code&gt;Font&lt;/code&gt; object has a
     * transform that affects its size in addition to the Size
     * attribute.
     * @return  &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Font&lt;/code&gt; object
     *          has a non-identity AffineTransform attribute.
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see     java.awt.Font#getTransform
     * @since   1.4
     */
    public boolean isTransformed() {
<span class="nc" id="L1383">        return nonIdentityTx;</span>
    }

    /**
     * Return true if this Font contains attributes that require extra
     * layout processing.
     * @return true if the font has layout attributes
     * @since 1.6
     */
    public boolean hasLayoutAttributes() {
<span class="nc" id="L1393">        return hasLayoutAttributes;</span>
    }

    /**
     * Returns a &lt;code&gt;Font&lt;/code&gt; object from the system properties list.
     * &lt;code&gt;nm&lt;/code&gt; is treated as the name of a system property to be
     * obtained.  The &lt;code&gt;String&lt;/code&gt; value of this property is then
     * interpreted as a &lt;code&gt;Font&lt;/code&gt; object according to the
     * specification of &lt;code&gt;Font.decode(String)&lt;/code&gt;
     * If the specified property is not found, or the executing code does
     * not have permission to read the property, null is returned instead.
     *
     * @param nm the property name
     * @return a &lt;code&gt;Font&lt;/code&gt; object that the property name
     *          describes, or null if no such property exists.
     * @throws NullPointerException if nm is null.
     * @since 1.2
     * @see #decode(String)
     */
    public static Font getFont(String nm) {
<span class="nc" id="L1413">        return getFont(nm, null);</span>
    }

    /**
     * Returns the &lt;code&gt;Font&lt;/code&gt; that the &lt;code&gt;str&lt;/code&gt;
     * argument describes.
     * To ensure that this method returns the desired Font,
     * format the &lt;code&gt;str&lt;/code&gt; parameter in
     * one of these ways
     * &lt;p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;&lt;em&gt;fontname-style-pointsize&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname-pointsize&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname-style&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname style pointsize&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname pointsize&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname style&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname&lt;/em&gt;
     * &lt;/ul&gt;
     * in which &lt;i&gt;style&lt;/i&gt; is one of the four
     * case-insensitive strings:
     * &lt;code&gt;&quot;PLAIN&quot;&lt;/code&gt;, &lt;code&gt;&quot;BOLD&quot;&lt;/code&gt;, &lt;code&gt;&quot;BOLDITALIC&quot;&lt;/code&gt;, or
     * &lt;code&gt;&quot;ITALIC&quot;&lt;/code&gt;, and pointsize is a positive decimal integer
     * representation of the point size.
     * For example, if you want a font that is Arial, bold, with
     * a point size of 18, you would call this method with:
     * &quot;Arial-BOLD-18&quot;.
     * This is equivalent to calling the Font constructor :
     * &lt;code&gt;new Font(&quot;Arial&quot;, Font.BOLD, 18);&lt;/code&gt;
     * and the values are interpreted as specified by that constructor.
     * &lt;p&gt;
     * A valid trailing decimal field is always interpreted as the pointsize.
     * Therefore a fontname containing a trailing decimal value should not
     * be used in the fontname only form.
     * &lt;p&gt;
     * If a style name field is not one of the valid style strings, it is
     * interpreted as part of the font name, and the default style is used.
     * &lt;p&gt;
     * Only one of ' ' or '-' may be used to separate fields in the input.
     * The identified separator is the one closest to the end of the string
     * which separates a valid pointsize, or a valid style name from
     * the rest of the string.
     * Null (empty) pointsize and style fields are treated
     * as valid fields with the default value for that field.
     *&lt;p&gt;
     * Some font names may include the separator characters ' ' or '-'.
     * If &lt;code&gt;str&lt;/code&gt; is not formed with 3 components, e.g. such that
     * &lt;code&gt;style&lt;/code&gt; or &lt;code&gt;pointsize&lt;/code&gt; fields are not present in
     * &lt;code&gt;str&lt;/code&gt;, and &lt;code&gt;fontname&lt;/code&gt; also contains a
     * character determined to be the separator character
     * then these characters where they appear as intended to be part of
     * &lt;code&gt;fontname&lt;/code&gt; may instead be interpreted as separators
     * so the font name may not be properly recognised.
     *
     * &lt;p&gt;
     * The default size is 12 and the default style is PLAIN.
     * If &lt;code&gt;str&lt;/code&gt; does not specify a valid size, the returned
     * &lt;code&gt;Font&lt;/code&gt; has a size of 12.  If &lt;code&gt;str&lt;/code&gt; does not
     * specify a valid style, the returned Font has a style of PLAIN.
     * If you do not specify a valid font name in
     * the &lt;code&gt;str&lt;/code&gt; argument, this method will return
     * a font with the family name &quot;Dialog&quot;.
     * To determine what font family names are available on
     * your system, use the
     * {@link GraphicsEnvironment#getAvailableFontFamilyNames()} method.
     * If &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a new &lt;code&gt;Font&lt;/code&gt;
     * is returned with the family name &quot;Dialog&quot;, a size of 12 and a
     * PLAIN style.
     * @param str the name of the font, or &lt;code&gt;null&lt;/code&gt;
     * @return the &lt;code&gt;Font&lt;/code&gt; object that &lt;code&gt;str&lt;/code&gt;
     *          describes, or a new default &lt;code&gt;Font&lt;/code&gt; if
     *          &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @see #getFamily
     * @since JDK1.1
     */
    public static Font decode(String str) {
<span class="nc" id="L1490">        String fontName = str;</span>
<span class="nc" id="L1491">        String styleName = &quot;&quot;;</span>
<span class="nc" id="L1492">        int fontSize = 12;</span>
<span class="nc" id="L1493">        int fontStyle = Font.PLAIN;</span>

<span class="nc bnc" id="L1495" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L1496">            return new Font(DIALOG, fontStyle, fontSize);</span>
        }

<span class="nc" id="L1499">        int lastHyphen = str.lastIndexOf('-');</span>
<span class="nc" id="L1500">        int lastSpace = str.lastIndexOf(' ');</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">        char sepChar = (lastHyphen &gt; lastSpace) ? '-' : ' ';</span>
<span class="nc" id="L1502">        int sizeIndex = str.lastIndexOf(sepChar);</span>
<span class="nc" id="L1503">        int styleIndex = str.lastIndexOf(sepChar, sizeIndex-1);</span>
<span class="nc" id="L1504">        int strlen = str.length();</span>

<span class="nc bnc" id="L1506" title="All 4 branches missed.">        if (sizeIndex &gt; 0 &amp;&amp; sizeIndex+1 &lt; strlen) {</span>
            try {
<span class="nc" id="L1508">                fontSize =</span>
<span class="nc" id="L1509">                    Integer.valueOf(str.substring(sizeIndex+1)).intValue();</span>
<span class="nc bnc" id="L1510" title="All 2 branches missed.">                if (fontSize &lt;= 0) {</span>
<span class="nc" id="L1511">                    fontSize = 12;</span>
                }
<span class="nc" id="L1513">            } catch (NumberFormatException e) {</span>
                /* It wasn't a valid size, if we didn't also find the
                 * start of the style string perhaps this is the style */
<span class="nc" id="L1516">                styleIndex = sizeIndex;</span>
<span class="nc" id="L1517">                sizeIndex = strlen;</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">                if (str.charAt(sizeIndex-1) == sepChar) {</span>
<span class="nc" id="L1519">                    sizeIndex--;</span>
                }
<span class="nc" id="L1521">            }</span>
        }

<span class="nc bnc" id="L1524" title="All 4 branches missed.">        if (styleIndex &gt;= 0 &amp;&amp; styleIndex+1 &lt; strlen) {</span>
<span class="nc" id="L1525">            styleName = str.substring(styleIndex+1, sizeIndex);</span>
<span class="nc" id="L1526">            styleName = styleName.toLowerCase(Locale.ENGLISH);</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">            if (styleName.equals(&quot;bolditalic&quot;)) {</span>
<span class="nc" id="L1528">                fontStyle = Font.BOLD | Font.ITALIC;</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">            } else if (styleName.equals(&quot;italic&quot;)) {</span>
<span class="nc" id="L1530">                fontStyle = Font.ITALIC;</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">            } else if (styleName.equals(&quot;bold&quot;)) {</span>
<span class="nc" id="L1532">                fontStyle = Font.BOLD;</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">            } else if (styleName.equals(&quot;plain&quot;)) {</span>
<span class="nc" id="L1534">                fontStyle = Font.PLAIN;</span>
            } else {
                /* this string isn't any of the expected styles, so
                 * assume its part of the font name
                 */
<span class="nc" id="L1539">                styleIndex = sizeIndex;</span>
<span class="nc bnc" id="L1540" title="All 2 branches missed.">                if (str.charAt(styleIndex-1) == sepChar) {</span>
<span class="nc" id="L1541">                    styleIndex--;</span>
                }
            }
<span class="nc" id="L1544">            fontName = str.substring(0, styleIndex);</span>

        } else {
<span class="nc" id="L1547">            int fontEnd = strlen;</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">            if (styleIndex &gt; 0) {</span>
<span class="nc" id="L1549">                fontEnd = styleIndex;</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">            } else if (sizeIndex &gt; 0) {</span>
<span class="nc" id="L1551">                fontEnd = sizeIndex;</span>
            }
<span class="nc bnc" id="L1553" title="All 4 branches missed.">            if (fontEnd &gt; 0 &amp;&amp; str.charAt(fontEnd-1) == sepChar) {</span>
<span class="nc" id="L1554">                fontEnd--;</span>
            }
<span class="nc" id="L1556">            fontName = str.substring(0, fontEnd);</span>
        }

<span class="nc" id="L1559">        return new Font(fontName, fontStyle, fontSize);</span>
    }

    /**
     * Gets the specified &lt;code&gt;Font&lt;/code&gt; from the system properties
     * list.  As in the &lt;code&gt;getProperty&lt;/code&gt; method of
     * &lt;code&gt;System&lt;/code&gt;, the first
     * argument is treated as the name of a system property to be
     * obtained.  The &lt;code&gt;String&lt;/code&gt; value of this property is then
     * interpreted as a &lt;code&gt;Font&lt;/code&gt; object.
     * &lt;p&gt;
     * The property value should be one of the forms accepted by
     * &lt;code&gt;Font.decode(String)&lt;/code&gt;
     * If the specified property is not found, or the executing code does not
     * have permission to read the property, the &lt;code&gt;font&lt;/code&gt;
     * argument is returned instead.
     * @param nm the case-insensitive property name
     * @param font a default &lt;code&gt;Font&lt;/code&gt; to return if property
     *          &lt;code&gt;nm&lt;/code&gt; is not defined
     * @return    the &lt;code&gt;Font&lt;/code&gt; value of the property.
     * @throws NullPointerException if nm is null.
     * @see #decode(String)
     */
    public static Font getFont(String nm, Font font) {
<span class="nc" id="L1583">        String str = null;</span>
        try {
<span class="nc" id="L1585">            str =System.getProperty(nm);</span>
<span class="nc" id="L1586">        } catch(SecurityException e) {</span>
<span class="nc" id="L1587">        }</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L1589">            return font;</span>
        }
<span class="nc" id="L1591">        return decode ( str );</span>
    }

    transient int hash;
    /**
     * Returns a hashcode for this &lt;code&gt;Font&lt;/code&gt;.
     * @return     a hashcode value for this &lt;code&gt;Font&lt;/code&gt;.
     * @since      JDK1.0
     */
    public int hashCode() {
<span class="nc bnc" id="L1601" title="All 2 branches missed.">        if (hash == 0) {</span>
<span class="nc" id="L1602">            hash = name.hashCode() ^ style ^ size;</span>
            /* It is possible many fonts differ only in transform.
             * So include the transform in the hash calculation.
             * nonIdentityTx is set whenever there is a transform in
             * 'values'. The tests for null are required because it can
             * also be set for other reasons.
             */
<span class="nc bnc" id="L1609" title="All 4 branches missed.">            if (nonIdentityTx &amp;&amp;</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">                values != null &amp;&amp; values.getTransform() != null) {</span>
<span class="nc" id="L1611">                hash ^= values.getTransform().hashCode();</span>
            }
        }
<span class="nc" id="L1614">        return hash;</span>
    }

    /**
     * Compares this &lt;code&gt;Font&lt;/code&gt; object to the specified
     * &lt;code&gt;Object&lt;/code&gt;.
     * @param obj the &lt;code&gt;Object&lt;/code&gt; to compare
     * @return &lt;code&gt;true&lt;/code&gt; if the objects are the same
     *          or if the argument is a &lt;code&gt;Font&lt;/code&gt; object
     *          describing the same font as this object;
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since JDK1.0
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L1628" title="All 2 branches missed.">        if (obj == this) {</span>
<span class="nc" id="L1629">            return true;</span>
        }

<span class="nc bnc" id="L1632" title="All 2 branches missed.">        if (obj != null) {</span>
            try {
<span class="nc" id="L1634">                Font font = (Font)obj;</span>
<span class="nc bnc" id="L1635" title="All 10 branches missed.">                if (size == font.size &amp;&amp;</span>
                    style == font.style &amp;&amp;
                    nonIdentityTx == font.nonIdentityTx &amp;&amp;
                    hasLayoutAttributes == font.hasLayoutAttributes &amp;&amp;
                    pointSize == font.pointSize &amp;&amp;
<span class="nc bnc" id="L1640" title="All 2 branches missed.">                    name.equals(font.name)) {</span>

                    /* 'values' is usually initialized lazily, except when
                     * the font is constructed from a Map, or derived using
                     * a Map or other values. So if only one font has
                     * the field initialized we need to initialize it in
                     * the other instance and compare.
                     */
<span class="nc bnc" id="L1648" title="All 2 branches missed.">                    if (values == null) {</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">                        if (font.values == null) {</span>
<span class="nc" id="L1650">                            return true;</span>
                        } else {
<span class="nc" id="L1652">                            return getAttributeValues().equals(font.values);</span>
                        }
                    } else {
<span class="nc" id="L1655">                        return values.equals(font.getAttributeValues());</span>
                    }
                }
            }
<span class="nc" id="L1659">            catch (ClassCastException e) {</span>
<span class="nc" id="L1660">            }</span>
        }
<span class="nc" id="L1662">        return false;</span>
    }

    /**
     * Converts this &lt;code&gt;Font&lt;/code&gt; object to a &lt;code&gt;String&lt;/code&gt;
     * representation.
     * @return     a &lt;code&gt;String&lt;/code&gt; representation of this
     *          &lt;code&gt;Font&lt;/code&gt; object.
     * @since      JDK1.0
     */
    // NOTE: This method may be called by privileged threads.
    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
    public String toString() {
        String  strStyle;

<span class="nc bnc" id="L1677" title="All 2 branches missed.">        if (isBold()) {</span>
<span class="nc bnc" id="L1678" title="All 2 branches missed.">            strStyle = isItalic() ? &quot;bolditalic&quot; : &quot;bold&quot;;</span>
        } else {
<span class="nc bnc" id="L1680" title="All 2 branches missed.">            strStyle = isItalic() ? &quot;italic&quot; : &quot;plain&quot;;</span>
        }

<span class="nc" id="L1683">        return getClass().getName() + &quot;[family=&quot; + getFamily() + &quot;,name=&quot; + name + &quot;,style=&quot; +</span>
            strStyle + &quot;,size=&quot; + size + &quot;]&quot;;
    } // toString()


    /** Serialization support.  A &lt;code&gt;readObject&lt;/code&gt;
     *  method is neccessary because the constructor creates
     *  the font's peer, and we can't serialize the peer.
     *  Similarly the computed font &quot;family&quot; may be different
     *  at &lt;code&gt;readObject&lt;/code&gt; time than at
     *  &lt;code&gt;writeObject&lt;/code&gt; time.  An integer version is
     *  written so that future versions of this class will be
     *  able to recognize serialized output from this one.
     */
    /**
     * The &lt;code&gt;Font&lt;/code&gt; Serializable Data Form.
     *
     * @serial
     */
<span class="pc" id="L1702">    private int fontSerializedDataVersion = 1;</span>

    /**
     * Writes default serializable fields to a stream.
     *
     * @param s the &lt;code&gt;ObjectOutputStream&lt;/code&gt; to write
     * @see AWTEventMulticaster#save(ObjectOutputStream, String, EventListener)
     * @see #readObject(java.io.ObjectInputStream)
     */
    private void writeObject(java.io.ObjectOutputStream s)
      throws java.lang.ClassNotFoundException,
             java.io.IOException
    {
<span class="nc bnc" id="L1715" title="All 2 branches missed.">        if (values != null) {</span>
<span class="nc" id="L1716">          synchronized(values) {</span>
            // transient
<span class="nc" id="L1718">            fRequestedAttributes = values.toSerializableHashtable();</span>
<span class="nc" id="L1719">            s.defaultWriteObject();</span>
<span class="nc" id="L1720">            fRequestedAttributes = null;</span>
<span class="nc" id="L1721">          }</span>
        } else {
<span class="nc" id="L1723">          s.defaultWriteObject();</span>
        }
<span class="nc" id="L1725">    }</span>

    /**
     * Reads the &lt;code&gt;ObjectInputStream&lt;/code&gt;.
     * Unrecognized keys or values will be ignored.
     *
     * @param s the &lt;code&gt;ObjectInputStream&lt;/code&gt; to read
     * @serial
     * @see #writeObject(java.io.ObjectOutputStream)
     */
    private void readObject(java.io.ObjectInputStream s)
      throws java.lang.ClassNotFoundException,
             java.io.IOException
    {
<span class="nc" id="L1739">        s.defaultReadObject();</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">        if (pointSize == 0) {</span>
<span class="nc" id="L1741">            pointSize = (float)size;</span>
        }

        // Handle fRequestedAttributes.
        // in 1.5, we always streamed out the font values plus
        // TRANSFORM, SUPERSCRIPT, and WIDTH, regardless of whether the
        // values were default or not.  In 1.6 we only stream out
        // defined values.  So, 1.6 streams in from a 1.5 stream,
        // it check each of these values and 'undefines' it if the
        // value is the default.

<span class="nc bnc" id="L1752" title="All 2 branches missed.">        if (fRequestedAttributes != null) {</span>
<span class="nc" id="L1753">            values = getAttributeValues(); // init</span>
<span class="nc" id="L1754">            AttributeValues extras =</span>
<span class="nc" id="L1755">                AttributeValues.fromSerializableHashtable(fRequestedAttributes);</span>
<span class="nc bnc" id="L1756" title="All 2 branches missed.">            if (!AttributeValues.is16Hashtable(fRequestedAttributes)) {</span>
<span class="nc" id="L1757">                extras.unsetDefault(); // if legacy stream, undefine these</span>
            }
<span class="nc" id="L1759">            values = getAttributeValues().merge(extras);</span>
<span class="nc" id="L1760">            this.nonIdentityTx = values.anyNonDefault(EXTRA_MASK);</span>
<span class="nc" id="L1761">            this.hasLayoutAttributes =  values.anyNonDefault(LAYOUT_MASK);</span>

<span class="nc" id="L1763">            fRequestedAttributes = null; // don't need it any more</span>
        }
<span class="nc" id="L1765">    }</span>

    /**
     * Returns the number of glyphs in this &lt;code&gt;Font&lt;/code&gt;. Glyph codes
     * for this &lt;code&gt;Font&lt;/code&gt; range from 0 to
     * &lt;code&gt;getNumGlyphs()&lt;/code&gt; - 1.
     * @return the number of glyphs in this &lt;code&gt;Font&lt;/code&gt;.
     * @since 1.2
     */
    public int getNumGlyphs() {
<span class="nc" id="L1775">        return  getFont2D().getNumGlyphs();</span>
    }

    /**
     * Returns the glyphCode which is used when this &lt;code&gt;Font&lt;/code&gt;
     * does not have a glyph for a specified unicode code point.
     * @return the glyphCode of this &lt;code&gt;Font&lt;/code&gt;.
     * @since 1.2
     */
    public int getMissingGlyphCode() {
<span class="nc" id="L1785">        return getFont2D().getMissingGlyphCode();</span>
    }

    /**
     * Returns the baseline appropriate for displaying this character.
     * &lt;p&gt;
     * Large fonts can support different writing systems, and each system can
     * use a different baseline.
     * The character argument determines the writing system to use. Clients
     * should not assume all characters use the same baseline.
     *
     * @param c a character used to identify the writing system
     * @return the baseline appropriate for the specified character.
     * @see LineMetrics#getBaselineOffsets
     * @see #ROMAN_BASELINE
     * @see #CENTER_BASELINE
     * @see #HANGING_BASELINE
     * @since 1.2
     */
    public byte getBaselineFor(char c) {
<span class="nc" id="L1805">        return getFont2D().getBaselineFor(c);</span>
    }

    /**
     * Returns a map of font attributes available in this
     * &lt;code&gt;Font&lt;/code&gt;.  Attributes include things like ligatures and
     * glyph substitution.
     * @return the attributes map of this &lt;code&gt;Font&lt;/code&gt;.
     */
    public Map&lt;TextAttribute,?&gt; getAttributes(){
<span class="nc" id="L1815">        return new AttributeMap(getAttributeValues());</span>
    }

    /**
     * Returns the keys of all the attributes supported by this
     * &lt;code&gt;Font&lt;/code&gt;.  These attributes can be used to derive other
     * fonts.
     * @return an array containing the keys of all the attributes
     *          supported by this &lt;code&gt;Font&lt;/code&gt;.
     * @since 1.2
     */
    public Attribute[] getAvailableAttributes() {
        // FONT is not supported by Font

<span class="nc" id="L1829">        Attribute attributes[] = {</span>
            TextAttribute.FAMILY,
            TextAttribute.WEIGHT,
            TextAttribute.WIDTH,
            TextAttribute.POSTURE,
            TextAttribute.SIZE,
            TextAttribute.TRANSFORM,
            TextAttribute.SUPERSCRIPT,
            TextAttribute.CHAR_REPLACEMENT,
            TextAttribute.FOREGROUND,
            TextAttribute.BACKGROUND,
            TextAttribute.UNDERLINE,
            TextAttribute.STRIKETHROUGH,
            TextAttribute.RUN_DIRECTION,
            TextAttribute.BIDI_EMBEDDING,
            TextAttribute.JUSTIFICATION,
            TextAttribute.INPUT_METHOD_HIGHLIGHT,
            TextAttribute.INPUT_METHOD_UNDERLINE,
            TextAttribute.SWAP_COLORS,
            TextAttribute.NUMERIC_SHAPING,
            TextAttribute.KERNING,
            TextAttribute.LIGATURES,
            TextAttribute.TRACKING,
        };

<span class="nc" id="L1854">        return attributes;</span>
    }

    /**
     * Creates a new &lt;code&gt;Font&lt;/code&gt; object by replicating this
     * &lt;code&gt;Font&lt;/code&gt; object and applying a new style and size.
     * @param style the style for the new &lt;code&gt;Font&lt;/code&gt;
     * @param size the size for the new &lt;code&gt;Font&lt;/code&gt;
     * @return a new &lt;code&gt;Font&lt;/code&gt; object.
     * @since 1.2
     */
    public Font deriveFont(int style, float size){
<span class="nc bnc" id="L1866" title="All 2 branches missed.">        if (values == null) {</span>
<span class="nc" id="L1867">            return new Font(name, style, size, createdFont, font2DHandle);</span>
        }
<span class="nc" id="L1869">        AttributeValues newValues = getAttributeValues().clone();</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">        int oldStyle = (this.style != style) ? this.style : -1;</span>
<span class="nc" id="L1871">        applyStyle(style, newValues);</span>
<span class="nc" id="L1872">        newValues.setSize(size);</span>
<span class="nc" id="L1873">        return new Font(newValues, null, oldStyle, createdFont, font2DHandle);</span>
    }

    /**
     * Creates a new &lt;code&gt;Font&lt;/code&gt; object by replicating this
     * &lt;code&gt;Font&lt;/code&gt; object and applying a new style and transform.
     * @param style the style for the new &lt;code&gt;Font&lt;/code&gt;
     * @param trans the &lt;code&gt;AffineTransform&lt;/code&gt; associated with the
     * new &lt;code&gt;Font&lt;/code&gt;
     * @return a new &lt;code&gt;Font&lt;/code&gt; object.
     * @throws IllegalArgumentException if &lt;code&gt;trans&lt;/code&gt; is
     *         &lt;code&gt;null&lt;/code&gt;
     * @since 1.2
     */
    public Font deriveFont(int style, AffineTransform trans){
<span class="nc" id="L1888">        AttributeValues newValues = getAttributeValues().clone();</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">        int oldStyle = (this.style != style) ? this.style : -1;</span>
<span class="nc" id="L1890">        applyStyle(style, newValues);</span>
<span class="nc" id="L1891">        applyTransform(trans, newValues);</span>
<span class="nc" id="L1892">        return new Font(newValues, null, oldStyle, createdFont, font2DHandle);</span>
    }

    /**
     * Creates a new &lt;code&gt;Font&lt;/code&gt; object by replicating the current
     * &lt;code&gt;Font&lt;/code&gt; object and applying a new size to it.
     * @param size the size for the new &lt;code&gt;Font&lt;/code&gt;.
     * @return a new &lt;code&gt;Font&lt;/code&gt; object.
     * @since 1.2
     */
    public Font deriveFont(float size){
<span class="nc bnc" id="L1903" title="All 2 branches missed.">        if (values == null) {</span>
<span class="nc" id="L1904">            return new Font(name, style, size, createdFont, font2DHandle);</span>
        }
<span class="nc" id="L1906">        AttributeValues newValues = getAttributeValues().clone();</span>
<span class="nc" id="L1907">        newValues.setSize(size);</span>
<span class="nc" id="L1908">        return new Font(newValues, null, -1, createdFont, font2DHandle);</span>
    }

    /**
     * Creates a new &lt;code&gt;Font&lt;/code&gt; object by replicating the current
     * &lt;code&gt;Font&lt;/code&gt; object and applying a new transform to it.
     * @param trans the &lt;code&gt;AffineTransform&lt;/code&gt; associated with the
     * new &lt;code&gt;Font&lt;/code&gt;
     * @return a new &lt;code&gt;Font&lt;/code&gt; object.
     * @throws IllegalArgumentException if &lt;code&gt;trans&lt;/code&gt; is
     *         &lt;code&gt;null&lt;/code&gt;
     * @since 1.2
     */
    public Font deriveFont(AffineTransform trans){
<span class="nc" id="L1922">        AttributeValues newValues = getAttributeValues().clone();</span>
<span class="nc" id="L1923">        applyTransform(trans, newValues);</span>
<span class="nc" id="L1924">        return new Font(newValues, null, -1, createdFont, font2DHandle);</span>
    }

    /**
     * Creates a new &lt;code&gt;Font&lt;/code&gt; object by replicating the current
     * &lt;code&gt;Font&lt;/code&gt; object and applying a new style to it.
     * @param style the style for the new &lt;code&gt;Font&lt;/code&gt;
     * @return a new &lt;code&gt;Font&lt;/code&gt; object.
     * @since 1.2
     */
    public Font deriveFont(int style){
<span class="nc bnc" id="L1935" title="All 2 branches missed.">        if (values == null) {</span>
<span class="nc" id="L1936">           return new Font(name, style, size, createdFont, font2DHandle);</span>
        }
<span class="nc" id="L1938">        AttributeValues newValues = getAttributeValues().clone();</span>
<span class="nc bnc" id="L1939" title="All 2 branches missed.">        int oldStyle = (this.style != style) ? this.style : -1;</span>
<span class="nc" id="L1940">        applyStyle(style, newValues);</span>
<span class="nc" id="L1941">        return new Font(newValues, null, oldStyle, createdFont, font2DHandle);</span>
    }

    /**
     * Creates a new &lt;code&gt;Font&lt;/code&gt; object by replicating the current
     * &lt;code&gt;Font&lt;/code&gt; object and applying a new set of font attributes
     * to it.
     *
     * @param attributes a map of attributes enabled for the new
     * &lt;code&gt;Font&lt;/code&gt;
     * @return a new &lt;code&gt;Font&lt;/code&gt; object.
     * @since 1.2
     */
    public Font deriveFont(Map&lt;? extends Attribute, ?&gt; attributes) {
<span class="nc bnc" id="L1955" title="All 2 branches missed.">        if (attributes == null) {</span>
<span class="nc" id="L1956">            return this;</span>
        }
<span class="nc" id="L1958">        AttributeValues newValues = getAttributeValues().clone();</span>
<span class="nc" id="L1959">        newValues.merge(attributes, RECOGNIZED_MASK);</span>

<span class="nc" id="L1961">        return new Font(newValues, name, style, createdFont, font2DHandle);</span>
    }

    /**
     * Checks if this &lt;code&gt;Font&lt;/code&gt; has a glyph for the specified
     * character.
     *
     * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; This method cannot handle &lt;a
     * href=&quot;../../java/lang/Character.html#supplementary&quot;&gt; supplementary
     * characters&lt;/a&gt;. To support all Unicode characters, including
     * supplementary characters, use the {@link #canDisplay(int)}
     * method or &lt;code&gt;canDisplayUpTo&lt;/code&gt; methods.
     *
     * @param c the character for which a glyph is needed
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Font&lt;/code&gt; has a glyph for this
     *          character; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.2
     */
    public boolean canDisplay(char c){
<span class="nc" id="L1980">        return getFont2D().canDisplay(c);</span>
    }

    /**
     * Checks if this &lt;code&gt;Font&lt;/code&gt; has a glyph for the specified
     * character.
     *
     * @param codePoint the character (Unicode code point) for which a glyph
     *        is needed.
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Font&lt;/code&gt; has a glyph for the
     *          character; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @throws IllegalArgumentException if the code point is not a valid Unicode
     *          code point.
     * @see Character#isValidCodePoint(int)
     * @since 1.5
     */
    public boolean canDisplay(int codePoint) {
<span class="nc bnc" id="L1997" title="All 2 branches missed.">        if (!Character.isValidCodePoint(codePoint)) {</span>
<span class="nc" id="L1998">            throw new IllegalArgumentException(&quot;invalid code point: &quot; +</span>
<span class="nc" id="L1999">                                               Integer.toHexString(codePoint));</span>
        }
<span class="nc" id="L2001">        return getFont2D().canDisplay(codePoint);</span>
    }

    /**
     * Indicates whether or not this &lt;code&gt;Font&lt;/code&gt; can display a
     * specified &lt;code&gt;String&lt;/code&gt;.  For strings with Unicode encoding,
     * it is important to know if a particular font can display the
     * string. This method returns an offset into the &lt;code&gt;String&lt;/code&gt;
     * &lt;code&gt;str&lt;/code&gt; which is the first character this
     * &lt;code&gt;Font&lt;/code&gt; cannot display without using the missing glyph
     * code. If the &lt;code&gt;Font&lt;/code&gt; can display all characters, -1 is
     * returned.
     * @param str a &lt;code&gt;String&lt;/code&gt; object
     * @return an offset into &lt;code&gt;str&lt;/code&gt; that points
     *          to the first character in &lt;code&gt;str&lt;/code&gt; that this
     *          &lt;code&gt;Font&lt;/code&gt; cannot display; or &lt;code&gt;-1&lt;/code&gt; if
     *          this &lt;code&gt;Font&lt;/code&gt; can display all characters in
     *          &lt;code&gt;str&lt;/code&gt;.
     * @since 1.2
     */
    public int canDisplayUpTo(String str) {
<span class="nc" id="L2022">        Font2D font2d = getFont2D();</span>
<span class="nc" id="L2023">        int len = str.length();</span>
<span class="nc bnc" id="L2024" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L2025">            char c = str.charAt(i);</span>
<span class="nc bnc" id="L2026" title="All 2 branches missed.">            if (font2d.canDisplay(c)) {</span>
<span class="nc" id="L2027">                continue;</span>
            }
<span class="nc bnc" id="L2029" title="All 2 branches missed.">            if (!Character.isHighSurrogate(c)) {</span>
<span class="nc" id="L2030">                return i;</span>
            }
<span class="nc bnc" id="L2032" title="All 2 branches missed.">            if (!font2d.canDisplay(str.codePointAt(i))) {</span>
<span class="nc" id="L2033">                return i;</span>
            }
<span class="nc" id="L2035">            i++;</span>
        }
<span class="nc" id="L2037">        return -1;</span>
    }

    /**
     * Indicates whether or not this &lt;code&gt;Font&lt;/code&gt; can display
     * the characters in the specified &lt;code&gt;text&lt;/code&gt;
     * starting at &lt;code&gt;start&lt;/code&gt; and ending at
     * &lt;code&gt;limit&lt;/code&gt;.  This method is a convenience overload.
     * @param text the specified array of &lt;code&gt;char&lt;/code&gt; values
     * @param start the specified starting offset (in
     *              &lt;code&gt;char&lt;/code&gt;s) into the specified array of
     *              &lt;code&gt;char&lt;/code&gt; values
     * @param limit the specified ending offset (in
     *              &lt;code&gt;char&lt;/code&gt;s) into the specified array of
     *              &lt;code&gt;char&lt;/code&gt; values
     * @return an offset into &lt;code&gt;text&lt;/code&gt; that points
     *          to the first character in &lt;code&gt;text&lt;/code&gt; that this
     *          &lt;code&gt;Font&lt;/code&gt; cannot display; or &lt;code&gt;-1&lt;/code&gt; if
     *          this &lt;code&gt;Font&lt;/code&gt; can display all characters in
     *          &lt;code&gt;text&lt;/code&gt;.
     * @since 1.2
     */
    public int canDisplayUpTo(char[] text, int start, int limit) {
<span class="nc" id="L2060">        Font2D font2d = getFont2D();</span>
<span class="nc bnc" id="L2061" title="All 2 branches missed.">        for (int i = start; i &lt; limit; i++) {</span>
<span class="nc" id="L2062">            char c = text[i];</span>
<span class="nc bnc" id="L2063" title="All 2 branches missed.">            if (font2d.canDisplay(c)) {</span>
<span class="nc" id="L2064">                continue;</span>
            }
<span class="nc bnc" id="L2066" title="All 2 branches missed.">            if (!Character.isHighSurrogate(c)) {</span>
<span class="nc" id="L2067">                return i;</span>
            }
<span class="nc bnc" id="L2069" title="All 2 branches missed.">            if (!font2d.canDisplay(Character.codePointAt(text, i, limit))) {</span>
<span class="nc" id="L2070">                return i;</span>
            }
<span class="nc" id="L2072">            i++;</span>
        }
<span class="nc" id="L2074">        return -1;</span>
    }

    /**
     * Indicates whether or not this &lt;code&gt;Font&lt;/code&gt; can display the
     * text specified by the &lt;code&gt;iter&lt;/code&gt; starting at
     * &lt;code&gt;start&lt;/code&gt; and ending at &lt;code&gt;limit&lt;/code&gt;.
     *
     * @param iter  a {@link CharacterIterator} object
     * @param start the specified starting offset into the specified
     *              &lt;code&gt;CharacterIterator&lt;/code&gt;.
     * @param limit the specified ending offset into the specified
     *              &lt;code&gt;CharacterIterator&lt;/code&gt;.
     * @return an offset into &lt;code&gt;iter&lt;/code&gt; that points
     *          to the first character in &lt;code&gt;iter&lt;/code&gt; that this
     *          &lt;code&gt;Font&lt;/code&gt; cannot display; or &lt;code&gt;-1&lt;/code&gt; if
     *          this &lt;code&gt;Font&lt;/code&gt; can display all characters in
     *          &lt;code&gt;iter&lt;/code&gt;.
     * @since 1.2
     */
    public int canDisplayUpTo(CharacterIterator iter, int start, int limit) {
<span class="nc" id="L2095">        Font2D font2d = getFont2D();</span>
<span class="nc" id="L2096">        char c = iter.setIndex(start);</span>
<span class="nc bnc" id="L2097" title="All 2 branches missed.">        for (int i = start; i &lt; limit; i++, c = iter.next()) {</span>
<span class="nc bnc" id="L2098" title="All 2 branches missed.">            if (font2d.canDisplay(c)) {</span>
<span class="nc" id="L2099">                continue;</span>
            }
<span class="nc bnc" id="L2101" title="All 2 branches missed.">            if (!Character.isHighSurrogate(c)) {</span>
<span class="nc" id="L2102">                return i;</span>
            }
<span class="nc" id="L2104">            char c2 = iter.next();</span>
            // c2 could be CharacterIterator.DONE which is not a low surrogate.
<span class="nc bnc" id="L2106" title="All 2 branches missed.">            if (!Character.isLowSurrogate(c2)) {</span>
<span class="nc" id="L2107">                return i;</span>
            }
<span class="nc bnc" id="L2109" title="All 2 branches missed.">            if (!font2d.canDisplay(Character.toCodePoint(c, c2))) {</span>
<span class="nc" id="L2110">                return i;</span>
            }
<span class="nc" id="L2112">            i++;</span>
        }
<span class="nc" id="L2114">        return -1;</span>
    }

    /**
     * Returns the italic angle of this &lt;code&gt;Font&lt;/code&gt;.  The italic angle
     * is the inverse slope of the caret which best matches the posture of this
     * &lt;code&gt;Font&lt;/code&gt;.
     * @see TextAttribute#POSTURE
     * @return the angle of the ITALIC style of this &lt;code&gt;Font&lt;/code&gt;.
     */
    public float getItalicAngle() {
<span class="nc" id="L2125">        return getItalicAngle(null);</span>
    }

    /* The FRC hints don't affect the value of the italic angle but
     * we need to pass them in to look up a strike.
     * If we can pass in ones already being used it can prevent an extra
     * strike from being allocated. Note that since italic angle is
     * a property of the font, the font transform is needed not the
     * device transform. Finally, this is private but the only caller of this
     * in the JDK - and the only likely caller - is in this same class.
     */
    private float getItalicAngle(FontRenderContext frc) {
        Object aa, fm;
<span class="nc bnc" id="L2138" title="All 2 branches missed.">        if (frc == null) {</span>
<span class="nc" id="L2139">            aa = RenderingHints.VALUE_TEXT_ANTIALIAS_OFF;</span>
<span class="nc" id="L2140">            fm = RenderingHints.VALUE_FRACTIONALMETRICS_OFF;</span>
        } else {
<span class="nc" id="L2142">            aa = frc.getAntiAliasingHint();</span>
<span class="nc" id="L2143">            fm = frc.getFractionalMetricsHint();</span>
        }
<span class="nc" id="L2145">        return getFont2D().getItalicAngle(this, identityTx, aa, fm);</span>
    }

    /**
     * Checks whether or not this &lt;code&gt;Font&lt;/code&gt; has uniform
     * line metrics.  A logical &lt;code&gt;Font&lt;/code&gt; might be a
     * composite font, which means that it is composed of different
     * physical fonts to cover different code ranges.  Each of these
     * fonts might have different &lt;code&gt;LineMetrics&lt;/code&gt;.  If the
     * logical &lt;code&gt;Font&lt;/code&gt; is a single
     * font then the metrics would be uniform.
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Font&lt;/code&gt; has
     * uniform line metrics; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean hasUniformLineMetrics() {
<span class="nc" id="L2160">        return false;   // REMIND always safe, but prevents caller optimize</span>
    }

    private transient SoftReference&lt;FontLineMetrics&gt; flmref;
    private FontLineMetrics defaultLineMetrics(FontRenderContext frc) {
<span class="nc" id="L2165">        FontLineMetrics flm = null;</span>
<span class="nc bnc" id="L2166" title="All 2 branches missed.">        if (flmref == null</span>
<span class="nc bnc" id="L2167" title="All 2 branches missed.">            || (flm = flmref.get()) == null</span>
<span class="nc bnc" id="L2168" title="All 2 branches missed.">            || !flm.frc.equals(frc)) {</span>

            /* The device transform in the frc is not used in obtaining line
             * metrics, although it probably should be: REMIND find why not?
             * The font transform is used but its applied in getFontMetrics, so
             * just pass identity here
             */
<span class="nc" id="L2175">            float [] metrics = new float[8];</span>
<span class="nc" id="L2176">            getFont2D().getFontMetrics(this, identityTx,</span>
<span class="nc" id="L2177">                                       frc.getAntiAliasingHint(),</span>
<span class="nc" id="L2178">                                       frc.getFractionalMetricsHint(),</span>
                                       metrics);
<span class="nc" id="L2180">            float ascent  = metrics[0];</span>
<span class="nc" id="L2181">            float descent = metrics[1];</span>
<span class="nc" id="L2182">            float leading = metrics[2];</span>
<span class="nc" id="L2183">            float ssOffset = 0;</span>
<span class="nc bnc" id="L2184" title="All 4 branches missed.">            if (values != null &amp;&amp; values.getSuperscript() != 0) {</span>
<span class="nc" id="L2185">                ssOffset = (float)getTransform().getTranslateY();</span>
<span class="nc" id="L2186">                ascent -= ssOffset;</span>
<span class="nc" id="L2187">                descent += ssOffset;</span>
            }
<span class="nc" id="L2189">            float height = ascent + descent + leading;</span>

<span class="nc" id="L2191">            int baselineIndex = 0; // need real index, assumes roman for everything</span>
            // need real baselines eventually
<span class="nc" id="L2193">            float[] baselineOffsets = { 0, (descent/2f - ascent) / 2f, -ascent };</span>

<span class="nc" id="L2195">            float strikethroughOffset = metrics[4];</span>
<span class="nc" id="L2196">            float strikethroughThickness = metrics[5];</span>

<span class="nc" id="L2198">            float underlineOffset = metrics[6];</span>
<span class="nc" id="L2199">            float underlineThickness = metrics[7];</span>

<span class="nc" id="L2201">            float italicAngle = getItalicAngle(frc);</span>

<span class="nc bnc" id="L2203" title="All 2 branches missed.">            if (isTransformed()) {</span>
<span class="nc" id="L2204">                AffineTransform ctx = values.getCharTransform(); // extract rotation</span>
<span class="nc bnc" id="L2205" title="All 2 branches missed.">                if (ctx != null) {</span>
<span class="nc" id="L2206">                    Point2D.Float pt = new Point2D.Float();</span>
<span class="nc" id="L2207">                    pt.setLocation(0, strikethroughOffset);</span>
<span class="nc" id="L2208">                    ctx.deltaTransform(pt, pt);</span>
<span class="nc" id="L2209">                    strikethroughOffset = pt.y;</span>
<span class="nc" id="L2210">                    pt.setLocation(0, strikethroughThickness);</span>
<span class="nc" id="L2211">                    ctx.deltaTransform(pt, pt);</span>
<span class="nc" id="L2212">                    strikethroughThickness = pt.y;</span>
<span class="nc" id="L2213">                    pt.setLocation(0, underlineOffset);</span>
<span class="nc" id="L2214">                    ctx.deltaTransform(pt, pt);</span>
<span class="nc" id="L2215">                    underlineOffset = pt.y;</span>
<span class="nc" id="L2216">                    pt.setLocation(0, underlineThickness);</span>
<span class="nc" id="L2217">                    ctx.deltaTransform(pt, pt);</span>
<span class="nc" id="L2218">                    underlineThickness = pt.y;</span>
                }
            }
<span class="nc" id="L2221">            strikethroughOffset += ssOffset;</span>
<span class="nc" id="L2222">            underlineOffset += ssOffset;</span>

<span class="nc" id="L2224">            CoreMetrics cm = new CoreMetrics(ascent, descent, leading, height,</span>
                                             baselineIndex, baselineOffsets,
                                             strikethroughOffset, strikethroughThickness,
                                             underlineOffset, underlineThickness,
                                             ssOffset, italicAngle);

<span class="nc" id="L2230">            flm = new FontLineMetrics(0, cm, frc);</span>
<span class="nc" id="L2231">            flmref = new SoftReference&lt;FontLineMetrics&gt;(flm);</span>
        }

<span class="nc" id="L2234">        return (FontLineMetrics)flm.clone();</span>
    }

    /**
     * Returns a {@link LineMetrics} object created with the specified
     * &lt;code&gt;String&lt;/code&gt; and {@link FontRenderContext}.
     * @param str the specified &lt;code&gt;String&lt;/code&gt;
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @return a &lt;code&gt;LineMetrics&lt;/code&gt; object created with the
     * specified &lt;code&gt;String&lt;/code&gt; and {@link FontRenderContext}.
     */
    public LineMetrics getLineMetrics( String str, FontRenderContext frc) {
<span class="nc" id="L2246">        FontLineMetrics flm = defaultLineMetrics(frc);</span>
<span class="nc" id="L2247">        flm.numchars = str.length();</span>
<span class="nc" id="L2248">        return flm;</span>
    }

    /**
     * Returns a &lt;code&gt;LineMetrics&lt;/code&gt; object created with the
     * specified arguments.
     * @param str the specified &lt;code&gt;String&lt;/code&gt;
     * @param beginIndex the initial offset of &lt;code&gt;str&lt;/code&gt;
     * @param limit the end offset of &lt;code&gt;str&lt;/code&gt;
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @return a &lt;code&gt;LineMetrics&lt;/code&gt; object created with the
     * specified arguments.
     */
    public LineMetrics getLineMetrics( String str,
                                    int beginIndex, int limit,
                                    FontRenderContext frc) {
<span class="nc" id="L2264">        FontLineMetrics flm = defaultLineMetrics(frc);</span>
<span class="nc" id="L2265">        int numChars = limit - beginIndex;</span>
<span class="nc bnc" id="L2266" title="All 2 branches missed.">        flm.numchars = (numChars &lt; 0)? 0: numChars;</span>
<span class="nc" id="L2267">        return flm;</span>
    }

    /**
     * Returns a &lt;code&gt;LineMetrics&lt;/code&gt; object created with the
     * specified arguments.
     * @param chars an array of characters
     * @param beginIndex the initial offset of &lt;code&gt;chars&lt;/code&gt;
     * @param limit the end offset of &lt;code&gt;chars&lt;/code&gt;
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @return a &lt;code&gt;LineMetrics&lt;/code&gt; object created with the
     * specified arguments.
     */
    public LineMetrics getLineMetrics(char [] chars,
                                    int beginIndex, int limit,
                                    FontRenderContext frc) {
<span class="nc" id="L2283">        FontLineMetrics flm = defaultLineMetrics(frc);</span>
<span class="nc" id="L2284">        int numChars = limit - beginIndex;</span>
<span class="nc bnc" id="L2285" title="All 2 branches missed.">        flm.numchars = (numChars &lt; 0)? 0: numChars;</span>
<span class="nc" id="L2286">        return flm;</span>
    }

    /**
     * Returns a &lt;code&gt;LineMetrics&lt;/code&gt; object created with the
     * specified arguments.
     * @param ci the specified &lt;code&gt;CharacterIterator&lt;/code&gt;
     * @param beginIndex the initial offset in &lt;code&gt;ci&lt;/code&gt;
     * @param limit the end offset of &lt;code&gt;ci&lt;/code&gt;
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @return a &lt;code&gt;LineMetrics&lt;/code&gt; object created with the
     * specified arguments.
     */
    public LineMetrics getLineMetrics(CharacterIterator ci,
                                    int beginIndex, int limit,
                                    FontRenderContext frc) {
<span class="nc" id="L2302">        FontLineMetrics flm = defaultLineMetrics(frc);</span>
<span class="nc" id="L2303">        int numChars = limit - beginIndex;</span>
<span class="nc bnc" id="L2304" title="All 2 branches missed.">        flm.numchars = (numChars &lt; 0)? 0: numChars;</span>
<span class="nc" id="L2305">        return flm;</span>
    }

    /**
     * Returns the logical bounds of the specified &lt;code&gt;String&lt;/code&gt; in
     * the specified &lt;code&gt;FontRenderContext&lt;/code&gt;.  The logical bounds
     * contains the origin, ascent, advance, and height, which includes
     * the leading.  The logical bounds does not always enclose all the
     * text.  For example, in some languages and in some fonts, accent
     * marks can be positioned above the ascent or below the descent.
     * To obtain a visual bounding box, which encloses all the text,
     * use the {@link TextLayout#getBounds() getBounds} method of
     * &lt;code&gt;TextLayout&lt;/code&gt;.
     * &lt;p&gt;Note: The returned bounds is in baseline-relative coordinates
     * (see {@link java.awt.Font class notes}).
     * @param str the specified &lt;code&gt;String&lt;/code&gt;
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @return a {@link Rectangle2D} that is the bounding box of the
     * specified &lt;code&gt;String&lt;/code&gt; in the specified
     * &lt;code&gt;FontRenderContext&lt;/code&gt;.
     * @see FontRenderContext
     * @see Font#createGlyphVector
     * @since 1.2
     */
    public Rectangle2D getStringBounds( String str, FontRenderContext frc) {
<span class="nc" id="L2330">        char[] array = str.toCharArray();</span>
<span class="nc" id="L2331">        return getStringBounds(array, 0, array.length, frc);</span>
    }

   /**
     * Returns the logical bounds of the specified &lt;code&gt;String&lt;/code&gt; in
     * the specified &lt;code&gt;FontRenderContext&lt;/code&gt;.  The logical bounds
     * contains the origin, ascent, advance, and height, which includes
     * the leading.  The logical bounds does not always enclose all the
     * text.  For example, in some languages and in some fonts, accent
     * marks can be positioned above the ascent or below the descent.
     * To obtain a visual bounding box, which encloses all the text,
     * use the {@link TextLayout#getBounds() getBounds} method of
     * &lt;code&gt;TextLayout&lt;/code&gt;.
     * &lt;p&gt;Note: The returned bounds is in baseline-relative coordinates
     * (see {@link java.awt.Font class notes}).
     * @param str the specified &lt;code&gt;String&lt;/code&gt;
     * @param beginIndex the initial offset of &lt;code&gt;str&lt;/code&gt;
     * @param limit the end offset of &lt;code&gt;str&lt;/code&gt;
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @return a &lt;code&gt;Rectangle2D&lt;/code&gt; that is the bounding box of the
     * specified &lt;code&gt;String&lt;/code&gt; in the specified
     * &lt;code&gt;FontRenderContext&lt;/code&gt;.
     * @throws IndexOutOfBoundsException if &lt;code&gt;beginIndex&lt;/code&gt; is
     *         less than zero, or &lt;code&gt;limit&lt;/code&gt; is greater than the
     *         length of &lt;code&gt;str&lt;/code&gt;, or &lt;code&gt;beginIndex&lt;/code&gt;
     *         is greater than &lt;code&gt;limit&lt;/code&gt;.
     * @see FontRenderContext
     * @see Font#createGlyphVector
     * @since 1.2
     */
    public Rectangle2D getStringBounds( String str,
                                    int beginIndex, int limit,
                                        FontRenderContext frc) {
<span class="nc" id="L2364">        String substr = str.substring(beginIndex, limit);</span>
<span class="nc" id="L2365">        return getStringBounds(substr, frc);</span>
    }

   /**
     * Returns the logical bounds of the specified array of characters
     * in the specified &lt;code&gt;FontRenderContext&lt;/code&gt;.  The logical
     * bounds contains the origin, ascent, advance, and height, which
     * includes the leading.  The logical bounds does not always enclose
     * all the text.  For example, in some languages and in some fonts,
     * accent marks can be positioned above the ascent or below the
     * descent.  To obtain a visual bounding box, which encloses all the
     * text, use the {@link TextLayout#getBounds() getBounds} method of
     * &lt;code&gt;TextLayout&lt;/code&gt;.
     * &lt;p&gt;Note: The returned bounds is in baseline-relative coordinates
     * (see {@link java.awt.Font class notes}).
     * @param chars an array of characters
     * @param beginIndex the initial offset in the array of
     * characters
     * @param limit the end offset in the array of characters
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @return a &lt;code&gt;Rectangle2D&lt;/code&gt; that is the bounding box of the
     * specified array of characters in the specified
     * &lt;code&gt;FontRenderContext&lt;/code&gt;.
     * @throws IndexOutOfBoundsException if &lt;code&gt;beginIndex&lt;/code&gt; is
     *         less than zero, or &lt;code&gt;limit&lt;/code&gt; is greater than the
     *         length of &lt;code&gt;chars&lt;/code&gt;, or &lt;code&gt;beginIndex&lt;/code&gt;
     *         is greater than &lt;code&gt;limit&lt;/code&gt;.
     * @see FontRenderContext
     * @see Font#createGlyphVector
     * @since 1.2
     */
    public Rectangle2D getStringBounds(char [] chars,
                                    int beginIndex, int limit,
                                       FontRenderContext frc) {
<span class="nc bnc" id="L2399" title="All 2 branches missed.">        if (beginIndex &lt; 0) {</span>
<span class="nc" id="L2400">            throw new IndexOutOfBoundsException(&quot;beginIndex: &quot; + beginIndex);</span>
        }
<span class="nc bnc" id="L2402" title="All 2 branches missed.">        if (limit &gt; chars.length) {</span>
<span class="nc" id="L2403">            throw new IndexOutOfBoundsException(&quot;limit: &quot; + limit);</span>
        }
<span class="nc bnc" id="L2405" title="All 2 branches missed.">        if (beginIndex &gt; limit) {</span>
<span class="nc" id="L2406">            throw new IndexOutOfBoundsException(&quot;range length: &quot; +</span>
                                                (limit - beginIndex));
        }

        // this code should be in textlayout
        // quick check for simple text, assume GV ok to use if simple

<span class="nc bnc" id="L2413" title="All 2 branches missed.">        boolean simple = values == null ||</span>
<span class="nc bnc" id="L2414" title="All 4 branches missed.">            (values.getKerning() == 0 &amp;&amp; values.getLigatures() == 0 &amp;&amp;</span>
<span class="nc bnc" id="L2415" title="All 2 branches missed.">              values.getBaselineTransform() == null);</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">        if (simple) {</span>
<span class="nc bnc" id="L2417" title="All 2 branches missed.">            simple = ! FontUtilities.isComplexText(chars, beginIndex, limit);</span>
        }

<span class="nc bnc" id="L2420" title="All 2 branches missed.">        if (simple) {</span>
<span class="nc" id="L2421">            GlyphVector gv = new StandardGlyphVector(this, chars, beginIndex,</span>
                                                     limit - beginIndex, frc);
<span class="nc" id="L2423">            return gv.getLogicalBounds();</span>
        } else {
            // need char array constructor on textlayout
<span class="nc" id="L2426">            String str = new String(chars, beginIndex, limit - beginIndex);</span>
<span class="nc" id="L2427">            TextLayout tl = new TextLayout(str, this, frc);</span>
<span class="nc" id="L2428">            return new Rectangle2D.Float(0, -tl.getAscent(), tl.getAdvance(),</span>
<span class="nc" id="L2429">                                         tl.getAscent() + tl.getDescent() +</span>
<span class="nc" id="L2430">                                         tl.getLeading());</span>
        }
    }

   /**
     * Returns the logical bounds of the characters indexed in the
     * specified {@link CharacterIterator} in the
     * specified &lt;code&gt;FontRenderContext&lt;/code&gt;.  The logical bounds
     * contains the origin, ascent, advance, and height, which includes
     * the leading.  The logical bounds does not always enclose all the
     * text.  For example, in some languages and in some fonts, accent
     * marks can be positioned above the ascent or below the descent.
     * To obtain a visual bounding box, which encloses all the text,
     * use the {@link TextLayout#getBounds() getBounds} method of
     * &lt;code&gt;TextLayout&lt;/code&gt;.
     * &lt;p&gt;Note: The returned bounds is in baseline-relative coordinates
     * (see {@link java.awt.Font class notes}).
     * @param ci the specified &lt;code&gt;CharacterIterator&lt;/code&gt;
     * @param beginIndex the initial offset in &lt;code&gt;ci&lt;/code&gt;
     * @param limit the end offset in &lt;code&gt;ci&lt;/code&gt;
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @return a &lt;code&gt;Rectangle2D&lt;/code&gt; that is the bounding box of the
     * characters indexed in the specified &lt;code&gt;CharacterIterator&lt;/code&gt;
     * in the specified &lt;code&gt;FontRenderContext&lt;/code&gt;.
     * @see FontRenderContext
     * @see Font#createGlyphVector
     * @since 1.2
     * @throws IndexOutOfBoundsException if &lt;code&gt;beginIndex&lt;/code&gt; is
     *         less than the start index of &lt;code&gt;ci&lt;/code&gt;, or
     *         &lt;code&gt;limit&lt;/code&gt; is greater than the end index of
     *         &lt;code&gt;ci&lt;/code&gt;, or &lt;code&gt;beginIndex&lt;/code&gt; is greater
     *         than &lt;code&gt;limit&lt;/code&gt;
     */
    public Rectangle2D getStringBounds(CharacterIterator ci,
                                    int beginIndex, int limit,
                                       FontRenderContext frc) {
<span class="nc" id="L2466">        int start = ci.getBeginIndex();</span>
<span class="nc" id="L2467">        int end = ci.getEndIndex();</span>

<span class="nc bnc" id="L2469" title="All 2 branches missed.">        if (beginIndex &lt; start) {</span>
<span class="nc" id="L2470">            throw new IndexOutOfBoundsException(&quot;beginIndex: &quot; + beginIndex);</span>
        }
<span class="nc bnc" id="L2472" title="All 2 branches missed.">        if (limit &gt; end) {</span>
<span class="nc" id="L2473">            throw new IndexOutOfBoundsException(&quot;limit: &quot; + limit);</span>
        }
<span class="nc bnc" id="L2475" title="All 2 branches missed.">        if (beginIndex &gt; limit) {</span>
<span class="nc" id="L2476">            throw new IndexOutOfBoundsException(&quot;range length: &quot; +</span>
                                                (limit - beginIndex));
        }

<span class="nc" id="L2480">        char[]  arr = new char[limit - beginIndex];</span>

<span class="nc" id="L2482">        ci.setIndex(beginIndex);</span>
<span class="nc bnc" id="L2483" title="All 2 branches missed.">        for(int idx = 0; idx &lt; arr.length; idx++) {</span>
<span class="nc" id="L2484">            arr[idx] = ci.current();</span>
<span class="nc" id="L2485">            ci.next();</span>
        }

<span class="nc" id="L2488">        return getStringBounds(arr,0,arr.length,frc);</span>
    }

    /**
     * Returns the bounds for the character with the maximum
     * bounds as defined in the specified &lt;code&gt;FontRenderContext&lt;/code&gt;.
     * &lt;p&gt;Note: The returned bounds is in baseline-relative coordinates
     * (see {@link java.awt.Font class notes}).
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @return a &lt;code&gt;Rectangle2D&lt;/code&gt; that is the bounding box
     * for the character with the maximum bounds.
     */
    public Rectangle2D getMaxCharBounds(FontRenderContext frc) {
<span class="nc" id="L2501">        float [] metrics = new float[4];</span>

<span class="nc" id="L2503">        getFont2D().getFontMetrics(this, frc, metrics);</span>

<span class="nc" id="L2505">        return new Rectangle2D.Float(0, -metrics[0],</span>
                                metrics[3],
                                metrics[0] + metrics[1] + metrics[2]);
    }

    /**
     * Creates a {@link java.awt.font.GlyphVector GlyphVector} by
     * mapping characters to glyphs one-to-one based on the
     * Unicode cmap in this &lt;code&gt;Font&lt;/code&gt;.  This method does no other
     * processing besides the mapping of glyphs to characters.  This
     * means that this method is not useful for some scripts, such
     * as Arabic, Hebrew, Thai, and Indic, that require reordering,
     * shaping, or ligature substitution.
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @param str the specified &lt;code&gt;String&lt;/code&gt;
     * @return a new &lt;code&gt;GlyphVector&lt;/code&gt; created with the
     * specified &lt;code&gt;String&lt;/code&gt; and the specified
     * &lt;code&gt;FontRenderContext&lt;/code&gt;.
     */
    public GlyphVector createGlyphVector(FontRenderContext frc, String str)
    {
<span class="nc" id="L2526">        return (GlyphVector)new StandardGlyphVector(this, str, frc);</span>
    }

    /**
     * Creates a {@link java.awt.font.GlyphVector GlyphVector} by
     * mapping characters to glyphs one-to-one based on the
     * Unicode cmap in this &lt;code&gt;Font&lt;/code&gt;.  This method does no other
     * processing besides the mapping of glyphs to characters.  This
     * means that this method is not useful for some scripts, such
     * as Arabic, Hebrew, Thai, and Indic, that require reordering,
     * shaping, or ligature substitution.
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @param chars the specified array of characters
     * @return a new &lt;code&gt;GlyphVector&lt;/code&gt; created with the
     * specified array of characters and the specified
     * &lt;code&gt;FontRenderContext&lt;/code&gt;.
     */
    public GlyphVector createGlyphVector(FontRenderContext frc, char[] chars)
    {
<span class="nc" id="L2545">        return (GlyphVector)new StandardGlyphVector(this, chars, frc);</span>
    }

    /**
     * Creates a {@link java.awt.font.GlyphVector GlyphVector} by
     * mapping the specified characters to glyphs one-to-one based on the
     * Unicode cmap in this &lt;code&gt;Font&lt;/code&gt;.  This method does no other
     * processing besides the mapping of glyphs to characters.  This
     * means that this method is not useful for some scripts, such
     * as Arabic, Hebrew, Thai, and Indic, that require reordering,
     * shaping, or ligature substitution.
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @param ci the specified &lt;code&gt;CharacterIterator&lt;/code&gt;
     * @return a new &lt;code&gt;GlyphVector&lt;/code&gt; created with the
     * specified &lt;code&gt;CharacterIterator&lt;/code&gt; and the specified
     * &lt;code&gt;FontRenderContext&lt;/code&gt;.
     */
    public GlyphVector createGlyphVector(   FontRenderContext frc,
                                            CharacterIterator ci)
    {
<span class="nc" id="L2565">        return (GlyphVector)new StandardGlyphVector(this, ci, frc);</span>
    }

    /**
     * Creates a {@link java.awt.font.GlyphVector GlyphVector} by
     * mapping characters to glyphs one-to-one based on the
     * Unicode cmap in this &lt;code&gt;Font&lt;/code&gt;.  This method does no other
     * processing besides the mapping of glyphs to characters.  This
     * means that this method is not useful for some scripts, such
     * as Arabic, Hebrew, Thai, and Indic, that require reordering,
     * shaping, or ligature substitution.
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @param glyphCodes the specified integer array
     * @return a new &lt;code&gt;GlyphVector&lt;/code&gt; created with the
     * specified integer array and the specified
     * &lt;code&gt;FontRenderContext&lt;/code&gt;.
     */
    public GlyphVector createGlyphVector(   FontRenderContext frc,
                                            int [] glyphCodes)
    {
<span class="nc" id="L2585">        return (GlyphVector)new StandardGlyphVector(this, glyphCodes, frc);</span>
    }

    /**
     * Returns a new &lt;code&gt;GlyphVector&lt;/code&gt; object, performing full
     * layout of the text if possible.  Full layout is required for
     * complex text, such as Arabic or Hindi.  Support for different
     * scripts depends on the font and implementation.
     * &lt;p&gt;
     * Layout requires bidi analysis, as performed by
     * &lt;code&gt;Bidi&lt;/code&gt;, and should only be performed on text that
     * has a uniform direction.  The direction is indicated in the
     * flags parameter,by using LAYOUT_RIGHT_TO_LEFT to indicate a
     * right-to-left (Arabic and Hebrew) run direction, or
     * LAYOUT_LEFT_TO_RIGHT to indicate a left-to-right (English)
     * run direction.
     * &lt;p&gt;
     * In addition, some operations, such as Arabic shaping, require
     * context, so that the characters at the start and limit can have
     * the proper shapes.  Sometimes the data in the buffer outside
     * the provided range does not have valid data.  The values
     * LAYOUT_NO_START_CONTEXT and LAYOUT_NO_LIMIT_CONTEXT can be
     * added to the flags parameter to indicate that the text before
     * start, or after limit, respectively, should not be examined
     * for context.
     * &lt;p&gt;
     * All other values for the flags parameter are reserved.
     *
     * @param frc the specified &lt;code&gt;FontRenderContext&lt;/code&gt;
     * @param text the text to layout
     * @param start the start of the text to use for the &lt;code&gt;GlyphVector&lt;/code&gt;
     * @param limit the limit of the text to use for the &lt;code&gt;GlyphVector&lt;/code&gt;
     * @param flags control flags as described above
     * @return a new &lt;code&gt;GlyphVector&lt;/code&gt; representing the text between
     * start and limit, with glyphs chosen and positioned so as to best represent
     * the text
     * @throws ArrayIndexOutOfBoundsException if start or limit is
     * out of bounds
     * @see java.text.Bidi
     * @see #LAYOUT_LEFT_TO_RIGHT
     * @see #LAYOUT_RIGHT_TO_LEFT
     * @see #LAYOUT_NO_START_CONTEXT
     * @see #LAYOUT_NO_LIMIT_CONTEXT
     * @since 1.4
     */
    public GlyphVector layoutGlyphVector(FontRenderContext frc,
                                         char[] text,
                                         int start,
                                         int limit,
                                         int flags) {

<span class="nc" id="L2636">        GlyphLayout gl = GlyphLayout.get(null); // !!! no custom layout engines</span>
<span class="nc" id="L2637">        StandardGlyphVector gv = gl.layout(this, frc, text,</span>
                                           start, limit-start, flags, null);
<span class="nc" id="L2639">        GlyphLayout.done(gl);</span>
<span class="nc" id="L2640">        return gv;</span>
    }

    /**
     * A flag to layoutGlyphVector indicating that text is left-to-right as
     * determined by Bidi analysis.
     */
    public static final int LAYOUT_LEFT_TO_RIGHT = 0;

    /**
     * A flag to layoutGlyphVector indicating that text is right-to-left as
     * determined by Bidi analysis.
     */
    public static final int LAYOUT_RIGHT_TO_LEFT = 1;

    /**
     * A flag to layoutGlyphVector indicating that text in the char array
     * before the indicated start should not be examined.
     */
    public static final int LAYOUT_NO_START_CONTEXT = 2;

    /**
     * A flag to layoutGlyphVector indicating that text in the char array
     * after the indicated limit should not be examined.
     */
    public static final int LAYOUT_NO_LIMIT_CONTEXT = 4;


    private static void applyTransform(AffineTransform trans, AttributeValues values) {
<span class="nc bnc" id="L2669" title="All 2 branches missed.">        if (trans == null) {</span>
<span class="nc" id="L2670">            throw new IllegalArgumentException(&quot;transform must not be null&quot;);</span>
        }
<span class="nc" id="L2672">        values.setTransform(trans);</span>
<span class="nc" id="L2673">    }</span>

    private static void applyStyle(int style, AttributeValues values) {
        // WEIGHT_BOLD, WEIGHT_REGULAR
<span class="nc bnc" id="L2677" title="All 2 branches missed.">        values.setWeight((style &amp; BOLD) != 0 ? 2f : 1f);</span>
        // POSTURE_OBLIQUE, POSTURE_REGULAR
<span class="nc bnc" id="L2679" title="All 2 branches missed.">        values.setPosture((style &amp; ITALIC) != 0 ? .2f : 0f);</span>
<span class="nc" id="L2680">    }</span>

    /*
     * Initialize JNI field and method IDs
     */
    private static native void initIDs();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>