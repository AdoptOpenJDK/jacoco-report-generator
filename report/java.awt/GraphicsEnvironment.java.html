<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>GraphicsEnvironment.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">GraphicsEnvironment.java</span></div><h1>GraphicsEnvironment.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package java.awt;

import java.awt.image.BufferedImage;
import java.security.AccessController;
import java.util.Locale;

import sun.font.FontManager;
import sun.font.FontManagerFactory;
import sun.java2d.HeadlessGraphicsEnvironment;
import sun.java2d.SunGraphicsEnvironment;
import sun.security.action.GetPropertyAction;

/**
 *
 * The &lt;code&gt;GraphicsEnvironment&lt;/code&gt; class describes the collection
 * of {@link GraphicsDevice} objects and {@link java.awt.Font} objects
 * available to a Java(tm) application on a particular platform.
 * The resources in this &lt;code&gt;GraphicsEnvironment&lt;/code&gt; might be local
 * or on a remote machine.  &lt;code&gt;GraphicsDevice&lt;/code&gt; objects can be
 * screens, printers or image buffers and are the destination of
 * {@link Graphics2D} drawing methods.  Each &lt;code&gt;GraphicsDevice&lt;/code&gt;
 * has a number of {@link GraphicsConfiguration} objects associated with
 * it.  These objects specify the different configurations in which the
 * &lt;code&gt;GraphicsDevice&lt;/code&gt; can be used.
 * @see GraphicsDevice
 * @see GraphicsConfiguration
 */

public abstract class GraphicsEnvironment {
    private static GraphicsEnvironment localEnv;

    /**
     * The headless state of the Toolkit and GraphicsEnvironment
     */
    private static Boolean headless;

    /**
     * The headless state assumed by default
     */
    private static Boolean defaultHeadless;

    /**
     * This is an abstract class and cannot be instantiated directly.
     * Instances must be obtained from a suitable factory or query method.
     */
<span class="fc" id="L72">    protected GraphicsEnvironment() {</span>
<span class="fc" id="L73">    }</span>

    /**
     * Returns the local &lt;code&gt;GraphicsEnvironment&lt;/code&gt;.
     * @return the local &lt;code&gt;GraphicsEnvironment&lt;/code&gt;
     */
    public static synchronized GraphicsEnvironment getLocalGraphicsEnvironment() {
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (localEnv == null) {</span>
<span class="fc" id="L81">            localEnv = createGE();</span>
        }

<span class="fc" id="L84">        return localEnv;</span>
    }

    /**
     * Creates and returns the GraphicsEnvironment, according to the
     * system property 'java.awt.graphicsenv'.
     *
     * @return the graphics environment
     */
    private static GraphicsEnvironment createGE() {
        GraphicsEnvironment ge;
<span class="fc" id="L95">        String nm = AccessController.doPrivileged(new GetPropertyAction(&quot;java.awt.graphicsenv&quot;, null));</span>
        try {
//          long t0 = System.currentTimeMillis();
            Class&lt;GraphicsEnvironment&gt; geCls;
            try {
                // First we try if the bootclassloader finds the requested
                // class. This way we can avoid to run in a privileged block.
<span class="fc" id="L102">                geCls = (Class&lt;GraphicsEnvironment&gt;)Class.forName(nm);</span>
<span class="nc" id="L103">            } catch (ClassNotFoundException ex) {</span>
                // If the bootclassloader fails, we try again with the
                // application classloader.
<span class="nc" id="L106">                ClassLoader cl = ClassLoader.getSystemClassLoader();</span>
<span class="nc" id="L107">                geCls = (Class&lt;GraphicsEnvironment&gt;)Class.forName(nm, true, cl);</span>
<span class="fc" id="L108">            }</span>
<span class="fc" id="L109">            ge = geCls.newInstance();</span>
//          long t1 = System.currentTimeMillis();
//          System.out.println(&quot;GE creation took &quot; + (t1-t0)+ &quot;ms.&quot;);
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">            if (isHeadless()) {</span>
<span class="fc" id="L113">                ge = new HeadlessGraphicsEnvironment(ge);</span>
            }
<span class="nc" id="L115">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L116">            throw new Error(&quot;Could not find class: &quot;+nm);</span>
<span class="nc" id="L117">        } catch (InstantiationException e) {</span>
<span class="nc" id="L118">            throw new Error(&quot;Could not instantiate Graphics Environment: &quot;</span>
                            + nm);
<span class="nc" id="L120">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L121">            throw new Error (&quot;Could not access Graphics Environment: &quot;</span>
                             + nm);
<span class="fc" id="L123">        }</span>
<span class="fc" id="L124">        return ge;</span>
    }

    /**
     * Tests whether or not a display, keyboard, and mouse can be
     * supported in this environment.  If this method returns true,
     * a HeadlessException is thrown from areas of the Toolkit
     * and GraphicsEnvironment that are dependent on a display,
     * keyboard, or mouse.
     * @return &lt;code&gt;true&lt;/code&gt; if this environment cannot support
     * a display, keyboard, and mouse; &lt;code&gt;false&lt;/code&gt;
     * otherwise
     * @see java.awt.HeadlessException
     * @since 1.4
     */
    public static boolean isHeadless() {
<span class="fc" id="L140">        return getHeadlessProperty();</span>
    }

    /**
     * @return warning message if headless state is assumed by default;
     * null otherwise
     * @since 1.5
     */
    static String getHeadlessMessage() {
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (headless == null) {</span>
<span class="nc" id="L150">            getHeadlessProperty(); // initialize the values</span>
        }
<span class="nc bnc" id="L152" title="All 2 branches missed.">        return defaultHeadless != Boolean.TRUE ? null :</span>
            &quot;\nNo X11 DISPLAY variable was set, &quot; +
            &quot;but this program performed an operation which requires it.&quot;;
    }

    /**
     * @return the value of the property &quot;java.awt.headless&quot;
     * @since 1.4
     */
    private static boolean getHeadlessProperty() {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (headless == null) {</span>
<span class="fc" id="L163">            java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L164">            new java.security.PrivilegedAction&lt;Object&gt;() {</span>
                public Object run() {
<span class="fc" id="L166">                    String nm = System.getProperty(&quot;java.awt.headless&quot;);</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">                    if (nm == null) {</span>
                        /* No need to ask for DISPLAY when run in a browser */
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">                        if (System.getProperty(&quot;javaplugin.version&quot;) != null) {</span>
<span class="nc" id="L171">                            headless = defaultHeadless = Boolean.FALSE;</span>
                        } else {
<span class="fc" id="L173">                            String osName = System.getProperty(&quot;os.name&quot;);</span>
<span class="pc bpc" id="L174" title="3 of 4 branches missed.">                            if (osName.contains(&quot;OS X&quot;) &amp;&amp; &quot;sun.awt.HToolkit&quot;.equals(</span>
<span class="nc" id="L175">                                    System.getProperty(&quot;awt.toolkit&quot;)))</span>
                            {
<span class="nc" id="L177">                                headless = defaultHeadless = Boolean.TRUE;</span>
                            } else {
<span class="fc" id="L179">                                headless = defaultHeadless =</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">                                    Boolean.valueOf((&quot;Linux&quot;.equals(osName) ||</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                                                     &quot;SunOS&quot;.equals(osName) ||</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                                                     &quot;FreeBSD&quot;.equals(osName) ||</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">                                                     &quot;NetBSD&quot;.equals(osName) ||</span>
<span class="pc bnc" id="L184" title="All 2 branches missed.">                                                     &quot;OpenBSD&quot;.equals(osName)) &amp;&amp;</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">                                                     (System.getenv(&quot;DISPLAY&quot;) == null));</span>
                            }
<span class="fc" id="L187">                        }</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                    } else if (nm.equals(&quot;true&quot;)) {</span>
<span class="fc" id="L189">                        headless = Boolean.TRUE;</span>
                    } else {
<span class="nc" id="L191">                        headless = Boolean.FALSE;</span>
                    }
<span class="fc" id="L193">                    return null;</span>
                }
                }
            );
        }
<span class="fc" id="L198">        return headless.booleanValue();</span>
    }

    /**
     * Check for headless state and throw HeadlessException if headless
     * @since 1.4
     */
    static void checkHeadless() throws HeadlessException {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (isHeadless()) {</span>
<span class="nc" id="L207">            throw new HeadlessException();</span>
        }
<span class="nc" id="L209">    }</span>

    /**
     * Returns whether or not a display, keyboard, and mouse can be
     * supported in this graphics environment.  If this returns true,
     * &lt;code&gt;HeadlessException&lt;/code&gt; will be thrown from areas of the
     * graphics environment that are dependent on a display, keyboard, or
     * mouse.
     * @return &lt;code&gt;true&lt;/code&gt; if a display, keyboard, and mouse
     * can be supported in this environment; &lt;code&gt;false&lt;/code&gt;
     * otherwise
     * @see java.awt.HeadlessException
     * @see #isHeadless
     * @since 1.4
     */
    public boolean isHeadlessInstance() {
        // By default (local graphics environment), simply check the
        // headless property.
<span class="nc" id="L227">        return getHeadlessProperty();</span>
    }

    /**
     * Returns an array of all of the screen &lt;code&gt;GraphicsDevice&lt;/code&gt;
     * objects.
     * @return an array containing all the &lt;code&gt;GraphicsDevice&lt;/code&gt;
     * objects that represent screen devices
     * @exception HeadlessException if isHeadless() returns true
     * @see #isHeadless()
     */
    public abstract GraphicsDevice[] getScreenDevices()
        throws HeadlessException;

    /**
     * Returns the default screen &lt;code&gt;GraphicsDevice&lt;/code&gt;.
     * @return the &lt;code&gt;GraphicsDevice&lt;/code&gt; that represents the
     * default screen device
     * @exception HeadlessException if isHeadless() returns true
     * @see #isHeadless()
     */
    public abstract GraphicsDevice getDefaultScreenDevice()
        throws HeadlessException;

    /**
     * Returns a &lt;code&gt;Graphics2D&lt;/code&gt; object for rendering into the
     * specified {@link BufferedImage}.
     * @param img the specified &lt;code&gt;BufferedImage&lt;/code&gt;
     * @return a &lt;code&gt;Graphics2D&lt;/code&gt; to be used for rendering into
     * the specified &lt;code&gt;BufferedImage&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;img&lt;/code&gt; is null
     */
    public abstract Graphics2D createGraphics(BufferedImage img);

    /**
     * Returns an array containing a one-point size instance of all fonts
     * available in this &lt;code&gt;GraphicsEnvironment&lt;/code&gt;.  Typical usage
     * would be to allow a user to select a particular font.  Then, the
     * application can size the font and set various font attributes by
     * calling the &lt;code&gt;deriveFont&lt;/code&gt; method on the chosen instance.
     * &lt;p&gt;
     * This method provides for the application the most precise control
     * over which &lt;code&gt;Font&lt;/code&gt; instance is used to render text.
     * If a font in this &lt;code&gt;GraphicsEnvironment&lt;/code&gt; has multiple
     * programmable variations, only one
     * instance of that &lt;code&gt;Font&lt;/code&gt; is returned in the array, and
     * other variations must be derived by the application.
     * &lt;p&gt;
     * If a font in this environment has multiple programmable variations,
     * such as Multiple-Master fonts, only one instance of that font is
     * returned in the &lt;code&gt;Font&lt;/code&gt; array.  The other variations
     * must be derived by the application.
     *
     * @return an array of &lt;code&gt;Font&lt;/code&gt; objects
     * @see #getAvailableFontFamilyNames
     * @see java.awt.Font
     * @see java.awt.Font#deriveFont
     * @see java.awt.Font#getFontName
     * @since 1.2
     */
    public abstract Font[] getAllFonts();

    /**
     * Returns an array containing the names of all font families in this
     * &lt;code&gt;GraphicsEnvironment&lt;/code&gt; localized for the default locale,
     * as returned by &lt;code&gt;Locale.getDefault()&lt;/code&gt;.
     * &lt;p&gt;
     * Typical usage would be for presentation to a user for selection of
     * a particular family name. An application can then specify this name
     * when creating a font, in conjunction with a style, such as bold or
     * italic, giving the font system flexibility in choosing its own best
     * match among multiple fonts in the same font family.
     *
     * @return an array of &lt;code&gt;String&lt;/code&gt; containing font family names
     * localized for the default locale, or a suitable alternative
     * name if no name exists for this locale.
     * @see #getAllFonts
     * @see java.awt.Font
     * @see java.awt.Font#getFamily
     * @since 1.2
     */
    public abstract String[] getAvailableFontFamilyNames();

    /**
     * Returns an array containing the names of all font families in this
     * &lt;code&gt;GraphicsEnvironment&lt;/code&gt; localized for the specified locale.
     * &lt;p&gt;
     * Typical usage would be for presentation to a user for selection of
     * a particular family name. An application can then specify this name
     * when creating a font, in conjunction with a style, such as bold or
     * italic, giving the font system flexibility in choosing its own best
     * match among multiple fonts in the same font family.
     *
     * @param l a {@link Locale} object that represents a
     * particular geographical, political, or cultural region.
     * Specifying &lt;code&gt;null&lt;/code&gt; is equivalent to
     * specifying &lt;code&gt;Locale.getDefault()&lt;/code&gt;.
     * @return an array of &lt;code&gt;String&lt;/code&gt; containing font family names
     * localized for the specified &lt;code&gt;Locale&lt;/code&gt;, or a
     * suitable alternative name if no name exists for the specified locale.
     * @see #getAllFonts
     * @see java.awt.Font
     * @see java.awt.Font#getFamily
     * @since 1.2
     */
    public abstract String[] getAvailableFontFamilyNames(Locale l);

    /**
     * Registers a &lt;i&gt;created&lt;/i&gt; &lt;code&gt;Font&lt;/code&gt;in this
     * &lt;code&gt;GraphicsEnvironment&lt;/code&gt;.
     * A created font is one that was returned from calling
     * {@link Font#createFont}, or derived from a created font by
     * calling {@link Font#deriveFont}.
     * After calling this method for such a font, it is available to
     * be used in constructing new &lt;code&gt;Font&lt;/code&gt;s by name or family name,
     * and is enumerated by {@link #getAvailableFontFamilyNames} and
     * {@link #getAllFonts} within the execution context of this
     * application or applet. This means applets cannot register fonts in
     * a way that they are visible to other applets.
     * &lt;p&gt;
     * Reasons that this method might not register the font and therefore
     * return &lt;code&gt;false&lt;/code&gt; are:
     * &lt;ul&gt;
     * &lt;li&gt;The font is not a &lt;i&gt;created&lt;/i&gt; &lt;code&gt;Font&lt;/code&gt;.
     * &lt;li&gt;The font conflicts with a non-created &lt;code&gt;Font&lt;/code&gt; already
     * in this &lt;code&gt;GraphicsEnvironment&lt;/code&gt;. For example if the name
     * is that of a system font, or a logical font as described in the
     * documentation of the {@link Font} class. It is implementation dependent
     * whether a font may also conflict if it has the same family name
     * as a system font.
     * &lt;p&gt;Notice that an application can supersede the registration
     * of an earlier created font with a new one.
     * &lt;/ul&gt;
     * @return true if the &lt;code&gt;font&lt;/code&gt; is successfully
     * registered in this &lt;code&gt;GraphicsEnvironment&lt;/code&gt;.
     * @throws NullPointerException if &lt;code&gt;font&lt;/code&gt; is null
     * @since 1.6
     */
    public boolean registerFont(Font font) {
<span class="nc bnc" id="L366" title="All 2 branches missed.">        if (font == null) {</span>
<span class="nc" id="L367">            throw new NullPointerException(&quot;font cannot be null.&quot;);</span>
        }
<span class="nc" id="L369">        FontManager fm = FontManagerFactory.getInstance();</span>
<span class="nc" id="L370">        return fm.registerFont(font);</span>
    }

    /**
     * Indicates a preference for locale-specific fonts in the mapping of
     * logical fonts to physical fonts. Calling this method indicates that font
     * rendering should primarily use fonts specific to the primary writing
     * system (the one indicated by the default encoding and the initial
     * default locale). For example, if the primary writing system is
     * Japanese, then characters should be rendered using a Japanese font
     * if possible, and other fonts should only be used for characters for
     * which the Japanese font doesn't have glyphs.
     * &lt;p&gt;
     * The actual change in font rendering behavior resulting from a call
     * to this method is implementation dependent; it may have no effect at
     * all, or the requested behavior may already match the default behavior.
     * The behavior may differ between font rendering in lightweight
     * and peered components.  Since calling this method requests a
     * different font, clients should expect different metrics, and may need
     * to recalculate window sizes and layout. Therefore this method should
     * be called before user interface initialisation.
     * @since 1.5
     */
    public void preferLocaleFonts() {
<span class="nc" id="L394">        FontManager fm = FontManagerFactory.getInstance();</span>
<span class="nc" id="L395">        fm.preferLocaleFonts();</span>
<span class="nc" id="L396">    }</span>

    /**
     * Indicates a preference for proportional over non-proportional (e.g.
     * dual-spaced CJK fonts) fonts in the mapping of logical fonts to
     * physical fonts. If the default mapping contains fonts for which
     * proportional and non-proportional variants exist, then calling
     * this method indicates the mapping should use a proportional variant.
     * &lt;p&gt;
     * The actual change in font rendering behavior resulting from a call to
     * this method is implementation dependent; it may have no effect at all.
     * The behavior may differ between font rendering in lightweight and
     * peered components. Since calling this method requests a
     * different font, clients should expect different metrics, and may need
     * to recalculate window sizes and layout. Therefore this method should
     * be called before user interface initialisation.
     * @since 1.5
     */
    public void preferProportionalFonts() {
<span class="nc" id="L415">        FontManager fm = FontManagerFactory.getInstance();</span>
<span class="nc" id="L416">        fm.preferProportionalFonts();</span>
<span class="nc" id="L417">    }</span>

    /**
     * Returns the Point where Windows should be centered.
     * It is recommended that centered Windows be checked to ensure they fit
     * within the available display area using getMaximumWindowBounds().
     * @return the point where Windows should be centered
     *
     * @exception HeadlessException if isHeadless() returns true
     * @see #getMaximumWindowBounds
     * @since 1.4
     */
    public Point getCenterPoint() throws HeadlessException {
    // Default implementation: return the center of the usable bounds of the
    // default screen device.
<span class="nc" id="L432">        Rectangle usableBounds =</span>
<span class="nc" id="L433">         SunGraphicsEnvironment.getUsableBounds(getDefaultScreenDevice());</span>
<span class="nc" id="L434">        return new Point((usableBounds.width / 2) + usableBounds.x,</span>
                         (usableBounds.height / 2) + usableBounds.y);
    }

    /**
     * Returns the maximum bounds for centered Windows.
     * These bounds account for objects in the native windowing system such as
     * task bars and menu bars.  The returned bounds will reside on a single
     * display with one exception: on multi-screen systems where Windows should
     * be centered across all displays, this method returns the bounds of the
     * entire display area.
     * &lt;p&gt;
     * To get the usable bounds of a single display, use
     * &lt;code&gt;GraphicsConfiguration.getBounds()&lt;/code&gt; and
     * &lt;code&gt;Toolkit.getScreenInsets()&lt;/code&gt;.
     * @return  the maximum bounds for centered Windows
     *
     * @exception HeadlessException if isHeadless() returns true
     * @see #getCenterPoint
     * @see GraphicsConfiguration#getBounds
     * @see Toolkit#getScreenInsets
     * @since 1.4
     */
    public Rectangle getMaximumWindowBounds() throws HeadlessException {
    // Default implementation: return the usable bounds of the default screen
    // device.  This is correct for Microsoft Windows and non-Xinerama X11.
<span class="nc" id="L460">        return SunGraphicsEnvironment.getUsableBounds(getDefaultScreenDevice());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>