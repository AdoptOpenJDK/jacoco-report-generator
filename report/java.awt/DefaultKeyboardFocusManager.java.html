<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultKeyboardFocusManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">DefaultKeyboardFocusManager.java</span></div><h1>DefaultKeyboardFocusManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt;

import java.awt.event.FocusEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowEvent;
import java.awt.peer.ComponentPeer;
import java.awt.peer.LightweightPeer;
import java.lang.ref.WeakReference;
import java.util.LinkedList;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Set;

import sun.util.logging.PlatformLogger;

import sun.awt.AppContext;
import sun.awt.SunToolkit;
import sun.awt.AWTAccessor;
import sun.awt.CausedFocusEvent;
import sun.awt.TimedWindowEvent;

/**
 * The default KeyboardFocusManager for AWT applications. Focus traversal is
 * done in response to a Component's focus traversal keys, and using a
 * Container's FocusTraversalPolicy.
 * &lt;p&gt;
 * Please see
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
 * How to Use the Focus Subsystem&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
 * &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
 * for more information.
 *
 * @author David Mendenhall
 *
 * @see FocusTraversalPolicy
 * @see Component#setFocusTraversalKeys
 * @see Component#getFocusTraversalKeys
 * @since 1.4
 */
<span class="fc" id="L65">public class DefaultKeyboardFocusManager extends KeyboardFocusManager {</span>
<span class="fc" id="L66">    private static final PlatformLogger focusLog = PlatformLogger.getLogger(&quot;java.awt.focus.DefaultKeyboardFocusManager&quot;);</span>

    // null weak references to not create too many objects
<span class="fc" id="L69">    private static final WeakReference&lt;Window&gt; NULL_WINDOW_WR =</span>
        new WeakReference&lt;Window&gt;(null);
<span class="fc" id="L71">    private static final WeakReference&lt;Component&gt; NULL_COMPONENT_WR =</span>
        new WeakReference&lt;Component&gt;(null);
<span class="fc" id="L73">    private WeakReference&lt;Window&gt; realOppositeWindowWR = NULL_WINDOW_WR;</span>
<span class="fc" id="L74">    private WeakReference&lt;Component&gt; realOppositeComponentWR = NULL_COMPONENT_WR;</span>
    private int inSendMessage;
<span class="fc" id="L76">    private LinkedList&lt;KeyEvent&gt; enqueuedKeyEvents = new LinkedList&lt;KeyEvent&gt;();</span>
<span class="fc" id="L77">    private LinkedList&lt;TypeAheadMarker&gt; typeAheadMarkers = new LinkedList&lt;TypeAheadMarker&gt;();</span>
    private boolean consumeNextKeyTyped;

    static {
<span class="fc" id="L81">        AWTAccessor.setDefaultKeyboardFocusManagerAccessor(</span>
<span class="fc" id="L82">            new AWTAccessor.DefaultKeyboardFocusManagerAccessor() {</span>
                public void consumeNextKeyTyped(DefaultKeyboardFocusManager dkfm, KeyEvent e) {
<span class="nc" id="L84">                    dkfm.consumeNextKeyTyped(e);</span>
<span class="nc" id="L85">                }</span>
            });
<span class="fc" id="L87">    }</span>

    private static class TypeAheadMarker {
        long after;
        Component untilFocused;

<span class="nc" id="L93">        TypeAheadMarker(long after, Component untilFocused) {</span>
<span class="nc" id="L94">            this.after = after;</span>
<span class="nc" id="L95">            this.untilFocused = untilFocused;</span>
<span class="nc" id="L96">        }</span>
        /**
         * Returns string representation of the marker
         */
        public String toString() {
<span class="nc" id="L101">            return &quot;&gt;&gt;&gt; Marker after &quot; + after + &quot; on &quot; + untilFocused;</span>
        }
    }

    private Window getOwningFrameDialog(Window window) {
<span class="nc bnc" id="L106" title="All 6 branches missed.">        while (window != null &amp;&amp; !(window instanceof Frame ||</span>
                                   window instanceof Dialog)) {
<span class="nc" id="L108">            window = (Window)window.getParent();</span>
        }
<span class="nc" id="L110">        return window;</span>
    }

    /*
     * This series of restoreFocus methods is used for recovering from a
     * rejected focus or activation change. Rejections typically occur when
     * the user attempts to focus a non-focusable Component or Window.
     */
    private void restoreFocus(FocusEvent fe, Window newFocusedWindow) {
<span class="nc" id="L119">        Component realOppositeComponent = this.realOppositeComponentWR.get();</span>
<span class="nc" id="L120">        Component vetoedComponent = fe.getComponent();</span>

<span class="nc bnc" id="L122" title="All 4 branches missed.">        if (newFocusedWindow != null &amp;&amp; restoreFocus(newFocusedWindow,</span>
                                                     vetoedComponent, false))
        {
<span class="nc bnc" id="L125" title="All 2 branches missed.">        } else if (realOppositeComponent != null &amp;&amp;</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">                   doRestoreFocus(realOppositeComponent, vetoedComponent, false)) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        } else if (fe.getOppositeComponent() != null &amp;&amp;</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                   doRestoreFocus(fe.getOppositeComponent(), vetoedComponent, false)) {</span>
        } else {
<span class="nc" id="L130">            clearGlobalFocusOwnerPriv();</span>
        }
<span class="nc" id="L132">    }</span>
    private void restoreFocus(WindowEvent we) {
<span class="nc" id="L134">        Window realOppositeWindow = this.realOppositeWindowWR.get();</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (realOppositeWindow != null</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">            &amp;&amp; restoreFocus(realOppositeWindow, null, false))</span>
        {
            // do nothing, everything is done in restoreFocus()
<span class="nc bnc" id="L139" title="All 2 branches missed.">        } else if (we.getOppositeWindow() != null &amp;&amp;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                   restoreFocus(we.getOppositeWindow(), null, false))</span>
        {
            // do nothing, everything is done in restoreFocus()
        } else {
<span class="nc" id="L144">            clearGlobalFocusOwnerPriv();</span>
        }
<span class="nc" id="L146">    }</span>
    private boolean restoreFocus(Window aWindow, Component vetoedComponent,
                                 boolean clearOnFailure) {
<span class="nc" id="L149">        Component toFocus =</span>
<span class="nc" id="L150">            KeyboardFocusManager.getMostRecentFocusOwner(aWindow);</span>

<span class="nc bnc" id="L152" title="All 6 branches missed.">        if (toFocus != null &amp;&amp; toFocus != vetoedComponent &amp;&amp; doRestoreFocus(toFocus, vetoedComponent, false)) {</span>
<span class="nc" id="L153">            return true;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        } else if (clearOnFailure) {</span>
<span class="nc" id="L155">            clearGlobalFocusOwnerPriv();</span>
<span class="nc" id="L156">            return true;</span>
        } else {
<span class="nc" id="L158">            return false;</span>
        }
    }
    private boolean restoreFocus(Component toFocus, boolean clearOnFailure) {
<span class="nc" id="L162">        return doRestoreFocus(toFocus, null, clearOnFailure);</span>
    }
    private boolean doRestoreFocus(Component toFocus, Component vetoedComponent,
                                   boolean clearOnFailure)
    {
<span class="nc bnc" id="L167" title="All 6 branches missed.">        if (toFocus != vetoedComponent &amp;&amp; toFocus.isShowing() &amp;&amp; toFocus.canBeFocusOwner() &amp;&amp;</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            toFocus.requestFocus(false, CausedFocusEvent.Cause.ROLLBACK))</span>
        {
<span class="nc" id="L170">            return true;</span>
        } else {
<span class="nc" id="L172">            Component nextFocus = toFocus.getNextFocusCandidate();</span>
<span class="nc bnc" id="L173" title="All 4 branches missed.">            if (nextFocus != null &amp;&amp; nextFocus != vetoedComponent &amp;&amp;</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">                nextFocus.requestFocusInWindow(CausedFocusEvent.Cause.ROLLBACK))</span>
            {
<span class="nc" id="L176">                return true;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            } else if (clearOnFailure) {</span>
<span class="nc" id="L178">                clearGlobalFocusOwnerPriv();</span>
<span class="nc" id="L179">                return true;</span>
            } else {
<span class="nc" id="L181">                return false;</span>
            }
        }
    }

    /**
     * A special type of SentEvent which updates a counter in the target
     * KeyboardFocusManager if it is an instance of
     * DefaultKeyboardFocusManager.
     */
<span class="fc" id="L191">    private static class DefaultKeyboardFocusManagerSentEvent</span>
        extends SentEvent
    {
        /*
         * serialVersionUID
         */
        private static final long serialVersionUID = -2924743257508701758L;

        public DefaultKeyboardFocusManagerSentEvent(AWTEvent nested,
                                                    AppContext toNotify) {
<span class="nc" id="L201">            super(nested, toNotify);</span>
<span class="nc" id="L202">        }</span>
        public final void dispatch() {
            KeyboardFocusManager manager =
<span class="nc" id="L205">                KeyboardFocusManager.getCurrentKeyboardFocusManager();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            DefaultKeyboardFocusManager defaultManager =</span>
                (manager instanceof DefaultKeyboardFocusManager)
                ? (DefaultKeyboardFocusManager)manager
                : null;

<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (defaultManager != null) {</span>
<span class="nc" id="L212">                synchronized (defaultManager) {</span>
<span class="nc" id="L213">                    defaultManager.inSendMessage++;</span>
<span class="nc" id="L214">                }</span>
            }

<span class="nc" id="L217">            super.dispatch();</span>

<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (defaultManager != null) {</span>
<span class="nc" id="L220">                synchronized (defaultManager) {</span>
<span class="nc" id="L221">                    defaultManager.inSendMessage--;</span>
<span class="nc" id="L222">                }</span>
            }
<span class="nc" id="L224">        }</span>
    }

    /**
     * Sends a synthetic AWTEvent to a Component. If the Component is in
     * the current AppContext, then the event is immediately dispatched.
     * If the Component is in a different AppContext, then the event is
     * posted to the other AppContext's EventQueue, and this method blocks
     * until the event is handled or target AppContext is disposed.
     * Returns true if successfuly dispatched event, false if failed
     * to dispatch.
     */
    static boolean sendMessage(Component target, AWTEvent e) {
<span class="nc" id="L237">        e.isPosted = true;</span>
<span class="nc" id="L238">        AppContext myAppContext = AppContext.getAppContext();</span>
<span class="nc" id="L239">        final AppContext targetAppContext = target.appContext;</span>
<span class="nc" id="L240">        final SentEvent se =</span>
            new DefaultKeyboardFocusManagerSentEvent(e, myAppContext);

<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (myAppContext == targetAppContext) {</span>
<span class="nc" id="L244">            se.dispatch();</span>
        } else {
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (targetAppContext.isDisposed()) {</span>
<span class="nc" id="L247">                return false;</span>
            }
<span class="nc" id="L249">            SunToolkit.postEvent(targetAppContext, se);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (EventQueue.isDispatchThread()) {</span>
                EventDispatchThread edt = (EventDispatchThread)
<span class="nc" id="L252">                    Thread.currentThread();</span>
<span class="nc" id="L253">                edt.pumpEvents(SentEvent.ID, new Conditional() {</span>
                        public boolean evaluate() {
<span class="nc bnc" id="L255" title="All 4 branches missed.">                            return !se.dispatched &amp;&amp; !targetAppContext.isDisposed();</span>
                        }
                    });
<span class="nc" id="L258">            } else {</span>
<span class="nc" id="L259">                synchronized (se) {</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">                    while (!se.dispatched &amp;&amp; !targetAppContext.isDisposed()) {</span>
                        try {
<span class="nc" id="L262">                            se.wait(1000);</span>
<span class="nc" id="L263">                        } catch (InterruptedException ie) {</span>
<span class="nc" id="L264">                            break;</span>
<span class="nc" id="L265">                        }</span>
                    }
<span class="nc" id="L267">                }</span>
            }
        }
<span class="nc" id="L270">        return se.dispatched;</span>
    }

    /*
     * Checks if the focus window event follows key events waiting in the type-ahead
     * queue (if any). This may happen when a user types ahead in the window, the client
     * listeners hang EDT for a while, and the user switches b/w toplevels. In that
     * case the focus window events may be dispatched before the type-ahead events
     * get handled. This may lead to wrong focus behavior and in order to avoid it,
     * the focus window events are reposted to the end of the event queue. See 6981400.
     */
    private boolean repostIfFollowsKeyEvents(WindowEvent e) {
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (!(e instanceof TimedWindowEvent)) {</span>
<span class="nc" id="L283">            return false;</span>
        }
<span class="nc" id="L285">        TimedWindowEvent we = (TimedWindowEvent)e;</span>
<span class="nc" id="L286">        long time = we.getWhen();</span>
<span class="nc" id="L287">        synchronized (this) {</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            KeyEvent ke = enqueuedKeyEvents.isEmpty() ? null : enqueuedKeyEvents.getFirst();</span>
<span class="nc bnc" id="L289" title="All 4 branches missed.">            if (ke != null &amp;&amp; time &gt;= ke.getWhen()) {</span>
<span class="nc" id="L290">                TypeAheadMarker marker = typeAheadMarkers.getFirst();</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                if (marker != null) {</span>
<span class="nc" id="L292">                    Window toplevel = marker.untilFocused.getContainingWindow();</span>
                    // Check that the component awaiting focus belongs to
                    // the current focused window. See 8015454.
<span class="nc bnc" id="L295" title="All 4 branches missed.">                    if (toplevel != null &amp;&amp; toplevel.isFocused()) {</span>
<span class="nc" id="L296">                        SunToolkit.postEvent(AppContext.getAppContext(), new SequencedEvent(e));</span>
<span class="nc" id="L297">                        return true;</span>
                    }
                }
            }
<span class="nc" id="L301">        }</span>
<span class="nc" id="L302">        return false;</span>
    }

    /**
     * This method is called by the AWT event dispatcher requesting that the
     * current KeyboardFocusManager dispatch the specified event on its behalf.
     * DefaultKeyboardFocusManagers dispatch all FocusEvents, all WindowEvents
     * related to focus, and all KeyEvents. These events are dispatched based
     * on the KeyboardFocusManager's notion of the focus owner and the focused
     * and active Windows, sometimes overriding the source of the specified
     * AWTEvent. If this method returns &lt;code&gt;false&lt;/code&gt;, then the AWT event
     * dispatcher will attempt to dispatch the event itself.
     *
     * @param e the AWTEvent to be dispatched
     * @return &lt;code&gt;true&lt;/code&gt; if this method dispatched the event;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public boolean dispatchEvent(AWTEvent e) {
<span class="nc bnc" id="L320" title="All 6 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINE) &amp;&amp; (e instanceof WindowEvent || e instanceof FocusEvent)) {</span>
<span class="nc" id="L321">            focusLog.fine(&quot;&quot; + e);</span>
        }
<span class="nc bnc" id="L323" title="All 8 branches missed.">        switch (e.getID()) {</span>
            case WindowEvent.WINDOW_GAINED_FOCUS: {
<span class="nc bnc" id="L325" title="All 2 branches missed.">                if (repostIfFollowsKeyEvents((WindowEvent)e)) {</span>
<span class="nc" id="L326">                    break;</span>
                }

<span class="nc" id="L329">                WindowEvent we = (WindowEvent)e;</span>
<span class="nc" id="L330">                Window oldFocusedWindow = getGlobalFocusedWindow();</span>
<span class="nc" id="L331">                Window newFocusedWindow = we.getWindow();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                if (newFocusedWindow == oldFocusedWindow) {</span>
<span class="nc" id="L333">                    break;</span>
                }

<span class="nc bnc" id="L336" title="All 2 branches missed.">                if (!(newFocusedWindow.isFocusableWindow()</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                      &amp;&amp; newFocusedWindow.isVisible()</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                      &amp;&amp; newFocusedWindow.isDisplayable()))</span>
                {
                    // we can not accept focus on such window, so reject it.
<span class="nc" id="L341">                    restoreFocus(we);</span>
<span class="nc" id="L342">                    break;</span>
                }
                // If there exists a current focused window, then notify it
                // that it has lost focus.
<span class="nc bnc" id="L346" title="All 2 branches missed.">                if (oldFocusedWindow != null) {</span>
<span class="nc" id="L347">                    boolean isEventDispatched =</span>
<span class="nc" id="L348">                        sendMessage(oldFocusedWindow,</span>
                                new WindowEvent(oldFocusedWindow,
                                                WindowEvent.WINDOW_LOST_FOCUS,
                                                newFocusedWindow));
                    // Failed to dispatch, clear by ourselfves
<span class="nc bnc" id="L353" title="All 2 branches missed.">                    if (!isEventDispatched) {</span>
<span class="nc" id="L354">                        setGlobalFocusOwner(null);</span>
<span class="nc" id="L355">                        setGlobalFocusedWindow(null);</span>
                    }
                }

                // Because the native libraries do not post WINDOW_ACTIVATED
                // events, we need to synthesize one if the active Window
                // changed.
<span class="nc" id="L362">                Window newActiveWindow =</span>
<span class="nc" id="L363">                    getOwningFrameDialog(newFocusedWindow);</span>
<span class="nc" id="L364">                Window currentActiveWindow = getGlobalActiveWindow();</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                if (newActiveWindow != currentActiveWindow) {</span>
<span class="nc" id="L366">                    sendMessage(newActiveWindow,</span>
                                new WindowEvent(newActiveWindow,
                                                WindowEvent.WINDOW_ACTIVATED,
                                                currentActiveWindow));
<span class="nc bnc" id="L370" title="All 2 branches missed.">                    if (newActiveWindow != getGlobalActiveWindow()) {</span>
                        // Activation change was rejected. Unlikely, but
                        // possible.
<span class="nc" id="L373">                        restoreFocus(we);</span>
<span class="nc" id="L374">                        break;</span>
                    }
                }

<span class="nc" id="L378">                setGlobalFocusedWindow(newFocusedWindow);</span>

<span class="nc bnc" id="L380" title="All 2 branches missed.">                if (newFocusedWindow != getGlobalFocusedWindow()) {</span>
                    // Focus change was rejected. Will happen if
                    // newFocusedWindow is not a focusable Window.
<span class="nc" id="L383">                    restoreFocus(we);</span>
<span class="nc" id="L384">                    break;</span>
                }

                // Restore focus to the Component which last held it. We do
                // this here so that client code can override our choice in
                // a WINDOW_GAINED_FOCUS handler.
                //
                // Make sure that the focus change request doesn't change the
                // focused Window in case we are no longer the focused Window
                // when the request is handled.
<span class="nc bnc" id="L394" title="All 2 branches missed.">                if (inSendMessage == 0) {</span>
                    // Identify which Component should initially gain focus
                    // in the Window.
                    //
                    // * If we're in SendMessage, then this is a synthetic
                    //   WINDOW_GAINED_FOCUS message which was generated by a
                    //   the FOCUS_GAINED handler. Allow the Component to
                    //   which the FOCUS_GAINED message was targeted to
                    //   receive the focus.
                    // * Otherwise, look up the correct Component here.
                    //   We don't use Window.getMostRecentFocusOwner because
                    //   window is focused now and 'null' will be returned


                    // Calculating of most recent focus owner and focus
                    // request should be synchronized on KeyboardFocusManager.class
                    // to prevent from thread race when user will request
                    // focus between calculation and our request.
                    // But if focus transfer is synchronous, this synchronization
                    // may cause deadlock, thus we don't synchronize this block.
<span class="nc" id="L414">                    Component toFocus = KeyboardFocusManager.</span>
<span class="nc" id="L415">                        getMostRecentFocusOwner(newFocusedWindow);</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                    if ((toFocus == null) &amp;&amp;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">                        newFocusedWindow.isFocusableWindow())</span>
                    {
<span class="nc" id="L419">                        toFocus = newFocusedWindow.getFocusTraversalPolicy().</span>
<span class="nc" id="L420">                            getInitialComponent(newFocusedWindow);</span>
                    }
<span class="nc" id="L422">                    Component tempLost = null;</span>
<span class="nc" id="L423">                    synchronized(KeyboardFocusManager.class) {</span>
<span class="nc" id="L424">                        tempLost = newFocusedWindow.setTemporaryLostComponent(null);</span>
<span class="nc" id="L425">                    }</span>

                    // The component which last has the focus when this window was focused
                    // should receive focus first
<span class="nc bnc" id="L429" title="All 2 branches missed.">                    if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L430">                        focusLog.finer(&quot;tempLost {0}, toFocus {1}&quot;,</span>
                                       tempLost, toFocus);
                    }
<span class="nc bnc" id="L433" title="All 2 branches missed.">                    if (tempLost != null) {</span>
<span class="nc" id="L434">                        tempLost.requestFocusInWindow(CausedFocusEvent.Cause.ACTIVATION);</span>
                    }

<span class="nc bnc" id="L437" title="All 4 branches missed.">                    if (toFocus != null &amp;&amp; toFocus != tempLost) {</span>
                        // If there is a component which requested focus when this window
                        // was inactive it expects to receive focus after activation.
<span class="nc" id="L440">                        toFocus.requestFocusInWindow(CausedFocusEvent.Cause.ACTIVATION);</span>
                    }
                }

<span class="nc" id="L444">                Window realOppositeWindow = this.realOppositeWindowWR.get();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">                if (realOppositeWindow != we.getOppositeWindow()) {</span>
<span class="nc" id="L446">                    we = new WindowEvent(newFocusedWindow,</span>
                                         WindowEvent.WINDOW_GAINED_FOCUS,
                                         realOppositeWindow);
                }
<span class="nc" id="L450">                return typeAheadAssertions(newFocusedWindow, we);</span>
            }

            case WindowEvent.WINDOW_ACTIVATED: {
<span class="nc" id="L454">                WindowEvent we = (WindowEvent)e;</span>
<span class="nc" id="L455">                Window oldActiveWindow = getGlobalActiveWindow();</span>
<span class="nc" id="L456">                Window newActiveWindow = we.getWindow();</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (oldActiveWindow == newActiveWindow) {</span>
<span class="nc" id="L458">                    break;</span>
                }

                // If there exists a current active window, then notify it that
                // it has lost activation.
<span class="nc bnc" id="L463" title="All 2 branches missed.">                if (oldActiveWindow != null) {</span>
<span class="nc" id="L464">                    boolean isEventDispatched =</span>
<span class="nc" id="L465">                        sendMessage(oldActiveWindow,</span>
                                new WindowEvent(oldActiveWindow,
                                                WindowEvent.WINDOW_DEACTIVATED,
                                                newActiveWindow));
                    // Failed to dispatch, clear by ourselfves
<span class="nc bnc" id="L470" title="All 2 branches missed.">                    if (!isEventDispatched) {</span>
<span class="nc" id="L471">                        setGlobalActiveWindow(null);</span>
                    }
<span class="nc bnc" id="L473" title="All 2 branches missed.">                    if (getGlobalActiveWindow() != null) {</span>
                        // Activation change was rejected. Unlikely, but
                        // possible.
<span class="nc" id="L476">                        break;</span>
                    }
                }

<span class="nc" id="L480">                setGlobalActiveWindow(newActiveWindow);</span>

<span class="nc bnc" id="L482" title="All 2 branches missed.">                if (newActiveWindow != getGlobalActiveWindow()) {</span>
                    // Activation change was rejected. Unlikely, but
                    // possible.
<span class="nc" id="L485">                    break;</span>
                }

<span class="nc" id="L488">                return typeAheadAssertions(newActiveWindow, we);</span>
            }

            case FocusEvent.FOCUS_GAINED: {
<span class="nc" id="L492">                FocusEvent fe = (FocusEvent)e;</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                CausedFocusEvent.Cause cause = (fe instanceof CausedFocusEvent) ?</span>
<span class="nc" id="L494">                    ((CausedFocusEvent)fe).getCause() : CausedFocusEvent.Cause.UNKNOWN;</span>
<span class="nc" id="L495">                Component oldFocusOwner = getGlobalFocusOwner();</span>
<span class="nc" id="L496">                Component newFocusOwner = fe.getComponent();</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                if (oldFocusOwner == newFocusOwner) {</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                    if (focusLog.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L499">                        focusLog.fine(&quot;Skipping {0} because focus owner is the same&quot;, e);</span>
                    }
                    // We can't just drop the event - there could be
                    // type-ahead markers associated with it.
<span class="nc" id="L503">                    dequeueKeyEvents(-1, newFocusOwner);</span>
<span class="nc" id="L504">                    break;</span>
                }

                // If there exists a current focus owner, then notify it that
                // it has lost focus.
<span class="nc bnc" id="L509" title="All 2 branches missed.">                if (oldFocusOwner != null) {</span>
<span class="nc" id="L510">                    boolean isEventDispatched =</span>
<span class="nc" id="L511">                        sendMessage(oldFocusOwner,</span>
                                    new CausedFocusEvent(oldFocusOwner,
                                                   FocusEvent.FOCUS_LOST,
<span class="nc" id="L514">                                                   fe.isTemporary(),</span>
                                                   newFocusOwner, cause));
                    // Failed to dispatch, clear by ourselfves
<span class="nc bnc" id="L517" title="All 2 branches missed.">                    if (!isEventDispatched) {</span>
<span class="nc" id="L518">                        setGlobalFocusOwner(null);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">                        if (!fe.isTemporary()) {</span>
<span class="nc" id="L520">                            setGlobalPermanentFocusOwner(null);</span>
                        }
                    }
                }

                // Because the native windowing system has a different notion
                // of the current focus and activation states, it is possible
                // that a Component outside of the focused Window receives a
                // FOCUS_GAINED event. We synthesize a WINDOW_GAINED_FOCUS
                // event in that case.
<span class="nc" id="L530">                final Window newFocusedWindow = SunToolkit.getContainingWindow(newFocusOwner);</span>
<span class="nc" id="L531">                final Window currentFocusedWindow = getGlobalFocusedWindow();</span>
<span class="nc bnc" id="L532" title="All 4 branches missed.">                if (newFocusedWindow != null &amp;&amp;</span>
                    newFocusedWindow != currentFocusedWindow)
                {
<span class="nc" id="L535">                    sendMessage(newFocusedWindow,</span>
                                new WindowEvent(newFocusedWindow,
                                        WindowEvent.WINDOW_GAINED_FOCUS,
                                                currentFocusedWindow));
<span class="nc bnc" id="L539" title="All 2 branches missed.">                    if (newFocusedWindow != getGlobalFocusedWindow()) {</span>
                        // Focus change was rejected. Will happen if
                        // newFocusedWindow is not a focusable Window.

                        // Need to recover type-ahead, but don't bother
                        // restoring focus. That was done by the
                        // WINDOW_GAINED_FOCUS handler
<span class="nc" id="L546">                        dequeueKeyEvents(-1, newFocusOwner);</span>
<span class="nc" id="L547">                        break;</span>
                    }
                }

<span class="nc bnc" id="L551" title="All 4 branches missed.">                if (!(newFocusOwner.isFocusable() &amp;&amp; newFocusOwner.isShowing() &amp;&amp;</span>
                    // Refuse focus on a disabled component if the focus event
                    // isn't of UNKNOWN reason (i.e. not a result of a direct request
                    // but traversal, activation or system generated).
<span class="nc bnc" id="L555" title="All 4 branches missed.">                    (newFocusOwner.isEnabled() || cause.equals(CausedFocusEvent.Cause.UNKNOWN))))</span>
                {
                    // we should not accept focus on such component, so reject it.
<span class="nc" id="L558">                    dequeueKeyEvents(-1, newFocusOwner);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                    if (KeyboardFocusManager.isAutoFocusTransferEnabled()) {</span>
                        // If FOCUS_GAINED is for a disposed component (however
                        // it shouldn't happen) its toplevel parent is null. In this
                        // case we have to try to restore focus in the current focused
                        // window (for the details: 6607170).
<span class="nc bnc" id="L564" title="All 2 branches missed.">                        if (newFocusedWindow == null) {</span>
<span class="nc" id="L565">                            restoreFocus(fe, currentFocusedWindow);</span>
                        } else {
<span class="nc" id="L567">                            restoreFocus(fe, newFocusedWindow);</span>
                        }
<span class="nc" id="L569">                        setMostRecentFocusOwner(newFocusedWindow, null); // see: 8013773</span>
                    }
                    break;
                }

<span class="nc" id="L574">                setGlobalFocusOwner(newFocusOwner);</span>

<span class="nc bnc" id="L576" title="All 2 branches missed.">                if (newFocusOwner != getGlobalFocusOwner()) {</span>
                    // Focus change was rejected. Will happen if
                    // newFocusOwner is not focus traversable.
<span class="nc" id="L579">                    dequeueKeyEvents(-1, newFocusOwner);</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                    if (KeyboardFocusManager.isAutoFocusTransferEnabled()) {</span>
<span class="nc" id="L581">                        restoreFocus(fe, (Window)newFocusedWindow);</span>
                    }
                    break;
                }

<span class="nc bnc" id="L586" title="All 2 branches missed.">                if (!fe.isTemporary()) {</span>
<span class="nc" id="L587">                    setGlobalPermanentFocusOwner(newFocusOwner);</span>

<span class="nc bnc" id="L589" title="All 2 branches missed.">                    if (newFocusOwner != getGlobalPermanentFocusOwner()) {</span>
                        // Focus change was rejected. Unlikely, but possible.
<span class="nc" id="L591">                        dequeueKeyEvents(-1, newFocusOwner);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">                        if (KeyboardFocusManager.isAutoFocusTransferEnabled()) {</span>
<span class="nc" id="L593">                            restoreFocus(fe, (Window)newFocusedWindow);</span>
                        }
                        break;
                    }
                }

<span class="nc" id="L599">                setNativeFocusOwner(getHeavyweight(newFocusOwner));</span>

<span class="nc" id="L601">                Component realOppositeComponent = this.realOppositeComponentWR.get();</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">                if (realOppositeComponent != null &amp;&amp;</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                    realOppositeComponent != fe.getOppositeComponent()) {</span>
<span class="nc" id="L604">                    fe = new CausedFocusEvent(newFocusOwner,</span>
                                        FocusEvent.FOCUS_GAINED,
<span class="nc" id="L606">                                        fe.isTemporary(),</span>
                                        realOppositeComponent, cause);
<span class="nc" id="L608">                    ((AWTEvent) fe).isPosted = true;</span>
                }
<span class="nc" id="L610">                return typeAheadAssertions(newFocusOwner, fe);</span>
            }

            case FocusEvent.FOCUS_LOST: {
<span class="nc" id="L614">                FocusEvent fe = (FocusEvent)e;</span>
<span class="nc" id="L615">                Component currentFocusOwner = getGlobalFocusOwner();</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">                if (currentFocusOwner == null) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">                    if (focusLog.isLoggable(PlatformLogger.Level.FINE))</span>
<span class="nc" id="L618">                        focusLog.fine(&quot;Skipping {0} because focus owner is null&quot;, e);</span>
                    break;
                }
                // Ignore cases where a Component loses focus to itself.
                // If we make a mistake because of retargeting, then the
                // FOCUS_GAINED handler will correct it.
<span class="nc bnc" id="L624" title="All 2 branches missed.">                if (currentFocusOwner == fe.getOppositeComponent()) {</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">                    if (focusLog.isLoggable(PlatformLogger.Level.FINE))</span>
<span class="nc" id="L626">                        focusLog.fine(&quot;Skipping {0} because current focus owner is equal to opposite&quot;, e);</span>
                    break;
                }

<span class="nc" id="L630">                setGlobalFocusOwner(null);</span>

<span class="nc bnc" id="L632" title="All 2 branches missed.">                if (getGlobalFocusOwner() != null) {</span>
                    // Focus change was rejected. Unlikely, but possible.
<span class="nc" id="L634">                    restoreFocus(currentFocusOwner, true);</span>
<span class="nc" id="L635">                    break;</span>
                }

<span class="nc bnc" id="L638" title="All 2 branches missed.">                if (!fe.isTemporary()) {</span>
<span class="nc" id="L639">                    setGlobalPermanentFocusOwner(null);</span>

<span class="nc bnc" id="L641" title="All 2 branches missed.">                    if (getGlobalPermanentFocusOwner() != null) {</span>
                        // Focus change was rejected. Unlikely, but possible.
<span class="nc" id="L643">                        restoreFocus(currentFocusOwner, true);</span>
<span class="nc" id="L644">                        break;</span>
                    }
                } else {
<span class="nc" id="L647">                    Window owningWindow = currentFocusOwner.getContainingWindow();</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">                    if (owningWindow != null) {</span>
<span class="nc" id="L649">                        owningWindow.setTemporaryLostComponent(currentFocusOwner);</span>
                    }
                }

<span class="nc" id="L653">                setNativeFocusOwner(null);</span>

<span class="nc" id="L655">                fe.setSource(currentFocusOwner);</span>

<span class="nc bnc" id="L657" title="All 2 branches missed.">                realOppositeComponentWR = (fe.getOppositeComponent() != null)</span>
                    ? new WeakReference&lt;Component&gt;(currentFocusOwner)
                    : NULL_COMPONENT_WR;

<span class="nc" id="L661">                return typeAheadAssertions(currentFocusOwner, fe);</span>
            }

            case WindowEvent.WINDOW_DEACTIVATED: {
<span class="nc" id="L665">                WindowEvent we = (WindowEvent)e;</span>
<span class="nc" id="L666">                Window currentActiveWindow = getGlobalActiveWindow();</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                if (currentActiveWindow == null) {</span>
<span class="nc" id="L668">                    break;</span>
                }

<span class="nc bnc" id="L671" title="All 2 branches missed.">                if (currentActiveWindow != e.getSource()) {</span>
                    // The event is lost in time.
                    // Allow listeners to precess the event but do not
                    // change any global states
<span class="nc" id="L675">                    break;</span>
                }

<span class="nc" id="L678">                setGlobalActiveWindow(null);</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">                if (getGlobalActiveWindow() != null) {</span>
                    // Activation change was rejected. Unlikely, but possible.
<span class="nc" id="L681">                    break;</span>
                }

<span class="nc" id="L684">                we.setSource(currentActiveWindow);</span>
<span class="nc" id="L685">                return typeAheadAssertions(currentActiveWindow, we);</span>
            }

            case WindowEvent.WINDOW_LOST_FOCUS: {
<span class="nc bnc" id="L689" title="All 2 branches missed.">                if (repostIfFollowsKeyEvents((WindowEvent)e)) {</span>
<span class="nc" id="L690">                    break;</span>
                }

<span class="nc" id="L693">                WindowEvent we = (WindowEvent)e;</span>
<span class="nc" id="L694">                Window currentFocusedWindow = getGlobalFocusedWindow();</span>
<span class="nc" id="L695">                Window losingFocusWindow = we.getWindow();</span>
<span class="nc" id="L696">                Window activeWindow = getGlobalActiveWindow();</span>
<span class="nc" id="L697">                Window oppositeWindow = we.getOppositeWindow();</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">                if (focusLog.isLoggable(PlatformLogger.Level.FINE))</span>
<span class="nc" id="L699">                    focusLog.fine(&quot;Active {0}, Current focused {1}, losing focus {2} opposite {3}&quot;,</span>
                                  activeWindow, currentFocusedWindow,
                                  losingFocusWindow, oppositeWindow);
<span class="nc bnc" id="L702" title="All 2 branches missed.">                if (currentFocusedWindow == null) {</span>
<span class="nc" id="L703">                    break;</span>
                }

                // Special case -- if the native windowing system posts an
                // event claiming that the active Window has lost focus to the
                // focused Window, then discard the event. This is an artifact
                // of the native windowing system not knowing which Window is
                // really focused.
<span class="nc bnc" id="L711" title="All 6 branches missed.">                if (inSendMessage == 0 &amp;&amp; losingFocusWindow == activeWindow &amp;&amp;</span>
                    oppositeWindow == currentFocusedWindow)
                {
<span class="nc" id="L714">                    break;</span>
                }

<span class="nc" id="L717">                Component currentFocusOwner = getGlobalFocusOwner();</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">                if (currentFocusOwner != null) {</span>
                    // The focus owner should always receive a FOCUS_LOST event
                    // before the Window is defocused.
<span class="nc" id="L721">                    Component oppositeComp = null;</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">                    if (oppositeWindow != null) {</span>
<span class="nc" id="L723">                        oppositeComp = oppositeWindow.getTemporaryLostComponent();</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                        if (oppositeComp == null) {</span>
<span class="nc" id="L725">                            oppositeComp = oppositeWindow.getMostRecentFocusOwner();</span>
                        }
                    }
<span class="nc bnc" id="L728" title="All 2 branches missed.">                    if (oppositeComp == null) {</span>
<span class="nc" id="L729">                        oppositeComp = oppositeWindow;</span>
                    }
<span class="nc" id="L731">                    sendMessage(currentFocusOwner,</span>
                                new CausedFocusEvent(currentFocusOwner,
                                               FocusEvent.FOCUS_LOST,
                                               true,
                                               oppositeComp, CausedFocusEvent.Cause.ACTIVATION));
                }

<span class="nc" id="L738">                setGlobalFocusedWindow(null);</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">                if (getGlobalFocusedWindow() != null) {</span>
                    // Focus change was rejected. Unlikely, but possible.
<span class="nc" id="L741">                    restoreFocus(currentFocusedWindow, null, true);</span>
<span class="nc" id="L742">                    break;</span>
                }

<span class="nc" id="L745">                we.setSource(currentFocusedWindow);</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">                realOppositeWindowWR = (oppositeWindow != null)</span>
                    ? new WeakReference&lt;Window&gt;(currentFocusedWindow)
                    : NULL_WINDOW_WR;
<span class="nc" id="L749">                typeAheadAssertions(currentFocusedWindow, we);</span>

<span class="nc bnc" id="L751" title="All 2 branches missed.">                if (oppositeWindow == null) {</span>
                    // Then we need to deactive the active Window as well.
                    // No need to synthesize in other cases, because
                    // WINDOW_ACTIVATED will handle it if necessary.
<span class="nc" id="L755">                    sendMessage(activeWindow,</span>
                                new WindowEvent(activeWindow,
                                                WindowEvent.WINDOW_DEACTIVATED,
                                                null));
<span class="nc bnc" id="L759" title="All 2 branches missed.">                    if (getGlobalActiveWindow() != null) {</span>
                        // Activation change was rejected. Unlikely,
                        // but possible.
<span class="nc" id="L762">                        restoreFocus(currentFocusedWindow, null, true);</span>
                    }
                }
                break;
            }

            case KeyEvent.KEY_TYPED:
            case KeyEvent.KEY_PRESSED:
            case KeyEvent.KEY_RELEASED:
<span class="nc" id="L771">                return typeAheadAssertions(null, e);</span>

            default:
<span class="nc" id="L774">                return false;</span>
        }

<span class="nc" id="L777">        return true;</span>
    }

    /**
     * Called by &lt;code&gt;dispatchEvent&lt;/code&gt; if no other
     * KeyEventDispatcher in the dispatcher chain dispatched the KeyEvent, or
     * if no other KeyEventDispatchers are registered. If the event has not
     * been consumed, its target is enabled, and the focus owner is not null,
     * this method dispatches the event to its target. This method will also
     * subsequently dispatch the event to all registered
     * KeyEventPostProcessors. After all this operations are finished,
     * the event is passed to peers for processing.
     * &lt;p&gt;
     * In all cases, this method returns &lt;code&gt;true&lt;/code&gt;, since
     * DefaultKeyboardFocusManager is designed so that neither
     * &lt;code&gt;dispatchEvent&lt;/code&gt;, nor the AWT event dispatcher, should take
     * further action on the event in any situation.
     *
     * @param e the KeyEvent to be dispatched
     * @return &lt;code&gt;true&lt;/code&gt;
     * @see Component#dispatchEvent
     */
    public boolean dispatchKeyEvent(KeyEvent e) {
<span class="nc bnc" id="L800" title="All 2 branches missed.">        Component focusOwner = (((AWTEvent)e).isPosted) ? getFocusOwner() : e.getComponent();</span>

<span class="nc bnc" id="L802" title="All 6 branches missed.">        if (focusOwner != null &amp;&amp; focusOwner.isShowing() &amp;&amp; focusOwner.canBeFocusOwner()) {</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">            if (!e.isConsumed()) {</span>
<span class="nc" id="L804">                Component comp = e.getComponent();</span>
<span class="nc bnc" id="L805" title="All 4 branches missed.">                if (comp != null &amp;&amp; comp.isEnabled()) {</span>
<span class="nc" id="L806">                    redispatchEvent(comp, e);</span>
                }
            }
        }
<span class="nc" id="L810">        boolean stopPostProcessing = false;</span>
<span class="nc" id="L811">        java.util.List&lt;KeyEventPostProcessor&gt; processors = getKeyEventPostProcessors();</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">        if (processors != null) {</span>
<span class="nc" id="L813">            for (java.util.Iterator&lt;KeyEventPostProcessor&gt; iter = processors.iterator();</span>
<span class="nc bnc" id="L814" title="All 4 branches missed.">                 !stopPostProcessing &amp;&amp; iter.hasNext(); )</span>
            {
<span class="nc" id="L816">                stopPostProcessing = iter.next().</span>
<span class="nc" id="L817">                            postProcessKeyEvent(e);</span>
            }
        }
<span class="nc bnc" id="L820" title="All 2 branches missed.">        if (!stopPostProcessing) {</span>
<span class="nc" id="L821">            postProcessKeyEvent(e);</span>
        }

        // Allow the peer to process KeyEvent
<span class="nc" id="L825">        Component source = e.getComponent();</span>
<span class="nc" id="L826">        ComponentPeer peer = source.getPeer();</span>

<span class="nc bnc" id="L828" title="All 4 branches missed.">        if (peer == null || peer instanceof LightweightPeer) {</span>
            // if focus owner is lightweight then its native container
            // processes event
<span class="nc" id="L831">            Container target = source.getNativeContainer();</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">            if (target != null) {</span>
<span class="nc" id="L833">                peer = target.getPeer();</span>
            }
        }
<span class="nc bnc" id="L836" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L837">            peer.handleEvent(e);</span>
        }

<span class="nc" id="L840">        return true;</span>
    }

    /**
     * This method will be called by &lt;code&gt;dispatchKeyEvent&lt;/code&gt;. It will
     * handle any unconsumed KeyEvents that map to an AWT
     * &lt;code&gt;MenuShortcut&lt;/code&gt; by consuming the event and activating the
     * shortcut.
     *
     * @param e the KeyEvent to post-process
     * @return &lt;code&gt;true&lt;/code&gt;
     * @see #dispatchKeyEvent
     * @see MenuShortcut
     */
    public boolean postProcessKeyEvent(KeyEvent e) {
<span class="nc bnc" id="L855" title="All 2 branches missed.">        if (!e.isConsumed()) {</span>
<span class="nc" id="L856">            Component target = e.getComponent();</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">            Container p = (Container)</span>
<span class="nc" id="L858">                (target instanceof Container ? target : target.getParent());</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            if (p != null) {</span>
<span class="nc" id="L860">                p.postProcessKeyEvent(e);</span>
            }
        }
<span class="nc" id="L863">        return true;</span>
    }

    private void pumpApprovedKeyEvents() {
        KeyEvent ke;
        do {
<span class="nc" id="L869">            ke = null;</span>
<span class="nc" id="L870">            synchronized (this) {</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">                if (enqueuedKeyEvents.size() != 0) {</span>
<span class="nc" id="L872">                    ke = enqueuedKeyEvents.getFirst();</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">                    if (typeAheadMarkers.size() != 0) {</span>
<span class="nc" id="L874">                        TypeAheadMarker marker = typeAheadMarkers.getFirst();</span>
                        // Fixed 5064013: may appears that the events have the same time
                        // if (ke.getWhen() &gt;= marker.after) {
                        // The fix is rolled out.

<span class="nc bnc" id="L879" title="All 2 branches missed.">                        if (ke.getWhen() &gt; marker.after) {</span>
<span class="nc" id="L880">                            ke = null;</span>
                        }
                    }
<span class="nc bnc" id="L883" title="All 2 branches missed.">                    if (ke != null) {</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L885">                            focusLog.finer(&quot;Pumping approved event {0}&quot;, ke);</span>
                        }
<span class="nc" id="L887">                        enqueuedKeyEvents.removeFirst();</span>
                    }
                }
<span class="nc" id="L890">            }</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">            if (ke != null) {</span>
<span class="nc" id="L892">                preDispatchKeyEvent(ke);</span>
            }
<span class="nc bnc" id="L894" title="All 2 branches missed.">        } while (ke != null);</span>
<span class="nc" id="L895">    }</span>

    /**
     * Dumps the list of type-ahead queue markers to stderr
     */
    void dumpMarkers() {
<span class="nc bnc" id="L901" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L902">            focusLog.finest(&quot;&gt;&gt;&gt; Markers dump, time: {0}&quot;, System.currentTimeMillis());</span>
<span class="nc" id="L903">            synchronized (this) {</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                if (typeAheadMarkers.size() != 0) {</span>
<span class="nc" id="L905">                    Iterator&lt;TypeAheadMarker&gt; iter = typeAheadMarkers.iterator();</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">                    while (iter.hasNext()) {</span>
<span class="nc" id="L907">                        TypeAheadMarker marker = iter.next();</span>
<span class="nc" id="L908">                        focusLog.finest(&quot;    {0}&quot;, marker);</span>
<span class="nc" id="L909">                    }</span>
                }
<span class="nc" id="L911">            }</span>
        }
<span class="nc" id="L913">    }</span>

    private boolean typeAheadAssertions(Component target, AWTEvent e) {

        // Clear any pending events here as well as in the FOCUS_GAINED
        // handler. We need this call here in case a marker was removed in
        // response to a call to dequeueKeyEvents.
<span class="nc" id="L920">        pumpApprovedKeyEvents();</span>

<span class="nc bnc" id="L922" title="All 3 branches missed.">        switch (e.getID()) {</span>
            case KeyEvent.KEY_TYPED:
            case KeyEvent.KEY_PRESSED:
            case KeyEvent.KEY_RELEASED: {
<span class="nc" id="L926">                KeyEvent ke = (KeyEvent)e;</span>
<span class="nc" id="L927">                synchronized (this) {</span>
<span class="nc bnc" id="L928" title="All 4 branches missed.">                    if (e.isPosted &amp;&amp; typeAheadMarkers.size() != 0) {</span>
<span class="nc" id="L929">                        TypeAheadMarker marker = typeAheadMarkers.getFirst();</span>
                        // Fixed 5064013: may appears that the events have the same time
                        // if (ke.getWhen() &gt;= marker.after) {
                        // The fix is rolled out.

<span class="nc bnc" id="L934" title="All 2 branches missed.">                        if (ke.getWhen() &gt; marker.after) {</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">                            if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L936">                                focusLog.finer(&quot;Storing event {0} because of marker {1}&quot;, ke, marker);</span>
                            }
<span class="nc" id="L938">                            enqueuedKeyEvents.addLast(ke);</span>
<span class="nc" id="L939">                            return true;</span>
                        }
                    }
<span class="nc" id="L942">                }</span>

                // KeyEvent was posted before focus change request
<span class="nc" id="L945">                return preDispatchKeyEvent(ke);</span>
            }

            case FocusEvent.FOCUS_GAINED:
<span class="nc bnc" id="L949" title="All 2 branches missed.">                if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L950">                    focusLog.finest(&quot;Markers before FOCUS_GAINED on {0}&quot;, target);</span>
                }
<span class="nc" id="L952">                dumpMarkers();</span>
                // Search the marker list for the first marker tied to
                // the Component which just gained focus. Then remove
                // that marker, any markers which immediately follow
                // and are tied to the same component, and all markers
                // that preceed it. This handles the case where
                // multiple focus requests were made for the same
                // Component in a row and when we lost some of the
                // earlier requests. Since FOCUS_GAINED events will
                // not be generated for these additional requests, we
                // need to clear those markers too.
<span class="nc" id="L963">                synchronized (this) {</span>
<span class="nc" id="L964">                    boolean found = false;</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">                    if (hasMarker(target)) {</span>
<span class="nc" id="L966">                        for (Iterator&lt;TypeAheadMarker&gt; iter = typeAheadMarkers.iterator();</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">                             iter.hasNext(); )</span>
                        {
<span class="nc bnc" id="L969" title="All 2 branches missed.">                            if (iter.next().untilFocused == target) {</span>
<span class="nc" id="L970">                                found = true;</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">                            } else if (found) {</span>
<span class="nc" id="L972">                                break;</span>
                            }
<span class="nc" id="L974">                            iter.remove();</span>
                        }
                    } else {
                        // Exception condition - event without marker
<span class="nc bnc" id="L978" title="All 2 branches missed.">                        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L979">                            focusLog.finer(&quot;Event without marker {0}&quot;, e);</span>
                        }
                    }
<span class="nc" id="L982">                }</span>
<span class="nc" id="L983">                focusLog.finest(&quot;Markers after FOCUS_GAINED&quot;);</span>
<span class="nc" id="L984">                dumpMarkers();</span>

<span class="nc" id="L986">                redispatchEvent(target, e);</span>

                // Now, dispatch any pending KeyEvents which have been
                // released because of the FOCUS_GAINED event so that we don't
                // have to wait for another event to be posted to the queue.
<span class="nc" id="L991">                pumpApprovedKeyEvents();</span>
<span class="nc" id="L992">                return true;</span>

            default:
<span class="nc" id="L995">                redispatchEvent(target, e);</span>
<span class="nc" id="L996">                return true;</span>
        }
    }

    /**
     * Returns true if there are some marker associated with component &lt;code&gt;comp&lt;/code&gt;
     * in a markers' queue
     * @since 1.5
     */
    private boolean hasMarker(Component comp) {
<span class="nc bnc" id="L1006" title="All 2 branches missed.">        for (Iterator&lt;TypeAheadMarker&gt; iter = typeAheadMarkers.iterator(); iter.hasNext(); ) {</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">            if (iter.next().untilFocused == comp) {</span>
<span class="nc" id="L1008">                return true;</span>
            }
        }
<span class="nc" id="L1011">        return false;</span>
    }

    /**
     * Clears markers queue
     * @since 1.5
     */
    void clearMarkers() {
<span class="nc" id="L1019">        synchronized(this) {</span>
<span class="nc" id="L1020">            typeAheadMarkers.clear();</span>
<span class="nc" id="L1021">        }</span>
<span class="nc" id="L1022">    }</span>

    private boolean preDispatchKeyEvent(KeyEvent ke) {
<span class="nc bnc" id="L1025" title="All 2 branches missed.">        if (((AWTEvent) ke).isPosted) {</span>
<span class="nc" id="L1026">            Component focusOwner = getFocusOwner();</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">            ke.setSource(((focusOwner != null) ? focusOwner : getFocusedWindow()));</span>
        }
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        if (ke.getSource() == null) {</span>
<span class="nc" id="L1030">            return true;</span>
        }

        // Explicitly set the key event timestamp here (not in Component.dispatchEventImpl):
        // - A key event is anyway passed to this method which starts its actual dispatching.
        // - If a key event is put to the type ahead queue, its time stamp should not be registered
        //   until its dispatching actually starts (by this method).
<span class="nc" id="L1037">        EventQueue.setCurrentEventAndMostRecentTime(ke);</span>

        /**
         * Fix for 4495473.
         * This fix allows to correctly dispatch events when native
         * event proxying mechanism is active.
         * If it is active we should redispatch key events after
         * we detected its correct target.
         */
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        if (KeyboardFocusManager.isProxyActive(ke)) {</span>
<span class="nc" id="L1047">            Component source = (Component)ke.getSource();</span>
<span class="nc" id="L1048">            Container target = source.getNativeContainer();</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">            if (target != null) {</span>
<span class="nc" id="L1050">                ComponentPeer peer = target.getPeer();</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">                if (peer != null) {</span>
<span class="nc" id="L1052">                    peer.handleEvent(ke);</span>
                    /**
                     * Fix for 4478780 - consume event after it was dispatched by peer.
                     */
<span class="nc" id="L1056">                    ke.consume();</span>
                }
            }
<span class="nc" id="L1059">            return true;</span>
        }

<span class="nc" id="L1062">        java.util.List&lt;KeyEventDispatcher&gt; dispatchers = getKeyEventDispatchers();</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">        if (dispatchers != null) {</span>
<span class="nc" id="L1064">            for (java.util.Iterator&lt;KeyEventDispatcher&gt; iter = dispatchers.iterator();</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">                 iter.hasNext(); )</span>
             {
<span class="nc" id="L1067">                 if (iter.next().</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                     dispatchKeyEvent(ke))</span>
                 {
<span class="nc" id="L1070">                     return true;</span>
                 }
             }
        }
<span class="nc" id="L1074">        return dispatchKeyEvent(ke);</span>
    }

    /*
     * @param e is a KEY_PRESSED event that can be used
     *          to track the next KEY_TYPED related.
     */
    private void consumeNextKeyTyped(KeyEvent e) {
<span class="nc" id="L1082">        consumeNextKeyTyped = true;</span>
<span class="nc" id="L1083">    }</span>

    private void consumeTraversalKey(KeyEvent e) {
<span class="nc" id="L1086">        e.consume();</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">        consumeNextKeyTyped = (e.getID() == KeyEvent.KEY_PRESSED) &amp;&amp;</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">                              !e.isActionKey();</span>
<span class="nc" id="L1089">    }</span>

    /*
     * return true if event was consumed
     */
    private boolean consumeProcessedKeyEvent(KeyEvent e) {
<span class="nc bnc" id="L1095" title="All 4 branches missed.">        if ((e.getID() == KeyEvent.KEY_TYPED) &amp;&amp; consumeNextKeyTyped) {</span>
<span class="nc" id="L1096">            e.consume();</span>
<span class="nc" id="L1097">            consumeNextKeyTyped = false;</span>
<span class="nc" id="L1098">            return true;</span>
        }
<span class="nc" id="L1100">        return false;</span>
    }

    /**
     * This method initiates a focus traversal operation if and only if the
     * KeyEvent represents a focus traversal key for the specified
     * focusedComponent. It is expected that focusedComponent is the current
     * focus owner, although this need not be the case. If it is not,
     * focus traversal will nevertheless proceed as if focusedComponent
     * were the focus owner.
     *
     * @param focusedComponent the Component that is the basis for a focus
     *        traversal operation if the specified event represents a focus
     *        traversal key for the Component
     * @param e the event that may represent a focus traversal key
     */
    public void processKeyEvent(Component focusedComponent, KeyEvent e) {
        // consume processed event if needed
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (consumeProcessedKeyEvent(e)) {</span>
<span class="nc" id="L1119">            return;</span>
        }

        // KEY_TYPED events cannot be focus traversal keys
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        if (e.getID() == KeyEvent.KEY_TYPED) {</span>
<span class="nc" id="L1124">            return;</span>
        }

<span class="nc bnc" id="L1127" title="All 2 branches missed.">        if (focusedComponent.getFocusTraversalKeysEnabled() &amp;&amp;</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">            !e.isConsumed())</span>
        {
<span class="nc" id="L1130">            AWTKeyStroke stroke = AWTKeyStroke.getAWTKeyStrokeForEvent(e),</span>
<span class="nc" id="L1131">                oppStroke = AWTKeyStroke.getAWTKeyStroke(stroke.getKeyCode(),</span>
<span class="nc" id="L1132">                                                 stroke.getModifiers(),</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                                                 !stroke.isOnKeyRelease());</span>
            Set&lt;AWTKeyStroke&gt; toTest;
            boolean contains, containsOpp;

<span class="nc" id="L1137">            toTest = focusedComponent.getFocusTraversalKeys(</span>
                KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);
<span class="nc" id="L1139">            contains = toTest.contains(stroke);</span>
<span class="nc" id="L1140">            containsOpp = toTest.contains(oppStroke);</span>

<span class="nc bnc" id="L1142" title="All 4 branches missed.">            if (contains || containsOpp) {</span>
<span class="nc" id="L1143">                consumeTraversalKey(e);</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">                if (contains) {</span>
<span class="nc" id="L1145">                    focusNextComponent(focusedComponent);</span>
                }
<span class="nc" id="L1147">                return;</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">            } else if (e.getID() == KeyEvent.KEY_PRESSED) {</span>
                // Fix for 6637607: consumeNextKeyTyped should be reset.
<span class="nc" id="L1150">                consumeNextKeyTyped = false;</span>
            }

<span class="nc" id="L1153">            toTest = focusedComponent.getFocusTraversalKeys(</span>
                KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS);
<span class="nc" id="L1155">            contains = toTest.contains(stroke);</span>
<span class="nc" id="L1156">            containsOpp = toTest.contains(oppStroke);</span>

<span class="nc bnc" id="L1158" title="All 4 branches missed.">            if (contains || containsOpp) {</span>
<span class="nc" id="L1159">                consumeTraversalKey(e);</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">                if (contains) {</span>
<span class="nc" id="L1161">                    focusPreviousComponent(focusedComponent);</span>
                }
<span class="nc" id="L1163">                return;</span>
            }

<span class="nc" id="L1166">            toTest = focusedComponent.getFocusTraversalKeys(</span>
                KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS);
<span class="nc" id="L1168">            contains = toTest.contains(stroke);</span>
<span class="nc" id="L1169">            containsOpp = toTest.contains(oppStroke);</span>

<span class="nc bnc" id="L1171" title="All 4 branches missed.">            if (contains || containsOpp) {</span>
<span class="nc" id="L1172">                consumeTraversalKey(e);</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">                if (contains) {</span>
<span class="nc" id="L1174">                    upFocusCycle(focusedComponent);</span>
                }
<span class="nc" id="L1176">                return;</span>
            }

<span class="nc bnc" id="L1179" title="All 2 branches missed.">            if (!((focusedComponent instanceof Container) &amp;&amp;</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">                  ((Container)focusedComponent).isFocusCycleRoot())) {</span>
<span class="nc" id="L1181">                return;</span>
            }

<span class="nc" id="L1184">            toTest = focusedComponent.getFocusTraversalKeys(</span>
                KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS);
<span class="nc" id="L1186">            contains = toTest.contains(stroke);</span>
<span class="nc" id="L1187">            containsOpp = toTest.contains(oppStroke);</span>

<span class="nc bnc" id="L1189" title="All 4 branches missed.">            if (contains || containsOpp) {</span>
<span class="nc" id="L1190">                consumeTraversalKey(e);</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">                if (contains) {</span>
<span class="nc" id="L1192">                    downFocusCycle((Container)focusedComponent);</span>
                }
            }
        }
<span class="nc" id="L1196">    }</span>

    /**
     * Delays dispatching of KeyEvents until the specified Component becomes
     * the focus owner. KeyEvents with timestamps later than the specified
     * timestamp will be enqueued until the specified Component receives a
     * FOCUS_GAINED event, or the AWT cancels the delay request by invoking
     * &lt;code&gt;dequeueKeyEvents&lt;/code&gt; or &lt;code&gt;discardKeyEvents&lt;/code&gt;.
     *
     * @param after timestamp of current event, or the current, system time if
     *        the current event has no timestamp, or the AWT cannot determine
     *        which event is currently being handled
     * @param untilFocused Component which will receive a FOCUS_GAINED event
     *        before any pending KeyEvents
     * @see #dequeueKeyEvents
     * @see #discardKeyEvents
     */
    protected synchronized void enqueueKeyEvents(long after,
                                                 Component untilFocused) {
<span class="nc bnc" id="L1215" title="All 2 branches missed.">        if (untilFocused == null) {</span>
<span class="nc" id="L1216">            return;</span>
        }

<span class="nc bnc" id="L1219" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L1220">            focusLog.finer(&quot;Enqueue at {0} for {1}&quot;,</span>
<span class="nc" id="L1221">                       after, untilFocused);</span>
        }

<span class="nc" id="L1224">        int insertionIndex = 0,</span>
<span class="nc" id="L1225">            i = typeAheadMarkers.size();</span>
<span class="nc" id="L1226">        ListIterator&lt;TypeAheadMarker&gt; iter = typeAheadMarkers.listIterator(i);</span>

<span class="nc bnc" id="L1228" title="All 2 branches missed.">        for (; i &gt; 0; i--) {</span>
<span class="nc" id="L1229">            TypeAheadMarker marker = iter.previous();</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">            if (marker.after &lt;= after) {</span>
<span class="nc" id="L1231">                insertionIndex = i;</span>
<span class="nc" id="L1232">                break;</span>
            }
        }

<span class="nc" id="L1236">        typeAheadMarkers.add(insertionIndex,</span>
                             new TypeAheadMarker(after, untilFocused));
<span class="nc" id="L1238">    }</span>

    /**
     * Releases for normal dispatching to the current focus owner all
     * KeyEvents which were enqueued because of a call to
     * &lt;code&gt;enqueueKeyEvents&lt;/code&gt; with the same timestamp and Component.
     * If the given timestamp is less than zero, the outstanding enqueue
     * request for the given Component with the &lt;b&gt;oldest&lt;/b&gt; timestamp (if
     * any) should be cancelled.
     *
     * @param after the timestamp specified in the call to
     *        &lt;code&gt;enqueueKeyEvents&lt;/code&gt;, or any value &amp;lt; 0
     * @param untilFocused the Component specified in the call to
     *        &lt;code&gt;enqueueKeyEvents&lt;/code&gt;
     * @see #enqueueKeyEvents
     * @see #discardKeyEvents
     */
    protected synchronized void dequeueKeyEvents(long after,
                                                 Component untilFocused) {
<span class="nc bnc" id="L1257" title="All 2 branches missed.">        if (untilFocused == null) {</span>
<span class="nc" id="L1258">            return;</span>
        }

<span class="nc bnc" id="L1261" title="All 2 branches missed.">        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L1262">            focusLog.finer(&quot;Dequeue at {0} for {1}&quot;,</span>
<span class="nc" id="L1263">                       after, untilFocused);</span>
        }

        TypeAheadMarker marker;
<span class="nc bnc" id="L1267" title="All 2 branches missed.">        ListIterator&lt;TypeAheadMarker&gt; iter = typeAheadMarkers.listIterator</span>
<span class="nc" id="L1268">            ((after &gt;= 0) ? typeAheadMarkers.size() : 0);</span>

<span class="nc bnc" id="L1270" title="All 2 branches missed.">        if (after &lt; 0) {</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L1272">                marker = iter.next();</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">                if (marker.untilFocused == untilFocused)</span>
                {
<span class="nc" id="L1275">                    iter.remove();</span>
<span class="nc" id="L1276">                    return;</span>
                }
            }
        } else {
<span class="nc bnc" id="L1280" title="All 2 branches missed.">            while (iter.hasPrevious()) {</span>
<span class="nc" id="L1281">                marker = iter.previous();</span>
<span class="nc bnc" id="L1282" title="All 4 branches missed.">                if (marker.untilFocused == untilFocused &amp;&amp;</span>
                    marker.after == after)
                {
<span class="nc" id="L1285">                    iter.remove();</span>
<span class="nc" id="L1286">                    return;</span>
                }
            }
        }
<span class="nc" id="L1290">    }</span>

    /**
     * Discards all KeyEvents which were enqueued because of one or more calls
     * to &lt;code&gt;enqueueKeyEvents&lt;/code&gt; with the specified Component, or one of
     * its descendants.
     *
     * @param comp the Component specified in one or more calls to
     *        &lt;code&gt;enqueueKeyEvents&lt;/code&gt;, or a parent of such a Component
     * @see #enqueueKeyEvents
     * @see #dequeueKeyEvents
     */
    protected synchronized void discardKeyEvents(Component comp) {
<span class="nc bnc" id="L1303" title="All 2 branches missed.">        if (comp == null) {</span>
<span class="nc" id="L1304">            return;</span>
        }

<span class="nc" id="L1307">        long start = -1;</span>

<span class="nc bnc" id="L1309" title="All 2 branches missed.">        for (Iterator&lt;TypeAheadMarker&gt; iter = typeAheadMarkers.iterator(); iter.hasNext(); ) {</span>
<span class="nc" id="L1310">            TypeAheadMarker marker = iter.next();</span>
<span class="nc" id="L1311">            Component toTest = marker.untilFocused;</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">            boolean match = (toTest == comp);</span>
<span class="nc bnc" id="L1313" title="All 6 branches missed.">            while (!match &amp;&amp; toTest != null &amp;&amp; !(toTest instanceof Window)) {</span>
<span class="nc" id="L1314">                toTest = toTest.getParent();</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">                match = (toTest == comp);</span>
            }
<span class="nc bnc" id="L1317" title="All 2 branches missed.">            if (match) {</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">                if (start &lt; 0) {</span>
<span class="nc" id="L1319">                    start = marker.after;</span>
                }
<span class="nc" id="L1321">                iter.remove();</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">            } else if (start &gt;= 0) {</span>
<span class="nc" id="L1323">                purgeStampedEvents(start, marker.after);</span>
<span class="nc" id="L1324">                start = -1;</span>
            }
<span class="nc" id="L1326">        }</span>

<span class="nc" id="L1328">        purgeStampedEvents(start, -1);</span>
<span class="nc" id="L1329">    }</span>

    // Notes:
    //   * must be called inside a synchronized block
    //   * if 'start' is &lt; 0, then this function does nothing
    //   * if 'end' is &lt; 0, then all KeyEvents from 'start' to the end of the
    //     queue will be removed
    private void purgeStampedEvents(long start, long end) {
<span class="nc bnc" id="L1337" title="All 2 branches missed.">        if (start &lt; 0) {</span>
<span class="nc" id="L1338">            return;</span>
        }

<span class="nc bnc" id="L1341" title="All 2 branches missed.">        for (Iterator&lt;KeyEvent&gt; iter = enqueuedKeyEvents.iterator(); iter.hasNext(); ) {</span>
<span class="nc" id="L1342">            KeyEvent ke = iter.next();</span>
<span class="nc" id="L1343">            long time = ke.getWhen();</span>

<span class="nc bnc" id="L1345" title="All 6 branches missed.">            if (start &lt; time &amp;&amp; (end &lt; 0 || time &lt;= end)) {</span>
<span class="nc" id="L1346">                iter.remove();</span>
            }

<span class="nc bnc" id="L1349" title="All 4 branches missed.">            if (end &gt;= 0 &amp;&amp; time &gt; end) {</span>
<span class="nc" id="L1350">                break;</span>
            }
<span class="nc" id="L1352">        }</span>
<span class="nc" id="L1353">    }</span>

    /**
     * Focuses the Component before aComponent, typically based on a
     * FocusTraversalPolicy.
     *
     * @param aComponent the Component that is the basis for the focus
     *        traversal operation
     * @see FocusTraversalPolicy
     * @see Component#transferFocusBackward
     */
    public void focusPreviousComponent(Component aComponent) {
<span class="nc bnc" id="L1365" title="All 2 branches missed.">        if (aComponent != null) {</span>
<span class="nc" id="L1366">            aComponent.transferFocusBackward();</span>
        }
<span class="nc" id="L1368">    }</span>

    /**
     * Focuses the Component after aComponent, typically based on a
     * FocusTraversalPolicy.
     *
     * @param aComponent the Component that is the basis for the focus
     *        traversal operation
     * @see FocusTraversalPolicy
     * @see Component#transferFocus
     */
    public void focusNextComponent(Component aComponent) {
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        if (aComponent != null) {</span>
<span class="nc" id="L1381">            aComponent.transferFocus();</span>
        }
<span class="nc" id="L1383">    }</span>

    /**
     * Moves the focus up one focus traversal cycle. Typically, the focus owner
     * is set to aComponent's focus cycle root, and the current focus cycle
     * root is set to the new focus owner's focus cycle root. If, however,
     * aComponent's focus cycle root is a Window, then the focus owner is set
     * to the focus cycle root's default Component to focus, and the current
     * focus cycle root is unchanged.
     *
     * @param aComponent the Component that is the basis for the focus
     *        traversal operation
     * @see Component#transferFocusUpCycle
     */
    public void upFocusCycle(Component aComponent) {
<span class="nc bnc" id="L1398" title="All 2 branches missed.">        if (aComponent != null) {</span>
<span class="nc" id="L1399">            aComponent.transferFocusUpCycle();</span>
        }
<span class="nc" id="L1401">    }</span>

    /**
     * Moves the focus down one focus traversal cycle. If aContainer is a focus
     * cycle root, then the focus owner is set to aContainer's default
     * Component to focus, and the current focus cycle root is set to
     * aContainer. If aContainer is not a focus cycle root, then no focus
     * traversal operation occurs.
     *
     * @param aContainer the Container that is the basis for the focus
     *        traversal operation
     * @see Container#transferFocusDownCycle
     */
    public void downFocusCycle(Container aContainer) {
<span class="nc bnc" id="L1415" title="All 4 branches missed.">        if (aContainer != null &amp;&amp; aContainer.isFocusCycleRoot()) {</span>
<span class="nc" id="L1416">            aContainer.transferFocusDownCycle();</span>
        }
<span class="nc" id="L1418">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>