<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Polygon.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">Polygon.java</span></div><h1>Polygon.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt;

import java.awt.geom.AffineTransform;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import sun.awt.geom.Crossings;
import java.util.Arrays;

/**
 * The &lt;code&gt;Polygon&lt;/code&gt; class encapsulates a description of a
 * closed, two-dimensional region within a coordinate space. This
 * region is bounded by an arbitrary number of line segments, each of
 * which is one side of the polygon. Internally, a polygon
 * comprises of a list of {@code (x,y)}
 * coordinate pairs, where each pair defines a &lt;i&gt;vertex&lt;/i&gt; of the
 * polygon, and two successive pairs are the endpoints of a
 * line that is a side of the polygon. The first and final
 * pairs of {@code (x,y)} points are joined by a line segment
 * that closes the polygon.  This &lt;code&gt;Polygon&lt;/code&gt; is defined with
 * an even-odd winding rule.  See
 * {@link java.awt.geom.PathIterator#WIND_EVEN_ODD WIND_EVEN_ODD}
 * for a definition of the even-odd winding rule.
 * This class's hit-testing methods, which include the
 * &lt;code&gt;contains&lt;/code&gt;, &lt;code&gt;intersects&lt;/code&gt; and &lt;code&gt;inside&lt;/code&gt;
 * methods, use the &lt;i&gt;insideness&lt;/i&gt; definition described in the
 * {@link Shape} class comments.
 *
 * @author      Sami Shaio
 * @see Shape
 * @author      Herb Jellinek
 * @since       1.0
 */
public class Polygon implements Shape, java.io.Serializable {

    /**
     * The total number of points.  The value of &lt;code&gt;npoints&lt;/code&gt;
     * represents the number of valid points in this &lt;code&gt;Polygon&lt;/code&gt;
     * and might be less than the number of elements in
     * {@link #xpoints xpoints} or {@link #ypoints ypoints}.
     * This value can be NULL.
     *
     * @serial
     * @see #addPoint(int, int)
     * @since 1.0
     */
    public int npoints;

    /**
     * The array of X coordinates.  The number of elements in
     * this array might be more than the number of X coordinates
     * in this &lt;code&gt;Polygon&lt;/code&gt;.  The extra elements allow new points
     * to be added to this &lt;code&gt;Polygon&lt;/code&gt; without re-creating this
     * array.  The value of {@link #npoints npoints} is equal to the
     * number of valid points in this &lt;code&gt;Polygon&lt;/code&gt;.
     *
     * @serial
     * @see #addPoint(int, int)
     * @since 1.0
     */
    public int xpoints[];

    /**
     * The array of Y coordinates.  The number of elements in
     * this array might be more than the number of Y coordinates
     * in this &lt;code&gt;Polygon&lt;/code&gt;.  The extra elements allow new points
     * to be added to this &lt;code&gt;Polygon&lt;/code&gt; without re-creating this
     * array.  The value of &lt;code&gt;npoints&lt;/code&gt; is equal to the
     * number of valid points in this &lt;code&gt;Polygon&lt;/code&gt;.
     *
     * @serial
     * @see #addPoint(int, int)
     * @since 1.0
     */
    public int ypoints[];

    /**
     * The bounds of this {@code Polygon}.
     * This value can be null.
     *
     * @serial
     * @see #getBoundingBox()
     * @see #getBounds()
     * @since 1.0
     */
    protected Rectangle bounds;

    /*
     * JDK 1.1 serialVersionUID
     */
    private static final long serialVersionUID = -6460061437900069969L;

    /*
     * Default length for xpoints and ypoints.
     */
    private static final int MIN_LENGTH = 4;

    /**
     * Creates an empty polygon.
     * @since 1.0
     */
<span class="nc" id="L126">    public Polygon() {</span>
<span class="nc" id="L127">        xpoints = new int[MIN_LENGTH];</span>
<span class="nc" id="L128">        ypoints = new int[MIN_LENGTH];</span>
<span class="nc" id="L129">    }</span>

    /**
     * Constructs and initializes a &lt;code&gt;Polygon&lt;/code&gt; from the specified
     * parameters.
     * @param xpoints an array of X coordinates
     * @param ypoints an array of Y coordinates
     * @param npoints the total number of points in the
     *                          &lt;code&gt;Polygon&lt;/code&gt;
     * @exception  NegativeArraySizeException if the value of
     *                       &lt;code&gt;npoints&lt;/code&gt; is negative.
     * @exception  IndexOutOfBoundsException if &lt;code&gt;npoints&lt;/code&gt; is
     *             greater than the length of &lt;code&gt;xpoints&lt;/code&gt;
     *             or the length of &lt;code&gt;ypoints&lt;/code&gt;.
     * @exception  NullPointerException if &lt;code&gt;xpoints&lt;/code&gt; or
     *             &lt;code&gt;ypoints&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @since 1.0
     */
<span class="nc" id="L147">    public Polygon(int xpoints[], int ypoints[], int npoints) {</span>
        // Fix 4489009: should throw IndexOutofBoundsException instead
        // of OutofMemoryException if npoints is huge and &gt; {x,y}points.length
<span class="nc bnc" id="L150" title="All 4 branches missed.">        if (npoints &gt; xpoints.length || npoints &gt; ypoints.length) {</span>
<span class="nc" id="L151">            throw new IndexOutOfBoundsException(&quot;npoints &gt; xpoints.length || &quot;+</span>
                                                &quot;npoints &gt; ypoints.length&quot;);
        }
        // Fix 6191114: should throw NegativeArraySizeException with
        // negative npoints
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (npoints &lt; 0) {</span>
<span class="nc" id="L157">            throw new NegativeArraySizeException(&quot;npoints &lt; 0&quot;);</span>
        }
        // Fix 6343431: Applet compatibility problems if arrays are not
        // exactly npoints in length
<span class="nc" id="L161">        this.npoints = npoints;</span>
<span class="nc" id="L162">        this.xpoints = Arrays.copyOf(xpoints, npoints);</span>
<span class="nc" id="L163">        this.ypoints = Arrays.copyOf(ypoints, npoints);</span>
<span class="nc" id="L164">    }</span>

    /**
     * Resets this &lt;code&gt;Polygon&lt;/code&gt; object to an empty polygon.
     * The coordinate arrays and the data in them are left untouched
     * but the number of points is reset to zero to mark the old
     * vertex data as invalid and to start accumulating new vertex
     * data at the beginning.
     * All internally-cached data relating to the old vertices
     * are discarded.
     * Note that since the coordinate arrays from before the reset
     * are reused, creating a new empty &lt;code&gt;Polygon&lt;/code&gt; might
     * be more memory efficient than resetting the current one if
     * the number of vertices in the new polygon data is significantly
     * smaller than the number of vertices in the data from before the
     * reset.
     * @see         java.awt.Polygon#invalidate
     * @since 1.4
     */
    public void reset() {
<span class="nc" id="L184">        npoints = 0;</span>
<span class="nc" id="L185">        bounds = null;</span>
<span class="nc" id="L186">    }</span>

    /**
     * Invalidates or flushes any internally-cached data that depends
     * on the vertex coordinates of this &lt;code&gt;Polygon&lt;/code&gt;.
     * This method should be called after any direct manipulation
     * of the coordinates in the &lt;code&gt;xpoints&lt;/code&gt; or
     * &lt;code&gt;ypoints&lt;/code&gt; arrays to avoid inconsistent results
     * from methods such as &lt;code&gt;getBounds&lt;/code&gt; or &lt;code&gt;contains&lt;/code&gt;
     * that might cache data from earlier computations relating to
     * the vertex coordinates.
     * @see         java.awt.Polygon#getBounds
     * @since 1.4
     */
    public void invalidate() {
<span class="nc" id="L201">        bounds = null;</span>
<span class="nc" id="L202">    }</span>

    /**
     * Translates the vertices of the &lt;code&gt;Polygon&lt;/code&gt; by
     * &lt;code&gt;deltaX&lt;/code&gt; along the x axis and by
     * &lt;code&gt;deltaY&lt;/code&gt; along the y axis.
     * @param deltaX the amount to translate along the X axis
     * @param deltaY the amount to translate along the Y axis
     * @since 1.1
     */
    public void translate(int deltaX, int deltaY) {
<span class="nc bnc" id="L213" title="All 2 branches missed.">        for (int i = 0; i &lt; npoints; i++) {</span>
<span class="nc" id="L214">            xpoints[i] += deltaX;</span>
<span class="nc" id="L215">            ypoints[i] += deltaY;</span>
        }
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (bounds != null) {</span>
<span class="nc" id="L218">            bounds.translate(deltaX, deltaY);</span>
        }
<span class="nc" id="L220">    }</span>

    /*
     * Calculates the bounding box of the points passed to the constructor.
     * Sets &lt;code&gt;bounds&lt;/code&gt; to the result.
     * @param xpoints[] array of &lt;i&gt;x&lt;/i&gt; coordinates
     * @param ypoints[] array of &lt;i&gt;y&lt;/i&gt; coordinates
     * @param npoints the total number of points
     */
    void calculateBounds(int xpoints[], int ypoints[], int npoints) {
<span class="nc" id="L230">        int boundsMinX = Integer.MAX_VALUE;</span>
<span class="nc" id="L231">        int boundsMinY = Integer.MAX_VALUE;</span>
<span class="nc" id="L232">        int boundsMaxX = Integer.MIN_VALUE;</span>
<span class="nc" id="L233">        int boundsMaxY = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L235" title="All 2 branches missed.">        for (int i = 0; i &lt; npoints; i++) {</span>
<span class="nc" id="L236">            int x = xpoints[i];</span>
<span class="nc" id="L237">            boundsMinX = Math.min(boundsMinX, x);</span>
<span class="nc" id="L238">            boundsMaxX = Math.max(boundsMaxX, x);</span>
<span class="nc" id="L239">            int y = ypoints[i];</span>
<span class="nc" id="L240">            boundsMinY = Math.min(boundsMinY, y);</span>
<span class="nc" id="L241">            boundsMaxY = Math.max(boundsMaxY, y);</span>
        }
<span class="nc" id="L243">        bounds = new Rectangle(boundsMinX, boundsMinY,</span>
                               boundsMaxX - boundsMinX,
                               boundsMaxY - boundsMinY);
<span class="nc" id="L246">    }</span>

    /*
     * Resizes the bounding box to accommodate the specified coordinates.
     * @param x,&amp;nbsp;y the specified coordinates
     */
    void updateBounds(int x, int y) {
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (x &lt; bounds.x) {</span>
<span class="nc" id="L254">            bounds.width = bounds.width + (bounds.x - x);</span>
<span class="nc" id="L255">            bounds.x = x;</span>
        }
        else {
<span class="nc" id="L258">            bounds.width = Math.max(bounds.width, x - bounds.x);</span>
            // bounds.x = bounds.x;
        }

<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (y &lt; bounds.y) {</span>
<span class="nc" id="L263">            bounds.height = bounds.height + (bounds.y - y);</span>
<span class="nc" id="L264">            bounds.y = y;</span>
        }
        else {
<span class="nc" id="L267">            bounds.height = Math.max(bounds.height, y - bounds.y);</span>
            // bounds.y = bounds.y;
        }
<span class="nc" id="L270">    }</span>

    /**
     * Appends the specified coordinates to this &lt;code&gt;Polygon&lt;/code&gt;.
     * &lt;p&gt;
     * If an operation that calculates the bounding box of this
     * &lt;code&gt;Polygon&lt;/code&gt; has already been performed, such as
     * &lt;code&gt;getBounds&lt;/code&gt; or &lt;code&gt;contains&lt;/code&gt;, then this
     * method updates the bounding box.
     * @param       x the specified X coordinate
     * @param       y the specified Y coordinate
     * @see         java.awt.Polygon#getBounds
     * @see         java.awt.Polygon#contains
     * @since 1.0
     */
    public void addPoint(int x, int y) {
<span class="nc bnc" id="L286" title="All 4 branches missed.">        if (npoints &gt;= xpoints.length || npoints &gt;= ypoints.length) {</span>
<span class="nc" id="L287">            int newLength = npoints * 2;</span>
            // Make sure that newLength will be greater than MIN_LENGTH and
            // aligned to the power of 2
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (newLength &lt; MIN_LENGTH) {</span>
<span class="nc" id="L291">                newLength = MIN_LENGTH;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            } else if ((newLength &amp; (newLength - 1)) != 0) {</span>
<span class="nc" id="L293">                newLength = Integer.highestOneBit(newLength);</span>
            }

<span class="nc" id="L296">            xpoints = Arrays.copyOf(xpoints, newLength);</span>
<span class="nc" id="L297">            ypoints = Arrays.copyOf(ypoints, newLength);</span>
        }
<span class="nc" id="L299">        xpoints[npoints] = x;</span>
<span class="nc" id="L300">        ypoints[npoints] = y;</span>
<span class="nc" id="L301">        npoints++;</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (bounds != null) {</span>
<span class="nc" id="L303">            updateBounds(x, y);</span>
        }
<span class="nc" id="L305">    }</span>

    /**
     * Gets the bounding box of this &lt;code&gt;Polygon&lt;/code&gt;.
     * The bounding box is the smallest {@link Rectangle} whose
     * sides are parallel to the x and y axes of the
     * coordinate space, and can completely contain the &lt;code&gt;Polygon&lt;/code&gt;.
     * @return a &lt;code&gt;Rectangle&lt;/code&gt; that defines the bounds of this
     * &lt;code&gt;Polygon&lt;/code&gt;.
     * @since 1.1
     */
    public Rectangle getBounds() {
<span class="nc" id="L317">        return getBoundingBox();</span>
    }

    /**
     * Returns the bounds of this &lt;code&gt;Polygon&lt;/code&gt;.
     * @return the bounds of this &lt;code&gt;Polygon&lt;/code&gt;.
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;getBounds()&lt;/code&gt;.
     * @since 1.0
     */
    @Deprecated
    public Rectangle getBoundingBox() {
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (npoints == 0) {</span>
<span class="nc" id="L330">            return new Rectangle();</span>
        }
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (bounds == null) {</span>
<span class="nc" id="L333">            calculateBounds(xpoints, ypoints, npoints);</span>
        }
<span class="nc" id="L335">        return bounds.getBounds();</span>
    }

    /**
     * Determines whether the specified {@link Point} is inside this
     * &lt;code&gt;Polygon&lt;/code&gt;.
     * @param p the specified &lt;code&gt;Point&lt;/code&gt; to be tested
     * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Polygon&lt;/code&gt; contains the
     *                  &lt;code&gt;Point&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see #contains(double, double)
     * @since 1.0
     */
    public boolean contains(Point p) {
<span class="nc" id="L348">        return contains(p.x, p.y);</span>
    }

    /**
     * Determines whether the specified coordinates are inside this
     * &lt;code&gt;Polygon&lt;/code&gt;.
     * &lt;p&gt;
     * @param x the specified X coordinate to be tested
     * @param y the specified Y coordinate to be tested
     * @return {@code true} if this {@code Polygon} contains
     *         the specified coordinates {@code (x,y)};
     *         {@code false} otherwise.
     * @see #contains(double, double)
     * @since 1.1
     */
    public boolean contains(int x, int y) {
<span class="nc" id="L364">        return contains((double) x, (double) y);</span>
    }

    /**
     * Determines whether the specified coordinates are contained in this
     * &lt;code&gt;Polygon&lt;/code&gt;.
     * @param x the specified X coordinate to be tested
     * @param y the specified Y coordinate to be tested
     * @return {@code true} if this {@code Polygon} contains
     *         the specified coordinates {@code (x,y)};
     *         {@code false} otherwise.
     * @see #contains(double, double)
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;contains(int, int)&lt;/code&gt;.
     * @since 1.0
     */
    @Deprecated
    public boolean inside(int x, int y) {
<span class="nc" id="L382">        return contains((double) x, (double) y);</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public Rectangle2D getBounds2D() {
<span class="nc" id="L390">        return getBounds();</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public boolean contains(double x, double y) {
<span class="nc bnc" id="L398" title="All 4 branches missed.">        if (npoints &lt;= 2 || !getBoundingBox().contains(x, y)) {</span>
<span class="nc" id="L399">            return false;</span>
        }
<span class="nc" id="L401">        int hits = 0;</span>

<span class="nc" id="L403">        int lastx = xpoints[npoints - 1];</span>
<span class="nc" id="L404">        int lasty = ypoints[npoints - 1];</span>
        int curx, cury;

        // Walk the edges of the polygon
<span class="nc bnc" id="L408" title="All 2 branches missed.">        for (int i = 0; i &lt; npoints; lastx = curx, lasty = cury, i++) {</span>
<span class="nc" id="L409">            curx = xpoints[i];</span>
<span class="nc" id="L410">            cury = ypoints[i];</span>

<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (cury == lasty) {</span>
<span class="nc" id="L413">                continue;</span>
            }

            int leftx;
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (curx &lt; lastx) {</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                if (x &gt;= lastx) {</span>
<span class="nc" id="L419">                    continue;</span>
                }
<span class="nc" id="L421">                leftx = curx;</span>
            } else {
<span class="nc bnc" id="L423" title="All 2 branches missed.">                if (x &gt;= curx) {</span>
<span class="nc" id="L424">                    continue;</span>
                }
<span class="nc" id="L426">                leftx = lastx;</span>
            }

            double test1, test2;
<span class="nc bnc" id="L430" title="All 2 branches missed.">            if (cury &lt; lasty) {</span>
<span class="nc bnc" id="L431" title="All 4 branches missed.">                if (y &lt; cury || y &gt;= lasty) {</span>
<span class="nc" id="L432">                    continue;</span>
                }
<span class="nc bnc" id="L434" title="All 2 branches missed.">                if (x &lt; leftx) {</span>
<span class="nc" id="L435">                    hits++;</span>
<span class="nc" id="L436">                    continue;</span>
                }
<span class="nc" id="L438">                test1 = x - curx;</span>
<span class="nc" id="L439">                test2 = y - cury;</span>
            } else {
<span class="nc bnc" id="L441" title="All 4 branches missed.">                if (y &lt; lasty || y &gt;= cury) {</span>
<span class="nc" id="L442">                    continue;</span>
                }
<span class="nc bnc" id="L444" title="All 2 branches missed.">                if (x &lt; leftx) {</span>
<span class="nc" id="L445">                    hits++;</span>
<span class="nc" id="L446">                    continue;</span>
                }
<span class="nc" id="L448">                test1 = x - lastx;</span>
<span class="nc" id="L449">                test2 = y - lasty;</span>
            }

<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (test1 &lt; (test2 / (lasty - cury) * (lastx - curx))) {</span>
<span class="nc" id="L453">                hits++;</span>
            }
        }

<span class="nc bnc" id="L457" title="All 2 branches missed.">        return ((hits &amp; 1) != 0);</span>
    }

    private Crossings getCrossings(double xlo, double ylo,
                                   double xhi, double yhi)
    {
<span class="nc" id="L463">        Crossings cross = new Crossings.EvenOdd(xlo, ylo, xhi, yhi);</span>
<span class="nc" id="L464">        int lastx = xpoints[npoints - 1];</span>
<span class="nc" id="L465">        int lasty = ypoints[npoints - 1];</span>
        int curx, cury;

        // Walk the edges of the polygon
<span class="nc bnc" id="L469" title="All 2 branches missed.">        for (int i = 0; i &lt; npoints; i++) {</span>
<span class="nc" id="L470">            curx = xpoints[i];</span>
<span class="nc" id="L471">            cury = ypoints[i];</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            if (cross.accumulateLine(lastx, lasty, curx, cury)) {</span>
<span class="nc" id="L473">                return null;</span>
            }
<span class="nc" id="L475">            lastx = curx;</span>
<span class="nc" id="L476">            lasty = cury;</span>
        }

<span class="nc" id="L479">        return cross;</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public boolean contains(Point2D p) {
<span class="nc" id="L487">        return contains(p.getX(), p.getY());</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public boolean intersects(double x, double y, double w, double h) {
<span class="nc bnc" id="L495" title="All 4 branches missed.">        if (npoints &lt;= 0 || !getBoundingBox().intersects(x, y, w, h)) {</span>
<span class="nc" id="L496">            return false;</span>
        }

<span class="nc" id="L499">        Crossings cross = getCrossings(x, y, x+w, y+h);</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">        return (cross == null || !cross.isEmpty());</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public boolean intersects(Rectangle2D r) {
<span class="nc" id="L508">        return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public boolean contains(double x, double y, double w, double h) {
<span class="nc bnc" id="L516" title="All 4 branches missed.">        if (npoints &lt;= 0 || !getBoundingBox().intersects(x, y, w, h)) {</span>
<span class="nc" id="L517">            return false;</span>
        }

<span class="nc" id="L520">        Crossings cross = getCrossings(x, y, x+w, y+h);</span>
<span class="nc bnc" id="L521" title="All 4 branches missed.">        return (cross != null &amp;&amp; cross.covers(y, y+h));</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public boolean contains(Rectangle2D r) {
<span class="nc" id="L529">        return contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());</span>
    }

    /**
     * Returns an iterator object that iterates along the boundary of this
     * &lt;code&gt;Polygon&lt;/code&gt; and provides access to the geometry
     * of the outline of this &lt;code&gt;Polygon&lt;/code&gt;.  An optional
     * {@link AffineTransform} can be specified so that the coordinates
     * returned in the iteration are transformed accordingly.
     * @param at an optional &lt;code&gt;AffineTransform&lt;/code&gt; to be applied to the
     *          coordinates as they are returned in the iteration, or
     *          &lt;code&gt;null&lt;/code&gt; if untransformed coordinates are desired
     * @return a {@link PathIterator} object that provides access to the
     *          geometry of this &lt;code&gt;Polygon&lt;/code&gt;.
     * @since 1.2
     */
    public PathIterator getPathIterator(AffineTransform at) {
<span class="nc" id="L546">        return new PolygonPathIterator(this, at);</span>
    }

    /**
     * Returns an iterator object that iterates along the boundary of
     * the &lt;code&gt;Shape&lt;/code&gt; and provides access to the geometry of the
     * outline of the &lt;code&gt;Shape&lt;/code&gt;.  Only SEG_MOVETO, SEG_LINETO, and
     * SEG_CLOSE point types are returned by the iterator.
     * Since polygons are already flat, the &lt;code&gt;flatness&lt;/code&gt; parameter
     * is ignored.  An optional &lt;code&gt;AffineTransform&lt;/code&gt; can be specified
     * in which case the coordinates returned in the iteration are transformed
     * accordingly.
     * @param at an optional &lt;code&gt;AffineTransform&lt;/code&gt; to be applied to the
     *          coordinates as they are returned in the iteration, or
     *          &lt;code&gt;null&lt;/code&gt; if untransformed coordinates are desired
     * @param flatness the maximum amount that the control points
     *          for a given curve can vary from colinear before a subdivided
     *          curve is replaced by a straight line connecting the
     *          endpoints.  Since polygons are already flat the
     *          &lt;code&gt;flatness&lt;/code&gt; parameter is ignored.
     * @return a &lt;code&gt;PathIterator&lt;/code&gt; object that provides access to the
     *          &lt;code&gt;Shape&lt;/code&gt; object's geometry.
     * @since 1.2
     */
    public PathIterator getPathIterator(AffineTransform at, double flatness) {
<span class="nc" id="L571">        return getPathIterator(at);</span>
    }

    class PolygonPathIterator implements PathIterator {
        Polygon poly;
        AffineTransform transform;
        int index;

<span class="nc" id="L579">        public PolygonPathIterator(Polygon pg, AffineTransform at) {</span>
<span class="nc" id="L580">            poly = pg;</span>
<span class="nc" id="L581">            transform = at;</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (pg.npoints == 0) {</span>
                // Prevent a spurious SEG_CLOSE segment
<span class="nc" id="L584">                index = 1;</span>
            }
<span class="nc" id="L586">        }</span>

        /**
         * Returns the winding rule for determining the interior of the
         * path.
         * @return an integer representing the current winding rule.
         * @see PathIterator#WIND_NON_ZERO
         */
        public int getWindingRule() {
<span class="nc" id="L595">            return WIND_EVEN_ODD;</span>
        }

        /**
         * Tests if there are more points to read.
         * @return &lt;code&gt;true&lt;/code&gt; if there are more points to read;
         *          &lt;code&gt;false&lt;/code&gt; otherwise.
         */
        public boolean isDone() {
<span class="nc bnc" id="L604" title="All 2 branches missed.">            return index &gt; poly.npoints;</span>
        }

        /**
         * Moves the iterator forwards, along the primary direction of
         * traversal, to the next segment of the path when there are
         * more points in that direction.
         */
        public void next() {
<span class="nc" id="L613">            index++;</span>
<span class="nc" id="L614">        }</span>

        /**
         * Returns the coordinates and type of the current path segment in
         * the iteration.
         * The return value is the path segment type:
         * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.
         * A &lt;code&gt;float&lt;/code&gt; array of length 2 must be passed in and
         * can be used to store the coordinates of the point(s).
         * Each point is stored as a pair of &lt;code&gt;float&lt;/code&gt; x,&amp;nbsp;y
         * coordinates.  SEG_MOVETO and SEG_LINETO types return one
         * point, and SEG_CLOSE does not return any points.
         * @param coords a &lt;code&gt;float&lt;/code&gt; array that specifies the
         * coordinates of the point(s)
         * @return an integer representing the type and coordinates of the
         *              current path segment.
         * @see PathIterator#SEG_MOVETO
         * @see PathIterator#SEG_LINETO
         * @see PathIterator#SEG_CLOSE
         */
        public int currentSegment(float[] coords) {
<span class="nc bnc" id="L635" title="All 2 branches missed.">            if (index &gt;= poly.npoints) {</span>
<span class="nc" id="L636">                return SEG_CLOSE;</span>
            }
<span class="nc" id="L638">            coords[0] = poly.xpoints[index];</span>
<span class="nc" id="L639">            coords[1] = poly.ypoints[index];</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">            if (transform != null) {</span>
<span class="nc" id="L641">                transform.transform(coords, 0, coords, 0, 1);</span>
            }
<span class="nc bnc" id="L643" title="All 2 branches missed.">            return (index == 0 ? SEG_MOVETO : SEG_LINETO);</span>
        }

        /**
         * Returns the coordinates and type of the current path segment in
         * the iteration.
         * The return value is the path segment type:
         * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.
         * A &lt;code&gt;double&lt;/code&gt; array of length 2 must be passed in and
         * can be used to store the coordinates of the point(s).
         * Each point is stored as a pair of &lt;code&gt;double&lt;/code&gt; x,&amp;nbsp;y
         * coordinates.
         * SEG_MOVETO and SEG_LINETO types return one point,
         * and SEG_CLOSE does not return any points.
         * @param coords a &lt;code&gt;double&lt;/code&gt; array that specifies the
         * coordinates of the point(s)
         * @return an integer representing the type and coordinates of the
         *              current path segment.
         * @see PathIterator#SEG_MOVETO
         * @see PathIterator#SEG_LINETO
         * @see PathIterator#SEG_CLOSE
         */
        public int currentSegment(double[] coords) {
<span class="nc bnc" id="L666" title="All 2 branches missed.">            if (index &gt;= poly.npoints) {</span>
<span class="nc" id="L667">                return SEG_CLOSE;</span>
            }
<span class="nc" id="L669">            coords[0] = poly.xpoints[index];</span>
<span class="nc" id="L670">            coords[1] = poly.ypoints[index];</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">            if (transform != null) {</span>
<span class="nc" id="L672">                transform.transform(coords, 0, coords, 0, 1);</span>
            }
<span class="nc bnc" id="L674" title="All 2 branches missed.">            return (index == 0 ? SEG_MOVETO : SEG_LINETO);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>