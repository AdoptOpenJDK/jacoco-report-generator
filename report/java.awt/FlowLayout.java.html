<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FlowLayout.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt</a> &gt; <span class="el_source">FlowLayout.java</span></div><h1>FlowLayout.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt;

import java.io.ObjectInputStream;
import java.io.IOException;

/**
 * A flow layout arranges components in a directional flow, much
 * like lines of text in a paragraph. The flow direction is
 * determined by the container's &lt;code&gt;componentOrientation&lt;/code&gt;
 * property and may be one of two values:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;ComponentOrientation.LEFT_TO_RIGHT&lt;/code&gt;
 * &lt;li&gt;&lt;code&gt;ComponentOrientation.RIGHT_TO_LEFT&lt;/code&gt;
 * &lt;/ul&gt;
 * Flow layouts are typically used
 * to arrange buttons in a panel. It arranges buttons
 * horizontally until no more buttons fit on the same line.
 * The line alignment is determined by the &lt;code&gt;align&lt;/code&gt;
 * property. The possible values are:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #LEFT LEFT}
 * &lt;li&gt;{@link #RIGHT RIGHT}
 * &lt;li&gt;{@link #CENTER CENTER}
 * &lt;li&gt;{@link #LEADING LEADING}
 * &lt;li&gt;{@link #TRAILING TRAILING}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * For example, the following picture shows an applet using the flow
 * layout manager (its default layout manager) to position three buttons:
 * &lt;p&gt;
 * &lt;img src=&quot;doc-files/FlowLayout-1.gif&quot;
 * ALT=&quot;Graphic of Layout for Three Buttons&quot;
 * style=&quot;float:center; margin: 7px 10px;&quot;&gt;
 * &lt;p&gt;
 * Here is the code for this applet:
 * &lt;p&gt;
 * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
 * import java.awt.*;
 * import java.applet.Applet;
 *
 * public class myButtons extends Applet {
 *     Button button1, button2, button3;
 *     public void init() {
 *         button1 = new Button(&quot;Ok&quot;);
 *         button2 = new Button(&quot;Open&quot;);
 *         button3 = new Button(&quot;Close&quot;);
 *         add(button1);
 *         add(button2);
 *         add(button3);
 *     }
 * }
 * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
 * &lt;p&gt;
 * A flow layout lets each component assume its natural (preferred) size.
 *
 * @author      Arthur van Hoff
 * @author      Sami Shaio
 * @since       JDK1.0
 * @see ComponentOrientation
 */
public class FlowLayout implements LayoutManager, java.io.Serializable {

    /**
     * This value indicates that each row of components
     * should be left-justified.
     */
    public static final int LEFT        = 0;

    /**
     * This value indicates that each row of components
     * should be centered.
     */
    public static final int CENTER      = 1;

    /**
     * This value indicates that each row of components
     * should be right-justified.
     */
    public static final int RIGHT       = 2;

    /**
     * This value indicates that each row of components
     * should be justified to the leading edge of the container's
     * orientation, for example, to the left in left-to-right orientations.
     *
     * @see     java.awt.Component#getComponentOrientation
     * @see     java.awt.ComponentOrientation
     * @since   1.2
     */
    public static final int LEADING     = 3;

    /**
     * This value indicates that each row of components
     * should be justified to the trailing edge of the container's
     * orientation, for example, to the right in left-to-right orientations.
     *
     * @see     java.awt.Component#getComponentOrientation
     * @see     java.awt.ComponentOrientation
     * @since   1.2
     */
    public static final int TRAILING = 4;

    /**
     * &lt;code&gt;align&lt;/code&gt; is the property that determines
     * how each row distributes empty space.
     * It can be one of the following values:
     * &lt;ul&gt;
     * &lt;code&gt;LEFT&lt;/code&gt;
     * &lt;code&gt;RIGHT&lt;/code&gt;
     * &lt;code&gt;CENTER&lt;/code&gt;
     * &lt;/ul&gt;
     *
     * @serial
     * @see #getAlignment
     * @see #setAlignment
     */
    int align;          // This is for 1.1 serialization compatibility

    /**
     * &lt;code&gt;newAlign&lt;/code&gt; is the property that determines
     * how each row distributes empty space for the Java 2 platform,
     * v1.2 and greater.
     * It can be one of the following three values:
     * &lt;ul&gt;
     * &lt;code&gt;LEFT&lt;/code&gt;
     * &lt;code&gt;RIGHT&lt;/code&gt;
     * &lt;code&gt;CENTER&lt;/code&gt;
     * &lt;code&gt;LEADING&lt;/code&gt;
     * &lt;code&gt;TRAILING&lt;/code&gt;
     * &lt;/ul&gt;
     *
     * @serial
     * @since 1.2
     * @see #getAlignment
     * @see #setAlignment
     */
    int newAlign;       // This is the one we actually use

    /**
     * The flow layout manager allows a seperation of
     * components with gaps.  The horizontal gap will
     * specify the space between components and between
     * the components and the borders of the
     * &lt;code&gt;Container&lt;/code&gt;.
     *
     * @serial
     * @see #getHgap()
     * @see #setHgap(int)
     */
    int hgap;

    /**
     * The flow layout manager allows a seperation of
     * components with gaps.  The vertical gap will
     * specify the space between rows and between the
     * the rows and the borders of the &lt;code&gt;Container&lt;/code&gt;.
     *
     * @serial
     * @see #getHgap()
     * @see #setHgap(int)
     */
    int vgap;

    /**
     * If true, components will be aligned on their baseline.
     */
    private boolean alignOnBaseline;

    /*
     * JDK 1.1 serialVersionUID
     */
     private static final long serialVersionUID = -7262534875583282631L;

    /**
     * Constructs a new &lt;code&gt;FlowLayout&lt;/code&gt; with a centered alignment and a
     * default 5-unit horizontal and vertical gap.
     */
    public FlowLayout() {
<span class="nc" id="L203">        this(CENTER, 5, 5);</span>
<span class="nc" id="L204">    }</span>

    /**
     * Constructs a new &lt;code&gt;FlowLayout&lt;/code&gt; with the specified
     * alignment and a default 5-unit horizontal and vertical gap.
     * The value of the alignment argument must be one of
     * &lt;code&gt;FlowLayout.LEFT&lt;/code&gt;, &lt;code&gt;FlowLayout.RIGHT&lt;/code&gt;,
     * &lt;code&gt;FlowLayout.CENTER&lt;/code&gt;, &lt;code&gt;FlowLayout.LEADING&lt;/code&gt;,
     * or &lt;code&gt;FlowLayout.TRAILING&lt;/code&gt;.
     * @param align the alignment value
     */
    public FlowLayout(int align) {
<span class="nc" id="L216">        this(align, 5, 5);</span>
<span class="nc" id="L217">    }</span>

    /**
     * Creates a new flow layout manager with the indicated alignment
     * and the indicated horizontal and vertical gaps.
     * &lt;p&gt;
     * The value of the alignment argument must be one of
     * &lt;code&gt;FlowLayout.LEFT&lt;/code&gt;, &lt;code&gt;FlowLayout.RIGHT&lt;/code&gt;,
     * &lt;code&gt;FlowLayout.CENTER&lt;/code&gt;, &lt;code&gt;FlowLayout.LEADING&lt;/code&gt;,
     * or &lt;code&gt;FlowLayout.TRAILING&lt;/code&gt;.
     * @param      align   the alignment value
     * @param      hgap    the horizontal gap between components
     *                     and between the components and the
     *                     borders of the &lt;code&gt;Container&lt;/code&gt;
     * @param      vgap    the vertical gap between components
     *                     and between the components and the
     *                     borders of the &lt;code&gt;Container&lt;/code&gt;
     */
<span class="nc" id="L235">    public FlowLayout(int align, int hgap, int vgap) {</span>
<span class="nc" id="L236">        this.hgap = hgap;</span>
<span class="nc" id="L237">        this.vgap = vgap;</span>
<span class="nc" id="L238">        setAlignment(align);</span>
<span class="nc" id="L239">    }</span>

    /**
     * Gets the alignment for this layout.
     * Possible values are &lt;code&gt;FlowLayout.LEFT&lt;/code&gt;,
     * &lt;code&gt;FlowLayout.RIGHT&lt;/code&gt;, &lt;code&gt;FlowLayout.CENTER&lt;/code&gt;,
     * &lt;code&gt;FlowLayout.LEADING&lt;/code&gt;,
     * or &lt;code&gt;FlowLayout.TRAILING&lt;/code&gt;.
     * @return     the alignment value for this layout
     * @see        java.awt.FlowLayout#setAlignment
     * @since      JDK1.1
     */
    public int getAlignment() {
<span class="nc" id="L252">        return newAlign;</span>
    }

    /**
     * Sets the alignment for this layout.
     * Possible values are
     * &lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;FlowLayout.LEFT&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;FlowLayout.RIGHT&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;FlowLayout.CENTER&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;FlowLayout.LEADING&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;FlowLayout.TRAILING&lt;/code&gt;
     * &lt;/ul&gt;
     * @param      align one of the alignment values shown above
     * @see        #getAlignment()
     * @since      JDK1.1
     */
    public void setAlignment(int align) {
<span class="nc" id="L270">        this.newAlign = align;</span>

        // this.align is used only for serialization compatibility,
        // so set it to a value compatible with the 1.1 version
        // of the class

<span class="nc bnc" id="L276" title="All 3 branches missed.">        switch (align) {</span>
        case LEADING:
<span class="nc" id="L278">            this.align = LEFT;</span>
<span class="nc" id="L279">            break;</span>
        case TRAILING:
<span class="nc" id="L281">            this.align = RIGHT;</span>
<span class="nc" id="L282">            break;</span>
        default:
<span class="nc" id="L284">            this.align = align;</span>
            break;
        }
<span class="nc" id="L287">    }</span>

    /**
     * Gets the horizontal gap between components
     * and between the components and the borders
     * of the &lt;code&gt;Container&lt;/code&gt;
     *
     * @return     the horizontal gap between components
     *             and between the components and the borders
     *             of the &lt;code&gt;Container&lt;/code&gt;
     * @see        java.awt.FlowLayout#setHgap
     * @since      JDK1.1
     */
    public int getHgap() {
<span class="nc" id="L301">        return hgap;</span>
    }

    /**
     * Sets the horizontal gap between components and
     * between the components and the borders of the
     * &lt;code&gt;Container&lt;/code&gt;.
     *
     * @param hgap the horizontal gap between components
     *             and between the components and the borders
     *             of the &lt;code&gt;Container&lt;/code&gt;
     * @see        java.awt.FlowLayout#getHgap
     * @since      JDK1.1
     */
    public void setHgap(int hgap) {
<span class="nc" id="L316">        this.hgap = hgap;</span>
<span class="nc" id="L317">    }</span>

    /**
     * Gets the vertical gap between components and
     * between the components and the borders of the
     * &lt;code&gt;Container&lt;/code&gt;.
     *
     * @return     the vertical gap between components
     *             and between the components and the borders
     *             of the &lt;code&gt;Container&lt;/code&gt;
     * @see        java.awt.FlowLayout#setVgap
     * @since      JDK1.1
     */
    public int getVgap() {
<span class="nc" id="L331">        return vgap;</span>
    }

    /**
     * Sets the vertical gap between components and between
     * the components and the borders of the &lt;code&gt;Container&lt;/code&gt;.
     *
     * @param vgap the vertical gap between components
     *             and between the components and the borders
     *             of the &lt;code&gt;Container&lt;/code&gt;
     * @see        java.awt.FlowLayout#getVgap
     * @since      JDK1.1
     */
    public void setVgap(int vgap) {
<span class="nc" id="L345">        this.vgap = vgap;</span>
<span class="nc" id="L346">    }</span>

    /**
     * Sets whether or not components should be vertically aligned along their
     * baseline.  Components that do not have a baseline will be centered.
     * The default is false.
     *
     * @param alignOnBaseline whether or not components should be
     *                        vertically aligned on their baseline
     * @since 1.6
     */
    public void setAlignOnBaseline(boolean alignOnBaseline) {
<span class="nc" id="L358">        this.alignOnBaseline = alignOnBaseline;</span>
<span class="nc" id="L359">    }</span>

    /**
     * Returns true if components are to be vertically aligned along
     * their baseline.  The default is false.
     *
     * @return true if components are to be vertically aligned along
     *              their baseline
     * @since 1.6
     */
    public boolean getAlignOnBaseline() {
<span class="nc" id="L370">        return alignOnBaseline;</span>
    }

    /**
     * Adds the specified component to the layout.
     * Not used by this class.
     * @param name the name of the component
     * @param comp the component to be added
     */
    public void addLayoutComponent(String name, Component comp) {
<span class="nc" id="L380">    }</span>

    /**
     * Removes the specified component from the layout.
     * Not used by this class.
     * @param comp the component to remove
     * @see       java.awt.Container#removeAll
     */
    public void removeLayoutComponent(Component comp) {
<span class="nc" id="L389">    }</span>

    /**
     * Returns the preferred dimensions for this layout given the
     * &lt;i&gt;visible&lt;/i&gt; components in the specified target container.
     *
     * @param target the container that needs to be laid out
     * @return    the preferred dimensions to lay out the
     *            subcomponents of the specified container
     * @see Container
     * @see #minimumLayoutSize
     * @see       java.awt.Container#getPreferredSize
     */
    public Dimension preferredLayoutSize(Container target) {
<span class="nc" id="L403">      synchronized (target.getTreeLock()) {</span>
<span class="nc" id="L404">        Dimension dim = new Dimension(0, 0);</span>
<span class="nc" id="L405">        int nmembers = target.getComponentCount();</span>
<span class="nc" id="L406">        boolean firstVisibleComponent = true;</span>
<span class="nc" id="L407">        boolean useBaseline = getAlignOnBaseline();</span>
<span class="nc" id="L408">        int maxAscent = 0;</span>
<span class="nc" id="L409">        int maxDescent = 0;</span>

<span class="nc bnc" id="L411" title="All 2 branches missed.">        for (int i = 0 ; i &lt; nmembers ; i++) {</span>
<span class="nc" id="L412">            Component m = target.getComponent(i);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            if (m.isVisible()) {</span>
<span class="nc" id="L414">                Dimension d = m.getPreferredSize();</span>
<span class="nc" id="L415">                dim.height = Math.max(dim.height, d.height);</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                if (firstVisibleComponent) {</span>
<span class="nc" id="L417">                    firstVisibleComponent = false;</span>
                } else {
<span class="nc" id="L419">                    dim.width += hgap;</span>
                }
<span class="nc" id="L421">                dim.width += d.width;</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                if (useBaseline) {</span>
<span class="nc" id="L423">                    int baseline = m.getBaseline(d.width, d.height);</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">                    if (baseline &gt;= 0) {</span>
<span class="nc" id="L425">                        maxAscent = Math.max(maxAscent, baseline);</span>
<span class="nc" id="L426">                        maxDescent = Math.max(maxDescent, d.height - baseline);</span>
                    }
                }
            }
        }
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (useBaseline) {</span>
<span class="nc" id="L432">            dim.height = Math.max(maxAscent + maxDescent, dim.height);</span>
        }
<span class="nc" id="L434">        Insets insets = target.getInsets();</span>
<span class="nc" id="L435">        dim.width += insets.left + insets.right + hgap*2;</span>
<span class="nc" id="L436">        dim.height += insets.top + insets.bottom + vgap*2;</span>
<span class="nc" id="L437">        return dim;</span>
<span class="nc" id="L438">      }</span>
    }

    /**
     * Returns the minimum dimensions needed to layout the &lt;i&gt;visible&lt;/i&gt;
     * components contained in the specified target container.
     * @param target the container that needs to be laid out
     * @return    the minimum dimensions to lay out the
     *            subcomponents of the specified container
     * @see #preferredLayoutSize
     * @see       java.awt.Container
     * @see       java.awt.Container#doLayout
     */
    public Dimension minimumLayoutSize(Container target) {
<span class="nc" id="L452">      synchronized (target.getTreeLock()) {</span>
<span class="nc" id="L453">        boolean useBaseline = getAlignOnBaseline();</span>
<span class="nc" id="L454">        Dimension dim = new Dimension(0, 0);</span>
<span class="nc" id="L455">        int nmembers = target.getComponentCount();</span>
<span class="nc" id="L456">        int maxAscent = 0;</span>
<span class="nc" id="L457">        int maxDescent = 0;</span>
<span class="nc" id="L458">        boolean firstVisibleComponent = true;</span>

<span class="nc bnc" id="L460" title="All 2 branches missed.">        for (int i = 0 ; i &lt; nmembers ; i++) {</span>
<span class="nc" id="L461">            Component m = target.getComponent(i);</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">            if (m.visible) {</span>
<span class="nc" id="L463">                Dimension d = m.getMinimumSize();</span>
<span class="nc" id="L464">                dim.height = Math.max(dim.height, d.height);</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                if (firstVisibleComponent) {</span>
<span class="nc" id="L466">                    firstVisibleComponent = false;</span>
                } else {
<span class="nc" id="L468">                    dim.width += hgap;</span>
                }
<span class="nc" id="L470">                dim.width += d.width;</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">                if (useBaseline) {</span>
<span class="nc" id="L472">                    int baseline = m.getBaseline(d.width, d.height);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                    if (baseline &gt;= 0) {</span>
<span class="nc" id="L474">                        maxAscent = Math.max(maxAscent, baseline);</span>
<span class="nc" id="L475">                        maxDescent = Math.max(maxDescent,</span>
                                              dim.height - baseline);
                    }
                }
}
}

<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (useBaseline) {</span>
<span class="nc" id="L483">            dim.height = Math.max(maxAscent + maxDescent, dim.height);</span>
        }

<span class="nc" id="L486">        Insets insets = target.getInsets();</span>
<span class="nc" id="L487">        dim.width += insets.left + insets.right + hgap*2;</span>
<span class="nc" id="L488">        dim.height += insets.top + insets.bottom + vgap*2;</span>
<span class="nc" id="L489">        return dim;</span>





<span class="nc" id="L495">      }</span>
    }

    /**
     * Centers the elements in the specified row, if there is any slack.
     * @param target the component which needs to be moved
     * @param x the x coordinate
     * @param y the y coordinate
     * @param width the width dimensions
     * @param height the height dimensions
     * @param rowStart the beginning of the row
     * @param rowEnd the the ending of the row
     * @param useBaseline Whether or not to align on baseline.
     * @param ascent Ascent for the components. This is only valid if
     *               useBaseline is true.
     * @param descent Ascent for the components. This is only valid if
     *               useBaseline is true.
     * @return actual row height
     */
    private int moveComponents(Container target, int x, int y, int width, int height,
                                int rowStart, int rowEnd, boolean ltr,
                                boolean useBaseline, int[] ascent,
                                int[] descent) {
<span class="nc bnc" id="L518" title="All 6 branches missed.">        switch (newAlign) {</span>
        case LEFT:
<span class="nc bnc" id="L520" title="All 2 branches missed.">            x += ltr ? 0 : width;</span>
<span class="nc" id="L521">            break;</span>
        case CENTER:
<span class="nc" id="L523">            x += width / 2;</span>
<span class="nc" id="L524">            break;</span>
        case RIGHT:
<span class="nc bnc" id="L526" title="All 2 branches missed.">            x += ltr ? width : 0;</span>
<span class="nc" id="L527">            break;</span>
        case LEADING:
<span class="nc" id="L529">            break;</span>
        case TRAILING:
<span class="nc" id="L531">            x += width;</span>
            break;
        }
<span class="nc" id="L534">        int maxAscent = 0;</span>
<span class="nc" id="L535">        int nonbaselineHeight = 0;</span>
<span class="nc" id="L536">        int baselineOffset = 0;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (useBaseline) {</span>
<span class="nc" id="L538">            int maxDescent = 0;</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">            for (int i = rowStart ; i &lt; rowEnd ; i++) {</span>
<span class="nc" id="L540">                Component m = target.getComponent(i);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                if (m.visible) {</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">                    if (ascent[i] &gt;= 0) {</span>
<span class="nc" id="L543">                        maxAscent = Math.max(maxAscent, ascent[i]);</span>
<span class="nc" id="L544">                        maxDescent = Math.max(maxDescent, descent[i]);</span>
                    }
                    else {
<span class="nc" id="L547">                        nonbaselineHeight = Math.max(m.getHeight(),</span>
                                                     nonbaselineHeight);
                    }
                }
            }
<span class="nc" id="L552">            height = Math.max(maxAscent + maxDescent, nonbaselineHeight);</span>
<span class="nc" id="L553">            baselineOffset = (height - maxAscent - maxDescent) / 2;</span>
        }
<span class="nc bnc" id="L555" title="All 2 branches missed.">        for (int i = rowStart ; i &lt; rowEnd ; i++) {</span>
<span class="nc" id="L556">            Component m = target.getComponent(i);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            if (m.isVisible()) {</span>
                int cy;
<span class="nc bnc" id="L559" title="All 4 branches missed.">                if (useBaseline &amp;&amp; ascent[i] &gt;= 0) {</span>
<span class="nc" id="L560">                    cy = y + baselineOffset + maxAscent - ascent[i];</span>
                }
                else {
<span class="nc" id="L563">                    cy = y + (height - m.height) / 2;</span>
                }
<span class="nc bnc" id="L565" title="All 2 branches missed.">                if (ltr) {</span>
<span class="nc" id="L566">                    m.setLocation(x, cy);</span>
                } else {
<span class="nc" id="L568">                    m.setLocation(target.width - x - m.width, cy);</span>
                }
<span class="nc" id="L570">                x += m.width + hgap;</span>
            }
        }
<span class="nc" id="L573">        return height;</span>
    }

    /**
     * Lays out the container. This method lets each
     * &lt;i&gt;visible&lt;/i&gt; component take
     * its preferred size by reshaping the components in the
     * target container in order to satisfy the alignment of
     * this &lt;code&gt;FlowLayout&lt;/code&gt; object.
     *
     * @param target the specified component being laid out
     * @see Container
     * @see       java.awt.Container#doLayout
     */
    public void layoutContainer(Container target) {
<span class="nc" id="L588">      synchronized (target.getTreeLock()) {</span>
<span class="nc" id="L589">        Insets insets = target.getInsets();</span>
<span class="nc" id="L590">        int maxwidth = target.width - (insets.left + insets.right + hgap*2);</span>
<span class="nc" id="L591">        int nmembers = target.getComponentCount();</span>
<span class="nc" id="L592">        int x = 0, y = insets.top + vgap;</span>
<span class="nc" id="L593">        int rowh = 0, start = 0;</span>

<span class="nc" id="L595">        boolean ltr = target.getComponentOrientation().isLeftToRight();</span>

<span class="nc" id="L597">        boolean useBaseline = getAlignOnBaseline();</span>
<span class="nc" id="L598">        int[] ascent = null;</span>
<span class="nc" id="L599">        int[] descent = null;</span>

<span class="nc bnc" id="L601" title="All 2 branches missed.">        if (useBaseline) {</span>
<span class="nc" id="L602">            ascent = new int[nmembers];</span>
<span class="nc" id="L603">            descent = new int[nmembers];</span>
        }

<span class="nc bnc" id="L606" title="All 2 branches missed.">        for (int i = 0 ; i &lt; nmembers ; i++) {</span>
<span class="nc" id="L607">            Component m = target.getComponent(i);</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">            if (m.isVisible()) {</span>
<span class="nc" id="L609">                Dimension d = m.getPreferredSize();</span>
<span class="nc" id="L610">                m.setSize(d.width, d.height);</span>

<span class="nc bnc" id="L612" title="All 2 branches missed.">                if (useBaseline) {</span>
<span class="nc" id="L613">                    int baseline = m.getBaseline(d.width, d.height);</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">                    if (baseline &gt;= 0) {</span>
<span class="nc" id="L615">                        ascent[i] = baseline;</span>
<span class="nc" id="L616">                        descent[i] = d.height - baseline;</span>
                    }
                    else {
<span class="nc" id="L619">                        ascent[i] = -1;</span>
                    }
                }
<span class="nc bnc" id="L622" title="All 4 branches missed.">                if ((x == 0) || ((x + d.width) &lt;= maxwidth)) {</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">                    if (x &gt; 0) {</span>
<span class="nc" id="L624">                        x += hgap;</span>
                    }
<span class="nc" id="L626">                    x += d.width;</span>
<span class="nc" id="L627">                    rowh = Math.max(rowh, d.height);</span>
                } else {
<span class="nc" id="L629">                    rowh = moveComponents(target, insets.left + hgap, y,</span>
                                   maxwidth - x, rowh, start, i, ltr,
                                   useBaseline, ascent, descent);
<span class="nc" id="L632">                    x = d.width;</span>
<span class="nc" id="L633">                    y += vgap + rowh;</span>
<span class="nc" id="L634">                    rowh = d.height;</span>
<span class="nc" id="L635">                    start = i;</span>
                }
            }
        }
<span class="nc" id="L639">        moveComponents(target, insets.left + hgap, y, maxwidth - x, rowh,</span>
                       start, nmembers, ltr, useBaseline, ascent, descent);
<span class="nc" id="L641">      }</span>
<span class="nc" id="L642">    }</span>

    //
    // the internal serial version which says which version was written
    // - 0 (default) for versions before the Java 2 platform, v1.2
    // - 1 for version &gt;= Java 2 platform v1.2, which includes &quot;newAlign&quot; field
    //
    private static final int currentSerialVersion = 1;
    /**
     * This represent the &lt;code&gt;currentSerialVersion&lt;/code&gt;
     * which is bein used.  It will be one of two values :
     * &lt;code&gt;0&lt;/code&gt; versions before Java 2 platform v1.2..
     * &lt;code&gt;1&lt;/code&gt; versions after  Java 2 platform v1.2..
     *
     * @serial
     * @since 1.2
     */
<span class="nc" id="L659">    private int serialVersionOnStream = currentSerialVersion;</span>

    /**
     * Reads this object out of a serialization stream, handling
     * objects written by older versions of the class that didn't contain all
     * of the fields we use now..
     */
    private void readObject(ObjectInputStream stream)
         throws IOException, ClassNotFoundException
    {
<span class="nc" id="L669">        stream.defaultReadObject();</span>

<span class="nc bnc" id="L671" title="All 2 branches missed.">        if (serialVersionOnStream &lt; 1) {</span>
            // &quot;newAlign&quot; field wasn't present, so use the old &quot;align&quot; field.
<span class="nc" id="L673">            setAlignment(this.align);</span>
        }
<span class="nc" id="L675">        serialVersionOnStream = currentSerialVersion;</span>
<span class="nc" id="L676">    }</span>

    /**
     * Returns a string representation of this &lt;code&gt;FlowLayout&lt;/code&gt;
     * object and its values.
     * @return     a string representation of this layout
     */
    public String toString() {
<span class="nc" id="L684">        String str = &quot;&quot;;</span>
<span class="nc bnc" id="L685" title="All 6 branches missed.">        switch (align) {</span>
<span class="nc" id="L686">          case LEFT:        str = &quot;,align=left&quot;; break;</span>
<span class="nc" id="L687">          case CENTER:      str = &quot;,align=center&quot;; break;</span>
<span class="nc" id="L688">          case RIGHT:       str = &quot;,align=right&quot;; break;</span>
<span class="nc" id="L689">          case LEADING:     str = &quot;,align=leading&quot;; break;</span>
<span class="nc" id="L690">          case TRAILING:    str = &quot;,align=trailing&quot;; break;</span>
        }
<span class="nc" id="L692">        return getClass().getName() + &quot;[hgap=&quot; + hgap + &quot;,vgap=&quot; + vgap + str + &quot;]&quot;;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>