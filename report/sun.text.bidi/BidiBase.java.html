<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BidiBase.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.text.bidi</a> &gt; <span class="el_source">BidiBase.java</span></div><h1>BidiBase.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2009, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. and others, 1996-2009 - All Rights Reserved         *
 *                                                                             *
 * The original version of this source code and documentation is copyrighted   *
 * and owned by IBM, These materials are provided under terms of a License     *
 * Agreement between IBM and Sun. This technology is protected by multiple     *
 * US and International patents. This notice and attribution to IBM may not    *
 * to removed.                                                                 *
 *******************************************************************************
 */

/* FOOD FOR THOUGHT: currently the reordering modes are a mixture of
 * algorithm for direct BiDi, algorithm for inverse Bidi and the bizarre
 * concept of RUNS_ONLY which is a double operation.
 * It could be advantageous to divide this into 3 concepts:
 * a) Operation: direct / inverse / RUNS_ONLY
 * b) Direct algorithm: default / NUMBERS_SPECIAL / GROUP_NUMBERS_WITH_L
 * c) Inverse algorithm: default / INVERSE_LIKE_DIRECT / NUMBERS_SPECIAL
 * This would allow combinations not possible today like RUNS_ONLY with
 * NUMBERS_SPECIAL.
 * Also allow to set INSERT_MARKS for the direct step of RUNS_ONLY and
 * REMOVE_CONTROLS for the inverse step.
 * Not all combinations would be supported, and probably not all do make sense.
 * This would need to document which ones are supported and what are the
 * fallbacks for unsupported combinations.
 */

package sun.text.bidi;

import java.io.IOException;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.text.AttributedCharacterIterator;
import java.text.Bidi;
import java.util.Arrays;
import java.util.MissingResourceException;
import sun.text.normalizer.UBiDiProps;
import sun.text.normalizer.UCharacter;
import sun.text.normalizer.UTF16;

/**
 *
 * &lt;h2&gt;Bidi algorithm for ICU&lt;/h2&gt;
 *
 * This is an implementation of the Unicode Bidirectional algorithm. The
 * algorithm is defined in the &lt;a
 * href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;,
 * version 13, also described in The Unicode Standard, Version 4.0 .
 * &lt;p&gt;
 *
 * Note: Libraries that perform a bidirectional algorithm and reorder strings
 * accordingly are sometimes called &quot;Storage Layout Engines&quot;. ICU's Bidi and
 * shaping (ArabicShaping) classes can be used at the core of such &quot;Storage
 * Layout Engines&quot;.
 *
 * &lt;h3&gt;General remarks about the API:&lt;/h3&gt;
 *
 * The &amp;quot;limit&amp;quot; of a sequence of characters is the position just after
 * their last character, i.e., one more than that position.
 * &lt;p&gt;
 *
 * Some of the API methods provide access to &amp;quot;runs&amp;quot;. Such a
 * &amp;quot;run&amp;quot; is defined as a sequence of characters that are at the same
 * embedding level after performing the Bidi algorithm.
 * &lt;p&gt;
 *
 * &lt;h3&gt;Basic concept: paragraph&lt;/h3&gt;
 * A piece of text can be divided into several paragraphs by characters
 * with the Bidi class &lt;code&gt;Block Separator&lt;/code&gt;. For handling of
 * paragraphs, see:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #countParagraphs}
 * &lt;li&gt;{@link #getParaLevel}
 * &lt;li&gt;{@link #getParagraph}
 * &lt;li&gt;{@link #getParagraphByIndex}
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Basic concept: text direction&lt;/h3&gt;
 * The direction of a piece of text may be:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #LTR}
 * &lt;li&gt;{@link #RTL}
 * &lt;li&gt;{@link #MIXED}
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Basic concept: levels&lt;/h3&gt;
 *
 * Levels in this API represent embedding levels according to the Unicode
 * Bidirectional Algorithm.
 * Their low-order bit (even/odd value) indicates the visual direction.&lt;p&gt;
 *
 * Levels can be abstract values when used for the
 * &lt;code&gt;paraLevel&lt;/code&gt; and &lt;code&gt;embeddingLevels&lt;/code&gt;
 * arguments of &lt;code&gt;setPara()&lt;/code&gt;; there:
 * &lt;ul&gt;
 * &lt;li&gt;the high-order bit of an &lt;code&gt;embeddingLevels[]&lt;/code&gt;
 * value indicates whether the using application is
 * specifying the level of a character to &lt;i&gt;override&lt;/i&gt; whatever the
 * Bidi implementation would resolve it to.&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;paraLevel&lt;/code&gt; can be set to the
 * pseudo-level values &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt;
 * and &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt;.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The related constants are not real, valid level values.
 * &lt;code&gt;DEFAULT_XXX&lt;/code&gt; can be used to specify
 * a default for the paragraph level for
 * when the &lt;code&gt;setPara()&lt;/code&gt; method
 * shall determine it but there is no
 * strongly typed character in the input.&lt;p&gt;
 *
 * Note that the value for &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt; is even
 * and the one for &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt; is odd,
 * just like with normal LTR and RTL level values -
 * these special values are designed that way. Also, the implementation
 * assumes that MAX_EXPLICIT_LEVEL is odd.
 *
 * &lt;ul&gt;&lt;b&gt;See Also:&lt;/b&gt;
 * &lt;li&gt;{@link #LEVEL_DEFAULT_LTR}
 * &lt;li&gt;{@link #LEVEL_DEFAULT_RTL}
 * &lt;li&gt;{@link #LEVEL_OVERRIDE}
 * &lt;li&gt;{@link #MAX_EXPLICIT_LEVEL}
 * &lt;li&gt;{@link #setPara}
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Basic concept: Reordering Mode&lt;/h3&gt;
 * Reordering mode values indicate which variant of the Bidi algorithm to
 * use.
 *
 * &lt;ul&gt;&lt;b&gt;See Also:&lt;/b&gt;
 * &lt;li&gt;{@link #setReorderingMode}
 * &lt;li&gt;{@link #REORDER_DEFAULT}
 * &lt;li&gt;{@link #REORDER_NUMBERS_SPECIAL}
 * &lt;li&gt;{@link #REORDER_GROUP_NUMBERS_WITH_R}
 * &lt;li&gt;{@link #REORDER_RUNS_ONLY}
 * &lt;li&gt;{@link #REORDER_INVERSE_NUMBERS_AS_L}
 * &lt;li&gt;{@link #REORDER_INVERSE_LIKE_DIRECT}
 * &lt;li&gt;{@link #REORDER_INVERSE_FOR_NUMBERS_SPECIAL}
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Basic concept: Reordering Options&lt;/h3&gt;
 * Reordering options can be applied during Bidi text transformations.
 * &lt;ul&gt;&lt;b&gt;See Also:&lt;/b&gt;
 * &lt;li&gt;{@link #setReorderingOptions}
 * &lt;li&gt;{@link #OPTION_DEFAULT}
 * &lt;li&gt;{@link #OPTION_INSERT_MARKS}
 * &lt;li&gt;{@link #OPTION_REMOVE_CONTROLS}
 * &lt;li&gt;{@link #OPTION_STREAMING}
 * &lt;/ul&gt;
 *
 *
 * @author Simon Montagu, Matitiahu Allouche (ported from C code written by Markus W. Scherer)
 * @stable ICU 3.8
 *
 *
 * &lt;h4&gt; Sample code for the ICU Bidi API &lt;/h4&gt;
 *
 * &lt;h5&gt;Rendering a paragraph with the ICU Bidi API&lt;/h5&gt;
 *
 * This is (hypothetical) sample code that illustrates how the ICU Bidi API
 * could be used to render a paragraph of text. Rendering code depends highly on
 * the graphics system, therefore this sample code must make a lot of
 * assumptions, which may or may not match any existing graphics system's
 * properties.
 *
 * &lt;p&gt;
 * The basic assumptions are:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Rendering is done from left to right on a horizontal line.&lt;/li&gt;
 * &lt;li&gt;A run of single-style, unidirectional text can be rendered at once.
 * &lt;/li&gt;
 * &lt;li&gt;Such a run of text is passed to the graphics system with characters
 * (code units) in logical order.&lt;/li&gt;
 * &lt;li&gt;The line-breaking algorithm is very complicated and Locale-dependent -
 * and therefore its implementation omitted from this sample code.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;pre&gt;
 *
 *  package com.ibm.icu.dev.test.bidi;
 *
 *  import com.ibm.icu.text.Bidi;
 *  import com.ibm.icu.text.BidiRun;
 *
 *  public class Sample {
 *
 *      static final int styleNormal = 0;
 *      static final int styleSelected = 1;
 *      static final int styleBold = 2;
 *      static final int styleItalics = 4;
 *      static final int styleSuper=8;
 *      static final int styleSub = 16;
 *
 *      static class StyleRun {
 *          int limit;
 *          int style;
 *
 *          public StyleRun(int limit, int style) {
 *              this.limit = limit;
 *              this.style = style;
 *          }
 *      }
 *
 *      static class Bounds {
 *          int start;
 *          int limit;
 *
 *          public Bounds(int start, int limit) {
 *              this.start = start;
 *              this.limit = limit;
 *          }
 *      }
 *
 *      static int getTextWidth(String text, int start, int limit,
 *                              StyleRun[] styleRuns, int styleRunCount) {
 *          // simplistic way to compute the width
 *          return limit - start;
 *      }
 *
 *      // set limit and StyleRun limit for a line
 *      // from text[start] and from styleRuns[styleRunStart]
 *      // using Bidi.getLogicalRun(...)
 *      // returns line width
 *      static int getLineBreak(String text, Bounds line, Bidi para,
 *                              StyleRun styleRuns[], Bounds styleRun) {
 *          // dummy return
 *          return 0;
 *      }
 *
 *      // render runs on a line sequentially, always from left to right
 *
 *      // prepare rendering a new line
 *      static void startLine(byte textDirection, int lineWidth) {
 *          System.out.println();
 *      }
 *
 *      // render a run of text and advance to the right by the run width
 *      // the text[start..limit-1] is always in logical order
 *      static void renderRun(String text, int start, int limit,
 *                            byte textDirection, int style) {
 *      }
 *
 *      // We could compute a cross-product
 *      // from the style runs with the directional runs
 *      // and then reorder it.
 *      // Instead, here we iterate over each run type
 *      // and render the intersections -
 *      // with shortcuts in simple (and common) cases.
 *      // renderParagraph() is the main function.
 *
 *      // render a directional run with
 *      // (possibly) multiple style runs intersecting with it
 *      static void renderDirectionalRun(String text, int start, int limit,
 *                                       byte direction, StyleRun styleRuns[],
 *                                       int styleRunCount) {
 *          int i;
 *
 *          // iterate over style runs
 *          if (direction == Bidi.LTR) {
 *              int styleLimit;
 *              for (i = 0; i &lt; styleRunCount; ++i) {
 *                  styleLimit = styleRuns[i].limit;
 *                  if (start &lt; styleLimit) {
 *                      if (styleLimit &gt; limit) {
 *                          styleLimit = limit;
 *                      }
 *                      renderRun(text, start, styleLimit,
 *                                direction, styleRuns[i].style);
 *                      if (styleLimit == limit) {
 *                          break;
 *                      }
 *                      start = styleLimit;
 *                  }
 *              }
 *          } else {
 *              int styleStart;
 *
 *              for (i = styleRunCount-1; i &gt;= 0; --i) {
 *                  if (i &gt; 0) {
 *                      styleStart = styleRuns[i-1].limit;
 *                  } else {
 *                      styleStart = 0;
 *                  }
 *                  if (limit &gt;= styleStart) {
 *                      if (styleStart &lt; start) {
 *                          styleStart = start;
 *                      }
 *                      renderRun(text, styleStart, limit, direction,
 *                                styleRuns[i].style);
 *                      if (styleStart == start) {
 *                          break;
 *                      }
 *                      limit = styleStart;
 *                  }
 *              }
 *          }
 *      }
 *
 *      // the line object represents text[start..limit-1]
 *      static void renderLine(Bidi line, String text, int start, int limit,
 *                             StyleRun styleRuns[], int styleRunCount) {
 *          byte direction = line.getDirection();
 *          if (direction != Bidi.MIXED) {
 *              // unidirectional
 *              if (styleRunCount &lt;= 1) {
 *                  renderRun(text, start, limit, direction, styleRuns[0].style);
 *              } else {
 *                  renderDirectionalRun(text, start, limit, direction,
 *                                       styleRuns, styleRunCount);
 *              }
 *          } else {
 *              // mixed-directional
 *              int count, i;
 *              BidiRun run;
 *
 *              try {
 *                  count = line.countRuns();
 *              } catch (IllegalStateException e) {
 *                  e.printStackTrace();
 *                  return;
 *              }
 *              if (styleRunCount &lt;= 1) {
 *                  int style = styleRuns[0].style;
 *
 *                  // iterate over directional runs
 *                  for (i = 0; i &lt; count; ++i) {
 *                      run = line.getVisualRun(i);
 *                      renderRun(text, run.getStart(), run.getLimit(),
 *                                run.getDirection(), style);
 *                  }
 *              } else {
 *                  // iterate over both directional and style runs
 *                  for (i = 0; i &lt; count; ++i) {
 *                      run = line.getVisualRun(i);
 *                      renderDirectionalRun(text, run.getStart(),
 *                                           run.getLimit(), run.getDirection(),
 *                                           styleRuns, styleRunCount);
 *                  }
 *              }
 *          }
 *      }
 *
 *      static void renderParagraph(String text, byte textDirection,
 *                                  StyleRun styleRuns[], int styleRunCount,
 *                                  int lineWidth) {
 *          int length = text.length();
 *          Bidi para = new Bidi();
 *          try {
 *              para.setPara(text,
 *                           textDirection != 0 ? Bidi.LEVEL_DEFAULT_RTL
 *                                              : Bidi.LEVEL_DEFAULT_LTR,
 *                           null);
 *          } catch (Exception e) {
 *              e.printStackTrace();
 *              return;
 *          }
 *          byte paraLevel = (byte)(1 &amp; para.getParaLevel());
 *          StyleRun styleRun = new StyleRun(length, styleNormal);
 *
 *          if (styleRuns == null || styleRunCount &lt;= 0) {
 *              styleRuns = new StyleRun[1];
 *              styleRunCount = 1;
 *              styleRuns[0] = styleRun;
 *          }
 *          // assume styleRuns[styleRunCount-1].limit&gt;=length
 *
 *          int width = getTextWidth(text, 0, length, styleRuns, styleRunCount);
 *          if (width &lt;= lineWidth) {
 *              // everything fits onto one line
 *
 *              // prepare rendering a new line from either left or right
 *              startLine(paraLevel, width);
 *
 *              renderLine(para, text, 0, length, styleRuns, styleRunCount);
 *          } else {
 *              // we need to render several lines
 *              Bidi line = new Bidi(length, 0);
 *              int start = 0, limit;
 *              int styleRunStart = 0, styleRunLimit;
 *
 *              for (;;) {
 *                  limit = length;
 *                  styleRunLimit = styleRunCount;
 *                  width = getLineBreak(text, new Bounds(start, limit),
 *                                       para, styleRuns,
 *                                       new Bounds(styleRunStart, styleRunLimit));
 *                  try {
 *                      line = para.setLine(start, limit);
 *                  } catch (Exception e) {
 *                      e.printStackTrace();
 *                      return;
 *                  }
 *                  // prepare rendering a new line
 *                  // from either left or right
 *                  startLine(paraLevel, width);
 *
 *                  if (styleRunStart &gt; 0) {
 *                      int newRunCount = styleRuns.length - styleRunStart;
 *                      StyleRun[] newRuns = new StyleRun[newRunCount];
 *                      System.arraycopy(styleRuns, styleRunStart, newRuns, 0,
 *                                       newRunCount);
 *                      renderLine(line, text, start, limit, newRuns,
 *                                 styleRunLimit - styleRunStart);
 *                  } else {
 *                      renderLine(line, text, start, limit, styleRuns,
 *                                 styleRunLimit - styleRunStart);
 *                  }
 *                  if (limit == length) {
 *                      break;
 *                  }
 *                  start = limit;
 *                  styleRunStart = styleRunLimit - 1;
 *                  if (start &gt;= styleRuns[styleRunStart].limit) {
 *                      ++styleRunStart;
 *                  }
 *              }
 *          }
 *      }
 *
 *      public static void main(String[] args)
 *      {
 *          renderParagraph(&quot;Some Latin text...&quot;, Bidi.LTR, null, 0, 80);
 *          renderParagraph(&quot;Some Hebrew text...&quot;, Bidi.RTL, null, 0, 60);
 *      }
 *  }
 *
 * &lt;/pre&gt;
 */

public class BidiBase {

<span class="nc" id="L460">    class Point {</span>
        int pos;    /* position in text */
        int flag;   /* flag for LRM/RLM, before/after */
    }

<span class="fc" id="L465">    class InsertPoints {</span>
        int size;
        int confirmed;
<span class="fc" id="L468">        Point[] points = new Point[0];</span>
    }

    /** Paragraph level setting&lt;p&gt;
     *
     * Constant indicating that the base direction depends on the first strong
     * directional character in the text according to the Unicode Bidirectional
     * Algorithm. If no strong directional character is present,
     * then set the paragraph level to 0 (left-to-right).&lt;p&gt;
     *
     * If this value is used in conjunction with reordering modes
     * &lt;code&gt;REORDER_INVERSE_LIKE_DIRECT&lt;/code&gt; or
     * &lt;code&gt;REORDER_INVERSE_FOR_NUMBERS_SPECIAL&lt;/code&gt;, the text to reorder
     * is assumed to be visual LTR, and the text after reordering is required
     * to be the corresponding logical string with appropriate contextual
     * direction. The direction of the result string will be RTL if either
     * the righmost or leftmost strong character of the source text is RTL
     * or Arabic Letter, the direction will be LTR otherwise.&lt;p&gt;
     *
     * If reordering option &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt; is set, an RLM may
     * be added at the beginning of the result string to ensure round trip
     * (that the result string, when reordered back to visual, will produce
     * the original source text).
     * @see #REORDER_INVERSE_LIKE_DIRECT
     * @see #REORDER_INVERSE_FOR_NUMBERS_SPECIAL
     * @stable ICU 3.8
     */
    public static final byte INTERNAL_LEVEL_DEFAULT_LTR = (byte)0x7e;

    /** Paragraph level setting&lt;p&gt;
     *
     * Constant indicating that the base direction depends on the first strong
     * directional character in the text according to the Unicode Bidirectional
     * Algorithm. If no strong directional character is present,
     * then set the paragraph level to 1 (right-to-left).&lt;p&gt;
     *
     * If this value is used in conjunction with reordering modes
     * &lt;code&gt;REORDER_INVERSE_LIKE_DIRECT&lt;/code&gt; or
     * &lt;code&gt;REORDER_INVERSE_FOR_NUMBERS_SPECIAL&lt;/code&gt;, the text to reorder
     * is assumed to be visual LTR, and the text after reordering is required
     * to be the corresponding logical string with appropriate contextual
     * direction. The direction of the result string will be RTL if either
     * the righmost or leftmost strong character of the source text is RTL
     * or Arabic Letter, or if the text contains no strong character;
     * the direction will be LTR otherwise.&lt;p&gt;
     *
     * If reordering option &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt; is set, an RLM may
     * be added at the beginning of the result string to ensure round trip
     * (that the result string, when reordered back to visual, will produce
     * the original source text).
     * @see #REORDER_INVERSE_LIKE_DIRECT
     * @see #REORDER_INVERSE_FOR_NUMBERS_SPECIAL
     * @stable ICU 3.8
     */
    public static final byte INTERNAL_LEVEL_DEFAULT_RTL = (byte)0x7f;

    /**
     * Maximum explicit embedding level.
     * (The maximum resolved level can be up to &lt;code&gt;MAX_EXPLICIT_LEVEL+1&lt;/code&gt;).
     * @stable ICU 3.8
     */
    public static final byte MAX_EXPLICIT_LEVEL = 61;

    /**
     * Bit flag for level input.
     * Overrides directional properties.
     * @stable ICU 3.8
     */
    public static final byte INTERNAL_LEVEL_OVERRIDE = (byte)0x80;

    /**
     * Special value which can be returned by the mapping methods when a
     * logical index has no corresponding visual index or vice-versa. This may
     * happen for the logical-to-visual mapping of a Bidi control when option
     * &lt;code&gt;OPTION_REMOVE_CONTROLS&lt;/code&gt; is
     * specified. This can also happen for the visual-to-logical mapping of a
     * Bidi mark (LRM or RLM) inserted by option
     * &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;.
     * @see #getVisualIndex
     * @see #getVisualMap
     * @see #getLogicalIndex
     * @see #getLogicalMap
     * @see #OPTION_INSERT_MARKS
     * @see #OPTION_REMOVE_CONTROLS
     * @stable ICU 3.8
     */
    public static final int MAP_NOWHERE = -1;

    /**
     * Mixed-directional text.
     * @stable ICU 3.8
     */
    public static final byte MIXED = 2;

    /**
     * option bit for writeReordered():
     * replace characters with the &quot;mirrored&quot; property in RTL runs
     * by their mirror-image mappings
     *
     * @see #writeReordered
     * @stable ICU 3.8
     */
    public static final short DO_MIRRORING = 2;

    /** Reordering mode: Regular Logical to Visual Bidi algorithm according to Unicode.
     * @see #setReorderingMode
     * @stable ICU 3.8
     */
    private static final short REORDER_DEFAULT = 0;

    /** Reordering mode: Logical to Visual algorithm which handles numbers in
     * a way which mimicks the behavior of Windows XP.
     * @see #setReorderingMode
     * @stable ICU 3.8
     */
    private static final short REORDER_NUMBERS_SPECIAL = 1;

    /** Reordering mode: Logical to Visual algorithm grouping numbers with
     * adjacent R characters (reversible algorithm).
     * @see #setReorderingMode
     * @stable ICU 3.8
     */
    private static final short REORDER_GROUP_NUMBERS_WITH_R = 2;

    /** Reordering mode: Reorder runs only to transform a Logical LTR string
     * to the logical RTL string with the same display, or vice-versa.&lt;br&gt;
     * If this mode is set together with option
     * &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;, some Bidi controls in the source
     * text may be removed and other controls may be added to produce the
     * minimum combination which has the required display.
     * @see #OPTION_INSERT_MARKS
     * @see #setReorderingMode
     * @stable ICU 3.8
     */
    private static final short REORDER_RUNS_ONLY = 3;

    /** Reordering mode: Visual to Logical algorithm which handles numbers
     * like L (same algorithm as selected by &lt;code&gt;setInverse(true)&lt;/code&gt;.
     * @see #setInverse
     * @see #setReorderingMode
     * @stable ICU 3.8
     */
    private static final short REORDER_INVERSE_NUMBERS_AS_L = 4;

    /** Reordering mode: Visual to Logical algorithm equivalent to the regular
     * Logical to Visual algorithm.
     * @see #setReorderingMode
     * @stable ICU 3.8
     */
    private static final short REORDER_INVERSE_LIKE_DIRECT = 5;

    /** Reordering mode: Inverse Bidi (Visual to Logical) algorithm for the
     * &lt;code&gt;REORDER_NUMBERS_SPECIAL&lt;/code&gt; Bidi algorithm.
     * @see #setReorderingMode
     * @stable ICU 3.8
     */
    private static final short REORDER_INVERSE_FOR_NUMBERS_SPECIAL = 6;

    /* Reordering mode values must be ordered so that all the regular logical to
     * visual modes come first, and all inverse Bidi modes come last.
     */
    private static final short REORDER_LAST_LOGICAL_TO_VISUAL =
            REORDER_NUMBERS_SPECIAL;

    /**
     * Option bit for &lt;code&gt;setReorderingOptions&lt;/code&gt;:
     * insert Bidi marks (LRM or RLM) when needed to ensure correct result of
     * a reordering to a Logical order
     *
     * &lt;p&gt;This option must be set or reset before calling
     * &lt;code&gt;setPara&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;This option is significant only with reordering modes which generate
     * a result with Logical order, specifically.&lt;/p&gt;
     * &lt;ul&gt;
     *   &lt;li&gt;&lt;code&gt;REORDER_RUNS_ONLY&lt;/code&gt;&lt;/li&gt;
     *   &lt;li&gt;&lt;code&gt;REORDER_INVERSE_NUMBERS_AS_L&lt;/code&gt;&lt;/li&gt;
     *   &lt;li&gt;&lt;code&gt;REORDER_INVERSE_LIKE_DIRECT&lt;/code&gt;&lt;/li&gt;
     *   &lt;li&gt;&lt;code&gt;REORDER_INVERSE_FOR_NUMBERS_SPECIAL&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If this option is set in conjunction with reordering mode
     * &lt;code&gt;REORDER_INVERSE_NUMBERS_AS_L&lt;/code&gt; or with calling
     * &lt;code&gt;setInverse(true)&lt;/code&gt;, it implies option
     * &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt; in calls to method
     * &lt;code&gt;writeReordered()&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;For other reordering modes, a minimum number of LRM or RLM characters
     * will be added to the source text after reordering it so as to ensure
     * round trip, i.e. when applying the inverse reordering mode on the
     * resulting logical text with removal of Bidi marks
     * (option &lt;code&gt;OPTION_REMOVE_CONTROLS&lt;/code&gt; set before calling
     * &lt;code&gt;setPara()&lt;/code&gt; or option
     * &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt; in
     * &lt;code&gt;writeReordered&lt;/code&gt;), the result will be identical to the
     * source text in the first transformation.
     *
     * &lt;p&gt;This option will be ignored if specified together with option
     * &lt;code&gt;OPTION_REMOVE_CONTROLS&lt;/code&gt;. It inhibits option
     * &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt; in calls to method
     * &lt;code&gt;writeReordered()&lt;/code&gt; and it implies option
     * &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt; in calls to method
     * &lt;code&gt;writeReordered()&lt;/code&gt; if the reordering mode is
     * &lt;code&gt;REORDER_INVERSE_NUMBERS_AS_L&lt;/code&gt;.&lt;/p&gt;
     *
     * @see #setReorderingMode
     * @see #setReorderingOptions
     * @see #INSERT_LRM_FOR_NUMERIC
     * @see #REMOVE_BIDI_CONTROLS
     * @see #OPTION_REMOVE_CONTROLS
     * @see #REORDER_RUNS_ONLY
     * @see #REORDER_INVERSE_NUMBERS_AS_L
     * @see #REORDER_INVERSE_LIKE_DIRECT
     * @see #REORDER_INVERSE_FOR_NUMBERS_SPECIAL
     * @stable ICU 3.8
     */
    private static final int OPTION_INSERT_MARKS = 1;

    /**
     * Option bit for &lt;code&gt;setReorderingOptions&lt;/code&gt;:
     * remove Bidi control characters
     *
     * &lt;p&gt;This option must be set or reset before calling
     * &lt;code&gt;setPara&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;This option nullifies option
     * &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;. It inhibits option
     * &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt; in calls to method
     * &lt;code&gt;writeReordered()&lt;/code&gt; and it implies option
     * &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt; in calls to that method.&lt;/p&gt;
     *
     * @see #setReorderingMode
     * @see #setReorderingOptions
     * @see #OPTION_INSERT_MARKS
     * @see #INSERT_LRM_FOR_NUMERIC
     * @see #REMOVE_BIDI_CONTROLS
     * @stable ICU 3.8
     */
    private static final int OPTION_REMOVE_CONTROLS = 2;

    /**
     * Option bit for &lt;code&gt;setReorderingOptions&lt;/code&gt;:
     * process the output as part of a stream to be continued
     *
     * &lt;p&gt;This option must be set or reset before calling
     * &lt;code&gt;setPara&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;This option specifies that the caller is interested in processing
     * large text object in parts. The results of the successive calls are
     * expected to be concatenated by the caller. Only the call for the last
     * part will have this option bit off.&lt;/p&gt;
     *
     * &lt;p&gt;When this option bit is on, &lt;code&gt;setPara()&lt;/code&gt; may process
     * less than the full source text in order to truncate the text at a
     * meaningful boundary. The caller should call
     * &lt;code&gt;getProcessedLength()&lt;/code&gt; immediately after calling
     * &lt;code&gt;setPara()&lt;/code&gt; in order to determine how much of the source
     * text has been processed. Source text beyond that length should be
     * resubmitted in following calls to &lt;code&gt;setPara&lt;/code&gt;. The
     * processed length may be less than the length of the source text if a
     * character preceding the last character of the source text constitutes a
     * reasonable boundary (like a block separator) for text to be continued.&lt;br&gt;
     * If the last character of the source text constitutes a reasonable
     * boundary, the whole text will be processed at once.&lt;br&gt;
     * If nowhere in the source text there exists
     * such a reasonable boundary, the processed length will be zero.&lt;br&gt;
     * The caller should check for such an occurrence and do one of the following:
     * &lt;ul&gt;&lt;li&gt;submit a larger amount of text with a better chance to include
     *         a reasonable boundary.&lt;/li&gt;
     *     &lt;li&gt;resubmit the same text after turning off option
     *         &lt;code&gt;OPTION_STREAMING&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;
     * In all cases, this option should be turned off before processing the last
     * part of the text.&lt;/p&gt;
     *
     * &lt;p&gt;When the &lt;code&gt;OPTION_STREAMING&lt;/code&gt; option is used, it is
     * recommended to call &lt;code&gt;orderParagraphsLTR()&lt;/code&gt; with argument
     * &lt;code&gt;orderParagraphsLTR&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; before calling
     * &lt;code&gt;setPara()&lt;/code&gt; so that later paragraphs may be concatenated to
     * previous paragraphs on the right.
     * &lt;/p&gt;
     *
     * @see #setReorderingMode
     * @see #setReorderingOptions
     * @see #getProcessedLength
     * @see #orderParagraphsLTR
     * @stable ICU 3.8
     */
    private static final int OPTION_STREAMING = 4;

    /*
     *   Comparing the description of the Bidi algorithm with this implementation
     *   is easier with the same names for the Bidi types in the code as there.
     *   See UCharacterDirection
     */
    private static final byte L   = 0;
    private static final byte R   = 1;
    private static final byte EN  = 2;
    private static final byte ES  = 3;
    private static final byte ET  = 4;
    private static final byte AN  = 5;
    private static final byte CS  = 6;
    static final byte B   = 7;
    private static final byte S   = 8;
    private static final byte WS  = 9;
    private static final byte ON  = 10;
    private static final byte LRE = 11;
    private static final byte LRO = 12;
    private static final byte AL  = 13;
    private static final byte RLE = 14;
    private static final byte RLO = 15;
    private static final byte PDF = 16;
    private static final byte NSM = 17;
    private static final byte BN  = 18;

    private static final int MASK_R_AL = (1 &lt;&lt; R | 1 &lt;&lt; AL);

    private static final char CR = '\r';
    private static final char LF = '\n';

    static final int LRM_BEFORE = 1;
    static final int LRM_AFTER = 2;
    static final int RLM_BEFORE = 4;
    static final int RLM_AFTER = 8;

    /*
     * reference to parent paragraph object (reference to self if this object is
     * a paragraph object); set to null in a newly opened object; set to a
     * real value after a successful execution of setPara or setLine
     */
    BidiBase                paraBidi;

    final UBiDiProps    bdp;

    /* character array representing the current text */
    char[]              text;

    /* length of the current text */
    int                 originalLength;

    /* if the option OPTION_STREAMING is set, this is the length of
     * text actually processed by &lt;code&gt;setPara&lt;/code&gt;, which may be shorter
     * than the original length. Otherwise, it is identical to the original
     * length.
     */
    public int                 length;

    /* if option OPTION_REMOVE_CONTROLS is set, and/or Bidi
     * marks are allowed to be inserted in one of the reordering modes, the
     * length of the result string may be different from the processed length.
     */
    int                 resultLength;

    /* indicators for whether memory may be allocated after construction */
    boolean             mayAllocateText;
    boolean             mayAllocateRuns;

    /* arrays with one value per text-character */
<span class="fc" id="L825">    byte[]              dirPropsMemory = new byte[1];</span>
<span class="fc" id="L826">    byte[]              levelsMemory = new byte[1];</span>
    byte[]              dirProps;
    byte[]              levels;

    /* must block separators receive level 0? */
    boolean             orderParagraphsLTR;

    /* the paragraph level */
    byte                paraLevel;

    /* original paraLevel when contextual */
    /* must be one of DEFAULT_xxx or 0 if not contextual */
    byte                defaultParaLevel;

    /* the following is set in setPara, used in processPropertySeq */

    ImpTabPair          impTabPair;  /* reference to levels state table pair */

    /* the overall paragraph or line directionality*/
    byte                direction;

    /* flags is a bit set for which directional properties are in the text */
    int                 flags;

    /* lastArabicPos is index to the last AL in the text, -1 if none */
    int                 lastArabicPos;

    /* characters after trailingWSStart are WS and are */
    /* implicitly at the paraLevel (rule (L1)) - levels may not reflect that */
    int                 trailingWSStart;

    /* fields for paragraph handling */
    int                 paraCount;       /* set in getDirProps() */
<span class="fc" id="L859">    int[]               parasMemory = new int[1];</span>
    int[]               paras;           /* limits of paragraphs, filled in
                                          ResolveExplicitLevels() or CheckExplicitLevels() */

    /* for single paragraph text, we only need a tiny array of paras (no allocation) */
<span class="fc" id="L864">    int[]               simpleParas = {0};</span>

    /* fields for line reordering */
    int                 runCount;     /* ==-1: runs not set up yet */
<span class="fc" id="L868">    BidiRun[]           runsMemory = new BidiRun[0];</span>
    BidiRun[]           runs;

    /* for non-mixed text, we only need a tiny array of runs (no allocation) */
<span class="fc" id="L872">    BidiRun[]           simpleRuns = {new BidiRun()};</span>

    /* mapping of runs in logical order to visual order */
    int[]               logicalToVisualRunsMap;

    /* flag to indicate that the map has been updated */
    boolean             isGoodLogicalToVisualRunsMap;

    /* for inverse Bidi with insertion of directional marks */
<span class="fc" id="L881">    InsertPoints        insertPoints = new InsertPoints();</span>

    /* for option OPTION_REMOVE_CONTROLS */
    int                 controlCount;

    /*
     * Sometimes, bit values are more appropriate
     * to deal with directionality properties.
     * Abbreviations in these method names refer to names
     * used in the Bidi algorithm.
     */
    static int DirPropFlag(byte dir) {
<span class="fc" id="L893">        return (1 &lt;&lt; dir);</span>
    }

    /*
     * The following bit is ORed to the property of characters in paragraphs
     * with contextual RTL direction when paraLevel is contextual.
     */
    static final byte CONTEXT_RTL_SHIFT = 6;
    static final byte CONTEXT_RTL = (byte)(1&lt;&lt;CONTEXT_RTL_SHIFT);   // 0x40
    static byte NoContextRTL(byte dir)
    {
<span class="nc" id="L904">        return (byte)(dir &amp; ~CONTEXT_RTL);</span>
    }

    /*
     * The following is a variant of DirProp.DirPropFlag() which ignores the
     * CONTEXT_RTL bit.
     */
    static int DirPropFlagNC(byte dir) {
<span class="nc" id="L912">        return (1&lt;&lt;(dir &amp; ~CONTEXT_RTL));</span>
    }

<span class="fc" id="L915">    static final int DirPropFlagMultiRuns = DirPropFlag((byte)31);</span>

    /* to avoid some conditional statements, use tiny constant arrays */
<span class="fc" id="L918">    static final int DirPropFlagLR[] = { DirPropFlag(L), DirPropFlag(R) };</span>
<span class="fc" id="L919">    static final int DirPropFlagE[] = { DirPropFlag(LRE), DirPropFlag(RLE) };</span>
<span class="fc" id="L920">    static final int DirPropFlagO[] = { DirPropFlag(LRO), DirPropFlag(RLO) };</span>

<span class="nc" id="L922">    static final int DirPropFlagLR(byte level) { return DirPropFlagLR[level &amp; 1]; }</span>
<span class="nc" id="L923">    static final int DirPropFlagE(byte level)  { return DirPropFlagE[level &amp; 1]; }</span>
<span class="nc" id="L924">    static final int DirPropFlagO(byte level)  { return DirPropFlagO[level &amp; 1]; }</span>

    /*
     *  are there any characters that are LTR?
     */
<span class="fc" id="L929">    static final int MASK_LTR =</span>
<span class="fc" id="L930">        DirPropFlag(L)|DirPropFlag(EN)|DirPropFlag(AN)|DirPropFlag(LRE)|DirPropFlag(LRO);</span>

    /*
     *  are there any characters that are RTL?
     */
<span class="fc" id="L935">    static final int MASK_RTL = DirPropFlag(R)|DirPropFlag(AL)|DirPropFlag(RLE)|DirPropFlag(RLO);</span>

    /* explicit embedding codes */
<span class="fc" id="L938">    private static final int MASK_LRX = DirPropFlag(LRE)|DirPropFlag(LRO);</span>
<span class="fc" id="L939">    private static final int MASK_RLX = DirPropFlag(RLE)|DirPropFlag(RLO);</span>
<span class="fc" id="L940">    private static final int MASK_EXPLICIT = MASK_LRX|MASK_RLX|DirPropFlag(PDF);</span>
<span class="fc" id="L941">    private static final int MASK_BN_EXPLICIT = DirPropFlag(BN)|MASK_EXPLICIT;</span>

    /* paragraph and segment separators */
<span class="fc" id="L944">    private static final int MASK_B_S = DirPropFlag(B)|DirPropFlag(S);</span>

    /* all types that are counted as White Space or Neutral in some steps */
<span class="fc" id="L947">    static final int MASK_WS = MASK_B_S|DirPropFlag(WS)|MASK_BN_EXPLICIT;</span>
<span class="fc" id="L948">    private static final int MASK_N = DirPropFlag(ON)|MASK_WS;</span>

    /* types that are neutrals or could becomes neutrals in (Wn) */
<span class="fc" id="L951">    private static final int MASK_POSSIBLE_N = DirPropFlag(CS)|DirPropFlag(ES)|DirPropFlag(ET)|MASK_N;</span>

    /*
     * These types may be changed to &quot;e&quot;,
     * the embedding type (L or R) of the run,
     * in the Bidi algorithm (N2)
     */
<span class="fc" id="L958">    static final int MASK_EMBEDDING = DirPropFlag(NSM)|MASK_POSSIBLE_N;</span>

    /*
     *  the dirProp's L and R are defined to 0 and 1 values in UCharacterDirection.java
     */
    private static byte GetLRFromLevel(byte level)
    {
<span class="nc" id="L965">        return (byte)(level &amp; 1);</span>
    }

    private static boolean IsDefaultLevel(byte level)
    {
<span class="nc bnc" id="L970" title="All 2 branches missed.">        return ((level &amp; INTERNAL_LEVEL_DEFAULT_LTR) == INTERNAL_LEVEL_DEFAULT_LTR);</span>
    }

    byte GetParaLevelAt(int index)
    {
<span class="nc bnc" id="L975" title="All 2 branches missed.">        return (defaultParaLevel != 0) ?</span>
                (byte)(dirProps[index]&gt;&gt;CONTEXT_RTL_SHIFT) : paraLevel;
    }

    static boolean IsBidiControlChar(int c)
    {
        /* check for range 0x200c to 0x200f (ZWNJ, ZWJ, LRM, RLM) or
                           0x202a to 0x202e (LRE, RLE, PDF, LRO, RLO) */
<span class="nc bnc" id="L983" title="All 6 branches missed.">        return (((c &amp; 0xfffffffc) == 0x200c) || ((c &gt;= 0x202a) &amp;&amp; (c &lt;= 0x202e)));</span>
    }

    public void verifyValidPara()
    {
<span class="nc bnc" id="L988" title="All 2 branches missed.">        if (this != this.paraBidi) {</span>
<span class="nc" id="L989">            throw new IllegalStateException(&quot;&quot;);</span>
        }
<span class="nc" id="L991">    }</span>

    public void verifyValidParaOrLine()
    {
<span class="nc" id="L995">        BidiBase para = this.paraBidi;</span>
        /* verify Para */
<span class="nc bnc" id="L997" title="All 2 branches missed.">        if (this == para) {</span>
<span class="nc" id="L998">            return;</span>
        }
        /* verify Line */
<span class="nc bnc" id="L1001" title="All 4 branches missed.">        if ((para == null) || (para != para.paraBidi)) {</span>
<span class="nc" id="L1002">            throw new IllegalStateException();</span>
        }
<span class="nc" id="L1004">    }</span>

    public void verifyRange(int index, int start, int limit)
    {
<span class="nc bnc" id="L1008" title="All 4 branches missed.">        if (index &lt; start || index &gt;= limit) {</span>
<span class="nc" id="L1009">            throw new IllegalArgumentException(&quot;Value &quot; + index +</span>
                      &quot; is out of range &quot; + start + &quot; to &quot; + limit);
        }
<span class="nc" id="L1012">    }</span>

    public void verifyIndex(int index, int start, int limit)
    {
<span class="nc bnc" id="L1016" title="All 4 branches missed.">        if (index &lt; start || index &gt;= limit) {</span>
<span class="nc" id="L1017">            throw new ArrayIndexOutOfBoundsException(&quot;Index &quot; + index +</span>
                      &quot; is out of range &quot; + start + &quot; to &quot; + limit);
        }
<span class="nc" id="L1020">    }</span>

    /**
     * Allocate a &lt;code&gt;Bidi&lt;/code&gt; object with preallocated memory
     * for internal structures.
     * This method provides a &lt;code&gt;Bidi&lt;/code&gt; object like the default constructor
     * but it also preallocates memory for internal structures
     * according to the sizings supplied by the caller.&lt;p&gt;
     * The preallocation can be limited to some of the internal memory
     * by setting some values to 0 here. That means that if, e.g.,
     * &lt;code&gt;maxRunCount&lt;/code&gt; cannot be reasonably predetermined and should not
     * be set to &lt;code&gt;maxLength&lt;/code&gt; (the only failproof value) to avoid
     * wasting  memory, then &lt;code&gt;maxRunCount&lt;/code&gt; could be set to 0 here
     * and the internal structures that are associated with it will be allocated
     * on demand, just like with the default constructor.
     *
     * @param maxLength is the maximum text or line length that internal memory
     *        will be preallocated for. An attempt to associate this object with a
     *        longer text will fail, unless this value is 0, which leaves the allocation
     *        up to the implementation.
     *
     * @param maxRunCount is the maximum anticipated number of same-level runs
     *        that internal memory will be preallocated for. An attempt to access
     *        visual runs on an object that was not preallocated for as many runs
     *        as the text was actually resolved to will fail,
     *        unless this value is 0, which leaves the allocation up to the implementation.&lt;br&gt;&lt;br&gt;
     *        The number of runs depends on the actual text and maybe anywhere between
     *        1 and &lt;code&gt;maxLength&lt;/code&gt;. It is typically small.
     *
     * @throws IllegalArgumentException if maxLength or maxRunCount is less than 0
     * @stable ICU 3.8
     */
    public BidiBase(int maxLength, int maxRunCount)
<span class="fc" id="L1053">     {</span>
        /* check the argument values */
<span class="pc bpc" id="L1055" title="2 of 4 branches missed.">        if (maxLength &lt; 0 || maxRunCount &lt; 0) {</span>
<span class="nc" id="L1056">            throw new IllegalArgumentException();</span>
        }

        /* reset the object, all reference variables null, all flags false,
           all sizes 0.
           In fact, we don't need to do anything, since class members are
           initialized as zero when an instance is created.
         */
        /*
        mayAllocateText = false;
        mayAllocateRuns = false;
        orderParagraphsLTR = false;
        paraCount = 0;
        runCount = 0;
        trailingWSStart = 0;
        flags = 0;
        paraLevel = 0;
        defaultParaLevel = 0;
        direction = 0;
        */
        /* get Bidi properties */
        try {
<span class="nc" id="L1078">            bdp = UBiDiProps.getSingleton();</span>
        }
<span class="fc" id="L1080">        catch (IOException e) {</span>
<span class="fc" id="L1081">            throw new MissingResourceException(e.getMessage(), &quot;(BidiProps)&quot;, &quot;&quot;);</span>
<span class="nc" id="L1082">        }</span>

        /* allocate memory for arrays as requested */
<span class="nc bnc" id="L1085" title="All 2 branches missed.">        if (maxLength &gt; 0) {</span>
<span class="nc" id="L1086">            getInitialDirPropsMemory(maxLength);</span>
<span class="nc" id="L1087">            getInitialLevelsMemory(maxLength);</span>
        } else {
<span class="nc" id="L1089">            mayAllocateText = true;</span>
        }

<span class="nc bnc" id="L1092" title="All 2 branches missed.">        if (maxRunCount &gt; 0) {</span>
            // if maxRunCount == 1, use simpleRuns[]
<span class="nc bnc" id="L1094" title="All 2 branches missed.">            if (maxRunCount &gt; 1) {</span>
<span class="nc" id="L1095">                getInitialRunsMemory(maxRunCount);</span>
            }
        } else {
<span class="nc" id="L1098">            mayAllocateRuns = true;</span>
        }
<span class="nc" id="L1100">    }</span>

    /*
     * We are allowed to allocate memory if object==null or
     * mayAllocate==true for each array that we need.
     *
     * Assume sizeNeeded&gt;0.
     * If object != null, then assume size &gt; 0.
     */
    private Object getMemory(String label, Object array, Class&lt;?&gt; arrayClass,
            boolean mayAllocate, int sizeNeeded)
    {
<span class="nc" id="L1112">        int len = Array.getLength(array);</span>

        /* we have at least enough memory and must not allocate */
<span class="nc bnc" id="L1115" title="All 2 branches missed.">        if (sizeNeeded == len) {</span>
<span class="nc" id="L1116">            return array;</span>
        }
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (!mayAllocate) {</span>
            /* we must not allocate */
<span class="nc bnc" id="L1120" title="All 2 branches missed.">            if (sizeNeeded &lt;= len) {</span>
<span class="nc" id="L1121">                return array;</span>
            }
<span class="nc" id="L1123">            throw new OutOfMemoryError(&quot;Failed to allocate memory for &quot;</span>
                                       + label);
        }
        /* we may try to grow or shrink */
        /* FOOD FOR THOUGHT: when shrinking it should be possible to avoid
           the allocation altogether and rely on this.length */
        try {
<span class="nc" id="L1130">            return Array.newInstance(arrayClass, sizeNeeded);</span>
<span class="nc" id="L1131">        } catch (Exception e) {</span>
<span class="nc" id="L1132">            throw new OutOfMemoryError(&quot;Failed to allocate memory for &quot;</span>
                                       + label);
        }
    }

    /* helper methods for each allocated array */
    private void getDirPropsMemory(boolean mayAllocate, int len)
    {
<span class="nc" id="L1140">        Object array = getMemory(&quot;DirProps&quot;, dirPropsMemory, Byte.TYPE, mayAllocate, len);</span>
<span class="nc" id="L1141">        dirPropsMemory = (byte[]) array;</span>
<span class="nc" id="L1142">    }</span>

    void getDirPropsMemory(int len)
    {
<span class="nc" id="L1146">        getDirPropsMemory(mayAllocateText, len);</span>
<span class="nc" id="L1147">    }</span>

    private void getLevelsMemory(boolean mayAllocate, int len)
    {
<span class="nc" id="L1151">        Object array = getMemory(&quot;Levels&quot;, levelsMemory, Byte.TYPE, mayAllocate, len);</span>
<span class="nc" id="L1152">        levelsMemory = (byte[]) array;</span>
<span class="nc" id="L1153">    }</span>

    void getLevelsMemory(int len)
    {
<span class="nc" id="L1157">        getLevelsMemory(mayAllocateText, len);</span>
<span class="nc" id="L1158">    }</span>

    private void getRunsMemory(boolean mayAllocate, int len)
    {
<span class="nc" id="L1162">        Object array = getMemory(&quot;Runs&quot;, runsMemory, BidiRun.class, mayAllocate, len);</span>
<span class="nc" id="L1163">        runsMemory = (BidiRun[]) array;</span>
<span class="nc" id="L1164">    }</span>

    void getRunsMemory(int len)
    {
<span class="nc" id="L1168">        getRunsMemory(mayAllocateRuns, len);</span>
<span class="nc" id="L1169">    }</span>

    /* additional methods used by constructor - always allow allocation */
    private void getInitialDirPropsMemory(int len)
    {
<span class="nc" id="L1174">        getDirPropsMemory(true, len);</span>
<span class="nc" id="L1175">    }</span>

    private void getInitialLevelsMemory(int len)
    {
<span class="nc" id="L1179">        getLevelsMemory(true, len);</span>
<span class="nc" id="L1180">    }</span>

    private void getInitialParasMemory(int len)
    {
<span class="nc" id="L1184">        Object array = getMemory(&quot;Paras&quot;, parasMemory, Integer.TYPE, true, len);</span>
<span class="nc" id="L1185">        parasMemory = (int[]) array;</span>
<span class="nc" id="L1186">    }</span>

    private void getInitialRunsMemory(int len)
    {
<span class="nc" id="L1190">        getRunsMemory(true, len);</span>
<span class="nc" id="L1191">    }</span>

/* perform (P2)..(P3) ------------------------------------------------------- */

    private void getDirProps()
    {
<span class="nc" id="L1197">        int i = 0, i0, i1;</span>
<span class="nc" id="L1198">        flags = 0;          /* collect all directionalities in the text */</span>
        int uchar;
        byte dirProp;
<span class="nc" id="L1201">        byte paraDirDefault = 0;   /* initialize to avoid compiler warnings */</span>
<span class="nc" id="L1202">        boolean isDefaultLevel = IsDefaultLevel(paraLevel);</span>
        /* for inverse Bidi, the default para level is set to RTL if there is a
           strong R or AL character at either end of the text                */
<span class="nc" id="L1205">        lastArabicPos = -1;</span>
<span class="nc" id="L1206">        controlCount = 0;</span>

        final int NOT_CONTEXTUAL = 0;         /* 0: not contextual paraLevel */
        final int LOOKING_FOR_STRONG = 1;     /* 1: looking for first strong char */
        final int FOUND_STRONG_CHAR = 2;      /* 2: found first strong char       */

        int state;
<span class="nc" id="L1213">        int paraStart = 0;                    /* index of first char in paragraph */</span>
        byte paraDir;                         /* == CONTEXT_RTL within paragraphs
                                                 starting with strong R char      */
<span class="nc" id="L1216">        byte lastStrongDir=0;                 /* for default level &amp; inverse Bidi */</span>
<span class="nc" id="L1217">        int lastStrongLTR=0;                  /* for STREAMING option             */</span>

<span class="nc bnc" id="L1219" title="All 2 branches missed.">        if (isDefaultLevel) {</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">            paraDirDefault = ((paraLevel &amp; 1) != 0) ? CONTEXT_RTL : 0;</span>
<span class="nc" id="L1221">            paraDir = paraDirDefault;</span>
<span class="nc" id="L1222">            lastStrongDir = paraDirDefault;</span>
<span class="nc" id="L1223">            state = LOOKING_FOR_STRONG;</span>
        } else {
<span class="nc" id="L1225">            state = NOT_CONTEXTUAL;</span>
<span class="nc" id="L1226">            paraDir = 0;</span>
        }
        /* count paragraphs and determine the paragraph level (P2..P3) */
        /*
         * see comment on constant fields:
         * the LEVEL_DEFAULT_XXX values are designed so that
         * their low-order bit alone yields the intended default
         */

<span class="nc bnc" id="L1235" title="All 2 branches missed.">        for (i = 0; i &lt; originalLength; /* i is incremented in the loop */) {</span>
<span class="nc" id="L1236">            i0 = i;                     /* index of first code unit */</span>
<span class="nc" id="L1237">            uchar = UTF16.charAt(text, 0, originalLength, i);</span>
<span class="nc" id="L1238">            i += Character.charCount(uchar);</span>
<span class="nc" id="L1239">            i1 = i - 1; /* index of last code unit, gets the directional property */</span>

<span class="nc" id="L1241">            dirProp = (byte)bdp.getClass(uchar);</span>

<span class="nc" id="L1243">            flags |= DirPropFlag(dirProp);</span>
<span class="nc" id="L1244">            dirProps[i1] = (byte)(dirProp | paraDir);</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">            if (i1 &gt; i0) {     /* set previous code units' properties to BN */</span>
<span class="nc" id="L1246">                flags |= DirPropFlag(BN);</span>
                do {
<span class="nc" id="L1248">                    dirProps[--i1] = (byte)(BN | paraDir);</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                } while (i1 &gt; i0);</span>
            }
<span class="nc bnc" id="L1251" title="All 2 branches missed.">            if (state == LOOKING_FOR_STRONG) {</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">                if (dirProp == L) {</span>
<span class="nc" id="L1253">                    state = FOUND_STRONG_CHAR;</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">                    if (paraDir != 0) {</span>
<span class="nc" id="L1255">                        paraDir = 0;</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">                        for (i1 = paraStart; i1 &lt; i; i1++) {</span>
<span class="nc" id="L1257">                            dirProps[i1] &amp;= ~CONTEXT_RTL;</span>
                        }
                    }
                    continue;
                }
<span class="nc bnc" id="L1262" title="All 4 branches missed.">                if (dirProp == R || dirProp == AL) {</span>
<span class="nc" id="L1263">                    state = FOUND_STRONG_CHAR;</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">                    if (paraDir == 0) {</span>
<span class="nc" id="L1265">                        paraDir = CONTEXT_RTL;</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">                        for (i1 = paraStart; i1 &lt; i; i1++) {</span>
<span class="nc" id="L1267">                            dirProps[i1] |= CONTEXT_RTL;</span>
                        }
                    }
                    continue;
                }
            }
<span class="nc bnc" id="L1273" title="All 2 branches missed.">            if (dirProp == L) {</span>
<span class="nc" id="L1274">                lastStrongDir = 0;</span>
<span class="nc" id="L1275">                lastStrongLTR = i;      /* i is index to next character */</span>
            }
<span class="nc bnc" id="L1277" title="All 2 branches missed.">            else if (dirProp == R) {</span>
<span class="nc" id="L1278">                lastStrongDir = CONTEXT_RTL;</span>
            }
<span class="nc bnc" id="L1280" title="All 2 branches missed.">            else if (dirProp == AL) {</span>
<span class="nc" id="L1281">                lastStrongDir = CONTEXT_RTL;</span>
<span class="nc" id="L1282">                lastArabicPos = i-1;</span>
            }
<span class="nc bnc" id="L1284" title="All 2 branches missed.">            else if (dirProp == B) {</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">                if (i &lt; originalLength) {   /* B not last char in text */</span>
<span class="nc bnc" id="L1286" title="All 4 branches missed.">                    if (!((uchar == (int)CR) &amp;&amp; (text[i] == (int)LF))) {</span>
<span class="nc" id="L1287">                        paraCount++;</span>
                    }
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                    if (isDefaultLevel) {</span>
<span class="nc" id="L1290">                        state=LOOKING_FOR_STRONG;</span>
<span class="nc" id="L1291">                        paraStart = i;        /* i is index to next character */</span>
<span class="nc" id="L1292">                        paraDir = paraDirDefault;</span>
<span class="nc" id="L1293">                        lastStrongDir = paraDirDefault;</span>
                    }
                }
            }
        }
<span class="nc bnc" id="L1298" title="All 2 branches missed.">        if (isDefaultLevel) {</span>
<span class="nc" id="L1299">            paraLevel = GetParaLevelAt(0);</span>
        }

        /* The following line does nothing new for contextual paraLevel, but is
           needed for absolute paraLevel.                               */
<span class="nc" id="L1304">        flags |= DirPropFlagLR(paraLevel);</span>

<span class="nc bnc" id="L1306" title="All 4 branches missed.">        if (orderParagraphsLTR &amp;&amp; (flags &amp; DirPropFlag(B)) != 0) {</span>
<span class="nc" id="L1307">            flags |= DirPropFlag(L);</span>
        }
<span class="nc" id="L1309">    }</span>

    /* perform (X1)..(X9) ------------------------------------------------------- */

    /* determine if the text is mixed-directional or single-directional */
    private byte directionFromFlags() {
        /* if the text contains AN and neutrals, then some neutrals may become RTL */
<span class="nc bnc" id="L1316" title="All 2 branches missed.">        if (!((flags &amp; MASK_RTL) != 0 ||</span>
<span class="nc bnc" id="L1317" title="All 4 branches missed.">              ((flags &amp; DirPropFlag(AN)) != 0 &amp;&amp;</span>
               (flags &amp; MASK_POSSIBLE_N) != 0))) {
<span class="nc" id="L1319">            return Bidi.DIRECTION_LEFT_TO_RIGHT;</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">        } else if ((flags &amp; MASK_LTR) == 0) {</span>
<span class="nc" id="L1321">            return Bidi.DIRECTION_RIGHT_TO_LEFT;</span>
        } else {
<span class="nc" id="L1323">            return MIXED;</span>
        }
    }

    /*
     * Resolve the explicit levels as specified by explicit embedding codes.
     * Recalculate the flags to have them reflect the real properties
     * after taking the explicit embeddings into account.
     *
     * The Bidi algorithm is designed to result in the same behavior whether embedding
     * levels are externally specified (from &quot;styled text&quot;, supposedly the preferred
     * method) or set by explicit embedding codes (LRx, RLx, PDF) in the plain text.
     * That is why (X9) instructs to remove all explicit codes (and BN).
     * However, in a real implementation, this removal of these codes and their index
     * positions in the plain text is undesirable since it would result in
     * reallocated, reindexed text.
     * Instead, this implementation leaves the codes in there and just ignores them
     * in the subsequent processing.
     * In order to get the same reordering behavior, positions with a BN or an
     * explicit embedding code just get the same level assigned as the last &quot;real&quot;
     * character.
     *
     * Some implementations, not this one, then overwrite some of these
     * directionality properties at &quot;real&quot; same-level-run boundaries by
     * L or R codes so that the resolution of weak types can be performed on the
     * entire paragraph at once instead of having to parse it once more and
     * perform that resolution on same-level-runs.
     * This limits the scope of the implicit rules in effectively
     * the same way as the run limits.
     *
     * Instead, this implementation does not modify these codes.
     * On one hand, the paragraph has to be scanned for same-level-runs, but
     * on the other hand, this saves another loop to reset these codes,
     * or saves making and modifying a copy of dirProps[].
     *
     *
     * Note that (Pn) and (Xn) changed significantly from version 4 of the Bidi algorithm.
     *
     *
     * Handling the stack of explicit levels (Xn):
     *
     * With the Bidi stack of explicit levels,
     * as pushed with each LRE, RLE, LRO, and RLO and popped with each PDF,
     * the explicit level must never exceed MAX_EXPLICIT_LEVEL==61.
     *
     * In order to have a correct push-pop semantics even in the case of overflows,
     * there are two overflow counters:
     * - countOver60 is incremented with each LRx at level 60
     * - from level 60, one RLx increases the level to 61
     * - countOver61 is incremented with each LRx and RLx at level 61
     *
     * Popping levels with PDF must work in the opposite order so that level 61
     * is correct at the correct point. Underflows (too many PDFs) must be checked.
     *
     * This implementation assumes that MAX_EXPLICIT_LEVEL is odd.
     */
    private byte resolveExplicitLevels() {
<span class="nc" id="L1380">        int i = 0;</span>
        byte dirProp;
<span class="nc" id="L1382">        byte level = GetParaLevelAt(0);</span>

        byte dirct;
<span class="nc" id="L1385">        int paraIndex = 0;</span>

        /* determine if the text is mixed-directional or single-directional */
<span class="nc" id="L1388">        dirct = directionFromFlags();</span>

        /* we may not need to resolve any explicit levels, but for multiple
           paragraphs we want to loop on all chars to set the para boundaries */
<span class="nc bnc" id="L1392" title="All 4 branches missed.">        if ((dirct != MIXED) &amp;&amp; (paraCount == 1)) {</span>
            /* not mixed directionality: levels don't matter - trailingWSStart will be 0 */
<span class="nc bnc" id="L1394" title="All 4 branches missed.">        } else if ((paraCount == 1) &amp;&amp;</span>
                   ((flags &amp; MASK_EXPLICIT) == 0)) {
            /* mixed, but all characters are at the same embedding level */
            /* or we are in &quot;inverse Bidi&quot; */
            /* and we don't have contextual multiple paragraphs with some B char */
            /* set all levels to the paragraph level */
<span class="nc bnc" id="L1400" title="All 2 branches missed.">            for (i = 0; i &lt; length; ++i) {</span>
<span class="nc" id="L1401">                levels[i] = level;</span>
            }
        } else {
            /* continue to perform (Xn) */

            /* (X1) level is set for all codes, embeddingLevel keeps track of the push/pop operations */
            /* both variables may carry the LEVEL_OVERRIDE flag to indicate the override status */
<span class="nc" id="L1408">            byte embeddingLevel = level;</span>
            byte newLevel;
<span class="nc" id="L1410">            byte stackTop = 0;</span>

<span class="nc" id="L1412">            byte[] stack = new byte[MAX_EXPLICIT_LEVEL];    /* we never push anything &gt;=MAX_EXPLICIT_LEVEL */</span>
<span class="nc" id="L1413">            int countOver60 = 0;</span>
<span class="nc" id="L1414">            int countOver61 = 0;  /* count overflows of explicit levels */</span>

            /* recalculate the flags */
<span class="nc" id="L1417">            flags = 0;</span>

<span class="nc bnc" id="L1419" title="All 2 branches missed.">            for (i = 0; i &lt; length; ++i) {</span>
<span class="nc" id="L1420">                dirProp = NoContextRTL(dirProps[i]);</span>
<span class="nc bnc" id="L1421" title="All 6 branches missed.">                switch(dirProp) {</span>
                case LRE:
                case LRO:
                    /* (X3, X5) */
<span class="nc" id="L1425">                    newLevel = (byte)((embeddingLevel+2) &amp; ~(INTERNAL_LEVEL_OVERRIDE | 1)); /* least greater even level */</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">                    if (newLevel &lt;= MAX_EXPLICIT_LEVEL) {</span>
<span class="nc" id="L1427">                        stack[stackTop] = embeddingLevel;</span>
<span class="nc" id="L1428">                        ++stackTop;</span>
<span class="nc" id="L1429">                        embeddingLevel = newLevel;</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">                        if (dirProp == LRO) {</span>
<span class="nc" id="L1431">                            embeddingLevel |= INTERNAL_LEVEL_OVERRIDE;</span>
                        }
                        /* we don't need to set LEVEL_OVERRIDE off for LRE
                           since this has already been done for newLevel which is
                           the source for embeddingLevel.
                         */
<span class="nc bnc" id="L1437" title="All 2 branches missed.">                    } else if ((embeddingLevel &amp; ~INTERNAL_LEVEL_OVERRIDE) == MAX_EXPLICIT_LEVEL) {</span>
<span class="nc" id="L1438">                        ++countOver61;</span>
                    } else /* (embeddingLevel &amp; ~INTERNAL_LEVEL_OVERRIDE) == MAX_EXPLICIT_LEVEL-1 */ {
<span class="nc" id="L1440">                        ++countOver60;</span>
                    }
<span class="nc" id="L1442">                    flags |= DirPropFlag(BN);</span>
<span class="nc" id="L1443">                    break;</span>
                case RLE:
                case RLO:
                    /* (X2, X4) */
<span class="nc" id="L1447">                    newLevel=(byte)(((embeddingLevel &amp; ~INTERNAL_LEVEL_OVERRIDE) + 1) | 1); /* least greater odd level */</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">                    if (newLevel&lt;=MAX_EXPLICIT_LEVEL) {</span>
<span class="nc" id="L1449">                        stack[stackTop] = embeddingLevel;</span>
<span class="nc" id="L1450">                        ++stackTop;</span>
<span class="nc" id="L1451">                        embeddingLevel = newLevel;</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">                        if (dirProp == RLO) {</span>
<span class="nc" id="L1453">                            embeddingLevel |= INTERNAL_LEVEL_OVERRIDE;</span>
                        }
                        /* we don't need to set LEVEL_OVERRIDE off for RLE
                           since this has already been done for newLevel which is
                           the source for embeddingLevel.
                         */
                    } else {
<span class="nc" id="L1460">                        ++countOver61;</span>
                    }
<span class="nc" id="L1462">                    flags |= DirPropFlag(BN);</span>
<span class="nc" id="L1463">                    break;</span>
                case PDF:
                    /* (X7) */
                    /* handle all the overflow cases first */
<span class="nc bnc" id="L1467" title="All 2 branches missed.">                    if (countOver61 &gt; 0) {</span>
<span class="nc" id="L1468">                        --countOver61;</span>
<span class="nc bnc" id="L1469" title="All 4 branches missed.">                    } else if (countOver60 &gt; 0 &amp;&amp; (embeddingLevel &amp; ~INTERNAL_LEVEL_OVERRIDE) != MAX_EXPLICIT_LEVEL) {</span>
                        /* handle LRx overflows from level 60 */
<span class="nc" id="L1471">                        --countOver60;</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">                    } else if (stackTop &gt; 0) {</span>
                        /* this is the pop operation; it also pops level 61 while countOver60&gt;0 */
<span class="nc" id="L1474">                        --stackTop;</span>
<span class="nc" id="L1475">                        embeddingLevel = stack[stackTop];</span>
                    /* } else { (underflow) */
                    }
<span class="nc" id="L1478">                    flags |= DirPropFlag(BN);</span>
<span class="nc" id="L1479">                    break;</span>
                case B:
<span class="nc" id="L1481">                    stackTop = 0;</span>
<span class="nc" id="L1482">                    countOver60 = 0;</span>
<span class="nc" id="L1483">                    countOver61 = 0;</span>
<span class="nc" id="L1484">                    level = GetParaLevelAt(i);</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">                    if ((i + 1) &lt; length) {</span>
<span class="nc" id="L1486">                        embeddingLevel = GetParaLevelAt(i+1);</span>
<span class="nc bnc" id="L1487" title="All 4 branches missed.">                        if (!((text[i] == CR) &amp;&amp; (text[i + 1] == LF))) {</span>
<span class="nc" id="L1488">                            paras[paraIndex++] = i+1;</span>
                        }
                    }
<span class="nc" id="L1491">                    flags |= DirPropFlag(B);</span>
<span class="nc" id="L1492">                    break;</span>
                case BN:
                    /* BN, LRE, RLE, and PDF are supposed to be removed (X9) */
                    /* they will get their levels set correctly in adjustWSLevels() */
<span class="nc" id="L1496">                    flags |= DirPropFlag(BN);</span>
<span class="nc" id="L1497">                    break;</span>
                default:
                    /* all other types get the &quot;real&quot; level */
<span class="nc bnc" id="L1500" title="All 2 branches missed.">                    if (level != embeddingLevel) {</span>
<span class="nc" id="L1501">                        level = embeddingLevel;</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">                        if ((level &amp; INTERNAL_LEVEL_OVERRIDE) != 0) {</span>
<span class="nc" id="L1503">                            flags |= DirPropFlagO(level) | DirPropFlagMultiRuns;</span>
                        } else {
<span class="nc" id="L1505">                            flags |= DirPropFlagE(level) | DirPropFlagMultiRuns;</span>
                        }
                    }
<span class="nc bnc" id="L1508" title="All 2 branches missed.">                    if ((level &amp; INTERNAL_LEVEL_OVERRIDE) == 0) {</span>
<span class="nc" id="L1509">                        flags |= DirPropFlag(dirProp);</span>
                    }
                    break;
                }

                /*
                 * We need to set reasonable levels even on BN codes and
                 * explicit codes because we will later look at same-level runs (X10).
                 */
<span class="nc" id="L1518">                levels[i] = level;</span>
            }
<span class="nc bnc" id="L1520" title="All 2 branches missed.">            if ((flags &amp; MASK_EMBEDDING) != 0) {</span>
<span class="nc" id="L1521">                flags |= DirPropFlagLR(paraLevel);</span>
            }
<span class="nc bnc" id="L1523" title="All 4 branches missed.">            if (orderParagraphsLTR &amp;&amp; (flags &amp; DirPropFlag(B)) != 0) {</span>
<span class="nc" id="L1524">                flags |= DirPropFlag(L);</span>
            }

            /* subsequently, ignore the explicit codes and BN (X9) */

            /* again, determine if the text is mixed-directional or single-directional */
<span class="nc" id="L1530">            dirct = directionFromFlags();</span>
        }

<span class="nc" id="L1533">        return dirct;</span>
    }

    /*
     * Use a pre-specified embedding levels array:
     *
     * Adjust the directional properties for overrides (-&gt;LEVEL_OVERRIDE),
     * ignore all explicit codes (X9),
     * and check all the preset levels.
     *
     * Recalculate the flags to have them reflect the real properties
     * after taking the explicit embeddings into account.
     */
    private byte checkExplicitLevels() {
        byte dirProp;
        int i;
<span class="nc" id="L1549">        this.flags = 0;     /* collect all directionalities in the text */</span>
        byte level;
<span class="nc" id="L1551">        int paraIndex = 0;</span>

<span class="nc bnc" id="L1553" title="All 2 branches missed.">        for (i = 0; i &lt; length; ++i) {</span>
<span class="nc bnc" id="L1554" title="All 2 branches missed.">            if (levels[i] == 0) {</span>
<span class="nc" id="L1555">                levels[i] = paraLevel;</span>
            }
<span class="nc bnc" id="L1557" title="All 2 branches missed.">            if (MAX_EXPLICIT_LEVEL &lt; (levels[i]&amp;0x7f)) {</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">                if ((levels[i] &amp; INTERNAL_LEVEL_OVERRIDE) != 0) {</span>
<span class="nc" id="L1559">                    levels[i] =  (byte)(paraLevel|INTERNAL_LEVEL_OVERRIDE);</span>
                } else {
<span class="nc" id="L1561">                    levels[i] = paraLevel;</span>
                }
            }
<span class="nc" id="L1564">            level = levels[i];</span>
<span class="nc" id="L1565">            dirProp = NoContextRTL(dirProps[i]);</span>
<span class="nc bnc" id="L1566" title="All 2 branches missed.">            if ((level &amp; INTERNAL_LEVEL_OVERRIDE) != 0) {</span>
                /* keep the override flag in levels[i] but adjust the flags */
<span class="nc" id="L1568">                level &amp;= ~INTERNAL_LEVEL_OVERRIDE;     /* make the range check below simpler */</span>
<span class="nc" id="L1569">                flags |= DirPropFlagO(level);</span>
            } else {
                /* set the flags */
<span class="nc" id="L1572">                flags |= DirPropFlagE(level) | DirPropFlag(dirProp);</span>
            }

<span class="nc bnc" id="L1575" title="All 8 branches missed.">            if ((level &lt; GetParaLevelAt(i) &amp;&amp;</span>
                    !((0 == level) &amp;&amp; (dirProp == B))) ||
                    (MAX_EXPLICIT_LEVEL &lt;level)) {
                /* level out of bounds */
<span class="nc" id="L1579">                throw new IllegalArgumentException(&quot;level &quot; + level +</span>
                                                   &quot; out of bounds at index &quot; + i);
            }
<span class="nc bnc" id="L1582" title="All 4 branches missed.">            if ((dirProp == B) &amp;&amp; ((i + 1) &lt; length)) {</span>
<span class="nc bnc" id="L1583" title="All 4 branches missed.">                if (!((text[i] == CR) &amp;&amp; (text[i + 1] == LF))) {</span>
<span class="nc" id="L1584">                    paras[paraIndex++] = i + 1;</span>
                }
            }
        }
<span class="nc bnc" id="L1588" title="All 2 branches missed.">        if ((flags&amp;MASK_EMBEDDING) != 0) {</span>
<span class="nc" id="L1589">            flags |= DirPropFlagLR(paraLevel);</span>
        }

        /* determine if the text is mixed-directional or single-directional */
<span class="nc" id="L1593">        return directionFromFlags();</span>
    }

    /*********************************************************************/
    /* The Properties state machine table                                */
    /*********************************************************************/
    /*                                                                   */
    /* All table cells are 8 bits:                                       */
    /*      bits 0..4:  next state                                       */
    /*      bits 5..7:  action to perform (if &gt; 0)                       */
    /*                                                                   */
    /* Cells may be of format &quot;n&quot; where n represents the next state      */
    /* (except for the rightmost column).                                */
    /* Cells may also be of format &quot;_(x,y)&quot; where x represents an action */
    /* to perform and y represents the next state.                       */
    /*                                                                   */
    /*********************************************************************/
    /* Definitions and type for properties state tables                  */
    /*********************************************************************/
    private static final int IMPTABPROPS_COLUMNS = 14;
    private static final int IMPTABPROPS_RES = IMPTABPROPS_COLUMNS - 1;
    private static short GetStateProps(short cell) {
<span class="nc" id="L1615">        return (short)(cell &amp; 0x1f);</span>
    }
    private static short GetActionProps(short cell) {
<span class="nc" id="L1618">        return (short)(cell &gt;&gt; 5);</span>
    }

<span class="fc" id="L1621">    private static final short groupProp[] =          /* dirProp regrouped */</span>
    {
        /*  L   R   EN  ES  ET  AN  CS  B   S   WS  ON  LRE LRO AL  RLE RLO PDF NSM BN  */
        0,  1,  2,  7,  8,  3,  9,  6,  5,  4,  4,  10, 10, 12, 10, 10, 10, 11, 10
    };
    private static final short _L  = 0;
    private static final short _R  = 1;
    private static final short _EN = 2;
    private static final short _AN = 3;
    private static final short _ON = 4;
    private static final short _S  = 5;
    private static final short _B  = 6; /* reduced dirProp */

    /*********************************************************************/
    /*                                                                   */
    /*      PROPERTIES  STATE  TABLE                                     */
    /*                                                                   */
    /* In table impTabProps,                                             */
    /*      - the ON column regroups ON and WS                           */
    /*      - the BN column regroups BN, LRE, RLE, LRO, RLO, PDF         */
    /*      - the Res column is the reduced property assigned to a run   */
    /*                                                                   */
    /* Action 1: process current run1, init new run1                     */
    /*        2: init new run2                                           */
    /*        3: process run1, process run2, init new run1               */
    /*        4: process run1, set run1=run2, init new run2              */
    /*                                                                   */
    /* Notes:                                                            */
    /*  1) This table is used in resolveImplicitLevels().                */
    /*  2) This table triggers actions when there is a change in the Bidi*/
    /*     property of incoming characters (action 1).                   */
    /*  3) Most such property sequences are processed immediately (in    */
    /*     fact, passed to processPropertySeq().                         */
    /*  4) However, numbers are assembled as one sequence. This means    */
    /*     that undefined situations (like CS following digits, until    */
    /*     it is known if the next char will be a digit) are held until  */
    /*     following chars define them.                                  */
    /*     Example: digits followed by CS, then comes another CS or ON;  */
    /*              the digits will be processed, then the CS assigned   */
    /*              as the start of an ON sequence (action 3).           */
    /*  5) There are cases where more than one sequence must be          */
    /*     processed, for instance digits followed by CS followed by L:  */
    /*     the digits must be processed as one sequence, and the CS      */
    /*     must be processed as an ON sequence, all this before starting */
    /*     assembling chars for the opening L sequence.                  */
    /*                                                                   */
    /*                                                                   */
<span class="fc" id="L1668">    private static final short impTabProps[][] =</span>
    {
/*                        L,     R,    EN,    AN,    ON,     S,     B,    ES,    ET,    CS,    BN,   NSM,    AL,  Res */
/* 0 Init        */ {     1,     2,     4,     5,     7,    15,    17,     7,     9,     7,     0,     7,     3,  _ON },
/* 1 L           */ {     1,  32+2,  32+4,  32+5,  32+7, 32+15, 32+17,  32+7,  32+9,  32+7,     1,     1,  32+3,   _L },
/* 2 R           */ {  32+1,     2,  32+4,  32+5,  32+7, 32+15, 32+17,  32+7,  32+9,  32+7,     2,     2,  32+3,   _R },
/* 3 AL          */ {  32+1,  32+2,  32+6,  32+6,  32+8, 32+16, 32+17,  32+8,  32+8,  32+8,     3,     3,     3,   _R },
/* 4 EN          */ {  32+1,  32+2,     4,  32+5,  32+7, 32+15, 32+17, 64+10,    11, 64+10,     4,     4,  32+3,  _EN },
/* 5 AN          */ {  32+1,  32+2,  32+4,     5,  32+7, 32+15, 32+17,  32+7,  32+9, 64+12,     5,     5,  32+3,  _AN },
/* 6 AL:EN/AN    */ {  32+1,  32+2,     6,     6,  32+8, 32+16, 32+17,  32+8,  32+8, 64+13,     6,     6,  32+3,  _AN },
/* 7 ON          */ {  32+1,  32+2,  32+4,  32+5,     7, 32+15, 32+17,     7, 64+14,     7,     7,     7,  32+3,  _ON },
/* 8 AL:ON       */ {  32+1,  32+2,  32+6,  32+6,     8, 32+16, 32+17,     8,     8,     8,     8,     8,  32+3,  _ON },
/* 9 ET          */ {  32+1,  32+2,     4,  32+5,     7, 32+15, 32+17,     7,     9,     7,     9,     9,  32+3,  _ON },
/*10 EN+ES/CS    */ {  96+1,  96+2,     4,  96+5, 128+7, 96+15, 96+17, 128+7,128+14, 128+7,    10, 128+7,  96+3,  _EN },
/*11 EN+ET       */ {  32+1,  32+2,     4,  32+5,  32+7, 32+15, 32+17,  32+7,    11,  32+7,    11,    11,  32+3,  _EN },
/*12 AN+CS       */ {  96+1,  96+2,  96+4,     5, 128+7, 96+15, 96+17, 128+7,128+14, 128+7,    12, 128+7,  96+3,  _AN },
/*13 AL:EN/AN+CS */ {  96+1,  96+2,     6,     6, 128+8, 96+16, 96+17, 128+8, 128+8, 128+8,    13, 128+8,  96+3,  _AN },
/*14 ON+ET       */ {  32+1,  32+2, 128+4,  32+5,     7, 32+15, 32+17,     7,    14,     7,    14,    14,  32+3,  _ON },
/*15 S           */ {  32+1,  32+2,  32+4,  32+5,  32+7,    15, 32+17,  32+7,  32+9,  32+7,    15,  32+7,  32+3,   _S },
/*16 AL:S        */ {  32+1,  32+2,  32+6,  32+6,  32+8,    16, 32+17,  32+8,  32+8,  32+8,    16,  32+8,  32+3,   _S },
/*17 B           */ {  32+1,  32+2,  32+4,  32+5,  32+7, 32+15,    17,  32+7,  32+9,  32+7,    17,  32+7,  32+3,   _B }
    };

    /*********************************************************************/
    /* The levels state machine tables                                   */
    /*********************************************************************/
    /*                                                                   */
    /* All table cells are 8 bits:                                       */
    /*      bits 0..3:  next state                                       */
    /*      bits 4..7:  action to perform (if &gt; 0)                       */
    /*                                                                   */
    /* Cells may be of format &quot;n&quot; where n represents the next state      */
    /* (except for the rightmost column).                                */
    /* Cells may also be of format &quot;_(x,y)&quot; where x represents an action */
    /* to perform and y represents the next state.                       */
    /*                                                                   */
    /* This format limits each table to 16 states each and to 15 actions.*/
    /*                                                                   */
    /*********************************************************************/
    /* Definitions and type for levels state tables                      */
    /*********************************************************************/
    private static final int IMPTABLEVELS_COLUMNS = _B + 2;
    private static final int IMPTABLEVELS_RES = IMPTABLEVELS_COLUMNS - 1;
<span class="nc" id="L1711">    private static short GetState(byte cell) { return (short)(cell &amp; 0x0f); }</span>
<span class="nc" id="L1712">    private static short GetAction(byte cell) { return (short)(cell &gt;&gt; 4); }</span>

    private static class ImpTabPair {
        byte[][][] imptab;
        short[][] impact;

        ImpTabPair(byte[][] table1, byte[][] table2,
<span class="fc" id="L1719">                   short[] act1, short[] act2) {</span>
<span class="fc" id="L1720">            imptab = new byte[][][] {table1, table2};</span>
<span class="fc" id="L1721">            impact = new short[][] {act1, act2};</span>
<span class="fc" id="L1722">        }</span>
    }

    /*********************************************************************/
    /*                                                                   */
    /*      LEVELS  STATE  TABLES                                        */
    /*                                                                   */
    /* In all levels state tables,                                       */
    /*      - state 0 is the initial state                               */
    /*      - the Res column is the increment to add to the text level   */
    /*        for this property sequence.                                */
    /*                                                                   */
    /* The impact arrays for each table of a pair map the local action   */
    /* numbers of the table to the total list of actions. For instance,  */
    /* action 2 in a given table corresponds to the action number which  */
    /* appears in entry [2] of the impact array for that table.          */
    /* The first entry of all impact arrays must be 0.                   */
    /*                                                                   */
    /* Action 1: init conditional sequence                               */
    /*        2: prepend conditional sequence to current sequence        */
    /*        3: set ON sequence to new level - 1                        */
    /*        4: init EN/AN/ON sequence                                  */
    /*        5: fix EN/AN/ON sequence followed by R                     */
    /*        6: set previous level sequence to level 2                  */
    /*                                                                   */
    /* Notes:                                                            */
    /*  1) These tables are used in processPropertySeq(). The input      */
    /*     is property sequences as determined by resolveImplicitLevels. */
    /*  2) Most such property sequences are processed immediately        */
    /*     (levels are assigned).                                        */
    /*  3) However, some sequences cannot be assigned a final level till */
    /*     one or more following sequences are received. For instance,   */
    /*     ON following an R sequence within an even-level paragraph.    */
    /*     If the following sequence is R, the ON sequence will be       */
    /*     assigned basic run level+1, and so will the R sequence.       */
    /*  4) S is generally handled like ON, since its level will be fixed */
    /*     to paragraph level in adjustWSLevels().                       */
    /*                                                                   */

<span class="fc" id="L1761">    private static final byte impTabL_DEFAULT[][] = /* Even paragraph level */</span>
        /*  In this table, conditional sequences receive the higher possible level
            until proven otherwise.
        */
    {
        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
        /* 0 : init       */ {     0,     1,     0,     2,     0,     0,     0,  0 },
        /* 1 : R          */ {     0,     1,     3,     3,  0x14,  0x14,     0,  1 },
        /* 2 : AN         */ {     0,     1,     0,     2,  0x15,  0x15,     0,  2 },
        /* 3 : R+EN/AN    */ {     0,     1,     3,     3,  0x14,  0x14,     0,  2 },
        /* 4 : R+ON       */ {  0x20,     1,     3,     3,     4,     4,  0x20,  1 },
        /* 5 : AN+ON      */ {  0x20,     1,  0x20,     2,     5,     5,  0x20,  1 }
    };

<span class="fc" id="L1775">    private static final byte impTabR_DEFAULT[][] = /* Odd  paragraph level */</span>
        /*  In this table, conditional sequences receive the lower possible level
            until proven otherwise.
        */
    {
        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
        /* 0 : init       */ {     1,     0,     2,     2,     0,     0,     0,  0 },
        /* 1 : L          */ {     1,     0,     1,     3,  0x14,  0x14,     0,  1 },
        /* 2 : EN/AN      */ {     1,     0,     2,     2,     0,     0,     0,  1 },
        /* 3 : L+AN       */ {     1,     0,     1,     3,     5,     5,     0,  1 },
        /* 4 : L+ON       */ {  0x21,     0,  0x21,     3,     4,     4,     0,  0 },
        /* 5 : L+AN+ON    */ {     1,     0,     1,     3,     5,     5,     0,  0 }
    };

<span class="fc" id="L1789">    private static final short[] impAct0 = {0,1,2,3,4,5,6};</span>

<span class="fc" id="L1791">    private static final ImpTabPair impTab_DEFAULT = new ImpTabPair(</span>
            impTabL_DEFAULT, impTabR_DEFAULT, impAct0, impAct0);

<span class="fc" id="L1794">    private static final byte impTabL_NUMBERS_SPECIAL[][] = { /* Even paragraph level */</span>
        /* In this table, conditional sequences receive the higher possible
           level until proven otherwise.
        */
        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
        /* 0 : init       */ {     0,     2,     1,     1,     0,     0,     0,  0 },
        /* 1 : L+EN/AN    */ {     0,     2,     1,     1,     0,     0,     0,  2 },
        /* 2 : R          */ {     0,     2,     4,     4,  0x13,     0,     0,  1 },
        /* 3 : R+ON       */ {  0x20,     2,     4,     4,     3,     3,  0x20,  1 },
        /* 4 : R+EN/AN    */ {     0,     2,     4,     4,  0x13,  0x13,     0,  2 }
    };
<span class="fc" id="L1805">    private static final ImpTabPair impTab_NUMBERS_SPECIAL = new ImpTabPair(</span>
            impTabL_NUMBERS_SPECIAL, impTabR_DEFAULT, impAct0, impAct0);

<span class="fc" id="L1808">    private static final byte impTabL_GROUP_NUMBERS_WITH_R[][] = {</span>
        /* In this table, EN/AN+ON sequences receive levels as if associated with R
           until proven that there is L or sor/eor on both sides. AN is handled like EN.
        */
        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
        /* 0 init         */ {     0,     3,  0x11,  0x11,     0,     0,     0,  0 },
        /* 1 EN/AN        */ {  0x20,     3,     1,     1,     2,  0x20,  0x20,  2 },
        /* 2 EN/AN+ON     */ {  0x20,     3,     1,     1,     2,  0x20,  0x20,  1 },
        /* 3 R            */ {     0,     3,     5,     5,  0x14,     0,     0,  1 },
        /* 4 R+ON         */ {  0x20,     3,     5,     5,     4,  0x20,  0x20,  1 },
        /* 5 R+EN/AN      */ {     0,     3,     5,     5,  0x14,     0,     0,  2 }
    };
<span class="fc" id="L1820">    private static final byte impTabR_GROUP_NUMBERS_WITH_R[][] = {</span>
        /*  In this table, EN/AN+ON sequences receive levels as if associated with R
            until proven that there is L on both sides. AN is handled like EN.
        */
        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
        /* 0 init         */ {     2,     0,     1,     1,     0,     0,     0,  0 },
        /* 1 EN/AN        */ {     2,     0,     1,     1,     0,     0,     0,  1 },
        /* 2 L            */ {     2,     0,  0x14,  0x14,  0x13,     0,     0,  1 },
        /* 3 L+ON         */ {  0x22,     0,     4,     4,     3,     0,     0,  0 },
        /* 4 L+EN/AN      */ {  0x22,     0,     4,     4,     3,     0,     0,  1 }
    };
<span class="fc" id="L1831">    private static final ImpTabPair impTab_GROUP_NUMBERS_WITH_R = new</span>
            ImpTabPair(impTabL_GROUP_NUMBERS_WITH_R,
                       impTabR_GROUP_NUMBERS_WITH_R, impAct0, impAct0);

<span class="fc" id="L1835">    private static final byte impTabL_INVERSE_NUMBERS_AS_L[][] = {</span>
        /* This table is identical to the Default LTR table except that EN and AN
           are handled like L.
        */
        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
        /* 0 : init       */ {     0,     1,     0,     0,     0,     0,     0,  0 },
        /* 1 : R          */ {     0,     1,     0,     0,  0x14,  0x14,     0,  1 },
        /* 2 : AN         */ {     0,     1,     0,     0,  0x15,  0x15,     0,  2 },
        /* 3 : R+EN/AN    */ {     0,     1,     0,     0,  0x14,  0x14,     0,  2 },
        /* 4 : R+ON       */ {  0x20,     1,  0x20,  0x20,     4,     4,  0x20,  1 },
        /* 5 : AN+ON      */ {  0x20,     1,  0x20,  0x20,     5,     5,  0x20,  1 }
    };
<span class="fc" id="L1847">    private static final byte impTabR_INVERSE_NUMBERS_AS_L[][] = {</span>
        /* This table is identical to the Default RTL table except that EN and AN
           are handled like L.
        */
        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
        /* 0 : init       */ {     1,     0,     1,     1,     0,     0,     0,  0 },
        /* 1 : L          */ {     1,     0,     1,     1,  0x14,  0x14,     0,  1 },
        /* 2 : EN/AN      */ {     1,     0,     1,     1,     0,     0,     0,  1 },
        /* 3 : L+AN       */ {     1,     0,     1,     1,     5,     5,     0,  1 },
        /* 4 : L+ON       */ {  0x21,     0,  0x21,  0x21,     4,     4,     0,  0 },
        /* 5 : L+AN+ON    */ {     1,     0,     1,     1,     5,     5,     0,  0 }
    };
<span class="fc" id="L1859">    private static final ImpTabPair impTab_INVERSE_NUMBERS_AS_L = new ImpTabPair</span>
            (impTabL_INVERSE_NUMBERS_AS_L, impTabR_INVERSE_NUMBERS_AS_L,
             impAct0, impAct0);

<span class="fc" id="L1863">    private static final byte impTabR_INVERSE_LIKE_DIRECT[][] = {  /* Odd  paragraph level */</span>
        /*  In this table, conditional sequences receive the lower possible level
            until proven otherwise.
        */
        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
        /* 0 : init       */ {     1,     0,     2,     2,     0,     0,     0,  0 },
        /* 1 : L          */ {     1,     0,     1,     2,  0x13,  0x13,     0,  1 },
        /* 2 : EN/AN      */ {     1,     0,     2,     2,     0,     0,     0,  1 },
        /* 3 : L+ON       */ {  0x21,  0x30,     6,     4,     3,     3,  0x30,  0 },
        /* 4 : L+ON+AN    */ {  0x21,  0x30,     6,     4,     5,     5,  0x30,  3 },
        /* 5 : L+AN+ON    */ {  0x21,  0x30,     6,     4,     5,     5,  0x30,  2 },
        /* 6 : L+ON+EN    */ {  0x21,  0x30,     6,     4,     3,     3,  0x30,  1 }
    };
<span class="fc" id="L1876">    private static final short[] impAct1 = {0,1,11,12};</span>
<span class="fc" id="L1877">    private static final ImpTabPair impTab_INVERSE_LIKE_DIRECT = new ImpTabPair(</span>
            impTabL_DEFAULT, impTabR_INVERSE_LIKE_DIRECT, impAct0, impAct1);

<span class="fc" id="L1880">    private static final byte impTabL_INVERSE_LIKE_DIRECT_WITH_MARKS[][] = {</span>
        /* The case handled in this table is (visually):  R EN L
         */
        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
        /* 0 : init       */ {     0,  0x63,     0,     1,     0,     0,     0,  0 },
        /* 1 : L+AN       */ {     0,  0x63,     0,     1,  0x12,  0x30,     0,  4 },
        /* 2 : L+AN+ON    */ {  0x20,  0x63,  0x20,     1,     2,  0x30,  0x20,  3 },
        /* 3 : R          */ {     0,  0x63,  0x55,  0x56,  0x14,  0x30,     0,  3 },
        /* 4 : R+ON       */ {  0x30,  0x43,  0x55,  0x56,     4,  0x30,  0x30,  3 },
        /* 5 : R+EN       */ {  0x30,  0x43,     5,  0x56,  0x14,  0x30,  0x30,  4 },
        /* 6 : R+AN       */ {  0x30,  0x43,  0x55,     6,  0x14,  0x30,  0x30,  4 }
    };
<span class="fc" id="L1892">    private static final byte impTabR_INVERSE_LIKE_DIRECT_WITH_MARKS[][] = {</span>
        /* The cases handled in this table are (visually):  R EN L
                                                            R L AN L
        */
        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
        /* 0 : init       */ {  0x13,     0,     1,     1,     0,     0,     0,  0 },
        /* 1 : R+EN/AN    */ {  0x23,     0,     1,     1,     2,  0x40,     0,  1 },
        /* 2 : R+EN/AN+ON */ {  0x23,     0,     1,     1,     2,  0x40,     0,  0 },
        /* 3 : L          */ {    3 ,     0,     3,  0x36,  0x14,  0x40,     0,  1 },
        /* 4 : L+ON       */ {  0x53,  0x40,     5,  0x36,     4,  0x40,  0x40,  0 },
        /* 5 : L+ON+EN    */ {  0x53,  0x40,     5,  0x36,     4,  0x40,  0x40,  1 },
        /* 6 : L+AN       */ {  0x53,  0x40,     6,     6,     4,  0x40,  0x40,  3 }
    };
<span class="fc" id="L1905">    private static final short impAct2[] = {0,1,7,8,9,10};</span>
<span class="fc" id="L1906">    private static final ImpTabPair impTab_INVERSE_LIKE_DIRECT_WITH_MARKS =</span>
            new ImpTabPair(impTabL_INVERSE_LIKE_DIRECT_WITH_MARKS,
                           impTabR_INVERSE_LIKE_DIRECT_WITH_MARKS, impAct0, impAct2);

<span class="fc" id="L1910">    private static final ImpTabPair impTab_INVERSE_FOR_NUMBERS_SPECIAL = new ImpTabPair(</span>
            impTabL_NUMBERS_SPECIAL, impTabR_INVERSE_LIKE_DIRECT, impAct0, impAct1);

<span class="fc" id="L1913">    private static final byte impTabL_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS[][] = {</span>
        /*  The case handled in this table is (visually):  R EN L
        */
        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
        /* 0 : init       */ {     0,  0x62,     1,     1,     0,     0,     0,  0 },
        /* 1 : L+EN/AN    */ {     0,  0x62,     1,     1,     0,  0x30,     0,  4 },
        /* 2 : R          */ {     0,  0x62,  0x54,  0x54,  0x13,  0x30,     0,  3 },
        /* 3 : R+ON       */ {  0x30,  0x42,  0x54,  0x54,     3,  0x30,  0x30,  3 },
        /* 4 : R+EN/AN    */ {  0x30,  0x42,     4,     4,  0x13,  0x30,  0x30,  4 }
    };
<span class="fc" id="L1923">    private static final ImpTabPair impTab_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS = new</span>
            ImpTabPair(impTabL_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS,
                       impTabR_INVERSE_LIKE_DIRECT_WITH_MARKS, impAct0, impAct2);

<span class="nc" id="L1927">    private class LevState {</span>
        byte[][] impTab;                /* level table pointer          */
        short[] impAct;                 /* action map array             */
        int startON;                    /* start of ON sequence         */
        int startL2EN;                  /* start of level 2 sequence    */
        int lastStrongRTL;              /* index of last found R or AL  */
        short state;                    /* current state                */
        byte runLevel;                  /* run level before implicit solving */
    }

    /*------------------------------------------------------------------------*/

    static final int FIRSTALLOC = 10;
    /*
     *  param pos:     position where to insert
     *  param flag:    one of LRM_BEFORE, LRM_AFTER, RLM_BEFORE, RLM_AFTER
     */
    private void addPoint(int pos, int flag)
    {
<span class="nc" id="L1946">        Point point = new Point();</span>

<span class="nc" id="L1948">        int len = insertPoints.points.length;</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">        if (len == 0) {</span>
<span class="nc" id="L1950">            insertPoints.points = new Point[FIRSTALLOC];</span>
<span class="nc" id="L1951">            len = FIRSTALLOC;</span>
        }
<span class="nc bnc" id="L1953" title="All 2 branches missed.">        if (insertPoints.size &gt;= len) { /* no room for new point */</span>
<span class="nc" id="L1954">            Point[] savePoints = insertPoints.points;</span>
<span class="nc" id="L1955">            insertPoints.points = new Point[len * 2];</span>
<span class="nc" id="L1956">            System.arraycopy(savePoints, 0, insertPoints.points, 0, len);</span>
        }
<span class="nc" id="L1958">        point.pos = pos;</span>
<span class="nc" id="L1959">        point.flag = flag;</span>
<span class="nc" id="L1960">        insertPoints.points[insertPoints.size] = point;</span>
<span class="nc" id="L1961">        insertPoints.size++;</span>
<span class="nc" id="L1962">    }</span>

    /* perform rules (Wn), (Nn), and (In) on a run of the text ------------------ */

    /*
     * This implementation of the (Wn) rules applies all rules in one pass.
     * In order to do so, it needs a look-ahead of typically 1 character
     * (except for W5: sequences of ET) and keeps track of changes
     * in a rule Wp that affect a later Wq (p&lt;q).
     *
     * The (Nn) and (In) rules are also performed in that same single loop,
     * but effectively one iteration behind for white space.
     *
     * Since all implicit rules are performed in one step, it is not necessary
     * to actually store the intermediate directional properties in dirProps[].
     */

    private void processPropertySeq(LevState levState, short _prop,
            int start, int limit) {
        byte cell;
<span class="nc" id="L1982">        byte[][] impTab = levState.impTab;</span>
<span class="nc" id="L1983">        short[] impAct = levState.impAct;</span>
        short oldStateSeq,actionSeq;
        byte level, addLevel;
        int start0, k;

<span class="nc" id="L1988">        start0 = start;                 /* save original start position */</span>
<span class="nc" id="L1989">        oldStateSeq = levState.state;</span>
<span class="nc" id="L1990">        cell = impTab[oldStateSeq][_prop];</span>
<span class="nc" id="L1991">        levState.state = GetState(cell);        /* isolate the new state */</span>
<span class="nc" id="L1992">        actionSeq = impAct[GetAction(cell)];    /* isolate the action */</span>
<span class="nc" id="L1993">        addLevel = impTab[levState.state][IMPTABLEVELS_RES];</span>

<span class="nc bnc" id="L1995" title="All 2 branches missed.">        if (actionSeq != 0) {</span>
<span class="nc bnc" id="L1996" title="All 13 branches missed.">            switch (actionSeq) {</span>
            case 1:                     /* init ON seq */
<span class="nc" id="L1998">                levState.startON = start0;</span>
<span class="nc" id="L1999">                break;</span>

            case 2:                     /* prepend ON seq to current seq */
<span class="nc" id="L2002">                start = levState.startON;</span>
<span class="nc" id="L2003">                break;</span>

            case 3:                     /* L or S after possible relevant EN/AN */
                /* check if we had EN after R/AL */
<span class="nc bnc" id="L2007" title="All 2 branches missed.">                if (levState.startL2EN &gt;= 0) {</span>
<span class="nc" id="L2008">                    addPoint(levState.startL2EN, LRM_BEFORE);</span>
                }
<span class="nc" id="L2010">                levState.startL2EN = -1;  /* not within previous if since could also be -2 */</span>
                /* check if we had any relevant EN/AN after R/AL */
<span class="nc bnc" id="L2012" title="All 4 branches missed.">                if ((insertPoints.points.length == 0) ||</span>
                        (insertPoints.size &lt;= insertPoints.confirmed)) {
                    /* nothing, just clean up */
<span class="nc" id="L2015">                    levState.lastStrongRTL = -1;</span>
                    /* check if we have a pending conditional segment */
<span class="nc" id="L2017">                    level = impTab[oldStateSeq][IMPTABLEVELS_RES];</span>
<span class="nc bnc" id="L2018" title="All 4 branches missed.">                    if ((level &amp; 1) != 0 &amp;&amp; levState.startON &gt; 0) { /* after ON */</span>
<span class="nc" id="L2019">                        start = levState.startON;   /* reset to basic run level */</span>
                    }
<span class="nc bnc" id="L2021" title="All 2 branches missed.">                    if (_prop == _S) {              /* add LRM before S */</span>
<span class="nc" id="L2022">                        addPoint(start0, LRM_BEFORE);</span>
<span class="nc" id="L2023">                        insertPoints.confirmed = insertPoints.size;</span>
                    }
                    break;
                }
                /* reset previous RTL cont to level for LTR text */
<span class="nc bnc" id="L2028" title="All 2 branches missed.">                for (k = levState.lastStrongRTL + 1; k &lt; start0; k++) {</span>
                    /* reset odd level, leave runLevel+2 as is */
<span class="nc" id="L2030">                    levels[k] = (byte)((levels[k] - 2) &amp; ~1);</span>
                }
                /* mark insert points as confirmed */
<span class="nc" id="L2033">                insertPoints.confirmed = insertPoints.size;</span>
<span class="nc" id="L2034">                levState.lastStrongRTL = -1;</span>
<span class="nc bnc" id="L2035" title="All 2 branches missed.">                if (_prop == _S) {           /* add LRM before S */</span>
<span class="nc" id="L2036">                    addPoint(start0, LRM_BEFORE);</span>
<span class="nc" id="L2037">                    insertPoints.confirmed = insertPoints.size;</span>
                }
                break;

            case 4:                     /* R/AL after possible relevant EN/AN */
                /* just clean up */
<span class="nc bnc" id="L2043" title="All 2 branches missed.">                if (insertPoints.points.length &gt; 0)</span>
                    /* remove all non confirmed insert points */
<span class="nc" id="L2045">                    insertPoints.size = insertPoints.confirmed;</span>
<span class="nc" id="L2046">                levState.startON = -1;</span>
<span class="nc" id="L2047">                levState.startL2EN = -1;</span>
<span class="nc" id="L2048">                levState.lastStrongRTL = limit - 1;</span>
<span class="nc" id="L2049">                break;</span>

            case 5:                     /* EN/AN after R/AL + possible cont */
                /* check for real AN */
<span class="nc bnc" id="L2053" title="All 4 branches missed.">                if ((_prop == _AN) &amp;&amp; (NoContextRTL(dirProps[start0]) == AN)) {</span>
                    /* real AN */
<span class="nc bnc" id="L2055" title="All 2 branches missed.">                    if (levState.startL2EN == -1) { /* if no relevant EN already found */</span>
                        /* just note the righmost digit as a strong RTL */
<span class="nc" id="L2057">                        levState.lastStrongRTL = limit - 1;</span>
<span class="nc" id="L2058">                        break;</span>
                    }
<span class="nc bnc" id="L2060" title="All 2 branches missed.">                    if (levState.startL2EN &gt;= 0)  { /* after EN, no AN */</span>
<span class="nc" id="L2061">                        addPoint(levState.startL2EN, LRM_BEFORE);</span>
<span class="nc" id="L2062">                        levState.startL2EN = -2;</span>
                    }
                    /* note AN */
<span class="nc" id="L2065">                    addPoint(start0, LRM_BEFORE);</span>
<span class="nc" id="L2066">                    break;</span>
                }
                /* if first EN/AN after R/AL */
<span class="nc bnc" id="L2069" title="All 2 branches missed.">                if (levState.startL2EN == -1) {</span>
<span class="nc" id="L2070">                    levState.startL2EN = start0;</span>
                }
                break;

            case 6:                     /* note location of latest R/AL */
<span class="nc" id="L2075">                levState.lastStrongRTL = limit - 1;</span>
<span class="nc" id="L2076">                levState.startON = -1;</span>
<span class="nc" id="L2077">                break;</span>

            case 7:                     /* L after R+ON/EN/AN */
                /* include possible adjacent number on the left */
<span class="nc bnc" id="L2081" title="All 4 branches missed.">                for (k = start0-1; k &gt;= 0 &amp;&amp; ((levels[k] &amp; 1) == 0); k--) {</span>
                }
<span class="nc bnc" id="L2083" title="All 2 branches missed.">                if (k &gt;= 0) {</span>
<span class="nc" id="L2084">                    addPoint(k, RLM_BEFORE);    /* add RLM before */</span>
<span class="nc" id="L2085">                    insertPoints.confirmed = insertPoints.size; /* confirm it */</span>
                }
<span class="nc" id="L2087">                levState.startON = start0;</span>
<span class="nc" id="L2088">                break;</span>

            case 8:                     /* AN after L */
                /* AN numbers between L text on both sides may be trouble. */
                /* tentatively bracket with LRMs; will be confirmed if followed by L */
<span class="nc" id="L2093">                addPoint(start0, LRM_BEFORE);   /* add LRM before */</span>
<span class="nc" id="L2094">                addPoint(start0, LRM_AFTER);    /* add LRM after  */</span>
<span class="nc" id="L2095">                break;</span>

            case 9:                     /* R after L+ON/EN/AN */
                /* false alert, infirm LRMs around previous AN */
<span class="nc" id="L2099">                insertPoints.size=insertPoints.confirmed;</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">                if (_prop == _S) {          /* add RLM before S */</span>
<span class="nc" id="L2101">                    addPoint(start0, RLM_BEFORE);</span>
<span class="nc" id="L2102">                    insertPoints.confirmed = insertPoints.size;</span>
                }
                break;

            case 10:                    /* L after L+ON/AN */
<span class="nc" id="L2107">                level = (byte)(levState.runLevel + addLevel);</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">                for (k=levState.startON; k &lt; start0; k++) {</span>
<span class="nc bnc" id="L2109" title="All 2 branches missed.">                    if (levels[k] &lt; level) {</span>
<span class="nc" id="L2110">                        levels[k] = level;</span>
                    }
                }
<span class="nc" id="L2113">                insertPoints.confirmed = insertPoints.size;   /* confirm inserts */</span>
<span class="nc" id="L2114">                levState.startON = start0;</span>
<span class="nc" id="L2115">                break;</span>

            case 11:                    /* L after L+ON+EN/AN/ON */
<span class="nc" id="L2118">                level = levState.runLevel;</span>
<span class="nc bnc" id="L2119" title="All 2 branches missed.">                for (k = start0-1; k &gt;= levState.startON; k--) {</span>
<span class="nc bnc" id="L2120" title="All 2 branches missed.">                    if (levels[k] == level+3) {</span>
<span class="nc bnc" id="L2121" title="All 2 branches missed.">                        while (levels[k] == level+3) {</span>
<span class="nc" id="L2122">                            levels[k--] -= 2;</span>
                        }
<span class="nc bnc" id="L2124" title="All 2 branches missed.">                        while (levels[k] == level) {</span>
<span class="nc" id="L2125">                            k--;</span>
                        }
                    }
<span class="nc bnc" id="L2128" title="All 2 branches missed.">                    if (levels[k] == level+2) {</span>
<span class="nc" id="L2129">                        levels[k] = level;</span>
<span class="nc" id="L2130">                        continue;</span>
                    }
<span class="nc" id="L2132">                    levels[k] = (byte)(level+1);</span>
                }
                break;

            case 12:                    /* R after L+ON+EN/AN/ON */
<span class="nc" id="L2137">                level = (byte)(levState.runLevel+1);</span>
<span class="nc bnc" id="L2138" title="All 2 branches missed.">                for (k = start0-1; k &gt;= levState.startON; k--) {</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">                    if (levels[k] &gt; level) {</span>
<span class="nc" id="L2140">                        levels[k] -= 2;</span>
                    }
                }
                break;

            default:                        /* we should never get here */
<span class="nc" id="L2146">                throw new IllegalStateException(&quot;Internal ICU error in processPropertySeq&quot;);</span>
            }
        }
<span class="nc bnc" id="L2149" title="All 4 branches missed.">        if ((addLevel) != 0 || (start &lt; start0)) {</span>
<span class="nc" id="L2150">            level = (byte)(levState.runLevel + addLevel);</span>
<span class="nc bnc" id="L2151" title="All 2 branches missed.">            for (k = start; k &lt; limit; k++) {</span>
<span class="nc" id="L2152">                levels[k] = level;</span>
            }
        }
<span class="nc" id="L2155">    }</span>

    private void resolveImplicitLevels(int start, int limit, short sor, short eor)
    {
<span class="nc" id="L2159">        LevState levState = new LevState();</span>
        int i, start1, start2;
        short oldStateImp, stateImp, actionImp;
        short gprop, resProp, cell;
<span class="nc" id="L2163">        short nextStrongProp = R;</span>
<span class="nc" id="L2164">        int nextStrongPos = -1;</span>


        /* check for RTL inverse Bidi mode */
        /* FOOD FOR THOUGHT: in case of RTL inverse Bidi, it would make sense to
         * loop on the text characters from end to start.
         * This would need a different properties state table (at least different
         * actions) and different levels state tables (maybe very similar to the
         * LTR corresponding ones.
         */
        /* initialize for levels state table */
<span class="nc" id="L2175">        levState.startL2EN = -1;        /* used for INVERSE_LIKE_DIRECT_WITH_MARKS */</span>
<span class="nc" id="L2176">        levState.lastStrongRTL = -1;    /* used for INVERSE_LIKE_DIRECT_WITH_MARKS */</span>
<span class="nc" id="L2177">        levState.state = 0;</span>
<span class="nc" id="L2178">        levState.runLevel = levels[start];</span>
<span class="nc" id="L2179">        levState.impTab = impTabPair.imptab[levState.runLevel &amp; 1];</span>
<span class="nc" id="L2180">        levState.impAct = impTabPair.impact[levState.runLevel &amp; 1];</span>
<span class="nc" id="L2181">        processPropertySeq(levState, sor, start, start);</span>
        /* initialize for property state table */
<span class="nc bnc" id="L2183" title="All 2 branches missed.">        if (dirProps[start] == NSM) {</span>
<span class="nc" id="L2184">            stateImp = (short)(1 + sor);</span>
        } else {
<span class="nc" id="L2186">            stateImp = 0;</span>
        }
<span class="nc" id="L2188">        start1 = start;</span>
<span class="nc" id="L2189">        start2 = 0;</span>

<span class="nc bnc" id="L2191" title="All 2 branches missed.">        for (i = start; i &lt;= limit; i++) {</span>
<span class="nc bnc" id="L2192" title="All 2 branches missed.">            if (i &gt;= limit) {</span>
<span class="nc" id="L2193">                gprop = eor;</span>
            } else {
                short prop, prop1;
<span class="nc" id="L2196">                prop = NoContextRTL(dirProps[i]);</span>
<span class="nc" id="L2197">                gprop = groupProp[prop];</span>
            }
<span class="nc" id="L2199">            oldStateImp = stateImp;</span>
<span class="nc" id="L2200">            cell = impTabProps[oldStateImp][gprop];</span>
<span class="nc" id="L2201">            stateImp = GetStateProps(cell);     /* isolate the new state */</span>
<span class="nc" id="L2202">            actionImp = GetActionProps(cell);   /* isolate the action */</span>
<span class="nc bnc" id="L2203" title="All 4 branches missed.">            if ((i == limit) &amp;&amp; (actionImp == 0)) {</span>
                /* there is an unprocessed sequence if its property == eor   */
<span class="nc" id="L2205">                actionImp = 1;                  /* process the last sequence */</span>
            }
<span class="nc bnc" id="L2207" title="All 2 branches missed.">            if (actionImp != 0) {</span>
<span class="nc" id="L2208">                resProp = impTabProps[oldStateImp][IMPTABPROPS_RES];</span>
<span class="nc bnc" id="L2209" title="All 5 branches missed.">                switch (actionImp) {</span>
                case 1:             /* process current seq1, init new seq1 */
<span class="nc" id="L2211">                    processPropertySeq(levState, resProp, start1, i);</span>
<span class="nc" id="L2212">                    start1 = i;</span>
<span class="nc" id="L2213">                    break;</span>
                case 2:             /* init new seq2 */
<span class="nc" id="L2215">                    start2 = i;</span>
<span class="nc" id="L2216">                    break;</span>
                case 3:             /* process seq1, process seq2, init new seq1 */
<span class="nc" id="L2218">                    processPropertySeq(levState, resProp, start1, start2);</span>
<span class="nc" id="L2219">                    processPropertySeq(levState, _ON, start2, i);</span>
<span class="nc" id="L2220">                    start1 = i;</span>
<span class="nc" id="L2221">                    break;</span>
                case 4:             /* process seq1, set seq1=seq2, init new seq2 */
<span class="nc" id="L2223">                    processPropertySeq(levState, resProp, start1, start2);</span>
<span class="nc" id="L2224">                    start1 = start2;</span>
<span class="nc" id="L2225">                    start2 = i;</span>
<span class="nc" id="L2226">                    break;</span>
                default:            /* we should never get here */
<span class="nc" id="L2228">                    throw new IllegalStateException(&quot;Internal ICU error in resolveImplicitLevels&quot;);</span>
                }
            }
        }
        /* flush possible pending sequence, e.g. ON */
<span class="nc" id="L2233">        processPropertySeq(levState, eor, limit, limit);</span>
<span class="nc" id="L2234">    }</span>

    /* perform (L1) and (X9) ---------------------------------------------------- */

    /*
     * Reset the embedding levels for some non-graphic characters (L1).
     * This method also sets appropriate levels for BN, and
     * explicit embedding types that are supposed to have been removed
     * from the paragraph in (X9).
     */
    private void adjustWSLevels() {
        int i;

<span class="nc bnc" id="L2247" title="All 2 branches missed.">        if ((flags &amp; MASK_WS) != 0) {</span>
            int flag;
<span class="nc" id="L2249">            i = trailingWSStart;</span>
<span class="nc bnc" id="L2250" title="All 2 branches missed.">            while (i &gt; 0) {</span>
                /* reset a sequence of WS/BN before eop and B/S to the paragraph paraLevel */
<span class="nc bnc" id="L2252" title="All 4 branches missed.">                while (i &gt; 0 &amp;&amp; ((flag = DirPropFlagNC(dirProps[--i])) &amp; MASK_WS) != 0) {</span>
<span class="nc bnc" id="L2253" title="All 4 branches missed.">                    if (orderParagraphsLTR &amp;&amp; (flag &amp; DirPropFlag(B)) != 0) {</span>
<span class="nc" id="L2254">                        levels[i] = 0;</span>
                    } else {
<span class="nc" id="L2256">                        levels[i] = GetParaLevelAt(i);</span>
                    }
                }

                /* reset BN to the next character's paraLevel until B/S, which restarts above loop */
                /* here, i+1 is guaranteed to be &lt;length */
<span class="nc bnc" id="L2262" title="All 2 branches missed.">                while (i &gt; 0) {</span>
<span class="nc" id="L2263">                    flag = DirPropFlagNC(dirProps[--i]);</span>
<span class="nc bnc" id="L2264" title="All 2 branches missed.">                    if ((flag &amp; MASK_BN_EXPLICIT) != 0) {</span>
<span class="nc" id="L2265">                        levels[i] = levels[i + 1];</span>
<span class="nc bnc" id="L2266" title="All 4 branches missed.">                    } else if (orderParagraphsLTR &amp;&amp; (flag &amp; DirPropFlag(B)) != 0) {</span>
<span class="nc" id="L2267">                        levels[i] = 0;</span>
<span class="nc" id="L2268">                        break;</span>
<span class="nc bnc" id="L2269" title="All 2 branches missed.">                    } else if ((flag &amp; MASK_B_S) != 0){</span>
<span class="nc" id="L2270">                        levels[i] = GetParaLevelAt(i);</span>
<span class="nc" id="L2271">                        break;</span>
                    }
                }
            }
        }
<span class="nc" id="L2276">    }</span>

    private int Bidi_Min(int x, int y) {
<span class="nc bnc" id="L2279" title="All 2 branches missed.">        return x &lt; y ? x : y;</span>
    }

    private int Bidi_Abs(int x) {
<span class="nc bnc" id="L2283" title="All 2 branches missed.">        return x &gt;= 0 ? x : -x;</span>
    }

    /**
     * Perform the Unicode Bidi algorithm. It is defined in the
     * &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;,
     * version 13,
     * also described in The Unicode Standard, Version 4.0 .&lt;p&gt;
     *
     * This method takes a piece of plain text containing one or more paragraphs,
     * with or without externally specified embedding levels from &lt;i&gt;styled&lt;/i&gt;
     * text and computes the left-right-directionality of each character.&lt;p&gt;
     *
     * If the entire text is all of the same directionality, then
     * the method may not perform all the steps described by the algorithm,
     * i.e., some levels may not be the same as if all steps were performed.
     * This is not relevant for unidirectional text.&lt;br&gt;
     * For example, in pure LTR text with numbers the numbers would get
     * a resolved level of 2 higher than the surrounding text according to
     * the algorithm. This implementation may set all resolved levels to
     * the same value in such a case.&lt;p&gt;
     *
     * The text can be composed of multiple paragraphs. Occurrence of a block
     * separator in the text terminates a paragraph, and whatever comes next starts
     * a new paragraph. The exception to this rule is when a Carriage Return (CR)
     * is followed by a Line Feed (LF). Both CR and LF are block separators, but
     * in that case, the pair of characters is considered as terminating the
     * preceding paragraph, and a new paragraph will be started by a character
     * coming after the LF.
     *
     * Although the text is passed here as a &lt;code&gt;String&lt;/code&gt;, it is
     * stored internally as an array of characters. Therefore the
     * documentation will refer to indexes of the characters in the text.
     *
     * @param text contains the text that the Bidi algorithm will be performed
     *        on. This text can be retrieved with &lt;code&gt;getText()&lt;/code&gt; or
     *        &lt;code&gt;getTextAsString&lt;/code&gt;.&lt;br&gt;
     *
     * @param paraLevel specifies the default level for the text;
     *        it is typically 0 (LTR) or 1 (RTL).
     *        If the method shall determine the paragraph level from the text,
     *        then &lt;code&gt;paraLevel&lt;/code&gt; can be set to
     *        either &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt;
     *        or &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt;; if the text contains multiple
     *        paragraphs, the paragraph level shall be determined separately for
     *        each paragraph; if a paragraph does not include any strongly typed
     *        character, then the desired default is used (0 for LTR or 1 for RTL).
     *        Any other value between 0 and &lt;code&gt;MAX_EXPLICIT_LEVEL&lt;/code&gt;
     *        is also valid, with odd levels indicating RTL.
     *
     * @param embeddingLevels (in) may be used to preset the embedding and override levels,
     *        ignoring characters like LRE and PDF in the text.
     *        A level overrides the directional property of its corresponding
     *        (same index) character if the level has the
     *        &lt;code&gt;LEVEL_OVERRIDE&lt;/code&gt; bit set.&lt;br&gt;&lt;br&gt;
     *        Except for that bit, it must be
     *        &lt;code&gt;paraLevel&lt;=embeddingLevels[]&lt;=MAX_EXPLICIT_LEVEL&lt;/code&gt;,
     *        with one exception: a level of zero may be specified for a
     *        paragraph separator even if &lt;code&gt;paraLevel&amp;gt;0&lt;/code&gt; when multiple
     *        paragraphs are submitted in the same call to &lt;code&gt;setPara()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;
     *        &lt;strong&gt;Caution: &lt;/strong&gt;A reference to this array, not a copy
     *        of the levels, will be stored in the &lt;code&gt;Bidi&lt;/code&gt; object;
     *        the &lt;code&gt;embeddingLevels&lt;/code&gt;
     *        should not be modified to avoid unexpected results on subsequent
     *        Bidi operations. However, the &lt;code&gt;setPara()&lt;/code&gt; and
     *        &lt;code&gt;setLine()&lt;/code&gt; methods may modify some or all of the
     *        levels.&lt;br&gt;&lt;br&gt;
     *        &lt;strong&gt;Note:&lt;/strong&gt; the &lt;code&gt;embeddingLevels&lt;/code&gt; array must
     *        have one entry for each character in &lt;code&gt;text&lt;/code&gt;.
     *
     * @throws IllegalArgumentException if the values in embeddingLevels are
     *         not within the allowed range
     *
     * @see #LEVEL_DEFAULT_LTR
     * @see #LEVEL_DEFAULT_RTL
     * @see #LEVEL_OVERRIDE
     * @see #MAX_EXPLICIT_LEVEL
     * @stable ICU 3.8
     */
    void setPara(String text, byte paraLevel, byte[] embeddingLevels)
    {
<span class="nc bnc" id="L2364" title="All 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L2365">            setPara(new char[0], paraLevel, embeddingLevels);</span>
        } else {
<span class="nc" id="L2367">            setPara(text.toCharArray(), paraLevel, embeddingLevels);</span>
        }
<span class="nc" id="L2369">    }</span>

    /**
     * Perform the Unicode Bidi algorithm. It is defined in the
     * &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;,
     * version 13,
     * also described in The Unicode Standard, Version 4.0 .&lt;p&gt;
     *
     * This method takes a piece of plain text containing one or more paragraphs,
     * with or without externally specified embedding levels from &lt;i&gt;styled&lt;/i&gt;
     * text and computes the left-right-directionality of each character.&lt;p&gt;
     *
     * If the entire text is all of the same directionality, then
     * the method may not perform all the steps described by the algorithm,
     * i.e., some levels may not be the same as if all steps were performed.
     * This is not relevant for unidirectional text.&lt;br&gt;
     * For example, in pure LTR text with numbers the numbers would get
     * a resolved level of 2 higher than the surrounding text according to
     * the algorithm. This implementation may set all resolved levels to
     * the same value in such a case.&lt;p&gt;
     *
     * The text can be composed of multiple paragraphs. Occurrence of a block
     * separator in the text terminates a paragraph, and whatever comes next starts
     * a new paragraph. The exception to this rule is when a Carriage Return (CR)
     * is followed by a Line Feed (LF). Both CR and LF are block separators, but
     * in that case, the pair of characters is considered as terminating the
     * preceding paragraph, and a new paragraph will be started by a character
     * coming after the LF.
     *
     * The text is stored internally as an array of characters. Therefore the
     * documentation will refer to indexes of the characters in the text.
     *
     * @param chars contains the text that the Bidi algorithm will be performed
     *        on. This text can be retrieved with &lt;code&gt;getText()&lt;/code&gt; or
     *        &lt;code&gt;getTextAsString&lt;/code&gt;.&lt;br&gt;
     *
     * @param paraLevel specifies the default level for the text;
     *        it is typically 0 (LTR) or 1 (RTL).
     *        If the method shall determine the paragraph level from the text,
     *        then &lt;code&gt;paraLevel&lt;/code&gt; can be set to
     *        either &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt;
     *        or &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt;; if the text contains multiple
     *        paragraphs, the paragraph level shall be determined separately for
     *        each paragraph; if a paragraph does not include any strongly typed
     *        character, then the desired default is used (0 for LTR or 1 for RTL).
     *        Any other value between 0 and &lt;code&gt;MAX_EXPLICIT_LEVEL&lt;/code&gt;
     *        is also valid, with odd levels indicating RTL.
     *
     * @param embeddingLevels (in) may be used to preset the embedding and
     *        override levels, ignoring characters like LRE and PDF in the text.
     *        A level overrides the directional property of its corresponding
     *        (same index) character if the level has the
     *        &lt;code&gt;LEVEL_OVERRIDE&lt;/code&gt; bit set.&lt;br&gt;&lt;br&gt;
     *        Except for that bit, it must be
     *        &lt;code&gt;paraLevel&lt;=embeddingLevels[]&lt;=MAX_EXPLICIT_LEVEL&lt;/code&gt;,
     *        with one exception: a level of zero may be specified for a
     *        paragraph separator even if &lt;code&gt;paraLevel&amp;gt;0&lt;/code&gt; when multiple
     *        paragraphs are submitted in the same call to &lt;code&gt;setPara()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;
     *        &lt;strong&gt;Caution: &lt;/strong&gt;A reference to this array, not a copy
     *        of the levels, will be stored in the &lt;code&gt;Bidi&lt;/code&gt; object;
     *        the &lt;code&gt;embeddingLevels&lt;/code&gt;
     *        should not be modified to avoid unexpected results on subsequent
     *        Bidi operations. However, the &lt;code&gt;setPara()&lt;/code&gt; and
     *        &lt;code&gt;setLine()&lt;/code&gt; methods may modify some or all of the
     *        levels.&lt;br&gt;&lt;br&gt;
     *        &lt;strong&gt;Note:&lt;/strong&gt; the &lt;code&gt;embeddingLevels&lt;/code&gt; array must
     *        have one entry for each character in &lt;code&gt;text&lt;/code&gt;.
     *
     * @throws IllegalArgumentException if the values in embeddingLevels are
     *         not within the allowed range
     *
     * @see #LEVEL_DEFAULT_LTR
     * @see #LEVEL_DEFAULT_RTL
     * @see #LEVEL_OVERRIDE
     * @see #MAX_EXPLICIT_LEVEL
     * @stable ICU 3.8
     */
    public void setPara(char[] chars, byte paraLevel, byte[] embeddingLevels)
    {
        /* check the argument values */
<span class="nc bnc" id="L2449" title="All 2 branches missed.">        if (paraLevel &lt; INTERNAL_LEVEL_DEFAULT_LTR) {</span>
<span class="nc" id="L2450">            verifyRange(paraLevel, 0, MAX_EXPLICIT_LEVEL + 1);</span>
        }
<span class="nc bnc" id="L2452" title="All 2 branches missed.">        if (chars == null) {</span>
<span class="nc" id="L2453">            chars = new char[0];</span>
        }

        /* initialize the Bidi object */
<span class="nc" id="L2457">        this.paraBidi = null;          /* mark unfinished setPara */</span>
<span class="nc" id="L2458">        this.text = chars;</span>
<span class="nc" id="L2459">        this.length = this.originalLength = this.resultLength = text.length;</span>
<span class="nc" id="L2460">        this.paraLevel = paraLevel;</span>
<span class="nc" id="L2461">        this.direction = Bidi.DIRECTION_LEFT_TO_RIGHT;</span>
<span class="nc" id="L2462">        this.paraCount = 1;</span>

        /* Allocate zero-length arrays instead of setting to null here; then
         * checks for null in various places can be eliminated.
         */
<span class="nc" id="L2467">        dirProps = new byte[0];</span>
<span class="nc" id="L2468">        levels = new byte[0];</span>
<span class="nc" id="L2469">        runs = new BidiRun[0];</span>
<span class="nc" id="L2470">        isGoodLogicalToVisualRunsMap = false;</span>
<span class="nc" id="L2471">        insertPoints.size = 0;          /* clean up from last call */</span>
<span class="nc" id="L2472">        insertPoints.confirmed = 0;     /* clean up from last call */</span>

        /*
         * Save the original paraLevel if contextual; otherwise, set to 0.
         */
<span class="nc bnc" id="L2477" title="All 2 branches missed.">        if (IsDefaultLevel(paraLevel)) {</span>
<span class="nc" id="L2478">            defaultParaLevel = paraLevel;</span>
        } else {
<span class="nc" id="L2480">            defaultParaLevel = 0;</span>
        }

<span class="nc bnc" id="L2483" title="All 2 branches missed.">        if (length == 0) {</span>
            /*
             * For an empty paragraph, create a Bidi object with the paraLevel and
             * the flags and the direction set but without allocating zero-length arrays.
             * There is nothing more to do.
             */
<span class="nc bnc" id="L2489" title="All 2 branches missed.">            if (IsDefaultLevel(paraLevel)) {</span>
<span class="nc" id="L2490">                this.paraLevel &amp;= 1;</span>
<span class="nc" id="L2491">                defaultParaLevel = 0;</span>
            }
<span class="nc bnc" id="L2493" title="All 2 branches missed.">            if ((this.paraLevel &amp; 1) != 0) {</span>
<span class="nc" id="L2494">                flags = DirPropFlag(R);</span>
<span class="nc" id="L2495">                direction = Bidi.DIRECTION_RIGHT_TO_LEFT;</span>
            } else {
<span class="nc" id="L2497">                flags = DirPropFlag(L);</span>
<span class="nc" id="L2498">                direction = Bidi.DIRECTION_LEFT_TO_RIGHT;</span>
            }

<span class="nc" id="L2501">            runCount = 0;</span>
<span class="nc" id="L2502">            paraCount = 0;</span>
<span class="nc" id="L2503">            paraBidi = this;         /* mark successful setPara */</span>
<span class="nc" id="L2504">            return;</span>
        }

<span class="nc" id="L2507">        runCount = -1;</span>

        /*
         * Get the directional properties,
         * the flags bit-set, and
         * determine the paragraph level if necessary.
         */
<span class="nc" id="L2514">        getDirPropsMemory(length);</span>
<span class="nc" id="L2515">        dirProps = dirPropsMemory;</span>
<span class="nc" id="L2516">        getDirProps();</span>

        /* the processed length may have changed if OPTION_STREAMING is set */
<span class="nc" id="L2519">        trailingWSStart = length;  /* the levels[] will reflect the WS run */</span>

        /* allocate paras memory */
<span class="nc bnc" id="L2522" title="All 2 branches missed.">        if (paraCount &gt; 1) {</span>
<span class="nc" id="L2523">            getInitialParasMemory(paraCount);</span>
<span class="nc" id="L2524">            paras = parasMemory;</span>
<span class="nc" id="L2525">            paras[paraCount - 1] = length;</span>
        } else {
            /* initialize paras for single paragraph */
<span class="nc" id="L2528">            paras = simpleParas;</span>
<span class="nc" id="L2529">            simpleParas[0] = length;</span>
        }

        /* are explicit levels specified? */
<span class="nc bnc" id="L2533" title="All 2 branches missed.">        if (embeddingLevels == null) {</span>
            /* no: determine explicit levels according to the (Xn) rules */
<span class="nc" id="L2535">            getLevelsMemory(length);</span>
<span class="nc" id="L2536">            levels = levelsMemory;</span>
<span class="nc" id="L2537">            direction = resolveExplicitLevels();</span>
        } else {
            /* set BN for all explicit codes, check that all levels are 0 or paraLevel..MAX_EXPLICIT_LEVEL */
<span class="nc" id="L2540">            levels = embeddingLevels;</span>
<span class="nc" id="L2541">            direction = checkExplicitLevels();</span>
        }

        /*
         * The steps after (X9) in the Bidi algorithm are performed only if
         * the paragraph text has mixed directionality!
         */
<span class="nc bnc" id="L2548" title="All 3 branches missed.">        switch (direction) {</span>
        case Bidi.DIRECTION_LEFT_TO_RIGHT:
            /* make sure paraLevel is even */
<span class="nc" id="L2551">            paraLevel = (byte)((paraLevel + 1) &amp; ~1);</span>

            /* all levels are implicitly at paraLevel (important for getLevels()) */
<span class="nc" id="L2554">            trailingWSStart = 0;</span>
<span class="nc" id="L2555">            break;</span>
        case Bidi.DIRECTION_RIGHT_TO_LEFT:
            /* make sure paraLevel is odd */
<span class="nc" id="L2558">            paraLevel |= 1;</span>

            /* all levels are implicitly at paraLevel (important for getLevels()) */
<span class="nc" id="L2561">            trailingWSStart = 0;</span>
<span class="nc" id="L2562">            break;</span>
        default:
<span class="nc" id="L2564">            this.impTabPair = impTab_DEFAULT;</span>

            /*
             * If there are no external levels specified and there
             * are no significant explicit level codes in the text,
             * then we can treat the entire paragraph as one run.
             * Otherwise, we need to perform the following rules on runs of
             * the text with the same embedding levels. (X10)
             * &quot;Significant&quot; explicit level codes are ones that actually
             * affect non-BN characters.
             * Examples for &quot;insignificant&quot; ones are empty embeddings
             * LRE-PDF, LRE-RLE-PDF-PDF, etc.
             */
<span class="nc bnc" id="L2577" title="All 6 branches missed.">            if (embeddingLevels == null &amp;&amp; paraCount &lt;= 1 &amp;&amp;</span>
                (flags &amp; DirPropFlagMultiRuns) == 0) {
<span class="nc" id="L2579">                resolveImplicitLevels(0, length,</span>
<span class="nc" id="L2580">                        GetLRFromLevel(GetParaLevelAt(0)),</span>
<span class="nc" id="L2581">                        GetLRFromLevel(GetParaLevelAt(length - 1)));</span>
            } else {
                /* sor, eor: start and end types of same-level-run */
<span class="nc" id="L2584">                int start, limit = 0;</span>
                byte level, nextLevel;
                short sor, eor;

                /* determine the first sor and set eor to it because of the loop body (sor=eor there) */
<span class="nc" id="L2589">                level = GetParaLevelAt(0);</span>
<span class="nc" id="L2590">                nextLevel = levels[0];</span>
<span class="nc bnc" id="L2591" title="All 2 branches missed.">                if (level &lt; nextLevel) {</span>
<span class="nc" id="L2592">                    eor = GetLRFromLevel(nextLevel);</span>
                } else {
<span class="nc" id="L2594">                    eor = GetLRFromLevel(level);</span>
                }

                do {
                    /* determine start and limit of the run (end points just behind the run) */

                    /* the values for this run's start are the same as for the previous run's end */
<span class="nc" id="L2601">                    start = limit;</span>
<span class="nc" id="L2602">                    level = nextLevel;</span>
<span class="nc bnc" id="L2603" title="All 4 branches missed.">                    if ((start &gt; 0) &amp;&amp; (NoContextRTL(dirProps[start - 1]) == B)) {</span>
                        /* except if this is a new paragraph, then set sor = para level */
<span class="nc" id="L2605">                        sor = GetLRFromLevel(GetParaLevelAt(start));</span>
                    } else {
<span class="nc" id="L2607">                        sor = eor;</span>
                    }

                    /* search for the limit of this run */
<span class="nc bnc" id="L2611" title="All 4 branches missed.">                    while (++limit &lt; length &amp;&amp; levels[limit] == level) {}</span>

                    /* get the correct level of the next run */
<span class="nc bnc" id="L2614" title="All 2 branches missed.">                    if (limit &lt; length) {</span>
<span class="nc" id="L2615">                        nextLevel = levels[limit];</span>
                    } else {
<span class="nc" id="L2617">                        nextLevel = GetParaLevelAt(length - 1);</span>
                    }

                    /* determine eor from max(level, nextLevel); sor is last run's eor */
<span class="nc bnc" id="L2621" title="All 2 branches missed.">                    if ((level &amp; ~INTERNAL_LEVEL_OVERRIDE) &lt; (nextLevel &amp; ~INTERNAL_LEVEL_OVERRIDE)) {</span>
<span class="nc" id="L2622">                        eor = GetLRFromLevel(nextLevel);</span>
                    } else {
<span class="nc" id="L2624">                        eor = GetLRFromLevel(level);</span>
                    }

                    /* if the run consists of overridden directional types, then there
                       are no implicit types to be resolved */
<span class="nc bnc" id="L2629" title="All 2 branches missed.">                    if ((level &amp; INTERNAL_LEVEL_OVERRIDE) == 0) {</span>
<span class="nc" id="L2630">                        resolveImplicitLevels(start, limit, sor, eor);</span>
                    } else {
                        /* remove the LEVEL_OVERRIDE flags */
                        do {
<span class="nc" id="L2634">                            levels[start++] &amp;= ~INTERNAL_LEVEL_OVERRIDE;</span>
<span class="nc bnc" id="L2635" title="All 2 branches missed.">                        } while (start &lt; limit);</span>
                    }
<span class="nc bnc" id="L2637" title="All 2 branches missed.">                } while (limit  &lt; length);</span>
            }

            /* reset the embedding levels for some non-graphic characters (L1), (X9) */
<span class="nc" id="L2641">            adjustWSLevels();</span>

            break;
        }

<span class="nc" id="L2646">        resultLength += insertPoints.size;</span>
<span class="nc" id="L2647">        paraBidi = this;             /* mark successful setPara */</span>
<span class="nc" id="L2648">    }</span>

    /**
     * Perform the Unicode Bidi algorithm on a given paragraph, as defined in the
     * &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;,
     * version 13,
     * also described in The Unicode Standard, Version 4.0 .&lt;p&gt;
     *
     * This method takes a paragraph of text and computes the
     * left-right-directionality of each character. The text should not
     * contain any Unicode block separators.&lt;p&gt;
     *
     * The RUN_DIRECTION attribute in the text, if present, determines the base
     * direction (left-to-right or right-to-left). If not present, the base
     * direction is computed using the Unicode Bidirectional Algorithm,
     * defaulting to left-to-right if there are no strong directional characters
     * in the text. This attribute, if present, must be applied to all the text
     * in the paragraph.&lt;p&gt;
     *
     * The BIDI_EMBEDDING attribute in the text, if present, represents
     * embedding level information. Negative values from -1 to -62 indicate
     * overrides at the absolute value of the level. Positive values from 1 to
     * 62 indicate embeddings. Where values are zero or not defined, the base
     * embedding level as determined by the base direction is assumed.&lt;p&gt;
     *
     * The NUMERIC_SHAPING attribute in the text, if present, converts European
     * digits to other decimal digits before running the bidi algorithm. This
     * attribute, if present, must be applied to all the text in the paragraph.
     *
     * If the entire text is all of the same directionality, then
     * the method may not perform all the steps described by the algorithm,
     * i.e., some levels may not be the same as if all steps were performed.
     * This is not relevant for unidirectional text.&lt;br&gt;
     * For example, in pure LTR text with numbers the numbers would get
     * a resolved level of 2 higher than the surrounding text according to
     * the algorithm. This implementation may set all resolved levels to
     * the same value in such a case.&lt;p&gt;
     *
     * @param paragraph a paragraph of text with optional character and
     *        paragraph attribute information
     * @stable ICU 3.8
     */
    public void setPara(AttributedCharacterIterator paragraph)
    {
        byte paraLvl;
<span class="nc" id="L2693">        char ch = paragraph.first();</span>
<span class="nc" id="L2694">        Boolean runDirection =</span>
<span class="nc" id="L2695">            (Boolean) paragraph.getAttribute(TextAttributeConstants.RUN_DIRECTION);</span>
<span class="nc" id="L2696">        Object shaper = paragraph.getAttribute(TextAttributeConstants.NUMERIC_SHAPING);</span>
<span class="nc bnc" id="L2697" title="All 2 branches missed.">        if (runDirection == null) {</span>
<span class="nc" id="L2698">            paraLvl = INTERNAL_LEVEL_DEFAULT_LTR;</span>
        } else {
<span class="nc bnc" id="L2700" title="All 2 branches missed.">            paraLvl = (runDirection.equals(TextAttributeConstants.RUN_DIRECTION_LTR)) ?</span>
                        (byte)Bidi.DIRECTION_LEFT_TO_RIGHT : (byte)Bidi.DIRECTION_RIGHT_TO_LEFT;
        }

<span class="nc" id="L2704">        byte[] lvls = null;</span>
<span class="nc" id="L2705">        int len = paragraph.getEndIndex() - paragraph.getBeginIndex();</span>
<span class="nc" id="L2706">        byte[] embeddingLevels = new byte[len];</span>
<span class="nc" id="L2707">        char[] txt = new char[len];</span>
<span class="nc" id="L2708">        int i = 0;</span>
<span class="nc bnc" id="L2709" title="All 2 branches missed.">        while (ch != AttributedCharacterIterator.DONE) {</span>
<span class="nc" id="L2710">            txt[i] = ch;</span>
<span class="nc" id="L2711">            Integer embedding =</span>
<span class="nc" id="L2712">                (Integer) paragraph.getAttribute(TextAttributeConstants.BIDI_EMBEDDING);</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">            if (embedding != null) {</span>
<span class="nc" id="L2714">                byte level = embedding.byteValue();</span>
<span class="nc bnc" id="L2715" title="All 2 branches missed.">                if (level == 0) {</span>
                    /* no-op */
<span class="nc bnc" id="L2717" title="All 2 branches missed.">                } else if (level &lt; 0) {</span>
<span class="nc" id="L2718">                    lvls = embeddingLevels;</span>
<span class="nc" id="L2719">                    embeddingLevels[i] = (byte)((0 - level) | INTERNAL_LEVEL_OVERRIDE);</span>
                } else {
<span class="nc" id="L2721">                    lvls = embeddingLevels;</span>
<span class="nc" id="L2722">                    embeddingLevels[i] = level;</span>
                }
            }
<span class="nc" id="L2725">            ch = paragraph.next();</span>
<span class="nc" id="L2726">            ++i;</span>
<span class="nc" id="L2727">        }</span>

<span class="nc bnc" id="L2729" title="All 2 branches missed.">        if (shaper != null) {</span>
<span class="nc" id="L2730">            NumericShapings.shape(shaper, txt, 0, len);</span>
        }
<span class="nc" id="L2732">        setPara(txt, paraLvl, lvls);</span>
<span class="nc" id="L2733">    }</span>

    /**
     * Specify whether block separators must be allocated level zero,
     * so that successive paragraphs will progress from left to right.
     * This method must be called before &lt;code&gt;setPara()&lt;/code&gt;.
     * Paragraph separators (B) may appear in the text.  Setting them to level zero
     * means that all paragraph separators (including one possibly appearing
     * in the last text position) are kept in the reordered text after the text
     * that they follow in the source text.
     * When this feature is not enabled, a paragraph separator at the last
     * position of the text before reordering will go to the first position
     * of the reordered text when the paragraph level is odd.
     *
     * @param ordarParaLTR specifies whether paragraph separators (B) must
     * receive level 0, so that successive paragraphs progress from left to right.
     *
     * @see #setPara
     * @stable ICU 3.8
     */
    private void orderParagraphsLTR(boolean ordarParaLTR) {
<span class="nc" id="L2754">        orderParagraphsLTR = ordarParaLTR;</span>
<span class="nc" id="L2755">    }</span>

    /**
     * Get the directionality of the text.
     *
     * @return a value of &lt;code&gt;LTR&lt;/code&gt;, &lt;code&gt;RTL&lt;/code&gt; or &lt;code&gt;MIXED&lt;/code&gt;
     *         that indicates if the entire text
     *         represented by this object is unidirectional,
     *         and which direction, or if it is mixed-directional.
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     *
     * @see #LTR
     * @see #RTL
     * @see #MIXED
     * @stable ICU 3.8
     */
    private byte getDirection()
    {
<span class="nc" id="L2775">        verifyValidParaOrLine();</span>
<span class="nc" id="L2776">        return direction;</span>
    }

    /**
     * Get the length of the text.
     *
     * @return The length of the text that the &lt;code&gt;Bidi&lt;/code&gt; object was
     *         created for.
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     * @stable ICU 3.8
     */
    public int getLength()
    {
<span class="nc" id="L2791">        verifyValidParaOrLine();</span>
<span class="nc" id="L2792">        return originalLength;</span>
    }

    /* paragraphs API methods ------------------------------------------------- */

    /**
     * Get the paragraph level of the text.
     *
     * @return The paragraph level. If there are multiple paragraphs, their
     *         level may vary if the required paraLevel is LEVEL_DEFAULT_LTR or
     *         LEVEL_DEFAULT_RTL.  In that case, the level of the first paragraph
     *         is returned.
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     *
     * @see #LEVEL_DEFAULT_LTR
     * @see #LEVEL_DEFAULT_RTL
     * @see #getParagraph
     * @see #getParagraphByIndex
     * @stable ICU 3.8
     */
    public byte getParaLevel()
    {
<span class="nc" id="L2816">        verifyValidParaOrLine();</span>
<span class="nc" id="L2817">        return paraLevel;</span>
    }

    /**
     * Get the index of a paragraph, given a position within the text.&lt;p&gt;
     *
     * @param charIndex is the index of a character within the text, in the
     *        range &lt;code&gt;[0..getProcessedLength()-1]&lt;/code&gt;.
     *
     * @return The index of the paragraph containing the specified position,
     *         starting from 0.
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     * @throws IllegalArgumentException if charIndex is not within the legal range
     *
     * @see com.ibm.icu.text.BidiRun
     * @see #getProcessedLength
     * @stable ICU 3.8
     */
    public int getParagraphIndex(int charIndex)
    {
<span class="nc" id="L2839">        verifyValidParaOrLine();</span>
<span class="nc" id="L2840">        BidiBase bidi = paraBidi;             /* get Para object if Line object */</span>
<span class="nc" id="L2841">        verifyRange(charIndex, 0, bidi.length);</span>
        int paraIndex;
<span class="nc bnc" id="L2843" title="All 2 branches missed.">        for (paraIndex = 0; charIndex &gt;= bidi.paras[paraIndex]; paraIndex++) {</span>
        }
<span class="nc" id="L2845">        return paraIndex;</span>
    }

    /**
     * &lt;code&gt;setLine()&lt;/code&gt; returns a &lt;code&gt;Bidi&lt;/code&gt; object to
     * contain the reordering information, especially the resolved levels,
     * for all the characters in a line of text. This line of text is
     * specified by referring to a &lt;code&gt;Bidi&lt;/code&gt; object representing
     * this information for a piece of text containing one or more paragraphs,
     * and by specifying a range of indexes in this text.&lt;p&gt;
     * In the new line object, the indexes will range from 0 to &lt;code&gt;limit-start-1&lt;/code&gt;.&lt;p&gt;
     *
     * This is used after calling &lt;code&gt;setPara()&lt;/code&gt;
     * for a piece of text, and after line-breaking on that text.
     * It is not necessary if each paragraph is treated as a single line.&lt;p&gt;
     *
     * After line-breaking, rules (L1) and (L2) for the treatment of
     * trailing WS and for reordering are performed on
     * a &lt;code&gt;Bidi&lt;/code&gt; object that represents a line.&lt;p&gt;
     *
     * &lt;strong&gt;Important: &lt;/strong&gt;the line &lt;code&gt;Bidi&lt;/code&gt; object may
     * reference data within the global text &lt;code&gt;Bidi&lt;/code&gt; object.
     * You should not alter the content of the global text object until
     * you are finished using the line object.
     *
     * @param start is the line's first index into the text.
     *
     * @param limit is just behind the line's last index into the text
     *        (its last index +1).
     *
     * @return a &lt;code&gt;Bidi&lt;/code&gt; object that will now represent a line of the text.
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt;
     * @throws IllegalArgumentException if start and limit are not in the range
     *         &lt;code&gt;0&amp;lt;=start&amp;lt;limit&amp;lt;=getProcessedLength()&lt;/code&gt;,
     *         or if the specified line crosses a paragraph boundary
     *
     * @see #setPara
     * @see #getProcessedLength
     * @stable ICU 3.8
     */
    public Bidi setLine(Bidi bidi, BidiBase bidiBase, Bidi newBidi, BidiBase newBidiBase, int start, int limit)
    {
<span class="nc" id="L2889">        verifyValidPara();</span>
<span class="nc" id="L2890">        verifyRange(start, 0, limit);</span>
<span class="nc" id="L2891">        verifyRange(limit, 0, length+1);</span>

<span class="nc" id="L2893">        return BidiLine.setLine(bidi, this, newBidi, newBidiBase, start, limit);</span>
    }

    /**
     * Get the level for one character.
     *
     * @param charIndex the index of a character.
     *
     * @return The level for the character at &lt;code&gt;charIndex&lt;/code&gt;.
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     * @throws IllegalArgumentException if charIndex is not in the range
     *         &lt;code&gt;0&amp;lt;=charIndex&amp;lt;getProcessedLength()&lt;/code&gt;
     *
     * @see #getProcessedLength
     * @stable ICU 3.8
     */
    public byte getLevelAt(int charIndex)
    {
<span class="nc bnc" id="L2913" title="All 4 branches missed.">        if (charIndex &lt; 0 || charIndex &gt;= length) {</span>
<span class="nc" id="L2914">            return (byte)getBaseLevel();</span>
        }
<span class="nc" id="L2916">        verifyValidParaOrLine();</span>
<span class="nc" id="L2917">        verifyRange(charIndex, 0, length);</span>
<span class="nc" id="L2918">        return BidiLine.getLevelAt(this, charIndex);</span>
    }

    /**
     * Get an array of levels for each character.&lt;p&gt;
     *
     * Note that this method may allocate memory under some
     * circumstances, unlike &lt;code&gt;getLevelAt()&lt;/code&gt;.
     *
     * @return The levels array for the text,
     *         or &lt;code&gt;null&lt;/code&gt; if an error occurs.
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     * @stable ICU 3.8
     */
    private byte[] getLevels()
    {
<span class="nc" id="L2936">        verifyValidParaOrLine();</span>
<span class="nc bnc" id="L2937" title="All 2 branches missed.">        if (length &lt;= 0) {</span>
<span class="nc" id="L2938">            return new byte[0];</span>
        }
<span class="nc" id="L2940">        return BidiLine.getLevels(this);</span>
    }

    /**
     * Get the number of runs.
     * This method may invoke the actual reordering on the
     * &lt;code&gt;Bidi&lt;/code&gt; object, after &lt;code&gt;setPara()&lt;/code&gt;
     * may have resolved only the levels of the text. Therefore,
     * &lt;code&gt;countRuns()&lt;/code&gt; may have to allocate memory,
     * and may throw an exception if it fails to do so.
     *
     * @return The number of runs.
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     * @stable ICU 3.8
     */
    public int countRuns()
    {
<span class="nc" id="L2959">        verifyValidParaOrLine();</span>
<span class="nc" id="L2960">        BidiLine.getRuns(this);</span>
<span class="nc" id="L2961">        return runCount;</span>
    }

    /**
     * Get a visual-to-logical index map (array) for the characters in the
     * &lt;code&gt;Bidi&lt;/code&gt; (paragraph or line) object.
     * &lt;p&gt;
     * Some values in the map may be &lt;code&gt;MAP_NOWHERE&lt;/code&gt; if the
     * corresponding text characters are Bidi marks inserted in the visual
     * output by the option &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;.
     * &lt;p&gt;
     * When the visual output is altered by using options of
     * &lt;code&gt;writeReordered()&lt;/code&gt; such as &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt;,
     * &lt;code&gt;KEEP_BASE_COMBINING&lt;/code&gt;, &lt;code&gt;OUTPUT_REVERSE&lt;/code&gt;,
     * &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt;, the logical positions returned may not
     * be correct. It is advised to use, when possible, reordering options
     * such as {@link #OPTION_INSERT_MARKS} and {@link #OPTION_REMOVE_CONTROLS}.
     *
     * @return an array of &lt;code&gt;getResultLength()&lt;/code&gt;
     *        indexes which will reflect the reordering of the characters.&lt;br&gt;&lt;br&gt;
     *        The index map will result in
     *        &lt;code&gt;indexMap[visualIndex]==logicalIndex&lt;/code&gt;, where
     *        &lt;code&gt;indexMap&lt;/code&gt; represents the returned array.
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     *
     * @see #getLogicalMap
     * @see #getLogicalIndex
     * @see #getResultLength
     * @see #MAP_NOWHERE
     * @see #OPTION_INSERT_MARKS
     * @see #writeReordered
     * @stable ICU 3.8
     */
    private int[] getVisualMap()
    {
        /* countRuns() checks successful call to setPara/setLine */
<span class="nc" id="L2999">        countRuns();</span>
<span class="nc bnc" id="L3000" title="All 2 branches missed.">        if (resultLength &lt;= 0) {</span>
<span class="nc" id="L3001">            return new int[0];</span>
        }
<span class="nc" id="L3003">        return BidiLine.getVisualMap(this);</span>
    }

    /**
     * This is a convenience method that does not use a &lt;code&gt;Bidi&lt;/code&gt; object.
     * It is intended to be used for when an application has determined the levels
     * of objects (character sequences) and just needs to have them reordered (L2).
     * This is equivalent to using &lt;code&gt;getVisualMap()&lt;/code&gt; on a
     * &lt;code&gt;Bidi&lt;/code&gt; object.
     *
     * @param levels is an array of levels that have been determined by
     *        the application.
     *
     * @return an array of &lt;code&gt;levels.length&lt;/code&gt;
     *        indexes which will reflect the reordering of the characters.&lt;p&gt;
     *        The index map will result in
     *        &lt;code&gt;indexMap[visualIndex]==logicalIndex&lt;/code&gt;, where
     *        &lt;code&gt;indexMap&lt;/code&gt; represents the returned array.
     *
     * @stable ICU 3.8
     */
    private static int[] reorderVisual(byte[] levels)
    {
<span class="nc" id="L3026">        return BidiLine.reorderVisual(levels);</span>
    }

    /**
     * Constant indicating that the base direction depends on the first strong
     * directional character in the text according to the Unicode Bidirectional
     * Algorithm. If no strong directional character is present, the base
     * direction is left-to-right.
     * @stable ICU 3.8
     */
    private static final int INTERNAL_DIRECTION_DEFAULT_LEFT_TO_RIGHT = 0x7e;

    /**
     * Constant indicating that the base direction depends on the first strong
     * directional character in the text according to the Unicode Bidirectional
     * Algorithm. If no strong directional character is present, the base
     * direction is right-to-left.
     * @stable ICU 3.8
     */
    private static final int INTERMAL_DIRECTION_DEFAULT_RIGHT_TO_LEFT = 0x7f;

    /**
     * Create Bidi from the given text, embedding, and direction information.
     * The embeddings array may be null. If present, the values represent
     * embedding level information. Negative values from -1 to -61 indicate
     * overrides at the absolute value of the level. Positive values from 1 to
     * 61 indicate embeddings. Where values are zero, the base embedding level
     * as determined by the base direction is assumed.&lt;p&gt;
     *
     * Note: this constructor calls setPara() internally.
     *
     * @param text an array containing the paragraph of text to process.
     * @param textStart the index into the text array of the start of the
     *        paragraph.
     * @param embeddings an array containing embedding values for each character
     *        in the paragraph. This can be null, in which case it is assumed
     *        that there is no external embedding information.
     * @param embStart the index into the embedding array of the start of the
     *        paragraph.
     * @param paragraphLength the length of the paragraph in the text and
     *        embeddings arrays.
     * @param flags a collection of flags that control the algorithm. The
     *        algorithm understands the flags DIRECTION_LEFT_TO_RIGHT,
     *        DIRECTION_RIGHT_TO_LEFT, DIRECTION_DEFAULT_LEFT_TO_RIGHT, and
     *        DIRECTION_DEFAULT_RIGHT_TO_LEFT. Other values are reserved.
     *
     * @throws IllegalArgumentException if the values in embeddings are
     *         not within the allowed range
     *
     * @see #DIRECTION_LEFT_TO_RIGHT
     * @see #DIRECTION_RIGHT_TO_LEFT
     * @see #DIRECTION_DEFAULT_LEFT_TO_RIGHT
     * @see #DIRECTION_DEFAULT_RIGHT_TO_LEFT
     * @stable ICU 3.8
     */
    public BidiBase(char[] text,
             int textStart,
             byte[] embeddings,
             int embStart,
             int paragraphLength,
             int flags)
     {
<span class="nc" id="L3088">        this(0, 0);</span>
        byte paraLvl;
<span class="nc bnc" id="L3090" title="All 4 branches missed.">        switch (flags) {</span>
        case Bidi.DIRECTION_LEFT_TO_RIGHT:
        default:
<span class="nc" id="L3093">            paraLvl = Bidi.DIRECTION_LEFT_TO_RIGHT;</span>
<span class="nc" id="L3094">            break;</span>
        case Bidi.DIRECTION_RIGHT_TO_LEFT:
<span class="nc" id="L3096">            paraLvl = Bidi.DIRECTION_RIGHT_TO_LEFT;</span>
<span class="nc" id="L3097">            break;</span>
        case Bidi.DIRECTION_DEFAULT_LEFT_TO_RIGHT:
<span class="nc" id="L3099">            paraLvl = INTERNAL_LEVEL_DEFAULT_LTR;</span>
<span class="nc" id="L3100">            break;</span>
        case Bidi.DIRECTION_DEFAULT_RIGHT_TO_LEFT:
<span class="nc" id="L3102">            paraLvl = INTERNAL_LEVEL_DEFAULT_RTL;</span>
            break;
        }
        byte[] paraEmbeddings;
<span class="nc bnc" id="L3106" title="All 2 branches missed.">        if (embeddings == null) {</span>
<span class="nc" id="L3107">            paraEmbeddings = null;</span>
        } else {
<span class="nc" id="L3109">            paraEmbeddings = new byte[paragraphLength];</span>
            byte lev;
<span class="nc bnc" id="L3111" title="All 2 branches missed.">            for (int i = 0; i &lt; paragraphLength; i++) {</span>
<span class="nc" id="L3112">                lev = embeddings[i + embStart];</span>
<span class="nc bnc" id="L3113" title="All 2 branches missed.">                if (lev &lt; 0) {</span>
<span class="nc" id="L3114">                    lev = (byte)((- lev) | INTERNAL_LEVEL_OVERRIDE);</span>
<span class="nc bnc" id="L3115" title="All 2 branches missed.">                } else if (lev == 0) {</span>
<span class="nc" id="L3116">                    lev = paraLvl;</span>
<span class="nc bnc" id="L3117" title="All 2 branches missed.">                    if (paraLvl &gt; MAX_EXPLICIT_LEVEL) {</span>
<span class="nc" id="L3118">                        lev &amp;= 1;</span>
                    }
                }
<span class="nc" id="L3121">                paraEmbeddings[i] = lev;</span>
            }
        }
<span class="nc bnc" id="L3124" title="All 6 branches missed.">        if (textStart == 0 &amp;&amp; embStart == 0 &amp;&amp; paragraphLength == text.length) {</span>
<span class="nc" id="L3125">            setPara(text, paraLvl, paraEmbeddings);</span>
        } else {
<span class="nc" id="L3127">            char[] paraText = new char[paragraphLength];</span>
<span class="nc" id="L3128">            System.arraycopy(text, textStart, paraText, 0, paragraphLength);</span>
<span class="nc" id="L3129">            setPara(paraText, paraLvl, paraEmbeddings);</span>
        }
<span class="nc" id="L3131">    }</span>

    /**
     * Return true if the line is not left-to-right or right-to-left. This means
     * it either has mixed runs of left-to-right and right-to-left text, or the
     * base direction differs from the direction of the only run of text.
     *
     * @return true if the line is not left-to-right or right-to-left.
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt;
     * @stable ICU 3.8
     */
    public boolean isMixed()
    {
<span class="nc bnc" id="L3146" title="All 4 branches missed.">        return (!isLeftToRight() &amp;&amp; !isRightToLeft());</span>
    }

    /**
    * Return true if the line is all left-to-right text and the base direction
     * is left-to-right.
     *
     * @return true if the line is all left-to-right text and the base direction
     *         is left-to-right.
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt;
     * @stable ICU 3.8
     */
    public boolean isLeftToRight()
    {
<span class="nc bnc" id="L3162" title="All 4 branches missed.">        return (getDirection() == Bidi.DIRECTION_LEFT_TO_RIGHT &amp;&amp; (paraLevel &amp; 1) == 0);</span>
    }

    /**
     * Return true if the line is all right-to-left text, and the base direction
     * is right-to-left
     *
     * @return true if the line is all right-to-left text, and the base
     *         direction is right-to-left
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt;
     * @stable ICU 3.8
     */
    public boolean isRightToLeft()
    {
<span class="nc bnc" id="L3178" title="All 4 branches missed.">        return (getDirection() == Bidi.DIRECTION_RIGHT_TO_LEFT &amp;&amp; (paraLevel &amp; 1) == 1);</span>
    }

    /**
     * Return true if the base direction is left-to-right
     *
     * @return true if the base direction is left-to-right
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     *
     * @stable ICU 3.8
     */
    public boolean baseIsLeftToRight()
    {
<span class="nc bnc" id="L3193" title="All 2 branches missed.">        return (getParaLevel() == Bidi.DIRECTION_LEFT_TO_RIGHT);</span>
    }

    /**
     * Return the base level (0 if left-to-right, 1 if right-to-left).
     *
     * @return the base level
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     *
     * @stable ICU 3.8
     */
    public int getBaseLevel()
    {
<span class="nc" id="L3208">        return getParaLevel();</span>
    }

    /**
     * Compute the logical to visual run mapping
     */
    private void getLogicalToVisualRunsMap()
    {
<span class="nc bnc" id="L3216" title="All 2 branches missed.">        if (isGoodLogicalToVisualRunsMap) {</span>
<span class="nc" id="L3217">            return;</span>
        }
<span class="nc" id="L3219">        int count = countRuns();</span>
<span class="nc bnc" id="L3220" title="All 4 branches missed.">        if ((logicalToVisualRunsMap == null) ||</span>
            (logicalToVisualRunsMap.length &lt; count)) {
<span class="nc" id="L3222">            logicalToVisualRunsMap = new int[count];</span>
        }
        int i;
<span class="nc" id="L3225">        long[] keys = new long[count];</span>
<span class="nc bnc" id="L3226" title="All 2 branches missed.">        for (i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L3227">            keys[i] = ((long)(runs[i].start)&lt;&lt;32) + i;</span>
        }
<span class="nc" id="L3229">        Arrays.sort(keys);</span>
<span class="nc bnc" id="L3230" title="All 2 branches missed.">        for (i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L3231">            logicalToVisualRunsMap[i] = (int)(keys[i] &amp; 0x00000000FFFFFFFF);</span>
        }
<span class="nc" id="L3233">        keys = null;</span>
<span class="nc" id="L3234">        isGoodLogicalToVisualRunsMap = true;</span>
<span class="nc" id="L3235">    }</span>

    /**
     * Return the level of the nth logical run in this line.
     *
     * @param run the index of the run, between 0 and &lt;code&gt;countRuns()-1&lt;/code&gt;
     *
     * @return the level of the run
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;run&lt;/code&gt; is not in
     *         the range &lt;code&gt;0&amp;lt;=run&amp;lt;countRuns()&lt;/code&gt;
     * @stable ICU 3.8
     */
    public int getRunLevel(int run)
    {
<span class="nc" id="L3252">        verifyValidParaOrLine();</span>
<span class="nc" id="L3253">        BidiLine.getRuns(this);</span>
<span class="nc bnc" id="L3254" title="All 4 branches missed.">        if (run &lt; 0 || run &gt;= runCount) {</span>
<span class="nc" id="L3255">            return getParaLevel();</span>
        }
<span class="nc" id="L3257">        getLogicalToVisualRunsMap();</span>
<span class="nc" id="L3258">        return runs[logicalToVisualRunsMap[run]].level;</span>
    }

    /**
     * Return the index of the character at the start of the nth logical run in
     * this line, as an offset from the start of the line.
     *
     * @param run the index of the run, between 0 and &lt;code&gt;countRuns()&lt;/code&gt;
     *
     * @return the start of the run
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;run&lt;/code&gt; is not in
     *         the range &lt;code&gt;0&amp;lt;=run&amp;lt;countRuns()&lt;/code&gt;
     * @stable ICU 3.8
     */
    public int getRunStart(int run)
    {
<span class="nc" id="L3277">        verifyValidParaOrLine();</span>
<span class="nc" id="L3278">        BidiLine.getRuns(this);</span>
<span class="nc bnc" id="L3279" title="All 2 branches missed.">        if (runCount == 1) {</span>
<span class="nc" id="L3280">            return 0;</span>
<span class="nc bnc" id="L3281" title="All 2 branches missed.">        } else if (run == runCount) {</span>
<span class="nc" id="L3282">            return length;</span>
        }
<span class="nc" id="L3284">        verifyIndex(run, 0, runCount);</span>
<span class="nc" id="L3285">        getLogicalToVisualRunsMap();</span>
<span class="nc" id="L3286">        return runs[logicalToVisualRunsMap[run]].start;</span>
    }

    /**
     * Return the index of the character past the end of the nth logical run in
     * this line, as an offset from the start of the line. For example, this
     * will return the length of the line for the last run on the line.
     *
     * @param run the index of the run, between 0 and &lt;code&gt;countRuns()&lt;/code&gt;
     *
     * @return the limit of the run
     *
     * @throws IllegalStateException if this call is not preceded by a successful
     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;run&lt;/code&gt; is not in
     *         the range &lt;code&gt;0&amp;lt;=run&amp;lt;countRuns()&lt;/code&gt;
     * @stable ICU 3.8
     */
    public int getRunLimit(int run)
    {
<span class="nc" id="L3306">        verifyValidParaOrLine();</span>
<span class="nc" id="L3307">        BidiLine.getRuns(this);</span>
<span class="nc bnc" id="L3308" title="All 2 branches missed.">        if (runCount == 1) {</span>
<span class="nc" id="L3309">            return length;</span>
        }
<span class="nc" id="L3311">        verifyIndex(run, 0, runCount);</span>
<span class="nc" id="L3312">        getLogicalToVisualRunsMap();</span>
<span class="nc" id="L3313">        int idx = logicalToVisualRunsMap[run];</span>
<span class="nc bnc" id="L3314" title="All 2 branches missed.">        int len = idx == 0 ? runs[idx].limit :</span>
                                runs[idx].limit - runs[idx-1].limit;
<span class="nc" id="L3316">        return runs[idx].start + len;</span>
    }

    /**
     * Return true if the specified text requires bidi analysis. If this returns
     * false, the text will display left-to-right. Clients can then avoid
     * constructing a Bidi object. Text in the Arabic Presentation Forms area of
     * Unicode is presumed to already be shaped and ordered for display, and so
     * will not cause this method to return true.
     *
     * @param text the text containing the characters to test
     * @param start the start of the range of characters to test
     * @param limit the limit of the range of characters to test
     *
     * @return true if the range of characters requires bidi analysis
     *
     * @stable ICU 3.8
     */
    public static boolean requiresBidi(char[] text,
            int start,
            int limit)
    {
        final int RTLMask = (1 &lt;&lt; Bidi.DIRECTION_RIGHT_TO_LEFT |
                1 &lt;&lt; AL |
                1 &lt;&lt; RLE |
                1 &lt;&lt; RLO |
                1 &lt;&lt; AN);

<span class="nc bnc" id="L3344" title="All 6 branches missed.">        if (0 &gt; start || start &gt; limit || limit &gt; text.length) {</span>
<span class="nc" id="L3345">            throw new IllegalArgumentException(&quot;Value start &quot; + start +</span>
                      &quot; is out of range 0 to &quot; + limit);
        }
<span class="nc bnc" id="L3348" title="All 2 branches missed.">        for (int i = start; i &lt; limit; ++i) {</span>
<span class="nc bnc" id="L3349" title="All 4 branches missed.">            if (Character.isHighSurrogate(text[i]) &amp;&amp; i &lt; (limit-1) &amp;&amp;</span>
<span class="nc bnc" id="L3350" title="All 2 branches missed.">                Character.isLowSurrogate(text[i+1])) {</span>
<span class="nc bnc" id="L3351" title="All 2 branches missed.">                if (((1 &lt;&lt; UCharacter.getDirection(Character.codePointAt(text, i))) &amp; RTLMask) != 0) {</span>
<span class="nc" id="L3352">                    return true;</span>
                }
<span class="nc bnc" id="L3354" title="All 2 branches missed.">            } else if (((1 &lt;&lt; UCharacter.getDirection(text[i])) &amp; RTLMask) != 0) {</span>
<span class="nc" id="L3355">                return true;</span>
            }
        }
<span class="nc" id="L3358">        return false;</span>
    }

    /**
     * Reorder the objects in the array into visual order based on their levels.
     * This is a utility method to use when you have a collection of objects
     * representing runs of text in logical order, each run containing text at a
     * single level. The elements at &lt;code&gt;index&lt;/code&gt; from
     * &lt;code&gt;objectStart&lt;/code&gt; up to &lt;code&gt;objectStart + count&lt;/code&gt; in the
     * objects array will be reordered into visual order assuming
     * each run of text has the level indicated by the corresponding element in
     * the levels array (at &lt;code&gt;index - objectStart + levelStart&lt;/code&gt;).
     *
     * @param levels an array representing the bidi level of each object
     * @param levelStart the start position in the levels array
     * @param objects the array of objects to be reordered into visual order
     * @param objectStart the start position in the objects array
     * @param count the number of objects to reorder
     * @stable ICU 3.8
     */
    public static void reorderVisually(byte[] levels,
            int levelStart,
            Object[] objects,
            int objectStart,
            int count)
    {
<span class="nc bnc" id="L3384" title="All 4 branches missed.">        if (0 &gt; levelStart || levels.length &lt;= levelStart) {</span>
<span class="nc" id="L3385">            throw new IllegalArgumentException(&quot;Value levelStart &quot; +</span>
                      levelStart + &quot; is out of range 0 to &quot; +
                      (levels.length-1));
        }
<span class="nc bnc" id="L3389" title="All 4 branches missed.">        if (0 &gt; objectStart || objects.length &lt;= objectStart) {</span>
<span class="nc" id="L3390">            throw new IllegalArgumentException(&quot;Value objectStart &quot; +</span>
                      levelStart + &quot; is out of range 0 to &quot; +
                      (objects.length-1));
        }
<span class="nc bnc" id="L3394" title="All 4 branches missed.">        if (0 &gt; count || objects.length &lt; (objectStart+count)) {</span>
<span class="nc" id="L3395">            throw new IllegalArgumentException(&quot;Value count &quot; +</span>
                      levelStart + &quot; is out of range 0 to &quot; +
                      (objects.length - objectStart));
        }
<span class="nc" id="L3399">        byte[] reorderLevels = new byte[count];</span>
<span class="nc" id="L3400">        System.arraycopy(levels, levelStart, reorderLevels, 0, count);</span>
<span class="nc" id="L3401">        int[] indexMap = reorderVisual(reorderLevels);</span>
<span class="nc" id="L3402">        Object[] temp = new Object[count];</span>
<span class="nc" id="L3403">        System.arraycopy(objects, objectStart, temp, 0, count);</span>
<span class="nc bnc" id="L3404" title="All 2 branches missed.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="nc" id="L3405">            objects[objectStart + i] = temp[indexMap[i]];</span>
        }
<span class="nc" id="L3407">    }</span>

    /**
     * Display the bidi internal state, used in debugging.
     */
    public String toString() {
<span class="nc" id="L3413">        StringBuilder buf = new StringBuilder(getClass().getName());</span>

<span class="nc" id="L3415">        buf.append(&quot;[dir: &quot;);</span>
<span class="nc" id="L3416">        buf.append(direction);</span>
<span class="nc" id="L3417">        buf.append(&quot; baselevel: &quot;);</span>
<span class="nc" id="L3418">        buf.append(paraLevel);</span>
<span class="nc" id="L3419">        buf.append(&quot; length: &quot;);</span>
<span class="nc" id="L3420">        buf.append(length);</span>
<span class="nc" id="L3421">        buf.append(&quot; runs: &quot;);</span>
<span class="nc bnc" id="L3422" title="All 2 branches missed.">        if (levels == null) {</span>
<span class="nc" id="L3423">            buf.append(&quot;none&quot;);</span>
        } else {
<span class="nc" id="L3425">            buf.append('[');</span>
<span class="nc" id="L3426">            buf.append(levels[0]);</span>
<span class="nc bnc" id="L3427" title="All 2 branches missed.">            for (int i = 1; i &lt; levels.length; i++) {</span>
<span class="nc" id="L3428">                buf.append(' ');</span>
<span class="nc" id="L3429">                buf.append(levels[i]);</span>
            }
<span class="nc" id="L3431">            buf.append(']');</span>
        }
<span class="nc" id="L3433">        buf.append(&quot; text: [0x&quot;);</span>
<span class="nc" id="L3434">        buf.append(Integer.toHexString(text[0]));</span>
<span class="nc bnc" id="L3435" title="All 2 branches missed.">        for (int i = 1; i &lt; text.length; i++) {</span>
<span class="nc" id="L3436">            buf.append(&quot; 0x&quot;);</span>
<span class="nc" id="L3437">            buf.append(Integer.toHexString(text[i]));</span>
        }
<span class="nc" id="L3439">        buf.append(&quot;]]&quot;);</span>

<span class="nc" id="L3441">        return buf.toString();</span>
    }

    /**
     * A class that provides access to constants defined by
     * java.awt.font.TextAttribute without creating a static dependency.
     */
<span class="nc" id="L3448">    private static class TextAttributeConstants {</span>
<span class="nc" id="L3449">        private static final Class&lt;?&gt; clazz = getClass(&quot;java.awt.font.TextAttribute&quot;);</span>

        /**
         * TextAttribute instances (or a fake Attribute type if
         * java.awt.font.TextAttribute is not present)
         */
<span class="nc" id="L3455">        static final AttributedCharacterIterator.Attribute RUN_DIRECTION =</span>
<span class="nc" id="L3456">            getTextAttribute(&quot;RUN_DIRECTION&quot;);</span>
<span class="nc" id="L3457">        static final AttributedCharacterIterator.Attribute NUMERIC_SHAPING =</span>
<span class="nc" id="L3458">            getTextAttribute(&quot;NUMERIC_SHAPING&quot;);</span>
<span class="nc" id="L3459">        static final AttributedCharacterIterator.Attribute BIDI_EMBEDDING =</span>
<span class="nc" id="L3460">            getTextAttribute(&quot;BIDI_EMBEDDING&quot;);</span>

        /**
         * TextAttribute.RUN_DIRECTION_LTR
         */
<span class="nc bnc" id="L3465" title="All 2 branches missed.">        static final Boolean RUN_DIRECTION_LTR = (clazz == null) ?</span>
<span class="nc" id="L3466">            Boolean.FALSE : (Boolean)getStaticField(clazz, &quot;RUN_DIRECTION_LTR&quot;);</span>


        private static Class&lt;?&gt; getClass(String name) {
            try {
<span class="nc" id="L3471">                return Class.forName(name, true, null);</span>
<span class="nc" id="L3472">            } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L3473">                return null;</span>
            }
        }

        private static Object getStaticField(Class&lt;?&gt; clazz, String name) {
            try {
<span class="nc" id="L3479">                Field f = clazz.getField(name);</span>
<span class="nc" id="L3480">                return f.get(null);</span>
<span class="nc" id="L3481">            } catch (NoSuchFieldException | IllegalAccessException x) {</span>
<span class="nc" id="L3482">                throw new AssertionError(x);</span>
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static AttributedCharacterIterator.Attribute
            getTextAttribute(String name)
        {
<span class="nc bnc" id="L3490" title="All 2 branches missed.">            if (clazz == null) {</span>
                // fake attribute
<span class="nc" id="L3492">                return new AttributedCharacterIterator.Attribute(name) { };</span>
            } else {
<span class="nc" id="L3494">                return (AttributedCharacterIterator.Attribute)getStaticField(clazz, name);</span>
            }
        }
    }

    /**
     * A class that provides access to java.awt.font.NumericShaping without
     * creating a static dependency.
     */
<span class="nc" id="L3503">    private static class NumericShapings {</span>
<span class="nc" id="L3504">        private static final Class&lt;?&gt; clazz =</span>
<span class="nc" id="L3505">            getClass(&quot;java.awt.font.NumericShaper&quot;);</span>
<span class="nc" id="L3506">        private static final Method shapeMethod =</span>
<span class="nc" id="L3507">            getMethod(clazz, &quot;shape&quot;, char[].class, int.class, int.class);</span>

        private static Class&lt;?&gt; getClass(String name) {
            try {
<span class="nc" id="L3511">                return Class.forName(name, true, null);</span>
<span class="nc" id="L3512">            } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L3513">                return null;</span>
            }
        }

        private static Method getMethod(Class&lt;?&gt; clazz,
                                        String name,
                                        Class&lt;?&gt;... paramTypes)
        {
<span class="nc bnc" id="L3521" title="All 2 branches missed.">            if (clazz != null) {</span>
                try {
<span class="nc" id="L3523">                    return clazz.getMethod(name, paramTypes);</span>
<span class="nc" id="L3524">                } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L3525">                    throw new AssertionError(e);</span>
                }
            } else {
<span class="nc" id="L3528">                return null;</span>
            }
        }

        /**
         * Invokes NumericShaping shape(text,start,count) method.
         */
        static void shape(Object shaper, char[] text, int start, int count) {
<span class="nc bnc" id="L3536" title="All 2 branches missed.">            if (shapeMethod == null)</span>
<span class="nc" id="L3537">                throw new AssertionError(&quot;Should not get here&quot;);</span>
            try {
<span class="nc" id="L3539">                shapeMethod.invoke(shaper, text, start, count);</span>
<span class="nc" id="L3540">            } catch (InvocationTargetException e) {</span>
<span class="nc" id="L3541">                Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L3542" title="All 2 branches missed.">                if (cause instanceof RuntimeException)</span>
<span class="nc" id="L3543">                    throw (RuntimeException)cause;</span>
<span class="nc" id="L3544">                throw new AssertionError(e);</span>
<span class="nc" id="L3545">            } catch (IllegalAccessException iae) {</span>
<span class="nc" id="L3546">                throw new AssertionError(iae);</span>
<span class="nc" id="L3547">            }</span>
<span class="nc" id="L3548">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>