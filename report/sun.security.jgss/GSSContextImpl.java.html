<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GSSContextImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.jgss</a> &gt; <span class="el_source">GSSContextImpl.java</span></div><h1>GSSContextImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2009, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.jgss;

import org.ietf.jgss.*;
import sun.security.jgss.spi.*;
import sun.security.util.ObjectIdentifier;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import com.sun.security.jgss.*;

/**
 * This class represents the JGSS security context and its associated
 * operations.  JGSS security contexts are established between
 * peers using locally established credentials.  Multiple contexts
 * may exist simultaneously between a pair of peers, using the same
 * or different set of credentials.  The JGSS is independent of
 * the underlying transport protocols and depends on its callers to
 * transport the tokens between peers.
 * &lt;p&gt;
 * The context object can be thought of as having 3 implicit states:
 * before it is established, during its context establishment, and
 * after a fully established context exists.
 * &lt;p&gt;
 * Before the context establishment phase is initiated, the context
 * initiator may request specific characteristics desired of the
 * established context. These can be set using the set methods. After the
 * context is established, the caller can check the actual characteristic
 * and services offered by the context using the query methods.
 * &lt;p&gt;
 * The context establishment phase begins with the first call to the
 * initSecContext method by the context initiator. During this phase the
 * initSecContext and acceptSecContext methods will produce GSS-API
 * authentication tokens which the calling application needs to send to its
 * peer. The initSecContext and acceptSecContext methods may
 * return a CONTINUE_NEEDED code which indicates that a token is needed
 * from its peer in order to continue the context establishment phase. A
 * return code of COMPLETE signals that the local end of the context is
 * established. This may still require that a token be sent to the peer,
 * depending if one is produced by GSS-API. The isEstablished method can
 * also be used to determine if the local end of the context has been
 * fully established. During the context establishment phase, the
 * isProtReady method may be called to determine if the context can be
 * used for the per-message operations. This allows implementation to
 * use per-message operations on contexts which aren't fully established.
 * &lt;p&gt;
 * After the context has been established or the isProtReady method
 * returns &quot;true&quot;, the query routines can be invoked to determine the actual
 * characteristics and services of the established context. The
 * application can also start using the per-message methods of wrap and
 * getMIC to obtain cryptographic operations on application supplied data.
 * &lt;p&gt;
 * When the context is no longer needed, the application should call
 * dispose to release any system resources the context may be using.
 * &lt;DL&gt;&lt;DT&gt;&lt;B&gt;RFC 2078&lt;/b&gt;
 *    &lt;DD&gt;This class corresponds to the context level calls together with
 * the per message calls of RFC 2078. The gss_init_sec_context and
 * gss_accept_sec_context calls have been made simpler by only taking
 * required parameters.  The context can have its properties set before
 * the first call to initSecContext. The supplementary status codes for the
 * per-message operations are returned in an instance of the MessageProp
 * class, which is used as an argument in these calls.&lt;/dl&gt;
 */
class GSSContextImpl implements ExtendedGSSContext {

    private final GSSManagerImpl gssManager;
    private final boolean initiator;

    // private flags for the context state
    private static final int PRE_INIT = 1;
    private static final int IN_PROGRESS = 2;
    private static final int READY = 3;
    private static final int DELETED = 4;

    // instance variables
<span class="pc" id="L102">    private int currentState = PRE_INIT;</span>

<span class="pc" id="L104">    private GSSContextSpi mechCtxt = null;</span>
<span class="pc" id="L105">    private Oid mechOid = null;</span>
<span class="pc" id="L106">    private ObjectIdentifier objId = null;</span>

<span class="pc" id="L108">    private GSSCredentialImpl myCred = null;</span>

<span class="pc" id="L110">    private GSSNameImpl srcName = null;</span>
<span class="pc" id="L111">    private GSSNameImpl targName = null;</span>

<span class="pc" id="L113">    private int reqLifetime = INDEFINITE_LIFETIME;</span>
<span class="pc" id="L114">    private ChannelBinding channelBindings = null;</span>

<span class="pc" id="L116">    private boolean reqConfState = true;</span>
<span class="pc" id="L117">    private boolean reqIntegState = true;</span>
<span class="pc" id="L118">    private boolean reqMutualAuthState = true;</span>
<span class="pc" id="L119">    private boolean reqReplayDetState = true;</span>
<span class="pc" id="L120">    private boolean reqSequenceDetState = true;</span>
<span class="pc" id="L121">    private boolean reqCredDelegState = false;</span>
<span class="pc" id="L122">    private boolean reqAnonState = false;</span>
<span class="pc" id="L123">    private boolean reqDelegPolicyState = false;</span>

    /**
     * Creates a GSSContextImp on the context initiator's side.
     */
    public GSSContextImpl(GSSManagerImpl gssManager, GSSName peer, Oid mech,
                          GSSCredential myCred, int lifetime)
<span class="fc" id="L130">        throws GSSException {</span>
<span class="pc bpc" id="L131" title="2 of 4 branches missed.">        if ((peer == null) || !(peer instanceof GSSNameImpl)) {</span>
<span class="nc" id="L132">            throw new GSSException(GSSException.BAD_NAME);</span>
        }
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;</span>

<span class="fc" id="L136">        this.gssManager = gssManager;</span>
<span class="fc" id="L137">        this.myCred = (GSSCredentialImpl) myCred;  // XXX Check first</span>
<span class="fc" id="L138">        reqLifetime = lifetime;</span>
<span class="fc" id="L139">        targName = (GSSNameImpl)peer;</span>
<span class="fc" id="L140">        this.mechOid = mech;</span>
<span class="fc" id="L141">        initiator = true;</span>
<span class="fc" id="L142">    }</span>

    /**
     * Creates a GSSContextImpl on the context acceptor's side.
     */
    public GSSContextImpl(GSSManagerImpl gssManager, GSSCredential myCred)
<span class="fc" id="L148">        throws GSSException {</span>
<span class="fc" id="L149">        this.gssManager = gssManager;</span>
<span class="fc" id="L150">        this.myCred = (GSSCredentialImpl) myCred; // XXX Check first</span>
<span class="fc" id="L151">        initiator = false;</span>
<span class="fc" id="L152">    }</span>

    /**
     * Creates a GSSContextImpl out of a previously exported
     * GSSContext.
     *
     * @see #isTransferable
     */
    public GSSContextImpl(GSSManagerImpl gssManager, byte[] interProcessToken)
<span class="nc" id="L161">        throws GSSException {</span>
<span class="nc" id="L162">        this.gssManager = gssManager;</span>
<span class="nc" id="L163">        mechCtxt = gssManager.getMechanismContext(interProcessToken);</span>
<span class="nc" id="L164">        initiator = mechCtxt.isInitiator();</span>
<span class="nc" id="L165">        this.mechOid = mechCtxt.getMech();</span>
<span class="nc" id="L166">    }</span>

    public byte[] initSecContext(byte inputBuf[], int offset, int len)
        throws GSSException {
        /*
         * Size of ByteArrayOutputStream will double each time that extra
         * bytes are to be written. Usually, without delegation, a GSS
         * initial token containing the Kerberos AP-REQ is between 400 and
         * 600 bytes.
         */
<span class="fc" id="L176">        ByteArrayOutputStream bos = new ByteArrayOutputStream(600);</span>
<span class="fc" id="L177">        ByteArrayInputStream bin =</span>
            new ByteArrayInputStream(inputBuf, offset, len);
<span class="fc" id="L179">        int size = initSecContext(bin, bos);</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        return (size == 0? null : bos.toByteArray());</span>
    }

    public int initSecContext(InputStream inStream,
                              OutputStream outStream) throws GSSException {

<span class="pc bpc" id="L186" title="1 of 4 branches missed.">        if (mechCtxt != null &amp;&amp; currentState != IN_PROGRESS) {</span>
<span class="nc" id="L187">            throw new GSSExceptionImpl(GSSException.FAILURE,</span>
                                   &quot;Illegal call to initSecContext&quot;);
        }

<span class="fc" id="L191">        GSSHeader gssHeader = null;</span>
<span class="fc" id="L192">        int inTokenLen = -1;</span>
<span class="fc" id="L193">        GSSCredentialSpi credElement = null;</span>
<span class="fc" id="L194">        boolean firstToken = false;</span>

        try {
<span class="fc bfc" id="L197" title="All 2 branches covered.">            if (mechCtxt == null) {</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">                if (myCred != null) {</span>
                    try {
<span class="fc" id="L200">                        credElement = myCred.getElement(mechOid, true);</span>
<span class="nc" id="L201">                    } catch (GSSException ge) {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">                        if (GSSUtil.isSpNegoMech(mechOid) &amp;&amp;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                            ge.getMajor() == GSSException.NO_CRED) {</span>
<span class="nc" id="L204">                            credElement = myCred.getElement</span>
<span class="nc" id="L205">                                (myCred.getMechs()[0], true);</span>
                        } else {
<span class="nc" id="L207">                            throw ge;</span>
                        }
<span class="fc" id="L209">                    }</span>
                }
<span class="fc" id="L211">                GSSNameSpi nameElement = targName.getElement(mechOid);</span>
<span class="fc" id="L212">                mechCtxt = gssManager.getMechanismContext(nameElement,</span>
                                                          credElement,
                                                          reqLifetime,
                                                          mechOid);
<span class="fc" id="L216">                mechCtxt.requestConf(reqConfState);</span>
<span class="fc" id="L217">                mechCtxt.requestInteg(reqIntegState);</span>
<span class="fc" id="L218">                mechCtxt.requestCredDeleg(reqCredDelegState);</span>
<span class="fc" id="L219">                mechCtxt.requestMutualAuth(reqMutualAuthState);</span>
<span class="fc" id="L220">                mechCtxt.requestReplayDet(reqReplayDetState);</span>
<span class="fc" id="L221">                mechCtxt.requestSequenceDet(reqSequenceDetState);</span>
<span class="fc" id="L222">                mechCtxt.requestAnonymity(reqAnonState);</span>
<span class="fc" id="L223">                mechCtxt.setChannelBinding(channelBindings);</span>
<span class="fc" id="L224">                mechCtxt.requestDelegPolicy(reqDelegPolicyState);</span>

<span class="fc" id="L226">                objId = new ObjectIdentifier(mechOid.toString());</span>

<span class="fc" id="L228">                currentState = IN_PROGRESS;</span>
<span class="fc" id="L229">                firstToken = true;</span>
<span class="fc" id="L230">            } else {</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                if (mechCtxt.getProvider().getName().equals(&quot;SunNativeGSS&quot;) ||</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">                    GSSUtil.isSpNegoMech(mechOid)) {</span>
                    // do not parse GSS header for native provider or SPNEGO
                    // mech
                } else {
                    // parse GSS header
<span class="fc" id="L237">                    gssHeader = new GSSHeader(inStream);</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">                    if (!gssHeader.getOid().equals((Object) objId))</span>
<span class="nc" id="L239">                        throw new GSSExceptionImpl</span>
                            (GSSException.DEFECTIVE_TOKEN,
                             &quot;Mechanism not equal to &quot; +
<span class="nc" id="L242">                             mechOid.toString() +</span>
                             &quot; in initSecContext token&quot;);
<span class="fc" id="L244">                    inTokenLen = gssHeader.getMechTokenLength();</span>
                }
            }

<span class="fc" id="L248">            byte[] obuf = mechCtxt.initSecContext(inStream, inTokenLen);</span>

<span class="fc" id="L250">            int retVal = 0;</span>

<span class="fc bfc" id="L252" title="All 2 branches covered.">            if (obuf != null) {</span>
<span class="fc" id="L253">                retVal = obuf.length;</span>
<span class="pc bpc" id="L254" title="2 of 4 branches missed.">                if (mechCtxt.getProvider().getName().equals(&quot;SunNativeGSS&quot;) ||</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                    (!firstToken &amp;&amp; GSSUtil.isSpNegoMech(mechOid))) {</span>
                    // do not add GSS header for native provider or SPNEGO
                    // except for the first SPNEGO token
                } else {
                    // add GSS header
<span class="fc" id="L260">                    gssHeader = new GSSHeader(objId, obuf.length);</span>
<span class="fc" id="L261">                    retVal += gssHeader.encode(outStream);</span>
                }
<span class="fc" id="L263">                outStream.write(obuf);</span>
            }

<span class="fc bfc" id="L266" title="All 2 branches covered.">            if (mechCtxt.isEstablished())</span>
<span class="fc" id="L267">                currentState = READY;</span>

<span class="fc" id="L269">            return retVal;</span>

<span class="nc" id="L271">        } catch (IOException e) {</span>
<span class="nc" id="L272">            throw new GSSExceptionImpl(GSSException.DEFECTIVE_TOKEN,</span>
<span class="nc" id="L273">                                   e.getMessage());</span>
        }
    }

    public byte[] acceptSecContext(byte inTok[], int offset, int len)
        throws GSSException {

        /*
         * Usually initial GSS token containing a Kerberos AP-REP is less
         * than 100 bytes.
         */
<span class="fc" id="L284">        ByteArrayOutputStream bos = new ByteArrayOutputStream(100);</span>
<span class="fc" id="L285">        acceptSecContext(new ByteArrayInputStream(inTok, offset, len),</span>
                         bos);
<span class="fc" id="L287">        byte[] out = bos.toByteArray();</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        return (out.length == 0) ? null : out;</span>
    }

    public void acceptSecContext(InputStream inStream,
                                 OutputStream outStream) throws GSSException {

<span class="pc bpc" id="L294" title="3 of 4 branches missed.">        if (mechCtxt != null &amp;&amp; currentState != IN_PROGRESS) {</span>
<span class="nc" id="L295">            throw new GSSExceptionImpl(GSSException.FAILURE,</span>
                                       &quot;Illegal call to acceptSecContext&quot;);
        }

<span class="fc" id="L299">        GSSHeader gssHeader = null;</span>
<span class="fc" id="L300">        int inTokenLen = -1;</span>
<span class="fc" id="L301">        GSSCredentialSpi credElement = null;</span>

        try {
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">            if (mechCtxt == null) {</span>
                // mechOid will be null for an acceptor's context
<span class="fc" id="L306">                gssHeader = new GSSHeader(inStream);</span>
<span class="fc" id="L307">                inTokenLen = gssHeader.getMechTokenLength();</span>

                /*
                 * Convert ObjectIdentifier to Oid
                 */
<span class="fc" id="L312">                objId = gssHeader.getOid();</span>
<span class="fc" id="L313">                mechOid = new Oid(objId.toString());</span>
                // System.out.println(&quot;Entered GSSContextImpl.acceptSecContext&quot;
                //                      + &quot; with mechanism = &quot; + mechOid);
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">                if (myCred != null) {</span>
<span class="fc" id="L317">                    credElement = myCred.getElement(mechOid, false);</span>
                }

<span class="fc" id="L320">                mechCtxt = gssManager.getMechanismContext(credElement,</span>
                                                          mechOid);
<span class="fc" id="L322">                mechCtxt.setChannelBinding(channelBindings);</span>

<span class="fc" id="L324">                currentState = IN_PROGRESS;</span>
            } else {
<span class="nc bnc" id="L326" title="All 2 branches missed.">                if (mechCtxt.getProvider().getName().equals(&quot;SunNativeGSS&quot;) ||</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                    (GSSUtil.isSpNegoMech(mechOid))) {</span>
                    // do not parse GSS header for native provider and SPNEGO
                } else {
                    // parse GSS Header
<span class="nc" id="L331">                    gssHeader = new GSSHeader(inStream);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                    if (!gssHeader.getOid().equals((Object) objId))</span>
<span class="nc" id="L333">                        throw new GSSExceptionImpl</span>
                            (GSSException.DEFECTIVE_TOKEN,
                             &quot;Mechanism not equal to &quot; +
<span class="nc" id="L336">                             mechOid.toString() +</span>
                             &quot; in acceptSecContext token&quot;);
<span class="nc" id="L338">                    inTokenLen = gssHeader.getMechTokenLength();</span>
                }
            }

<span class="fc" id="L342">            byte[] obuf = mechCtxt.acceptSecContext(inStream, inTokenLen);</span>

<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            if (obuf != null) {</span>
<span class="fc" id="L345">                int retVal = obuf.length;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                if (mechCtxt.getProvider().getName().equals(&quot;SunNativeGSS&quot;) ||</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">                    (GSSUtil.isSpNegoMech(mechOid))) {</span>
                    // do not add GSS header for native provider and SPNEGO
                } else {
                    // add GSS header
<span class="fc" id="L351">                    gssHeader = new GSSHeader(objId, obuf.length);</span>
<span class="fc" id="L352">                    retVal += gssHeader.encode(outStream);</span>
                }
<span class="fc" id="L354">                outStream.write(obuf);</span>
            }

<span class="pc bpc" id="L357" title="1 of 2 branches missed.">            if (mechCtxt.isEstablished()) {</span>
<span class="fc" id="L358">                currentState = READY;</span>
            }
<span class="nc" id="L360">        } catch (IOException e) {</span>
<span class="nc" id="L361">            throw new GSSExceptionImpl(GSSException.DEFECTIVE_TOKEN,</span>
<span class="nc" id="L362">                                   e.getMessage());</span>
<span class="fc" id="L363">        }</span>
<span class="fc" id="L364">    }</span>

    public boolean isEstablished() {
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (mechCtxt == null)</span>
<span class="fc" id="L368">            return false;</span>
        else
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">            return (currentState == READY);</span>
    }

    public int getWrapSizeLimit(int qop, boolean confReq,
                                int maxTokenSize) throws GSSException {
<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L376">            return mechCtxt.getWrapSizeLimit(qop, confReq, maxTokenSize);</span>
        else
<span class="nc" id="L378">            throw new GSSExceptionImpl(GSSException.NO_CONTEXT,</span>
                                  &quot;No mechanism context yet!&quot;);
    }

    public byte[] wrap(byte inBuf[], int offset, int len,
                       MessageProp msgProp) throws GSSException {
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (mechCtxt != null)</span>
<span class="fc" id="L385">            return mechCtxt.wrap(inBuf, offset, len, msgProp);</span>
        else
<span class="nc" id="L387">            throw new GSSExceptionImpl(GSSException.NO_CONTEXT,</span>
                                   &quot;No mechanism context yet!&quot;);
    }

    public void wrap(InputStream inStream, OutputStream outStream,
                     MessageProp msgProp) throws GSSException {
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L394">            mechCtxt.wrap(inStream, outStream, msgProp);</span>
        else
<span class="nc" id="L396">            throw new GSSExceptionImpl(GSSException.NO_CONTEXT,</span>
                                  &quot;No mechanism context yet!&quot;);
<span class="nc" id="L398">    }</span>

    public byte [] unwrap(byte[] inBuf, int offset, int len,
                          MessageProp msgProp) throws GSSException {
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (mechCtxt != null)</span>
<span class="fc" id="L403">            return mechCtxt.unwrap(inBuf, offset, len, msgProp);</span>
        else
<span class="nc" id="L405">            throw new GSSExceptionImpl(GSSException.NO_CONTEXT,</span>
                                  &quot;No mechanism context yet!&quot;);
    }

    public void unwrap(InputStream inStream, OutputStream outStream,
                       MessageProp msgProp) throws GSSException {
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L412">            mechCtxt.unwrap(inStream, outStream, msgProp);</span>
        else
<span class="nc" id="L414">            throw new GSSExceptionImpl(GSSException.NO_CONTEXT,</span>
                                  &quot;No mechanism context yet!&quot;);
<span class="nc" id="L416">    }</span>

    public byte[] getMIC(byte []inMsg, int offset, int len,
                         MessageProp msgProp) throws GSSException {
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">        if (mechCtxt != null)</span>
<span class="fc" id="L421">            return mechCtxt.getMIC(inMsg, offset, len, msgProp);</span>
        else
<span class="nc" id="L423">            throw new GSSExceptionImpl(GSSException.NO_CONTEXT,</span>
                                  &quot;No mechanism context yet!&quot;);
    }

    public void getMIC(InputStream inStream, OutputStream outStream,
                       MessageProp msgProp) throws GSSException {
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L430">            mechCtxt.getMIC(inStream, outStream, msgProp);</span>
        else
<span class="nc" id="L432">            throw new GSSExceptionImpl(GSSException.NO_CONTEXT,</span>
                                  &quot;No mechanism context yet!&quot;);
<span class="nc" id="L434">    }</span>

    public void verifyMIC(byte[] inTok, int tokOffset, int tokLen,
                          byte[] inMsg, int msgOffset, int msgLen,
                          MessageProp msgProp) throws GSSException {
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        if (mechCtxt != null)</span>
<span class="fc" id="L440">            mechCtxt.verifyMIC(inTok, tokOffset, tokLen,</span>
                               inMsg, msgOffset, msgLen, msgProp);
        else
<span class="nc" id="L443">            throw new GSSExceptionImpl(GSSException.NO_CONTEXT,</span>
                                  &quot;No mechanism context yet!&quot;);
<span class="fc" id="L445">    }</span>

    public void verifyMIC(InputStream tokStream, InputStream msgStream,
                          MessageProp msgProp) throws GSSException {
<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L450">            mechCtxt.verifyMIC(tokStream, msgStream, msgProp);</span>
        else
<span class="nc" id="L452">            throw new GSSExceptionImpl(GSSException.NO_CONTEXT,</span>
                                  &quot;No mechanism context yet!&quot;);
<span class="nc" id="L454">    }</span>

    public byte[] export() throws GSSException {
        // Defaults to null to match old behavior
<span class="nc" id="L458">        byte[] result = null;</span>
        // Only allow context export from native provider since JGSS
        // still has not defined its own interprocess token format
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (mechCtxt.isTransferable() &amp;&amp;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">            mechCtxt.getProvider().getName().equals(&quot;SunNativeGSS&quot;)) {</span>
<span class="nc" id="L463">            result = mechCtxt.export();</span>
        }
<span class="nc" id="L465">        return result;</span>
    }

    public void requestMutualAuth(boolean state) throws GSSException {
<span class="pc bpc" id="L469" title="2 of 4 branches missed.">        if (mechCtxt == null &amp;&amp; initiator)</span>
<span class="fc" id="L470">            reqMutualAuthState = state;</span>
<span class="fc" id="L471">    }</span>

    public void requestReplayDet(boolean state) throws GSSException {
<span class="nc bnc" id="L474" title="All 4 branches missed.">        if (mechCtxt == null &amp;&amp; initiator)</span>
<span class="nc" id="L475">            reqReplayDetState = state;</span>
<span class="nc" id="L476">    }</span>

    public void requestSequenceDet(boolean state) throws GSSException {
<span class="nc bnc" id="L479" title="All 4 branches missed.">        if (mechCtxt == null &amp;&amp; initiator)</span>
<span class="nc" id="L480">            reqSequenceDetState = state;</span>
<span class="nc" id="L481">    }</span>

    public void requestCredDeleg(boolean state) throws GSSException {
<span class="pc bpc" id="L484" title="2 of 4 branches missed.">        if (mechCtxt == null &amp;&amp; initiator)</span>
<span class="fc" id="L485">            reqCredDelegState = state;</span>
<span class="fc" id="L486">    }</span>

    public void requestAnonymity(boolean state) throws GSSException {
<span class="nc bnc" id="L489" title="All 4 branches missed.">        if (mechCtxt == null &amp;&amp; initiator)</span>
<span class="nc" id="L490">            reqAnonState = state;</span>
<span class="nc" id="L491">    }</span>

    public void requestConf(boolean state) throws GSSException {
<span class="pc bpc" id="L494" title="1 of 4 branches missed.">        if (mechCtxt == null &amp;&amp; initiator)</span>
<span class="fc" id="L495">            reqConfState = state;</span>
<span class="fc" id="L496">    }</span>

    public void requestInteg(boolean state) throws GSSException {
<span class="pc bpc" id="L499" title="1 of 4 branches missed.">        if (mechCtxt == null &amp;&amp; initiator)</span>
<span class="fc" id="L500">            reqIntegState = state;</span>
<span class="fc" id="L501">    }</span>

    public void requestLifetime(int lifetime) throws GSSException {
<span class="nc bnc" id="L504" title="All 4 branches missed.">        if (mechCtxt == null &amp;&amp; initiator)</span>
<span class="nc" id="L505">            reqLifetime = lifetime;</span>
<span class="nc" id="L506">    }</span>

    public void setChannelBinding(ChannelBinding channelBindings)
        throws GSSException {

<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (mechCtxt == null)</span>
<span class="nc" id="L512">            this.channelBindings = channelBindings;</span>

<span class="nc" id="L514">    }</span>

    public boolean getCredDelegState() {
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">        if (mechCtxt != null)</span>
<span class="fc" id="L518">            return mechCtxt.getCredDelegState();</span>
        else
<span class="nc" id="L520">            return reqCredDelegState;</span>
    }

    public boolean getMutualAuthState() {
<span class="nc bnc" id="L524" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L525">            return mechCtxt.getMutualAuthState();</span>
        else
<span class="nc" id="L527">            return reqMutualAuthState;</span>
    }

    public boolean getReplayDetState() {
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L532">            return mechCtxt.getReplayDetState();</span>
        else
<span class="nc" id="L534">            return reqReplayDetState;</span>
    }

    public boolean getSequenceDetState() {
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L539">            return mechCtxt.getSequenceDetState();</span>
        else
<span class="nc" id="L541">            return reqSequenceDetState;</span>
    }

    public boolean getAnonymityState() {
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L546">            return mechCtxt.getAnonymityState();</span>
        else
<span class="nc" id="L548">            return reqAnonState;</span>
    }

    public boolean isTransferable() throws GSSException {
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L553">            return mechCtxt.isTransferable();</span>
        else
<span class="nc" id="L555">            return false;</span>
    }

    public boolean isProtReady() {
<span class="nc bnc" id="L559" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L560">            return mechCtxt.isProtReady();</span>
        else
<span class="nc" id="L562">            return false;</span>
    }

    public boolean getConfState() {
<span class="nc bnc" id="L566" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L567">            return mechCtxt.getConfState();</span>
        else
<span class="nc" id="L569">            return reqConfState;</span>
    }

    public boolean getIntegState() {
<span class="nc bnc" id="L573" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L574">            return mechCtxt.getIntegState();</span>
        else
<span class="nc" id="L576">            return reqIntegState;</span>
    }

    public int getLifetime() {
<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L581">            return mechCtxt.getLifetime();</span>
        else
<span class="nc" id="L583">            return reqLifetime;</span>
    }

    public GSSName getSrcName() throws GSSException {
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (srcName == null) {</span>
<span class="nc" id="L588">            srcName = GSSNameImpl.wrapElement</span>
<span class="nc" id="L589">                (gssManager, mechCtxt.getSrcName());</span>
        }
<span class="nc" id="L591">        return srcName;</span>
    }

    public GSSName getTargName() throws GSSException {
<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (targName == null) {</span>
<span class="nc" id="L596">            targName = GSSNameImpl.wrapElement</span>
<span class="nc" id="L597">                (gssManager, mechCtxt.getTargName());</span>
        }
<span class="nc" id="L599">        return targName;</span>
    }

    public Oid getMech() throws GSSException {
<span class="nc bnc" id="L603" title="All 2 branches missed.">        if (mechCtxt != null) {</span>
<span class="nc" id="L604">            return mechCtxt.getMech();</span>
        }
<span class="nc" id="L606">        return mechOid;</span>
    }

    public GSSCredential getDelegCred() throws GSSException {

<span class="pc bpc" id="L611" title="1 of 2 branches missed.">        if (mechCtxt == null)</span>
<span class="nc" id="L612">            throw new GSSExceptionImpl(GSSException.NO_CONTEXT,</span>
                                   &quot;No mechanism context yet!&quot;);
<span class="fc" id="L614">        GSSCredentialSpi delCredElement = mechCtxt.getDelegCred();</span>
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">        return (delCredElement == null ?</span>
            null : new GSSCredentialImpl(gssManager, delCredElement));
    }

    public boolean isInitiator() throws GSSException {
<span class="fc" id="L620">        return initiator;</span>
    }

    public void dispose() throws GSSException {
<span class="nc" id="L624">        currentState = DELETED;</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">        if (mechCtxt != null) {</span>
<span class="nc" id="L626">            mechCtxt.dispose();</span>
<span class="nc" id="L627">            mechCtxt = null;</span>
        }
<span class="nc" id="L629">        myCred = null;</span>
<span class="nc" id="L630">        srcName = null;</span>
<span class="nc" id="L631">        targName = null;</span>
<span class="nc" id="L632">    }</span>

    // ExtendedGSSContext methods:

    @Override
    public Object inquireSecContext(InquireType type) throws GSSException {
<span class="nc" id="L638">        SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">        if (security != null) {</span>
<span class="nc" id="L640">            security.checkPermission(new InquireSecContextPermission(type.toString()));</span>
        }
<span class="nc bnc" id="L642" title="All 2 branches missed.">        if (mechCtxt == null) {</span>
<span class="nc" id="L643">            throw new GSSException(GSSException.NO_CONTEXT);</span>
        }
<span class="nc" id="L645">        return mechCtxt.inquireSecContext(type);</span>
    }

    @Override
    public void requestDelegPolicy(boolean state) throws GSSException {
<span class="nc bnc" id="L650" title="All 4 branches missed.">        if (mechCtxt == null &amp;&amp; initiator)</span>
<span class="nc" id="L651">            reqDelegPolicyState = state;</span>
<span class="nc" id="L652">    }</span>

    @Override
    public boolean getDelegPolicyState() {
<span class="nc bnc" id="L656" title="All 2 branches missed.">        if (mechCtxt != null)</span>
<span class="nc" id="L657">            return mechCtxt.getDelegPolicyState();</span>
        else
<span class="nc" id="L659">            return reqDelegPolicyState;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>