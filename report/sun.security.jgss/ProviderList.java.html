<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ProviderList.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.jgss</a> &gt; <span class="el_source">ProviderList.java</span></div><h1>ProviderList.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2009, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.jgss;

import java.lang.reflect.InvocationTargetException;
import org.ietf.jgss.*;
import java.security.AccessController;
import java.security.Provider;
import java.security.Security;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Enumeration;
import java.util.Iterator;
import sun.security.jgss.spi.*;
import sun.security.jgss.wrapper.NativeGSSFactory;
import sun.security.jgss.wrapper.SunNativeProvider;
import sun.security.action.GetPropertyAction;

/**
 * This class stores the list of providers that this
 * GSS-Implementation is configured to use. The GSSManagerImpl class
 * queries this class whenever it needs a mechanism's factory.&lt;p&gt;
 *
 * This class stores an ordered list of pairs of the form
 * &lt;provider, oid&gt;. When it attempts to instantiate a mechanism
 * defined by oid o, it steps through the list looking for an entry
 * with oid=o, or with oid=null. (An entry with oid=null matches all
 * mechanisms.) When it finds such an entry, the corresponding
 * provider is approached for the mechanism's factory class.
 * At instantiation time this list in initialized to contain those
 * system wide providers that contain a property of the form
 * &quot;GssApiMechanism.x.y.z...&quot; where &quot;x.y.z...&quot; is a numeric object
 * identifier with numbers x, y, z, etc. Such a property is defined
 * to map to that provider's implementation of the MechanismFactory
 * interface for the mechanism x.y.z...
 * As and when a MechanismFactory is instantiated, it is
 * cached for future use. &lt;p&gt;
 *
 * An application can cause more providers to be added by means of
 * the addProviderAtFront and addProviderAtEnd methods on
 * GSSManager which get delegated to this class. The
 * addProviderAtFront method can also cause a change in the ordering
 * of the providers without adding any new providers, by causing a
 * provider to move up in a list. The method addProviderAtEnd can
 * only add providers at the end of the list if they are not already
 * in the list. The rationale is that an application will call
 * addProviderAtFront when it wants a provider to be used in
 * preference over the default ones. And it will call
 * addProviderAtEnd when it wants a provider to be used in case
 * the system ones don't suffice.&lt;p&gt;
 *
 * If a mechanism's factory is being obtained from a provider as a
 * result of encountering a entryof the form &lt;provider, oid&gt; where
 * oid is non-null, then the assumption is that the application added
 * this entry and it wants this mechanism to be obtained from this
 * provider. Thus is the provider does not actually contain the
 * requested mechanism, an exception will be thrown. However, if the
 * entry were of the form &lt;provider, null&gt;, then it is viewed more
 * liberally and is simply skipped over if the provider does not claim to
 * support the requested mechanism.
 */

public final class ProviderList {

    private static final String PROV_PROP_PREFIX = &quot;GssApiMechanism.&quot;;
<span class="fc" id="L90">    private static final int PROV_PROP_PREFIX_LEN =</span>
<span class="fc" id="L91">        PROV_PROP_PREFIX.length();</span>

    private static final String SPI_MECH_FACTORY_TYPE
        = &quot;sun.security.jgss.spi.MechanismFactory&quot;;

    // Undocumented property?
    private static final String DEFAULT_MECH_PROP =
        &quot;sun.security.jgss.mechanism&quot;;

    public static final Oid DEFAULT_MECH_OID;

    static {
        /*
         * Set the default mechanism. Kerberos v5 is the default
         * mechanism unless it is overridden by a system property.
         * with a valid OID value
         */
<span class="fc" id="L108">        Oid defOid = null;</span>
<span class="fc" id="L109">        String defaultOidStr = AccessController.doPrivileged</span>
<span class="fc" id="L110">            (new GetPropertyAction(DEFAULT_MECH_PROP));</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (defaultOidStr != null) {</span>
<span class="fc" id="L112">            defOid = GSSUtil.createOid(defaultOidStr);</span>
        }
<span class="fc bfc" id="L114" title="All 2 branches covered.">        DEFAULT_MECH_OID =</span>
            (defOid == null ? GSSUtil.GSS_KRB5_MECH_OID : defOid);
<span class="fc" id="L116">   }</span>

<span class="fc" id="L118">    private ArrayList&lt;PreferencesEntry&gt; preferences =</span>
                        new ArrayList&lt;PreferencesEntry&gt;(5);
<span class="fc" id="L120">    private HashMap&lt;PreferencesEntry, MechanismFactory&gt; factories =</span>
                        new HashMap&lt;PreferencesEntry, MechanismFactory&gt;(5);
<span class="fc" id="L122">    private HashSet&lt;Oid&gt; mechs = new HashSet&lt;Oid&gt;(5);</span>

    final private GSSCaller caller;

<span class="fc" id="L126">    public ProviderList(GSSCaller caller, boolean useNative) {</span>
<span class="fc" id="L127">        this.caller = caller;</span>
        Provider[] provList;
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (useNative) {</span>
<span class="fc" id="L130">            provList = new Provider[1];</span>
<span class="fc" id="L131">            provList[0] = new SunNativeProvider();</span>
        } else {
<span class="fc" id="L133">            provList = Security.getProviders();</span>
        }

<span class="fc bfc" id="L136" title="All 2 branches covered.">        for (int i = 0; i &lt; provList.length; i++) {</span>
<span class="fc" id="L137">            Provider prov = provList[i];</span>
            try {
<span class="fc" id="L139">                addProviderAtEnd(prov, null);</span>
<span class="nc" id="L140">            } catch (GSSException ge) {</span>
                // Move on to the next provider
<span class="nc" id="L142">                GSSUtil.debug(&quot;Error in adding provider &quot; +</span>
<span class="nc" id="L143">                              prov.getName() + &quot;: &quot; + ge);</span>
<span class="fc" id="L144">            }</span>
        } // End of for loop
<span class="fc" id="L146">    }</span>

    /**
     * Determines if the given provider property represents a GSS-API
     * Oid to MechanismFactory mapping.
     * @return true if this is a GSS-API property, false otherwise.
     */
    private boolean isMechFactoryProperty(String prop) {
<span class="fc bfc" id="L154" title="All 2 branches covered.">        return (prop.startsWith(PROV_PROP_PREFIX) ||</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">                prop.regionMatches(true, 0, // Try ignoring case</span>
                                   PROV_PROP_PREFIX, 0,
                                   PROV_PROP_PREFIX_LEN));
    }

    private Oid getOidFromMechFactoryProperty(String prop)
        throws GSSException {

<span class="fc" id="L163">        String oidPart = prop.substring(PROV_PROP_PREFIX_LEN);</span>
<span class="fc" id="L164">        return new Oid(oidPart);</span>
    }

    // So the existing code do not have to be changed
    synchronized public MechanismFactory getMechFactory(Oid mechOid)
        throws GSSException {
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (mechOid == null) mechOid = ProviderList.DEFAULT_MECH_OID;</span>
<span class="fc" id="L171">        return getMechFactory(mechOid, null);</span>
    }

    /**
     * Obtains a MechanismFactory for a given mechanism. If the
     * specified provider is not null, then the impl from the
     * provider is used. Otherwise, the most preferred impl based
     * on the configured preferences is used.
     * @param mechOid the oid of the desired mechanism
     * @return a MechanismFactory for the desired mechanism.
     * @throws GSSException when the specified provider does not
     * support the desired mechanism, or when no provider supports
     * the desired mechanism.
     */
    synchronized public MechanismFactory getMechFactory(Oid mechOid,
                                                        Provider p)
        throws GSSException {

<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (mechOid == null) mechOid = ProviderList.DEFAULT_MECH_OID;</span>

<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (p == null) {</span>
            // Iterate thru all preferences to find right provider
            String className;
            PreferencesEntry entry;

<span class="fc" id="L196">            Iterator&lt;PreferencesEntry&gt; list = preferences.iterator();</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            while (list.hasNext()) {</span>
<span class="fc" id="L198">                entry = list.next();</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">                if (entry.impliesMechanism(mechOid)) {</span>
<span class="fc" id="L200">                    MechanismFactory retVal = getMechFactory(entry, mechOid);</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">                    if (retVal != null) return retVal;</span>
<span class="nc" id="L202">                }</span>
            } // end of while loop
<span class="nc" id="L204">            throw new GSSExceptionImpl(GSSException.BAD_MECH, mechOid);</span>
        } else {
            // Use the impl from the specified provider; return null if the
            // the mech is unsupported by the specified provider.
<span class="fc" id="L208">            PreferencesEntry entry = new PreferencesEntry(p, mechOid);</span>
<span class="fc" id="L209">            return getMechFactory(entry, mechOid);</span>
        }
    }

    /**
     * Helper routine that uses a preferences entry to obtain an
     * implementation of a MechanismFactory from it.
     * @param e the preferences entry that contains the provider and
     * either a null of an explicit oid that matched the oid of the
     * desired mechanism.
     * @param mechOid the oid of the desired mechanism
     * @throws GSSException If the application explicitly requested
     * this entry's provider to be used for the desired mechanism but
     * some problem is encountered
     */
    private MechanismFactory getMechFactory(PreferencesEntry e, Oid mechOid)
        throws GSSException {
<span class="fc" id="L226">        Provider p = e.getProvider();</span>

        /*
         * See if a MechanismFactory was previously instantiated for
         * this provider and mechanism combination.
         */
<span class="fc" id="L232">        PreferencesEntry searchEntry = new PreferencesEntry(p, mechOid);</span>
<span class="fc" id="L233">        MechanismFactory retVal = factories.get(searchEntry);</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (retVal == null) {</span>
            /*
             * Apparently not. Now try to instantiate this class from
             * the provider.
             */
<span class="fc" id="L239">            String prop = PROV_PROP_PREFIX + mechOid.toString();</span>
<span class="fc" id="L240">            String className = p.getProperty(prop);</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            if (className != null) {</span>
<span class="fc" id="L242">                retVal = getMechFactoryImpl(p, className, mechOid, caller);</span>
<span class="fc" id="L243">                factories.put(searchEntry, retVal);</span>
            } else {
                /*
                 * This provider does not support this mechanism.
                 * If the application explicitly requested that
                 * this provider be used for this mechanism, then
                 * throw an exception
                 */
<span class="nc bnc" id="L251" title="All 2 branches missed.">                if (e.getOid() != null) {</span>
<span class="nc" id="L252">                    throw new GSSExceptionImpl(GSSException.BAD_MECH,</span>
<span class="nc" id="L253">                         &quot;Provider &quot; + p.getName() +</span>
                         &quot; does not support mechanism &quot; + mechOid);
                }
            }
        }
<span class="fc" id="L258">        return retVal;</span>
    }

    /**
     * Helper routine to obtain a MechanismFactory implementation
     * from the same class loader as the provider of this
     * implementation.
     * @param p the provider whose classloader must be used for
     * instantiating the desired MechanismFactory
     * @ param className the name of the MechanismFactory class
     * @throws GSSException If some error occurs when trying to
     * instantiate this MechanismFactory.
     */
    private static MechanismFactory getMechFactoryImpl(Provider p,
                                                       String className,
                                                       Oid mechOid,
                                                       GSSCaller caller)
        throws GSSException {

        try {
<span class="fc" id="L278">            Class&lt;?&gt; baseClass = Class.forName(SPI_MECH_FACTORY_TYPE);</span>

            /*
             * Load the implementation class with the same class loader
             * that was used to load the provider.
             * In order to get the class loader of a class, the
             * caller's class loader must be the same as or an ancestor of
             * the class loader being returned. Otherwise, the caller must
             * have &quot;getClassLoader&quot; permission, or a SecurityException
             * will be thrown.
             */

<span class="fc" id="L290">            ClassLoader cl = p.getClass().getClassLoader();</span>
            Class&lt;?&gt; implClass;
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">            if (cl != null) {</span>
<span class="nc" id="L293">                implClass = cl.loadClass(className);</span>
            } else {
<span class="fc" id="L295">                implClass = Class.forName(className);</span>
            }

<span class="pc bpc" id="L298" title="1 of 2 branches missed.">            if (baseClass.isAssignableFrom(implClass)) {</span>

<span class="fc" id="L300">                java.lang.reflect.Constructor&lt;?&gt; c =</span>
<span class="fc" id="L301">                                implClass.getConstructor(GSSCaller.class);</span>
<span class="fc" id="L302">                MechanismFactory mf = (MechanismFactory) (c.newInstance(caller));</span>

<span class="fc bfc" id="L304" title="All 2 branches covered.">                if (mf instanceof NativeGSSFactory) {</span>
<span class="fc" id="L305">                    ((NativeGSSFactory) mf).setMech(mechOid);</span>
                }
<span class="fc" id="L307">                return mf;</span>
            } else {
<span class="nc" id="L309">                throw createGSSException(p, className, &quot;is not a &quot; +</span>
                                         SPI_MECH_FACTORY_TYPE, null);
            }
<span class="nc" id="L312">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L313">            throw createGSSException(p, className, &quot;cannot be created&quot;, e);</span>
<span class="nc" id="L314">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L315">            throw createGSSException(p, className, &quot;cannot be created&quot;, e);</span>
<span class="nc" id="L316">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L317">            throw createGSSException(p, className, &quot;cannot be created&quot;, e);</span>
<span class="nc" id="L318">        } catch (InstantiationException e) {</span>
<span class="nc" id="L319">            throw createGSSException(p, className, &quot;cannot be created&quot;, e);</span>
<span class="nc" id="L320">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L321">            throw createGSSException(p, className, &quot;cannot be created&quot;, e);</span>
<span class="nc" id="L322">        } catch (SecurityException e) {</span>
<span class="nc" id="L323">            throw createGSSException(p, className, &quot;cannot be created&quot;, e);</span>
        }
    }

    // Only used by getMechFactoryImpl
    private static GSSException createGSSException(Provider p,
                                                   String className,
                                                   String trailingMsg,
                                                   Exception cause) {
<span class="nc" id="L332">        String errClassInfo = className + &quot; configured by &quot; +</span>
<span class="nc" id="L333">            p.getName() + &quot; for GSS-API Mechanism Factory &quot;;</span>
<span class="nc" id="L334">        return new GSSExceptionImpl(GSSException.BAD_MECH,</span>
                                    errClassInfo + trailingMsg,
                                    cause);
    }

    public Oid[] getMechs() {
<span class="fc" id="L340">        return mechs.toArray(new Oid[] {});</span>
    }

    synchronized public void addProviderAtFront(Provider p, Oid mechOid)
        throws GSSException {

<span class="nc" id="L346">        PreferencesEntry newEntry = new PreferencesEntry(p, mechOid);</span>
        PreferencesEntry oldEntry;
        boolean foundSomeMech;

<span class="nc" id="L350">        Iterator&lt;PreferencesEntry&gt; list = preferences.iterator();</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">        while (list.hasNext()) {</span>
<span class="nc" id="L352">            oldEntry = list.next();</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (newEntry.implies(oldEntry))</span>
<span class="nc" id="L354">                list.remove();</span>
        }

<span class="nc bnc" id="L357" title="All 2 branches missed.">        if (mechOid == null) {</span>
<span class="nc" id="L358">            foundSomeMech = addAllMechsFromProvider(p);</span>
        } else {
<span class="nc" id="L360">            String oidStr = mechOid.toString();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">            if (p.getProperty(PROV_PROP_PREFIX + oidStr) == null)</span>
<span class="nc" id="L362">                throw new GSSExceptionImpl(GSSException.BAD_MECH,</span>
<span class="nc" id="L363">                                           &quot;Provider &quot; + p.getName()</span>
                                           + &quot; does not support &quot;
                                           + oidStr);
<span class="nc" id="L366">            mechs.add(mechOid);</span>
<span class="nc" id="L367">            foundSomeMech = true;</span>
        }

<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (foundSomeMech) {</span>
<span class="nc" id="L371">            preferences.add(0, newEntry);</span>
        }
<span class="nc" id="L373">    }</span>

    synchronized public void addProviderAtEnd(Provider p, Oid mechOid)
        throws GSSException {

<span class="fc" id="L378">        PreferencesEntry newEntry = new PreferencesEntry(p, mechOid);</span>
        PreferencesEntry oldEntry;
        boolean foundSomeMech;

<span class="fc" id="L382">        Iterator&lt;PreferencesEntry&gt; list = preferences.iterator();</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">        while (list.hasNext()) {</span>
<span class="fc" id="L384">            oldEntry = list.next();</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">            if (oldEntry.implies(newEntry))</span>
<span class="nc" id="L386">                return;</span>
        }

        // System.out.println(&quot;addProviderAtEnd: No it is not redundant&quot;);

<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (mechOid == null)</span>
<span class="fc" id="L392">            foundSomeMech = addAllMechsFromProvider(p);</span>
        else {
<span class="nc" id="L394">            String oidStr = mechOid.toString();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">            if (p.getProperty(PROV_PROP_PREFIX + oidStr) == null)</span>
<span class="nc" id="L396">                throw new GSSExceptionImpl(GSSException.BAD_MECH,</span>
<span class="nc" id="L397">                                       &quot;Provider &quot; + p.getName()</span>
                                       + &quot; does not support &quot;
                                       + oidStr);
<span class="nc" id="L400">            mechs.add(mechOid);</span>
<span class="nc" id="L401">            foundSomeMech = true;</span>
        }

<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (foundSomeMech) {</span>
<span class="fc" id="L405">            preferences.add(newEntry);</span>
        }
<span class="fc" id="L407">    }</span>

    /**
     * Helper routine to go through all properties contined in a
     * provider and add its mechanisms to the list of supported
     * mechanisms. If no default mechanism has been assinged so far,
     * it sets the default MechanismFactory and Oid as well.
     * @param p the provider to query
     * @return true if there is at least one mechanism that this
     * provider contributed, false otherwise
     */
    private boolean addAllMechsFromProvider(Provider p) {

        String prop;
<span class="fc" id="L421">        boolean retVal = false;</span>

        // Get all props for this provider
<span class="fc" id="L424">        Enumeration&lt;Object&gt; props = p.keys();</span>

        // See if there are any GSS prop's
<span class="fc bfc" id="L427" title="All 2 branches covered.">        while (props.hasMoreElements()) {</span>
<span class="fc" id="L428">            prop = (String) props.nextElement();</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">            if (isMechFactoryProperty(prop)) {</span>
                // Ok! This is a GSS provider!
                try {
<span class="fc" id="L432">                    Oid mechOid = getOidFromMechFactoryProperty(prop);</span>
<span class="fc" id="L433">                    mechs.add(mechOid);</span>
<span class="fc" id="L434">                    retVal = true;</span>
<span class="nc" id="L435">                } catch (GSSException e) {</span>
                    // Skip to next property
<span class="nc" id="L437">                    GSSUtil.debug(&quot;Ignore the invalid property &quot; +</span>
<span class="nc" id="L438">                                  prop + &quot; from provider &quot; + p.getName());</span>
<span class="pc" id="L439">                }</span>
            } // Processed GSS property
        } // while loop

<span class="fc" id="L443">        return retVal;</span>

    }

    /**
     * Stores a provider and a mechanism oid indicating that the
     * provider should be used for the mechanism. If the mechanism
     * Oid is null, then it indicates that this preference holds for
     * any mechanism.&lt;p&gt;
     *
     * The ProviderList maintains an ordered list of
     * PreferencesEntry's and iterates thru them as it tries to
     * instantiate MechanismFactory's.
     */
    private static final class PreferencesEntry {
        private Provider p;
        private Oid oid;
<span class="fc" id="L460">        PreferencesEntry(Provider p, Oid oid) {</span>
<span class="fc" id="L461">            this.p = p;</span>
<span class="fc" id="L462">            this.oid = oid;</span>
<span class="fc" id="L463">        }</span>

        public boolean equals(Object other) {
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">            if (this == other) {</span>
<span class="nc" id="L467">                return true;</span>
            }

<span class="pc bpc" id="L470" title="1 of 2 branches missed.">            if (!(other instanceof PreferencesEntry)) {</span>
<span class="nc" id="L471">                return false;</span>
            }

<span class="fc" id="L474">            PreferencesEntry that = (PreferencesEntry)other;</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">            if (this.p.getName().equals(that.p.getName())) {</span>
<span class="pc bpc" id="L476" title="2 of 4 branches missed.">                if (this.oid != null &amp;&amp; that.oid != null) {</span>
<span class="fc" id="L477">                    return this.oid.equals(that.oid);</span>
                } else {
<span class="nc bnc" id="L479" title="All 4 branches missed.">                    return (this.oid == null &amp;&amp; that.oid == null);</span>
                }
            }

<span class="fc" id="L483">            return false;</span>
        }

        public int hashCode() {
<span class="fc" id="L487">            int result = 17;</span>

<span class="fc" id="L489">            result = 37 * result + p.getName().hashCode();</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">            if (oid != null) {</span>
<span class="fc" id="L491">                result = 37 * result + oid.hashCode();</span>
            }

<span class="fc" id="L494">            return result;</span>
        }

        /**
         * Determines if a preference implies another. A preference
         * implies another if the latter is subsumed by the
         * former. e.g., &lt;Provider1, null&gt; implies &lt;Provider1, OidX&gt;
         * because the null in the former indicates that it should
         * be used for all mechanisms.
         */
        boolean implies(Object other) {

<span class="pc bpc" id="L506" title="1 of 2 branches missed.">            if (other instanceof PreferencesEntry) {</span>
<span class="fc" id="L507">                PreferencesEntry temp = (PreferencesEntry) other;</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">                return (equals(temp) ||</span>
<span class="pc bpc" id="L509" title="3 of 4 branches missed.">                        p.getName().equals(temp.p.getName()) &amp;&amp;</span>
                        oid == null);
            } else {
<span class="nc" id="L512">                return false;</span>
            }
        }

        Provider getProvider() {
<span class="fc" id="L517">            return p;</span>
        }

        Oid getOid() {
<span class="nc" id="L521">            return oid;</span>
        }

        /**
         * Determines if this entry is applicable to the desired
         * mechanism. The entry is applicable to the desired mech if
         * it contains the same oid or if it contains a null oid
         * indicating that it is applicable to all mechs.
         * @param mechOid the desired mechanism
         * @return true if the provider in this entry should be
         * queried for this mechanism.
         */
        boolean impliesMechanism(Oid oid) {
<span class="pc bpc" id="L534" title="3 of 4 branches missed.">            return (this.oid == null || this.oid.equals(oid));</span>
        }

        // For debugging
        public String toString() {
<span class="nc" id="L539">            StringBuffer buf = new StringBuffer(&quot;&lt;&quot;);</span>
<span class="nc" id="L540">            buf.append(p.getName());</span>
<span class="nc" id="L541">            buf.append(&quot;, &quot;);</span>
<span class="nc" id="L542">            buf.append(oid);</span>
<span class="nc" id="L543">            buf.append(&quot;&gt;&quot;);</span>
<span class="nc" id="L544">            return buf.toString();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>