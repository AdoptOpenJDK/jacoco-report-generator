<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GSSToken.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.jgss</a> &gt; <span class="el_source">GSSToken.java</span></div><h1>GSSToken.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.jgss;

import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.EOFException;
import sun.security.util.*;

/**
 * Utilities for processing GSS Tokens.
 *
 */

<span class="fc" id="L39">public abstract class GSSToken {</span>

    /**
     * Copies an integer value to a byte array in little endian form.
     * @param value the integer value to write
     * @param array the byte array into which the integer must be copied. It
     * is assumed that the array will be large enough to hold the 4 bytes of
     * the integer.
     */
    public static final void writeLittleEndian(int value, byte[] array) {
<span class="fc" id="L49">        writeLittleEndian(value, array, 0);</span>
<span class="fc" id="L50">    }</span>

    /**
     * Copies an integer value to a byte array in little endian form.
     * @param value the integer value to write
     * @param array the byte array into which the integer must be copied. It
     * is assumed that the array will be large enough to hold the 4 bytes of
     * the integer.
     * @param pos the position at which to start writing
     */
    public static final void writeLittleEndian(int value, byte[] array,
                                               int pos) {
<span class="fc" id="L62">        array[pos++] = (byte)(value);</span>
<span class="fc" id="L63">        array[pos++] = (byte)((value&gt;&gt;&gt;8));</span>
<span class="fc" id="L64">        array[pos++] = (byte)((value&gt;&gt;&gt;16));</span>
<span class="fc" id="L65">        array[pos++] = (byte)((value&gt;&gt;&gt;24));</span>
<span class="fc" id="L66">    }</span>

    public static final void writeBigEndian(int value, byte[] array) {
<span class="nc" id="L69">        writeBigEndian(value, array, 0);</span>
<span class="nc" id="L70">    }</span>

    public static final void writeBigEndian(int value, byte[] array,
                                               int pos) {
<span class="fc" id="L74">        array[pos++] = (byte)((value&gt;&gt;&gt;24));</span>
<span class="fc" id="L75">        array[pos++] = (byte)((value&gt;&gt;&gt;16));</span>
<span class="fc" id="L76">        array[pos++] = (byte)((value&gt;&gt;&gt;8));</span>
<span class="fc" id="L77">        array[pos++] = (byte)(value);</span>
<span class="fc" id="L78">    }</span>

    /**
     * Reads an integer value from a byte array in little endian form. This
     * method allows the reading of two byte values as well as four bytes
     * values both of which are needed in the Kerberos v5 GSS-API mechanism.
     *
     * @param data the array containing the bytes of the integer value
     * @param pos the offset in the array
     * @size the number of bytes to read from the array.
     * @return the integer value
     */
    public static final int readLittleEndian(byte[] data, int pos, int size) {
<span class="fc" id="L91">        int retVal = 0;</span>
<span class="fc" id="L92">        int shifter = 0;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        while (size &gt; 0) {</span>
<span class="fc" id="L94">            retVal += (data[pos] &amp; 0xff) &lt;&lt; shifter;</span>
<span class="fc" id="L95">            shifter += 8;</span>
<span class="fc" id="L96">            pos++;</span>
<span class="fc" id="L97">            size--;</span>
        }
<span class="fc" id="L99">        return retVal;</span>
    }

    public static final int readBigEndian(byte[] data, int pos, int size) {
<span class="fc" id="L103">        int retVal = 0;</span>
<span class="fc" id="L104">        int shifter = (size-1)*8;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        while (size &gt; 0) {</span>
<span class="fc" id="L106">            retVal += (data[pos] &amp; 0xff) &lt;&lt; shifter;</span>
<span class="fc" id="L107">            shifter -= 8;</span>
<span class="fc" id="L108">            pos++;</span>
<span class="fc" id="L109">            size--;</span>
        }
<span class="fc" id="L111">        return retVal;</span>
    }

    /**
     * Writes a two byte integer value to a OutputStream.
     *
     * @param val the integer value. It will lose the high-order two bytes.
     * @param os the OutputStream to write to
     * @throws IOException if an error occurs while writing to the OutputStream
     */
    public static final void writeInt(int val, OutputStream os)
        throws IOException {
<span class="nc" id="L123">        os.write(val&gt;&gt;&gt;8);</span>
<span class="nc" id="L124">        os.write(val);</span>
<span class="nc" id="L125">    }</span>

    /**
     * Writes a two byte integer value to a byte array.
     *
     * @param val the integer value. It will lose the high-order two bytes.
     * @param dest the byte array to write to
     * @param pos the offset to start writing to
     */
    public static final int writeInt(int val, byte[] dest, int pos) {
<span class="fc" id="L135">        dest[pos++] = (byte)(val&gt;&gt;&gt;8);</span>
<span class="fc" id="L136">        dest[pos++] = (byte)val;</span>
<span class="fc" id="L137">        return pos;</span>
    }

    /**
     * Reads a two byte integer value from an InputStream.
     *
     * @param is the InputStream to read from
     * @returns the integer value
     * @throws IOException if some errors occurs while reading the integer
     * bytes.
     */
    public static final int readInt(InputStream is) throws IOException {
<span class="nc" id="L149">        return (((0xFF &amp; is.read()) &lt;&lt; 8)</span>
<span class="nc" id="L150">                 | (0xFF &amp; is.read()));</span>
    }

    /**
     * Reads a two byte integer value from a byte array.
     *
     * @param src the byte arra to read from
     * @param pos the offset to start reading from
     * @returns the integer value
     */
    public static final int readInt(byte[] src, int pos) {
<span class="fc" id="L161">        return ((0xFF &amp; src[pos])&lt;&lt;8 | (0xFF &amp; src[pos+1]));</span>
    }

    /**
     * Blocks till the required number of bytes have been read from the
     * input stream.
     *
     * @param is the InputStream to read from
     * @param buffer the buffer to store the bytes into
     * @param throws EOFException if EOF is reached before all bytes are
     * read.
     * @throws IOException is an error occurs while reading
     */
    public static final void readFully(InputStream is, byte[] buffer)
        throws IOException {
<span class="fc" id="L176">        readFully(is, buffer, 0, buffer.length);</span>
<span class="fc" id="L177">    }</span>

    /**
     * Blocks till the required number of bytes have been read from the
     * input stream.
     *
     * @param is the InputStream to read from
     * @param buffer the buffer to store the bytes into
     * @param offset the offset to start storing at
     * @param len the number of bytes to read
     * @param throws EOFException if EOF is reached before all bytes are
     * read.
     * @throws IOException is an error occurs while reading
     */
    public static final void readFully(InputStream is,
                                       byte[] buffer, int offset, int len)
        throws IOException {
        int temp;
<span class="fc bfc" id="L195" title="All 2 branches covered.">        while (len &gt; 0) {</span>
<span class="fc" id="L196">            temp = is.read(buffer, offset, len);</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            if (temp == -1)</span>
<span class="nc" id="L198">                throw new EOFException(&quot;Cannot read all &quot;</span>
                                       + len
                                       + &quot; bytes needed to form this token!&quot;);
<span class="fc" id="L201">            offset += temp;</span>
<span class="fc" id="L202">            len -= temp;</span>
        }
<span class="fc" id="L204">    }</span>

    public static final void debug(String str) {
<span class="nc" id="L207">        System.err.print(str);</span>
<span class="nc" id="L208">    }</span>

    public static final  String getHexBytes(byte[] bytes) {
<span class="nc" id="L211">        return getHexBytes(bytes, 0, bytes.length);</span>
    }

    public static final  String getHexBytes(byte[] bytes, int len) {
<span class="nc" id="L215">        return getHexBytes(bytes, 0, len);</span>
    }

    public static final String getHexBytes(byte[] bytes, int pos, int len) {
<span class="nc" id="L219">        StringBuffer sb = new StringBuffer();</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        for (int i = pos; i &lt; (pos+len); i++) {</span>
<span class="nc" id="L221">            int b1 = (bytes[i]&gt;&gt;4) &amp; 0x0f;</span>
<span class="nc" id="L222">            int b2 = bytes[i] &amp; 0x0f;</span>

<span class="nc" id="L224">            sb.append(Integer.toHexString(b1));</span>
<span class="nc" id="L225">            sb.append(Integer.toHexString(b2));</span>
<span class="nc" id="L226">            sb.append(' ');</span>
        }
<span class="nc" id="L228">        return sb.toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>