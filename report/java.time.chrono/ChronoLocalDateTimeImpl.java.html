<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ChronoLocalDateTimeImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.time.chrono</a> &gt; <span class="el_source">ChronoLocalDateTimeImpl.java</span></div><h1>ChronoLocalDateTimeImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Copyright (c) 2007-2012, Stephen Colebourne &amp; Michael Nascimento Santos
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of JSR-310 nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package java.time.chrono;

import static java.time.temporal.ChronoField.EPOCH_DAY;

import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;
import java.time.temporal.Temporal;
import java.time.temporal.TemporalAdjuster;
import java.time.temporal.TemporalField;
import java.time.temporal.TemporalUnit;
import java.time.temporal.ValueRange;
import java.util.Objects;

/**
 * A date-time without a time-zone for the calendar neutral API.
 * &lt;p&gt;
 * {@code ChronoLocalDateTime} is an immutable date-time object that represents a date-time, often
 * viewed as year-month-day-hour-minute-second. This object can also access other
 * fields such as day-of-year, day-of-week and week-of-year.
 * &lt;p&gt;
 * This class stores all date and time fields, to a precision of nanoseconds.
 * It does not store or represent a time-zone. For example, the value
 * &quot;2nd October 2007 at 13:45.30.123456789&quot; can be stored in an {@code ChronoLocalDateTime}.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 * @serial
 * @param &lt;D&gt; the concrete type for the date of this date-time
 * @since 1.8
 */
final class ChronoLocalDateTimeImpl&lt;D extends ChronoLocalDate&gt;
        implements  ChronoLocalDateTime&lt;D&gt;, Temporal, TemporalAdjuster, Serializable {

    /**
     * Serialization version.
     */
    private static final long serialVersionUID = 4556003607393004514L;
    /**
     * Hours per day.
     */
    static final int HOURS_PER_DAY = 24;
    /**
     * Minutes per hour.
     */
    static final int MINUTES_PER_HOUR = 60;
    /**
     * Minutes per day.
     */
    static final int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;
    /**
     * Seconds per minute.
     */
    static final int SECONDS_PER_MINUTE = 60;
    /**
     * Seconds per hour.
     */
    static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
    /**
     * Seconds per day.
     */
    static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;
    /**
     * Milliseconds per day.
     */
    static final long MILLIS_PER_DAY = SECONDS_PER_DAY * 1000L;
    /**
     * Microseconds per day.
     */
    static final long MICROS_PER_DAY = SECONDS_PER_DAY * 1000_000L;
    /**
     * Nanos per second.
     */
    static final long NANOS_PER_SECOND = 1000_000_000L;
    /**
     * Nanos per minute.
     */
    static final long NANOS_PER_MINUTE = NANOS_PER_SECOND * SECONDS_PER_MINUTE;
    /**
     * Nanos per hour.
     */
    static final long NANOS_PER_HOUR = NANOS_PER_MINUTE * MINUTES_PER_HOUR;
    /**
     * Nanos per day.
     */
    static final long NANOS_PER_DAY = NANOS_PER_HOUR * HOURS_PER_DAY;

    /**
     * The date part.
     */
    private final transient D date;
    /**
     * The time part.
     */
    private final transient LocalTime time;

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code ChronoLocalDateTime} from a date and time.
     *
     * @param date  the local date, not null
     * @param time  the local time, not null
     * @return the local date-time, not null
     */
    static &lt;R extends ChronoLocalDate&gt; ChronoLocalDateTimeImpl&lt;R&gt; of(R date, LocalTime time) {
<span class="nc" id="L174">        return new ChronoLocalDateTimeImpl&lt;&gt;(date, time);</span>
    }

    /**
     * Casts the {@code Temporal} to {@code ChronoLocalDateTime} ensuring it bas the specified chronology.
     *
     * @param chrono  the chronology to check for, not null
     * @param temporal   a date-time to cast, not null
     * @return the date-time checked and cast to {@code ChronoLocalDateTime}, not null
     * @throws ClassCastException if the date-time cannot be cast to ChronoLocalDateTimeImpl
     *  or the chronology is not equal this Chronology
     */
    static &lt;R extends ChronoLocalDate&gt; ChronoLocalDateTimeImpl&lt;R&gt; ensureValid(Chronology chrono, Temporal temporal) {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L188">        ChronoLocalDateTimeImpl&lt;R&gt; other = (ChronoLocalDateTimeImpl&lt;R&gt;) temporal;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (chrono.equals(other.getChronology()) == false) {</span>
<span class="nc" id="L190">            throw new ClassCastException(&quot;Chronology mismatch, required: &quot; + chrono.getId()</span>
<span class="nc" id="L191">                    + &quot;, actual: &quot; + other.getChronology().getId());</span>
        }
<span class="nc" id="L193">        return other;</span>
    }

    /**
     * Constructor.
     *
     * @param date  the date part of the date-time, not null
     * @param time  the time part of the date-time, not null
     */
<span class="nc" id="L202">    private ChronoLocalDateTimeImpl(D date, LocalTime time) {</span>
<span class="nc" id="L203">        Objects.requireNonNull(date, &quot;date&quot;);</span>
<span class="nc" id="L204">        Objects.requireNonNull(time, &quot;time&quot;);</span>
<span class="nc" id="L205">        this.date = date;</span>
<span class="nc" id="L206">        this.time = time;</span>
<span class="nc" id="L207">    }</span>

    /**
     * Returns a copy of this date-time with the new date and time, checking
     * to see if a new object is in fact required.
     *
     * @param newDate  the date of the new date-time, not null
     * @param newTime  the time of the new date-time, not null
     * @return the date-time, not null
     */
    private ChronoLocalDateTimeImpl&lt;D&gt; with(Temporal newDate, LocalTime newTime) {
<span class="nc bnc" id="L218" title="All 4 branches missed.">        if (date == newDate &amp;&amp; time == newTime) {</span>
<span class="nc" id="L219">            return this;</span>
        }
        // Validate that the new Temporal is a ChronoLocalDate (and not something else)
<span class="nc" id="L222">        D cd = ChronoLocalDateImpl.ensureValid(date.getChronology(), newDate);</span>
<span class="nc" id="L223">        return new ChronoLocalDateTimeImpl&lt;&gt;(cd, newTime);</span>
    }

    //-----------------------------------------------------------------------
    @Override
    public D toLocalDate() {
<span class="nc" id="L229">        return date;</span>
    }

    @Override
    public LocalTime toLocalTime() {
<span class="nc" id="L234">        return time;</span>
    }

    //-----------------------------------------------------------------------
    @Override
    public boolean isSupported(TemporalField field) {
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (field instanceof ChronoField) {</span>
<span class="nc" id="L241">            ChronoField f = (ChronoField) field;</span>
<span class="nc bnc" id="L242" title="All 4 branches missed.">            return f.isDateBased() || f.isTimeBased();</span>
        }
<span class="nc bnc" id="L244" title="All 4 branches missed.">        return field != null &amp;&amp; field.isSupportedBy(this);</span>
    }

    @Override
    public ValueRange range(TemporalField field) {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (field instanceof ChronoField) {</span>
<span class="nc" id="L250">            ChronoField f = (ChronoField) field;</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            return (f.isTimeBased() ? time.range(field) : date.range(field));</span>
        }
<span class="nc" id="L253">        return field.rangeRefinedBy(this);</span>
    }

    @Override
    public int get(TemporalField field) {
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (field instanceof ChronoField) {</span>
<span class="nc" id="L259">            ChronoField f = (ChronoField) field;</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            return (f.isTimeBased() ? time.get(field) : date.get(field));</span>
        }
<span class="nc" id="L262">        return range(field).checkValidIntValue(getLong(field), field);</span>
    }

    @Override
    public long getLong(TemporalField field) {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (field instanceof ChronoField) {</span>
<span class="nc" id="L268">            ChronoField f = (ChronoField) field;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            return (f.isTimeBased() ? time.getLong(field) : date.getLong(field));</span>
        }
<span class="nc" id="L271">        return field.getFrom(this);</span>
    }

    //-----------------------------------------------------------------------
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public ChronoLocalDateTimeImpl&lt;D&gt; with(TemporalAdjuster adjuster) {
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (adjuster instanceof ChronoLocalDate) {</span>
            // The Chronology is checked in with(date,time)
<span class="nc" id="L280">            return with((ChronoLocalDate) adjuster, time);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        } else if (adjuster instanceof LocalTime) {</span>
<span class="nc" id="L282">            return with(date, (LocalTime) adjuster);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">        } else if (adjuster instanceof ChronoLocalDateTimeImpl) {</span>
<span class="nc" id="L284">            return ChronoLocalDateTimeImpl.ensureValid(date.getChronology(), (ChronoLocalDateTimeImpl&lt;?&gt;) adjuster);</span>
        }
<span class="nc" id="L286">        return ChronoLocalDateTimeImpl.ensureValid(date.getChronology(), (ChronoLocalDateTimeImpl&lt;?&gt;) adjuster.adjustInto(this));</span>
    }

    @Override
    public ChronoLocalDateTimeImpl&lt;D&gt; with(TemporalField field, long newValue) {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (field instanceof ChronoField) {</span>
<span class="nc" id="L292">            ChronoField f = (ChronoField) field;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (f.isTimeBased()) {</span>
<span class="nc" id="L294">                return with(date, time.with(field, newValue));</span>
            } else {
<span class="nc" id="L296">                return with(date.with(field, newValue), time);</span>
            }
        }
<span class="nc" id="L299">        return ChronoLocalDateTimeImpl.ensureValid(date.getChronology(), field.adjustInto(this, newValue));</span>
    }

    //-----------------------------------------------------------------------
    @Override
    public ChronoLocalDateTimeImpl&lt;D&gt; plus(long amountToAdd, TemporalUnit unit) {
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (unit instanceof ChronoUnit) {</span>
<span class="nc" id="L306">            ChronoUnit f = (ChronoUnit) unit;</span>
<span class="nc bnc" id="L307" title="All 8 branches missed.">            switch (f) {</span>
<span class="nc" id="L308">                case NANOS: return plusNanos(amountToAdd);</span>
<span class="nc" id="L309">                case MICROS: return plusDays(amountToAdd / MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);</span>
<span class="nc" id="L310">                case MILLIS: return plusDays(amountToAdd / MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000000);</span>
<span class="nc" id="L311">                case SECONDS: return plusSeconds(amountToAdd);</span>
<span class="nc" id="L312">                case MINUTES: return plusMinutes(amountToAdd);</span>
<span class="nc" id="L313">                case HOURS: return plusHours(amountToAdd);</span>
<span class="nc" id="L314">                case HALF_DAYS: return plusDays(amountToAdd / 256).plusHours((amountToAdd % 256) * 12);  // no overflow (256 is multiple of 2)</span>
            }
<span class="nc" id="L316">            return with(date.plus(amountToAdd, unit), time);</span>
        }
<span class="nc" id="L318">        return ChronoLocalDateTimeImpl.ensureValid(date.getChronology(), unit.addTo(this, amountToAdd));</span>
    }

    private ChronoLocalDateTimeImpl&lt;D&gt; plusDays(long days) {
<span class="nc" id="L322">        return with(date.plus(days, ChronoUnit.DAYS), time);</span>
    }

    private ChronoLocalDateTimeImpl&lt;D&gt; plusHours(long hours) {
<span class="nc" id="L326">        return plusWithOverflow(date, hours, 0, 0, 0);</span>
    }

    private ChronoLocalDateTimeImpl&lt;D&gt; plusMinutes(long minutes) {
<span class="nc" id="L330">        return plusWithOverflow(date, 0, minutes, 0, 0);</span>
    }

    ChronoLocalDateTimeImpl&lt;D&gt; plusSeconds(long seconds) {
<span class="nc" id="L334">        return plusWithOverflow(date, 0, 0, seconds, 0);</span>
    }

    private ChronoLocalDateTimeImpl&lt;D&gt; plusNanos(long nanos) {
<span class="nc" id="L338">        return plusWithOverflow(date, 0, 0, 0, nanos);</span>
    }

    //-----------------------------------------------------------------------
    private ChronoLocalDateTimeImpl&lt;D&gt; plusWithOverflow(D newDate, long hours, long minutes, long seconds, long nanos) {
        // 9223372036854775808 long, 2147483648 int
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if ((hours | minutes | seconds | nanos) == 0) {</span>
<span class="nc" id="L345">            return with(newDate, time);</span>
        }
<span class="nc" id="L347">        long totDays = nanos / NANOS_PER_DAY +             //   max/24*60*60*1B</span>
                seconds / SECONDS_PER_DAY +                //   max/24*60*60
                minutes / MINUTES_PER_DAY +                //   max/24*60
                hours / HOURS_PER_DAY;                     //   max/24
<span class="nc" id="L351">        long totNanos = nanos % NANOS_PER_DAY +                    //   max  86400000000000</span>
                (seconds % SECONDS_PER_DAY) * NANOS_PER_SECOND +   //   max  86400000000000
                (minutes % MINUTES_PER_DAY) * NANOS_PER_MINUTE +   //   max  86400000000000
                (hours % HOURS_PER_DAY) * NANOS_PER_HOUR;          //   max  86400000000000
<span class="nc" id="L355">        long curNoD = time.toNanoOfDay();                          //   max  86400000000000</span>
<span class="nc" id="L356">        totNanos = totNanos + curNoD;                              // total 432000000000000</span>
<span class="nc" id="L357">        totDays += Math.floorDiv(totNanos, NANOS_PER_DAY);</span>
<span class="nc" id="L358">        long newNoD = Math.floorMod(totNanos, NANOS_PER_DAY);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">        LocalTime newTime = (newNoD == curNoD ? time : LocalTime.ofNanoOfDay(newNoD));</span>
<span class="nc" id="L360">        return with(newDate.plus(totDays, ChronoUnit.DAYS), newTime);</span>
    }

    //-----------------------------------------------------------------------
    @Override
    public ChronoZonedDateTime&lt;D&gt; atZone(ZoneId zone) {
<span class="nc" id="L366">        return ChronoZonedDateTimeImpl.ofBest(this, zone, null);</span>
    }

    //-----------------------------------------------------------------------
    @Override
    public long until(Temporal endExclusive, TemporalUnit unit) {
<span class="nc" id="L372">        Objects.requireNonNull(endExclusive, &quot;endExclusive&quot;);</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L374">        ChronoLocalDateTime&lt;D&gt; end = (ChronoLocalDateTime&lt;D&gt;) getChronology().localDateTime(endExclusive);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (unit instanceof ChronoUnit) {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">            if (unit.isTimeBased()) {</span>
<span class="nc" id="L377">                long amount = end.getLong(EPOCH_DAY) - date.getLong(EPOCH_DAY);</span>
<span class="nc bnc" id="L378" title="All 8 branches missed.">                switch ((ChronoUnit) unit) {</span>
<span class="nc" id="L379">                    case NANOS: amount = Math.multiplyExact(amount, NANOS_PER_DAY); break;</span>
<span class="nc" id="L380">                    case MICROS: amount = Math.multiplyExact(amount, MICROS_PER_DAY); break;</span>
<span class="nc" id="L381">                    case MILLIS: amount = Math.multiplyExact(amount, MILLIS_PER_DAY); break;</span>
<span class="nc" id="L382">                    case SECONDS: amount = Math.multiplyExact(amount, SECONDS_PER_DAY); break;</span>
<span class="nc" id="L383">                    case MINUTES: amount = Math.multiplyExact(amount, MINUTES_PER_DAY); break;</span>
<span class="nc" id="L384">                    case HOURS: amount = Math.multiplyExact(amount, HOURS_PER_DAY); break;</span>
<span class="nc" id="L385">                    case HALF_DAYS: amount = Math.multiplyExact(amount, 2); break;</span>
                }
<span class="nc" id="L387">                return Math.addExact(amount, time.until(end.toLocalTime(), unit));</span>
            }
<span class="nc" id="L389">            ChronoLocalDate endDate = end.toLocalDate();</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (end.toLocalTime().isBefore(time)) {</span>
<span class="nc" id="L391">                endDate = endDate.minus(1, ChronoUnit.DAYS);</span>
            }
<span class="nc" id="L393">            return date.until(endDate, unit);</span>
        }
<span class="nc" id="L395">        Objects.requireNonNull(unit, &quot;unit&quot;);</span>
<span class="nc" id="L396">        return unit.between(this, end);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Writes the ChronoLocalDateTime using a
     * &lt;a href=&quot;../../../serialized-form.html#java.time.chrono.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
     * @serialData
     * &lt;pre&gt;
     *  out.writeByte(2);              // identifies a ChronoLocalDateTime
     *  out.writeObject(toLocalDate());
     *  out.witeObject(toLocalTime());
     * &lt;/pre&gt;
     *
     * @return the instance of {@code Ser}, not null
     */
    private Object writeReplace() {
<span class="nc" id="L413">        return new Ser(Ser.CHRONO_LOCAL_DATE_TIME_TYPE, this);</span>
    }

    /**
     * Defend against malicious streams.
     * @return never
     * @throws InvalidObjectException always
     */
    private Object readResolve() throws InvalidObjectException {
<span class="nc" id="L422">        throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);</span>
    }

    void writeExternal(ObjectOutput out) throws IOException {
<span class="nc" id="L426">        out.writeObject(date);</span>
<span class="nc" id="L427">        out.writeObject(time);</span>
<span class="nc" id="L428">    }</span>

    static ChronoLocalDateTime&lt;?&gt; readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
<span class="nc" id="L431">        ChronoLocalDate date = (ChronoLocalDate) in.readObject();</span>
<span class="nc" id="L432">        LocalTime time = (LocalTime) in.readObject();</span>
<span class="nc" id="L433">        return date.atTime(time);</span>
    }

    //-----------------------------------------------------------------------
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L439" title="All 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L440">            return true;</span>
        }
<span class="nc bnc" id="L442" title="All 2 branches missed.">        if (obj instanceof ChronoLocalDateTime) {</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">            return compareTo((ChronoLocalDateTime&lt;?&gt;) obj) == 0;</span>
        }
<span class="nc" id="L445">        return false;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L450">        return toLocalDate().hashCode() ^ toLocalTime().hashCode();</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L455">        return toLocalDate().toString() + 'T' + toLocalTime().toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>