<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>JapaneseChronology.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.time.chrono</a> &gt; <span class="el_source">JapaneseChronology.java</span></div><h1>JapaneseChronology.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * Copyright (c) 2012, Stephen Colebourne &amp; Michael Nascimento Santos
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of JSR-310 nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package java.time.chrono;

import static java.time.temporal.ChronoField.DAY_OF_MONTH;
import static java.time.temporal.ChronoField.DAY_OF_YEAR;
import static java.time.temporal.ChronoField.ERA;
import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
import static java.time.temporal.ChronoField.YEAR;
import static java.time.temporal.ChronoField.YEAR_OF_ERA;
import static java.time.temporal.ChronoUnit.DAYS;
import static java.time.temporal.ChronoUnit.MONTHS;

import java.io.InvalidObjectException;
import java.io.Serializable;
import java.time.Clock;
import java.time.DateTimeException;
import java.time.Instant;
import java.time.LocalDate;
import java.time.Year;
import java.time.ZoneId;
import java.time.format.ResolverStyle;
import java.time.temporal.ChronoField;
import java.time.temporal.TemporalAccessor;
import java.time.temporal.TemporalAdjusters;
import java.time.temporal.TemporalField;
import java.time.temporal.UnsupportedTemporalTypeException;
import java.time.temporal.ValueRange;
import java.util.Arrays;
import java.util.Calendar;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import sun.util.calendar.CalendarSystem;
import sun.util.calendar.LocalGregorianCalendar;

/**
 * The Japanese Imperial calendar system.
 * &lt;p&gt;
 * This chronology defines the rules of the Japanese Imperial calendar system.
 * This calendar system is primarily used in Japan.
 * The Japanese Imperial calendar system is the same as the ISO calendar system
 * apart from the era-based year numbering.
 * &lt;p&gt;
 * Japan introduced the Gregorian calendar starting with Meiji 6.
 * Only Meiji and later eras are supported;
 * dates before Meiji 6, January 1 are not supported.
 * &lt;p&gt;
 * The supported {@code ChronoField} instances are:
 * &lt;ul&gt;
 * &lt;li&gt;{@code DAY_OF_WEEK}
 * &lt;li&gt;{@code DAY_OF_MONTH}
 * &lt;li&gt;{@code DAY_OF_YEAR}
 * &lt;li&gt;{@code EPOCH_DAY}
 * &lt;li&gt;{@code MONTH_OF_YEAR}
 * &lt;li&gt;{@code PROLEPTIC_MONTH}
 * &lt;li&gt;{@code YEAR_OF_ERA}
 * &lt;li&gt;{@code YEAR}
 * &lt;li&gt;{@code ERA}
 * &lt;/ul&gt;
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
 */
public final class JapaneseChronology extends AbstractChronology implements Serializable {

<span class="fc" id="L124">    static final LocalGregorianCalendar JCAL =</span>
<span class="fc" id="L125">        (LocalGregorianCalendar) CalendarSystem.forName(&quot;japanese&quot;);</span>

    // Locale for creating a JapaneseImpericalCalendar.
<span class="fc" id="L128">    static final Locale LOCALE = Locale.forLanguageTag(&quot;ja-JP-u-ca-japanese&quot;);</span>

    /**
     * Singleton instance for Japanese chronology.
     */
<span class="fc" id="L133">    public static final JapaneseChronology INSTANCE = new JapaneseChronology();</span>

    /**
     * Serialization version.
     */
    private static final long serialVersionUID = 459996390165777884L;

    //-----------------------------------------------------------------------
    /**
     * Restricted constructor.
     */
<span class="fc" id="L144">    private JapaneseChronology() {</span>
<span class="fc" id="L145">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets the ID of the chronology - 'Japanese'.
     * &lt;p&gt;
     * The ID uniquely identifies the {@code Chronology}.
     * It can be used to lookup the {@code Chronology} using {@link #of(String)}.
     *
     * @return the chronology ID - 'Japanese'
     * @see #getCalendarType()
     */
    @Override
    public String getId() {
<span class="nc" id="L159">        return &quot;Japanese&quot;;</span>
    }

    /**
     * Gets the calendar type of the underlying calendar system - 'japanese'.
     * &lt;p&gt;
     * The calendar type is an identifier defined by the
     * &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt; specification.
     * It can be used to lookup the {@code Chronology} using {@link #of(String)}.
     * It can also be used as part of a locale, accessible via
     * {@link Locale#getUnicodeLocaleType(String)} with the key 'ca'.
     *
     * @return the calendar system type - 'japanese'
     * @see #getId()
     */
    @Override
    public String getCalendarType() {
<span class="nc" id="L176">        return &quot;japanese&quot;;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains a local date in Japanese calendar system from the
     * era, year-of-era, month-of-year and day-of-month fields.
     * &lt;p&gt;
     * The Japanese month and day-of-month are the same as those in the
     * ISO calendar system. They are not reset when the era changes.
     * For example:
     * &lt;pre&gt;
     *  6th Jan Showa 64 = ISO 1989-01-06
     *  7th Jan Showa 64 = ISO 1989-01-07
     *  8th Jan Heisei 1 = ISO 1989-01-08
     *  9th Jan Heisei 1 = ISO 1989-01-09
     * &lt;/pre&gt;
     *
     * @param era  the Japanese era, not null
     * @param yearOfEra  the year-of-era
     * @param month  the month-of-year
     * @param dayOfMonth  the day-of-month
     * @return the Japanese local date, not null
     * @throws DateTimeException if unable to create the date
     * @throws ClassCastException if the {@code era} is not a {@code JapaneseEra}
     */
    @Override
    public JapaneseDate date(Era era, int yearOfEra, int month, int dayOfMonth) {
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (era instanceof JapaneseEra == false) {</span>
<span class="nc" id="L205">            throw new ClassCastException(&quot;Era must be JapaneseEra&quot;);</span>
        }
<span class="nc" id="L207">        return JapaneseDate.of((JapaneseEra) era, yearOfEra, month, dayOfMonth);</span>
    }

    /**
     * Obtains a local date in Japanese calendar system from the
     * proleptic-year, month-of-year and day-of-month fields.
     * &lt;p&gt;
     * The Japanese proleptic year, month and day-of-month are the same as those
     * in the ISO calendar system. They are not reset when the era changes.
     *
     * @param prolepticYear  the proleptic-year
     * @param month  the month-of-year
     * @param dayOfMonth  the day-of-month
     * @return the Japanese local date, not null
     * @throws DateTimeException if unable to create the date
     */
    @Override
    public JapaneseDate date(int prolepticYear, int month, int dayOfMonth) {
<span class="nc" id="L225">        return new JapaneseDate(LocalDate.of(prolepticYear, month, dayOfMonth));</span>
    }

    /**
     * Obtains a local date in Japanese calendar system from the
     * era, year-of-era and day-of-year fields.
     * &lt;p&gt;
     * The day-of-year in this factory is expressed relative to the start of the year-of-era.
     * This definition changes the normal meaning of day-of-year only in those years
     * where the year-of-era is reset to one due to a change in the era.
     * For example:
     * &lt;pre&gt;
     *  6th Jan Showa 64 = day-of-year 6
     *  7th Jan Showa 64 = day-of-year 7
     *  8th Jan Heisei 1 = day-of-year 1
     *  9th Jan Heisei 1 = day-of-year 2
     * &lt;/pre&gt;
     *
     * @param era  the Japanese era, not null
     * @param yearOfEra  the year-of-era
     * @param dayOfYear  the day-of-year
     * @return the Japanese local date, not null
     * @throws DateTimeException if unable to create the date
     * @throws ClassCastException if the {@code era} is not a {@code JapaneseEra}
     */
    @Override
    public JapaneseDate dateYearDay(Era era, int yearOfEra, int dayOfYear) {
<span class="nc" id="L252">        return JapaneseDate.ofYearDay((JapaneseEra) era, yearOfEra, dayOfYear);</span>
    }

    /**
     * Obtains a local date in Japanese calendar system from the
     * proleptic-year and day-of-year fields.
     * &lt;p&gt;
     * The day-of-year in this factory is expressed relative to the start of the proleptic year.
     * The Japanese proleptic year and day-of-year are the same as those in the ISO calendar system.
     * They are not reset when the era changes.
     *
     * @param prolepticYear  the proleptic-year
     * @param dayOfYear  the day-of-year
     * @return the Japanese local date, not null
     * @throws DateTimeException if unable to create the date
     */
    @Override
    public JapaneseDate dateYearDay(int prolepticYear, int dayOfYear) {
<span class="nc" id="L270">        return new JapaneseDate(LocalDate.ofYearDay(prolepticYear, dayOfYear));</span>
    }

    /**
     * Obtains a local date in the Japanese calendar system from the epoch-day.
     *
     * @param epochDay  the epoch day
     * @return the Japanese local date, not null
     * @throws DateTimeException if unable to create the date
     */
    @Override  // override with covariant return type
    public JapaneseDate dateEpochDay(long epochDay) {
<span class="nc" id="L282">        return new JapaneseDate(LocalDate.ofEpochDay(epochDay));</span>
    }

    @Override
    public JapaneseDate dateNow() {
<span class="nc" id="L287">        return dateNow(Clock.systemDefaultZone());</span>
    }

    @Override
    public JapaneseDate dateNow(ZoneId zone) {
<span class="nc" id="L292">        return dateNow(Clock.system(zone));</span>
    }

    @Override
    public JapaneseDate dateNow(Clock clock) {
<span class="nc" id="L297">        return date(LocalDate.now(clock));</span>
    }

    @Override
    public JapaneseDate date(TemporalAccessor temporal) {
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (temporal instanceof JapaneseDate) {</span>
<span class="nc" id="L303">            return (JapaneseDate) temporal;</span>
        }
<span class="nc" id="L305">        return new JapaneseDate(LocalDate.from(temporal));</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public ChronoLocalDateTime&lt;JapaneseDate&gt; localDateTime(TemporalAccessor temporal) {
<span class="nc" id="L311">        return (ChronoLocalDateTime&lt;JapaneseDate&gt;)super.localDateTime(temporal);</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public ChronoZonedDateTime&lt;JapaneseDate&gt; zonedDateTime(TemporalAccessor temporal) {
<span class="nc" id="L317">        return (ChronoZonedDateTime&lt;JapaneseDate&gt;)super.zonedDateTime(temporal);</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public ChronoZonedDateTime&lt;JapaneseDate&gt; zonedDateTime(Instant instant, ZoneId zone) {
<span class="nc" id="L323">        return (ChronoZonedDateTime&lt;JapaneseDate&gt;)super.zonedDateTime(instant, zone);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if the specified year is a leap year.
     * &lt;p&gt;
     * Japanese calendar leap years occur exactly in line with ISO leap years.
     * This method does not validate the year passed in, and only has a
     * well-defined result for years in the supported range.
     *
     * @param prolepticYear  the proleptic-year to check, not validated for range
     * @return true if the year is a leap year
     */
    @Override
    public boolean isLeapYear(long prolepticYear) {
<span class="nc" id="L339">        return IsoChronology.INSTANCE.isLeapYear(prolepticYear);</span>
    }

    @Override
    public int prolepticYear(Era era, int yearOfEra) {
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (era instanceof JapaneseEra == false) {</span>
<span class="nc" id="L345">            throw new ClassCastException(&quot;Era must be JapaneseEra&quot;);</span>
        }

<span class="nc" id="L348">        JapaneseEra jera = (JapaneseEra) era;</span>
<span class="nc" id="L349">        int gregorianYear = jera.getPrivateEra().getSinceDate().getYear() + yearOfEra - 1;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (yearOfEra == 1) {</span>
<span class="nc" id="L351">            return gregorianYear;</span>
        }
<span class="nc bnc" id="L353" title="All 4 branches missed.">        if (gregorianYear &gt;= Year.MIN_VALUE &amp;&amp; gregorianYear &lt;= Year.MAX_VALUE) {</span>
<span class="nc" id="L354">            LocalGregorianCalendar.Date jdate = JCAL.newCalendarDate(null);</span>
<span class="nc" id="L355">            jdate.setEra(jera.getPrivateEra()).setDate(yearOfEra, 1, 1);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">            if (JapaneseChronology.JCAL.validate(jdate)) {</span>
<span class="nc" id="L357">                return gregorianYear;</span>
            }
        }
<span class="nc" id="L360">        throw new DateTimeException(&quot;Invalid yearOfEra value&quot;);</span>
    }

    /**
     * Returns the calendar system era object from the given numeric value.
     *
     * See the description of each Era for the numeric values of:
     * {@link JapaneseEra#HEISEI}, {@link JapaneseEra#SHOWA},{@link JapaneseEra#TAISHO},
     * {@link JapaneseEra#MEIJI}), only Meiji and later eras are supported.
     *
     * @param eraValue  the era value
     * @return the Japanese {@code Era} for the given numeric era value
     * @throws DateTimeException if {@code eraValue} is invalid
     */
    @Override
    public JapaneseEra eraOf(int eraValue) {
<span class="nc" id="L376">        return JapaneseEra.of(eraValue);</span>
    }

    @Override
    public List&lt;Era&gt; eras() {
<span class="nc" id="L381">        return Arrays.&lt;Era&gt;asList(JapaneseEra.values());</span>
    }

    JapaneseEra getCurrentEra() {
        // Assume that the last JapaneseEra is the current one.
<span class="nc" id="L386">        JapaneseEra[] eras = JapaneseEra.values();</span>
<span class="nc" id="L387">        return eras[eras.length - 1];</span>
    }

    //-----------------------------------------------------------------------
    @Override
    public ValueRange range(ChronoField field) {
<span class="nc bnc" id="L393" title="All 6 branches missed.">        switch (field) {</span>
            case ALIGNED_DAY_OF_WEEK_IN_MONTH:
            case ALIGNED_DAY_OF_WEEK_IN_YEAR:
            case ALIGNED_WEEK_OF_MONTH:
            case ALIGNED_WEEK_OF_YEAR:
<span class="nc" id="L398">                throw new UnsupportedTemporalTypeException(&quot;Unsupported field: &quot; + field);</span>
            case YEAR_OF_ERA: {
<span class="nc" id="L400">                Calendar jcal = Calendar.getInstance(LOCALE);</span>
<span class="nc" id="L401">                int startYear = getCurrentEra().getPrivateEra().getSinceDate().getYear();</span>
<span class="nc" id="L402">                return ValueRange.of(1, jcal.getGreatestMinimum(Calendar.YEAR),</span>
<span class="nc" id="L403">                        jcal.getLeastMaximum(Calendar.YEAR) + 1, // +1 due to the different definitions</span>
                        Year.MAX_VALUE - startYear);
            }
            case DAY_OF_YEAR: {
<span class="nc" id="L407">                Calendar jcal = Calendar.getInstance(LOCALE);</span>
<span class="nc" id="L408">                int fieldIndex = Calendar.DAY_OF_YEAR;</span>
<span class="nc" id="L409">                return ValueRange.of(jcal.getMinimum(fieldIndex), jcal.getGreatestMinimum(fieldIndex),</span>
<span class="nc" id="L410">                        jcal.getLeastMaximum(fieldIndex), jcal.getMaximum(fieldIndex));</span>
            }
            case YEAR:
<span class="nc" id="L413">                return ValueRange.of(JapaneseDate.MEIJI_6_ISODATE.getYear(), Year.MAX_VALUE);</span>
            case ERA:
<span class="nc" id="L415">                return ValueRange.of(JapaneseEra.MEIJI.getValue(), getCurrentEra().getValue());</span>
            default:
<span class="nc" id="L417">                return field.range();</span>
        }
    }

    //-----------------------------------------------------------------------
    @Override  // override for return type
    public JapaneseDate resolveDate(Map &lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
<span class="nc" id="L424">        return (JapaneseDate) super.resolveDate(fieldValues, resolverStyle);</span>
    }

    @Override  // override for special Japanese behavior
    ChronoLocalDate resolveYearOfEra(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
        // validate era and year-of-era
<span class="nc" id="L430">        Long eraLong = fieldValues.get(ERA);</span>
<span class="nc" id="L431">        JapaneseEra era = null;</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (eraLong != null) {</span>
<span class="nc" id="L433">            era = eraOf(range(ERA).checkValidIntValue(eraLong, ERA));  // always validated</span>
        }
<span class="nc" id="L435">        Long yoeLong = fieldValues.get(YEAR_OF_ERA);</span>
<span class="nc" id="L436">        int yoe = 0;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        if (yoeLong != null) {</span>
<span class="nc" id="L438">            yoe = range(YEAR_OF_ERA).checkValidIntValue(yoeLong, YEAR_OF_ERA);  // always validated</span>
        }
        // if only year-of-era and no year then invent era unless strict
<span class="nc bnc" id="L441" title="All 8 branches missed.">        if (era == null &amp;&amp; yoeLong != null &amp;&amp; fieldValues.containsKey(YEAR) == false &amp;&amp; resolverStyle != ResolverStyle.STRICT) {</span>
<span class="nc" id="L442">            era = JapaneseEra.values()[JapaneseEra.values().length - 1];</span>
        }
        // if both present, then try to create date
<span class="nc bnc" id="L445" title="All 4 branches missed.">        if (yoeLong != null &amp;&amp; era != null) {</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (fieldValues.containsKey(MONTH_OF_YEAR)) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                if (fieldValues.containsKey(DAY_OF_MONTH)) {</span>
<span class="nc" id="L448">                    return resolveYMD(era, yoe, fieldValues, resolverStyle);</span>
                }
            }
<span class="nc bnc" id="L451" title="All 2 branches missed.">            if (fieldValues.containsKey(DAY_OF_YEAR)) {</span>
<span class="nc" id="L452">                return resolveYD(era, yoe, fieldValues, resolverStyle);</span>
            }
        }
<span class="nc" id="L455">        return null;</span>
    }

    private int prolepticYearLenient(JapaneseEra era, int yearOfEra) {
<span class="nc" id="L459">        return era.getPrivateEra().getSinceDate().getYear() + yearOfEra - 1;</span>
    }

     private ChronoLocalDate resolveYMD(JapaneseEra era, int yoe, Map&lt;TemporalField,Long&gt; fieldValues, ResolverStyle resolverStyle) {
<span class="nc" id="L463">         fieldValues.remove(ERA);</span>
<span class="nc" id="L464">         fieldValues.remove(YEAR_OF_ERA);</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">         if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L466">             int y = prolepticYearLenient(era, yoe);</span>
<span class="nc" id="L467">             long months = Math.subtractExact(fieldValues.remove(MONTH_OF_YEAR), 1);</span>
<span class="nc" id="L468">             long days = Math.subtractExact(fieldValues.remove(DAY_OF_MONTH), 1);</span>
<span class="nc" id="L469">             return date(y, 1, 1).plus(months, MONTHS).plus(days, DAYS);</span>
         }
<span class="nc" id="L471">         int moy = range(MONTH_OF_YEAR).checkValidIntValue(fieldValues.remove(MONTH_OF_YEAR), MONTH_OF_YEAR);</span>
<span class="nc" id="L472">         int dom = range(DAY_OF_MONTH).checkValidIntValue(fieldValues.remove(DAY_OF_MONTH), DAY_OF_MONTH);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">         if (resolverStyle == ResolverStyle.SMART) {  // previous valid</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">             if (yoe &lt; 1) {</span>
<span class="nc" id="L475">                 throw new DateTimeException(&quot;Invalid YearOfEra: &quot; + yoe);</span>
             }
<span class="nc" id="L477">             int y = prolepticYearLenient(era, yoe);</span>
             JapaneseDate result;
             try {
<span class="nc" id="L480">                 result = date(y, moy, dom);</span>
<span class="nc" id="L481">             } catch (DateTimeException ex) {</span>
<span class="nc" id="L482">                 result = date(y, moy, 1).with(TemporalAdjusters.lastDayOfMonth());</span>
<span class="nc" id="L483">             }</span>
             // handle the era being changed
             // only allow if the new date is in the same Jan-Dec as the era change
             // determine by ensuring either original yoe or result yoe is 1
<span class="nc bnc" id="L487" title="All 6 branches missed.">             if (result.getEra() != era &amp;&amp; result.get(YEAR_OF_ERA) &gt; 1 &amp;&amp; yoe &gt; 1) {</span>
<span class="nc" id="L488">                 throw new DateTimeException(&quot;Invalid YearOfEra for Era: &quot; + era + &quot; &quot; + yoe);</span>
             }
<span class="nc" id="L490">             return result;</span>
         }
<span class="nc" id="L492">         return date(era, yoe, moy, dom);</span>
     }

    private ChronoLocalDate resolveYD(JapaneseEra era, int yoe, Map &lt;TemporalField,Long&gt; fieldValues, ResolverStyle resolverStyle) {
<span class="nc" id="L496">        fieldValues.remove(ERA);</span>
<span class="nc" id="L497">        fieldValues.remove(YEAR_OF_ERA);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L499">            int y = prolepticYearLenient(era, yoe);</span>
<span class="nc" id="L500">            long days = Math.subtractExact(fieldValues.remove(DAY_OF_YEAR), 1);</span>
<span class="nc" id="L501">            return dateYearDay(y, 1).plus(days, DAYS);</span>
        }
<span class="nc" id="L503">        int doy = range(DAY_OF_YEAR).checkValidIntValue(fieldValues.remove(DAY_OF_YEAR), DAY_OF_YEAR);</span>
<span class="nc" id="L504">        return dateYearDay(era, yoe, doy);  // smart is same as strict</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Writes the Chronology using a
     * &lt;a href=&quot;../../../serialized-form.html#java.time.chrono.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
     * @serialData
     * &lt;pre&gt;
     *  out.writeByte(1);     // identifies a Chronology
     *  out.writeUTF(getId());
     * &lt;/pre&gt;
     *
     * @return the instance of {@code Ser}, not null
     */
    @Override
    Object writeReplace() {
<span class="nc" id="L521">        return super.writeReplace();</span>
    }

    /**
     * Defend against malicious streams.
     * @return never
     * @throws InvalidObjectException always
     */
    private Object readResolve() throws InvalidObjectException {
<span class="nc" id="L530">        throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>