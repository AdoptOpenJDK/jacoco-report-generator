<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractChronology.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.time.chrono</a> &gt; <span class="el_source">AbstractChronology.java</span></div><h1>AbstractChronology.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Copyright (c) 2012, Stephen Colebourne &amp; Michael Nascimento Santos
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of JSR-310 nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package java.time.chrono;

import static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH;
import static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR;
import static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_MONTH;
import static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_YEAR;
import static java.time.temporal.ChronoField.DAY_OF_MONTH;
import static java.time.temporal.ChronoField.DAY_OF_WEEK;
import static java.time.temporal.ChronoField.DAY_OF_YEAR;
import static java.time.temporal.ChronoField.EPOCH_DAY;
import static java.time.temporal.ChronoField.ERA;
import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
import static java.time.temporal.ChronoField.PROLEPTIC_MONTH;
import static java.time.temporal.ChronoField.YEAR;
import static java.time.temporal.ChronoField.YEAR_OF_ERA;
import static java.time.temporal.ChronoUnit.DAYS;
import static java.time.temporal.ChronoUnit.MONTHS;
import static java.time.temporal.ChronoUnit.WEEKS;
import static java.time.temporal.TemporalAdjusters.nextOrSame;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.time.DateTimeException;
import java.time.DayOfWeek;
import java.time.format.ResolverStyle;
import java.time.temporal.ChronoField;
import java.time.temporal.TemporalAdjusters;
import java.time.temporal.TemporalField;
import java.time.temporal.ValueRange;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import sun.util.logging.PlatformLogger;

/**
 * An abstract implementation of a calendar system, used to organize and identify dates.
 * &lt;p&gt;
 * The main date and time API is built on the ISO calendar system.
 * The chronology operates behind the scenes to represent the general concept of a calendar system.
 * &lt;p&gt;
 * See {@link Chronology} for more details.
 *
 * @implSpec
 * This class is separated from the {@code Chronology} interface so that the static methods
 * are not inherited. While {@code Chronology} can be implemented directly, it is strongly
 * recommended to extend this abstract class instead.
 * &lt;p&gt;
 * This class must be implemented with care to ensure other classes operate correctly.
 * All implementations that can be instantiated must be final, immutable and thread-safe.
 * Subclasses should be Serializable wherever possible.
 *
 * @since 1.8
 */
public abstract class AbstractChronology implements Chronology {

    /**
     * ChronoLocalDate order constant.
     */
<span class="fc" id="L131">    static final Comparator&lt;ChronoLocalDate&gt; DATE_ORDER =</span>
        (Comparator&lt;ChronoLocalDate&gt; &amp; Serializable) (date1, date2) -&gt; {
            return Long.compare(date1.toEpochDay(), date2.toEpochDay());
        };
    /**
     * ChronoLocalDateTime order constant.
     */
<span class="fc" id="L138">    static final Comparator&lt;ChronoLocalDateTime&lt;? extends ChronoLocalDate&gt;&gt; DATE_TIME_ORDER =</span>
        (Comparator&lt;ChronoLocalDateTime&lt;? extends ChronoLocalDate&gt;&gt; &amp; Serializable) (dateTime1, dateTime2) -&gt; {
            int cmp = Long.compare(dateTime1.toLocalDate().toEpochDay(), dateTime2.toLocalDate().toEpochDay());
            if (cmp == 0) {
                cmp = Long.compare(dateTime1.toLocalTime().toNanoOfDay(), dateTime2.toLocalTime().toNanoOfDay());
            }
            return cmp;
        };
    /**
     * ChronoZonedDateTime order constant.
     */
<span class="fc" id="L149">    static final Comparator&lt;ChronoZonedDateTime&lt;?&gt;&gt; INSTANT_ORDER =</span>
            (Comparator&lt;ChronoZonedDateTime&lt;?&gt;&gt; &amp; Serializable) (dateTime1, dateTime2) -&gt; {
                int cmp = Long.compare(dateTime1.toEpochSecond(), dateTime2.toEpochSecond());
                if (cmp == 0) {
                    cmp = Long.compare(dateTime1.toLocalTime().getNano(), dateTime2.toLocalTime().getNano());
                }
                return cmp;
            };

    /**
     * Map of available calendars by ID.
     */
<span class="fc" id="L161">    private static final ConcurrentHashMap&lt;String, Chronology&gt; CHRONOS_BY_ID = new ConcurrentHashMap&lt;&gt;();</span>
    /**
     * Map of available calendars by calendar type.
     */
<span class="fc" id="L165">    private static final ConcurrentHashMap&lt;String, Chronology&gt; CHRONOS_BY_TYPE = new ConcurrentHashMap&lt;&gt;();</span>

    /**
     * Register a Chronology by its ID and type for lookup by {@link #of(String)}.
     * Chronologies must not be registered until they are completely constructed.
     * Specifically, not in the constructor of Chronology.
     *
     * @param chrono the chronology to register; not null
     * @return the already registered Chronology if any, may be null
     */
    static Chronology registerChrono(Chronology chrono) {
<span class="nc" id="L176">        return registerChrono(chrono, chrono.getId());</span>
    }

    /**
     * Register a Chronology by ID and type for lookup by {@link #of(String)}.
     * Chronos must not be registered until they are completely constructed.
     * Specifically, not in the constructor of Chronology.
     *
     * @param chrono the chronology to register; not null
     * @param id the ID to register the chronology; not null
     * @return the already registered Chronology if any, may be null
     */
    static Chronology registerChrono(Chronology chrono, String id) {
<span class="fc" id="L189">        Chronology prev = CHRONOS_BY_ID.putIfAbsent(id, chrono);</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (prev == null) {</span>
<span class="fc" id="L191">            String type = chrono.getCalendarType();</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">            if (type != null) {</span>
<span class="fc" id="L193">                CHRONOS_BY_TYPE.putIfAbsent(type, chrono);</span>
            }
        }
<span class="fc" id="L196">        return prev;</span>
    }

    /**
     * Initialization of the maps from id and type to Chronology.
     * The ServiceLoader is used to find and register any implementations
     * of {@link java.time.chrono.AbstractChronology} found in the bootclass loader.
     * The built-in chronologies are registered explicitly.
     * Calendars configured via the Thread's context classloader are local
     * to that thread and are ignored.
     * &lt;p&gt;
     * The initialization is done only once using the registration
     * of the IsoChronology as the test and the final step.
     * Multiple threads may perform the initialization concurrently.
     * Only the first registration of each Chronology is retained by the
     * ConcurrentHashMap.
     * @return true if the cache was initialized
     */
    private static boolean initCache() {
<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (CHRONOS_BY_ID.get(&quot;ISO&quot;) == null) {</span>
            // Initialization is incomplete

            // Register built-in Chronologies
<span class="nc" id="L219">            registerChrono(HijrahChronology.INSTANCE);</span>
<span class="nc" id="L220">            registerChrono(JapaneseChronology.INSTANCE);</span>
<span class="nc" id="L221">            registerChrono(MinguoChronology.INSTANCE);</span>
<span class="nc" id="L222">            registerChrono(ThaiBuddhistChronology.INSTANCE);</span>

            // Register Chronologies from the ServiceLoader
            @SuppressWarnings(&quot;rawtypes&quot;)
<span class="nc" id="L226">            ServiceLoader&lt;AbstractChronology&gt; loader =  ServiceLoader.load(AbstractChronology.class, null);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            for (AbstractChronology chrono : loader) {</span>
<span class="nc" id="L228">                String id = chrono.getId();</span>
<span class="nc bnc" id="L229" title="All 4 branches missed.">                if (id.equals(&quot;ISO&quot;) || registerChrono(chrono) != null) {</span>
                    // Log the attempt to replace an existing Chronology
<span class="nc" id="L231">                    PlatformLogger logger = PlatformLogger.getLogger(&quot;java.time.chrono&quot;);</span>
<span class="nc" id="L232">                    logger.warning(&quot;Ignoring duplicate Chronology, from ServiceLoader configuration &quot;  + id);</span>
                }
<span class="nc" id="L234">            }</span>

            // finally, register IsoChronology to mark initialization is complete
<span class="nc" id="L237">            registerChrono(IsoChronology.INSTANCE);</span>
<span class="nc" id="L238">            return true;</span>
        }
<span class="nc" id="L240">        return false;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code Chronology} from a locale.
     * &lt;p&gt;
     * See {@link Chronology#ofLocale(Locale)}.
     *
     * @param locale  the locale to use to obtain the calendar system, not null
     * @return the calendar system associated with the locale, not null
     * @throws java.time.DateTimeException if the locale-specified calendar cannot be found
     */
    static Chronology ofLocale(Locale locale) {
<span class="nc" id="L254">        Objects.requireNonNull(locale, &quot;locale&quot;);</span>
<span class="nc" id="L255">        String type = locale.getUnicodeLocaleType(&quot;ca&quot;);</span>
<span class="nc bnc" id="L256" title="All 6 branches missed.">        if (type == null || &quot;iso&quot;.equals(type) || &quot;iso8601&quot;.equals(type)) {</span>
<span class="nc" id="L257">            return IsoChronology.INSTANCE;</span>
        }
        // Not pre-defined; lookup by the type
        do {
<span class="nc" id="L261">            Chronology chrono = CHRONOS_BY_TYPE.get(type);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (chrono != null) {</span>
<span class="nc" id="L263">                return chrono;</span>
            }
            // If not found, do the initialization (once) and repeat the lookup
<span class="nc bnc" id="L266" title="All 2 branches missed.">        } while (initCache());</span>

        // Look for a Chronology using ServiceLoader of the Thread's ContextClassLoader
        // Application provided Chronologies must not be cached
        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="nc" id="L271">        ServiceLoader&lt;Chronology&gt; loader = ServiceLoader.load(Chronology.class);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        for (Chronology chrono : loader) {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (type.equals(chrono.getCalendarType())) {</span>
<span class="nc" id="L274">                return chrono;</span>
            }
<span class="nc" id="L276">        }</span>
<span class="nc" id="L277">        throw new DateTimeException(&quot;Unknown calendar system: &quot; + type);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code Chronology} from a chronology ID or
     * calendar system type.
     * &lt;p&gt;
     * See {@link Chronology#of(String)}.
     *
     * @param id  the chronology ID or calendar system type, not null
     * @return the chronology with the identifier requested, not null
     * @throws java.time.DateTimeException if the chronology cannot be found
     */
    static Chronology of(String id) {
<span class="nc" id="L292">        Objects.requireNonNull(id, &quot;id&quot;);</span>
        do {
<span class="nc" id="L294">            Chronology chrono = of0(id);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (chrono != null) {</span>
<span class="nc" id="L296">                return chrono;</span>
            }
            // If not found, do the initialization (once) and repeat the lookup
<span class="nc bnc" id="L299" title="All 2 branches missed.">        } while (initCache());</span>

        // Look for a Chronology using ServiceLoader of the Thread's ContextClassLoader
        // Application provided Chronologies must not be cached
        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="nc" id="L304">        ServiceLoader&lt;Chronology&gt; loader = ServiceLoader.load(Chronology.class);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        for (Chronology chrono : loader) {</span>
<span class="nc bnc" id="L306" title="All 4 branches missed.">            if (id.equals(chrono.getId()) || id.equals(chrono.getCalendarType())) {</span>
<span class="nc" id="L307">                return chrono;</span>
            }
<span class="nc" id="L309">        }</span>
<span class="nc" id="L310">        throw new DateTimeException(&quot;Unknown chronology: &quot; + id);</span>
    }

    /**
     * Obtains an instance of {@code Chronology} from a chronology ID or
     * calendar system type.
     *
     * @param id  the chronology ID or calendar system type, not null
     * @return the chronology with the identifier requested, or {@code null} if not found
     */
    private static Chronology of0(String id) {
<span class="nc" id="L321">        Chronology chrono = CHRONOS_BY_ID.get(id);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (chrono == null) {</span>
<span class="nc" id="L323">            chrono = CHRONOS_BY_TYPE.get(id);</span>
        }
<span class="nc" id="L325">        return chrono;</span>
    }

    /**
     * Returns the available chronologies.
     * &lt;p&gt;
     * Each returned {@code Chronology} is available for use in the system.
     * The set of chronologies includes the system chronologies and
     * any chronologies provided by the application via ServiceLoader
     * configuration.
     *
     * @return the independent, modifiable set of the available chronology IDs, not null
     */
    static Set&lt;Chronology&gt; getAvailableChronologies() {
<span class="nc" id="L339">        initCache();       // force initialization</span>
<span class="nc" id="L340">        HashSet&lt;Chronology&gt; chronos = new HashSet&lt;&gt;(CHRONOS_BY_ID.values());</span>

        /// Add in Chronologies from the ServiceLoader configuration
        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="nc" id="L344">        ServiceLoader&lt;Chronology&gt; loader = ServiceLoader.load(Chronology.class);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">        for (Chronology chrono : loader) {</span>
<span class="nc" id="L346">            chronos.add(chrono);</span>
<span class="nc" id="L347">        }</span>
<span class="nc" id="L348">        return chronos;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Creates an instance.
     */
<span class="fc" id="L355">    protected AbstractChronology() {</span>
<span class="fc" id="L356">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Resolves parsed {@code ChronoField} values into a date during parsing.
     * &lt;p&gt;
     * Most {@code TemporalField} implementations are resolved using the
     * resolve method on the field. By contrast, the {@code ChronoField} class
     * defines fields that only have meaning relative to the chronology.
     * As such, {@code ChronoField} date fields are resolved here in the
     * context of a specific chronology.
     * &lt;p&gt;
     * {@code ChronoField} instances are resolved by this method, which may
     * be overridden in subclasses.
     * &lt;ul&gt;
     * &lt;li&gt;{@code EPOCH_DAY} - If present, this is converted to a date and
     *  all other date fields are then cross-checked against the date.
     * &lt;li&gt;{@code PROLEPTIC_MONTH} - If present, then it is split into the
     *  {@code YEAR} and {@code MONTH_OF_YEAR}. If the mode is strict or smart
     *  then the field is validated.
     * &lt;li&gt;{@code YEAR_OF_ERA} and {@code ERA} - If both are present, then they
     *  are combined to form a {@code YEAR}. In lenient mode, the {@code YEAR_OF_ERA}
     *  range is not validated, in smart and strict mode it is. The {@code ERA} is
     *  validated for range in all three modes. If only the {@code YEAR_OF_ERA} is
     *  present, and the mode is smart or lenient, then the last available era
     *  is assumed. In strict mode, no era is assumed and the {@code YEAR_OF_ERA} is
     *  left untouched. If only the {@code ERA} is present, then it is left untouched.
     * &lt;li&gt;{@code YEAR}, {@code MONTH_OF_YEAR} and {@code DAY_OF_MONTH} -
     *  If all three are present, then they are combined to form a date.
     *  In all three modes, the {@code YEAR} is validated.
     *  If the mode is smart or strict, then the month and day are validated.
     *  If the mode is lenient, then the date is combined in a manner equivalent to
     *  creating a date on the first day of the first month in the requested year,
     *  then adding the difference in months, then the difference in days.
     *  If the mode is smart, and the day-of-month is greater than the maximum for
     *  the year-month, then the day-of-month is adjusted to the last day-of-month.
     *  If the mode is strict, then the three fields must form a valid date.
     * &lt;li&gt;{@code YEAR} and {@code DAY_OF_YEAR} -
     *  If both are present, then they are combined to form a date.
     *  In all three modes, the {@code YEAR} is validated.
     *  If the mode is lenient, then the date is combined in a manner equivalent to
     *  creating a date on the first day of the requested year, then adding
     *  the difference in days.
     *  If the mode is smart or strict, then the two fields must form a valid date.
     * &lt;li&gt;{@code YEAR}, {@code MONTH_OF_YEAR}, {@code ALIGNED_WEEK_OF_MONTH} and
     *  {@code ALIGNED_DAY_OF_WEEK_IN_MONTH} -
     *  If all four are present, then they are combined to form a date.
     *  In all three modes, the {@code YEAR} is validated.
     *  If the mode is lenient, then the date is combined in a manner equivalent to
     *  creating a date on the first day of the first month in the requested year, then adding
     *  the difference in months, then the difference in weeks, then in days.
     *  If the mode is smart or strict, then the all four fields are validated to
     *  their outer ranges. The date is then combined in a manner equivalent to
     *  creating a date on the first day of the requested year and month, then adding
     *  the amount in weeks and days to reach their values. If the mode is strict,
     *  the date is additionally validated to check that the day and week adjustment
     *  did not change the month.
     * &lt;li&gt;{@code YEAR}, {@code MONTH_OF_YEAR}, {@code ALIGNED_WEEK_OF_MONTH} and
     *  {@code DAY_OF_WEEK} - If all four are present, then they are combined to
     *  form a date. The approach is the same as described above for
     *  years, months and weeks in {@code ALIGNED_DAY_OF_WEEK_IN_MONTH}.
     *  The day-of-week is adjusted as the next or same matching day-of-week once
     *  the years, months and weeks have been handled.
     * &lt;li&gt;{@code YEAR}, {@code ALIGNED_WEEK_OF_YEAR} and {@code ALIGNED_DAY_OF_WEEK_IN_YEAR} -
     *  If all three are present, then they are combined to form a date.
     *  In all three modes, the {@code YEAR} is validated.
     *  If the mode is lenient, then the date is combined in a manner equivalent to
     *  creating a date on the first day of the requested year, then adding
     *  the difference in weeks, then in days.
     *  If the mode is smart or strict, then the all three fields are validated to
     *  their outer ranges. The date is then combined in a manner equivalent to
     *  creating a date on the first day of the requested year, then adding
     *  the amount in weeks and days to reach their values. If the mode is strict,
     *  the date is additionally validated to check that the day and week adjustment
     *  did not change the year.
     * &lt;li&gt;{@code YEAR}, {@code ALIGNED_WEEK_OF_YEAR} and {@code DAY_OF_WEEK} -
     *  If all three are present, then they are combined to form a date.
     *  The approach is the same as described above for years and weeks in
     *  {@code ALIGNED_DAY_OF_WEEK_IN_YEAR}. The day-of-week is adjusted as the
     *  next or same matching day-of-week once the years and weeks have been handled.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The default implementation is suitable for most calendar systems.
     * If {@link java.time.temporal.ChronoField#YEAR_OF_ERA} is found without an {@link java.time.temporal.ChronoField#ERA}
     * then the last era in {@link #eras()} is used.
     * The implementation assumes a 7 day week, that the first day-of-month
     * has the value 1, that first day-of-year has the value 1, and that the
     * first of the month and year always exists.
     *
     * @param fieldValues  the map of fields to values, which can be updated, not null
     * @param resolverStyle  the requested type of resolve, not null
     * @return the resolved date, null if insufficient information to create a date
     * @throws java.time.DateTimeException if the date cannot be resolved, typically
     *  because of a conflict in the input data
     */
    @Override
    public ChronoLocalDate resolveDate(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
        // check epoch-day before inventing era
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (fieldValues.containsKey(EPOCH_DAY)) {</span>
<span class="nc" id="L455">            return dateEpochDay(fieldValues.remove(EPOCH_DAY));</span>
        }

        // fix proleptic month before inventing era
<span class="nc" id="L459">        resolveProlepticMonth(fieldValues, resolverStyle);</span>

        // invent era if necessary to resolve year-of-era
<span class="nc" id="L462">        ChronoLocalDate resolved = resolveYearOfEra(fieldValues, resolverStyle);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (resolved != null) {</span>
<span class="nc" id="L464">            return resolved;</span>
        }

        // build date
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (fieldValues.containsKey(YEAR)) {</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">            if (fieldValues.containsKey(MONTH_OF_YEAR)) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">                if (fieldValues.containsKey(DAY_OF_MONTH)) {</span>
<span class="nc" id="L471">                    return resolveYMD(fieldValues, resolverStyle);</span>
                }
<span class="nc bnc" id="L473" title="All 2 branches missed.">                if (fieldValues.containsKey(ALIGNED_WEEK_OF_MONTH)) {</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">                    if (fieldValues.containsKey(ALIGNED_DAY_OF_WEEK_IN_MONTH)) {</span>
<span class="nc" id="L475">                        return resolveYMAA(fieldValues, resolverStyle);</span>
                    }
<span class="nc bnc" id="L477" title="All 2 branches missed.">                    if (fieldValues.containsKey(DAY_OF_WEEK)) {</span>
<span class="nc" id="L478">                        return resolveYMAD(fieldValues, resolverStyle);</span>
                    }
                }
            }
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if (fieldValues.containsKey(DAY_OF_YEAR)) {</span>
<span class="nc" id="L483">                return resolveYD(fieldValues, resolverStyle);</span>
            }
<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (fieldValues.containsKey(ALIGNED_WEEK_OF_YEAR)) {</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                if (fieldValues.containsKey(ALIGNED_DAY_OF_WEEK_IN_YEAR)) {</span>
<span class="nc" id="L487">                    return resolveYAA(fieldValues, resolverStyle);</span>
                }
<span class="nc bnc" id="L489" title="All 2 branches missed.">                if (fieldValues.containsKey(DAY_OF_WEEK)) {</span>
<span class="nc" id="L490">                    return resolveYAD(fieldValues, resolverStyle);</span>
                }
            }
        }
<span class="nc" id="L494">        return null;</span>
    }

    void resolveProlepticMonth(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
<span class="nc" id="L498">        Long pMonth = fieldValues.remove(PROLEPTIC_MONTH);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (pMonth != null) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (resolverStyle != ResolverStyle.LENIENT) {</span>
<span class="nc" id="L501">                PROLEPTIC_MONTH.checkValidValue(pMonth);</span>
            }
            // first day-of-month is likely to be safest for setting proleptic-month
            // cannot add to year zero, as not all chronologies have a year zero
<span class="nc" id="L505">            ChronoLocalDate chronoDate = dateNow()</span>
<span class="nc" id="L506">                    .with(DAY_OF_MONTH, 1).with(PROLEPTIC_MONTH, pMonth);</span>
<span class="nc" id="L507">            addFieldValue(fieldValues, MONTH_OF_YEAR, chronoDate.get(MONTH_OF_YEAR));</span>
<span class="nc" id="L508">            addFieldValue(fieldValues, YEAR, chronoDate.get(YEAR));</span>
        }
<span class="nc" id="L510">    }</span>

    ChronoLocalDate resolveYearOfEra(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
<span class="nc" id="L513">        Long yoeLong = fieldValues.remove(YEAR_OF_ERA);</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (yoeLong != null) {</span>
<span class="nc" id="L515">            Long eraLong = fieldValues.remove(ERA);</span>
            int yoe;
<span class="nc bnc" id="L517" title="All 2 branches missed.">            if (resolverStyle != ResolverStyle.LENIENT) {</span>
<span class="nc" id="L518">                yoe = range(YEAR_OF_ERA).checkValidIntValue(yoeLong, YEAR_OF_ERA);</span>
            } else {
<span class="nc" id="L520">                yoe = Math.toIntExact(yoeLong);</span>
            }
<span class="nc bnc" id="L522" title="All 2 branches missed.">            if (eraLong != null) {</span>
<span class="nc" id="L523">                Era eraObj = eraOf(range(ERA).checkValidIntValue(eraLong, ERA));</span>
<span class="nc" id="L524">                addFieldValue(fieldValues, YEAR, prolepticYear(eraObj, yoe));</span>
<span class="nc" id="L525">            } else {</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">                if (fieldValues.containsKey(YEAR)) {</span>
<span class="nc" id="L527">                    int year = range(YEAR).checkValidIntValue(fieldValues.get(YEAR), YEAR);</span>
<span class="nc" id="L528">                    ChronoLocalDate chronoDate = dateYearDay(year, 1);</span>
<span class="nc" id="L529">                    addFieldValue(fieldValues, YEAR, prolepticYear(chronoDate.getEra(), yoe));</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                } else if (resolverStyle == ResolverStyle.STRICT) {</span>
                    // do not invent era if strict
                    // reinstate the field removed earlier, no cross-check issues
<span class="nc" id="L533">                    fieldValues.put(YEAR_OF_ERA, yoeLong);</span>
                } else {
<span class="nc" id="L535">                    List&lt;Era&gt; eras = eras();</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                    if (eras.isEmpty()) {</span>
<span class="nc" id="L537">                        addFieldValue(fieldValues, YEAR, yoe);</span>
                    } else {
<span class="nc" id="L539">                        Era eraObj = eras.get(eras.size() - 1);</span>
<span class="nc" id="L540">                        addFieldValue(fieldValues, YEAR, prolepticYear(eraObj, yoe));</span>
                    }
                }
            }
<span class="nc bnc" id="L544" title="All 2 branches missed.">        } else if (fieldValues.containsKey(ERA)) {</span>
<span class="nc" id="L545">            range(ERA).checkValidValue(fieldValues.get(ERA), ERA);  // always validated</span>
        }
<span class="nc" id="L547">        return null;</span>
    }

    ChronoLocalDate resolveYMD(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
<span class="nc" id="L551">        int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L553">            long months = Math.subtractExact(fieldValues.remove(MONTH_OF_YEAR), 1);</span>
<span class="nc" id="L554">            long days = Math.subtractExact(fieldValues.remove(DAY_OF_MONTH), 1);</span>
<span class="nc" id="L555">            return date(y, 1, 1).plus(months, MONTHS).plus(days, DAYS);</span>
        }
<span class="nc" id="L557">        int moy = range(MONTH_OF_YEAR).checkValidIntValue(fieldValues.remove(MONTH_OF_YEAR), MONTH_OF_YEAR);</span>
<span class="nc" id="L558">        ValueRange domRange = range(DAY_OF_MONTH);</span>
<span class="nc" id="L559">        int dom = domRange.checkValidIntValue(fieldValues.remove(DAY_OF_MONTH), DAY_OF_MONTH);</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (resolverStyle == ResolverStyle.SMART) {  // previous valid</span>
            try {
<span class="nc" id="L562">                return date(y, moy, dom);</span>
<span class="nc" id="L563">            } catch (DateTimeException ex) {</span>
<span class="nc" id="L564">                return date(y, moy, 1).with(TemporalAdjusters.lastDayOfMonth());</span>
            }
        }
<span class="nc" id="L567">        return date(y, moy, dom);</span>
    }

    ChronoLocalDate resolveYD(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
<span class="nc" id="L571">        int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L573">            long days = Math.subtractExact(fieldValues.remove(DAY_OF_YEAR), 1);</span>
<span class="nc" id="L574">            return dateYearDay(y, 1).plus(days, DAYS);</span>
        }
<span class="nc" id="L576">        int doy = range(DAY_OF_YEAR).checkValidIntValue(fieldValues.remove(DAY_OF_YEAR), DAY_OF_YEAR);</span>
<span class="nc" id="L577">        return dateYearDay(y, doy);  // smart is same as strict</span>
    }

    ChronoLocalDate resolveYMAA(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
<span class="nc" id="L581">        int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">        if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L583">            long months = Math.subtractExact(fieldValues.remove(MONTH_OF_YEAR), 1);</span>
<span class="nc" id="L584">            long weeks = Math.subtractExact(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);</span>
<span class="nc" id="L585">            long days = Math.subtractExact(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH), 1);</span>
<span class="nc" id="L586">            return date(y, 1, 1).plus(months, MONTHS).plus(weeks, WEEKS).plus(days, DAYS);</span>
        }
<span class="nc" id="L588">        int moy = range(MONTH_OF_YEAR).checkValidIntValue(fieldValues.remove(MONTH_OF_YEAR), MONTH_OF_YEAR);</span>
<span class="nc" id="L589">        int aw = range(ALIGNED_WEEK_OF_MONTH).checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), ALIGNED_WEEK_OF_MONTH);</span>
<span class="nc" id="L590">        int ad = range(ALIGNED_DAY_OF_WEEK_IN_MONTH).checkValidIntValue(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH), ALIGNED_DAY_OF_WEEK_IN_MONTH);</span>
<span class="nc" id="L591">        ChronoLocalDate date = date(y, moy, 1).plus((aw - 1) * 7 + (ad - 1), DAYS);</span>
<span class="nc bnc" id="L592" title="All 4 branches missed.">        if (resolverStyle == ResolverStyle.STRICT &amp;&amp; date.get(MONTH_OF_YEAR) != moy) {</span>
<span class="nc" id="L593">            throw new DateTimeException(&quot;Strict mode rejected resolved date as it is in a different month&quot;);</span>
        }
<span class="nc" id="L595">        return date;</span>
    }

    ChronoLocalDate resolveYMAD(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
<span class="nc" id="L599">        int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L601">            long months = Math.subtractExact(fieldValues.remove(MONTH_OF_YEAR), 1);</span>
<span class="nc" id="L602">            long weeks = Math.subtractExact(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);</span>
<span class="nc" id="L603">            long dow = Math.subtractExact(fieldValues.remove(DAY_OF_WEEK), 1);</span>
<span class="nc" id="L604">            return resolveAligned(date(y, 1, 1), months, weeks, dow);</span>
        }
<span class="nc" id="L606">        int moy = range(MONTH_OF_YEAR).checkValidIntValue(fieldValues.remove(MONTH_OF_YEAR), MONTH_OF_YEAR);</span>
<span class="nc" id="L607">        int aw = range(ALIGNED_WEEK_OF_MONTH).checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), ALIGNED_WEEK_OF_MONTH);</span>
<span class="nc" id="L608">        int dow = range(DAY_OF_WEEK).checkValidIntValue(fieldValues.remove(DAY_OF_WEEK), DAY_OF_WEEK);</span>
<span class="nc" id="L609">        ChronoLocalDate date = date(y, moy, 1).plus((aw - 1) * 7, DAYS).with(nextOrSame(DayOfWeek.of(dow)));</span>
<span class="nc bnc" id="L610" title="All 4 branches missed.">        if (resolverStyle == ResolverStyle.STRICT &amp;&amp; date.get(MONTH_OF_YEAR) != moy) {</span>
<span class="nc" id="L611">            throw new DateTimeException(&quot;Strict mode rejected resolved date as it is in a different month&quot;);</span>
        }
<span class="nc" id="L613">        return date;</span>
    }

    ChronoLocalDate resolveYAA(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
<span class="nc" id="L617">        int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">        if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L619">            long weeks = Math.subtractExact(fieldValues.remove(ALIGNED_WEEK_OF_YEAR), 1);</span>
<span class="nc" id="L620">            long days = Math.subtractExact(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);</span>
<span class="nc" id="L621">            return dateYearDay(y, 1).plus(weeks, WEEKS).plus(days, DAYS);</span>
        }
<span class="nc" id="L623">        int aw = range(ALIGNED_WEEK_OF_YEAR).checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_YEAR), ALIGNED_WEEK_OF_YEAR);</span>
<span class="nc" id="L624">        int ad = range(ALIGNED_DAY_OF_WEEK_IN_YEAR).checkValidIntValue(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_YEAR), ALIGNED_DAY_OF_WEEK_IN_YEAR);</span>
<span class="nc" id="L625">        ChronoLocalDate date = dateYearDay(y, 1).plus((aw - 1) * 7 + (ad - 1), DAYS);</span>
<span class="nc bnc" id="L626" title="All 4 branches missed.">        if (resolverStyle == ResolverStyle.STRICT &amp;&amp; date.get(YEAR) != y) {</span>
<span class="nc" id="L627">            throw new DateTimeException(&quot;Strict mode rejected resolved date as it is in a different year&quot;);</span>
        }
<span class="nc" id="L629">        return date;</span>
    }

    ChronoLocalDate resolveYAD(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
<span class="nc" id="L633">        int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">        if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L635">            long weeks = Math.subtractExact(fieldValues.remove(ALIGNED_WEEK_OF_YEAR), 1);</span>
<span class="nc" id="L636">            long dow = Math.subtractExact(fieldValues.remove(DAY_OF_WEEK), 1);</span>
<span class="nc" id="L637">            return resolveAligned(dateYearDay(y, 1), 0, weeks, dow);</span>
        }
<span class="nc" id="L639">        int aw = range(ALIGNED_WEEK_OF_YEAR).checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_YEAR), ALIGNED_WEEK_OF_YEAR);</span>
<span class="nc" id="L640">        int dow = range(DAY_OF_WEEK).checkValidIntValue(fieldValues.remove(DAY_OF_WEEK), DAY_OF_WEEK);</span>
<span class="nc" id="L641">        ChronoLocalDate date = dateYearDay(y, 1).plus((aw - 1) * 7, DAYS).with(nextOrSame(DayOfWeek.of(dow)));</span>
<span class="nc bnc" id="L642" title="All 4 branches missed.">        if (resolverStyle == ResolverStyle.STRICT &amp;&amp; date.get(YEAR) != y) {</span>
<span class="nc" id="L643">            throw new DateTimeException(&quot;Strict mode rejected resolved date as it is in a different year&quot;);</span>
        }
<span class="nc" id="L645">        return date;</span>
    }

    ChronoLocalDate resolveAligned(ChronoLocalDate base, long months, long weeks, long dow) {
<span class="nc" id="L649">        ChronoLocalDate date = base.plus(months, MONTHS).plus(weeks, WEEKS);</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">        if (dow &gt; 7) {</span>
<span class="nc" id="L651">            date = date.plus((dow - 1) / 7, WEEKS);</span>
<span class="nc" id="L652">            dow = ((dow - 1) % 7) + 1;</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">        } else if (dow &lt; 1) {</span>
<span class="nc" id="L654">            date = date.plus(Math.subtractExact(dow,  7) / 7, WEEKS);</span>
<span class="nc" id="L655">            dow = ((dow + 6) % 7) + 1;</span>
        }
<span class="nc" id="L657">        return date.with(nextOrSame(DayOfWeek.of((int) dow)));</span>
    }

    /**
     * Adds a field-value pair to the map, checking for conflicts.
     * &lt;p&gt;
     * If the field is not already present, then the field-value pair is added to the map.
     * If the field is already present and it has the same value as that specified, no action occurs.
     * If the field is already present and it has a different value to that specified, then
     * an exception is thrown.
     *
     * @param field  the field to add, not null
     * @param value  the value to add, not null
     * @throws java.time.DateTimeException if the field is already present with a different value
     */
    void addFieldValue(Map&lt;TemporalField, Long&gt; fieldValues, ChronoField field, long value) {
<span class="nc" id="L673">        Long old = fieldValues.get(field);  // check first for better error message</span>
<span class="nc bnc" id="L674" title="All 4 branches missed.">        if (old != null &amp;&amp; old.longValue() != value) {</span>
<span class="nc" id="L675">            throw new DateTimeException(&quot;Conflict found: &quot; + field + &quot; &quot; + old + &quot; differs from &quot; + field + &quot; &quot; + value);</span>
        }
<span class="nc" id="L677">        fieldValues.put(field, value);</span>
<span class="nc" id="L678">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Compares this chronology to another chronology.
     * &lt;p&gt;
     * The comparison order first by the chronology ID string, then by any
     * additional information specific to the subclass.
     * It is &quot;consistent with equals&quot;, as defined by {@link Comparable}.
     *
     * @implSpec
     * This implementation compares the chronology ID.
     * Subclasses must compare any additional state that they store.
     *
     * @param other  the other chronology to compare to, not null
     * @return the comparator value, negative if less, positive if greater
     */
    @Override
    public int compareTo(Chronology other) {
<span class="nc" id="L697">        return getId().compareTo(other.getId());</span>
    }

    /**
     * Checks if this chronology is equal to another chronology.
     * &lt;p&gt;
     * The comparison is based on the entire state of the object.
     *
     * @implSpec
     * This implementation checks the type and calls
     * {@link #compareTo(java.time.chrono.Chronology)}.
     *
     * @param obj  the object to check, null returns false
     * @return true if this is equal to the other chronology
     */
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L715">           return true;</span>
        }
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (obj instanceof AbstractChronology) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">            return compareTo((AbstractChronology) obj) == 0;</span>
        }
<span class="nc" id="L720">        return false;</span>
    }

    /**
     * A hash code for this chronology.
     * &lt;p&gt;
     * The hash code should be based on the entire state of the object.
     *
     * @implSpec
     * This implementation is based on the chronology ID and class.
     * Subclasses should add any additional state that they store.
     *
     * @return a suitable hash code
     */
    @Override
    public int hashCode() {
<span class="nc" id="L736">        return getClass().hashCode() ^ getId().hashCode();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Outputs this chronology as a {@code String}, using the chronology ID.
     *
     * @return a string representation of this chronology, not null
     */
    @Override
    public String toString() {
<span class="nc" id="L747">        return getId();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Writes the Chronology using a
     * &lt;a href=&quot;../../../serialized-form.html#java.time.chrono.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
     * &lt;pre&gt;
     *  out.writeByte(1);  // identifies this as a Chronology
     *  out.writeUTF(getId());
     * &lt;/pre&gt;
     *
     * @return the instance of {@code Ser}, not null
     */
    Object writeReplace() {
<span class="nc" id="L762">        return new Ser(Ser.CHRONO_TYPE, this);</span>
    }

    /**
     * Defend against malicious streams.
     * @return never
     * @throws java.io.InvalidObjectException always
     */
    private Object readResolve() throws ObjectStreamException {
<span class="nc" id="L771">        throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);</span>
    }

    void writeExternal(DataOutput out) throws IOException {
<span class="nc" id="L775">        out.writeUTF(getId());</span>
<span class="nc" id="L776">    }</span>

    static Chronology readExternal(DataInput in) throws IOException {
<span class="nc" id="L779">        String id = in.readUTF();</span>
<span class="nc" id="L780">        return Chronology.of(id);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>