<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractPlainSocketImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">AbstractPlainSocketImpl.java</span></div><h1>AbstractPlainSocketImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.FileDescriptor;

import sun.net.ConnectionResetException;
import sun.net.NetHooks;
import sun.net.ResourceManager;

/**
 * Default Socket Implementation. This implementation does
 * not implement any security checks.
 * Note this class should &lt;b&gt;NOT&lt;/b&gt; be public.
 *
 * @author  Steven B. Byrne
 */
<span class="fc" id="L44">abstract class AbstractPlainSocketImpl extends SocketImpl</span>
{
    /* instance variable for SO_TIMEOUT */
    int timeout;   // timeout in millisec
    // traffic class
    private int trafficClass;

<span class="fc" id="L51">    private boolean shut_rd = false;</span>
<span class="fc" id="L52">    private boolean shut_wr = false;</span>

<span class="fc" id="L54">    private SocketInputStream socketInputStream = null;</span>
<span class="fc" id="L55">    private SocketOutputStream socketOutputStream = null;</span>

    /* number of threads using the FileDescriptor */
<span class="fc" id="L58">    protected int fdUseCount = 0;</span>

    /* lock when increment/decrementing fdUseCount */
<span class="fc" id="L61">    protected final Object fdLock = new Object();</span>

    /* indicates a close is pending on the file descriptor */
<span class="fc" id="L64">    protected boolean closePending = false;</span>

    /* indicates connection reset state */
<span class="fc" id="L67">    private int CONNECTION_NOT_RESET = 0;</span>
<span class="fc" id="L68">    private int CONNECTION_RESET_PENDING = 1;</span>
<span class="fc" id="L69">    private int CONNECTION_RESET = 2;</span>
    private int resetState;
<span class="fc" id="L71">    private final Object resetLock = new Object();</span>

   /* whether this Socket is a stream (TCP) socket or not (UDP)
    */
    protected boolean stream;

    /**
     * Load net library into runtime.
     */
    static {
<span class="fc" id="L81">        java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L82">            new java.security.PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
<span class="fc" id="L84">                    System.loadLibrary(&quot;net&quot;);</span>
<span class="fc" id="L85">                    return null;</span>
                }
            });
<span class="fc" id="L88">    }</span>

    /**
     * Creates a socket with a boolean that specifies whether this
     * is a stream socket (true) or an unconnected UDP socket (false).
     */
    protected synchronized void create(boolean stream) throws IOException {
<span class="fc" id="L95">        this.stream = stream;</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if (!stream) {</span>
<span class="nc" id="L97">            ResourceManager.beforeUdpCreate();</span>
            // only create the fd after we know we will be able to create the socket
<span class="nc" id="L99">            fd = new FileDescriptor();</span>
            try {
<span class="nc" id="L101">                socketCreate(false);</span>
<span class="nc" id="L102">            } catch (IOException ioe) {</span>
<span class="nc" id="L103">                ResourceManager.afterUdpClose();</span>
<span class="nc" id="L104">                fd = null;</span>
<span class="nc" id="L105">                throw ioe;</span>
<span class="nc" id="L106">            }</span>
        } else {
<span class="fc" id="L108">            fd = new FileDescriptor();</span>
<span class="fc" id="L109">            socketCreate(true);</span>
        }
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (socket != null)</span>
<span class="fc" id="L112">            socket.setCreated();</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (serverSocket != null)</span>
<span class="fc" id="L114">            serverSocket.setCreated();</span>
<span class="fc" id="L115">    }</span>

    /**
     * Creates a socket and connects it to the specified port on
     * the specified host.
     * @param host the specified host
     * @param port the specified port
     */
    protected void connect(String host, int port)
        throws UnknownHostException, IOException
    {
<span class="nc" id="L126">        boolean connected = false;</span>
        try {
<span class="nc" id="L128">            InetAddress address = InetAddress.getByName(host);</span>
<span class="nc" id="L129">            this.port = port;</span>
<span class="nc" id="L130">            this.address = address;</span>

<span class="nc" id="L132">            connectToAddress(address, port, timeout);</span>
<span class="nc" id="L133">            connected = true;</span>
        } finally {
<span class="nc bnc" id="L135" title="All 4 branches missed.">            if (!connected) {</span>
                try {
<span class="nc" id="L137">                    close();</span>
<span class="nc" id="L138">                } catch (IOException ioe) {</span>
                    /* Do nothing. If connect threw an exception then
                       it will be passed up the call stack */
<span class="nc" id="L141">                }</span>
            }
        }
<span class="nc" id="L144">    }</span>

    /**
     * Creates a socket and connects it to the specified address on
     * the specified port.
     * @param address the address
     * @param port the specified port
     */
    protected void connect(InetAddress address, int port) throws IOException {
<span class="nc" id="L153">        this.port = port;</span>
<span class="nc" id="L154">        this.address = address;</span>

        try {
<span class="nc" id="L157">            connectToAddress(address, port, timeout);</span>
<span class="nc" id="L158">            return;</span>
<span class="nc" id="L159">        } catch (IOException e) {</span>
            // everything failed
<span class="nc" id="L161">            close();</span>
<span class="nc" id="L162">            throw e;</span>
        }
    }

    /**
     * Creates a socket and connects it to the specified address on
     * the specified port.
     * @param address the address
     * @param timeout the timeout value in milliseconds, or zero for no timeout.
     * @throws IOException if connection fails
     * @throws  IllegalArgumentException if address is null or is a
     *          SocketAddress subclass not supported by this socket
     * @since 1.4
     */
    protected void connect(SocketAddress address, int timeout)
            throws IOException {
<span class="fc" id="L178">        boolean connected = false;</span>
        try {
<span class="pc bpc" id="L180" title="2 of 4 branches missed.">            if (address == null || !(address instanceof InetSocketAddress))</span>
<span class="nc" id="L181">                throw new IllegalArgumentException(&quot;unsupported address type&quot;);</span>
<span class="fc" id="L182">            InetSocketAddress addr = (InetSocketAddress) address;</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">            if (addr.isUnresolved())</span>
<span class="fc" id="L184">                throw new UnknownHostException(addr.getHostName());</span>
<span class="fc" id="L185">            this.port = addr.getPort();</span>
<span class="fc" id="L186">            this.address = addr.getAddress();</span>

<span class="fc" id="L188">            connectToAddress(this.address, port, timeout);</span>
<span class="fc" id="L189">            connected = true;</span>
        } finally {
<span class="pc bpc" id="L191" title="2 of 4 branches missed.">            if (!connected) {</span>
                try {
<span class="pc" id="L193">                    close();</span>
<span class="nc" id="L194">                } catch (IOException ioe) {</span>
                    /* Do nothing. If connect threw an exception then
                       it will be passed up the call stack */
<span class="pc" id="L197">                }</span>
            }
        }
<span class="fc" id="L200">    }</span>

    private void connectToAddress(InetAddress address, int port, int timeout) throws IOException {
<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (address.isAnyLocalAddress()) {</span>
<span class="fc" id="L204">            doConnect(InetAddress.getLocalHost(), port, timeout);</span>
        } else {
<span class="fc" id="L206">            doConnect(address, port, timeout);</span>
        }
<span class="fc" id="L208">    }</span>

    public void setOption(int opt, Object val) throws SocketException {
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (isClosedOrPending()) {</span>
<span class="nc" id="L212">            throw new SocketException(&quot;Socket Closed&quot;);</span>
        }
<span class="fc" id="L214">        boolean on = true;</span>
<span class="pc bpc" id="L215" title="4 of 10 branches missed.">        switch (opt) {</span>
            /* check type safety b4 going native.  These should never
             * fail, since only java.Socket* has access to
             * PlainSocketImpl.setOption().
             */
        case SO_LINGER:
<span class="pc bpc" id="L221" title="4 of 6 branches missed.">            if (val == null || (!(val instanceof Integer) &amp;&amp; !(val instanceof Boolean)))</span>
<span class="nc" id="L222">                throw new SocketException(&quot;Bad parameter for option&quot;);</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            if (val instanceof Boolean) {</span>
                /* true only if disabling - enabling should be Integer */
<span class="nc" id="L225">                on = false;</span>
            }
            break;
        case SO_TIMEOUT:
<span class="pc bpc" id="L229" title="2 of 4 branches missed.">            if (val == null || (!(val instanceof Integer)))</span>
<span class="nc" id="L230">                throw new SocketException(&quot;Bad parameter for SO_TIMEOUT&quot;);</span>
<span class="fc" id="L231">            int tmp = ((Integer) val).intValue();</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">            if (tmp &lt; 0)</span>
<span class="nc" id="L233">                throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
<span class="fc" id="L234">            timeout = tmp;</span>
<span class="fc" id="L235">            break;</span>
        case IP_TOS:
<span class="pc bpc" id="L237" title="2 of 4 branches missed.">             if (val == null || !(val instanceof Integer)) {</span>
<span class="nc" id="L238">                 throw new SocketException(&quot;bad argument for IP_TOS&quot;);</span>
             }
<span class="fc" id="L240">             trafficClass = ((Integer)val).intValue();</span>
<span class="fc" id="L241">             break;</span>
        case SO_BINDADDR:
<span class="nc" id="L243">            throw new SocketException(&quot;Cannot re-bind socket&quot;);</span>
        case TCP_NODELAY:
<span class="pc bpc" id="L245" title="2 of 4 branches missed.">            if (val == null || !(val instanceof Boolean))</span>
<span class="nc" id="L246">                throw new SocketException(&quot;bad parameter for TCP_NODELAY&quot;);</span>
<span class="fc" id="L247">            on = ((Boolean)val).booleanValue();</span>
<span class="fc" id="L248">            break;</span>
        case SO_SNDBUF:
        case SO_RCVBUF:
<span class="nc bnc" id="L251" title="All 4 branches missed.">            if (val == null || !(val instanceof Integer) ||</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                !(((Integer)val).intValue() &gt; 0)) {</span>
<span class="nc" id="L253">                throw new SocketException(&quot;bad parameter for SO_SNDBUF &quot; +</span>
                                          &quot;or SO_RCVBUF&quot;);
            }
            break;
        case SO_KEEPALIVE:
<span class="pc bpc" id="L258" title="2 of 4 branches missed.">            if (val == null || !(val instanceof Boolean))</span>
<span class="nc" id="L259">                throw new SocketException(&quot;bad parameter for SO_KEEPALIVE&quot;);</span>
<span class="fc" id="L260">            on = ((Boolean)val).booleanValue();</span>
<span class="fc" id="L261">            break;</span>
        case SO_OOBINLINE:
<span class="nc bnc" id="L263" title="All 4 branches missed.">            if (val == null || !(val instanceof Boolean))</span>
<span class="nc" id="L264">                throw new SocketException(&quot;bad parameter for SO_OOBINLINE&quot;);</span>
<span class="nc" id="L265">            on = ((Boolean)val).booleanValue();</span>
<span class="nc" id="L266">            break;</span>
        case SO_REUSEADDR:
<span class="pc bpc" id="L268" title="2 of 4 branches missed.">            if (val == null || !(val instanceof Boolean))</span>
<span class="nc" id="L269">                throw new SocketException(&quot;bad parameter for SO_REUSEADDR&quot;);</span>
<span class="fc" id="L270">            on = ((Boolean)val).booleanValue();</span>
<span class="fc" id="L271">            break;</span>
        default:
<span class="nc" id="L273">            throw new SocketException(&quot;unrecognized TCP option: &quot; + opt);</span>
        }
<span class="fc" id="L275">        socketSetOption(opt, on, val);</span>
<span class="fc" id="L276">    }</span>
    public Object getOption(int opt) throws SocketException {
<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (isClosedOrPending()) {</span>
<span class="fc" id="L279">            throw new SocketException(&quot;Socket Closed&quot;);</span>
        }
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (opt == SO_TIMEOUT) {</span>
<span class="fc" id="L282">            return new Integer(timeout);</span>
        }
<span class="fc" id="L284">        int ret = 0;</span>
        /*
         * The native socketGetOption() knows about 3 options.
         * The 32 bit value it returns will be interpreted according
         * to what we're asking.  A return of -1 means it understands
         * the option but its turned off.  It will raise a SocketException
         * if &quot;opt&quot; isn't one it understands.
         */

<span class="pc bpc" id="L293" title="4 of 9 branches missed.">        switch (opt) {</span>
        case TCP_NODELAY:
<span class="fc" id="L295">            ret = socketGetOption(opt, null);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            return Boolean.valueOf(ret != -1);</span>
        case SO_OOBINLINE:
<span class="nc" id="L298">            ret = socketGetOption(opt, null);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">            return Boolean.valueOf(ret != -1);</span>
        case SO_LINGER:
<span class="fc" id="L301">            ret = socketGetOption(opt, null);</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">            return (ret == -1) ? Boolean.FALSE: (Object)(new Integer(ret));</span>
        case SO_REUSEADDR:
<span class="fc" id="L304">            ret = socketGetOption(opt, null);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">            return Boolean.valueOf(ret != -1);</span>
        case SO_BINDADDR:
<span class="fc" id="L307">            InetAddressContainer in = new InetAddressContainer();</span>
<span class="fc" id="L308">            ret = socketGetOption(opt, in);</span>
<span class="fc" id="L309">            return in.addr;</span>
        case SO_SNDBUF:
        case SO_RCVBUF:
<span class="nc" id="L312">            ret = socketGetOption(opt, null);</span>
<span class="nc" id="L313">            return new Integer(ret);</span>
        case IP_TOS:
<span class="fc" id="L315">            ret = socketGetOption(opt, null);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            if (ret == -1) { // ipv6 tos</span>
<span class="fc" id="L317">                return new Integer(trafficClass);</span>
            } else {
<span class="nc" id="L319">                return new Integer(ret);</span>
            }
        case SO_KEEPALIVE:
<span class="nc" id="L322">            ret = socketGetOption(opt, null);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            return Boolean.valueOf(ret != -1);</span>
        // should never get here
        default:
<span class="nc" id="L326">            return null;</span>
        }
    }

    /**
     * The workhorse of the connection operation.  Tries several times to
     * establish a connection to the given &lt;host, port&gt;.  If unsuccessful,
     * throws an IOException indicating what went wrong.
     */

    synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {
<span class="fc" id="L337">        synchronized (fdLock) {</span>
<span class="pc bpc" id="L338" title="2 of 6 branches missed.">            if (!closePending &amp;&amp; (socket == null || !socket.isBound())) {</span>
<span class="fc" id="L339">                NetHooks.beforeTcpConnect(fd, address, port);</span>
            }
<span class="pc" id="L341">        }</span>
        try {
<span class="fc" id="L343">            acquireFD();</span>
            try {
<span class="fc" id="L345">                socketConnect(address, port, timeout);</span>
                /* socket may have been closed during poll/select */
<span class="fc" id="L347">                synchronized (fdLock) {</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">                    if (closePending) {</span>
<span class="nc" id="L349">                        throw new SocketException (&quot;Socket closed&quot;);</span>
                    }
<span class="pc" id="L351">                }</span>
                // If we have a ref. to the Socket, then sets the flags
                // created, bound &amp; connected to true.
                // This is normally done in Socket.connect() but some
                // subclasses of Socket may call impl.connect() directly!
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">                if (socket != null) {</span>
<span class="fc" id="L357">                    socket.setBound();</span>
<span class="fc" id="L358">                    socket.setConnected();</span>
                }
            } finally {
<span class="fc" id="L361">                releaseFD();</span>
<span class="fc" id="L362">            }</span>
<span class="fc" id="L363">        } catch (IOException e) {</span>
<span class="fc" id="L364">            close();</span>
<span class="fc" id="L365">            throw e;</span>
<span class="fc" id="L366">        }</span>
<span class="fc" id="L367">    }</span>

    /**
     * Binds the socket to the specified address of the specified local port.
     * @param address the address
     * @param lport the port
     */
    protected synchronized void bind(InetAddress address, int lport)
        throws IOException
    {
<span class="fc" id="L377">       synchronized (fdLock) {</span>
<span class="pc bpc" id="L378" title="2 of 6 branches missed.">            if (!closePending &amp;&amp; (socket == null || !socket.isBound())) {</span>
<span class="fc" id="L379">                NetHooks.beforeTcpBind(fd, address, lport);</span>
            }
<span class="pc" id="L381">        }</span>
<span class="fc" id="L382">        socketBind(address, lport);</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (socket != null)</span>
<span class="fc" id="L384">            socket.setBound();</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (serverSocket != null)</span>
<span class="fc" id="L386">            serverSocket.setBound();</span>
<span class="fc" id="L387">    }</span>

    /**
     * Listens, for a specified amount of time, for connections.
     * @param count the amount of time to listen for connections
     */
    protected synchronized void listen(int count) throws IOException {
<span class="fc" id="L394">        socketListen(count);</span>
<span class="fc" id="L395">    }</span>

    /**
     * Accepts connections.
     * @param s the connection
     */
    protected void accept(SocketImpl s) throws IOException {
<span class="fc" id="L402">        acquireFD();</span>
        try {
<span class="fc" id="L404">            socketAccept(s);</span>
        } finally {
<span class="fc" id="L406">            releaseFD();</span>
<span class="fc" id="L407">        }</span>
<span class="fc" id="L408">    }</span>

    /**
     * Gets an InputStream for this socket.
     */
    protected synchronized InputStream getInputStream() throws IOException {
<span class="fc" id="L414">        synchronized (fdLock) {</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">            if (isClosedOrPending())</span>
<span class="nc" id="L416">                throw new IOException(&quot;Socket Closed&quot;);</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">            if (shut_rd)</span>
<span class="nc" id="L418">                throw new IOException(&quot;Socket input is shutdown&quot;);</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">            if (socketInputStream == null)</span>
<span class="fc" id="L420">                socketInputStream = new SocketInputStream(this);</span>
<span class="pc" id="L421">        }</span>
<span class="fc" id="L422">        return socketInputStream;</span>
    }

    void setInputStream(SocketInputStream in) {
<span class="nc" id="L426">        socketInputStream = in;</span>
<span class="nc" id="L427">    }</span>

    /**
     * Gets an OutputStream for this socket.
     */
    protected synchronized OutputStream getOutputStream() throws IOException {
<span class="fc" id="L433">        synchronized (fdLock) {</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">            if (isClosedOrPending())</span>
<span class="nc" id="L435">                throw new IOException(&quot;Socket Closed&quot;);</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">            if (shut_wr)</span>
<span class="nc" id="L437">                throw new IOException(&quot;Socket output is shutdown&quot;);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">            if (socketOutputStream == null)</span>
<span class="fc" id="L439">                socketOutputStream = new SocketOutputStream(this);</span>
<span class="pc" id="L440">        }</span>
<span class="fc" id="L441">        return socketOutputStream;</span>
    }

    void setFileDescriptor(FileDescriptor fd) {
<span class="nc" id="L445">        this.fd = fd;</span>
<span class="nc" id="L446">    }</span>

    void setAddress(InetAddress address) {
<span class="nc" id="L449">        this.address = address;</span>
<span class="nc" id="L450">    }</span>

    void setPort(int port) {
<span class="nc" id="L453">        this.port = port;</span>
<span class="nc" id="L454">    }</span>

    void setLocalPort(int localport) {
<span class="nc" id="L457">        this.localport = localport;</span>
<span class="nc" id="L458">    }</span>

    /**
     * Returns the number of bytes that can be read without blocking.
     */
    protected synchronized int available() throws IOException {
<span class="fc bfc" id="L464" title="All 2 branches covered.">        if (isClosedOrPending()) {</span>
<span class="fc" id="L465">            throw new IOException(&quot;Stream closed.&quot;);</span>
        }

        /*
         * If connection has been reset or shut down for input, then return 0
         * to indicate there are no buffered bytes.
         */
<span class="pc bpc" id="L472" title="2 of 4 branches missed.">        if (isConnectionReset() || shut_rd) {</span>
<span class="nc" id="L473">            return 0;</span>
        }

        /*
         * If no bytes available and we were previously notified
         * of a connection reset then we move to the reset state.
         *
         * If are notified of a connection reset then check
         * again if there are bytes buffered on the socket.
         */
<span class="fc" id="L483">        int n = 0;</span>
        try {
<span class="fc" id="L485">            n = socketAvailable();</span>
<span class="pc bpc" id="L486" title="1 of 4 branches missed.">            if (n == 0 &amp;&amp; isConnectionResetPending()) {</span>
<span class="nc" id="L487">                setConnectionReset();</span>
            }
<span class="nc" id="L489">        } catch (ConnectionResetException exc1) {</span>
<span class="nc" id="L490">            setConnectionResetPending();</span>
            try {
<span class="nc" id="L492">                n = socketAvailable();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                if (n == 0) {</span>
<span class="nc" id="L494">                    setConnectionReset();</span>
                }
<span class="nc" id="L496">            } catch (ConnectionResetException exc2) {</span>
<span class="nc" id="L497">            }</span>
<span class="fc" id="L498">        }</span>
<span class="fc" id="L499">        return n;</span>
    }

    /**
     * Closes the socket.
     */
    protected void close() throws IOException {
<span class="fc" id="L506">        synchronized(fdLock) {</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">            if (fd != null) {</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">                if (!stream) {</span>
<span class="fc" id="L509">                    ResourceManager.afterUdpClose();</span>
                }
<span class="fc bfc" id="L511" title="All 2 branches covered.">                if (fdUseCount == 0) {</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">                    if (closePending) {</span>
<span class="nc" id="L513">                        return;</span>
                    }
<span class="fc" id="L515">                    closePending = true;</span>
                    /*
                     * We close the FileDescriptor in two-steps - first the
                     * &quot;pre-close&quot; which closes the socket but doesn't
                     * release the underlying file descriptor. This operation
                     * may be lengthy due to untransmitted data and a long
                     * linger interval. Once the pre-close is done we do the
                     * actual socket to release the fd.
                     */
                    try {
<span class="fc" id="L525">                        socketPreClose();</span>
                    } finally {
<span class="pc" id="L527">                        socketClose();</span>
<span class="fc" id="L528">                    }</span>
<span class="fc" id="L529">                    fd = null;</span>
<span class="fc" id="L530">                    return;</span>
                } else {
                    /*
                     * If a thread has acquired the fd and a close
                     * isn't pending then use a deferred close.
                     * Also decrement fdUseCount to signal the last
                     * thread that releases the fd to close it.
                     */
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">                    if (!closePending) {</span>
<span class="fc" id="L539">                        closePending = true;</span>
<span class="fc" id="L540">                        fdUseCount--;</span>
<span class="fc" id="L541">                        socketPreClose();</span>
                    }
                }
            }
<span class="pc" id="L545">        }</span>
<span class="fc" id="L546">    }</span>

    void reset() throws IOException {
<span class="fc bfc" id="L549" title="All 2 branches covered.">        if (fd != null) {</span>
<span class="fc" id="L550">            socketClose();</span>
        }
<span class="fc" id="L552">        fd = null;</span>
<span class="fc" id="L553">        super.reset();</span>
<span class="fc" id="L554">    }</span>


    /**
     * Shutdown read-half of the socket connection;
     */
    protected void shutdownInput() throws IOException {
<span class="nc bnc" id="L561" title="All 2 branches missed.">      if (fd != null) {</span>
<span class="nc" id="L562">          socketShutdown(SHUT_RD);</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">          if (socketInputStream != null) {</span>
<span class="nc" id="L564">              socketInputStream.setEOF(true);</span>
          }
<span class="nc" id="L566">          shut_rd = true;</span>
      }
<span class="nc" id="L568">    }</span>

    /**
     * Shutdown write-half of the socket connection;
     */
    protected void shutdownOutput() throws IOException {
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">      if (fd != null) {</span>
<span class="fc" id="L575">          socketShutdown(SHUT_WR);</span>
<span class="fc" id="L576">          shut_wr = true;</span>
      }
<span class="fc" id="L578">    }</span>

    protected boolean supportsUrgentData () {
<span class="nc" id="L581">        return true;</span>
    }

    protected void sendUrgentData (int data) throws IOException {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (fd == null) {</span>
<span class="nc" id="L586">            throw new IOException(&quot;Socket Closed&quot;);</span>
        }
<span class="nc" id="L588">        socketSendUrgentData (data);</span>
<span class="nc" id="L589">    }</span>

    /**
     * Cleans up if the user forgets to close it.
     */
    protected void finalize() throws IOException {
<span class="fc" id="L595">        close();</span>
<span class="fc" id="L596">    }</span>

    /*
     * &quot;Acquires&quot; and returns the FileDescriptor for this impl
     *
     * A corresponding releaseFD is required to &quot;release&quot; the
     * FileDescriptor.
     */
    FileDescriptor acquireFD() {
<span class="fc" id="L605">        synchronized (fdLock) {</span>
<span class="fc" id="L606">            fdUseCount++;</span>
<span class="fc" id="L607">            return fd;</span>
<span class="nc" id="L608">        }</span>
    }

    /*
     * &quot;Release&quot; the FileDescriptor for this impl.
     *
     * If the use count goes to -1 then the socket is closed.
     */
    void releaseFD() {
<span class="fc" id="L617">        synchronized (fdLock) {</span>
<span class="fc" id="L618">            fdUseCount--;</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">            if (fdUseCount == -1) {</span>
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">                if (fd != null) {</span>
                    try {
<span class="fc" id="L622">                        socketClose();</span>
<span class="nc" id="L623">                    } catch (IOException e) {</span>
                    } finally {
<span class="pc" id="L625">                        fd = null;</span>
<span class="pc" id="L626">                    }</span>
                }
            }
<span class="pc" id="L629">        }</span>
<span class="fc" id="L630">    }</span>

    public boolean isConnectionReset() {
<span class="fc" id="L633">        synchronized (resetLock) {</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">            return (resetState == CONNECTION_RESET);</span>
<span class="nc" id="L635">        }</span>
    }

    public boolean isConnectionResetPending() {
<span class="fc" id="L639">        synchronized (resetLock) {</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">            return (resetState == CONNECTION_RESET_PENDING);</span>
<span class="nc" id="L641">        }</span>
    }

    public void setConnectionReset() {
<span class="fc" id="L645">        synchronized (resetLock) {</span>
<span class="fc" id="L646">            resetState = CONNECTION_RESET;</span>
<span class="pc" id="L647">        }</span>
<span class="fc" id="L648">    }</span>

    public void setConnectionResetPending() {
<span class="fc" id="L651">        synchronized (resetLock) {</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">            if (resetState == CONNECTION_NOT_RESET) {</span>
<span class="fc" id="L653">                resetState = CONNECTION_RESET_PENDING;</span>
            }
<span class="pc" id="L655">        }</span>

<span class="fc" id="L657">    }</span>

    /*
     * Return true if already closed or close is pending
     */
    public boolean isClosedOrPending() {
        /*
         * Lock on fdLock to ensure that we wait if a
         * close is in progress.
         */
<span class="fc" id="L667">        synchronized (fdLock) {</span>
<span class="pc bpc" id="L668" title="1 of 4 branches missed.">            if (closePending || (fd == null)) {</span>
<span class="fc" id="L669">                return true;</span>
            } else {
<span class="fc" id="L671">                return false;</span>
            }
<span class="nc" id="L673">        }</span>
    }

    /*
     * Return the current value of SO_TIMEOUT
     */
    public int getTimeout() {
<span class="fc" id="L680">        return timeout;</span>
    }

    /*
     * &quot;Pre-close&quot; a socket by dup'ing the file descriptor - this enables
     * the socket to be closed without releasing the file descriptor.
     */
    private void socketPreClose() throws IOException {
<span class="fc" id="L688">        socketClose0(true);</span>
<span class="fc" id="L689">    }</span>

    /*
     * Close the socket (and release the file descriptor).
     */
    protected void socketClose() throws IOException {
<span class="fc" id="L695">        socketClose0(false);</span>
<span class="fc" id="L696">    }</span>

    abstract void socketCreate(boolean isServer) throws IOException;
    abstract void socketConnect(InetAddress address, int port, int timeout)
        throws IOException;
    abstract void socketBind(InetAddress address, int port)
        throws IOException;
    abstract void socketListen(int count)
        throws IOException;
    abstract void socketAccept(SocketImpl s)
        throws IOException;
    abstract int socketAvailable()
        throws IOException;
    abstract void socketClose0(boolean useDeferredClose)
        throws IOException;
    abstract void socketShutdown(int howto)
        throws IOException;
    abstract void socketSetOption(int cmd, boolean on, Object value)
        throws SocketException;
    abstract int socketGetOption(int opt, Object iaContainerObj) throws SocketException;
    abstract void socketSendUrgentData(int data)
        throws IOException;

    public final static int SHUT_RD = 0;
    public final static int SHUT_WR = 1;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>