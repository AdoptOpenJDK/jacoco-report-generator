<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>URLConnection.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">URLConnection.java</span></div><h1>URLConnection.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Hashtable;
import java.util.Date;
import java.util.StringTokenizer;
import java.util.Collections;
import java.util.Map;
import java.util.List;
import java.security.Permission;
import java.security.AccessController;
import sun.security.util.SecurityConstants;
import sun.net.www.MessageHeader;

/**
 * The abstract class {@code URLConnection} is the superclass
 * of all classes that represent a communications link between the
 * application and a URL. Instances of this class can be used both to
 * read from and to write to the resource referenced by the URL. In
 * general, creating a connection to a URL is a multistep process:
 *
 * &lt;center&gt;&lt;table border=2 summary=&quot;Describes the process of creating a connection to a URL: openConnection() and connect() over time.&quot;&gt;
 * &lt;tr&gt;&lt;th&gt;{@code openConnection()}&lt;/th&gt;
 *     &lt;th&gt;{@code connect()}&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;Manipulate parameters that affect the connection to the remote
 *         resource.&lt;/td&gt;
 *     &lt;td&gt;Interact with the resource; query header fields and
 *         contents.&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * ----------------------------&amp;gt;
 * &lt;br&gt;time&lt;/center&gt;
 *
 * &lt;ol&gt;
 * &lt;li&gt;The connection object is created by invoking the
 *     {@code openConnection} method on a URL.
 * &lt;li&gt;The setup parameters and general request properties are manipulated.
 * &lt;li&gt;The actual connection to the remote object is made, using the
 *    {@code connect} method.
 * &lt;li&gt;The remote object becomes available. The header fields and the contents
 *     of the remote object can be accessed.
 * &lt;/ol&gt;
 * &lt;p&gt;
 * The setup parameters are modified using the following methods:
 * &lt;ul&gt;
 *   &lt;li&gt;{@code setAllowUserInteraction}
 *   &lt;li&gt;{@code setDoInput}
 *   &lt;li&gt;{@code setDoOutput}
 *   &lt;li&gt;{@code setIfModifiedSince}
 *   &lt;li&gt;{@code setUseCaches}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * and the general request properties are modified using the method:
 * &lt;ul&gt;
 *   &lt;li&gt;{@code setRequestProperty}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Default values for the {@code AllowUserInteraction} and
 * {@code UseCaches} parameters can be set using the methods
 * {@code setDefaultAllowUserInteraction} and
 * {@code setDefaultUseCaches}.
 * &lt;p&gt;
 * Each of the above {@code set} methods has a corresponding
 * {@code get} method to retrieve the value of the parameter or
 * general request property. The specific parameters and general
 * request properties that are applicable are protocol specific.
 * &lt;p&gt;
 * The following methods are used to access the header fields and
 * the contents after the connection is made to the remote object:
 * &lt;ul&gt;
 *   &lt;li&gt;{@code getContent}
 *   &lt;li&gt;{@code getHeaderField}
 *   &lt;li&gt;{@code getInputStream}
 *   &lt;li&gt;{@code getOutputStream}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Certain header fields are accessed frequently. The methods:
 * &lt;ul&gt;
 *   &lt;li&gt;{@code getContentEncoding}
 *   &lt;li&gt;{@code getContentLength}
 *   &lt;li&gt;{@code getContentType}
 *   &lt;li&gt;{@code getDate}
 *   &lt;li&gt;{@code getExpiration}
 *   &lt;li&gt;{@code getLastModifed}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * provide convenient access to these fields. The
 * {@code getContentType} method is used by the
 * {@code getContent} method to determine the type of the remote
 * object; subclasses may find it convenient to override the
 * {@code getContentType} method.
 * &lt;p&gt;
 * In the common case, all of the pre-connection parameters and
 * general request properties can be ignored: the pre-connection
 * parameters and request properties default to sensible values. For
 * most clients of this interface, there are only two interesting
 * methods: {@code getInputStream} and {@code getContent},
 * which are mirrored in the {@code URL} class by convenience methods.
 * &lt;p&gt;
 * More information on the request properties and header fields of
 * an {@code http} connection can be found at:
 * &lt;blockquote&gt;&lt;pre&gt;
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;http://www.ietf.org/rfc/rfc2616.txt&lt;/a&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * Invoking the {@code close()} methods on the {@code InputStream} or {@code OutputStream} of an
 * {@code URLConnection} after a request may free network resources associated with this
 * instance, unless particular protocol specifications specify different behaviours
 * for it.
 *
 * @author  James Gosling
 * @see     java.net.URL#openConnection()
 * @see     java.net.URLConnection#connect()
 * @see     java.net.URLConnection#getContent()
 * @see     java.net.URLConnection#getContentEncoding()
 * @see     java.net.URLConnection#getContentLength()
 * @see     java.net.URLConnection#getContentType()
 * @see     java.net.URLConnection#getDate()
 * @see     java.net.URLConnection#getExpiration()
 * @see     java.net.URLConnection#getHeaderField(int)
 * @see     java.net.URLConnection#getHeaderField(java.lang.String)
 * @see     java.net.URLConnection#getInputStream()
 * @see     java.net.URLConnection#getLastModified()
 * @see     java.net.URLConnection#getOutputStream()
 * @see     java.net.URLConnection#setAllowUserInteraction(boolean)
 * @see     java.net.URLConnection#setDefaultUseCaches(boolean)
 * @see     java.net.URLConnection#setDoInput(boolean)
 * @see     java.net.URLConnection#setDoOutput(boolean)
 * @see     java.net.URLConnection#setIfModifiedSince(long)
 * @see     java.net.URLConnection#setRequestProperty(java.lang.String, java.lang.String)
 * @see     java.net.URLConnection#setUseCaches(boolean)
 * @since   JDK1.0
 */
public abstract class URLConnection {

   /**
     * The URL represents the remote object on the World Wide Web to
     * which this connection is opened.
     * &lt;p&gt;
     * The value of this field can be accessed by the
     * {@code getURL} method.
     * &lt;p&gt;
     * The default value of this variable is the value of the URL
     * argument in the {@code URLConnection} constructor.
     *
     * @see     java.net.URLConnection#getURL()
     * @see     java.net.URLConnection#url
     */
    protected URL url;

   /**
     * This variable is set by the {@code setDoInput} method. Its
     * value is returned by the {@code getDoInput} method.
     * &lt;p&gt;
     * A URL connection can be used for input and/or output. Setting the
     * {@code doInput} flag to {@code true} indicates that
     * the application intends to read data from the URL connection.
     * &lt;p&gt;
     * The default value of this field is {@code true}.
     *
     * @see     java.net.URLConnection#getDoInput()
     * @see     java.net.URLConnection#setDoInput(boolean)
     */
<span class="fc" id="L190">    protected boolean doInput = true;</span>

   /**
     * This variable is set by the {@code setDoOutput} method. Its
     * value is returned by the {@code getDoOutput} method.
     * &lt;p&gt;
     * A URL connection can be used for input and/or output. Setting the
     * {@code doOutput} flag to {@code true} indicates
     * that the application intends to write data to the URL connection.
     * &lt;p&gt;
     * The default value of this field is {@code false}.
     *
     * @see     java.net.URLConnection#getDoOutput()
     * @see     java.net.URLConnection#setDoOutput(boolean)
     */
<span class="fc" id="L205">    protected boolean doOutput = false;</span>

<span class="fc" id="L207">    private static boolean defaultAllowUserInteraction = false;</span>

   /**
     * If {@code true}, this {@code URL} is being examined in
     * a context in which it makes sense to allow user interactions such
     * as popping up an authentication dialog. If {@code false},
     * then no user interaction is allowed.
     * &lt;p&gt;
     * The value of this field can be set by the
     * {@code setAllowUserInteraction} method.
     * Its value is returned by the
     * {@code getAllowUserInteraction} method.
     * Its default value is the value of the argument in the last invocation
     * of the {@code setDefaultAllowUserInteraction} method.
     *
     * @see     java.net.URLConnection#getAllowUserInteraction()
     * @see     java.net.URLConnection#setAllowUserInteraction(boolean)
     * @see     java.net.URLConnection#setDefaultAllowUserInteraction(boolean)
     */
<span class="fc" id="L226">    protected boolean allowUserInteraction = defaultAllowUserInteraction;</span>

<span class="fc" id="L228">    private static boolean defaultUseCaches = true;</span>

   /**
     * If {@code true}, the protocol is allowed to use caching
     * whenever it can. If {@code false}, the protocol must always
     * try to get a fresh copy of the object.
     * &lt;p&gt;
     * This field is set by the {@code setUseCaches} method. Its
     * value is returned by the {@code getUseCaches} method.
     * &lt;p&gt;
     * Its default value is the value given in the last invocation of the
     * {@code setDefaultUseCaches} method.
     *
     * @see     java.net.URLConnection#setUseCaches(boolean)
     * @see     java.net.URLConnection#getUseCaches()
     * @see     java.net.URLConnection#setDefaultUseCaches(boolean)
     */
<span class="fc" id="L245">    protected boolean useCaches = defaultUseCaches;</span>

   /**
     * Some protocols support skipping the fetching of the object unless
     * the object has been modified more recently than a certain time.
     * &lt;p&gt;
     * A nonzero value gives a time as the number of milliseconds since
     * January 1, 1970, GMT. The object is fetched only if it has been
     * modified more recently than that time.
     * &lt;p&gt;
     * This variable is set by the {@code setIfModifiedSince}
     * method. Its value is returned by the
     * {@code getIfModifiedSince} method.
     * &lt;p&gt;
     * The default value of this field is {@code 0}, indicating
     * that the fetching must always occur.
     *
     * @see     java.net.URLConnection#getIfModifiedSince()
     * @see     java.net.URLConnection#setIfModifiedSince(long)
     */
<span class="fc" id="L265">    protected long ifModifiedSince = 0;</span>

   /**
     * If {@code false}, this connection object has not created a
     * communications link to the specified URL. If {@code true},
     * the communications link has been established.
     */
<span class="fc" id="L272">    protected boolean connected = false;</span>

    /**
     * @since 1.5
     */
    private int connectTimeout;
    private int readTimeout;

    /**
     * @since 1.6
     */
    private MessageHeader requests;

   /**
    * @since   JDK1.1
    */
    private static FileNameMap fileNameMap;

    /**
     * @since 1.2.2
     */
<span class="fc" id="L293">    private static boolean fileNameMapLoaded = false;</span>

    /**
     * Loads filename map (a mimetable) from a data file. It will
     * first try to load the user-specific table, defined
     * by &amp;quot;content.types.user.table&amp;quot; property. If that fails,
     * it tries to load the default built-in table.
     *
     * @return the FileNameMap
     * @since 1.2
     * @see #setFileNameMap(java.net.FileNameMap)
     */
    public static synchronized FileNameMap getFileNameMap() {
<span class="pc bpc" id="L306" title="1 of 4 branches missed.">        if ((fileNameMap == null) &amp;&amp; !fileNameMapLoaded) {</span>
<span class="fc" id="L307">            fileNameMap = sun.net.www.MimeTable.loadTable();</span>
<span class="fc" id="L308">            fileNameMapLoaded = true;</span>
        }

<span class="fc" id="L311">        return new FileNameMap() {</span>
<span class="fc" id="L312">            private FileNameMap map = fileNameMap;</span>
            public String getContentTypeFor(String fileName) {
<span class="fc" id="L314">                return map.getContentTypeFor(fileName);</span>
            }
        };
    }

    /**
     * Sets the FileNameMap.
     * &lt;p&gt;
     * If there is a security manager, this method first calls
     * the security manager's {@code checkSetFactory} method
     * to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * @param map the FileNameMap to be set
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkSetFactory} method doesn't allow the operation.
     * @see        SecurityManager#checkSetFactory
     * @see #getFileNameMap()
     * @since 1.2
     */
    public static void setFileNameMap(FileNameMap map) {
<span class="fc" id="L335">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (sm != null) sm.checkSetFactory();</span>
<span class="fc" id="L337">        fileNameMap = map;</span>
<span class="fc" id="L338">    }</span>

    /**
     * Opens a communications link to the resource referenced by this
     * URL, if such a connection has not already been established.
     * &lt;p&gt;
     * If the {@code connect} method is called when the connection
     * has already been opened (indicated by the {@code connected}
     * field having the value {@code true}), the call is ignored.
     * &lt;p&gt;
     * URLConnection objects go through two phases: first they are
     * created, then they are connected.  After being created, and
     * before being connected, various options can be specified
     * (e.g., doInput and UseCaches).  After connecting, it is an
     * error to try to set them.  Operations that depend on being
     * connected, like getContentLength, will implicitly perform the
     * connection, if necessary.
     *
     * @throws SocketTimeoutException if the timeout expires before
     *               the connection can be established
     * @exception  IOException  if an I/O error occurs while opening the
     *               connection.
     * @see java.net.URLConnection#connected
     * @see #getConnectTimeout()
     * @see #setConnectTimeout(int)
     */
    abstract public void connect() throws IOException;

    /**
     * Sets a specified timeout value, in milliseconds, to be used
     * when opening a communications link to the resource referenced
     * by this URLConnection.  If the timeout expires before the
     * connection can be established, a
     * java.net.SocketTimeoutException is raised. A timeout of zero is
     * interpreted as an infinite timeout.

     * &lt;p&gt; Some non-standard implementation of this method may ignore
     * the specified timeout. To see the connect timeout set, please
     * call getConnectTimeout().
     *
     * @param timeout an {@code int} that specifies the connect
     *               timeout value in milliseconds
     * @throws IllegalArgumentException if the timeout parameter is negative
     *
     * @see #getConnectTimeout()
     * @see #connect()
     * @since 1.5
     */
    public void setConnectTimeout(int timeout) {
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (timeout &lt; 0) {</span>
<span class="nc" id="L388">            throw new IllegalArgumentException(&quot;timeout can not be negative&quot;);</span>
        }
<span class="nc" id="L390">        connectTimeout = timeout;</span>
<span class="nc" id="L391">    }</span>

    /**
     * Returns setting for connect timeout.
     * &lt;p&gt;
     * 0 return implies that the option is disabled
     * (i.e., timeout of infinity).
     *
     * @return an {@code int} that indicates the connect timeout
     *         value in milliseconds
     * @see #setConnectTimeout(int)
     * @see #connect()
     * @since 1.5
     */
    public int getConnectTimeout() {
<span class="nc" id="L406">        return connectTimeout;</span>
    }

    /**
     * Sets the read timeout to a specified timeout, in
     * milliseconds. A non-zero value specifies the timeout when
     * reading from Input stream when a connection is established to a
     * resource. If the timeout expires before there is data available
     * for read, a java.net.SocketTimeoutException is raised. A
     * timeout of zero is interpreted as an infinite timeout.
     *
     *&lt;p&gt; Some non-standard implementation of this method ignores the
     * specified timeout. To see the read timeout set, please call
     * getReadTimeout().
     *
     * @param timeout an {@code int} that specifies the timeout
     * value to be used in milliseconds
     * @throws IllegalArgumentException if the timeout parameter is negative
     *
     * @see #getReadTimeout()
     * @see InputStream#read()
     * @since 1.5
     */
    public void setReadTimeout(int timeout) {
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (timeout &lt; 0) {</span>
<span class="nc" id="L431">            throw new IllegalArgumentException(&quot;timeout can not be negative&quot;);</span>
        }
<span class="nc" id="L433">        readTimeout = timeout;</span>
<span class="nc" id="L434">    }</span>

    /**
     * Returns setting for read timeout. 0 return implies that the
     * option is disabled (i.e., timeout of infinity).
     *
     * @return an {@code int} that indicates the read timeout
     *         value in milliseconds
     *
     * @see #setReadTimeout(int)
     * @see InputStream#read()
     * @since 1.5
     */
    public int getReadTimeout() {
<span class="nc" id="L448">        return readTimeout;</span>
    }

    /**
     * Constructs a URL connection to the specified URL. A connection to
     * the object referenced by the URL is not created.
     *
     * @param   url   the specified URL.
     */
<span class="fc" id="L457">    protected URLConnection(URL url) {</span>
<span class="fc" id="L458">        this.url = url;</span>
<span class="fc" id="L459">    }</span>

    /**
     * Returns the value of this {@code URLConnection}'s {@code URL}
     * field.
     *
     * @return  the value of this {@code URLConnection}'s {@code URL}
     *          field.
     * @see     java.net.URLConnection#url
     */
    public URL getURL() {
<span class="fc" id="L470">        return url;</span>
    }

    /**
     * Returns the value of the {@code content-length} header field.
     * &lt;P&gt;
     * &lt;B&gt;Note&lt;/B&gt;: {@link #getContentLengthLong() getContentLengthLong()}
     * should be preferred over this method, since it returns a {@code long}
     * instead and is therefore more portable.&lt;/P&gt;
     *
     * @return  the content length of the resource that this connection's URL
     *          references, {@code -1} if the content length is not known,
     *          or if the content length is greater than Integer.MAX_VALUE.
     */
    public int getContentLength() {
<span class="fc" id="L485">        long l = getContentLengthLong();</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (l &gt; Integer.MAX_VALUE)</span>
<span class="nc" id="L487">            return -1;</span>
<span class="fc" id="L488">        return (int) l;</span>
    }

    /**
     * Returns the value of the {@code content-length} header field as a
     * long.
     *
     * @return  the content length of the resource that this connection's URL
     *          references, or {@code -1} if the content length is
     *          not known.
     * @since 7.0
     */
    public long getContentLengthLong() {
<span class="fc" id="L501">        return getHeaderFieldLong(&quot;content-length&quot;, -1);</span>
    }

    /**
     * Returns the value of the {@code content-type} header field.
     *
     * @return  the content type of the resource that the URL references,
     *          or {@code null} if not known.
     * @see     java.net.URLConnection#getHeaderField(java.lang.String)
     */
    public String getContentType() {
<span class="fc" id="L512">        return getHeaderField(&quot;content-type&quot;);</span>
    }

    /**
     * Returns the value of the {@code content-encoding} header field.
     *
     * @return  the content encoding of the resource that the URL references,
     *          or {@code null} if not known.
     * @see     java.net.URLConnection#getHeaderField(java.lang.String)
     */
    public String getContentEncoding() {
<span class="nc" id="L523">        return getHeaderField(&quot;content-encoding&quot;);</span>
    }

    /**
     * Returns the value of the {@code expires} header field.
     *
     * @return  the expiration date of the resource that this URL references,
     *          or 0 if not known. The value is the number of milliseconds since
     *          January 1, 1970 GMT.
     * @see     java.net.URLConnection#getHeaderField(java.lang.String)
     */
    public long getExpiration() {
<span class="nc" id="L535">        return getHeaderFieldDate(&quot;expires&quot;, 0);</span>
    }

    /**
     * Returns the value of the {@code date} header field.
     *
     * @return  the sending date of the resource that the URL references,
     *          or {@code 0} if not known. The value returned is the
     *          number of milliseconds since January 1, 1970 GMT.
     * @see     java.net.URLConnection#getHeaderField(java.lang.String)
     */
    public long getDate() {
<span class="nc" id="L547">        return getHeaderFieldDate(&quot;date&quot;, 0);</span>
    }

    /**
     * Returns the value of the {@code last-modified} header field.
     * The result is the number of milliseconds since January 1, 1970 GMT.
     *
     * @return  the date the resource referenced by this
     *          {@code URLConnection} was last modified, or 0 if not known.
     * @see     java.net.URLConnection#getHeaderField(java.lang.String)
     */
    public long getLastModified() {
<span class="fc" id="L559">        return getHeaderFieldDate(&quot;last-modified&quot;, 0);</span>
    }

    /**
     * Returns the value of the named header field.
     * &lt;p&gt;
     * If called on a connection that sets the same header multiple times
     * with possibly different values, only the last value is returned.
     *
     *
     * @param   name   the name of a header field.
     * @return  the value of the named header field, or {@code null}
     *          if there is no such field in the header.
     */
    public String getHeaderField(String name) {
<span class="nc" id="L574">        return null;</span>
    }

    /**
     * Returns an unmodifiable Map of the header fields.
     * The Map keys are Strings that represent the
     * response-header field names. Each Map value is an
     * unmodifiable List of Strings that represents
     * the corresponding field values.
     *
     * @return a Map of header fields
     * @since 1.4
     */
    public Map&lt;String,List&lt;String&gt;&gt; getHeaderFields() {
<span class="nc" id="L588">        return Collections.emptyMap();</span>
    }

    /**
     * Returns the value of the named field parsed as a number.
     * &lt;p&gt;
     * This form of {@code getHeaderField} exists because some
     * connection types (e.g., {@code http-ng}) have pre-parsed
     * headers. Classes for that connection type can override this method
     * and short-circuit the parsing.
     *
     * @param   name      the name of the header field.
     * @param   Default   the default value.
     * @return  the value of the named field, parsed as an integer. The
     *          {@code Default} value is returned if the field is
     *          missing or malformed.
     */
    public int getHeaderFieldInt(String name, int Default) {
<span class="nc" id="L606">        String value = getHeaderField(name);</span>
        try {
<span class="nc" id="L608">            return Integer.parseInt(value);</span>
<span class="nc" id="L609">        } catch (Exception e) { }</span>
<span class="nc" id="L610">        return Default;</span>
    }

    /**
     * Returns the value of the named field parsed as a number.
     * &lt;p&gt;
     * This form of {@code getHeaderField} exists because some
     * connection types (e.g., {@code http-ng}) have pre-parsed
     * headers. Classes for that connection type can override this method
     * and short-circuit the parsing.
     *
     * @param   name      the name of the header field.
     * @param   Default   the default value.
     * @return  the value of the named field, parsed as a long. The
     *          {@code Default} value is returned if the field is
     *          missing or malformed.
     * @since 7.0
     */
    public long getHeaderFieldLong(String name, long Default) {
<span class="fc" id="L629">        String value = getHeaderField(name);</span>
        try {
<span class="fc" id="L631">            return Long.parseLong(value);</span>
<span class="nc" id="L632">        } catch (Exception e) { }</span>
<span class="nc" id="L633">        return Default;</span>
    }

    /**
     * Returns the value of the named field parsed as date.
     * The result is the number of milliseconds since January 1, 1970 GMT
     * represented by the named field.
     * &lt;p&gt;
     * This form of {@code getHeaderField} exists because some
     * connection types (e.g., {@code http-ng}) have pre-parsed
     * headers. Classes for that connection type can override this method
     * and short-circuit the parsing.
     *
     * @param   name     the name of the header field.
     * @param   Default   a default value.
     * @return  the value of the field, parsed as a date. The value of the
     *          {@code Default} argument is returned if the field is
     *          missing or malformed.
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public long getHeaderFieldDate(String name, long Default) {
<span class="fc" id="L654">        String value = getHeaderField(name);</span>
        try {
<span class="fc" id="L656">            return Date.parse(value);</span>
<span class="nc" id="L657">        } catch (Exception e) { }</span>
<span class="nc" id="L658">        return Default;</span>
    }

    /**
     * Returns the key for the {@code n}&lt;sup&gt;th&lt;/sup&gt; header field.
     * It returns {@code null} if there are fewer than {@code n+1} fields.
     *
     * @param   n   an index, where {@code n&gt;=0}
     * @return  the key for the {@code n}&lt;sup&gt;th&lt;/sup&gt; header field,
     *          or {@code null} if there are fewer than {@code n+1}
     *          fields.
     */
    public String getHeaderFieldKey(int n) {
<span class="nc" id="L671">        return null;</span>
    }

    /**
     * Returns the value for the {@code n}&lt;sup&gt;th&lt;/sup&gt; header field.
     * It returns {@code null} if there are fewer than
     * {@code n+1}fields.
     * &lt;p&gt;
     * This method can be used in conjunction with the
     * {@link #getHeaderFieldKey(int) getHeaderFieldKey} method to iterate through all
     * the headers in the message.
     *
     * @param   n   an index, where {@code n&gt;=0}
     * @return  the value of the {@code n}&lt;sup&gt;th&lt;/sup&gt; header field
     *          or {@code null} if there are fewer than {@code n+1} fields
     * @see     java.net.URLConnection#getHeaderFieldKey(int)
     */
    public String getHeaderField(int n) {
<span class="nc" id="L689">        return null;</span>
    }

    /**
     * Retrieves the contents of this URL connection.
     * &lt;p&gt;
     * This method first determines the content type of the object by
     * calling the {@code getContentType} method. If this is
     * the first time that the application has seen that specific content
     * type, a content handler for that content type is created:
     * &lt;ol&gt;
     * &lt;li&gt;If the application has set up a content handler factory instance
     *     using the {@code setContentHandlerFactory} method, the
     *     {@code createContentHandler} method of that instance is called
     *     with the content type as an argument; the result is a content
     *     handler for that content type.
     * &lt;li&gt;If no content handler factory has yet been set up, or if the
     *     factory's {@code createContentHandler} method returns
     *     {@code null}, then the application loads the class named:
     *     &lt;blockquote&gt;&lt;pre&gt;
     *         sun.net.www.content.&amp;lt;&lt;i&gt;contentType&lt;/i&gt;&amp;gt;
     *     &lt;/pre&gt;&lt;/blockquote&gt;
     *     where &amp;lt;&lt;i&gt;contentType&lt;/i&gt;&amp;gt; is formed by taking the
     *     content-type string, replacing all slash characters with a
     *     {@code period} ('.'), and all other non-alphanumeric characters
     *     with the underscore character '{@code _}'. The alphanumeric
     *     characters are specifically the 26 uppercase ASCII letters
     *     '{@code A}' through '{@code Z}', the 26 lowercase ASCII
     *     letters '{@code a}' through '{@code z}', and the 10 ASCII
     *     digits '{@code 0}' through '{@code 9}'. If the specified
     *     class does not exist, or is not a subclass of
     *     {@code ContentHandler}, then an
     *     {@code UnknownServiceException} is thrown.
     * &lt;/ol&gt;
     *
     * @return     the object fetched. The {@code instanceof} operator
     *               should be used to determine the specific kind of object
     *               returned.
     * @exception  IOException              if an I/O error occurs while
     *               getting the content.
     * @exception  UnknownServiceException  if the protocol does not support
     *               the content type.
     * @see        java.net.ContentHandlerFactory#createContentHandler(java.lang.String)
     * @see        java.net.URLConnection#getContentType()
     * @see        java.net.URLConnection#setContentHandlerFactory(java.net.ContentHandlerFactory)
     */
    public Object getContent() throws IOException {
        // Must call getInputStream before GetHeaderField gets called
        // so that FileNotFoundException has a chance to be thrown up
        // from here without being caught.
<span class="fc" id="L739">        getInputStream();</span>
<span class="fc" id="L740">        return getContentHandler().getContent(this);</span>
    }

    /**
     * Retrieves the contents of this URL connection.
     *
     * @param classes the {@code Class} array
     * indicating the requested types
     * @return     the object fetched that is the first match of the type
     *               specified in the classes array. null if none of
     *               the requested types are supported.
     *               The {@code instanceof} operator should be used to
     *               determine the specific kind of object returned.
     * @exception  IOException              if an I/O error occurs while
     *               getting the content.
     * @exception  UnknownServiceException  if the protocol does not support
     *               the content type.
     * @see        java.net.URLConnection#getContent()
     * @see        java.net.ContentHandlerFactory#createContentHandler(java.lang.String)
     * @see        java.net.URLConnection#getContent(java.lang.Class[])
     * @see        java.net.URLConnection#setContentHandlerFactory(java.net.ContentHandlerFactory)
     * @since 1.3
     */
    public Object getContent(Class[] classes) throws IOException {
        // Must call getInputStream before GetHeaderField gets called
        // so that FileNotFoundException has a chance to be thrown up
        // from here without being caught.
<span class="nc" id="L767">        getInputStream();</span>
<span class="nc" id="L768">        return getContentHandler().getContent(this, classes);</span>
    }

    /**
     * Returns a permission object representing the permission
     * necessary to make the connection represented by this
     * object. This method returns null if no permission is
     * required to make the connection. By default, this method
     * returns {@code java.security.AllPermission}. Subclasses
     * should override this method and return the permission
     * that best represents the permission required to make a
     * a connection to the URL. For example, a {@code URLConnection}
     * representing a {@code file:} URL would return a
     * {@code java.io.FilePermission} object.
     *
     * &lt;p&gt;The permission returned may dependent upon the state of the
     * connection. For example, the permission before connecting may be
     * different from that after connecting. For example, an HTTP
     * sever, say foo.com, may redirect the connection to a different
     * host, say bar.com. Before connecting the permission returned by
     * the connection will represent the permission needed to connect
     * to foo.com, while the permission returned after connecting will
     * be to bar.com.
     *
     * &lt;p&gt;Permissions are generally used for two purposes: to protect
     * caches of objects obtained through URLConnections, and to check
     * the right of a recipient to learn about a particular URL. In
     * the first case, the permission should be obtained
     * &lt;em&gt;after&lt;/em&gt; the object has been obtained. For example, in an
     * HTTP connection, this will represent the permission to connect
     * to the host from which the data was ultimately fetched. In the
     * second case, the permission should be obtained and tested
     * &lt;em&gt;before&lt;/em&gt; connecting.
     *
     * @return the permission object representing the permission
     * necessary to make the connection represented by this
     * URLConnection.
     *
     * @exception IOException if the computation of the permission
     * requires network or file I/O and an exception occurs while
     * computing it.
     */
    public Permission getPermission() throws IOException {
<span class="nc" id="L811">        return SecurityConstants.ALL_PERMISSION;</span>
    }

    /**
     * Returns an input stream that reads from this open connection.
     *
     * A SocketTimeoutException can be thrown when reading from the
     * returned input stream if the read timeout expires before data
     * is available for read.
     *
     * @return     an input stream that reads from this open connection.
     * @exception  IOException              if an I/O error occurs while
     *               creating the input stream.
     * @exception  UnknownServiceException  if the protocol does not support
     *               input.
     * @see #setReadTimeout(int)
     * @see #getReadTimeout()
     */
    public InputStream getInputStream() throws IOException {
<span class="nc" id="L830">        throw new UnknownServiceException(&quot;protocol doesn't support input&quot;);</span>
    }

    /**
     * Returns an output stream that writes to this connection.
     *
     * @return     an output stream that writes to this connection.
     * @exception  IOException              if an I/O error occurs while
     *               creating the output stream.
     * @exception  UnknownServiceException  if the protocol does not support
     *               output.
     */
    public OutputStream getOutputStream() throws IOException {
<span class="nc" id="L843">        throw new UnknownServiceException(&quot;protocol doesn't support output&quot;);</span>
    }

    /**
     * Returns a {@code String} representation of this URL connection.
     *
     * @return  a string representation of this {@code URLConnection}.
     */
    public String toString() {
<span class="fc" id="L852">        return this.getClass().getName() + &quot;:&quot; + url;</span>
    }

    /**
     * Sets the value of the {@code doInput} field for this
     * {@code URLConnection} to the specified value.
     * &lt;p&gt;
     * A URL connection can be used for input and/or output.  Set the DoInput
     * flag to true if you intend to use the URL connection for input,
     * false if not.  The default is true.
     *
     * @param   doinput   the new value.
     * @throws IllegalStateException if already connected
     * @see     java.net.URLConnection#doInput
     * @see #getDoInput()
     */
    public void setDoInput(boolean doinput) {
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">        if (connected)</span>
<span class="nc" id="L870">            throw new IllegalStateException(&quot;Already connected&quot;);</span>
<span class="fc" id="L871">        doInput = doinput;</span>
<span class="fc" id="L872">    }</span>

    /**
     * Returns the value of this {@code URLConnection}'s
     * {@code doInput} flag.
     *
     * @return  the value of this {@code URLConnection}'s
     *          {@code doInput} flag.
     * @see     #setDoInput(boolean)
     */
    public boolean getDoInput() {
<span class="nc" id="L883">        return doInput;</span>
    }

    /**
     * Sets the value of the {@code doOutput} field for this
     * {@code URLConnection} to the specified value.
     * &lt;p&gt;
     * A URL connection can be used for input and/or output.  Set the DoOutput
     * flag to true if you intend to use the URL connection for output,
     * false if not.  The default is false.
     *
     * @param   dooutput   the new value.
     * @throws IllegalStateException if already connected
     * @see #getDoOutput()
     */
    public void setDoOutput(boolean dooutput) {
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">        if (connected)</span>
<span class="nc" id="L900">            throw new IllegalStateException(&quot;Already connected&quot;);</span>
<span class="fc" id="L901">        doOutput = dooutput;</span>
<span class="fc" id="L902">    }</span>

    /**
     * Returns the value of this {@code URLConnection}'s
     * {@code doOutput} flag.
     *
     * @return  the value of this {@code URLConnection}'s
     *          {@code doOutput} flag.
     * @see     #setDoOutput(boolean)
     */
    public boolean getDoOutput() {
<span class="nc" id="L913">        return doOutput;</span>
    }

    /**
     * Set the value of the {@code allowUserInteraction} field of
     * this {@code URLConnection}.
     *
     * @param   allowuserinteraction   the new value.
     * @throws IllegalStateException if already connected
     * @see     #getAllowUserInteraction()
     */
    public void setAllowUserInteraction(boolean allowuserinteraction) {
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">        if (connected)</span>
<span class="nc" id="L926">            throw new IllegalStateException(&quot;Already connected&quot;);</span>
<span class="fc" id="L927">        allowUserInteraction = allowuserinteraction;</span>
<span class="fc" id="L928">    }</span>

    /**
     * Returns the value of the {@code allowUserInteraction} field for
     * this object.
     *
     * @return  the value of the {@code allowUserInteraction} field for
     *          this object.
     * @see     #setAllowUserInteraction(boolean)
     */
    public boolean getAllowUserInteraction() {
<span class="nc" id="L939">        return allowUserInteraction;</span>
    }

    /**
     * Sets the default value of the
     * {@code allowUserInteraction} field for all future
     * {@code URLConnection} objects to the specified value.
     *
     * @param   defaultallowuserinteraction   the new value.
     * @see     #getDefaultAllowUserInteraction()
     */
    public static void setDefaultAllowUserInteraction(boolean defaultallowuserinteraction) {
<span class="nc" id="L951">        defaultAllowUserInteraction = defaultallowuserinteraction;</span>
<span class="nc" id="L952">    }</span>

    /**
     * Returns the default value of the {@code allowUserInteraction}
     * field.
     * &lt;p&gt;
     * Ths default is &quot;sticky&quot;, being a part of the static state of all
     * URLConnections.  This flag applies to the next, and all following
     * URLConnections that are created.
     *
     * @return  the default value of the {@code allowUserInteraction}
     *          field.
     * @see     #setDefaultAllowUserInteraction(boolean)
     */
    public static boolean getDefaultAllowUserInteraction() {
<span class="nc" id="L967">        return defaultAllowUserInteraction;</span>
    }

    /**
     * Sets the value of the {@code useCaches} field of this
     * {@code URLConnection} to the specified value.
     * &lt;p&gt;
     * Some protocols do caching of documents.  Occasionally, it is important
     * to be able to &quot;tunnel through&quot; and ignore the caches (e.g., the
     * &quot;reload&quot; button in a browser).  If the UseCaches flag on a connection
     * is true, the connection is allowed to use whatever caches it can.
     *  If false, caches are to be ignored.
     *  The default value comes from DefaultUseCaches, which defaults to
     * true.
     *
     * @param usecaches a {@code boolean} indicating whether
     * or not to allow caching
     * @throws IllegalStateException if already connected
     * @see #getUseCaches()
     */
    public void setUseCaches(boolean usecaches) {
<span class="pc bpc" id="L988" title="1 of 2 branches missed.">        if (connected)</span>
<span class="nc" id="L989">            throw new IllegalStateException(&quot;Already connected&quot;);</span>
<span class="fc" id="L990">        useCaches = usecaches;</span>
<span class="fc" id="L991">    }</span>

    /**
     * Returns the value of this {@code URLConnection}'s
     * {@code useCaches} field.
     *
     * @return  the value of this {@code URLConnection}'s
     *          {@code useCaches} field.
     * @see #setUseCaches(boolean)
     */
    public boolean getUseCaches() {
<span class="fc" id="L1002">        return useCaches;</span>
    }

    /**
     * Sets the value of the {@code ifModifiedSince} field of
     * this {@code URLConnection} to the specified value.
     *
     * @param   ifmodifiedsince   the new value.
     * @throws IllegalStateException if already connected
     * @see     #getIfModifiedSince()
     */
    public void setIfModifiedSince(long ifmodifiedsince) {
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">        if (connected)</span>
<span class="nc" id="L1015">            throw new IllegalStateException(&quot;Already connected&quot;);</span>
<span class="fc" id="L1016">        ifModifiedSince = ifmodifiedsince;</span>
<span class="fc" id="L1017">    }</span>

    /**
     * Returns the value of this object's {@code ifModifiedSince} field.
     *
     * @return  the value of this object's {@code ifModifiedSince} field.
     * @see #setIfModifiedSince(long)
     */
    public long getIfModifiedSince() {
<span class="fc" id="L1026">        return ifModifiedSince;</span>
    }

   /**
     * Returns the default value of a {@code URLConnection}'s
     * {@code useCaches} flag.
     * &lt;p&gt;
     * Ths default is &quot;sticky&quot;, being a part of the static state of all
     * URLConnections.  This flag applies to the next, and all following
     * URLConnections that are created.
     *
     * @return  the default value of a {@code URLConnection}'s
     *          {@code useCaches} flag.
     * @see     #setDefaultUseCaches(boolean)
     */
    public boolean getDefaultUseCaches() {
<span class="nc" id="L1042">        return defaultUseCaches;</span>
    }

   /**
     * Sets the default value of the {@code useCaches} field to the
     * specified value.
     *
     * @param   defaultusecaches   the new value.
     * @see     #getDefaultUseCaches()
     */
    public void setDefaultUseCaches(boolean defaultusecaches) {
<span class="fc" id="L1053">        defaultUseCaches = defaultusecaches;</span>
<span class="fc" id="L1054">    }</span>

    /**
     * Sets the general request property. If a property with the key already
     * exists, overwrite its value with the new value.
     *
     * &lt;p&gt; NOTE: HTTP requires all request properties which can
     * legally have multiple instances with the same key
     * to use a comma-separated list syntax which enables multiple
     * properties to be appended into a single property.
     *
     * @param   key     the keyword by which the request is known
     *                  (e.g., &quot;{@code Accept}&quot;).
     * @param   value   the value associated with it.
     * @throws IllegalStateException if already connected
     * @throws NullPointerException if key is &lt;CODE&gt;null&lt;/CODE&gt;
     * @see #getRequestProperty(java.lang.String)
     */
    public void setRequestProperty(String key, String value) {
<span class="nc bnc" id="L1073" title="All 2 branches missed.">        if (connected)</span>
<span class="nc" id="L1074">            throw new IllegalStateException(&quot;Already connected&quot;);</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L1076">            throw new NullPointerException (&quot;key is null&quot;);</span>

<span class="nc bnc" id="L1078" title="All 2 branches missed.">        if (requests == null)</span>
<span class="nc" id="L1079">            requests = new MessageHeader();</span>

<span class="nc" id="L1081">        requests.set(key, value);</span>
<span class="nc" id="L1082">    }</span>

    /**
     * Adds a general request property specified by a
     * key-value pair.  This method will not overwrite
     * existing values associated with the same key.
     *
     * @param   key     the keyword by which the request is known
     *                  (e.g., &quot;{@code Accept}&quot;).
     * @param   value  the value associated with it.
     * @throws IllegalStateException if already connected
     * @throws NullPointerException if key is null
     * @see #getRequestProperties()
     * @since 1.4
     */
    public void addRequestProperty(String key, String value) {
<span class="nc bnc" id="L1098" title="All 2 branches missed.">        if (connected)</span>
<span class="nc" id="L1099">            throw new IllegalStateException(&quot;Already connected&quot;);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L1101">            throw new NullPointerException (&quot;key is null&quot;);</span>

<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (requests == null)</span>
<span class="nc" id="L1104">            requests = new MessageHeader();</span>

<span class="nc" id="L1106">        requests.add(key, value);</span>
<span class="nc" id="L1107">    }</span>


    /**
     * Returns the value of the named general request property for this
     * connection.
     *
     * @param key the keyword by which the request is known (e.g., &quot;Accept&quot;).
     * @return  the value of the named general request property for this
     *           connection. If key is null, then null is returned.
     * @throws IllegalStateException if already connected
     * @see #setRequestProperty(java.lang.String, java.lang.String)
     */
    public String getRequestProperty(String key) {
<span class="nc bnc" id="L1121" title="All 2 branches missed.">        if (connected)</span>
<span class="nc" id="L1122">            throw new IllegalStateException(&quot;Already connected&quot;);</span>

<span class="nc bnc" id="L1124" title="All 2 branches missed.">        if (requests == null)</span>
<span class="nc" id="L1125">            return null;</span>

<span class="nc" id="L1127">        return requests.findValue(key);</span>
    }

    /**
     * Returns an unmodifiable Map of general request
     * properties for this connection. The Map keys
     * are Strings that represent the request-header
     * field names. Each Map value is a unmodifiable List
     * of Strings that represents the corresponding
     * field values.
     *
     * @return  a Map of the general request properties for this connection.
     * @throws IllegalStateException if already connected
     * @since 1.4
     */
    public Map&lt;String,List&lt;String&gt;&gt; getRequestProperties() {
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        if (connected)</span>
<span class="nc" id="L1144">            throw new IllegalStateException(&quot;Already connected&quot;);</span>

<span class="nc bnc" id="L1146" title="All 2 branches missed.">        if (requests == null)</span>
<span class="nc" id="L1147">            return Collections.emptyMap();</span>

<span class="nc" id="L1149">        return requests.getHeaders(null);</span>
    }

    /**
     * Sets the default value of a general request property. When a
     * {@code URLConnection} is created, it is initialized with
     * these properties.
     *
     * @param   key     the keyword by which the request is known
     *                  (e.g., &quot;{@code Accept}&quot;).
     * @param   value   the value associated with the key.
     *
     * @see java.net.URLConnection#setRequestProperty(java.lang.String,java.lang.String)
     *
     * @deprecated The instance specific setRequestProperty method
     * should be used after an appropriate instance of URLConnection
     * is obtained. Invoking this method will have no effect.
     *
     * @see #getDefaultRequestProperty(java.lang.String)
     */
    @Deprecated
    public static void setDefaultRequestProperty(String key, String value) {
<span class="nc" id="L1171">    }</span>

    /**
     * Returns the value of the default request property. Default request
     * properties are set for every connection.
     *
     * @param key the keyword by which the request is known (e.g., &quot;Accept&quot;).
     * @return  the value of the default request property
     * for the specified key.
     *
     * @see java.net.URLConnection#getRequestProperty(java.lang.String)
     *
     * @deprecated The instance specific getRequestProperty method
     * should be used after an appropriate instance of URLConnection
     * is obtained.
     *
     * @see #setDefaultRequestProperty(java.lang.String, java.lang.String)
     */
    @Deprecated
    public static String getDefaultRequestProperty(String key) {
<span class="nc" id="L1191">        return null;</span>
    }

    /**
     * The ContentHandler factory.
     */
    static ContentHandlerFactory factory;

    /**
     * Sets the {@code ContentHandlerFactory} of an
     * application. It can be called at most once by an application.
     * &lt;p&gt;
     * The {@code ContentHandlerFactory} instance is used to
     * construct a content handler from a content type
     * &lt;p&gt;
     * If there is a security manager, this method first calls
     * the security manager's {@code checkSetFactory} method
     * to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * @param      fac   the desired factory.
     * @exception  Error  if the factory has already been defined.
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkSetFactory} method doesn't allow the operation.
     * @see        java.net.ContentHandlerFactory
     * @see        java.net.URLConnection#getContent()
     * @see        SecurityManager#checkSetFactory
     */
    public static synchronized void setContentHandlerFactory(ContentHandlerFactory fac) {
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        if (factory != null) {</span>
<span class="nc" id="L1221">            throw new Error(&quot;factory already defined&quot;);</span>
        }
<span class="nc" id="L1223">        SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">        if (security != null) {</span>
<span class="nc" id="L1225">            security.checkSetFactory();</span>
        }
<span class="nc" id="L1227">        factory = fac;</span>
<span class="nc" id="L1228">    }</span>

<span class="fc" id="L1230">    private static Hashtable&lt;String, ContentHandler&gt; handlers = new Hashtable&lt;&gt;();</span>

    /**
     * Gets the Content Handler appropriate for this connection.
     */
    synchronized ContentHandler getContentHandler()
        throws UnknownServiceException
    {
<span class="fc" id="L1238">        String contentType = stripOffParameters(getContentType());</span>
<span class="fc" id="L1239">        ContentHandler handler = null;</span>
<span class="pc bpc" id="L1240" title="1 of 2 branches missed.">        if (contentType == null)</span>
<span class="nc" id="L1241">            throw new UnknownServiceException(&quot;no content-type&quot;);</span>
        try {
<span class="fc" id="L1243">            handler = handlers.get(contentType);</span>
<span class="pc bpc" id="L1244" title="1 of 2 branches missed.">            if (handler != null)</span>
<span class="nc" id="L1245">                return handler;</span>
<span class="nc" id="L1246">        } catch(Exception e) {</span>
<span class="fc" id="L1247">        }</span>

<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">        if (factory != null)</span>
<span class="nc" id="L1250">            handler = factory.createContentHandler(contentType);</span>
<span class="pc bpc" id="L1251" title="1 of 2 branches missed.">        if (handler == null) {</span>
            try {
<span class="fc" id="L1253">                handler = lookupContentHandlerClassFor(contentType);</span>
<span class="nc" id="L1254">            } catch(Exception e) {</span>
<span class="nc" id="L1255">                e.printStackTrace();</span>
<span class="nc" id="L1256">                handler = UnknownContentHandler.INSTANCE;</span>
<span class="fc" id="L1257">            }</span>
<span class="fc" id="L1258">            handlers.put(contentType, handler);</span>
        }
<span class="fc" id="L1260">        return handler;</span>
    }

    /*
     * Media types are in the format: type/subtype*(; parameter).
     * For looking up the content handler, we should ignore those
     * parameters.
     */
    private String stripOffParameters(String contentType)
    {
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">        if (contentType == null)</span>
<span class="nc" id="L1271">            return null;</span>
<span class="fc" id="L1272">        int index = contentType.indexOf(';');</span>

<span class="fc bfc" id="L1274" title="All 2 branches covered.">        if (index &gt; 0)</span>
<span class="fc" id="L1275">            return contentType.substring(0, index);</span>
        else
<span class="fc" id="L1277">            return contentType;</span>
    }

    private static final String contentClassPrefix = &quot;sun.net.www.content&quot;;
    private static final String contentPathProp = &quot;java.content.handler.pkgs&quot;;

    /**
     * Looks for a content handler in a user-defineable set of places.
     * By default it looks in sun.net.www.content, but users can define a
     * vertical-bar delimited set of class prefixes to search through in
     * addition by defining the java.content.handler.pkgs property.
     * The class name must be of the form:
     * &lt;pre&gt;
     *     {package-prefix}.{major}.{minor}
     * e.g.
     *     YoyoDyne.experimental.text.plain
     * &lt;/pre&gt;
     */
    private ContentHandler lookupContentHandlerClassFor(String contentType)
        throws InstantiationException, IllegalAccessException, ClassNotFoundException {
<span class="fc" id="L1297">        String contentHandlerClassName = typeToPackageName(contentType);</span>

<span class="fc" id="L1299">        String contentHandlerPkgPrefixes =getContentHandlerPkgPrefixes();</span>

<span class="fc" id="L1301">        StringTokenizer packagePrefixIter =</span>
            new StringTokenizer(contentHandlerPkgPrefixes, &quot;|&quot;);

<span class="fc bfc" id="L1304" title="All 2 branches covered.">        while (packagePrefixIter.hasMoreTokens()) {</span>
<span class="fc" id="L1305">            String packagePrefix = packagePrefixIter.nextToken().trim();</span>

            try {
<span class="fc" id="L1308">                String clsName = packagePrefix + &quot;.&quot; + contentHandlerClassName;</span>
<span class="fc" id="L1309">                Class&lt;?&gt; cls = null;</span>
                try {
<span class="fc" id="L1311">                    cls = Class.forName(clsName);</span>
<span class="fc" id="L1312">                } catch (ClassNotFoundException e) {</span>
<span class="fc" id="L1313">                    ClassLoader cl = ClassLoader.getSystemClassLoader();</span>
<span class="pc bpc" id="L1314" title="1 of 2 branches missed.">                    if (cl != null) {</span>
<span class="fc" id="L1315">                        cls = cl.loadClass(clsName);</span>
                    }
<span class="fc" id="L1317">                }</span>
<span class="pc bpc" id="L1318" title="1 of 2 branches missed.">                if (cls != null) {</span>
<span class="fc" id="L1319">                    ContentHandler handler =</span>
<span class="fc" id="L1320">                        (ContentHandler)cls.newInstance();</span>
<span class="fc" id="L1321">                    return handler;</span>
                }
<span class="fc" id="L1323">            } catch(Exception e) {</span>
<span class="nc" id="L1324">            }</span>
<span class="fc" id="L1325">        }</span>

<span class="fc" id="L1327">        return UnknownContentHandler.INSTANCE;</span>
    }

    /**
     * Utility function to map a MIME content type into an equivalent
     * pair of class name components.  For example: &quot;text/html&quot; would
     * be returned as &quot;text.html&quot;
     */
    private String typeToPackageName(String contentType) {
        // make sure we canonicalize the class name: all lower case
<span class="fc" id="L1337">        contentType = contentType.toLowerCase();</span>
<span class="fc" id="L1338">        int len = contentType.length();</span>
<span class="fc" id="L1339">        char nm[] = new char[len];</span>
<span class="fc" id="L1340">        contentType.getChars(0, len, nm, 0);</span>
<span class="fc bfc" id="L1341" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1342">            char c = nm[i];</span>
<span class="fc bfc" id="L1343" title="All 2 branches covered.">            if (c == '/') {</span>
<span class="fc" id="L1344">                nm[i] = '.';</span>
<span class="pc bpc" id="L1345" title="8 of 12 branches missed.">            } else if (!('A' &lt;= c &amp;&amp; c &lt;= 'Z' ||</span>
                       'a' &lt;= c &amp;&amp; c &lt;= 'z' ||
                       '0' &lt;= c &amp;&amp; c &lt;= '9')) {
<span class="nc" id="L1348">                nm[i] = '_';</span>
            }
        }
<span class="fc" id="L1351">        return new String(nm);</span>
    }


    /**
     * Returns a vertical bar separated list of package prefixes for potential
     * content handlers.  Tries to get the java.content.handler.pkgs property
     * to use as a set of package prefixes to search.  Whether or not
     * that property has been defined, the sun.net.www.content is always
     * the last one on the returned package list.
     */
    private String getContentHandlerPkgPrefixes() {
<span class="fc" id="L1363">        String packagePrefixList = AccessController.doPrivileged(</span>
            new sun.security.action.GetPropertyAction(contentPathProp, &quot;&quot;));

<span class="fc bfc" id="L1366" title="All 2 branches covered.">        if (packagePrefixList != &quot;&quot;) {</span>
<span class="fc" id="L1367">            packagePrefixList += &quot;|&quot;;</span>
        }

<span class="fc" id="L1370">        return packagePrefixList + contentClassPrefix;</span>
    }

    /**
     * Tries to determine the content type of an object, based
     * on the specified &quot;file&quot; component of a URL.
     * This is a convenience method that can be used by
     * subclasses that override the {@code getContentType} method.
     *
     * @param   fname   a filename.
     * @return  a guess as to what the content type of the object is,
     *          based upon its file name.
     * @see     java.net.URLConnection#getContentType()
     */
    public static String guessContentTypeFromName(String fname) {
<span class="fc" id="L1385">        return getFileNameMap().getContentTypeFor(fname);</span>
    }

    /**
     * Tries to determine the type of an input stream based on the
     * characters at the beginning of the input stream. This method can
     * be used by subclasses that override the
     * {@code getContentType} method.
     * &lt;p&gt;
     * Ideally, this routine would not be needed. But many
     * {@code http} servers return the incorrect content type; in
     * addition, there are many nonstandard extensions. Direct inspection
     * of the bytes to determine the content type is often more accurate
     * than believing the content type claimed by the {@code http} server.
     *
     * @param      is   an input stream that supports marks.
     * @return     a guess at the content type, or {@code null} if none
     *             can be determined.
     * @exception  IOException  if an I/O error occurs while reading the
     *               input stream.
     * @see        java.io.InputStream#mark(int)
     * @see        java.io.InputStream#markSupported()
     * @see        java.net.URLConnection#getContentType()
     */
    static public String guessContentTypeFromStream(InputStream is)
                        throws IOException {
        // If we can't read ahead safely, just give up on guessing
<span class="pc bpc" id="L1412" title="1 of 2 branches missed.">        if (!is.markSupported())</span>
<span class="nc" id="L1413">            return null;</span>

<span class="fc" id="L1415">        is.mark(16);</span>
<span class="fc" id="L1416">        int c1 = is.read();</span>
<span class="fc" id="L1417">        int c2 = is.read();</span>
<span class="fc" id="L1418">        int c3 = is.read();</span>
<span class="fc" id="L1419">        int c4 = is.read();</span>
<span class="fc" id="L1420">        int c5 = is.read();</span>
<span class="fc" id="L1421">        int c6 = is.read();</span>
<span class="fc" id="L1422">        int c7 = is.read();</span>
<span class="fc" id="L1423">        int c8 = is.read();</span>
<span class="fc" id="L1424">        int c9 = is.read();</span>
<span class="fc" id="L1425">        int c10 = is.read();</span>
<span class="fc" id="L1426">        int c11 = is.read();</span>
<span class="fc" id="L1427">        int c12 = is.read();</span>
<span class="fc" id="L1428">        int c13 = is.read();</span>
<span class="fc" id="L1429">        int c14 = is.read();</span>
<span class="fc" id="L1430">        int c15 = is.read();</span>
<span class="fc" id="L1431">        int c16 = is.read();</span>
<span class="fc" id="L1432">        is.reset();</span>

<span class="pc bpc" id="L1434" title="7 of 8 branches missed.">        if (c1 == 0xCA &amp;&amp; c2 == 0xFE &amp;&amp; c3 == 0xBA &amp;&amp; c4 == 0xBE) {</span>
<span class="nc" id="L1435">            return &quot;application/java-vm&quot;;</span>
        }

<span class="pc bpc" id="L1438" title="3 of 4 branches missed.">        if (c1 == 0xAC &amp;&amp; c2 == 0xED) {</span>
            // next two bytes are version number, currently 0x00 0x05
<span class="nc" id="L1440">            return &quot;application/x-java-serialized-object&quot;;</span>
        }

<span class="fc bfc" id="L1443" title="All 2 branches covered.">        if (c1 == '&lt;') {</span>
<span class="pc bpc" id="L1444" title="41 of 46 branches missed.">            if (c2 == '!'</span>
                || ((c2 == 'h' &amp;&amp; (c3 == 't' &amp;&amp; c4 == 'm' &amp;&amp; c5 == 'l' ||
                                   c3 == 'e' &amp;&amp; c4 == 'a' &amp;&amp; c5 == 'd') ||
                (c2 == 'b' &amp;&amp; c3 == 'o' &amp;&amp; c4 == 'd' &amp;&amp; c5 == 'y'))) ||
                ((c2 == 'H' &amp;&amp; (c3 == 'T' &amp;&amp; c4 == 'M' &amp;&amp; c5 == 'L' ||
                                c3 == 'E' &amp;&amp; c4 == 'A' &amp;&amp; c5 == 'D') ||
                (c2 == 'B' &amp;&amp; c3 == 'O' &amp;&amp; c4 == 'D' &amp;&amp; c5 == 'Y')))) {
<span class="nc" id="L1451">                return &quot;text/html&quot;;</span>
            }

<span class="pc bpc" id="L1454" title="3 of 10 branches missed.">            if (c2 == '?' &amp;&amp; c3 == 'x' &amp;&amp; c4 == 'm' &amp;&amp; c5 == 'l' &amp;&amp; c6 == ' ') {</span>
<span class="fc" id="L1455">                return &quot;application/xml&quot;;</span>
            }
        }

        // big and little (identical) endian UTF-8 encodings, with BOM
<span class="pc bpc" id="L1460" title="2 of 6 branches missed.">        if (c1 == 0xef &amp;&amp;  c2 == 0xbb &amp;&amp;  c3 == 0xbf) {</span>
<span class="pc bpc" id="L1461" title="3 of 6 branches missed.">            if (c4 == '&lt;' &amp;&amp;  c5 == '?' &amp;&amp;  c6 == 'x') {</span>
<span class="fc" id="L1462">                return &quot;application/xml&quot;;</span>
            }
        }

        // big and little endian UTF-16 encodings, with byte order mark
<span class="pc bpc" id="L1467" title="1 of 4 branches missed.">        if (c1 == 0xfe &amp;&amp; c2 == 0xff) {</span>
<span class="pc bpc" id="L1468" title="6 of 12 branches missed.">            if (c3 == 0 &amp;&amp; c4 == '&lt;' &amp;&amp; c5 == 0 &amp;&amp; c6 == '?' &amp;&amp;</span>
                c7 == 0 &amp;&amp; c8 == 'x') {
<span class="fc" id="L1470">                return &quot;application/xml&quot;;</span>
            }
        }

<span class="fc bfc" id="L1474" title="All 4 branches covered.">        if (c1 == 0xff &amp;&amp; c2 == 0xfe) {</span>
<span class="pc bpc" id="L1475" title="5 of 12 branches missed.">            if (c3 == '&lt;' &amp;&amp; c4 == 0 &amp;&amp; c5 == '?' &amp;&amp; c6 == 0 &amp;&amp;</span>
                c7 == 'x' &amp;&amp; c8 == 0) {
<span class="fc" id="L1477">                return &quot;application/xml&quot;;</span>
            }
        }

        // big and little endian UTF-32 encodings, with BOM
<span class="pc bpc" id="L1482" title="2 of 8 branches missed.">        if (c1 == 0x00 &amp;&amp;  c2 == 0x00 &amp;&amp;  c3 == 0xfe &amp;&amp;  c4 == 0xff) {</span>
<span class="pc bpc" id="L1483" title="12 of 24 branches missed.">            if (c5  == 0 &amp;&amp; c6  == 0 &amp;&amp; c7  == 0 &amp;&amp; c8  == '&lt;' &amp;&amp;</span>
                c9  == 0 &amp;&amp; c10 == 0 &amp;&amp; c11 == 0 &amp;&amp; c12 == '?' &amp;&amp;
                c13 == 0 &amp;&amp; c14 == 0 &amp;&amp; c15 == 0 &amp;&amp; c16 == 'x') {
<span class="fc" id="L1486">                return &quot;application/xml&quot;;</span>
            }
        }

<span class="pc bpc" id="L1490" title="2 of 8 branches missed.">        if (c1 == 0xff &amp;&amp;  c2 == 0xfe &amp;&amp;  c3 == 0x00 &amp;&amp;  c4 == 0x00) {</span>
<span class="pc bpc" id="L1491" title="12 of 24 branches missed.">            if (c5  == '&lt;' &amp;&amp; c6  == 0 &amp;&amp; c7  == 0 &amp;&amp; c8  == 0 &amp;&amp;</span>
                c9  == '?' &amp;&amp; c10 == 0 &amp;&amp; c11 == 0 &amp;&amp; c12 == 0 &amp;&amp;
                c13 == 'x' &amp;&amp; c14 == 0 &amp;&amp; c15 == 0 &amp;&amp; c16 == 0) {
<span class="fc" id="L1494">                return &quot;application/xml&quot;;</span>
            }
        }

<span class="pc bpc" id="L1498" title="7 of 8 branches missed.">        if (c1 == 'G' &amp;&amp; c2 == 'I' &amp;&amp; c3 == 'F' &amp;&amp; c4 == '8') {</span>
<span class="nc" id="L1499">            return &quot;image/gif&quot;;</span>
        }

<span class="pc bpc" id="L1502" title="7 of 8 branches missed.">        if (c1 == '#' &amp;&amp; c2 == 'd' &amp;&amp; c3 == 'e' &amp;&amp; c4 == 'f') {</span>
<span class="nc" id="L1503">            return &quot;image/x-bitmap&quot;;</span>
        }

<span class="pc bpc" id="L1506" title="11 of 12 branches missed.">        if (c1 == '!' &amp;&amp; c2 == ' ' &amp;&amp; c3 == 'X' &amp;&amp; c4 == 'P' &amp;&amp;</span>
                        c5 == 'M' &amp;&amp; c6 == '2') {
<span class="nc" id="L1508">            return &quot;image/x-pixmap&quot;;</span>
        }

<span class="pc bpc" id="L1511" title="15 of 16 branches missed.">        if (c1 == 137 &amp;&amp; c2 == 80 &amp;&amp; c3 == 78 &amp;&amp;</span>
                c4 == 71 &amp;&amp; c5 == 13 &amp;&amp; c6 == 10 &amp;&amp;
                c7 == 26 &amp;&amp; c8 == 10) {
<span class="nc" id="L1514">            return &quot;image/png&quot;;</span>
        }

<span class="pc bpc" id="L1517" title="2 of 6 branches missed.">        if (c1 == 0xFF &amp;&amp; c2 == 0xD8 &amp;&amp; c3 == 0xFF) {</span>
<span class="pc bpc" id="L1518" title="1 of 2 branches missed.">            if (c4 == 0xE0) {</span>
<span class="nc" id="L1519">                return &quot;image/jpeg&quot;;</span>
            }

            /**
             * File format used by digital cameras to store images.
             * Exif Format can be read by any application supporting
             * JPEG. Exif Spec can be found at:
             * http://www.pima.net/standards/it10/PIMA15740/Exif_2-1.PDF
             */
<span class="pc bpc" id="L1528" title="6 of 12 branches missed.">            if ((c4 == 0xE1) &amp;&amp;</span>
                (c7 == 'E' &amp;&amp; c8 == 'x' &amp;&amp; c9 == 'i' &amp;&amp; c10 =='f' &amp;&amp;
                 c11 == 0)) {
<span class="fc" id="L1531">                return &quot;image/jpeg&quot;;</span>
            }

<span class="nc bnc" id="L1534" title="All 2 branches missed.">            if (c4 == 0xEE) {</span>
<span class="nc" id="L1535">                return &quot;image/jpg&quot;;</span>
            }
        }

<span class="pc bpc" id="L1539" title="7 of 16 branches missed.">        if (c1 == 0xD0 &amp;&amp; c2 == 0xCF &amp;&amp; c3 == 0x11 &amp;&amp; c4 == 0xE0 &amp;&amp;</span>
            c5 == 0xA1 &amp;&amp; c6 == 0xB1 &amp;&amp; c7 == 0x1A &amp;&amp; c8 == 0xE1) {

            /* Above is signature of Microsoft Structured Storage.
             * Below this, could have tests for various SS entities.
             * For now, just test for FlashPix.
             */
<span class="pc bpc" id="L1546" title="1 of 2 branches missed.">            if (checkfpx(is)) {</span>
<span class="nc" id="L1547">                return &quot;image/vnd.fpx&quot;;</span>
            }
        }

<span class="pc bpc" id="L1551" title="7 of 8 branches missed.">        if (c1 == 0x2E &amp;&amp; c2 == 0x73 &amp;&amp; c3 == 0x6E &amp;&amp; c4 == 0x64) {</span>
<span class="nc" id="L1552">            return &quot;audio/basic&quot;;  // .au format, big endian</span>
        }

<span class="pc bpc" id="L1555" title="7 of 8 branches missed.">        if (c1 == 0x64 &amp;&amp; c2 == 0x6E &amp;&amp; c3 == 0x73 &amp;&amp; c4 == 0x2E) {</span>
<span class="nc" id="L1556">            return &quot;audio/basic&quot;;  // .au format, little endian</span>
        }

<span class="pc bpc" id="L1559" title="7 of 8 branches missed.">        if (c1 == 'R' &amp;&amp; c2 == 'I' &amp;&amp; c3 == 'F' &amp;&amp; c4 == 'F') {</span>
            /* I don't know if this is official but evidence
             * suggests that .wav files start with &quot;RIFF&quot; - brown
             */
<span class="nc" id="L1563">            return &quot;audio/x-wav&quot;;</span>
        }
<span class="fc" id="L1565">        return null;</span>
    }

    /**
     * Check for FlashPix image data in InputStream is.  Return true if
     * the stream has FlashPix data, false otherwise.  Before calling this
     * method, the stream should have already been checked to be sure it
     * contains Microsoft Structured Storage data.
     */
    static private boolean checkfpx(InputStream is) throws IOException {

        /* Test for FlashPix image data in Microsoft Structured Storage format.
         * In general, should do this with calls to an SS implementation.
         * Lacking that, need to dig via offsets to get to the FlashPix
         * ClassID.  Details:
         *
         * Offset to Fpx ClsID from beginning of stream should be:
         *
         * FpxClsidOffset = rootEntryOffset + clsidOffset
         *
         * where: clsidOffset = 0x50.
         *        rootEntryOffset = headerSize + sectorSize*sectDirStart
         *                          + 128*rootEntryDirectory
         *
         *        where:  headerSize = 0x200 (always)
         *                sectorSize = 2 raised to power of uSectorShift,
         *                             which is found in the header at
         *                             offset 0x1E.
         *                sectDirStart = found in the header at offset 0x30.
         *                rootEntryDirectory = in general, should search for
         *                                     directory labelled as root.
         *                                     We will assume value of 0 (i.e.,
         *                                     rootEntry is in first directory)
         */

        // Mark the stream so we can reset it. 0x100 is enough for the first
        // few reads, but the mark will have to be reset and set again once
        // the offset to the root directory entry is computed. That offset
        // can be very large and isn't know until the stream has been read from
<span class="fc" id="L1604">        is.mark(0x100);</span>

        // Get the byte ordering located at 0x1E. 0xFE is Intel,
        // 0xFF is other
<span class="fc" id="L1608">        long toSkip = (long)0x1C;</span>
        long posn;

<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">        if ((posn = skipForward(is, toSkip)) &lt; toSkip) {</span>
<span class="nc" id="L1612">          is.reset();</span>
<span class="nc" id="L1613">          return false;</span>
        }

<span class="fc" id="L1616">        int c[] = new int[16];</span>
<span class="pc bpc" id="L1617" title="1 of 2 branches missed.">        if (readBytes(c, 2, is) &lt; 0) {</span>
<span class="nc" id="L1618">            is.reset();</span>
<span class="nc" id="L1619">            return false;</span>
        }

<span class="fc" id="L1622">        int byteOrder = c[0];</span>

<span class="fc" id="L1624">        posn+=2;</span>
        int uSectorShift;
<span class="pc bpc" id="L1626" title="1 of 2 branches missed.">        if (readBytes(c, 2, is) &lt; 0) {</span>
<span class="nc" id="L1627">            is.reset();</span>
<span class="nc" id="L1628">            return false;</span>
        }

<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">        if(byteOrder == 0xFE) {</span>
<span class="fc" id="L1632">            uSectorShift = c[0];</span>
<span class="fc" id="L1633">            uSectorShift += c[1] &lt;&lt; 8;</span>
        }
        else {
<span class="nc" id="L1636">            uSectorShift = c[0] &lt;&lt; 8;</span>
<span class="nc" id="L1637">            uSectorShift += c[1];</span>
        }

<span class="fc" id="L1640">        posn += 2;</span>
<span class="fc" id="L1641">        toSkip = (long)0x30 - posn;</span>
<span class="fc" id="L1642">        long skipped = 0;</span>
<span class="pc bpc" id="L1643" title="1 of 2 branches missed.">        if ((skipped = skipForward(is, toSkip)) &lt; toSkip) {</span>
<span class="nc" id="L1644">          is.reset();</span>
<span class="nc" id="L1645">          return false;</span>
        }
<span class="fc" id="L1647">        posn += skipped;</span>

<span class="pc bpc" id="L1649" title="1 of 2 branches missed.">        if (readBytes(c, 4, is) &lt; 0) {</span>
<span class="nc" id="L1650">            is.reset();</span>
<span class="nc" id="L1651">            return false;</span>
        }

        int sectDirStart;
<span class="pc bpc" id="L1655" title="1 of 2 branches missed.">        if(byteOrder == 0xFE) {</span>
<span class="fc" id="L1656">            sectDirStart = c[0];</span>
<span class="fc" id="L1657">            sectDirStart += c[1] &lt;&lt; 8;</span>
<span class="fc" id="L1658">            sectDirStart += c[2] &lt;&lt; 16;</span>
<span class="fc" id="L1659">            sectDirStart += c[3] &lt;&lt; 24;</span>
        } else {
<span class="nc" id="L1661">            sectDirStart =  c[0] &lt;&lt; 24;</span>
<span class="nc" id="L1662">            sectDirStart += c[1] &lt;&lt; 16;</span>
<span class="nc" id="L1663">            sectDirStart += c[2] &lt;&lt; 8;</span>
<span class="nc" id="L1664">            sectDirStart += c[3];</span>
        }
<span class="fc" id="L1666">        posn += 4;</span>
<span class="fc" id="L1667">        is.reset(); // Reset back to the beginning</span>

<span class="fc" id="L1669">        toSkip = 0x200L + (long)(1&lt;&lt;uSectorShift)*sectDirStart + 0x50L;</span>

        // Sanity check!
<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">        if (toSkip &lt; 0) {</span>
<span class="nc" id="L1673">            return false;</span>
        }

        /*
         * How far can we skip? Is there any performance problem here?
         * This skip can be fairly long, at least 0x4c650 in at least
         * one case. Have to assume that the skip will fit in an int.
         * Leave room to read whole root dir
         */
<span class="fc" id="L1682">        is.mark((int)toSkip+0x30);</span>

<span class="pc bpc" id="L1684" title="1 of 2 branches missed.">        if ((skipForward(is, toSkip)) &lt; toSkip) {</span>
<span class="nc" id="L1685">            is.reset();</span>
<span class="nc" id="L1686">            return false;</span>
        }

        /* should be at beginning of ClassID, which is as follows
         * (in Intel byte order):
         *    00 67 61 56 54 C1 CE 11 85 53 00 AA 00 A1 F9 5B
         *
         * This is stored from Windows as long,short,short,char[8]
         * so for byte order changes, the order only changes for
         * the first 8 bytes in the ClassID.
         *
         * Test against this, ignoring second byte (Intel) since
         * this could change depending on part of Fpx file we have.
         */

<span class="pc bpc" id="L1701" title="1 of 2 branches missed.">        if (readBytes(c, 16, is) &lt; 0) {</span>
<span class="nc" id="L1702">            is.reset();</span>
<span class="nc" id="L1703">            return false;</span>
        }

        // intel byte order
<span class="pc bpc" id="L1707" title="29 of 32 branches missed.">        if (byteOrder == 0xFE &amp;&amp;</span>
            c[0] == 0x00 &amp;&amp; c[2] == 0x61 &amp;&amp; c[3] == 0x56 &amp;&amp;
            c[4] == 0x54 &amp;&amp; c[5] == 0xC1 &amp;&amp; c[6] == 0xCE &amp;&amp;
            c[7] == 0x11 &amp;&amp; c[8] == 0x85 &amp;&amp; c[9] == 0x53 &amp;&amp;
            c[10]== 0x00 &amp;&amp; c[11]== 0xAA &amp;&amp; c[12]== 0x00 &amp;&amp;
            c[13]== 0xA1 &amp;&amp; c[14]== 0xF9 &amp;&amp; c[15]== 0x5B) {
<span class="nc" id="L1713">            is.reset();</span>
<span class="nc" id="L1714">            return true;</span>
        }

        // non-intel byte order
<span class="pc bpc" id="L1718" title="28 of 30 branches missed.">        else if (c[3] == 0x00 &amp;&amp; c[1] == 0x61 &amp;&amp; c[0] == 0x56 &amp;&amp;</span>
            c[5] == 0x54 &amp;&amp; c[4] == 0xC1 &amp;&amp; c[7] == 0xCE &amp;&amp;
            c[6] == 0x11 &amp;&amp; c[8] == 0x85 &amp;&amp; c[9] == 0x53 &amp;&amp;
            c[10]== 0x00 &amp;&amp; c[11]== 0xAA &amp;&amp; c[12]== 0x00 &amp;&amp;
            c[13]== 0xA1 &amp;&amp; c[14]== 0xF9 &amp;&amp; c[15]== 0x5B) {
<span class="nc" id="L1723">            is.reset();</span>
<span class="nc" id="L1724">            return true;</span>
        }
<span class="fc" id="L1726">        is.reset();</span>
<span class="fc" id="L1727">        return false;</span>
    }

    /**
     * Tries to read the specified number of bytes from the stream
     * Returns -1, If EOF is reached before len bytes are read, returns 0
     * otherwise
     */
    static private int readBytes(int c[], int len, InputStream is)
                throws IOException {

<span class="fc" id="L1738">        byte buf[] = new byte[len];</span>
<span class="pc bpc" id="L1739" title="1 of 2 branches missed.">        if (is.read(buf, 0, len) &lt; len) {</span>
<span class="nc" id="L1740">            return -1;</span>
        }

        // fill the passed in int array
<span class="fc bfc" id="L1744" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1745">             c[i] = buf[i] &amp; 0xff;</span>
        }
<span class="fc" id="L1747">        return 0;</span>
    }


    /**
     * Skips through the specified number of bytes from the stream
     * until either EOF is reached, or the specified
     * number of bytes have been skipped
     */
    static private long skipForward(InputStream is, long toSkip)
                throws IOException {

<span class="fc" id="L1759">        long eachSkip = 0;</span>
<span class="fc" id="L1760">        long skipped = 0;</span>

<span class="fc bfc" id="L1762" title="All 2 branches covered.">        while (skipped != toSkip) {</span>
<span class="fc" id="L1763">            eachSkip = is.skip(toSkip - skipped);</span>

            // check if EOF is reached
<span class="pc bpc" id="L1766" title="1 of 2 branches missed.">            if (eachSkip &lt;= 0) {</span>
<span class="nc bnc" id="L1767" title="All 2 branches missed.">                if (is.read() == -1) {</span>
<span class="nc" id="L1768">                    return skipped ;</span>
                } else {
<span class="nc" id="L1770">                    skipped++;</span>
                }
            }
<span class="fc" id="L1773">            skipped += eachSkip;</span>
        }
<span class="fc" id="L1775">        return skipped;</span>
    }

}


<span class="fc" id="L1781">class UnknownContentHandler extends ContentHandler {</span>
<span class="fc" id="L1782">    static final ContentHandler INSTANCE = new UnknownContentHandler();</span>

    public Object getContent(URLConnection uc) throws IOException {
<span class="fc" id="L1785">        return uc.getInputStream();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>