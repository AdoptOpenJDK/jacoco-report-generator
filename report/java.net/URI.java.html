<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>URI.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">URI.java</span></div><h1>URI.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CoderResult;
import java.nio.charset.CodingErrorAction;
import java.nio.charset.CharacterCodingException;
import java.text.Normalizer;
import sun.nio.cs.ThreadLocalCoders;

import java.lang.Character;             // for javadoc
import java.lang.NullPointerException;  // for javadoc


/**
 * Represents a Uniform Resource Identifier (URI) reference.
 *
 * &lt;p&gt; Aside from some minor deviations noted below, an instance of this
 * class represents a URI reference as defined by
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
 * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
 * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
 * also supports scope_ids. The syntax and usage of scope_ids is described
 * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
 * This class provides constructors for creating URI instances from
 * their components or by parsing their string forms, methods for accessing the
 * various components of an instance, and methods for normalizing, resolving,
 * and relativizing URI instances.  Instances of this class are immutable.
 *
 *
 * &lt;h3&gt; URI syntax and components &lt;/h3&gt;
 *
 * At the highest level a URI reference (hereinafter simply &quot;URI&quot;) in string
 * form has the syntax
 *
 * &lt;blockquote&gt;
 * [&lt;i&gt;scheme&lt;/i&gt;&lt;b&gt;{@code :}&lt;/b&gt;]&lt;i&gt;scheme-specific-part&lt;/i&gt;[&lt;b&gt;{@code #}&lt;/b&gt;&lt;i&gt;fragment&lt;/i&gt;]
 * &lt;/blockquote&gt;
 *
 * where square brackets [...] delineate optional components and the characters
 * &lt;b&gt;{@code :}&lt;/b&gt; and &lt;b&gt;{@code #}&lt;/b&gt; stand for themselves.
 *
 * &lt;p&gt; An &lt;i&gt;absolute&lt;/i&gt; URI specifies a scheme; a URI that is not absolute is
 * said to be &lt;i&gt;relative&lt;/i&gt;.  URIs are also classified according to whether
 * they are &lt;i&gt;opaque&lt;/i&gt; or &lt;i&gt;hierarchical&lt;/i&gt;.
 *
 * &lt;p&gt; An &lt;i&gt;opaque&lt;/i&gt; URI is an absolute URI whose scheme-specific part does
 * not begin with a slash character ({@code '/'}).  Opaque URIs are not
 * subject to further parsing.  Some examples of opaque URIs are:
 *
 * &lt;blockquote&gt;&lt;table cellpadding=0 cellspacing=0 summary=&quot;layout&quot;&gt;
 * &lt;tr&gt;&lt;td&gt;{@code mailto:java-net@java.sun.com}&lt;td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;{@code news:comp.lang.java}&lt;td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;{@code urn:isbn:096139210x}&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; A &lt;i&gt;hierarchical&lt;/i&gt; URI is either an absolute URI whose
 * scheme-specific part begins with a slash character, or a relative URI, that
 * is, a URI that does not specify a scheme.  Some examples of hierarchical
 * URIs are:
 *
 * &lt;blockquote&gt;
 * {@code http://java.sun.com/j2se/1.3/}&lt;br&gt;
 * {@code docs/guide/collections/designfaq.html#28}&lt;br&gt;
 * {@code ../../../demo/jfc/SwingSet2/src/SwingSet2.java}&lt;br&gt;
 * {@code file:///~/calendar}
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt; A hierarchical URI is subject to further parsing according to the syntax
 *
 * &lt;blockquote&gt;
 * [&lt;i&gt;scheme&lt;/i&gt;&lt;b&gt;{@code :}&lt;/b&gt;][&lt;b&gt;{@code //}&lt;/b&gt;&lt;i&gt;authority&lt;/i&gt;][&lt;i&gt;path&lt;/i&gt;][&lt;b&gt;{@code ?}&lt;/b&gt;&lt;i&gt;query&lt;/i&gt;][&lt;b&gt;{@code #}&lt;/b&gt;&lt;i&gt;fragment&lt;/i&gt;]
 * &lt;/blockquote&gt;
 *
 * where the characters &lt;b&gt;{@code :}&lt;/b&gt;, &lt;b&gt;{@code /}&lt;/b&gt;,
 * &lt;b&gt;{@code ?}&lt;/b&gt;, and &lt;b&gt;{@code #}&lt;/b&gt; stand for themselves.  The
 * scheme-specific part of a hierarchical URI consists of the characters
 * between the scheme and fragment components.
 *
 * &lt;p&gt; The authority component of a hierarchical URI is, if specified, either
 * &lt;i&gt;server-based&lt;/i&gt; or &lt;i&gt;registry-based&lt;/i&gt;.  A server-based authority
 * parses according to the familiar syntax
 *
 * &lt;blockquote&gt;
 * [&lt;i&gt;user-info&lt;/i&gt;&lt;b&gt;{@code @}&lt;/b&gt;]&lt;i&gt;host&lt;/i&gt;[&lt;b&gt;{@code :}&lt;/b&gt;&lt;i&gt;port&lt;/i&gt;]
 * &lt;/blockquote&gt;
 *
 * where the characters &lt;b&gt;{@code @}&lt;/b&gt; and &lt;b&gt;{@code :}&lt;/b&gt; stand for
 * themselves.  Nearly all URI schemes currently in use are server-based.  An
 * authority component that does not parse in this way is considered to be
 * registry-based.
 *
 * &lt;p&gt; The path component of a hierarchical URI is itself said to be absolute
 * if it begins with a slash character ({@code '/'}); otherwise it is
 * relative.  The path of a hierarchical URI that is either absolute or
 * specifies an authority is always absolute.
 *
 * &lt;p&gt; All told, then, a URI instance has the following nine components:
 *
 * &lt;blockquote&gt;&lt;table summary=&quot;Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment&quot;&gt;
 * &lt;tr&gt;&lt;th&gt;&lt;i&gt;Component&lt;/i&gt;&lt;/th&gt;&lt;th&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;scheme&lt;/td&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;scheme-specific-part&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;authority&lt;/td&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;user-info&lt;/td&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;host&lt;/td&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;port&lt;/td&gt;&lt;td&gt;{@code int}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;path&lt;/td&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;query&lt;/td&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;fragment&lt;/td&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;&lt;/blockquote&gt;
 *
 * In a given instance any particular component is either &lt;i&gt;undefined&lt;/i&gt; or
 * &lt;i&gt;defined&lt;/i&gt; with a distinct value.  Undefined string components are
 * represented by {@code null}, while undefined integer components are
 * represented by {@code -1}.  A string component may be defined to have the
 * empty string as its value; this is not equivalent to that component being
 * undefined.
 *
 * &lt;p&gt; Whether a particular component is or is not defined in an instance
 * depends upon the type of the URI being represented.  An absolute URI has a
 * scheme component.  An opaque URI has a scheme, a scheme-specific part, and
 * possibly a fragment, but has no other components.  A hierarchical URI always
 * has a path (though it may be empty) and a scheme-specific-part (which at
 * least contains the path), and may have any of the other components.  If the
 * authority component is present and is server-based then the host component
 * will be defined and the user-information and port components may be defined.
 *
 *
 * &lt;h4&gt; Operations on URI instances &lt;/h4&gt;
 *
 * The key operations supported by this class are those of
 * &lt;i&gt;normalization&lt;/i&gt;, &lt;i&gt;resolution&lt;/i&gt;, and &lt;i&gt;relativization&lt;/i&gt;.
 *
 * &lt;p&gt; &lt;i&gt;Normalization&lt;/i&gt; is the process of removing unnecessary {@code &quot;.&quot;}
 * and {@code &quot;..&quot;} segments from the path component of a hierarchical URI.
 * Each {@code &quot;.&quot;} segment is simply removed.  A {@code &quot;..&quot;} segment is
 * removed only if it is preceded by a non-{@code &quot;..&quot;} segment.
 * Normalization has no effect upon opaque URIs.
 *
 * &lt;p&gt; &lt;i&gt;Resolution&lt;/i&gt; is the process of resolving one URI against another,
 * &lt;i&gt;base&lt;/i&gt; URI.  The resulting URI is constructed from components of both
 * URIs in the manner specified by RFC&amp;nbsp;2396, taking components from the
 * base URI for those not specified in the original.  For hierarchical URIs,
 * the path of the original is resolved against the path of the base and then
 * normalized.  The result, for example, of resolving
 *
 * &lt;blockquote&gt;
 * {@code docs/guide/collections/designfaq.html#28}
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(1)
 * &lt;/blockquote&gt;
 *
 * against the base URI {@code http://java.sun.com/j2se/1.3/} is the result
 * URI
 *
 * &lt;blockquote&gt;
 * {@code http://docs.oracle.com/javase/1.3/docs/guide/collections/designfaq.html#28}
 * &lt;/blockquote&gt;
 *
 * Resolving the relative URI
 *
 * &lt;blockquote&gt;
 * {@code ../../../demo/jfc/SwingSet2/src/SwingSet2.java}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(2)
 * &lt;/blockquote&gt;
 *
 * against this result yields, in turn,
 *
 * &lt;blockquote&gt;
 * {@code http://java.sun.com/j2se/1.3/demo/jfc/SwingSet2/src/SwingSet2.java}
 * &lt;/blockquote&gt;
 *
 * Resolution of both absolute and relative URIs, and of both absolute and
 * relative paths in the case of hierarchical URIs, is supported.  Resolving
 * the URI {@code file:///~calendar} against any other URI simply yields the
 * original URI, since it is absolute.  Resolving the relative URI (2) above
 * against the relative base URI (1) yields the normalized, but still relative,
 * URI
 *
 * &lt;blockquote&gt;
 * {@code demo/jfc/SwingSet2/src/SwingSet2.java}
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt; &lt;i&gt;Relativization&lt;/i&gt;, finally, is the inverse of resolution: For any
 * two normalized URIs &lt;i&gt;u&lt;/i&gt; and&amp;nbsp;&lt;i&gt;v&lt;/i&gt;,
 *
 * &lt;blockquote&gt;
 *   &lt;i&gt;u&lt;/i&gt;{@code .relativize(}&lt;i&gt;u&lt;/i&gt;{@code .resolve(}&lt;i&gt;v&lt;/i&gt;{@code )).equals(}&lt;i&gt;v&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;and&lt;br&gt;
 *   &lt;i&gt;u&lt;/i&gt;{@code .resolve(}&lt;i&gt;u&lt;/i&gt;{@code .relativize(}&lt;i&gt;v&lt;/i&gt;{@code )).equals(}&lt;i&gt;v&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;.&lt;br&gt;
 * &lt;/blockquote&gt;
 *
 * This operation is often useful when constructing a document containing URIs
 * that must be made relative to the base URI of the document wherever
 * possible.  For example, relativizing the URI
 *
 * &lt;blockquote&gt;
 * {@code http://docs.oracle.com/javase/1.3/docs/guide/index.html}
 * &lt;/blockquote&gt;
 *
 * against the base URI
 *
 * &lt;blockquote&gt;
 * {@code http://java.sun.com/j2se/1.3}
 * &lt;/blockquote&gt;
 *
 * yields the relative URI {@code docs/guide/index.html}.
 *
 *
 * &lt;h4&gt; Character categories &lt;/h4&gt;
 *
 * RFC&amp;nbsp;2396 specifies precisely which characters are permitted in the
 * various components of a URI reference.  The following categories, most of
 * which are taken from that specification, are used below to describe these
 * constraints:
 *
 * &lt;blockquote&gt;&lt;table cellspacing=2 summary=&quot;Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other&quot;&gt;
 *   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;alpha&lt;/i&gt;&lt;/th&gt;
 *       &lt;td&gt;The US-ASCII alphabetic characters,
 *        {@code 'A'}&amp;nbsp;through&amp;nbsp;{@code 'Z'}
 *        and {@code 'a'}&amp;nbsp;through&amp;nbsp;{@code 'z'}&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;digit&lt;/i&gt;&lt;/th&gt;
 *       &lt;td&gt;The US-ASCII decimal digit characters,
 *       {@code '0'}&amp;nbsp;through&amp;nbsp;{@code '9'}&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;alphanum&lt;/i&gt;&lt;/th&gt;
 *       &lt;td&gt;All &lt;i&gt;alpha&lt;/i&gt; and &lt;i&gt;digit&lt;/i&gt; characters&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;unreserved&lt;/i&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 *       &lt;td&gt;All &lt;i&gt;alphanum&lt;/i&gt; characters together with those in the string
 *        {@code &quot;_-!.~'()*&quot;}&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;punct&lt;/i&gt;&lt;/th&gt;
 *       &lt;td&gt;The characters in the string {@code &quot;,;:$&amp;+=&quot;}&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;reserved&lt;/i&gt;&lt;/th&gt;
 *       &lt;td&gt;All &lt;i&gt;punct&lt;/i&gt; characters together with those in the string
 *        {@code &quot;?/[]@&quot;}&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;escaped&lt;/i&gt;&lt;/th&gt;
 *       &lt;td&gt;Escaped octets, that is, triplets consisting of the percent
 *           character ({@code '%'}) followed by two hexadecimal digits
 *           ({@code '0'}-{@code '9'}, {@code 'A'}-{@code 'F'}, and
 *           {@code 'a'}-{@code 'f'})&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;other&lt;/i&gt;&lt;/th&gt;
 *       &lt;td&gt;The Unicode characters that are not in the US-ASCII character set,
 *           are not control characters (according to the {@link
 *           java.lang.Character#isISOControl(char) Character.isISOControl}
 *           method), and are not space characters (according to the {@link
 *           java.lang.Character#isSpaceChar(char) Character.isSpaceChar}
 *           method)&amp;nbsp;&amp;nbsp;&lt;i&gt;(&lt;b&gt;Deviation from RFC 2396&lt;/b&gt;, which is
 *           limited to US-ASCII)&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;&lt;a name=&quot;legal-chars&quot;&gt;&lt;/a&gt; The set of all legal URI characters consists of
 * the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;reserved&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
 * characters.
 *
 *
 * &lt;h4&gt; Escaped octets, quotation, encoding, and decoding &lt;/h4&gt;
 *
 * RFC 2396 allows escaped octets to appear in the user-info, path, query, and
 * fragment components.  Escaping serves two purposes in URIs:
 *
 * &lt;ul&gt;
 *
 *   &lt;li&gt;&lt;p&gt; To &lt;i&gt;encode&lt;/i&gt; non-US-ASCII characters when a URI is required to
 *   conform strictly to RFC&amp;nbsp;2396 by not containing any &lt;i&gt;other&lt;/i&gt;
 *   characters.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; To &lt;i&gt;quote&lt;/i&gt; characters that are otherwise illegal in a
 *   component.  The user-info, path, query, and fragment components differ
 *   slightly in terms of which characters are considered legal and illegal.
 *   &lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 * These purposes are served in this class by three related operations:
 *
 * &lt;ul&gt;
 *
 *   &lt;li&gt;&lt;p&gt;&lt;a name=&quot;encode&quot;&gt;&lt;/a&gt; A character is &lt;i&gt;encoded&lt;/i&gt; by replacing it
 *   with the sequence of escaped octets that represent that character in the
 *   UTF-8 character set.  The Euro currency symbol ({@code '\u005Cu20AC'}),
 *   for example, is encoded as {@code &quot;%E2%82%AC&quot;}.  &lt;i&gt;(&lt;b&gt;Deviation from
 *   RFC&amp;nbsp;2396&lt;/b&gt;, which does not specify any particular character
 *   set.)&lt;/i&gt; &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt;&lt;a name=&quot;quote&quot;&gt;&lt;/a&gt; An illegal character is &lt;i&gt;quoted&lt;/i&gt; simply by
 *   encoding it.  The space character, for example, is quoted by replacing it
 *   with {@code &quot;%20&quot;}.  UTF-8 contains US-ASCII, hence for US-ASCII
 *   characters this transformation has exactly the effect required by
 *   RFC&amp;nbsp;2396. &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt;&lt;a name=&quot;decode&quot;&gt;&lt;/a&gt;
 *   A sequence of escaped octets is &lt;i&gt;decoded&lt;/i&gt; by
 *   replacing it with the sequence of characters that it represents in the
 *   UTF-8 character set.  UTF-8 contains US-ASCII, hence decoding has the
 *   effect of de-quoting any quoted US-ASCII characters as well as that of
 *   decoding any encoded non-US-ASCII characters.  If a &lt;a
 *   href=&quot;../nio/charset/CharsetDecoder.html#ce&quot;&gt;decoding error&lt;/a&gt; occurs
 *   when decoding the escaped octets then the erroneous octets are replaced by
 *   {@code '\u005CuFFFD'}, the Unicode replacement character.  &lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 * These operations are exposed in the constructors and methods of this class
 * as follows:
 *
 * &lt;ul&gt;
 *
 *   &lt;li&gt;&lt;p&gt; The {@linkplain #URI(java.lang.String) single-argument
 *   constructor} requires any illegal characters in its argument to be
 *   quoted and preserves any escaped octets and &lt;i&gt;other&lt;/i&gt; characters that
 *   are present.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; The {@linkplain
 *   #URI(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)
 *   multi-argument constructors} quote illegal characters as
 *   required by the components in which they appear.  The percent character
 *   ({@code '%'}) is always quoted by these constructors.  Any &lt;i&gt;other&lt;/i&gt;
 *   characters are preserved.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; The {@link #getRawUserInfo() getRawUserInfo}, {@link #getRawPath()
 *   getRawPath}, {@link #getRawQuery() getRawQuery}, {@link #getRawFragment()
 *   getRawFragment}, {@link #getRawAuthority() getRawAuthority}, and {@link
 *   #getRawSchemeSpecificPart() getRawSchemeSpecificPart} methods return the
 *   values of their corresponding components in raw form, without interpreting
 *   any escaped octets.  The strings returned by these methods may contain
 *   both escaped octets and &lt;i&gt;other&lt;/i&gt; characters, and will not contain any
 *   illegal characters.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; The {@link #getUserInfo() getUserInfo}, {@link #getPath()
 *   getPath}, {@link #getQuery() getQuery}, {@link #getFragment()
 *   getFragment}, {@link #getAuthority() getAuthority}, and {@link
 *   #getSchemeSpecificPart() getSchemeSpecificPart} methods decode any escaped
 *   octets in their corresponding components.  The strings returned by these
 *   methods may contain both &lt;i&gt;other&lt;/i&gt; characters and illegal characters,
 *   and will not contain any escaped octets.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; The {@link #toString() toString} method returns a URI string with
 *   all necessary quotation but which may contain &lt;i&gt;other&lt;/i&gt; characters.
 *   &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; The {@link #toASCIIString() toASCIIString} method returns a fully
 *   quoted and encoded URI string that does not contain any &lt;i&gt;other&lt;/i&gt;
 *   characters.  &lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 *
 * &lt;h4&gt; Identities &lt;/h4&gt;
 *
 * For any URI &lt;i&gt;u&lt;/i&gt;, it is always the case that
 *
 * &lt;blockquote&gt;
 * {@code new URI(}&lt;i&gt;u&lt;/i&gt;{@code .toString()).equals(}&lt;i&gt;u&lt;/i&gt;{@code )}&amp;nbsp;.
 * &lt;/blockquote&gt;
 *
 * For any URI &lt;i&gt;u&lt;/i&gt; that does not contain redundant syntax such as two
 * slashes before an empty authority (as in {@code file:///tmp/}&amp;nbsp;) or a
 * colon following a host name but no port (as in
 * {@code http://java.sun.com:}&amp;nbsp;), and that does not encode characters
 * except those that must be quoted, the following identities also hold:
 * &lt;pre&gt;
 *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 *             &lt;i&gt;u&lt;/i&gt;.getSchemeSpecificPart(),
 *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 * in all cases,
 * &lt;pre&gt;
 *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 *             &lt;i&gt;u&lt;/i&gt;.getUserInfo(), &lt;i&gt;u&lt;/i&gt;.getAuthority(),
 *             &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
 *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 * if &lt;i&gt;u&lt;/i&gt; is hierarchical, and
 * &lt;pre&gt;
 *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 *             &lt;i&gt;u&lt;/i&gt;.getUserInfo(), &lt;i&gt;u&lt;/i&gt;.getHost(), &lt;i&gt;u&lt;/i&gt;.getPort(),
 *             &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
 *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 * if &lt;i&gt;u&lt;/i&gt; is hierarchical and has either no authority or a server-based
 * authority.
 *
 *
 * &lt;h4&gt; URIs, URLs, and URNs &lt;/h4&gt;
 *
 * A URI is a uniform resource &lt;i&gt;identifier&lt;/i&gt; while a URL is a uniform
 * resource &lt;i&gt;locator&lt;/i&gt;.  Hence every URL is a URI, abstractly speaking, but
 * not every URI is a URL.  This is because there is another subcategory of
 * URIs, uniform resource &lt;i&gt;names&lt;/i&gt; (URNs), which name resources but do not
 * specify how to locate them.  The {@code mailto}, {@code news}, and
 * {@code isbn} URIs shown above are examples of URNs.
 *
 * &lt;p&gt; The conceptual distinction between URIs and URLs is reflected in the
 * differences between this class and the {@link URL} class.
 *
 * &lt;p&gt; An instance of this class represents a URI reference in the syntactic
 * sense defined by RFC&amp;nbsp;2396.  A URI may be either absolute or relative.
 * A URI string is parsed according to the generic syntax without regard to the
 * scheme, if any, that it specifies.  No lookup of the host, if any, is
 * performed, and no scheme-dependent stream handler is constructed.  Equality,
 * hashing, and comparison are defined strictly in terms of the character
 * content of the instance.  In other words, a URI instance is little more than
 * a structured string that supports the syntactic, scheme-independent
 * operations of comparison, normalization, resolution, and relativization.
 *
 * &lt;p&gt; An instance of the {@link URL} class, by contrast, represents the
 * syntactic components of a URL together with some of the information required
 * to access the resource that it describes.  A URL must be absolute, that is,
 * it must always specify a scheme.  A URL string is parsed according to its
 * scheme.  A stream handler is always established for a URL, and in fact it is
 * impossible to create a URL instance for a scheme for which no handler is
 * available.  Equality and hashing depend upon both the scheme and the
 * Internet address of the host, if any; comparison is not defined.  In other
 * words, a URL is a structured string that supports the syntactic operation of
 * resolution as well as the network I/O operations of looking up the host and
 * opening a connection to the specified resource.
 *
 *
 * @author Mark Reinhold
 * @since 1.4
 *
 * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2279.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2279: UTF-8, a
 * transformation format of ISO 10646&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6 Addressing
 * Architecture&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
 * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
 * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 * href=&quot;URISyntaxException.html&quot;&gt;URISyntaxException&lt;/a&gt;
 */

<span class="fc bfc" id="L464" title="All 2 branches covered.">public final class URI</span>
    implements Comparable&lt;URI&gt;, Serializable
{

    // Note: Comments containing the word &quot;ASSERT&quot; indicate places where a
    // throw of an InternalError should be replaced by an appropriate assertion
    // statement once asserts are enabled in the build.

    static final long serialVersionUID = -6052424284110960213L;


    // -- Properties and components of this instance --

    // Components of all URIs: [&lt;scheme&gt;:]&lt;scheme-specific-part&gt;[#&lt;fragment&gt;]
    private transient String scheme;            // null ==&gt; relative URI
    private transient String fragment;

    // Hierarchical URI components: [//&lt;authority&gt;]&lt;path&gt;[?&lt;query&gt;]
    private transient String authority;         // Registry or server

    // Server-based authority: [&lt;userInfo&gt;@]&lt;host&gt;[:&lt;port&gt;]
    private transient String userInfo;
    private transient String host;              // null ==&gt; registry-based
<span class="fc" id="L487">    private transient int port = -1;            // -1 ==&gt; undefined</span>

    // Remaining components of hierarchical URIs
    private transient String path;              // null ==&gt; opaque
    private transient String query;

    // The remaining fields may be computed on demand

    private volatile transient String schemeSpecificPart;
    private volatile transient int hash;        // Zero ==&gt; undefined

<span class="fc" id="L498">    private volatile transient String decodedUserInfo = null;</span>
<span class="fc" id="L499">    private volatile transient String decodedAuthority = null;</span>
<span class="fc" id="L500">    private volatile transient String decodedPath = null;</span>
<span class="fc" id="L501">    private volatile transient String decodedQuery = null;</span>
<span class="fc" id="L502">    private volatile transient String decodedFragment = null;</span>
<span class="fc" id="L503">    private volatile transient String decodedSchemeSpecificPart = null;</span>

    /**
     * The string form of this URI.
     *
     * @serial
     */
    private volatile String string;             // The only serializable field



    // -- Constructors and factories --

<span class="fc" id="L516">    private URI() { }                           // Used internally</span>

    /**
     * Constructs a URI by parsing the given string.
     *
     * &lt;p&gt; This constructor parses the given string exactly as specified by the
     * grammar in &lt;a
     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
     * Appendix&amp;nbsp;A, &lt;b&gt;&lt;i&gt;except for the following deviations:&lt;/i&gt;&lt;/b&gt; &lt;/p&gt;
     *
     * &lt;ul&gt;
     *
     *   &lt;li&gt;&lt;p&gt; An empty authority component is permitted as long as it is
     *   followed by a non-empty path, a query component, or a fragment
     *   component.  This allows the parsing of URIs such as
     *   {@code &quot;file:///foo/bar&quot;}, which seems to be the intent of
     *   RFC&amp;nbsp;2396 although the grammar does not permit it.  If the
     *   authority component is empty then the user-information, host, and port
     *   components are undefined. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Empty relative paths are permitted; this seems to be the
     *   intent of RFC&amp;nbsp;2396 although the grammar does not permit it.  The
     *   primary consequence of this deviation is that a standalone fragment
     *   such as {@code &quot;#foo&quot;} parses as a relative URI with an empty path
     *   and the given fragment, and can be usefully &lt;a
     *   href=&quot;#resolve-frag&quot;&gt;resolved&lt;/a&gt; against a base URI.
     *
     *   &lt;li&gt;&lt;p&gt; IPv4 addresses in host components are parsed rigorously, as
     *   specified by &lt;a
     *   href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;: Each
     *   element of a dotted-quad address must contain no more than three
     *   decimal digits.  Each element is further constrained to have a value
     *   no greater than 255. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt; &lt;p&gt; Hostnames in host components that comprise only a single
     *   domain label are permitted to start with an &lt;i&gt;alphanum&lt;/i&gt;
     *   character. This seems to be the intent of &lt;a
     *   href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;
     *   section&amp;nbsp;3.2.2 although the grammar does not permit it. The
     *   consequence of this deviation is that the authority component of a
     *   hierarchical URI such as {@code s://123}, will parse as a server-based
     *   authority. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; IPv6 addresses are permitted for the host component.  An IPv6
     *   address must be enclosed in square brackets ({@code '['} and
     *   {@code ']'}) as specified by &lt;a
     *   href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;.  The
     *   IPv6 address itself must parse according to &lt;a
     *   href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;.  IPv6
     *   addresses are further constrained to describe no more than sixteen
     *   bytes of address information, a constraint implicit in RFC&amp;nbsp;2373
     *   but not expressible in the grammar. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Characters in the &lt;i&gt;other&lt;/i&gt; category are permitted wherever
     *   RFC&amp;nbsp;2396 permits &lt;i&gt;escaped&lt;/i&gt; octets, that is, in the
     *   user-information, path, query, and fragment components, as well as in
     *   the authority component if the authority is registry-based.  This
     *   allows URIs to contain Unicode characters beyond those in the US-ASCII
     *   character set. &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ul&gt;
     *
     * @param  str   The string to be parsed into a URI
     *
     * @throws  NullPointerException
     *          If {@code str} is {@code null}
     *
     * @throws  URISyntaxException
     *          If the given string violates RFC&amp;nbsp;2396, as augmented
     *          by the above deviations
     */
<span class="fc" id="L587">    public URI(String str) throws URISyntaxException {</span>
<span class="fc" id="L588">        new Parser(str).parse(false);</span>
<span class="fc" id="L589">    }</span>

    /**
     * Constructs a hierarchical URI from the given components.
     *
     * &lt;p&gt; If a scheme is given then the path, if also given, must either be
     * empty or begin with a slash character ({@code '/'}).  Otherwise a
     * component of the new URI may be left undefined by passing {@code null}
     * for the corresponding parameter or, in the case of the {@code port}
     * parameter, by passing {@code -1}.
     *
     * &lt;p&gt; This constructor first builds a URI string from the given components
     * according to the rules specified in &lt;a
     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
     * section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p&gt;
     *
     * &lt;ol&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Initially, the result string is empty. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
     *   followed by a colon character ({@code ':'}).  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If user information, a host, or a port are given then the
     *   string {@code &quot;//&quot;} is appended.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If user information is given then it is appended, followed by
     *   a commercial-at character ({@code '@'}).  Any character not in the
     *   &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
     *   categories is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If a host is given then it is appended.  If the host is a
     *   literal IPv6 address but is not enclosed in square brackets
     *   ({@code '['} and {@code ']'}) then the square brackets are added.
     *   &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If a port number is given then a colon character
     *   ({@code ':'}) is appended, followed by the port number in decimal.
     *   &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If a path is given then it is appended.  Any character not in
     *   the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
     *   categories, and not equal to the slash character ({@code '/'}) or the
     *   commercial-at character ({@code '@'}), is quoted.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If a query is given then a question-mark character
     *   ({@code '?'}) is appended, followed by the query.  Any character that
     *   is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.
     *   &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
     *   ({@code '#'}) is appended, followed by the fragment.  Any character
     *   that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ol&gt;
     *
     * &lt;p&gt; The resulting URI string is then parsed as if by invoking the {@link
     * #URI(String)} constructor and then invoking the {@link
     * #parseServerAuthority()} method upon the result; this may cause a {@link
     * URISyntaxException} to be thrown.  &lt;/p&gt;
     *
     * @param   scheme    Scheme name
     * @param   userInfo  User name and authorization information
     * @param   host      Host name
     * @param   port      Port number
     * @param   path      Path
     * @param   query     Query
     * @param   fragment  Fragment
     *
     * @throws URISyntaxException
     *         If both a scheme and a path are given but the path is relative,
     *         if the URI string constructed from the given components violates
     *         RFC&amp;nbsp;2396, or if the authority component of the string is
     *         present but cannot be parsed as a server-based authority
     */
    public URI(String scheme,
               String userInfo, String host, int port,
               String path, String query, String fragment)
        throws URISyntaxException
<span class="fc" id="L668">    {</span>
<span class="fc" id="L669">        String s = toString(scheme, null,</span>
                            null, userInfo, host, port,
                            path, query, fragment);
<span class="fc" id="L672">        checkPath(s, scheme, path);</span>
<span class="fc" id="L673">        new Parser(s).parse(true);</span>
<span class="fc" id="L674">    }</span>

    /**
     * Constructs a hierarchical URI from the given components.
     *
     * &lt;p&gt; If a scheme is given then the path, if also given, must either be
     * empty or begin with a slash character ({@code '/'}).  Otherwise a
     * component of the new URI may be left undefined by passing {@code null}
     * for the corresponding parameter.
     *
     * &lt;p&gt; This constructor first builds a URI string from the given components
     * according to the rules specified in &lt;a
     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
     * section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p&gt;
     *
     * &lt;ol&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Initially, the result string is empty.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
     *   followed by a colon character ({@code ':'}).  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If an authority is given then the string {@code &quot;//&quot;} is
     *   appended, followed by the authority.  If the authority contains a
     *   literal IPv6 address then the address must be enclosed in square
     *   brackets ({@code '['} and {@code ']'}).  Any character not in the
     *   &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
     *   categories, and not equal to the commercial-at character
     *   ({@code '@'}), is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If a path is given then it is appended.  Any character not in
     *   the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
     *   categories, and not equal to the slash character ({@code '/'}) or the
     *   commercial-at character ({@code '@'}), is quoted.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If a query is given then a question-mark character
     *   ({@code '?'}) is appended, followed by the query.  Any character that
     *   is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.
     *   &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
     *   ({@code '#'}) is appended, followed by the fragment.  Any character
     *   that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ol&gt;
     *
     * &lt;p&gt; The resulting URI string is then parsed as if by invoking the {@link
     * #URI(String)} constructor and then invoking the {@link
     * #parseServerAuthority()} method upon the result; this may cause a {@link
     * URISyntaxException} to be thrown.  &lt;/p&gt;
     *
     * @param   scheme     Scheme name
     * @param   authority  Authority
     * @param   path       Path
     * @param   query      Query
     * @param   fragment   Fragment
     *
     * @throws URISyntaxException
     *         If both a scheme and a path are given but the path is relative,
     *         if the URI string constructed from the given components violates
     *         RFC&amp;nbsp;2396, or if the authority component of the string is
     *         present but cannot be parsed as a server-based authority
     */
    public URI(String scheme,
               String authority,
               String path, String query, String fragment)
        throws URISyntaxException
<span class="fc" id="L741">    {</span>
<span class="fc" id="L742">        String s = toString(scheme, null,</span>
                            authority, null, null, -1,
                            path, query, fragment);
<span class="fc" id="L745">        checkPath(s, scheme, path);</span>
<span class="fc" id="L746">        new Parser(s).parse(false);</span>
<span class="fc" id="L747">    }</span>

    /**
     * Constructs a hierarchical URI from the given components.
     *
     * &lt;p&gt; A component may be left undefined by passing {@code null}.
     *
     * &lt;p&gt; This convenience constructor works as if by invoking the
     * seven-argument constructor as follows:
     *
     * &lt;blockquote&gt;
     * {@code new} {@link #URI(String, String, String, int, String, String, String)
     * URI}{@code (scheme, null, host, -1, path, null, fragment);}
     * &lt;/blockquote&gt;
     *
     * @param   scheme    Scheme name
     * @param   host      Host name
     * @param   path      Path
     * @param   fragment  Fragment
     *
     * @throws  URISyntaxException
     *          If the URI string constructed from the given components
     *          violates RFC&amp;nbsp;2396
     */
    public URI(String scheme, String host, String path, String fragment)
        throws URISyntaxException
    {
<span class="fc" id="L774">        this(scheme, null, host, -1, path, null, fragment);</span>
<span class="fc" id="L775">    }</span>

    /**
     * Constructs a URI from the given components.
     *
     * &lt;p&gt; A component may be left undefined by passing {@code null}.
     *
     * &lt;p&gt; This constructor first builds a URI in string form using the given
     * components as follows:  &lt;/p&gt;
     *
     * &lt;ol&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Initially, the result string is empty.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
     *   followed by a colon character ({@code ':'}).  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If a scheme-specific part is given then it is appended.  Any
     *   character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt;
     *   is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
     *   ({@code '#'}) is appended to the string, followed by the fragment.
     *   Any character that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ol&gt;
     *
     * &lt;p&gt; The resulting URI string is then parsed in order to create the new
     * URI instance as if by invoking the {@link #URI(String)} constructor;
     * this may cause a {@link URISyntaxException} to be thrown.  &lt;/p&gt;
     *
     * @param   scheme    Scheme name
     * @param   ssp       Scheme-specific part
     * @param   fragment  Fragment
     *
     * @throws  URISyntaxException
     *          If the URI string constructed from the given components
     *          violates RFC&amp;nbsp;2396
     */
    public URI(String scheme, String ssp, String fragment)
        throws URISyntaxException
<span class="fc" id="L816">    {</span>
<span class="fc" id="L817">        new Parser(toString(scheme, ssp,</span>
                            null, null, null, -1,
                            null, null, fragment))
<span class="fc" id="L820">            .parse(false);</span>
<span class="fc" id="L821">    }</span>

    /**
     * Creates a URI by parsing the given string.
     *
     * &lt;p&gt; This convenience factory method works as if by invoking the {@link
     * #URI(String)} constructor; any {@link URISyntaxException} thrown by the
     * constructor is caught and wrapped in a new {@link
     * IllegalArgumentException} object, which is then thrown.
     *
     * &lt;p&gt; This method is provided for use in situations where it is known that
     * the given string is a legal URI, for example for URI constants declared
     * within in a program, and so it would be considered a programming error
     * for the string not to parse as such.  The constructors, which throw
     * {@link URISyntaxException} directly, should be used situations where a
     * URI is being constructed from user input or from some other source that
     * may be prone to errors.  &lt;/p&gt;
     *
     * @param  str   The string to be parsed into a URI
     * @return The new URI
     *
     * @throws  NullPointerException
     *          If {@code str} is {@code null}
     *
     * @throws  IllegalArgumentException
     *          If the given string violates RFC&amp;nbsp;2396
     */
    public static URI create(String str) {
        try {
<span class="fc" id="L850">            return new URI(str);</span>
<span class="nc" id="L851">        } catch (URISyntaxException x) {</span>
<span class="nc" id="L852">            throw new IllegalArgumentException(x.getMessage(), x);</span>
        }
    }


    // -- Operations --

    /**
     * Attempts to parse this URI's authority component, if defined, into
     * user-information, host, and port components.
     *
     * &lt;p&gt; If this URI's authority component has already been recognized as
     * being server-based then it will already have been parsed into
     * user-information, host, and port components.  In this case, or if this
     * URI has no authority component, this method simply returns this URI.
     *
     * &lt;p&gt; Otherwise this method attempts once more to parse the authority
     * component into user-information, host, and port components, and throws
     * an exception describing why the authority component could not be parsed
     * in that way.
     *
     * &lt;p&gt; This method is provided because the generic URI syntax specified in
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;
     * cannot always distinguish a malformed server-based authority from a
     * legitimate registry-based authority.  It must therefore treat some
     * instances of the former as instances of the latter.  The authority
     * component in the URI string {@code &quot;//foo:bar&quot;}, for example, is not a
     * legal server-based authority but it is legal as a registry-based
     * authority.
     *
     * &lt;p&gt; In many common situations, for example when working URIs that are
     * known to be either URNs or URLs, the hierarchical URIs being used will
     * always be server-based.  They therefore must either be parsed as such or
     * treated as an error.  In these cases a statement such as
     *
     * &lt;blockquote&gt;
     * {@code URI }&lt;i&gt;u&lt;/i&gt;{@code  = new URI(str).parseServerAuthority();}
     * &lt;/blockquote&gt;
     *
     * &lt;p&gt; can be used to ensure that &lt;i&gt;u&lt;/i&gt; always refers to a URI that, if
     * it has an authority component, has a server-based authority with proper
     * user-information, host, and port components.  Invoking this method also
     * ensures that if the authority could not be parsed in that way then an
     * appropriate diagnostic message can be issued based upon the exception
     * that is thrown. &lt;/p&gt;
     *
     * @return  A URI whose authority field has been parsed
     *          as a server-based authority
     *
     * @throws  URISyntaxException
     *          If the authority component of this URI is defined
     *          but cannot be parsed as a server-based authority
     *          according to RFC&amp;nbsp;2396
     */
    public URI parseServerAuthority()
        throws URISyntaxException
    {
        // We could be clever and cache the error message and index from the
        // exception thrown during the original parse, but that would require
        // either more fields or a more-obscure representation.
<span class="pc bpc" id="L912" title="1 of 4 branches missed.">        if ((host != null) || (authority == null))</span>
<span class="fc" id="L913">            return this;</span>
<span class="nc" id="L914">        defineString();</span>
<span class="nc" id="L915">        new Parser(string).parse(true);</span>
<span class="nc" id="L916">        return this;</span>
    }

    /**
     * Normalizes this URI's path.
     *
     * &lt;p&gt; If this URI is opaque, or if its path is already in normal form,
     * then this URI is returned.  Otherwise a new URI is constructed that is
     * identical to this URI except that its path is computed by normalizing
     * this URI's path in a manner consistent with &lt;a
     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
     * section&amp;nbsp;5.2, step&amp;nbsp;6, sub-steps&amp;nbsp;c through&amp;nbsp;f; that is:
     * &lt;/p&gt;
     *
     * &lt;ol&gt;
     *
     *   &lt;li&gt;&lt;p&gt; All {@code &quot;.&quot;} segments are removed. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If a {@code &quot;..&quot;} segment is preceded by a non-{@code &quot;..&quot;}
     *   segment then both of these segments are removed.  This step is
     *   repeated until it is no longer applicable. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If the path is relative, and if its first segment contains a
     *   colon character ({@code ':'}), then a {@code &quot;.&quot;} segment is
     *   prepended.  This prevents a relative URI with a path such as
     *   {@code &quot;a:b/c/d&quot;} from later being re-parsed as an opaque URI with a
     *   scheme of {@code &quot;a&quot;} and a scheme-specific part of {@code &quot;b/c/d&quot;}.
     *   &lt;b&gt;&lt;i&gt;(Deviation from RFC&amp;nbsp;2396)&lt;/i&gt;&lt;/b&gt; &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ol&gt;
     *
     * &lt;p&gt; A normalized path will begin with one or more {@code &quot;..&quot;} segments
     * if there were insufficient non-{@code &quot;..&quot;} segments preceding them to
     * allow their removal.  A normalized path will begin with a {@code &quot;.&quot;}
     * segment if one was inserted by step 3 above.  Otherwise, a normalized
     * path will not contain any {@code &quot;.&quot;} or {@code &quot;..&quot;} segments. &lt;/p&gt;
     *
     * @return  A URI equivalent to this URI,
     *          but whose path is in normal form
     */
    public URI normalize() {
<span class="fc" id="L957">        return normalize(this);</span>
    }

    /**
     * Resolves the given URI against this URI.
     *
     * &lt;p&gt; If the given URI is already absolute, or if this URI is opaque, then
     * the given URI is returned.
     *
     * &lt;p&gt;&lt;a name=&quot;resolve-frag&quot;&gt;&lt;/a&gt; If the given URI's fragment component is
     * defined, its path component is empty, and its scheme, authority, and
     * query components are undefined, then a URI with the given fragment but
     * with all other components equal to those of this URI is returned.  This
     * allows a URI representing a standalone fragment reference, such as
     * {@code &quot;#foo&quot;}, to be usefully resolved against a base URI.
     *
     * &lt;p&gt; Otherwise this method constructs a new hierarchical URI in a manner
     * consistent with &lt;a
     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
     * section&amp;nbsp;5.2; that is: &lt;/p&gt;
     *
     * &lt;ol&gt;
     *
     *   &lt;li&gt;&lt;p&gt; A new URI is constructed with this URI's scheme and the given
     *   URI's query and fragment components. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If the given URI has an authority component then the new URI's
     *   authority and path are taken from the given URI. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Otherwise the new URI's authority component is copied from
     *   this URI, and its path is computed as follows: &lt;/p&gt;
     *
     *   &lt;ol&gt;
     *
     *     &lt;li&gt;&lt;p&gt; If the given URI's path is absolute then the new URI's path
     *     is taken from the given URI. &lt;/p&gt;&lt;/li&gt;
     *
     *     &lt;li&gt;&lt;p&gt; Otherwise the given URI's path is relative, and so the new
     *     URI's path is computed by resolving the path of the given URI
     *     against the path of this URI.  This is done by concatenating all but
     *     the last segment of this URI's path, if any, with the given URI's
     *     path and then normalizing the result as if by invoking the {@link
     *     #normalize() normalize} method. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;/ol&gt;&lt;/li&gt;
     *
     * &lt;/ol&gt;
     *
     * &lt;p&gt; The result of this method is absolute if, and only if, either this
     * URI is absolute or the given URI is absolute.  &lt;/p&gt;
     *
     * @param  uri  The URI to be resolved against this URI
     * @return The resulting URI
     *
     * @throws  NullPointerException
     *          If {@code uri} is {@code null}
     */
    public URI resolve(URI uri) {
<span class="fc" id="L1015">        return resolve(this, uri);</span>
    }

    /**
     * Constructs a new URI by parsing the given string and then resolving it
     * against this URI.
     *
     * &lt;p&gt; This convenience method works as if invoking it were equivalent to
     * evaluating the expression {@link #resolve(java.net.URI)
     * resolve}{@code (URI.}{@link #create(String) create}{@code (str))}. &lt;/p&gt;
     *
     * @param  str   The string to be parsed into a URI
     * @return The resulting URI
     *
     * @throws  NullPointerException
     *          If {@code str} is {@code null}
     *
     * @throws  IllegalArgumentException
     *          If the given string violates RFC&amp;nbsp;2396
     */
    public URI resolve(String str) {
<span class="nc" id="L1036">        return resolve(URI.create(str));</span>
    }

    /**
     * Relativizes the given URI against this URI.
     *
     * &lt;p&gt; The relativization of the given URI against this URI is computed as
     * follows: &lt;/p&gt;
     *
     * &lt;ol&gt;
     *
     *   &lt;li&gt;&lt;p&gt; If either this URI or the given URI are opaque, or if the
     *   scheme and authority components of the two URIs are not identical, or
     *   if the path of this URI is not a prefix of the path of the given URI,
     *   then the given URI is returned. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Otherwise a new relative hierarchical URI is constructed with
     *   query and fragment components taken from the given URI and with a path
     *   component computed by removing this URI's path from the beginning of
     *   the given URI's path. &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ol&gt;
     *
     * @param  uri  The URI to be relativized against this URI
     * @return The resulting URI
     *
     * @throws  NullPointerException
     *          If {@code uri} is {@code null}
     */
    public URI relativize(URI uri) {
<span class="fc" id="L1066">        return relativize(this, uri);</span>
    }

    /**
     * Constructs a URL from this URI.
     *
     * &lt;p&gt; This convenience method works as if invoking it were equivalent to
     * evaluating the expression {@code new URL(this.toString())} after
     * first checking that this URI is absolute. &lt;/p&gt;
     *
     * @return  A URL constructed from this URI
     *
     * @throws  IllegalArgumentException
     *          If this URL is not absolute
     *
     * @throws  MalformedURLException
     *          If a protocol handler for the URL could not be found,
     *          or if some other error occurred while constructing the URL
     */
    public URL toURL()
        throws MalformedURLException {
<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">        if (!isAbsolute())</span>
<span class="nc" id="L1088">            throw new IllegalArgumentException(&quot;URI is not absolute&quot;);</span>
<span class="fc" id="L1089">        return new URL(toString());</span>
    }

    // -- Component access methods --

    /**
     * Returns the scheme component of this URI.
     *
     * &lt;p&gt; The scheme component of a URI, if defined, only contains characters
     * in the &lt;i&gt;alphanum&lt;/i&gt; category and in the string {@code &quot;-.+&quot;}.  A
     * scheme always starts with an &lt;i&gt;alpha&lt;/i&gt; character. &lt;p&gt;
     *
     * The scheme component of a URI cannot contain escaped octets, hence this
     * method does not perform any decoding.
     *
     * @return  The scheme component of this URI,
     *          or {@code null} if the scheme is undefined
     */
    public String getScheme() {
<span class="fc" id="L1108">        return scheme;</span>
    }

    /**
     * Tells whether or not this URI is absolute.
     *
     * &lt;p&gt; A URI is absolute if, and only if, it has a scheme component. &lt;/p&gt;
     *
     * @return  {@code true} if, and only if, this URI is absolute
     */
    public boolean isAbsolute() {
<span class="fc bfc" id="L1119" title="All 2 branches covered.">        return scheme != null;</span>
    }

    /**
     * Tells whether or not this URI is opaque.
     *
     * &lt;p&gt; A URI is opaque if, and only if, it is absolute and its
     * scheme-specific part does not begin with a slash character ('/').
     * An opaque URI has a scheme, a scheme-specific part, and possibly
     * a fragment; all other components are undefined. &lt;/p&gt;
     *
     * @return  {@code true} if, and only if, this URI is opaque
     */
    public boolean isOpaque() {
<span class="fc bfc" id="L1133" title="All 2 branches covered.">        return path == null;</span>
    }

    /**
     * Returns the raw scheme-specific part of this URI.  The scheme-specific
     * part is never undefined, though it may be empty.
     *
     * &lt;p&gt; The scheme-specific part of a URI only contains legal URI
     * characters. &lt;/p&gt;
     *
     * @return  The raw scheme-specific part of this URI
     *          (never {@code null})
     */
    public String getRawSchemeSpecificPart() {
<span class="fc" id="L1147">        defineSchemeSpecificPart();</span>
<span class="fc" id="L1148">        return schemeSpecificPart;</span>
    }

    /**
     * Returns the decoded scheme-specific part of this URI.
     *
     * &lt;p&gt; The string returned by this method is equal to that returned by the
     * {@link #getRawSchemeSpecificPart() getRawSchemeSpecificPart} method
     * except that all sequences of escaped octets are &lt;a
     * href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
     *
     * @return  The decoded scheme-specific part of this URI
     *          (never {@code null})
     */
    public String getSchemeSpecificPart() {
<span class="fc bfc" id="L1163" title="All 2 branches covered.">        if (decodedSchemeSpecificPart == null)</span>
<span class="fc" id="L1164">            decodedSchemeSpecificPart = decode(getRawSchemeSpecificPart());</span>
<span class="fc" id="L1165">        return decodedSchemeSpecificPart;</span>
    }

    /**
     * Returns the raw authority component of this URI.
     *
     * &lt;p&gt; The authority component of a URI, if defined, only contains the
     * commercial-at character ({@code '@'}) and characters in the
     * &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
     * categories.  If the authority is server-based then it is further
     * constrained to have valid user-information, host, and port
     * components. &lt;/p&gt;
     *
     * @return  The raw authority component of this URI,
     *          or {@code null} if the authority is undefined
     */
    public String getRawAuthority() {
<span class="fc" id="L1182">        return authority;</span>
    }

    /**
     * Returns the decoded authority component of this URI.
     *
     * &lt;p&gt; The string returned by this method is equal to that returned by the
     * {@link #getRawAuthority() getRawAuthority} method except that all
     * sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
     *
     * @return  The decoded authority component of this URI,
     *          or {@code null} if the authority is undefined
     */
    public String getAuthority() {
<span class="fc bfc" id="L1196" title="All 2 branches covered.">        if (decodedAuthority == null)</span>
<span class="fc" id="L1197">            decodedAuthority = decode(authority);</span>
<span class="fc" id="L1198">        return decodedAuthority;</span>
    }

    /**
     * Returns the raw user-information component of this URI.
     *
     * &lt;p&gt; The user-information component of a URI, if defined, only contains
     * characters in the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and
     * &lt;i&gt;other&lt;/i&gt; categories. &lt;/p&gt;
     *
     * @return  The raw user-information component of this URI,
     *          or {@code null} if the user information is undefined
     */
    public String getRawUserInfo() {
<span class="fc" id="L1212">        return userInfo;</span>
    }

    /**
     * Returns the decoded user-information component of this URI.
     *
     * &lt;p&gt; The string returned by this method is equal to that returned by the
     * {@link #getRawUserInfo() getRawUserInfo} method except that all
     * sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
     *
     * @return  The decoded user-information component of this URI,
     *          or {@code null} if the user information is undefined
     */
    public String getUserInfo() {
<span class="fc bfc" id="L1226" title="All 4 branches covered.">        if ((decodedUserInfo == null) &amp;&amp; (userInfo != null))</span>
<span class="fc" id="L1227">            decodedUserInfo = decode(userInfo);</span>
<span class="fc" id="L1228">        return decodedUserInfo;</span>
    }

    /**
     * Returns the host component of this URI.
     *
     * &lt;p&gt; The host component of a URI, if defined, will have one of the
     * following forms: &lt;/p&gt;
     *
     * &lt;ul&gt;
     *
     *   &lt;li&gt;&lt;p&gt; A domain name consisting of one or more &lt;i&gt;labels&lt;/i&gt;
     *   separated by period characters ({@code '.'}), optionally followed by
     *   a period character.  Each label consists of &lt;i&gt;alphanum&lt;/i&gt; characters
     *   as well as hyphen characters ({@code '-'}), though hyphens never
     *   occur as the first or last characters in a label. The rightmost
     *   label of a domain name consisting of two or more labels, begins
     *   with an &lt;i&gt;alpha&lt;/i&gt; character. &lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; A dotted-quad IPv4 address of the form
     *   &lt;i&gt;digit&lt;/i&gt;{@code +.}&lt;i&gt;digit&lt;/i&gt;{@code +.}&lt;i&gt;digit&lt;/i&gt;{@code +.}&lt;i&gt;digit&lt;/i&gt;{@code +},
     *   where no &lt;i&gt;digit&lt;/i&gt; sequence is longer than three characters and no
     *   sequence has a value larger than 255. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; An IPv6 address enclosed in square brackets ({@code '['} and
     *   {@code ']'}) and consisting of hexadecimal digits, colon characters
     *   ({@code ':'}), and possibly an embedded IPv4 address.  The full
     *   syntax of IPv6 addresses is specified in &lt;a
     *   href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6
     *   Addressing Architecture&lt;/i&gt;&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ul&gt;
     *
     * The host component of a URI cannot contain escaped octets, hence this
     * method does not perform any decoding.
     *
     * @return  The host component of this URI,
     *          or {@code null} if the host is undefined
     */
    public String getHost() {
<span class="fc" id="L1268">        return host;</span>
    }

    /**
     * Returns the port number of this URI.
     *
     * &lt;p&gt; The port component of a URI, if defined, is a non-negative
     * integer. &lt;/p&gt;
     *
     * @return  The port component of this URI,
     *          or {@code -1} if the port is undefined
     */
    public int getPort() {
<span class="fc" id="L1281">        return port;</span>
    }

    /**
     * Returns the raw path component of this URI.
     *
     * &lt;p&gt; The path component of a URI, if defined, only contains the slash
     * character ({@code '/'}), the commercial-at character ({@code '@'}),
     * and characters in the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;,
     * and &lt;i&gt;other&lt;/i&gt; categories. &lt;/p&gt;
     *
     * @return  The path component of this URI,
     *          or {@code null} if the path is undefined
     */
    public String getRawPath() {
<span class="fc" id="L1296">        return path;</span>
    }

    /**
     * Returns the decoded path component of this URI.
     *
     * &lt;p&gt; The string returned by this method is equal to that returned by the
     * {@link #getRawPath() getRawPath} method except that all sequences of
     * escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
     *
     * @return  The decoded path component of this URI,
     *          or {@code null} if the path is undefined
     */
    public String getPath() {
<span class="fc bfc" id="L1310" title="All 4 branches covered.">        if ((decodedPath == null) &amp;&amp; (path != null))</span>
<span class="fc" id="L1311">            decodedPath = decode(path);</span>
<span class="fc" id="L1312">        return decodedPath;</span>
    }

    /**
     * Returns the raw query component of this URI.
     *
     * &lt;p&gt; The query component of a URI, if defined, only contains legal URI
     * characters. &lt;/p&gt;
     *
     * @return  The raw query component of this URI,
     *          or {@code null} if the query is undefined
     */
    public String getRawQuery() {
<span class="fc" id="L1325">        return query;</span>
    }

    /**
     * Returns the decoded query component of this URI.
     *
     * &lt;p&gt; The string returned by this method is equal to that returned by the
     * {@link #getRawQuery() getRawQuery} method except that all sequences of
     * escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
     *
     * @return  The decoded query component of this URI,
     *          or {@code null} if the query is undefined
     */
    public String getQuery() {
<span class="fc bfc" id="L1339" title="All 4 branches covered.">        if ((decodedQuery == null) &amp;&amp; (query != null))</span>
<span class="fc" id="L1340">            decodedQuery = decode(query);</span>
<span class="fc" id="L1341">        return decodedQuery;</span>
    }

    /**
     * Returns the raw fragment component of this URI.
     *
     * &lt;p&gt; The fragment component of a URI, if defined, only contains legal URI
     * characters. &lt;/p&gt;
     *
     * @return  The raw fragment component of this URI,
     *          or {@code null} if the fragment is undefined
     */
    public String getRawFragment() {
<span class="fc" id="L1354">        return fragment;</span>
    }

    /**
     * Returns the decoded fragment component of this URI.
     *
     * &lt;p&gt; The string returned by this method is equal to that returned by the
     * {@link #getRawFragment() getRawFragment} method except that all
     * sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
     *
     * @return  The decoded fragment component of this URI,
     *          or {@code null} if the fragment is undefined
     */
    public String getFragment() {
<span class="fc bfc" id="L1368" title="All 4 branches covered.">        if ((decodedFragment == null) &amp;&amp; (fragment != null))</span>
<span class="fc" id="L1369">            decodedFragment = decode(fragment);</span>
<span class="fc" id="L1370">        return decodedFragment;</span>
    }


    // -- Equality, comparison, hash code, toString, and serialization --

    /**
     * Tests this URI for equality with another object.
     *
     * &lt;p&gt; If the given object is not a URI then this method immediately
     * returns {@code false}.
     *
     * &lt;p&gt; For two URIs to be considered equal requires that either both are
     * opaque or both are hierarchical.  Their schemes must either both be
     * undefined or else be equal without regard to case. Their fragments
     * must either both be undefined or else be equal.
     *
     * &lt;p&gt; For two opaque URIs to be considered equal, their scheme-specific
     * parts must be equal.
     *
     * &lt;p&gt; For two hierarchical URIs to be considered equal, their paths must
     * be equal and their queries must either both be undefined or else be
     * equal.  Their authorities must either both be undefined, or both be
     * registry-based, or both be server-based.  If their authorities are
     * defined and are registry-based, then they must be equal.  If their
     * authorities are defined and are server-based, then their hosts must be
     * equal without regard to case, their port numbers must be equal, and
     * their user-information components must be equal.
     *
     * &lt;p&gt; When testing the user-information, path, query, fragment, authority,
     * or scheme-specific parts of two URIs for equality, the raw forms rather
     * than the encoded forms of these components are compared and the
     * hexadecimal digits of escaped octets are compared without regard to
     * case.
     *
     * &lt;p&gt; This method satisfies the general contract of the {@link
     * java.lang.Object#equals(Object) Object.equals} method. &lt;/p&gt;
     *
     * @param   ob   The object to which this object is to be compared
     *
     * @return  {@code true} if, and only if, the given object is a URI that
     *          is identical to this URI
     */
    public boolean equals(Object ob) {
<span class="fc bfc" id="L1414" title="All 2 branches covered.">        if (ob == this)</span>
<span class="fc" id="L1415">            return true;</span>
<span class="pc bpc" id="L1416" title="1 of 2 branches missed.">        if (!(ob instanceof URI))</span>
<span class="nc" id="L1417">            return false;</span>
<span class="fc" id="L1418">        URI that = (URI)ob;</span>
<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">        if (this.isOpaque() != that.isOpaque()) return false;</span>
<span class="pc bpc" id="L1420" title="1 of 2 branches missed.">        if (!equalIgnoringCase(this.scheme, that.scheme)) return false;</span>
<span class="pc bpc" id="L1421" title="1 of 2 branches missed.">        if (!equal(this.fragment, that.fragment)) return false;</span>

        // Opaque
<span class="fc bfc" id="L1424" title="All 2 branches covered.">        if (this.isOpaque())</span>
<span class="fc" id="L1425">            return equal(this.schemeSpecificPart, that.schemeSpecificPart);</span>

        // Hierarchical
<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">        if (!equal(this.path, that.path)) return false;</span>
<span class="pc bpc" id="L1429" title="1 of 2 branches missed.">        if (!equal(this.query, that.query)) return false;</span>

        // Authorities
<span class="fc bfc" id="L1432" title="All 2 branches covered.">        if (this.authority == that.authority) return true;</span>
<span class="fc bfc" id="L1433" title="All 2 branches covered.">        if (this.host != null) {</span>
            // Server-based
<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">            if (!equal(this.userInfo, that.userInfo)) return false;</span>
<span class="pc bpc" id="L1436" title="1 of 2 branches missed.">            if (!equalIgnoringCase(this.host, that.host)) return false;</span>
<span class="pc bpc" id="L1437" title="1 of 2 branches missed.">            if (this.port != that.port) return false;</span>
<span class="pc bpc" id="L1438" title="1 of 2 branches missed.">        } else if (this.authority != null) {</span>
            // Registry-based
<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">            if (!equal(this.authority, that.authority)) return false;</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">        } else if (this.authority != that.authority) {</span>
<span class="nc" id="L1442">            return false;</span>
        }

<span class="fc" id="L1445">        return true;</span>
    }

    /**
     * Returns a hash-code value for this URI.  The hash code is based upon all
     * of the URI's components, and satisfies the general contract of the
     * {@link java.lang.Object#hashCode() Object.hashCode} method.
     *
     * @return  A hash-code value for this URI
     */
    public int hashCode() {
<span class="fc bfc" id="L1456" title="All 2 branches covered.">        if (hash != 0)</span>
<span class="fc" id="L1457">            return hash;</span>
<span class="fc" id="L1458">        int h = hashIgnoringCase(0, scheme);</span>
<span class="fc" id="L1459">        h = hash(h, fragment);</span>
<span class="pc bpc" id="L1460" title="1 of 2 branches missed.">        if (isOpaque()) {</span>
<span class="nc" id="L1461">            h = hash(h, schemeSpecificPart);</span>
        } else {
<span class="fc" id="L1463">            h = hash(h, path);</span>
<span class="fc" id="L1464">            h = hash(h, query);</span>
<span class="pc bpc" id="L1465" title="1 of 2 branches missed.">            if (host != null) {</span>
<span class="fc" id="L1466">                h = hash(h, userInfo);</span>
<span class="fc" id="L1467">                h = hashIgnoringCase(h, host);</span>
<span class="fc" id="L1468">                h += 1949 * port;</span>
            } else {
<span class="nc" id="L1470">                h = hash(h, authority);</span>
            }
        }
<span class="fc" id="L1473">        hash = h;</span>
<span class="fc" id="L1474">        return h;</span>
    }

    /**
     * Compares this URI to another object, which must be a URI.
     *
     * &lt;p&gt; When comparing corresponding components of two URIs, if one
     * component is undefined but the other is defined then the first is
     * considered to be less than the second.  Unless otherwise noted, string
     * components are ordered according to their natural, case-sensitive
     * ordering as defined by the {@link java.lang.String#compareTo(Object)
     * String.compareTo} method.  String components that are subject to
     * encoding are compared by comparing their raw forms rather than their
     * encoded forms.
     *
     * &lt;p&gt; The ordering of URIs is defined as follows: &lt;/p&gt;
     *
     * &lt;ul&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Two URIs with different schemes are ordered according the
     *   ordering of their schemes, without regard to case. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; A hierarchical URI is considered to be less than an opaque URI
     *   with an identical scheme. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes are ordered according
     *   to the ordering of their scheme-specific parts. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes and scheme-specific
     *   parts are ordered according to the ordering of their
     *   fragments. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Two hierarchical URIs with identical schemes are ordered
     *   according to the ordering of their authority components: &lt;/p&gt;
     *
     *   &lt;ul&gt;
     *
     *     &lt;li&gt;&lt;p&gt; If both authority components are server-based then the URIs
     *     are ordered according to their user-information components; if these
     *     components are identical then the URIs are ordered according to the
     *     ordering of their hosts, without regard to case; if the hosts are
     *     identical then the URIs are ordered according to the ordering of
     *     their ports. &lt;/p&gt;&lt;/li&gt;
     *
     *     &lt;li&gt;&lt;p&gt; If one or both authority components are registry-based then
     *     the URIs are ordered according to the ordering of their authority
     *     components. &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;/ul&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Finally, two hierarchical URIs with identical schemes and
     *   authority components are ordered according to the ordering of their
     *   paths; if their paths are identical then they are ordered according to
     *   the ordering of their queries; if the queries are identical then they
     *   are ordered according to the order of their fragments. &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt; This method satisfies the general contract of the {@link
     * java.lang.Comparable#compareTo(Object) Comparable.compareTo}
     * method. &lt;/p&gt;
     *
     * @param   that
     *          The object to which this URI is to be compared
     *
     * @return  A negative integer, zero, or a positive integer as this URI is
     *          less than, equal to, or greater than the given URI
     *
     * @throws  ClassCastException
     *          If the given object is not a URI
     */
    public int compareTo(URI that) {
        int c;

<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">        if ((c = compareIgnoringCase(this.scheme, that.scheme)) != 0)</span>
<span class="nc" id="L1549">            return c;</span>

<span class="pc bpc" id="L1551" title="1 of 2 branches missed.">        if (this.isOpaque()) {</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">            if (that.isOpaque()) {</span>
                // Both opaque
<span class="nc bnc" id="L1554" title="All 2 branches missed.">                if ((c = compare(this.schemeSpecificPart,</span>
                                 that.schemeSpecificPart)) != 0)
<span class="nc" id="L1556">                    return c;</span>
<span class="nc" id="L1557">                return compare(this.fragment, that.fragment);</span>
            }
<span class="nc" id="L1559">            return +1;                  // Opaque &gt; hierarchical</span>
<span class="pc bpc" id="L1560" title="1 of 2 branches missed.">        } else if (that.isOpaque()) {</span>
<span class="nc" id="L1561">            return -1;                  // Hierarchical &lt; opaque</span>
        }

        // Hierarchical
<span class="pc bpc" id="L1565" title="2 of 4 branches missed.">        if ((this.host != null) &amp;&amp; (that.host != null)) {</span>
            // Both server-based
<span class="pc bpc" id="L1567" title="1 of 2 branches missed.">            if ((c = compare(this.userInfo, that.userInfo)) != 0)</span>
<span class="nc" id="L1568">                return c;</span>
<span class="fc bfc" id="L1569" title="All 2 branches covered.">            if ((c = compareIgnoringCase(this.host, that.host)) != 0)</span>
<span class="fc" id="L1570">                return c;</span>
<span class="pc bpc" id="L1571" title="1 of 2 branches missed.">            if ((c = this.port - that.port) != 0)</span>
<span class="nc" id="L1572">                return c;</span>
        } else {
            // If one or both authorities are registry-based then we simply
            // compare them in the usual, case-sensitive way.  If one is
            // registry-based and one is server-based then the strings are
            // guaranteed to be unequal, hence the comparison will never return
            // zero and the compareTo and equals methods will remain
            // consistent.
<span class="nc bnc" id="L1580" title="All 2 branches missed.">            if ((c = compare(this.authority, that.authority)) != 0) return c;</span>
        }

<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">        if ((c = compare(this.path, that.path)) != 0) return c;</span>
<span class="pc bpc" id="L1584" title="1 of 2 branches missed.">        if ((c = compare(this.query, that.query)) != 0) return c;</span>
<span class="fc" id="L1585">        return compare(this.fragment, that.fragment);</span>
    }

    /**
     * Returns the content of this URI as a string.
     *
     * &lt;p&gt; If this URI was created by invoking one of the constructors in this
     * class then a string equivalent to the original input string, or to the
     * string computed from the originally-given components, as appropriate, is
     * returned.  Otherwise this URI was created by normalization, resolution,
     * or relativization, and so a string is constructed from this URI's
     * components according to the rules specified in &lt;a
     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
     * section&amp;nbsp;5.2, step&amp;nbsp;7. &lt;/p&gt;
     *
     * @return  The string form of this URI
     */
    public String toString() {
<span class="fc" id="L1603">        defineString();</span>
<span class="fc" id="L1604">        return string;</span>
    }

    /**
     * Returns the content of this URI as a US-ASCII string.
     *
     * &lt;p&gt; If this URI does not contain any characters in the &lt;i&gt;other&lt;/i&gt;
     * category then an invocation of this method will return the same value as
     * an invocation of the {@link #toString() toString} method.  Otherwise
     * this method works as if by invoking that method and then &lt;a
     * href=&quot;#encode&quot;&gt;encoding&lt;/a&gt; the result.  &lt;/p&gt;
     *
     * @return  The string form of this URI, encoded as needed
     *          so that it only contains characters in the US-ASCII
     *          charset
     */
    public String toASCIIString() {
<span class="fc" id="L1621">        defineString();</span>
<span class="fc" id="L1622">        return encode(string);</span>
    }


    // -- Serialization support --

    /**
     * Saves the content of this URI to the given serial stream.
     *
     * &lt;p&gt; The only serializable field of a URI instance is its {@code string}
     * field.  That field is given a value, if it does not have one already,
     * and then the {@link java.io.ObjectOutputStream#defaultWriteObject()}
     * method of the given object-output stream is invoked. &lt;/p&gt;
     *
     * @param  os  The object-output stream to which this object
     *             is to be written
     */
    private void writeObject(ObjectOutputStream os)
        throws IOException
    {
<span class="nc" id="L1642">        defineString();</span>
<span class="nc" id="L1643">        os.defaultWriteObject();        // Writes the string field only</span>
<span class="nc" id="L1644">    }</span>

    /**
     * Reconstitutes a URI from the given serial stream.
     *
     * &lt;p&gt; The {@link java.io.ObjectInputStream#defaultReadObject()} method is
     * invoked to read the value of the {@code string} field.  The result is
     * then parsed in the usual way.
     *
     * @param  is  The object-input stream from which this object
     *             is being read
     */
    private void readObject(ObjectInputStream is)
        throws ClassNotFoundException, IOException
    {
<span class="nc" id="L1659">        port = -1;                      // Argh</span>
<span class="nc" id="L1660">        is.defaultReadObject();</span>
        try {
<span class="nc" id="L1662">            new Parser(string).parse(false);</span>
<span class="nc" id="L1663">        } catch (URISyntaxException x) {</span>
<span class="nc" id="L1664">            IOException y = new InvalidObjectException(&quot;Invalid URI&quot;);</span>
<span class="nc" id="L1665">            y.initCause(x);</span>
<span class="nc" id="L1666">            throw y;</span>
<span class="nc" id="L1667">        }</span>
<span class="nc" id="L1668">    }</span>


    // -- End of public methods --


    // -- Utility methods for string-field comparison and hashing --

    // These methods return appropriate values for null string arguments,
    // thereby simplifying the equals, hashCode, and compareTo methods.
    //
    // The case-ignoring methods should only be applied to strings whose
    // characters are all known to be US-ASCII.  Because of this restriction,
    // these methods are faster than the similar methods in the String class.

    // US-ASCII only
    private static int toLower(char c) {
<span class="fc bfc" id="L1685" title="All 4 branches covered.">        if ((c &gt;= 'A') &amp;&amp; (c &lt;= 'Z'))</span>
<span class="fc" id="L1686">            return c + ('a' - 'A');</span>
<span class="fc" id="L1687">        return c;</span>
    }

    // US-ASCII only
    private static int toUpper(char c) {
<span class="nc bnc" id="L1692" title="All 4 branches missed.">        if ((c &gt;= 'a') &amp;&amp; (c &lt;= 'z'))</span>
<span class="nc" id="L1693">            return c - ('a' - 'A');</span>
<span class="nc" id="L1694">        return c;</span>
    }

    private static boolean equal(String s, String t) {
<span class="fc bfc" id="L1698" title="All 2 branches covered.">        if (s == t) return true;</span>
<span class="pc bpc" id="L1699" title="2 of 4 branches missed.">        if ((s != null) &amp;&amp; (t != null)) {</span>
<span class="pc bpc" id="L1700" title="1 of 2 branches missed.">            if (s.length() != t.length())</span>
<span class="nc" id="L1701">                return false;</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">            if (s.indexOf('%') &lt; 0)</span>
<span class="fc" id="L1703">                return s.equals(t);</span>
<span class="fc" id="L1704">            int n = s.length();</span>
<span class="fc bfc" id="L1705" title="All 2 branches covered.">            for (int i = 0; i &lt; n;) {</span>
<span class="fc" id="L1706">                char c = s.charAt(i);</span>
<span class="fc" id="L1707">                char d = t.charAt(i);</span>
<span class="fc bfc" id="L1708" title="All 2 branches covered.">                if (c != '%') {</span>
<span class="pc bpc" id="L1709" title="1 of 2 branches missed.">                    if (c != d)</span>
<span class="nc" id="L1710">                        return false;</span>
<span class="fc" id="L1711">                    i++;</span>
<span class="fc" id="L1712">                    continue;</span>
                }
<span class="pc bpc" id="L1714" title="1 of 2 branches missed.">                if (d != '%')</span>
<span class="nc" id="L1715">                    return false;</span>
<span class="fc" id="L1716">                i++;</span>
<span class="pc bpc" id="L1717" title="1 of 2 branches missed.">                if (toLower(s.charAt(i)) != toLower(t.charAt(i)))</span>
<span class="nc" id="L1718">                    return false;</span>
<span class="fc" id="L1719">                i++;</span>
<span class="pc bpc" id="L1720" title="1 of 2 branches missed.">                if (toLower(s.charAt(i)) != toLower(t.charAt(i)))</span>
<span class="nc" id="L1721">                    return false;</span>
<span class="fc" id="L1722">                i++;</span>
<span class="fc" id="L1723">            }</span>
<span class="fc" id="L1724">            return true;</span>
        }
<span class="nc" id="L1726">        return false;</span>
    }

    // US-ASCII only
    private static boolean equalIgnoringCase(String s, String t) {
<span class="fc bfc" id="L1731" title="All 2 branches covered.">        if (s == t) return true;</span>
<span class="pc bpc" id="L1732" title="2 of 4 branches missed.">        if ((s != null) &amp;&amp; (t != null)) {</span>
<span class="fc" id="L1733">            int n = s.length();</span>
<span class="pc bpc" id="L1734" title="1 of 2 branches missed.">            if (t.length() != n)</span>
<span class="nc" id="L1735">                return false;</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L1737" title="1 of 2 branches missed.">                if (toLower(s.charAt(i)) != toLower(t.charAt(i)))</span>
<span class="nc" id="L1738">                    return false;</span>
            }
<span class="fc" id="L1740">            return true;</span>
        }
<span class="nc" id="L1742">        return false;</span>
    }

    private static int hash(int hash, String s) {
<span class="fc bfc" id="L1746" title="All 2 branches covered.">        if (s == null) return hash;</span>
<span class="pc bpc" id="L1747" title="1 of 2 branches missed.">        return s.indexOf('%') &lt; 0 ? hash * 127 + s.hashCode()</span>
<span class="pc" id="L1748">                                  : normalizedHash(hash, s);</span>
    }


    private static int normalizedHash(int hash, String s) {
<span class="nc" id="L1753">        int h = 0;</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">        for (int index = 0; index &lt; s.length(); index++) {</span>
<span class="nc" id="L1755">            char ch = s.charAt(index);</span>
<span class="nc" id="L1756">            h = 31 * h + ch;</span>
<span class="nc bnc" id="L1757" title="All 2 branches missed.">            if (ch == '%') {</span>
                /*
                 * Process the next two encoded characters
                 */
<span class="nc bnc" id="L1761" title="All 2 branches missed.">                for (int i = index + 1; i &lt; index + 3; i++)</span>
<span class="nc" id="L1762">                    h = 31 * h + toUpper(s.charAt(i));</span>
<span class="nc" id="L1763">                index += 2;</span>
            }
        }
<span class="nc" id="L1766">        return hash * 127 + h;</span>
    }

    // US-ASCII only
    private static int hashIgnoringCase(int hash, String s) {
<span class="fc bfc" id="L1771" title="All 2 branches covered.">        if (s == null) return hash;</span>
<span class="fc" id="L1772">        int h = hash;</span>
<span class="fc" id="L1773">        int n = s.length();</span>
<span class="fc bfc" id="L1774" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++)</span>
<span class="fc" id="L1775">            h = 31 * h + toLower(s.charAt(i));</span>
<span class="fc" id="L1776">        return h;</span>
    }

    private static int compare(String s, String t) {
<span class="fc bfc" id="L1780" title="All 2 branches covered.">        if (s == t) return 0;</span>
<span class="pc bpc" id="L1781" title="1 of 2 branches missed.">        if (s != null) {</span>
<span class="pc bpc" id="L1782" title="1 of 2 branches missed.">            if (t != null)</span>
<span class="fc" id="L1783">                return s.compareTo(t);</span>
            else
<span class="nc" id="L1785">                return +1;</span>
        } else {
<span class="nc" id="L1787">            return -1;</span>
        }
    }

    // US-ASCII only
    private static int compareIgnoringCase(String s, String t) {
<span class="fc bfc" id="L1793" title="All 2 branches covered.">        if (s == t) return 0;</span>
<span class="pc bpc" id="L1794" title="1 of 2 branches missed.">        if (s != null) {</span>
<span class="pc bpc" id="L1795" title="1 of 2 branches missed.">            if (t != null) {</span>
<span class="fc" id="L1796">                int sn = s.length();</span>
<span class="fc" id="L1797">                int tn = t.length();</span>
<span class="fc bfc" id="L1798" title="All 2 branches covered.">                int n = sn &lt; tn ? sn : tn;</span>
<span class="fc bfc" id="L1799" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1800">                    int c = toLower(s.charAt(i)) - toLower(t.charAt(i));</span>
<span class="fc bfc" id="L1801" title="All 2 branches covered.">                    if (c != 0)</span>
<span class="fc" id="L1802">                        return c;</span>
                }
<span class="fc" id="L1804">                return sn - tn;</span>
            }
<span class="nc" id="L1806">            return +1;</span>
        } else {
<span class="nc" id="L1808">            return -1;</span>
        }
    }


    // -- String construction --

    // If a scheme is given then the path, if given, must be absolute
    //
    private static void checkPath(String s, String scheme, String path)
        throws URISyntaxException
    {
<span class="fc bfc" id="L1820" title="All 2 branches covered.">        if (scheme != null) {</span>
<span class="fc bfc" id="L1821" title="All 2 branches covered.">            if ((path != null)</span>
<span class="fc bfc" id="L1822" title="All 4 branches covered.">                &amp;&amp; ((path.length() &gt; 0) &amp;&amp; (path.charAt(0) != '/')))</span>
<span class="fc" id="L1823">                throw new URISyntaxException(s,</span>
                                             &quot;Relative path in absolute URI&quot;);
        }
<span class="fc" id="L1826">    }</span>

    private void appendAuthority(StringBuffer sb,
                                 String authority,
                                 String userInfo,
                                 String host,
                                 int port)
    {
<span class="fc bfc" id="L1834" title="All 2 branches covered.">        if (host != null) {</span>
<span class="fc" id="L1835">            sb.append(&quot;//&quot;);</span>
<span class="fc bfc" id="L1836" title="All 2 branches covered.">            if (userInfo != null) {</span>
<span class="fc" id="L1837">                sb.append(quote(userInfo, L_USERINFO, H_USERINFO));</span>
<span class="fc" id="L1838">                sb.append('@');</span>
            }
<span class="fc bfc" id="L1840" title="All 2 branches covered.">            boolean needBrackets = ((host.indexOf(':') &gt;= 0)</span>
<span class="fc bfc" id="L1841" title="All 2 branches covered.">                                    &amp;&amp; !host.startsWith(&quot;[&quot;)</span>
<span class="pc bpc" id="L1842" title="1 of 2 branches missed.">                                    &amp;&amp; !host.endsWith(&quot;]&quot;));</span>
<span class="fc bfc" id="L1843" title="All 2 branches covered.">            if (needBrackets) sb.append('[');</span>
<span class="fc" id="L1844">            sb.append(host);</span>
<span class="fc bfc" id="L1845" title="All 2 branches covered.">            if (needBrackets) sb.append(']');</span>
<span class="fc bfc" id="L1846" title="All 2 branches covered.">            if (port != -1) {</span>
<span class="fc" id="L1847">                sb.append(':');</span>
<span class="fc" id="L1848">                sb.append(port);</span>
            }
<span class="fc bfc" id="L1850" title="All 2 branches covered.">        } else if (authority != null) {</span>
<span class="fc" id="L1851">            sb.append(&quot;//&quot;);</span>
<span class="fc bfc" id="L1852" title="All 2 branches covered.">            if (authority.startsWith(&quot;[&quot;)) {</span>
                // authority should (but may not) contain an embedded IPv6 address
<span class="fc" id="L1854">                int end = authority.indexOf(&quot;]&quot;);</span>
<span class="fc" id="L1855">                String doquote = authority, dontquote = &quot;&quot;;</span>
<span class="fc bfc" id="L1856" title="All 4 branches covered.">                if (end != -1 &amp;&amp; authority.indexOf(&quot;:&quot;) != -1) {</span>
                    // the authority contains an IPv6 address
<span class="pc bpc" id="L1858" title="1 of 2 branches missed.">                    if (end == authority.length()) {</span>
<span class="nc" id="L1859">                        dontquote = authority;</span>
<span class="nc" id="L1860">                        doquote = &quot;&quot;;</span>
                    } else {
<span class="fc" id="L1862">                        dontquote = authority.substring(0 , end + 1);</span>
<span class="fc" id="L1863">                        doquote = authority.substring(end + 1);</span>
                    }
                }
<span class="fc" id="L1866">                sb.append(dontquote);</span>
<span class="fc" id="L1867">                sb.append(quote(doquote,</span>
                            L_REG_NAME | L_SERVER,
                            H_REG_NAME | H_SERVER));
<span class="fc" id="L1870">            } else {</span>
<span class="fc" id="L1871">                sb.append(quote(authority,</span>
                            L_REG_NAME | L_SERVER,
                            H_REG_NAME | H_SERVER));
            }
        }
<span class="fc" id="L1876">    }</span>

    private void appendSchemeSpecificPart(StringBuffer sb,
                                          String opaquePart,
                                          String authority,
                                          String userInfo,
                                          String host,
                                          int port,
                                          String path,
                                          String query)
    {
<span class="fc bfc" id="L1887" title="All 2 branches covered.">        if (opaquePart != null) {</span>
            /* check if SSP begins with an IPv6 address
             * because we must not quote a literal IPv6 address
             */
<span class="fc bfc" id="L1891" title="All 2 branches covered.">            if (opaquePart.startsWith(&quot;//[&quot;)) {</span>
<span class="fc" id="L1892">                int end =  opaquePart.indexOf(&quot;]&quot;);</span>
<span class="pc bpc" id="L1893" title="2 of 4 branches missed.">                if (end != -1 &amp;&amp; opaquePart.indexOf(&quot;:&quot;)!=-1) {</span>
                    String doquote, dontquote;
<span class="pc bpc" id="L1895" title="1 of 2 branches missed.">                    if (end == opaquePart.length()) {</span>
<span class="nc" id="L1896">                        dontquote = opaquePart;</span>
<span class="nc" id="L1897">                        doquote = &quot;&quot;;</span>
                    } else {
<span class="fc" id="L1899">                        dontquote = opaquePart.substring(0,end+1);</span>
<span class="fc" id="L1900">                        doquote = opaquePart.substring(end+1);</span>
                    }
<span class="fc" id="L1902">                    sb.append (dontquote);</span>
<span class="fc" id="L1903">                    sb.append(quote(doquote, L_URIC, H_URIC));</span>
                }
<span class="fc" id="L1905">            } else {</span>
<span class="fc" id="L1906">                sb.append(quote(opaquePart, L_URIC, H_URIC));</span>
            }
        } else {
<span class="fc" id="L1909">            appendAuthority(sb, authority, userInfo, host, port);</span>
<span class="fc bfc" id="L1910" title="All 2 branches covered.">            if (path != null)</span>
<span class="fc" id="L1911">                sb.append(quote(path, L_PATH, H_PATH));</span>
<span class="fc bfc" id="L1912" title="All 2 branches covered.">            if (query != null) {</span>
<span class="fc" id="L1913">                sb.append('?');</span>
<span class="fc" id="L1914">                sb.append(quote(query, L_URIC, H_URIC));</span>
            }
        }
<span class="fc" id="L1917">    }</span>

    private void appendFragment(StringBuffer sb, String fragment) {
<span class="fc bfc" id="L1920" title="All 2 branches covered.">        if (fragment != null) {</span>
<span class="fc" id="L1921">            sb.append('#');</span>
<span class="fc" id="L1922">            sb.append(quote(fragment, L_URIC, H_URIC));</span>
        }
<span class="fc" id="L1924">    }</span>

    private String toString(String scheme,
                            String opaquePart,
                            String authority,
                            String userInfo,
                            String host,
                            int port,
                            String path,
                            String query,
                            String fragment)
    {
<span class="fc" id="L1936">        StringBuffer sb = new StringBuffer();</span>
<span class="fc bfc" id="L1937" title="All 2 branches covered.">        if (scheme != null) {</span>
<span class="fc" id="L1938">            sb.append(scheme);</span>
<span class="fc" id="L1939">            sb.append(':');</span>
        }
<span class="fc" id="L1941">        appendSchemeSpecificPart(sb, opaquePart,</span>
                                 authority, userInfo, host, port,
                                 path, query);
<span class="fc" id="L1944">        appendFragment(sb, fragment);</span>
<span class="fc" id="L1945">        return sb.toString();</span>
    }

    private void defineSchemeSpecificPart() {
<span class="fc bfc" id="L1949" title="All 2 branches covered.">        if (schemeSpecificPart != null) return;</span>
<span class="fc" id="L1950">        StringBuffer sb = new StringBuffer();</span>
<span class="fc" id="L1951">        appendSchemeSpecificPart(sb, null, getAuthority(), getUserInfo(),</span>
<span class="fc" id="L1952">                                 host, port, getPath(), getQuery());</span>
<span class="pc bpc" id="L1953" title="1 of 2 branches missed.">        if (sb.length() == 0) return;</span>
<span class="fc" id="L1954">        schemeSpecificPart = sb.toString();</span>
<span class="fc" id="L1955">    }</span>

    private void defineString() {
<span class="fc bfc" id="L1958" title="All 2 branches covered.">        if (string != null) return;</span>

<span class="fc" id="L1960">        StringBuffer sb = new StringBuffer();</span>
<span class="fc bfc" id="L1961" title="All 2 branches covered.">        if (scheme != null) {</span>
<span class="fc" id="L1962">            sb.append(scheme);</span>
<span class="fc" id="L1963">            sb.append(':');</span>
        }
<span class="pc bpc" id="L1965" title="1 of 2 branches missed.">        if (isOpaque()) {</span>
<span class="nc" id="L1966">            sb.append(schemeSpecificPart);</span>
        } else {
<span class="fc bfc" id="L1968" title="All 2 branches covered.">            if (host != null) {</span>
<span class="fc" id="L1969">                sb.append(&quot;//&quot;);</span>
<span class="pc bpc" id="L1970" title="1 of 2 branches missed.">                if (userInfo != null) {</span>
<span class="nc" id="L1971">                    sb.append(userInfo);</span>
<span class="nc" id="L1972">                    sb.append('@');</span>
                }
<span class="pc bpc" id="L1974" title="1 of 2 branches missed.">                boolean needBrackets = ((host.indexOf(':') &gt;= 0)</span>
<span class="nc bnc" id="L1975" title="All 2 branches missed.">                                    &amp;&amp; !host.startsWith(&quot;[&quot;)</span>
<span class="pc bnc" id="L1976" title="All 2 branches missed.">                                    &amp;&amp; !host.endsWith(&quot;]&quot;));</span>
<span class="pc bpc" id="L1977" title="1 of 2 branches missed.">                if (needBrackets) sb.append('[');</span>
<span class="fc" id="L1978">                sb.append(host);</span>
<span class="pc bpc" id="L1979" title="1 of 2 branches missed.">                if (needBrackets) sb.append(']');</span>
<span class="pc bpc" id="L1980" title="1 of 2 branches missed.">                if (port != -1) {</span>
<span class="nc" id="L1981">                    sb.append(':');</span>
<span class="nc" id="L1982">                    sb.append(port);</span>
                }
<span class="pc bpc" id="L1984" title="1 of 2 branches missed.">            } else if (authority != null) {</span>
<span class="nc" id="L1985">                sb.append(&quot;//&quot;);</span>
<span class="nc" id="L1986">                sb.append(authority);</span>
            }
<span class="pc bpc" id="L1988" title="1 of 2 branches missed.">            if (path != null)</span>
<span class="fc" id="L1989">                sb.append(path);</span>
<span class="fc bfc" id="L1990" title="All 2 branches covered.">            if (query != null) {</span>
<span class="fc" id="L1991">                sb.append('?');</span>
<span class="fc" id="L1992">                sb.append(query);</span>
            }
        }
<span class="fc bfc" id="L1995" title="All 2 branches covered.">        if (fragment != null) {</span>
<span class="fc" id="L1996">            sb.append('#');</span>
<span class="fc" id="L1997">            sb.append(fragment);</span>
        }
<span class="fc" id="L1999">        string = sb.toString();</span>
<span class="fc" id="L2000">    }</span>


    // -- Normalization, resolution, and relativization --

    // RFC2396 5.2 (6)
    private static String resolvePath(String base, String child,
                                      boolean absolute)
    {
<span class="fc" id="L2009">        int i = base.lastIndexOf('/');</span>
<span class="fc" id="L2010">        int cn = child.length();</span>
<span class="fc" id="L2011">        String path = &quot;&quot;;</span>

<span class="fc bfc" id="L2013" title="All 2 branches covered.">        if (cn == 0) {</span>
            // 5.2 (6a)
<span class="pc bpc" id="L2015" title="1 of 2 branches missed.">            if (i &gt;= 0)</span>
<span class="fc" id="L2016">                path = base.substring(0, i + 1);</span>
        } else {
<span class="fc" id="L2018">            StringBuffer sb = new StringBuffer(base.length() + cn);</span>
            // 5.2 (6a)
<span class="pc bpc" id="L2020" title="1 of 2 branches missed.">            if (i &gt;= 0)</span>
<span class="fc" id="L2021">                sb.append(base.substring(0, i + 1));</span>
            // 5.2 (6b)
<span class="fc" id="L2023">            sb.append(child);</span>
<span class="fc" id="L2024">            path = sb.toString();</span>
        }

        // 5.2 (6c-f)
<span class="fc" id="L2028">        String np = normalize(path);</span>

        // 5.2 (6g): If the result is absolute but the path begins with &quot;../&quot;,
        // then we simply leave the path as-is

<span class="fc" id="L2033">        return np;</span>
    }

    // RFC2396 5.2
    private static URI resolve(URI base, URI child) {
        // check if child if opaque first so that NPE is thrown
        // if child is null.
<span class="pc bpc" id="L2040" title="1 of 4 branches missed.">        if (child.isOpaque() || base.isOpaque())</span>
<span class="fc" id="L2041">            return child;</span>

        // 5.2 (2): Reference to current document (lone fragment)
<span class="pc bpc" id="L2044" title="1 of 4 branches missed.">        if ((child.scheme == null) &amp;&amp; (child.authority == null)</span>
<span class="pc bpc" id="L2045" title="1 of 6 branches missed.">            &amp;&amp; child.path.equals(&quot;&quot;) &amp;&amp; (child.fragment != null)</span>
            &amp;&amp; (child.query == null)) {
<span class="pc bpc" id="L2047" title="1 of 2 branches missed.">            if ((base.fragment != null)</span>
<span class="nc bnc" id="L2048" title="All 2 branches missed.">                &amp;&amp; child.fragment.equals(base.fragment)) {</span>
<span class="nc" id="L2049">                return base;</span>
            }
<span class="fc" id="L2051">            URI ru = new URI();</span>
<span class="fc" id="L2052">            ru.scheme = base.scheme;</span>
<span class="fc" id="L2053">            ru.authority = base.authority;</span>
<span class="fc" id="L2054">            ru.userInfo = base.userInfo;</span>
<span class="fc" id="L2055">            ru.host = base.host;</span>
<span class="fc" id="L2056">            ru.port = base.port;</span>
<span class="fc" id="L2057">            ru.path = base.path;</span>
<span class="fc" id="L2058">            ru.fragment = child.fragment;</span>
<span class="fc" id="L2059">            ru.query = base.query;</span>
<span class="fc" id="L2060">            return ru;</span>
        }

        // 5.2 (3): Child is absolute
<span class="pc bpc" id="L2064" title="1 of 2 branches missed.">        if (child.scheme != null)</span>
<span class="nc" id="L2065">            return child;</span>

<span class="fc" id="L2067">        URI ru = new URI();             // Resolved URI</span>
<span class="fc" id="L2068">        ru.scheme = base.scheme;</span>
<span class="fc" id="L2069">        ru.query = child.query;</span>
<span class="fc" id="L2070">        ru.fragment = child.fragment;</span>

        // 5.2 (4): Authority
<span class="fc bfc" id="L2073" title="All 2 branches covered.">        if (child.authority == null) {</span>
<span class="fc" id="L2074">            ru.authority = base.authority;</span>
<span class="fc" id="L2075">            ru.host = base.host;</span>
<span class="fc" id="L2076">            ru.userInfo = base.userInfo;</span>
<span class="fc" id="L2077">            ru.port = base.port;</span>

<span class="pc bpc" id="L2079" title="1 of 2 branches missed.">            String cp = (child.path == null) ? &quot;&quot; : child.path;</span>
<span class="fc bfc" id="L2080" title="All 4 branches covered.">            if ((cp.length() &gt; 0) &amp;&amp; (cp.charAt(0) == '/')) {</span>
                // 5.2 (5): Child path is absolute
<span class="fc" id="L2082">                ru.path = child.path;</span>
            } else {
                // 5.2 (6): Resolve relative path
<span class="fc" id="L2085">                ru.path = resolvePath(base.path, cp, base.isAbsolute());</span>
            }
<span class="fc" id="L2087">        } else {</span>
<span class="fc" id="L2088">            ru.authority = child.authority;</span>
<span class="fc" id="L2089">            ru.host = child.host;</span>
<span class="fc" id="L2090">            ru.userInfo = child.userInfo;</span>
<span class="fc" id="L2091">            ru.host = child.host;</span>
<span class="fc" id="L2092">            ru.port = child.port;</span>
<span class="fc" id="L2093">            ru.path = child.path;</span>
        }

        // 5.2 (7): Recombine (nothing to do here)
<span class="fc" id="L2097">        return ru;</span>
    }

    // If the given URI's path is normal then return the URI;
    // o.w., return a new URI containing the normalized path.
    //
    private static URI normalize(URI u) {
<span class="pc bpc" id="L2104" title="3 of 6 branches missed.">        if (u.isOpaque() || (u.path == null) || (u.path.length() == 0))</span>
<span class="nc" id="L2105">            return u;</span>

<span class="fc" id="L2107">        String np = normalize(u.path);</span>
<span class="fc bfc" id="L2108" title="All 2 branches covered.">        if (np == u.path)</span>
<span class="fc" id="L2109">            return u;</span>

<span class="fc" id="L2111">        URI v = new URI();</span>
<span class="fc" id="L2112">        v.scheme = u.scheme;</span>
<span class="fc" id="L2113">        v.fragment = u.fragment;</span>
<span class="fc" id="L2114">        v.authority = u.authority;</span>
<span class="fc" id="L2115">        v.userInfo = u.userInfo;</span>
<span class="fc" id="L2116">        v.host = u.host;</span>
<span class="fc" id="L2117">        v.port = u.port;</span>
<span class="fc" id="L2118">        v.path = np;</span>
<span class="fc" id="L2119">        v.query = u.query;</span>
<span class="fc" id="L2120">        return v;</span>
    }

    // If both URIs are hierarchical, their scheme and authority components are
    // identical, and the base path is a prefix of the child's path, then
    // return a relative URI that, when resolved against the base, yields the
    // child; otherwise, return the child.
    //
    private static URI relativize(URI base, URI child) {
        // check if child if opaque first so that NPE is thrown
        // if child is null.
<span class="pc bpc" id="L2131" title="2 of 4 branches missed.">        if (child.isOpaque() || base.isOpaque())</span>
<span class="nc" id="L2132">            return child;</span>
<span class="pc bpc" id="L2133" title="1 of 2 branches missed.">        if (!equalIgnoringCase(base.scheme, child.scheme)</span>
<span class="pc bpc" id="L2134" title="1 of 2 branches missed.">            || !equal(base.authority, child.authority))</span>
<span class="nc" id="L2135">            return child;</span>

<span class="fc" id="L2137">        String bp = normalize(base.path);</span>
<span class="fc" id="L2138">        String cp = normalize(child.path);</span>
<span class="fc bfc" id="L2139" title="All 2 branches covered.">        if (!bp.equals(cp)) {</span>
<span class="fc bfc" id="L2140" title="All 2 branches covered.">            if (!bp.endsWith(&quot;/&quot;))</span>
<span class="fc" id="L2141">                bp = bp + &quot;/&quot;;</span>
<span class="pc bpc" id="L2142" title="1 of 2 branches missed.">            if (!cp.startsWith(bp))</span>
<span class="nc" id="L2143">                return child;</span>
        }

<span class="fc" id="L2146">        URI v = new URI();</span>
<span class="fc" id="L2147">        v.path = cp.substring(bp.length());</span>
<span class="fc" id="L2148">        v.query = child.query;</span>
<span class="fc" id="L2149">        v.fragment = child.fragment;</span>
<span class="fc" id="L2150">        return v;</span>
    }



    // -- Path normalization --

    // The following algorithm for path normalization avoids the creation of a
    // string object for each segment, as well as the use of a string buffer to
    // compute the final result, by using a single char array and editing it in
    // place.  The array is first split into segments, replacing each slash
    // with '\0' and creating a segment-index array, each element of which is
    // the index of the first char in the corresponding segment.  We then walk
    // through both arrays, removing &quot;.&quot;, &quot;..&quot;, and other segments as necessary
    // by setting their entries in the index array to -1.  Finally, the two
    // arrays are used to rejoin the segments and compute the final result.
    //
    // This code is based upon src/solaris/native/java/io/canonicalize_md.c


    // Check the given path to see if it might need normalization.  A path
    // might need normalization if it contains duplicate slashes, a &quot;.&quot;
    // segment, or a &quot;..&quot; segment.  Return -1 if no further normalization is
    // possible, otherwise return the number of segments found.
    //
    // This method takes a string argument rather than a char array so that
    // this test can be performed without invoking path.toCharArray().
    //
    static private int needsNormalization(String path) {
<span class="fc" id="L2179">        boolean normal = true;</span>
<span class="fc" id="L2180">        int ns = 0;                     // Number of segments</span>
<span class="fc" id="L2181">        int end = path.length() - 1;    // Index of last char in path</span>
<span class="fc" id="L2182">        int p = 0;                      // Index of next char in path</span>

        // Skip initial slashes
<span class="pc bpc" id="L2185" title="1 of 2 branches missed.">        while (p &lt;= end) {</span>
<span class="fc bfc" id="L2186" title="All 2 branches covered.">            if (path.charAt(p) != '/') break;</span>
<span class="fc" id="L2187">            p++;</span>
        }
<span class="pc bpc" id="L2189" title="1 of 2 branches missed.">        if (p &gt; 1) normal = false;</span>

        // Scan segments
<span class="fc bfc" id="L2192" title="All 2 branches covered.">        while (p &lt;= end) {</span>

            // Looking at &quot;.&quot; or &quot;..&quot; ?
<span class="fc bfc" id="L2195" title="All 4 branches covered.">            if ((path.charAt(p) == '.')</span>
                &amp;&amp; ((p == end)
<span class="fc bfc" id="L2197" title="All 2 branches covered.">                    || ((path.charAt(p + 1) == '/')</span>
<span class="fc bfc" id="L2198" title="All 4 branches covered.">                        || ((path.charAt(p + 1) == '.')</span>
                            &amp;&amp; ((p + 1 == end)
<span class="fc bfc" id="L2200" title="All 2 branches covered.">                                || (path.charAt(p + 2) == '/')))))) {</span>
<span class="fc" id="L2201">                normal = false;</span>
            }
<span class="fc" id="L2203">            ns++;</span>

            // Find beginning of next segment
<span class="fc bfc" id="L2206" title="All 2 branches covered.">            while (p &lt;= end) {</span>
<span class="fc bfc" id="L2207" title="All 2 branches covered.">                if (path.charAt(p++) != '/')</span>
<span class="fc" id="L2208">                    continue;</span>

                // Skip redundant slashes
<span class="fc bfc" id="L2211" title="All 2 branches covered.">                while (p &lt;= end) {</span>
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">                    if (path.charAt(p) != '/') break;</span>
<span class="nc" id="L2213">                    normal = false;</span>
<span class="nc" id="L2214">                    p++;</span>
                }

                break;
            }
        }

<span class="fc bfc" id="L2221" title="All 2 branches covered.">        return normal ? -1 : ns;</span>
    }


    // Split the given path into segments, replacing slashes with nulls and
    // filling in the given segment-index array.
    //
    // Preconditions:
    //   segs.length == Number of segments in path
    //
    // Postconditions:
    //   All slashes in path replaced by '\0'
    //   segs[i] == Index of first char in segment i (0 &lt;= i &lt; segs.length)
    //
    static private void split(char[] path, int[] segs) {
<span class="fc" id="L2236">        int end = path.length - 1;      // Index of last char in path</span>
<span class="fc" id="L2237">        int p = 0;                      // Index of next char in path</span>
<span class="fc" id="L2238">        int i = 0;                      // Index of current segment</span>

        // Skip initial slashes
<span class="pc bpc" id="L2241" title="1 of 2 branches missed.">        while (p &lt;= end) {</span>
<span class="fc bfc" id="L2242" title="All 2 branches covered.">            if (path[p] != '/') break;</span>
<span class="fc" id="L2243">            path[p] = '\0';</span>
<span class="fc" id="L2244">            p++;</span>
        }

<span class="fc bfc" id="L2247" title="All 2 branches covered.">        while (p &lt;= end) {</span>

            // Note start of segment
<span class="fc" id="L2250">            segs[i++] = p++;</span>

            // Find beginning of next segment
<span class="fc bfc" id="L2253" title="All 2 branches covered.">            while (p &lt;= end) {</span>
<span class="fc bfc" id="L2254" title="All 2 branches covered.">                if (path[p++] != '/')</span>
<span class="fc" id="L2255">                    continue;</span>
<span class="fc" id="L2256">                path[p - 1] = '\0';</span>

                // Skip redundant slashes
<span class="fc bfc" id="L2259" title="All 2 branches covered.">                while (p &lt;= end) {</span>
<span class="pc bpc" id="L2260" title="1 of 2 branches missed.">                    if (path[p] != '/') break;</span>
<span class="nc" id="L2261">                    path[p++] = '\0';</span>
                }
                break;
            }
        }

<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">        if (i != segs.length)</span>
<span class="nc" id="L2268">            throw new InternalError();  // ASSERT</span>
<span class="fc" id="L2269">    }</span>


    // Join the segments in the given path according to the given segment-index
    // array, ignoring those segments whose index entries have been set to -1,
    // and inserting slashes as needed.  Return the length of the resulting
    // path.
    //
    // Preconditions:
    //   segs[i] == -1 implies segment i is to be ignored
    //   path computed by split, as above, with '\0' having replaced '/'
    //
    // Postconditions:
    //   path[0] .. path[return value] == Resulting path
    //
    static private int join(char[] path, int[] segs) {
<span class="fc" id="L2285">        int ns = segs.length;           // Number of segments</span>
<span class="fc" id="L2286">        int end = path.length - 1;      // Index of last char in path</span>
<span class="fc" id="L2287">        int p = 0;                      // Index of next path char to write</span>

<span class="fc bfc" id="L2289" title="All 2 branches covered.">        if (path[p] == '\0') {</span>
            // Restore initial slash for absolute paths
<span class="fc" id="L2291">            path[p++] = '/';</span>
        }

<span class="fc bfc" id="L2294" title="All 2 branches covered.">        for (int i = 0; i &lt; ns; i++) {</span>
<span class="fc" id="L2295">            int q = segs[i];            // Current segment</span>
<span class="fc bfc" id="L2296" title="All 2 branches covered.">            if (q == -1)</span>
                // Ignore this segment
<span class="fc" id="L2298">                continue;</span>

<span class="fc bfc" id="L2300" title="All 2 branches covered.">            if (p == q) {</span>
                // We're already at this segment, so just skip to its end
<span class="fc bfc" id="L2302" title="All 4 branches covered.">                while ((p &lt;= end) &amp;&amp; (path[p] != '\0'))</span>
<span class="fc" id="L2303">                    p++;</span>
<span class="fc bfc" id="L2304" title="All 2 branches covered.">                if (p &lt;= end) {</span>
                    // Preserve trailing slash
<span class="fc" id="L2306">                    path[p++] = '/';</span>
                }
<span class="pc bpc" id="L2308" title="1 of 2 branches missed.">            } else if (p &lt; q) {</span>
                // Copy q down to p
<span class="fc bfc" id="L2310" title="All 4 branches covered.">                while ((q &lt;= end) &amp;&amp; (path[q] != '\0'))</span>
<span class="fc" id="L2311">                    path[p++] = path[q++];</span>
<span class="fc bfc" id="L2312" title="All 2 branches covered.">                if (q &lt;= end) {</span>
                    // Preserve trailing slash
<span class="fc" id="L2314">                    path[p++] = '/';</span>
                }
            } else
<span class="nc" id="L2317">                throw new InternalError(); // ASSERT false</span>
        }

<span class="fc" id="L2320">        return p;</span>
    }


    // Remove &quot;.&quot; segments from the given path, and remove segment pairs
    // consisting of a non-&quot;..&quot; segment followed by a &quot;..&quot; segment.
    //
    private static void removeDots(char[] path, int[] segs) {
<span class="fc" id="L2328">        int ns = segs.length;</span>
<span class="fc" id="L2329">        int end = path.length - 1;</span>

<span class="fc bfc" id="L2331" title="All 2 branches covered.">        for (int i = 0; i &lt; ns; i++) {</span>
<span class="fc" id="L2332">            int dots = 0;               // Number of dots found (0, 1, or 2)</span>

            // Find next occurrence of &quot;.&quot; or &quot;..&quot;
            do {
<span class="fc" id="L2336">                int p = segs[i];</span>
<span class="fc bfc" id="L2337" title="All 2 branches covered.">                if (path[p] == '.') {</span>
<span class="fc bfc" id="L2338" title="All 2 branches covered.">                    if (p == end) {</span>
<span class="fc" id="L2339">                        dots = 1;</span>
<span class="fc" id="L2340">                        break;</span>
<span class="fc bfc" id="L2341" title="All 2 branches covered.">                    } else if (path[p + 1] == '\0') {</span>
<span class="fc" id="L2342">                        dots = 1;</span>
<span class="fc" id="L2343">                        break;</span>
<span class="pc bpc" id="L2344" title="2 of 6 branches missed.">                    } else if ((path[p + 1] == '.')</span>
                               &amp;&amp; ((p + 1 == end)
                                   || (path[p + 2] == '\0'))) {
<span class="fc" id="L2347">                        dots = 2;</span>
<span class="fc" id="L2348">                        break;</span>
                    }
                }
<span class="fc" id="L2351">                i++;</span>
<span class="fc bfc" id="L2352" title="All 2 branches covered.">            } while (i &lt; ns);</span>
<span class="pc bpc" id="L2353" title="1 of 4 branches missed.">            if ((i &gt; ns) || (dots == 0))</span>
<span class="fc" id="L2354">                break;</span>

<span class="fc bfc" id="L2356" title="All 2 branches covered.">            if (dots == 1) {</span>
                // Remove this occurrence of &quot;.&quot;
<span class="fc" id="L2358">                segs[i] = -1;</span>
            } else {
                // If there is a preceding non-&quot;..&quot; segment, remove both that
                // segment and this occurrence of &quot;..&quot;; otherwise, leave this
                // &quot;..&quot; segment as-is.
                int j;
<span class="fc bfc" id="L2364" title="All 2 branches covered.">                for (j = i - 1; j &gt;= 0; j--) {</span>
<span class="fc bfc" id="L2365" title="All 2 branches covered.">                    if (segs[j] != -1) break;</span>
                }
<span class="fc bfc" id="L2367" title="All 2 branches covered.">                if (j &gt;= 0) {</span>
<span class="fc" id="L2368">                    int q = segs[j];</span>
<span class="pc bpc" id="L2369" title="2 of 6 branches missed.">                    if (!((path[q] == '.')</span>
                          &amp;&amp; (path[q + 1] == '.')
                          &amp;&amp; (path[q + 2] == '\0'))) {
<span class="fc" id="L2372">                        segs[i] = -1;</span>
<span class="fc" id="L2373">                        segs[j] = -1;</span>
                    }
                }
            }
        }
<span class="fc" id="L2378">    }</span>


    // DEVIATION: If the normalized path is relative, and if the first
    // segment could be parsed as a scheme name, then prepend a &quot;.&quot; segment
    //
    private static void maybeAddLeadingDot(char[] path, int[] segs) {

<span class="fc bfc" id="L2386" title="All 2 branches covered.">        if (path[0] == '\0')</span>
            // The path is absolute
<span class="fc" id="L2388">            return;</span>

<span class="fc" id="L2390">        int ns = segs.length;</span>
<span class="fc" id="L2391">        int f = 0;                      // Index of first segment</span>
<span class="pc bpc" id="L2392" title="1 of 2 branches missed.">        while (f &lt; ns) {</span>
<span class="fc bfc" id="L2393" title="All 2 branches covered.">            if (segs[f] &gt;= 0)</span>
<span class="fc" id="L2394">                break;</span>
<span class="fc" id="L2395">            f++;</span>
        }
<span class="pc bpc" id="L2397" title="1 of 4 branches missed.">        if ((f &gt;= ns) || (f == 0))</span>
            // The path is empty, or else the original first segment survived,
            // in which case we already know that no leading &quot;.&quot; is needed
<span class="fc" id="L2400">            return;</span>

<span class="fc" id="L2402">        int p = segs[f];</span>
<span class="fc bfc" id="L2403" title="All 6 branches covered.">        while ((p &lt; path.length) &amp;&amp; (path[p] != ':') &amp;&amp; (path[p] != '\0')) p++;</span>
<span class="fc bfc" id="L2404" title="All 4 branches covered.">        if (p &gt;= path.length || path[p] == '\0')</span>
            // No colon in first segment, so no &quot;.&quot; needed
<span class="fc" id="L2406">            return;</span>

        // At this point we know that the first segment is unused,
        // hence we can insert a &quot;.&quot; segment at that position
<span class="fc" id="L2410">        path[0] = '.';</span>
<span class="fc" id="L2411">        path[1] = '\0';</span>
<span class="fc" id="L2412">        segs[0] = 0;</span>
<span class="fc" id="L2413">    }</span>


    // Normalize the given path string.  A normal path string has no empty
    // segments (i.e., occurrences of &quot;//&quot;), no segments equal to &quot;.&quot;, and no
    // segments equal to &quot;..&quot; that are preceded by a segment not equal to &quot;..&quot;.
    // In contrast to Unix-style pathname normalization, for URI paths we
    // always retain trailing slashes.
    //
    private static String normalize(String ps) {

        // Does this path need normalization?
<span class="fc" id="L2425">        int ns = needsNormalization(ps);        // Number of segments</span>
<span class="fc bfc" id="L2426" title="All 2 branches covered.">        if (ns &lt; 0)</span>
            // Nope -- just return it
<span class="fc" id="L2428">            return ps;</span>

<span class="fc" id="L2430">        char[] path = ps.toCharArray();         // Path in char-array form</span>

        // Split path into segments
<span class="fc" id="L2433">        int[] segs = new int[ns];               // Segment-index array</span>
<span class="fc" id="L2434">        split(path, segs);</span>

        // Remove dots
<span class="fc" id="L2437">        removeDots(path, segs);</span>

        // Prevent scheme-name confusion
<span class="fc" id="L2440">        maybeAddLeadingDot(path, segs);</span>

        // Join the remaining segments and return the result
<span class="fc" id="L2443">        String s = new String(path, 0, join(path, segs));</span>
<span class="fc bfc" id="L2444" title="All 2 branches covered.">        if (s.equals(ps)) {</span>
            // string was already normalized
<span class="fc" id="L2446">            return ps;</span>
        }
<span class="fc" id="L2448">        return s;</span>
    }



    // -- Character classes for parsing --

    // RFC2396 precisely specifies which characters in the US-ASCII charset are
    // permissible in the various components of a URI reference.  We here
    // define a set of mask pairs to aid in enforcing these restrictions.  Each
    // mask pair consists of two longs, a low mask and a high mask.  Taken
    // together they represent a 128-bit mask, where bit i is set iff the
    // character with value i is permitted.
    //
    // This approach is more efficient than sequentially searching arrays of
    // permitted characters.  It could be made still more efficient by
    // precompiling the mask information so that a character's presence in a
    // given mask could be determined by a single table lookup.

    // Compute the low-order mask for the characters in the given string
    private static long lowMask(String chars) {
<span class="fc" id="L2469">        int n = chars.length();</span>
<span class="fc" id="L2470">        long m = 0;</span>
<span class="fc bfc" id="L2471" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2472">            char c = chars.charAt(i);</span>
<span class="fc bfc" id="L2473" title="All 2 branches covered.">            if (c &lt; 64)</span>
<span class="fc" id="L2474">                m |= (1L &lt;&lt; c);</span>
        }
<span class="fc" id="L2476">        return m;</span>
    }

    // Compute the high-order mask for the characters in the given string
    private static long highMask(String chars) {
<span class="fc" id="L2481">        int n = chars.length();</span>
<span class="fc" id="L2482">        long m = 0;</span>
<span class="fc bfc" id="L2483" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2484">            char c = chars.charAt(i);</span>
<span class="pc bpc" id="L2485" title="1 of 4 branches missed.">            if ((c &gt;= 64) &amp;&amp; (c &lt; 128))</span>
<span class="fc" id="L2486">                m |= (1L &lt;&lt; (c - 64));</span>
        }
<span class="fc" id="L2488">        return m;</span>
    }

    // Compute a low-order mask for the characters
    // between first and last, inclusive
    private static long lowMask(char first, char last) {
<span class="fc" id="L2494">        long m = 0;</span>
<span class="fc" id="L2495">        int f = Math.max(Math.min(first, 63), 0);</span>
<span class="fc" id="L2496">        int l = Math.max(Math.min(last, 63), 0);</span>
<span class="fc bfc" id="L2497" title="All 2 branches covered.">        for (int i = f; i &lt;= l; i++)</span>
<span class="fc" id="L2498">            m |= 1L &lt;&lt; i;</span>
<span class="fc" id="L2499">        return m;</span>
    }

    // Compute a high-order mask for the characters
    // between first and last, inclusive
    private static long highMask(char first, char last) {
<span class="fc" id="L2505">        long m = 0;</span>
<span class="fc" id="L2506">        int f = Math.max(Math.min(first, 127), 64) - 64;</span>
<span class="fc" id="L2507">        int l = Math.max(Math.min(last, 127), 64) - 64;</span>
<span class="fc bfc" id="L2508" title="All 2 branches covered.">        for (int i = f; i &lt;= l; i++)</span>
<span class="fc" id="L2509">            m |= 1L &lt;&lt; i;</span>
<span class="fc" id="L2510">        return m;</span>
    }

    // Tell whether the given character is permitted by the given mask pair
    private static boolean match(char c, long lowMask, long highMask) {
<span class="pc bpc" id="L2515" title="1 of 2 branches missed.">        if (c == 0) // 0 doesn't have a slot in the mask. So, it never matches.</span>
<span class="nc" id="L2516">            return false;</span>
<span class="fc bfc" id="L2517" title="All 2 branches covered.">        if (c &lt; 64)</span>
<span class="fc bfc" id="L2518" title="All 2 branches covered.">            return ((1L &lt;&lt; c) &amp; lowMask) != 0;</span>
<span class="fc bfc" id="L2519" title="All 2 branches covered.">        if (c &lt; 128)</span>
<span class="fc bfc" id="L2520" title="All 2 branches covered.">            return ((1L &lt;&lt; (c - 64)) &amp; highMask) != 0;</span>
<span class="fc" id="L2521">        return false;</span>
    }

    // Character-class masks, in reverse order from RFC2396 because
    // initializers for static fields cannot make forward references.

    // digit    = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |
    //            &quot;8&quot; | &quot;9&quot;
<span class="fc" id="L2529">    private static final long L_DIGIT = lowMask('0', '9');</span>
    private static final long H_DIGIT = 0L;

    // upalpha  = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot; | &quot;H&quot; | &quot;I&quot; |
    //            &quot;J&quot; | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot; | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; |
    //            &quot;S&quot; | &quot;T&quot; | &quot;U&quot; | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot;
    private static final long L_UPALPHA = 0L;
<span class="fc" id="L2536">    private static final long H_UPALPHA = highMask('A', 'Z');</span>

    // lowalpha = &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; |
    //            &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; |
    //            &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;
    private static final long L_LOWALPHA = 0L;
<span class="fc" id="L2542">    private static final long H_LOWALPHA = highMask('a', 'z');</span>

    // alpha         = lowalpha | upalpha
    private static final long L_ALPHA = L_LOWALPHA | L_UPALPHA;
<span class="fc" id="L2546">    private static final long H_ALPHA = H_LOWALPHA | H_UPALPHA;</span>

    // alphanum      = alpha | digit
<span class="fc" id="L2549">    private static final long L_ALPHANUM = L_DIGIT | L_ALPHA;</span>
<span class="fc" id="L2550">    private static final long H_ALPHANUM = H_DIGIT | H_ALPHA;</span>

    // hex           = digit | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; |
    //                         &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
<span class="fc" id="L2554">    private static final long L_HEX = L_DIGIT;</span>
<span class="fc" id="L2555">    private static final long H_HEX = highMask('A', 'F') | highMask('a', 'f');</span>

    // mark          = &quot;-&quot; | &quot;_&quot; | &quot;.&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot; | &quot;'&quot; |
    //                 &quot;(&quot; | &quot;)&quot;
<span class="fc" id="L2559">    private static final long L_MARK = lowMask(&quot;-_.!~*'()&quot;);</span>
<span class="fc" id="L2560">    private static final long H_MARK = highMask(&quot;-_.!~*'()&quot;);</span>

    // unreserved    = alphanum | mark
<span class="fc" id="L2563">    private static final long L_UNRESERVED = L_ALPHANUM | L_MARK;</span>
<span class="fc" id="L2564">    private static final long H_UNRESERVED = H_ALPHANUM | H_MARK;</span>

    // reserved      = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; |
    //                 &quot;$&quot; | &quot;,&quot; | &quot;[&quot; | &quot;]&quot;
    // Added per RFC2732: &quot;[&quot;, &quot;]&quot;
<span class="fc" id="L2569">    private static final long L_RESERVED = lowMask(&quot;;/?:@&amp;=+$,[]&quot;);</span>
<span class="fc" id="L2570">    private static final long H_RESERVED = highMask(&quot;;/?:@&amp;=+$,[]&quot;);</span>

    // The zero'th bit is used to indicate that escape pairs and non-US-ASCII
    // characters are allowed; this is handled by the scanEscape method below.
    private static final long L_ESCAPED = 1L;
    private static final long H_ESCAPED = 0L;

    // uric          = reserved | unreserved | escaped
<span class="fc" id="L2578">    private static final long L_URIC = L_RESERVED | L_UNRESERVED | L_ESCAPED;</span>
<span class="fc" id="L2579">    private static final long H_URIC = H_RESERVED | H_UNRESERVED | H_ESCAPED;</span>

    // pchar         = unreserved | escaped |
    //                 &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;
<span class="fc" id="L2583">    private static final long L_PCHAR</span>
<span class="fc" id="L2584">        = L_UNRESERVED | L_ESCAPED | lowMask(&quot;:@&amp;=+$,&quot;);</span>
<span class="fc" id="L2585">    private static final long H_PCHAR</span>
<span class="fc" id="L2586">        = H_UNRESERVED | H_ESCAPED | highMask(&quot;:@&amp;=+$,&quot;);</span>

    // All valid path characters
<span class="fc" id="L2589">    private static final long L_PATH = L_PCHAR | lowMask(&quot;;/&quot;);</span>
<span class="fc" id="L2590">    private static final long H_PATH = H_PCHAR | highMask(&quot;;/&quot;);</span>

    // Dash, for use in domainlabel and toplabel
<span class="fc" id="L2593">    private static final long L_DASH = lowMask(&quot;-&quot;);</span>
<span class="fc" id="L2594">    private static final long H_DASH = highMask(&quot;-&quot;);</span>

    // Dot, for use in hostnames
<span class="fc" id="L2597">    private static final long L_DOT = lowMask(&quot;.&quot;);</span>
<span class="fc" id="L2598">    private static final long H_DOT = highMask(&quot;.&quot;);</span>

    // userinfo      = *( unreserved | escaped |
    //                    &quot;;&quot; | &quot;:&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot; )
<span class="fc" id="L2602">    private static final long L_USERINFO</span>
<span class="fc" id="L2603">        = L_UNRESERVED | L_ESCAPED | lowMask(&quot;;:&amp;=+$,&quot;);</span>
<span class="fc" id="L2604">    private static final long H_USERINFO</span>
<span class="fc" id="L2605">        = H_UNRESERVED | H_ESCAPED | highMask(&quot;;:&amp;=+$,&quot;);</span>

    // reg_name      = 1*( unreserved | escaped | &quot;$&quot; | &quot;,&quot; |
    //                     &quot;;&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; )
<span class="fc" id="L2609">    private static final long L_REG_NAME</span>
<span class="fc" id="L2610">        = L_UNRESERVED | L_ESCAPED | lowMask(&quot;$,;:@&amp;=+&quot;);</span>
<span class="fc" id="L2611">    private static final long H_REG_NAME</span>
<span class="fc" id="L2612">        = H_UNRESERVED | H_ESCAPED | highMask(&quot;$,;:@&amp;=+&quot;);</span>

    // All valid characters for server-based authorities
<span class="fc" id="L2615">    private static final long L_SERVER</span>
<span class="fc" id="L2616">        = L_USERINFO | L_ALPHANUM | L_DASH | lowMask(&quot;.:@[]&quot;);</span>
<span class="fc" id="L2617">    private static final long H_SERVER</span>
<span class="fc" id="L2618">        = H_USERINFO | H_ALPHANUM | H_DASH | highMask(&quot;.:@[]&quot;);</span>

    // Special case of server authority that represents an IPv6 address
    // In this case, a % does not signify an escape sequence
<span class="fc" id="L2622">    private static final long L_SERVER_PERCENT</span>
<span class="fc" id="L2623">        = L_SERVER | lowMask(&quot;%&quot;);</span>
<span class="fc" id="L2624">    private static final long H_SERVER_PERCENT</span>
<span class="fc" id="L2625">        = H_SERVER | highMask(&quot;%&quot;);</span>
<span class="fc" id="L2626">    private static final long L_LEFT_BRACKET = lowMask(&quot;[&quot;);</span>
<span class="fc" id="L2627">    private static final long H_LEFT_BRACKET = highMask(&quot;[&quot;);</span>

    // scheme        = alpha *( alpha | digit | &quot;+&quot; | &quot;-&quot; | &quot;.&quot; )
<span class="fc" id="L2630">    private static final long L_SCHEME = L_ALPHA | L_DIGIT | lowMask(&quot;+-.&quot;);</span>
<span class="fc" id="L2631">    private static final long H_SCHEME = H_ALPHA | H_DIGIT | highMask(&quot;+-.&quot;);</span>

    // uric_no_slash = unreserved | escaped | &quot;;&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; |
    //                 &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;
<span class="fc" id="L2635">    private static final long L_URIC_NO_SLASH</span>
<span class="fc" id="L2636">        = L_UNRESERVED | L_ESCAPED | lowMask(&quot;;?:@&amp;=+$,&quot;);</span>
<span class="fc" id="L2637">    private static final long H_URIC_NO_SLASH</span>
<span class="fc" id="L2638">        = H_UNRESERVED | H_ESCAPED | highMask(&quot;;?:@&amp;=+$,&quot;);</span>


    // -- Escaping and encoding --

<span class="fc" id="L2643">    private final static char[] hexDigits = {</span>
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
    };

    private static void appendEscape(StringBuffer sb, byte b) {
<span class="fc" id="L2649">        sb.append('%');</span>
<span class="fc" id="L2650">        sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);</span>
<span class="fc" id="L2651">        sb.append(hexDigits[(b &gt;&gt; 0) &amp; 0x0f]);</span>
<span class="fc" id="L2652">    }</span>

    private static void appendEncoded(StringBuffer sb, char c) {
<span class="fc" id="L2655">        ByteBuffer bb = null;</span>
        try {
<span class="fc" id="L2657">            bb = ThreadLocalCoders.encoderFor(&quot;UTF-8&quot;)</span>
<span class="fc" id="L2658">                .encode(CharBuffer.wrap(&quot;&quot; + c));</span>
<span class="nc" id="L2659">        } catch (CharacterCodingException x) {</span>
<span class="nc bnc" id="L2660" title="All 2 branches missed.">            assert false;</span>
<span class="fc" id="L2661">        }</span>
<span class="fc bfc" id="L2662" title="All 2 branches covered.">        while (bb.hasRemaining()) {</span>
<span class="fc" id="L2663">            int b = bb.get() &amp; 0xff;</span>
<span class="pc bpc" id="L2664" title="1 of 2 branches missed.">            if (b &gt;= 0x80)</span>
<span class="fc" id="L2665">                appendEscape(sb, (byte)b);</span>
            else
<span class="nc" id="L2667">                sb.append((char)b);</span>
<span class="fc" id="L2668">        }</span>
<span class="fc" id="L2669">    }</span>

    // Quote any characters in s that are not permitted
    // by the given mask pair
    //
    private static String quote(String s, long lowMask, long highMask) {
<span class="fc" id="L2675">        int n = s.length();</span>
<span class="fc" id="L2676">        StringBuffer sb = null;</span>
<span class="pc bpc" id="L2677" title="1 of 2 branches missed.">        boolean allowNonASCII = ((lowMask &amp; L_ESCAPED) != 0);</span>
<span class="fc bfc" id="L2678" title="All 2 branches covered.">        for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="fc" id="L2679">            char c = s.charAt(i);</span>
<span class="fc bfc" id="L2680" title="All 2 branches covered.">            if (c &lt; '\u0080') {</span>
<span class="fc bfc" id="L2681" title="All 2 branches covered.">                if (!match(c, lowMask, highMask)) {</span>
<span class="fc bfc" id="L2682" title="All 2 branches covered.">                    if (sb == null) {</span>
<span class="fc" id="L2683">                        sb = new StringBuffer();</span>
<span class="fc" id="L2684">                        sb.append(s.substring(0, i));</span>
                    }
<span class="fc" id="L2686">                    appendEscape(sb, (byte)c);</span>
                } else {
<span class="fc bfc" id="L2688" title="All 2 branches covered.">                    if (sb != null)</span>
<span class="fc" id="L2689">                        sb.append(c);</span>
                }
<span class="pc bpc" id="L2691" title="1 of 2 branches missed.">            } else if (allowNonASCII</span>
<span class="fc bfc" id="L2692" title="All 2 branches covered.">                       &amp;&amp; (Character.isSpaceChar(c)</span>
<span class="pc bpc" id="L2693" title="1 of 2 branches missed.">                           || Character.isISOControl(c))) {</span>
<span class="pc bpc" id="L2694" title="1 of 2 branches missed.">                if (sb == null) {</span>
<span class="nc" id="L2695">                    sb = new StringBuffer();</span>
<span class="nc" id="L2696">                    sb.append(s.substring(0, i));</span>
                }
<span class="fc" id="L2698">                appendEncoded(sb, c);</span>
            } else {
<span class="fc bfc" id="L2700" title="All 2 branches covered.">                if (sb != null)</span>
<span class="fc" id="L2701">                    sb.append(c);</span>
            }
        }
<span class="fc bfc" id="L2704" title="All 2 branches covered.">        return (sb == null) ? s : sb.toString();</span>
    }

    // Encodes all characters &gt;= \u0080 into escaped, normalized UTF-8 octets,
    // assuming that s is otherwise legal
    //
    private static String encode(String s) {
<span class="fc" id="L2711">        int n = s.length();</span>
<span class="pc bpc" id="L2712" title="1 of 2 branches missed.">        if (n == 0)</span>
<span class="nc" id="L2713">            return s;</span>

        // First check whether we actually need to encode
<span class="fc" id="L2716">        for (int i = 0;;) {</span>
<span class="pc bpc" id="L2717" title="1 of 2 branches missed.">            if (s.charAt(i) &gt;= '\u0080')</span>
<span class="nc" id="L2718">                break;</span>
<span class="fc bfc" id="L2719" title="All 2 branches covered.">            if (++i &gt;= n)</span>
<span class="fc" id="L2720">                return s;</span>
        }

<span class="nc" id="L2723">        String ns = Normalizer.normalize(s, Normalizer.Form.NFC);</span>
<span class="nc" id="L2724">        ByteBuffer bb = null;</span>
        try {
<span class="nc" id="L2726">            bb = ThreadLocalCoders.encoderFor(&quot;UTF-8&quot;)</span>
<span class="nc" id="L2727">                .encode(CharBuffer.wrap(ns));</span>
<span class="nc" id="L2728">        } catch (CharacterCodingException x) {</span>
<span class="nc bnc" id="L2729" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L2730">        }</span>

<span class="nc" id="L2732">        StringBuffer sb = new StringBuffer();</span>
<span class="nc bnc" id="L2733" title="All 2 branches missed.">        while (bb.hasRemaining()) {</span>
<span class="nc" id="L2734">            int b = bb.get() &amp; 0xff;</span>
<span class="nc bnc" id="L2735" title="All 2 branches missed.">            if (b &gt;= 0x80)</span>
<span class="nc" id="L2736">                appendEscape(sb, (byte)b);</span>
            else
<span class="nc" id="L2738">                sb.append((char)b);</span>
<span class="nc" id="L2739">        }</span>
<span class="nc" id="L2740">        return sb.toString();</span>
    }

    private static int decode(char c) {
<span class="pc bpc" id="L2744" title="1 of 4 branches missed.">        if ((c &gt;= '0') &amp;&amp; (c &lt;= '9'))</span>
<span class="fc" id="L2745">            return c - '0';</span>
<span class="pc bpc" id="L2746" title="1 of 4 branches missed.">        if ((c &gt;= 'a') &amp;&amp; (c &lt;= 'f'))</span>
<span class="fc" id="L2747">            return c - 'a' + 10;</span>
<span class="pc bpc" id="L2748" title="2 of 4 branches missed.">        if ((c &gt;= 'A') &amp;&amp; (c &lt;= 'F'))</span>
<span class="fc" id="L2749">            return c - 'A' + 10;</span>
<span class="nc bnc" id="L2750" title="All 2 branches missed.">        assert false;</span>
<span class="nc" id="L2751">        return -1;</span>
    }

    private static byte decode(char c1, char c2) {
<span class="fc" id="L2755">        return (byte)(  ((decode(c1) &amp; 0xf) &lt;&lt; 4)</span>
<span class="fc" id="L2756">                      | ((decode(c2) &amp; 0xf) &lt;&lt; 0));</span>
    }

    // Evaluates all escapes in s, applying UTF-8 decoding if needed.  Assumes
    // that escapes are well-formed syntactically, i.e., of the form %XX.  If a
    // sequence of escaped octets is not valid UTF-8 then the erroneous octets
    // are replaced with '\uFFFD'.
    // Exception: any &quot;%&quot; found between &quot;[]&quot; is left alone. It is an IPv6 literal
    //            with a scope_id
    //
    private static String decode(String s) {
<span class="fc bfc" id="L2767" title="All 2 branches covered.">        if (s == null)</span>
<span class="fc" id="L2768">            return s;</span>
<span class="fc" id="L2769">        int n = s.length();</span>
<span class="fc bfc" id="L2770" title="All 2 branches covered.">        if (n == 0)</span>
<span class="fc" id="L2771">            return s;</span>
<span class="fc bfc" id="L2772" title="All 2 branches covered.">        if (s.indexOf('%') &lt; 0)</span>
<span class="fc" id="L2773">            return s;</span>

<span class="fc" id="L2775">        StringBuffer sb = new StringBuffer(n);</span>
<span class="fc" id="L2776">        ByteBuffer bb = ByteBuffer.allocate(n);</span>
<span class="fc" id="L2777">        CharBuffer cb = CharBuffer.allocate(n);</span>
<span class="fc" id="L2778">        CharsetDecoder dec = ThreadLocalCoders.decoderFor(&quot;UTF-8&quot;)</span>
<span class="fc" id="L2779">            .onMalformedInput(CodingErrorAction.REPLACE)</span>
<span class="fc" id="L2780">            .onUnmappableCharacter(CodingErrorAction.REPLACE);</span>

        // This is not horribly efficient, but it will do for now
<span class="fc" id="L2783">        char c = s.charAt(0);</span>
<span class="fc" id="L2784">        boolean betweenBrackets = false;</span>

<span class="fc bfc" id="L2786" title="All 2 branches covered.">        for (int i = 0; i &lt; n;) {</span>
<span class="pc bpc" id="L2787" title="2 of 4 branches missed.">            assert c == s.charAt(i);    // Loop invariant</span>
<span class="fc bfc" id="L2788" title="All 2 branches covered.">            if (c == '[') {</span>
<span class="fc" id="L2789">                betweenBrackets = true;</span>
<span class="fc bfc" id="L2790" title="All 4 branches covered.">            } else if (betweenBrackets &amp;&amp; c == ']') {</span>
<span class="fc" id="L2791">                betweenBrackets = false;</span>
            }
<span class="fc bfc" id="L2793" title="All 4 branches covered.">            if (c != '%' || betweenBrackets) {</span>
<span class="fc" id="L2794">                sb.append(c);</span>
<span class="fc bfc" id="L2795" title="All 2 branches covered.">                if (++i &gt;= n)</span>
<span class="fc" id="L2796">                    break;</span>
<span class="fc" id="L2797">                c = s.charAt(i);</span>
<span class="fc" id="L2798">                continue;</span>
            }
<span class="fc" id="L2800">            bb.clear();</span>
<span class="fc" id="L2801">            int ui = i;</span>
            for (;;) {
<span class="pc bpc" id="L2803" title="2 of 4 branches missed.">                assert (n - i &gt;= 2);</span>
<span class="fc" id="L2804">                bb.put(decode(s.charAt(++i), s.charAt(++i)));</span>
<span class="fc bfc" id="L2805" title="All 2 branches covered.">                if (++i &gt;= n)</span>
<span class="fc" id="L2806">                    break;</span>
<span class="fc" id="L2807">                c = s.charAt(i);</span>
<span class="fc bfc" id="L2808" title="All 2 branches covered.">                if (c != '%')</span>
<span class="fc" id="L2809">                    break;</span>
            }
<span class="fc" id="L2811">            bb.flip();</span>
<span class="fc" id="L2812">            cb.clear();</span>
<span class="fc" id="L2813">            dec.reset();</span>
<span class="fc" id="L2814">            CoderResult cr = dec.decode(bb, cb, true);</span>
<span class="pc bpc" id="L2815" title="2 of 4 branches missed.">            assert cr.isUnderflow();</span>
<span class="fc" id="L2816">            cr = dec.flush(cb);</span>
<span class="pc bpc" id="L2817" title="2 of 4 branches missed.">            assert cr.isUnderflow();</span>
<span class="fc" id="L2818">            sb.append(cb.flip().toString());</span>
<span class="fc" id="L2819">        }</span>

<span class="fc" id="L2821">        return sb.toString();</span>
    }


    // -- Parsing --

    // For convenience we wrap the input URI string in a new instance of the
    // following internal class.  This saves always having to pass the input
    // string as an argument to each internal scan/parse method.

    private class Parser {

        private String input;           // URI input string
<span class="fc" id="L2834">        private boolean requireServerAuthority = false;</span>

<span class="fc" id="L2836">        Parser(String s) {</span>
<span class="fc" id="L2837">            input = s;</span>
<span class="fc" id="L2838">            string = s;</span>
<span class="fc" id="L2839">        }</span>

        // -- Methods for throwing URISyntaxException in various ways --

        private void fail(String reason) throws URISyntaxException {
<span class="fc" id="L2844">            throw new URISyntaxException(input, reason);</span>
        }

        private void fail(String reason, int p) throws URISyntaxException {
<span class="fc" id="L2848">            throw new URISyntaxException(input, reason, p);</span>
        }

        private void failExpecting(String expected, int p)
            throws URISyntaxException
        {
<span class="nc" id="L2854">            fail(&quot;Expected &quot; + expected, p);</span>
<span class="nc" id="L2855">        }</span>

        private void failExpecting(String expected, String prior, int p)
            throws URISyntaxException
        {
<span class="nc" id="L2860">            fail(&quot;Expected &quot; + expected + &quot; following &quot; + prior, p);</span>
<span class="nc" id="L2861">        }</span>


        // -- Simple access to the input string --

        // Return a substring of the input string
        //
        private String substring(int start, int end) {
<span class="fc" id="L2869">            return input.substring(start, end);</span>
        }

        // Return the char at position p,
        // assuming that p &lt; input.length()
        //
        private char charAt(int p) {
<span class="fc" id="L2876">            return input.charAt(p);</span>
        }

        // Tells whether start &lt; end and, if so, whether charAt(start) == c
        //
        private boolean at(int start, int end, char c) {
<span class="fc bfc" id="L2882" title="All 4 branches covered.">            return (start &lt; end) &amp;&amp; (charAt(start) == c);</span>
        }

        // Tells whether start + s.length() &lt; end and, if so,
        // whether the chars at the start position match s exactly
        //
        private boolean at(int start, int end, String s) {
<span class="fc" id="L2889">            int p = start;</span>
<span class="fc" id="L2890">            int sn = s.length();</span>
<span class="fc bfc" id="L2891" title="All 2 branches covered.">            if (sn &gt; end - p)</span>
<span class="fc" id="L2892">                return false;</span>
<span class="fc" id="L2893">            int i = 0;</span>
<span class="fc bfc" id="L2894" title="All 2 branches covered.">            while (i &lt; sn) {</span>
<span class="fc bfc" id="L2895" title="All 2 branches covered.">                if (charAt(p++) != s.charAt(i)) {</span>
<span class="fc" id="L2896">                    break;</span>
                }
<span class="fc" id="L2898">                i++;</span>
            }
<span class="fc bfc" id="L2900" title="All 2 branches covered.">            return (i == sn);</span>
        }


        // -- Scanning --

        // The various scan and parse methods that follow use a uniform
        // convention of taking the current start position and end index as
        // their first two arguments.  The start is inclusive while the end is
        // exclusive, just as in the String class, i.e., a start/end pair
        // denotes the left-open interval [start, end) of the input string.
        //
        // These methods never proceed past the end position.  They may return
        // -1 to indicate outright failure, but more often they simply return
        // the position of the first char after the last char scanned.  Thus
        // a typical idiom is
        //
        //     int p = start;
        //     int q = scan(p, end, ...);
        //     if (q &gt; p)
        //         // We scanned something
        //         ...;
        //     else if (q == p)
        //         // We scanned nothing
        //         ...;
        //     else if (q == -1)
        //         // Something went wrong
        //         ...;


        // Scan a specific char: If the char at the given start position is
        // equal to c, return the index of the next char; otherwise, return the
        // start position.
        //
        private int scan(int start, int end, char c) {
<span class="fc bfc" id="L2935" title="All 4 branches covered.">            if ((start &lt; end) &amp;&amp; (charAt(start) == c))</span>
<span class="fc" id="L2936">                return start + 1;</span>
<span class="fc" id="L2937">            return start;</span>
        }

        // Scan forward from the given start position.  Stop at the first char
        // in the err string (in which case -1 is returned), or the first char
        // in the stop string (in which case the index of the preceding char is
        // returned), or the end of the input string (in which case the length
        // of the input string is returned).  May return the start position if
        // nothing matches.
        //
        private int scan(int start, int end, String err, String stop) {
<span class="fc" id="L2948">            int p = start;</span>
<span class="fc bfc" id="L2949" title="All 2 branches covered.">            while (p &lt; end) {</span>
<span class="fc" id="L2950">                char c = charAt(p);</span>
<span class="fc bfc" id="L2951" title="All 2 branches covered.">                if (err.indexOf(c) &gt;= 0)</span>
<span class="fc" id="L2952">                    return -1;</span>
<span class="fc bfc" id="L2953" title="All 2 branches covered.">                if (stop.indexOf(c) &gt;= 0)</span>
<span class="fc" id="L2954">                    break;</span>
<span class="fc" id="L2955">                p++;</span>
<span class="fc" id="L2956">            }</span>
<span class="fc" id="L2957">            return p;</span>
        }

        // Scan a potential escape sequence, starting at the given position,
        // with the given first char (i.e., charAt(start) == c).
        //
        // This method assumes that if escapes are allowed then visible
        // non-US-ASCII chars are also allowed.
        //
        private int scanEscape(int start, int n, char first)
            throws URISyntaxException
        {
<span class="fc" id="L2969">            int p = start;</span>
<span class="fc" id="L2970">            char c = first;</span>
<span class="fc bfc" id="L2971" title="All 2 branches covered.">            if (c == '%') {</span>
                // Process escape pair
<span class="fc bfc" id="L2973" title="All 2 branches covered.">                if ((p + 3 &lt;= n)</span>
<span class="pc bpc" id="L2974" title="1 of 2 branches missed.">                    &amp;&amp; match(charAt(p + 1), L_HEX, H_HEX)</span>
<span class="fc bfc" id="L2975" title="All 2 branches covered.">                    &amp;&amp; match(charAt(p + 2), L_HEX, H_HEX)) {</span>
<span class="fc" id="L2976">                    return p + 3;</span>
                }
<span class="nc" id="L2978">                fail(&quot;Malformed escape pair&quot;, p);</span>
<span class="fc bfc" id="L2979" title="All 2 branches covered.">            } else if ((c &gt; 128)</span>
<span class="pc bpc" id="L2980" title="1 of 2 branches missed.">                       &amp;&amp; !Character.isSpaceChar(c)</span>
<span class="pc bpc" id="L2981" title="1 of 2 branches missed.">                       &amp;&amp; !Character.isISOControl(c)) {</span>
                // Allow unescaped but visible non-US-ASCII chars
<span class="fc" id="L2983">                return p + 1;</span>
            }
<span class="fc" id="L2985">            return p;</span>
        }

        // Scan chars that match the given mask pair
        //
        private int scan(int start, int n, long lowMask, long highMask)
            throws URISyntaxException
        {
<span class="fc" id="L2993">            int p = start;</span>
<span class="fc bfc" id="L2994" title="All 2 branches covered.">            while (p &lt; n) {</span>
<span class="fc" id="L2995">                char c = charAt(p);</span>
<span class="fc bfc" id="L2996" title="All 2 branches covered.">                if (match(c, lowMask, highMask)) {</span>
<span class="fc" id="L2997">                    p++;</span>
<span class="fc" id="L2998">                    continue;</span>
                }
<span class="fc bfc" id="L3000" title="All 2 branches covered.">                if ((lowMask &amp; L_ESCAPED) != 0) {</span>
<span class="fc" id="L3001">                    int q = scanEscape(p, n, c);</span>
<span class="fc bfc" id="L3002" title="All 2 branches covered.">                    if (q &gt; p) {</span>
<span class="fc" id="L3003">                        p = q;</span>
<span class="fc" id="L3004">                        continue;</span>
                    }
<span class="fc" id="L3006">                }</span>
                break;
            }
<span class="fc" id="L3009">            return p;</span>
        }

        // Check that each of the chars in [start, end) matches the given mask
        //
        private void checkChars(int start, int end,
                                long lowMask, long highMask,
                                String what)
            throws URISyntaxException
        {
<span class="fc" id="L3019">            int p = scan(start, end, lowMask, highMask);</span>
<span class="pc bpc" id="L3020" title="1 of 2 branches missed.">            if (p &lt; end)</span>
<span class="nc" id="L3021">                fail(&quot;Illegal character in &quot; + what, p);</span>
<span class="fc" id="L3022">        }</span>

        // Check that the char at position p matches the given mask
        //
        private void checkChar(int p,
                               long lowMask, long highMask,
                               String what)
            throws URISyntaxException
        {
<span class="fc" id="L3031">            checkChars(p, p + 1, lowMask, highMask, what);</span>
<span class="fc" id="L3032">        }</span>


        // -- Parsing --

        // [&lt;scheme&gt;:]&lt;scheme-specific-part&gt;[#&lt;fragment&gt;]
        //
        void parse(boolean rsa) throws URISyntaxException {
<span class="fc" id="L3040">            requireServerAuthority = rsa;</span>
            int ssp;                    // Start of scheme-specific part
<span class="fc" id="L3042">            int n = input.length();</span>
<span class="fc" id="L3043">            int p = scan(0, n, &quot;/?#&quot;, &quot;:&quot;);</span>
<span class="fc bfc" id="L3044" title="All 4 branches covered.">            if ((p &gt;= 0) &amp;&amp; at(p, n, ':')) {</span>
<span class="pc bpc" id="L3045" title="1 of 2 branches missed.">                if (p == 0)</span>
<span class="nc" id="L3046">                    failExpecting(&quot;scheme name&quot;, 0);</span>
<span class="fc" id="L3047">                checkChar(0, L_ALPHA, H_ALPHA, &quot;scheme name&quot;);</span>
<span class="fc" id="L3048">                checkChars(1, p, L_SCHEME, H_SCHEME, &quot;scheme name&quot;);</span>
<span class="fc" id="L3049">                scheme = substring(0, p);</span>
<span class="fc" id="L3050">                p++;                    // Skip ':'</span>
<span class="fc" id="L3051">                ssp = p;</span>
<span class="fc bfc" id="L3052" title="All 2 branches covered.">                if (at(p, n, '/')) {</span>
<span class="fc" id="L3053">                    p = parseHierarchical(p, n);</span>
                } else {
<span class="fc" id="L3055">                    int q = scan(p, n, &quot;&quot;, &quot;#&quot;);</span>
<span class="pc bpc" id="L3056" title="1 of 2 branches missed.">                    if (q &lt;= p)</span>
<span class="nc" id="L3057">                        failExpecting(&quot;scheme-specific part&quot;, p);</span>
<span class="fc" id="L3058">                    checkChars(p, q, L_URIC, H_URIC, &quot;opaque part&quot;);</span>
<span class="fc" id="L3059">                    p = q;</span>
<span class="fc" id="L3060">                }</span>
            } else {
<span class="fc" id="L3062">                ssp = 0;</span>
<span class="fc" id="L3063">                p = parseHierarchical(0, n);</span>
            }
<span class="fc" id="L3065">            schemeSpecificPart = substring(ssp, p);</span>
<span class="fc bfc" id="L3066" title="All 2 branches covered.">            if (at(p, n, '#')) {</span>
<span class="fc" id="L3067">                checkChars(p + 1, n, L_URIC, H_URIC, &quot;fragment&quot;);</span>
<span class="fc" id="L3068">                fragment = substring(p + 1, n);</span>
<span class="fc" id="L3069">                p = n;</span>
            }
<span class="pc bpc" id="L3071" title="1 of 2 branches missed.">            if (p &lt; n)</span>
<span class="nc" id="L3072">                fail(&quot;end of URI&quot;, p);</span>
<span class="fc" id="L3073">        }</span>

        // [//authority]&lt;path&gt;[?&lt;query&gt;]
        //
        // DEVIATION from RFC2396: We allow an empty authority component as
        // long as it's followed by a non-empty path, query component, or
        // fragment component.  This is so that URIs such as &quot;file:///foo/bar&quot;
        // will parse.  This seems to be the intent of RFC2396, though the
        // grammar does not permit it.  If the authority is empty then the
        // userInfo, host, and port components are undefined.
        //
        // DEVIATION from RFC2396: We allow empty relative paths.  This seems
        // to be the intent of RFC2396, but the grammar does not permit it.
        // The primary consequence of this deviation is that &quot;#f&quot; parses as a
        // relative URI with an empty path.
        //
        private int parseHierarchical(int start, int n)
            throws URISyntaxException
        {
<span class="fc" id="L3092">            int p = start;</span>
<span class="fc bfc" id="L3093" title="All 4 branches covered.">            if (at(p, n, '/') &amp;&amp; at(p + 1, n, '/')) {</span>
<span class="fc" id="L3094">                p += 2;</span>
<span class="fc" id="L3095">                int q = scan(p, n, &quot;&quot;, &quot;/?#&quot;);</span>
<span class="fc bfc" id="L3096" title="All 2 branches covered.">                if (q &gt; p) {</span>
<span class="fc" id="L3097">                    p = parseAuthority(p, q);</span>
<span class="pc bpc" id="L3098" title="1 of 2 branches missed.">                } else if (q &lt; n) {</span>
                    // DEVIATION: Allow empty authority prior to non-empty
                    // path, query component or fragment identifier
                } else
<span class="nc" id="L3102">                    failExpecting(&quot;authority&quot;, p);</span>
            }
<span class="fc" id="L3104">            int q = scan(p, n, &quot;&quot;, &quot;?#&quot;); // DEVIATION: May be empty</span>
<span class="fc" id="L3105">            checkChars(p, q, L_PATH, H_PATH, &quot;path&quot;);</span>
<span class="fc" id="L3106">            path = substring(p, q);</span>
<span class="fc" id="L3107">            p = q;</span>
<span class="fc bfc" id="L3108" title="All 2 branches covered.">            if (at(p, n, '?')) {</span>
<span class="fc" id="L3109">                p++;</span>
<span class="fc" id="L3110">                q = scan(p, n, &quot;&quot;, &quot;#&quot;);</span>
<span class="fc" id="L3111">                checkChars(p, q, L_URIC, H_URIC, &quot;query&quot;);</span>
<span class="fc" id="L3112">                query = substring(p, q);</span>
<span class="fc" id="L3113">                p = q;</span>
            }
<span class="fc" id="L3115">            return p;</span>
        }

        // authority     = server | reg_name
        //
        // Ambiguity: An authority that is a registry name rather than a server
        // might have a prefix that parses as a server.  We use the fact that
        // the authority component is always followed by '/' or the end of the
        // input string to resolve this: If the complete authority did not
        // parse as a server then we try to parse it as a registry name.
        //
        private int parseAuthority(int start, int n)
            throws URISyntaxException
        {
<span class="fc" id="L3129">            int p = start;</span>
<span class="fc" id="L3130">            int q = p;</span>
<span class="fc" id="L3131">            URISyntaxException ex = null;</span>

            boolean serverChars;
            boolean regChars;

<span class="pc bpc" id="L3136" title="1 of 2 branches missed.">            if (scan(p, n, &quot;&quot;, &quot;]&quot;) &gt; p) {</span>
                // contains a literal IPv6 address, therefore % is allowed
<span class="pc bpc" id="L3138" title="1 of 2 branches missed.">                serverChars = (scan(p, n, L_SERVER_PERCENT, H_SERVER_PERCENT) == n);</span>
            } else {
<span class="nc bnc" id="L3140" title="All 2 branches missed.">                serverChars = (scan(p, n, L_SERVER, H_SERVER) == n);</span>
            }
<span class="fc bfc" id="L3142" title="All 2 branches covered.">            regChars = (scan(p, n, L_REG_NAME, H_REG_NAME) == n);</span>

<span class="pc bpc" id="L3144" title="1 of 4 branches missed.">            if (regChars &amp;&amp; !serverChars) {</span>
                // Must be a registry-based authority
<span class="nc" id="L3146">                authority = substring(p, n);</span>
<span class="nc" id="L3147">                return n;</span>
            }

<span class="pc bpc" id="L3150" title="1 of 2 branches missed.">            if (serverChars) {</span>
                // Might be (probably is) a server-based authority, so attempt
                // to parse it as such.  If the attempt fails, try to treat it
                // as a registry-based authority.
                try {
<span class="fc" id="L3155">                    q = parseServer(p, n);</span>
<span class="pc bpc" id="L3156" title="1 of 2 branches missed.">                    if (q &lt; n)</span>
<span class="nc" id="L3157">                        failExpecting(&quot;end of authority&quot;, q);</span>
<span class="fc" id="L3158">                    authority = substring(p, n);</span>
<span class="fc" id="L3159">                } catch (URISyntaxException x) {</span>
                    // Undo results of failed parse
<span class="fc" id="L3161">                    userInfo = null;</span>
<span class="fc" id="L3162">                    host = null;</span>
<span class="fc" id="L3163">                    port = -1;</span>
<span class="fc bfc" id="L3164" title="All 2 branches covered.">                    if (requireServerAuthority) {</span>
                        // If we're insisting upon a server-based authority,
                        // then just re-throw the exception
<span class="fc" id="L3167">                        throw x;</span>
                    } else {
                        // Save the exception in case it doesn't parse as a
                        // registry either
<span class="fc" id="L3171">                        ex = x;</span>
<span class="fc" id="L3172">                        q = p;</span>
                    }
<span class="fc" id="L3174">                }</span>
            }

<span class="fc bfc" id="L3177" title="All 2 branches covered.">            if (q &lt; n) {</span>
<span class="fc bfc" id="L3178" title="All 2 branches covered.">                if (regChars) {</span>
                    // Registry-based authority
<span class="fc" id="L3180">                    authority = substring(p, n);</span>
<span class="pc bpc" id="L3181" title="1 of 2 branches missed.">                } else if (ex != null) {</span>
                    // Re-throw exception; it was probably due to
                    // a malformed IPv6 address
<span class="fc" id="L3184">                    throw ex;</span>
                } else {
<span class="nc" id="L3186">                    fail(&quot;Illegal character in authority&quot;, q);</span>
                }
            }

<span class="fc" id="L3190">            return n;</span>
        }


        // [&lt;userinfo&gt;@]&lt;host&gt;[:&lt;port&gt;]
        //
        private int parseServer(int start, int n)
            throws URISyntaxException
        {
<span class="fc" id="L3199">            int p = start;</span>
            int q;

            // userinfo
<span class="fc" id="L3203">            q = scan(p, n, &quot;/?#&quot;, &quot;@&quot;);</span>
<span class="pc bpc" id="L3204" title="1 of 4 branches missed.">            if ((q &gt;= p) &amp;&amp; at(q, n, '@')) {</span>
<span class="fc" id="L3205">                checkChars(p, q, L_USERINFO, H_USERINFO, &quot;user info&quot;);</span>
<span class="fc" id="L3206">                userInfo = substring(p, q);</span>
<span class="fc" id="L3207">                p = q + 1;              // Skip '@'</span>
            }

            // hostname, IPv4 address, or IPv6 address
<span class="fc bfc" id="L3211" title="All 2 branches covered.">            if (at(p, n, '[')) {</span>
                // DEVIATION from RFC2396: Support IPv6 addresses, per RFC2732
<span class="fc" id="L3213">                p++;</span>
<span class="fc" id="L3214">                q = scan(p, n, &quot;/?#&quot;, &quot;]&quot;);</span>
<span class="fc bfc" id="L3215" title="All 4 branches covered.">                if ((q &gt; p) &amp;&amp; at(q, n, ']')) {</span>
                    // look for a &quot;%&quot; scope id
<span class="fc" id="L3217">                    int r = scan (p, q, &quot;&quot;, &quot;%&quot;);</span>
<span class="pc bpc" id="L3218" title="1 of 2 branches missed.">                    if (r &gt; p) {</span>
<span class="fc" id="L3219">                        parseIPv6Reference(p, r);</span>
<span class="pc bpc" id="L3220" title="1 of 2 branches missed.">                        if (r+1 == q) {</span>
<span class="nc" id="L3221">                            fail (&quot;scope id expected&quot;);</span>
                        }
<span class="fc" id="L3223">                        checkChars (r+1, q, L_ALPHANUM, H_ALPHANUM,</span>
                                                &quot;scope id&quot;);
                    } else {
<span class="nc" id="L3226">                        parseIPv6Reference(p, q);</span>
                    }
<span class="fc" id="L3228">                    host = substring(p-1, q+1);</span>
<span class="fc" id="L3229">                    p = q + 1;</span>
<span class="fc" id="L3230">                } else {</span>
<span class="nc" id="L3231">                    failExpecting(&quot;closing bracket for IPv6 address&quot;, q);</span>
                }
            } else {
<span class="fc" id="L3234">                q = parseIPv4Address(p, n);</span>
<span class="fc bfc" id="L3235" title="All 2 branches covered.">                if (q &lt;= p)</span>
<span class="fc" id="L3236">                    q = parseHostname(p, n);</span>
<span class="fc" id="L3237">                p = q;</span>
            }

            // port
<span class="fc bfc" id="L3241" title="All 2 branches covered.">            if (at(p, n, ':')) {</span>
<span class="fc" id="L3242">                p++;</span>
<span class="fc" id="L3243">                q = scan(p, n, &quot;&quot;, &quot;/&quot;);</span>
<span class="fc bfc" id="L3244" title="All 2 branches covered.">                if (q &gt; p) {</span>
<span class="fc" id="L3245">                    checkChars(p, q, L_DIGIT, H_DIGIT, &quot;port number&quot;);</span>
                    try {
<span class="fc" id="L3247">                        port = Integer.parseInt(substring(p, q));</span>
<span class="nc" id="L3248">                    } catch (NumberFormatException x) {</span>
<span class="nc" id="L3249">                        fail(&quot;Malformed port number&quot;, p);</span>
<span class="fc" id="L3250">                    }</span>
<span class="fc" id="L3251">                    p = q;</span>
                }
            }
<span class="pc bpc" id="L3254" title="1 of 2 branches missed.">            if (p &lt; n)</span>
<span class="nc" id="L3255">                failExpecting(&quot;port number&quot;, p);</span>

<span class="fc" id="L3257">            return p;</span>
        }

        // Scan a string of decimal digits whose value fits in a byte
        //
        private int scanByte(int start, int n)
            throws URISyntaxException
        {
<span class="fc" id="L3265">            int p = start;</span>
<span class="fc" id="L3266">            int q = scan(p, n, L_DIGIT, H_DIGIT);</span>
<span class="fc bfc" id="L3267" title="All 2 branches covered.">            if (q &lt;= p) return q;</span>
<span class="fc bfc" id="L3268" title="All 2 branches covered.">            if (Integer.parseInt(substring(p, q)) &gt; 255) return p;</span>
<span class="fc" id="L3269">            return q;</span>
        }

        // Scan an IPv4 address.
        //
        // If the strict argument is true then we require that the given
        // interval contain nothing besides an IPv4 address; if it is false
        // then we only require that it start with an IPv4 address.
        //
        // If the interval does not contain or start with (depending upon the
        // strict argument) a legal IPv4 address characters then we return -1
        // immediately; otherwise we insist that these characters parse as a
        // legal IPv4 address and throw an exception on failure.
        //
        // We assume that any string of decimal digits and dots must be an IPv4
        // address.  It won't parse as a hostname anyway, so making that
        // assumption here allows more meaningful exceptions to be thrown.
        //
        private int scanIPv4Address(int start, int n, boolean strict)
            throws URISyntaxException
        {
<span class="fc" id="L3290">            int p = start;</span>
            int q;
<span class="fc" id="L3292">            int m = scan(p, n, L_DIGIT | L_DOT, H_DIGIT | H_DOT);</span>
<span class="pc bpc" id="L3293" title="1 of 6 branches missed.">            if ((m &lt;= p) || (strict &amp;&amp; (m != n)))</span>
<span class="fc" id="L3294">                return -1;</span>
            for (;;) {
                // Per RFC2732: At most three digits per byte
                // Further constraint: Each element fits in a byte
<span class="fc bfc" id="L3298" title="All 2 branches covered.">                if ((q = scanByte(p, m)) &lt;= p) break;   p = q;</span>
<span class="fc bfc" id="L3299" title="All 2 branches covered.">                if ((q = scan(p, m, '.')) &lt;= p) break;  p = q;</span>
<span class="pc bpc" id="L3300" title="1 of 2 branches missed.">                if ((q = scanByte(p, m)) &lt;= p) break;   p = q;</span>
<span class="fc bfc" id="L3301" title="All 2 branches covered.">                if ((q = scan(p, m, '.')) &lt;= p) break;  p = q;</span>
<span class="pc bpc" id="L3302" title="1 of 2 branches missed.">                if ((q = scanByte(p, m)) &lt;= p) break;   p = q;</span>
<span class="fc bfc" id="L3303" title="All 2 branches covered.">                if ((q = scan(p, m, '.')) &lt;= p) break;  p = q;</span>
<span class="fc bfc" id="L3304" title="All 2 branches covered.">                if ((q = scanByte(p, m)) &lt;= p) break;   p = q;</span>
<span class="fc bfc" id="L3305" title="All 2 branches covered.">                if (q &lt; m) break;</span>
<span class="fc" id="L3306">                return q;</span>
            }
<span class="nc" id="L3308">            fail(&quot;Malformed IPv4 address&quot;, q);</span>
<span class="nc" id="L3309">            return -1;</span>
        }

        // Take an IPv4 address: Throw an exception if the given interval
        // contains anything except an IPv4 address
        //
        private int takeIPv4Address(int start, int n, String expected)
            throws URISyntaxException
        {
<span class="fc" id="L3318">            int p = scanIPv4Address(start, n, true);</span>
<span class="pc bpc" id="L3319" title="1 of 2 branches missed.">            if (p &lt;= start)</span>
<span class="nc" id="L3320">                failExpecting(expected, start);</span>
<span class="fc" id="L3321">            return p;</span>
        }

        // Attempt to parse an IPv4 address, returning -1 on failure but
        // allowing the given interval to contain [:&lt;characters&gt;] after
        // the IPv4 address.
        //
        private int parseIPv4Address(int start, int n) {
            int p;

            try {
<span class="fc" id="L3332">                p = scanIPv4Address(start, n, false);</span>
<span class="fc" id="L3333">            } catch (URISyntaxException x) {</span>
<span class="fc" id="L3334">                return -1;</span>
<span class="nc" id="L3335">            } catch (NumberFormatException nfe) {</span>
<span class="nc" id="L3336">                return -1;</span>
<span class="fc" id="L3337">            }</span>

<span class="fc bfc" id="L3339" title="All 4 branches covered.">            if (p &gt; start &amp;&amp; p &lt; n) {</span>
                // IPv4 address is followed by something - check that
                // it's a &quot;:&quot; as this is the only valid character to
                // follow an address.
<span class="fc bfc" id="L3343" title="All 2 branches covered.">                if (charAt(p) != ':') {</span>
<span class="fc" id="L3344">                    p = -1;</span>
                }
            }

<span class="fc bfc" id="L3348" title="All 2 branches covered.">            if (p &gt; start)</span>
<span class="fc" id="L3349">                host = substring(start, p);</span>

<span class="fc" id="L3351">            return p;</span>
        }

        // hostname      = domainlabel [ &quot;.&quot; ] | 1*( domainlabel &quot;.&quot; ) toplabel [ &quot;.&quot; ]
        // domainlabel   = alphanum | alphanum *( alphanum | &quot;-&quot; ) alphanum
        // toplabel      = alpha | alpha *( alphanum | &quot;-&quot; ) alphanum
        //
        private int parseHostname(int start, int n)
            throws URISyntaxException
        {
<span class="fc" id="L3361">            int p = start;</span>
            int q;
<span class="fc" id="L3363">            int l = -1;                 // Start of last parsed label</span>

            do {
                // domainlabel = alphanum [ *( alphanum | &quot;-&quot; ) alphanum ]
<span class="fc" id="L3367">                q = scan(p, n, L_ALPHANUM, H_ALPHANUM);</span>
<span class="fc bfc" id="L3368" title="All 2 branches covered.">                if (q &lt;= p)</span>
<span class="fc" id="L3369">                    break;</span>
<span class="fc" id="L3370">                l = p;</span>
<span class="pc bpc" id="L3371" title="1 of 2 branches missed.">                if (q &gt; p) {</span>
<span class="fc" id="L3372">                    p = q;</span>
<span class="fc" id="L3373">                    q = scan(p, n, L_ALPHANUM | L_DASH, H_ALPHANUM | H_DASH);</span>
<span class="fc bfc" id="L3374" title="All 2 branches covered.">                    if (q &gt; p) {</span>
<span class="pc bpc" id="L3375" title="1 of 2 branches missed.">                        if (charAt(q - 1) == '-')</span>
<span class="nc" id="L3376">                            fail(&quot;Illegal character in hostname&quot;, q - 1);</span>
<span class="fc" id="L3377">                        p = q;</span>
                    }
                }
<span class="fc" id="L3380">                q = scan(p, n, '.');</span>
<span class="fc bfc" id="L3381" title="All 2 branches covered.">                if (q &lt;= p)</span>
<span class="fc" id="L3382">                    break;</span>
<span class="fc" id="L3383">                p = q;</span>
<span class="fc bfc" id="L3384" title="All 2 branches covered.">            } while (p &lt; n);</span>

<span class="pc bpc" id="L3386" title="1 of 4 branches missed.">            if ((p &lt; n) &amp;&amp; !at(p, n, ':'))</span>
<span class="nc" id="L3387">                fail(&quot;Illegal character in hostname&quot;, p);</span>

<span class="pc bpc" id="L3389" title="1 of 2 branches missed.">            if (l &lt; 0)</span>
<span class="nc" id="L3390">                failExpecting(&quot;hostname&quot;, start);</span>

            // for a fully qualified hostname check that the rightmost
            // label starts with an alpha character.
<span class="pc bpc" id="L3394" title="1 of 4 branches missed.">            if (l &gt; start &amp;&amp; !match(charAt(l), L_ALPHA, H_ALPHA)) {</span>
<span class="nc" id="L3395">                fail(&quot;Illegal character in hostname&quot;, l);</span>
            }

<span class="fc" id="L3398">            host = substring(start, p);</span>
<span class="fc" id="L3399">            return p;</span>
        }


        // IPv6 address parsing, from RFC2373: IPv6 Addressing Architecture
        //
        // Bug: The grammar in RFC2373 Appendix B does not allow addresses of
        // the form ::12.34.56.78, which are clearly shown in the examples
        // earlier in the document.  Here is the original grammar:
        //
        //   IPv6address = hexpart [ &quot;:&quot; IPv4address ]
        //   hexpart     = hexseq | hexseq &quot;::&quot; [ hexseq ] | &quot;::&quot; [ hexseq ]
        //   hexseq      = hex4 *( &quot;:&quot; hex4)
        //   hex4        = 1*4HEXDIG
        //
        // We therefore use the following revised grammar:
        //
        //   IPv6address = hexseq [ &quot;:&quot; IPv4address ]
        //                 | hexseq [ &quot;::&quot; [ hexpost ] ]
        //                 | &quot;::&quot; [ hexpost ]
        //   hexpost     = hexseq | hexseq &quot;:&quot; IPv4address | IPv4address
        //   hexseq      = hex4 *( &quot;:&quot; hex4)
        //   hex4        = 1*4HEXDIG
        //
        // This covers all and only the following cases:
        //
        //   hexseq
        //   hexseq : IPv4address
        //   hexseq ::
        //   hexseq :: hexseq
        //   hexseq :: hexseq : IPv4address
        //   hexseq :: IPv4address
        //   :: hexseq
        //   :: hexseq : IPv4address
        //   :: IPv4address
        //   ::
        //
        // Additionally we constrain the IPv6 address as follows :-
        //
        //  i.  IPv6 addresses without compressed zeros should contain
        //      exactly 16 bytes.
        //
        //  ii. IPv6 addresses with compressed zeros should contain
        //      less than 16 bytes.

<span class="fc" id="L3444">        private int ipv6byteCount = 0;</span>

        private int parseIPv6Reference(int start, int n)
            throws URISyntaxException
        {
<span class="fc" id="L3449">            int p = start;</span>
            int q;
<span class="fc" id="L3451">            boolean compressedZeros = false;</span>

<span class="fc" id="L3453">            q = scanHexSeq(p, n);</span>

<span class="fc bfc" id="L3455" title="All 2 branches covered.">            if (q &gt; p) {</span>
<span class="fc" id="L3456">                p = q;</span>
<span class="fc bfc" id="L3457" title="All 2 branches covered.">                if (at(p, n, &quot;::&quot;)) {</span>
<span class="fc" id="L3458">                    compressedZeros = true;</span>
<span class="fc" id="L3459">                    p = scanHexPost(p + 2, n);</span>
<span class="fc bfc" id="L3460" title="All 2 branches covered.">                } else if (at(p, n, ':')) {</span>
<span class="fc" id="L3461">                    p = takeIPv4Address(p + 1,  n, &quot;IPv4 address&quot;);</span>
<span class="fc" id="L3462">                    ipv6byteCount += 4;</span>
                }
<span class="fc bfc" id="L3464" title="All 2 branches covered.">            } else if (at(p, n, &quot;::&quot;)) {</span>
<span class="fc" id="L3465">                compressedZeros = true;</span>
<span class="fc" id="L3466">                p = scanHexPost(p + 2, n);</span>
            }
<span class="pc bpc" id="L3468" title="1 of 2 branches missed.">            if (p &lt; n)</span>
<span class="nc" id="L3469">                fail(&quot;Malformed IPv6 address&quot;, start);</span>
<span class="pc bpc" id="L3470" title="1 of 2 branches missed.">            if (ipv6byteCount &gt; 16)</span>
<span class="nc" id="L3471">                fail(&quot;IPv6 address too long&quot;, start);</span>
<span class="pc bpc" id="L3472" title="1 of 4 branches missed.">            if (!compressedZeros &amp;&amp; ipv6byteCount &lt; 16)</span>
<span class="nc" id="L3473">                fail(&quot;IPv6 address too short&quot;, start);</span>
<span class="pc bpc" id="L3474" title="1 of 4 branches missed.">            if (compressedZeros &amp;&amp; ipv6byteCount == 16)</span>
<span class="nc" id="L3475">                fail(&quot;Malformed IPv6 address&quot;, start);</span>

<span class="fc" id="L3477">            return p;</span>
        }

        private int scanHexPost(int start, int n)
            throws URISyntaxException
        {
<span class="fc" id="L3483">            int p = start;</span>
            int q;

<span class="fc bfc" id="L3486" title="All 2 branches covered.">            if (p == n)</span>
<span class="fc" id="L3487">                return p;</span>

<span class="fc" id="L3489">            q = scanHexSeq(p, n);</span>
<span class="fc bfc" id="L3490" title="All 2 branches covered.">            if (q &gt; p) {</span>
<span class="fc" id="L3491">                p = q;</span>
<span class="fc bfc" id="L3492" title="All 2 branches covered.">                if (at(p, n, ':')) {</span>
<span class="fc" id="L3493">                    p++;</span>
<span class="fc" id="L3494">                    p = takeIPv4Address(p, n, &quot;hex digits or IPv4 address&quot;);</span>
<span class="fc" id="L3495">                    ipv6byteCount += 4;</span>
                }
            } else {
<span class="fc" id="L3498">                p = takeIPv4Address(p, n, &quot;hex digits or IPv4 address&quot;);</span>
<span class="fc" id="L3499">                ipv6byteCount += 4;</span>
            }
<span class="fc" id="L3501">            return p;</span>
        }

        // Scan a hex sequence; return -1 if one could not be scanned
        //
        private int scanHexSeq(int start, int n)
            throws URISyntaxException
        {
<span class="fc" id="L3509">            int p = start;</span>
            int q;

<span class="fc" id="L3512">            q = scan(p, n, L_HEX, H_HEX);</span>
<span class="fc bfc" id="L3513" title="All 2 branches covered.">            if (q &lt;= p)</span>
<span class="fc" id="L3514">                return -1;</span>
<span class="fc bfc" id="L3515" title="All 2 branches covered.">            if (at(q, n, '.'))          // Beginning of IPv4 address</span>
<span class="fc" id="L3516">                return -1;</span>
<span class="pc bpc" id="L3517" title="1 of 2 branches missed.">            if (q &gt; p + 4)</span>
<span class="nc" id="L3518">                fail(&quot;IPv6 hexadecimal digit sequence too long&quot;, p);</span>
<span class="fc" id="L3519">            ipv6byteCount += 2;</span>
<span class="fc" id="L3520">            p = q;</span>
<span class="fc bfc" id="L3521" title="All 2 branches covered.">            while (p &lt; n) {</span>
<span class="fc bfc" id="L3522" title="All 2 branches covered.">                if (!at(p, n, ':'))</span>
<span class="fc" id="L3523">                    break;</span>
<span class="fc bfc" id="L3524" title="All 2 branches covered.">                if (at(p + 1, n, ':'))</span>
<span class="fc" id="L3525">                    break;              // &quot;::&quot;</span>
<span class="fc" id="L3526">                p++;</span>
<span class="fc" id="L3527">                q = scan(p, n, L_HEX, H_HEX);</span>
<span class="pc bpc" id="L3528" title="1 of 2 branches missed.">                if (q &lt;= p)</span>
<span class="nc" id="L3529">                    failExpecting(&quot;digits for an IPv6 address&quot;, p);</span>
<span class="fc bfc" id="L3530" title="All 2 branches covered.">                if (at(q, n, '.')) {    // Beginning of IPv4 address</span>
<span class="fc" id="L3531">                    p--;</span>
<span class="fc" id="L3532">                    break;</span>
                }
<span class="pc bpc" id="L3534" title="1 of 2 branches missed.">                if (q &gt; p + 4)</span>
<span class="nc" id="L3535">                    fail(&quot;IPv6 hexadecimal digit sequence too long&quot;, p);</span>
<span class="fc" id="L3536">                ipv6byteCount += 2;</span>
<span class="fc" id="L3537">                p = q;</span>
            }

<span class="fc" id="L3540">            return p;</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>