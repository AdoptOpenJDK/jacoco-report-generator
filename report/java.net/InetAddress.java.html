<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>InetAddress.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">InetAddress.java</span></div><h1>InetAddress.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Random;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.ServiceLoader;
import java.security.AccessController;
import java.io.ObjectStreamException;
import java.io.ObjectStreamField;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectInputStream.GetField;
import java.io.ObjectOutputStream;
import java.io.ObjectOutputStream.PutField;
import sun.security.action.*;
import sun.net.InetAddressCachePolicy;
import sun.net.util.IPAddressUtil;
import sun.net.spi.nameservice.*;

/**
 * This class represents an Internet Protocol (IP) address.
 *
 * &lt;p&gt; An IP address is either a 32-bit or 128-bit unsigned number
 * used by IP, a lower-level protocol on which protocols like UDP and
 * TCP are built. The IP address architecture is defined by &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc790.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;790:
 * Assigned Numbers&lt;/i&gt;&lt;/a&gt;, &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc1918.txt&quot;&gt; &lt;i&gt;RFC&amp;nbsp;1918:
 * Address Allocation for Private Internets&lt;/i&gt;&lt;/a&gt;, &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2365.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2365:
 * Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;, and &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IP
 * Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;. An instance of an
 * InetAddress consists of an IP address and possibly its
 * corresponding host name (depending on whether it is constructed
 * with a host name or whether it has already done reverse host name
 * resolution).
 *
 * &lt;h3&gt; Address types &lt;/h3&gt;
 *
 * &lt;blockquote&gt;&lt;table cellspacing=2 summary=&quot;Description of unicast and multicast address types&quot;&gt;
 *   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;unicast&lt;/i&gt;&lt;/th&gt;
 *       &lt;td&gt;An identifier for a single interface. A packet sent to
 *         a unicast address is delivered to the interface identified by
 *         that address.
 *
 *         &lt;p&gt; The Unspecified Address -- Also called anylocal or wildcard
 *         address. It must never be assigned to any node. It indicates the
 *         absence of an address. One example of its use is as the target of
 *         bind, which allows a server to accept a client connection on any
 *         interface, in case the server host has multiple interfaces.
 *
 *         &lt;p&gt; The &lt;i&gt;unspecified&lt;/i&gt; address must not be used as
 *         the destination address of an IP packet.
 *
 *         &lt;p&gt; The &lt;i&gt;Loopback&lt;/i&gt; Addresses -- This is the address
 *         assigned to the loopback interface. Anything sent to this
 *         IP address loops around and becomes IP input on the local
 *         host. This address is often used when testing a
 *         client.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;multicast&lt;/i&gt;&lt;/th&gt;
 *       &lt;td&gt;An identifier for a set of interfaces (typically belonging
 *         to different nodes). A packet sent to a multicast address is
 *         delivered to all interfaces identified by that address.&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;&lt;/blockquote&gt;
 *
 * &lt;h4&gt; IP address scope &lt;/h4&gt;
 *
 * &lt;p&gt; &lt;i&gt;Link-local&lt;/i&gt; addresses are designed to be used for addressing
 * on a single link for purposes such as auto-address configuration,
 * neighbor discovery, or when no routers are present.
 *
 * &lt;p&gt; &lt;i&gt;Site-local&lt;/i&gt; addresses are designed to be used for addressing
 * inside of a site without the need for a global prefix.
 *
 * &lt;p&gt; &lt;i&gt;Global&lt;/i&gt; addresses are unique across the internet.
 *
 * &lt;h4&gt; Textual representation of IP addresses &lt;/h4&gt;
 *
 * The textual representation of an IP address is address family specific.
 *
 * &lt;p&gt;
 *
 * For IPv4 address format, please refer to &lt;A
 * HREF=&quot;Inet4Address.html#format&quot;&gt;Inet4Address#format&lt;/A&gt;; For IPv6
 * address format, please refer to &lt;A
 * HREF=&quot;Inet6Address.html#format&quot;&gt;Inet6Address#format&lt;/A&gt;.
 *
 * &lt;P&gt;There is a &lt;a href=&quot;doc-files/net-properties.html#Ipv4IPv6&quot;&gt;couple of
 * System Properties&lt;/a&gt; affecting how IPv4 and IPv6 addresses are used.&lt;/P&gt;
 *
 * &lt;h4&gt; Host Name Resolution &lt;/h4&gt;
 *
 * Host name-to-IP address &lt;i&gt;resolution&lt;/i&gt; is accomplished through
 * the use of a combination of local machine configuration information
 * and network naming services such as the Domain Name System (DNS)
 * and Network Information Service(NIS). The particular naming
 * services(s) being used is by default the local machine configured
 * one. For any host name, its corresponding IP address is returned.
 *
 * &lt;p&gt; &lt;i&gt;Reverse name resolution&lt;/i&gt; means that for any IP address,
 * the host associated with the IP address is returned.
 *
 * &lt;p&gt; The InetAddress class provides methods to resolve host names to
 * their IP addresses and vice versa.
 *
 * &lt;h4&gt; InetAddress Caching &lt;/h4&gt;
 *
 * The InetAddress class has a cache to store successful as well as
 * unsuccessful host name resolutions.
 *
 * &lt;p&gt; By default, when a security manager is installed, in order to
 * protect against DNS spoofing attacks,
 * the result of positive host name resolutions are
 * cached forever. When a security manager is not installed, the default
 * behavior is to cache entries for a finite (implementation dependent)
 * period of time. The result of unsuccessful host
 * name resolution is cached for a very short period of time (10
 * seconds) to improve performance.
 *
 * &lt;p&gt; If the default behavior is not desired, then a Java security property
 * can be set to a different Time-to-live (TTL) value for positive
 * caching. Likewise, a system admin can configure a different
 * negative caching TTL value when needed.
 *
 * &lt;p&gt; Two Java security properties control the TTL values used for
 *  positive and negative host name resolution caching:
 *
 * &lt;blockquote&gt;
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;b&gt;networkaddress.cache.ttl&lt;/b&gt;&lt;/dt&gt;
 * &lt;dd&gt;Indicates the caching policy for successful name lookups from
 * the name service. The value is specified as as integer to indicate
 * the number of seconds to cache the successful lookup. The default
 * setting is to cache for an implementation specific period of time.
 * &lt;p&gt;
 * A value of -1 indicates &quot;cache forever&quot;.
 * &lt;/dd&gt;
 * &lt;dt&gt;&lt;b&gt;networkaddress.cache.negative.ttl&lt;/b&gt; (default: 10)&lt;/dt&gt;
 * &lt;dd&gt;Indicates the caching policy for un-successful name lookups
 * from the name service. The value is specified as as integer to
 * indicate the number of seconds to cache the failure for
 * un-successful lookups.
 * &lt;p&gt;
 * A value of 0 indicates &quot;never cache&quot;.
 * A value of -1 indicates &quot;cache forever&quot;.
 * &lt;/dd&gt;
 * &lt;/dl&gt;
 * &lt;/blockquote&gt;
 *
 * @author  Chris Warth
 * @see     java.net.InetAddress#getByAddress(byte[])
 * @see     java.net.InetAddress#getByAddress(java.lang.String, byte[])
 * @see     java.net.InetAddress#getAllByName(java.lang.String)
 * @see     java.net.InetAddress#getByName(java.lang.String)
 * @see     java.net.InetAddress#getLocalHost()
 * @since JDK1.0
 */
<span class="nc bnc" id="L188" title="All 2 branches missed.">public</span>
class InetAddress implements java.io.Serializable {
    /**
     * Specify the address family: Internet Protocol, Version 4
     * @since 1.4
     */
    static final int IPv4 = 1;

    /**
     * Specify the address family: Internet Protocol, Version 6
     * @since 1.4
     */
    static final int IPv6 = 2;

    /* Specify address family preference */
<span class="nc" id="L203">    static transient boolean preferIPv6Address = false;</span>

    static class InetAddressHolder {

<span class="nc" id="L207">        InetAddressHolder() {}</span>

<span class="nc" id="L209">        InetAddressHolder(String hostName, int address, int family) {</span>
<span class="nc" id="L210">            this.hostName = hostName;</span>
<span class="nc" id="L211">            this.address = address;</span>
<span class="nc" id="L212">            this.family = family;</span>
<span class="nc" id="L213">        }</span>

        void init(String hostName, int family) {
<span class="nc" id="L216">            this.hostName = hostName;</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">            if (family != -1) {</span>
<span class="nc" id="L218">                this.family = family;</span>
            }
<span class="nc" id="L220">        }</span>

        String hostName;

        String getHostName() {
<span class="nc" id="L225">            return hostName;</span>
        }

        /**
         * Holds a 32-bit IPv4 address.
         */
        int address;

        int getAddress() {
<span class="nc" id="L234">            return address;</span>
        }

        /**
         * Specifies the address family type, for instance, '1' for IPv4
         * addresses, and '2' for IPv6 addresses.
         */
        int family;

        int getFamily() {
<span class="nc" id="L244">            return family;</span>
        }
    }

    /* Used to store the serializable fields of InetAddress */
    final transient InetAddressHolder holder;

    InetAddressHolder holder() {
<span class="nc" id="L252">        return holder;</span>
    }

    /* Used to store the name service provider */
<span class="nc" id="L256">    private static List&lt;NameService&gt; nameServices = null;</span>

    /* Used to store the best available hostname */
<span class="nc" id="L259">    private transient String canonicalHostName = null;</span>

    /** use serialVersionUID from JDK 1.0.2 for interoperability */
    private static final long serialVersionUID = 3286316764910316507L;

    /*
     * Load net library into runtime, and perform initializations.
     */
    static {
<span class="nc" id="L268">        preferIPv6Address = java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L269">            new GetBooleanAction(&quot;java.net.preferIPv6Addresses&quot;)).booleanValue();</span>
<span class="nc" id="L270">        AccessController.doPrivileged(</span>
<span class="nc" id="L271">            new java.security.PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
<span class="nc" id="L273">                    System.loadLibrary(&quot;net&quot;);</span>
<span class="nc" id="L274">                    return null;</span>
                }
            });
<span class="nc" id="L277">        init();</span>
    }

    /**
     * Constructor for the Socket.accept() method.
     * This creates an empty InetAddress, which is filled in by
     * the accept() method.  This InetAddress, however, is not
     * put in the address cache, since it is not created by name.
     */
<span class="nc" id="L286">    InetAddress() {</span>
<span class="nc" id="L287">        holder = new InetAddressHolder();</span>
<span class="nc" id="L288">    }</span>

    /**
     * Replaces the de-serialized object with an Inet4Address object.
     *
     * @return the alternate object to the de-serialized object.
     *
     * @throws ObjectStreamException if a new object replacing this
     * object could not be created
     */
    private Object readResolve() throws ObjectStreamException {
        // will replace the deserialized 'this' object
<span class="nc" id="L300">        return new Inet4Address(holder().getHostName(), holder().getAddress());</span>
    }

    /**
     * Utility routine to check if the InetAddress is an
     * IP multicast address.
     * @return a {@code boolean} indicating if the InetAddress is
     * an IP multicast address
     * @since   JDK1.1
     */
    public boolean isMulticastAddress() {
<span class="nc" id="L311">        return false;</span>
    }

    /**
     * Utility routine to check if the InetAddress in a wildcard address.
     * @return a {@code boolean} indicating if the Inetaddress is
     *         a wildcard address.
     * @since 1.4
     */
    public boolean isAnyLocalAddress() {
<span class="nc" id="L321">        return false;</span>
    }

    /**
     * Utility routine to check if the InetAddress is a loopback address.
     *
     * @return a {@code boolean} indicating if the InetAddress is
     * a loopback address; or false otherwise.
     * @since 1.4
     */
    public boolean isLoopbackAddress() {
<span class="nc" id="L332">        return false;</span>
    }

    /**
     * Utility routine to check if the InetAddress is an link local address.
     *
     * @return a {@code boolean} indicating if the InetAddress is
     * a link local address; or false if address is not a link local unicast address.
     * @since 1.4
     */
    public boolean isLinkLocalAddress() {
<span class="nc" id="L343">        return false;</span>
    }

    /**
     * Utility routine to check if the InetAddress is a site local address.
     *
     * @return a {@code boolean} indicating if the InetAddress is
     * a site local address; or false if address is not a site local unicast address.
     * @since 1.4
     */
    public boolean isSiteLocalAddress() {
<span class="nc" id="L354">        return false;</span>
    }

    /**
     * Utility routine to check if the multicast address has global scope.
     *
     * @return a {@code boolean} indicating if the address has
     *         is a multicast address of global scope, false if it is not
     *         of global scope or it is not a multicast address
     * @since 1.4
     */
    public boolean isMCGlobal() {
<span class="nc" id="L366">        return false;</span>
    }

    /**
     * Utility routine to check if the multicast address has node scope.
     *
     * @return a {@code boolean} indicating if the address has
     *         is a multicast address of node-local scope, false if it is not
     *         of node-local scope or it is not a multicast address
     * @since 1.4
     */
    public boolean isMCNodeLocal() {
<span class="nc" id="L378">        return false;</span>
    }

    /**
     * Utility routine to check if the multicast address has link scope.
     *
     * @return a {@code boolean} indicating if the address has
     *         is a multicast address of link-local scope, false if it is not
     *         of link-local scope or it is not a multicast address
     * @since 1.4
     */
    public boolean isMCLinkLocal() {
<span class="nc" id="L390">        return false;</span>
    }

    /**
     * Utility routine to check if the multicast address has site scope.
     *
     * @return a {@code boolean} indicating if the address has
     *         is a multicast address of site-local scope, false if it is not
     *         of site-local scope or it is not a multicast address
     * @since 1.4
     */
    public boolean isMCSiteLocal() {
<span class="nc" id="L402">        return false;</span>
    }

    /**
     * Utility routine to check if the multicast address has organization scope.
     *
     * @return a {@code boolean} indicating if the address has
     *         is a multicast address of organization-local scope,
     *         false if it is not of organization-local scope
     *         or it is not a multicast address
     * @since 1.4
     */
    public boolean isMCOrgLocal() {
<span class="nc" id="L415">        return false;</span>
    }


    /**
     * Test whether that address is reachable. Best effort is made by the
     * implementation to try to reach the host, but firewalls and server
     * configuration may block requests resulting in a unreachable status
     * while some specific ports may be accessible.
     * A typical implementation will use ICMP ECHO REQUESTs if the
     * privilege can be obtained, otherwise it will try to establish
     * a TCP connection on port 7 (Echo) of the destination host.
     * &lt;p&gt;
     * The timeout value, in milliseconds, indicates the maximum amount of time
     * the try should take. If the operation times out before getting an
     * answer, the host is deemed unreachable. A negative value will result
     * in an IllegalArgumentException being thrown.
     *
     * @param   timeout the time, in milliseconds, before the call aborts
     * @return a {@code boolean} indicating if the address is reachable.
     * @throws IOException if a network error occurs
     * @throws  IllegalArgumentException if {@code timeout} is negative.
     * @since 1.5
     */
    public boolean isReachable(int timeout) throws IOException {
<span class="nc" id="L440">        return isReachable(null, 0 , timeout);</span>
    }

    /**
     * Test whether that address is reachable. Best effort is made by the
     * implementation to try to reach the host, but firewalls and server
     * configuration may block requests resulting in a unreachable status
     * while some specific ports may be accessible.
     * A typical implementation will use ICMP ECHO REQUESTs if the
     * privilege can be obtained, otherwise it will try to establish
     * a TCP connection on port 7 (Echo) of the destination host.
     * &lt;p&gt;
     * The {@code network interface} and {@code ttl} parameters
     * let the caller specify which network interface the test will go through
     * and the maximum number of hops the packets should go through.
     * A negative value for the {@code ttl} will result in an
     * IllegalArgumentException being thrown.
     * &lt;p&gt;
     * The timeout value, in milliseconds, indicates the maximum amount of time
     * the try should take. If the operation times out before getting an
     * answer, the host is deemed unreachable. A negative value will result
     * in an IllegalArgumentException being thrown.
     *
     * @param   netif   the NetworkInterface through which the
     *                    test will be done, or null for any interface
     * @param   ttl     the maximum numbers of hops to try or 0 for the
     *                  default
     * @param   timeout the time, in milliseconds, before the call aborts
     * @throws  IllegalArgumentException if either {@code timeout}
     *                          or {@code ttl} are negative.
     * @return a {@code boolean}indicating if the address is reachable.
     * @throws IOException if a network error occurs
     * @since 1.5
     */
    public boolean isReachable(NetworkInterface netif, int ttl,
                               int timeout) throws IOException {
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (ttl &lt; 0)</span>
<span class="nc" id="L477">            throw new IllegalArgumentException(&quot;ttl can't be negative&quot;);</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (timeout &lt; 0)</span>
<span class="nc" id="L479">            throw new IllegalArgumentException(&quot;timeout can't be negative&quot;);</span>

<span class="nc" id="L481">        return impl.isReachable(this, timeout, netif, ttl);</span>
    }

    /**
     * Gets the host name for this IP address.
     *
     * &lt;p&gt;If this InetAddress was created with a host name,
     * this host name will be remembered and returned;
     * otherwise, a reverse name lookup will be performed
     * and the result will be returned based on the system
     * configured name lookup service. If a lookup of the name service
     * is required, call
     * {@link #getCanonicalHostName() getCanonicalHostName}.
     *
     * &lt;p&gt;If there is a security manager, its
     * {@code checkConnect} method is first called
     * with the hostname and {@code -1}
     * as its arguments to see if the operation is allowed.
     * If the operation is not allowed, it will return
     * the textual representation of the IP address.
     *
     * @return  the host name for this IP address, or if the operation
     *    is not allowed by the security check, the textual
     *    representation of the IP address.
     *
     * @see InetAddress#getCanonicalHostName
     * @see SecurityManager#checkConnect
     */
    public String getHostName() {
<span class="nc" id="L510">        return getHostName(true);</span>
    }

    /**
     * Returns the hostname for this address.
     * If the host is equal to null, then this address refers to any
     * of the local machine's available network addresses.
     * this is package private so SocketPermission can make calls into
     * here without a security check.
     *
     * &lt;p&gt;If there is a security manager, this method first
     * calls its {@code checkConnect} method
     * with the hostname and {@code -1}
     * as its arguments to see if the calling code is allowed to know
     * the hostname for this IP address, i.e., to connect to the host.
     * If the operation is not allowed, it will return
     * the textual representation of the IP address.
     *
     * @return  the host name for this IP address, or if the operation
     *    is not allowed by the security check, the textual
     *    representation of the IP address.
     *
     * @param check make security check if true
     *
     * @see SecurityManager#checkConnect
     */
    String getHostName(boolean check) {
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (holder().getHostName() == null) {</span>
<span class="nc" id="L538">            holder().hostName = InetAddress.getHostFromNameService(this, check);</span>
        }
<span class="nc" id="L540">        return holder().getHostName();</span>
    }

    /**
     * Gets the fully qualified domain name for this IP address.
     * Best effort method, meaning we may not be able to return
     * the FQDN depending on the underlying system configuration.
     *
     * &lt;p&gt;If there is a security manager, this method first
     * calls its {@code checkConnect} method
     * with the hostname and {@code -1}
     * as its arguments to see if the calling code is allowed to know
     * the hostname for this IP address, i.e., to connect to the host.
     * If the operation is not allowed, it will return
     * the textual representation of the IP address.
     *
     * @return  the fully qualified domain name for this IP address,
     *    or if the operation is not allowed by the security check,
     *    the textual representation of the IP address.
     *
     * @see SecurityManager#checkConnect
     *
     * @since 1.4
     */
    public String getCanonicalHostName() {
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (canonicalHostName == null) {</span>
<span class="nc" id="L566">            canonicalHostName =</span>
<span class="nc" id="L567">                InetAddress.getHostFromNameService(this, true);</span>
        }
<span class="nc" id="L569">        return canonicalHostName;</span>
    }

    /**
     * Returns the hostname for this address.
     *
     * &lt;p&gt;If there is a security manager, this method first
     * calls its {@code checkConnect} method
     * with the hostname and {@code -1}
     * as its arguments to see if the calling code is allowed to know
     * the hostname for this IP address, i.e., to connect to the host.
     * If the operation is not allowed, it will return
     * the textual representation of the IP address.
     *
     * @return  the host name for this IP address, or if the operation
     *    is not allowed by the security check, the textual
     *    representation of the IP address.
     *
     * @param check make security check if true
     *
     * @see SecurityManager#checkConnect
     */
    private static String getHostFromNameService(InetAddress addr, boolean check) {
<span class="nc" id="L592">        String host = null;</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">        for (NameService nameService : nameServices) {</span>
            try {
                // first lookup the hostname
<span class="nc" id="L596">                host = nameService.getHostByAddr(addr.getAddress());</span>

                /* check to see if calling code is allowed to know
                 * the hostname for this IP address, ie, connect to the host
                 */
<span class="nc bnc" id="L601" title="All 2 branches missed.">                if (check) {</span>
<span class="nc" id="L602">                    SecurityManager sec = System.getSecurityManager();</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                    if (sec != null) {</span>
<span class="nc" id="L604">                        sec.checkConnect(host, -1);</span>
                    }
                }

                /* now get all the IP addresses for this hostname,
                 * and make sure one of them matches the original IP
                 * address. We do this to try and prevent spoofing.
                 */

<span class="nc" id="L613">                InetAddress[] arr = InetAddress.getAllByName0(host, check);</span>
<span class="nc" id="L614">                boolean ok = false;</span>

<span class="nc bnc" id="L616" title="All 2 branches missed.">                if(arr != null) {</span>
<span class="nc bnc" id="L617" title="All 4 branches missed.">                    for(int i = 0; !ok &amp;&amp; i &lt; arr.length; i++) {</span>
<span class="nc" id="L618">                        ok = addr.equals(arr[i]);</span>
                    }
                }

                //XXX: if it looks a spoof just return the address?
<span class="nc bnc" id="L623" title="All 2 branches missed.">                if (!ok) {</span>
<span class="nc" id="L624">                    host = addr.getHostAddress();</span>
<span class="nc" id="L625">                    return host;</span>
                }

<span class="nc" id="L628">                break;</span>

<span class="nc" id="L630">            } catch (SecurityException e) {</span>
<span class="nc" id="L631">                host = addr.getHostAddress();</span>
<span class="nc" id="L632">                break;</span>
<span class="nc" id="L633">            } catch (UnknownHostException e) {</span>
<span class="nc" id="L634">                host = addr.getHostAddress();</span>
                // let next provider resolve the hostname
            }
<span class="nc" id="L637">        }</span>

<span class="nc" id="L639">        return host;</span>
    }

    /**
     * Returns the raw IP address of this {@code InetAddress}
     * object. The result is in network byte order: the highest order
     * byte of the address is in {@code getAddress()[0]}.
     *
     * @return  the raw IP address of this object.
     */
    public byte[] getAddress() {
<span class="nc" id="L650">        return null;</span>
    }

    /**
     * Returns the IP address string in textual presentation.
     *
     * @return  the raw IP address in a string format.
     * @since   JDK1.0.2
     */
    public String getHostAddress() {
<span class="nc" id="L660">        return null;</span>
     }

    /**
     * Returns a hashcode for this IP address.
     *
     * @return  a hash code value for this IP address.
     */
    public int hashCode() {
<span class="nc" id="L669">        return -1;</span>
    }

    /**
     * Compares this object against the specified object.
     * The result is {@code true} if and only if the argument is
     * not {@code null} and it represents the same IP address as
     * this object.
     * &lt;p&gt;
     * Two instances of {@code InetAddress} represent the same IP
     * address if the length of the byte arrays returned by
     * {@code getAddress} is the same for both, and each of the
     * array components is the same for the byte arrays.
     *
     * @param   obj   the object to compare against.
     * @return  {@code true} if the objects are the same;
     *          {@code false} otherwise.
     * @see     java.net.InetAddress#getAddress()
     */
    public boolean equals(Object obj) {
<span class="nc" id="L689">        return false;</span>
    }

    /**
     * Converts this IP address to a {@code String}. The
     * string returned is of the form: hostname / literal IP
     * address.
     *
     * If the host name is unresolved, no reverse name service lookup
     * is performed. The hostname part will be represented by an empty string.
     *
     * @return  a string representation of this IP address.
     */
    public String toString() {
<span class="nc" id="L703">        String hostName = holder().getHostName();</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">        return ((hostName != null) ? hostName : &quot;&quot;)</span>
<span class="nc" id="L705">            + &quot;/&quot; + getHostAddress();</span>
    }

    /*
     * Cached addresses - our own litle nis, not!
     */
<span class="nc" id="L711">    private static Cache addressCache = new Cache(Cache.Type.Positive);</span>

<span class="nc" id="L713">    private static Cache negativeCache = new Cache(Cache.Type.Negative);</span>

<span class="nc" id="L715">    private static boolean addressCacheInit = false;</span>

    static InetAddress[]    unknown_array; // put THIS in cache

    static InetAddressImpl  impl;

<span class="nc" id="L721">    private static final HashMap&lt;String, Void&gt; lookupTable = new HashMap&lt;&gt;();</span>

    /**
     * Represents a cache entry
     */
    static final class CacheEntry {

<span class="nc" id="L728">        CacheEntry(InetAddress[] addresses, long expiration) {</span>
<span class="nc" id="L729">            this.addresses = addresses;</span>
<span class="nc" id="L730">            this.expiration = expiration;</span>
<span class="nc" id="L731">        }</span>

        InetAddress[] addresses;
        long expiration;
    }

    /**
     * A cache that manages entries based on a policy specified
     * at creation time.
     */
    static final class Cache {
        private LinkedHashMap&lt;String, CacheEntry&gt; cache;
        private Type type;

<span class="nc" id="L745">        enum Type {Positive, Negative};</span>

        /**
         * Create cache
         */
<span class="nc" id="L750">        public Cache(Type type) {</span>
<span class="nc" id="L751">            this.type = type;</span>
<span class="nc" id="L752">            cache = new LinkedHashMap&lt;String, CacheEntry&gt;();</span>
<span class="nc" id="L753">        }</span>

        private int getPolicy() {
<span class="nc bnc" id="L756" title="All 2 branches missed.">            if (type == Type.Positive) {</span>
<span class="nc" id="L757">                return InetAddressCachePolicy.get();</span>
            } else {
<span class="nc" id="L759">                return InetAddressCachePolicy.getNegative();</span>
            }
        }

        /**
         * Add an entry to the cache. If there's already an
         * entry then for this host then the entry will be
         * replaced.
         */
        public Cache put(String host, InetAddress[] addresses) {
<span class="nc" id="L769">            int policy = getPolicy();</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">            if (policy == InetAddressCachePolicy.NEVER) {</span>
<span class="nc" id="L771">                return this;</span>
            }

            // purge any expired entries

<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (policy != InetAddressCachePolicy.FOREVER) {</span>

                // As we iterate in insertion order we can
                // terminate when a non-expired entry is found.
<span class="nc" id="L780">                LinkedList&lt;String&gt; expired = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L781">                long now = System.currentTimeMillis();</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">                for (String key : cache.keySet()) {</span>
<span class="nc" id="L783">                    CacheEntry entry = cache.get(key);</span>

<span class="nc bnc" id="L785" title="All 4 branches missed.">                    if (entry.expiration &gt;= 0 &amp;&amp; entry.expiration &lt; now) {</span>
<span class="nc" id="L786">                        expired.add(key);</span>
                    } else {
                        break;
                    }
<span class="nc" id="L790">                }</span>

<span class="nc bnc" id="L792" title="All 2 branches missed.">                for (String key : expired) {</span>
<span class="nc" id="L793">                    cache.remove(key);</span>
<span class="nc" id="L794">                }</span>
            }

            // create new entry and add it to the cache
            // -- as a HashMap replaces existing entries we
            //    don't need to explicitly check if there is
            //    already an entry for this host.
            long expiration;
<span class="nc bnc" id="L802" title="All 2 branches missed.">            if (policy == InetAddressCachePolicy.FOREVER) {</span>
<span class="nc" id="L803">                expiration = -1;</span>
            } else {
<span class="nc" id="L805">                expiration = System.currentTimeMillis() + (policy * 1000);</span>
            }
<span class="nc" id="L807">            CacheEntry entry = new CacheEntry(addresses, expiration);</span>
<span class="nc" id="L808">            cache.put(host, entry);</span>
<span class="nc" id="L809">            return this;</span>
        }

        /**
         * Query the cache for the specific host. If found then
         * return its CacheEntry, or null if not found.
         */
        public CacheEntry get(String host) {
<span class="nc" id="L817">            int policy = getPolicy();</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">            if (policy == InetAddressCachePolicy.NEVER) {</span>
<span class="nc" id="L819">                return null;</span>
            }
<span class="nc" id="L821">            CacheEntry entry = cache.get(host);</span>

            // check if entry has expired
<span class="nc bnc" id="L824" title="All 4 branches missed.">            if (entry != null &amp;&amp; policy != InetAddressCachePolicy.FOREVER) {</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">                if (entry.expiration &gt;= 0 &amp;&amp;</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                    entry.expiration &lt; System.currentTimeMillis()) {</span>
<span class="nc" id="L827">                    cache.remove(host);</span>
<span class="nc" id="L828">                    entry = null;</span>
                }
            }

<span class="nc" id="L832">            return entry;</span>
        }
    }

    /*
     * Initialize cache and insert anyLocalAddress into the
     * unknown array with no expiry.
     */
    private static void cacheInitIfNeeded() {
<span class="nc bnc" id="L841" title="All 4 branches missed.">        assert Thread.holdsLock(addressCache);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">        if (addressCacheInit) {</span>
<span class="nc" id="L843">            return;</span>
        }
<span class="nc" id="L845">        unknown_array = new InetAddress[1];</span>
<span class="nc" id="L846">        unknown_array[0] = impl.anyLocalAddress();</span>

<span class="nc" id="L848">        addressCache.put(impl.anyLocalAddress().getHostName(),</span>
                         unknown_array);

<span class="nc" id="L851">        addressCacheInit = true;</span>
<span class="nc" id="L852">    }</span>

    /*
     * Cache the given hostname and addresses.
     */
    private static void cacheAddresses(String hostname,
                                       InetAddress[] addresses,
                                       boolean success) {
<span class="nc" id="L860">        hostname = hostname.toLowerCase();</span>
<span class="nc" id="L861">        synchronized (addressCache) {</span>
<span class="nc" id="L862">            cacheInitIfNeeded();</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">            if (success) {</span>
<span class="nc" id="L864">                addressCache.put(hostname, addresses);</span>
            } else {
<span class="nc" id="L866">                negativeCache.put(hostname, addresses);</span>
            }
<span class="nc" id="L868">        }</span>
<span class="nc" id="L869">    }</span>

    /*
     * Lookup hostname in cache (positive &amp; negative cache). If
     * found return addresses, null if not found.
     */
    private static InetAddress[] getCachedAddresses(String hostname) {
<span class="nc" id="L876">        hostname = hostname.toLowerCase();</span>

        // search both positive &amp; negative caches

<span class="nc" id="L880">        synchronized (addressCache) {</span>
<span class="nc" id="L881">            cacheInitIfNeeded();</span>

<span class="nc" id="L883">            CacheEntry entry = addressCache.get(hostname);</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">            if (entry == null) {</span>
<span class="nc" id="L885">                entry = negativeCache.get(hostname);</span>
            }

<span class="nc bnc" id="L888" title="All 2 branches missed.">            if (entry != null) {</span>
<span class="nc" id="L889">                return entry.addresses;</span>
            }
<span class="nc" id="L891">        }</span>

        // not found
<span class="nc" id="L894">        return null;</span>
    }

    private static NameService createNSProvider(String provider) {
<span class="nc bnc" id="L898" title="All 2 branches missed.">        if (provider == null)</span>
<span class="nc" id="L899">            return null;</span>

<span class="nc" id="L901">        NameService nameService = null;</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">        if (provider.equals(&quot;default&quot;)) {</span>
            // initialize the default name service
<span class="nc" id="L904">            nameService = new NameService() {</span>
                public InetAddress[] lookupAllHostAddr(String host)
                    throws UnknownHostException {
<span class="nc" id="L907">                    return impl.lookupAllHostAddr(host);</span>
                }
                public String getHostByAddr(byte[] addr)
                    throws UnknownHostException {
<span class="nc" id="L911">                    return impl.getHostByAddr(addr);</span>
                }
            };
        } else {
<span class="nc" id="L915">            final String providerName = provider;</span>
            try {
<span class="nc" id="L917">                nameService = java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L918">                    new java.security.PrivilegedExceptionAction&lt;NameService&gt;() {</span>
                        public NameService run() {
<span class="nc" id="L920">                            Iterator&lt;NameServiceDescriptor&gt; itr =</span>
<span class="nc" id="L921">                                ServiceLoader.load(NameServiceDescriptor.class)</span>
<span class="nc" id="L922">                                    .iterator();</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">                            while (itr.hasNext()) {</span>
<span class="nc" id="L924">                                NameServiceDescriptor nsd = itr.next();</span>
<span class="nc" id="L925">                                if (providerName.</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">                                    equalsIgnoreCase(nsd.getType()+&quot;,&quot;</span>
<span class="nc" id="L927">                                        +nsd.getProviderName())) {</span>
                                    try {
<span class="nc" id="L929">                                        return nsd.createNameService();</span>
<span class="nc" id="L930">                                    } catch (Exception e) {</span>
<span class="nc" id="L931">                                        e.printStackTrace();</span>
<span class="nc" id="L932">                                        System.err.println(</span>
                                            &quot;Cannot create name service:&quot;
                                             +providerName+&quot;: &quot; + e);
                                    }
                                }
<span class="nc" id="L937">                            }</span>

<span class="nc" id="L939">                            return null;</span>
                        }
                    }
                );
<span class="nc" id="L943">            } catch (java.security.PrivilegedActionException e) {</span>
<span class="nc" id="L944">            }</span>
        }

<span class="nc" id="L947">        return nameService;</span>
    }

    static {
        // create the impl
<span class="nc" id="L952">        impl = InetAddressImplFactory.create();</span>

        // get name service if provided and requested
<span class="nc" id="L955">        String provider = null;;</span>
<span class="nc" id="L956">        String propPrefix = &quot;sun.net.spi.nameservice.provider.&quot;;</span>
<span class="nc" id="L957">        int n = 1;</span>
<span class="nc" id="L958">        nameServices = new ArrayList&lt;NameService&gt;();</span>
<span class="nc" id="L959">        provider = AccessController.doPrivileged(</span>
                new GetPropertyAction(propPrefix + n));
<span class="nc bnc" id="L961" title="All 2 branches missed.">        while (provider != null) {</span>
<span class="nc" id="L962">            NameService ns = createNSProvider(provider);</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">            if (ns != null)</span>
<span class="nc" id="L964">                nameServices.add(ns);</span>

<span class="nc" id="L966">            n++;</span>
<span class="nc" id="L967">            provider = AccessController.doPrivileged(</span>
                    new GetPropertyAction(propPrefix + n));
<span class="nc" id="L969">        }</span>

        // if not designate any name services provider,
        // create a default one
<span class="nc bnc" id="L973" title="All 2 branches missed.">        if (nameServices.size() == 0) {</span>
<span class="nc" id="L974">            NameService ns = createNSProvider(&quot;default&quot;);</span>
<span class="nc" id="L975">            nameServices.add(ns);</span>
        }
    }

    /**
     * Creates an InetAddress based on the provided host name and IP address.
     * No name service is checked for the validity of the address.
     *
     * &lt;p&gt; The host name can either be a machine name, such as
     * &quot;{@code java.sun.com}&quot;, or a textual representation of its IP
     * address.
     * &lt;p&gt; No validity checking is done on the host name either.
     *
     * &lt;p&gt; If addr specifies an IPv4 address an instance of Inet4Address
     * will be returned; otherwise, an instance of Inet6Address
     * will be returned.
     *
     * &lt;p&gt; IPv4 address byte array must be 4 bytes long and IPv6 byte array
     * must be 16 bytes long
     *
     * @param host the specified host
     * @param addr the raw IP address in network byte order
     * @return  an InetAddress object created from the raw IP address.
     * @exception  UnknownHostException  if IP address is of illegal length
     * @since 1.4
     */
    public static InetAddress getByAddress(String host, byte[] addr)
        throws UnknownHostException {
<span class="nc bnc" id="L1003" title="All 6 branches missed.">        if (host != null &amp;&amp; host.length() &gt; 0 &amp;&amp; host.charAt(0) == '[') {</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">            if (host.charAt(host.length()-1) == ']') {</span>
<span class="nc" id="L1005">                host = host.substring(1, host.length() -1);</span>
            }
        }
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (addr != null) {</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            if (addr.length == Inet4Address.INADDRSZ) {</span>
<span class="nc" id="L1010">                return new Inet4Address(host, addr);</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">            } else if (addr.length == Inet6Address.INADDRSZ) {</span>
<span class="nc" id="L1012">                byte[] newAddr</span>
<span class="nc" id="L1013">                    = IPAddressUtil.convertFromIPv4MappedAddress(addr);</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">                if (newAddr != null) {</span>
<span class="nc" id="L1015">                    return new Inet4Address(host, newAddr);</span>
                } else {
<span class="nc" id="L1017">                    return new Inet6Address(host, addr);</span>
                }
            }
        }
<span class="nc" id="L1021">        throw new UnknownHostException(&quot;addr is of illegal length&quot;);</span>
    }


    /**
     * Determines the IP address of a host, given the host's name.
     *
     * &lt;p&gt; The host name can either be a machine name, such as
     * &quot;{@code java.sun.com}&quot;, or a textual representation of its
     * IP address. If a literal IP address is supplied, only the
     * validity of the address format is checked.
     *
     * &lt;p&gt; For {@code host} specified in literal IPv6 address,
     * either the form defined in RFC 2732 or the literal IPv6 address
     * format defined in RFC 2373 is accepted. IPv6 scoped addresses are also
     * supported. See &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt; for a description of IPv6
     * scoped addresses.
     *
     * &lt;p&gt; If the host is {@code null} then an {@code InetAddress}
     * representing an address of the loopback interface is returned.
     * See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC&amp;nbsp;3330&lt;/a&gt;
     * section&amp;nbsp;2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;
     * section&amp;nbsp;2.5.3. &lt;/p&gt;
     *
     * @param      host   the specified host, or {@code null}.
     * @return     an IP address for the given host name.
     * @exception  UnknownHostException  if no IP address for the
     *               {@code host} could be found, or if a scope_id was specified
     *               for a global IPv6 address.
     * @exception  SecurityException if a security manager exists
     *             and its checkConnect method doesn't allow the operation
     */
    public static InetAddress getByName(String host)
        throws UnknownHostException {
<span class="nc" id="L1055">        return InetAddress.getAllByName(host)[0];</span>
    }

    // called from deployment cache manager
    private static InetAddress getByName(String host, InetAddress reqAddr)
        throws UnknownHostException {
<span class="nc" id="L1061">        return InetAddress.getAllByName(host, reqAddr)[0];</span>
    }

    /**
     * Given the name of a host, returns an array of its IP addresses,
     * based on the configured name service on the system.
     *
     * &lt;p&gt; The host name can either be a machine name, such as
     * &quot;{@code java.sun.com}&quot;, or a textual representation of its IP
     * address. If a literal IP address is supplied, only the
     * validity of the address format is checked.
     *
     * &lt;p&gt; For {@code host} specified in &lt;i&gt;literal IPv6 address&lt;/i&gt;,
     * either the form defined in RFC 2732 or the literal IPv6 address
     * format defined in RFC 2373 is accepted. A literal IPv6 address may
     * also be qualified by appending a scoped zone identifier or scope_id.
     * The syntax and usage of scope_ids is described
     * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
     * &lt;p&gt; If the host is {@code null} then an {@code InetAddress}
     * representing an address of the loopback interface is returned.
     * See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC&amp;nbsp;3330&lt;/a&gt;
     * section&amp;nbsp;2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;
     * section&amp;nbsp;2.5.3. &lt;/p&gt;
     *
     * &lt;p&gt; If there is a security manager and {@code host} is not
     * null and {@code host.length() } is not equal to zero, the
     * security manager's
     * {@code checkConnect} method is called
     * with the hostname and {@code -1}
     * as its arguments to see if the operation is allowed.
     *
     * @param      host   the name of the host, or {@code null}.
     * @return     an array of all the IP addresses for a given host name.
     *
     * @exception  UnknownHostException  if no IP address for the
     *               {@code host} could be found, or if a scope_id was specified
     *               for a global IPv6 address.
     * @exception  SecurityException  if a security manager exists and its
     *               {@code checkConnect} method doesn't allow the operation.
     *
     * @see SecurityManager#checkConnect
     */
    public static InetAddress[] getAllByName(String host)
        throws UnknownHostException {
<span class="nc" id="L1105">        return getAllByName(host, null);</span>
    }

    private static InetAddress[] getAllByName(String host, InetAddress reqAddr)
        throws UnknownHostException {

<span class="nc bnc" id="L1111" title="All 4 branches missed.">        if (host == null || host.length() == 0) {</span>
<span class="nc" id="L1112">            InetAddress[] ret = new InetAddress[1];</span>
<span class="nc" id="L1113">            ret[0] = impl.loopbackAddress();</span>
<span class="nc" id="L1114">            return ret;</span>
        }

<span class="nc" id="L1117">        boolean ipv6Expected = false;</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (host.charAt(0) == '[') {</span>
            // This is supposed to be an IPv6 literal
<span class="nc bnc" id="L1120" title="All 4 branches missed.">            if (host.length() &gt; 2 &amp;&amp; host.charAt(host.length()-1) == ']') {</span>
<span class="nc" id="L1121">                host = host.substring(1, host.length() -1);</span>
<span class="nc" id="L1122">                ipv6Expected = true;</span>
            } else {
                // This was supposed to be a IPv6 address, but it's not!
<span class="nc" id="L1125">                throw new UnknownHostException(host + &quot;: invalid IPv6 address&quot;);</span>
            }
        }

        // if host is an IP address, we won't do further lookup
<span class="nc bnc" id="L1130" title="All 2 branches missed.">        if (Character.digit(host.charAt(0), 16) != -1</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">            || (host.charAt(0) == ':')) {</span>
<span class="nc" id="L1132">            byte[] addr = null;</span>
<span class="nc" id="L1133">            int numericZone = -1;</span>
<span class="nc" id="L1134">            String ifname = null;</span>
            // see if it is IPv4 address
<span class="nc" id="L1136">            addr = IPAddressUtil.textToNumericFormatV4(host);</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">            if (addr == null) {</span>
                // This is supposed to be an IPv6 literal
                // Check if a numeric or string zone id is present
                int pos;
<span class="nc bnc" id="L1141" title="All 2 branches missed.">                if ((pos=host.indexOf (&quot;%&quot;)) != -1) {</span>
<span class="nc" id="L1142">                    numericZone = checkNumericZone (host);</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">                    if (numericZone == -1) { /* remainder of string must be an ifname */</span>
<span class="nc" id="L1144">                        ifname = host.substring (pos+1);</span>
                    }
                }
<span class="nc bnc" id="L1147" title="All 4 branches missed.">                if ((addr = IPAddressUtil.textToNumericFormatV6(host)) == null &amp;&amp; host.contains(&quot;:&quot;)) {</span>
<span class="nc" id="L1148">                    throw new UnknownHostException(host + &quot;: invalid IPv6 address&quot;);</span>
                }
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            } else if (ipv6Expected) {</span>
                // Means an IPv4 litteral between brackets!
<span class="nc" id="L1152">                throw new UnknownHostException(&quot;[&quot;+host+&quot;]&quot;);</span>
            }
<span class="nc" id="L1154">            InetAddress[] ret = new InetAddress[1];</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">            if(addr != null) {</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">                if (addr.length == Inet4Address.INADDRSZ) {</span>
<span class="nc" id="L1157">                    ret[0] = new Inet4Address(null, addr);</span>
                } else {
<span class="nc bnc" id="L1159" title="All 2 branches missed.">                    if (ifname != null) {</span>
<span class="nc" id="L1160">                        ret[0] = new Inet6Address(null, addr, ifname);</span>
                    } else {
<span class="nc" id="L1162">                        ret[0] = new Inet6Address(null, addr, numericZone);</span>
                    }
                }
<span class="nc" id="L1165">                return ret;</span>
            }
<span class="nc bnc" id="L1167" title="All 2 branches missed.">        } else if (ipv6Expected) {</span>
            // We were expecting an IPv6 Litteral, but got something else
<span class="nc" id="L1169">            throw new UnknownHostException(&quot;[&quot;+host+&quot;]&quot;);</span>
        }
<span class="nc" id="L1171">        return getAllByName0(host, reqAddr, true);</span>
    }

    /**
     * Returns the loopback address.
     * &lt;p&gt;
     * The InetAddress returned will represent the IPv4
     * loopback address, 127.0.0.1, or the IPv6 loopback
     * address, ::1. The IPv4 loopback address returned
     * is only one of many in the form 127.*.*.*
     *
     * @return  the InetAddress loopback instance.
     * @since 1.7
     */
    public static InetAddress getLoopbackAddress() {
<span class="nc" id="L1186">        return impl.loopbackAddress();</span>
    }


    /**
     * check if the literal address string has %nn appended
     * returns -1 if not, or the numeric value otherwise.
     *
     * %nn may also be a string that represents the displayName of
     * a currently available NetworkInterface.
     */
    private static int checkNumericZone (String s) throws UnknownHostException {
<span class="nc" id="L1198">        int percent = s.indexOf ('%');</span>
<span class="nc" id="L1199">        int slen = s.length();</span>
<span class="nc" id="L1200">        int digit, zone=0;</span>
<span class="nc bnc" id="L1201" title="All 2 branches missed.">        if (percent == -1) {</span>
<span class="nc" id="L1202">            return -1;</span>
        }
<span class="nc bnc" id="L1204" title="All 2 branches missed.">        for (int i=percent+1; i&lt;slen; i++) {</span>
<span class="nc" id="L1205">            char c = s.charAt(i);</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">            if (c == ']') {</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">                if (i == percent+1) {</span>
                    /* empty per-cent field */
<span class="nc" id="L1209">                    return -1;</span>
                }
                break;
            }
<span class="nc bnc" id="L1213" title="All 2 branches missed.">            if ((digit = Character.digit (c, 10)) &lt; 0) {</span>
<span class="nc" id="L1214">                return -1;</span>
            }
<span class="nc" id="L1216">            zone = (zone * 10) + digit;</span>
        }
<span class="nc" id="L1218">        return zone;</span>
    }

    private static InetAddress[] getAllByName0 (String host)
        throws UnknownHostException
    {
<span class="nc" id="L1224">        return getAllByName0(host, true);</span>
    }

    /**
     * package private so SocketPermission can call it
     */
    static InetAddress[] getAllByName0 (String host, boolean check)
        throws UnknownHostException  {
<span class="nc" id="L1232">        return getAllByName0 (host, null, check);</span>
    }

    private static InetAddress[] getAllByName0 (String host, InetAddress reqAddr, boolean check)
        throws UnknownHostException  {

        /* If it gets here it is presumed to be a hostname */
        /* Cache.get can return: null, unknownAddress, or InetAddress[] */

        /* make sure the connection to the host is allowed, before we
         * give out a hostname
         */
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        if (check) {</span>
<span class="nc" id="L1245">            SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">            if (security != null) {</span>
<span class="nc" id="L1247">                security.checkConnect(host, -1);</span>
            }
        }

<span class="nc" id="L1251">        InetAddress[] addresses = getCachedAddresses(host);</span>

        /* If no entry in cache, then do the host lookup */
<span class="nc bnc" id="L1254" title="All 2 branches missed.">        if (addresses == null) {</span>
<span class="nc" id="L1255">            addresses = getAddressesFromNameService(host, reqAddr);</span>
        }

<span class="nc bnc" id="L1258" title="All 2 branches missed.">        if (addresses == unknown_array)</span>
<span class="nc" id="L1259">            throw new UnknownHostException(host);</span>

<span class="nc" id="L1261">        return addresses.clone();</span>
    }

    private static InetAddress[] getAddressesFromNameService(String host, InetAddress reqAddr)
        throws UnknownHostException
    {
<span class="nc" id="L1267">        InetAddress[] addresses = null;</span>
<span class="nc" id="L1268">        boolean success = false;</span>
<span class="nc" id="L1269">        UnknownHostException ex = null;</span>

        // Check whether the host is in the lookupTable.
        // 1) If the host isn't in the lookupTable when
        //    checkLookupTable() is called, checkLookupTable()
        //    would add the host in the lookupTable and
        //    return null. So we will do the lookup.
        // 2) If the host is in the lookupTable when
        //    checkLookupTable() is called, the current thread
        //    would be blocked until the host is removed
        //    from the lookupTable. Then this thread
        //    should try to look up the addressCache.
        //     i) if it found the addresses in the
        //        addressCache, checkLookupTable()  would
        //        return the addresses.
        //     ii) if it didn't find the addresses in the
        //         addressCache for any reason,
        //         it should add the host in the
        //         lookupTable and return null so the
        //         following code would do  a lookup itself.
<span class="nc bnc" id="L1289" title="All 2 branches missed.">        if ((addresses = checkLookupTable(host)) == null) {</span>
            try {
                // This is the first thread which looks up the addresses
                // this host or the cache entry for this host has been
                // expired so this thread should do the lookup.
<span class="nc bnc" id="L1294" title="All 2 branches missed.">                for (NameService nameService : nameServices) {</span>
                    try {
                        /*
                         * Do not put the call to lookup() inside the
                         * constructor.  if you do you will still be
                         * allocating space when the lookup fails.
                         */

<span class="nc" id="L1302">                        addresses = nameService.lookupAllHostAddr(host);</span>
<span class="nc" id="L1303">                        success = true;</span>
<span class="nc" id="L1304">                        break;</span>
<span class="nc" id="L1305">                    } catch (UnknownHostException uhe) {</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">                        if (host.equalsIgnoreCase(&quot;localhost&quot;)) {</span>
<span class="nc" id="L1307">                            InetAddress[] local = new InetAddress[] { impl.loopbackAddress() };</span>
<span class="nc" id="L1308">                            addresses = local;</span>
<span class="nc" id="L1309">                            success = true;</span>
<span class="nc" id="L1310">                            break;</span>
                        }
                        else {
<span class="nc" id="L1313">                            addresses = unknown_array;</span>
<span class="nc" id="L1314">                            success = false;</span>
<span class="nc" id="L1315">                            ex = uhe;</span>
                        }
                    }
<span class="nc" id="L1318">                }</span>

                // More to do?
<span class="nc bnc" id="L1321" title="All 6 branches missed.">                if (reqAddr != null &amp;&amp; addresses.length &gt; 1 &amp;&amp; !addresses[0].equals(reqAddr)) {</span>
                    // Find it?
<span class="nc" id="L1323">                    int i = 1;</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">                    for (; i &lt; addresses.length; i++) {</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">                        if (addresses[i].equals(reqAddr)) {</span>
<span class="nc" id="L1326">                            break;</span>
                        }
                    }
                    // Rotate
<span class="nc bnc" id="L1330" title="All 2 branches missed.">                    if (i &lt; addresses.length) {</span>
<span class="nc" id="L1331">                        InetAddress tmp, tmp2 = reqAddr;</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">                        for (int j = 0; j &lt; i; j++) {</span>
<span class="nc" id="L1333">                            tmp = addresses[j];</span>
<span class="nc" id="L1334">                            addresses[j] = tmp2;</span>
<span class="nc" id="L1335">                            tmp2 = tmp;</span>
                        }
<span class="nc" id="L1337">                        addresses[i] = tmp2;</span>
                    }
                }
                // Cache the address.
<span class="nc" id="L1341">                cacheAddresses(host, addresses, success);</span>

<span class="nc bnc" id="L1343" title="All 4 branches missed.">                if (!success &amp;&amp; ex != null)</span>
<span class="nc" id="L1344">                    throw ex;</span>

            } finally {
                // Delete host from the lookupTable and notify
                // all threads waiting on the lookupTable monitor.
<span class="nc" id="L1349">                updateLookupTable(host);</span>
<span class="nc" id="L1350">            }</span>
        }

<span class="nc" id="L1353">        return addresses;</span>
    }


    private static InetAddress[] checkLookupTable(String host) {
<span class="nc" id="L1358">        synchronized (lookupTable) {</span>
            // If the host isn't in the lookupTable, add it in the
            // lookuptable and return null. The caller should do
            // the lookup.
<span class="nc bnc" id="L1362" title="All 2 branches missed.">            if (lookupTable.containsKey(host) == false) {</span>
<span class="nc" id="L1363">                lookupTable.put(host, null);</span>
<span class="nc" id="L1364">                return null;</span>
            }

            // If the host is in the lookupTable, it means that another
            // thread is trying to look up the addresses of this host.
            // This thread should wait.
<span class="nc bnc" id="L1370" title="All 2 branches missed.">            while (lookupTable.containsKey(host)) {</span>
                try {
<span class="nc" id="L1372">                    lookupTable.wait();</span>
<span class="nc" id="L1373">                } catch (InterruptedException e) {</span>
<span class="nc" id="L1374">                }</span>
            }
<span class="nc" id="L1376">        }</span>

        // The other thread has finished looking up the addresses of
        // the host. This thread should retry to get the addresses
        // from the addressCache. If it doesn't get the addresses from
        // the cache, it will try to look up the addresses itself.
<span class="nc" id="L1382">        InetAddress[] addresses = getCachedAddresses(host);</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">        if (addresses == null) {</span>
<span class="nc" id="L1384">            synchronized (lookupTable) {</span>
<span class="nc" id="L1385">                lookupTable.put(host, null);</span>
<span class="nc" id="L1386">                return null;</span>
<span class="nc" id="L1387">            }</span>
        }

<span class="nc" id="L1390">        return addresses;</span>
    }

    private static void updateLookupTable(String host) {
<span class="nc" id="L1394">        synchronized (lookupTable) {</span>
<span class="nc" id="L1395">            lookupTable.remove(host);</span>
<span class="nc" id="L1396">            lookupTable.notifyAll();</span>
<span class="nc" id="L1397">        }</span>
<span class="nc" id="L1398">    }</span>

    /**
     * Returns an {@code InetAddress} object given the raw IP address .
     * The argument is in network byte order: the highest order
     * byte of the address is in {@code getAddress()[0]}.
     *
     * &lt;p&gt; This method doesn't block, i.e. no reverse name service lookup
     * is performed.
     *
     * &lt;p&gt; IPv4 address byte array must be 4 bytes long and IPv6 byte array
     * must be 16 bytes long
     *
     * @param addr the raw IP address in network byte order
     * @return  an InetAddress object created from the raw IP address.
     * @exception  UnknownHostException  if IP address is of illegal length
     * @since 1.4
     */
    public static InetAddress getByAddress(byte[] addr)
        throws UnknownHostException {
<span class="nc" id="L1418">        return getByAddress(null, addr);</span>
    }

<span class="nc" id="L1421">    private static InetAddress cachedLocalHost = null;</span>
<span class="nc" id="L1422">    private static long cacheTime = 0;</span>
    private static final long maxCacheTime = 5000L;
<span class="nc" id="L1424">    private static final Object cacheLock = new Object();</span>

    /**
     * Returns the address of the local host. This is achieved by retrieving
     * the name of the host from the system, then resolving that name into
     * an {@code InetAddress}.
     *
     * &lt;P&gt;Note: The resolved address may be cached for a short period of time.
     * &lt;/P&gt;
     *
     * &lt;p&gt;If there is a security manager, its
     * {@code checkConnect} method is called
     * with the local host name and {@code -1}
     * as its arguments to see if the operation is allowed.
     * If the operation is not allowed, an InetAddress representing
     * the loopback address is returned.
     *
     * @return     the address of the local host.
     *
     * @exception  UnknownHostException  if the local host name could not
     *             be resolved into an address.
     *
     * @see SecurityManager#checkConnect
     * @see java.net.InetAddress#getByName(java.lang.String)
     */
    public static InetAddress getLocalHost() throws UnknownHostException {

<span class="nc" id="L1451">        SecurityManager security = System.getSecurityManager();</span>
        try {
<span class="nc" id="L1453">            String local = impl.getLocalHostName();</span>

<span class="nc bnc" id="L1455" title="All 2 branches missed.">            if (security != null) {</span>
<span class="nc" id="L1456">                security.checkConnect(local, -1);</span>
            }

<span class="nc bnc" id="L1459" title="All 2 branches missed.">            if (local.equals(&quot;localhost&quot;)) {</span>
<span class="nc" id="L1460">                return impl.loopbackAddress();</span>
            }

<span class="nc" id="L1463">            InetAddress ret = null;</span>
<span class="nc" id="L1464">            synchronized (cacheLock) {</span>
<span class="nc" id="L1465">                long now = System.currentTimeMillis();</span>
<span class="nc bnc" id="L1466" title="All 2 branches missed.">                if (cachedLocalHost != null) {</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">                    if ((now - cacheTime) &lt; maxCacheTime) // Less than 5s old?</span>
<span class="nc" id="L1468">                        ret = cachedLocalHost;</span>
                    else
<span class="nc" id="L1470">                        cachedLocalHost = null;</span>
                }

                // we are calling getAddressesFromNameService directly
                // to avoid getting localHost from cache
<span class="nc bnc" id="L1475" title="All 2 branches missed.">                if (ret == null) {</span>
                    InetAddress[] localAddrs;
                    try {
<span class="nc" id="L1478">                        localAddrs =</span>
<span class="nc" id="L1479">                            InetAddress.getAddressesFromNameService(local, null);</span>
<span class="nc" id="L1480">                    } catch (UnknownHostException uhe) {</span>
                        // Rethrow with a more informative error message.
<span class="nc" id="L1482">                        UnknownHostException uhe2 =</span>
                            new UnknownHostException(local + &quot;: &quot; +
<span class="nc" id="L1484">                                                     uhe.getMessage());</span>
<span class="nc" id="L1485">                        uhe2.initCause(uhe);</span>
<span class="nc" id="L1486">                        throw uhe2;</span>
<span class="nc" id="L1487">                    }</span>
<span class="nc" id="L1488">                    cachedLocalHost = localAddrs[0];</span>
<span class="nc" id="L1489">                    cacheTime = now;</span>
<span class="nc" id="L1490">                    ret = localAddrs[0];</span>
                }
<span class="nc" id="L1492">            }</span>
<span class="nc" id="L1493">            return ret;</span>
<span class="nc" id="L1494">        } catch (java.lang.SecurityException e) {</span>
<span class="nc" id="L1495">            return impl.loopbackAddress();</span>
        }
    }

    /**
     * Perform class load-time initializations.
     */
    private static native void init();


    /*
     * Returns the InetAddress representing anyLocalAddress
     * (typically 0.0.0.0 or ::0)
     */
    static InetAddress anyLocalAddress() {
<span class="nc" id="L1510">        return impl.anyLocalAddress();</span>
    }

    /*
     * Load and instantiate an underlying impl class
     */
    static InetAddressImpl loadImpl(String implName) {
<span class="nc" id="L1517">        Object impl = null;</span>

        /*
         * Property &quot;impl.prefix&quot; will be prepended to the classname
         * of the implementation object we instantiate, to which we
         * delegate the real work (like native methods).  This
         * property can vary across implementations of the java.
         * classes.  The default is an empty String &quot;&quot;.
         */
<span class="nc" id="L1526">        String prefix = AccessController.doPrivileged(</span>
                      new GetPropertyAction(&quot;impl.prefix&quot;, &quot;&quot;));
        try {
<span class="nc" id="L1529">            impl = Class.forName(&quot;java.net.&quot; + prefix + implName).newInstance();</span>
<span class="nc" id="L1530">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1531">            System.err.println(&quot;Class not found: java.net.&quot; + prefix +</span>
                               implName + &quot;:\ncheck impl.prefix property &quot; +
                               &quot;in your properties file.&quot;);
<span class="nc" id="L1534">        } catch (InstantiationException e) {</span>
<span class="nc" id="L1535">            System.err.println(&quot;Could not instantiate: java.net.&quot; + prefix +</span>
                               implName + &quot;:\ncheck impl.prefix property &quot; +
                               &quot;in your properties file.&quot;);
<span class="nc" id="L1538">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L1539">            System.err.println(&quot;Cannot access class: java.net.&quot; + prefix +</span>
                               implName + &quot;:\ncheck impl.prefix property &quot; +
                               &quot;in your properties file.&quot;);
<span class="nc" id="L1542">        }</span>

<span class="nc bnc" id="L1544" title="All 2 branches missed.">        if (impl == null) {</span>
            try {
<span class="nc" id="L1546">                impl = Class.forName(implName).newInstance();</span>
<span class="nc" id="L1547">            } catch (Exception e) {</span>
<span class="nc" id="L1548">                throw new Error(&quot;System property impl.prefix incorrect&quot;);</span>
<span class="nc" id="L1549">            }</span>
        }

<span class="nc" id="L1552">        return (InetAddressImpl) impl;</span>
    }

    private void readObjectNoData (ObjectInputStream s) throws
                         IOException, ClassNotFoundException {
<span class="nc bnc" id="L1557" title="All 2 branches missed.">        if (getClass().getClassLoader() != null) {</span>
<span class="nc" id="L1558">            throw new SecurityException (&quot;invalid address type&quot;);</span>
        }
<span class="nc" id="L1560">    }</span>

    private static final long FIELDS_OFFSET;
    private static final sun.misc.Unsafe UNSAFE;

    static {
        try {
<span class="nc" id="L1567">            sun.misc.Unsafe unsafe = sun.misc.Unsafe.getUnsafe();</span>
<span class="nc" id="L1568">            FIELDS_OFFSET = unsafe.objectFieldOffset(</span>
<span class="nc" id="L1569">                InetAddress.class.getDeclaredField(&quot;holder&quot;)</span>
            );
<span class="nc" id="L1571">            UNSAFE = unsafe;</span>
<span class="nc" id="L1572">        } catch (ReflectiveOperationException e) {</span>
<span class="nc" id="L1573">            throw new Error(e);</span>
<span class="nc" id="L1574">        }</span>
    }

    private void readObject (ObjectInputStream s) throws
                         IOException, ClassNotFoundException {
<span class="nc bnc" id="L1579" title="All 2 branches missed.">        if (getClass().getClassLoader() != null) {</span>
<span class="nc" id="L1580">            throw new SecurityException (&quot;invalid address type&quot;);</span>
        }
<span class="nc" id="L1582">        GetField gf = s.readFields();</span>
<span class="nc" id="L1583">        String host = (String)gf.get(&quot;hostName&quot;, null);</span>
<span class="nc" id="L1584">        int address= gf.get(&quot;address&quot;, 0);</span>
<span class="nc" id="L1585">        int family= gf.get(&quot;family&quot;, 0);</span>
<span class="nc" id="L1586">        InetAddressHolder h = new InetAddressHolder(host, address, family);</span>
<span class="nc" id="L1587">        UNSAFE.putObject(this, FIELDS_OFFSET, h);</span>
<span class="nc" id="L1588">    }</span>

    /* needed because the serializable fields no longer exist */

    /**
     * @serialField hostName String
     * @serialField address int
     * @serialField family int
     */
<span class="nc" id="L1597">    private static final ObjectStreamField[] serialPersistentFields = {</span>
        new ObjectStreamField(&quot;hostName&quot;, String.class),
        new ObjectStreamField(&quot;address&quot;, int.class),
        new ObjectStreamField(&quot;family&quot;, int.class),
    };

    private void writeObject (ObjectOutputStream s) throws
                        IOException {
<span class="nc bnc" id="L1605" title="All 2 branches missed.">        if (getClass().getClassLoader() != null) {</span>
<span class="nc" id="L1606">            throw new SecurityException (&quot;invalid address type&quot;);</span>
        }
<span class="nc" id="L1608">        PutField pf = s.putFields();</span>
<span class="nc" id="L1609">        pf.put(&quot;hostName&quot;, holder().getHostName());</span>
<span class="nc" id="L1610">        pf.put(&quot;address&quot;, holder().getAddress());</span>
<span class="nc" id="L1611">        pf.put(&quot;family&quot;, holder().getFamily());</span>
<span class="nc" id="L1612">        s.writeFields();</span>
<span class="nc" id="L1613">    }</span>
}

/*
 * Simple factory to create the impl
 */
<span class="nc" id="L1619">class InetAddressImplFactory {</span>

    static InetAddressImpl create() {
<span class="nc bnc" id="L1622" title="All 2 branches missed.">        return InetAddress.loadImpl(isIPv6Supported() ?</span>
                                    &quot;Inet6AddressImpl&quot; : &quot;Inet4AddressImpl&quot;);
    }

    static native boolean isIPv6Supported();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>