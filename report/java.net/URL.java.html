<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>URL.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">URL.java</span></div><h1>URL.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.io.IOException;
import java.io.InputStream;
import java.util.Hashtable;
import java.util.StringTokenizer;
import sun.security.util.SecurityConstants;

/**
 * Class {@code URL} represents a Uniform Resource
 * Locator, a pointer to a &quot;resource&quot; on the World
 * Wide Web. A resource can be something as simple as a file or a
 * directory, or it can be a reference to a more complicated object,
 * such as a query to a database or to a search engine. More
 * information on the types of URLs and their formats can be found at:
 * &lt;a href=
 * &quot;http://web.archive.org/web/20051219043731/http://archive.ncsa.uiuc.edu/SDG/Software/Mosaic/Demo/url-primer.html&quot;&gt;
 * &lt;i&gt;Types of URL&lt;/i&gt;&lt;/a&gt;
 * &lt;p&gt;
 * In general, a URL can be broken into several parts. Consider the
 * following example:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     http://www.example.com/docs/resource1.html
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;
 * The URL above indicates that the protocol to use is
 * {@code http} (HyperText Transfer Protocol) and that the
 * information resides on a host machine named
 * {@code www.example.com}. The information on that host
 * machine is named {@code /docs/resource1.html}. The exact
 * meaning of this name on the host machine is both protocol
 * dependent and host dependent. The information normally resides in
 * a file, but it could be generated on the fly. This component of
 * the URL is called the &lt;i&gt;path&lt;/i&gt; component.
 * &lt;p&gt;
 * A URL can optionally specify a &quot;port&quot;, which is the
 * port number to which the TCP connection is made on the remote host
 * machine. If the port is not specified, the default port for
 * the protocol is used instead. For example, the default port for
 * {@code http} is {@code 80}. An alternative port could be
 * specified as:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     http://www.example.com:1080/docs/resource1.html
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;
 * The syntax of {@code URL} is defined by  &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
 * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
 * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
 * also supports scope_ids. The syntax and usage of scope_ids is described
 * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
 * &lt;p&gt;
 * A URL may have appended to it a &quot;fragment&quot;, also known
 * as a &quot;ref&quot; or a &quot;reference&quot;. The fragment is indicated by the sharp
 * sign character &quot;#&quot; followed by more characters. For example,
 * &lt;blockquote&gt;&lt;pre&gt;
 *     http://java.sun.com/index.html#chapter1
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;
 * This fragment is not technically part of the URL. Rather, it
 * indicates that after the specified resource is retrieved, the
 * application is specifically interested in that part of the
 * document that has the tag {@code chapter1} attached to it. The
 * meaning of a tag is resource specific.
 * &lt;p&gt;
 * An application can also specify a &quot;relative URL&quot;,
 * which contains only enough information to reach the resource
 * relative to another URL. Relative URLs are frequently used within
 * HTML pages. For example, if the contents of the URL:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     http://java.sun.com/index.html
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * contained within it the relative URL:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     FAQ.html
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * it would be a shorthand for:
 * &lt;blockquote&gt;&lt;pre&gt;
 *     http://java.sun.com/FAQ.html
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;
 * The relative URL need not specify all the components of a URL. If
 * the protocol, host name, or port number is missing, the value is
 * inherited from the fully specified URL. The file component must be
 * specified. The optional fragment is not inherited.
 * &lt;p&gt;
 * The URL class does not itself encode or decode any URL components
 * according to the escaping mechanism defined in RFC2396. It is the
 * responsibility of the caller to encode any fields, which need to be
 * escaped prior to calling URL, and also to decode any escaped fields,
 * that are returned from URL. Furthermore, because URL has no knowledge
 * of URL escaping, it does not recognise equivalence between the encoded
 * or decoded form of the same URL. For example, the two URLs:&lt;br&gt;
 * &lt;pre&gt;    http://foo.com/hello world/ and http://foo.com/hello%20world&lt;/pre&gt;
 * would be considered not equal to each other.
 * &lt;p&gt;
 * Note, the {@link java.net.URI} class does perform escaping of its
 * component fields in certain circumstances. The recommended way
 * to manage the encoding and decoding of URLs is to use {@link java.net.URI},
 * and to convert between these two classes using {@link #toURI()} and
 * {@link URI#toURL()}.
 * &lt;p&gt;
 * The {@link URLEncoder} and {@link URLDecoder} classes can also be
 * used, but only for HTML form encoding, which is not the same
 * as the encoding scheme defined in RFC2396.
 *
 * @author  James Gosling
 * @since JDK1.0
 */
public final class URL implements java.io.Serializable {

    static final long serialVersionUID = -7627629688361524110L;

    /**
     * The property which specifies the package prefix list to be scanned
     * for protocol handlers.  The value of this property (if any) should
     * be a vertical bar delimited list of package names to search through
     * for a protocol handler to load.  The policy of this class is that
     * all protocol handlers will be in a class called &lt;protocolname&gt;.Handler,
     * and each package in the list is examined in turn for a matching
     * handler.  If none are found (or the property is not specified), the
     * default package prefix, sun.net.www.protocol, is used.  The search
     * proceeds from the first package in the list to the last and stops
     * when a match is found.
     */
    private static final String protocolPathProp = &quot;java.protocol.handler.pkgs&quot;;

    /**
     * The protocol to use (ftp, http, nntp, ... etc.) .
     * @serial
     */
    private String protocol;

    /**
     * The host name to connect to.
     * @serial
     */
    private String host;

    /**
     * The protocol port to connect to.
     * @serial
     */
<span class="fc" id="L170">    private int port = -1;</span>

    /**
     * The specified file name on that host. {@code file} is
     * defined as {@code path[?query]}
     * @serial
     */
    private String file;

    /**
     * The query part of this URL.
     */
    private transient String query;

    /**
     * The authority part of this URL.
     * @serial
     */
    private String authority;

    /**
     * The path part of this URL.
     */
    private transient String path;

    /**
     * The userinfo part of this URL.
     */
    private transient String userInfo;

    /**
     * # reference.
     * @serial
     */
    private String ref;

    /**
     * The host's IP address, used in equals and hashCode.
     * Computed on demand. An uninitialized or unknown hostAddress is null.
     */
    transient InetAddress hostAddress;

    /**
     * The URLStreamHandler for this URL.
     */
    transient URLStreamHandler handler;

    /* Our hash code.
     * @serial
     */
<span class="fc" id="L220">    private int hashCode = -1;</span>

    /**
     * Creates a {@code URL} object from the specified
     * {@code protocol}, {@code host}, {@code port}
     * number, and {@code file}.&lt;p&gt;
     *
     * {@code host} can be expressed as a host name or a literal
     * IP address. If IPv6 literal address is used, it should be
     * enclosed in square brackets ({@code '['} and {@code ']'}), as
     * specified by &lt;a
     * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;;
     * However, the literal IPv6 address format defined in &lt;a
     * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IP
     * Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt; is also accepted.&lt;p&gt;
     *
     * Specifying a {@code port} number of {@code -1}
     * indicates that the URL should use the default port for the
     * protocol.&lt;p&gt;
     *
     * If this is the first URL object being created with the specified
     * protocol, a &lt;i&gt;stream protocol handler&lt;/i&gt; object, an instance of
     * class {@code URLStreamHandler}, is created for that protocol:
     * &lt;ol&gt;
     * &lt;li&gt;If the application has previously set up an instance of
     *     {@code URLStreamHandlerFactory} as the stream handler factory,
     *     then the {@code createURLStreamHandler} method of that instance
     *     is called with the protocol string as an argument to create the
     *     stream protocol handler.
     * &lt;li&gt;If no {@code URLStreamHandlerFactory} has yet been set up,
     *     or if the factory's {@code createURLStreamHandler} method
     *     returns {@code null}, then the constructor finds the
     *     value of the system property:
     *     &lt;blockquote&gt;&lt;pre&gt;
     *         java.protocol.handler.pkgs
     *     &lt;/pre&gt;&lt;/blockquote&gt;
     *     If the value of that system property is not {@code null},
     *     it is interpreted as a list of packages separated by a vertical
     *     slash character '{@code |}'. The constructor tries to load
     *     the class named:
     *     &lt;blockquote&gt;&lt;pre&gt;
     *         &amp;lt;&lt;i&gt;package&lt;/i&gt;&amp;gt;.&amp;lt;&lt;i&gt;protocol&lt;/i&gt;&amp;gt;.Handler
     *     &lt;/pre&gt;&lt;/blockquote&gt;
     *     where &amp;lt;&lt;i&gt;package&lt;/i&gt;&amp;gt; is replaced by the name of the package
     *     and &amp;lt;&lt;i&gt;protocol&lt;/i&gt;&amp;gt; is replaced by the name of the protocol.
     *     If this class does not exist, or if the class exists but it is not
     *     a subclass of {@code URLStreamHandler}, then the next package
     *     in the list is tried.
     * &lt;li&gt;If the previous step fails to find a protocol handler, then the
     *     constructor tries to load from a system default package.
     *     &lt;blockquote&gt;&lt;pre&gt;
     *         &amp;lt;&lt;i&gt;system default package&lt;/i&gt;&amp;gt;.&amp;lt;&lt;i&gt;protocol&lt;/i&gt;&amp;gt;.Handler
     *     &lt;/pre&gt;&lt;/blockquote&gt;
     *     If this class does not exist, or if the class exists but it is not a
     *     subclass of {@code URLStreamHandler}, then a
     *     {@code MalformedURLException} is thrown.
     * &lt;/ol&gt;
     *
     * &lt;p&gt;Protocol handlers for the following protocols are guaranteed
     * to exist on the search path :-
     * &lt;blockquote&gt;&lt;pre&gt;
     *     http, https, file, and jar
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * Protocol handlers for additional protocols may also be
     * available.
     *
     * &lt;p&gt;No validation of the inputs is performed by this constructor.
     *
     * @param      protocol   the name of the protocol to use.
     * @param      host       the name of the host.
     * @param      port       the port number on the host.
     * @param      file       the file on the host
     * @exception  MalformedURLException  if an unknown protocol is specified.
     * @see        java.lang.System#getProperty(java.lang.String)
     * @see        java.net.URL#setURLStreamHandlerFactory(
     *                  java.net.URLStreamHandlerFactory)
     * @see        java.net.URLStreamHandler
     * @see        java.net.URLStreamHandlerFactory#createURLStreamHandler(
     *                  java.lang.String)
     */
    public URL(String protocol, String host, int port, String file)
        throws MalformedURLException
    {
<span class="fc" id="L303">        this(protocol, host, port, file, null);</span>
<span class="fc" id="L304">    }</span>

    /**
     * Creates a URL from the specified {@code protocol}
     * name, {@code host} name, and {@code file} name. The
     * default port for the specified protocol is used.
     * &lt;p&gt;
     * This method is equivalent to calling the four-argument
     * constructor with the arguments being {@code protocol},
     * {@code host}, {@code -1}, and {@code file}.
     *
     * No validation of the inputs is performed by this constructor.
     *
     * @param      protocol   the name of the protocol to use.
     * @param      host       the name of the host.
     * @param      file       the file on the host.
     * @exception  MalformedURLException  if an unknown protocol is specified.
     * @see        java.net.URL#URL(java.lang.String, java.lang.String,
     *                  int, java.lang.String)
     */
    public URL(String protocol, String host, String file)
            throws MalformedURLException {
<span class="fc" id="L326">        this(protocol, host, -1, file);</span>
<span class="fc" id="L327">    }</span>

    /**
     * Creates a {@code URL} object from the specified
     * {@code protocol}, {@code host}, {@code port}
     * number, {@code file}, and {@code handler}. Specifying
     * a {@code port} number of {@code -1} indicates that
     * the URL should use the default port for the protocol. Specifying
     * a {@code handler} of {@code null} indicates that the URL
     * should use a default stream handler for the protocol, as outlined
     * for:
     *     java.net.URL#URL(java.lang.String, java.lang.String, int,
     *                      java.lang.String)
     *
     * &lt;p&gt;If the handler is not null and there is a security manager,
     * the security manager's {@code checkPermission}
     * method is called with a
     * {@code NetPermission(&quot;specifyStreamHandler&quot;)} permission.
     * This may result in a SecurityException.
     *
     * No validation of the inputs is performed by this constructor.
     *
     * @param      protocol   the name of the protocol to use.
     * @param      host       the name of the host.
     * @param      port       the port number on the host.
     * @param      file       the file on the host
     * @param      handler    the stream handler for the URL.
     * @exception  MalformedURLException  if an unknown protocol is specified.
     * @exception  SecurityException
     *        if a security manager exists and its
     *        {@code checkPermission} method doesn't allow
     *        specifying a stream handler explicitly.
     * @see        java.lang.System#getProperty(java.lang.String)
     * @see        java.net.URL#setURLStreamHandlerFactory(
     *                  java.net.URLStreamHandlerFactory)
     * @see        java.net.URLStreamHandler
     * @see        java.net.URLStreamHandlerFactory#createURLStreamHandler(
     *                  java.lang.String)
     * @see        SecurityManager#checkPermission
     * @see        java.net.NetPermission
     */
    public URL(String protocol, String host, int port, String file,
<span class="fc" id="L369">               URLStreamHandler handler) throws MalformedURLException {</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">        if (handler != null) {</span>
<span class="fc" id="L371">            SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">            if (sm != null) {</span>
                // check for permission to specify a handler
<span class="fc" id="L374">                checkSpecifyHandler(sm);</span>
            }
        }

<span class="fc" id="L378">        protocol = protocol.toLowerCase();</span>
<span class="fc" id="L379">        this.protocol = protocol;</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (host != null) {</span>

            /**
             * if host is a literal IPv6 address,
             * we will make it conform to RFC 2732
             */
<span class="fc bfc" id="L386" title="All 4 branches covered.">            if (host.indexOf(':') &gt;= 0 &amp;&amp; !host.startsWith(&quot;[&quot;)) {</span>
<span class="fc" id="L387">                host = &quot;[&quot;+host+&quot;]&quot;;</span>
            }
<span class="fc" id="L389">            this.host = host;</span>

<span class="pc bpc" id="L391" title="1 of 2 branches missed.">            if (port &lt; -1) {</span>
<span class="nc" id="L392">                throw new MalformedURLException(&quot;Invalid port number :&quot; +</span>
                                                    port);
            }
<span class="fc" id="L395">            this.port = port;</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">            authority = (port == -1) ? host : host + &quot;:&quot; + port;</span>
        }

<span class="fc" id="L399">        Parts parts = new Parts(file);</span>
<span class="fc" id="L400">        path = parts.getPath();</span>
<span class="fc" id="L401">        query = parts.getQuery();</span>

<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if (query != null) {</span>
<span class="nc" id="L404">            this.file = path + &quot;?&quot; + query;</span>
        } else {
<span class="fc" id="L406">            this.file = path;</span>
        }
<span class="fc" id="L408">        ref = parts.getRef();</span>

        // Note: we don't do validation of the URL here. Too risky to change
        // right now, but worth considering for future reference. -br
<span class="fc bfc" id="L412" title="All 2 branches covered.">        if (handler == null &amp;&amp;</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">            (handler = getURLStreamHandler(protocol)) == null) {</span>
<span class="nc" id="L414">            throw new MalformedURLException(&quot;unknown protocol: &quot; + protocol);</span>
        }
<span class="fc" id="L416">        this.handler = handler;</span>
<span class="fc" id="L417">    }</span>

    /**
     * Creates a {@code URL} object from the {@code String}
     * representation.
     * &lt;p&gt;
     * This constructor is equivalent to a call to the two-argument
     * constructor with a {@code null} first argument.
     *
     * @param      spec   the {@code String} to parse as a URL.
     * @exception  MalformedURLException  if no protocol is specified, or an
     *               unknown protocol is found, or {@code spec} is {@code null}.
     * @see        java.net.URL#URL(java.net.URL, java.lang.String)
     */
    public URL(String spec) throws MalformedURLException {
<span class="fc" id="L432">        this(null, spec);</span>
<span class="fc" id="L433">    }</span>

    /**
     * Creates a URL by parsing the given spec within a specified context.
     *
     * The new URL is created from the given context URL and the spec
     * argument as described in
     * RFC2396 &amp;quot;Uniform Resource Identifiers : Generic * Syntax&amp;quot; :
     * &lt;blockquote&gt;&lt;pre&gt;
     *          &amp;lt;scheme&amp;gt;://&amp;lt;authority&amp;gt;&amp;lt;path&amp;gt;?&amp;lt;query&amp;gt;#&amp;lt;fragment&amp;gt;
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * The reference is parsed into the scheme, authority, path, query and
     * fragment parts. If the path component is empty and the scheme,
     * authority, and query components are undefined, then the new URL is a
     * reference to the current document. Otherwise, the fragment and query
     * parts present in the spec are used in the new URL.
     * &lt;p&gt;
     * If the scheme component is defined in the given spec and does not match
     * the scheme of the context, then the new URL is created as an absolute
     * URL based on the spec alone. Otherwise the scheme component is inherited
     * from the context URL.
     * &lt;p&gt;
     * If the authority component is present in the spec then the spec is
     * treated as absolute and the spec authority and path will replace the
     * context authority and path. If the authority component is absent in the
     * spec then the authority of the new URL will be inherited from the
     * context.
     * &lt;p&gt;
     * If the spec's path component begins with a slash character
     * &amp;quot;/&amp;quot; then the
     * path is treated as absolute and the spec path replaces the context path.
     * &lt;p&gt;
     * Otherwise, the path is treated as a relative path and is appended to the
     * context path, as described in RFC2396. Also, in this case,
     * the path is canonicalized through the removal of directory
     * changes made by occurrences of &amp;quot;..&amp;quot; and &amp;quot;.&amp;quot;.
     * &lt;p&gt;
     * For a more detailed description of URL parsing, refer to RFC2396.
     *
     * @param      context   the context in which to parse the specification.
     * @param      spec      the {@code String} to parse as a URL.
     * @exception  MalformedURLException  if no protocol is specified, or an
     *               unknown protocol is found, or {@code spec} is {@code null}.
     * @see        java.net.URL#URL(java.lang.String, java.lang.String,
     *                  int, java.lang.String)
     * @see        java.net.URLStreamHandler
     * @see        java.net.URLStreamHandler#parseURL(java.net.URL,
     *                  java.lang.String, int, int)
     */
    public URL(URL context, String spec) throws MalformedURLException {
<span class="fc" id="L483">        this(context, spec, null);</span>
<span class="fc" id="L484">    }</span>

    /**
     * Creates a URL by parsing the given spec with the specified handler
     * within a specified context. If the handler is null, the parsing
     * occurs as with the two argument constructor.
     *
     * @param      context   the context in which to parse the specification.
     * @param      spec      the {@code String} to parse as a URL.
     * @param      handler   the stream handler for the URL.
     * @exception  MalformedURLException  if no protocol is specified, or an
     *               unknown protocol is found, or {@code spec} is {@code null}.
     * @exception  SecurityException
     *        if a security manager exists and its
     *        {@code checkPermission} method doesn't allow
     *        specifying a stream handler.
     * @see        java.net.URL#URL(java.lang.String, java.lang.String,
     *                  int, java.lang.String)
     * @see        java.net.URLStreamHandler
     * @see        java.net.URLStreamHandler#parseURL(java.net.URL,
     *                  java.lang.String, int, int)
     */
    public URL(URL context, String spec, URLStreamHandler handler)
        throws MalformedURLException
<span class="fc" id="L508">    {</span>
<span class="fc" id="L509">        String original = spec;</span>
        int i, limit, c;
<span class="fc" id="L511">        int start = 0;</span>
<span class="fc" id="L512">        String newProtocol = null;</span>
<span class="fc" id="L513">        boolean aRef=false;</span>
<span class="fc" id="L514">        boolean isRelative = false;</span>

        // Check for permission to specify a handler
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (handler != null) {</span>
<span class="fc" id="L518">            SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">            if (sm != null) {</span>
<span class="fc" id="L520">                checkSpecifyHandler(sm);</span>
            }
        }

        try {
<span class="fc" id="L525">            limit = spec.length();</span>
<span class="pc bpc" id="L526" title="2 of 4 branches missed.">            while ((limit &gt; 0) &amp;&amp; (spec.charAt(limit - 1) &lt;= ' ')) {</span>
<span class="nc" id="L527">                limit--;        //eliminate trailing whitespace</span>
            }
<span class="pc bpc" id="L529" title="2 of 4 branches missed.">            while ((start &lt; limit) &amp;&amp; (spec.charAt(start) &lt;= ' ')) {</span>
<span class="nc" id="L530">                start++;        // eliminate leading whitespace</span>
            }

<span class="pc bpc" id="L533" title="1 of 2 branches missed.">            if (spec.regionMatches(true, start, &quot;url:&quot;, 0, 4)) {</span>
<span class="nc" id="L534">                start += 4;</span>
            }
<span class="pc bpc" id="L536" title="1 of 4 branches missed.">            if (start &lt; spec.length() &amp;&amp; spec.charAt(start) == '#') {</span>
                /* we're assuming this is a ref relative to the context URL.
                 * This means protocols cannot start w/ '#', but we must parse
                 * ref URL's like: &quot;hello:there&quot; w/ a ':' in them.
                 */
<span class="fc" id="L541">                aRef=true;</span>
            }
<span class="fc bfc" id="L543" title="All 4 branches covered.">            for (i = start ; !aRef &amp;&amp; (i &lt; limit) &amp;&amp;</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">                     ((c = spec.charAt(i)) != '/') ; i++) {</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">                if (c == ':') {</span>

<span class="fc" id="L547">                    String s = spec.substring(start, i).toLowerCase();</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">                    if (isValidProtocol(s)) {</span>
<span class="fc" id="L549">                        newProtocol = s;</span>
<span class="fc" id="L550">                        start = i + 1;</span>
                    }
                    break;
                }
            }

            // Only use our context if the protocols match.
<span class="fc" id="L557">            protocol = newProtocol;</span>
<span class="fc bfc" id="L558" title="All 4 branches covered.">            if ((context != null) &amp;&amp; ((newProtocol == null) ||</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">                            newProtocol.equalsIgnoreCase(context.protocol))) {</span>
                // inherit the protocol handler from the context
                // if not specified to the constructor
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">                if (handler == null) {</span>
<span class="fc" id="L563">                    handler = context.handler;</span>
                }

                // If the context is a hierarchical URL scheme and the spec
                // contains a matching scheme then maintain backwards
                // compatibility and treat it as if the spec didn't contain
                // the scheme; see 5.2.3 of RFC2396
<span class="pc bpc" id="L570" title="1 of 4 branches missed.">                if (context.path != null &amp;&amp; context.path.startsWith(&quot;/&quot;))</span>
<span class="fc" id="L571">                    newProtocol = null;</span>

<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                if (newProtocol == null) {</span>
<span class="fc" id="L574">                    protocol = context.protocol;</span>
<span class="fc" id="L575">                    authority = context.authority;</span>
<span class="fc" id="L576">                    userInfo = context.userInfo;</span>
<span class="fc" id="L577">                    host = context.host;</span>
<span class="fc" id="L578">                    port = context.port;</span>
<span class="fc" id="L579">                    file = context.file;</span>
<span class="fc" id="L580">                    path = context.path;</span>
<span class="fc" id="L581">                    isRelative = true;</span>
                }
            }

<span class="fc bfc" id="L585" title="All 2 branches covered.">            if (protocol == null) {</span>
<span class="fc" id="L586">                throw new MalformedURLException(&quot;no protocol: &quot;+original);</span>
            }

            // Get the protocol handler if not specified or the protocol
            // of the context could not be used
<span class="fc bfc" id="L591" title="All 2 branches covered.">            if (handler == null &amp;&amp;</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">                (handler = getURLStreamHandler(protocol)) == null) {</span>
<span class="fc" id="L593">                throw new MalformedURLException(&quot;unknown protocol: &quot;+protocol);</span>
            }

<span class="fc" id="L596">            this.handler = handler;</span>

<span class="fc" id="L598">            i = spec.indexOf('#', start);</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">            if (i &gt;= 0) {</span>
<span class="fc" id="L600">                ref = spec.substring(i + 1, limit);</span>
<span class="fc" id="L601">                limit = i;</span>
            }

            /*
             * Handle special case inheritance of query and fragment
             * implied by RFC2396 section 5.2.2.
             */
<span class="fc bfc" id="L608" title="All 4 branches covered.">            if (isRelative &amp;&amp; start == limit) {</span>
<span class="fc" id="L609">                query = context.query;</span>
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">                if (ref == null) {</span>
<span class="nc" id="L611">                    ref = context.ref;</span>
                }
            }

<span class="fc" id="L615">            handler.parseURL(this, spec, start, limit);</span>

<span class="fc" id="L617">        } catch(MalformedURLException e) {</span>
<span class="fc" id="L618">            throw e;</span>
<span class="fc" id="L619">        } catch(Exception e) {</span>
<span class="fc" id="L620">            MalformedURLException exception = new MalformedURLException(e.getMessage());</span>
<span class="fc" id="L621">            exception.initCause(e);</span>
<span class="fc" id="L622">            throw exception;</span>
<span class="fc" id="L623">        }</span>
<span class="fc" id="L624">    }</span>

    /*
     * Returns true if specified string is a valid protocol name.
     */
    private boolean isValidProtocol(String protocol) {
<span class="fc" id="L630">        int len = protocol.length();</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">        if (len &lt; 1)</span>
<span class="nc" id="L632">            return false;</span>
<span class="fc" id="L633">        char c = protocol.charAt(0);</span>
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">        if (!Character.isLetter(c))</span>
<span class="nc" id="L635">            return false;</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">        for (int i = 1; i &lt; len; i++) {</span>
<span class="fc" id="L637">            c = protocol.charAt(i);</span>
<span class="pc bpc" id="L638" title="7 of 8 branches missed.">            if (!Character.isLetterOrDigit(c) &amp;&amp; c != '.' &amp;&amp; c != '+' &amp;&amp;</span>
                c != '-') {
<span class="nc" id="L640">                return false;</span>
            }
        }
<span class="fc" id="L643">        return true;</span>
    }

    /*
     * Checks for permission to specify a stream handler.
     */
    private void checkSpecifyHandler(SecurityManager sm) {
<span class="fc" id="L650">        sm.checkPermission(SecurityConstants.SPECIFY_HANDLER_PERMISSION);</span>
<span class="fc" id="L651">    }</span>

    /**
     * Sets the fields of the URL. This is not a public method so that
     * only URLStreamHandlers can modify URL fields. URLs are
     * otherwise constant.
     *
     * @param protocol the name of the protocol to use
     * @param host the name of the host
       @param port the port number on the host
     * @param file the file on the host
     * @param ref the internal reference in the URL
     */
    void set(String protocol, String host, int port,
             String file, String ref) {
<span class="nc" id="L666">        synchronized (this) {</span>
<span class="nc" id="L667">            this.protocol = protocol;</span>
<span class="nc" id="L668">            this.host = host;</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">            authority = port == -1 ? host : host + &quot;:&quot; + port;</span>
<span class="nc" id="L670">            this.port = port;</span>
<span class="nc" id="L671">            this.file = file;</span>
<span class="nc" id="L672">            this.ref = ref;</span>
            /* This is very important. We must recompute this after the
             * URL has been changed. */
<span class="nc" id="L675">            hashCode = -1;</span>
<span class="nc" id="L676">            hostAddress = null;</span>
<span class="nc" id="L677">            int q = file.lastIndexOf('?');</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">            if (q != -1) {</span>
<span class="nc" id="L679">                query = file.substring(q+1);</span>
<span class="nc" id="L680">                path = file.substring(0, q);</span>
            } else
<span class="nc" id="L682">                path = file;</span>
<span class="nc" id="L683">        }</span>
<span class="nc" id="L684">    }</span>

    /**
     * Sets the specified 8 fields of the URL. This is not a public method so
     * that only URLStreamHandlers can modify URL fields. URLs are otherwise
     * constant.
     *
     * @param protocol the name of the protocol to use
     * @param host the name of the host
     * @param port the port number on the host
     * @param authority the authority part for the url
     * @param userInfo the username and password
     * @param path the file on the host
     * @param ref the internal reference in the URL
     * @param query the query part of this URL
     * @since 1.3
     */
    void set(String protocol, String host, int port,
             String authority, String userInfo, String path,
             String query, String ref) {
<span class="fc" id="L704">        synchronized (this) {</span>
<span class="fc" id="L705">            this.protocol = protocol;</span>
<span class="fc" id="L706">            this.host = host;</span>
<span class="fc" id="L707">            this.port = port;</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">            this.file = query == null ? path : path + &quot;?&quot; + query;</span>
<span class="fc" id="L709">            this.userInfo = userInfo;</span>
<span class="fc" id="L710">            this.path = path;</span>
<span class="fc" id="L711">            this.ref = ref;</span>
            /* This is very important. We must recompute this after the
             * URL has been changed. */
<span class="fc" id="L714">            hashCode = -1;</span>
<span class="fc" id="L715">            hostAddress = null;</span>
<span class="fc" id="L716">            this.query = query;</span>
<span class="fc" id="L717">            this.authority = authority;</span>
<span class="pc" id="L718">        }</span>
<span class="fc" id="L719">    }</span>

    /**
     * Gets the query part of this {@code URL}.
     *
     * @return  the query part of this {@code URL},
     * or &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist
     * @since 1.3
     */
    public String getQuery() {
<span class="fc" id="L729">        return query;</span>
    }

    /**
     * Gets the path part of this {@code URL}.
     *
     * @return  the path part of this {@code URL}, or an
     * empty string if one does not exist
     * @since 1.3
     */
    public String getPath() {
<span class="fc" id="L740">        return path;</span>
    }

    /**
     * Gets the userInfo part of this {@code URL}.
     *
     * @return  the userInfo part of this {@code URL}, or
     * &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist
     * @since 1.3
     */
    public String getUserInfo() {
<span class="fc" id="L751">        return userInfo;</span>
    }

    /**
     * Gets the authority part of this {@code URL}.
     *
     * @return  the authority part of this {@code URL}
     * @since 1.3
     */
    public String getAuthority() {
<span class="fc" id="L761">        return authority;</span>
    }

    /**
     * Gets the port number of this {@code URL}.
     *
     * @return  the port number, or -1 if the port is not set
     */
    public int getPort() {
<span class="fc" id="L770">        return port;</span>
    }

    /**
     * Gets the default port number of the protocol associated
     * with this {@code URL}. If the URL scheme or the URLStreamHandler
     * for the URL do not define a default port number,
     * then -1 is returned.
     *
     * @return  the port number
     * @since 1.4
     */
    public int getDefaultPort() {
<span class="fc" id="L783">        return handler.getDefaultPort();</span>
    }

    /**
     * Gets the protocol name of this {@code URL}.
     *
     * @return  the protocol of this {@code URL}.
     */
    public String getProtocol() {
<span class="fc" id="L792">        return protocol;</span>
    }

    /**
     * Gets the host name of this {@code URL}, if applicable.
     * The format of the host conforms to RFC 2732, i.e. for a
     * literal IPv6 address, this method will return the IPv6 address
     * enclosed in square brackets ({@code '['} and {@code ']'}).
     *
     * @return  the host name of this {@code URL}.
     */
    public String getHost() {
<span class="fc" id="L804">        return host;</span>
    }

    /**
     * Gets the file name of this {@code URL}.
     * The returned file portion will be
     * the same as &lt;CODE&gt;getPath()&lt;/CODE&gt;, plus the concatenation of
     * the value of &lt;CODE&gt;getQuery()&lt;/CODE&gt;, if any. If there is
     * no query portion, this method and &lt;CODE&gt;getPath()&lt;/CODE&gt; will
     * return identical results.
     *
     * @return  the file name of this {@code URL},
     * or an empty string if one does not exist
     */
    public String getFile() {
<span class="fc" id="L819">        return file;</span>
    }

    /**
     * Gets the anchor (also known as the &quot;reference&quot;) of this
     * {@code URL}.
     *
     * @return  the anchor (also known as the &quot;reference&quot;) of this
     *          {@code URL}, or &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist
     */
    public String getRef() {
<span class="fc" id="L830">        return ref;</span>
    }

    /**
     * Compares this URL for equality with another object.&lt;p&gt;
     *
     * If the given object is not a URL then this method immediately returns
     * {@code false}.&lt;p&gt;
     *
     * Two URL objects are equal if they have the same protocol, reference
     * equivalent hosts, have the same port number on the host, and the same
     * file and fragment of the file.&lt;p&gt;
     *
     * Two hosts are considered equivalent if both host names can be resolved
     * into the same IP addresses; else if either host name can't be
     * resolved, the host names must be equal without regard to case; or both
     * host names equal to null.&lt;p&gt;
     *
     * Since hosts comparison requires name resolution, this operation is a
     * blocking operation. &lt;p&gt;
     *
     * Note: The defined behavior for {@code equals} is known to
     * be inconsistent with virtual hosting in HTTP.
     *
     * @param   obj   the URL to compare against.
     * @return  {@code true} if the objects are the same;
     *          {@code false} otherwise.
     */
    public boolean equals(Object obj) {
<span class="fc bfc" id="L859" title="All 2 branches covered.">        if (!(obj instanceof URL))</span>
<span class="fc" id="L860">            return false;</span>
<span class="fc" id="L861">        URL u2 = (URL)obj;</span>

<span class="fc" id="L863">        return handler.equals(this, u2);</span>
    }

    /**
     * Creates an integer suitable for hash table indexing.&lt;p&gt;
     *
     * The hash code is based upon all the URL components relevant for URL
     * comparison. As such, this operation is a blocking operation.&lt;p&gt;
     *
     * @return  a hash code for this {@code URL}.
     */
    public synchronized int hashCode() {
<span class="fc bfc" id="L875" title="All 2 branches covered.">        if (hashCode != -1)</span>
<span class="fc" id="L876">            return hashCode;</span>

<span class="fc" id="L878">        hashCode = handler.hashCode(this);</span>
<span class="fc" id="L879">        return hashCode;</span>
    }

    /**
     * Compares two URLs, excluding the fragment component.&lt;p&gt;
     *
     * Returns {@code true} if this {@code URL} and the
     * {@code other} argument are equal without taking the
     * fragment component into consideration.
     *
     * @param   other   the {@code URL} to compare against.
     * @return  {@code true} if they reference the same remote object;
     *          {@code false} otherwise.
     */
    public boolean sameFile(URL other) {
<span class="fc" id="L894">        return handler.sameFile(this, other);</span>
    }

    /**
     * Constructs a string representation of this {@code URL}. The
     * string is created by calling the {@code toExternalForm}
     * method of the stream protocol handler for this object.
     *
     * @return  a string representation of this object.
     * @see     java.net.URL#URL(java.lang.String, java.lang.String, int,
     *                  java.lang.String)
     * @see     java.net.URLStreamHandler#toExternalForm(java.net.URL)
     */
    public String toString() {
<span class="fc" id="L908">        return toExternalForm();</span>
    }

    /**
     * Constructs a string representation of this {@code URL}. The
     * string is created by calling the {@code toExternalForm}
     * method of the stream protocol handler for this object.
     *
     * @return  a string representation of this object.
     * @see     java.net.URL#URL(java.lang.String, java.lang.String,
     *                  int, java.lang.String)
     * @see     java.net.URLStreamHandler#toExternalForm(java.net.URL)
     */
    public String toExternalForm() {
<span class="fc" id="L922">        return handler.toExternalForm(this);</span>
    }

    /**
     * Returns a {@link java.net.URI} equivalent to this URL.
     * This method functions in the same way as {@code new URI (this.toString())}.
     * &lt;p&gt;Note, any URL instance that complies with RFC 2396 can be converted
     * to a URI. However, some URLs that are not strictly in compliance
     * can not be converted to a URI.
     *
     * @exception URISyntaxException if this URL is not formatted strictly according to
     *            to RFC2396 and cannot be converted to a URI.
     *
     * @return    a URI instance equivalent to this URL.
     * @since 1.5
     */
    public URI toURI() throws URISyntaxException {
<span class="fc" id="L939">        return new URI (toString());</span>
    }

    /**
     * Returns a {@link java.net.URLConnection URLConnection} instance that
     * represents a connection to the remote object referred to by the
     * {@code URL}.
     *
     * &lt;P&gt;A new instance of {@linkplain java.net.URLConnection URLConnection} is
     * created every time when invoking the
     * {@linkplain java.net.URLStreamHandler#openConnection(URL)
     * URLStreamHandler.openConnection(URL)} method of the protocol handler for
     * this URL.&lt;/P&gt;
     *
     * &lt;P&gt;It should be noted that a URLConnection instance does not establish
     * the actual network connection on creation. This will happen only when
     * calling {@linkplain java.net.URLConnection#connect() URLConnection.connect()}.&lt;/P&gt;
     *
     * &lt;P&gt;If for the URL's protocol (such as HTTP or JAR), there
     * exists a public, specialized URLConnection subclass belonging
     * to one of the following packages or one of their subpackages:
     * java.lang, java.io, java.util, java.net, the connection
     * returned will be of that subclass. For example, for HTTP an
     * HttpURLConnection will be returned, and for JAR a
     * JarURLConnection will be returned.&lt;/P&gt;
     *
     * @return     a {@link java.net.URLConnection URLConnection} linking
     *             to the URL.
     * @exception  IOException  if an I/O exception occurs.
     * @see        java.net.URL#URL(java.lang.String, java.lang.String,
     *             int, java.lang.String)
     */
    public URLConnection openConnection() throws java.io.IOException {
<span class="fc" id="L972">        return handler.openConnection(this);</span>
    }

    /**
     * Same as {@link #openConnection()}, except that the connection will be
     * made through the specified proxy; Protocol handlers that do not
     * support proxing will ignore the proxy parameter and make a
     * normal connection.
     *
     * Invoking this method preempts the system's default ProxySelector
     * settings.
     *
     * @param      proxy the Proxy through which this connection
     *             will be made. If direct connection is desired,
     *             Proxy.NO_PROXY should be specified.
     * @return     a {@code URLConnection} to the URL.
     * @exception  IOException  if an I/O exception occurs.
     * @exception  SecurityException if a security manager is present
     *             and the caller doesn't have permission to connect
     *             to the proxy.
     * @exception  IllegalArgumentException will be thrown if proxy is null,
     *             or proxy has the wrong type
     * @exception  UnsupportedOperationException if the subclass that
     *             implements the protocol handler doesn't support
     *             this method.
     * @see        java.net.URL#URL(java.lang.String, java.lang.String,
     *             int, java.lang.String)
     * @see        java.net.URLConnection
     * @see        java.net.URLStreamHandler#openConnection(java.net.URL,
     *             java.net.Proxy)
     * @since      1.5
     */
    public URLConnection openConnection(Proxy proxy)
        throws java.io.IOException {
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">        if (proxy == null) {</span>
<span class="nc" id="L1007">            throw new IllegalArgumentException(&quot;proxy can not be null&quot;);</span>
        }

        // Create a copy of Proxy as a security measure
<span class="fc bfc" id="L1011" title="All 2 branches covered.">        Proxy p = proxy == Proxy.NO_PROXY ? Proxy.NO_PROXY : sun.net.ApplicationProxy.create(proxy);</span>
<span class="fc" id="L1012">        SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L1013" title="1 of 4 branches missed.">        if (p.type() != Proxy.Type.DIRECT &amp;&amp; sm != null) {</span>
<span class="nc" id="L1014">            InetSocketAddress epoint = (InetSocketAddress) p.address();</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">            if (epoint.isUnresolved())</span>
<span class="nc" id="L1016">                sm.checkConnect(epoint.getHostName(), epoint.getPort());</span>
            else
<span class="nc" id="L1018">                sm.checkConnect(epoint.getAddress().getHostAddress(),</span>
<span class="nc" id="L1019">                                epoint.getPort());</span>
        }
<span class="fc" id="L1021">        return handler.openConnection(this, p);</span>
    }

    /**
     * Opens a connection to this {@code URL} and returns an
     * {@code InputStream} for reading from that connection. This
     * method is a shorthand for:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     openConnection().getInputStream()
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return     an input stream for reading from the URL connection.
     * @exception  IOException  if an I/O exception occurs.
     * @see        java.net.URL#openConnection()
     * @see        java.net.URLConnection#getInputStream()
     */
    public final InputStream openStream() throws java.io.IOException {
<span class="fc" id="L1038">        return openConnection().getInputStream();</span>
    }

    /**
     * Gets the contents of this URL. This method is a shorthand for:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     openConnection().getContent()
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return     the contents of this URL.
     * @exception  IOException  if an I/O exception occurs.
     * @see        java.net.URLConnection#getContent()
     */
    public final Object getContent() throws java.io.IOException {
<span class="fc" id="L1052">        return openConnection().getContent();</span>
    }

    /**
     * Gets the contents of this URL. This method is a shorthand for:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     openConnection().getContent(Class[])
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param classes an array of Java types
     * @return     the content object of this URL that is the first match of
     *               the types specified in the classes array.
     *               null if none of the requested types are supported.
     * @exception  IOException  if an I/O exception occurs.
     * @see        java.net.URLConnection#getContent(Class[])
     * @since 1.3
     */
    public final Object getContent(Class[] classes)
    throws java.io.IOException {
<span class="nc" id="L1071">        return openConnection().getContent(classes);</span>
    }

    /**
     * The URLStreamHandler factory.
     */
    static URLStreamHandlerFactory factory;

    /**
     * Sets an application's {@code URLStreamHandlerFactory}.
     * This method can be called at most once in a given Java Virtual
     * Machine.
     *
     *&lt;p&gt; The {@code URLStreamHandlerFactory} instance is used to
     *construct a stream protocol handler from a protocol name.
     *
     * &lt;p&gt; If there is a security manager, this method first calls
     * the security manager's {@code checkSetFactory} method
     * to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * @param      fac   the desired factory.
     * @exception  Error  if the application has already set a factory.
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkSetFactory} method doesn't allow
     *             the operation.
     * @see        java.net.URL#URL(java.lang.String, java.lang.String,
     *             int, java.lang.String)
     * @see        java.net.URLStreamHandlerFactory
     * @see        SecurityManager#checkSetFactory
     */
    public static void setURLStreamHandlerFactory(URLStreamHandlerFactory fac) {
<span class="fc" id="L1103">        synchronized (streamHandlerLock) {</span>
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">            if (factory != null) {</span>
<span class="nc" id="L1105">                throw new Error(&quot;factory already defined&quot;);</span>
            }
<span class="fc" id="L1107">            SecurityManager security = System.getSecurityManager();</span>
<span class="pc bpc" id="L1108" title="1 of 2 branches missed.">            if (security != null) {</span>
<span class="fc" id="L1109">                security.checkSetFactory();</span>
            }
<span class="fc" id="L1111">            handlers.clear();</span>
<span class="fc" id="L1112">            factory = fac;</span>
<span class="pc" id="L1113">        }</span>
<span class="fc" id="L1114">    }</span>

    /**
     * A table of protocol handlers.
     */
<span class="fc" id="L1119">    static Hashtable&lt;String,URLStreamHandler&gt; handlers = new Hashtable&lt;&gt;();</span>
<span class="fc" id="L1120">    private static Object streamHandlerLock = new Object();</span>

    /**
     * Returns the Stream Handler.
     * @param protocol the protocol to use
     */
    static URLStreamHandler getURLStreamHandler(String protocol) {

<span class="fc" id="L1128">        URLStreamHandler handler = handlers.get(protocol);</span>
<span class="fc bfc" id="L1129" title="All 2 branches covered.">        if (handler == null) {</span>

<span class="fc" id="L1131">            boolean checkedWithFactory = false;</span>

            // Use the factory (if any)
<span class="fc bfc" id="L1134" title="All 2 branches covered.">            if (factory != null) {</span>
<span class="fc" id="L1135">                handler = factory.createURLStreamHandler(protocol);</span>
<span class="fc" id="L1136">                checkedWithFactory = true;</span>
            }

            // Try java protocol handler
<span class="fc bfc" id="L1140" title="All 2 branches covered.">            if (handler == null) {</span>
<span class="fc" id="L1141">                String packagePrefixList = null;</span>

<span class="fc" id="L1143">                packagePrefixList</span>
<span class="fc" id="L1144">                    = java.security.AccessController.doPrivileged(</span>
                    new sun.security.action.GetPropertyAction(
                        protocolPathProp,&quot;&quot;));
<span class="fc bfc" id="L1147" title="All 2 branches covered.">                if (packagePrefixList != &quot;&quot;) {</span>
<span class="fc" id="L1148">                    packagePrefixList += &quot;|&quot;;</span>
                }

                // REMIND: decide whether to allow the &quot;null&quot; class prefix
                // or not.
<span class="fc" id="L1153">                packagePrefixList += &quot;sun.net.www.protocol&quot;;</span>

<span class="fc" id="L1155">                StringTokenizer packagePrefixIter =</span>
                    new StringTokenizer(packagePrefixList, &quot;|&quot;);

<span class="fc bfc" id="L1158" title="All 2 branches covered.">                while (handler == null &amp;&amp;</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">                       packagePrefixIter.hasMoreTokens()) {</span>

<span class="fc" id="L1161">                    String packagePrefix =</span>
<span class="fc" id="L1162">                      packagePrefixIter.nextToken().trim();</span>
                    try {
<span class="fc" id="L1164">                        String clsName = packagePrefix + &quot;.&quot; + protocol +</span>
                          &quot;.Handler&quot;;
<span class="fc" id="L1166">                        Class&lt;?&gt; cls = null;</span>
                        try {
<span class="fc" id="L1168">                            cls = Class.forName(clsName);</span>
<span class="nc" id="L1169">                        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1170">                            ClassLoader cl = ClassLoader.getSystemClassLoader();</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">                            if (cl != null) {</span>
<span class="nc" id="L1172">                                cls = cl.loadClass(clsName);</span>
                            }
<span class="fc" id="L1174">                        }</span>
<span class="pc bpc" id="L1175" title="1 of 2 branches missed.">                        if (cls != null) {</span>
<span class="fc" id="L1176">                            handler  =</span>
<span class="fc" id="L1177">                              (URLStreamHandler)cls.newInstance();</span>
                        }
<span class="fc" id="L1179">                    } catch (Exception e) {</span>
                        // any number of exceptions can get thrown here
<span class="fc" id="L1181">                    }</span>
<span class="fc" id="L1182">                }</span>
            }

<span class="fc" id="L1185">            synchronized (streamHandlerLock) {</span>

<span class="fc" id="L1187">                URLStreamHandler handler2 = null;</span>

                // Check again with hashtable just in case another
                // thread created a handler since we last checked
<span class="fc" id="L1191">                handler2 = handlers.get(protocol);</span>

<span class="fc bfc" id="L1193" title="All 2 branches covered.">                if (handler2 != null) {</span>
<span class="fc" id="L1194">                    return handler2;</span>
                }

                // Check with factory if another thread set a
                // factory since our last check
<span class="pc bpc" id="L1199" title="1 of 4 branches missed.">                if (!checkedWithFactory &amp;&amp; factory != null) {</span>
<span class="nc" id="L1200">                    handler2 = factory.createURLStreamHandler(protocol);</span>
                }

<span class="pc bpc" id="L1203" title="1 of 2 branches missed.">                if (handler2 != null) {</span>
                    // The handler from the factory must be given more
                    // importance. Discard the default handler that
                    // this thread created.
<span class="nc" id="L1207">                    handler = handler2;</span>
                }

                // Insert this handler into the hashtable
<span class="fc bfc" id="L1211" title="All 2 branches covered.">                if (handler != null) {</span>
<span class="fc" id="L1212">                    handlers.put(protocol, handler);</span>
                }

<span class="pc" id="L1215">            }</span>
        }

<span class="fc" id="L1218">        return handler;</span>

    }

    /**
     * WriteObject is called to save the state of the URL to an
     * ObjectOutputStream. The handler is not saved since it is
     * specific to this system.
     *
     * @serialData the default write object value. When read back in,
     * the reader must ensure that calling getURLStreamHandler with
     * the protocol variable returns a valid URLStreamHandler and
     * throw an IOException if it does not.
     */
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException
    {
<span class="nc" id="L1235">        s.defaultWriteObject(); // write the fields</span>
<span class="nc" id="L1236">    }</span>

    /**
     * readObject is called to restore the state of the URL from the
     * stream.  It reads the components of the URL and finds the local
     * stream handler.
     */
    private synchronized void readObject(java.io.ObjectInputStream s)
         throws IOException, ClassNotFoundException
    {
<span class="nc" id="L1246">        s.defaultReadObject();  // read the fields</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">        if ((handler = getURLStreamHandler(protocol)) == null) {</span>
<span class="nc" id="L1248">            throw new IOException(&quot;unknown protocol: &quot; + protocol);</span>
        }

        // Construct authority part
<span class="nc bnc" id="L1252" title="All 4 branches missed.">        if (authority == null &amp;&amp;</span>
<span class="nc bnc" id="L1253" title="All 4 branches missed.">            ((host != null &amp;&amp; host.length() &gt; 0) || port != -1)) {</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">            if (host == null)</span>
<span class="nc" id="L1255">                host = &quot;&quot;;</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">            authority = (port == -1) ? host : host + &quot;:&quot; + port;</span>

            // Handle hosts with userInfo in them
<span class="nc" id="L1259">            int at = host.lastIndexOf('@');</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">            if (at != -1) {</span>
<span class="nc" id="L1261">                userInfo = host.substring(0, at);</span>
<span class="nc" id="L1262">                host = host.substring(at+1);</span>
            }
<span class="nc bnc" id="L1264" title="All 2 branches missed.">        } else if (authority != null) {</span>
            // Construct user info part
<span class="nc" id="L1266">            int ind = authority.indexOf('@');</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">            if (ind != -1)</span>
<span class="nc" id="L1268">                userInfo = authority.substring(0, ind);</span>
        }

        // Construct path and query part
<span class="nc" id="L1272">        path = null;</span>
<span class="nc" id="L1273">        query = null;</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">        if (file != null) {</span>
            // Fix: only do this if hierarchical?
<span class="nc" id="L1276">            int q = file.lastIndexOf('?');</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">            if (q != -1) {</span>
<span class="nc" id="L1278">                query = file.substring(q+1);</span>
<span class="nc" id="L1279">                path = file.substring(0, q);</span>
            } else
<span class="nc" id="L1281">                path = file;</span>
        }
<span class="nc" id="L1283">    }</span>
}

class Parts {
    String path, query, ref;

<span class="fc" id="L1289">    Parts(String file) {</span>
<span class="fc" id="L1290">        int ind = file.indexOf('#');</span>
<span class="pc bpc" id="L1291" title="1 of 2 branches missed.">        ref = ind &lt; 0 ? null: file.substring(ind + 1);</span>
<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">        file = ind &lt; 0 ? file: file.substring(0, ind);</span>
<span class="fc" id="L1293">        int q = file.lastIndexOf('?');</span>
<span class="pc bpc" id="L1294" title="1 of 2 branches missed.">        if (q != -1) {</span>
<span class="nc" id="L1295">            query = file.substring(q+1);</span>
<span class="nc" id="L1296">            path = file.substring(0, q);</span>
        } else {
<span class="fc" id="L1298">            path = file;</span>
        }
<span class="fc" id="L1300">    }</span>

    String getPath() {
<span class="fc" id="L1303">        return path;</span>
    }

    String getQuery() {
<span class="fc" id="L1307">        return query;</span>
    }

    String getRef() {
<span class="fc" id="L1311">        return ref;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>