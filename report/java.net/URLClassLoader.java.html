<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>URLClassLoader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">URLClassLoader.java</span></div><h1>URLClassLoader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.io.Closeable;
import java.io.File;
import java.io.FilePermission;
import java.io.IOException;
import java.io.InputStream;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.CodeSigner;
import java.security.CodeSource;
import java.security.Permission;
import java.security.PermissionCollection;
import java.security.PrivilegedAction;
import java.security.PrivilegedExceptionAction;
import java.security.SecureClassLoader;
import java.util.Enumeration;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.jar.Attributes;
import java.util.jar.Attributes.Name;
import java.util.jar.JarFile;
import java.util.jar.Manifest;
import sun.misc.Resource;
import sun.misc.URLClassPath;
import sun.net.www.ParseUtil;
import sun.security.util.SecurityConstants;

/**
 * This class loader is used to load classes and resources from a search
 * path of URLs referring to both JAR files and directories. Any URL that
 * ends with a '/' is assumed to refer to a directory. Otherwise, the URL
 * is assumed to refer to a JAR file which will be opened as needed.
 * &lt;p&gt;
 * The AccessControlContext of the thread that created the instance of
 * URLClassLoader will be used when subsequently loading classes and
 * resources.
 * &lt;p&gt;
 * The classes that are loaded are by default granted permission only to
 * access the URLs specified when the URLClassLoader was created.
 *
 * @author  David Connelly
 * @since   1.2
 */
public class URLClassLoader extends SecureClassLoader implements Closeable {
    /* The search path for classes and resources */
    private final URLClassPath ucp;

    /* The context to be used when loading classes and resources */
    private final AccessControlContext acc;

    /**
     * Constructs a new URLClassLoader for the given URLs. The URLs will be
     * searched in the order specified for classes and resources after first
     * searching in the specified parent class loader. Any URL that ends with
     * a '/' is assumed to refer to a directory. Otherwise, the URL is assumed
     * to refer to a JAR file which will be downloaded and opened as needed.
     *
     * &lt;p&gt;If there is a security manager, this method first
     * calls the security manager's {@code checkCreateClassLoader} method
     * to ensure creation of a class loader is allowed.
     *
     * @param urls the URLs from which to load classes and resources
     * @param parent the parent class loader for delegation
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkCreateClassLoader} method doesn't allow
     *             creation of a class loader.
     * @exception  NullPointerException if {@code urls} is {@code null}.
     * @see SecurityManager#checkCreateClassLoader
     */
    public URLClassLoader(URL[] urls, ClassLoader parent) {
<span class="fc" id="L100">        super(parent);</span>
        // this is to make the stack depth consistent with 1.1
<span class="fc" id="L102">        SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (security != null) {</span>
<span class="fc" id="L104">            security.checkCreateClassLoader();</span>
        }
<span class="fc" id="L106">        ucp = new URLClassPath(urls);</span>
<span class="fc" id="L107">        this.acc = AccessController.getContext();</span>
<span class="fc" id="L108">    }</span>

    URLClassLoader(URL[] urls, ClassLoader parent,
                   AccessControlContext acc) {
<span class="nc" id="L112">        super(parent);</span>
        // this is to make the stack depth consistent with 1.1
<span class="nc" id="L114">        SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (security != null) {</span>
<span class="nc" id="L116">            security.checkCreateClassLoader();</span>
        }
<span class="nc" id="L118">        ucp = new URLClassPath(urls);</span>
<span class="nc" id="L119">        this.acc = acc;</span>
<span class="nc" id="L120">    }</span>

    /**
     * Constructs a new URLClassLoader for the specified URLs using the
     * default delegation parent {@code ClassLoader}. The URLs will
     * be searched in the order specified for classes and resources after
     * first searching in the parent class loader. Any URL that ends with
     * a '/' is assumed to refer to a directory. Otherwise, the URL is
     * assumed to refer to a JAR file which will be downloaded and opened
     * as needed.
     *
     * &lt;p&gt;If there is a security manager, this method first
     * calls the security manager's {@code checkCreateClassLoader} method
     * to ensure creation of a class loader is allowed.
     *
     * @param urls the URLs from which to load classes and resources
     *
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkCreateClassLoader} method doesn't allow
     *             creation of a class loader.
     * @exception  NullPointerException if {@code urls} is {@code null}.
     * @see SecurityManager#checkCreateClassLoader
     */
    public URLClassLoader(URL[] urls) {
<span class="fc" id="L144">        super();</span>
        // this is to make the stack depth consistent with 1.1
<span class="fc" id="L146">        SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (security != null) {</span>
<span class="fc" id="L148">            security.checkCreateClassLoader();</span>
        }
<span class="fc" id="L150">        ucp = new URLClassPath(urls);</span>
<span class="fc" id="L151">        this.acc = AccessController.getContext();</span>
<span class="fc" id="L152">    }</span>

    URLClassLoader(URL[] urls, AccessControlContext acc) {
<span class="fc" id="L155">        super();</span>
        // this is to make the stack depth consistent with 1.1
<span class="fc" id="L157">        SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (security != null) {</span>
<span class="fc" id="L159">            security.checkCreateClassLoader();</span>
        }
<span class="fc" id="L161">        ucp = new URLClassPath(urls);</span>
<span class="fc" id="L162">        this.acc = acc;</span>
<span class="fc" id="L163">    }</span>

    /**
     * Constructs a new URLClassLoader for the specified URLs, parent
     * class loader, and URLStreamHandlerFactory. The parent argument
     * will be used as the parent class loader for delegation. The
     * factory argument will be used as the stream handler factory to
     * obtain protocol handlers when creating new jar URLs.
     *
     * &lt;p&gt;If there is a security manager, this method first
     * calls the security manager's {@code checkCreateClassLoader} method
     * to ensure creation of a class loader is allowed.
     *
     * @param urls the URLs from which to load classes and resources
     * @param parent the parent class loader for delegation
     * @param factory the URLStreamHandlerFactory to use when creating URLs
     *
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkCreateClassLoader} method doesn't allow
     *             creation of a class loader.
     * @exception  NullPointerException if {@code urls} is {@code null}.
     * @see SecurityManager#checkCreateClassLoader
     */
    public URLClassLoader(URL[] urls, ClassLoader parent,
                          URLStreamHandlerFactory factory) {
<span class="fc" id="L188">        super(parent);</span>
        // this is to make the stack depth consistent with 1.1
<span class="fc" id="L190">        SecurityManager security = System.getSecurityManager();</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (security != null) {</span>
<span class="nc" id="L192">            security.checkCreateClassLoader();</span>
        }
<span class="fc" id="L194">        ucp = new URLClassPath(urls, factory);</span>
<span class="fc" id="L195">        acc = AccessController.getContext();</span>
<span class="fc" id="L196">    }</span>

    /* A map (used as a set) to keep track of closeable local resources
     * (either JarFiles or FileInputStreams). We don't care about
     * Http resources since they don't need to be closed.
     *
     * If the resource is coming from a jar file
     * we keep a (weak) reference to the JarFile object which can
     * be closed if URLClassLoader.close() called. Due to jar file
     * caching there will typically be only one JarFile object
     * per underlying jar file.
     *
     * For file resources, which is probably a less common situation
     * we have to keep a weak reference to each stream.
     */

<span class="pc" id="L212">    private WeakHashMap&lt;Closeable,Void&gt;</span>
        closeables = new WeakHashMap&lt;&gt;();

    /**
     * Returns an input stream for reading the specified resource.
     * If this loader is closed, then any resources opened by this method
     * will be closed.
     *
     * &lt;p&gt; The search order is described in the documentation for {@link
     * #getResource(String)}.  &lt;/p&gt;
     *
     * @param  name
     *         The resource name
     *
     * @return  An input stream for reading the resource, or {@code null}
     *          if the resource could not be found
     *
     * @since  1.7
     */
    public InputStream getResourceAsStream(String name) {
<span class="fc" id="L232">        URL url = getResource(name);</span>
        try {
<span class="fc bfc" id="L234" title="All 2 branches covered.">            if (url == null) {</span>
<span class="fc" id="L235">                return null;</span>
            }
<span class="fc" id="L237">            URLConnection urlc = url.openConnection();</span>
<span class="fc" id="L238">            InputStream is = urlc.getInputStream();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            if (urlc instanceof JarURLConnection) {</span>
<span class="fc" id="L240">                JarURLConnection juc = (JarURLConnection)urlc;</span>
<span class="fc" id="L241">                JarFile jar = juc.getJarFile();</span>
<span class="fc" id="L242">                synchronized (closeables) {</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">                    if (!closeables.containsKey(jar)) {</span>
<span class="fc" id="L244">                        closeables.put(jar, null);</span>
                    }
<span class="pc" id="L246">                }</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">            } else if (urlc instanceof sun.net.www.protocol.file.FileURLConnection) {</span>
<span class="fc" id="L248">                synchronized (closeables) {</span>
<span class="fc" id="L249">                    closeables.put(is, null);</span>
<span class="pc" id="L250">                }</span>
            }
<span class="fc" id="L252">            return is;</span>
<span class="nc" id="L253">        } catch (IOException e) {</span>
<span class="nc" id="L254">            return null;</span>
        }
    }

   /**
    * Closes this URLClassLoader, so that it can no longer be used to load
    * new classes or resources that are defined by this loader.
    * Classes and resources defined by any of this loader's parents in the
    * delegation hierarchy are still accessible. Also, any classes or resources
    * that are already loaded, are still accessible.
    * &lt;p&gt;
    * In the case of jar: and file: URLs, it also closes any files
    * that were opened by it. If another thread is loading a
    * class when the {@code close} method is invoked, then the result of
    * that load is undefined.
    * &lt;p&gt;
    * The method makes a best effort attempt to close all opened files,
    * by catching {@link IOException}s internally. Unchecked exceptions
    * and errors are not caught. Calling close on an already closed
    * loader has no effect.
    * &lt;p&gt;
    * @exception IOException if closing any file opened by this class loader
    * resulted in an IOException. Any such exceptions are caught internally.
    * If only one is caught, then it is re-thrown. If more than one exception
    * is caught, then the second and following exceptions are added
    * as suppressed exceptions of the first one caught, which is then re-thrown.
    *
    * @exception SecurityException if a security manager is set, and it denies
    *   {@link RuntimePermission}{@code (&quot;closeClassLoader&quot;)}
    *
    * @since 1.7
    */
    public void close() throws IOException {
<span class="fc" id="L287">        SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (security != null) {</span>
<span class="fc" id="L289">            security.checkPermission(new RuntimePermission(&quot;closeClassLoader&quot;));</span>
        }
<span class="fc" id="L291">        List&lt;IOException&gt; errors = ucp.closeLoaders();</span>

        // now close any remaining streams.

<span class="fc" id="L295">        synchronized (closeables) {</span>
<span class="fc" id="L296">            Set&lt;Closeable&gt; keys = closeables.keySet();</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">            for (Closeable c : keys) {</span>
                try {
<span class="fc" id="L299">                    c.close();</span>
<span class="nc" id="L300">                } catch (IOException ioex) {</span>
<span class="nc" id="L301">                    errors.add(ioex);</span>
<span class="fc" id="L302">                }</span>
<span class="fc" id="L303">            }</span>
<span class="fc" id="L304">            closeables.clear();</span>
<span class="pc" id="L305">        }</span>

<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (errors.isEmpty()) {</span>
<span class="fc" id="L308">            return;</span>
        }

<span class="nc" id="L311">        IOException firstex = errors.remove(0);</span>

        // Suppress any remaining exceptions

<span class="nc bnc" id="L315" title="All 2 branches missed.">        for (IOException error: errors) {</span>
<span class="nc" id="L316">            firstex.addSuppressed(error);</span>
<span class="nc" id="L317">        }</span>
<span class="nc" id="L318">        throw firstex;</span>
    }

    /**
     * Appends the specified URL to the list of URLs to search for
     * classes and resources.
     * &lt;p&gt;
     * If the URL specified is {@code null} or is already in the
     * list of URLs, or if this loader is closed, then invoking this
     * method has no effect.
     *
     * @param url the URL to be added to the search path of URLs
     */
    protected void addURL(URL url) {
<span class="fc" id="L332">        ucp.addURL(url);</span>
<span class="fc" id="L333">    }</span>

    /**
     * Returns the search path of URLs for loading classes and resources.
     * This includes the original list of URLs specified to the constructor,
     * along with any URLs subsequently appended by the addURL() method.
     * @return the search path of URLs for loading classes and resources.
     */
    public URL[] getURLs() {
<span class="fc" id="L342">        return ucp.getURLs();</span>
    }

    /**
     * Finds and loads the class with the specified name from the URL search
     * path. Any URLs referring to JAR files are loaded and opened as needed
     * until the class is found.
     *
     * @param name the name of the class
     * @return the resulting class
     * @exception ClassNotFoundException if the class could not be found,
     *            or if the loader is closed.
     * @exception NullPointerException if {@code name} is {@code null}.
     */
    protected Class&lt;?&gt; findClass(final String name)
         throws ClassNotFoundException
    {
        try {
<span class="fc" id="L360">            return AccessController.doPrivileged(</span>
<span class="fc" id="L361">                new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() {</span>
                    public Class&lt;?&gt; run() throws ClassNotFoundException {
<span class="fc" id="L363">                        String path = name.replace('.', '/').concat(&quot;.class&quot;);</span>
<span class="fc" id="L364">                        Resource res = ucp.getResource(path, false);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">                        if (res != null) {</span>
                            try {
<span class="fc" id="L367">                                return defineClass(name, res);</span>
<span class="nc" id="L368">                            } catch (IOException e) {</span>
<span class="nc" id="L369">                                throw new ClassNotFoundException(name, e);</span>
                            }
                        } else {
<span class="fc" id="L372">                            throw new ClassNotFoundException(name);</span>
                        }
                    }
                }, acc);
<span class="fc" id="L376">        } catch (java.security.PrivilegedActionException pae) {</span>
<span class="fc" id="L377">            throw (ClassNotFoundException) pae.getException();</span>
        }
    }

    /*
     * Retrieve the package using the specified package name.
     * If non-null, verify the package using the specified code
     * source and manifest.
     */
    private Package getAndVerifyPackage(String pkgname,
                                        Manifest man, URL url) {
<span class="fc" id="L388">        Package pkg = getPackage(pkgname);</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (pkg != null) {</span>
            // Package found, so check package sealing.
<span class="fc bfc" id="L391" title="All 2 branches covered.">            if (pkg.isSealed()) {</span>
                // Verify that code source URL is the same.
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">                if (!pkg.isSealed(url)) {</span>
<span class="fc" id="L394">                    throw new SecurityException(</span>
                        &quot;sealing violation: package &quot; + pkgname + &quot; is sealed&quot;);
                }
            } else {
                // Make sure we are not attempting to seal the package
                // at this code source URL.
<span class="fc bfc" id="L400" title="All 4 branches covered.">                if ((man != null) &amp;&amp; isSealed(pkgname, man)) {</span>
<span class="fc" id="L401">                    throw new SecurityException(</span>
                        &quot;sealing violation: can't seal package &quot; + pkgname +
                        &quot;: already loaded&quot;);
                }
            }
        }
<span class="fc" id="L407">        return pkg;</span>
    }

    /*
     * Defines a Class using the class bytes obtained from the specified
     * Resource. The resulting Class must be resolved before it can be
     * used.
     */
    private Class&lt;?&gt; defineClass(String name, Resource res) throws IOException {
<span class="fc" id="L416">        long t0 = System.nanoTime();</span>
<span class="fc" id="L417">        int i = name.lastIndexOf('.');</span>
<span class="fc" id="L418">        URL url = res.getCodeSourceURL();</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        if (i != -1) {</span>
<span class="fc" id="L420">            String pkgname = name.substring(0, i);</span>
            // Check if package already loaded.
<span class="fc" id="L422">            Manifest man = res.getManifest();</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">            if (getAndVerifyPackage(pkgname, man, url) == null) {</span>
                try {
<span class="fc bfc" id="L425" title="All 2 branches covered.">                    if (man != null) {</span>
<span class="fc" id="L426">                        definePackage(pkgname, man, url);</span>
                    } else {
<span class="fc" id="L428">                        definePackage(pkgname, null, null, null, null, null, null, null);</span>
                    }
<span class="nc" id="L430">                } catch (IllegalArgumentException iae) {</span>
                    // parallel-capable class loaders: re-verify in case of a
                    // race condition
<span class="nc bnc" id="L433" title="All 2 branches missed.">                    if (getAndVerifyPackage(pkgname, man, url) == null) {</span>
                        // Should never happen
<span class="nc" id="L435">                        throw new AssertionError(&quot;Cannot find package &quot; +</span>
                                                 pkgname);
                    }
<span class="fc" id="L438">                }</span>
            }
        }
        // Now read the class bytes and define the class
<span class="fc" id="L442">        java.nio.ByteBuffer bb = res.getByteBuffer();</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        if (bb != null) {</span>
            // Use (direct) ByteBuffer:
<span class="nc" id="L445">            CodeSigner[] signers = res.getCodeSigners();</span>
<span class="nc" id="L446">            CodeSource cs = new CodeSource(url, signers);</span>
<span class="nc" id="L447">            sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span>
<span class="nc" id="L448">            return defineClass(name, bb, cs);</span>
        } else {
<span class="fc" id="L450">            byte[] b = res.getBytes();</span>
            // must read certificates AFTER reading bytes.
<span class="fc" id="L452">            CodeSigner[] signers = res.getCodeSigners();</span>
<span class="fc" id="L453">            CodeSource cs = new CodeSource(url, signers);</span>
<span class="fc" id="L454">            sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span>
<span class="fc" id="L455">            return defineClass(name, b, 0, b.length, cs);</span>
        }
    }

    /**
     * Defines a new package by name in this ClassLoader. The attributes
     * contained in the specified Manifest will be used to obtain package
     * version and sealing information. For sealed packages, the additional
     * URL specifies the code source URL from which the package was loaded.
     *
     * @param name  the package name
     * @param man   the Manifest containing package version and sealing
     *              information
     * @param url   the code source url for the package, or null if none
     * @exception   IllegalArgumentException if the package name duplicates
     *              an existing package either in this class loader or one
     *              of its ancestors
     * @return the newly defined Package object
     */
    protected Package definePackage(String name, Manifest man, URL url)
        throws IllegalArgumentException
    {
<span class="fc" id="L477">        String path = name.replace('.', '/').concat(&quot;/&quot;);</span>
<span class="fc" id="L478">        String specTitle = null, specVersion = null, specVendor = null;</span>
<span class="fc" id="L479">        String implTitle = null, implVersion = null, implVendor = null;</span>
<span class="fc" id="L480">        String sealed = null;</span>
<span class="fc" id="L481">        URL sealBase = null;</span>

<span class="fc" id="L483">        Attributes attr = man.getAttributes(path);</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L485">            specTitle   = attr.getValue(Name.SPECIFICATION_TITLE);</span>
<span class="nc" id="L486">            specVersion = attr.getValue(Name.SPECIFICATION_VERSION);</span>
<span class="nc" id="L487">            specVendor  = attr.getValue(Name.SPECIFICATION_VENDOR);</span>
<span class="nc" id="L488">            implTitle   = attr.getValue(Name.IMPLEMENTATION_TITLE);</span>
<span class="nc" id="L489">            implVersion = attr.getValue(Name.IMPLEMENTATION_VERSION);</span>
<span class="nc" id="L490">            implVendor  = attr.getValue(Name.IMPLEMENTATION_VENDOR);</span>
<span class="nc" id="L491">            sealed      = attr.getValue(Name.SEALED);</span>
        }
<span class="fc" id="L493">        attr = man.getMainAttributes();</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">        if (attr != null) {</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">            if (specTitle == null) {</span>
<span class="fc" id="L496">                specTitle = attr.getValue(Name.SPECIFICATION_TITLE);</span>
            }
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">            if (specVersion == null) {</span>
<span class="fc" id="L499">                specVersion = attr.getValue(Name.SPECIFICATION_VERSION);</span>
            }
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">            if (specVendor == null) {</span>
<span class="fc" id="L502">                specVendor = attr.getValue(Name.SPECIFICATION_VENDOR);</span>
            }
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">            if (implTitle == null) {</span>
<span class="fc" id="L505">                implTitle = attr.getValue(Name.IMPLEMENTATION_TITLE);</span>
            }
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">            if (implVersion == null) {</span>
<span class="fc" id="L508">                implVersion = attr.getValue(Name.IMPLEMENTATION_VERSION);</span>
            }
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">            if (implVendor == null) {</span>
<span class="fc" id="L511">                implVendor = attr.getValue(Name.IMPLEMENTATION_VENDOR);</span>
            }
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">            if (sealed == null) {</span>
<span class="fc" id="L514">                sealed = attr.getValue(Name.SEALED);</span>
            }
        }
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (&quot;true&quot;.equalsIgnoreCase(sealed)) {</span>
<span class="fc" id="L518">            sealBase = url;</span>
        }
<span class="fc" id="L520">        return definePackage(name, specTitle, specVersion, specVendor,</span>
                             implTitle, implVersion, implVendor, sealBase);
    }

    /*
     * Returns true if the specified package name is sealed according to the
     * given manifest.
     */
    private boolean isSealed(String name, Manifest man) {
<span class="fc" id="L529">        String path = name.replace('.', '/').concat(&quot;/&quot;);</span>
<span class="fc" id="L530">        Attributes attr = man.getAttributes(path);</span>
<span class="fc" id="L531">        String sealed = null;</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L533">            sealed = attr.getValue(Name.SEALED);</span>
        }
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        if (sealed == null) {</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">            if ((attr = man.getMainAttributes()) != null) {</span>
<span class="fc" id="L537">                sealed = attr.getValue(Name.SEALED);</span>
            }
        }
<span class="fc" id="L540">        return &quot;true&quot;.equalsIgnoreCase(sealed);</span>
    }

    /**
     * Finds the resource with the specified name on the URL search path.
     *
     * @param name the name of the resource
     * @return a {@code URL} for the resource, or {@code null}
     * if the resource could not be found, or if the loader is closed.
     */
    public URL findResource(final String name) {
        /*
         * The same restriction to finding classes applies to resources
         */
<span class="fc" id="L554">        URL url = AccessController.doPrivileged(</span>
<span class="fc" id="L555">            new PrivilegedAction&lt;URL&gt;() {</span>
                public URL run() {
<span class="fc" id="L557">                    return ucp.findResource(name, true);</span>
                }
            }, acc);

<span class="fc bfc" id="L561" title="All 2 branches covered.">        return url != null ? ucp.checkURL(url) : null;</span>
    }

    /**
     * Returns an Enumeration of URLs representing all of the resources
     * on the URL search path having the specified name.
     *
     * @param name the resource name
     * @exception IOException if an I/O exception occurs
     * @return an {@code Enumeration} of {@code URL}s
     *         If the loader is closed, the Enumeration will be empty.
     */
    public Enumeration&lt;URL&gt; findResources(final String name)
        throws IOException
    {
<span class="fc" id="L576">        final Enumeration&lt;URL&gt; e = ucp.findResources(name, true);</span>

<span class="fc" id="L578">        return new Enumeration&lt;URL&gt;() {</span>
<span class="fc" id="L579">            private URL url = null;</span>

            private boolean next() {
<span class="fc bfc" id="L582" title="All 2 branches covered.">                if (url != null) {</span>
<span class="fc" id="L583">                    return true;</span>
                }
                do {
<span class="fc" id="L586">                    URL u = AccessController.doPrivileged(</span>
<span class="fc" id="L587">                        new PrivilegedAction&lt;URL&gt;() {</span>
                            public URL run() {
<span class="fc bfc" id="L589" title="All 2 branches covered.">                                if (!e.hasMoreElements())</span>
<span class="fc" id="L590">                                    return null;</span>
<span class="fc" id="L591">                                return e.nextElement();</span>
                            }
<span class="fc" id="L593">                        }, acc);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">                    if (u == null)</span>
<span class="fc" id="L595">                        break;</span>
<span class="fc" id="L596">                    url = ucp.checkURL(u);</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">                } while (url == null);</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">                return url != null;</span>
            }

            public URL nextElement() {
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">                if (!next()) {</span>
<span class="nc" id="L603">                    throw new NoSuchElementException();</span>
                }
<span class="fc" id="L605">                URL u = url;</span>
<span class="fc" id="L606">                url = null;</span>
<span class="fc" id="L607">                return u;</span>
            }

            public boolean hasMoreElements() {
<span class="fc" id="L611">                return next();</span>
            }
        };
    }

    /**
     * Returns the permissions for the given codesource object.
     * The implementation of this method first calls super.getPermissions
     * and then adds permissions based on the URL of the codesource.
     * &lt;p&gt;
     * If the protocol of this URL is &quot;jar&quot;, then the permission granted
     * is based on the permission that is required by the URL of the Jar
     * file.
     * &lt;p&gt;
     * If the protocol is &quot;file&quot; and there is an authority component, then
     * permission to connect to and accept connections from that authority
     * may be granted. If the protocol is &quot;file&quot;
     * and the path specifies a file, then permission to read that
     * file is granted. If protocol is &quot;file&quot; and the path is
     * a directory, permission is granted to read all files
     * and (recursively) all files and subdirectories contained in
     * that directory.
     * &lt;p&gt;
     * If the protocol is not &quot;file&quot;, then permission
     * to connect to and accept connections from the URL's host is granted.
     * @param codesource the codesource
     * @exception NullPointerException if {@code codesource} is {@code null}.
     * @return the permissions granted to the codesource
     */
    protected PermissionCollection getPermissions(CodeSource codesource)
    {
<span class="fc" id="L642">        PermissionCollection perms = super.getPermissions(codesource);</span>

<span class="fc" id="L644">        URL url = codesource.getLocation();</span>

        Permission p;
        URLConnection urlConnection;

        try {
<span class="fc" id="L650">            urlConnection = url.openConnection();</span>
<span class="fc" id="L651">            p = urlConnection.getPermission();</span>
<span class="nc" id="L652">        } catch (java.io.IOException ioe) {</span>
<span class="nc" id="L653">            p = null;</span>
<span class="nc" id="L654">            urlConnection = null;</span>
<span class="fc" id="L655">        }</span>

<span class="fc bfc" id="L657" title="All 2 branches covered.">        if (p instanceof FilePermission) {</span>
            // if the permission has a separator char on the end,
            // it means the codebase is a directory, and we need
            // to add an additional permission to read recursively
<span class="fc" id="L661">            String path = p.getName();</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">            if (path.endsWith(File.separator)) {</span>
<span class="fc" id="L663">                path += &quot;-&quot;;</span>
<span class="fc" id="L664">                p = new FilePermission(path, SecurityConstants.FILE_READ_ACTION);</span>
            }
<span class="pc bpc" id="L666" title="3 of 4 branches missed.">        } else if ((p == null) &amp;&amp; (url.getProtocol().equals(&quot;file&quot;))) {</span>
<span class="nc" id="L667">            String path = url.getFile().replace('/', File.separatorChar);</span>
<span class="nc" id="L668">            path = ParseUtil.decode(path);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">            if (path.endsWith(File.separator))</span>
<span class="nc" id="L670">                path += &quot;-&quot;;</span>
<span class="nc" id="L671">            p =  new FilePermission(path, SecurityConstants.FILE_READ_ACTION);</span>
<span class="nc" id="L672">        } else {</span>
            /**
             * Not loading from a 'file:' URL so we want to give the class
             * permission to connect to and accept from the remote host
             * after we've made sure the host is the correct one and is valid.
             */
<span class="fc" id="L678">            URL locUrl = url;</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">            if (urlConnection instanceof JarURLConnection) {</span>
<span class="nc" id="L680">                locUrl = ((JarURLConnection)urlConnection).getJarFileURL();</span>
            }
<span class="fc" id="L682">            String host = locUrl.getHost();</span>
<span class="pc bpc" id="L683" title="2 of 4 branches missed.">            if (host != null &amp;&amp; (host.length() &gt; 0))</span>
<span class="fc" id="L684">                p = new SocketPermission(host,</span>
                                         SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION);
        }

        // make sure the person that created this class loader
        // would have this permission

<span class="pc bpc" id="L691" title="1 of 2 branches missed.">        if (p != null) {</span>
<span class="fc" id="L692">            final SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">            if (sm != null) {</span>
<span class="fc" id="L694">                final Permission fp = p;</span>
<span class="fc" id="L695">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                    public Void run() throws SecurityException {
<span class="fc" id="L697">                        sm.checkPermission(fp);</span>
<span class="fc" id="L698">                        return null;</span>
                    }
                }, acc);
            }
<span class="fc" id="L702">            perms.add(p);</span>
        }
<span class="fc" id="L704">        return perms;</span>
    }

    /**
     * Creates a new instance of URLClassLoader for the specified
     * URLs and parent class loader. If a security manager is
     * installed, the {@code loadClass} method of the URLClassLoader
     * returned by this method will invoke the
     * {@code SecurityManager.checkPackageAccess} method before
     * loading the class.
     *
     * @param urls the URLs to search for classes and resources
     * @param parent the parent class loader for delegation
     * @exception  NullPointerException if {@code urls} is {@code null}.
     * @return the resulting class loader
     */
    public static URLClassLoader newInstance(final URL[] urls,
                                             final ClassLoader parent) {
        // Save the caller's context
<span class="nc" id="L723">        final AccessControlContext acc = AccessController.getContext();</span>
        // Need a privileged block to create the class loader
<span class="nc" id="L725">        URLClassLoader ucl = AccessController.doPrivileged(</span>
<span class="nc" id="L726">            new PrivilegedAction&lt;URLClassLoader&gt;() {</span>
                public URLClassLoader run() {
<span class="nc" id="L728">                    return new FactoryURLClassLoader(urls, parent, acc);</span>
                }
            });
<span class="nc" id="L731">        return ucl;</span>
    }

    /**
     * Creates a new instance of URLClassLoader for the specified
     * URLs and default parent class loader. If a security manager is
     * installed, the {@code loadClass} method of the URLClassLoader
     * returned by this method will invoke the
     * {@code SecurityManager.checkPackageAccess} before
     * loading the class.
     *
     * @param urls the URLs to search for classes and resources
     * @exception  NullPointerException if {@code urls} is {@code null}.
     * @return the resulting class loader
     */
    public static URLClassLoader newInstance(final URL[] urls) {
        // Save the caller's context
<span class="fc" id="L748">        final AccessControlContext acc = AccessController.getContext();</span>
        // Need a privileged block to create the class loader
<span class="fc" id="L750">        URLClassLoader ucl = AccessController.doPrivileged(</span>
<span class="fc" id="L751">            new PrivilegedAction&lt;URLClassLoader&gt;() {</span>
                public URLClassLoader run() {
<span class="fc" id="L753">                    return new FactoryURLClassLoader(urls, acc);</span>
                }
            });
<span class="fc" id="L756">        return ucl;</span>
    }

    static {
<span class="fc" id="L760">        sun.misc.SharedSecrets.setJavaNetAccess (</span>
<span class="fc" id="L761">            new sun.misc.JavaNetAccess() {</span>
                public URLClassPath getURLClassPath (URLClassLoader u) {
<span class="nc" id="L763">                    return u.ucp;</span>
                }
            }
        );
<span class="fc" id="L767">        ClassLoader.registerAsParallelCapable();</span>
<span class="fc" id="L768">    }</span>
}

final class FactoryURLClassLoader extends URLClassLoader {

    static {
<span class="fc" id="L774">        ClassLoader.registerAsParallelCapable();</span>
<span class="fc" id="L775">    }</span>

    FactoryURLClassLoader(URL[] urls, ClassLoader parent,
                          AccessControlContext acc) {
<span class="nc" id="L779">        super(urls, parent, acc);</span>
<span class="nc" id="L780">    }</span>

    FactoryURLClassLoader(URL[] urls, AccessControlContext acc) {
<span class="fc" id="L783">        super(urls, acc);</span>
<span class="fc" id="L784">    }</span>

    public final Class&lt;?&gt; loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        // First check if we have permission to access the package. This
        // should go away once we've added support for exported packages.
<span class="fc" id="L791">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">        if (sm != null) {</span>
<span class="fc" id="L793">            int i = name.lastIndexOf('.');</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">            if (i != -1) {</span>
<span class="fc" id="L795">                sm.checkPackageAccess(name.substring(0, i));</span>
            }
        }
<span class="fc" id="L798">        return super.loadClass(name, resolve);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>