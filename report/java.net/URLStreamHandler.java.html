<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>URLStreamHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">URLStreamHandler.java</span></div><h1>URLStreamHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.io.IOException;
import java.io.InputStream;
import java.io.File;
import java.io.OutputStream;
import java.util.Hashtable;
import sun.net.util.IPAddressUtil;
import sun.net.www.ParseUtil;

/**
 * The abstract class {@code URLStreamHandler} is the common
 * superclass for all stream protocol handlers. A stream protocol
 * handler knows how to make a connection for a particular protocol
 * type, such as {@code http} or {@code https}.
 * &lt;p&gt;
 * In most cases, an instance of a {@code URLStreamHandler}
 * subclass is not created directly by an application. Rather, the
 * first time a protocol name is encountered when constructing a
 * {@code URL}, the appropriate stream protocol handler is
 * automatically loaded.
 *
 * @author  James Gosling
 * @see     java.net.URL#URL(java.lang.String, java.lang.String, int, java.lang.String)
 * @since   JDK1.0
 */
<span class="fc" id="L52">public abstract class URLStreamHandler {</span>
    /**
     * Opens a connection to the object referenced by the
     * {@code URL} argument.
     * This method should be overridden by a subclass.
     *
     * &lt;p&gt;If for the handler's protocol (such as HTTP or JAR), there
     * exists a public, specialized URLConnection subclass belonging
     * to one of the following packages or one of their subpackages:
     * java.lang, java.io, java.util, java.net, the connection
     * returned will be of that subclass. For example, for HTTP an
     * HttpURLConnection will be returned, and for JAR a
     * JarURLConnection will be returned.
     *
     * @param      u   the URL that this connects to.
     * @return     a {@code URLConnection} object for the {@code URL}.
     * @exception  IOException  if an I/O error occurs while opening the
     *               connection.
     */
    abstract protected URLConnection openConnection(URL u) throws IOException;

    /**
     * Same as openConnection(URL), except that the connection will be
     * made through the specified proxy; Protocol handlers that do not
     * support proxying will ignore the proxy parameter and make a
     * normal connection.
     *
     * Calling this method preempts the system's default ProxySelector
     * settings.
     *
     * @param      u   the URL that this connects to.
     * @param      p   the proxy through which the connection will be made.
     *                 If direct connection is desired, Proxy.NO_PROXY
     *                 should be specified.
     * @return     a {@code URLConnection} object for the {@code URL}.
     * @exception  IOException  if an I/O error occurs while opening the
     *               connection.
     * @exception  IllegalArgumentException if either u or p is null,
     *               or p has the wrong type.
     * @exception  UnsupportedOperationException if the subclass that
     *               implements the protocol doesn't support this method.
     * @since      1.5
     */
    protected URLConnection openConnection(URL u, Proxy p) throws IOException {
<span class="nc" id="L96">        throw new UnsupportedOperationException(&quot;Method not implemented.&quot;);</span>
    }

    /**
     * Parses the string representation of a {@code URL} into a
     * {@code URL} object.
     * &lt;p&gt;
     * If there is any inherited context, then it has already been
     * copied into the {@code URL} argument.
     * &lt;p&gt;
     * The {@code parseURL} method of {@code URLStreamHandler}
     * parses the string representation as if it were an
     * {@code http} specification. Most URL protocol families have a
     * similar parsing. A stream protocol handler for a protocol that has
     * a different syntax must override this routine.
     *
     * @param   u       the {@code URL} to receive the result of parsing
     *                  the spec.
     * @param   spec    the {@code String} representing the URL that
     *                  must be parsed.
     * @param   start   the character index at which to begin parsing. This is
     *                  just past the '{@code :}' (if there is one) that
     *                  specifies the determination of the protocol name.
     * @param   limit   the character position to stop parsing at. This is the
     *                  end of the string or the position of the
     *                  &quot;{@code #}&quot; character, if present. All information
     *                  after the sharp sign indicates an anchor.
     */
    protected void parseURL(URL u, String spec, int start, int limit) {
        // These fields may receive context content if this was relative URL
<span class="fc" id="L126">        String protocol = u.getProtocol();</span>
<span class="fc" id="L127">        String authority = u.getAuthority();</span>
<span class="fc" id="L128">        String userInfo = u.getUserInfo();</span>
<span class="fc" id="L129">        String host = u.getHost();</span>
<span class="fc" id="L130">        int port = u.getPort();</span>
<span class="fc" id="L131">        String path = u.getPath();</span>
<span class="fc" id="L132">        String query = u.getQuery();</span>

        // This field has already been parsed
<span class="fc" id="L135">        String ref = u.getRef();</span>

<span class="fc" id="L137">        boolean isRelPath = false;</span>
<span class="fc" id="L138">        boolean queryOnly = false;</span>

// FIX: should not assume query if opaque
        // Strip off the query part
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        if (start &lt; limit) {</span>
<span class="fc" id="L143">            int queryStart = spec.indexOf('?');</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            queryOnly = queryStart == start;</span>
<span class="fc bfc" id="L145" title="All 4 branches covered.">            if ((queryStart != -1) &amp;&amp; (queryStart &lt; limit)) {</span>
<span class="fc" id="L146">                query = spec.substring(queryStart+1, limit);</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">                if (limit &gt; queryStart)</span>
<span class="fc" id="L148">                    limit = queryStart;</span>
<span class="fc" id="L149">                spec = spec.substring(0, queryStart);</span>
            }
        }

<span class="fc" id="L153">        int i = 0;</span>
        // Parse the authority part if any
<span class="fc bfc" id="L155" title="All 2 branches covered.">        boolean isUNCName = (start &lt;= limit - 4) &amp;&amp;</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">                        (spec.charAt(start) == '/') &amp;&amp;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">                        (spec.charAt(start + 1) == '/') &amp;&amp;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">                        (spec.charAt(start + 2) == '/') &amp;&amp;</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">                        (spec.charAt(start + 3) == '/');</span>
<span class="pc bpc" id="L160" title="1 of 6 branches missed.">        if (!isUNCName &amp;&amp; (start &lt;= limit - 2) &amp;&amp; (spec.charAt(start) == '/') &amp;&amp;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">            (spec.charAt(start + 1) == '/')) {</span>
<span class="fc" id="L162">            start += 2;</span>
<span class="fc" id="L163">            i = spec.indexOf('/', start);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            if (i &lt; 0) {</span>
<span class="fc" id="L165">                i = spec.indexOf('?', start);</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">                if (i &lt; 0)</span>
<span class="fc" id="L167">                    i = limit;</span>
            }

<span class="fc" id="L170">            host = authority = spec.substring(start, i);</span>

<span class="fc" id="L172">            int ind = authority.indexOf('@');</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">            if (ind != -1) {</span>
<span class="fc" id="L174">                userInfo = authority.substring(0, ind);</span>
<span class="fc" id="L175">                host = authority.substring(ind+1);</span>
            } else {
<span class="fc" id="L177">                userInfo = null;</span>
            }
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">            if (host != null) {</span>
                // If the host is surrounded by [ and ] then its an IPv6
                // literal address as specified in RFC2732
<span class="pc bpc" id="L182" title="1 of 4 branches missed.">                if (host.length()&gt;0 &amp;&amp; (host.charAt(0) == '[')) {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">                    if ((ind = host.indexOf(']')) &gt; 2) {</span>

<span class="nc" id="L185">                        String nhost = host ;</span>
<span class="nc" id="L186">                        host = nhost.substring(0,ind+1);</span>
<span class="nc" id="L187">                        if (!IPAddressUtil.</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                            isIPv6LiteralAddress(host.substring(1, ind))) {</span>
<span class="nc" id="L189">                            throw new IllegalArgumentException(</span>
                                &quot;Invalid host: &quot;+ host);
                        }

<span class="nc" id="L193">                        port = -1 ;</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">                        if (nhost.length() &gt; ind+1) {</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">                            if (nhost.charAt(ind+1) == ':') {</span>
<span class="nc" id="L196">                                ++ind ;</span>
                                // port can be null according to RFC2396
<span class="nc bnc" id="L198" title="All 2 branches missed.">                                if (nhost.length() &gt; (ind + 1)) {</span>
<span class="nc" id="L199">                                    port = Integer.parseInt(nhost.substring(ind+1));</span>
                                }
                            } else {
<span class="nc" id="L202">                                throw new IllegalArgumentException(</span>
                                    &quot;Invalid authority field: &quot; + authority);
                            }
                        }
<span class="nc" id="L206">                    } else {</span>
<span class="nc" id="L207">                        throw new IllegalArgumentException(</span>
                            &quot;Invalid authority field: &quot; + authority);
                    }
                } else {
<span class="fc" id="L211">                    ind = host.indexOf(':');</span>
<span class="fc" id="L212">                    port = -1;</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">                    if (ind &gt;= 0) {</span>
                        // port can be null according to RFC2396
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">                        if (host.length() &gt; (ind + 1)) {</span>
<span class="fc" id="L216">                            port = Integer.parseInt(host.substring(ind + 1));</span>
                        }
<span class="fc" id="L218">                        host = host.substring(0, ind);</span>
                    }
                }
            } else {
<span class="nc" id="L222">                host = &quot;&quot;;</span>
            }
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">            if (port &lt; -1)</span>
<span class="nc" id="L225">                throw new IllegalArgumentException(&quot;Invalid port number :&quot; +</span>
                                                   port);
<span class="fc" id="L227">            start = i;</span>
            // If the authority is defined then the path is defined by the
            // spec only; See RFC 2396 Section 5.2.4.
<span class="pc bpc" id="L230" title="1 of 4 branches missed.">            if (authority != null &amp;&amp; authority.length() &gt; 0)</span>
<span class="fc" id="L231">                path = &quot;&quot;;</span>
        }

<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (host == null) {</span>
<span class="fc" id="L235">            host = &quot;&quot;;</span>
        }

        // Parse the file path if any
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (start &lt; limit) {</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (spec.charAt(start) == '/') {</span>
<span class="fc" id="L241">                path = spec.substring(start, limit);</span>
<span class="fc bfc" id="L242" title="All 4 branches covered.">            } else if (path != null &amp;&amp; path.length() &gt; 0) {</span>
<span class="fc" id="L243">                isRelPath = true;</span>
<span class="fc" id="L244">                int ind = path.lastIndexOf('/');</span>
<span class="fc" id="L245">                String seperator = &quot;&quot;;</span>
<span class="pc bpc" id="L246" title="3 of 4 branches missed.">                if (ind == -1 &amp;&amp; authority != null)</span>
<span class="nc" id="L247">                    seperator = &quot;/&quot;;</span>
<span class="fc" id="L248">                path = path.substring(0, ind + 1) + seperator +</span>
<span class="fc" id="L249">                         spec.substring(start, limit);</span>

<span class="fc" id="L251">            } else {</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">                String seperator = (authority != null) ? &quot;/&quot; : &quot;&quot;;</span>
<span class="fc" id="L253">                path = seperator + spec.substring(start, limit);</span>
<span class="fc" id="L254">            }</span>
<span class="pc bpc" id="L255" title="1 of 4 branches missed.">        } else if (queryOnly &amp;&amp; path != null) {</span>
<span class="fc" id="L256">            int ind = path.lastIndexOf('/');</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">            if (ind &lt; 0)</span>
<span class="nc" id="L258">                ind = 0;</span>
<span class="fc" id="L259">            path = path.substring(0, ind) + &quot;/&quot;;</span>
        }
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (path == null)</span>
<span class="fc" id="L262">            path = &quot;&quot;;</span>

<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (isRelPath) {</span>
            // Remove embedded /./
<span class="fc bfc" id="L266" title="All 2 branches covered.">            while ((i = path.indexOf(&quot;/./&quot;)) &gt;= 0) {</span>
<span class="fc" id="L267">                path = path.substring(0, i) + path.substring(i + 2);</span>
            }
            // Remove embedded /../ if possible
<span class="fc" id="L270">            i = 0;</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            while ((i = path.indexOf(&quot;/../&quot;, i)) &gt;= 0) {</span>
                /*
                 * A &quot;/../&quot; will cancel the previous segment and itself,
                 * unless that segment is a &quot;/../&quot; itself
                 * i.e. &quot;/a/b/../c&quot; becomes &quot;/a/c&quot;
                 * but &quot;/../../a&quot; should stay unchanged
                 */
<span class="fc bfc" id="L278" title="All 4 branches covered.">                if (i &gt; 0 &amp;&amp; (limit = path.lastIndexOf('/', i - 1)) &gt;= 0 &amp;&amp;</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">                    (path.indexOf(&quot;/../&quot;, limit) != 0)) {</span>
<span class="fc" id="L280">                    path = path.substring(0, limit) + path.substring(i + 3);</span>
<span class="fc" id="L281">                    i = 0;</span>
                } else {
<span class="fc" id="L283">                    i = i + 3;</span>
                }
            }
            // Remove trailing .. if possible
<span class="fc bfc" id="L287" title="All 2 branches covered.">            while (path.endsWith(&quot;/..&quot;)) {</span>
<span class="fc" id="L288">                i = path.indexOf(&quot;/..&quot;);</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">                if ((limit = path.lastIndexOf('/', i - 1)) &gt;= 0) {</span>
<span class="fc" id="L290">                    path = path.substring(0, limit+1);</span>
                } else {
                    break;
                }
            }
            // Remove starting .
<span class="pc bpc" id="L296" title="1 of 4 branches missed.">            if (path.startsWith(&quot;./&quot;) &amp;&amp; path.length() &gt; 2)</span>
<span class="fc" id="L297">                path = path.substring(2);</span>

            // Remove trailing .
<span class="fc bfc" id="L300" title="All 2 branches covered.">            if (path.endsWith(&quot;/.&quot;))</span>
<span class="fc" id="L301">                path = path.substring(0, path.length() -1);</span>
        }

<span class="fc" id="L304">        setURL(u, protocol, host, port, authority, userInfo, path, query, ref);</span>
<span class="fc" id="L305">    }</span>

    /**
     * Returns the default port for a URL parsed by this handler. This method
     * is meant to be overidden by handlers with default port numbers.
     * @return the default port for a {@code URL} parsed by this handler.
     * @since 1.3
     */
    protected int getDefaultPort() {
<span class="fc" id="L314">        return -1;</span>
    }

    /**
     * Provides the default equals calculation. May be overidden by handlers
     * for other protocols that have different requirements for equals().
     * This method requires that none of its arguments is null. This is
     * guaranteed by the fact that it is only called by java.net.URL class.
     * @param u1 a URL object
     * @param u2 a URL object
     * @return {@code true} if the two urls are
     * considered equal, ie. they refer to the same
     * fragment in the same file.
     * @since 1.3
     */
    protected boolean equals(URL u1, URL u2) {
<span class="fc" id="L330">        String ref1 = u1.getRef();</span>
<span class="fc" id="L331">        String ref2 = u2.getRef();</span>
<span class="pc bpc" id="L332" title="1 of 6 branches missed.">        return (ref1 == ref2 || (ref1 != null &amp;&amp; ref1.equals(ref2))) &amp;&amp;</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">               sameFile(u1, u2);</span>
    }

    /**
     * Provides the default hash calculation. May be overidden by handlers for
     * other protocols that have different requirements for hashCode
     * calculation.
     * @param u a URL object
     * @return an {@code int} suitable for hash table indexing
     * @since 1.3
     */
    protected int hashCode(URL u) {
<span class="fc" id="L345">        int h = 0;</span>

        // Generate the protocol part.
<span class="fc" id="L348">        String protocol = u.getProtocol();</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (protocol != null)</span>
<span class="fc" id="L350">            h += protocol.hashCode();</span>

        // Generate the host part.
<span class="fc" id="L353">        InetAddress addr = getHostAddress(u);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (addr != null) {</span>
<span class="fc" id="L355">            h += addr.hashCode();</span>
        } else {
<span class="fc" id="L357">            String host = u.getHost();</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">            if (host != null)</span>
<span class="fc" id="L359">                h += host.toLowerCase().hashCode();</span>
        }

        // Generate the file part.
<span class="fc" id="L363">        String file = u.getFile();</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (file != null)</span>
<span class="fc" id="L365">            h += file.hashCode();</span>

        // Generate the port part.
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (u.getPort() == -1)</span>
<span class="fc" id="L369">            h += getDefaultPort();</span>
        else
<span class="fc" id="L371">            h += u.getPort();</span>

        // Generate the ref part.
<span class="fc" id="L374">        String ref = u.getRef();</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">        if (ref != null)</span>
<span class="nc" id="L376">            h += ref.hashCode();</span>

<span class="fc" id="L378">        return h;</span>
    }

    /**
     * Compare two urls to see whether they refer to the same file,
     * i.e., having the same protocol, host, port, and path.
     * This method requires that none of its arguments is null. This is
     * guaranteed by the fact that it is only called indirectly
     * by java.net.URL class.
     * @param u1 a URL object
     * @param u2 a URL object
     * @return true if u1 and u2 refer to the same file
     * @since 1.3
     */
    protected boolean sameFile(URL u1, URL u2) {
        // Compare the protocols.
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (!((u1.getProtocol() == u2.getProtocol()) ||</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">              (u1.getProtocol() != null &amp;&amp;</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">               u1.getProtocol().equalsIgnoreCase(u2.getProtocol()))))</span>
<span class="fc" id="L397">            return false;</span>

        // Compare the files.
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (!(u1.getFile() == u2.getFile() ||</span>
<span class="pc bpc" id="L401" title="1 of 4 branches missed.">              (u1.getFile() != null &amp;&amp; u1.getFile().equals(u2.getFile()))))</span>
<span class="fc" id="L402">            return false;</span>

        // Compare the ports.
        int port1, port2;
<span class="fc bfc" id="L406" title="All 2 branches covered.">        port1 = (u1.getPort() != -1) ? u1.getPort() : u1.handler.getDefaultPort();</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">        port2 = (u2.getPort() != -1) ? u2.getPort() : u2.handler.getDefaultPort();</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        if (port1 != port2)</span>
<span class="nc" id="L409">            return false;</span>

        // Compare the hosts.
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if (!hostsEqual(u1, u2))</span>
<span class="nc" id="L413">            return false;</span>

<span class="fc" id="L415">        return true;</span>
    }

    /**
     * Get the IP address of our host. An empty host field or a DNS failure
     * will result in a null return.
     *
     * @param u a URL object
     * @return an {@code InetAddress} representing the host
     * IP address.
     * @since 1.3
     */
    protected synchronized InetAddress getHostAddress(URL u) {
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        if (u.hostAddress != null)</span>
<span class="nc" id="L429">            return u.hostAddress;</span>

<span class="fc" id="L431">        String host = u.getHost();</span>
<span class="fc bfc" id="L432" title="All 4 branches covered.">        if (host == null || host.equals(&quot;&quot;)) {</span>
<span class="fc" id="L433">            return null;</span>
        } else {
            try {
<span class="fc" id="L436">                u.hostAddress = InetAddress.getByName(host);</span>
<span class="fc" id="L437">            } catch (UnknownHostException ex) {</span>
<span class="fc" id="L438">                return null;</span>
<span class="fc" id="L439">            } catch (SecurityException se) {</span>
<span class="fc" id="L440">                return null;</span>
<span class="fc" id="L441">            }</span>
        }
<span class="fc" id="L443">        return u.hostAddress;</span>
    }

    /**
     * Compares the host components of two URLs.
     * @param u1 the URL of the first host to compare
     * @param u2 the URL of the second host to compare
     * @return  {@code true} if and only if they
     * are equal, {@code false} otherwise.
     * @since 1.3
     */
    protected boolean hostsEqual(URL u1, URL u2) {
<span class="fc" id="L455">        InetAddress a1 = getHostAddress(u1);</span>
<span class="fc" id="L456">        InetAddress a2 = getHostAddress(u2);</span>
        // if we have internet address for both, compare them
<span class="pc bpc" id="L458" title="1 of 4 branches missed.">        if (a1 != null &amp;&amp; a2 != null) {</span>
<span class="fc" id="L459">            return a1.equals(a2);</span>
        // else, if both have host names, compare them
<span class="pc bpc" id="L461" title="2 of 4 branches missed.">        } else if (u1.getHost() != null &amp;&amp; u2.getHost() != null)</span>
<span class="fc" id="L462">            return u1.getHost().equalsIgnoreCase(u2.getHost());</span>
         else
<span class="nc bnc" id="L464" title="All 4 branches missed.">            return u1.getHost() == null &amp;&amp; u2.getHost() == null;</span>
    }

    /**
     * Converts a {@code URL} of a specific protocol to a
     * {@code String}.
     *
     * @param   u   the URL.
     * @return  a string representation of the {@code URL} argument.
     */
    protected String toExternalForm(URL u) {

        // pre-compute length of StringBuffer
<span class="fc" id="L477">        int len = u.getProtocol().length() + 1;</span>
<span class="fc bfc" id="L478" title="All 4 branches covered.">        if (u.getAuthority() != null &amp;&amp; u.getAuthority().length() &gt; 0)</span>
<span class="fc" id="L479">            len += 2 + u.getAuthority().length();</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        if (u.getPath() != null) {</span>
<span class="fc" id="L481">            len += u.getPath().length();</span>
        }
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (u.getQuery() != null) {</span>
<span class="fc" id="L484">            len += 1 + u.getQuery().length();</span>
        }
<span class="fc bfc" id="L486" title="All 2 branches covered.">        if (u.getRef() != null)</span>
<span class="fc" id="L487">            len += 1 + u.getRef().length();</span>

<span class="fc" id="L489">        StringBuffer result = new StringBuffer(len);</span>
<span class="fc" id="L490">        result.append(u.getProtocol());</span>
<span class="fc" id="L491">        result.append(&quot;:&quot;);</span>
<span class="fc bfc" id="L492" title="All 4 branches covered.">        if (u.getAuthority() != null &amp;&amp; u.getAuthority().length() &gt; 0) {</span>
<span class="fc" id="L493">            result.append(&quot;//&quot;);</span>
<span class="fc" id="L494">            result.append(u.getAuthority());</span>
        }
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        if (u.getPath() != null) {</span>
<span class="fc" id="L497">            result.append(u.getPath());</span>
        }
<span class="fc bfc" id="L499" title="All 2 branches covered.">        if (u.getQuery() != null) {</span>
<span class="fc" id="L500">            result.append('?');</span>
<span class="fc" id="L501">            result.append(u.getQuery());</span>
        }
<span class="fc bfc" id="L503" title="All 2 branches covered.">        if (u.getRef() != null) {</span>
<span class="fc" id="L504">            result.append(&quot;#&quot;);</span>
<span class="fc" id="L505">            result.append(u.getRef());</span>
        }
<span class="fc" id="L507">        return result.toString();</span>
    }

    /**
     * Sets the fields of the {@code URL} argument to the indicated values.
     * Only classes derived from URLStreamHandler are able
     * to use this method to set the values of the URL fields.
     *
     * @param   u         the URL to modify.
     * @param   protocol  the protocol name.
     * @param   host      the remote host value for the URL.
     * @param   port      the port on the remote machine.
     * @param   authority the authority part for the URL.
     * @param   userInfo the userInfo part of the URL.
     * @param   path      the path component of the URL.
     * @param   query     the query part for the URL.
     * @param   ref       the reference.
     * @exception       SecurityException       if the protocol handler of the URL is
     *                                  different from this one
     * @see     java.net.URL#set(java.lang.String, java.lang.String, int, java.lang.String, java.lang.String)
     * @since 1.3
     */
       protected void setURL(URL u, String protocol, String host, int port,
                             String authority, String userInfo, String path,
                             String query, String ref) {
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        if (this != u.handler) {</span>
<span class="nc" id="L533">            throw new SecurityException(&quot;handler for url different from &quot; +</span>
                                        &quot;this handler&quot;);
        }
        // ensure that no one can reset the protocol on a given URL.
<span class="fc" id="L537">        u.set(u.getProtocol(), host, port, authority, userInfo, path, query, ref);</span>
<span class="fc" id="L538">    }</span>

    /**
     * Sets the fields of the {@code URL} argument to the indicated values.
     * Only classes derived from URLStreamHandler are able
     * to use this method to set the values of the URL fields.
     *
     * @param   u         the URL to modify.
     * @param   protocol  the protocol name. This value is ignored since 1.2.
     * @param   host      the remote host value for the URL.
     * @param   port      the port on the remote machine.
     * @param   file      the file.
     * @param   ref       the reference.
     * @exception       SecurityException       if the protocol handler of the URL is
     *                                  different from this one
     * @deprecated Use setURL(URL, String, String, int, String, String, String,
     *             String);
     */
    @Deprecated
    protected void setURL(URL u, String protocol, String host, int port,
                          String file, String ref) {
        /*
         * Only old URL handlers call this, so assume that the host
         * field might contain &quot;user:passwd@host&quot;. Fix as necessary.
         */
<span class="fc" id="L563">        String authority = null;</span>
<span class="fc" id="L564">        String userInfo = null;</span>
<span class="pc bpc" id="L565" title="2 of 4 branches missed.">        if (host != null &amp;&amp; host.length() != 0) {</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">            authority = (port == -1) ? host : host + &quot;:&quot; + port;</span>
<span class="nc" id="L567">            int at = host.lastIndexOf('@');</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (at != -1) {</span>
<span class="nc" id="L569">                userInfo = host.substring(0, at);</span>
<span class="nc" id="L570">                host = host.substring(at+1);</span>
            }
        }

        /*
         * Assume file might contain query part. Fix as necessary.
         */
<span class="fc" id="L577">        String path = null;</span>
<span class="fc" id="L578">        String query = null;</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        if (file != null) {</span>
<span class="fc" id="L580">            int q = file.lastIndexOf('?');</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">            if (q != -1) {</span>
<span class="nc" id="L582">                query = file.substring(q+1);</span>
<span class="nc" id="L583">                path = file.substring(0, q);</span>
            } else
<span class="fc" id="L585">                path = file;</span>
        }
<span class="fc" id="L587">        setURL(u, protocol, host, port, authority, userInfo, path, query, ref);</span>
<span class="fc" id="L588">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>