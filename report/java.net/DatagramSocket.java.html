<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DatagramSocket.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">DatagramSocket.java</span></div><h1>DatagramSocket.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.io.IOException;
import java.nio.channels.DatagramChannel;
import java.security.AccessController;
import java.security.PrivilegedExceptionAction;

/**
 * This class represents a socket for sending and receiving datagram packets.
 *
 * &lt;p&gt;A datagram socket is the sending or receiving point for a packet
 * delivery service. Each packet sent or received on a datagram socket
 * is individually addressed and routed. Multiple packets sent from
 * one machine to another may be routed differently, and may arrive in
 * any order.
 *
 * &lt;p&gt; Where possible, a newly constructed {@code DatagramSocket} has the
 * {@link SocketOptions#SO_BROADCAST SO_BROADCAST} socket option enabled so as
 * to allow the transmission of broadcast datagrams. In order to receive
 * broadcast packets a DatagramSocket should be bound to the wildcard address.
 * In some implementations, broadcast packets may also be received when
 * a DatagramSocket is bound to a more specific address.
 * &lt;p&gt;
 * Example:
 * {@code
 *              DatagramSocket s = new DatagramSocket(null);
 *              s.bind(new InetSocketAddress(8888));
 * }
 * Which is equivalent to:
 * {@code
 *              DatagramSocket s = new DatagramSocket(8888);
 * }
 * Both cases will create a DatagramSocket able to receive broadcasts on
 * UDP port 8888.
 *
 * @author  Pavani Diwanji
 * @see     java.net.DatagramPacket
 * @see     java.nio.channels.DatagramChannel
 * @since JDK1.0
 */
public
class DatagramSocket implements java.io.Closeable {
    /**
     * Various states of this socket.
     */
<span class="fc" id="L71">    private boolean created = false;</span>
<span class="fc" id="L72">    private boolean bound = false;</span>
<span class="fc" id="L73">    private boolean closed = false;</span>
<span class="fc" id="L74">    private Object closeLock = new Object();</span>

    /*
     * The implementation of this DatagramSocket.
     */
    DatagramSocketImpl impl;

    /**
     * Are we using an older DatagramSocketImpl?
     */
<span class="fc" id="L84">    boolean oldImpl = false;</span>

    /*
     * Connection state:
     * ST_NOT_CONNECTED = socket not connected
     * ST_CONNECTED = socket connected
     * ST_CONNECTED_NO_IMPL = socket connected but not at impl level
     */
    static final int ST_NOT_CONNECTED = 0;
    static final int ST_CONNECTED = 1;
    static final int ST_CONNECTED_NO_IMPL = 2;

<span class="fc" id="L96">    int connectState = ST_NOT_CONNECTED;</span>

    /*
     * Connected address &amp; port
     */
<span class="fc" id="L101">    InetAddress connectedAddress = null;</span>
<span class="fc" id="L102">    int connectedPort = -1;</span>

    /**
     * Connects this socket to a remote socket address (IP address + port number).
     * Binds socket if not already bound.
     * &lt;p&gt;
     * @param   address The remote address.
     * @param   port    The remote port
     * @throws  SocketException if binding the socket fails.
     */
    private synchronized void connectInternal(InetAddress address, int port) throws SocketException {
<span class="pc bpc" id="L113" title="2 of 4 branches missed.">        if (port &lt; 0 || port &gt; 0xFFFF) {</span>
<span class="nc" id="L114">            throw new IllegalArgumentException(&quot;connect: &quot; + port);</span>
        }
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (address == null) {</span>
<span class="nc" id="L117">            throw new IllegalArgumentException(&quot;connect: null address&quot;);</span>
        }
<span class="fc" id="L119">        checkAddress (address, &quot;connect&quot;);</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L121">            return;</span>
<span class="fc" id="L122">        SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (security != null) {</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">            if (address.isMulticastAddress()) {</span>
<span class="nc" id="L125">                security.checkMulticast(address);</span>
            } else {
<span class="fc" id="L127">                security.checkConnect(address.getHostAddress(), port);</span>
<span class="fc" id="L128">                security.checkAccept(address.getHostAddress(), port);</span>
            }
        }

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (!isBound())</span>
<span class="nc" id="L133">          bind(new InetSocketAddress(0));</span>

        // old impls do not support connect/disconnect
<span class="pc bpc" id="L136" title="2 of 4 branches missed.">        if (oldImpl || (impl instanceof AbstractPlainDatagramSocketImpl &amp;&amp;</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">             ((AbstractPlainDatagramSocketImpl)impl).nativeConnectDisabled())) {</span>
<span class="nc" id="L138">            connectState = ST_CONNECTED_NO_IMPL;</span>
        } else {
            try {
<span class="fc" id="L141">                getImpl().connect(address, port);</span>

                // socket is now connected by the impl
<span class="fc" id="L144">                connectState = ST_CONNECTED;</span>
<span class="fc" id="L145">            } catch (SocketException se) {</span>

                // connection will be emulated by DatagramSocket
<span class="fc" id="L148">                connectState = ST_CONNECTED_NO_IMPL;</span>
<span class="fc" id="L149">            }</span>
        }

<span class="fc" id="L152">        connectedAddress = address;</span>
<span class="fc" id="L153">        connectedPort = port;</span>
<span class="fc" id="L154">    }</span>


    /**
     * Constructs a datagram socket and binds it to any available port
     * on the local host machine.  The socket will be bound to the
     * {@link InetAddress#isAnyLocalAddress wildcard} address,
     * an IP address chosen by the kernel.
     *
     * &lt;p&gt;If there is a security manager,
     * its {@code checkListen} method is first called
     * with 0 as its argument to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * @exception  SocketException  if the socket could not be opened,
     *               or the socket could not bind to the specified local port.
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkListen} method doesn't allow the operation.
     *
     * @see SecurityManager#checkListen
     */
    public DatagramSocket() throws SocketException {
<span class="fc" id="L176">        this(new InetSocketAddress(0));</span>
<span class="fc" id="L177">    }</span>

    /**
     * Creates an unbound datagram socket with the specified
     * DatagramSocketImpl.
     *
     * @param impl an instance of a &lt;B&gt;DatagramSocketImpl&lt;/B&gt;
     *        the subclass wishes to use on the DatagramSocket.
     * @since   1.4
     */
<span class="fc" id="L187">    protected DatagramSocket(DatagramSocketImpl impl) {</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (impl == null)</span>
<span class="nc" id="L189">            throw new NullPointerException();</span>
<span class="fc" id="L190">        this.impl = impl;</span>
<span class="fc" id="L191">        checkOldImpl();</span>
<span class="fc" id="L192">    }</span>

    /**
     * Creates a datagram socket, bound to the specified local
     * socket address.
     * &lt;p&gt;
     * If, if the address is {@code null}, creates an unbound socket.
     *
     * &lt;p&gt;If there is a security manager,
     * its {@code checkListen} method is first called
     * with the port from the socket address
     * as its argument to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * @param bindaddr local socket address to bind, or {@code null}
     *                 for an unbound socket.
     *
     * @exception  SocketException  if the socket could not be opened,
     *               or the socket could not bind to the specified local port.
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkListen} method doesn't allow the operation.
     *
     * @see SecurityManager#checkListen
     * @since   1.4
     */
<span class="fc" id="L217">    public DatagramSocket(SocketAddress bindaddr) throws SocketException {</span>
        // create a datagram socket.
<span class="fc" id="L219">        createImpl();</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (bindaddr != null) {</span>
            try {
<span class="fc" id="L222">                bind(bindaddr);</span>
            } finally {
<span class="pc bpc" id="L224" title="2 of 4 branches missed.">                if (!isBound())</span>
<span class="pc" id="L225">                    close();</span>
            }
        }
<span class="fc" id="L228">    }</span>

    /**
     * Constructs a datagram socket and binds it to the specified port
     * on the local host machine.  The socket will be bound to the
     * {@link InetAddress#isAnyLocalAddress wildcard} address,
     * an IP address chosen by the kernel.
     *
     * &lt;p&gt;If there is a security manager,
     * its {@code checkListen} method is first called
     * with the {@code port} argument
     * as its argument to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * @param      port port to use.
     * @exception  SocketException  if the socket could not be opened,
     *               or the socket could not bind to the specified local port.
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkListen} method doesn't allow the operation.
     *
     * @see SecurityManager#checkListen
     */
    public DatagramSocket(int port) throws SocketException {
<span class="fc" id="L251">        this(port, null);</span>
<span class="fc" id="L252">    }</span>

    /**
     * Creates a datagram socket, bound to the specified local
     * address.  The local port must be between 0 and 65535 inclusive.
     * If the IP address is 0.0.0.0, the socket will be bound to the
     * {@link InetAddress#isAnyLocalAddress wildcard} address,
     * an IP address chosen by the kernel.
     *
     * &lt;p&gt;If there is a security manager,
     * its {@code checkListen} method is first called
     * with the {@code port} argument
     * as its argument to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * @param port local port to use
     * @param laddr local address to bind
     *
     * @exception  SocketException  if the socket could not be opened,
     *               or the socket could not bind to the specified local port.
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkListen} method doesn't allow the operation.
     *
     * @see SecurityManager#checkListen
     * @since   JDK1.1
     */
    public DatagramSocket(int port, InetAddress laddr) throws SocketException {
<span class="fc" id="L279">        this(new InetSocketAddress(laddr, port));</span>
<span class="fc" id="L280">    }</span>

    private void checkOldImpl() {
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        if (impl == null)</span>
<span class="nc" id="L284">            return;</span>
        // DatagramSocketImpl.peekdata() is a protected method, therefore we need to use
        // getDeclaredMethod, therefore we need permission to access the member
        try {
<span class="fc" id="L288">            AccessController.doPrivileged(</span>
<span class="fc" id="L289">                new PrivilegedExceptionAction&lt;Void&gt;() {</span>
                    public Void run() throws NoSuchMethodException {
<span class="fc" id="L291">                        Class&lt;?&gt;[] cl = new Class&lt;?&gt;[1];</span>
<span class="fc" id="L292">                        cl[0] = DatagramPacket.class;</span>
<span class="fc" id="L293">                        impl.getClass().getDeclaredMethod(&quot;peekData&quot;, cl);</span>
<span class="fc" id="L294">                        return null;</span>
                    }
                });
<span class="nc" id="L297">        } catch (java.security.PrivilegedActionException e) {</span>
<span class="nc" id="L298">            oldImpl = true;</span>
<span class="fc" id="L299">        }</span>
<span class="fc" id="L300">    }</span>

<span class="fc" id="L302">    static Class&lt;?&gt; implClass = null;</span>

    void createImpl() throws SocketException {
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        if (impl == null) {</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">            if (factory != null) {</span>
<span class="fc" id="L307">                impl = factory.createDatagramSocketImpl();</span>
<span class="fc" id="L308">                checkOldImpl();</span>
            } else {
<span class="fc bfc" id="L310" title="All 2 branches covered.">                boolean isMulticast = (this instanceof MulticastSocket) ? true : false;</span>
<span class="fc" id="L311">                impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(isMulticast);</span>

<span class="fc" id="L313">                checkOldImpl();</span>
            }
        }
        // creates a udp socket
<span class="fc" id="L317">        impl.create();</span>
<span class="fc" id="L318">        created = true;</span>
<span class="fc" id="L319">    }</span>

    /**
     * Get the {@code DatagramSocketImpl} attached to this socket,
     * creating it if necessary.
     *
     * @return  the {@code DatagramSocketImpl} attached to that
     *          DatagramSocket
     * @throws SocketException if creation fails.
     * @since 1.4
     */
    DatagramSocketImpl getImpl() throws SocketException {
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if (!created)</span>
<span class="nc" id="L332">            createImpl();</span>
<span class="fc" id="L333">        return impl;</span>
    }

    /**
     * Binds this DatagramSocket to a specific address and port.
     * &lt;p&gt;
     * If the address is {@code null}, then the system will pick up
     * an ephemeral port and a valid local address to bind the socket.
     *&lt;p&gt;
     * @param   addr The address and port to bind to.
     * @throws  SocketException if any error happens during the bind, or if the
     *          socket is already bound.
     * @throws  SecurityException  if a security manager exists and its
     *             {@code checkListen} method doesn't allow the operation.
     * @throws IllegalArgumentException if addr is a SocketAddress subclass
     *         not supported by this socket.
     * @since 1.4
     */
    public synchronized void bind(SocketAddress addr) throws SocketException {
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L353">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (isBound())</span>
<span class="nc" id="L355">            throw new SocketException(&quot;already bound&quot;);</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (addr == null)</span>
<span class="nc" id="L357">            addr = new InetSocketAddress(0);</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if (!(addr instanceof InetSocketAddress))</span>
<span class="nc" id="L359">            throw new IllegalArgumentException(&quot;Unsupported address type!&quot;);</span>
<span class="fc" id="L360">        InetSocketAddress epoint = (InetSocketAddress) addr;</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if (epoint.isUnresolved())</span>
<span class="nc" id="L362">            throw new SocketException(&quot;Unresolved address&quot;);</span>
<span class="fc" id="L363">        InetAddress iaddr = epoint.getAddress();</span>
<span class="fc" id="L364">        int port = epoint.getPort();</span>
<span class="fc" id="L365">        checkAddress(iaddr, &quot;bind&quot;);</span>
<span class="fc" id="L366">        SecurityManager sec = System.getSecurityManager();</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (sec != null) {</span>
<span class="fc" id="L368">            sec.checkListen(port);</span>
        }
        try {
<span class="fc" id="L371">            getImpl().bind(port, iaddr);</span>
<span class="fc" id="L372">        } catch (SocketException e) {</span>
<span class="fc" id="L373">            getImpl().close();</span>
<span class="fc" id="L374">            throw e;</span>
<span class="fc" id="L375">        }</span>
<span class="fc" id="L376">        bound = true;</span>
<span class="fc" id="L377">    }</span>

    void checkAddress (InetAddress addr, String op) {
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (addr == null) {</span>
<span class="fc" id="L381">            return;</span>
        }
<span class="pc bpc" id="L383" title="1 of 4 branches missed.">        if (!(addr instanceof Inet4Address || addr instanceof Inet6Address)) {</span>
<span class="nc" id="L384">            throw new IllegalArgumentException(op + &quot;: invalid address type&quot;);</span>
        }
<span class="fc" id="L386">    }</span>

    /**
     * Connects the socket to a remote address for this socket. When a
     * socket is connected to a remote address, packets may only be
     * sent to or received from that address. By default a datagram
     * socket is not connected.
     *
     * &lt;p&gt;If the remote destination to which the socket is connected does not
     * exist, or is otherwise unreachable, and if an ICMP destination unreachable
     * packet has been received for that address, then a subsequent call to
     * send or receive may throw a PortUnreachableException. Note, there is no
     * guarantee that the exception will be thrown.
     *
     * &lt;p&gt; If a security manager has been installed then it is invoked to check
     * access to the remote address. Specifically, if the given {@code address}
     * is a {@link InetAddress#isMulticastAddress multicast address},
     * the security manager's {@link
     * java.lang.SecurityManager#checkMulticast(InetAddress)
     * checkMulticast} method is invoked with the given {@code address}.
     * Otherwise, the security manager's {@link
     * java.lang.SecurityManager#checkConnect(String,int) checkConnect}
     * and {@link java.lang.SecurityManager#checkAccept checkAccept} methods
     * are invoked, with the given {@code address} and {@code port}, to
     * verify that datagrams are permitted to be sent and received
     * respectively.
     *
     * &lt;p&gt; When a socket is connected, {@link #receive receive} and
     * {@link #send send} &lt;b&gt;will not perform any security checks&lt;/b&gt;
     * on incoming and outgoing packets, other than matching the packet's
     * and the socket's address and port. On a send operation, if the
     * packet's address is set and the packet's address and the socket's
     * address do not match, an {@code IllegalArgumentException} will be
     * thrown. A socket connected to a multicast address may only be used
     * to send packets.
     *
     * @param address the remote address for the socket
     *
     * @param port the remote port for the socket.
     *
     * @throws IllegalArgumentException
     *         if the address is null, or the port is out of range.
     *
     * @throws SecurityException
     *         if a security manager has been installed and it does
     *         not permit access to the given remote address
     *
     * @see #disconnect
     */
    public void connect(InetAddress address, int port) {
        try {
<span class="fc" id="L437">            connectInternal(address, port);</span>
<span class="nc" id="L438">        } catch (SocketException se) {</span>
<span class="nc" id="L439">            throw new Error(&quot;connect failed&quot;, se);</span>
<span class="fc" id="L440">        }</span>
<span class="fc" id="L441">    }</span>

    /**
     * Connects this socket to a remote socket address (IP address + port number).
     *
     * &lt;p&gt; If given an {@link InetSocketAddress InetSocketAddress}, this method
     * behaves as if invoking {@link #connect(InetAddress,int) connect(InetAddress,int)}
     * with the the given socket addresses IP address and port number.
     *
     * @param   addr    The remote address.
     *
     * @throws  SocketException
     *          if the connect fails
     *
     * @throws IllegalArgumentException
     *         if {@code addr} is {@code null}, or {@code addr} is a SocketAddress
     *         subclass not supported by this socket
     *
     * @throws SecurityException
     *         if a security manager has been installed and it does
     *         not permit access to the given remote address
     *
     * @since 1.4
     */
    public void connect(SocketAddress addr) throws SocketException {
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (addr == null)</span>
<span class="nc" id="L467">            throw new IllegalArgumentException(&quot;Address can't be null&quot;);</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        if (!(addr instanceof InetSocketAddress))</span>
<span class="nc" id="L469">            throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>
<span class="fc" id="L470">        InetSocketAddress epoint = (InetSocketAddress) addr;</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        if (epoint.isUnresolved())</span>
<span class="nc" id="L472">            throw new SocketException(&quot;Unresolved address&quot;);</span>
<span class="fc" id="L473">        connectInternal(epoint.getAddress(), epoint.getPort());</span>
<span class="fc" id="L474">    }</span>

    /**
     * Disconnects the socket. If the socket is closed or not connected,
     * then this method has no effect.
     *
     * @see #connect
     */
    public void disconnect() {
<span class="fc" id="L483">        synchronized (this) {</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">            if (isClosed())</span>
<span class="nc" id="L485">                return;</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">            if (connectState == ST_CONNECTED) {</span>
<span class="fc" id="L487">                impl.disconnect ();</span>
            }
<span class="fc" id="L489">            connectedAddress = null;</span>
<span class="fc" id="L490">            connectedPort = -1;</span>
<span class="fc" id="L491">            connectState = ST_NOT_CONNECTED;</span>
<span class="pc" id="L492">        }</span>
<span class="fc" id="L493">    }</span>

    /**
     * Returns the binding state of the socket.
     * &lt;p&gt;
     * If the socket was bound prior to being {@link #close closed},
     * then this method will continue to return {@code true}
     * after the socket is closed.
     *
     * @return true if the socket successfully bound to an address
     * @since 1.4
     */
    public boolean isBound() {
<span class="fc" id="L506">        return bound;</span>
    }

    /**
     * Returns the connection state of the socket.
     * &lt;p&gt;
     * If the socket was connected prior to being {@link #close closed},
     * then this method will continue to return {@code true}
     * after the socket is closed.
     *
     * @return true if the socket successfully connected to a server
     * @since 1.4
     */
    public boolean isConnected() {
<span class="nc bnc" id="L520" title="All 2 branches missed.">        return connectState != ST_NOT_CONNECTED;</span>
    }

    /**
     * Returns the address to which this socket is connected. Returns
     * {@code null} if the socket is not connected.
     * &lt;p&gt;
     * If the socket was connected prior to being {@link #close closed},
     * then this method will continue to return the connected address
     * after the socket is closed.
     *
     * @return the address to which this socket is connected.
     */
    public InetAddress getInetAddress() {
<span class="nc" id="L534">        return connectedAddress;</span>
    }

    /**
     * Returns the port number to which this socket is connected.
     * Returns {@code -1} if the socket is not connected.
     * &lt;p&gt;
     * If the socket was connected prior to being {@link #close closed},
     * then this method will continue to return the connected port number
     * after the socket is closed.
     *
     * @return the port number to which this socket is connected.
     */
    public int getPort() {
<span class="nc" id="L548">        return connectedPort;</span>
    }

    /**
     * Returns the address of the endpoint this socket is connected to, or
     * {@code null} if it is unconnected.
     * &lt;p&gt;
     * If the socket was connected prior to being {@link #close closed},
     * then this method will continue to return the connected address
     * after the socket is closed.
     *
     * @return a {@code SocketAddress} representing the remote
     *         endpoint of this socket, or {@code null} if it is
     *         not connected yet.
     * @see #getInetAddress()
     * @see #getPort()
     * @see #connect(SocketAddress)
     * @since 1.4
     */
    public SocketAddress getRemoteSocketAddress() {
<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (!isConnected())</span>
<span class="nc" id="L569">            return null;</span>
<span class="nc" id="L570">        return new InetSocketAddress(getInetAddress(), getPort());</span>
    }

    /**
     * Returns the address of the endpoint this socket is bound to.
     *
     * @return a {@code SocketAddress} representing the local endpoint of this
     *         socket, or {@code null} if it is closed or not bound yet.
     * @see #getLocalAddress()
     * @see #getLocalPort()
     * @see #bind(SocketAddress)
     * @since 1.4
     */

    public SocketAddress getLocalSocketAddress() {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L586">            return null;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (!isBound())</span>
<span class="nc" id="L588">            return null;</span>
<span class="nc" id="L589">        return new InetSocketAddress(getLocalAddress(), getLocalPort());</span>
    }

    /**
     * Sends a datagram packet from this socket. The
     * {@code DatagramPacket} includes information indicating the
     * data to be sent, its length, the IP address of the remote host,
     * and the port number on the remote host.
     *
     * &lt;p&gt;If there is a security manager, and the socket is not currently
     * connected to a remote address, this method first performs some
     * security checks. First, if {@code p.getAddress().isMulticastAddress()}
     * is true, this method calls the
     * security manager's {@code checkMulticast} method
     * with {@code p.getAddress()} as its argument.
     * If the evaluation of that expression is false,
     * this method instead calls the security manager's
     * {@code checkConnect} method with arguments
     * {@code p.getAddress().getHostAddress()} and
     * {@code p.getPort()}. Each call to a security manager method
     * could result in a SecurityException if the operation is not allowed.
     *
     * @param      p   the {@code DatagramPacket} to be sent.
     *
     * @exception  IOException  if an I/O error occurs.
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkMulticast} or {@code checkConnect}
     *             method doesn't allow the send.
     * @exception  PortUnreachableException may be thrown if the socket is connected
     *             to a currently unreachable destination. Note, there is no
     *             guarantee that the exception will be thrown.
     * @exception  java.nio.channels.IllegalBlockingModeException
     *             if this socket has an associated channel,
     *             and the channel is in non-blocking mode.
     * @exception  IllegalArgumentException if the socket is connected,
     *             and connected address and packet address differ.
     *
     * @see        java.net.DatagramPacket
     * @see        SecurityManager#checkMulticast(InetAddress)
     * @see        SecurityManager#checkConnect
     * @revised 1.4
     * @spec JSR-51
     */
    public void send(DatagramPacket p) throws IOException  {
<span class="fc" id="L633">        InetAddress packetAddress = null;</span>
<span class="fc" id="L634">        synchronized (p) {</span>
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">            if (isClosed())</span>
<span class="nc" id="L636">                throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="fc" id="L637">            checkAddress (p.getAddress(), &quot;send&quot;);</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">            if (connectState == ST_NOT_CONNECTED) {</span>
                // check the address is ok wiht the security manager on every send.
<span class="fc" id="L640">                SecurityManager security = System.getSecurityManager();</span>

                // The reason you want to synchronize on datagram packet
                // is because you don't want an applet to change the address
                // while you are trying to send the packet for example
                // after the security check but before the send.
<span class="fc bfc" id="L646" title="All 2 branches covered.">                if (security != null) {</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">                    if (p.getAddress().isMulticastAddress()) {</span>
<span class="fc" id="L648">                        security.checkMulticast(p.getAddress());</span>
                    } else {
<span class="fc" id="L650">                        security.checkConnect(p.getAddress().getHostAddress(),</span>
<span class="fc" id="L651">                                              p.getPort());</span>
                    }
                }
<span class="fc" id="L654">            } else {</span>
                // we're connected
<span class="fc" id="L656">                packetAddress = p.getAddress();</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">                if (packetAddress == null) {</span>
<span class="fc" id="L658">                    p.setAddress(connectedAddress);</span>
<span class="fc" id="L659">                    p.setPort(connectedPort);</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">                } else if ((!packetAddress.equals(connectedAddress)) ||</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">                           p.getPort() != connectedPort) {</span>
<span class="nc" id="L662">                    throw new IllegalArgumentException(&quot;connected address &quot; +</span>
                                                       &quot;and packet address&quot; +
                                                       &quot; differ&quot;);
                }
            }
            // Check whether the socket is bound
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">            if (!isBound())</span>
<span class="nc" id="L669">                bind(new InetSocketAddress(0));</span>
            // call the  method to send
<span class="fc" id="L671">            getImpl().send(p);</span>
<span class="fc" id="L672">        }</span>
<span class="fc" id="L673">    }</span>

    /**
     * Receives a datagram packet from this socket. When this method
     * returns, the {@code DatagramPacket}'s buffer is filled with
     * the data received. The datagram packet also contains the sender's
     * IP address, and the port number on the sender's machine.
     * &lt;p&gt;
     * This method blocks until a datagram is received. The
     * {@code length} field of the datagram packet object contains
     * the length of the received message. If the message is longer than
     * the packet's length, the message is truncated.
     * &lt;p&gt;
     * If there is a security manager, a packet cannot be received if the
     * security manager's {@code checkAccept} method
     * does not allow it.
     *
     * @param      p   the {@code DatagramPacket} into which to place
     *                 the incoming data.
     * @exception  IOException  if an I/O error occurs.
     * @exception  SocketTimeoutException  if setSoTimeout was previously called
     *                 and the timeout has expired.
     * @exception  PortUnreachableException may be thrown if the socket is connected
     *             to a currently unreachable destination. Note, there is no guarantee that the
     *             exception will be thrown.
     * @exception  java.nio.channels.IllegalBlockingModeException
     *             if this socket has an associated channel,
     *             and the channel is in non-blocking mode.
     * @see        java.net.DatagramPacket
     * @see        java.net.DatagramSocket
     * @revised 1.4
     * @spec JSR-51
     */
    public synchronized void receive(DatagramPacket p) throws IOException {
<span class="fc" id="L707">        synchronized (p) {</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">            if (!isBound())</span>
<span class="nc" id="L709">                bind(new InetSocketAddress(0));</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">            if (connectState == ST_NOT_CONNECTED) {</span>
                // check the address is ok with the security manager before every recv.
<span class="fc" id="L712">                SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">                if (security != null) {</span>
                    while(true) {
<span class="fc" id="L715">                        String peekAd = null;</span>
<span class="fc" id="L716">                        int peekPort = 0;</span>
                        // peek at the packet to see who it is from.
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">                        if (!oldImpl) {</span>
                            // We can use the new peekData() API
<span class="fc" id="L720">                            DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);</span>
<span class="fc" id="L721">                            peekPort = getImpl().peekData(peekPacket);</span>
<span class="fc" id="L722">                            peekAd = peekPacket.getAddress().getHostAddress();</span>
<span class="fc" id="L723">                        } else {</span>
<span class="nc" id="L724">                            InetAddress adr = new InetAddress();</span>
<span class="nc" id="L725">                            peekPort = getImpl().peek(adr);</span>
<span class="nc" id="L726">                            peekAd = adr.getHostAddress();</span>
                        }
                        try {
<span class="fc" id="L729">                            security.checkAccept(peekAd, peekPort);</span>
                            // security check succeeded - so now break
                            // and recv the packet.
<span class="fc" id="L732">                            break;</span>
<span class="nc" id="L733">                        } catch (SecurityException se) {</span>
                            // Throw away the offending packet by consuming
                            // it in a tmp buffer.
<span class="nc" id="L736">                            DatagramPacket tmp = new DatagramPacket(new byte[1], 1);</span>
<span class="nc" id="L737">                            getImpl().receive(tmp);</span>

                            // silently discard the offending packet
                            // and continue: unknown/malicious
                            // entities on nets should not make
                            // runtime throw security exception and
                            // disrupt the applet by sending random
                            // datagram packets.
<span class="nc" id="L745">                            continue;</span>
                        }
                    } // end of while
                }
            }
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">            if (connectState == ST_CONNECTED_NO_IMPL) {</span>
                // We have to do the filtering the old fashioned way since
                // the native impl doesn't support connect or the connect
                // via the impl failed.
<span class="nc" id="L754">                boolean stop = false;</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">                while (!stop) {</span>
<span class="nc" id="L756">                    InetAddress peekAddress = null;</span>
<span class="nc" id="L757">                    int peekPort = -1;</span>
                    // peek at the packet to see who it is from.
<span class="nc bnc" id="L759" title="All 2 branches missed.">                    if (!oldImpl) {</span>
                        // We can use the new peekData() API
<span class="nc" id="L761">                        DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);</span>
<span class="nc" id="L762">                        peekPort = getImpl().peekData(peekPacket);</span>
<span class="nc" id="L763">                        peekAddress = peekPacket.getAddress();</span>
<span class="nc" id="L764">                    } else {</span>
                        // this api only works for IPv4
<span class="nc" id="L766">                        peekAddress = new InetAddress();</span>
<span class="nc" id="L767">                        peekPort = getImpl().peek(peekAddress);</span>
                    }
<span class="nc bnc" id="L769" title="All 4 branches missed.">                    if ((!connectedAddress.equals(peekAddress)) ||</span>
                        (connectedPort != peekPort)) {
                        // throw the packet away and silently continue
<span class="nc" id="L772">                        DatagramPacket tmp = new DatagramPacket(new byte[1], 1);</span>
<span class="nc" id="L773">                        getImpl().receive(tmp);</span>
<span class="nc" id="L774">                    } else {</span>
<span class="nc" id="L775">                        stop = true;</span>
                    }
<span class="nc" id="L777">                }</span>
            }
            // If the security check succeeds, or the datagram is
            // connected then receive the packet
<span class="fc" id="L781">            getImpl().receive(p);</span>
<span class="fc" id="L782">        }</span>
<span class="fc" id="L783">    }</span>

    /**
     * Gets the local address to which the socket is bound.
     *
     * &lt;p&gt;If there is a security manager, its
     * {@code checkConnect} method is first called
     * with the host address and {@code -1}
     * as its arguments to see if the operation is allowed.
     *
     * @see SecurityManager#checkConnect
     * @return  the local address to which the socket is bound,
     *          {@code null} if the socket is closed, or
     *          an {@code InetAddress} representing
     *          {@link InetAddress#isAnyLocalAddress wildcard}
     *          address if either the socket is not bound, or
     *          the security manager {@code checkConnect}
     *          method does not allow the operation
     * @since   1.1
     */
    public InetAddress getLocalAddress() {
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L805">            return null;</span>
<span class="fc" id="L806">        InetAddress in = null;</span>
        try {
<span class="fc" id="L808">            in = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">            if (in.isAnyLocalAddress()) {</span>
<span class="nc" id="L810">                in = InetAddress.anyLocalAddress();</span>
            }
<span class="fc" id="L812">            SecurityManager s = System.getSecurityManager();</span>
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">            if (s != null) {</span>
<span class="fc" id="L814">                s.checkConnect(in.getHostAddress(), -1);</span>
            }
<span class="nc" id="L816">        } catch (Exception e) {</span>
<span class="nc" id="L817">            in = InetAddress.anyLocalAddress(); // &quot;0.0.0.0&quot;</span>
<span class="fc" id="L818">        }</span>
<span class="fc" id="L819">        return in;</span>
    }

    /**
     * Returns the port number on the local host to which this socket
     * is bound.
     *
     * @return  the port number on the local host to which this socket is bound,
                {@code -1} if the socket is closed, or
                {@code 0} if it is not bound yet.
     */
    public int getLocalPort() {
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L832">            return -1;</span>
        try {
<span class="fc" id="L834">            return getImpl().getLocalPort();</span>
<span class="nc" id="L835">        } catch (Exception e) {</span>
<span class="nc" id="L836">            return 0;</span>
        }
    }

    /** Enable/disable SO_TIMEOUT with the specified timeout, in
     *  milliseconds. With this option set to a non-zero timeout,
     *  a call to receive() for this DatagramSocket
     *  will block for only this amount of time.  If the timeout expires,
     *  a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
     *  DatagramSocket is still valid.  The option &lt;B&gt;must&lt;/B&gt; be enabled
     *  prior to entering the blocking operation to have effect.  The
     *  timeout must be {@code &gt; 0}.
     *  A timeout of zero is interpreted as an infinite timeout.
     *
     * @param timeout the specified timeout in milliseconds.
     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
     * @since   JDK1.1
     * @see #getSoTimeout()
     */
    public synchronized void setSoTimeout(int timeout) throws SocketException {
<span class="pc bpc" id="L856" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L857">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="fc" id="L858">        getImpl().setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));</span>
<span class="fc" id="L859">    }</span>

    /**
     * Retrieve setting for SO_TIMEOUT.  0 returns implies that the
     * option is disabled (i.e., timeout of infinity).
     *
     * @return the setting for SO_TIMEOUT
     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
     * @since   JDK1.1
     * @see #setSoTimeout(int)
     */
    public synchronized int getSoTimeout() throws SocketException {
<span class="nc bnc" id="L871" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L872">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">        if (getImpl() == null)</span>
<span class="nc" id="L874">            return 0;</span>
<span class="nc" id="L875">        Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);</span>
        /* extra type safety */
<span class="nc bnc" id="L877" title="All 2 branches missed.">        if (o instanceof Integer) {</span>
<span class="nc" id="L878">            return ((Integer) o).intValue();</span>
        } else {
<span class="nc" id="L880">            return 0;</span>
        }
    }

    /**
     * Sets the SO_SNDBUF option to the specified value for this
     * {@code DatagramSocket}. The SO_SNDBUF option is used by the
     * network implementation as a hint to size the underlying
     * network I/O buffers. The SO_SNDBUF setting may also be used
     * by the network implementation to determine the maximum size
     * of the packet that can be sent on this socket.
     * &lt;p&gt;
     * As SO_SNDBUF is a hint, applications that want to verify
     * what size the buffer is should call {@link #getSendBufferSize()}.
     * &lt;p&gt;
     * Increasing the buffer size may allow multiple outgoing packets
     * to be queued by the network implementation when the send rate
     * is high.
     * &lt;p&gt;
     * Note: If {@link #send(DatagramPacket)} is used to send a
     * {@code DatagramPacket} that is larger than the setting
     * of SO_SNDBUF then it is implementation specific if the
     * packet is sent or discarded.
     *
     * @param size the size to which to set the send buffer
     * size. This value must be greater than 0.
     *
     * @exception SocketException if there is an error
     * in the underlying protocol, such as an UDP error.
     * @exception IllegalArgumentException if the value is 0 or is
     * negative.
     * @see #getSendBufferSize()
     */
    public synchronized void setSendBufferSize(int size)
    throws SocketException{
<span class="nc bnc" id="L915" title="All 2 branches missed.">        if (!(size &gt; 0)) {</span>
<span class="nc" id="L916">            throw new IllegalArgumentException(&quot;negative send size&quot;);</span>
        }
<span class="nc bnc" id="L918" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L919">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc" id="L920">        getImpl().setOption(SocketOptions.SO_SNDBUF, new Integer(size));</span>
<span class="nc" id="L921">    }</span>

    /**
     * Get value of the SO_SNDBUF option for this {@code DatagramSocket}, that is the
     * buffer size used by the platform for output on this {@code DatagramSocket}.
     *
     * @return the value of the SO_SNDBUF option for this {@code DatagramSocket}
     * @exception SocketException if there is an error in
     * the underlying protocol, such as an UDP error.
     * @see #setSendBufferSize
     */
    public synchronized int getSendBufferSize() throws SocketException {
<span class="nc bnc" id="L933" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L934">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc" id="L935">        int result = 0;</span>
<span class="nc" id="L936">        Object o = getImpl().getOption(SocketOptions.SO_SNDBUF);</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">        if (o instanceof Integer) {</span>
<span class="nc" id="L938">            result = ((Integer)o).intValue();</span>
        }
<span class="nc" id="L940">        return result;</span>
    }

    /**
     * Sets the SO_RCVBUF option to the specified value for this
     * {@code DatagramSocket}. The SO_RCVBUF option is used by the
     * the network implementation as a hint to size the underlying
     * network I/O buffers. The SO_RCVBUF setting may also be used
     * by the network implementation to determine the maximum size
     * of the packet that can be received on this socket.
     * &lt;p&gt;
     * Because SO_RCVBUF is a hint, applications that want to
     * verify what size the buffers were set to should call
     * {@link #getReceiveBufferSize()}.
     * &lt;p&gt;
     * Increasing SO_RCVBUF may allow the network implementation
     * to buffer multiple packets when packets arrive faster than
     * are being received using {@link #receive(DatagramPacket)}.
     * &lt;p&gt;
     * Note: It is implementation specific if a packet larger
     * than SO_RCVBUF can be received.
     *
     * @param size the size to which to set the receive buffer
     * size. This value must be greater than 0.
     *
     * @exception SocketException if there is an error in
     * the underlying protocol, such as an UDP error.
     * @exception IllegalArgumentException if the value is 0 or is
     * negative.
     * @see #getReceiveBufferSize()
     */
    public synchronized void setReceiveBufferSize(int size)
    throws SocketException{
<span class="nc bnc" id="L973" title="All 2 branches missed.">        if (size &lt;= 0) {</span>
<span class="nc" id="L974">            throw new IllegalArgumentException(&quot;invalid receive size&quot;);</span>
        }
<span class="nc bnc" id="L976" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L977">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc" id="L978">        getImpl().setOption(SocketOptions.SO_RCVBUF, new Integer(size));</span>
<span class="nc" id="L979">    }</span>

    /**
     * Get value of the SO_RCVBUF option for this {@code DatagramSocket}, that is the
     * buffer size used by the platform for input on this {@code DatagramSocket}.
     *
     * @return the value of the SO_RCVBUF option for this {@code DatagramSocket}
     * @exception SocketException if there is an error in the underlying protocol, such as an UDP error.
     * @see #setReceiveBufferSize(int)
     */
    public synchronized int getReceiveBufferSize()
    throws SocketException{
<span class="nc bnc" id="L991" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L992">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc" id="L993">        int result = 0;</span>
<span class="nc" id="L994">        Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">        if (o instanceof Integer) {</span>
<span class="nc" id="L996">            result = ((Integer)o).intValue();</span>
        }
<span class="nc" id="L998">        return result;</span>
    }

    /**
     * Enable/disable the SO_REUSEADDR socket option.
     * &lt;p&gt;
     * For UDP sockets it may be necessary to bind more than one
     * socket to the same socket address. This is typically for the
     * purpose of receiving multicast packets
     * (See {@link java.net.MulticastSocket}). The
     * {@code SO_REUSEADDR} socket option allows multiple
     * sockets to be bound to the same socket address if the
     * {@code SO_REUSEADDR} socket option is enabled prior
     * to binding the socket using {@link #bind(SocketAddress)}.
     * &lt;p&gt;
     * Note: This functionality is not supported by all existing platforms,
     * so it is implementation specific whether this option will be ignored
     * or not. However, if it is not supported then
     * {@link #getReuseAddress()} will always return {@code false}.
     * &lt;p&gt;
     * When a {@code DatagramSocket} is created the initial setting
     * of {@code SO_REUSEADDR} is disabled.
     * &lt;p&gt;
     * The behaviour when {@code SO_REUSEADDR} is enabled or
     * disabled after a socket is bound (See {@link #isBound()})
     * is not defined.
     *
     * @param on  whether to enable or disable the
     * @exception SocketException if an error occurs enabling or
     *            disabling the {@code SO_RESUEADDR} socket option,
     *            or the socket is closed.
     * @since 1.4
     * @see #getReuseAddress()
     * @see #bind(SocketAddress)
     * @see #isBound()
     * @see #isClosed()
     */
    public synchronized void setReuseAddress(boolean on) throws SocketException {
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L1037">            throw new SocketException(&quot;Socket is closed&quot;);</span>
        // Integer instead of Boolean for compatibility with older DatagramSocketImpl
<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">        if (oldImpl)</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">            getImpl().setOption(SocketOptions.SO_REUSEADDR, new Integer(on?-1:0));</span>
        else
<span class="fc" id="L1042">            getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));</span>
<span class="fc" id="L1043">    }</span>

    /**
     * Tests if SO_REUSEADDR is enabled.
     *
     * @return a {@code boolean} indicating whether or not SO_REUSEADDR is enabled.
     * @exception SocketException if there is an error
     * in the underlying protocol, such as an UDP error.
     * @since   1.4
     * @see #setReuseAddress(boolean)
     */
    public synchronized boolean getReuseAddress() throws SocketException {
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L1056">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="fc" id="L1057">        Object o = getImpl().getOption(SocketOptions.SO_REUSEADDR);</span>
<span class="fc" id="L1058">        return ((Boolean)o).booleanValue();</span>
    }

    /**
     * Enable/disable SO_BROADCAST.
     *
     * &lt;p&gt; Some operating systems may require that the Java virtual machine be
     * started with implementation specific privileges to enable this option or
     * send broadcast datagrams.
     *
     * @param  on
     *         whether or not to have broadcast turned on.
     *
     * @throws  SocketException
     *          if there is an error in the underlying protocol, such as an UDP
     *          error.
     *
     * @since 1.4
     * @see #getBroadcast()
     */
    public synchronized void setBroadcast(boolean on) throws SocketException {
<span class="nc bnc" id="L1079" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L1080">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc" id="L1081">        getImpl().setOption(SocketOptions.SO_BROADCAST, Boolean.valueOf(on));</span>
<span class="nc" id="L1082">    }</span>

    /**
     * Tests if SO_BROADCAST is enabled.
     * @return a {@code boolean} indicating whether or not SO_BROADCAST is enabled.
     * @exception SocketException if there is an error
     * in the underlying protocol, such as an UDP error.
     * @since 1.4
     * @see #setBroadcast(boolean)
     */
    public synchronized boolean getBroadcast() throws SocketException {
<span class="nc bnc" id="L1093" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L1094">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc" id="L1095">        return ((Boolean)(getImpl().getOption(SocketOptions.SO_BROADCAST))).booleanValue();</span>
    }

    /**
     * Sets traffic class or type-of-service octet in the IP
     * datagram header for datagrams sent from this DatagramSocket.
     * As the underlying network implementation may ignore this
     * value applications should consider it a hint.
     *
     * &lt;P&gt; The tc &lt;B&gt;must&lt;/B&gt; be in the range {@code 0 &lt;= tc &lt;=
     * 255} or an IllegalArgumentException will be thrown.
     * &lt;p&gt;Notes:
     * &lt;p&gt;For Internet Protocol v4 the value consists of an
     * {@code integer}, the least significant 8 bits of which
     * represent the value of the TOS octet in IP packets sent by
     * the socket.
     * RFC 1349 defines the TOS values as follows:
     *
     * &lt;UL&gt;
     * &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWCOST (0x02)&lt;/CODE&gt;&lt;/LI&gt;
     * &lt;LI&gt;&lt;CODE&gt;IPTOS_RELIABILITY (0x04)&lt;/CODE&gt;&lt;/LI&gt;
     * &lt;LI&gt;&lt;CODE&gt;IPTOS_THROUGHPUT (0x08)&lt;/CODE&gt;&lt;/LI&gt;
     * &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWDELAY (0x10)&lt;/CODE&gt;&lt;/LI&gt;
     * &lt;/UL&gt;
     * The last low order bit is always ignored as this
     * corresponds to the MBZ (must be zero) bit.
     * &lt;p&gt;
     * Setting bits in the precedence field may result in a
     * SocketException indicating that the operation is not
     * permitted.
     * &lt;p&gt;
     * for Internet Protocol v6 {@code tc} is the value that
     * would be placed into the sin6_flowinfo field of the IP header.
     *
     * @param tc        an {@code int} value for the bitset.
     * @throws SocketException if there is an error setting the
     * traffic class or type-of-service
     * @since 1.4
     * @see #getTrafficClass
     */
    public synchronized void setTrafficClass(int tc) throws SocketException {
<span class="nc bnc" id="L1136" title="All 4 branches missed.">        if (tc &lt; 0 || tc &gt; 255)</span>
<span class="nc" id="L1137">            throw new IllegalArgumentException(&quot;tc is not in range 0 -- 255&quot;);</span>

<span class="nc bnc" id="L1139" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L1140">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc" id="L1141">        getImpl().setOption(SocketOptions.IP_TOS, new Integer(tc));</span>
<span class="nc" id="L1142">    }</span>

    /**
     * Gets traffic class or type-of-service in the IP datagram
     * header for packets sent from this DatagramSocket.
     * &lt;p&gt;
     * As the underlying network implementation may ignore the
     * traffic class or type-of-service set using {@link #setTrafficClass(int)}
     * this method may return a different value than was previously
     * set using the {@link #setTrafficClass(int)} method on this
     * DatagramSocket.
     *
     * @return the traffic class or type-of-service already set
     * @throws SocketException if there is an error obtaining the
     * traffic class or type-of-service value.
     * @since 1.4
     * @see #setTrafficClass(int)
     */
    public synchronized int getTrafficClass() throws SocketException {
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L1162">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc" id="L1163">        return ((Integer)(getImpl().getOption(SocketOptions.IP_TOS))).intValue();</span>
    }

    /**
     * Closes this datagram socket.
     * &lt;p&gt;
     * Any thread currently blocked in {@link #receive} upon this socket
     * will throw a {@link SocketException}.
     *
     * &lt;p&gt; If this socket has an associated channel then the channel is closed
     * as well.
     *
     * @revised 1.4
     * @spec JSR-51
     */
    public void close() {
<span class="fc" id="L1179">        synchronized(closeLock) {</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">            if (isClosed())</span>
<span class="fc" id="L1181">                return;</span>
<span class="fc" id="L1182">            impl.close();</span>
<span class="fc" id="L1183">            closed = true;</span>
<span class="pc" id="L1184">        }</span>
<span class="fc" id="L1185">    }</span>

    /**
     * Returns whether the socket is closed or not.
     *
     * @return true if the socket has been closed
     * @since 1.4
     */
    public boolean isClosed() {
<span class="fc" id="L1194">        synchronized(closeLock) {</span>
<span class="fc" id="L1195">            return closed;</span>
<span class="nc" id="L1196">        }</span>
    }

    /**
     * Returns the unique {@link java.nio.channels.DatagramChannel} object
     * associated with this datagram socket, if any.
     *
     * &lt;p&gt; A datagram socket will have a channel if, and only if, the channel
     * itself was created via the {@link java.nio.channels.DatagramChannel#open
     * DatagramChannel.open} method.
     *
     * @return  the datagram channel associated with this datagram socket,
     *          or {@code null} if this socket was not created for a channel
     *
     * @since 1.4
     * @spec JSR-51
     */
    public DatagramChannel getChannel() {
<span class="nc" id="L1214">        return null;</span>
    }

    /**
     * User defined factory for all datagram sockets.
     */
    static DatagramSocketImplFactory factory;

    /**
     * Sets the datagram socket implementation factory for the
     * application. The factory can be specified only once.
     * &lt;p&gt;
     * When an application creates a new datagram socket, the socket
     * implementation factory's {@code createDatagramSocketImpl} method is
     * called to create the actual datagram socket implementation.
     * &lt;p&gt;
     * Passing {@code null} to the method is a no-op unless the factory
     * was already set.
     *
     * &lt;p&gt;If there is a security manager, this method first calls
     * the security manager's {@code checkSetFactory} method
     * to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * @param      fac   the desired factory.
     * @exception  IOException  if an I/O error occurs when setting the
     *              datagram socket factory.
     * @exception  SocketException  if the factory is already defined.
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkSetFactory} method doesn't allow the
     operation.
     * @see
     java.net.DatagramSocketImplFactory#createDatagramSocketImpl()
     * @see       SecurityManager#checkSetFactory
     * @since 1.3
     */
    public static synchronized void
    setDatagramSocketImplFactory(DatagramSocketImplFactory fac)
       throws IOException
    {
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">        if (factory != null) {</span>
<span class="nc" id="L1255">            throw new SocketException(&quot;factory already defined&quot;);</span>
        }
<span class="fc" id="L1257">        SecurityManager security = System.getSecurityManager();</span>
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">        if (security != null) {</span>
<span class="nc" id="L1259">            security.checkSetFactory();</span>
        }
<span class="fc" id="L1261">        factory = fac;</span>
<span class="fc" id="L1262">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>