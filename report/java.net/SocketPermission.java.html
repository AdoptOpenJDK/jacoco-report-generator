<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SocketPermission.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">SocketPermission.java</span></div><h1>SocketPermission.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.util.Enumeration;
import java.util.Vector;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.StringTokenizer;
import java.net.InetAddress;
import java.security.Permission;
import java.security.PermissionCollection;
import java.io.Serializable;
import java.io.ObjectStreamField;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import sun.net.util.IPAddressUtil;
import sun.net.RegisteredDomain;
import sun.security.util.SecurityConstants;
import sun.security.util.Debug;


/**
 * This class represents access to a network via sockets.
 * A SocketPermission consists of a
 * host specification and a set of &quot;actions&quot; specifying ways to
 * connect to that host. The host is specified as
 * &lt;pre&gt;
 *    host = (hostname | IPv4address | iPv6reference) [:portrange]
 *    portrange = portnumber | -portnumber | portnumber-[portnumber]
 * &lt;/pre&gt;
 * The host is expressed as a DNS name, as a numerical IP address,
 * or as &quot;localhost&quot; (for the local machine).
 * The wildcard &quot;*&quot; may be included once in a DNS name host
 * specification. If it is included, it must be in the leftmost
 * position, as in &quot;*.sun.com&quot;.
 * &lt;p&gt;
 * The format of the IPv6reference should follow that specified in &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format
 * for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;:
 * &lt;pre&gt;
 *    ipv6reference = &quot;[&quot; IPv6address &quot;]&quot;
 *&lt;/pre&gt;
 * For example, you can construct a SocketPermission instance
 * as the following:
 * &lt;pre&gt;
 *    String hostAddress = inetaddress.getHostAddress();
 *    if (inetaddress instanceof Inet6Address) {
 *        sp = new SocketPermission(&quot;[&quot; + hostAddress + &quot;]:&quot; + port, action);
 *    } else {
 *        sp = new SocketPermission(hostAddress + &quot;:&quot; + port, action);
 *    }
 * &lt;/pre&gt;
 * or
 * &lt;pre&gt;
 *    String host = url.getHost();
 *    sp = new SocketPermission(host + &quot;:&quot; + port, action);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * The &lt;A HREF=&quot;Inet6Address.html#lform&quot;&gt;full uncompressed form&lt;/A&gt; of
 * an IPv6 literal address is also valid.
 * &lt;p&gt;
 * The port or portrange is optional. A port specification of the
 * form &quot;N-&quot;, where &lt;i&gt;N&lt;/i&gt; is a port number, signifies all ports
 * numbered &lt;i&gt;N&lt;/i&gt; and above, while a specification of the
 * form &quot;-N&quot; indicates all ports numbered &lt;i&gt;N&lt;/i&gt; and below.
 * &lt;p&gt;
 * The possible ways to connect to the host are
 * &lt;pre&gt;
 * accept
 * connect
 * listen
 * resolve
 * &lt;/pre&gt;
 * The &quot;listen&quot; action is only meaningful when used with &quot;localhost&quot;.
 * The &quot;resolve&quot; action is implied when any of the other actions are present.
 * The action &quot;resolve&quot; refers to host/ip name service lookups.
 * &lt;P&gt;
 * The actions string is converted to lowercase before processing.
 * &lt;p&gt;As an example of the creation and meaning of SocketPermissions,
 * note that if the following permission:
 *
 * &lt;pre&gt;
 *   p1 = new SocketPermission(&quot;puffin.eng.sun.com:7777&quot;, &quot;connect,accept&quot;);
 * &lt;/pre&gt;
 *
 * is granted to some code, it allows that code to connect to port 7777 on
 * {@code puffin.eng.sun.com}, and to accept connections on that port.
 *
 * &lt;p&gt;Similarly, if the following permission:
 *
 * &lt;pre&gt;
 *   p2 = new SocketPermission(&quot;localhost:1024-&quot;, &quot;accept,connect,listen&quot;);
 * &lt;/pre&gt;
 *
 * is granted to some code, it allows that code to
 * accept connections on, connect to, or listen on any port between
 * 1024 and 65535 on the local host.
 *
 * &lt;p&gt;Note: Granting code permission to accept or make connections to remote
 * hosts may be dangerous because malevolent code can then more easily
 * transfer and share confidential data among parties who may not
 * otherwise have access to the data.
 *
 * @see java.security.Permissions
 * @see SocketPermission
 *
 *
 * @author Marianne Mueller
 * @author Roland Schemers
 *
 * @serial exclude
 */

public final class SocketPermission extends Permission
    implements java.io.Serializable
{
    private static final long serialVersionUID = -7204263841984476862L;

    /**
     * Connect to host:port
     */
    private final static int CONNECT    = 0x1;

    /**
     * Listen on host:port
     */
    private final static int LISTEN     = 0x2;

    /**
     * Accept a connection from host:port
     */
    private final static int ACCEPT     = 0x4;

    /**
     * Resolve DNS queries
     */
    private final static int RESOLVE    = 0x8;

    /**
     * No actions
     */
    private final static int NONE               = 0x0;

    /**
     * All actions
     */
    private final static int ALL        = CONNECT|LISTEN|ACCEPT|RESOLVE;

    // various port constants
    private static final int PORT_MIN = 0;
    private static final int PORT_MAX = 65535;
    private static final int PRIV_PORT_MAX = 1023;

    // the actions mask
    private transient int mask;

    /**
     * the actions string.
     *
     * @serial
     */

    private String actions; // Left null as long as possible, then
                            // created and re-used in the getAction function.

    // hostname part as it is passed
    private transient String hostname;

    // the canonical name of the host
    // in the case of &quot;*.foo.com&quot;, cname is &quot;.foo.com&quot;.

    private transient String cname;

    // all the IP addresses of the host
    private transient InetAddress[] addresses;

    // true if the hostname is a wildcard (e.g. &quot;*.sun.com&quot;)
    private transient boolean wildcard;

    // true if we were initialized with a single numeric IP address
    private transient boolean init_with_ip;

    // true if this SocketPermission represents an invalid/unknown host
    // used for implies when the delayed lookup has already failed
    private transient boolean invalid;

    // port range on host
    private transient int[] portrange;

<span class="pc" id="L216">    private transient boolean defaultDeny = false;</span>

    // true if this SocketPermission represents a hostname
    // that failed our reverse mapping heuristic test
    private transient boolean untrusted;
    private transient boolean trusted;

    // true if the sun.net.trustNameService system property is set
    private static boolean trustNameService;

<span class="fc" id="L226">    private static Debug debug = null;</span>
<span class="fc" id="L227">    private static boolean debugInit = false;</span>

    static {
<span class="fc" id="L230">        Boolean tmp = java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetBooleanAction(&quot;sun.net.trustNameService&quot;));
<span class="fc" id="L232">        trustNameService = tmp.booleanValue();</span>
<span class="fc" id="L233">    }</span>

    private static synchronized Debug getDebug() {
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (!debugInit) {</span>
<span class="nc" id="L237">            debug = Debug.getInstance(&quot;access&quot;);</span>
<span class="nc" id="L238">            debugInit = true;</span>
        }
<span class="nc" id="L240">        return debug;</span>
    }

    /**
     * Creates a new SocketPermission object with the specified actions.
     * The host is expressed as a DNS name, or as a numerical IP address.
     * Optionally, a port or a portrange may be supplied (separated
     * from the DNS name or IP address by a colon).
     * &lt;p&gt;
     * To specify the local machine, use &quot;localhost&quot; as the &lt;i&gt;host&lt;/i&gt;.
     * Also note: An empty &lt;i&gt;host&lt;/i&gt; String (&quot;&quot;) is equivalent to &quot;localhost&quot;.
     * &lt;p&gt;
     * The &lt;i&gt;actions&lt;/i&gt; parameter contains a comma-separated list of the
     * actions granted for the specified host (and port(s)). Possible actions are
     * &quot;connect&quot;, &quot;listen&quot;, &quot;accept&quot;, &quot;resolve&quot;, or
     * any combination of those. &quot;resolve&quot; is automatically added
     * when any of the other three are specified.
     * &lt;p&gt;
     * Examples of SocketPermission instantiation are the following:
     * &lt;pre&gt;
     *    nr = new SocketPermission(&quot;www.catalog.com&quot;, &quot;connect&quot;);
     *    nr = new SocketPermission(&quot;www.sun.com:80&quot;, &quot;connect&quot;);
     *    nr = new SocketPermission(&quot;*.sun.com&quot;, &quot;connect&quot;);
     *    nr = new SocketPermission(&quot;*.edu&quot;, &quot;resolve&quot;);
     *    nr = new SocketPermission(&quot;204.160.241.0&quot;, &quot;connect&quot;);
     *    nr = new SocketPermission(&quot;localhost:1024-65535&quot;, &quot;listen&quot;);
     *    nr = new SocketPermission(&quot;204.160.241.0:1024-65535&quot;, &quot;connect&quot;);
     * &lt;/pre&gt;
     *
     * @param host the hostname or IPaddress of the computer, optionally
     * including a colon followed by a port or port range.
     * @param action the action string.
     */
    public SocketPermission(String host, String action) {
<span class="fc" id="L274">        super(getHost(host));</span>
        // name initialized to getHost(host); NPE detected in getHost()
<span class="fc" id="L276">        init(getName(), getMask(action));</span>
<span class="fc" id="L277">    }</span>


    SocketPermission(String host, int mask) {
<span class="nc" id="L281">        super(getHost(host));</span>
        // name initialized to getHost(host); NPE detected in getHost()
<span class="nc" id="L283">        init(getName(), mask);</span>
<span class="nc" id="L284">    }</span>

    private void setDeny() {
<span class="nc" id="L287">        defaultDeny = true;</span>
<span class="nc" id="L288">    }</span>

    private static String getHost(String host) {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (host.equals(&quot;&quot;)) {</span>
<span class="nc" id="L292">            return &quot;localhost&quot;;</span>
        } else {
            /* IPv6 literal address used in this context should follow
             * the format specified in RFC 2732;
             * if not, we try to solve the unambiguous case
             */
            int ind;
<span class="fc bfc" id="L299" title="All 2 branches covered.">            if (host.charAt(0) != '[') {</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                if ((ind = host.indexOf(':')) != host.lastIndexOf(':')) {</span>
                    /* More than one &quot;:&quot;, meaning IPv6 address is not
                     * in RFC 2732 format;
                     * We will rectify user errors for all unambiguious cases
                     */
<span class="fc" id="L305">                    StringTokenizer st = new StringTokenizer(host, &quot;:&quot;);</span>
<span class="fc" id="L306">                    int tokens = st.countTokens();</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">                    if (tokens == 9) {</span>
                        // IPv6 address followed by port
<span class="fc" id="L309">                        ind = host.lastIndexOf(':');</span>
<span class="fc" id="L310">                        host = &quot;[&quot; + host.substring(0, ind) + &quot;]&quot; +</span>
<span class="fc" id="L311">                            host.substring(ind);</span>
<span class="nc bnc" id="L312" title="All 4 branches missed.">                    } else if (tokens == 8 &amp;&amp; host.indexOf(&quot;::&quot;) == -1) {</span>
                        // IPv6 address only, not followed by port
<span class="nc" id="L314">                        host = &quot;[&quot; + host + &quot;]&quot;;</span>
                    } else {
                        // could be ambiguous
<span class="nc" id="L317">                        throw new IllegalArgumentException(&quot;Ambiguous&quot;+</span>
                                                           &quot; hostport part&quot;);
                    }
                }
            }
<span class="fc" id="L322">            return host;</span>
        }
    }

    private int[] parsePort(String port)
        throws Exception
    {

<span class="pc bpc" id="L330" title="2 of 6 branches missed.">        if (port == null || port.equals(&quot;&quot;) || port.equals(&quot;*&quot;)) {</span>
<span class="fc" id="L331">            return new int[] {PORT_MIN, PORT_MAX};</span>
        }

<span class="fc" id="L334">        int dash = port.indexOf('-');</span>

<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (dash == -1) {</span>
<span class="fc" id="L337">            int p = Integer.parseInt(port);</span>
<span class="fc" id="L338">            return new int[] {p, p};</span>
        } else {
<span class="fc" id="L340">            String low = port.substring(0, dash);</span>
<span class="fc" id="L341">            String high = port.substring(dash+1);</span>
            int l,h;

<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            if (low.equals(&quot;&quot;)) {</span>
<span class="nc" id="L345">                l = PORT_MIN;</span>
            } else {
<span class="fc" id="L347">                l = Integer.parseInt(low);</span>
            }

<span class="fc bfc" id="L350" title="All 2 branches covered.">            if (high.equals(&quot;&quot;)) {</span>
<span class="fc" id="L351">                h = PORT_MAX;</span>
            } else {
<span class="fc" id="L353">                h = Integer.parseInt(high);</span>
            }
<span class="pc bpc" id="L355" title="3 of 6 branches missed.">            if (l &lt; 0 || h &lt; 0 || h&lt;l)</span>
<span class="nc" id="L356">                throw new IllegalArgumentException(&quot;invalid port range&quot;);</span>

<span class="fc" id="L358">            return new int[] {l, h};</span>
        }
    }

    /**
     * Initialize the SocketPermission object. We don't do any DNS lookups
     * as this point, instead we hold off until the implies method is
     * called.
     */
    private void init(String host, int mask) {
        // Set the integer mask that represents the actions

<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        if ((mask &amp; ALL) != mask)</span>
<span class="nc" id="L371">            throw new IllegalArgumentException(&quot;invalid actions mask&quot;);</span>

        // always OR in RESOLVE if we allow any of the others
<span class="fc" id="L374">        this.mask = mask | RESOLVE;</span>

        // Parse the host name.  A name has up to three components, the
        // hostname, a port number, or two numbers representing a port
        // range.   &quot;www.sun.com:8080-9090&quot; is a valid host name.

        // With IPv6 an address can be 2010:836B:4179::836B:4179
        // An IPv6 address needs to be enclose in []
        // For ex: [2010:836B:4179::836B:4179]:8080-9090
        // Refer to RFC 2732 for more information.

<span class="fc" id="L385">        int rb = 0 ;</span>
<span class="fc" id="L386">        int start = 0, end = 0;</span>
<span class="fc" id="L387">        int sep = -1;</span>
<span class="fc" id="L388">        String hostport = host;</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (host.charAt(0) == '[') {</span>
<span class="fc" id="L390">            start = 1;</span>
<span class="fc" id="L391">            rb = host.indexOf(']');</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">            if (rb != -1) {</span>
<span class="fc" id="L393">                host = host.substring(start, rb);</span>
            } else {
<span class="nc" id="L395">                throw new</span>
                    IllegalArgumentException(&quot;invalid host/port: &quot;+host);
            }
<span class="fc" id="L398">            sep = hostport.indexOf(':', rb+1);</span>
        } else {
<span class="fc" id="L400">            start = 0;</span>
<span class="fc" id="L401">            sep = host.indexOf(':', rb);</span>
<span class="fc" id="L402">            end = sep;</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            if (sep != -1) {</span>
<span class="fc" id="L404">                host = host.substring(start, end);</span>
            }
        }

<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (sep != -1) {</span>
<span class="fc" id="L409">            String port = hostport.substring(sep+1);</span>
            try {
<span class="fc" id="L411">                portrange = parsePort(port);</span>
<span class="nc" id="L412">            } catch (Exception e) {</span>
<span class="nc" id="L413">                throw new</span>
                    IllegalArgumentException(&quot;invalid port range: &quot;+port);
<span class="fc" id="L415">            }</span>
<span class="fc" id="L416">        } else {</span>
<span class="fc" id="L417">            portrange = new int[] { PORT_MIN, PORT_MAX };</span>
        }

<span class="fc" id="L420">        hostname = host;</span>

        // is this a domain wildcard specification
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        if (host.lastIndexOf('*') &gt; 0) {</span>
<span class="nc" id="L424">            throw new</span>
               IllegalArgumentException(&quot;invalid host wildcard specification&quot;);
<span class="fc bfc" id="L426" title="All 2 branches covered.">        } else if (host.startsWith(&quot;*&quot;)) {</span>
<span class="fc" id="L427">            wildcard = true;</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">            if (host.equals(&quot;*&quot;)) {</span>
<span class="fc" id="L429">                cname = &quot;&quot;;</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">            } else if (host.startsWith(&quot;*.&quot;)) {</span>
<span class="fc" id="L431">                cname = host.substring(1).toLowerCase();</span>
            } else {
<span class="nc" id="L433">              throw new</span>
               IllegalArgumentException(&quot;invalid host wildcard specification&quot;);
            }
<span class="fc" id="L436">            return;</span>
        } else {
<span class="fc bfc" id="L438" title="All 2 branches covered.">            if (host.length() &gt; 0) {</span>
                // see if we are being initialized with an IP address.
<span class="fc" id="L440">                char ch = host.charAt(0);</span>
<span class="pc bpc" id="L441" title="1 of 4 branches missed.">                if (ch == ':' || Character.digit(ch, 16) != -1) {</span>
<span class="fc" id="L442">                    byte ip[] = IPAddressUtil.textToNumericFormatV4(host);</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">                    if (ip == null) {</span>
<span class="fc" id="L444">                        ip = IPAddressUtil.textToNumericFormatV6(host);</span>
                    }
<span class="fc bfc" id="L446" title="All 2 branches covered.">                    if (ip != null) {</span>
                        try {
<span class="fc" id="L448">                            addresses =</span>
                                new InetAddress[]
<span class="fc" id="L450">                                {InetAddress.getByAddress(ip) };</span>
<span class="fc" id="L451">                            init_with_ip = true;</span>
<span class="nc" id="L452">                        } catch (UnknownHostException uhe) {</span>
                            // this shouldn't happen
<span class="nc" id="L454">                            invalid = true;</span>
<span class="fc" id="L455">                        }</span>
                    }
                }
            }
        }
<span class="fc" id="L460">    }</span>

    /**
     * Convert an action string to an integer actions mask.
     *
     * @param action the action string
     * @return the action mask
     */
    private static int getMask(String action) {

<span class="fc bfc" id="L470" title="All 2 branches covered.">        if (action == null) {</span>
<span class="fc" id="L471">            throw new NullPointerException(&quot;action can't be null&quot;);</span>
        }

<span class="fc bfc" id="L474" title="All 2 branches covered.">        if (action.equals(&quot;&quot;)) {</span>
<span class="fc" id="L475">            throw new IllegalArgumentException(&quot;action can't be empty&quot;);</span>
        }

<span class="fc" id="L478">        int mask = NONE;</span>

        // Use object identity comparison against known-interned strings for
        // performance benefit (these values are used heavily within the JDK).
<span class="fc bfc" id="L482" title="All 2 branches covered.">        if (action == SecurityConstants.SOCKET_RESOLVE_ACTION) {</span>
<span class="fc" id="L483">            return RESOLVE;</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">        } else if (action == SecurityConstants.SOCKET_CONNECT_ACTION) {</span>
<span class="fc" id="L485">            return CONNECT;</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">        } else if (action == SecurityConstants.SOCKET_LISTEN_ACTION) {</span>
<span class="fc" id="L487">            return LISTEN;</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">        } else if (action == SecurityConstants.SOCKET_ACCEPT_ACTION) {</span>
<span class="fc" id="L489">            return ACCEPT;</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">        } else if (action == SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION) {</span>
<span class="fc" id="L491">            return CONNECT|ACCEPT;</span>
        }

<span class="fc" id="L494">        char[] a = action.toCharArray();</span>

<span class="fc" id="L496">        int i = a.length - 1;</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">        if (i &lt; 0)</span>
<span class="nc" id="L498">            return mask;</span>

<span class="fc bfc" id="L500" title="All 2 branches covered.">        while (i != -1) {</span>
            char c;

            // skip whitespace
<span class="pc bpc" id="L504" title="5 of 12 branches missed.">            while ((i!=-1) &amp;&amp; ((c = a[i]) == ' ' ||</span>
                               c == '\r' ||
                               c == '\n' ||
                               c == '\f' ||
                               c == '\t'))
<span class="fc" id="L509">                i--;</span>

            // check for the known strings
            int matchlen;

<span class="pc bpc" id="L514" title="19 of 30 branches missed.">            if (i &gt;= 6 &amp;&amp; (a[i-6] == 'c' || a[i-6] == 'C') &amp;&amp;</span>
                          (a[i-5] == 'o' || a[i-5] == 'O') &amp;&amp;
                          (a[i-4] == 'n' || a[i-4] == 'N') &amp;&amp;
                          (a[i-3] == 'n' || a[i-3] == 'N') &amp;&amp;
                          (a[i-2] == 'e' || a[i-2] == 'E') &amp;&amp;
                          (a[i-1] == 'c' || a[i-1] == 'C') &amp;&amp;
                          (a[i] == 't' || a[i] == 'T'))
            {
<span class="fc" id="L522">                matchlen = 7;</span>
<span class="fc" id="L523">                mask |= CONNECT;</span>

<span class="pc bpc" id="L525" title="19 of 30 branches missed.">            } else if (i &gt;= 6 &amp;&amp; (a[i-6] == 'r' || a[i-6] == 'R') &amp;&amp;</span>
                                 (a[i-5] == 'e' || a[i-5] == 'E') &amp;&amp;
                                 (a[i-4] == 's' || a[i-4] == 'S') &amp;&amp;
                                 (a[i-3] == 'o' || a[i-3] == 'O') &amp;&amp;
                                 (a[i-2] == 'l' || a[i-2] == 'L') &amp;&amp;
                                 (a[i-1] == 'v' || a[i-1] == 'V') &amp;&amp;
                                 (a[i] == 'e' || a[i] == 'E'))
            {
<span class="fc" id="L533">                matchlen = 7;</span>
<span class="fc" id="L534">                mask |= RESOLVE;</span>

<span class="pc bpc" id="L536" title="17 of 26 branches missed.">            } else if (i &gt;= 5 &amp;&amp; (a[i-5] == 'l' || a[i-5] == 'L') &amp;&amp;</span>
                                 (a[i-4] == 'i' || a[i-4] == 'I') &amp;&amp;
                                 (a[i-3] == 's' || a[i-3] == 'S') &amp;&amp;
                                 (a[i-2] == 't' || a[i-2] == 'T') &amp;&amp;
                                 (a[i-1] == 'e' || a[i-1] == 'E') &amp;&amp;
                                 (a[i] == 'n' || a[i] == 'N'))
            {
<span class="fc" id="L543">                matchlen = 6;</span>
<span class="fc" id="L544">                mask |= LISTEN;</span>

<span class="pc bpc" id="L546" title="19 of 26 branches missed.">            } else if (i &gt;= 5 &amp;&amp; (a[i-5] == 'a' || a[i-5] == 'A') &amp;&amp;</span>
                                 (a[i-4] == 'c' || a[i-4] == 'C') &amp;&amp;
                                 (a[i-3] == 'c' || a[i-3] == 'C') &amp;&amp;
                                 (a[i-2] == 'e' || a[i-2] == 'E') &amp;&amp;
                                 (a[i-1] == 'p' || a[i-1] == 'P') &amp;&amp;
                                 (a[i] == 't' || a[i] == 'T'))
            {
<span class="fc" id="L553">                matchlen = 6;</span>
<span class="fc" id="L554">                mask |= ACCEPT;</span>

            } else {
                // parse error
<span class="nc" id="L558">                throw new IllegalArgumentException(</span>
                        &quot;invalid permission: &quot; + action);
            }

            // make sure we didn't just match the tail of a word
            // like &quot;ackbarfaccept&quot;.  Also, skip to the comma.
<span class="fc" id="L564">            boolean seencomma = false;</span>
<span class="fc bfc" id="L565" title="All 4 branches covered.">            while (i &gt;= matchlen &amp;&amp; !seencomma) {</span>
<span class="pc bpc" id="L566" title="1 of 3 branches missed.">                switch(a[i-matchlen]) {</span>
                case ',':
<span class="fc" id="L568">                    seencomma = true;</span>
<span class="fc" id="L569">                    break;</span>
                case ' ': case '\r': case '\n':
                case '\f': case '\t':
<span class="fc" id="L572">                    break;</span>
                default:
<span class="nc" id="L574">                    throw new IllegalArgumentException(</span>
                            &quot;invalid permission: &quot; + action);
                }
<span class="fc" id="L577">                i--;</span>
            }

            // point i at the location of the comma minus one (or -1).
<span class="fc" id="L581">            i -= matchlen;</span>
<span class="fc" id="L582">        }</span>

<span class="fc" id="L584">        return mask;</span>
    }

    private boolean isUntrusted()
        throws UnknownHostException
    {
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">        if (trusted) return false;</span>
<span class="pc bpc" id="L591" title="2 of 4 branches missed.">        if (invalid || untrusted) return true;</span>
        try {
<span class="pc bpc" id="L593" title="2 of 4 branches missed.">            if (!trustNameService &amp;&amp; (defaultDeny ||</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">                sun.net.www.URLConnection.isProxiedHost(hostname))) {</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                if (this.cname == null) {</span>
<span class="nc" id="L596">                    this.getCanonName();</span>
                }
<span class="nc bnc" id="L598" title="All 2 branches missed.">                if (!match(cname, hostname)) {</span>
                    // Last chance
<span class="nc bnc" id="L600" title="All 2 branches missed.">                    if (!authorized(hostname, addresses[0].getAddress())) {</span>
<span class="nc" id="L601">                        untrusted = true;</span>
<span class="nc" id="L602">                        Debug debug = getDebug();</span>
<span class="nc bnc" id="L603" title="All 4 branches missed.">                        if (debug != null &amp;&amp; Debug.isOn(&quot;failure&quot;)) {</span>
<span class="nc" id="L604">                            debug.println(&quot;socket access restriction: proxied host &quot; + &quot;(&quot; + addresses[0] + &quot;)&quot; + &quot; does not match &quot; + cname + &quot; from reverse lookup&quot;);</span>
                        }
<span class="nc" id="L606">                        return true;</span>
                    }
                }
<span class="nc" id="L609">                trusted = true;</span>
            }
<span class="nc" id="L611">        } catch (UnknownHostException uhe) {</span>
<span class="nc" id="L612">            invalid = true;</span>
<span class="nc" id="L613">            throw uhe;</span>
<span class="fc" id="L614">        }</span>
<span class="fc" id="L615">        return false;</span>
    }

    /**
     * attempt to get the fully qualified domain name
     *
     */
    void getCanonName()
        throws UnknownHostException
    {
<span class="pc bpc" id="L625" title="2 of 6 branches missed.">        if (cname != null || invalid || untrusted) return;</span>

        // attempt to get the canonical name

        try {
            // first get the IP addresses if we don't have them yet
            // this is because we need the IP address to then get
            // FQDN.
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">            if (addresses == null) {</span>
<span class="nc" id="L634">                getIP();</span>
            }

            // we have to do this check, otherwise we might not
            // get the fully qualified domain name
<span class="fc bfc" id="L639" title="All 2 branches covered.">            if (init_with_ip) {</span>
<span class="fc" id="L640">                cname = addresses[0].getHostName(false).toLowerCase();</span>
            } else {
<span class="fc" id="L642">             cname = InetAddress.getByName(addresses[0].getHostAddress()).</span>
<span class="fc" id="L643">                                              getHostName(false).toLowerCase();</span>
            }
<span class="fc" id="L645">        } catch (UnknownHostException uhe) {</span>
<span class="fc" id="L646">            invalid = true;</span>
<span class="fc" id="L647">            throw uhe;</span>
<span class="fc" id="L648">        }</span>
<span class="fc" id="L649">    }</span>

    private transient String cdomain, hdomain;

    private boolean match(String cname, String hname) {
<span class="nc" id="L654">        String a = cname.toLowerCase();</span>
<span class="nc" id="L655">        String b = hname.toLowerCase();</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">        if (a.startsWith(b)  &amp;&amp;</span>
<span class="nc bnc" id="L657" title="All 4 branches missed.">            ((a.length() == b.length()) || (a.charAt(b.length()) == '.')))</span>
<span class="nc" id="L658">            return true;</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">        if (cdomain == null) {</span>
<span class="nc" id="L660">            cdomain = RegisteredDomain.getRegisteredDomain(a);</span>
        }
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (hdomain == null) {</span>
<span class="nc" id="L663">            hdomain = RegisteredDomain.getRegisteredDomain(b);</span>
        }

<span class="nc bnc" id="L666" title="All 4 branches missed.">        return cdomain.length() != 0 &amp;&amp; hdomain.length() != 0</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                        &amp;&amp; cdomain.equals(hdomain);</span>
    }

    private boolean authorized(String cname, byte[] addr) {
<span class="nc bnc" id="L671" title="All 2 branches missed.">        if (addr.length == 4)</span>
<span class="nc" id="L672">            return authorizedIPv4(cname, addr);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">        else if (addr.length == 16)</span>
<span class="nc" id="L674">            return authorizedIPv6(cname, addr);</span>
        else
<span class="nc" id="L676">            return false;</span>
    }

    private boolean authorizedIPv4(String cname, byte[] addr) {
<span class="nc" id="L680">        String authHost = &quot;&quot;;</span>
        InetAddress auth;

        try {
<span class="nc" id="L684">            authHost = &quot;auth.&quot; +</span>
                        (addr[3] &amp; 0xff) + &quot;.&quot; + (addr[2] &amp; 0xff) + &quot;.&quot; +
                        (addr[1] &amp; 0xff) + &quot;.&quot; + (addr[0] &amp; 0xff) +
                        &quot;.in-addr.arpa&quot;;
            // Following check seems unnecessary
            // auth = InetAddress.getAllByName0(authHost, false)[0];
<span class="nc" id="L690">            authHost = hostname + '.' + authHost;</span>
<span class="nc" id="L691">            auth = InetAddress.getAllByName0(authHost, false)[0];</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">            if (auth.equals(InetAddress.getByAddress(addr))) {</span>
<span class="nc" id="L693">                return true;</span>
            }
<span class="nc" id="L695">            Debug debug = getDebug();</span>
<span class="nc bnc" id="L696" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;failure&quot;)) {</span>
<span class="nc" id="L697">                debug.println(&quot;socket access restriction: IP address of &quot; + auth + &quot; != &quot; + InetAddress.getByAddress(addr));</span>
            }
<span class="nc" id="L699">        } catch (UnknownHostException uhe) {</span>
<span class="nc" id="L700">            Debug debug = getDebug();</span>
<span class="nc bnc" id="L701" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;failure&quot;)) {</span>
<span class="nc" id="L702">                debug.println(&quot;socket access restriction: forward lookup failed for &quot; + authHost);</span>
            }
<span class="nc" id="L704">        }</span>
<span class="nc" id="L705">        return false;</span>
    }

    private boolean authorizedIPv6(String cname, byte[] addr) {
<span class="nc" id="L709">        String authHost = &quot;&quot;;</span>
        InetAddress auth;

        try {
<span class="nc" id="L713">            StringBuffer sb = new StringBuffer(39);</span>

<span class="nc bnc" id="L715" title="All 2 branches missed.">            for (int i = 15; i &gt;= 0; i--) {</span>
<span class="nc" id="L716">                sb.append(Integer.toHexString(((addr[i]) &amp; 0x0f)));</span>
<span class="nc" id="L717">                sb.append('.');</span>
<span class="nc" id="L718">                sb.append(Integer.toHexString(((addr[i] &gt;&gt; 4) &amp; 0x0f)));</span>
<span class="nc" id="L719">                sb.append('.');</span>
            }
<span class="nc" id="L721">            authHost = &quot;auth.&quot; + sb.toString() + &quot;IP6.ARPA&quot;;</span>
            //auth = InetAddress.getAllByName0(authHost, false)[0];
<span class="nc" id="L723">            authHost = hostname + '.' + authHost;</span>
<span class="nc" id="L724">            auth = InetAddress.getAllByName0(authHost, false)[0];</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">            if (auth.equals(InetAddress.getByAddress(addr)))</span>
<span class="nc" id="L726">                return true;</span>
<span class="nc" id="L727">            Debug debug = getDebug();</span>
<span class="nc bnc" id="L728" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;failure&quot;)) {</span>
<span class="nc" id="L729">                debug.println(&quot;socket access restriction: IP address of &quot; + auth + &quot; != &quot; + InetAddress.getByAddress(addr));</span>
            }
<span class="nc" id="L731">        } catch (UnknownHostException uhe) {</span>
<span class="nc" id="L732">            Debug debug = getDebug();</span>
<span class="nc bnc" id="L733" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;failure&quot;)) {</span>
<span class="nc" id="L734">                debug.println(&quot;socket access restriction: forward lookup failed for &quot; + authHost);</span>
            }
<span class="nc" id="L736">        }</span>
<span class="nc" id="L737">        return false;</span>
    }


    /**
     * get IP addresses. Sets invalid to true if we can't get them.
     *
     */
    void getIP()
        throws UnknownHostException
    {
<span class="pc bpc" id="L748" title="3 of 6 branches missed.">        if (addresses != null || wildcard || invalid) return;</span>

        try {
            // now get all the IP addresses
            String host;
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">            if (getName().charAt(0) == '[') {</span>
                // Literal IPv6 address
<span class="nc" id="L755">                host = getName().substring(1, getName().indexOf(']'));</span>
            } else {
<span class="fc" id="L757">                int i = getName().indexOf(&quot;:&quot;);</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">                if (i == -1)</span>
<span class="fc" id="L759">                    host = getName();</span>
                else {
<span class="fc" id="L761">                    host = getName().substring(0,i);</span>
                }
            }

<span class="fc" id="L765">            addresses =</span>
<span class="fc" id="L766">                new InetAddress[] {InetAddress.getAllByName0(host, false)[0]};</span>

<span class="fc" id="L768">        } catch (UnknownHostException uhe) {</span>
<span class="fc" id="L769">            invalid = true;</span>
<span class="fc" id="L770">            throw uhe;</span>
<span class="nc" id="L771">        }  catch (IndexOutOfBoundsException iobe) {</span>
<span class="nc" id="L772">            invalid = true;</span>
<span class="nc" id="L773">            throw new UnknownHostException(getName());</span>
<span class="fc" id="L774">        }</span>
<span class="fc" id="L775">    }</span>

    /**
     * Checks if this socket permission object &quot;implies&quot; the
     * specified permission.
     * &lt;P&gt;
     * More specifically, this method first ensures that all of the following
     * are true (and returns false if any of them are not):
     * &lt;ul&gt;
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; is an instanceof SocketPermission,
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;'s actions are a proper subset of this
     * object's actions, and
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;'s port range is included in this port range. Note:
     * port range is ignored when p only contains the action, 'resolve'.
     * &lt;/ul&gt;
     *
     * Then {@code implies} checks each of the following, in order,
     * and for each returns true if the stated condition is true:
     * &lt;ul&gt;
     * &lt;li&gt; If this object was initialized with a single IP address and one of &lt;i&gt;p&lt;/i&gt;'s
     * IP addresses is equal to this object's IP address.
     * &lt;li&gt;If this object is a wildcard domain (such as *.sun.com), and
     * &lt;i&gt;p&lt;/i&gt;'s canonical name (the name without any preceding *)
     * ends with this object's canonical host name. For example, *.sun.com
     * implies *.eng.sun.com.
     * &lt;li&gt;If this object was not initialized with a single IP address, and one of this
     * object's IP addresses equals one of &lt;i&gt;p&lt;/i&gt;'s IP addresses.
     * &lt;li&gt;If this canonical name equals &lt;i&gt;p&lt;/i&gt;'s canonical name.
     * &lt;/ul&gt;
     *
     * If none of the above are true, {@code implies} returns false.
     * @param p the permission to check against.
     *
     * @return true if the specified permission is implied by this object,
     * false if not.
     */
    public boolean implies(Permission p) {
        int i,j;

<span class="pc bpc" id="L814" title="1 of 2 branches missed.">        if (!(p instanceof SocketPermission))</span>
<span class="nc" id="L815">            return false;</span>

<span class="fc bfc" id="L817" title="All 2 branches covered.">        if (p == this)</span>
<span class="fc" id="L818">            return true;</span>

<span class="fc" id="L820">        SocketPermission that = (SocketPermission) p;</span>

<span class="pc bpc" id="L822" title="1 of 2 branches missed.">        return ((this.mask &amp; that.mask) == that.mask) &amp;&amp;</span>
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">                                        impliesIgnoreMask(that);</span>
    }

    /**
     * Checks if the incoming Permission's action are a proper subset of
     * the this object's actions.
     * &lt;P&gt;
     * Check, in the following order:
     * &lt;ul&gt;
     * &lt;li&gt; Checks that &quot;p&quot; is an instanceof a SocketPermission
     * &lt;li&gt; Checks that &quot;p&quot;'s actions are a proper subset of the
     * current object's actions.
     * &lt;li&gt; Checks that &quot;p&quot;'s port range is included in this port range
     * &lt;li&gt; If this object was initialized with an IP address, checks that
     *      one of &quot;p&quot;'s IP addresses is equal to this object's IP address.
     * &lt;li&gt; If either object is a wildcard domain (i.e., &quot;*.sun.com&quot;),
     *      attempt to match based on the wildcard.
     * &lt;li&gt; If this object was not initialized with an IP address, attempt
     *      to find a match based on the IP addresses in both objects.
     * &lt;li&gt; Attempt to match on the canonical hostnames of both objects.
     * &lt;/ul&gt;
     * @param that the incoming permission request
     *
     * @return true if &quot;permission&quot; is a proper subset of the current object,
     * false if not.
     */
    boolean impliesIgnoreMask(SocketPermission that) {
        int i,j;

<span class="fc bfc" id="L852" title="All 2 branches covered.">        if ((that.mask &amp; RESOLVE) != that.mask) {</span>
            // check port range
<span class="pc bpc" id="L854" title="1 of 4 branches missed.">            if ((that.portrange[0] &lt; this.portrange[0]) ||</span>
                    (that.portrange[1] &gt; this.portrange[1])) {
<span class="fc" id="L856">                    return false;</span>
            }
        }

        // allow a &quot;*&quot; wildcard to always match anything
<span class="fc bfc" id="L861" title="All 4 branches covered.">        if (this.wildcard &amp;&amp; &quot;&quot;.equals(this.cname))</span>
<span class="fc" id="L862">            return true;</span>

        // return if either one of these NetPerm objects are invalid...
<span class="pc bpc" id="L865" title="1 of 4 branches missed.">        if (this.invalid || that.invalid) {</span>
<span class="fc" id="L866">            return compareHostnames(that);</span>
        }

        try {
<span class="fc bfc" id="L870" title="All 2 branches covered.">            if (this.init_with_ip) { // we only check IP addresses</span>
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">                if (that.wildcard)</span>
<span class="nc" id="L872">                    return false;</span>

<span class="pc bpc" id="L874" title="1 of 2 branches missed.">                if (that.init_with_ip) {</span>
<span class="fc" id="L875">                    return (this.addresses[0].equals(that.addresses[0]));</span>
                } else {
<span class="nc bnc" id="L877" title="All 2 branches missed.">                    if (that.addresses == null) {</span>
<span class="nc" id="L878">                        that.getIP();</span>
                    }
<span class="nc bnc" id="L880" title="All 2 branches missed.">                    for (i=0; i &lt; that.addresses.length; i++) {</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">                        if (this.addresses[0].equals(that.addresses[i]))</span>
<span class="nc" id="L882">                            return true;</span>
                    }
                }
                // since &quot;this&quot; was initialized with an IP address, we
                // don't check any other cases
<span class="nc" id="L887">                return false;</span>
            }

            // check and see if we have any wildcards...
<span class="pc bpc" id="L891" title="1 of 4 branches missed.">            if (this.wildcard || that.wildcard) {</span>
                // if they are both wildcards, return true iff
                // that's cname ends with this cname (i.e., *.sun.com
                // implies *.eng.sun.com)
<span class="pc bpc" id="L895" title="2 of 4 branches missed.">                if (this.wildcard &amp;&amp; that.wildcard)</span>
<span class="nc" id="L896">                    return (that.cname.endsWith(this.cname));</span>

                // a non-wildcard can't imply a wildcard
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">                if (that.wildcard)</span>
<span class="nc" id="L900">                    return false;</span>

                // this is a wildcard, lets see if that's cname ends with
                // it...
<span class="nc bnc" id="L904" title="All 2 branches missed.">                if (that.cname == null) {</span>
<span class="nc" id="L905">                    that.getCanonName();</span>
                }
<span class="nc" id="L907">                return (that.cname.endsWith(this.cname));</span>
            }

            // comapare IP addresses
<span class="fc bfc" id="L911" title="All 2 branches covered.">            if (this.addresses == null) {</span>
<span class="fc" id="L912">                this.getIP();</span>
            }

<span class="fc bfc" id="L915" title="All 2 branches covered.">            if (that.addresses == null) {</span>
<span class="fc" id="L916">                that.getIP();</span>
            }

<span class="pc bpc" id="L919" title="1 of 4 branches missed.">            if (!(that.init_with_ip &amp;&amp; this.isUntrusted())) {</span>
<span class="fc bfc" id="L920" title="All 2 branches covered.">                for (j = 0; j &lt; this.addresses.length; j++) {</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">                    for (i=0; i &lt; that.addresses.length; i++) {</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">                        if (this.addresses[j].equals(that.addresses[i]))</span>
<span class="fc" id="L923">                            return true;</span>
                    }
                }

                // XXX: if all else fails, compare hostnames?
                // Do we really want this?
<span class="fc bfc" id="L929" title="All 2 branches covered.">                if (this.cname == null) {</span>
<span class="fc" id="L930">                    this.getCanonName();</span>
                }

<span class="fc bfc" id="L933" title="All 2 branches covered.">                if (that.cname == null) {</span>
<span class="fc" id="L934">                    that.getCanonName();</span>
                }

<span class="fc" id="L937">                return (this.cname.equalsIgnoreCase(that.cname));</span>
            }

<span class="fc" id="L940">        } catch (UnknownHostException uhe) {</span>
<span class="fc" id="L941">            return compareHostnames(that);</span>
<span class="nc" id="L942">        }</span>

        // make sure the first thing that is done here is to return
        // false. If not, uncomment the return false in the above catch.

<span class="nc" id="L947">        return false;</span>
    }

    private boolean compareHostnames(SocketPermission that) {
        // we see if the original names/IPs passed in were equal.

<span class="fc" id="L953">        String thisHost = hostname;</span>
<span class="fc" id="L954">        String thatHost = that.hostname;</span>

<span class="pc bpc" id="L956" title="1 of 2 branches missed.">        if (thisHost == null) {</span>
<span class="nc" id="L957">            return false;</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">        } else if (this.wildcard) {</span>
<span class="fc" id="L959">            final int cnameLength = this.cname.length();</span>
<span class="fc" id="L960">            return thatHost.regionMatches(true,</span>
<span class="fc" id="L961">                                          (thatHost.length() - cnameLength),</span>
                                          this.cname, 0, cnameLength);
        } else {
<span class="fc" id="L964">            return thisHost.equalsIgnoreCase(thatHost);</span>
        }
    }

    /**
     * Checks two SocketPermission objects for equality.
     * &lt;P&gt;
     * @param obj the object to test for equality with this object.
     *
     * @return true if &lt;i&gt;obj&lt;/i&gt; is a SocketPermission, and has the
     *  same hostname, port range, and actions as this
     *  SocketPermission object. However, port range will be ignored
     *  in the comparison if &lt;i&gt;obj&lt;/i&gt; only contains the action, 'resolve'.
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L980">            return true;</span>

<span class="pc bpc" id="L982" title="1 of 2 branches missed.">        if (! (obj instanceof SocketPermission))</span>
<span class="nc" id="L983">            return false;</span>

<span class="fc" id="L985">        SocketPermission that = (SocketPermission) obj;</span>

        //this is (overly?) complex!!!

        // check the mask first
<span class="pc bpc" id="L990" title="1 of 2 branches missed.">        if (this.mask != that.mask) return false;</span>

<span class="pc bpc" id="L992" title="1 of 2 branches missed.">        if ((that.mask &amp; RESOLVE) != that.mask) {</span>
            // now check the port range...
<span class="nc bnc" id="L994" title="All 4 branches missed.">            if ((this.portrange[0] != that.portrange[0]) ||</span>
                (this.portrange[1] != that.portrange[1])) {
<span class="nc" id="L996">                return false;</span>
            }
        }

        // short cut. This catches:
        //  &quot;crypto&quot; equal to &quot;crypto&quot;, or
        // &quot;1.2.3.4&quot; equal to &quot;1.2.3.4.&quot;, or
        //  &quot;*.edu&quot; equal to &quot;*.edu&quot;, but it
        //  does not catch &quot;crypto&quot; equal to
        // &quot;crypto.eng.sun.com&quot;.

<span class="pc bpc" id="L1007" title="1 of 2 branches missed.">        if (this.getName().equalsIgnoreCase(that.getName())) {</span>
<span class="nc" id="L1008">            return true;</span>
        }

        // we now attempt to get the Canonical (FQDN) name and
        // compare that. If this fails, about all we can do is return
        // false.

        try {
<span class="fc" id="L1016">            this.getCanonName();</span>
<span class="fc" id="L1017">            that.getCanonName();</span>
<span class="nc" id="L1018">        } catch (UnknownHostException uhe) {</span>
<span class="nc" id="L1019">            return false;</span>
<span class="fc" id="L1020">        }</span>

<span class="pc bpc" id="L1022" title="2 of 4 branches missed.">        if (this.invalid || that.invalid)</span>
<span class="nc" id="L1023">            return false;</span>

<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">        if (this.cname != null) {</span>
<span class="fc" id="L1026">            return this.cname.equalsIgnoreCase(that.cname);</span>
        }

<span class="nc" id="L1029">        return false;</span>
    }

    /**
     * Returns the hash code value for this object.
     *
     * @return a hash code value for this object.
     */

    public int hashCode() {
        /*
         * If this SocketPermission was initialized with an IP address
         * or a wildcard, use getName().hashCode(), otherwise use
         * the hashCode() of the host name returned from
         * java.net.InetAddress.getHostName method.
         */

<span class="nc bnc" id="L1046" title="All 4 branches missed.">        if (init_with_ip || wildcard) {</span>
<span class="nc" id="L1047">            return this.getName().hashCode();</span>
        }

        try {
<span class="nc" id="L1051">            getCanonName();</span>
<span class="nc" id="L1052">        } catch (UnknownHostException uhe) {</span>

<span class="nc" id="L1054">        }</span>

<span class="nc bnc" id="L1056" title="All 4 branches missed.">        if (invalid || cname == null)</span>
<span class="nc" id="L1057">            return this.getName().hashCode();</span>
        else
<span class="nc" id="L1059">            return this.cname.hashCode();</span>
    }

    /**
     * Return the current action mask.
     *
     * @return the actions mask.
     */

    int getMask() {
<span class="fc" id="L1069">        return mask;</span>
    }

    /**
     * Returns the &quot;canonical string representation&quot; of the actions in the
     * specified mask.
     * Always returns present actions in the following order:
     * connect, listen, accept, resolve.
     *
     * @param mask a specific integer action mask to translate into a string
     * @return the canonical string representation of the actions
     */
    private static String getActions(int mask)
    {
<span class="fc" id="L1083">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L1084">        boolean comma = false;</span>

<span class="fc bfc" id="L1086" title="All 2 branches covered.">        if ((mask &amp; CONNECT) == CONNECT) {</span>
<span class="fc" id="L1087">            comma = true;</span>
<span class="fc" id="L1088">            sb.append(&quot;connect&quot;);</span>
        }

<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">        if ((mask &amp; LISTEN) == LISTEN) {</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">            if (comma) sb.append(',');</span>
<span class="nc" id="L1093">            else comma = true;</span>
<span class="nc" id="L1094">            sb.append(&quot;listen&quot;);</span>
        }

<span class="fc bfc" id="L1097" title="All 2 branches covered.">        if ((mask &amp; ACCEPT) == ACCEPT) {</span>
<span class="pc bpc" id="L1098" title="1 of 2 branches missed.">            if (comma) sb.append(',');</span>
<span class="fc" id="L1099">            else comma = true;</span>
<span class="fc" id="L1100">            sb.append(&quot;accept&quot;);</span>
        }


<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">        if ((mask &amp; RESOLVE) == RESOLVE) {</span>
<span class="fc bfc" id="L1105" title="All 2 branches covered.">            if (comma) sb.append(',');</span>
<span class="fc" id="L1106">            else comma = true;</span>
<span class="fc" id="L1107">            sb.append(&quot;resolve&quot;);</span>
        }

<span class="fc" id="L1110">        return sb.toString();</span>
    }

    /**
     * Returns the canonical string representation of the actions.
     * Always returns present actions in the following order:
     * connect, listen, accept, resolve.
     *
     * @return the canonical string representation of the actions.
     */
    public String getActions()
    {
<span class="pc bpc" id="L1122" title="1 of 2 branches missed.">        if (actions == null)</span>
<span class="fc" id="L1123">            actions = getActions(this.mask);</span>

<span class="fc" id="L1125">        return actions;</span>
    }

    /**
     * Returns a new PermissionCollection object for storing SocketPermission
     * objects.
     * &lt;p&gt;
     * SocketPermission objects must be stored in a manner that allows them
     * to be inserted into the collection in any order, but that also enables the
     * PermissionCollection {@code implies}
     * method to be implemented in an efficient (and consistent) manner.
     *
     * @return a new PermissionCollection object suitable for storing SocketPermissions.
     */

    public PermissionCollection newPermissionCollection() {
<span class="fc" id="L1141">        return new SocketPermissionCollection();</span>
    }

    /**
     * WriteObject is called to save the state of the SocketPermission
     * to a stream. The actions are serialized, and the superclass
     * takes care of the name.
     */
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException
    {
        // Write out the actions. The superclass takes care of the name
        // call getActions to make sure actions field is initialized
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if (actions == null)</span>
<span class="nc" id="L1155">            getActions();</span>
<span class="nc" id="L1156">        s.defaultWriteObject();</span>
<span class="nc" id="L1157">    }</span>

    /**
     * readObject is called to restore the state of the SocketPermission from
     * a stream.
     */
    private synchronized void readObject(java.io.ObjectInputStream s)
         throws IOException, ClassNotFoundException
    {
        // Read in the action, then initialize the rest
<span class="nc" id="L1167">        s.defaultReadObject();</span>
<span class="nc" id="L1168">        init(getName(),getMask(actions));</span>
<span class="nc" id="L1169">    }</span>

    /*
    public String toString()
    {
        StringBuffer s = new StringBuffer(super.toString() + &quot;\n&quot; +
            &quot;cname = &quot; + cname + &quot;\n&quot; +
            &quot;wildcard = &quot; + wildcard + &quot;\n&quot; +
            &quot;invalid = &quot; + invalid + &quot;\n&quot; +
            &quot;portrange = &quot; + portrange[0] + &quot;,&quot; + portrange[1] + &quot;\n&quot;);
        if (addresses != null) for (int i=0; i&lt;addresses.length; i++) {
            s.append( addresses[i].getHostAddress());
            s.append(&quot;\n&quot;);
        } else {
            s.append(&quot;(no addresses)\n&quot;);
        }

        return s.toString();
    }

    public static void main(String args[]) throws Exception {
        SocketPermission this_ = new SocketPermission(args[0], &quot;connect&quot;);
        SocketPermission that_ = new SocketPermission(args[1], &quot;connect&quot;);
        System.out.println(&quot;-----\n&quot;);
        System.out.println(&quot;this.implies(that) = &quot; + this_.implies(that_));
        System.out.println(&quot;-----\n&quot;);
        System.out.println(&quot;this = &quot;+this_);
        System.out.println(&quot;-----\n&quot;);
        System.out.println(&quot;that = &quot;+that_);
        System.out.println(&quot;-----\n&quot;);

        SocketPermissionCollection nps = new SocketPermissionCollection();
        nps.add(this_);
        nps.add(new SocketPermission(&quot;www-leland.stanford.edu&quot;,&quot;connect&quot;));
        nps.add(new SocketPermission(&quot;www-sun.com&quot;,&quot;connect&quot;));
        System.out.println(&quot;nps.implies(that) = &quot; + nps.implies(that_));
        System.out.println(&quot;-----\n&quot;);
    }
    */
}

/**

if (init'd with IP, key is IP as string)
if wildcard, its the wild card
else its the cname?

 *
 * @see java.security.Permission
 * @see java.security.Permissions
 * @see java.security.PermissionCollection
 *
 *
 * @author Roland Schemers
 *
 * @serial include
 */

final class SocketPermissionCollection extends PermissionCollection
    implements Serializable
{
    // Not serialized; see serialization section at end of class
    private transient List&lt;SocketPermission&gt; perms;

    /**
     * Create an empty SocketPermissions object.
     *
     */

<span class="fc" id="L1238">    public SocketPermissionCollection() {</span>
<span class="fc" id="L1239">        perms = new ArrayList&lt;SocketPermission&gt;();</span>
<span class="fc" id="L1240">    }</span>

    /**
     * Adds a permission to the SocketPermissions. The key for the hash is
     * the name in the case of wildcards, or all the IP addresses.
     *
     * @param permission the Permission object to add.
     *
     * @exception IllegalArgumentException - if the permission is not a
     *                                       SocketPermission
     *
     * @exception SecurityException - if this SocketPermissionCollection object
     *                                has been marked readonly
     */
    public void add(Permission permission) {
<span class="pc bpc" id="L1255" title="1 of 2 branches missed.">        if (! (permission instanceof SocketPermission))</span>
<span class="nc" id="L1256">            throw new IllegalArgumentException(&quot;invalid permission: &quot;+</span>
                                               permission);
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">        if (isReadOnly())</span>
<span class="nc" id="L1259">            throw new SecurityException(</span>
                &quot;attempt to add a Permission to a readonly PermissionCollection&quot;);

        // optimization to ensure perms most likely to be tested
        // show up early (4301064)
<span class="fc" id="L1264">        synchronized (this) {</span>
<span class="fc" id="L1265">            perms.add(0, (SocketPermission)permission);</span>
<span class="pc" id="L1266">        }</span>
<span class="fc" id="L1267">    }</span>

    /**
     * Check and see if this collection of permissions implies the permissions
     * expressed in &quot;permission&quot;.
     *
     * @param permission the Permission object to compare
     *
     * @return true if &quot;permission&quot; is a proper subset of a permission in
     * the collection, false if not.
     */

    public boolean implies(Permission permission)
    {
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">        if (! (permission instanceof SocketPermission))</span>
<span class="nc" id="L1282">                return false;</span>

<span class="fc" id="L1284">        SocketPermission np = (SocketPermission) permission;</span>

<span class="fc" id="L1286">        int desired = np.getMask();</span>
<span class="fc" id="L1287">        int effective = 0;</span>
<span class="fc" id="L1288">        int needed = desired;</span>

<span class="fc" id="L1290">        synchronized (this) {</span>
<span class="fc" id="L1291">            int len = perms.size();</span>
            //System.out.println(&quot;implies &quot;+np);
<span class="fc bfc" id="L1293" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1294">                SocketPermission x = perms.get(i);</span>
                //System.out.println(&quot;  trying &quot;+x);
<span class="fc bfc" id="L1296" title="All 4 branches covered.">                if (((needed &amp; x.getMask()) != 0) &amp;&amp; x.impliesIgnoreMask(np)) {</span>
<span class="fc" id="L1297">                    effective |=  x.getMask();</span>
<span class="fc bfc" id="L1298" title="All 2 branches covered.">                    if ((effective &amp; desired) == desired)</span>
<span class="fc" id="L1299">                        return true;</span>
<span class="fc" id="L1300">                    needed = (desired ^ effective);</span>
                }
            }
<span class="pc" id="L1303">        }</span>
<span class="fc" id="L1304">        return false;</span>
    }

    /**
     * Returns an enumeration of all the SocketPermission objects in the
     * container.
     *
     * @return an enumeration of all the SocketPermission objects.
     */

    @SuppressWarnings(&quot;unchecked&quot;)
    public Enumeration&lt;Permission&gt; elements() {
        // Convert Iterator into Enumeration
<span class="fc" id="L1317">        synchronized (this) {</span>
<span class="fc" id="L1318">            return Collections.enumeration((List&lt;Permission&gt;)(List)perms);</span>
<span class="nc" id="L1319">        }</span>
    }

    private static final long serialVersionUID = 2787186408602843674L;

    // Need to maintain serialization interoperability with earlier releases,
    // which had the serializable field:

    //
    // The SocketPermissions for this set.
    // @serial
    //
    // private Vector permissions;

    /**
     * @serialField permissions java.util.Vector
     *     A list of the SocketPermissions for this set.
     */
<span class="fc" id="L1337">    private static final ObjectStreamField[] serialPersistentFields = {</span>
        new ObjectStreamField(&quot;permissions&quot;, Vector.class),
    };

    /**
     * @serialData &quot;permissions&quot; field (a Vector containing the SocketPermissions).
     */
    /*
     * Writes the contents of the perms field out as a Vector for
     * serialization compatibility with earlier releases.
     */
    private void writeObject(ObjectOutputStream out) throws IOException {
        // Don't call out.defaultWriteObject()

        // Write out Vector
<span class="nc" id="L1352">        Vector&lt;SocketPermission&gt; permissions = new Vector&lt;&gt;(perms.size());</span>

<span class="nc" id="L1354">        synchronized (this) {</span>
<span class="nc" id="L1355">            permissions.addAll(perms);</span>
<span class="nc" id="L1356">        }</span>

<span class="nc" id="L1358">        ObjectOutputStream.PutField pfields = out.putFields();</span>
<span class="nc" id="L1359">        pfields.put(&quot;permissions&quot;, permissions);</span>
<span class="nc" id="L1360">        out.writeFields();</span>
<span class="nc" id="L1361">    }</span>

    /*
     * Reads in a Vector of SocketPermissions and saves them in the perms field.
     */
    private void readObject(ObjectInputStream in)
        throws IOException, ClassNotFoundException
    {
        // Don't call in.defaultReadObject()

        // Read in serialized fields
<span class="nc" id="L1372">        ObjectInputStream.GetField gfields = in.readFields();</span>

        // Get the one we want
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1376">        Vector&lt;SocketPermission&gt; permissions = (Vector&lt;SocketPermission&gt;)gfields.get(&quot;permissions&quot;, null);</span>
<span class="nc" id="L1377">        perms = new ArrayList&lt;SocketPermission&gt;(permissions.size());</span>
<span class="nc" id="L1378">        perms.addAll(permissions);</span>
<span class="nc" id="L1379">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>