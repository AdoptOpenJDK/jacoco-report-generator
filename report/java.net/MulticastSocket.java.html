<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MulticastSocket.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">MulticastSocket.java</span></div><h1>MulticastSocket.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.io.IOException;
import java.util.Enumeration;

/**
 * The multicast datagram socket class is useful for sending
 * and receiving IP multicast packets.  A MulticastSocket is
 * a (UDP) DatagramSocket, with additional capabilities for
 * joining &quot;groups&quot; of other multicast hosts on the internet.
 * &lt;P&gt;
 * A multicast group is specified by a class D IP address
 * and by a standard UDP port number. Class D IP addresses
 * are in the range &lt;CODE&gt;224.0.0.0&lt;/CODE&gt; to &lt;CODE&gt;239.255.255.255&lt;/CODE&gt;,
 * inclusive. The address 224.0.0.0 is reserved and should not be used.
 * &lt;P&gt;
 * One would join a multicast group by first creating a MulticastSocket
 * with the desired port, then invoking the
 * &lt;CODE&gt;joinGroup(InetAddress groupAddr)&lt;/CODE&gt;
 * method:
 * &lt;PRE&gt;
 * // join a Multicast group and send the group salutations
 * ...
 * String msg = &quot;Hello&quot;;
 * InetAddress group = InetAddress.getByName(&quot;228.5.6.7&quot;);
 * MulticastSocket s = new MulticastSocket(6789);
 * s.joinGroup(group);
 * DatagramPacket hi = new DatagramPacket(msg.getBytes(), msg.length(),
 *                             group, 6789);
 * s.send(hi);
 * // get their responses!
 * byte[] buf = new byte[1000];
 * DatagramPacket recv = new DatagramPacket(buf, buf.length);
 * s.receive(recv);
 * ...
 * // OK, I'm done talking - leave the group...
 * s.leaveGroup(group);
 * &lt;/PRE&gt;
 *
 * When one sends a message to a multicast group, &lt;B&gt;all&lt;/B&gt; subscribing
 * recipients to that host and port receive the message (within the
 * time-to-live range of the packet, see below).  The socket needn't
 * be a member of the multicast group to send messages to it.
 * &lt;P&gt;
 * When a socket subscribes to a multicast group/port, it receives
 * datagrams sent by other hosts to the group/port, as do all other
 * members of the group and port.  A socket relinquishes membership
 * in a group by the leaveGroup(InetAddress addr) method.  &lt;B&gt;
 * Multiple MulticastSocket's&lt;/B&gt; may subscribe to a multicast group
 * and port concurrently, and they will all receive group datagrams.
 * &lt;P&gt;
 * Currently applets are not allowed to use multicast sockets.
 *
 * @author Pavani Diwanji
 * @since  JDK1.1
 */
public
class MulticastSocket extends DatagramSocket {

    /**
     * Used on some platforms to record if an outgoing interface
     * has been set for this socket.
     */
    private boolean interfaceSet;

    /**
     * Create a multicast socket.
     *
     * &lt;p&gt;If there is a security manager,
     * its {@code checkListen} method is first called
     * with 0 as its argument to ensure the operation is allowed.
     * This could result in a SecurityException.
     * &lt;p&gt;
     * When the socket is created the
     * {@link DatagramSocket#setReuseAddress(boolean)} method is
     * called to enable the SO_REUSEADDR socket option.
     *
     * @exception IOException if an I/O exception occurs
     * while creating the MulticastSocket
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkListen} method doesn't allow the operation.
     * @see SecurityManager#checkListen
     * @see java.net.DatagramSocket#setReuseAddress(boolean)
     */
    public MulticastSocket() throws IOException {
<span class="fc" id="L111">        this(new InetSocketAddress(0));</span>
<span class="fc" id="L112">    }</span>

    /**
     * Create a multicast socket and bind it to a specific port.
     *
     * &lt;p&gt;If there is a security manager,
     * its {@code checkListen} method is first called
     * with the {@code port} argument
     * as its argument to ensure the operation is allowed.
     * This could result in a SecurityException.
     * &lt;p&gt;
     * When the socket is created the
     * {@link DatagramSocket#setReuseAddress(boolean)} method is
     * called to enable the SO_REUSEADDR socket option.
     *
     * @param port port to use
     * @exception IOException if an I/O exception occurs
     * while creating the MulticastSocket
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkListen} method doesn't allow the operation.
     * @see SecurityManager#checkListen
     * @see java.net.DatagramSocket#setReuseAddress(boolean)
     */
    public MulticastSocket(int port) throws IOException {
<span class="fc" id="L136">        this(new InetSocketAddress(port));</span>
<span class="fc" id="L137">    }</span>

    /**
     * Create a MulticastSocket bound to the specified socket address.
     * &lt;p&gt;
     * Or, if the address is {@code null}, create an unbound socket.
     *
     * &lt;p&gt;If there is a security manager,
     * its {@code checkListen} method is first called
     * with the SocketAddress port as its argument to ensure the operation is allowed.
     * This could result in a SecurityException.
     * &lt;p&gt;
     * When the socket is created the
     * {@link DatagramSocket#setReuseAddress(boolean)} method is
     * called to enable the SO_REUSEADDR socket option.
     *
     * @param bindaddr Socket address to bind to, or {@code null} for
     *                 an unbound socket.
     * @exception IOException if an I/O exception occurs
     * while creating the MulticastSocket
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkListen} method doesn't allow the operation.
     * @see SecurityManager#checkListen
     * @see java.net.DatagramSocket#setReuseAddress(boolean)
     *
     * @since 1.4
     */
    public MulticastSocket(SocketAddress bindaddr) throws IOException {
<span class="fc" id="L165">        super((SocketAddress) null);</span>

        // Enable SO_REUSEADDR before binding
<span class="fc" id="L168">        setReuseAddress(true);</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (bindaddr != null) {</span>
            try {
<span class="fc" id="L172">                bind(bindaddr);</span>
            } finally {
<span class="pc bpc" id="L174" title="3 of 4 branches missed.">                if (!isBound())</span>
<span class="nc" id="L175">                    close();</span>
            }
        }
<span class="fc" id="L178">    }</span>

    /**
     * The lock on the socket's TTL. This is for set/getTTL and
     * send(packet,ttl).
     */
<span class="fc" id="L184">    private Object ttlLock = new Object();</span>

    /**
     * The lock on the socket's interface - used by setInterface
     * and getInterface
     */
<span class="fc" id="L190">    private Object infLock = new Object();</span>

    /**
     * The &quot;last&quot; interface set by setInterface on this MulticastSocket
     */
<span class="fc" id="L195">    private InetAddress infAddress = null;</span>


    /**
     * Set the default time-to-live for multicast packets sent out
     * on this {@code MulticastSocket} in order to control the
     * scope of the multicasts.
     *
     * &lt;p&gt;The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;B&gt;must&lt;/B&gt; be
     * in the range {@code 0 &lt;= ttl &lt;= 0xFF }.
     *
     * @param ttl the time-to-live
     * @exception IOException if an I/O exception occurs
     * while setting the default time-to-live value
     * @deprecated use the setTimeToLive method instead, which uses
     * &lt;b&gt;int&lt;/b&gt; instead of &lt;b&gt;byte&lt;/b&gt; as the type for ttl.
     * @see #getTTL()
     */
    @Deprecated
    public void setTTL(byte ttl) throws IOException {
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L216">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="fc" id="L217">        getImpl().setTTL(ttl);</span>
<span class="fc" id="L218">    }</span>

    /**
     * Set the default time-to-live for multicast packets sent out
     * on this {@code MulticastSocket} in order to control the
     * scope of the multicasts.
     *
     * &lt;P&gt; The ttl &lt;B&gt;must&lt;/B&gt; be in the range {@code  0 &lt;= ttl &lt;=
     * 255} or an {@code IllegalArgumentException} will be thrown.
     * Multicast packets sent with a TTL of {@code 0} are not transmitted
     * on the network but may be delivered locally.
     *
     * @param  ttl
     *         the time-to-live
     *
     * @throws  IOException
     *          if an I/O exception occurs while setting the
     *          default time-to-live value
     *
     * @see #getTimeToLive()
     */
    public void setTimeToLive(int ttl) throws IOException {
<span class="pc bpc" id="L240" title="2 of 4 branches missed.">        if (ttl &lt; 0 || ttl &gt; 255) {</span>
<span class="nc" id="L241">            throw new IllegalArgumentException(&quot;ttl out of range&quot;);</span>
        }
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L244">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="fc" id="L245">        getImpl().setTimeToLive(ttl);</span>
<span class="fc" id="L246">    }</span>

    /**
     * Get the default time-to-live for multicast packets sent out on
     * the socket.
     *
     * @exception IOException if an I/O exception occurs
     * while getting the default time-to-live value
     * @return the default time-to-live value
     * @deprecated use the getTimeToLive method instead, which returns
     * an &lt;b&gt;int&lt;/b&gt; instead of a &lt;b&gt;byte&lt;/b&gt;.
     * @see #setTTL(byte)
     */
    @Deprecated
    public byte getTTL() throws IOException {
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L262">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="fc" id="L263">        return getImpl().getTTL();</span>
    }

    /**
     * Get the default time-to-live for multicast packets sent out on
     * the socket.
     * @exception IOException if an I/O exception occurs while
     * getting the default time-to-live value
     * @return the default time-to-live value
     * @see #setTimeToLive(int)
     */
    public int getTimeToLive() throws IOException {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L276">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="fc" id="L277">        return getImpl().getTimeToLive();</span>
    }

    /**
     * Joins a multicast group. Its behavior may be affected by
     * {@code setInterface} or {@code setNetworkInterface}.
     *
     * &lt;p&gt;If there is a security manager, this method first
     * calls its {@code checkMulticast} method
     * with the {@code mcastaddr} argument
     * as its argument.
     *
     * @param mcastaddr is the multicast address to join
     *
     * @exception IOException if there is an error joining
     * or when the address is not a multicast address.
     * @exception  SecurityException  if a security manager exists and its
     * {@code checkMulticast} method doesn't allow the join.
     *
     * @see SecurityManager#checkMulticast(InetAddress)
     */
    public void joinGroup(InetAddress mcastaddr) throws IOException {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (isClosed()) {</span>
<span class="nc" id="L300">            throw new SocketException(&quot;Socket is closed&quot;);</span>
        }

<span class="fc" id="L303">        checkAddress(mcastaddr, &quot;joinGroup&quot;);</span>
<span class="fc" id="L304">        SecurityManager security = System.getSecurityManager();</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        if (security != null) {</span>
<span class="fc" id="L306">            security.checkMulticast(mcastaddr);</span>
        }

<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        if (!mcastaddr.isMulticastAddress()) {</span>
<span class="nc" id="L310">            throw new SocketException(&quot;Not a multicast address&quot;);</span>
        }

        /**
         * required for some platforms where it's not possible to join
         * a group without setting the interface first.
         */
<span class="fc" id="L317">        NetworkInterface defaultInterface = NetworkInterface.getDefault();</span>

<span class="pc bpc" id="L319" title="2 of 4 branches missed.">        if (!interfaceSet &amp;&amp; defaultInterface != null) {</span>
<span class="nc" id="L320">            setNetworkInterface(defaultInterface);</span>
        }

<span class="fc" id="L323">        getImpl().join(mcastaddr);</span>
<span class="fc" id="L324">    }</span>

    /**
     * Leave a multicast group. Its behavior may be affected by
     * {@code setInterface} or {@code setNetworkInterface}.
     *
     * &lt;p&gt;If there is a security manager, this method first
     * calls its {@code checkMulticast} method
     * with the {@code mcastaddr} argument
     * as its argument.
     *
     * @param mcastaddr is the multicast address to leave
     * @exception IOException if there is an error leaving
     * or when the address is not a multicast address.
     * @exception  SecurityException  if a security manager exists and its
     * {@code checkMulticast} method doesn't allow the operation.
     *
     * @see SecurityManager#checkMulticast(InetAddress)
     */
    public void leaveGroup(InetAddress mcastaddr) throws IOException {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (isClosed()) {</span>
<span class="nc" id="L345">            throw new SocketException(&quot;Socket is closed&quot;);</span>
        }

<span class="fc" id="L348">        checkAddress(mcastaddr, &quot;leaveGroup&quot;);</span>
<span class="fc" id="L349">        SecurityManager security = System.getSecurityManager();</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (security != null) {</span>
<span class="fc" id="L351">            security.checkMulticast(mcastaddr);</span>
        }

<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (!mcastaddr.isMulticastAddress()) {</span>
<span class="nc" id="L355">            throw new SocketException(&quot;Not a multicast address&quot;);</span>
        }

<span class="fc" id="L358">        getImpl().leave(mcastaddr);</span>
<span class="fc" id="L359">    }</span>

    /**
     * Joins the specified multicast group at the specified interface.
     *
     * &lt;p&gt;If there is a security manager, this method first
     * calls its {@code checkMulticast} method
     * with the {@code mcastaddr} argument
     * as its argument.
     *
     * @param mcastaddr is the multicast address to join
     * @param netIf specifies the local interface to receive multicast
     *        datagram packets, or &lt;i&gt;null&lt;/i&gt; to defer to the interface set by
     *       {@link MulticastSocket#setInterface(InetAddress)} or
     *       {@link MulticastSocket#setNetworkInterface(NetworkInterface)}
     *
     * @exception IOException if there is an error joining
     * or when the address is not a multicast address.
     * @exception  SecurityException  if a security manager exists and its
     * {@code checkMulticast} method doesn't allow the join.
     * @throws  IllegalArgumentException if mcastaddr is null or is a
     *          SocketAddress subclass not supported by this socket
     *
     * @see SecurityManager#checkMulticast(InetAddress)
     * @since 1.4
     */
    public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
        throws IOException {
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L388">            throw new SocketException(&quot;Socket is closed&quot;);</span>

<span class="pc bpc" id="L390" title="2 of 4 branches missed.">        if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))</span>
<span class="nc" id="L391">            throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>

<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        if (oldImpl)</span>
<span class="nc" id="L394">            throw new UnsupportedOperationException();</span>

<span class="fc" id="L396">        checkAddress(((InetSocketAddress)mcastaddr).getAddress(), &quot;joinGroup&quot;);</span>
<span class="fc" id="L397">        SecurityManager security = System.getSecurityManager();</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (security != null) {</span>
<span class="fc" id="L399">            security.checkMulticast(((InetSocketAddress)mcastaddr).getAddress());</span>
        }

<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (!((InetSocketAddress)mcastaddr).getAddress().isMulticastAddress()) {</span>
<span class="nc" id="L403">            throw new SocketException(&quot;Not a multicast address&quot;);</span>
        }

<span class="fc" id="L406">        getImpl().joinGroup(mcastaddr, netIf);</span>
<span class="fc" id="L407">    }</span>

    /**
     * Leave a multicast group on a specified local interface.
     *
     * &lt;p&gt;If there is a security manager, this method first
     * calls its {@code checkMulticast} method
     * with the {@code mcastaddr} argument
     * as its argument.
     *
     * @param mcastaddr is the multicast address to leave
     * @param netIf specifies the local interface or &lt;i&gt;null&lt;/i&gt; to defer
     *             to the interface set by
     *             {@link MulticastSocket#setInterface(InetAddress)} or
     *             {@link MulticastSocket#setNetworkInterface(NetworkInterface)}
     * @exception IOException if there is an error leaving
     * or when the address is not a multicast address.
     * @exception  SecurityException  if a security manager exists and its
     * {@code checkMulticast} method doesn't allow the operation.
     * @throws  IllegalArgumentException if mcastaddr is null or is a
     *          SocketAddress subclass not supported by this socket
     *
     * @see SecurityManager#checkMulticast(InetAddress)
     * @since 1.4
     */
    public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
        throws IOException {
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L435">            throw new SocketException(&quot;Socket is closed&quot;);</span>

<span class="pc bpc" id="L437" title="2 of 4 branches missed.">        if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))</span>
<span class="nc" id="L438">            throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>

<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        if (oldImpl)</span>
<span class="nc" id="L441">            throw new UnsupportedOperationException();</span>

<span class="fc" id="L443">        checkAddress(((InetSocketAddress)mcastaddr).getAddress(), &quot;leaveGroup&quot;);</span>
<span class="fc" id="L444">        SecurityManager security = System.getSecurityManager();</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">        if (security != null) {</span>
<span class="fc" id="L446">            security.checkMulticast(((InetSocketAddress)mcastaddr).getAddress());</span>
        }

<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        if (!((InetSocketAddress)mcastaddr).getAddress().isMulticastAddress()) {</span>
<span class="nc" id="L450">            throw new SocketException(&quot;Not a multicast address&quot;);</span>
        }

<span class="fc" id="L453">        getImpl().leaveGroup(mcastaddr, netIf);</span>
<span class="fc" id="L454">     }</span>

    /**
     * Set the multicast network interface used by methods
     * whose behavior would be affected by the value of the
     * network interface. Useful for multihomed hosts.
     * @param inf the InetAddress
     * @exception SocketException if there is an error in
     * the underlying protocol, such as a TCP error.
     * @see #getInterface()
     */
    public void setInterface(InetAddress inf) throws SocketException {
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (isClosed()) {</span>
<span class="nc" id="L467">            throw new SocketException(&quot;Socket is closed&quot;);</span>
        }
<span class="nc" id="L469">        checkAddress(inf, &quot;setInterface&quot;);</span>
<span class="nc" id="L470">        synchronized (infLock) {</span>
<span class="nc" id="L471">            getImpl().setOption(SocketOptions.IP_MULTICAST_IF, inf);</span>
<span class="nc" id="L472">            infAddress = inf;</span>
<span class="nc" id="L473">            interfaceSet = true;</span>
<span class="nc" id="L474">        }</span>
<span class="nc" id="L475">    }</span>

    /**
     * Retrieve the address of the network interface used for
     * multicast packets.
     *
     * @return An {@code InetAddress} representing
     *  the address of the network interface used for
     *  multicast packets.
     *
     * @exception SocketException if there is an error in
     * the underlying protocol, such as a TCP error.
     *
     * @see #setInterface(java.net.InetAddress)
     */
    public InetAddress getInterface() throws SocketException {
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (isClosed()) {</span>
<span class="nc" id="L492">            throw new SocketException(&quot;Socket is closed&quot;);</span>
        }
<span class="nc" id="L494">        synchronized (infLock) {</span>
<span class="nc" id="L495">            InetAddress ia =</span>
<span class="nc" id="L496">                (InetAddress)getImpl().getOption(SocketOptions.IP_MULTICAST_IF);</span>

            /**
             * No previous setInterface or interface can be
             * set using setNetworkInterface
             */
<span class="nc bnc" id="L502" title="All 2 branches missed.">            if (infAddress == null) {</span>
<span class="nc" id="L503">                return ia;</span>
            }

            /**
             * Same interface set with setInterface?
             */
<span class="nc bnc" id="L509" title="All 2 branches missed.">            if (ia.equals(infAddress)) {</span>
<span class="nc" id="L510">                return ia;</span>
            }

            /**
             * Different InetAddress from what we set with setInterface
             * so enumerate the current interface to see if the
             * address set by setInterface is bound to this interface.
             */
            try {
<span class="nc" id="L519">                NetworkInterface ni = NetworkInterface.getByInetAddress(ia);</span>
<span class="nc" id="L520">                Enumeration&lt;InetAddress&gt; addrs = ni.getInetAddresses();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                while (addrs.hasMoreElements()) {</span>
<span class="nc" id="L522">                    InetAddress addr = addrs.nextElement();</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">                    if (addr.equals(infAddress)) {</span>
<span class="nc" id="L524">                        return infAddress;</span>
                    }
<span class="nc" id="L526">                }</span>

                /**
                 * No match so reset infAddress to indicate that the
                 * interface has changed via means
                 */
<span class="nc" id="L532">                infAddress = null;</span>
<span class="nc" id="L533">                return ia;</span>
<span class="nc" id="L534">            } catch (Exception e) {</span>
<span class="nc" id="L535">                return ia;</span>
            }
<span class="nc" id="L537">        }</span>
    }

    /**
     * Specify the network interface for outgoing multicast datagrams
     * sent on this socket.
     *
     * @param netIf the interface
     * @exception SocketException if there is an error in
     * the underlying protocol, such as a TCP error.
     * @see #getNetworkInterface()
     * @since 1.4
     */
    public void setNetworkInterface(NetworkInterface netIf)
        throws SocketException {

<span class="nc" id="L553">        synchronized (infLock) {</span>
<span class="nc" id="L554">            getImpl().setOption(SocketOptions.IP_MULTICAST_IF2, netIf);</span>
<span class="nc" id="L555">            infAddress = null;</span>
<span class="nc" id="L556">            interfaceSet = true;</span>
<span class="nc" id="L557">        }</span>
<span class="nc" id="L558">    }</span>

    /**
     * Get the multicast network interface set.
     *
     * @exception SocketException if there is an error in
     * the underlying protocol, such as a TCP error.
     * @return the multicast {@code NetworkInterface} currently set
     * @see #setNetworkInterface(NetworkInterface)
     * @since 1.4
     */
    public NetworkInterface getNetworkInterface() throws SocketException {
<span class="nc" id="L570">        NetworkInterface ni</span>
<span class="nc" id="L571">            = (NetworkInterface)getImpl().getOption(SocketOptions.IP_MULTICAST_IF2);</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (ni.getIndex() == 0) {</span>
<span class="nc" id="L573">            InetAddress[] addrs = new InetAddress[1];</span>
<span class="nc" id="L574">            addrs[0] = InetAddress.anyLocalAddress();</span>
<span class="nc" id="L575">            return new NetworkInterface(addrs[0].getHostName(), 0, addrs);</span>
        } else {
<span class="nc" id="L577">            return ni;</span>
        }
    }

    /**
     * Disable/Enable local loopback of multicast datagrams
     * The option is used by the platform's networking code as a hint
     * for setting whether multicast data will be looped back to
     * the local socket.
     *
     * &lt;p&gt;Because this option is a hint, applications that want to
     * verify what loopback mode is set to should call
     * {@link #getLoopbackMode()}
     * @param disable {@code true} to disable the LoopbackMode
     * @throws SocketException if an error occurs while setting the value
     * @since 1.4
     * @see #getLoopbackMode
     */
    public void setLoopbackMode(boolean disable) throws SocketException {
<span class="fc" id="L596">        getImpl().setOption(SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(disable));</span>
<span class="fc" id="L597">    }</span>

    /**
     * Get the setting for local loopback of multicast datagrams.
     *
     * @throws SocketException  if an error occurs while getting the value
     * @return true if the LoopbackMode has been disabled
     * @since 1.4
     * @see #setLoopbackMode
     */
    public boolean getLoopbackMode() throws SocketException {
<span class="nc" id="L608">        return ((Boolean)getImpl().getOption(SocketOptions.IP_MULTICAST_LOOP)).booleanValue();</span>
    }

    /**
     * Sends a datagram packet to the destination, with a TTL (time-
     * to-live) other than the default for the socket.  This method
     * need only be used in instances where a particular TTL is desired;
     * otherwise it is preferable to set a TTL once on the socket, and
     * use that default TTL for all packets.  This method does &lt;B&gt;not
     * &lt;/B&gt; alter the default TTL for the socket. Its behavior may be
     * affected by {@code setInterface}.
     *
     * &lt;p&gt;If there is a security manager, this method first performs some
     * security checks. First, if {@code p.getAddress().isMulticastAddress()}
     * is true, this method calls the
     * security manager's {@code checkMulticast} method
     * with {@code p.getAddress()} and {@code ttl} as its arguments.
     * If the evaluation of that expression is false,
     * this method instead calls the security manager's
     * {@code checkConnect} method with arguments
     * {@code p.getAddress().getHostAddress()} and
     * {@code p.getPort()}. Each call to a security manager method
     * could result in a SecurityException if the operation is not allowed.
     *
     * @param p is the packet to be sent. The packet should contain
     * the destination multicast ip address and the data to be sent.
     * One does not need to be the member of the group to send
     * packets to a destination multicast address.
     * @param ttl optional time to live for multicast packet.
     * default ttl is 1.
     *
     * @exception IOException is raised if an error occurs i.e
     * error while setting ttl.
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkMulticast} or {@code checkConnect}
     *             method doesn't allow the send.
     *
     * @deprecated Use the following code or its equivalent instead:
     *  ......
     *  int ttl = mcastSocket.getTimeToLive();
     *  mcastSocket.setTimeToLive(newttl);
     *  mcastSocket.send(p);
     *  mcastSocket.setTimeToLive(ttl);
     *  ......
     *
     * @see DatagramSocket#send
     * @see DatagramSocket#receive
     * @see SecurityManager#checkMulticast(java.net.InetAddress, byte)
     * @see SecurityManager#checkConnect
     */
    @Deprecated
    public void send(DatagramPacket p, byte ttl)
        throws IOException {
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">            if (isClosed())</span>
<span class="nc" id="L662">                throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="fc" id="L663">            checkAddress(p.getAddress(), &quot;send&quot;);</span>
<span class="fc" id="L664">            synchronized(ttlLock) {</span>
<span class="fc" id="L665">                synchronized(p) {</span>
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">                    if (connectState == ST_NOT_CONNECTED) {</span>
                        // Security manager makes sure that the multicast address
                        // is allowed one and that the ttl used is less
                        // than the allowed maxttl.
<span class="fc" id="L670">                        SecurityManager security = System.getSecurityManager();</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">                        if (security != null) {</span>
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">                            if (p.getAddress().isMulticastAddress()) {</span>
<span class="fc" id="L673">                                security.checkMulticast(p.getAddress(), ttl);</span>
                            } else {
<span class="nc" id="L675">                                security.checkConnect(p.getAddress().getHostAddress(),</span>
<span class="nc" id="L676">                                                      p.getPort());</span>
                            }
                        }
<span class="fc" id="L679">                    } else {</span>
                        // we're connected
<span class="nc" id="L681">                        InetAddress packetAddress = null;</span>
<span class="nc" id="L682">                        packetAddress = p.getAddress();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">                        if (packetAddress == null) {</span>
<span class="nc" id="L684">                            p.setAddress(connectedAddress);</span>
<span class="nc" id="L685">                            p.setPort(connectedPort);</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">                        } else if ((!packetAddress.equals(connectedAddress)) ||</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">                                   p.getPort() != connectedPort) {</span>
<span class="nc" id="L688">                            throw new SecurityException(&quot;connected address and packet address&quot; +</span>
                                                        &quot; differ&quot;);
                        }
                    }
<span class="fc" id="L692">                    byte dttl = getTTL();</span>
                    try {
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">                        if (ttl != dttl) {</span>
                            // set the ttl
<span class="fc" id="L696">                            getImpl().setTTL(ttl);</span>
                        }
                        // call the datagram method to send
<span class="nc" id="L699">                        getImpl().send(p);</span>
                    } finally {
                        // set it back to default
<span class="pc bpc" id="L702" title="3 of 4 branches missed.">                        if (ttl != dttl) {</span>
<span class="pc" id="L703">                            getImpl().setTTL(dttl);</span>
                        }
                    }
<span class="pc" id="L706">                } // synch p</span>
<span class="pc" id="L707">            }  //synch ttl</span>
<span class="nc" id="L708">    } //method</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>