<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CookieManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">CookieManager.java</span></div><h1>CookieManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.util.Map;
import java.util.List;
import java.util.Collections;
import java.util.Comparator;
import java.io.IOException;
import sun.util.logging.PlatformLogger;

/**
 * CookieManager provides a concrete implementation of {@link CookieHandler},
 * which separates the storage of cookies from the policy surrounding accepting
 * and rejecting cookies. A CookieManager is initialized with a {@link CookieStore}
 * which manages storage, and a {@link CookiePolicy} object, which makes
 * policy decisions on cookie acceptance/rejection.
 *
 * &lt;p&gt; The HTTP cookie management in java.net package looks like:
 * &lt;blockquote&gt;
 * &lt;pre&gt;{@code
 *                  use
 * CookieHandler &lt;------- HttpURLConnection
 *       ^
 *       | impl
 *       |         use
 * CookieManager -------&gt; CookiePolicy
 *             |   use
 *             |--------&gt; HttpCookie
 *             |              ^
 *             |              | use
 *             |   use        |
 *             |--------&gt; CookieStore
 *                            ^
 *                            | impl
 *                            |
 *                  Internal in-memory implementation
 * }&lt;/pre&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;
 *     CookieHandler is at the core of cookie management. User can call
 *     CookieHandler.setDefault to set a concrete CookieHanlder implementation
 *     to be used.
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     CookiePolicy.shouldAccept will be called by CookieManager.put to see whether
 *     or not one cookie should be accepted and put into cookie store. User can use
 *     any of three pre-defined CookiePolicy, namely ACCEPT_ALL, ACCEPT_NONE and
 *     ACCEPT_ORIGINAL_SERVER, or user can define his own CookiePolicy implementation
 *     and tell CookieManager to use it.
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     CookieStore is the place where any accepted HTTP cookie is stored in.
 *     If not specified when created, a CookieManager instance will use an internal
 *     in-memory implementation. Or user can implements one and tell CookieManager
 *     to use it.
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     Currently, only CookieStore.add(URI, HttpCookie) and CookieStore.get(URI)
 *     are used by CookieManager. Others are for completeness and might be needed
 *     by a more sophisticated CookieStore implementation, e.g. a NetscapeCookieSotre.
 *   &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt;There're various ways user can hook up his own HTTP cookie management behavior, e.g.
 * &lt;blockquote&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;Use CookieHandler.setDefault to set a brand new {@link CookieHandler} implementation
 *   &lt;li&gt;Let CookieManager be the default {@link CookieHandler} implementation,
 *       but implement user's own {@link CookieStore} and {@link CookiePolicy}
 *       and tell default CookieManager to use them:
 *     &lt;blockquote&gt;&lt;pre&gt;
 *       // this should be done at the beginning of an HTTP session
 *       CookieHandler.setDefault(new CookieManager(new MyCookieStore(), new MyCookiePolicy()));
 *     &lt;/pre&gt;&lt;/blockquote&gt;
 *   &lt;li&gt;Let CookieManager be the default {@link CookieHandler} implementation, but
 *       use customized {@link CookiePolicy}:
 *     &lt;blockquote&gt;&lt;pre&gt;
 *       // this should be done at the beginning of an HTTP session
 *       CookieHandler.setDefault(new CookieManager());
 *       // this can be done at any point of an HTTP session
 *       ((CookieManager)CookieHandler.getDefault()).setCookiePolicy(new MyCookiePolicy());
 *     &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;/ul&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt;The implementation conforms to &lt;a href=&quot;http://www.ietf.org/rfc/rfc2965.txt&quot;&gt;RFC 2965&lt;/a&gt;, section 3.3.
 *
 * @see CookiePolicy
 * @author Edward Wang
 * @since 1.6
 */
public class CookieManager extends CookieHandler
{
    /* ---------------- Fields -------------- */

    private CookiePolicy policyCallback;


<span class="fc" id="L124">    private CookieStore cookieJar = null;</span>


    /* ---------------- Ctors -------------- */

    /**
     * Create a new cookie manager.
     *
     * &lt;p&gt;This constructor will create new cookie manager with default
     * cookie store and accept policy. The effect is same as
     * {@code CookieManager(null, null)}.
     */
    public CookieManager() {
<span class="fc" id="L137">        this(null, null);</span>
<span class="fc" id="L138">    }</span>


    /**
     * Create a new cookie manager with specified cookie store and cookie policy.
     *
     * @param store     a {@code CookieStore} to be used by cookie manager.
     *                  if {@code null}, cookie manager will use a default one,
     *                  which is an in-memory CookieStore implementation.
     * @param cookiePolicy      a {@code CookiePolicy} instance
     *                          to be used by cookie manager as policy callback.
     *                          if {@code null}, ACCEPT_ORIGINAL_SERVER will
     *                          be used.
     */
    public CookieManager(CookieStore store,
                         CookiePolicy cookiePolicy)
<span class="fc" id="L154">    {</span>
        // use default cookie policy if not specify one
<span class="fc bfc" id="L156" title="All 2 branches covered.">        policyCallback = (cookiePolicy == null) ? CookiePolicy.ACCEPT_ORIGINAL_SERVER</span>
                                                : cookiePolicy;

        // if not specify CookieStore to use, use default one
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (store == null) {</span>
<span class="fc" id="L161">            cookieJar = new InMemoryCookieStore();</span>
        } else {
<span class="nc" id="L163">            cookieJar = store;</span>
        }
<span class="fc" id="L165">    }</span>


    /* ---------------- Public operations -------------- */

    /**
     * To set the cookie policy of this cookie manager.
     *
     * &lt;p&gt; A instance of {@code CookieManager} will have
     * cookie policy ACCEPT_ORIGINAL_SERVER by default. Users always
     * can call this method to set another cookie policy.
     *
     * @param cookiePolicy      the cookie policy. Can be {@code null}, which
     *                          has no effects on current cookie policy.
     */
    public void setCookiePolicy(CookiePolicy cookiePolicy) {
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (cookiePolicy != null) policyCallback = cookiePolicy;</span>
<span class="fc" id="L182">    }</span>


    /**
     * To retrieve current cookie store.
     *
     * @return  the cookie store currently used by cookie manager.
     */
    public CookieStore getCookieStore() {
<span class="fc" id="L191">        return cookieJar;</span>
    }


    public Map&lt;String, List&lt;String&gt;&gt;
        get(URI uri, Map&lt;String, List&lt;String&gt;&gt; requestHeaders)
        throws IOException
    {
        // pre-condition check
<span class="pc bpc" id="L200" title="2 of 4 branches missed.">        if (uri == null || requestHeaders == null) {</span>
<span class="nc" id="L201">            throw new IllegalArgumentException(&quot;Argument is null&quot;);</span>
        }

<span class="fc" id="L204">        Map&lt;String, List&lt;String&gt;&gt; cookieMap =</span>
                        new java.util.HashMap&lt;String, List&lt;String&gt;&gt;();
        // if there's no default CookieStore, no way for us to get any cookie
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (cookieJar == null)</span>
<span class="nc" id="L208">            return Collections.unmodifiableMap(cookieMap);</span>

<span class="fc" id="L210">        boolean secureLink = &quot;https&quot;.equalsIgnoreCase(uri.getScheme());</span>
<span class="fc" id="L211">        List&lt;HttpCookie&gt; cookies = new java.util.ArrayList&lt;HttpCookie&gt;();</span>
<span class="fc" id="L212">        String path = uri.getPath();</span>
<span class="pc bpc" id="L213" title="1 of 4 branches missed.">        if (path == null || path.isEmpty()) {</span>
<span class="fc" id="L214">            path = &quot;/&quot;;</span>
        }
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (HttpCookie cookie : cookieJar.get(uri)) {</span>
            // apply path-matches rule (RFC 2965 sec. 3.3.4)
            // and check for the possible &quot;secure&quot; tag (i.e. don't send
            // 'secure' cookies over unsecure links)
<span class="fc bfc" id="L220" title="All 4 branches covered.">            if (pathMatches(path, cookie.getPath()) &amp;&amp;</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">                    (secureLink || !cookie.getSecure())) {</span>
                // Enforce httponly attribute
<span class="fc bfc" id="L223" title="All 2 branches covered.">                if (cookie.isHttpOnly()) {</span>
<span class="fc" id="L224">                    String s = uri.getScheme();</span>
<span class="pc bpc" id="L225" title="1 of 4 branches missed.">                    if (!&quot;http&quot;.equalsIgnoreCase(s) &amp;&amp; !&quot;https&quot;.equalsIgnoreCase(s)) {</span>
<span class="fc" id="L226">                        continue;</span>
                    }
                }
                // Let's check the authorize port list if it exists
<span class="fc" id="L230">                String ports = cookie.getPortlist();</span>
<span class="pc bpc" id="L231" title="1 of 4 branches missed.">                if (ports != null &amp;&amp; !ports.isEmpty()) {</span>
<span class="fc" id="L232">                    int port = uri.getPort();</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">                    if (port == -1) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                        port = &quot;https&quot;.equals(uri.getScheme()) ? 443 : 80;</span>
                    }
<span class="fc bfc" id="L236" title="All 2 branches covered.">                    if (isInPortList(ports, port)) {</span>
<span class="fc" id="L237">                        cookies.add(cookie);</span>
                    }
<span class="fc" id="L239">                } else {</span>
<span class="fc" id="L240">                    cookies.add(cookie);</span>
                }
            }
<span class="fc" id="L243">        }</span>

        // apply sort rule (RFC 2965 sec. 3.3.4)
<span class="fc" id="L246">        List&lt;String&gt; cookieHeader = sortByPath(cookies);</span>

<span class="fc" id="L248">        cookieMap.put(&quot;Cookie&quot;, cookieHeader);</span>
<span class="fc" id="L249">        return Collections.unmodifiableMap(cookieMap);</span>
    }

    public void
        put(URI uri, Map&lt;String, List&lt;String&gt;&gt; responseHeaders)
        throws IOException
    {
        // pre-condition check
<span class="pc bpc" id="L257" title="2 of 4 branches missed.">        if (uri == null || responseHeaders == null) {</span>
<span class="nc" id="L258">            throw new IllegalArgumentException(&quot;Argument is null&quot;);</span>
        }


        // if there's no default CookieStore, no need to remember any cookie
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (cookieJar == null)</span>
<span class="nc" id="L264">            return;</span>

<span class="fc" id="L266">    PlatformLogger logger = PlatformLogger.getLogger(&quot;java.net.CookieManager&quot;);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        for (String headerKey : responseHeaders.keySet()) {</span>
            // RFC 2965 3.2.2, key must be 'Set-Cookie2'
            // we also accept 'Set-Cookie' here for backward compatibility
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (headerKey == null</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">                || !(headerKey.equalsIgnoreCase(&quot;Set-Cookie2&quot;)</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                     || headerKey.equalsIgnoreCase(&quot;Set-Cookie&quot;)</span>
                    )
                )
            {
<span class="fc" id="L276">                continue;</span>
            }

<span class="fc bfc" id="L279" title="All 2 branches covered.">            for (String headerValue : responseHeaders.get(headerKey)) {</span>
                try {
                    List&lt;HttpCookie&gt; cookies;
                    try {
<span class="fc" id="L283">                        cookies = HttpCookie.parse(headerValue);</span>
<span class="nc" id="L284">                    } catch (IllegalArgumentException e) {</span>
                        // Bogus header, make an empty list and log the error
<span class="nc" id="L286">                        cookies = java.util.Collections.emptyList();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                        if (logger.isLoggable(PlatformLogger.Level.SEVERE)) {</span>
<span class="nc" id="L288">                            logger.severe(&quot;Invalid cookie for &quot; + uri + &quot;: &quot; + headerValue);</span>
                        }
<span class="fc" id="L290">                    }</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">                    for (HttpCookie cookie : cookies) {</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">                        if (cookie.getPath() == null) {</span>
                            // If no path is specified, then by default
                            // the path is the directory of the page/doc
<span class="fc" id="L295">                            String path = uri.getPath();</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">                            if (!path.endsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L297">                                int i = path.lastIndexOf(&quot;/&quot;);</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">                                if (i &gt; 0) {</span>
<span class="fc" id="L299">                                    path = path.substring(0, i + 1);</span>
                                } else {
<span class="fc" id="L301">                                    path = &quot;/&quot;;</span>
                                }
                            }
<span class="fc" id="L304">                            cookie.setPath(path);</span>
                        }

                        // As per RFC 2965, section 3.3.1:
                        // Domain  Defaults to the effective request-host.  (Note that because
                        // there is no dot at the beginning of effective request-host,
                        // the default Domain can only domain-match itself.)
<span class="fc bfc" id="L311" title="All 2 branches covered.">                        if (cookie.getDomain() == null) {</span>
<span class="fc" id="L312">                            String host = uri.getHost();</span>
<span class="pc bpc" id="L313" title="1 of 4 branches missed.">                            if (host != null &amp;&amp; !host.contains(&quot;.&quot;))</span>
<span class="fc" id="L314">                                host += &quot;.local&quot;;</span>
<span class="fc" id="L315">                            cookie.setDomain(host);</span>
                        }
<span class="fc" id="L317">                        String ports = cookie.getPortlist();</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">                        if (ports != null) {</span>
<span class="fc" id="L319">                            int port = uri.getPort();</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">                            if (port == -1) {</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">                                port = &quot;https&quot;.equals(uri.getScheme()) ? 443 : 80;</span>
                            }
<span class="fc bfc" id="L323" title="All 2 branches covered.">                            if (ports.isEmpty()) {</span>
                                // Empty port list means this should be restricted
                                // to the incoming URI port
<span class="fc" id="L326">                                cookie.setPortlist(&quot;&quot; + port );</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">                                if (shouldAcceptInternal(uri, cookie)) {</span>
<span class="fc" id="L328">                                    cookieJar.add(uri, cookie);</span>
                                }
                            } else {
                                // Only store cookies with a port list
                                // IF the URI port is in that list, as per
                                // RFC 2965 section 3.3.2
<span class="fc bfc" id="L334" title="All 2 branches covered.">                                if (isInPortList(ports, port) &amp;&amp;</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">                                        shouldAcceptInternal(uri, cookie)) {</span>
<span class="fc" id="L336">                                    cookieJar.add(uri, cookie);</span>
                                }
                            }
<span class="fc" id="L339">                        } else {</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">                            if (shouldAcceptInternal(uri, cookie)) {</span>
<span class="fc" id="L341">                                cookieJar.add(uri, cookie);</span>
                            }
                        }
<span class="fc" id="L344">                    }</span>
<span class="nc" id="L345">                } catch (IllegalArgumentException e) {</span>
                    // invalid set-cookie header string
                    // no-op
<span class="fc" id="L348">                }</span>
<span class="fc" id="L349">            }</span>
<span class="fc" id="L350">        }</span>
<span class="fc" id="L351">    }</span>


    /* ---------------- Private operations -------------- */

    // to determine whether or not accept this cookie
    private boolean shouldAcceptInternal(URI uri, HttpCookie cookie) {
        try {
<span class="fc" id="L359">            return policyCallback.shouldAccept(uri, cookie);</span>
<span class="nc" id="L360">        } catch (Exception ignored) { // pretect against malicious callback</span>
<span class="nc" id="L361">            return false;</span>
        }
    }


    static private boolean isInPortList(String lst, int port) {
<span class="fc" id="L367">        int i = lst.indexOf(&quot;,&quot;);</span>
<span class="fc" id="L368">        int val = -1;</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        while (i &gt; 0) {</span>
            try {
<span class="fc" id="L371">                val = Integer.parseInt(lst.substring(0, i));</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">                if (val == port) {</span>
<span class="fc" id="L373">                    return true;</span>
                }
<span class="nc" id="L375">            } catch (NumberFormatException numberFormatException) {</span>
<span class="fc" id="L376">            }</span>
<span class="fc" id="L377">            lst = lst.substring(i+1);</span>
<span class="fc" id="L378">            i = lst.indexOf(&quot;,&quot;);</span>
        }
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (!lst.isEmpty()) {</span>
            try {
<span class="fc" id="L382">                val = Integer.parseInt(lst);</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">                if (val == port) {</span>
<span class="fc" id="L384">                    return true;</span>
                }
<span class="nc" id="L386">            } catch (NumberFormatException numberFormatException) {</span>
<span class="fc" id="L387">            }</span>
        }
<span class="fc" id="L389">        return false;</span>
    }

    /*
     * path-matches algorithm, as defined by RFC 2965
     */
    private boolean pathMatches(String path, String pathToMatchWith) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (path == pathToMatchWith)</span>
<span class="fc" id="L397">            return true;</span>
<span class="pc bpc" id="L398" title="2 of 4 branches missed.">        if (path == null || pathToMatchWith == null)</span>
<span class="nc" id="L399">            return false;</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (path.startsWith(pathToMatchWith))</span>
<span class="fc" id="L401">            return true;</span>

<span class="fc" id="L403">        return false;</span>
    }


    /*
     * sort cookies with respect to their path: those with more specific Path attributes
     * precede those with less specific, as defined in RFC 2965 sec. 3.3.4
     */
    private List&lt;String&gt; sortByPath(List&lt;HttpCookie&gt; cookies) {
<span class="fc" id="L412">        Collections.sort(cookies, new CookiePathComparator());</span>

<span class="fc" id="L414">        List&lt;String&gt; cookieHeader = new java.util.ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">        for (HttpCookie cookie : cookies) {</span>
            // Netscape cookie spec and RFC 2965 have different format of Cookie
            // header; RFC 2965 requires a leading $Version=&quot;1&quot; string while Netscape
            // does not.
            // The workaround here is to add a $Version=&quot;1&quot; string in advance
<span class="fc bfc" id="L420" title="All 4 branches covered.">            if (cookies.indexOf(cookie) == 0 &amp;&amp; cookie.getVersion() &gt; 0) {</span>
<span class="fc" id="L421">                cookieHeader.add(&quot;$Version=\&quot;1\&quot;&quot;);</span>
            }

<span class="fc" id="L424">            cookieHeader.add(cookie.toString());</span>
<span class="fc" id="L425">        }</span>
<span class="fc" id="L426">        return cookieHeader;</span>
    }


<span class="fc" id="L430">    static class CookiePathComparator implements Comparator&lt;HttpCookie&gt; {</span>
        public int compare(HttpCookie c1, HttpCookie c2) {
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">            if (c1 == c2) return 0;</span>
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">            if (c1 == null) return -1;</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">            if (c2 == null) return 1;</span>

            // path rule only applies to the cookies with same name
<span class="fc bfc" id="L437" title="All 2 branches covered.">            if (!c1.getName().equals(c2.getName())) return 0;</span>

            // those with more specific Path attributes precede those with less specific
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">            if (c1.getPath().startsWith(c2.getPath()))</span>
<span class="fc" id="L441">                return -1;</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            else if (c2.getPath().startsWith(c1.getPath()))</span>
<span class="nc" id="L443">                return 1;</span>
            else
<span class="nc" id="L445">                return 0;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>