<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>HttpCookie.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">HttpCookie.java</span></div><h1>HttpCookie.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.util.List;
import java.util.StringTokenizer;
import java.util.NoSuchElementException;
import java.text.SimpleDateFormat;
import java.util.TimeZone;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Date;
import java.util.Locale;
import java.util.Objects;

/**
 * An HttpCookie object represents an HTTP cookie, which carries state
 * information between server and user agent. Cookie is widely adopted
 * to create stateful sessions.
 *
 * &lt;p&gt; There are 3 HTTP cookie specifications:
 * &lt;blockquote&gt;
 *   Netscape draft&lt;br&gt;
 *   RFC 2109 - &lt;a href=&quot;http://www.ietf.org/rfc/rfc2109.txt&quot;&gt;
 * &lt;i&gt;http://www.ietf.org/rfc/rfc2109.txt&lt;/i&gt;&lt;/a&gt;&lt;br&gt;
 *   RFC 2965 - &lt;a href=&quot;http://www.ietf.org/rfc/rfc2965.txt&quot;&gt;
 * &lt;i&gt;http://www.ietf.org/rfc/rfc2965.txt&lt;/i&gt;&lt;/a&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt; HttpCookie class can accept all these 3 forms of syntax.
 *
 * @author Edward Wang
 * @since 1.6
 */
public final class HttpCookie implements Cloneable {
    // ---------------- Fields --------------

    // The value of the cookie itself.
    private final String name;  // NAME= ... &quot;$Name&quot; style is reserved
    private String value;       // value of NAME

    // Attributes encoded in the header's cookie fields.
    private String comment;     // Comment=VALUE ... describes cookie's use
    private String commentURL;  // CommentURL=&quot;http URL&quot; ... describes cookie's use
    private boolean toDiscard;  // Discard ... discard cookie unconditionally
    private String domain;      // Domain=VALUE ... domain that sees cookie
<span class="fc" id="L70">    private long maxAge = MAX_AGE_UNSPECIFIED;  // Max-Age=VALUE ... cookies auto-expire</span>
    private String path;        // Path=VALUE ... URLs that see the cookie
    private String portlist;    // Port[=&quot;portlist&quot;] ... the port cookie may be returned to
    private boolean secure;     // Secure ... e.g. use SSL
    private boolean httpOnly;   // HttpOnly ... i.e. not accessible to scripts
<span class="fc" id="L75">    private int version = 1;    // Version=1 ... RFC 2965 style</span>

    // The original header this cookie was consructed from, if it was
    // constructed by parsing a header, otherwise null.
    private final String header;

    // Hold the creation time (in seconds) of the http cookie for later
    // expiration calculation
    private final long whenCreated;

    // Since the positive and zero max-age have their meanings,
    // this value serves as a hint as 'not specify max-age'
    private final static long MAX_AGE_UNSPECIFIED = -1;

    // date formats used by Netscape's cookie draft
    // as well as formats seen on various sites
<span class="fc" id="L91">    private final static String[] COOKIE_DATE_FORMATS = {</span>
        &quot;EEE',' dd-MMM-yyyy HH:mm:ss 'GMT'&quot;,
        &quot;EEE',' dd MMM yyyy HH:mm:ss 'GMT'&quot;,
        &quot;EEE MMM dd yyyy HH:mm:ss 'GMT'Z&quot;,
        &quot;EEE',' dd-MMM-yy HH:mm:ss 'GMT'&quot;,
        &quot;EEE',' dd MMM yy HH:mm:ss 'GMT'&quot;,
        &quot;EEE MMM dd yy HH:mm:ss 'GMT'Z&quot;
    };

    // constant strings represent set-cookie header token
    private final static String SET_COOKIE = &quot;set-cookie:&quot;;
    private final static String SET_COOKIE2 = &quot;set-cookie2:&quot;;

    // ---------------- Ctors --------------

    /**
     * Constructs a cookie with a specified name and value.
     *
     * &lt;p&gt; The name must conform to RFC 2965. That means it can contain
     * only ASCII alphanumeric characters and cannot contain commas,
     * semicolons, or white space or begin with a $ character. The cookie's
     * name cannot be changed after creation.
     *
     * &lt;p&gt; The value can be anything the server chooses to send. Its
     * value is probably of interest only to the server. The cookie's
     * value can be changed after creation with the
     * {@code setValue} method.
     *
     * &lt;p&gt; By default, cookies are created according to the RFC 2965
     * cookie specification. The version can be changed with the
     * {@code setVersion} method.
     *
     *
     * @param  name
     *         a {@code String} specifying the name of the cookie
     *
     * @param  value
     *         a {@code String} specifying the value of the cookie
     *
     * @throws  IllegalArgumentException
     *          if the cookie name contains illegal characters
     * @throws  NullPointerException
     *          if {@code name} is {@code null}
     *
     * @see #setValue
     * @see #setVersion
     */
    public HttpCookie(String name, String value) {
<span class="fc" id="L139">        this(name, value, null /*header*/);</span>
<span class="fc" id="L140">    }</span>

<span class="fc" id="L142">    private HttpCookie(String name, String value, String header) {</span>
<span class="fc" id="L143">        name = name.trim();</span>
<span class="pc bpc" id="L144" title="3 of 6 branches missed.">        if (name.length() == 0 || !isToken(name) || name.charAt(0) == '$') {</span>
<span class="nc" id="L145">            throw new IllegalArgumentException(&quot;Illegal cookie name&quot;);</span>
        }

<span class="fc" id="L148">        this.name = name;</span>
<span class="fc" id="L149">        this.value = value;</span>
<span class="fc" id="L150">        toDiscard = false;</span>
<span class="fc" id="L151">        secure = false;</span>

<span class="fc" id="L153">        whenCreated = System.currentTimeMillis();</span>
<span class="fc" id="L154">        portlist = null;</span>
<span class="fc" id="L155">        this.header = header;</span>
<span class="fc" id="L156">    }</span>

    /**
     * Constructs cookies from set-cookie or set-cookie2 header string.
     * RFC 2965 section 3.2.2 set-cookie2 syntax indicates that one header line
     * may contain more than one cookie definitions, so this is a static
     * utility method instead of another constructor.
     *
     * @param  header
     *         a {@code String} specifying the set-cookie header. The header
     *         should start with &quot;set-cookie&quot;, or &quot;set-cookie2&quot; token; or it
     *         should have no leading token at all.
     *
     * @return  a List of cookie parsed from header line string
     *
     * @throws  IllegalArgumentException
     *          if header string violates the cookie specification's syntax or
     *          the cookie name contains illegal characters.
     * @throws  NullPointerException
     *          if the header string is {@code null}
     */
    public static List&lt;HttpCookie&gt; parse(String header) {
<span class="fc" id="L178">        return parse(header, false);</span>
    }

    // Private version of parse() that will store the original header used to
    // create the cookie, in the cookie itself. This can be useful for filtering
    // Set-Cookie[2] headers, using the internal parsing logic defined in this
    // class.
    private static List&lt;HttpCookie&gt; parse(String header, boolean retainHeader) {

<span class="fc" id="L187">        int version = guessCookieVersion(header);</span>

        // if header start with set-cookie or set-cookie2, strip it off
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (startsWithIgnoreCase(header, SET_COOKIE2)) {</span>
<span class="nc" id="L191">            header = header.substring(SET_COOKIE2.length());</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        } else if (startsWithIgnoreCase(header, SET_COOKIE)) {</span>
<span class="fc" id="L193">            header = header.substring(SET_COOKIE.length());</span>
        }

<span class="fc" id="L196">        List&lt;HttpCookie&gt; cookies = new java.util.ArrayList&lt;&gt;();</span>
        // The Netscape cookie may have a comma in its expires attribute, while
        // the comma is the delimiter in rfc 2965/2109 cookie header string.
        // so the parse logic is slightly different
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (version == 0) {</span>
            // Netscape draft cookie
<span class="fc" id="L202">            HttpCookie cookie = parseInternal(header, retainHeader);</span>
<span class="fc" id="L203">            cookie.setVersion(0);</span>
<span class="fc" id="L204">            cookies.add(cookie);</span>
<span class="fc" id="L205">        } else {</span>
            // rfc2965/2109 cookie
            // if header string contains more than one cookie,
            // it'll separate them with comma
<span class="fc" id="L209">            List&lt;String&gt; cookieStrings = splitMultiCookies(header);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">            for (String cookieStr : cookieStrings) {</span>
<span class="fc" id="L211">                HttpCookie cookie = parseInternal(cookieStr, retainHeader);</span>
<span class="fc" id="L212">                cookie.setVersion(1);</span>
<span class="fc" id="L213">                cookies.add(cookie);</span>
<span class="fc" id="L214">            }</span>
        }

<span class="fc" id="L217">        return cookies;</span>
    }

    // ---------------- Public operations --------------

    /**
     * Reports whether this HTTP cookie has expired or not.
     *
     * @return  {@code true} to indicate this HTTP cookie has expired;
     *          otherwise, {@code false}
     */
    public boolean hasExpired() {
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (maxAge == 0) return true;</span>

        // if not specify max-age, this cookie should be
        // discarded when user agent is to be closed, but
        // it is not expired.
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (maxAge == MAX_AGE_UNSPECIFIED) return false;</span>

<span class="fc" id="L236">        long deltaSecond = (System.currentTimeMillis() - whenCreated) / 1000;</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (deltaSecond &gt; maxAge)</span>
<span class="nc" id="L238">            return true;</span>
        else
<span class="fc" id="L240">            return false;</span>
    }

    /**
     * Specifies a comment that describes a cookie's purpose.
     * The comment is useful if the browser presents the cookie
     * to the user. Comments are not supported by Netscape Version 0 cookies.
     *
     * @param  purpose
     *         a {@code String} specifying the comment to display to the user
     *
     * @see  #getComment
     */
    public void setComment(String purpose) {
<span class="nc" id="L254">        comment = purpose;</span>
<span class="nc" id="L255">    }</span>

    /**
     * Returns the comment describing the purpose of this cookie, or
     * {@code null} if the cookie has no comment.
     *
     * @return  a {@code String} containing the comment, or {@code null} if none
     *
     * @see  #setComment
     */
    public String getComment() {
<span class="nc" id="L266">        return comment;</span>
    }

    /**
     * Specifies a comment URL that describes a cookie's purpose.
     * The comment URL is useful if the browser presents the cookie
     * to the user. Comment URL is RFC 2965 only.
     *
     * @param  purpose
     *         a {@code String} specifying the comment URL to display to the user
     *
     * @see  #getCommentURL
     */
    public void setCommentURL(String purpose) {
<span class="nc" id="L280">        commentURL = purpose;</span>
<span class="nc" id="L281">    }</span>

    /**
     * Returns the comment URL describing the purpose of this cookie, or
     * {@code null} if the cookie has no comment URL.
     *
     * @return  a {@code String} containing the comment URL, or {@code null}
     *          if none
     *
     * @see  #setCommentURL
     */
    public String getCommentURL() {
<span class="nc" id="L293">        return commentURL;</span>
    }

    /**
     * Specify whether user agent should discard the cookie unconditionally.
     * This is RFC 2965 only attribute.
     *
     * @param  discard
     *         {@code true} indicates to discard cookie unconditionally
     *
     * @see  #getDiscard
     */
    public void setDiscard(boolean discard) {
<span class="nc" id="L306">        toDiscard = discard;</span>
<span class="nc" id="L307">    }</span>

    /**
     * Returns the discard attribute of the cookie
     *
     * @return  a {@code boolean} to represent this cookie's discard attribute
     *
     * @see  #setDiscard
     */
    public boolean getDiscard() {
<span class="nc" id="L317">        return toDiscard;</span>
    }

    /**
     * Specify the portlist of the cookie, which restricts the port(s)
     * to which a cookie may be sent back in a Cookie header.
     *
     * @param  ports
     *         a {@code String} specify the port list, which is comma separated
     *         series of digits
     *
     * @see  #getPortlist
     */
    public void setPortlist(String ports) {
<span class="fc" id="L331">        portlist = ports;</span>
<span class="fc" id="L332">    }</span>

    /**
     * Returns the port list attribute of the cookie
     *
     * @return  a {@code String} contains the port list or {@code null} if none
     *
     * @see  #setPortlist
     */
    public String getPortlist() {
<span class="fc" id="L342">        return portlist;</span>
    }

    /**
     * Specifies the domain within which this cookie should be presented.
     *
     * &lt;p&gt; The form of the domain name is specified by RFC 2965. A domain
     * name begins with a dot ({@code .foo.com}) and means that
     * the cookie is visible to servers in a specified Domain Name System
     * (DNS) zone (for example, {@code www.foo.com}, but not
     * {@code a.b.foo.com}). By default, cookies are only returned
     * to the server that sent them.
     *
     * @param  pattern
     *         a {@code String} containing the domain name within which this
     *         cookie is visible; form is according to RFC 2965
     *
     * @see  #getDomain
     */
    public void setDomain(String pattern) {
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">        if (pattern != null)</span>
<span class="fc" id="L363">            domain = pattern.toLowerCase();</span>
        else
<span class="nc" id="L365">            domain = pattern;</span>
<span class="fc" id="L366">    }</span>

    /**
     * Returns the domain name set for this cookie. The form of the domain name
     * is set by RFC 2965.
     *
     * @return  a {@code String} containing the domain name
     *
     * @see  #setDomain
     */
    public String getDomain() {
<span class="fc" id="L377">        return domain;</span>
    }

    /**
     * Sets the maximum age of the cookie in seconds.
     *
     * &lt;p&gt; A positive value indicates that the cookie will expire
     * after that many seconds have passed. Note that the value is
     * the &lt;i&gt;maximum&lt;/i&gt; age when the cookie will expire, not the cookie's
     * current age.
     *
     * &lt;p&gt; A negative value means that the cookie is not stored persistently
     * and will be deleted when the Web browser exits. A zero value causes the
     * cookie to be deleted.
     *
     * @param  expiry
     *         an integer specifying the maximum age of the cookie in seconds;
     *         if zero, the cookie should be discarded immediately; otherwise,
     *         the cookie's max age is unspecified.
     *
     * @see  #getMaxAge
     */
    public void setMaxAge(long expiry) {
<span class="fc" id="L400">        maxAge = expiry;</span>
<span class="fc" id="L401">    }</span>

    /**
     * Returns the maximum age of the cookie, specified in seconds. By default,
     * {@code -1} indicating the cookie will persist until browser shutdown.
     *
     * @return  an integer specifying the maximum age of the cookie in seconds
     *
     * @see  #setMaxAge
     */
    public long getMaxAge() {
<span class="fc" id="L412">        return maxAge;</span>
    }

    /**
     * Specifies a path for the cookie to which the client should return
     * the cookie.
     *
     * &lt;p&gt; The cookie is visible to all the pages in the directory
     * you specify, and all the pages in that directory's subdirectories.
     * A cookie's path must include the servlet that set the cookie,
     * for example, &lt;i&gt;/catalog&lt;/i&gt;, which makes the cookie
     * visible to all directories on the server under &lt;i&gt;/catalog&lt;/i&gt;.
     *
     * &lt;p&gt; Consult RFC 2965 (available on the Internet) for more
     * information on setting path names for cookies.
     *
     * @param  uri
     *         a {@code String} specifying a path
     *
     * @see  #getPath
     */
    public void setPath(String uri) {
<span class="fc" id="L434">        path = uri;</span>
<span class="fc" id="L435">    }</span>

    /**
     * Returns the path on the server to which the browser returns this cookie.
     * The cookie is visible to all subpaths on the server.
     *
     * @return  a {@code String} specifying a path that contains a servlet name,
     *          for example, &lt;i&gt;/catalog&lt;/i&gt;
     *
     * @see  #setPath
     */
    public String getPath() {
<span class="fc" id="L447">        return path;</span>
    }

    /**
     * Indicates whether the cookie should only be sent using a secure protocol,
     * such as HTTPS or SSL.
     *
     * &lt;p&gt; The default value is {@code false}.
     *
     * @param  flag
     *         If {@code true}, the cookie can only be sent over a secure
     *         protocol like HTTPS. If {@code false}, it can be sent over
     *         any protocol.
     *
     * @see  #getSecure
     */
    public void setSecure(boolean flag) {
<span class="fc" id="L464">        secure = flag;</span>
<span class="fc" id="L465">    }</span>

    /**
     * Returns {@code true} if sending this cookie should be restricted to a
     * secure protocol, or {@code false} if the it can be sent using any
     * protocol.
     *
     * @return  {@code false} if the cookie can be sent over any standard
     *          protocol; otherwise, {@code true}
     *
     * @see  #setSecure
     */
    public boolean getSecure() {
<span class="fc" id="L478">        return secure;</span>
    }

    /**
     * Returns the name of the cookie. The name cannot be changed after
     * creation.
     *
     * @return  a {@code String} specifying the cookie's name
     */
    public String getName() {
<span class="fc" id="L488">        return name;</span>
    }

    /**
     * Assigns a new value to a cookie after the cookie is created.
     * If you use a binary value, you may want to use BASE64 encoding.
     *
     * &lt;p&gt; With Version 0 cookies, values should not contain white space,
     * brackets, parentheses, equals signs, commas, double quotes, slashes,
     * question marks, at signs, colons, and semicolons. Empty values may not
     * behave the same way on all browsers.
     *
     * @param  newValue
     *         a {@code String} specifying the new value
     *
     * @see  #getValue
     */
    public void setValue(String newValue) {
<span class="nc" id="L506">        value = newValue;</span>
<span class="nc" id="L507">    }</span>

    /**
     * Returns the value of the cookie.
     *
     * @return  a {@code String} containing the cookie's present value
     *
     * @see  #setValue
     */
    public String getValue() {
<span class="fc" id="L517">        return value;</span>
    }

    /**
     * Returns the version of the protocol this cookie complies with. Version 1
     * complies with RFC 2965/2109, and version 0 complies with the original
     * cookie specification drafted by Netscape. Cookies provided by a browser
     * use and identify the browser's cookie version.
     *
     * @return  0 if the cookie complies with the original Netscape
     *          specification; 1 if the cookie complies with RFC 2965/2109
     *
     * @see  #setVersion
     */
    public int getVersion() {
<span class="fc" id="L532">        return version;</span>
    }

    /**
     * Sets the version of the cookie protocol this cookie complies
     * with. Version 0 complies with the original Netscape cookie
     * specification. Version 1 complies with RFC 2965/2109.
     *
     * @param  v
     *         0 if the cookie should comply with the original Netscape
     *         specification; 1 if the cookie should comply with RFC 2965/2109
     *
     * @throws  IllegalArgumentException
     *          if {@code v} is neither 0 nor 1
     *
     * @see  #getVersion
     */
    public void setVersion(int v) {
<span class="pc bpc" id="L550" title="1 of 4 branches missed.">        if (v != 0 &amp;&amp; v != 1) {</span>
<span class="nc" id="L551">            throw new IllegalArgumentException(&quot;cookie version should be 0 or 1&quot;);</span>
        }

<span class="fc" id="L554">        version = v;</span>
<span class="fc" id="L555">    }</span>

    /**
     * Returns {@code true} if this cookie contains the &lt;i&gt;HttpOnly&lt;/i&gt;
     * attribute. This means that the cookie should not be accessible to
     * scripting engines, like javascript.
     *
     * @return  {@code true} if this cookie should be considered HTTPOnly
     *
     * @see  #setHttpOnly(boolean)
     */
    public boolean isHttpOnly() {
<span class="fc" id="L567">        return httpOnly;</span>
    }

    /**
     * Indicates whether the cookie should be considered HTTP Only. If set to
     * {@code true} it means the cookie should not be accessible to scripting
     * engines like javascript.
     *
     * @param  httpOnly
     *         if {@code true} make the cookie HTTP only, i.e. only visible as
     *         part of an HTTP request.
     *
     * @see  #isHttpOnly()
     */
    public void setHttpOnly(boolean httpOnly) {
<span class="fc" id="L582">        this.httpOnly = httpOnly;</span>
<span class="fc" id="L583">    }</span>

    /**
     * The utility method to check whether a host name is in a domain or not.
     *
     * &lt;p&gt; This concept is described in the cookie specification.
     * To understand the concept, some terminologies need to be defined first:
     * &lt;blockquote&gt;
     * effective host name = hostname if host name contains dot&lt;br&gt;
     * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
     * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;or = hostname.local if not
     * &lt;/blockquote&gt;
     * &lt;p&gt;Host A's name domain-matches host B's if:
     * &lt;blockquote&gt;&lt;ul&gt;
     *   &lt;li&gt;their host name strings string-compare equal; or&lt;/li&gt;
     *   &lt;li&gt;A is a HDN string and has the form NB, where N is a non-empty
     *   name string, B has the form .B', and B' is a HDN string.  (So,
     *   x.y.com domain-matches .Y.com but not Y.com.)&lt;/li&gt;
     * &lt;/ul&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt;A host isn't in a domain (RFC 2965 sec. 3.3.2) if:
     * &lt;blockquote&gt;&lt;ul&gt;
     *   &lt;li&gt;The value for the Domain attribute contains no embedded dots,
     *   and the value is not .local.&lt;/li&gt;
     *   &lt;li&gt;The effective host name that derives from the request-host does
     *   not domain-match the Domain attribute.&lt;/li&gt;
     *   &lt;li&gt;The request-host is a HDN (not IP address) and has the form HD,
     *   where D is the value of the Domain attribute, and H is a string
     *   that contains one or more dots.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt;Examples:
     * &lt;blockquote&gt;&lt;ul&gt;
     *   &lt;li&gt;A Set-Cookie2 from request-host y.x.foo.com for Domain=.foo.com
     *   would be rejected, because H is y.x and contains a dot.&lt;/li&gt;
     *   &lt;li&gt;A Set-Cookie2 from request-host x.foo.com for Domain=.foo.com
     *   would be accepted.&lt;/li&gt;
     *   &lt;li&gt;A Set-Cookie2 with Domain=.com or Domain=.com., will always be
     *   rejected, because there is no embedded dot.&lt;/li&gt;
     *   &lt;li&gt;A Set-Cookie2 from request-host example for Domain=.local will
     *   be accepted, because the effective host name for the request-
     *   host is example.local, and example.local domain-matches .local.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/blockquote&gt;
     *
     * @param  domain
     *         the domain name to check host name with
     *
     * @param  host
     *         the host name in question
     *
     * @return  {@code true} if they domain-matches; {@code false} if not
     */
    public static boolean domainMatches(String domain, String host) {
<span class="pc bpc" id="L636" title="2 of 4 branches missed.">        if (domain == null || host == null)</span>
<span class="nc" id="L637">            return false;</span>

        // if there's no embedded dot in domain and domain is not .local
<span class="fc" id="L640">        boolean isLocalDomain = &quot;.local&quot;.equalsIgnoreCase(domain);</span>
<span class="fc" id="L641">        int embeddedDotInDomain = domain.indexOf('.');</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">        if (embeddedDotInDomain == 0)</span>
<span class="fc" id="L643">            embeddedDotInDomain = domain.indexOf('.', 1);</span>
<span class="pc bpc" id="L644" title="2 of 4 branches missed.">        if (!isLocalDomain</span>
            &amp;&amp; (embeddedDotInDomain == -1 ||
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">                embeddedDotInDomain == domain.length() - 1))</span>
<span class="nc" id="L647">            return false;</span>

        // if the host name contains no dot and the domain name
        // is .local or host.local
<span class="fc" id="L651">        int firstDotInHost = host.indexOf('.');</span>
<span class="pc bpc" id="L652" title="1 of 4 branches missed.">        if (firstDotInHost == -1 &amp;&amp;</span>
            (isLocalDomain ||
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">             domain.equalsIgnoreCase(host + &quot;.local&quot;))) {</span>
<span class="fc" id="L655">            return true;</span>
        }

<span class="fc" id="L658">        int domainLength = domain.length();</span>
<span class="fc" id="L659">        int lengthDiff = host.length() - domainLength;</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">        if (lengthDiff == 0) {</span>
            // if the host name and the domain name are just string-compare euqal
<span class="fc" id="L662">            return host.equalsIgnoreCase(domain);</span>
        }
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">        else if (lengthDiff &gt; 0) {</span>
            // need to check H &amp; D component
<span class="nc" id="L666">            String H = host.substring(0, lengthDiff);</span>
<span class="nc" id="L667">            String D = host.substring(lengthDiff);</span>

<span class="nc bnc" id="L669" title="All 4 branches missed.">            return (H.indexOf('.') == -1 &amp;&amp; D.equalsIgnoreCase(domain));</span>
        }
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        else if (lengthDiff == -1) {</span>
            // if domain is actually .host
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">            return (domain.charAt(0) == '.' &amp;&amp;</span>
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">                        host.equalsIgnoreCase(domain.substring(1)));</span>
        }

<span class="nc" id="L677">        return false;</span>
    }

    /**
     * Constructs a cookie header string representation of this cookie,
     * which is in the format defined by corresponding cookie specification,
     * but without the leading &quot;Cookie:&quot; token.
     *
     * @return  a string form of the cookie. The string has the defined format
     */
    @Override
    public String toString() {
<span class="fc bfc" id="L689" title="All 2 branches covered.">        if (getVersion() &gt; 0) {</span>
<span class="fc" id="L690">            return toRFC2965HeaderString();</span>
        } else {
<span class="fc" id="L692">            return toNetscapeHeaderString();</span>
        }
    }

    /**
     * Test the equality of two HTTP cookies.
     *
     * &lt;p&gt; The result is {@code true} only if two cookies come from same domain
     * (case-insensitive), have same name (case-insensitive), and have same path
     * (case-sensitive).
     *
     * @return  {@code true} if two HTTP cookies equal to each other;
     *          otherwise, {@code false}
     */
    @Override
    public boolean equals(Object obj) {
<span class="fc bfc" id="L708" title="All 2 branches covered.">        if (obj == this)</span>
<span class="fc" id="L709">            return true;</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">        if (!(obj instanceof HttpCookie))</span>
<span class="nc" id="L711">            return false;</span>
<span class="fc" id="L712">        HttpCookie other = (HttpCookie)obj;</span>

        // One http cookie equals to another cookie (RFC 2965 sec. 3.3.3) if:
        //   1. they come from same domain (case-insensitive),
        //   2. have same name (case-insensitive),
        //   3. and have same path (case-sensitive).
<span class="fc bfc" id="L718" title="All 2 branches covered.">        return equalsIgnoreCase(getName(), other.getName()) &amp;&amp;</span>
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">               equalsIgnoreCase(getDomain(), other.getDomain()) &amp;&amp;</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">               Objects.equals(getPath(), other.getPath());</span>
    }

    /**
     * Returns the hash code of this HTTP cookie. The result is the sum of
     * hash code value of three significant components of this cookie: name,
     * domain, and path. That is, the hash code is the value of the expression:
     * &lt;blockquote&gt;
     * getName().toLowerCase().hashCode()&lt;br&gt;
     * + getDomain().toLowerCase().hashCode()&lt;br&gt;
     * + getPath().hashCode()
     * &lt;/blockquote&gt;
     *
     * @return  this HTTP cookie's hash code
     */
    @Override
    public int hashCode() {
<span class="nc" id="L737">        int h1 = name.toLowerCase().hashCode();</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">        int h2 = (domain!=null) ? domain.toLowerCase().hashCode() : 0;</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">        int h3 = (path!=null) ? path.hashCode() : 0;</span>

<span class="nc" id="L741">        return h1 + h2 + h3;</span>
    }

    /**
     * Create and return a copy of this object.
     *
     * @return  a clone of this HTTP cookie
     */
    @Override
    public Object clone() {
        try {
<span class="nc" id="L752">            return super.clone();</span>
<span class="nc" id="L753">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L754">            throw new RuntimeException(e.getMessage());</span>
        }
    }

    // ---------------- Private operations --------------

    // Note -- disabled for now to allow full Netscape compatibility
    // from RFC 2068, token special case characters
    //
    // private static final String tspecials = &quot;()&lt;&gt;@,;:\\\&quot;/[]?={} \t&quot;;
    private static final String tspecials = &quot;,; &quot;;  // deliberately includes space

    /*
     * Tests a string and returns true if the string counts as a token.
     *
     * @param  value
     *         the {@code String} to be tested
     *
     * @return  {@code true} if the {@code String} is a token;
     *          {@code false} if it is not
     */
    private static boolean isToken(String value) {
<span class="fc" id="L776">        int len = value.length();</span>

<span class="fc bfc" id="L778" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L779">            char c = value.charAt(i);</span>

<span class="pc bpc" id="L781" title="3 of 6 branches missed.">            if (c &lt; 0x20 || c &gt;= 0x7f || tspecials.indexOf(c) != -1)</span>
<span class="nc" id="L782">                return false;</span>
        }
<span class="fc" id="L784">        return true;</span>
    }

    /*
     * Parse header string to cookie object.
     *
     * @param  header
     *         header string; should contain only one NAME=VALUE pair
     *
     * @return  an HttpCookie being extracted
     *
     * @throws  IllegalArgumentException
     *          if header string violates the cookie specification
     */
    private static HttpCookie parseInternal(String header,
                                            boolean retainHeader)
    {
<span class="fc" id="L801">        HttpCookie cookie = null;</span>
<span class="fc" id="L802">        String namevaluePair = null;</span>

<span class="fc" id="L804">        StringTokenizer tokenizer = new StringTokenizer(header, &quot;;&quot;);</span>

        // there should always have at least on name-value pair;
        // it's cookie's name
        try {
<span class="fc" id="L809">            namevaluePair = tokenizer.nextToken();</span>
<span class="fc" id="L810">            int index = namevaluePair.indexOf('=');</span>
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">            if (index != -1) {</span>
<span class="fc" id="L812">                String name = namevaluePair.substring(0, index).trim();</span>
<span class="fc" id="L813">                String value = namevaluePair.substring(index + 1).trim();</span>
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">                if (retainHeader)</span>
<span class="nc" id="L815">                    cookie = new HttpCookie(name,</span>
<span class="nc" id="L816">                                            stripOffSurroundingQuote(value),</span>
                                            header);
                else
<span class="fc" id="L819">                    cookie = new HttpCookie(name,</span>
<span class="fc" id="L820">                                            stripOffSurroundingQuote(value));</span>
<span class="fc" id="L821">            } else {</span>
                // no &quot;=&quot; in name-value pair; it's an error
<span class="nc" id="L823">                throw new IllegalArgumentException(&quot;Invalid cookie name-value pair&quot;);</span>
            }
<span class="nc" id="L825">        } catch (NoSuchElementException ignored) {</span>
<span class="nc" id="L826">            throw new IllegalArgumentException(&quot;Empty cookie header string&quot;);</span>
<span class="fc" id="L827">        }</span>

        // remaining name-value pairs are cookie's attributes
<span class="fc bfc" id="L830" title="All 2 branches covered.">        while (tokenizer.hasMoreTokens()) {</span>
<span class="fc" id="L831">            namevaluePair = tokenizer.nextToken();</span>
<span class="fc" id="L832">            int index = namevaluePair.indexOf('=');</span>
            String name, value;
<span class="fc bfc" id="L834" title="All 2 branches covered.">            if (index != -1) {</span>
<span class="fc" id="L835">                name = namevaluePair.substring(0, index).trim();</span>
<span class="fc" id="L836">                value = namevaluePair.substring(index + 1).trim();</span>
            } else {
<span class="fc" id="L838">                name = namevaluePair.trim();</span>
<span class="fc" id="L839">                value = null;</span>
            }

            // assign attribute to cookie
<span class="fc" id="L843">            assignAttribute(cookie, name, value);</span>
<span class="fc" id="L844">        }</span>

<span class="fc" id="L846">        return cookie;</span>
    }

    /*
     * assign cookie attribute value to attribute name;
     * use a map to simulate method dispatch
     */
    static interface CookieAttributeAssignor {
            public void assign(HttpCookie cookie,
                               String attrName,
                               String attrValue);
    }
<span class="fc" id="L858">    static final java.util.Map&lt;String, CookieAttributeAssignor&gt; assignors =</span>
            new java.util.HashMap&lt;&gt;();
    static {
<span class="fc" id="L861">        assignors.put(&quot;comment&quot;, new CookieAttributeAssignor() {</span>
                public void assign(HttpCookie cookie,
                                   String attrName,
                                   String attrValue) {
<span class="nc bnc" id="L865" title="All 2 branches missed.">                    if (cookie.getComment() == null)</span>
<span class="nc" id="L866">                        cookie.setComment(attrValue);</span>
<span class="nc" id="L867">                }</span>
            });
<span class="fc" id="L869">        assignors.put(&quot;commenturl&quot;, new CookieAttributeAssignor() {</span>
                public void assign(HttpCookie cookie,
                                   String attrName,
                                   String attrValue) {
<span class="nc bnc" id="L873" title="All 2 branches missed.">                    if (cookie.getCommentURL() == null)</span>
<span class="nc" id="L874">                        cookie.setCommentURL(attrValue);</span>
<span class="nc" id="L875">                }</span>
            });
<span class="fc" id="L877">        assignors.put(&quot;discard&quot;, new CookieAttributeAssignor() {</span>
                public void assign(HttpCookie cookie,
                                   String attrName,
                                   String attrValue) {
<span class="nc" id="L881">                    cookie.setDiscard(true);</span>
<span class="nc" id="L882">                }</span>
            });
<span class="fc" id="L884">        assignors.put(&quot;domain&quot;, new CookieAttributeAssignor(){</span>
                public void assign(HttpCookie cookie,
                                   String attrName,
                                   String attrValue) {
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">                    if (cookie.getDomain() == null)</span>
<span class="fc" id="L889">                        cookie.setDomain(attrValue);</span>
<span class="fc" id="L890">                }</span>
            });
<span class="fc" id="L892">        assignors.put(&quot;max-age&quot;, new CookieAttributeAssignor(){</span>
                public void assign(HttpCookie cookie,
                                   String attrName,
                                   String attrValue) {
                    try {
<span class="nc" id="L897">                        long maxage = Long.parseLong(attrValue);</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">                        if (cookie.getMaxAge() == MAX_AGE_UNSPECIFIED)</span>
<span class="nc" id="L899">                            cookie.setMaxAge(maxage);</span>
<span class="nc" id="L900">                    } catch (NumberFormatException ignored) {</span>
<span class="nc" id="L901">                        throw new IllegalArgumentException(</span>
                                &quot;Illegal cookie max-age attribute&quot;);
<span class="nc" id="L903">                    }</span>
<span class="nc" id="L904">                }</span>
            });
<span class="fc" id="L906">        assignors.put(&quot;path&quot;, new CookieAttributeAssignor(){</span>
                public void assign(HttpCookie cookie,
                                   String attrName,
                                   String attrValue) {
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">                    if (cookie.getPath() == null)</span>
<span class="fc" id="L911">                        cookie.setPath(attrValue);</span>
<span class="fc" id="L912">                }</span>
            });
<span class="fc" id="L914">        assignors.put(&quot;port&quot;, new CookieAttributeAssignor(){</span>
                public void assign(HttpCookie cookie,
                                   String attrName,
                                   String attrValue) {
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">                    if (cookie.getPortlist() == null)</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">                        cookie.setPortlist(attrValue == null ? &quot;&quot; : attrValue);</span>
<span class="fc" id="L920">                }</span>
            });
<span class="fc" id="L922">        assignors.put(&quot;secure&quot;, new CookieAttributeAssignor(){</span>
                public void assign(HttpCookie cookie,
                                   String attrName,
                                   String attrValue) {
<span class="fc" id="L926">                    cookie.setSecure(true);</span>
<span class="fc" id="L927">                }</span>
            });
<span class="fc" id="L929">        assignors.put(&quot;httponly&quot;, new CookieAttributeAssignor(){</span>
                public void assign(HttpCookie cookie,
                                   String attrName,
                                   String attrValue) {
<span class="fc" id="L933">                    cookie.setHttpOnly(true);</span>
<span class="fc" id="L934">                }</span>
            });
<span class="fc" id="L936">        assignors.put(&quot;version&quot;, new CookieAttributeAssignor(){</span>
                public void assign(HttpCookie cookie,
                                   String attrName,
                                   String attrValue) {
                    try {
<span class="fc" id="L941">                        int version = Integer.parseInt(attrValue);</span>
<span class="fc" id="L942">                        cookie.setVersion(version);</span>
<span class="nc" id="L943">                    } catch (NumberFormatException ignored) {</span>
                        // Just ignore bogus version, it will default to 0 or 1
<span class="fc" id="L945">                    }</span>
<span class="fc" id="L946">                }</span>
            });
<span class="fc" id="L948">        assignors.put(&quot;expires&quot;, new CookieAttributeAssignor(){ // Netscape only</span>
                public void assign(HttpCookie cookie,
                                   String attrName,
                                   String attrValue) {
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">                    if (cookie.getMaxAge() == MAX_AGE_UNSPECIFIED) {</span>
<span class="fc" id="L953">                        cookie.setMaxAge(cookie.expiryDate2DeltaSeconds(attrValue));</span>
                    }
<span class="fc" id="L955">                }</span>
            });
    }
    private static void assignAttribute(HttpCookie cookie,
                                        String attrName,
                                        String attrValue)
    {
        // strip off the surrounding &quot;-sign if there's any
<span class="fc" id="L963">        attrValue = stripOffSurroundingQuote(attrValue);</span>

<span class="fc" id="L965">        CookieAttributeAssignor assignor = assignors.get(attrName.toLowerCase());</span>
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">        if (assignor != null) {</span>
<span class="fc" id="L967">            assignor.assign(cookie, attrName, attrValue);</span>
        } else {
            // Ignore the attribute as per RFC 2965
        }
<span class="fc" id="L971">    }</span>

    static {
<span class="fc" id="L974">        sun.misc.SharedSecrets.setJavaNetHttpCookieAccess(</span>
<span class="fc" id="L975">            new sun.misc.JavaNetHttpCookieAccess() {</span>
                public List&lt;HttpCookie&gt; parse(String header) {
<span class="nc" id="L977">                    return HttpCookie.parse(header, true);</span>
                }

                public String header(HttpCookie cookie) {
<span class="nc" id="L981">                    return cookie.header;</span>
                }
            }
        );
    }

    /*
     * Returns the original header this cookie was consructed from, if it was
     * constructed by parsing a header, otherwise null.
     */
    private String header() {
<span class="nc" id="L992">        return header;</span>
    }

    /*
     * Constructs a string representation of this cookie. The string format is
     * as Netscape spec, but without leading &quot;Cookie:&quot; token.
     */
    private String toNetscapeHeaderString() {
<span class="fc" id="L1000">        return getName() + &quot;=&quot; + getValue();</span>
    }

    /*
     * Constructs a string representation of this cookie. The string format is
     * as RFC 2965/2109, but without leading &quot;Cookie:&quot; token.
     */
    private String toRFC2965HeaderString() {
<span class="fc" id="L1008">        StringBuilder sb = new StringBuilder();</span>

<span class="fc" id="L1010">        sb.append(getName()).append(&quot;=\&quot;&quot;).append(getValue()).append('&quot;');</span>
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">        if (getPath() != null)</span>
<span class="fc" id="L1012">            sb.append(&quot;;$Path=\&quot;&quot;).append(getPath()).append('&quot;');</span>
<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">        if (getDomain() != null)</span>
<span class="fc" id="L1014">            sb.append(&quot;;$Domain=\&quot;&quot;).append(getDomain()).append('&quot;');</span>
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">        if (getPortlist() != null)</span>
<span class="nc" id="L1016">            sb.append(&quot;;$Port=\&quot;&quot;).append(getPortlist()).append('&quot;');</span>

<span class="fc" id="L1018">        return sb.toString();</span>
    }

<span class="fc" id="L1021">    static final TimeZone GMT = TimeZone.getTimeZone(&quot;GMT&quot;);</span>

    /*
     * @param  dateString
     *         a date string in one of the formats defined in Netscape cookie spec
     *
     * @return  delta seconds between this cookie's creation time and the time
     *          specified by dateString
     */
    private long expiryDate2DeltaSeconds(String dateString) {
<span class="fc" id="L1031">        Calendar cal = new GregorianCalendar(GMT);</span>
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">        for (int i = 0; i &lt; COOKIE_DATE_FORMATS.length; i++) {</span>
<span class="fc" id="L1033">            SimpleDateFormat df = new SimpleDateFormat(COOKIE_DATE_FORMATS[i],</span>
                                                       Locale.US);
<span class="fc" id="L1035">            cal.set(1970, 0, 1, 0, 0, 0);</span>
<span class="fc" id="L1036">            df.setTimeZone(GMT);</span>
<span class="fc" id="L1037">            df.setLenient(false);</span>
<span class="fc" id="L1038">            df.set2DigitYearStart(cal.getTime());</span>
            try {
<span class="fc" id="L1040">                cal.setTime(df.parse(dateString));</span>
<span class="pc bpc" id="L1041" title="1 of 2 branches missed.">                if (!COOKIE_DATE_FORMATS[i].contains(&quot;yyyy&quot;)) {</span>
                    // 2-digit years following the standard set
                    // out it rfc 6265
<span class="nc" id="L1044">                    int year = cal.get(Calendar.YEAR);</span>
<span class="nc" id="L1045">                    year %= 100;</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">                    if (year &lt; 70) {</span>
<span class="nc" id="L1047">                        year += 2000;</span>
                    } else {
<span class="nc" id="L1049">                        year += 1900;</span>
                    }
<span class="nc" id="L1051">                    cal.set(Calendar.YEAR, year);</span>
                }
<span class="fc" id="L1053">                return (cal.getTimeInMillis() - whenCreated) / 1000;</span>
<span class="fc" id="L1054">            } catch (Exception e) {</span>
                // Ignore, try the next date format
            }
        }
<span class="nc" id="L1058">        return 0;</span>
    }

    /*
     * try to guess the cookie version through set-cookie header string
     */
    private static int guessCookieVersion(String header) {
<span class="fc" id="L1065">        int version = 0;</span>

<span class="fc" id="L1067">        header = header.toLowerCase();</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">        if (header.indexOf(&quot;expires=&quot;) != -1) {</span>
            // only netscape cookie using 'expires'
<span class="fc" id="L1070">            version = 0;</span>
<span class="fc bfc" id="L1071" title="All 2 branches covered.">        } else if (header.indexOf(&quot;version=&quot;) != -1) {</span>
            // version is mandatory for rfc 2965/2109 cookie
<span class="fc" id="L1073">            version = 1;</span>
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">        } else if (header.indexOf(&quot;max-age&quot;) != -1) {</span>
            // rfc 2965/2109 use 'max-age'
<span class="nc" id="L1076">            version = 1;</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">        } else if (startsWithIgnoreCase(header, SET_COOKIE2)) {</span>
            // only rfc 2965 cookie starts with 'set-cookie2'
<span class="nc" id="L1079">            version = 1;</span>
        }

<span class="fc" id="L1082">        return version;</span>
    }

    private static String stripOffSurroundingQuote(String str) {
<span class="fc bfc" id="L1086" title="All 4 branches covered.">        if (str != null &amp;&amp; str.length() &gt; 2 &amp;&amp;</span>
<span class="pc bpc" id="L1087" title="1 of 4 branches missed.">            str.charAt(0) == '&quot;' &amp;&amp; str.charAt(str.length() - 1) == '&quot;') {</span>
<span class="fc" id="L1088">            return str.substring(1, str.length() - 1);</span>
        }
<span class="fc bfc" id="L1090" title="All 4 branches covered.">        if (str != null &amp;&amp; str.length() &gt; 2 &amp;&amp;</span>
<span class="pc bpc" id="L1091" title="3 of 4 branches missed.">            str.charAt(0) == '\'' &amp;&amp; str.charAt(str.length() - 1) == '\'') {</span>
<span class="nc" id="L1092">            return str.substring(1, str.length() - 1);</span>
        }
<span class="fc" id="L1094">        return str;</span>
    }

    private static boolean equalsIgnoreCase(String s, String t) {
<span class="pc bpc" id="L1098" title="1 of 2 branches missed.">        if (s == t) return true;</span>
<span class="pc bpc" id="L1099" title="2 of 4 branches missed.">        if ((s != null) &amp;&amp; (t != null)) {</span>
<span class="fc" id="L1100">            return s.equalsIgnoreCase(t);</span>
        }
<span class="nc" id="L1102">        return false;</span>
    }

    private static boolean startsWithIgnoreCase(String s, String start) {
<span class="pc bpc" id="L1106" title="2 of 4 branches missed.">        if (s == null || start == null) return false;</span>

<span class="fc bfc" id="L1108" title="All 2 branches covered.">        if (s.length() &gt;= start.length() &amp;&amp;</span>
<span class="fc bfc" id="L1109" title="All 2 branches covered.">                start.equalsIgnoreCase(s.substring(0, start.length()))) {</span>
<span class="fc" id="L1110">            return true;</span>
        }

<span class="fc" id="L1113">        return false;</span>
    }

    /*
     * Split cookie header string according to rfc 2965:
     *   1) split where it is a comma;
     *   2) but not the comma surrounding by double-quotes, which is the comma
     *      inside port list or embeded URIs.
     *
     * @param  header
     *         the cookie header string to split
     *
     * @return  list of strings; never null
     */
    private static List&lt;String&gt; splitMultiCookies(String header) {
<span class="fc" id="L1128">        List&lt;String&gt; cookies = new java.util.ArrayList&lt;String&gt;();</span>
<span class="fc" id="L1129">        int quoteCount = 0;</span>
        int p, q;

<span class="fc bfc" id="L1132" title="All 2 branches covered.">        for (p = 0, q = 0; p &lt; header.length(); p++) {</span>
<span class="fc" id="L1133">            char c = header.charAt(p);</span>
<span class="fc bfc" id="L1134" title="All 2 branches covered.">            if (c == '&quot;') quoteCount++;</span>
<span class="pc bpc" id="L1135" title="3 of 4 branches missed.">            if (c == ',' &amp;&amp; (quoteCount % 2 == 0)) {</span>
                // it is comma and not surrounding by double-quotes
<span class="nc" id="L1137">                cookies.add(header.substring(q, p));</span>
<span class="nc" id="L1138">                q = p + 1;</span>
            }
        }

<span class="fc" id="L1142">        cookies.add(header.substring(q));</span>

<span class="fc" id="L1144">        return cookies;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>