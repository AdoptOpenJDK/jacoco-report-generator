<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ServerSocket.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">ServerSocket.java</span></div><h1>ServerSocket.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.io.FileDescriptor;
import java.io.IOException;
import java.nio.channels.ServerSocketChannel;
import java.security.AccessController;
import java.security.PrivilegedExceptionAction;

/**
 * This class implements server sockets. A server socket waits for
 * requests to come in over the network. It performs some operation
 * based on that request, and then possibly returns a result to the requester.
 * &lt;p&gt;
 * The actual work of the server socket is performed by an instance
 * of the {@code SocketImpl} class. An application can
 * change the socket factory that creates the socket
 * implementation to configure itself to create sockets
 * appropriate to the local firewall.
 *
 * @author  unascribed
 * @see     java.net.SocketImpl
 * @see     java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
 * @see     java.nio.channels.ServerSocketChannel
 * @since   JDK1.0
 */
public
class ServerSocket implements java.io.Closeable {
    /**
     * Various states of this socket.
     */
<span class="pc" id="L56">    private boolean created = false;</span>
<span class="pc" id="L57">    private boolean bound = false;</span>
<span class="pc" id="L58">    private boolean closed = false;</span>
<span class="pc" id="L59">    private Object closeLock = new Object();</span>

    /**
     * The implementation of this Socket.
     */
    private SocketImpl impl;

    /**
     * Are we using an older SocketImpl?
     */
<span class="pc" id="L69">    private boolean oldImpl = false;</span>

    /**
     * Package-private constructor to create a ServerSocket associated with
     * the given SocketImpl.
     */
<span class="nc" id="L75">    ServerSocket(SocketImpl impl) {</span>
<span class="nc" id="L76">        this.impl = impl;</span>
<span class="nc" id="L77">        impl.setServerSocket(this);</span>
<span class="nc" id="L78">    }</span>

    /**
     * Creates an unbound server socket.
     *
     * @exception IOException IO error when opening the socket.
     * @revised 1.4
     */
<span class="fc" id="L86">    public ServerSocket() throws IOException {</span>
<span class="fc" id="L87">        setImpl();</span>
<span class="fc" id="L88">    }</span>

    /**
     * Creates a server socket, bound to the specified port. A port number
     * of {@code 0} means that the port number is automatically
     * allocated, typically from an ephemeral port range. This port
     * number can then be retrieved by calling {@link #getLocalPort getLocalPort}.
     * &lt;p&gt;
     * The maximum queue length for incoming connection indications (a
     * request to connect) is set to {@code 50}. If a connection
     * indication arrives when the queue is full, the connection is refused.
     * &lt;p&gt;
     * If the application has specified a server socket factory, that
     * factory's {@code createSocketImpl} method is called to create
     * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.
     * &lt;p&gt;
     * If there is a security manager,
     * its {@code checkListen} method is called
     * with the {@code port} argument
     * as its argument to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     *
     * @param      port  the port number, or {@code 0} to use a port
     *                   number that is automatically allocated.
     *
     * @exception  IOException  if an I/O error occurs when opening the socket.
     * @exception  SecurityException
     * if a security manager exists and its {@code checkListen}
     * method doesn't allow the operation.
     * @exception  IllegalArgumentException if the port parameter is outside
     *             the specified range of valid port values, which is between
     *             0 and 65535, inclusive.
     *
     * @see        java.net.SocketImpl
     * @see        java.net.SocketImplFactory#createSocketImpl()
     * @see        java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
     * @see        SecurityManager#checkListen
     */
    public ServerSocket(int port) throws IOException {
<span class="fc" id="L128">        this(port, 50, null);</span>
<span class="fc" id="L129">    }</span>

    /**
     * Creates a server socket and binds it to the specified local port
     * number, with the specified backlog.
     * A port number of {@code 0} means that the port number is
     * automatically allocated, typically from an ephemeral port range.
     * This port number can then be retrieved by calling
     * {@link #getLocalPort getLocalPort}.
     * &lt;p&gt;
     * The maximum queue length for incoming connection indications (a
     * request to connect) is set to the {@code backlog} parameter. If
     * a connection indication arrives when the queue is full, the
     * connection is refused.
     * &lt;p&gt;
     * If the application has specified a server socket factory, that
     * factory's {@code createSocketImpl} method is called to create
     * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.
     * &lt;p&gt;
     * If there is a security manager,
     * its {@code checkListen} method is called
     * with the {@code port} argument
     * as its argument to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * The {@code backlog} argument is the requested maximum number of
     * pending connections on the socket. Its exact semantics are implementation
     * specific. In particular, an implementation may impose a maximum length
     * or may choose to ignore the parameter altogther. The value provided
     * should be greater than {@code 0}. If it is less than or equal to
     * {@code 0}, then an implementation specific default will be used.
     * &lt;P&gt;
     *
     * @param      port     the port number, or {@code 0} to use a port
     *                      number that is automatically allocated.
     * @param      backlog  requested maximum length of the queue of incoming
     *                      connections.
     *
     * @exception  IOException  if an I/O error occurs when opening the socket.
     * @exception  SecurityException
     * if a security manager exists and its {@code checkListen}
     * method doesn't allow the operation.
     * @exception  IllegalArgumentException if the port parameter is outside
     *             the specified range of valid port values, which is between
     *             0 and 65535, inclusive.
     *
     * @see        java.net.SocketImpl
     * @see        java.net.SocketImplFactory#createSocketImpl()
     * @see        java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
     * @see        SecurityManager#checkListen
     */
    public ServerSocket(int port, int backlog) throws IOException {
<span class="fc" id="L181">        this(port, backlog, null);</span>
<span class="fc" id="L182">    }</span>

    /**
     * Create a server with the specified port, listen backlog, and
     * local IP address to bind to.  The &lt;i&gt;bindAddr&lt;/i&gt; argument
     * can be used on a multi-homed host for a ServerSocket that
     * will only accept connect requests to one of its addresses.
     * If &lt;i&gt;bindAddr&lt;/i&gt; is null, it will default accepting
     * connections on any/all local addresses.
     * The port must be between 0 and 65535, inclusive.
     * A port number of {@code 0} means that the port number is
     * automatically allocated, typically from an ephemeral port range.
     * This port number can then be retrieved by calling
     * {@link #getLocalPort getLocalPort}.
     *
     * &lt;P&gt;If there is a security manager, this method
     * calls its {@code checkListen} method
     * with the {@code port} argument
     * as its argument to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * The {@code backlog} argument is the requested maximum number of
     * pending connections on the socket. Its exact semantics are implementation
     * specific. In particular, an implementation may impose a maximum length
     * or may choose to ignore the parameter altogther. The value provided
     * should be greater than {@code 0}. If it is less than or equal to
     * {@code 0}, then an implementation specific default will be used.
     * &lt;P&gt;
     * @param port  the port number, or {@code 0} to use a port
     *              number that is automatically allocated.
     * @param backlog requested maximum length of the queue of incoming
     *                connections.
     * @param bindAddr the local InetAddress the server will bind to
     *
     * @throws  SecurityException if a security manager exists and
     * its {@code checkListen} method doesn't allow the operation.
     *
     * @throws  IOException if an I/O error occurs when opening the socket.
     * @exception  IllegalArgumentException if the port parameter is outside
     *             the specified range of valid port values, which is between
     *             0 and 65535, inclusive.
     *
     * @see SocketOptions
     * @see SocketImpl
     * @see SecurityManager#checkListen
     * @since   JDK1.1
     */
<span class="fc" id="L229">    public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException {</span>
<span class="fc" id="L230">        setImpl();</span>
<span class="pc bpc" id="L231" title="2 of 4 branches missed.">        if (port &lt; 0 || port &gt; 0xFFFF)</span>
<span class="nc" id="L232">            throw new IllegalArgumentException(</span>
                       &quot;Port value out of range: &quot; + port);
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (backlog &lt; 1)</span>
<span class="fc" id="L235">          backlog = 50;</span>
        try {
<span class="fc" id="L237">            bind(new InetSocketAddress(bindAddr, port), backlog);</span>
<span class="fc" id="L238">        } catch(SecurityException e) {</span>
<span class="fc" id="L239">            close();</span>
<span class="fc" id="L240">            throw e;</span>
<span class="fc" id="L241">        } catch(IOException e) {</span>
<span class="fc" id="L242">            close();</span>
<span class="fc" id="L243">            throw e;</span>
<span class="fc" id="L244">        }</span>
<span class="fc" id="L245">    }</span>

    /**
     * Get the {@code SocketImpl} attached to this socket, creating
     * it if necessary.
     *
     * @return  the {@code SocketImpl} attached to that ServerSocket.
     * @throws SocketException if creation fails.
     * @since 1.4
     */
    SocketImpl getImpl() throws SocketException {
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (!created)</span>
<span class="fc" id="L257">            createImpl();</span>
<span class="fc" id="L258">        return impl;</span>
    }

    private void checkOldImpl() {
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (impl == null)</span>
<span class="nc" id="L263">            return;</span>
        // SocketImpl.connect() is a protected method, therefore we need to use
        // getDeclaredMethod, therefore we need permission to access the member
        try {
<span class="nc" id="L267">            AccessController.doPrivileged(</span>
<span class="nc" id="L268">                new PrivilegedExceptionAction&lt;Void&gt;() {</span>
                    public Void run() throws NoSuchMethodException {
<span class="nc" id="L270">                        impl.getClass().getDeclaredMethod(&quot;connect&quot;,</span>
                                                          SocketAddress.class,
                                                          int.class);
<span class="nc" id="L273">                        return null;</span>
                    }
                });
<span class="nc" id="L276">        } catch (java.security.PrivilegedActionException e) {</span>
<span class="nc" id="L277">            oldImpl = true;</span>
<span class="nc" id="L278">        }</span>
<span class="nc" id="L279">    }</span>

    private void setImpl() {
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        if (factory != null) {</span>
<span class="nc" id="L283">            impl = factory.createSocketImpl();</span>
<span class="nc" id="L284">            checkOldImpl();</span>
        } else {
            // No need to do a checkOldImpl() here, we know it's an up to date
            // SocketImpl!
<span class="fc" id="L288">            impl = new SocksSocketImpl();</span>
        }
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        if (impl != null)</span>
<span class="fc" id="L291">            impl.setServerSocket(this);</span>
<span class="fc" id="L292">    }</span>

    /**
     * Creates the socket implementation.
     *
     * @throws IOException if creation fails
     * @since 1.4
     */
    void createImpl() throws SocketException {
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (impl == null)</span>
<span class="nc" id="L302">            setImpl();</span>
        try {
<span class="fc" id="L304">            impl.create(true);</span>
<span class="fc" id="L305">            created = true;</span>
<span class="nc" id="L306">        } catch (IOException e) {</span>
<span class="nc" id="L307">            throw new SocketException(e.getMessage());</span>
<span class="fc" id="L308">        }</span>
<span class="fc" id="L309">    }</span>

    /**
     *
     * Binds the {@code ServerSocket} to a specific address
     * (IP address and port number).
     * &lt;p&gt;
     * If the address is {@code null}, then the system will pick up
     * an ephemeral port and a valid local address to bind the socket.
     * &lt;p&gt;
     * @param   endpoint        The IP address and port number to bind to.
     * @throws  IOException if the bind operation fails, or if the socket
     *                     is already bound.
     * @throws  SecurityException       if a {@code SecurityManager} is present and
     * its {@code checkListen} method doesn't allow the operation.
     * @throws  IllegalArgumentException if endpoint is a
     *          SocketAddress subclass not supported by this socket
     * @since 1.4
     */
    public void bind(SocketAddress endpoint) throws IOException {
<span class="fc" id="L329">        bind(endpoint, 50);</span>
<span class="fc" id="L330">    }</span>

    /**
     *
     * Binds the {@code ServerSocket} to a specific address
     * (IP address and port number).
     * &lt;p&gt;
     * If the address is {@code null}, then the system will pick up
     * an ephemeral port and a valid local address to bind the socket.
     * &lt;P&gt;
     * The {@code backlog} argument is the requested maximum number of
     * pending connections on the socket. Its exact semantics are implementation
     * specific. In particular, an implementation may impose a maximum length
     * or may choose to ignore the parameter altogther. The value provided
     * should be greater than {@code 0}. If it is less than or equal to
     * {@code 0}, then an implementation specific default will be used.
     * @param   endpoint        The IP address and port number to bind to.
     * @param   backlog         requested maximum length of the queue of
     *                          incoming connections.
     * @throws  IOException if the bind operation fails, or if the socket
     *                     is already bound.
     * @throws  SecurityException       if a {@code SecurityManager} is present and
     * its {@code checkListen} method doesn't allow the operation.
     * @throws  IllegalArgumentException if endpoint is a
     *          SocketAddress subclass not supported by this socket
     * @since 1.4
     */
    public void bind(SocketAddress endpoint, int backlog) throws IOException {
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L359">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="pc bpc" id="L360" title="2 of 4 branches missed.">        if (!oldImpl &amp;&amp; isBound())</span>
<span class="nc" id="L361">            throw new SocketException(&quot;Already bound&quot;);</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (endpoint == null)</span>
<span class="fc" id="L363">            endpoint = new InetSocketAddress(0);</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (!(endpoint instanceof InetSocketAddress))</span>
<span class="nc" id="L365">            throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>
<span class="fc" id="L366">        InetSocketAddress epoint = (InetSocketAddress) endpoint;</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        if (epoint.isUnresolved())</span>
<span class="nc" id="L368">            throw new SocketException(&quot;Unresolved address&quot;);</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">        if (backlog &lt; 1)</span>
<span class="nc" id="L370">          backlog = 50;</span>
        try {
<span class="fc" id="L372">            SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (security != null)</span>
<span class="fc" id="L374">                security.checkListen(epoint.getPort());</span>
<span class="fc" id="L375">            getImpl().bind(epoint.getAddress(), epoint.getPort());</span>
<span class="fc" id="L376">            getImpl().listen(backlog);</span>
<span class="fc" id="L377">            bound = true;</span>
<span class="fc" id="L378">        } catch(SecurityException e) {</span>
<span class="fc" id="L379">            bound = false;</span>
<span class="fc" id="L380">            throw e;</span>
<span class="fc" id="L381">        } catch(IOException e) {</span>
<span class="fc" id="L382">            bound = false;</span>
<span class="fc" id="L383">            throw e;</span>
<span class="fc" id="L384">        }</span>
<span class="fc" id="L385">    }</span>

    /**
     * Returns the local address of this server socket.
     * &lt;p&gt;
     * If the socket was bound prior to being {@link #close closed},
     * then this method will continue to return the local address
     * after the socket is closed.
     * &lt;p&gt;
     * If there is a security manager set, its {@code checkConnect} method is
     * called with the local address and {@code -1} as its arguments to see
     * if the operation is allowed. If the operation is not allowed,
     * the {@link InetAddress#getLoopbackAddress loopback} address is returned.
     *
     * @return  the address to which this socket is bound,
     *          or the loopback address if denied by the security manager,
     *          or {@code null} if the socket is unbound.
     *
     * @see SecurityManager#checkConnect
     */
    public InetAddress getInetAddress() {
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (!isBound())</span>
<span class="nc" id="L407">            return null;</span>
        try {
<span class="fc" id="L409">            InetAddress in = getImpl().getInetAddress();</span>
<span class="fc" id="L410">            SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">            if (sm != null)</span>
<span class="fc" id="L412">                sm.checkConnect(in.getHostAddress(), -1);</span>
<span class="fc" id="L413">            return in;</span>
<span class="nc" id="L414">        } catch (SecurityException e) {</span>
<span class="nc" id="L415">            return InetAddress.getLoopbackAddress();</span>
<span class="nc" id="L416">        } catch (SocketException e) {</span>
            // nothing
            // If we're bound, the impl has been created
            // so we shouldn't get here
        }
<span class="nc" id="L421">        return null;</span>
    }

    /**
     * Returns the port number on which this socket is listening.
     * &lt;p&gt;
     * If the socket was bound prior to being {@link #close closed},
     * then this method will continue to return the port number
     * after the socket is closed.
     *
     * @return  the port number to which this socket is listening or
     *          -1 if the socket is not bound yet.
     */
    public int getLocalPort() {
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        if (!isBound())</span>
<span class="nc" id="L436">            return -1;</span>
        try {
<span class="fc" id="L438">            return getImpl().getLocalPort();</span>
<span class="nc" id="L439">        } catch (SocketException e) {</span>
            // nothing
            // If we're bound, the impl has been created
            // so we shouldn't get here
        }
<span class="nc" id="L444">        return -1;</span>
    }

    /**
     * Returns the address of the endpoint this socket is bound to.
     * &lt;p&gt;
     * If the socket was bound prior to being {@link #close closed},
     * then this method will continue to return the address of the endpoint
     * after the socket is closed.
     * &lt;p&gt;
     * If there is a security manager set, its {@code checkConnect} method is
     * called with the local address and {@code -1} as its arguments to see
     * if the operation is allowed. If the operation is not allowed,
     * a {@code SocketAddress} representing the
     * {@link InetAddress#getLoopbackAddress loopback} address and the local
     * port to which the socket is bound is returned.
     *
     * @return a {@code SocketAddress} representing the local endpoint of
     *         this socket, or a {@code SocketAddress} representing the
     *         loopback address if denied by the security manager,
     *         or {@code null} if the socket is not bound yet.
     *
     * @see #getInetAddress()
     * @see #getLocalPort()
     * @see #bind(SocketAddress)
     * @see SecurityManager#checkConnect
     * @since 1.4
     */

    public SocketAddress getLocalSocketAddress() {
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        if (!isBound())</span>
<span class="nc" id="L475">            return null;</span>
<span class="fc" id="L476">        return new InetSocketAddress(getInetAddress(), getLocalPort());</span>
    }

    /**
     * Listens for a connection to be made to this socket and accepts
     * it. The method blocks until a connection is made.
     *
     * &lt;p&gt;A new Socket {@code s} is created and, if there
     * is a security manager,
     * the security manager's {@code checkAccept} method is called
     * with {@code s.getInetAddress().getHostAddress()} and
     * {@code s.getPort()}
     * as its arguments to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * @exception  IOException  if an I/O error occurs when waiting for a
     *               connection.
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkAccept} method doesn't allow the operation.
     * @exception  SocketTimeoutException if a timeout was previously set with setSoTimeout and
     *             the timeout has been reached.
     * @exception  java.nio.channels.IllegalBlockingModeException
     *             if this socket has an associated channel, the channel is in
     *             non-blocking mode, and there is no connection ready to be
     *             accepted
     *
     * @return the new Socket
     * @see SecurityManager#checkAccept
     * @revised 1.4
     * @spec JSR-51
     */
    public Socket accept() throws IOException {
<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (isClosed())</span>
<span class="fc" id="L509">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">        if (!isBound())</span>
<span class="nc" id="L511">            throw new SocketException(&quot;Socket is not bound yet&quot;);</span>
<span class="fc" id="L512">        Socket s = new Socket((SocketImpl) null);</span>
<span class="fc" id="L513">        implAccept(s);</span>
<span class="fc" id="L514">        return s;</span>
    }

    /**
     * Subclasses of ServerSocket use this method to override accept()
     * to return their own subclass of socket.  So a JDKServerSocket
     * will typically hand this method an &lt;i&gt;empty&lt;/i&gt; JDKSocket.  On
     * return from implAccept the JDKSocket will be connected to a client.
     *
     * @param s the Socket
     * @throws java.nio.channels.IllegalBlockingModeException
     *         if this socket has an associated channel,
     *         and the channel is in non-blocking mode
     * @throws IOException if an I/O error occurs when waiting
     * for a connection.
     * @since   JDK1.1
     * @revised 1.4
     * @spec JSR-51
     */
    protected final void implAccept(Socket s) throws IOException {
<span class="fc" id="L534">        SocketImpl si = null;</span>
        try {
<span class="fc bfc" id="L536" title="All 2 branches covered.">            if (s.impl == null)</span>
<span class="fc" id="L537">              s.setImpl();</span>
            else {
<span class="fc" id="L539">                s.impl.reset();</span>
            }
<span class="fc" id="L541">            si = s.impl;</span>
<span class="fc" id="L542">            s.impl = null;</span>
<span class="fc" id="L543">            si.address = new InetAddress();</span>
<span class="fc" id="L544">            si.fd = new FileDescriptor();</span>
<span class="fc" id="L545">            getImpl().accept(si);</span>

<span class="fc" id="L547">            SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">            if (security != null) {</span>
<span class="fc" id="L549">                security.checkAccept(si.getInetAddress().getHostAddress(),</span>
<span class="fc" id="L550">                                     si.getPort());</span>
            }
<span class="fc" id="L552">        } catch (IOException e) {</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">            if (si != null)</span>
<span class="fc" id="L554">                si.reset();</span>
<span class="fc" id="L555">            s.impl = si;</span>
<span class="fc" id="L556">            throw e;</span>
<span class="nc" id="L557">        } catch (SecurityException e) {</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">            if (si != null)</span>
<span class="nc" id="L559">                si.reset();</span>
<span class="nc" id="L560">            s.impl = si;</span>
<span class="nc" id="L561">            throw e;</span>
<span class="fc" id="L562">        }</span>
<span class="fc" id="L563">        s.impl = si;</span>
<span class="fc" id="L564">        s.postAccept();</span>
<span class="fc" id="L565">    }</span>

    /**
     * Closes this socket.
     *
     * Any thread currently blocked in {@link #accept()} will throw
     * a {@link SocketException}.
     *
     * &lt;p&gt; If this socket has an associated channel then the channel is closed
     * as well.
     *
     * @exception  IOException  if an I/O error occurs when closing the socket.
     * @revised 1.4
     * @spec JSR-51
     */
    public void close() throws IOException {
<span class="fc" id="L581">        synchronized(closeLock) {</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">            if (isClosed())</span>
<span class="fc" id="L583">                return;</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">            if (created)</span>
<span class="fc" id="L585">                impl.close();</span>
<span class="fc" id="L586">            closed = true;</span>
<span class="pc" id="L587">        }</span>
<span class="fc" id="L588">    }</span>

    /**
     * Returns the unique {@link java.nio.channels.ServerSocketChannel} object
     * associated with this socket, if any.
     *
     * &lt;p&gt; A server socket will have a channel if, and only if, the channel
     * itself was created via the {@link
     * java.nio.channels.ServerSocketChannel#open ServerSocketChannel.open}
     * method.
     *
     * @return  the server-socket channel associated with this socket,
     *          or {@code null} if this socket was not created
     *          for a channel
     *
     * @since 1.4
     * @spec JSR-51
     */
    public ServerSocketChannel getChannel() {
<span class="nc" id="L607">        return null;</span>
    }

    /**
     * Returns the binding state of the ServerSocket.
     *
     * @return true if the ServerSocket successfully bound to an address
     * @since 1.4
     */
    public boolean isBound() {
        // Before 1.3 ServerSockets were always bound during creation
<span class="pc bpc" id="L618" title="1 of 4 branches missed.">        return bound || oldImpl;</span>
    }

    /**
     * Returns the closed state of the ServerSocket.
     *
     * @return true if the socket has been closed
     * @since 1.4
     */
    public boolean isClosed() {
<span class="fc" id="L628">        synchronized(closeLock) {</span>
<span class="fc" id="L629">            return closed;</span>
<span class="nc" id="L630">        }</span>
    }

    /**
     * Enable/disable {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} with the
     * specified timeout, in milliseconds.  With this option set to a non-zero
     * timeout, a call to accept() for this ServerSocket
     * will block for only this amount of time.  If the timeout expires,
     * a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
     * ServerSocket is still valid.  The option &lt;B&gt;must&lt;/B&gt; be enabled
     * prior to entering the blocking operation to have effect.  The
     * timeout must be {@code &gt; 0}.
     * A timeout of zero is interpreted as an infinite timeout.
     * @param timeout the specified timeout, in milliseconds
     * @exception SocketException if there is an error in
     * the underlying protocol, such as a TCP error.
     * @since   JDK1.1
     * @see #getSoTimeout()
     */
    public synchronized void setSoTimeout(int timeout) throws SocketException {
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L651">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="fc" id="L652">        getImpl().setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));</span>
<span class="fc" id="L653">    }</span>

    /**
     * Retrieve setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}.
     * 0 returns implies that the option is disabled (i.e., timeout of infinity).
     * @return the {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} value
     * @exception IOException if an I/O error occurs
     * @since   JDK1.1
     * @see #setSoTimeout(int)
     */
    public synchronized int getSoTimeout() throws IOException {
<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L665">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc" id="L666">        Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);</span>
        /* extra type safety */
<span class="nc bnc" id="L668" title="All 2 branches missed.">        if (o instanceof Integer) {</span>
<span class="nc" id="L669">            return ((Integer) o).intValue();</span>
        } else {
<span class="nc" id="L671">            return 0;</span>
        }
    }

    /**
     * Enable/disable the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
     * socket option.
     * &lt;p&gt;
     * When a TCP connection is closed the connection may remain
     * in a timeout state for a period of time after the connection
     * is closed (typically known as the {@code TIME_WAIT} state
     * or {@code 2MSL} wait state).
     * For applications using a well known socket address or port
     * it may not be possible to bind a socket to the required
     * {@code SocketAddress} if there is a connection in the
     * timeout state involving the socket address or port.
     * &lt;p&gt;
     * Enabling {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} prior to
     * binding the socket using {@link #bind(SocketAddress)} allows the socket
     * to be bound even though a previous connection is in a timeout state.
     * &lt;p&gt;
     * When a {@code ServerSocket} is created the initial setting
     * of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is not defined.
     * Applications can use {@link #getReuseAddress()} to determine the initial
     * setting of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}.
     * &lt;p&gt;
     * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is
     * enabled or disabled after a socket is bound (See {@link #isBound()})
     * is not defined.
     *
     * @param on  whether to enable or disable the socket option
     * @exception SocketException if an error occurs enabling or
     *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
     *            socket option, or the socket is closed.
     * @since 1.4
     * @see #getReuseAddress()
     * @see #bind(SocketAddress)
     * @see #isBound()
     * @see #isClosed()
     */
    public void setReuseAddress(boolean on) throws SocketException {
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L713">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="fc" id="L714">        getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));</span>
<span class="fc" id="L715">    }</span>

    /**
     * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
     *
     * @return a {@code boolean} indicating whether or not
     *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
     * @exception SocketException if there is an error
     * in the underlying protocol, such as a TCP error.
     * @since   1.4
     * @see #setReuseAddress(boolean)
     */
    public boolean getReuseAddress() throws SocketException {
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L729">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="fc" id="L730">        return ((Boolean) (getImpl().getOption(SocketOptions.SO_REUSEADDR))).booleanValue();</span>
    }

    /**
     * Returns the implementation address and implementation port of
     * this socket as a {@code String}.
     * &lt;p&gt;
     * If there is a security manager set, its {@code checkConnect} method is
     * called with the local address and {@code -1} as its arguments to see
     * if the operation is allowed. If the operation is not allowed,
     * an {@code InetAddress} representing the
     * {@link InetAddress#getLoopbackAddress loopback} address is returned as
     * the implementation address.
     *
     * @return  a string representation of this socket.
     */
    public String toString() {
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">        if (!isBound())</span>
<span class="nc" id="L748">            return &quot;ServerSocket[unbound]&quot;;</span>
        InetAddress in;
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">        if (System.getSecurityManager() != null)</span>
<span class="nc" id="L751">            in = InetAddress.getLoopbackAddress();</span>
        else
<span class="fc" id="L753">            in = impl.getInetAddress();</span>
<span class="fc" id="L754">        return &quot;ServerSocket[addr=&quot; + in +</span>
<span class="fc" id="L755">                &quot;,localport=&quot; + impl.getLocalPort()  + &quot;]&quot;;</span>
    }

    void setBound() {
<span class="fc" id="L759">        bound = true;</span>
<span class="fc" id="L760">    }</span>

    void setCreated() {
<span class="fc" id="L763">        created = true;</span>
<span class="fc" id="L764">    }</span>

    /**
     * The factory for all server sockets.
     */
<span class="fc" id="L769">    private static SocketImplFactory factory = null;</span>

    /**
     * Sets the server socket implementation factory for the
     * application. The factory can be specified only once.
     * &lt;p&gt;
     * When an application creates a new server socket, the socket
     * implementation factory's {@code createSocketImpl} method is
     * called to create the actual socket implementation.
     * &lt;p&gt;
     * Passing {@code null} to the method is a no-op unless the factory
     * was already set.
     * &lt;p&gt;
     * If there is a security manager, this method first calls
     * the security manager's {@code checkSetFactory} method
     * to ensure the operation is allowed.
     * This could result in a SecurityException.
     *
     * @param      fac   the desired factory.
     * @exception  IOException  if an I/O error occurs when setting the
     *               socket factory.
     * @exception  SocketException  if the factory has already been defined.
     * @exception  SecurityException  if a security manager exists and its
     *             {@code checkSetFactory} method doesn't allow the operation.
     * @see        java.net.SocketImplFactory#createSocketImpl()
     * @see        SecurityManager#checkSetFactory
     */
    public static synchronized void setSocketFactory(SocketImplFactory fac) throws IOException {
<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (factory != null) {</span>
<span class="nc" id="L798">            throw new SocketException(&quot;factory already defined&quot;);</span>
        }
<span class="nc" id="L800">        SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">        if (security != null) {</span>
<span class="nc" id="L802">            security.checkSetFactory();</span>
        }
<span class="nc" id="L804">        factory = fac;</span>
<span class="nc" id="L805">    }</span>

    /**
     * Sets a default proposed value for the
     * {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option for sockets
     * accepted from this {@code ServerSocket}. The value actually set
     * in the accepted socket must be determined by calling
     * {@link Socket#getReceiveBufferSize()} after the socket
     * is returned by {@link #accept()}.
     * &lt;p&gt;
     * The value of {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is used both to
     * set the size of the internal socket receive buffer, and to set the size
     * of the TCP receive window that is advertized to the remote peer.
     * &lt;p&gt;
     * It is possible to change the value subsequently, by calling
     * {@link Socket#setReceiveBufferSize(int)}. However, if the application
     * wishes to allow a receive window larger than 64K bytes, as defined by RFC1323
     * then the proposed value must be set in the ServerSocket &lt;B&gt;before&lt;/B&gt;
     * it is bound to a local address. This implies, that the ServerSocket must be
     * created with the no-argument constructor, then setReceiveBufferSize() must
     * be called and lastly the ServerSocket is bound to an address by calling bind().
     * &lt;p&gt;
     * Failure to do this will not cause an error, and the buffer size may be set to the
     * requested value but the TCP receive window in sockets accepted from
     * this ServerSocket will be no larger than 64K bytes.
     *
     * @exception SocketException if there is an error
     * in the underlying protocol, such as a TCP error.
     *
     * @param size the size to which to set the receive buffer
     * size. This value must be greater than 0.
     *
     * @exception IllegalArgumentException if the
     * value is 0 or is negative.
     *
     * @since 1.4
     * @see #getReceiveBufferSize
     */
     public synchronized void setReceiveBufferSize (int size) throws SocketException {
<span class="nc bnc" id="L844" title="All 2 branches missed.">        if (!(size &gt; 0)) {</span>
<span class="nc" id="L845">            throw new IllegalArgumentException(&quot;negative receive size&quot;);</span>
        }
<span class="nc bnc" id="L847" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L848">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc" id="L849">        getImpl().setOption(SocketOptions.SO_RCVBUF, new Integer(size));</span>
<span class="nc" id="L850">    }</span>

    /**
     * Gets the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option
     * for this {@code ServerSocket}, that is the proposed buffer size that
     * will be used for Sockets accepted from this {@code ServerSocket}.
     *
     * &lt;p&gt;Note, the value actually set in the accepted socket is determined by
     * calling {@link Socket#getReceiveBufferSize()}.
     * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}
     *         option for this {@code Socket}.
     * @exception SocketException if there is an error
     *            in the underlying protocol, such as a TCP error.
     * @see #setReceiveBufferSize(int)
     * @since 1.4
     */
    public synchronized int getReceiveBufferSize()
    throws SocketException{
<span class="nc bnc" id="L868" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L869">            throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc" id="L870">        int result = 0;</span>
<span class="nc" id="L871">        Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (o instanceof Integer) {</span>
<span class="nc" id="L873">            result = ((Integer)o).intValue();</span>
        }
<span class="nc" id="L875">        return result;</span>
    }

    /**
     * Sets performance preferences for this ServerSocket.
     *
     * &lt;p&gt; Sockets use the TCP/IP protocol by default.  Some implementations
     * may offer alternative protocols which have different performance
     * characteristics than TCP/IP.  This method allows the application to
     * express its own preferences as to how these tradeoffs should be made
     * when the implementation chooses from the available protocols.
     *
     * &lt;p&gt; Performance preferences are described by three integers
     * whose values indicate the relative importance of short connection time,
     * low latency, and high bandwidth.  The absolute values of the integers
     * are irrelevant; in order to choose a protocol the values are simply
     * compared, with larger values indicating stronger preferences.  If the
     * application prefers short connection time over both low latency and high
     * bandwidth, for example, then it could invoke this method with the values
     * {@code (1, 0, 0)}.  If the application prefers high bandwidth above low
     * latency, and low latency above short connection time, then it could
     * invoke this method with the values {@code (0, 1, 2)}.
     *
     * &lt;p&gt; Invoking this method after this socket has been bound
     * will have no effect. This implies that in order to use this capability
     * requires the socket to be created with the no-argument constructor.
     *
     * @param  connectionTime
     *         An {@code int} expressing the relative importance of a short
     *         connection time
     *
     * @param  latency
     *         An {@code int} expressing the relative importance of low
     *         latency
     *
     * @param  bandwidth
     *         An {@code int} expressing the relative importance of high
     *         bandwidth
     *
     * @since 1.5
     */
    public void setPerformancePreferences(int connectionTime,
                                          int latency,
                                          int bandwidth)
    {
        /* Not implemented yet */
<span class="nc" id="L921">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>