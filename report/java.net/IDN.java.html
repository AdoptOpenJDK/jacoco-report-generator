<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>IDN.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">IDN.java</span></div><h1>IDN.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.net;

import java.io.InputStream;
import java.io.IOException;
import java.security.AccessController;
import java.security.PrivilegedAction;

import sun.net.idn.StringPrep;
import sun.net.idn.Punycode;
import sun.text.normalizer.UCharacterIterator;

/**
 * Provides methods to convert internationalized domain names (IDNs) between
 * a normal Unicode representation and an ASCII Compatible Encoding (ACE) representation.
 * Internationalized domain names can use characters from the entire range of
 * Unicode, while traditional domain names are restricted to ASCII characters.
 * ACE is an encoding of Unicode strings that uses only ASCII characters and
 * can be used with software (such as the Domain Name System) that only
 * understands traditional domain names.
 *
 * &lt;p&gt;Internationalized domain names are defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;.
 * RFC 3490 defines two operations: ToASCII and ToUnicode. These 2 operations employ
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc3491.txt&quot;&gt;Nameprep&lt;/a&gt; algorithm, which is a
 * profile of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3454.txt&quot;&gt;Stringprep&lt;/a&gt;, and
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc3492.txt&quot;&gt;Punycode&lt;/a&gt; algorithm to convert
 * domain name string back and forth.
 *
 * &lt;p&gt;The behavior of aforementioned conversion process can be adjusted by various flags:
 *   &lt;ul&gt;
 *     &lt;li&gt;If the ALLOW_UNASSIGNED flag is used, the domain name string to be converted
 *         can contain code points that are unassigned in Unicode 3.2, which is the
 *         Unicode version on which IDN conversion is based. If the flag is not used,
 *         the presence of such unassigned code points is treated as an error.
 *     &lt;li&gt;If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;.
 *         It is an error if they don't meet the requirements.
 *   &lt;/ul&gt;
 * These flags can be logically OR'ed together.
 *
 * &lt;p&gt;The security consideration is important with respect to internationalization
 * domain name support. For example, English domain names may be &lt;i&gt;homographed&lt;/i&gt;
 * - maliciously misspelled by substitution of non-Latin letters.
 * &lt;a href=&quot;http://www.unicode.org/reports/tr36/&quot;&gt;Unicode Technical Report #36&lt;/a&gt;
 * discusses security issues of IDN support as well as possible solutions.
 * Applications are responsible for taking adequate security measures when using
 * international domain names.
 *
 * @author Edward Wang
 * @since 1.6
 *
 */
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">public final class IDN {</span>
    /**
     * Flag to allow processing of unassigned code points
     */
    public static final int ALLOW_UNASSIGNED = 0x01;

    /**
     * Flag to turn on the check against STD-3 ASCII rules
     */
    public static final int USE_STD3_ASCII_RULES = 0x02;


    /**
     * Translates a string from Unicode to ASCII Compatible Encoding (ACE),
     * as defined by the ToASCII operation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;.
     *
     * &lt;p&gt;ToASCII operation can fail. ToASCII fails if any step of it fails.
     * If ToASCII operation fails, an IllegalArgumentException will be thrown.
     * In this case, the input string should not be used in an internationalized domain name.
     *
     * &lt;p&gt; A label is an individual part of a domain name. The original ToASCII operation,
     * as defined in RFC 3490, only operates on a single label. This method can handle
     * both label and entire domain name, by assuming that labels in a domain name are
     * always separated by dots. The following characters are recognized as dots:
     * &amp;#0092;u002E (full stop), &amp;#0092;u3002 (ideographic full stop), &amp;#0092;uFF0E (fullwidth full stop),
     * and &amp;#0092;uFF61 (halfwidth ideographic full stop). if dots are
     * used as label separators, this method also changes all of them to &amp;#0092;u002E (full stop)
     * in output translated string.
     *
     * @param input     the string to be processed
     * @param flag      process flag; can be 0 or any logical OR of possible flags
     *
     * @return          the translated {@code String}
     *
     * @throws IllegalArgumentException   if the input string doesn't conform to RFC 3490 specification
     */
    public static String toASCII(String input, int flag)
    {
<span class="nc" id="L113">        int p = 0, q = 0;</span>
<span class="nc" id="L114">        StringBuffer out = new StringBuffer();</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (isRootLabel(input)) {</span>
<span class="nc" id="L117">            return &quot;.&quot;;</span>
        }

<span class="nc bnc" id="L120" title="All 2 branches missed.">        while (p &lt; input.length()) {</span>
<span class="nc" id="L121">            q = searchDots(input, p);</span>
<span class="nc" id="L122">            out.append(toASCIIInternal(input.substring(p, q),  flag));</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">            if (q != (input.length())) {</span>
               // has more labels, or keep the trailing dot as at present
<span class="nc" id="L125">               out.append('.');</span>
            }
<span class="nc" id="L127">            p = q + 1;</span>
        }

<span class="nc" id="L130">        return out.toString();</span>
    }


    /**
     * Translates a string from Unicode to ASCII Compatible Encoding (ACE),
     * as defined by the ToASCII operation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;.
     *
     * &lt;p&gt; This convenience method works as if by invoking the
     * two-argument counterpart as follows:
     * &lt;blockquote&gt;
     * {@link #toASCII(String, int) toASCII}(input,&amp;nbsp;0);
     * &lt;/blockquote&gt;
     *
     * @param input     the string to be processed
     *
     * @return          the translated {@code String}
     *
     * @throws IllegalArgumentException   if the input string doesn't conform to RFC 3490 specification
     */
    public static String toASCII(String input) {
<span class="nc" id="L151">        return toASCII(input, 0);</span>
    }


    /**
     * Translates a string from ASCII Compatible Encoding (ACE) to Unicode,
     * as defined by the ToUnicode operation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;.
     *
     * &lt;p&gt;ToUnicode never fails. In case of any error, the input string is returned unmodified.
     *
     * &lt;p&gt; A label is an individual part of a domain name. The original ToUnicode operation,
     * as defined in RFC 3490, only operates on a single label. This method can handle
     * both label and entire domain name, by assuming that labels in a domain name are
     * always separated by dots. The following characters are recognized as dots:
     * &amp;#0092;u002E (full stop), &amp;#0092;u3002 (ideographic full stop), &amp;#0092;uFF0E (fullwidth full stop),
     * and &amp;#0092;uFF61 (halfwidth ideographic full stop).
     *
     * @param input     the string to be processed
     * @param flag      process flag; can be 0 or any logical OR of possible flags
     *
     * @return          the translated {@code String}
     */
    public static String toUnicode(String input, int flag) {
<span class="nc" id="L174">        int p = 0, q = 0;</span>
<span class="nc" id="L175">        StringBuffer out = new StringBuffer();</span>

<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (isRootLabel(input)) {</span>
<span class="nc" id="L178">            return &quot;.&quot;;</span>
        }

<span class="nc bnc" id="L181" title="All 2 branches missed.">        while (p &lt; input.length()) {</span>
<span class="nc" id="L182">            q = searchDots(input, p);</span>
<span class="nc" id="L183">            out.append(toUnicodeInternal(input.substring(p, q),  flag));</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (q != (input.length())) {</span>
               // has more labels, or keep the trailing dot as at present
<span class="nc" id="L186">               out.append('.');</span>
            }
<span class="nc" id="L188">            p = q + 1;</span>
        }

<span class="nc" id="L191">        return out.toString();</span>
    }


    /**
     * Translates a string from ASCII Compatible Encoding (ACE) to Unicode,
     * as defined by the ToUnicode operation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;.
     *
     * &lt;p&gt; This convenience method works as if by invoking the
     * two-argument counterpart as follows:
     * &lt;blockquote&gt;
     * {@link #toUnicode(String, int) toUnicode}(input,&amp;nbsp;0);
     * &lt;/blockquote&gt;
     *
     * @param input     the string to be processed
     *
     * @return          the translated {@code String}
     */
    public static String toUnicode(String input) {
<span class="nc" id="L210">        return toUnicode(input, 0);</span>
    }


    /* ---------------- Private members -------------- */

    // ACE Prefix is &quot;xn--&quot;
    private static final String ACE_PREFIX = &quot;xn--&quot;;
<span class="fc" id="L218">    private static final int ACE_PREFIX_LENGTH = ACE_PREFIX.length();</span>

    private static final int MAX_LABEL_LENGTH   = 63;

    // single instance of nameprep
<span class="fc" id="L223">    private static StringPrep namePrep = null;</span>

    static {
<span class="fc" id="L226">        InputStream stream = null;</span>

        try {
            final String IDN_PROFILE = &quot;uidna.spp&quot;;
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">            if (System.getSecurityManager() != null) {</span>
<span class="nc" id="L231">                stream = AccessController.doPrivileged(new PrivilegedAction&lt;InputStream&gt;() {</span>
                    public InputStream run() {
<span class="nc" id="L233">                        return StringPrep.class.getResourceAsStream(IDN_PROFILE);</span>
                    }
                });
            } else {
<span class="fc" id="L237">                stream = StringPrep.class.getResourceAsStream(IDN_PROFILE);</span>
            }

<span class="nc" id="L240">            namePrep = new StringPrep(stream);</span>
<span class="nc" id="L241">            stream.close();</span>
<span class="fc" id="L242">        } catch (IOException e) {</span>
            // should never reach here
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">            assert false;</span>
<span class="nc" id="L245">        }</span>
<span class="nc" id="L246">    }</span>


    /* ---------------- Private operations -------------- */


    //
    // to suppress the default zero-argument constructor
    //
<span class="nc" id="L255">    private IDN() {}</span>

    //
    // toASCII operation; should only apply to a single label
    //
    private static String toASCIIInternal(String label, int flag)
    {
        // step 1
        // Check if the string contains code points outside the ASCII range 0..0x7c.
<span class="nc" id="L264">        boolean isASCII  = isAllASCII(label);</span>
        StringBuffer dest;

        // step 2
        // perform the nameprep operation; flag ALLOW_UNASSIGNED is used here
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (!isASCII) {</span>
<span class="nc" id="L270">            UCharacterIterator iter = UCharacterIterator.getInstance(label);</span>
            try {
<span class="nc" id="L272">                dest = namePrep.prepare(iter, flag);</span>
<span class="nc" id="L273">            } catch (java.text.ParseException e) {</span>
<span class="nc" id="L274">                throw new IllegalArgumentException(e);</span>
<span class="nc" id="L275">            }</span>
<span class="nc" id="L276">        } else {</span>
<span class="nc" id="L277">            dest = new StringBuffer(label);</span>
        }

        // step 8, move forward to check the smallest number of the code points
        // the length must be inside 1..63
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (dest.length() == 0) {</span>
<span class="nc" id="L283">            throw new IllegalArgumentException(</span>
                        &quot;Empty label is not a legal name&quot;);
        }

        // step 3
        // Verify the absence of non-LDH ASCII code points
        //   0..0x2c, 0x2e..0x2f, 0x3a..0x40, 0x5b..0x60, 0x7b..0x7f
        // Verify the absence of leading and trailing hyphen
<span class="nc bnc" id="L291" title="All 2 branches missed.">        boolean useSTD3ASCIIRules = ((flag &amp; USE_STD3_ASCII_RULES) != 0);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (useSTD3ASCIIRules) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            for (int i = 0; i &lt; dest.length(); i++) {</span>
<span class="nc" id="L294">                int c = dest.charAt(i);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">                if (isNonLDHAsciiCodePoint(c)) {</span>
<span class="nc" id="L296">                    throw new IllegalArgumentException(</span>
                        &quot;Contains non-LDH ASCII characters&quot;);
                }
            }

<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (dest.charAt(0) == '-' ||</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">                dest.charAt(dest.length() - 1) == '-') {</span>

<span class="nc" id="L304">                throw new IllegalArgumentException(</span>
                        &quot;Has leading or trailing hyphen&quot;);
            }
        }

<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (!isASCII) {</span>
            // step 4
            // If all code points are inside 0..0x7f, skip to step 8
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (!isAllASCII(dest.toString())) {</span>
                // step 5
                // verify the sequence does not begin with ACE prefix
<span class="nc bnc" id="L315" title="All 2 branches missed.">                if(!startsWithACEPrefix(dest)){</span>

                    // step 6
                    // encode the sequence with punycode
                    try {
<span class="nc" id="L320">                        dest = Punycode.encode(dest, null);</span>
<span class="nc" id="L321">                    } catch (java.text.ParseException e) {</span>
<span class="nc" id="L322">                        throw new IllegalArgumentException(e);</span>
<span class="nc" id="L323">                    }</span>

<span class="nc" id="L325">                    dest = toASCIILower(dest);</span>

                    // step 7
                    // prepend the ACE prefix
<span class="nc" id="L329">                    dest.insert(0, ACE_PREFIX);</span>
                } else {
<span class="nc" id="L331">                    throw new IllegalArgumentException(&quot;The input starts with the ACE Prefix&quot;);</span>
                }

            }
        }

        // step 8
        // the length must be inside 1..63
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (dest.length() &gt; MAX_LABEL_LENGTH) {</span>
<span class="nc" id="L340">            throw new IllegalArgumentException(&quot;The label in the input is too long&quot;);</span>
        }

<span class="nc" id="L343">        return dest.toString();</span>
    }

    //
    // toUnicode operation; should only apply to a single label
    //
    private static String toUnicodeInternal(String label, int flag) {
<span class="nc" id="L350">        boolean[] caseFlags = null;</span>
        StringBuffer dest;

        // step 1
        // find out if all the codepoints in input are ASCII
<span class="nc" id="L355">        boolean isASCII = isAllASCII(label);</span>

<span class="nc bnc" id="L357" title="All 2 branches missed.">        if(!isASCII){</span>
            // step 2
            // perform the nameprep operation; flag ALLOW_UNASSIGNED is used here
            try {
<span class="nc" id="L361">                UCharacterIterator iter = UCharacterIterator.getInstance(label);</span>
<span class="nc" id="L362">                dest = namePrep.prepare(iter, flag);</span>
<span class="nc" id="L363">            } catch (Exception e) {</span>
                // toUnicode never fails; if any step fails, return the input string
<span class="nc" id="L365">                return label;</span>
<span class="nc" id="L366">            }</span>
        } else {
<span class="nc" id="L368">            dest = new StringBuffer(label);</span>
        }

        // step 3
        // verify ACE Prefix
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if(startsWithACEPrefix(dest)) {</span>

            // step 4
            // Remove the ACE Prefix
<span class="nc" id="L377">            String temp = dest.substring(ACE_PREFIX_LENGTH, dest.length());</span>

            try {
                // step 5
                // Decode using punycode
<span class="nc" id="L382">                StringBuffer decodeOut = Punycode.decode(new StringBuffer(temp), null);</span>

                // step 6
                // Apply toASCII
<span class="nc" id="L386">                String toASCIIOut = toASCII(decodeOut.toString(), flag);</span>

                // step 7
                // verify
<span class="nc bnc" id="L390" title="All 2 branches missed.">                if (toASCIIOut.equalsIgnoreCase(dest.toString())) {</span>
                    // step 8
                    // return output of step 5
<span class="nc" id="L393">                    return decodeOut.toString();</span>
                }
<span class="nc" id="L395">            } catch (Exception ignored) {</span>
                // no-op
<span class="nc" id="L397">            }</span>
        }

        // just return the input
<span class="nc" id="L401">        return label;</span>
    }


    //
    // LDH stands for &quot;letter/digit/hyphen&quot;, with characters restricted to the
    // 26-letter Latin alphabet &lt;A-Z a-z&gt;, the digits &lt;0-9&gt;, and the hyphen
    // &lt;-&gt;.
    // Non LDH refers to characters in the ASCII range, but which are not
    // letters, digits or the hypen.
    //
    // non-LDH = 0..0x2C, 0x2E..0x2F, 0x3A..0x40, 0x5B..0x60, 0x7B..0x7F
    //
    private static boolean isNonLDHAsciiCodePoint(int ch){
<span class="nc bnc" id="L415" title="All 20 branches missed.">        return (0x0000 &lt;= ch &amp;&amp; ch &lt;= 0x002C) ||</span>
               (0x002E &lt;= ch &amp;&amp; ch &lt;= 0x002F) ||
               (0x003A &lt;= ch &amp;&amp; ch &lt;= 0x0040) ||
               (0x005B &lt;= ch &amp;&amp; ch &lt;= 0x0060) ||
               (0x007B &lt;= ch &amp;&amp; ch &lt;= 0x007F);
    }

    //
    // search dots in a string and return the index of that character;
    // or if there is no dots, return the length of input string
    // dots might be: \u002E (full stop), \u3002 (ideographic full stop), \uFF0E (fullwidth full stop),
    // and \uFF61 (halfwidth ideographic full stop).
    //
    private static int searchDots(String s, int start) {
        int i;
<span class="nc bnc" id="L430" title="All 2 branches missed.">        for (i = start; i &lt; s.length(); i++) {</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">            if (isLabelSeparator(s.charAt(i))) {</span>
<span class="nc" id="L432">                break;</span>
            }
        }

<span class="nc" id="L436">        return i;</span>
    }

    //
    // to check if a string is a root label, &quot;.&quot;.
    //
    private static boolean isRootLabel(String s) {
<span class="nc bnc" id="L443" title="All 4 branches missed.">        return (s.length() == 1 &amp;&amp; isLabelSeparator(s.charAt(0)));</span>
    }

    //
    // to check if a character is a label separator, i.e. a dot character.
    //
    private static boolean isLabelSeparator(char c) {
<span class="nc bnc" id="L450" title="All 8 branches missed.">        return (c == '.' || c == '\u3002' || c == '\uFF0E' || c == '\uFF61');</span>
    }

    //
    // to check if a string only contains US-ASCII code point
    //
    private static boolean isAllASCII(String input) {
<span class="nc" id="L457">        boolean isASCII = true;</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        for (int i = 0; i &lt; input.length(); i++) {</span>
<span class="nc" id="L459">            int c = input.charAt(i);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            if (c &gt; 0x7F) {</span>
<span class="nc" id="L461">                isASCII = false;</span>
<span class="nc" id="L462">                break;</span>
            }
        }
<span class="nc" id="L465">        return isASCII;</span>
    }

    //
    // to check if a string starts with ACE-prefix
    //
    private static boolean startsWithACEPrefix(StringBuffer input){
<span class="nc" id="L472">        boolean startsWithPrefix = true;</span>

<span class="nc bnc" id="L474" title="All 2 branches missed.">        if(input.length() &lt; ACE_PREFIX_LENGTH){</span>
<span class="nc" id="L475">            return false;</span>
        }
<span class="nc bnc" id="L477" title="All 2 branches missed.">        for(int i = 0; i &lt; ACE_PREFIX_LENGTH; i++){</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">            if(toASCIILower(input.charAt(i)) != ACE_PREFIX.charAt(i)){</span>
<span class="nc" id="L479">                startsWithPrefix = false;</span>
            }
        }
<span class="nc" id="L482">        return startsWithPrefix;</span>
    }

    private static char toASCIILower(char ch){
<span class="nc bnc" id="L486" title="All 4 branches missed.">        if('A' &lt;= ch &amp;&amp; ch &lt;= 'Z'){</span>
<span class="nc" id="L487">            return (char)(ch + 'a' - 'A');</span>
        }
<span class="nc" id="L489">        return ch;</span>
    }

    private static StringBuffer toASCIILower(StringBuffer input){
<span class="nc" id="L493">        StringBuffer dest = new StringBuffer();</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">        for(int i = 0; i &lt; input.length();i++){</span>
<span class="nc" id="L495">            dest.append(toASCIILower(input.charAt(i)));</span>
        }
<span class="nc" id="L497">        return dest;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>