<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InMemoryCookieStore.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">InMemoryCookieStore.java</span></div><h1>InMemoryCookieStore.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.net;

import java.net.URI;
import java.net.CookieStore;
import java.net.HttpCookie;
import java.net.URISyntaxException;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Collections;
import java.util.Iterator;
import java.util.concurrent.locks.ReentrantLock;

/**
 * A simple in-memory java.net.CookieStore implementation
 *
 * @author Edward Wang
 * @since 1.6
 */
class InMemoryCookieStore implements CookieStore {
    // the in-memory representation of cookies
<span class="fc" id="L48">    private List&lt;HttpCookie&gt; cookieJar = null;</span>

    // the cookies are indexed by its domain and associated uri (if present)
    // CAUTION: when a cookie removed from main data structure (i.e. cookieJar),
    //          it won't be cleared in domainIndex &amp; uriIndex. Double-check the
    //          presence of cookie when retrieve one form index store.
<span class="fc" id="L54">    private Map&lt;String, List&lt;HttpCookie&gt;&gt; domainIndex = null;</span>
<span class="fc" id="L55">    private Map&lt;URI, List&lt;HttpCookie&gt;&gt; uriIndex = null;</span>

    // use ReentrantLock instead of syncronized for scalability
<span class="fc" id="L58">    private ReentrantLock lock = null;</span>


    /**
     * The default ctor
     */
<span class="fc" id="L64">    public InMemoryCookieStore() {</span>
<span class="fc" id="L65">        cookieJar = new ArrayList&lt;HttpCookie&gt;();</span>
<span class="fc" id="L66">        domainIndex = new HashMap&lt;String, List&lt;HttpCookie&gt;&gt;();</span>
<span class="fc" id="L67">        uriIndex = new HashMap&lt;URI, List&lt;HttpCookie&gt;&gt;();</span>

<span class="fc" id="L69">        lock = new ReentrantLock(false);</span>
<span class="fc" id="L70">    }</span>

    /**
     * Add one cookie into cookie store.
     */
    public void add(URI uri, HttpCookie cookie) {
        // pre-condition : argument can't be null
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        if (cookie == null) {</span>
<span class="nc" id="L78">            throw new NullPointerException(&quot;cookie is null&quot;);</span>
        }


<span class="fc" id="L82">        lock.lock();</span>
        try {
            // remove the ole cookie if there has had one
<span class="fc" id="L85">            cookieJar.remove(cookie);</span>

            // add new cookie if it has a non-zero max-age
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">            if (cookie.getMaxAge() != 0) {</span>
<span class="fc" id="L89">                cookieJar.add(cookie);</span>
                // and add it to domain index
<span class="fc bfc" id="L91" title="All 2 branches covered.">                if (cookie.getDomain() != null) {</span>
<span class="fc" id="L92">                    addIndex(domainIndex, cookie.getDomain(), cookie);</span>
                }
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">                if (uri != null) {</span>
                    // add it to uri index, too
<span class="fc" id="L96">                    addIndex(uriIndex, getEffectiveURI(uri), cookie);</span>
                }
            }
        } finally {
<span class="pc" id="L100">            lock.unlock();</span>
<span class="fc" id="L101">        }</span>
<span class="fc" id="L102">    }</span>


    /**
     * Get all cookies, which:
     *  1) given uri domain-matches with, or, associated with
     *     given uri when added to the cookie store.
     *  3) not expired.
     * See RFC 2965 sec. 3.3.4 for more detail.
     */
    public List&lt;HttpCookie&gt; get(URI uri) {
        // argument can't be null
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (uri == null) {</span>
<span class="nc" id="L115">            throw new NullPointerException(&quot;uri is null&quot;);</span>
        }

<span class="fc" id="L118">        List&lt;HttpCookie&gt; cookies = new ArrayList&lt;HttpCookie&gt;();</span>
<span class="fc" id="L119">        boolean secureLink = &quot;https&quot;.equalsIgnoreCase(uri.getScheme());</span>
<span class="fc" id="L120">        lock.lock();</span>
        try {
            // check domainIndex first
<span class="fc" id="L123">            getInternal1(cookies, domainIndex, uri.getHost(), secureLink);</span>
            // check uriIndex then
<span class="fc" id="L125">            getInternal2(cookies, uriIndex, getEffectiveURI(uri), secureLink);</span>
        } finally {
<span class="pc" id="L127">            lock.unlock();</span>
<span class="fc" id="L128">        }</span>

<span class="fc" id="L130">        return cookies;</span>
    }

    /**
     * Get all cookies in cookie store, except those have expired
     */
    public List&lt;HttpCookie&gt; getCookies() {
        List&lt;HttpCookie&gt; rt;

<span class="fc" id="L139">        lock.lock();</span>
        try {
<span class="fc" id="L141">            Iterator&lt;HttpCookie&gt; it = cookieJar.iterator();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">                if (it.next().hasExpired()) {</span>
<span class="nc" id="L144">                    it.remove();</span>
                }
            }
        } finally {
<span class="pc" id="L148">            rt = Collections.unmodifiableList(cookieJar);</span>
<span class="pc" id="L149">            lock.unlock();</span>
<span class="fc" id="L150">        }</span>

<span class="fc" id="L152">        return rt;</span>
    }

    /**
     * Get all URIs, which are associated with at least one cookie
     * of this cookie store.
     */
    public List&lt;URI&gt; getURIs() {
<span class="fc" id="L160">        List&lt;URI&gt; uris = new ArrayList&lt;URI&gt;();</span>

<span class="fc" id="L162">        lock.lock();</span>
        try {
<span class="fc" id="L164">            Iterator&lt;URI&gt; it = uriIndex.keySet().iterator();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L166">                URI uri = it.next();</span>
<span class="fc" id="L167">                List&lt;HttpCookie&gt; cookies = uriIndex.get(uri);</span>
<span class="pc bpc" id="L168" title="2 of 4 branches missed.">                if (cookies == null || cookies.size() == 0) {</span>
                    // no cookies list or an empty list associated with
                    // this uri entry, delete it
<span class="nc" id="L171">                    it.remove();</span>
                }
<span class="fc" id="L173">            }</span>
        } finally {
<span class="pc" id="L175">            uris.addAll(uriIndex.keySet());</span>
<span class="pc" id="L176">            lock.unlock();</span>
<span class="fc" id="L177">        }</span>

<span class="fc" id="L179">        return uris;</span>
    }


    /**
     * Remove a cookie from store
     */
    public boolean remove(URI uri, HttpCookie ck) {
        // argument can't be null
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (ck == null) {</span>
<span class="nc" id="L189">            throw new NullPointerException(&quot;cookie is null&quot;);</span>
        }

<span class="nc" id="L192">        boolean modified = false;</span>
<span class="nc" id="L193">        lock.lock();</span>
        try {
<span class="nc" id="L195">            modified = cookieJar.remove(ck);</span>
        } finally {
<span class="nc" id="L197">            lock.unlock();</span>
<span class="nc" id="L198">        }</span>

<span class="nc" id="L200">        return modified;</span>
    }


    /**
     * Remove all cookies in this cookie store.
     */
    public boolean removeAll() {
<span class="fc" id="L208">        lock.lock();</span>
        try {
<span class="fc bfc" id="L210" title="All 2 branches covered.">            if (cookieJar.isEmpty()) {</span>
<span class="fc" id="L211">                return false;</span>
            }
<span class="fc" id="L213">            cookieJar.clear();</span>
<span class="fc" id="L214">            domainIndex.clear();</span>
<span class="fc" id="L215">            uriIndex.clear();</span>
        } finally {
<span class="pc" id="L217">            lock.unlock();</span>
<span class="fc" id="L218">        }</span>

<span class="fc" id="L220">        return true;</span>
    }


    /* ---------------- Private operations -------------- */


    /*
     * This is almost the same as HttpCookie.domainMatches except for
     * one difference: It won't reject cookies when the 'H' part of the
     * domain contains a dot ('.').
     * I.E.: RFC 2965 section 3.3.2 says that if host is x.y.domain.com
     * and the cookie domain is .domain.com, then it should be rejected.
     * However that's not how the real world works. Browsers don't reject and
     * some sites, like yahoo.com do actually expect these cookies to be
     * passed along.
     * And should be used for 'old' style cookies (aka Netscape type of cookies)
     */
    private boolean netscapeDomainMatches(String domain, String host)
    {
<span class="pc bpc" id="L240" title="2 of 4 branches missed.">        if (domain == null || host == null) {</span>
<span class="nc" id="L241">            return false;</span>
        }

        // if there's no embedded dot in domain and domain is not .local
<span class="fc" id="L245">        boolean isLocalDomain = &quot;.local&quot;.equalsIgnoreCase(domain);</span>
<span class="fc" id="L246">        int embeddedDotInDomain = domain.indexOf('.');</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (embeddedDotInDomain == 0) {</span>
<span class="fc" id="L248">            embeddedDotInDomain = domain.indexOf('.', 1);</span>
        }
<span class="pc bpc" id="L250" title="3 of 6 branches missed.">        if (!isLocalDomain &amp;&amp; (embeddedDotInDomain == -1 || embeddedDotInDomain == domain.length() - 1)) {</span>
<span class="nc" id="L251">            return false;</span>
        }

        // if the host name contains no dot and the domain name is .local
<span class="fc" id="L255">        int firstDotInHost = host.indexOf('.');</span>
<span class="pc bpc" id="L256" title="1 of 4 branches missed.">        if (firstDotInHost == -1 &amp;&amp; isLocalDomain) {</span>
<span class="nc" id="L257">            return true;</span>
        }

<span class="fc" id="L260">        int domainLength = domain.length();</span>
<span class="fc" id="L261">        int lengthDiff = host.length() - domainLength;</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (lengthDiff == 0) {</span>
            // if the host name and the domain name are just string-compare euqal
<span class="fc" id="L264">            return host.equalsIgnoreCase(domain);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">        } else if (lengthDiff &gt; 0) {</span>
            // need to check H &amp; D component
<span class="fc" id="L267">            String H = host.substring(0, lengthDiff);</span>
<span class="fc" id="L268">            String D = host.substring(lengthDiff);</span>

<span class="fc" id="L270">            return (D.equalsIgnoreCase(domain));</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">        } else if (lengthDiff == -1) {</span>
            // if domain is actually .host
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">            return (domain.charAt(0) == '.' &amp;&amp;</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">                    host.equalsIgnoreCase(domain.substring(1)));</span>
        }

<span class="fc" id="L277">        return false;</span>
    }

    private void getInternal1(List&lt;HttpCookie&gt; cookies, Map&lt;String, List&lt;HttpCookie&gt;&gt; cookieIndex,
            String host, boolean secureLink) {
        // Use a separate list to handle cookies that need to be removed so
        // that there is no conflict with iterators.
<span class="fc" id="L284">        ArrayList&lt;HttpCookie&gt; toRemove = new ArrayList&lt;HttpCookie&gt;();</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">        for (Map.Entry&lt;String, List&lt;HttpCookie&gt;&gt; entry : cookieIndex.entrySet()) {</span>
<span class="fc" id="L286">            String domain = entry.getKey();</span>
<span class="fc" id="L287">            List&lt;HttpCookie&gt; lst = entry.getValue();</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            for (HttpCookie c : lst) {</span>
<span class="fc bfc" id="L289" title="All 4 branches covered.">                if ((c.getVersion() == 0 &amp;&amp; netscapeDomainMatches(domain, host)) ||</span>
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">                        (c.getVersion() == 1 &amp;&amp; HttpCookie.domainMatches(domain, host))) {</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">                    if ((cookieJar.indexOf(c) != -1)) {</span>
                        // the cookie still in main cookie store
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">                        if (!c.hasExpired()) {</span>
                            // don't add twice and make sure it's the proper
                            // security level
<span class="fc bfc" id="L296" title="All 4 branches covered.">                            if ((secureLink || !c.getSecure()) &amp;&amp;</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">                                    !cookies.contains(c)) {</span>
<span class="fc" id="L298">                                cookies.add(c);</span>
                            }
                        } else {
<span class="nc" id="L301">                            toRemove.add(c);</span>
                        }
                    } else {
                        // the cookie has beed removed from main store,
                        // so also remove it from domain indexed store
<span class="nc" id="L306">                        toRemove.add(c);</span>
                    }
                }
<span class="fc" id="L309">            }</span>
            // Clear up the cookies that need to be removed
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">            for (HttpCookie c : toRemove) {</span>
<span class="nc" id="L312">                lst.remove(c);</span>
<span class="nc" id="L313">                cookieJar.remove(c);</span>

<span class="nc" id="L315">            }</span>
<span class="fc" id="L316">            toRemove.clear();</span>
<span class="fc" id="L317">        }</span>
<span class="fc" id="L318">    }</span>

    // @param cookies           [OUT] contains the found cookies
    // @param cookieIndex       the index
    // @param comparator        the prediction to decide whether or not
    //                          a cookie in index should be returned
    private &lt;T&gt; void getInternal2(List&lt;HttpCookie&gt; cookies,
                                Map&lt;T, List&lt;HttpCookie&gt;&gt; cookieIndex,
                                Comparable&lt;T&gt; comparator, boolean secureLink)
    {
<span class="fc bfc" id="L328" title="All 2 branches covered.">        for (T index : cookieIndex.keySet()) {</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">            if (comparator.compareTo(index) == 0) {</span>
<span class="fc" id="L330">                List&lt;HttpCookie&gt; indexedCookies = cookieIndex.get(index);</span>
                // check the list of cookies associated with this domain
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">                if (indexedCookies != null) {</span>
<span class="fc" id="L333">                    Iterator&lt;HttpCookie&gt; it = indexedCookies.iterator();</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">                    while (it.hasNext()) {</span>
<span class="fc" id="L335">                        HttpCookie ck = it.next();</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                        if (cookieJar.indexOf(ck) != -1) {</span>
                            // the cookie still in main cookie store
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">                            if (!ck.hasExpired()) {</span>
                                // don't add twice
<span class="fc bfc" id="L340" title="All 4 branches covered.">                                if ((secureLink || !ck.getSecure()) &amp;&amp;</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">                                        !cookies.contains(ck))</span>
<span class="fc" id="L342">                                    cookies.add(ck);</span>
                            } else {
<span class="nc" id="L344">                                it.remove();</span>
<span class="nc" id="L345">                                cookieJar.remove(ck);</span>
                            }
                        } else {
                            // the cookie has beed removed from main store,
                            // so also remove it from domain indexed store
<span class="nc" id="L350">                            it.remove();</span>
                        }
<span class="fc" id="L352">                    }</span>
                } // end of indexedCookies != null
            } // end of comparator.compareTo(index) == 0
<span class="fc" id="L355">        } // end of cookieIndex iteration</span>
<span class="fc" id="L356">    }</span>

    // add 'cookie' indexed by 'index' into 'indexStore'
    private &lt;T&gt; void addIndex(Map&lt;T, List&lt;HttpCookie&gt;&gt; indexStore,
                              T index,
                              HttpCookie cookie)
    {
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        if (index != null) {</span>
<span class="fc" id="L364">            List&lt;HttpCookie&gt; cookies = indexStore.get(index);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">            if (cookies != null) {</span>
                // there may already have the same cookie, so remove it first
<span class="fc" id="L367">                cookies.remove(cookie);</span>

<span class="fc" id="L369">                cookies.add(cookie);</span>
            } else {
<span class="fc" id="L371">                cookies = new ArrayList&lt;HttpCookie&gt;();</span>
<span class="fc" id="L372">                cookies.add(cookie);</span>
<span class="fc" id="L373">                indexStore.put(index, cookies);</span>
            }
        }
<span class="fc" id="L376">    }</span>


    //
    // for cookie purpose, the effective uri should only be http://host
    // the path will be taken into account when path-match algorithm applied
    //
    private URI getEffectiveURI(URI uri) {
<span class="fc" id="L384">        URI effectiveURI = null;</span>
        try {
<span class="fc" id="L386">            effectiveURI = new URI(&quot;http&quot;,</span>
<span class="fc" id="L387">                                   uri.getHost(),</span>
                                   null,  // path component
                                   null,  // query component
                                   null   // fragment component
                                  );
<span class="nc" id="L392">        } catch (URISyntaxException ignored) {</span>
<span class="nc" id="L393">            effectiveURI = uri;</span>
<span class="fc" id="L394">        }</span>

<span class="fc" id="L396">        return effectiveURI;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>