<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AbstractPlainDatagramSocketImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.net</a> &gt; <span class="el_source">AbstractPlainDatagramSocketImpl.java</span></div><h1>AbstractPlainDatagramSocketImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.net;

import java.io.FileDescriptor;
import java.io.IOException;
import java.security.AccessController;
import sun.net.ResourceManager;

/**
 * Abstract datagram and multicast socket implementation base class.
 * Note: This is not a public class, so that applets cannot call
 * into the implementation directly and hence cannot bypass the
 * security checks present in the DatagramSocket and MulticastSocket
 * classes.
 *
 * @author Pavani Diwanji
 */

<span class="fc" id="L42">abstract class AbstractPlainDatagramSocketImpl extends DatagramSocketImpl</span>
{
    /* timeout value for receive() */
<span class="fc" id="L45">    int timeout = 0;</span>
<span class="fc" id="L46">    boolean connected = false;</span>
<span class="fc" id="L47">    private int trafficClass = 0;</span>
<span class="fc" id="L48">    protected InetAddress connectedAddress = null;</span>
<span class="fc" id="L49">    private int connectedPort = -1;</span>

<span class="fc" id="L51">    private static final String os = AccessController.doPrivileged(</span>
        new sun.security.action.GetPropertyAction(&quot;os.name&quot;)
    );

    /**
     * flag set if the native connect() call not to be used
     */
<span class="fc" id="L58">    private final static boolean connectDisabled = os.contains(&quot;OS X&quot;);</span>

    /**
     * Load net library into runtime.
     */
    static {
<span class="fc" id="L64">        java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L65">            new java.security.PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
<span class="fc" id="L67">                    System.loadLibrary(&quot;net&quot;);</span>
<span class="fc" id="L68">                    return null;</span>
                }
            });
<span class="fc" id="L71">    }</span>

    /**
     * Creates a datagram socket
     */
    protected synchronized void create() throws SocketException {
<span class="fc" id="L77">        ResourceManager.beforeUdpCreate();</span>
<span class="fc" id="L78">        fd = new FileDescriptor();</span>
        try {
<span class="fc" id="L80">            datagramSocketCreate();</span>
<span class="nc" id="L81">        } catch (SocketException ioe) {</span>
<span class="nc" id="L82">            ResourceManager.afterUdpClose();</span>
<span class="nc" id="L83">            fd = null;</span>
<span class="nc" id="L84">            throw ioe;</span>
<span class="fc" id="L85">        }</span>
<span class="fc" id="L86">    }</span>

    /**
     * Binds a datagram socket to a local port.
     */
    protected synchronized void bind(int lport, InetAddress laddr)
        throws SocketException {
<span class="fc" id="L93">        bind0(lport, laddr);</span>
<span class="fc" id="L94">    }</span>

    protected abstract void bind0(int lport, InetAddress laddr)
        throws SocketException;

    /**
     * Sends a datagram packet. The packet contains the data and the
     * destination address to send the packet to.
     * @param p the packet to be sent.
     */
    protected abstract void send(DatagramPacket p) throws IOException;

    /**
     * Connects a datagram socket to a remote destination. This associates the remote
     * address with the local socket so that datagrams may only be sent to this destination
     * and received from this destination.
     * @param address the remote InetAddress to connect to
     * @param port the remote port number
     */
    protected void connect(InetAddress address, int port) throws SocketException {
<span class="fc" id="L114">        connect0(address, port);</span>
<span class="fc" id="L115">        connectedAddress = address;</span>
<span class="fc" id="L116">        connectedPort = port;</span>
<span class="fc" id="L117">        connected = true;</span>
<span class="fc" id="L118">    }</span>

    /**
     * Disconnects a previously connected socket. Does nothing if the socket was
     * not connected already.
     */
    protected void disconnect() {
<span class="fc" id="L125">        disconnect0(connectedAddress.holder().getFamily());</span>
<span class="fc" id="L126">        connected = false;</span>
<span class="fc" id="L127">        connectedAddress = null;</span>
<span class="fc" id="L128">        connectedPort = -1;</span>
<span class="fc" id="L129">    }</span>

    /**
     * Peek at the packet to see who it is from.
     * @param i the address to populate with the sender address
     */
    protected abstract int peek(InetAddress i) throws IOException;
    protected abstract int peekData(DatagramPacket p) throws IOException;
    /**
     * Receive the datagram packet.
     * @param p the packet to receive into
     */
    protected synchronized void receive(DatagramPacket p)
        throws IOException {
<span class="fc" id="L143">        receive0(p);</span>
<span class="fc" id="L144">    }</span>

    protected abstract void receive0(DatagramPacket p)
        throws IOException;

    /**
     * Set the TTL (time-to-live) option.
     * @param ttl TTL to be set.
     */
    protected abstract void setTimeToLive(int ttl) throws IOException;

    /**
     * Get the TTL (time-to-live) option.
     */
    protected abstract int getTimeToLive() throws IOException;

    /**
     * Set the TTL (time-to-live) option.
     * @param ttl TTL to be set.
     */
    @Deprecated
    protected abstract void setTTL(byte ttl) throws IOException;

    /**
     * Get the TTL (time-to-live) option.
     */
    @Deprecated
    protected abstract byte getTTL() throws IOException;

    /**
     * Join the multicast group.
     * @param inetaddr multicast address to join.
     */
    protected void join(InetAddress inetaddr) throws IOException {
<span class="fc" id="L178">        join(inetaddr, null);</span>
<span class="fc" id="L179">    }</span>

    /**
     * Leave the multicast group.
     * @param inetaddr multicast address to leave.
     */
    protected void leave(InetAddress inetaddr) throws IOException {
<span class="fc" id="L186">        leave(inetaddr, null);</span>
<span class="fc" id="L187">    }</span>
    /**
     * Join the multicast group.
     * @param mcastaddr multicast address to join.
     * @param netIf specifies the local interface to receive multicast
     *        datagram packets
     * @throws  IllegalArgumentException if mcastaddr is null or is a
     *          SocketAddress subclass not supported by this socket
     * @since 1.4
     */

    protected void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
        throws IOException {
<span class="pc bpc" id="L200" title="2 of 4 branches missed.">        if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))</span>
<span class="nc" id="L201">            throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>
<span class="fc" id="L202">        join(((InetSocketAddress)mcastaddr).getAddress(), netIf);</span>
<span class="fc" id="L203">    }</span>

    protected abstract void join(InetAddress inetaddr, NetworkInterface netIf)
        throws IOException;

    /**
     * Leave the multicast group.
     * @param mcastaddr  multicast address to leave.
     * @param netIf specified the local interface to leave the group at
     * @throws  IllegalArgumentException if mcastaddr is null or is a
     *          SocketAddress subclass not supported by this socket
     * @since 1.4
     */
    protected void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
        throws IOException {
<span class="pc bpc" id="L218" title="2 of 4 branches missed.">        if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))</span>
<span class="nc" id="L219">            throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>
<span class="fc" id="L220">        leave(((InetSocketAddress)mcastaddr).getAddress(), netIf);</span>
<span class="fc" id="L221">    }</span>

    protected abstract void leave(InetAddress inetaddr, NetworkInterface netIf)
        throws IOException;

    /**
     * Close the socket.
     */
    protected void close() {
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (fd != null) {</span>
<span class="fc" id="L231">            datagramSocketClose();</span>
<span class="fc" id="L232">            ResourceManager.afterUdpClose();</span>
<span class="fc" id="L233">            fd = null;</span>
        }
<span class="fc" id="L235">    }</span>

    protected boolean isClosed() {
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">        return (fd == null) ? true : false;</span>
    }

    protected void finalize() {
<span class="fc" id="L242">        close();</span>
<span class="fc" id="L243">    }</span>

    /**
     * set a value - since we only support (setting) binary options
     * here, o must be a Boolean
     */

     public void setOption(int optID, Object o) throws SocketException {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">         if (isClosed()) {</span>
<span class="nc" id="L252">             throw new SocketException(&quot;Socket Closed&quot;);</span>
         }
<span class="pc bpc" id="L254" title="7 of 10 branches missed.">         switch (optID) {</span>
            /* check type safety b4 going native.  These should never
             * fail, since only java.Socket* has access to
             * PlainSocketImpl.setOption().
             */
         case SO_TIMEOUT:
<span class="pc bpc" id="L260" title="2 of 4 branches missed.">             if (o == null || !(o instanceof Integer)) {</span>
<span class="nc" id="L261">                 throw new SocketException(&quot;bad argument for SO_TIMEOUT&quot;);</span>
             }
<span class="fc" id="L263">             int tmp = ((Integer) o).intValue();</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">             if (tmp &lt; 0)</span>
<span class="nc" id="L265">                 throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
<span class="fc" id="L266">             timeout = tmp;</span>
<span class="fc" id="L267">             return;</span>
         case IP_TOS:
<span class="nc bnc" id="L269" title="All 4 branches missed.">             if (o == null || !(o instanceof Integer)) {</span>
<span class="nc" id="L270">                 throw new SocketException(&quot;bad argument for IP_TOS&quot;);</span>
             }
<span class="nc" id="L272">             trafficClass = ((Integer)o).intValue();</span>
<span class="nc" id="L273">             break;</span>
         case SO_REUSEADDR:
<span class="pc bpc" id="L275" title="2 of 4 branches missed.">             if (o == null || !(o instanceof Boolean)) {</span>
<span class="nc" id="L276">                 throw new SocketException(&quot;bad argument for SO_REUSEADDR&quot;);</span>
             }
             break;
         case SO_BROADCAST:
<span class="nc bnc" id="L280" title="All 4 branches missed.">             if (o == null || !(o instanceof Boolean)) {</span>
<span class="nc" id="L281">                 throw new SocketException(&quot;bad argument for SO_BROADCAST&quot;);</span>
             }
             break;
         case SO_BINDADDR:
<span class="nc" id="L285">             throw new SocketException(&quot;Cannot re-bind Socket&quot;);</span>
         case SO_RCVBUF:
         case SO_SNDBUF:
<span class="nc bnc" id="L288" title="All 4 branches missed.">             if (o == null || !(o instanceof Integer) ||</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                 ((Integer)o).intValue() &lt; 0) {</span>
<span class="nc" id="L290">                 throw new SocketException(&quot;bad argument for SO_SNDBUF or &quot; +</span>
                                           &quot;SO_RCVBUF&quot;);
             }
             break;
         case IP_MULTICAST_IF:
<span class="nc bnc" id="L295" title="All 4 branches missed.">             if (o == null || !(o instanceof InetAddress))</span>
<span class="nc" id="L296">                 throw new SocketException(&quot;bad argument for IP_MULTICAST_IF&quot;);</span>
             break;
         case IP_MULTICAST_IF2:
<span class="nc bnc" id="L299" title="All 4 branches missed.">             if (o == null || !(o instanceof NetworkInterface))</span>
<span class="nc" id="L300">                 throw new SocketException(&quot;bad argument for IP_MULTICAST_IF2&quot;);</span>
             break;
         case IP_MULTICAST_LOOP:
<span class="pc bpc" id="L303" title="2 of 4 branches missed.">             if (o == null || !(o instanceof Boolean))</span>
<span class="nc" id="L304">                 throw new SocketException(&quot;bad argument for IP_MULTICAST_LOOP&quot;);</span>
             break;
         default:
<span class="nc" id="L307">             throw new SocketException(&quot;invalid option: &quot; + optID);</span>
         }
<span class="fc" id="L309">         socketSetOption(optID, o);</span>
<span class="fc" id="L310">     }</span>

    /*
     * get option's state - set or not
     */

    public Object getOption(int optID) throws SocketException {
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (isClosed()) {</span>
<span class="nc" id="L318">            throw new SocketException(&quot;Socket Closed&quot;);</span>
        }

        Object result;

<span class="pc bpc" id="L323" title="3 of 4 branches missed.">        switch (optID) {</span>
            case SO_TIMEOUT:
<span class="nc" id="L325">                result = new Integer(timeout);</span>
<span class="nc" id="L326">                break;</span>

            case IP_TOS:
<span class="nc" id="L329">                result = socketGetOption(optID);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">                if ( ((Integer)result).intValue() == -1) {</span>
<span class="nc" id="L331">                    result = new Integer(trafficClass);</span>
                }
                break;

            case SO_BINDADDR:
            case IP_MULTICAST_IF:
            case IP_MULTICAST_IF2:
            case SO_RCVBUF:
            case SO_SNDBUF:
            case IP_MULTICAST_LOOP:
            case SO_REUSEADDR:
            case SO_BROADCAST:
<span class="fc" id="L343">                result = socketGetOption(optID);</span>
<span class="fc" id="L344">                break;</span>

            default:
<span class="nc" id="L347">                throw new SocketException(&quot;invalid option: &quot; + optID);</span>
        }

<span class="fc" id="L350">        return result;</span>
    }

    protected abstract void datagramSocketCreate() throws SocketException;
    protected abstract void datagramSocketClose();
    protected abstract void socketSetOption(int opt, Object val)
        throws SocketException;
    protected abstract Object socketGetOption(int opt) throws SocketException;

    protected abstract void connect0(InetAddress address, int port) throws SocketException;
    protected abstract void disconnect0(int family);

    protected boolean nativeConnectDisabled() {
<span class="fc" id="L363">        return connectDisabled;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>