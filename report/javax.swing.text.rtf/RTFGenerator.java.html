<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RTFGenerator.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text.rtf</a> &gt; <span class="el_source">RTFGenerator.java</span></div><h1>RTFGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text.rtf;

import java.lang.*;
import java.util.*;
import java.awt.Color;
import java.awt.Font;
import java.io.OutputStream;
import java.io.IOException;

import javax.swing.text.*;

/**
 * Generates an RTF output stream (java.io.OutputStream) from rich text
 * (handed off through a series of LTTextAcceptor calls).  Can be used to
 * generate RTF from any object which knows how to write to a text acceptor
 * (e.g., LTAttributedText and LTRTFFilter).
 *
 * &lt;p&gt;Note that this is a lossy conversion since RTF's model of
 * text does not exactly correspond with LightText's.
 *
 * @see LTAttributedText
 * @see LTRTFFilter
 * @see LTTextAcceptor
 * @see java.io.OutputStream
 */

class RTFGenerator extends Object
{
    /* These dictionaries map Colors, font names, or Style objects
       to Integers */
    Dictionary&lt;Object, Integer&gt; colorTable;
    int colorCount;
    Dictionary&lt;String, Integer&gt; fontTable;
    int fontCount;
    Dictionary&lt;AttributeSet, Integer&gt; styleTable;
    int styleCount;

    /* where all the text is going */
    OutputStream outputStream;

    boolean afterKeyword;

    MutableAttributeSet outputAttributes;

    /* the value of the last \\ucN keyword emitted */
    int unicodeCount;

    /* for efficiency's sake (ha) */
    private Segment workingSegment;

    int[] outputConversion;

    /** The default color, used for text without an explicit color
     *  attribute. */
<span class="nc" id="L79">    static public final Color defaultRTFColor = Color.black;</span>

    static public final float defaultFontSize = 12f;

    static public final String defaultFontFamily = &quot;Helvetica&quot;;

    /* constants so we can avoid allocating objects in inner loops */
    final static private Object MagicToken;

    /* An array of character-keyword pairs. This could be done
       as a dictionary (and lookup would be quicker), but that
       would require allocating an object for every character
       written (slow!). */
<span class="nc" id="L92">    static class CharacterKeywordPair</span>
      { public char character; public String keyword; }
    static protected CharacterKeywordPair[] textKeywords;

    static {
<span class="nc" id="L97">        MagicToken = new Object();</span>

<span class="nc" id="L99">        Dictionary textKeywordDictionary = RTFReader.textKeywords;</span>
<span class="nc" id="L100">        Enumeration keys = textKeywordDictionary.keys();</span>
<span class="nc" id="L101">        Vector&lt;CharacterKeywordPair&gt; tempPairs = new Vector&lt;CharacterKeywordPair&gt;();</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        while(keys.hasMoreElements()) {</span>
<span class="nc" id="L103">            CharacterKeywordPair pair = new CharacterKeywordPair();</span>
<span class="nc" id="L104">            pair.keyword = (String)keys.nextElement();</span>
<span class="nc" id="L105">            pair.character = ((String)textKeywordDictionary.get(pair.keyword)).charAt(0);</span>
<span class="nc" id="L106">            tempPairs.addElement(pair);</span>
<span class="nc" id="L107">        }</span>
<span class="nc" id="L108">        textKeywords = new CharacterKeywordPair[tempPairs.size()];</span>
<span class="nc" id="L109">        tempPairs.copyInto(textKeywords);</span>
    }

<span class="nc" id="L112">    static final char[] hexdigits = { '0', '1', '2', '3', '4', '5', '6', '7',</span>
                                      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

static public void writeDocument(Document d, OutputStream to)
    throws IOException
{
<span class="nc" id="L118">    RTFGenerator gen = new RTFGenerator(to);</span>
<span class="nc" id="L119">    Element root = d.getDefaultRootElement();</span>

<span class="nc" id="L121">    gen.examineElement(root);</span>
<span class="nc" id="L122">    gen.writeRTFHeader();</span>
<span class="nc" id="L123">    gen.writeDocumentProperties(d);</span>

    /* TODO this assumes a particular element structure; is there
       a way to iterate more generically ? */
<span class="nc" id="L127">    int max = root.getElementCount();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">    for(int idx = 0; idx &lt; max; idx++)</span>
<span class="nc" id="L129">        gen.writeParagraphElement(root.getElement(idx));</span>

<span class="nc" id="L131">    gen.writeRTFTrailer();</span>
<span class="nc" id="L132">}</span>

public RTFGenerator(OutputStream to)
<span class="nc" id="L135">{</span>
<span class="nc" id="L136">    colorTable = new Hashtable&lt;Object, Integer&gt;();</span>
<span class="nc" id="L137">    colorTable.put(defaultRTFColor, Integer.valueOf(0));</span>
<span class="nc" id="L138">    colorCount = 1;</span>

<span class="nc" id="L140">    fontTable = new Hashtable&lt;String, Integer&gt;();</span>
<span class="nc" id="L141">    fontCount = 0;</span>

<span class="nc" id="L143">    styleTable = new Hashtable&lt;AttributeSet, Integer&gt;();</span>
    /* TODO: put default style in style table */
<span class="nc" id="L145">    styleCount = 0;</span>

<span class="nc" id="L147">    workingSegment = new Segment();</span>

<span class="nc" id="L149">    outputStream = to;</span>

<span class="nc" id="L151">    unicodeCount = 1;</span>
<span class="nc" id="L152">}</span>

public void examineElement(Element el)
{
<span class="nc" id="L156">    AttributeSet a = el.getAttributes();</span>
    String fontName;
    Object foregroundColor, backgroundColor;

<span class="nc" id="L160">    tallyStyles(a);</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">    if (a != null) {</span>
        /* TODO: default color must be color 0! */

<span class="nc" id="L165">        foregroundColor = StyleConstants.getForeground(a);</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (foregroundColor != null &amp;&amp;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">            colorTable.get(foregroundColor) == null) {</span>
<span class="nc" id="L168">            colorTable.put(foregroundColor, new Integer(colorCount));</span>
<span class="nc" id="L169">            colorCount ++;</span>
        }

<span class="nc" id="L172">        backgroundColor = a.getAttribute(StyleConstants.Background);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (backgroundColor != null &amp;&amp;</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            colorTable.get(backgroundColor) == null) {</span>
<span class="nc" id="L175">            colorTable.put(backgroundColor, new Integer(colorCount));</span>
<span class="nc" id="L176">            colorCount ++;</span>
        }

<span class="nc" id="L179">        fontName = StyleConstants.getFontFamily(a);</span>

<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (fontName == null)</span>
<span class="nc" id="L182">            fontName = defaultFontFamily;</span>

<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (fontName != null &amp;&amp;</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            fontTable.get(fontName) == null) {</span>
<span class="nc" id="L186">            fontTable.put(fontName, new Integer(fontCount));</span>
<span class="nc" id="L187">            fontCount ++;</span>
        }
    }

<span class="nc" id="L191">    int el_count = el.getElementCount();</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">    for(int el_idx = 0; el_idx &lt; el_count; el_idx ++) {</span>
<span class="nc" id="L193">        examineElement(el.getElement(el_idx));</span>
    }
<span class="nc" id="L195">}</span>

private void tallyStyles(AttributeSet a) {
<span class="nc bnc" id="L198" title="All 2 branches missed.">    while (a != null) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (a instanceof Style) {</span>
<span class="nc" id="L200">            Integer aNum = styleTable.get(a);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (aNum == null) {</span>
<span class="nc" id="L202">                styleCount = styleCount + 1;</span>
<span class="nc" id="L203">                aNum = new Integer(styleCount);</span>
<span class="nc" id="L204">                styleTable.put(a, aNum);</span>
            }
        }
<span class="nc" id="L207">        a = a.getResolveParent();</span>
    }
<span class="nc" id="L209">}</span>

private Style findStyle(AttributeSet a)
{
<span class="nc bnc" id="L213" title="All 2 branches missed.">    while(a != null) {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (a instanceof Style) {</span>
<span class="nc" id="L215">            Object aNum = styleTable.get(a);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if (aNum != null)</span>
<span class="nc" id="L217">                return (Style)a;</span>
        }
<span class="nc" id="L219">        a = a.getResolveParent();</span>
    }
<span class="nc" id="L221">    return null;</span>
}

private Integer findStyleNumber(AttributeSet a, String domain)
{
<span class="nc bnc" id="L226" title="All 2 branches missed.">    while(a != null) {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (a instanceof Style) {</span>
<span class="nc" id="L228">            Integer aNum = styleTable.get(a);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">            if (aNum != null) {</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">                if (domain == null ||</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">                    domain.equals(a.getAttribute(Constants.StyleType)))</span>
<span class="nc" id="L232">                    return aNum;</span>
            }

        }
<span class="nc" id="L236">        a = a.getResolveParent();</span>
    }
<span class="nc" id="L238">    return null;</span>
}

static private Object attrDiff(MutableAttributeSet oldAttrs,
                               AttributeSet newAttrs,
                               Object key,
                               Object dfl)
{
    Object oldValue, newValue;

<span class="nc" id="L248">    oldValue = oldAttrs.getAttribute(key);</span>
<span class="nc" id="L249">    newValue = newAttrs.getAttribute(key);</span>

<span class="nc bnc" id="L251" title="All 2 branches missed.">    if (newValue == oldValue)</span>
<span class="nc" id="L252">        return null;</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    if (newValue == null) {</span>
<span class="nc" id="L254">        oldAttrs.removeAttribute(key);</span>
<span class="nc bnc" id="L255" title="All 4 branches missed.">        if (dfl != null &amp;&amp; !dfl.equals(oldValue))</span>
<span class="nc" id="L256">            return dfl;</span>
        else
<span class="nc" id="L258">            return null;</span>
    }
<span class="nc bnc" id="L260" title="All 2 branches missed.">    if (oldValue == null ||</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">        !equalArraysOK(oldValue, newValue)) {</span>
<span class="nc" id="L262">        oldAttrs.addAttribute(key, newValue);</span>
<span class="nc" id="L263">        return newValue;</span>
    }
<span class="nc" id="L265">    return null;</span>
}

static private boolean equalArraysOK(Object a, Object b)
{
    Object[] aa, bb;
<span class="nc bnc" id="L271" title="All 2 branches missed.">    if (a == b)</span>
<span class="nc" id="L272">        return true;</span>
<span class="nc bnc" id="L273" title="All 4 branches missed.">    if (a == null || b == null)</span>
<span class="nc" id="L274">        return false;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">    if (a.equals(b))</span>
<span class="nc" id="L276">        return true;</span>
<span class="nc bnc" id="L277" title="All 4 branches missed.">    if (!(a.getClass().isArray() &amp;&amp; b.getClass().isArray()))</span>
<span class="nc" id="L278">        return false;</span>
<span class="nc" id="L279">    aa = (Object[])a;</span>
<span class="nc" id="L280">    bb = (Object[])b;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">    if (aa.length != bb.length)</span>
<span class="nc" id="L282">        return false;</span>

    int i;
<span class="nc" id="L285">    int l = aa.length;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">    for(i = 0; i &lt; l; i++) {</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (!equalArraysOK(aa[i], bb[i]))</span>
<span class="nc" id="L288">            return false;</span>
    }

<span class="nc" id="L291">    return true;</span>
}

/* Writes a line break to the output file, for ease in debugging */
public void writeLineBreak()
    throws IOException
{
<span class="nc" id="L298">    writeRawString(&quot;\n&quot;);</span>
<span class="nc" id="L299">    afterKeyword = false;</span>
<span class="nc" id="L300">}</span>


public void writeRTFHeader()
    throws IOException
{
    int index;

    /* TODO: Should the writer attempt to examine the text it's writing
       and pick a character set which will most compactly represent the
       document? (currently the writer always uses the ansi character
       set, which is roughly ISO-8859 Latin-1, and uses Unicode escapes
       for all other characters. However Unicode is a relatively
       recent addition to RTF, and not all readers will understand it.) */
<span class="nc" id="L314">    writeBegingroup();</span>
<span class="nc" id="L315">    writeControlWord(&quot;rtf&quot;, 1);</span>
<span class="nc" id="L316">    writeControlWord(&quot;ansi&quot;);</span>
<span class="nc" id="L317">    outputConversion = outputConversionForName(&quot;ansi&quot;);</span>
<span class="nc" id="L318">    writeLineBreak();</span>

    /* write font table */
<span class="nc" id="L321">    String[] sortedFontTable = new String[fontCount];</span>
<span class="nc" id="L322">    Enumeration&lt;String&gt; fonts = fontTable.keys();</span>
    String font;
<span class="nc bnc" id="L324" title="All 2 branches missed.">    while(fonts.hasMoreElements()) {</span>
<span class="nc" id="L325">        font = fonts.nextElement();</span>
<span class="nc" id="L326">        Integer num = fontTable.get(font);</span>
<span class="nc" id="L327">        sortedFontTable[num.intValue()] = font;</span>
<span class="nc" id="L328">    }</span>
<span class="nc" id="L329">    writeBegingroup();</span>
<span class="nc" id="L330">    writeControlWord(&quot;fonttbl&quot;);</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">    for(index = 0; index &lt; fontCount; index ++) {</span>
<span class="nc" id="L332">        writeControlWord(&quot;f&quot;, index);</span>
<span class="nc" id="L333">        writeControlWord(&quot;fnil&quot;);  /* TODO: supply correct font style */</span>
<span class="nc" id="L334">        writeText(sortedFontTable[index]);</span>
<span class="nc" id="L335">        writeText(&quot;;&quot;);</span>
    }
<span class="nc" id="L337">    writeEndgroup();</span>
<span class="nc" id="L338">    writeLineBreak();</span>

    /* write color table */
<span class="nc bnc" id="L341" title="All 2 branches missed.">    if (colorCount &gt; 1) {</span>
<span class="nc" id="L342">        Color[] sortedColorTable = new Color[colorCount];</span>
<span class="nc" id="L343">        Enumeration colors = colorTable.keys();</span>
        Color color;
<span class="nc bnc" id="L345" title="All 2 branches missed.">        while(colors.hasMoreElements()) {</span>
<span class="nc" id="L346">            color = (Color)colors.nextElement();</span>
<span class="nc" id="L347">            Integer num = colorTable.get(color);</span>
<span class="nc" id="L348">            sortedColorTable[num.intValue()] = color;</span>
<span class="nc" id="L349">        }</span>
<span class="nc" id="L350">        writeBegingroup();</span>
<span class="nc" id="L351">        writeControlWord(&quot;colortbl&quot;);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        for(index = 0; index &lt; colorCount; index ++) {</span>
<span class="nc" id="L353">            color = sortedColorTable[index];</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">            if (color != null) {</span>
<span class="nc" id="L355">                writeControlWord(&quot;red&quot;, color.getRed());</span>
<span class="nc" id="L356">                writeControlWord(&quot;green&quot;, color.getGreen());</span>
<span class="nc" id="L357">                writeControlWord(&quot;blue&quot;, color.getBlue());</span>
            }
<span class="nc" id="L359">            writeRawString(&quot;;&quot;);</span>
        }
<span class="nc" id="L361">        writeEndgroup();</span>
<span class="nc" id="L362">        writeLineBreak();</span>
    }

    /* write the style sheet */
<span class="nc bnc" id="L366" title="All 2 branches missed.">    if (styleCount &gt; 1) {</span>
<span class="nc" id="L367">        writeBegingroup();</span>
<span class="nc" id="L368">        writeControlWord(&quot;stylesheet&quot;);</span>
<span class="nc" id="L369">        Enumeration&lt;AttributeSet&gt; styles = styleTable.keys();</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">        while(styles.hasMoreElements()) {</span>
<span class="nc" id="L371">            Style style = (Style)styles.nextElement();</span>
<span class="nc" id="L372">            int styleNumber = styleTable.get(style).intValue();</span>
<span class="nc" id="L373">            writeBegingroup();</span>
<span class="nc" id="L374">            String styleType = (String)style.getAttribute(Constants.StyleType);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            if (styleType == null)</span>
<span class="nc" id="L376">                styleType = Constants.STParagraph;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (styleType.equals(Constants.STCharacter)) {</span>
<span class="nc" id="L378">                writeControlWord(&quot;*&quot;);</span>
<span class="nc" id="L379">                writeControlWord(&quot;cs&quot;, styleNumber);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            } else if(styleType.equals(Constants.STSection)) {</span>
<span class="nc" id="L381">                writeControlWord(&quot;*&quot;);</span>
<span class="nc" id="L382">                writeControlWord(&quot;ds&quot;, styleNumber);</span>
            } else {
<span class="nc" id="L384">                writeControlWord(&quot;s&quot;, styleNumber);</span>
            }

<span class="nc" id="L387">            AttributeSet basis = style.getResolveParent();</span>
            MutableAttributeSet goat;
<span class="nc bnc" id="L389" title="All 2 branches missed.">            if (basis == null) {</span>
<span class="nc" id="L390">                goat = new SimpleAttributeSet();</span>
            } else {
<span class="nc" id="L392">                goat = new SimpleAttributeSet(basis);</span>
            }

<span class="nc" id="L395">            updateSectionAttributes(goat, style, false);</span>
<span class="nc" id="L396">            updateParagraphAttributes(goat, style, false);</span>
<span class="nc" id="L397">            updateCharacterAttributes(goat, style, false);</span>

<span class="nc" id="L399">            basis = style.getResolveParent();</span>
<span class="nc bnc" id="L400" title="All 4 branches missed.">            if (basis != null &amp;&amp; basis instanceof Style) {</span>
<span class="nc" id="L401">                Integer basedOn = styleTable.get(basis);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">                if (basedOn != null) {</span>
<span class="nc" id="L403">                    writeControlWord(&quot;sbasedon&quot;, basedOn.intValue());</span>
                }
            }

<span class="nc" id="L407">            Style nextStyle = (Style)style.getAttribute(Constants.StyleNext);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if (nextStyle != null) {</span>
<span class="nc" id="L409">                Integer nextNum = styleTable.get(nextStyle);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">                if (nextNum != null) {</span>
<span class="nc" id="L411">                    writeControlWord(&quot;snext&quot;, nextNum.intValue());</span>
                }
            }

<span class="nc" id="L415">            Boolean hidden = (Boolean)style.getAttribute(Constants.StyleHidden);</span>
<span class="nc bnc" id="L416" title="All 4 branches missed.">            if (hidden != null &amp;&amp; hidden.booleanValue())</span>
<span class="nc" id="L417">                writeControlWord(&quot;shidden&quot;);</span>

<span class="nc" id="L419">            Boolean additive = (Boolean)style.getAttribute(Constants.StyleAdditive);</span>
<span class="nc bnc" id="L420" title="All 4 branches missed.">            if (additive != null &amp;&amp; additive.booleanValue())</span>
<span class="nc" id="L421">                writeControlWord(&quot;additive&quot;);</span>


<span class="nc" id="L424">            writeText(style.getName());</span>
<span class="nc" id="L425">            writeText(&quot;;&quot;);</span>
<span class="nc" id="L426">            writeEndgroup();</span>
<span class="nc" id="L427">        }</span>
<span class="nc" id="L428">        writeEndgroup();</span>
<span class="nc" id="L429">        writeLineBreak();</span>
    }

<span class="nc" id="L432">    outputAttributes = new SimpleAttributeSet();</span>
<span class="nc" id="L433">}</span>

void writeDocumentProperties(Document doc)
    throws IOException
{
    /* Write the document properties */
    int i;
<span class="nc" id="L440">    boolean wroteSomething = false;</span>

<span class="nc bnc" id="L442" title="All 2 branches missed.">    for(i = 0; i &lt; RTFAttributes.attributes.length; i++) {</span>
<span class="nc" id="L443">        RTFAttribute attr = RTFAttributes.attributes[i];</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (attr.domain() != RTFAttribute.D_DOCUMENT)</span>
<span class="nc" id="L445">            continue;</span>
<span class="nc" id="L446">        Object prop = doc.getProperty(attr.swingName());</span>
<span class="nc" id="L447">        boolean ok = attr.writeValue(prop, this, false);</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (ok)</span>
<span class="nc" id="L449">            wroteSomething = true;</span>
    }

<span class="nc bnc" id="L452" title="All 2 branches missed.">    if (wroteSomething)</span>
<span class="nc" id="L453">        writeLineBreak();</span>
<span class="nc" id="L454">}</span>

public void writeRTFTrailer()
    throws IOException
{
<span class="nc" id="L459">    writeEndgroup();</span>
<span class="nc" id="L460">    writeLineBreak();</span>
<span class="nc" id="L461">}</span>

protected void checkNumericControlWord(MutableAttributeSet currentAttributes,
                                       AttributeSet newAttributes,
                                       Object attrName,
                                       String controlWord,
                                       float dflt, float scale)
    throws IOException
{
    Object parm;

<span class="nc bnc" id="L472" title="All 2 branches missed.">    if ((parm = attrDiff(currentAttributes, newAttributes,</span>
                         attrName, MagicToken)) != null) {
        float targ;
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (parm == MagicToken)</span>
<span class="nc" id="L476">            targ = dflt;</span>
        else
<span class="nc" id="L478">            targ = ((Number)parm).floatValue();</span>
<span class="nc" id="L479">        writeControlWord(controlWord, Math.round(targ * scale));</span>
    }
<span class="nc" id="L481">}</span>

protected void checkControlWord(MutableAttributeSet currentAttributes,
                                AttributeSet newAttributes,
                                RTFAttribute word)
    throws IOException
{
    Object parm;

<span class="nc bnc" id="L490" title="All 2 branches missed.">    if ((parm = attrDiff(currentAttributes, newAttributes,</span>
<span class="nc" id="L491">                         word.swingName(), MagicToken)) != null) {</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (parm == MagicToken)</span>
<span class="nc" id="L493">            parm = null;</span>
<span class="nc" id="L494">        word.writeValue(parm, this, true);</span>
    }
<span class="nc" id="L496">}</span>

protected void checkControlWords(MutableAttributeSet currentAttributes,
                                 AttributeSet newAttributes,
                                 RTFAttribute words[],
                                 int domain)
    throws IOException
{
    int wordIndex;
<span class="nc" id="L505">    int wordCount = words.length;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">    for(wordIndex = 0; wordIndex &lt; wordCount; wordIndex++) {</span>
<span class="nc" id="L507">        RTFAttribute attr = words[wordIndex];</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (attr.domain() == domain)</span>
<span class="nc" id="L509">            checkControlWord(currentAttributes, newAttributes, attr);</span>
    }
<span class="nc" id="L511">}</span>

void updateSectionAttributes(MutableAttributeSet current,
                             AttributeSet newAttributes,
                             boolean emitStyleChanges)
    throws IOException
{
<span class="nc bnc" id="L518" title="All 2 branches missed.">    if (emitStyleChanges) {</span>
<span class="nc" id="L519">        Object oldStyle = current.getAttribute(&quot;sectionStyle&quot;);</span>
<span class="nc" id="L520">        Object newStyle = findStyleNumber(newAttributes, Constants.STSection);</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        if (oldStyle != newStyle) {</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">            if (oldStyle != null) {</span>
<span class="nc" id="L523">                resetSectionAttributes(current);</span>
            }
<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (newStyle != null) {</span>
<span class="nc" id="L526">                writeControlWord(&quot;ds&quot;, ((Integer)newStyle).intValue());</span>
<span class="nc" id="L527">                current.addAttribute(&quot;sectionStyle&quot;, newStyle);</span>
            } else {
<span class="nc" id="L529">                current.removeAttribute(&quot;sectionStyle&quot;);</span>
            }
        }
    }

<span class="nc" id="L534">    checkControlWords(current, newAttributes,</span>
                      RTFAttributes.attributes, RTFAttribute.D_SECTION);
<span class="nc" id="L536">}</span>

protected void resetSectionAttributes(MutableAttributeSet currentAttributes)
    throws IOException
{
<span class="nc" id="L541">    writeControlWord(&quot;sectd&quot;);</span>

    int wordIndex;
<span class="nc" id="L544">    int wordCount = RTFAttributes.attributes.length;</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">    for(wordIndex = 0; wordIndex &lt; wordCount; wordIndex++) {</span>
<span class="nc" id="L546">        RTFAttribute attr = RTFAttributes.attributes[wordIndex];</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (attr.domain() == RTFAttribute.D_SECTION)</span>
<span class="nc" id="L548">            attr.setDefault(currentAttributes);</span>
    }

<span class="nc" id="L551">    currentAttributes.removeAttribute(&quot;sectionStyle&quot;);</span>
<span class="nc" id="L552">}</span>

void updateParagraphAttributes(MutableAttributeSet current,
                               AttributeSet newAttributes,
                               boolean emitStyleChanges)
    throws IOException
{
    Object parm;
    Object oldStyle, newStyle;

    /* The only way to get rid of tabs or styles is with the \pard keyword,
       emitted by resetParagraphAttributes(). Ideally we should avoid
       emitting \pard if the new paragraph's tabs are a superset of the old
       paragraph's tabs. */

<span class="nc bnc" id="L567" title="All 2 branches missed.">    if (emitStyleChanges) {</span>
<span class="nc" id="L568">        oldStyle = current.getAttribute(&quot;paragraphStyle&quot;);</span>
<span class="nc" id="L569">        newStyle = findStyleNumber(newAttributes, Constants.STParagraph);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (oldStyle != newStyle) {</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">            if (oldStyle != null) {</span>
<span class="nc" id="L572">                resetParagraphAttributes(current);</span>
<span class="nc" id="L573">                oldStyle = null;</span>
            }
        }
    } else {
<span class="nc" id="L577">        oldStyle = null;</span>
<span class="nc" id="L578">        newStyle = null;</span>
    }

<span class="nc" id="L581">    Object oldTabs = current.getAttribute(Constants.Tabs);</span>
<span class="nc" id="L582">    Object newTabs = newAttributes.getAttribute(Constants.Tabs);</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">    if (oldTabs != newTabs) {</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">        if (oldTabs != null) {</span>
<span class="nc" id="L585">            resetParagraphAttributes(current);</span>
<span class="nc" id="L586">            oldTabs = null;</span>
<span class="nc" id="L587">            oldStyle = null;</span>
        }
    }

<span class="nc bnc" id="L591" title="All 4 branches missed.">    if (oldStyle != newStyle &amp;&amp; newStyle != null) {</span>
<span class="nc" id="L592">        writeControlWord(&quot;s&quot;, ((Integer)newStyle).intValue());</span>
<span class="nc" id="L593">        current.addAttribute(&quot;paragraphStyle&quot;, newStyle);</span>
    }

<span class="nc" id="L596">    checkControlWords(current, newAttributes,</span>
                      RTFAttributes.attributes, RTFAttribute.D_PARAGRAPH);

<span class="nc bnc" id="L599" title="All 4 branches missed.">    if (oldTabs != newTabs &amp;&amp; newTabs != null) {</span>
<span class="nc" id="L600">        TabStop tabs[] = (TabStop[])newTabs;</span>
        int index;
<span class="nc bnc" id="L602" title="All 2 branches missed.">        for(index = 0; index &lt; tabs.length; index ++) {</span>
<span class="nc" id="L603">            TabStop tab = tabs[index];</span>
<span class="nc bnc" id="L604" title="All 5 branches missed.">            switch (tab.getAlignment()) {</span>
              case TabStop.ALIGN_LEFT:
              case TabStop.ALIGN_BAR:
<span class="nc" id="L607">                break;</span>
              case TabStop.ALIGN_RIGHT:
<span class="nc" id="L609">                writeControlWord(&quot;tqr&quot;);</span>
<span class="nc" id="L610">                break;</span>
              case TabStop.ALIGN_CENTER:
<span class="nc" id="L612">                writeControlWord(&quot;tqc&quot;);</span>
<span class="nc" id="L613">                break;</span>
              case TabStop.ALIGN_DECIMAL:
<span class="nc" id="L615">                writeControlWord(&quot;tqdec&quot;);</span>
                break;
            }
<span class="nc bnc" id="L618" title="All 7 branches missed.">            switch (tab.getLeader()) {</span>
              case TabStop.LEAD_NONE:
<span class="nc" id="L620">                break;</span>
              case TabStop.LEAD_DOTS:
<span class="nc" id="L622">                writeControlWord(&quot;tldot&quot;);</span>
<span class="nc" id="L623">                break;</span>
              case TabStop.LEAD_HYPHENS:
<span class="nc" id="L625">                writeControlWord(&quot;tlhyph&quot;);</span>
<span class="nc" id="L626">                break;</span>
              case TabStop.LEAD_UNDERLINE:
<span class="nc" id="L628">                writeControlWord(&quot;tlul&quot;);</span>
<span class="nc" id="L629">                break;</span>
              case TabStop.LEAD_THICKLINE:
<span class="nc" id="L631">                writeControlWord(&quot;tlth&quot;);</span>
<span class="nc" id="L632">                break;</span>
              case TabStop.LEAD_EQUALS:
<span class="nc" id="L634">                writeControlWord(&quot;tleq&quot;);</span>
                break;
            }
<span class="nc" id="L637">            int twips = Math.round(20f * tab.getPosition());</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (tab.getAlignment() == TabStop.ALIGN_BAR) {</span>
<span class="nc" id="L639">                writeControlWord(&quot;tb&quot;, twips);</span>
            } else {
<span class="nc" id="L641">                writeControlWord(&quot;tx&quot;, twips);</span>
            }
        }
<span class="nc" id="L644">        current.addAttribute(Constants.Tabs, tabs);</span>
    }
<span class="nc" id="L646">}</span>

public void writeParagraphElement(Element el)
    throws IOException
{
<span class="nc" id="L651">    updateParagraphAttributes(outputAttributes, el.getAttributes(), true);</span>

<span class="nc" id="L653">    int sub_count = el.getElementCount();</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">    for(int idx = 0; idx &lt; sub_count; idx ++) {</span>
<span class="nc" id="L655">        writeTextElement(el.getElement(idx));</span>
    }

<span class="nc" id="L658">    writeControlWord(&quot;par&quot;);</span>
<span class="nc" id="L659">    writeLineBreak();  /* makes the raw file more readable */</span>
<span class="nc" id="L660">}</span>

/* debugging. TODO: remove.
private static String tabdump(Object tso)
{
    String buf;
    int i;

    if (tso == null)
        return &quot;[none]&quot;;

    TabStop[] ts = (TabStop[])tso;

    buf = &quot;[&quot;;
    for(i = 0; i &lt; ts.length; i++) {
        buf = buf + ts[i].toString();
        if ((i+1) &lt; ts.length)
            buf = buf + &quot;,&quot;;
    }
    return buf + &quot;]&quot;;
}
*/

protected void resetParagraphAttributes(MutableAttributeSet currentAttributes)
    throws IOException
{
<span class="nc" id="L686">    writeControlWord(&quot;pard&quot;);</span>

<span class="nc" id="L688">    currentAttributes.addAttribute(StyleConstants.Alignment, Integer.valueOf(0));</span>

    int wordIndex;
<span class="nc" id="L691">    int wordCount = RTFAttributes.attributes.length;</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">    for(wordIndex = 0; wordIndex &lt; wordCount; wordIndex++) {</span>
<span class="nc" id="L693">        RTFAttribute attr = RTFAttributes.attributes[wordIndex];</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (attr.domain() == RTFAttribute.D_PARAGRAPH)</span>
<span class="nc" id="L695">            attr.setDefault(currentAttributes);</span>
    }

<span class="nc" id="L698">    currentAttributes.removeAttribute(&quot;paragraphStyle&quot;);</span>
<span class="nc" id="L699">    currentAttributes.removeAttribute(Constants.Tabs);</span>
<span class="nc" id="L700">}</span>

void updateCharacterAttributes(MutableAttributeSet current,
                               AttributeSet newAttributes,
                               boolean updateStyleChanges)
    throws IOException
{
    Object parm;

<span class="nc bnc" id="L709" title="All 2 branches missed.">    if (updateStyleChanges) {</span>
<span class="nc" id="L710">        Object oldStyle = current.getAttribute(&quot;characterStyle&quot;);</span>
<span class="nc" id="L711">        Object newStyle = findStyleNumber(newAttributes,</span>
                                          Constants.STCharacter);
<span class="nc bnc" id="L713" title="All 2 branches missed.">        if (oldStyle != newStyle) {</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">            if (oldStyle != null) {</span>
<span class="nc" id="L715">                resetCharacterAttributes(current);</span>
            }
<span class="nc bnc" id="L717" title="All 2 branches missed.">            if (newStyle != null) {</span>
<span class="nc" id="L718">                writeControlWord(&quot;cs&quot;, ((Integer)newStyle).intValue());</span>
<span class="nc" id="L719">                current.addAttribute(&quot;characterStyle&quot;, newStyle);</span>
            } else {
<span class="nc" id="L721">                current.removeAttribute(&quot;characterStyle&quot;);</span>
            }
        }
    }

<span class="nc bnc" id="L726" title="All 2 branches missed.">    if ((parm = attrDiff(current, newAttributes,</span>
                         StyleConstants.FontFamily, null)) != null) {
<span class="nc" id="L728">        Integer fontNum = fontTable.get(parm);</span>
<span class="nc" id="L729">        writeControlWord(&quot;f&quot;, fontNum.intValue());</span>
    }

<span class="nc" id="L732">    checkNumericControlWord(current, newAttributes,</span>
                            StyleConstants.FontSize, &quot;fs&quot;,
                            defaultFontSize, 2f);

<span class="nc" id="L736">    checkControlWords(current, newAttributes,</span>
                      RTFAttributes.attributes, RTFAttribute.D_CHARACTER);

<span class="nc" id="L739">    checkNumericControlWord(current, newAttributes,</span>
                            StyleConstants.LineSpacing, &quot;sl&quot;,
                            0, 20f); /* TODO: sl wackiness */

<span class="nc bnc" id="L743" title="All 2 branches missed.">    if ((parm = attrDiff(current, newAttributes,</span>
                         StyleConstants.Background, MagicToken)) != null) {
        int colorNum;
<span class="nc bnc" id="L746" title="All 2 branches missed.">        if (parm == MagicToken)</span>
<span class="nc" id="L747">            colorNum = 0;</span>
        else
<span class="nc" id="L749">            colorNum = colorTable.get(parm).intValue();</span>
<span class="nc" id="L750">        writeControlWord(&quot;cb&quot;, colorNum);</span>
    }

<span class="nc bnc" id="L753" title="All 2 branches missed.">    if ((parm = attrDiff(current, newAttributes,</span>
                         StyleConstants.Foreground, null)) != null) {
        int colorNum;
<span class="nc bnc" id="L756" title="All 2 branches missed.">        if (parm == MagicToken)</span>
<span class="nc" id="L757">            colorNum = 0;</span>
        else
<span class="nc" id="L759">            colorNum = colorTable.get(parm).intValue();</span>
<span class="nc" id="L760">        writeControlWord(&quot;cf&quot;, colorNum);</span>
    }
<span class="nc" id="L762">}</span>

protected void resetCharacterAttributes(MutableAttributeSet currentAttributes)
    throws IOException
{
<span class="nc" id="L767">    writeControlWord(&quot;plain&quot;);</span>

    int wordIndex;
<span class="nc" id="L770">    int wordCount = RTFAttributes.attributes.length;</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">    for(wordIndex = 0; wordIndex &lt; wordCount; wordIndex++) {</span>
<span class="nc" id="L772">        RTFAttribute attr = RTFAttributes.attributes[wordIndex];</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">        if (attr.domain() == RTFAttribute.D_CHARACTER)</span>
<span class="nc" id="L774">            attr.setDefault(currentAttributes);</span>
    }

<span class="nc" id="L777">    StyleConstants.setFontFamily(currentAttributes, defaultFontFamily);</span>
<span class="nc" id="L778">    currentAttributes.removeAttribute(StyleConstants.FontSize); /* =default */</span>
<span class="nc" id="L779">    currentAttributes.removeAttribute(StyleConstants.Background);</span>
<span class="nc" id="L780">    currentAttributes.removeAttribute(StyleConstants.Foreground);</span>
<span class="nc" id="L781">    currentAttributes.removeAttribute(StyleConstants.LineSpacing);</span>
<span class="nc" id="L782">    currentAttributes.removeAttribute(&quot;characterStyle&quot;);</span>
<span class="nc" id="L783">}</span>

public void writeTextElement(Element el)
    throws IOException
{
<span class="nc" id="L788">    updateCharacterAttributes(outputAttributes, el.getAttributes(), true);</span>

<span class="nc bnc" id="L790" title="All 2 branches missed.">    if (el.isLeaf()) {</span>
        try {
<span class="nc" id="L792">            el.getDocument().getText(el.getStartOffset(),</span>
<span class="nc" id="L793">                                     el.getEndOffset() - el.getStartOffset(),</span>
                                     this.workingSegment);
<span class="nc" id="L795">        } catch (BadLocationException ble) {</span>
            /* TODO is this the correct error to raise? */
<span class="nc" id="L797">            ble.printStackTrace();</span>
<span class="nc" id="L798">            throw new InternalError(ble.getMessage());</span>
<span class="nc" id="L799">        }</span>
<span class="nc" id="L800">        writeText(this.workingSegment);</span>
    } else {
<span class="nc" id="L802">        int sub_count = el.getElementCount();</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">        for(int idx = 0; idx &lt; sub_count; idx ++)</span>
<span class="nc" id="L804">            writeTextElement(el.getElement(idx));</span>
    }
<span class="nc" id="L806">}</span>

public void writeText(Segment s)
    throws IOException
{
    int pos, end;
    char[] array;

<span class="nc" id="L814">    pos = s.offset;</span>
<span class="nc" id="L815">    end = pos + s.count;</span>
<span class="nc" id="L816">    array = s.array;</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">    for( ; pos &lt; end; pos ++)</span>
<span class="nc" id="L818">        writeCharacter(array[pos]);</span>
<span class="nc" id="L819">}</span>

public void writeText(String s)
    throws IOException
{
    int pos, end;

<span class="nc" id="L826">    pos = 0;</span>
<span class="nc" id="L827">    end = s.length();</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">    for( ; pos &lt; end; pos ++)</span>
<span class="nc" id="L829">        writeCharacter(s.charAt(pos));</span>
<span class="nc" id="L830">}</span>

public void writeRawString(String str)
    throws IOException
{
<span class="nc" id="L835">    int strlen = str.length();</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">    for (int offset = 0; offset &lt; strlen; offset ++)</span>
<span class="nc" id="L837">        outputStream.write((int)str.charAt(offset));</span>
<span class="nc" id="L838">}</span>

public void writeControlWord(String keyword)
    throws IOException
{
<span class="nc" id="L843">    outputStream.write('\\');</span>
<span class="nc" id="L844">    writeRawString(keyword);</span>
<span class="nc" id="L845">    afterKeyword = true;</span>
<span class="nc" id="L846">}</span>

public void writeControlWord(String keyword, int arg)
    throws IOException
{
<span class="nc" id="L851">    outputStream.write('\\');</span>
<span class="nc" id="L852">    writeRawString(keyword);</span>
<span class="nc" id="L853">    writeRawString(String.valueOf(arg)); /* TODO: correct in all cases? */</span>
<span class="nc" id="L854">    afterKeyword = true;</span>
<span class="nc" id="L855">}</span>

public void writeBegingroup()
    throws IOException
{
<span class="nc" id="L860">    outputStream.write('{');</span>
<span class="nc" id="L861">    afterKeyword = false;</span>
<span class="nc" id="L862">}</span>

public void writeEndgroup()
    throws IOException
{
<span class="nc" id="L867">    outputStream.write('}');</span>
<span class="nc" id="L868">    afterKeyword = false;</span>
<span class="nc" id="L869">}</span>

public void writeCharacter(char ch)
    throws IOException
{
    /* Nonbreaking space is in most RTF encodings, but the keyword is
       preferable; same goes for tabs */
<span class="nc bnc" id="L876" title="All 2 branches missed.">    if (ch == 0xA0) { /* nonbreaking space */</span>
<span class="nc" id="L877">        outputStream.write(0x5C);  /* backslash */</span>
<span class="nc" id="L878">        outputStream.write(0x7E);  /* tilde */</span>
<span class="nc" id="L879">        afterKeyword = false; /* non-alpha keywords are self-terminating */</span>
<span class="nc" id="L880">        return;</span>
    }

<span class="nc bnc" id="L883" title="All 2 branches missed.">    if (ch == 0x09) { /* horizontal tab */</span>
<span class="nc" id="L884">        writeControlWord(&quot;tab&quot;);</span>
<span class="nc" id="L885">        return;</span>
    }

<span class="nc bnc" id="L888" title="All 4 branches missed.">    if (ch == 10 || ch == 13) { /* newline / paragraph */</span>
        /* ignore CRs, we'll write a paragraph element soon enough */
<span class="nc" id="L890">        return;</span>
    }

<span class="nc" id="L893">    int b = convertCharacter(outputConversion, ch);</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">    if (b == 0) {</span>
        /* Unicode characters which have corresponding RTF keywords */
        int i;
<span class="nc bnc" id="L897" title="All 2 branches missed.">        for(i = 0; i &lt; textKeywords.length; i++) {</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">            if (textKeywords[i].character == ch) {</span>
<span class="nc" id="L899">                writeControlWord(textKeywords[i].keyword);</span>
<span class="nc" id="L900">                return;</span>
            }
        }
        /* In some cases it would be reasonable to check to see if the
           glyph being written out is in the Symbol encoding, and if so,
           to switch to the Symbol font for this character. TODO. */
        /* Currently all unrepresentable characters are written as
           Unicode escapes. */
<span class="nc" id="L908">        String approximation = approximationForUnicode(ch);</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">        if (approximation.length() != unicodeCount) {</span>
<span class="nc" id="L910">            unicodeCount = approximation.length();</span>
<span class="nc" id="L911">            writeControlWord(&quot;uc&quot;, unicodeCount);</span>
        }
<span class="nc" id="L913">        writeControlWord(&quot;u&quot;, (int)ch);</span>
<span class="nc" id="L914">        writeRawString(&quot; &quot;);</span>
<span class="nc" id="L915">        writeRawString(approximation);</span>
<span class="nc" id="L916">        afterKeyword = false;</span>
<span class="nc" id="L917">        return;</span>
    }

<span class="nc bnc" id="L920" title="All 2 branches missed.">    if (b &gt; 127) {</span>
        int nybble;
<span class="nc" id="L922">        outputStream.write('\\');</span>
<span class="nc" id="L923">        outputStream.write('\'');</span>
<span class="nc" id="L924">        nybble = ( b &amp; 0xF0 ) &gt;&gt;&gt; 4;</span>
<span class="nc" id="L925">        outputStream.write(hexdigits[nybble]);</span>
<span class="nc" id="L926">        nybble = ( b &amp; 0x0F );</span>
<span class="nc" id="L927">        outputStream.write(hexdigits[nybble]);</span>
<span class="nc" id="L928">        afterKeyword = false;</span>
<span class="nc" id="L929">        return;</span>
    }

<span class="nc bnc" id="L932" title="All 2 branches missed.">    switch (b) {</span>
    case '}':
    case '{':
    case '\\':
<span class="nc" id="L936">        outputStream.write(0x5C);  /* backslash */</span>
<span class="nc" id="L937">        afterKeyword = false;  /* in a keyword, actually ... */</span>
        /* fall through */
    default:
<span class="nc bnc" id="L940" title="All 2 branches missed.">        if (afterKeyword) {</span>
<span class="nc" id="L941">            outputStream.write(0x20);  /* space */</span>
<span class="nc" id="L942">            afterKeyword = false;</span>
        }
<span class="nc" id="L944">        outputStream.write(b);</span>
        break;
    }
<span class="nc" id="L947">}</span>

String approximationForUnicode(char ch)
{
    /* TODO: Find reasonable approximations for all Unicode characters
       in all RTF code pages... heh, heh... */
<span class="nc" id="L953">    return &quot;?&quot;;</span>
}

/** Takes a translation table (a 256-element array of characters)
 * and creates an output conversion table for use by
 * convertCharacter(). */
    /* Not very efficient at all. Could be changed to sort the table
       for binary search. TODO. (Even though this is inefficient however,
       writing RTF is still much faster than reading it.) */
static int[] outputConversionFromTranslationTable(char[] table)
{
<span class="nc" id="L964">    int[] conversion = new int[2 * table.length];</span>

    int index;

<span class="nc bnc" id="L968" title="All 2 branches missed.">    for(index = 0; index &lt; table.length; index ++) {</span>
<span class="nc" id="L969">        conversion[index * 2] = table[index];</span>
<span class="nc" id="L970">        conversion[(index * 2) + 1] = index;</span>
    }

<span class="nc" id="L973">    return conversion;</span>
}

static int[] outputConversionForName(String name)
    throws IOException
{
<span class="nc" id="L979">    char[] table = (char[])RTFReader.getCharacterSet(name);</span>
<span class="nc" id="L980">    return outputConversionFromTranslationTable(table);</span>
}

/** Takes a char and a conversion table (an int[] in the current
 * implementation, but conversion tables should be treated as an opaque
 * type) and returns the
 * corresponding byte value (as an int, since bytes are signed).
 */
    /* Not very efficient. TODO. */
static protected int convertCharacter(int[] conversion, char ch)
{
   int index;

<span class="nc bnc" id="L993" title="All 2 branches missed.">   for(index = 0; index &lt; conversion.length; index += 2) {</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">       if(conversion[index] == ch)</span>
<span class="nc" id="L995">           return conversion[index + 1];</span>
   }

<span class="nc" id="L998">   return 0;  /* 0 indicates an unrepresentable character */</span>
}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>