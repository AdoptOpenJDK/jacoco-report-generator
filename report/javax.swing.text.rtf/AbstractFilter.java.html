<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractFilter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text.rtf</a> &gt; <span class="el_source">AbstractFilter.java</span></div><h1>AbstractFilter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text.rtf;

import java.io.*;
import java.lang.*;

/**
 * A generic superclass for streams which read and parse text
 * consisting of runs of characters interspersed with occasional
 * ``specials'' (formatting characters).
 *
 * &lt;p&gt; Most of the functionality
 * of this class would be redundant except that the
 * &lt;code&gt;ByteToChar&lt;/code&gt; converters
 * are suddenly private API. Presumably this class will disappear
 * when the API is made public again. (sigh) That will also let us handle
 * multibyte character sets...
 *
 * &lt;P&gt; A subclass should override at least &lt;code&gt;write(char)&lt;/code&gt;
 * and &lt;code&gt;writeSpecial(int)&lt;/code&gt;. For efficiency's sake it's a
 * good idea to override &lt;code&gt;write(String)&lt;/code&gt; as well. The subclass'
 * initializer may also install appropriate translation and specials tables.
 *
 * @see OutputStream
 */
abstract class AbstractFilter extends OutputStream
{
    /** A table mapping bytes to characters */
    protected char translationTable[];
    /** A table indicating which byte values should be interpreted as
     *  characters and which should be treated as formatting codes */
    protected boolean specialsTable[];

    /** A translation table which does ISO Latin-1 (trivial) */
    static final char latin1TranslationTable[];
    /** A specials table which indicates that no characters are special */
    static final boolean noSpecialsTable[];
    /** A specials table which indicates that all characters are special */
    static final boolean allSpecialsTable[];

    static {
      int i;

<span class="nc" id="L67">      noSpecialsTable = new boolean[256];</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">      for (i = 0; i &lt; 256; i++)</span>
<span class="nc" id="L69">        noSpecialsTable[i] = false;</span>

<span class="nc" id="L71">      allSpecialsTable = new boolean[256];</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">      for (i = 0; i &lt; 256; i++)</span>
<span class="nc" id="L73">        allSpecialsTable[i] = true;</span>

<span class="nc" id="L75">      latin1TranslationTable = new char[256];</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">      for (i = 0; i &lt; 256; i++)</span>
<span class="nc" id="L77">        latin1TranslationTable[i] = (char)i;</span>
<span class="nc" id="L78">    }</span>

    /**
     * A convenience method that reads text from a FileInputStream
     * and writes it to the receiver.
     * The format in which the file
     * is read is determined by the concrete subclass of
     * AbstractFilter to which this method is sent.
     * &lt;p&gt;This method does not close the receiver after reaching EOF on
     * the input stream.
     * The user must call &lt;code&gt;close()&lt;/code&gt; to ensure that all
     * data are processed.
     *
     * @param in      An InputStream providing text.
     */
    public void readFromStream(InputStream in)
      throws IOException
    {
        byte buf[];
        int count;

<span class="nc" id="L99">        buf = new byte[16384];</span>

        while(true) {
<span class="nc" id="L102">            count = in.read(buf);</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            if (count &lt; 0)</span>
<span class="nc" id="L104">                break;</span>

<span class="nc" id="L106">            this.write(buf, 0, count);</span>
        }
<span class="nc" id="L108">    }</span>

    public void readFromReader(Reader in)
      throws IOException
    {
        char buf[];
        int count;

<span class="nc" id="L116">        buf = new char[2048];</span>

        while(true) {
<span class="nc" id="L119">            count = in.read(buf);</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">            if (count &lt; 0)</span>
<span class="nc" id="L121">                break;</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L123">              this.write(buf[i]);</span>
            }
        }
<span class="nc" id="L126">    }</span>

    public AbstractFilter()
<span class="nc" id="L129">    {</span>
<span class="nc" id="L130">        translationTable = latin1TranslationTable;</span>
<span class="nc" id="L131">        specialsTable = noSpecialsTable;</span>
<span class="nc" id="L132">    }</span>

    /**
     * Implements the abstract method of OutputStream, of which this class
     * is a subclass.
     */
    public void write(int b)
      throws IOException
    {
<span class="nc bnc" id="L141" title="All 2 branches missed.">      if (b &lt; 0)</span>
<span class="nc" id="L142">        b += 256;</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">      if (specialsTable[b])</span>
<span class="nc" id="L144">        writeSpecial(b);</span>
      else {
<span class="nc" id="L146">        char ch = translationTable[b];</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (ch != (char)0)</span>
<span class="nc" id="L148">          write(ch);</span>
      }
<span class="nc" id="L150">    }</span>

    /**
     * Implements the buffer-at-a-time write method for greater
     * efficiency.
     *
     * &lt;p&gt; &lt;strong&gt;PENDING:&lt;/strong&gt; Does &lt;code&gt;write(byte[])&lt;/code&gt;
     * call &lt;code&gt;write(byte[], int, int)&lt;/code&gt; or is it the other way
     * around?
     */
    public void write(byte[] buf, int off, int len)
      throws IOException
    {
<span class="nc" id="L163">      StringBuilder accumulator = null;</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      while (len &gt; 0) {</span>
<span class="nc" id="L165">        short b = (short)buf[off];</span>

        // stupid signed bytes
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (b &lt; 0)</span>
<span class="nc" id="L169">            b += 256;</span>

<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (specialsTable[b]) {</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">          if (accumulator != null) {</span>
<span class="nc" id="L173">            write(accumulator.toString());</span>
<span class="nc" id="L174">            accumulator = null;</span>
          }
<span class="nc" id="L176">          writeSpecial(b);</span>
        } else {
<span class="nc" id="L178">          char ch = translationTable[b];</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">          if (ch != (char)0) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (accumulator == null)</span>
<span class="nc" id="L181">              accumulator = new StringBuilder();</span>
<span class="nc" id="L182">            accumulator.append(ch);</span>
          }
        }

<span class="nc" id="L186">        len --;</span>
<span class="nc" id="L187">        off ++;</span>
<span class="nc" id="L188">      }</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">      if (accumulator != null)</span>
<span class="nc" id="L191">        write(accumulator.toString());</span>
<span class="nc" id="L192">    }</span>

    /**
     * Hopefully, all subclasses will override this method to accept strings
     * of text, but if they don't, AbstractFilter's implementation
     * will spoon-feed them via &lt;code&gt;write(char)&lt;/code&gt;.
     *
     * @param s The string of non-special characters written to the
     *          OutputStream.
     */
    public void write(String s)
      throws IOException
    {
      int index, length;

<span class="nc" id="L207">      length = s.length();</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">      for(index = 0; index &lt; length; index ++) {</span>
<span class="nc" id="L209">        write(s.charAt(index));</span>
      }
<span class="nc" id="L211">    }</span>

    /**
     * Subclasses must provide an implementation of this method which
     * accepts a single (non-special) character.
     *
     * @param ch The character written to the OutputStream.
     */
    protected abstract void write(char ch) throws IOException;

    /**
     * Subclasses must provide an implementation of this method which
     * accepts a single special byte. No translation is performed
     * on specials.
     *
     * @param b The byte written to the OutputStream.
     */
    protected abstract void writeSpecial(int b) throws IOException;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>