<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RTFReader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text.rtf</a> &gt; <span class="el_source">RTFReader.java</span></div><h1>RTFReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text.rtf;

import java.lang.*;
import java.util.*;
import java.io.*;
import java.awt.Font;
import java.awt.Color;

import javax.swing.text.*;

/**
 * Takes a sequence of RTF tokens and text and appends the text
 * described by the RTF to a &lt;code&gt;StyledDocument&lt;/code&gt; (the &lt;em&gt;target&lt;/em&gt;).
 * The RTF is lexed
 * from the character stream by the &lt;code&gt;RTFParser&lt;/code&gt; which is this class's
 * superclass.
 *
 * This class is an indirect subclass of OutputStream. It must be closed
 * in order to guarantee that all of the text has been sent to
 * the text acceptor.
 *
 *   @see RTFParser
 *   @see java.io.OutputStream
 */
class RTFReader extends RTFParser
{
  /** The object to which the parsed text is sent. */
  StyledDocument target;

  /** Miscellaneous information about the parser's state. This
   *  dictionary is saved and restored when an RTF group begins
   *  or ends. */
  Dictionary&lt;Object, Object&gt; parserState;   /* Current parser state */
  /** This is the &quot;dst&quot; item from parserState. rtfDestination
   *  is the current rtf destination. It is cached in an instance
   *  variable for speed. */
  Destination rtfDestination;
  /** This holds the current document attributes. */
  MutableAttributeSet documentAttributes;

  /** This Dictionary maps Integer font numbers to String font names. */
  Dictionary&lt;Integer, String&gt; fontTable;
  /** This array maps color indices to Color objects. */
  Color[] colorTable;
  /** This array maps character style numbers to Style objects. */
  Style[] characterStyles;
  /** This array maps paragraph style numbers to Style objects. */
  Style[] paragraphStyles;
  /** This array maps section style numbers to Style objects. */
  Style[] sectionStyles;

  /** This is the RTF version number, extracted from the \rtf keyword.
   *  The version information is currently not used. */
  int rtfversion;

  /** &lt;code&gt;true&lt;/code&gt; to indicate that if the next keyword is unknown,
   *  the containing group should be ignored. */
  boolean ignoreGroupIfUnknownKeyword;

  /** The parameter of the most recently parsed \\ucN keyword,
   *  used for skipping alternative representations after a
   *  Unicode character. */
  int skippingCharacters;

  static private Dictionary&lt;String, RTFAttribute&gt; straightforwardAttributes;
  static {
<span class="nc" id="L91">      straightforwardAttributes = RTFAttributes.attributesByKeyword();</span>
  }

  private MockAttributeSet mockery;

  /* this should be final, but there's a bug in javac... */
  /** textKeywords maps RTF keywords to single-character strings,
   *  for those keywords which simply insert some text. */
<span class="nc" id="L99">  static Dictionary&lt;String, String&gt; textKeywords = null;</span>
  static {
<span class="nc" id="L101">      textKeywords = new Hashtable&lt;String, String&gt;();</span>
<span class="nc" id="L102">      textKeywords.put(&quot;\\&quot;,         &quot;\\&quot;);</span>
<span class="nc" id="L103">      textKeywords.put(&quot;{&quot;,          &quot;{&quot;);</span>
<span class="nc" id="L104">      textKeywords.put(&quot;}&quot;,          &quot;}&quot;);</span>
<span class="nc" id="L105">      textKeywords.put(&quot; &quot;,          &quot;\u00A0&quot;);  /* not in the spec... */</span>
<span class="nc" id="L106">      textKeywords.put(&quot;~&quot;,          &quot;\u00A0&quot;);  /* nonbreaking space */</span>
<span class="nc" id="L107">      textKeywords.put(&quot;_&quot;,          &quot;\u2011&quot;);  /* nonbreaking hyphen */</span>
<span class="nc" id="L108">      textKeywords.put(&quot;bullet&quot;,     &quot;\u2022&quot;);</span>
<span class="nc" id="L109">      textKeywords.put(&quot;emdash&quot;,     &quot;\u2014&quot;);</span>
<span class="nc" id="L110">      textKeywords.put(&quot;emspace&quot;,    &quot;\u2003&quot;);</span>
<span class="nc" id="L111">      textKeywords.put(&quot;endash&quot;,     &quot;\u2013&quot;);</span>
<span class="nc" id="L112">      textKeywords.put(&quot;enspace&quot;,    &quot;\u2002&quot;);</span>
<span class="nc" id="L113">      textKeywords.put(&quot;ldblquote&quot;,  &quot;\u201C&quot;);</span>
<span class="nc" id="L114">      textKeywords.put(&quot;lquote&quot;,     &quot;\u2018&quot;);</span>
<span class="nc" id="L115">      textKeywords.put(&quot;ltrmark&quot;,    &quot;\u200E&quot;);</span>
<span class="nc" id="L116">      textKeywords.put(&quot;rdblquote&quot;,  &quot;\u201D&quot;);</span>
<span class="nc" id="L117">      textKeywords.put(&quot;rquote&quot;,     &quot;\u2019&quot;);</span>
<span class="nc" id="L118">      textKeywords.put(&quot;rtlmark&quot;,    &quot;\u200F&quot;);</span>
<span class="nc" id="L119">      textKeywords.put(&quot;tab&quot;,        &quot;\u0009&quot;);</span>
<span class="nc" id="L120">      textKeywords.put(&quot;zwj&quot;,        &quot;\u200D&quot;);</span>
<span class="nc" id="L121">      textKeywords.put(&quot;zwnj&quot;,       &quot;\u200C&quot;);</span>

      /* There is no Unicode equivalent to an optional hyphen, as far as
         I can tell. */
<span class="nc" id="L125">      textKeywords.put(&quot;-&quot;,          &quot;\u2027&quot;);  /* TODO: optional hyphen */</span>
  }

  /* some entries in parserState */
  static final String TabAlignmentKey = &quot;tab_alignment&quot;;
  static final String TabLeaderKey = &quot;tab_leader&quot;;

  static Dictionary&lt;String, char[]&gt; characterSets;
<span class="nc" id="L133">  static boolean useNeXTForAnsi = false;</span>
  static {
<span class="nc" id="L135">      characterSets = new Hashtable&lt;String, char[]&gt;();</span>
<span class="nc" id="L136">  }</span>

/* TODO: per-font font encodings ( \fcharset control word ) ? */

/**
 * Creates a new RTFReader instance. Text will be sent to
 * the specified TextAcceptor.
 *
 * @param destination The TextAcceptor which is to receive the text.
 */
public RTFReader(StyledDocument destination)
<span class="nc" id="L147">{</span>
    int i;

<span class="nc" id="L150">    target = destination;</span>
<span class="nc" id="L151">    parserState = new Hashtable&lt;Object, Object&gt;();</span>
<span class="nc" id="L152">    fontTable = new Hashtable&lt;Integer, String&gt;();</span>

<span class="nc" id="L154">    rtfversion = -1;</span>

<span class="nc" id="L156">    mockery = new MockAttributeSet();</span>
<span class="nc" id="L157">    documentAttributes = new SimpleAttributeSet();</span>
<span class="nc" id="L158">}</span>

/** Called when the RTFParser encounters a bin keyword in the
 *  RTF stream.
 *
 *  @see RTFParser
 */
public void handleBinaryBlob(byte[] data)
{
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (skippingCharacters &gt; 0) {</span>
        /* a blob only counts as one character for skipping purposes */
<span class="nc" id="L169">        skippingCharacters --;</span>
<span class="nc" id="L170">        return;</span>
    }

    /* someday, someone will want to do something with blobs */
<span class="nc" id="L174">}</span>


/**
 * Handles any pure text (containing no control characters) in the input
 * stream. Called by the superclass. */
public void handleText(String text)
{
<span class="nc bnc" id="L182" title="All 2 branches missed.">    if (skippingCharacters &gt; 0) {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (skippingCharacters &gt;= text.length()) {</span>
<span class="nc" id="L184">            skippingCharacters -= text.length();</span>
<span class="nc" id="L185">            return;</span>
        } else {
<span class="nc" id="L187">            text = text.substring(skippingCharacters);</span>
<span class="nc" id="L188">            skippingCharacters = 0;</span>
        }
    }

<span class="nc bnc" id="L192" title="All 2 branches missed.">    if (rtfDestination != null) {</span>
<span class="nc" id="L193">        rtfDestination.handleText(text);</span>
<span class="nc" id="L194">        return;</span>
    }

<span class="nc" id="L197">    warning(&quot;Text with no destination. oops.&quot;);</span>
<span class="nc" id="L198">}</span>

/** The default color for text which has no specified color. */
Color defaultColor()
{
<span class="nc" id="L203">    return Color.black;</span>
}

/** Called by the superclass when a new RTF group is begun.
 *  This implementation saves the current &lt;code&gt;parserState&lt;/code&gt;, and gives
 *  the current destination a chance to save its own state.
 * @see RTFParser#begingroup
 */
public void begingroup()
{
<span class="nc bnc" id="L213" title="All 2 branches missed.">    if (skippingCharacters &gt; 0) {</span>
        /* TODO this indicates an error in the RTF. Log it? */
<span class="nc" id="L215">        skippingCharacters = 0;</span>
    }

    /* we do this little dance to avoid cloning the entire state stack and
       immediately throwing it away. */
<span class="nc" id="L220">    Object oldSaveState = parserState.get(&quot;_savedState&quot;);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">    if (oldSaveState != null)</span>
<span class="nc" id="L222">        parserState.remove(&quot;_savedState&quot;);</span>
<span class="nc" id="L223">    Dictionary&lt;String, Object&gt; saveState = (Dictionary&lt;String, Object&gt;)((Hashtable)parserState).clone();</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">    if (oldSaveState != null)</span>
<span class="nc" id="L225">        saveState.put(&quot;_savedState&quot;, oldSaveState);</span>
<span class="nc" id="L226">    parserState.put(&quot;_savedState&quot;, saveState);</span>

<span class="nc bnc" id="L228" title="All 2 branches missed.">    if (rtfDestination != null)</span>
<span class="nc" id="L229">        rtfDestination.begingroup();</span>
<span class="nc" id="L230">}</span>

/** Called by the superclass when the current RTF group is closed.
 *  This restores the parserState saved by &lt;code&gt;begingroup()&lt;/code&gt;
 *  as well as invoking the endgroup method of the current
 *  destination.
 * @see RTFParser#endgroup
 */
public void endgroup()
{
<span class="nc bnc" id="L240" title="All 2 branches missed.">    if (skippingCharacters &gt; 0) {</span>
        /* NB this indicates an error in the RTF. Log it? */
<span class="nc" id="L242">        skippingCharacters = 0;</span>
    }

<span class="nc" id="L245">    Dictionary&lt;Object, Object&gt; restoredState = (Dictionary&lt;Object, Object&gt;)parserState.get(&quot;_savedState&quot;);</span>
<span class="nc" id="L246">    Destination restoredDestination = (Destination)restoredState.get(&quot;dst&quot;);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">    if (restoredDestination != rtfDestination) {</span>
<span class="nc" id="L248">        rtfDestination.close(); /* allow the destination to clean up */</span>
<span class="nc" id="L249">        rtfDestination = restoredDestination;</span>
    }
<span class="nc" id="L251">    Dictionary oldParserState = parserState;</span>
<span class="nc" id="L252">    parserState = restoredState;</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    if (rtfDestination != null)</span>
<span class="nc" id="L254">        rtfDestination.endgroup(oldParserState);</span>
<span class="nc" id="L255">}</span>

protected void setRTFDestination(Destination newDestination)
{
    /* Check that setting the destination won't close the
       current destination (should never happen) */
<span class="nc" id="L261">    Dictionary previousState = (Dictionary)parserState.get(&quot;_savedState&quot;);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">    if (previousState != null) {</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (rtfDestination != previousState.get(&quot;dst&quot;)) {</span>
<span class="nc" id="L264">            warning(&quot;Warning, RTF destination overridden, invalid RTF.&quot;);</span>
<span class="nc" id="L265">            rtfDestination.close();</span>
        }
    }
<span class="nc" id="L268">    rtfDestination = newDestination;</span>
<span class="nc" id="L269">    parserState.put(&quot;dst&quot;, rtfDestination);</span>
<span class="nc" id="L270">}</span>

/** Called by the user when there is no more input (&lt;i&gt;i.e.&lt;/i&gt;,
 * at the end of the RTF file.)
 *
 * @see OutputStream#close
 */
public void close()
    throws IOException
{
<span class="nc" id="L280">    Enumeration docProps = documentAttributes.getAttributeNames();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">    while(docProps.hasMoreElements()) {</span>
<span class="nc" id="L282">        Object propName = docProps.nextElement();</span>
<span class="nc" id="L283">        target.putProperty(propName,</span>
<span class="nc" id="L284">                           documentAttributes.getAttribute(propName));</span>
<span class="nc" id="L285">    }</span>

    /* RTFParser should have ensured that all our groups are closed */

<span class="nc" id="L289">    warning(&quot;RTF filter done.&quot;);</span>

<span class="nc" id="L291">    super.close();</span>
<span class="nc" id="L292">}</span>

/**
 * Handles a parameterless RTF keyword. This is called by the superclass
 * (RTFParser) when a keyword is found in the input stream.
 *
 * @returns &lt;code&gt;true&lt;/code&gt; if the keyword is recognized and handled;
 *          &lt;code&gt;false&lt;/code&gt; otherwise
 * @see RTFParser#handleKeyword
 */
public boolean handleKeyword(String keyword)
{
    String item;
<span class="nc" id="L305">    boolean ignoreGroupIfUnknownKeywordSave = ignoreGroupIfUnknownKeyword;</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">    if (skippingCharacters &gt; 0) {</span>
<span class="nc" id="L308">        skippingCharacters --;</span>
<span class="nc" id="L309">        return true;</span>
    }

<span class="nc" id="L312">    ignoreGroupIfUnknownKeyword = false;</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">    if ((item = textKeywords.get(keyword)) != null) {</span>
<span class="nc" id="L315">        handleText(item);</span>
<span class="nc" id="L316">        return true;</span>
    }

<span class="nc bnc" id="L319" title="All 2 branches missed.">    if (keyword.equals(&quot;fonttbl&quot;)) {</span>
<span class="nc" id="L320">        setRTFDestination(new FonttblDestination());</span>
<span class="nc" id="L321">        return true;</span>
    }

<span class="nc bnc" id="L324" title="All 2 branches missed.">    if (keyword.equals(&quot;colortbl&quot;)) {</span>
<span class="nc" id="L325">        setRTFDestination(new ColortblDestination());</span>
<span class="nc" id="L326">        return true;</span>
    }

<span class="nc bnc" id="L329" title="All 2 branches missed.">    if (keyword.equals(&quot;stylesheet&quot;)) {</span>
<span class="nc" id="L330">        setRTFDestination(new StylesheetDestination());</span>
<span class="nc" id="L331">        return true;</span>
    }

<span class="nc bnc" id="L334" title="All 2 branches missed.">    if (keyword.equals(&quot;info&quot;)) {</span>
<span class="nc" id="L335">        setRTFDestination(new InfoDestination());</span>
<span class="nc" id="L336">        return false;</span>
    }

<span class="nc bnc" id="L339" title="All 2 branches missed.">    if (keyword.equals(&quot;mac&quot;)) {</span>
<span class="nc" id="L340">        setCharacterSet(&quot;mac&quot;);</span>
<span class="nc" id="L341">        return true;</span>
    }

<span class="nc bnc" id="L344" title="All 2 branches missed.">    if (keyword.equals(&quot;ansi&quot;)) {</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (useNeXTForAnsi)</span>
<span class="nc" id="L346">            setCharacterSet(&quot;NeXT&quot;);</span>
        else
<span class="nc" id="L348">            setCharacterSet(&quot;ansi&quot;);</span>
<span class="nc" id="L349">        return true;</span>
    }

<span class="nc bnc" id="L352" title="All 2 branches missed.">    if (keyword.equals(&quot;next&quot;)) {</span>
<span class="nc" id="L353">        setCharacterSet(&quot;NeXT&quot;);</span>
<span class="nc" id="L354">        return true;</span>
    }

<span class="nc bnc" id="L357" title="All 2 branches missed.">    if (keyword.equals(&quot;pc&quot;)) {</span>
<span class="nc" id="L358">        setCharacterSet(&quot;cpg437&quot;); /* IBM Code Page 437 */</span>
<span class="nc" id="L359">        return true;</span>
    }

<span class="nc bnc" id="L362" title="All 2 branches missed.">    if (keyword.equals(&quot;pca&quot;)) {</span>
<span class="nc" id="L363">        setCharacterSet(&quot;cpg850&quot;); /* IBM Code Page 850 */</span>
<span class="nc" id="L364">        return true;</span>
    }

<span class="nc bnc" id="L367" title="All 2 branches missed.">    if (keyword.equals(&quot;*&quot;)) {</span>
<span class="nc" id="L368">        ignoreGroupIfUnknownKeyword = true;</span>
<span class="nc" id="L369">        return true;</span>
    }

<span class="nc bnc" id="L372" title="All 2 branches missed.">    if (rtfDestination != null) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if(rtfDestination.handleKeyword(keyword))</span>
<span class="nc" id="L374">            return true;</span>
    }

    /* this point is reached only if the keyword is unrecognized */

    /* other destinations we don't understand and therefore ignore */
<span class="nc bnc" id="L380" title="All 2 branches missed.">    if (keyword.equals(&quot;aftncn&quot;) ||</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        keyword.equals(&quot;aftnsep&quot;) ||</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">        keyword.equals(&quot;aftnsepc&quot;) ||</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        keyword.equals(&quot;annotation&quot;) ||</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        keyword.equals(&quot;atnauthor&quot;) ||</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        keyword.equals(&quot;atnicn&quot;) ||</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        keyword.equals(&quot;atnid&quot;) ||</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        keyword.equals(&quot;atnref&quot;) ||</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        keyword.equals(&quot;atntime&quot;) ||</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        keyword.equals(&quot;atrfend&quot;) ||</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        keyword.equals(&quot;atrfstart&quot;) ||</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        keyword.equals(&quot;bkmkend&quot;) ||</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        keyword.equals(&quot;bkmkstart&quot;) ||</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        keyword.equals(&quot;datafield&quot;) ||</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">        keyword.equals(&quot;do&quot;) ||</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">        keyword.equals(&quot;dptxbxtext&quot;) ||</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">        keyword.equals(&quot;falt&quot;) ||</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        keyword.equals(&quot;field&quot;) ||</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        keyword.equals(&quot;file&quot;) ||</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        keyword.equals(&quot;filetbl&quot;) ||</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        keyword.equals(&quot;fname&quot;) ||</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        keyword.equals(&quot;fontemb&quot;) ||</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">        keyword.equals(&quot;fontfile&quot;) ||</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        keyword.equals(&quot;footer&quot;) ||</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        keyword.equals(&quot;footerf&quot;) ||</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        keyword.equals(&quot;footerl&quot;) ||</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        keyword.equals(&quot;footerr&quot;) ||</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        keyword.equals(&quot;footnote&quot;) ||</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        keyword.equals(&quot;ftncn&quot;) ||</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">        keyword.equals(&quot;ftnsep&quot;) ||</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        keyword.equals(&quot;ftnsepc&quot;) ||</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">        keyword.equals(&quot;header&quot;) ||</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        keyword.equals(&quot;headerf&quot;) ||</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">        keyword.equals(&quot;headerl&quot;) ||</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">        keyword.equals(&quot;headerr&quot;) ||</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        keyword.equals(&quot;keycode&quot;) ||</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">        keyword.equals(&quot;nextfile&quot;) ||</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">        keyword.equals(&quot;object&quot;) ||</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        keyword.equals(&quot;pict&quot;) ||</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">        keyword.equals(&quot;pn&quot;) ||</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        keyword.equals(&quot;pnseclvl&quot;) ||</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        keyword.equals(&quot;pntxtb&quot;) ||</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">        keyword.equals(&quot;pntxta&quot;) ||</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        keyword.equals(&quot;revtbl&quot;) ||</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        keyword.equals(&quot;rxe&quot;) ||</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        keyword.equals(&quot;tc&quot;) ||</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">        keyword.equals(&quot;template&quot;) ||</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        keyword.equals(&quot;txe&quot;) ||</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">        keyword.equals(&quot;xe&quot;)) {</span>
<span class="nc" id="L429">        ignoreGroupIfUnknownKeywordSave = true;</span>
    }

<span class="nc bnc" id="L432" title="All 2 branches missed.">    if (ignoreGroupIfUnknownKeywordSave) {</span>
<span class="nc" id="L433">        setRTFDestination(new DiscardingDestination());</span>
    }

<span class="nc" id="L436">    return false;</span>
}

/**
 * Handles an RTF keyword and its integer parameter.
 * This is called by the superclass
 * (RTFParser) when a keyword is found in the input stream.
 *
 * @returns &lt;code&gt;true&lt;/code&gt; if the keyword is recognized and handled;
 *          &lt;code&gt;false&lt;/code&gt; otherwise
 * @see RTFParser#handleKeyword
 */
public boolean handleKeyword(String keyword, int parameter)
{
<span class="nc" id="L450">    boolean ignoreGroupIfUnknownKeywordSave = ignoreGroupIfUnknownKeyword;</span>

<span class="nc bnc" id="L452" title="All 2 branches missed.">    if (skippingCharacters &gt; 0) {</span>
<span class="nc" id="L453">        skippingCharacters --;</span>
<span class="nc" id="L454">        return true;</span>
    }

<span class="nc" id="L457">    ignoreGroupIfUnknownKeyword = false;</span>

<span class="nc bnc" id="L459" title="All 2 branches missed.">    if (keyword.equals(&quot;uc&quot;)) {</span>
        /* count of characters to skip after a unicode character */
<span class="nc" id="L461">        parserState.put(&quot;UnicodeSkip&quot;, Integer.valueOf(parameter));</span>
<span class="nc" id="L462">        return true;</span>
    }
<span class="nc bnc" id="L464" title="All 2 branches missed.">    if (keyword.equals(&quot;u&quot;)) {</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (parameter &lt; 0)</span>
<span class="nc" id="L466">            parameter = parameter + 65536;</span>
<span class="nc" id="L467">        handleText((char)parameter);</span>
<span class="nc" id="L468">        Number skip = (Number)(parserState.get(&quot;UnicodeSkip&quot;));</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (skip != null) {</span>
<span class="nc" id="L470">            skippingCharacters = skip.intValue();</span>
        } else {
<span class="nc" id="L472">            skippingCharacters = 1;</span>
        }
<span class="nc" id="L474">        return true;</span>
    }

<span class="nc bnc" id="L477" title="All 2 branches missed.">    if (keyword.equals(&quot;rtf&quot;)) {</span>
<span class="nc" id="L478">        rtfversion = parameter;</span>
<span class="nc" id="L479">        setRTFDestination(new DocumentDestination());</span>
<span class="nc" id="L480">        return true;</span>
    }

<span class="nc bnc" id="L483" title="All 2 branches missed.">    if (keyword.startsWith(&quot;NeXT&quot;) ||</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        keyword.equals(&quot;private&quot;))</span>
<span class="nc" id="L485">        ignoreGroupIfUnknownKeywordSave = true;</span>

<span class="nc bnc" id="L487" title="All 2 branches missed.">    if (rtfDestination != null) {</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if(rtfDestination.handleKeyword(keyword, parameter))</span>
<span class="nc" id="L489">            return true;</span>
    }

    /* this point is reached only if the keyword is unrecognized */

<span class="nc bnc" id="L494" title="All 2 branches missed.">    if (ignoreGroupIfUnknownKeywordSave) {</span>
<span class="nc" id="L495">        setRTFDestination(new DiscardingDestination());</span>
    }

<span class="nc" id="L498">    return false;</span>
}

private void setTargetAttribute(String name, Object value)
{
//    target.changeAttributes(new LFDictionary(LFArray.arrayWithObject(value), LFArray.arrayWithObject(name)));
<span class="nc" id="L504">}</span>

/**
 * setCharacterSet sets the current translation table to correspond with
 * the named character set. The character set is loaded if necessary.
 *
 * @see AbstractFilter
 */
public void setCharacterSet(String name)
{
    Object set;

    try {
<span class="nc" id="L517">        set = getCharacterSet(name);</span>
<span class="nc" id="L518">    } catch (Exception e) {</span>
<span class="nc" id="L519">        warning(&quot;Exception loading RTF character set \&quot;&quot; + name + &quot;\&quot;: &quot; + e);</span>
<span class="nc" id="L520">        set = null;</span>
<span class="nc" id="L521">    }</span>

<span class="nc bnc" id="L523" title="All 2 branches missed.">    if (set != null) {</span>
<span class="nc" id="L524">        translationTable = (char[])set;</span>
    } else {
<span class="nc" id="L526">        warning(&quot;Unknown RTF character set \&quot;&quot; + name + &quot;\&quot;&quot;);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (!name.equals(&quot;ansi&quot;)) {</span>
            try {
<span class="nc" id="L529">                translationTable = (char[])getCharacterSet(&quot;ansi&quot;);</span>
<span class="nc" id="L530">            } catch (IOException e) {</span>
<span class="nc" id="L531">                throw new InternalError(&quot;RTFReader: Unable to find character set resources (&quot; + e + &quot;)&quot;, e);</span>
<span class="nc" id="L532">            }</span>
        }
    }

<span class="nc" id="L536">    setTargetAttribute(Constants.RTFCharacterSet, name);</span>
<span class="nc" id="L537">}</span>

/** Adds a character set to the RTFReader's list
 *  of known character sets */
public static void
defineCharacterSet(String name, char[] table)
{
<span class="nc bnc" id="L544" title="All 2 branches missed.">    if (table.length &lt; 256)</span>
<span class="nc" id="L545">        throw new IllegalArgumentException(&quot;Translation table must have 256 entries.&quot;);</span>
<span class="nc" id="L546">    characterSets.put(name, table);</span>
<span class="nc" id="L547">}</span>

/** Looks up a named character set. A character set is a 256-entry
 *  array of characters, mapping unsigned byte values to their Unicode
 *  equivalents. The character set is loaded if necessary.
 *
 *  @returns the character set
 */
public static Object
getCharacterSet(final String name)
    throws IOException
{
<span class="nc" id="L559">    char[] set = characterSets.get(name);</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">    if (set == null) {</span>
      InputStream charsetStream;
<span class="nc" id="L562">      charsetStream = java.security.AccessController.</span>
<span class="nc" id="L563">              doPrivileged(new java.security.PrivilegedAction&lt;InputStream&gt;() {</span>
          public InputStream run() {
<span class="nc" id="L565">              return RTFReader.class.getResourceAsStream</span>
<span class="nc" id="L566">                                     (&quot;charsets/&quot; + name + &quot;.txt&quot;);</span>
          }
      });
<span class="nc" id="L569">      set = readCharset(charsetStream);</span>
<span class="nc" id="L570">      defineCharacterSet(name, set);</span>
    }
<span class="nc" id="L572">    return set;</span>
}

/** Parses a character set from an InputStream. The character set
 * must contain 256 decimal integers, separated by whitespace, with
 * no punctuation. B- and C- style comments are allowed.
 *
 * @returns the newly read character set
 */
static char[] readCharset(InputStream strm)
     throws IOException
{
<span class="nc" id="L584">    char[] values = new char[256];</span>
    int i;
<span class="nc" id="L586">    StreamTokenizer in = new StreamTokenizer(new BufferedReader(</span>
            new InputStreamReader(strm, &quot;ISO-8859-1&quot;)));

<span class="nc" id="L589">    in.eolIsSignificant(false);</span>
<span class="nc" id="L590">    in.commentChar('#');</span>
<span class="nc" id="L591">    in.slashSlashComments(true);</span>
<span class="nc" id="L592">    in.slashStarComments(true);</span>

<span class="nc" id="L594">    i = 0;</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">    while (i &lt; 256) {</span>
        int ttype;
        try {
<span class="nc" id="L598">            ttype = in.nextToken();</span>
<span class="nc" id="L599">        } catch (Exception e) {</span>
<span class="nc" id="L600">            throw new IOException(&quot;Unable to read from character set file (&quot; + e + &quot;)&quot;);</span>
<span class="nc" id="L601">        }</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (ttype != in.TT_NUMBER) {</span>
//          System.out.println(&quot;Bad token: type=&quot; + ttype + &quot; tok=&quot; + in.sval);
<span class="nc" id="L604">            throw new IOException(&quot;Unexpected token in character set file&quot;);</span>
//          continue;
        }
<span class="nc" id="L607">        values[i] = (char)(in.nval);</span>
<span class="nc" id="L608">        i++;</span>
<span class="nc" id="L609">    }</span>

<span class="nc" id="L611">    return values;</span>
}

static char[] readCharset(java.net.URL href)
     throws IOException
{
<span class="nc" id="L617">    return readCharset(href.openStream());</span>
}

/** An interface (could be an entirely abstract class) describing
 *  a destination. The RTF reader always has a current destination
 *  which is where text is sent.
 *
 *  @see RTFReader
 */
interface Destination {
    void handleBinaryBlob(byte[] data);
    void handleText(String text);
    boolean handleKeyword(String keyword);
    boolean handleKeyword(String keyword, int parameter);

    void begingroup();
    void endgroup(Dictionary oldState);

    void close();
}

/** This data-sink class is used to implement ignored destinations
 *  (e.g. {\*\blegga blah blah blah} )
 *  It accepts all keywords and text but does nothing with them. */
<span class="nc" id="L641">class DiscardingDestination implements Destination</span>
{
    public void handleBinaryBlob(byte[] data)
    {
        /* Discard binary blobs. */
<span class="nc" id="L646">    }</span>

    public void handleText(String text)
    {
        /* Discard text. */
<span class="nc" id="L651">    }</span>

    public boolean handleKeyword(String text)
    {
        /* Accept and discard keywords. */
<span class="nc" id="L656">        return true;</span>
    }

    public boolean handleKeyword(String text, int parameter)
    {
        /* Accept and discard parameterized keywords. */
<span class="nc" id="L662">        return true;</span>
    }

    public void begingroup()
    {
        /* Ignore groups --- the RTFReader will keep track of the
           current group level as necessary */
<span class="nc" id="L669">    }</span>

    public void endgroup(Dictionary oldState)
    {
        /* Ignore groups */
<span class="nc" id="L674">    }</span>

    public void close()
    {
        /* No end-of-destination cleanup needed */
<span class="nc" id="L679">    }</span>
}

/** Reads the fonttbl group, inserting fonts into the RTFReader's
 *  fontTable dictionary. */
<span class="nc" id="L684">class FonttblDestination implements Destination</span>
{
    int nextFontNumber;
<span class="nc" id="L687">    Integer fontNumberKey = null;</span>
    String nextFontFamily;

    public void handleBinaryBlob(byte[] data)
<span class="nc" id="L691">    { /* Discard binary blobs. */ }</span>

    public void handleText(String text)
    {
<span class="nc" id="L695">        int semicolon = text.indexOf(';');</span>
        String fontName;

<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (semicolon &gt; -1)</span>
<span class="nc" id="L699">            fontName = text.substring(0, semicolon);</span>
        else
<span class="nc" id="L701">            fontName = text;</span>


        /* TODO: do something with the font family. */

<span class="nc bnc" id="L706" title="All 4 branches missed.">        if (nextFontNumber == -1</span>
            &amp;&amp; fontNumberKey != null) {
            //font name might be broken across multiple calls
<span class="nc" id="L709">            fontName = fontTable.get(fontNumberKey) + fontName;</span>
        } else {
<span class="nc" id="L711">            fontNumberKey = Integer.valueOf(nextFontNumber);</span>
        }
<span class="nc" id="L713">        fontTable.put(fontNumberKey, fontName);</span>

<span class="nc" id="L715">        nextFontNumber = -1;</span>
<span class="nc" id="L716">        nextFontFamily = null;</span>
<span class="nc" id="L717">    }</span>

    public boolean handleKeyword(String keyword)
    {
<span class="nc bnc" id="L721" title="All 2 branches missed.">        if (keyword.charAt(0) == 'f') {</span>
<span class="nc" id="L722">            nextFontFamily = keyword.substring(1);</span>
<span class="nc" id="L723">            return true;</span>
        }

<span class="nc" id="L726">        return false;</span>
    }

    public boolean handleKeyword(String keyword, int parameter)
    {
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (keyword.equals(&quot;f&quot;)) {</span>
<span class="nc" id="L732">            nextFontNumber = parameter;</span>
<span class="nc" id="L733">            return true;</span>
        }

<span class="nc" id="L736">        return false;</span>
    }

    /* Groups are irrelevant. */
<span class="nc" id="L740">    public void begingroup() {}</span>
<span class="nc" id="L741">    public void endgroup(Dictionary oldState) {}</span>

    /* currently, the only thing we do when the font table ends is
       dump its contents to the debugging log. */
    public void close()
    {
<span class="nc" id="L747">        Enumeration&lt;Integer&gt; nums = fontTable.keys();</span>
<span class="nc" id="L748">        warning(&quot;Done reading font table.&quot;);</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">        while(nums.hasMoreElements()) {</span>
<span class="nc" id="L750">            Integer num = nums.nextElement();</span>
<span class="nc" id="L751">            warning(&quot;Number &quot; + num + &quot;: &quot; + fontTable.get(num));</span>
<span class="nc" id="L752">        }</span>
<span class="nc" id="L753">    }</span>
}

/** Reads the colortbl group. Upon end-of-group, the RTFReader's
 *  color table is set to an array containing the read colors. */
class ColortblDestination implements Destination
{
    int red, green, blue;
    Vector&lt;Color&gt; proTemTable;

    public ColortblDestination()
<span class="nc" id="L764">    {</span>
<span class="nc" id="L765">        red = 0;</span>
<span class="nc" id="L766">        green = 0;</span>
<span class="nc" id="L767">        blue = 0;</span>
<span class="nc" id="L768">        proTemTable = new Vector&lt;Color&gt;();</span>
<span class="nc" id="L769">    }</span>

    public void handleText(String text)
    {
        int index;

<span class="nc bnc" id="L775" title="All 2 branches missed.">        for (index = 0; index &lt; text.length(); index ++) {</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (text.charAt(index) == ';') {</span>
                Color newColor;
<span class="nc" id="L778">                newColor = new Color(red, green, blue);</span>
<span class="nc" id="L779">                proTemTable.addElement(newColor);</span>
            }
        }
<span class="nc" id="L782">    }</span>

    public void close()
    {
<span class="nc" id="L786">        int count = proTemTable.size();</span>
<span class="nc" id="L787">        warning(&quot;Done reading color table, &quot; + count + &quot; entries.&quot;);</span>
<span class="nc" id="L788">        colorTable = new Color[count];</span>
<span class="nc" id="L789">        proTemTable.copyInto(colorTable);</span>
<span class="nc" id="L790">    }</span>

    public boolean handleKeyword(String keyword, int parameter)
    {
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (keyword.equals(&quot;red&quot;))</span>
<span class="nc" id="L795">            red = parameter;</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">        else if (keyword.equals(&quot;green&quot;))</span>
<span class="nc" id="L797">            green = parameter;</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">        else if (keyword.equals(&quot;blue&quot;))</span>
<span class="nc" id="L799">            blue = parameter;</span>
        else
<span class="nc" id="L801">            return false;</span>

<span class="nc" id="L803">        return true;</span>
    }

    /* Colortbls don't understand any parameterless keywords */
<span class="nc" id="L807">    public boolean handleKeyword(String keyword) { return false; }</span>

    /* Groups are irrelevant. */
<span class="nc" id="L810">    public void begingroup() {}</span>
<span class="nc" id="L811">    public void endgroup(Dictionary oldState) {}</span>

    /* Shouldn't see any binary blobs ... */
<span class="nc" id="L814">    public void handleBinaryBlob(byte[] data) {}</span>
}

/** Handles the stylesheet keyword. Styles are read and sorted
 *  into the three style arrays in the RTFReader. */
class StylesheetDestination
    extends DiscardingDestination
    implements Destination
{
    Dictionary&lt;Integer, StyleDefiningDestination&gt; definedStyles;

    public StylesheetDestination()
<span class="nc" id="L826">    {</span>
<span class="nc" id="L827">        definedStyles = new Hashtable&lt;Integer, StyleDefiningDestination&gt;();</span>
<span class="nc" id="L828">    }</span>

    public void begingroup()
    {
<span class="nc" id="L832">        setRTFDestination(new StyleDefiningDestination());</span>
<span class="nc" id="L833">    }</span>

    public void close()
    {
<span class="nc" id="L837">        Vector&lt;Style&gt; chrStyles = new Vector&lt;Style&gt;();</span>
<span class="nc" id="L838">        Vector&lt;Style&gt; pgfStyles = new Vector&lt;Style&gt;();</span>
<span class="nc" id="L839">        Vector&lt;Style&gt; secStyles = new Vector&lt;Style&gt;();</span>
<span class="nc" id="L840">        Enumeration&lt;StyleDefiningDestination&gt; styles = definedStyles.elements();</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">        while(styles.hasMoreElements()) {</span>
            StyleDefiningDestination style;
            Style defined;
<span class="nc" id="L844">            style = styles.nextElement();</span>
<span class="nc" id="L845">            defined = style.realize();</span>
<span class="nc" id="L846">            warning(&quot;Style &quot;+style.number+&quot; (&quot;+style.styleName+&quot;): &quot;+defined);</span>
<span class="nc" id="L847">            String stype = (String)defined.getAttribute(Constants.StyleType);</span>
            Vector&lt;Style&gt; toSet;
<span class="nc bnc" id="L849" title="All 2 branches missed.">            if (stype.equals(Constants.STSection)) {</span>
<span class="nc" id="L850">                toSet = secStyles;</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">            } else if (stype.equals(Constants.STCharacter)) {</span>
<span class="nc" id="L852">                toSet = chrStyles;</span>
            } else {
<span class="nc" id="L854">                toSet = pgfStyles;</span>
            }
<span class="nc bnc" id="L856" title="All 2 branches missed.">            if (toSet.size() &lt;= style.number)</span>
<span class="nc" id="L857">                toSet.setSize(style.number + 1);</span>
<span class="nc" id="L858">            toSet.setElementAt(defined, style.number);</span>
<span class="nc" id="L859">        }</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">        if (!(chrStyles.isEmpty())) {</span>
<span class="nc" id="L861">            Style[] styleArray = new Style[chrStyles.size()];</span>
<span class="nc" id="L862">            chrStyles.copyInto(styleArray);</span>
<span class="nc" id="L863">            characterStyles = styleArray;</span>
        }
<span class="nc bnc" id="L865" title="All 2 branches missed.">        if (!(pgfStyles.isEmpty())) {</span>
<span class="nc" id="L866">            Style[] styleArray = new Style[pgfStyles.size()];</span>
<span class="nc" id="L867">            pgfStyles.copyInto(styleArray);</span>
<span class="nc" id="L868">            paragraphStyles = styleArray;</span>
        }
<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (!(secStyles.isEmpty())) {</span>
<span class="nc" id="L871">            Style[] styleArray = new Style[secStyles.size()];</span>
<span class="nc" id="L872">            secStyles.copyInto(styleArray);</span>
<span class="nc" id="L873">            sectionStyles = styleArray;</span>
        }

/* (old debugging code)
        int i, m;
        if (characterStyles != null) {
          m = characterStyles.length;
          for(i=0;i&lt;m;i++)
            warnings.println(&quot;chrStyle[&quot;+i+&quot;]=&quot;+characterStyles[i]);
        } else warnings.println(&quot;No character styles.&quot;);
        if (paragraphStyles != null) {
          m = paragraphStyles.length;
          for(i=0;i&lt;m;i++)
            warnings.println(&quot;pgfStyle[&quot;+i+&quot;]=&quot;+paragraphStyles[i]);
        } else warnings.println(&quot;No paragraph styles.&quot;);
        if (sectionStyles != null) {
          m = characterStyles.length;
          for(i=0;i&lt;m;i++)
            warnings.println(&quot;secStyle[&quot;+i+&quot;]=&quot;+sectionStyles[i]);
        } else warnings.println(&quot;No section styles.&quot;);
*/
<span class="nc" id="L894">    }</span>

    /** This subclass handles an individual style */
    class StyleDefiningDestination
        extends AttributeTrackingDestination
        implements Destination
    {
<span class="nc" id="L901">        final int STYLENUMBER_NONE = 222;</span>
        boolean additive;
        boolean characterStyle;
        boolean sectionStyle;
        public String styleName;
        public int number;
        int basedOn;
        int nextStyle;
        boolean hidden;

        Style realizedStyle;

        public StyleDefiningDestination()
<span class="nc" id="L914">        {</span>
<span class="nc" id="L915">            additive = false;</span>
<span class="nc" id="L916">            characterStyle = false;</span>
<span class="nc" id="L917">            sectionStyle = false;</span>
<span class="nc" id="L918">            styleName = null;</span>
<span class="nc" id="L919">            number = 0;</span>
<span class="nc" id="L920">            basedOn = STYLENUMBER_NONE;</span>
<span class="nc" id="L921">            nextStyle = STYLENUMBER_NONE;</span>
<span class="nc" id="L922">            hidden = false;</span>
<span class="nc" id="L923">        }</span>

        public void handleText(String text)
        {
<span class="nc bnc" id="L927" title="All 2 branches missed.">            if (styleName != null)</span>
<span class="nc" id="L928">                styleName = styleName + text;</span>
            else
<span class="nc" id="L930">                styleName = text;</span>
<span class="nc" id="L931">        }</span>

        public void close() {
<span class="nc bnc" id="L934" title="All 2 branches missed.">            int semicolon = (styleName == null) ? 0 : styleName.indexOf(';');</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">            if (semicolon &gt; 0)</span>
<span class="nc" id="L936">                styleName = styleName.substring(0, semicolon);</span>
<span class="nc" id="L937">            definedStyles.put(Integer.valueOf(number), this);</span>
<span class="nc" id="L938">            super.close();</span>
<span class="nc" id="L939">        }</span>

        public boolean handleKeyword(String keyword)
        {
<span class="nc bnc" id="L943" title="All 2 branches missed.">            if (keyword.equals(&quot;additive&quot;)) {</span>
<span class="nc" id="L944">                additive = true;</span>
<span class="nc" id="L945">                return true;</span>
            }
<span class="nc bnc" id="L947" title="All 2 branches missed.">            if (keyword.equals(&quot;shidden&quot;)) {</span>
<span class="nc" id="L948">                hidden = true;</span>
<span class="nc" id="L949">                return true;</span>
            }
<span class="nc" id="L951">            return super.handleKeyword(keyword);</span>
        }

        public boolean handleKeyword(String keyword, int parameter)
        {
<span class="nc bnc" id="L956" title="All 2 branches missed.">            if (keyword.equals(&quot;s&quot;)) {</span>
<span class="nc" id="L957">                characterStyle = false;</span>
<span class="nc" id="L958">                sectionStyle = false;</span>
<span class="nc" id="L959">                number = parameter;</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">            } else if (keyword.equals(&quot;cs&quot;)) {</span>
<span class="nc" id="L961">                characterStyle = true;</span>
<span class="nc" id="L962">                sectionStyle = false;</span>
<span class="nc" id="L963">                number = parameter;</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">            } else if (keyword.equals(&quot;ds&quot;)) {</span>
<span class="nc" id="L965">                characterStyle = false;</span>
<span class="nc" id="L966">                sectionStyle = true;</span>
<span class="nc" id="L967">                number = parameter;</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">            } else if (keyword.equals(&quot;sbasedon&quot;)) {</span>
<span class="nc" id="L969">                basedOn = parameter;</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">            } else if (keyword.equals(&quot;snext&quot;)) {</span>
<span class="nc" id="L971">                nextStyle = parameter;</span>
            } else {
<span class="nc" id="L973">                return super.handleKeyword(keyword, parameter);</span>
            }
<span class="nc" id="L975">            return true;</span>
        }

        public Style realize()
        {
<span class="nc" id="L980">            Style basis = null;</span>
<span class="nc" id="L981">            Style next = null;</span>

<span class="nc bnc" id="L983" title="All 2 branches missed.">            if (realizedStyle != null)</span>
<span class="nc" id="L984">                return realizedStyle;</span>

<span class="nc bnc" id="L986" title="All 2 branches missed.">            if (basedOn != STYLENUMBER_NONE) {</span>
                StyleDefiningDestination styleDest;
<span class="nc" id="L988">                styleDest = definedStyles.get(Integer.valueOf(basedOn));</span>
<span class="nc bnc" id="L989" title="All 4 branches missed.">                if (styleDest != null &amp;&amp; styleDest != this) {</span>
<span class="nc" id="L990">                    basis = styleDest.realize();</span>
                }
            }

            /* NB: Swing StyleContext doesn't allow distinct styles with
               the same name; RTF apparently does. This may confuse the
               user. */
<span class="nc" id="L997">            realizedStyle = target.addStyle(styleName, basis);</span>

<span class="nc bnc" id="L999" title="All 2 branches missed.">            if (characterStyle) {</span>
<span class="nc" id="L1000">                realizedStyle.addAttributes(currentTextAttributes());</span>
<span class="nc" id="L1001">                realizedStyle.addAttribute(Constants.StyleType,</span>
                                           Constants.STCharacter);
<span class="nc bnc" id="L1003" title="All 2 branches missed.">            } else if (sectionStyle) {</span>
<span class="nc" id="L1004">                realizedStyle.addAttributes(currentSectionAttributes());</span>
<span class="nc" id="L1005">                realizedStyle.addAttribute(Constants.StyleType,</span>
                                           Constants.STSection);
            } else { /* must be a paragraph style */
<span class="nc" id="L1008">                realizedStyle.addAttributes(currentParagraphAttributes());</span>
<span class="nc" id="L1009">                realizedStyle.addAttribute(Constants.StyleType,</span>
                                           Constants.STParagraph);
            }

<span class="nc bnc" id="L1013" title="All 2 branches missed.">            if (nextStyle != STYLENUMBER_NONE) {</span>
                StyleDefiningDestination styleDest;
<span class="nc" id="L1015">                styleDest = definedStyles.get(Integer.valueOf(nextStyle));</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">                if (styleDest != null) {</span>
<span class="nc" id="L1017">                    next = styleDest.realize();</span>
                }
            }

<span class="nc bnc" id="L1021" title="All 2 branches missed.">            if (next != null)</span>
<span class="nc" id="L1022">                realizedStyle.addAttribute(Constants.StyleNext, next);</span>
<span class="nc" id="L1023">            realizedStyle.addAttribute(Constants.StyleAdditive,</span>
<span class="nc" id="L1024">                                       Boolean.valueOf(additive));</span>
<span class="nc" id="L1025">            realizedStyle.addAttribute(Constants.StyleHidden,</span>
<span class="nc" id="L1026">                                       Boolean.valueOf(hidden));</span>

<span class="nc" id="L1028">            return realizedStyle;</span>
        }
    }
}

/** Handles the info group. Currently no info keywords are recognized
 *  so this is a subclass of DiscardingDestination. */
<span class="nc" id="L1035">class InfoDestination</span>
    extends DiscardingDestination
    implements Destination
{
}

/** RTFReader.TextHandlingDestination is an abstract RTF destination
 *  which simply tracks the attributes specified by the RTF control words
 *  in internal form and can produce acceptable AttributeSets for the
 *  current character, paragraph, and section attributes. It is up
 *  to the subclasses to determine what is done with the actual text. */
abstract class AttributeTrackingDestination implements Destination
{
    /** This is the &quot;chr&quot; element of parserState, cached for
     *  more efficient use */
    MutableAttributeSet characterAttributes;
    /** This is the &quot;pgf&quot; element of parserState, cached for
     *  more efficient use */
    MutableAttributeSet paragraphAttributes;
    /** This is the &quot;sec&quot; element of parserState, cached for
     *  more efficient use */
    MutableAttributeSet sectionAttributes;

    public AttributeTrackingDestination()
<span class="nc" id="L1059">    {</span>
<span class="nc" id="L1060">        characterAttributes = rootCharacterAttributes();</span>
<span class="nc" id="L1061">        parserState.put(&quot;chr&quot;, characterAttributes);</span>
<span class="nc" id="L1062">        paragraphAttributes = rootParagraphAttributes();</span>
<span class="nc" id="L1063">        parserState.put(&quot;pgf&quot;, paragraphAttributes);</span>
<span class="nc" id="L1064">        sectionAttributes = rootSectionAttributes();</span>
<span class="nc" id="L1065">        parserState.put(&quot;sec&quot;, sectionAttributes);</span>
<span class="nc" id="L1066">    }</span>

    abstract public void handleText(String text);

    public void handleBinaryBlob(byte[] data)
    {
        /* This should really be in TextHandlingDestination, but
         * since *nobody* does anything with binary blobs, this
         * is more convenient. */
<span class="nc" id="L1075">        warning(&quot;Unexpected binary data in RTF file.&quot;);</span>
<span class="nc" id="L1076">    }</span>

    public void begingroup()
    {
<span class="nc" id="L1080">        AttributeSet characterParent = currentTextAttributes();</span>
<span class="nc" id="L1081">        AttributeSet paragraphParent = currentParagraphAttributes();</span>
<span class="nc" id="L1082">        AttributeSet sectionParent = currentSectionAttributes();</span>

        /* It would probably be more efficient to use the
         * resolver property of the attributes set for
         * implementing rtf groups,
         * but that's needed for styles. */

        /* update the cached attribute dictionaries */
<span class="nc" id="L1090">        characterAttributes = new SimpleAttributeSet();</span>
<span class="nc" id="L1091">        characterAttributes.addAttributes(characterParent);</span>
<span class="nc" id="L1092">        parserState.put(&quot;chr&quot;, characterAttributes);</span>

<span class="nc" id="L1094">        paragraphAttributes = new SimpleAttributeSet();</span>
<span class="nc" id="L1095">        paragraphAttributes.addAttributes(paragraphParent);</span>
<span class="nc" id="L1096">        parserState.put(&quot;pgf&quot;, paragraphAttributes);</span>

<span class="nc" id="L1098">        sectionAttributes = new SimpleAttributeSet();</span>
<span class="nc" id="L1099">        sectionAttributes.addAttributes(sectionParent);</span>
<span class="nc" id="L1100">        parserState.put(&quot;sec&quot;, sectionAttributes);</span>
<span class="nc" id="L1101">    }</span>

    public void endgroup(Dictionary oldState)
    {
<span class="nc" id="L1105">        characterAttributes = (MutableAttributeSet)parserState.get(&quot;chr&quot;);</span>
<span class="nc" id="L1106">        paragraphAttributes = (MutableAttributeSet)parserState.get(&quot;pgf&quot;);</span>
<span class="nc" id="L1107">        sectionAttributes   = (MutableAttributeSet)parserState.get(&quot;sec&quot;);</span>
<span class="nc" id="L1108">    }</span>

    public void close()
    {
<span class="nc" id="L1112">    }</span>

    public boolean handleKeyword(String keyword)
    {
<span class="nc bnc" id="L1116" title="All 2 branches missed.">        if (keyword.equals(&quot;ulnone&quot;)) {</span>
<span class="nc" id="L1117">            return handleKeyword(&quot;ul&quot;, 0);</span>
        }

        {
<span class="nc" id="L1121">            RTFAttribute attr = straightforwardAttributes.get(keyword);</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">            if (attr != null) {</span>
                boolean ok;

<span class="nc bnc" id="L1125" title="All 6 branches missed.">                switch(attr.domain()) {</span>
                  case RTFAttribute.D_CHARACTER:
<span class="nc" id="L1127">                    ok = attr.set(characterAttributes);</span>
<span class="nc" id="L1128">                    break;</span>
                  case RTFAttribute.D_PARAGRAPH:
<span class="nc" id="L1130">                    ok = attr.set(paragraphAttributes);</span>
<span class="nc" id="L1131">                    break;</span>
                  case RTFAttribute.D_SECTION:
<span class="nc" id="L1133">                    ok = attr.set(sectionAttributes);</span>
<span class="nc" id="L1134">                    break;</span>
                  case RTFAttribute.D_META:
<span class="nc" id="L1136">                    mockery.backing = parserState;</span>
<span class="nc" id="L1137">                    ok = attr.set(mockery);</span>
<span class="nc" id="L1138">                    mockery.backing = null;</span>
<span class="nc" id="L1139">                    break;</span>
                  case RTFAttribute.D_DOCUMENT:
<span class="nc" id="L1141">                    ok = attr.set(documentAttributes);</span>
<span class="nc" id="L1142">                    break;</span>
                  default:
                    /* should never happen */
<span class="nc" id="L1145">                    ok = false;</span>
                    break;
                }
<span class="nc bnc" id="L1148" title="All 2 branches missed.">                if (ok)</span>
<span class="nc" id="L1149">                    return true;</span>
            }
        }


<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if (keyword.equals(&quot;plain&quot;)) {</span>
<span class="nc" id="L1155">            resetCharacterAttributes();</span>
<span class="nc" id="L1156">            return true;</span>
        }

<span class="nc bnc" id="L1159" title="All 2 branches missed.">        if (keyword.equals(&quot;pard&quot;)) {</span>
<span class="nc" id="L1160">            resetParagraphAttributes();</span>
<span class="nc" id="L1161">            return true;</span>
        }

<span class="nc bnc" id="L1164" title="All 2 branches missed.">        if (keyword.equals(&quot;sectd&quot;)) {</span>
<span class="nc" id="L1165">            resetSectionAttributes();</span>
<span class="nc" id="L1166">            return true;</span>
        }

<span class="nc" id="L1169">        return false;</span>
    }

    public boolean handleKeyword(String keyword, int parameter)
    {
<span class="nc bnc" id="L1174" title="All 2 branches missed.">        boolean booleanParameter = (parameter != 0);</span>

<span class="nc bnc" id="L1176" title="All 2 branches missed.">        if (keyword.equals(&quot;fc&quot;))</span>
<span class="nc" id="L1177">            keyword = &quot;cf&quot;; /* whatEVER, dude. */</span>

<span class="nc bnc" id="L1179" title="All 2 branches missed.">        if (keyword.equals(&quot;f&quot;)) {</span>
<span class="nc" id="L1180">            parserState.put(keyword, Integer.valueOf(parameter));</span>
<span class="nc" id="L1181">            return true;</span>
        }
<span class="nc bnc" id="L1183" title="All 2 branches missed.">        if (keyword.equals(&quot;cf&quot;)) {</span>
<span class="nc" id="L1184">            parserState.put(keyword, Integer.valueOf(parameter));</span>
<span class="nc" id="L1185">            return true;</span>
        }

        {
<span class="nc" id="L1189">            RTFAttribute attr = straightforwardAttributes.get(keyword);</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">            if (attr != null) {</span>
                boolean ok;

<span class="nc bnc" id="L1193" title="All 6 branches missed.">                switch(attr.domain()) {</span>
                  case RTFAttribute.D_CHARACTER:
<span class="nc" id="L1195">                    ok = attr.set(characterAttributes, parameter);</span>
<span class="nc" id="L1196">                    break;</span>
                  case RTFAttribute.D_PARAGRAPH:
<span class="nc" id="L1198">                    ok = attr.set(paragraphAttributes, parameter);</span>
<span class="nc" id="L1199">                    break;</span>
                  case RTFAttribute.D_SECTION:
<span class="nc" id="L1201">                    ok = attr.set(sectionAttributes, parameter);</span>
<span class="nc" id="L1202">                    break;</span>
                  case RTFAttribute.D_META:
<span class="nc" id="L1204">                    mockery.backing = parserState;</span>
<span class="nc" id="L1205">                    ok = attr.set(mockery, parameter);</span>
<span class="nc" id="L1206">                    mockery.backing = null;</span>
<span class="nc" id="L1207">                    break;</span>
                  case RTFAttribute.D_DOCUMENT:
<span class="nc" id="L1209">                    ok = attr.set(documentAttributes, parameter);</span>
<span class="nc" id="L1210">                    break;</span>
                  default:
                    /* should never happen */
<span class="nc" id="L1213">                    ok = false;</span>
                    break;
                }
<span class="nc bnc" id="L1216" title="All 2 branches missed.">                if (ok)</span>
<span class="nc" id="L1217">                    return true;</span>
            }
        }

<span class="nc bnc" id="L1221" title="All 2 branches missed.">        if (keyword.equals(&quot;fs&quot;)) {</span>
<span class="nc" id="L1222">            StyleConstants.setFontSize(characterAttributes, (parameter / 2));</span>
<span class="nc" id="L1223">            return true;</span>
        }

        /* TODO: superscript/subscript */

<span class="nc bnc" id="L1228" title="All 2 branches missed.">        if (keyword.equals(&quot;sl&quot;)) {</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">            if (parameter == 1000) {  /* magic value! */</span>
<span class="nc" id="L1230">                characterAttributes.removeAttribute(StyleConstants.LineSpacing);</span>
            } else {
                /* TODO: The RTF sl attribute has special meaning if it's
                   negative. Make sure that SwingText has the same special
                   meaning, or find a way to imitate that. When SwingText
                   handles this, also recognize the slmult keyword. */
<span class="nc" id="L1236">                StyleConstants.setLineSpacing(characterAttributes,</span>
                                              parameter / 20f);
            }
<span class="nc" id="L1239">            return true;</span>
        }

        /* TODO: Other kinds of underlining */

<span class="nc bnc" id="L1244" title="All 4 branches missed.">        if (keyword.equals(&quot;tx&quot;) || keyword.equals(&quot;tb&quot;)) {</span>
<span class="nc" id="L1245">            float tabPosition = parameter / 20f;</span>
            int tabAlignment, tabLeader;
            Number item;

<span class="nc" id="L1249">            tabAlignment = TabStop.ALIGN_LEFT;</span>
<span class="nc" id="L1250">            item = (Number)(parserState.get(&quot;tab_alignment&quot;));</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">            if (item != null)</span>
<span class="nc" id="L1252">                tabAlignment = item.intValue();</span>
<span class="nc" id="L1253">            tabLeader = TabStop.LEAD_NONE;</span>
<span class="nc" id="L1254">            item = (Number)(parserState.get(&quot;tab_leader&quot;));</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">            if (item != null)</span>
<span class="nc" id="L1256">                tabLeader = item.intValue();</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">            if (keyword.equals(&quot;tb&quot;))</span>
<span class="nc" id="L1258">                tabAlignment = TabStop.ALIGN_BAR;</span>

<span class="nc" id="L1260">            parserState.remove(&quot;tab_alignment&quot;);</span>
<span class="nc" id="L1261">            parserState.remove(&quot;tab_leader&quot;);</span>

<span class="nc" id="L1263">            TabStop newStop = new TabStop(tabPosition, tabAlignment, tabLeader);</span>
            Dictionary&lt;Object, Object&gt; tabs;
            Integer stopCount;

<span class="nc" id="L1267">            tabs = (Dictionary&lt;Object, Object&gt;)parserState.get(&quot;_tabs&quot;);</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">            if (tabs == null) {</span>
<span class="nc" id="L1269">                tabs = new Hashtable&lt;Object, Object&gt;();</span>
<span class="nc" id="L1270">                parserState.put(&quot;_tabs&quot;, tabs);</span>
<span class="nc" id="L1271">                stopCount = Integer.valueOf(1);</span>
            } else {
<span class="nc" id="L1273">                stopCount = (Integer)tabs.get(&quot;stop count&quot;);</span>
<span class="nc" id="L1274">                stopCount = Integer.valueOf(1 + stopCount.intValue());</span>
            }
<span class="nc" id="L1276">            tabs.put(stopCount, newStop);</span>
<span class="nc" id="L1277">            tabs.put(&quot;stop count&quot;, stopCount);</span>
<span class="nc" id="L1278">            parserState.remove(&quot;_tabs_immutable&quot;);</span>

<span class="nc" id="L1280">            return true;</span>
        }

<span class="nc bnc" id="L1283" title="All 4 branches missed.">        if (keyword.equals(&quot;s&quot;) &amp;&amp;</span>
            paragraphStyles != null) {
<span class="nc" id="L1285">            parserState.put(&quot;paragraphStyle&quot;, paragraphStyles[parameter]);</span>
<span class="nc" id="L1286">            return true;</span>
        }

<span class="nc bnc" id="L1289" title="All 4 branches missed.">        if (keyword.equals(&quot;cs&quot;) &amp;&amp;</span>
            characterStyles != null) {
<span class="nc" id="L1291">            parserState.put(&quot;characterStyle&quot;, characterStyles[parameter]);</span>
<span class="nc" id="L1292">            return true;</span>
        }

<span class="nc bnc" id="L1295" title="All 4 branches missed.">        if (keyword.equals(&quot;ds&quot;) &amp;&amp;</span>
            sectionStyles != null) {
<span class="nc" id="L1297">            parserState.put(&quot;sectionStyle&quot;, sectionStyles[parameter]);</span>
<span class="nc" id="L1298">            return true;</span>
        }

<span class="nc" id="L1301">        return false;</span>
    }

    /** Returns a new MutableAttributeSet containing the
     *  default character attributes */
    protected MutableAttributeSet rootCharacterAttributes()
    {
<span class="nc" id="L1308">        MutableAttributeSet set = new SimpleAttributeSet();</span>

        /* TODO: default font */

<span class="nc" id="L1312">        StyleConstants.setItalic(set, false);</span>
<span class="nc" id="L1313">        StyleConstants.setBold(set, false);</span>
<span class="nc" id="L1314">        StyleConstants.setUnderline(set, false);</span>
<span class="nc" id="L1315">        StyleConstants.setForeground(set, defaultColor());</span>

<span class="nc" id="L1317">        return set;</span>
    }

    /** Returns a new MutableAttributeSet containing the
     *  default paragraph attributes */
    protected MutableAttributeSet rootParagraphAttributes()
    {
<span class="nc" id="L1324">        MutableAttributeSet set = new SimpleAttributeSet();</span>

<span class="nc" id="L1326">        StyleConstants.setLeftIndent(set, 0f);</span>
<span class="nc" id="L1327">        StyleConstants.setRightIndent(set, 0f);</span>
<span class="nc" id="L1328">        StyleConstants.setFirstLineIndent(set, 0f);</span>

        /* TODO: what should this be, really? */
<span class="nc" id="L1331">        set.setResolveParent(target.getStyle(StyleContext.DEFAULT_STYLE));</span>

<span class="nc" id="L1333">        return set;</span>
    }

    /** Returns a new MutableAttributeSet containing the
     *  default section attributes */
    protected MutableAttributeSet rootSectionAttributes()
    {
<span class="nc" id="L1340">        MutableAttributeSet set = new SimpleAttributeSet();</span>

<span class="nc" id="L1342">        return set;</span>
    }

    /**
     * Calculates the current text (character) attributes in a form suitable
     * for SwingText from the current parser state.
     *
     * @returns a new MutableAttributeSet containing the text attributes.
     */
    MutableAttributeSet currentTextAttributes()
    {
<span class="nc" id="L1353">        MutableAttributeSet attributes =</span>
            new SimpleAttributeSet(characterAttributes);
        Integer fontnum;
        Integer stateItem;

        /* figure out the font name */
        /* TODO: catch exceptions for undefined attributes,
           bad font indices, etc.? (as it stands, it is the caller's
           job to clean up after corrupt RTF) */
<span class="nc" id="L1362">        fontnum = (Integer)parserState.get(&quot;f&quot;);</span>
        /* note setFontFamily() can not handle a null font */
        String fontFamily;
<span class="nc bnc" id="L1365" title="All 2 branches missed.">        if (fontnum != null)</span>
<span class="nc" id="L1366">            fontFamily = fontTable.get(fontnum);</span>
        else
<span class="nc" id="L1368">            fontFamily = null;</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">        if (fontFamily != null)</span>
<span class="nc" id="L1370">            StyleConstants.setFontFamily(attributes, fontFamily);</span>
        else
<span class="nc" id="L1372">            attributes.removeAttribute(StyleConstants.FontFamily);</span>

<span class="nc bnc" id="L1374" title="All 2 branches missed.">        if (colorTable != null) {</span>
<span class="nc" id="L1375">            stateItem = (Integer)parserState.get(&quot;cf&quot;);</span>
<span class="nc bnc" id="L1376" title="All 2 branches missed.">            if (stateItem != null) {</span>
<span class="nc" id="L1377">                Color fg = colorTable[stateItem.intValue()];</span>
<span class="nc" id="L1378">                StyleConstants.setForeground(attributes, fg);</span>
<span class="nc" id="L1379">            } else {</span>
                /* AttributeSet dies if you set a value to null */
<span class="nc" id="L1381">                attributes.removeAttribute(StyleConstants.Foreground);</span>
            }
        }

<span class="nc bnc" id="L1385" title="All 2 branches missed.">        if (colorTable != null) {</span>
<span class="nc" id="L1386">            stateItem = (Integer)parserState.get(&quot;cb&quot;);</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">            if (stateItem != null) {</span>
<span class="nc" id="L1388">                Color bg = colorTable[stateItem.intValue()];</span>
<span class="nc" id="L1389">                attributes.addAttribute(StyleConstants.Background,</span>
                                        bg);
<span class="nc" id="L1391">            } else {</span>
                /* AttributeSet dies if you set a value to null */
<span class="nc" id="L1393">                attributes.removeAttribute(StyleConstants.Background);</span>
            }
        }

<span class="nc" id="L1397">        Style characterStyle = (Style)parserState.get(&quot;characterStyle&quot;);</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">        if (characterStyle != null)</span>
<span class="nc" id="L1399">            attributes.setResolveParent(characterStyle);</span>

        /* Other attributes are maintained directly in &quot;attributes&quot; */

<span class="nc" id="L1403">        return attributes;</span>
    }

    /**
     * Calculates the current paragraph attributes (with keys
     * as given in StyleConstants) from the current parser state.
     *
     * @returns a newly created MutableAttributeSet.
     * @see StyleConstants
     */
    MutableAttributeSet currentParagraphAttributes()
    {
        /* NB if there were a mutableCopy() method we should use it */
<span class="nc" id="L1416">        MutableAttributeSet bld = new SimpleAttributeSet(paragraphAttributes);</span>

        Integer stateItem;

        /*** Tab stops ***/
        TabStop tabs[];

<span class="nc" id="L1423">        tabs = (TabStop[])parserState.get(&quot;_tabs_immutable&quot;);</span>
<span class="nc bnc" id="L1424" title="All 2 branches missed.">        if (tabs == null) {</span>
<span class="nc" id="L1425">            Dictionary workingTabs = (Dictionary)parserState.get(&quot;_tabs&quot;);</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">            if (workingTabs != null) {</span>
<span class="nc" id="L1427">                int count = ((Integer)workingTabs.get(&quot;stop count&quot;)).intValue();</span>
<span class="nc" id="L1428">                tabs = new TabStop[count];</span>
<span class="nc bnc" id="L1429" title="All 2 branches missed.">                for (int ix = 1; ix &lt;= count; ix ++)</span>
<span class="nc" id="L1430">                    tabs[ix-1] = (TabStop)workingTabs.get(Integer.valueOf(ix));</span>
<span class="nc" id="L1431">                parserState.put(&quot;_tabs_immutable&quot;, tabs);</span>
            }
        }
<span class="nc bnc" id="L1434" title="All 2 branches missed.">        if (tabs != null)</span>
<span class="nc" id="L1435">            bld.addAttribute(Constants.Tabs, tabs);</span>

<span class="nc" id="L1437">        Style paragraphStyle = (Style)parserState.get(&quot;paragraphStyle&quot;);</span>
<span class="nc bnc" id="L1438" title="All 2 branches missed.">        if (paragraphStyle != null)</span>
<span class="nc" id="L1439">            bld.setResolveParent(paragraphStyle);</span>

<span class="nc" id="L1441">        return bld;</span>
    }

    /**
     * Calculates the current section attributes
     * from the current parser state.
     *
     * @returns a newly created MutableAttributeSet.
     */
    public AttributeSet currentSectionAttributes()
    {
<span class="nc" id="L1452">        MutableAttributeSet attributes = new SimpleAttributeSet(sectionAttributes);</span>

<span class="nc" id="L1454">        Style sectionStyle = (Style)parserState.get(&quot;sectionStyle&quot;);</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">        if (sectionStyle != null)</span>
<span class="nc" id="L1456">            attributes.setResolveParent(sectionStyle);</span>

<span class="nc" id="L1458">        return attributes;</span>
    }

    /** Resets the filter's internal notion of the current character
     *  attributes to their default values. Invoked to handle the
     *  \plain keyword. */
    protected void resetCharacterAttributes()
    {
<span class="nc" id="L1466">        handleKeyword(&quot;f&quot;, 0);</span>
<span class="nc" id="L1467">        handleKeyword(&quot;cf&quot;, 0);</span>

<span class="nc" id="L1469">        handleKeyword(&quot;fs&quot;, 24);  /* 12 pt. */</span>

<span class="nc" id="L1471">        Enumeration&lt;RTFAttribute&gt; attributes = straightforwardAttributes.elements();</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">        while(attributes.hasMoreElements()) {</span>
<span class="nc" id="L1473">            RTFAttribute attr = attributes.nextElement();</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">            if (attr.domain() == RTFAttribute.D_CHARACTER)</span>
<span class="nc" id="L1475">                attr.setDefault(characterAttributes);</span>
<span class="nc" id="L1476">        }</span>

<span class="nc" id="L1478">        handleKeyword(&quot;sl&quot;, 1000);</span>

<span class="nc" id="L1480">        parserState.remove(&quot;characterStyle&quot;);</span>
<span class="nc" id="L1481">    }</span>

    /** Resets the filter's internal notion of the current paragraph's
     *  attributes to their default values. Invoked to handle the
     *  \pard keyword. */
    protected void resetParagraphAttributes()
    {
<span class="nc" id="L1488">        parserState.remove(&quot;_tabs&quot;);</span>
<span class="nc" id="L1489">        parserState.remove(&quot;_tabs_immutable&quot;);</span>
<span class="nc" id="L1490">        parserState.remove(&quot;paragraphStyle&quot;);</span>

<span class="nc" id="L1492">        StyleConstants.setAlignment(paragraphAttributes,</span>
                                    StyleConstants.ALIGN_LEFT);

<span class="nc" id="L1495">        Enumeration&lt;RTFAttribute&gt; attributes = straightforwardAttributes.elements();</span>
<span class="nc bnc" id="L1496" title="All 2 branches missed.">        while(attributes.hasMoreElements()) {</span>
<span class="nc" id="L1497">            RTFAttribute attr = attributes.nextElement();</span>
<span class="nc bnc" id="L1498" title="All 2 branches missed.">            if (attr.domain() == RTFAttribute.D_PARAGRAPH)</span>
<span class="nc" id="L1499">                attr.setDefault(characterAttributes);</span>
<span class="nc" id="L1500">        }</span>
<span class="nc" id="L1501">    }</span>

    /** Resets the filter's internal notion of the current section's
     *  attributes to their default values. Invoked to handle the
     *  \sectd keyword. */
    protected void resetSectionAttributes()
    {
<span class="nc" id="L1508">        Enumeration&lt;RTFAttribute&gt; attributes = straightforwardAttributes.elements();</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">        while(attributes.hasMoreElements()) {</span>
<span class="nc" id="L1510">            RTFAttribute attr = attributes.nextElement();</span>
<span class="nc bnc" id="L1511" title="All 2 branches missed.">            if (attr.domain() == RTFAttribute.D_SECTION)</span>
<span class="nc" id="L1512">                attr.setDefault(characterAttributes);</span>
<span class="nc" id="L1513">        }</span>

<span class="nc" id="L1515">        parserState.remove(&quot;sectionStyle&quot;);</span>
<span class="nc" id="L1516">    }</span>
}

/** RTFReader.TextHandlingDestination provides basic text handling
 *  functionality. Subclasses must implement: &lt;dl&gt;
 *  &lt;dt&gt;deliverText()&lt;dd&gt;to handle a run of text with the same
 *                       attributes
 *  &lt;dt&gt;finishParagraph()&lt;dd&gt;to end the current paragraph and
 *                           set the paragraph's attributes
 *  &lt;dt&gt;endSection()&lt;dd&gt;to end the current section
 *  &lt;/dl&gt;
 */
abstract class TextHandlingDestination
    extends AttributeTrackingDestination
    implements Destination
{
    /** &lt;code&gt;true&lt;/code&gt; if the reader has not just finished
     *  a paragraph; false upon startup */
    boolean inParagraph;

    public TextHandlingDestination()
<span class="nc" id="L1537">    {</span>
<span class="nc" id="L1538">        super();</span>
<span class="nc" id="L1539">        inParagraph = false;</span>
<span class="nc" id="L1540">    }</span>

    public void handleText(String text)
    {
<span class="nc bnc" id="L1544" title="All 2 branches missed.">        if (! inParagraph)</span>
<span class="nc" id="L1545">            beginParagraph();</span>

<span class="nc" id="L1547">        deliverText(text, currentTextAttributes());</span>
<span class="nc" id="L1548">    }</span>

    abstract void deliverText(String text, AttributeSet characterAttributes);

    public void close()
    {
<span class="nc bnc" id="L1554" title="All 2 branches missed.">        if (inParagraph)</span>
<span class="nc" id="L1555">            endParagraph();</span>

<span class="nc" id="L1557">        super.close();</span>
<span class="nc" id="L1558">    }</span>

    public boolean handleKeyword(String keyword)
    {
<span class="nc bnc" id="L1562" title="All 4 branches missed.">        if (keyword.equals(&quot;\r&quot;) || keyword.equals(&quot;\n&quot;)) {</span>
<span class="nc" id="L1563">            keyword = &quot;par&quot;;</span>
        }

<span class="nc bnc" id="L1566" title="All 2 branches missed.">        if (keyword.equals(&quot;par&quot;)) {</span>
//          warnings.println(&quot;Ending paragraph.&quot;);
<span class="nc" id="L1568">            endParagraph();</span>
<span class="nc" id="L1569">            return true;</span>
        }

<span class="nc bnc" id="L1572" title="All 2 branches missed.">        if (keyword.equals(&quot;sect&quot;)) {</span>
//          warnings.println(&quot;Ending section.&quot;);
<span class="nc" id="L1574">            endSection();</span>
<span class="nc" id="L1575">            return true;</span>
        }

<span class="nc" id="L1578">        return super.handleKeyword(keyword);</span>
    }

    protected void beginParagraph()
    {
<span class="nc" id="L1583">        inParagraph = true;</span>
<span class="nc" id="L1584">    }</span>

    protected void endParagraph()
    {
<span class="nc" id="L1588">        AttributeSet pgfAttributes = currentParagraphAttributes();</span>
<span class="nc" id="L1589">        AttributeSet chrAttributes = currentTextAttributes();</span>
<span class="nc" id="L1590">        finishParagraph(pgfAttributes, chrAttributes);</span>
<span class="nc" id="L1591">        inParagraph = false;</span>
<span class="nc" id="L1592">    }</span>

    abstract void finishParagraph(AttributeSet pgfA, AttributeSet chrA);

    abstract void endSection();
}

/** RTFReader.DocumentDestination is a concrete subclass of
 *  TextHandlingDestination which appends the text to the
 *  StyledDocument given by the &lt;code&gt;target&lt;/code&gt; ivar of the
 *  containing RTFReader.
 */
<span class="nc" id="L1604">class DocumentDestination</span>
    extends TextHandlingDestination
    implements Destination
{
    public void deliverText(String text, AttributeSet characterAttributes)
    {
        try {
<span class="nc" id="L1611">            target.insertString(target.getLength(),</span>
                                text,
<span class="nc" id="L1613">                                currentTextAttributes());</span>
<span class="nc" id="L1614">        } catch (BadLocationException ble) {</span>
            /* This shouldn't be able to happen, of course */
            /* TODO is InternalError the correct error to throw? */
<span class="nc" id="L1617">            throw new InternalError(ble.getMessage(), ble);</span>
<span class="nc" id="L1618">        }</span>
<span class="nc" id="L1619">    }</span>

    public void finishParagraph(AttributeSet pgfAttributes,
                                AttributeSet chrAttributes)
    {
<span class="nc" id="L1624">        int pgfEndPosition = target.getLength();</span>
        try {
<span class="nc" id="L1626">            target.insertString(pgfEndPosition, &quot;\n&quot;, chrAttributes);</span>
<span class="nc" id="L1627">            target.setParagraphAttributes(pgfEndPosition, 1, pgfAttributes, true);</span>
<span class="nc" id="L1628">        } catch (BadLocationException ble) {</span>
            /* This shouldn't be able to happen, of course */
            /* TODO is InternalError the correct error to throw? */
<span class="nc" id="L1631">            throw new InternalError(ble.getMessage(), ble);</span>
<span class="nc" id="L1632">        }</span>
<span class="nc" id="L1633">    }</span>

    public void endSection()
    {
        /* If we implemented sections, we'd end 'em here */
<span class="nc" id="L1638">    }</span>
}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>