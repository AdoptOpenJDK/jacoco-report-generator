<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultMBeanServerInterceptor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jmx.interceptor</a> &gt; <span class="el_source">DefaultMBeanServerInterceptor.java</span></div><h1>DefaultMBeanServerInterceptor.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jmx.interceptor;


// JMX RI
import static com.sun.jmx.defaults.JmxProperties.MBEANSERVER_LOGGER;
import com.sun.jmx.mbeanserver.DynamicMBean2;
import com.sun.jmx.mbeanserver.Introspector;
import com.sun.jmx.mbeanserver.MBeanInstantiator;
import com.sun.jmx.mbeanserver.ModifiableClassLoaderRepository;
import com.sun.jmx.mbeanserver.NamedObject;
import com.sun.jmx.mbeanserver.Repository;
import com.sun.jmx.mbeanserver.Repository.RegistrationContext;
import com.sun.jmx.mbeanserver.Util;
import com.sun.jmx.remote.util.EnvHelp;

import java.io.ObjectInputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.Permission;
import java.security.PrivilegedAction;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.logging.Level;

// JMX import
import javax.management.Attribute;
import javax.management.AttributeList;
import javax.management.AttributeNotFoundException;
import javax.management.DynamicMBean;
import javax.management.InstanceAlreadyExistsException;
import javax.management.InstanceNotFoundException;
import javax.management.IntrospectionException;
import javax.management.InvalidAttributeValueException;
import javax.management.JMRuntimeException;
import javax.management.ListenerNotFoundException;
import javax.management.MBeanException;
import javax.management.MBeanInfo;
import javax.management.MBeanPermission;
import javax.management.MBeanRegistration;
import javax.management.MBeanRegistrationException;
import javax.management.MBeanServer;
import javax.management.MBeanServerDelegate;
import javax.management.MBeanServerNotification;
import javax.management.MBeanTrustPermission;
import javax.management.NotCompliantMBeanException;
import javax.management.Notification;
import javax.management.NotificationBroadcaster;
import javax.management.NotificationEmitter;
import javax.management.NotificationFilter;
import javax.management.NotificationListener;
import javax.management.ObjectInstance;
import javax.management.ObjectName;
import javax.management.OperationsException;
import javax.management.QueryEval;
import javax.management.QueryExp;
import javax.management.ReflectionException;
import javax.management.RuntimeErrorException;
import javax.management.RuntimeMBeanException;
import javax.management.RuntimeOperationsException;
import javax.management.loading.ClassLoaderRepository;

/**
 * This is the default class for MBean manipulation on the agent side. It
 * contains the methods necessary for the creation, registration, and
 * deletion of MBeans as well as the access methods for registered MBeans.
 * This is the core component of the JMX infrastructure.
 * &lt;P&gt;
 * Every MBean which is added to the MBean server becomes manageable: its attributes and operations
 * become remotely accessible through the connectors/adaptors connected to that MBean server.
 * A Java object cannot be registered in the MBean server unless it is a JMX compliant MBean.
 * &lt;P&gt;
 * When an MBean is registered or unregistered in the MBean server an
 * {@link javax.management.MBeanServerNotification MBeanServerNotification}
 * Notification is emitted. To register an object as listener to MBeanServerNotifications
 * you should call the MBean server method {@link #addNotificationListener addNotificationListener} with &lt;CODE&gt;ObjectName&lt;/CODE&gt;
 * the &lt;CODE&gt;ObjectName&lt;/CODE&gt; of the {@link javax.management.MBeanServerDelegate MBeanServerDelegate}.
 * This &lt;CODE&gt;ObjectName&lt;/CODE&gt; is:
 * &lt;BR&gt;
 * &lt;CODE&gt;JMImplementation:type=MBeanServerDelegate&lt;/CODE&gt;.
 *
 * @since 1.5
 */
public class DefaultMBeanServerInterceptor implements MBeanServerInterceptor {

    /** The MBeanInstantiator object used by the
     *  DefaultMBeanServerInterceptor */
    private final transient MBeanInstantiator instantiator;

    /** The MBean server object that is associated to the
     *  DefaultMBeanServerInterceptor */
<span class="nc" id="L121">    private transient MBeanServer server = null;</span>

    /** The MBean server delegate object that is associated to the
     *  DefaultMBeanServerInterceptor */
    private final transient MBeanServerDelegate delegate;

    /** The Repository object used by the DefaultMBeanServerInterceptor */
    private final transient Repository repository;

    /** Wrappers for client listeners.  */
    /* See the comment before addNotificationListener below.  */
<span class="nc" id="L132">    private final transient</span>
        WeakHashMap&lt;ListenerWrapper, WeakReference&lt;ListenerWrapper&gt;&gt;
            listenerWrappers =
                new WeakHashMap&lt;ListenerWrapper,
                                WeakReference&lt;ListenerWrapper&gt;&gt;();

    /** The default domain of the object names */
    private final String domain;

    /** The sequence number identifying the notifications sent */
    // Now sequence number is handled by MBeanServerDelegate.
    // private int sequenceNumber=0;

    /**
     * Creates a DefaultMBeanServerInterceptor with the specified
     * repository instance.
     * &lt;p&gt;Do not forget to call &lt;code&gt;initialize(outer,delegate)&lt;/code&gt;
     * before using this object.
     * @param outer A pointer to the MBeanServer object that must be
     *        passed to the MBeans when invoking their
     *        {@link javax.management.MBeanRegistration} interface.
     * @param delegate A pointer to the MBeanServerDelegate associated
     *        with the new MBeanServer. The new MBeanServer must register
     *        this MBean in its MBean repository.
     * @param instantiator The MBeanInstantiator that will be used to
     *        instantiate MBeans and take care of class loading issues.
     * @param repository The repository to use for this MBeanServer.
     */
    public DefaultMBeanServerInterceptor(MBeanServer         outer,
                                         MBeanServerDelegate delegate,
                                         MBeanInstantiator   instantiator,
<span class="nc" id="L163">                                         Repository          repository) {</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (outer == null) throw new</span>
            IllegalArgumentException(&quot;outer MBeanServer cannot be null&quot;);
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (delegate == null) throw new</span>
            IllegalArgumentException(&quot;MBeanServerDelegate cannot be null&quot;);
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (instantiator == null) throw new</span>
            IllegalArgumentException(&quot;MBeanInstantiator cannot be null&quot;);
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (repository == null) throw new</span>
            IllegalArgumentException(&quot;Repository cannot be null&quot;);

<span class="nc" id="L173">        this.server   = outer;</span>
<span class="nc" id="L174">        this.delegate = delegate;</span>
<span class="nc" id="L175">        this.instantiator = instantiator;</span>
<span class="nc" id="L176">        this.repository   = repository;</span>
<span class="nc" id="L177">        this.domain       = repository.getDefaultDomain();</span>
<span class="nc" id="L178">    }</span>

    public ObjectInstance createMBean(String className, ObjectName name)
        throws ReflectionException, InstanceAlreadyExistsException,
               MBeanRegistrationException, MBeanException,
               NotCompliantMBeanException {

<span class="nc" id="L185">        return createMBean(className, name, (Object[]) null, (String[]) null);</span>

    }

    public ObjectInstance createMBean(String className, ObjectName name,
                                      ObjectName loaderName)
        throws ReflectionException, InstanceAlreadyExistsException,
               MBeanRegistrationException, MBeanException,
               NotCompliantMBeanException, InstanceNotFoundException {

<span class="nc" id="L195">        return createMBean(className, name, loaderName, (Object[]) null,</span>
                           (String[]) null);
    }

    public ObjectInstance createMBean(String className, ObjectName name,
                                      Object[] params, String[] signature)
        throws ReflectionException, InstanceAlreadyExistsException,
               MBeanRegistrationException, MBeanException,
               NotCompliantMBeanException  {

        try {
<span class="nc" id="L206">            return createMBean(className, name, null, true,</span>
                               params, signature);
<span class="nc" id="L208">        } catch (InstanceNotFoundException e) {</span>
            /* Can only happen if loaderName doesn't exist, but we just
               passed null, so we shouldn't get this exception.  */
<span class="nc" id="L211">            throw EnvHelp.initCause(</span>
                new IllegalArgumentException(&quot;Unexpected exception: &quot; + e), e);
        }
    }

    public ObjectInstance createMBean(String className, ObjectName name,
                                      ObjectName loaderName,
                                      Object[] params, String[] signature)
        throws ReflectionException, InstanceAlreadyExistsException,
               MBeanRegistrationException, MBeanException,
               NotCompliantMBeanException, InstanceNotFoundException  {

<span class="nc" id="L223">        return createMBean(className, name, loaderName, false,</span>
                           params, signature);
    }

    private ObjectInstance createMBean(String className, ObjectName name,
                                       ObjectName loaderName,
                                       boolean withDefaultLoaderRepository,
                                       Object[] params, String[] signature)
        throws ReflectionException, InstanceAlreadyExistsException,
               MBeanRegistrationException, MBeanException,
               NotCompliantMBeanException, InstanceNotFoundException {

        Class&lt;?&gt; theClass;

<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (className == null) {</span>
<span class="nc" id="L238">            final RuntimeException wrapped =</span>
                new IllegalArgumentException(&quot;The class name cannot be null&quot;);
<span class="nc" id="L240">            throw new RuntimeOperationsException(wrapped,</span>
                      &quot;Exception occurred during MBean creation&quot;);
        }

<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (name != null) {</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">            if (name.isPattern()) {</span>
<span class="nc" id="L246">                final RuntimeException wrapped =</span>
                    new IllegalArgumentException(&quot;Invalid name-&gt;&quot; +
<span class="nc" id="L248">                                                 name.toString());</span>
                final String msg = &quot;Exception occurred during MBean creation&quot;;
<span class="nc" id="L250">                throw new RuntimeOperationsException(wrapped, msg);</span>
            }

<span class="nc" id="L253">            name = nonDefaultDomain(name);</span>
        }

<span class="nc" id="L256">        checkMBeanPermission(className, null, null, &quot;instantiate&quot;);</span>
<span class="nc" id="L257">        checkMBeanPermission(className, null, name, &quot;registerMBean&quot;);</span>

        /* Load the appropriate class. */
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (withDefaultLoaderRepository) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">            if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L262">                MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L263">                        DefaultMBeanServerInterceptor.class.getName(),</span>
                        &quot;createMBean&quot;,
                        &quot;ClassName = &quot; + className + &quot;, ObjectName = &quot; + name);
            }
<span class="nc" id="L267">            theClass =</span>
<span class="nc" id="L268">                instantiator.findClassWithDefaultLoaderRepository(className);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        } else if (loaderName == null) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L271">                MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L272">                        DefaultMBeanServerInterceptor.class.getName(),</span>
                        &quot;createMBean&quot;, &quot;ClassName = &quot; + className +
                        &quot;, ObjectName = &quot; + name + &quot;, Loader name = null&quot;);
            }

<span class="nc" id="L277">            theClass = instantiator.findClass(className,</span>
<span class="nc" id="L278">                                  server.getClass().getClassLoader());</span>
        } else {
<span class="nc" id="L280">            loaderName = nonDefaultDomain(loaderName);</span>

<span class="nc bnc" id="L282" title="All 2 branches missed.">            if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L283">                MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L284">                        DefaultMBeanServerInterceptor.class.getName(),</span>
                        &quot;createMBean&quot;, &quot;ClassName = &quot; + className +
                        &quot;, ObjectName = &quot; + name +
                        &quot;, Loader name = &quot; + loaderName);
            }

<span class="nc" id="L290">            theClass = instantiator.findClass(className, loaderName);</span>
        }

<span class="nc" id="L293">        checkMBeanTrustPermission(theClass);</span>

        // Check that the MBean can be instantiated by the MBeanServer.
<span class="nc" id="L296">        Introspector.testCreation(theClass);</span>

        // Check the JMX MBean compliance of the class
<span class="nc" id="L299">        Introspector.checkCompliance(theClass);</span>

<span class="nc" id="L301">        Object moi= instantiator.instantiate(theClass, params,  signature,</span>
<span class="nc" id="L302">                                             server.getClass().getClassLoader());</span>

<span class="nc" id="L304">        final String infoClassName = getNewMBeanClassName(moi);</span>

<span class="nc" id="L306">        return registerObject(infoClassName, moi, name);</span>
    }

    public ObjectInstance registerMBean(Object object, ObjectName name)
        throws InstanceAlreadyExistsException, MBeanRegistrationException,
        NotCompliantMBeanException  {

        // ------------------------------
        // ------------------------------
<span class="nc" id="L315">        Class&lt;?&gt; theClass = object.getClass();</span>

<span class="nc" id="L317">        Introspector.checkCompliance(theClass);</span>

<span class="nc" id="L319">        final String infoClassName = getNewMBeanClassName(object);</span>

<span class="nc" id="L321">        checkMBeanPermission(infoClassName, null, name, &quot;registerMBean&quot;);</span>
<span class="nc" id="L322">        checkMBeanTrustPermission(theClass);</span>

<span class="nc" id="L324">        return registerObject(infoClassName, object, name);</span>
    }

    private static String getNewMBeanClassName(Object mbeanToRegister)
            throws NotCompliantMBeanException {
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (mbeanToRegister instanceof DynamicMBean) {</span>
<span class="nc" id="L330">            DynamicMBean mbean = (DynamicMBean) mbeanToRegister;</span>
            final String name;
            try {
<span class="nc" id="L333">                name = mbean.getMBeanInfo().getClassName();</span>
<span class="nc" id="L334">            } catch (Exception e) {</span>
                // Includes case where getMBeanInfo() returns null
<span class="nc" id="L336">                NotCompliantMBeanException ncmbe =</span>
                    new NotCompliantMBeanException(&quot;Bad getMBeanInfo()&quot;);
<span class="nc" id="L338">                ncmbe.initCause(e);</span>
<span class="nc" id="L339">                throw ncmbe;</span>
<span class="nc" id="L340">            }</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (name == null) {</span>
                final String msg = &quot;MBeanInfo has null class name&quot;;
<span class="nc" id="L343">                throw new NotCompliantMBeanException(msg);</span>
            }
<span class="nc" id="L345">            return name;</span>
        } else
<span class="nc" id="L347">            return mbeanToRegister.getClass().getName();</span>
    }

<span class="nc" id="L350">    private final Set&lt;ObjectName&gt; beingUnregistered =</span>
        new HashSet&lt;ObjectName&gt;();

    public void unregisterMBean(ObjectName name)
            throws InstanceNotFoundException, MBeanRegistrationException  {

<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L357">            final RuntimeException wrapped =</span>
                new IllegalArgumentException(&quot;Object name cannot be null&quot;);
<span class="nc" id="L359">            throw new RuntimeOperationsException(wrapped,</span>
                      &quot;Exception occurred trying to unregister the MBean&quot;);
        }

<span class="nc" id="L363">        name = nonDefaultDomain(name);</span>

        /* The semantics of preDeregister are tricky.  If it throws an
           exception, then the unregisterMBean fails.  This allows an
           MBean to refuse to be unregistered.  If it returns
           successfully, then the unregisterMBean can proceed.  In
           this case the preDeregister may have cleaned up some state,
           and will not expect to be called a second time.  So if two
           threads try to unregister the same MBean at the same time
           then one of them must wait for the other one to either (a)
           call preDeregister and get an exception or (b) call
           preDeregister successfully and unregister the MBean.
           Suppose thread T1 is unregistering an MBean and thread T2
           is trying to unregister the same MBean, so waiting for T1.
           Then a deadlock is possible if the preDeregister for T1
           ends up needing a lock held by T2.  Given the semantics
           just described, there does not seem to be any way to avoid
           this.  This will not happen to code where it is clear for
           any given MBean what thread may unregister that MBean.

           On the other hand we clearly do not want a thread that is
           unregistering MBean A to have to wait for another thread
           that is unregistering another MBean B (see bug 6318664).  A
           deadlock in this situation could reasonably be considered
           gratuitous.  So holding a global lock across the
           preDeregister call would be bad.

           So we have a set of ObjectNames that some thread is
           currently unregistering.  When a thread wants to unregister
           a name, it must first check if the name is in the set, and
           if so it must wait.  When a thread successfully unregisters
           a name it removes the name from the set and notifies any
           waiting threads that the set has changed.

           This implies that we must be very careful to ensure that
           the name is removed from the set and waiters notified, no
           matter what code path is taken.  */

<span class="nc" id="L401">        synchronized (beingUnregistered) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            while (beingUnregistered.contains(name)) {</span>
                try {
<span class="nc" id="L404">                    beingUnregistered.wait();</span>
<span class="nc" id="L405">                } catch (InterruptedException e) {</span>
<span class="nc" id="L406">                    throw new MBeanRegistrationException(e, e.toString());</span>
                    // pretend the exception came from preDeregister;
                    // in another execution sequence it could have
<span class="nc" id="L409">                }</span>
            }
<span class="nc" id="L411">            beingUnregistered.add(name);</span>
<span class="nc" id="L412">        }</span>

        try {
<span class="nc" id="L415">            exclusiveUnregisterMBean(name);</span>
        } finally {
<span class="nc" id="L417">            synchronized (beingUnregistered) {</span>
<span class="nc" id="L418">                beingUnregistered.remove(name);</span>
<span class="nc" id="L419">                beingUnregistered.notifyAll();</span>
<span class="nc" id="L420">            }</span>
<span class="nc" id="L421">        }</span>
<span class="nc" id="L422">    }</span>

    private void exclusiveUnregisterMBean(ObjectName name)
            throws InstanceNotFoundException, MBeanRegistrationException {

<span class="nc" id="L427">        DynamicMBean instance = getMBean(name);</span>
        // may throw InstanceNotFoundException

<span class="nc" id="L430">        checkMBeanPermission(instance, null, name, &quot;unregisterMBean&quot;);</span>

<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (instance instanceof MBeanRegistration)</span>
<span class="nc" id="L433">            preDeregisterInvoke((MBeanRegistration) instance);</span>

<span class="nc" id="L435">        final Object resource = getResource(instance);</span>

        // Unregisters the MBean from the repository.
        // Returns the resource context that was used.
        // The returned context does nothing for regular MBeans.
        // For ClassLoader MBeans and JMXNamespace (and JMXDomain)
        // MBeans - the context makes it possible to unregister these
        // objects from the appropriate framework artifacts, such as
        // the CLR or the dispatcher, from within the repository lock.
        // In case of success, we also need to call context.done() at the
        // end of this method.
        //
<span class="nc" id="L447">        final ResourceContext context =</span>
<span class="nc" id="L448">                unregisterFromRepository(resource, instance, name);</span>

        try {
<span class="nc bnc" id="L451" title="All 2 branches missed.">            if (instance instanceof MBeanRegistration)</span>
<span class="nc" id="L452">                postDeregisterInvoke(name,(MBeanRegistration) instance);</span>
        } finally {
<span class="nc" id="L454">            context.done();</span>
<span class="nc" id="L455">        }</span>
<span class="nc" id="L456">    }</span>

    public ObjectInstance getObjectInstance(ObjectName name)
            throws InstanceNotFoundException {

<span class="nc" id="L461">        name = nonDefaultDomain(name);</span>
<span class="nc" id="L462">        DynamicMBean instance = getMBean(name);</span>

<span class="nc" id="L464">        checkMBeanPermission(instance, null, name, &quot;getObjectInstance&quot;);</span>

<span class="nc" id="L466">        final String className = getClassName(instance);</span>

<span class="nc" id="L468">        return new ObjectInstance(name, className);</span>
    }

    public Set&lt;ObjectInstance&gt; queryMBeans(ObjectName name, QueryExp query) {
<span class="nc" id="L472">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (sm != null) {</span>
            // Check if the caller has the right to invoke 'queryMBeans'
            //
<span class="nc" id="L476">            checkMBeanPermission((String) null, null, null, &quot;queryMBeans&quot;);</span>

            // Perform query without &quot;query&quot;.
            //
<span class="nc" id="L480">            Set&lt;ObjectInstance&gt; list = queryMBeansImpl(name, null);</span>

            // Check if the caller has the right to invoke 'queryMBeans'
            // on each specific classname/objectname in the list.
            //
<span class="nc" id="L485">            Set&lt;ObjectInstance&gt; allowedList =</span>
<span class="nc" id="L486">                new HashSet&lt;ObjectInstance&gt;(list.size());</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">            for (ObjectInstance oi : list) {</span>
                try {
<span class="nc" id="L489">                    checkMBeanPermission(oi.getClassName(), null,</span>
<span class="nc" id="L490">                                         oi.getObjectName(), &quot;queryMBeans&quot;);</span>
<span class="nc" id="L491">                    allowedList.add(oi);</span>
<span class="nc" id="L492">                } catch (SecurityException e) {</span>
                    // OK: Do not add this ObjectInstance to the list
<span class="nc" id="L494">                }</span>
<span class="nc" id="L495">            }</span>

            // Apply query to allowed MBeans only.
            //
<span class="nc" id="L499">            return filterListOfObjectInstances(allowedList, query);</span>
        } else {
            // Perform query.
            //
<span class="nc" id="L503">            return queryMBeansImpl(name, query);</span>
        }
    }

    private Set&lt;ObjectInstance&gt; queryMBeansImpl(ObjectName name,
                                                QueryExp query) {
        // Query the MBeans on the repository
        //
<span class="nc" id="L511">        Set&lt;NamedObject&gt; list = repository.query(name, query);</span>

<span class="nc" id="L513">        return (objectInstancesFromFilteredNamedObjects(list, query));</span>
    }

    public Set&lt;ObjectName&gt; queryNames(ObjectName name, QueryExp query) {
        Set&lt;ObjectName&gt; queryList;
<span class="nc" id="L518">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">        if (sm != null) {</span>
            // Check if the caller has the right to invoke 'queryNames'
            //
<span class="nc" id="L522">            checkMBeanPermission((String) null, null, null, &quot;queryNames&quot;);</span>

            // Perform query without &quot;query&quot;.
            //
<span class="nc" id="L526">            Set&lt;ObjectInstance&gt; list = queryMBeansImpl(name, null);</span>

            // Check if the caller has the right to invoke 'queryNames'
            // on each specific classname/objectname in the list.
            //
<span class="nc" id="L531">            Set&lt;ObjectInstance&gt; allowedList =</span>
<span class="nc" id="L532">                new HashSet&lt;ObjectInstance&gt;(list.size());</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">            for (ObjectInstance oi : list) {</span>
                try {
<span class="nc" id="L535">                    checkMBeanPermission(oi.getClassName(), null,</span>
<span class="nc" id="L536">                                         oi.getObjectName(), &quot;queryNames&quot;);</span>
<span class="nc" id="L537">                    allowedList.add(oi);</span>
<span class="nc" id="L538">                } catch (SecurityException e) {</span>
                    // OK: Do not add this ObjectInstance to the list
<span class="nc" id="L540">                }</span>
<span class="nc" id="L541">            }</span>

            // Apply query to allowed MBeans only.
            //
<span class="nc" id="L545">            Set&lt;ObjectInstance&gt; queryObjectInstanceList =</span>
<span class="nc" id="L546">                filterListOfObjectInstances(allowedList, query);</span>
<span class="nc" id="L547">            queryList = new HashSet&lt;ObjectName&gt;(queryObjectInstanceList.size());</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">            for (ObjectInstance oi : queryObjectInstanceList) {</span>
<span class="nc" id="L549">                queryList.add(oi.getObjectName());</span>
<span class="nc" id="L550">            }</span>
<span class="nc" id="L551">        } else {</span>
            // Perform query.
            //
<span class="nc" id="L554">            queryList = queryNamesImpl(name, query);</span>
        }
<span class="nc" id="L556">        return queryList;</span>
    }

    private Set&lt;ObjectName&gt; queryNamesImpl(ObjectName name, QueryExp query) {
        // Query the MBeans on the repository
        //
<span class="nc" id="L562">        Set&lt;NamedObject&gt; list = repository.query(name, query);</span>

<span class="nc" id="L564">        return (objectNamesFromFilteredNamedObjects(list, query));</span>
    }

    public boolean isRegistered(ObjectName name) {
<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L569">            throw new RuntimeOperationsException(</span>
                     new IllegalArgumentException(&quot;Object name cannot be null&quot;),
                     &quot;Object name cannot be null&quot;);
        }

<span class="nc" id="L574">        name = nonDefaultDomain(name);</span>

        /* No Permission check */
        // isRegistered is always unchecked as per JMX spec.

<span class="nc" id="L579">        return (repository.contains(name));</span>
    }

    public String[] getDomains()  {
<span class="nc" id="L583">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">        if (sm != null) {</span>
            // Check if the caller has the right to invoke 'getDomains'
            //
<span class="nc" id="L587">            checkMBeanPermission((String) null, null, null, &quot;getDomains&quot;);</span>

            // Return domains
            //
<span class="nc" id="L591">            String[] domains = repository.getDomains();</span>

            // Check if the caller has the right to invoke 'getDomains'
            // on each specific domain in the list.
            //
<span class="nc" id="L596">            List&lt;String&gt; result = new ArrayList&lt;String&gt;(domains.length);</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">            for (int i = 0; i &lt; domains.length; i++) {</span>
                try {
<span class="nc" id="L599">                    ObjectName dom = Util.newObjectName(domains[i] + &quot;:x=x&quot;);</span>
<span class="nc" id="L600">                    checkMBeanPermission((String) null, null, dom, &quot;getDomains&quot;);</span>
<span class="nc" id="L601">                    result.add(domains[i]);</span>
<span class="nc" id="L602">                } catch (SecurityException e) {</span>
                    // OK: Do not add this domain to the list
<span class="nc" id="L604">                }</span>
            }

            // Make an array from result.
            //
<span class="nc" id="L609">            return result.toArray(new String[result.size()]);</span>
        } else {
<span class="nc" id="L611">            return repository.getDomains();</span>
        }
    }

    public Integer getMBeanCount() {
<span class="nc" id="L616">        return (repository.getCount());</span>
    }

    public Object getAttribute(ObjectName name, String attribute)
        throws MBeanException, AttributeNotFoundException,
               InstanceNotFoundException, ReflectionException {

<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L624">            throw new RuntimeOperationsException(new</span>
                IllegalArgumentException(&quot;Object name cannot be null&quot;),
                &quot;Exception occurred trying to invoke the getter on the MBean&quot;);
        }
<span class="nc bnc" id="L628" title="All 2 branches missed.">        if (attribute == null) {</span>
<span class="nc" id="L629">            throw new RuntimeOperationsException(new</span>
                IllegalArgumentException(&quot;Attribute cannot be null&quot;),
                &quot;Exception occurred trying to invoke the getter on the MBean&quot;);
        }

<span class="nc" id="L634">        name = nonDefaultDomain(name);</span>

<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L637">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L638">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;getAttribute&quot;,
                    &quot;Attribute = &quot; + attribute + &quot;, ObjectName = &quot; + name);
        }

<span class="nc" id="L643">        final DynamicMBean instance = getMBean(name);</span>
<span class="nc" id="L644">        checkMBeanPermission(instance, attribute, name, &quot;getAttribute&quot;);</span>

        try {
<span class="nc" id="L647">            return instance.getAttribute(attribute);</span>
<span class="nc" id="L648">        } catch (AttributeNotFoundException e) {</span>
<span class="nc" id="L649">            throw e;</span>
<span class="nc" id="L650">        } catch (Throwable t) {</span>
<span class="nc" id="L651">            rethrowMaybeMBeanException(t);</span>
<span class="nc" id="L652">            throw new AssertionError(); // not reached</span>
        }
    }

    public AttributeList getAttributes(ObjectName name, String[] attributes)
        throws InstanceNotFoundException, ReflectionException  {

<span class="nc bnc" id="L659" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L660">            throw new RuntimeOperationsException(new</span>
                IllegalArgumentException(&quot;ObjectName name cannot be null&quot;),
                &quot;Exception occurred trying to invoke the getter on the MBean&quot;);
        }

<span class="nc bnc" id="L665" title="All 2 branches missed.">        if (attributes == null) {</span>
<span class="nc" id="L666">            throw new RuntimeOperationsException(new</span>
                IllegalArgumentException(&quot;Attributes cannot be null&quot;),
                &quot;Exception occurred trying to invoke the getter on the MBean&quot;);
        }

<span class="nc" id="L671">        name = nonDefaultDomain(name);</span>

<span class="nc bnc" id="L673" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L674">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L675">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;getAttributes&quot;, &quot;ObjectName = &quot; + name);
        }

<span class="nc" id="L679">        final DynamicMBean instance = getMBean(name);</span>
        final String[] allowedAttributes;
<span class="nc" id="L681">        final SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (sm == null)</span>
<span class="nc" id="L683">            allowedAttributes = attributes;</span>
        else {
<span class="nc" id="L685">            final String classname = getClassName(instance);</span>

            // Check if the caller has the right to invoke 'getAttribute'
            //
<span class="nc" id="L689">            checkMBeanPermission(classname, null, name, &quot;getAttribute&quot;);</span>

            // Check if the caller has the right to invoke 'getAttribute'
            // on each specific attribute
            //
<span class="nc" id="L694">            List&lt;String&gt; allowedList =</span>
                new ArrayList&lt;String&gt;(attributes.length);
<span class="nc bnc" id="L696" title="All 2 branches missed.">            for (String attr : attributes) {</span>
                try {
<span class="nc" id="L698">                    checkMBeanPermission(classname, attr, name, &quot;getAttribute&quot;);</span>
<span class="nc" id="L699">                    allowedList.add(attr);</span>
<span class="nc" id="L700">                } catch (SecurityException e) {</span>
                    // OK: Do not add this attribute to the list
<span class="nc" id="L702">                }</span>
            }
<span class="nc" id="L704">            allowedAttributes =</span>
<span class="nc" id="L705">                    allowedList.toArray(new String[allowedList.size()]);</span>
        }

        try {
<span class="nc" id="L709">            return instance.getAttributes(allowedAttributes);</span>
<span class="nc" id="L710">        } catch (Throwable t) {</span>
<span class="nc" id="L711">            rethrow(t);</span>
<span class="nc" id="L712">            throw new AssertionError();</span>
        }
    }

    public void setAttribute(ObjectName name, Attribute attribute)
        throws InstanceNotFoundException, AttributeNotFoundException,
               InvalidAttributeValueException, MBeanException,
               ReflectionException  {

<span class="nc bnc" id="L721" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L722">            throw new RuntimeOperationsException(new</span>
                IllegalArgumentException(&quot;ObjectName name cannot be null&quot;),
                &quot;Exception occurred trying to invoke the setter on the MBean&quot;);
        }

<span class="nc bnc" id="L727" title="All 2 branches missed.">        if (attribute == null) {</span>
<span class="nc" id="L728">            throw new RuntimeOperationsException(new</span>
                IllegalArgumentException(&quot;Attribute cannot be null&quot;),
                &quot;Exception occurred trying to invoke the setter on the MBean&quot;);
        }

<span class="nc" id="L733">        name = nonDefaultDomain(name);</span>

<span class="nc bnc" id="L735" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L736">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L737">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;setAttribute&quot;, &quot;ObjectName = &quot; + name +
<span class="nc" id="L739">                    &quot;, Attribute = &quot; + attribute.getName());</span>
        }

<span class="nc" id="L742">        DynamicMBean instance = getMBean(name);</span>
<span class="nc" id="L743">        checkMBeanPermission(instance, attribute.getName(), name, &quot;setAttribute&quot;);</span>

        try {
<span class="nc" id="L746">            instance.setAttribute(attribute);</span>
<span class="nc" id="L747">        } catch (AttributeNotFoundException e) {</span>
<span class="nc" id="L748">            throw e;</span>
<span class="nc" id="L749">        } catch (InvalidAttributeValueException e) {</span>
<span class="nc" id="L750">            throw e;</span>
<span class="nc" id="L751">        } catch (Throwable t) {</span>
<span class="nc" id="L752">            rethrowMaybeMBeanException(t);</span>
<span class="nc" id="L753">            throw new AssertionError();</span>
<span class="nc" id="L754">        }</span>
<span class="nc" id="L755">    }</span>

    public AttributeList setAttributes(ObjectName name,
                                       AttributeList attributes)
            throws InstanceNotFoundException, ReflectionException  {

<span class="nc bnc" id="L761" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L762">            throw new RuntimeOperationsException(new</span>
                IllegalArgumentException(&quot;ObjectName name cannot be null&quot;),
                &quot;Exception occurred trying to invoke the setter on the MBean&quot;);
        }

<span class="nc bnc" id="L767" title="All 2 branches missed.">        if (attributes == null) {</span>
<span class="nc" id="L768">            throw new RuntimeOperationsException(new</span>
            IllegalArgumentException(&quot;AttributeList  cannot be null&quot;),
            &quot;Exception occurred trying to invoke the setter on the MBean&quot;);
        }

<span class="nc" id="L773">        name = nonDefaultDomain(name);</span>

<span class="nc" id="L775">        final DynamicMBean instance = getMBean(name);</span>
        final AttributeList allowedAttributes;
<span class="nc" id="L777">        final SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (sm == null)</span>
<span class="nc" id="L779">            allowedAttributes = attributes;</span>
        else {
<span class="nc" id="L781">            String classname = getClassName(instance);</span>

            // Check if the caller has the right to invoke 'setAttribute'
            //
<span class="nc" id="L785">            checkMBeanPermission(classname, null, name, &quot;setAttribute&quot;);</span>

            // Check if the caller has the right to invoke 'setAttribute'
            // on each specific attribute
            //
<span class="nc" id="L790">            allowedAttributes = new AttributeList(attributes.size());</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">            for (Attribute attribute : attributes.asList()) {</span>
                try {
<span class="nc" id="L793">                    checkMBeanPermission(classname, attribute.getName(),</span>
                                         name, &quot;setAttribute&quot;);
<span class="nc" id="L795">                    allowedAttributes.add(attribute);</span>
<span class="nc" id="L796">                } catch (SecurityException e) {</span>
                    // OK: Do not add this attribute to the list
<span class="nc" id="L798">                }</span>
<span class="nc" id="L799">            }</span>
        }
        try {
<span class="nc" id="L802">            return instance.setAttributes(allowedAttributes);</span>
<span class="nc" id="L803">        } catch (Throwable t) {</span>
<span class="nc" id="L804">            rethrow(t);</span>
<span class="nc" id="L805">            throw new AssertionError();</span>
        }
    }

    public Object invoke(ObjectName name, String operationName,
                         Object params[], String signature[])
            throws InstanceNotFoundException, MBeanException,
                   ReflectionException {

<span class="nc" id="L814">        name = nonDefaultDomain(name);</span>

<span class="nc" id="L816">        DynamicMBean instance = getMBean(name);</span>
<span class="nc" id="L817">        checkMBeanPermission(instance, operationName, name, &quot;invoke&quot;);</span>
        try {
<span class="nc" id="L819">            return instance.invoke(operationName, params, signature);</span>
<span class="nc" id="L820">        } catch (Throwable t) {</span>
<span class="nc" id="L821">            rethrowMaybeMBeanException(t);</span>
<span class="nc" id="L822">            throw new AssertionError();</span>
        }
    }

    /* Centralize some of the tedious exception wrapping demanded by the JMX
       spec. */
    private static void rethrow(Throwable t)
            throws ReflectionException {
        try {
<span class="nc" id="L831">            throw t;</span>
<span class="nc" id="L832">        } catch (ReflectionException e) {</span>
<span class="nc" id="L833">            throw e;</span>
<span class="nc" id="L834">        } catch (RuntimeOperationsException e) {</span>
<span class="nc" id="L835">            throw e;</span>
<span class="nc" id="L836">        } catch (RuntimeErrorException e) {</span>
<span class="nc" id="L837">            throw e;</span>
<span class="nc" id="L838">        } catch (RuntimeException e) {</span>
<span class="nc" id="L839">            throw new RuntimeMBeanException(e, e.toString());</span>
<span class="nc" id="L840">        } catch (Error e) {</span>
<span class="nc" id="L841">            throw new RuntimeErrorException(e, e.toString());</span>
<span class="nc" id="L842">        } catch (Throwable t2) {</span>
            // should not happen
<span class="nc" id="L844">            throw new RuntimeException(&quot;Unexpected exception&quot;, t2);</span>
        }
    }

    private static void rethrowMaybeMBeanException(Throwable t)
            throws ReflectionException, MBeanException {
<span class="nc bnc" id="L850" title="All 2 branches missed.">        if (t instanceof MBeanException)</span>
<span class="nc" id="L851">            throw (MBeanException) t;</span>
<span class="nc" id="L852">        rethrow(t);</span>
<span class="nc" id="L853">    }</span>

    /**
     * Register &lt;code&gt;object&lt;/code&gt; in the repository, with the
     * given &lt;code&gt;name&lt;/code&gt;.
     * This method is called by the various createMBean() flavours
     * and by registerMBean() after all MBean compliance tests
     * have been performed.
     * &lt;p&gt;
     * This method does not performed any kind of test compliance,
     * and the caller should make sure that the given &lt;code&gt;object&lt;/code&gt;
     * is MBean compliant.
     * &lt;p&gt;
     * This methods performed all the basic steps needed for object
     * registration:
     * &lt;ul&gt;
     * &lt;li&gt;If the &lt;code&gt;object&lt;/code&gt; implements the MBeanRegistration
     *     interface, it invokes preRegister() on the object.&lt;/li&gt;
     * &lt;li&gt;Then the object is added to the repository with the given
     *     &lt;code&gt;name&lt;/code&gt;.&lt;/li&gt;
     * &lt;li&gt;Finally, if the &lt;code&gt;object&lt;/code&gt; implements the
     *     MBeanRegistration interface, it invokes postRegister()
     *     on the object.&lt;/li&gt;
     * &lt;/ul&gt;
     * @param object A reference to a MBean compliant object.
     * @param name   The ObjectName of the &lt;code&gt;object&lt;/code&gt; MBean.
     * @return the actual ObjectName with which the object was registered.
     * @exception InstanceAlreadyExistsException if an object is already
     *            registered with that name.
     * @exception MBeanRegistrationException if an exception occurs during
     *            registration.
     **/
    private ObjectInstance registerObject(String classname,
                                          Object object, ObjectName name)
        throws InstanceAlreadyExistsException,
               MBeanRegistrationException,
               NotCompliantMBeanException {

<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (object == null) {</span>
<span class="nc" id="L892">            final RuntimeException wrapped =</span>
                new IllegalArgumentException(&quot;Cannot add null object&quot;);
<span class="nc" id="L894">            throw new RuntimeOperationsException(wrapped,</span>
                        &quot;Exception occurred trying to register the MBean&quot;);
        }

<span class="nc" id="L898">        DynamicMBean mbean = Introspector.makeDynamicMBean(object);</span>

<span class="nc" id="L900">        return registerDynamicMBean(classname, mbean, name);</span>
    }

    private ObjectInstance registerDynamicMBean(String classname,
                                                DynamicMBean mbean,
                                                ObjectName name)
        throws InstanceAlreadyExistsException,
               MBeanRegistrationException,
               NotCompliantMBeanException {


<span class="nc" id="L911">        name = nonDefaultDomain(name);</span>

<span class="nc bnc" id="L913" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L914">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L915">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;registerMBean&quot;, &quot;ObjectName = &quot; + name);
        }

<span class="nc" id="L919">        ObjectName logicalName = preRegister(mbean, server, name);</span>

        // preRegister returned successfully, so from this point on we
        // must call postRegister(false) if there is any problem.
<span class="nc" id="L923">        boolean registered = false;</span>
<span class="nc" id="L924">        boolean registerFailed = false;</span>
<span class="nc" id="L925">        ResourceContext context = null;</span>

        try {
<span class="nc bnc" id="L928" title="All 2 branches missed.">            if (mbean instanceof DynamicMBean2) {</span>
                try {
<span class="nc" id="L930">                    ((DynamicMBean2) mbean).preRegister2(server, logicalName);</span>
<span class="nc" id="L931">                    registerFailed = true;  // until we succeed</span>
<span class="nc" id="L932">                } catch (Exception e) {</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">                    if (e instanceof RuntimeException)</span>
<span class="nc" id="L934">                        throw (RuntimeException) e;</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">                    if (e instanceof InstanceAlreadyExistsException)</span>
<span class="nc" id="L936">                        throw (InstanceAlreadyExistsException) e;</span>
<span class="nc" id="L937">                    throw new RuntimeException(e);</span>
<span class="nc" id="L938">                }</span>
            }

<span class="nc bnc" id="L941" title="All 4 branches missed.">            if (logicalName != name &amp;&amp; logicalName != null) {</span>
<span class="nc" id="L942">                logicalName =</span>
<span class="nc" id="L943">                        ObjectName.getInstance(nonDefaultDomain(logicalName));</span>
            }

<span class="nc" id="L946">            checkMBeanPermission(classname, null, logicalName, &quot;registerMBean&quot;);</span>

<span class="nc bnc" id="L948" title="All 2 branches missed.">            if (logicalName == null) {</span>
<span class="nc" id="L949">                final RuntimeException wrapped =</span>
                    new IllegalArgumentException(&quot;No object name specified&quot;);
<span class="nc" id="L951">                throw new RuntimeOperationsException(wrapped,</span>
                            &quot;Exception occurred trying to register the MBean&quot;);
            }

<span class="nc" id="L955">            final Object resource = getResource(mbean);</span>

            // Register the MBean with the repository.
            // Returns the resource context that was used.
            // The returned context does nothing for regular MBeans.
            // For ClassLoader MBeans the context makes it possible to register these
            // objects with the appropriate framework artifacts, such as
            // the CLR, from within the repository lock.
            // In case of success, we also need to call context.done() at the
            // end of this method.
            //
<span class="nc" id="L966">            context = registerWithRepository(resource, mbean, logicalName);</span>


<span class="nc" id="L969">            registerFailed = false;</span>
<span class="nc" id="L970">            registered = true;</span>

        } finally {
<span class="nc" id="L973">            try {</span>
<span class="nc" id="L974">                postRegister(logicalName, mbean, registered, registerFailed);</span>
            } finally {
<span class="nc bnc" id="L976" title="All 16 branches missed.">                if (registered &amp;&amp; context!=null) context.done();</span>
            }
<span class="nc" id="L978">        }</span>
<span class="nc" id="L979">        return new ObjectInstance(logicalName, classname);</span>
    }

    private static void throwMBeanRegistrationException(Throwable t, String where)
    throws MBeanRegistrationException {
<span class="nc bnc" id="L984" title="All 2 branches missed.">        if (t instanceof RuntimeException) {</span>
<span class="nc" id="L985">            throw new RuntimeMBeanException((RuntimeException)t,</span>
                    &quot;RuntimeException thrown &quot; + where);
<span class="nc bnc" id="L987" title="All 2 branches missed.">        } else if (t instanceof Error) {</span>
<span class="nc" id="L988">            throw new RuntimeErrorException((Error)t,</span>
                    &quot;Error thrown &quot; + where);
<span class="nc bnc" id="L990" title="All 2 branches missed.">        } else if (t instanceof MBeanRegistrationException) {</span>
<span class="nc" id="L991">            throw (MBeanRegistrationException)t;</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">        } else if (t instanceof Exception) {</span>
<span class="nc" id="L993">            throw new MBeanRegistrationException((Exception)t,</span>
                    &quot;Exception thrown &quot; + where);
        } else // neither Error nor Exception??
<span class="nc" id="L996">            throw new RuntimeException(t);</span>
    }

    private static ObjectName preRegister(
            DynamicMBean mbean, MBeanServer mbs, ObjectName name)
            throws InstanceAlreadyExistsException, MBeanRegistrationException {

<span class="nc" id="L1003">        ObjectName newName = null;</span>

        try {
<span class="nc bnc" id="L1006" title="All 2 branches missed.">            if (mbean instanceof MBeanRegistration)</span>
<span class="nc" id="L1007">                newName = ((MBeanRegistration) mbean).preRegister(mbs, name);</span>
<span class="nc" id="L1008">        } catch (Throwable t) {</span>
<span class="nc" id="L1009">            throwMBeanRegistrationException(t, &quot;in preRegister method&quot;);</span>
<span class="nc" id="L1010">        }</span>

<span class="nc bnc" id="L1012" title="All 2 branches missed.">        if (newName != null) return newName;</span>
<span class="nc" id="L1013">        else return name;</span>
    }

    private static void postRegister(
            ObjectName logicalName, DynamicMBean mbean,
            boolean registrationDone, boolean registerFailed) {

<span class="nc bnc" id="L1020" title="All 4 branches missed.">        if (registerFailed &amp;&amp; mbean instanceof DynamicMBean2)</span>
<span class="nc" id="L1021">            ((DynamicMBean2) mbean).registerFailed();</span>
        try {
<span class="nc bnc" id="L1023" title="All 2 branches missed.">            if (mbean instanceof MBeanRegistration)</span>
<span class="nc" id="L1024">                ((MBeanRegistration) mbean).postRegister(registrationDone);</span>
<span class="nc" id="L1025">        } catch (RuntimeException e) {</span>
<span class="nc" id="L1026">            MBEANSERVER_LOGGER.fine(&quot;While registering MBean [&quot;+logicalName+</span>
                    &quot;]: &quot; + &quot;Exception thrown by postRegister: &quot; +
                    &quot;rethrowing &lt;&quot;+e+&quot;&gt;, but keeping the MBean registered&quot;);
<span class="nc" id="L1029">            throw new RuntimeMBeanException(e,</span>
                      &quot;RuntimeException thrown in postRegister method: &quot;+
                      &quot;rethrowing &lt;&quot;+e+&quot;&gt;, but keeping the MBean registered&quot;);
<span class="nc" id="L1032">        } catch (Error er) {</span>
<span class="nc" id="L1033">            MBEANSERVER_LOGGER.fine(&quot;While registering MBean [&quot;+logicalName+</span>
                    &quot;]: &quot; + &quot;Error thrown by postRegister: &quot; +
                    &quot;rethrowing &lt;&quot;+er+&quot;&gt;, but keeping the MBean registered&quot;);
<span class="nc" id="L1036">            throw new RuntimeErrorException(er,</span>
                      &quot;Error thrown in postRegister method: &quot;+
                      &quot;rethrowing &lt;&quot;+er+&quot;&gt;, but keeping the MBean registered&quot;);
<span class="nc" id="L1039">        }</span>
<span class="nc" id="L1040">    }</span>

    private static void preDeregisterInvoke(MBeanRegistration moi)
            throws MBeanRegistrationException {
        try {
<span class="nc" id="L1045">            moi.preDeregister();</span>
<span class="nc" id="L1046">        } catch (Throwable t) {</span>
<span class="nc" id="L1047">            throwMBeanRegistrationException(t, &quot;in preDeregister method&quot;);</span>
<span class="nc" id="L1048">        }</span>
<span class="nc" id="L1049">    }</span>

    private static void postDeregisterInvoke(ObjectName mbean,
            MBeanRegistration moi) {
        try {
<span class="nc" id="L1054">            moi.postDeregister();</span>
<span class="nc" id="L1055">        } catch (RuntimeException e) {</span>
<span class="nc" id="L1056">            MBEANSERVER_LOGGER.fine(&quot;While unregistering MBean [&quot;+mbean+</span>
                    &quot;]: &quot; + &quot;Exception thrown by postDeregister: &quot; +
                    &quot;rethrowing &lt;&quot;+e+&quot;&gt;, although the MBean is succesfully &quot; +
                    &quot;unregistered&quot;);
<span class="nc" id="L1060">            throw new RuntimeMBeanException(e,</span>
                      &quot;RuntimeException thrown in postDeregister method: &quot;+
                      &quot;rethrowing &lt;&quot;+e+
                      &quot;&gt;, although the MBean is sucessfully unregistered&quot;);
<span class="nc" id="L1064">        } catch (Error er) {</span>
<span class="nc" id="L1065">            MBEANSERVER_LOGGER.fine(&quot;While unregistering MBean [&quot;+mbean+</span>
                    &quot;]: &quot; + &quot;Error thrown by postDeregister: &quot; +
                    &quot;rethrowing &lt;&quot;+er+&quot;&gt;, although the MBean is succesfully &quot; +
                    &quot;unregistered&quot;);
<span class="nc" id="L1069">            throw new RuntimeErrorException(er,</span>
                      &quot;Error thrown in postDeregister method: &quot;+
                      &quot;rethrowing &lt;&quot;+er+
                      &quot;&gt;, although the MBean is sucessfully unregistered&quot;);
<span class="nc" id="L1073">        }</span>
<span class="nc" id="L1074">    }</span>

    /**
     * Gets a specific MBean controlled by the DefaultMBeanServerInterceptor.
     * The name must have a non-default domain.
     */
    private DynamicMBean getMBean(ObjectName name)
        throws InstanceNotFoundException {

<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L1084">            throw new RuntimeOperationsException(new</span>
                IllegalArgumentException(&quot;Object name cannot be null&quot;),
                               &quot;Exception occurred trying to get an MBean&quot;);
        }
<span class="nc" id="L1088">        DynamicMBean obj = repository.retrieve(name);</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1091">                MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L1092">                        DefaultMBeanServerInterceptor.class.getName(),</span>
                        &quot;getMBean&quot;, name + &quot; : Found no object&quot;);
            }
<span class="nc" id="L1095">            throw new InstanceNotFoundException(name.toString());</span>
        }
<span class="nc" id="L1097">        return obj;</span>
    }

    private static Object getResource(DynamicMBean mbean) {
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        if (mbean instanceof DynamicMBean2)</span>
<span class="nc" id="L1102">            return ((DynamicMBean2) mbean).getResource();</span>
        else
<span class="nc" id="L1104">            return mbean;</span>
    }

    private ObjectName nonDefaultDomain(ObjectName name) {
<span class="nc bnc" id="L1108" title="All 4 branches missed.">        if (name == null || name.getDomain().length() &gt; 0)</span>
<span class="nc" id="L1109">            return name;</span>

        /* The ObjectName looks like &quot;:a=b&quot;, and that's what its
           toString() will return in this implementation.  So
           we can just stick the default domain in front of it
           to get a non-default-domain name.  We depend on the
           fact that toString() works like that and that it
           leaves wildcards in place (so we can detect an error
           if one is supplied where it shouldn't be).  */
<span class="nc" id="L1118">        final String completeName = domain + name;</span>

<span class="nc" id="L1120">        return Util.newObjectName(completeName);</span>
    }

    public String getDefaultDomain()  {
<span class="nc" id="L1124">        return domain;</span>
    }

    /*
     * Notification handling.
     *
     * This is not trivial, because the MBeanServer translates the
     * source of a received notification from a reference to an MBean
     * into the ObjectName of that MBean.  While that does make
     * notification sending easier for MBean writers, it comes at a
     * considerable cost.  We need to replace the source of a
     * notification, which is basically wrong if there are also
     * listeners registered directly with the MBean (without going
     * through the MBean server).  We also need to wrap the listener
     * supplied by the client of the MBeanServer with a listener that
     * performs the substitution before forwarding.  This is why we
     * strongly discourage people from putting MBean references in the
     * source of their notifications.  Instead they should arrange to
     * put the ObjectName there themselves.
     *
     * However, existing code relies on the substitution, so we are
     * stuck with it.
     *
     * Here's how we handle it.  When you add a listener, we make a
     * ListenerWrapper around it.  We look that up in the
     * listenerWrappers map, and if there was already a wrapper for
     * that listener with the given ObjectName, we reuse it.  This map
     * is a WeakHashMap, so a listener that is no longer registered
     * with any MBean can be garbage collected.
     *
     * We cannot use simpler solutions such as always creating a new
     * wrapper or always registering the same listener with the MBean
     * and using the handback to find the client's original listener.
     * The reason is that we need to support the removeListener
     * variant that removes all (listener,filter,handback) triples on
     * a broadcaster that have a given listener.  And we do not have
     * any way to inspect a broadcaster's internal list of triples.
     * So the same client listener must always map to the same
     * listener registered with the broadcaster.
     *
     * Another possible solution would be to map from ObjectName to
     * list of listener wrappers (or IdentityHashMap of listener
     * wrappers), making this list the first time a listener is added
     * on a given MBean, and removing it when the MBean is removed.
     * This is probably more costly in memory, but could be useful if
     * some day we don't want to rely on weak references.
     */
    public void addNotificationListener(ObjectName name,
                                        NotificationListener listener,
                                        NotificationFilter filter,
                                        Object handback)
            throws InstanceNotFoundException {

        // ------------------------------
        // ------------------------------
<span class="nc bnc" id="L1179" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1180">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L1181">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;addNotificationListener&quot;, &quot;ObjectName = &quot; + name);
        }

<span class="nc" id="L1185">        DynamicMBean instance = getMBean(name);</span>
<span class="nc" id="L1186">        checkMBeanPermission(instance, null, name, &quot;addNotificationListener&quot;);</span>

<span class="nc" id="L1188">        NotificationBroadcaster broadcaster =</span>
<span class="nc" id="L1189">                getNotificationBroadcaster(name, instance,</span>
                                           NotificationBroadcaster.class);

        // ------------------
        // Check listener
        // ------------------
<span class="nc bnc" id="L1195" title="All 2 branches missed.">        if (listener == null) {</span>
<span class="nc" id="L1196">            throw new RuntimeOperationsException(new</span>
                IllegalArgumentException(&quot;Null listener&quot;),&quot;Null listener&quot;);
        }

<span class="nc" id="L1200">        NotificationListener listenerWrapper =</span>
<span class="nc" id="L1201">            getListenerWrapper(listener, name, instance, true);</span>
<span class="nc" id="L1202">        broadcaster.addNotificationListener(listenerWrapper, filter, handback);</span>
<span class="nc" id="L1203">    }</span>

    public void addNotificationListener(ObjectName name,
                                        ObjectName listener,
                                        NotificationFilter filter,
                                        Object handback)
            throws InstanceNotFoundException {

        // ------------------------------
        // ------------------------------

        // ----------------
        // Get listener object
        // ----------------
<span class="nc" id="L1217">        DynamicMBean instance = getMBean(listener);</span>
<span class="nc" id="L1218">        Object resource = getResource(instance);</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">        if (!(resource instanceof NotificationListener)) {</span>
<span class="nc" id="L1220">            throw new RuntimeOperationsException(new</span>
<span class="nc" id="L1221">                IllegalArgumentException(listener.getCanonicalName()),</span>
<span class="nc" id="L1222">                &quot;The MBean &quot; + listener.getCanonicalName() +</span>
                &quot;does not implement the NotificationListener interface&quot;) ;
        }

        // ----------------
        // Add a listener on an MBean
        // ----------------
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1230">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L1231">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;addNotificationListener&quot;,
                    &quot;ObjectName = &quot; + name + &quot;, Listener = &quot; + listener);
        }
<span class="nc" id="L1235">        server.addNotificationListener(name,(NotificationListener) resource,</span>
                                       filter, handback) ;
<span class="nc" id="L1237">    }</span>

    public void removeNotificationListener(ObjectName name,
                                           NotificationListener listener)
            throws InstanceNotFoundException, ListenerNotFoundException {
<span class="nc" id="L1242">        removeNotificationListener(name, listener, null, null, true);</span>
<span class="nc" id="L1243">    }</span>

    public void removeNotificationListener(ObjectName name,
                                           NotificationListener listener,
                                           NotificationFilter filter,
                                           Object handback)
            throws InstanceNotFoundException, ListenerNotFoundException {
<span class="nc" id="L1250">        removeNotificationListener(name, listener, filter, handback, false);</span>
<span class="nc" id="L1251">    }</span>

    public void removeNotificationListener(ObjectName name,
                                           ObjectName listener)
            throws InstanceNotFoundException, ListenerNotFoundException {
<span class="nc" id="L1256">        NotificationListener instance = getListener(listener);</span>

<span class="nc bnc" id="L1258" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1259">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L1260">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;removeNotificationListener&quot;,
                    &quot;ObjectName = &quot; + name + &quot;, Listener = &quot; + listener);
        }
<span class="nc" id="L1264">        server.removeNotificationListener(name, instance);</span>
<span class="nc" id="L1265">    }</span>

    public void removeNotificationListener(ObjectName name,
                                           ObjectName listener,
                                           NotificationFilter filter,
                                           Object handback)
            throws InstanceNotFoundException, ListenerNotFoundException {

<span class="nc" id="L1273">        NotificationListener instance = getListener(listener);</span>

<span class="nc bnc" id="L1275" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1276">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L1277">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;removeNotificationListener&quot;,
                    &quot;ObjectName = &quot; + name + &quot;, Listener = &quot; + listener);
        }
<span class="nc" id="L1281">        server.removeNotificationListener(name, instance, filter, handback);</span>
<span class="nc" id="L1282">    }</span>

    private NotificationListener getListener(ObjectName listener)
        throws ListenerNotFoundException {
        // ----------------
        // Get listener object
        // ----------------
        DynamicMBean instance;
        try {
<span class="nc" id="L1291">            instance = getMBean(listener);</span>
<span class="nc" id="L1292">        } catch (InstanceNotFoundException e) {</span>
<span class="nc" id="L1293">            throw EnvHelp.initCause(</span>
<span class="nc" id="L1294">                          new ListenerNotFoundException(e.getMessage()), e);</span>
<span class="nc" id="L1295">        }</span>

<span class="nc" id="L1297">        Object resource = getResource(instance);</span>
<span class="nc bnc" id="L1298" title="All 2 branches missed.">        if (!(resource instanceof NotificationListener)) {</span>
<span class="nc" id="L1299">            final RuntimeException exc =</span>
<span class="nc" id="L1300">                new IllegalArgumentException(listener.getCanonicalName());</span>
<span class="nc" id="L1301">            final String msg =</span>
<span class="nc" id="L1302">                &quot;MBean &quot; + listener.getCanonicalName() + &quot; does not &quot; +</span>
<span class="nc" id="L1303">                &quot;implement &quot; + NotificationListener.class.getName();</span>
<span class="nc" id="L1304">            throw new RuntimeOperationsException(exc, msg);</span>
        }
<span class="nc" id="L1306">        return (NotificationListener) resource;</span>
    }

    private void removeNotificationListener(ObjectName name,
                                            NotificationListener listener,
                                            NotificationFilter filter,
                                            Object handback,
                                            boolean removeAll)
            throws InstanceNotFoundException, ListenerNotFoundException {

<span class="nc bnc" id="L1316" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1317">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L1318">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;removeNotificationListener&quot;, &quot;ObjectName = &quot; + name);
        }

<span class="nc" id="L1322">        DynamicMBean instance = getMBean(name);</span>
<span class="nc" id="L1323">        checkMBeanPermission(instance, null, name, &quot;removeNotificationListener&quot;);</span>

        /* We could simplify the code by assigning broadcaster after
           assigning listenerWrapper, but that would change the error
           behavior when both the broadcaster and the listener are
           erroneous.  */

<span class="nc bnc" id="L1330" title="All 2 branches missed.">        Class&lt;? extends NotificationBroadcaster&gt; reqClass =</span>
            removeAll ? NotificationBroadcaster.class : NotificationEmitter.class;
<span class="nc" id="L1332">        NotificationBroadcaster broadcaster =</span>
<span class="nc" id="L1333">            getNotificationBroadcaster(name, instance, reqClass);</span>

<span class="nc" id="L1335">        NotificationListener listenerWrapper =</span>
<span class="nc" id="L1336">            getListenerWrapper(listener, name, instance, false);</span>

<span class="nc bnc" id="L1338" title="All 2 branches missed.">        if (listenerWrapper == null)</span>
<span class="nc" id="L1339">            throw new ListenerNotFoundException(&quot;Unknown listener&quot;);</span>

<span class="nc bnc" id="L1341" title="All 2 branches missed.">        if (removeAll)</span>
<span class="nc" id="L1342">            broadcaster.removeNotificationListener(listenerWrapper);</span>
        else {
<span class="nc" id="L1344">            NotificationEmitter emitter = (NotificationEmitter) broadcaster;</span>
<span class="nc" id="L1345">            emitter.removeNotificationListener(listenerWrapper,</span>
                                               filter,
                                               handback);
        }
<span class="nc" id="L1349">    }</span>

    private static &lt;T extends NotificationBroadcaster&gt;
            T getNotificationBroadcaster(ObjectName name, Object instance,
                                         Class&lt;T&gt; reqClass) {
<span class="nc bnc" id="L1354" title="All 2 branches missed.">        if (reqClass.isInstance(instance))</span>
<span class="nc" id="L1355">            return reqClass.cast(instance);</span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">        if (instance instanceof DynamicMBean2)</span>
<span class="nc" id="L1357">            instance = ((DynamicMBean2) instance).getResource();</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">        if (reqClass.isInstance(instance))</span>
<span class="nc" id="L1359">            return reqClass.cast(instance);</span>
<span class="nc" id="L1360">        final RuntimeException exc =</span>
<span class="nc" id="L1361">            new IllegalArgumentException(name.getCanonicalName());</span>
<span class="nc" id="L1362">        final String msg =</span>
<span class="nc" id="L1363">            &quot;MBean &quot; + name.getCanonicalName() + &quot; does not &quot; +</span>
<span class="nc" id="L1364">            &quot;implement &quot; + reqClass.getName();</span>
<span class="nc" id="L1365">        throw new RuntimeOperationsException(exc, msg);</span>
    }

    public MBeanInfo getMBeanInfo(ObjectName name)
        throws InstanceNotFoundException, IntrospectionException,
               ReflectionException {

        // ------------------------------
        // ------------------------------

<span class="nc" id="L1375">        DynamicMBean moi = getMBean(name);</span>
        final MBeanInfo mbi;
        try {
<span class="nc" id="L1378">            mbi = moi.getMBeanInfo();</span>
<span class="nc" id="L1379">        } catch (RuntimeMBeanException e) {</span>
<span class="nc" id="L1380">            throw e;</span>
<span class="nc" id="L1381">        } catch (RuntimeErrorException e) {</span>
<span class="nc" id="L1382">            throw e;</span>
<span class="nc" id="L1383">        } catch (RuntimeException e) {</span>
<span class="nc" id="L1384">            throw new RuntimeMBeanException(e,</span>
                    &quot;getMBeanInfo threw RuntimeException&quot;);
<span class="nc" id="L1386">        } catch (Error e) {</span>
<span class="nc" id="L1387">            throw new RuntimeErrorException(e, &quot;getMBeanInfo threw Error&quot;);</span>
<span class="nc" id="L1388">        }</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">        if (mbi == null)</span>
<span class="nc" id="L1390">            throw new JMRuntimeException(&quot;MBean &quot; + name +</span>
                                         &quot;has no MBeanInfo&quot;);

<span class="nc" id="L1393">        checkMBeanPermission(mbi.getClassName(), null, name, &quot;getMBeanInfo&quot;);</span>

<span class="nc" id="L1395">        return mbi;</span>
    }

    public boolean isInstanceOf(ObjectName name, String className)
        throws InstanceNotFoundException {

<span class="nc" id="L1401">        final DynamicMBean instance = getMBean(name);</span>
<span class="nc" id="L1402">        checkMBeanPermission(instance, null, name, &quot;isInstanceOf&quot;);</span>

        try {
<span class="nc" id="L1405">            Object resource = getResource(instance);</span>

<span class="nc bnc" id="L1407" title="All 2 branches missed.">            final String resourceClassName =</span>
                    (resource instanceof DynamicMBean) ?
<span class="nc" id="L1409">                        getClassName((DynamicMBean) resource) :</span>
<span class="nc" id="L1410">                        resource.getClass().getName();</span>

<span class="nc bnc" id="L1412" title="All 2 branches missed.">            if (resourceClassName.equals(className))</span>
<span class="nc" id="L1413">                return true;</span>
<span class="nc" id="L1414">            final ClassLoader cl = resource.getClass().getClassLoader();</span>

<span class="nc" id="L1416">            final Class&lt;?&gt; classNameClass = Class.forName(className, false, cl);</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">            if (classNameClass.isInstance(resource))</span>
<span class="nc" id="L1418">                return true;</span>

<span class="nc" id="L1420">            final Class&lt;?&gt; resourceClass = Class.forName(resourceClassName, false, cl);</span>
<span class="nc" id="L1421">            return classNameClass.isAssignableFrom(resourceClass);</span>
<span class="nc" id="L1422">        } catch (Exception x) {</span>
            /* Could be SecurityException or ClassNotFoundException */
<span class="nc bnc" id="L1424" title="All 2 branches missed.">            if (MBEANSERVER_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L1425">                MBEANSERVER_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L1426">                        DefaultMBeanServerInterceptor.class.getName(),</span>
                        &quot;isInstanceOf&quot;, &quot;Exception calling isInstanceOf&quot;, x);
            }
<span class="nc" id="L1429">            return false;</span>
        }

    }

    /**
     * &lt;p&gt;Return the {@link java.lang.ClassLoader} that was used for
     * loading the class of the named MBean.
     * @param mbeanName The ObjectName of the MBean.
     * @return The ClassLoader used for that MBean.
     * @exception InstanceNotFoundException if the named MBean is not found.
     */
    public ClassLoader getClassLoaderFor(ObjectName mbeanName)
        throws InstanceNotFoundException {

<span class="nc" id="L1444">        DynamicMBean instance = getMBean(mbeanName);</span>
<span class="nc" id="L1445">        checkMBeanPermission(instance, null, mbeanName, &quot;getClassLoaderFor&quot;);</span>
<span class="nc" id="L1446">        return getResource(instance).getClass().getClassLoader();</span>
    }

    /**
     * &lt;p&gt;Return the named {@link java.lang.ClassLoader}.
     * @param loaderName The ObjectName of the ClassLoader.
     * @return The named ClassLoader.
     * @exception InstanceNotFoundException if the named ClassLoader
     * is not found.
     */
    public ClassLoader getClassLoader(ObjectName loaderName)
            throws InstanceNotFoundException {

<span class="nc bnc" id="L1459" title="All 2 branches missed.">        if (loaderName == null) {</span>
<span class="nc" id="L1460">            checkMBeanPermission((String) null, null, null, &quot;getClassLoader&quot;);</span>
<span class="nc" id="L1461">            return server.getClass().getClassLoader();</span>
        }

<span class="nc" id="L1464">        DynamicMBean instance = getMBean(loaderName);</span>
<span class="nc" id="L1465">        checkMBeanPermission(instance, null, loaderName, &quot;getClassLoader&quot;);</span>

<span class="nc" id="L1467">        Object resource = getResource(instance);</span>

        /* Check if the given MBean is a ClassLoader */
<span class="nc bnc" id="L1470" title="All 2 branches missed.">        if (!(resource instanceof ClassLoader))</span>
<span class="nc" id="L1471">            throw new InstanceNotFoundException(loaderName.toString() +</span>
                                                &quot; is not a classloader&quot;);

<span class="nc" id="L1474">        return (ClassLoader) resource;</span>
    }

    /**
     * Sends an MBeanServerNotifications with the specified type for the
     * MBean with the specified ObjectName
     */
    private void sendNotification(String NotifType, ObjectName name) {

        // ------------------------------
        // ------------------------------

        // ---------------------
        // Create notification
        // ---------------------
<span class="nc" id="L1489">        MBeanServerNotification notif = new MBeanServerNotification(</span>
            NotifType,MBeanServerDelegate.DELEGATE_NAME,0,name);

<span class="nc bnc" id="L1492" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1493">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L1494">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;sendNotification&quot;, NotifType + &quot; &quot; + name);
        }

<span class="nc" id="L1498">        delegate.sendNotification(notif);</span>
<span class="nc" id="L1499">    }</span>

    /**
     * Applies the specified queries to the set of NamedObjects.
     */
    private Set&lt;ObjectName&gt;
        objectNamesFromFilteredNamedObjects(Set&lt;NamedObject&gt; list,
                                            QueryExp query) {
<span class="nc" id="L1507">        Set&lt;ObjectName&gt; result = new HashSet&lt;ObjectName&gt;();</span>
        // No query ...
<span class="nc bnc" id="L1509" title="All 2 branches missed.">        if (query == null) {</span>
<span class="nc bnc" id="L1510" title="All 2 branches missed.">            for (NamedObject no : list) {</span>
<span class="nc" id="L1511">                result.add(no.getName());</span>
<span class="nc" id="L1512">            }</span>
        } else {
            // Access the filter
<span class="nc" id="L1515">            final MBeanServer oldServer = QueryEval.getMBeanServer();</span>
<span class="nc" id="L1516">            query.setMBeanServer(server);</span>
            try {
<span class="nc bnc" id="L1518" title="All 2 branches missed.">                for (NamedObject no : list) {</span>
                    boolean res;
                    try {
<span class="nc" id="L1521">                        res = query.apply(no.getName());</span>
<span class="nc" id="L1522">                    } catch (Exception e) {</span>
<span class="nc" id="L1523">                        res = false;</span>
<span class="nc" id="L1524">                    }</span>
<span class="nc bnc" id="L1525" title="All 2 branches missed.">                    if (res) {</span>
<span class="nc" id="L1526">                        result.add(no.getName());</span>
                    }
<span class="nc" id="L1528">                }</span>
            } finally {
                /*
                 * query.setMBeanServer is probably
                 * QueryEval.setMBeanServer so put back the old
                 * value.  Since that method uses a ThreadLocal
                 * variable, this code is only needed for the
                 * unusual case where the user creates a custom
                 * QueryExp that calls a nested query on another
                 * MBeanServer.
                 */
<span class="nc" id="L1539">                query.setMBeanServer(oldServer);</span>
<span class="nc" id="L1540">            }</span>
        }
<span class="nc" id="L1542">        return result;</span>
    }

    /**
     * Applies the specified queries to the set of NamedObjects.
     */
    private Set&lt;ObjectInstance&gt;
        objectInstancesFromFilteredNamedObjects(Set&lt;NamedObject&gt; list,
                                                QueryExp query) {
<span class="nc" id="L1551">        Set&lt;ObjectInstance&gt; result = new HashSet&lt;ObjectInstance&gt;();</span>
        // No query ...
<span class="nc bnc" id="L1553" title="All 2 branches missed.">        if (query == null) {</span>
<span class="nc bnc" id="L1554" title="All 2 branches missed.">            for (NamedObject no : list) {</span>
<span class="nc" id="L1555">                final DynamicMBean obj = no.getObject();</span>
<span class="nc" id="L1556">                final String className = safeGetClassName(obj);</span>
<span class="nc" id="L1557">                result.add(new ObjectInstance(no.getName(), className));</span>
<span class="nc" id="L1558">            }</span>
        } else {
            // Access the filter
<span class="nc" id="L1561">            MBeanServer oldServer = QueryEval.getMBeanServer();</span>
<span class="nc" id="L1562">            query.setMBeanServer(server);</span>
            try {
<span class="nc bnc" id="L1564" title="All 2 branches missed.">                for (NamedObject no : list) {</span>
<span class="nc" id="L1565">                    final DynamicMBean obj = no.getObject();</span>
                    boolean res;
                    try {
<span class="nc" id="L1568">                        res = query.apply(no.getName());</span>
<span class="nc" id="L1569">                    } catch (Exception e) {</span>
<span class="nc" id="L1570">                        res = false;</span>
<span class="nc" id="L1571">                    }</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">                    if (res) {</span>
<span class="nc" id="L1573">                        String className = safeGetClassName(obj);</span>
<span class="nc" id="L1574">                        result.add(new ObjectInstance(no.getName(), className));</span>
                    }
<span class="nc" id="L1576">                }</span>
            } finally {
                /*
                 * query.setMBeanServer is probably
                 * QueryEval.setMBeanServer so put back the old
                 * value.  Since that method uses a ThreadLocal
                 * variable, this code is only needed for the
                 * unusual case where the user creates a custom
                 * QueryExp that calls a nested query on another
                 * MBeanServer.
                 */
<span class="nc" id="L1587">                query.setMBeanServer(oldServer);</span>
<span class="nc" id="L1588">            }</span>
        }
<span class="nc" id="L1590">        return result;</span>
    }

    private static String safeGetClassName(DynamicMBean mbean) {
        try {
<span class="nc" id="L1595">            return getClassName(mbean);</span>
<span class="nc" id="L1596">        } catch (Exception e) {</span>
<span class="nc bnc" id="L1597" title="All 2 branches missed.">            if (MBEANSERVER_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L1598">                MBEANSERVER_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L1599">                        DefaultMBeanServerInterceptor.class.getName(),</span>
                        &quot;safeGetClassName&quot;,
                        &quot;Exception getting MBean class name&quot;, e);
            }
<span class="nc" id="L1603">            return null;</span>
        }
    }

    /**
     * Applies the specified queries to the set of ObjectInstances.
     */
    private Set&lt;ObjectInstance&gt;
            filterListOfObjectInstances(Set&lt;ObjectInstance&gt; list,
                                        QueryExp query) {
        // Null query.
        //
<span class="nc bnc" id="L1615" title="All 2 branches missed.">        if (query == null) {</span>
<span class="nc" id="L1616">            return list;</span>
        } else {
<span class="nc" id="L1618">            Set&lt;ObjectInstance&gt; result = new HashSet&lt;ObjectInstance&gt;();</span>
            // Access the filter.
            //
<span class="nc bnc" id="L1621" title="All 2 branches missed.">            for (ObjectInstance oi : list) {</span>
<span class="nc" id="L1622">                boolean res = false;</span>
<span class="nc" id="L1623">                MBeanServer oldServer = QueryEval.getMBeanServer();</span>
<span class="nc" id="L1624">                query.setMBeanServer(server);</span>
                try {
<span class="nc" id="L1626">                    res = query.apply(oi.getObjectName());</span>
<span class="nc" id="L1627">                } catch (Exception e) {</span>
<span class="nc" id="L1628">                    res = false;</span>
                } finally {
                    /*
                     * query.setMBeanServer is probably
                     * QueryEval.setMBeanServer so put back the old
                     * value.  Since that method uses a ThreadLocal
                     * variable, this code is only needed for the
                     * unusual case where the user creates a custom
                     * QueryExp that calls a nested query on another
                     * MBeanServer.
                     */
<span class="nc" id="L1639">                    query.setMBeanServer(oldServer);</span>
<span class="nc" id="L1640">                }</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">                if (res) {</span>
<span class="nc" id="L1642">                    result.add(oi);</span>
                }
<span class="nc" id="L1644">            }</span>
<span class="nc" id="L1645">            return result;</span>
        }
    }

    /*
     * Get the existing wrapper for this listener, name, and mbean, if
     * there is one.  Otherwise, if &quot;create&quot; is true, create and
     * return one.  Otherwise, return null.
     *
     * We use a WeakHashMap so that if the only reference to a user
     * listener is in listenerWrappers, it can be garbage collected.
     * This requires a certain amount of care, because only the key in
     * a WeakHashMap is weak; the value is strong.  We need to recover
     * the existing wrapper object (not just an object that is equal
     * to it), so we would like listenerWrappers to map any
     * ListenerWrapper to the canonical ListenerWrapper for that
     * (listener,name,mbean) set.  But we do not want this canonical
     * wrapper to be referenced strongly.  Therefore we put it inside
     * a WeakReference and that is the value in the WeakHashMap.
     */
    private NotificationListener getListenerWrapper(NotificationListener l,
                                                    ObjectName name,
                                                    DynamicMBean mbean,
                                                    boolean create) {
<span class="nc" id="L1669">        Object resource = getResource(mbean);</span>
<span class="nc" id="L1670">        ListenerWrapper wrapper = new ListenerWrapper(l, name, resource);</span>
<span class="nc" id="L1671">        synchronized (listenerWrappers) {</span>
<span class="nc" id="L1672">            WeakReference&lt;ListenerWrapper&gt; ref = listenerWrappers.get(wrapper);</span>
<span class="nc bnc" id="L1673" title="All 2 branches missed.">            if (ref != null) {</span>
<span class="nc" id="L1674">                NotificationListener existing = ref.get();</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">                if (existing != null)</span>
<span class="nc" id="L1676">                    return existing;</span>
            }
<span class="nc bnc" id="L1678" title="All 2 branches missed.">            if (create) {</span>
<span class="nc" id="L1679">                ref = new WeakReference&lt;ListenerWrapper&gt;(wrapper);</span>
<span class="nc" id="L1680">                listenerWrappers.put(wrapper, ref);</span>
<span class="nc" id="L1681">                return wrapper;</span>
            } else
<span class="nc" id="L1683">                return null;</span>
<span class="nc" id="L1684">        }</span>
    }

    public Object instantiate(String className) throws ReflectionException,
                                                       MBeanException {
<span class="nc" id="L1689">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    public Object instantiate(String className, ObjectName loaderName) throws ReflectionException,
                                                                              MBeanException,
                                                                              InstanceNotFoundException {
<span class="nc" id="L1695">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    public Object instantiate(String className, Object[] params,
            String[] signature) throws ReflectionException, MBeanException {
<span class="nc" id="L1700">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    public Object instantiate(String className, ObjectName loaderName,
            Object[] params, String[] signature) throws ReflectionException,
                                                        MBeanException,
                                                        InstanceNotFoundException {
<span class="nc" id="L1707">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    public ObjectInputStream deserialize(ObjectName name, byte[] data) throws InstanceNotFoundException,
                                                                              OperationsException {
<span class="nc" id="L1712">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    public ObjectInputStream deserialize(String className, byte[] data) throws OperationsException,
                                                                               ReflectionException {
<span class="nc" id="L1717">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    public ObjectInputStream deserialize(String className, ObjectName loaderName,
            byte[] data) throws InstanceNotFoundException, OperationsException,
                                ReflectionException {
<span class="nc" id="L1723">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    public ClassLoaderRepository getClassLoaderRepository() {
<span class="nc" id="L1727">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    private static class ListenerWrapper implements NotificationListener {
        ListenerWrapper(NotificationListener l, ObjectName name,
<span class="nc" id="L1732">                        Object mbean) {</span>
<span class="nc" id="L1733">            this.listener = l;</span>
<span class="nc" id="L1734">            this.name = name;</span>
<span class="nc" id="L1735">            this.mbean = mbean;</span>
<span class="nc" id="L1736">        }</span>

        public void handleNotification(Notification notification,
                                       Object handback) {
<span class="nc bnc" id="L1740" title="All 2 branches missed.">            if (notification != null) {</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">                if (notification.getSource() == mbean)</span>
<span class="nc" id="L1742">                    notification.setSource(name);</span>
            }

            /*
             * Listeners are not supposed to throw exceptions.  If
             * this one does, we could remove it from the MBean.  It
             * might indicate that a connector has stopped working,
             * for instance, and there is no point in sending future
             * notifications over that connection.  However, this
             * seems rather drastic, so instead we propagate the
             * exception and let the broadcaster handle it.
             */
<span class="nc" id="L1754">            listener.handleNotification(notification, handback);</span>
<span class="nc" id="L1755">        }</span>

        @Override
        public boolean equals(Object o) {
<span class="nc bnc" id="L1759" title="All 2 branches missed.">            if (!(o instanceof ListenerWrapper))</span>
<span class="nc" id="L1760">                return false;</span>
<span class="nc" id="L1761">            ListenerWrapper w = (ListenerWrapper) o;</span>
<span class="nc bnc" id="L1762" title="All 4 branches missed.">            return (w.listener == listener &amp;&amp; w.mbean == mbean</span>
<span class="nc bnc" id="L1763" title="All 2 branches missed.">                    &amp;&amp; w.name.equals(name));</span>
            /*
             * We compare all three, in case the same MBean object
             * gets unregistered and then reregistered under a
             * different name, or the same name gets assigned to two
             * different MBean objects at different times.  We do the
             * comparisons in this order to avoid the slow
             * ObjectName.equals when possible.
             */
        }

        @Override
        public int hashCode() {
<span class="nc" id="L1776">            return (System.identityHashCode(listener) ^</span>
<span class="nc" id="L1777">                    System.identityHashCode(mbean));</span>
            /*
             * We do not include name.hashCode() in the hash because
             * computing it is slow and usually we will not have two
             * instances of ListenerWrapper with the same mbean but
             * different ObjectNames.  That can happen if the MBean is
             * unregistered from one name and reregistered with
             * another, and there is no garbage collection between; or
             * if the same object is registered under two names (which
             * is not recommended because MBeanRegistration will
             * break).  But even in these unusual cases the hash code
             * does not have to be unique.
             */
        }

        private NotificationListener listener;
        private ObjectName name;
        private Object mbean;
    }

    // SECURITY CHECKS
    //----------------

    private static String getClassName(DynamicMBean mbean) {
<span class="nc bnc" id="L1801" title="All 2 branches missed.">        if (mbean instanceof DynamicMBean2)</span>
<span class="nc" id="L1802">            return ((DynamicMBean2) mbean).getClassName();</span>
        else
<span class="nc" id="L1804">            return mbean.getMBeanInfo().getClassName();</span>
    }

    private static void checkMBeanPermission(DynamicMBean mbean,
                                             String member,
                                             ObjectName objectName,
                                             String actions) {
<span class="nc" id="L1811">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1812" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L1813">            checkMBeanPermission(safeGetClassName(mbean),</span>
                                 member,
                                 objectName,
                                 actions);
        }
<span class="nc" id="L1818">    }</span>

    private static void checkMBeanPermission(String classname,
                                             String member,
                                             ObjectName objectName,
                                             String actions) {
<span class="nc" id="L1824">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1825" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L1826">            Permission perm = new MBeanPermission(classname,</span>
                                                  member,
                                                  objectName,
                                                  actions);
<span class="nc" id="L1830">            sm.checkPermission(perm);</span>
        }
<span class="nc" id="L1832">    }</span>

    private static void checkMBeanTrustPermission(final Class&lt;?&gt; theClass)
        throws SecurityException {
<span class="nc" id="L1836">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1837" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L1838">            Permission perm = new MBeanTrustPermission(&quot;register&quot;);</span>
<span class="nc" id="L1839">            PrivilegedAction&lt;ProtectionDomain&gt; act =</span>
<span class="nc" id="L1840">                new PrivilegedAction&lt;ProtectionDomain&gt;() {</span>
                    public ProtectionDomain run() {
<span class="nc" id="L1842">                        return theClass.getProtectionDomain();</span>
                    }
                };
<span class="nc" id="L1845">            ProtectionDomain pd = AccessController.doPrivileged(act);</span>
<span class="nc" id="L1846">            AccessControlContext acc =</span>
                new AccessControlContext(new ProtectionDomain[] { pd });
<span class="nc" id="L1848">            sm.checkPermission(perm, acc);</span>
        }
<span class="nc" id="L1850">    }</span>

    // ------------------------------------------------------------------
    //
    // Dealing with registration of special MBeans in the repository.
    //
    // ------------------------------------------------------------------

    /**
     * A RegistrationContext that makes it possible to perform additional
     * post registration actions (or post unregistration actions) outside
     * of the repository lock, once postRegister (or postDeregister) has
     * been called.
     * The method {@code done()} will be called in registerMBean or
     * unregisterMBean, at the end.
     */
    private static interface ResourceContext extends RegistrationContext {
        public void done();
        /** An empty ResourceContext which does nothing **/
<span class="nc" id="L1869">        public static final ResourceContext NONE = new ResourceContext() {</span>
<span class="nc" id="L1870">            public void done() {}</span>
<span class="nc" id="L1871">            public void registering() {}</span>
<span class="nc" id="L1872">            public void unregistered() {}</span>
        };
    }

    /**
     * Adds a MBean in the repository,
     * sends MBeanServerNotification.REGISTRATION_NOTIFICATION,
     * returns ResourceContext for special resources such as ClassLoaders
     * or JMXNamespaces. For regular MBean this method returns
     * ResourceContext.NONE.
     * @return a ResourceContext for special resources such as ClassLoaders
     *         or JMXNamespaces.
     */
    private ResourceContext registerWithRepository(
            final Object resource,
            final DynamicMBean object,
            final ObjectName logicalName)
            throws InstanceAlreadyExistsException,
            MBeanRegistrationException {

        // Creates a registration context, if needed.
        //
<span class="nc" id="L1894">        final ResourceContext context =</span>
<span class="nc" id="L1895">                makeResourceContextFor(resource, logicalName);</span>


<span class="nc" id="L1898">        repository.addMBean(object, logicalName, context);</span>
        // May throw InstanceAlreadyExistsException

        // ---------------------
        // Send create event
        // ---------------------
<span class="nc bnc" id="L1904" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1905">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L1906">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;addObject&quot;, &quot;Send create notification of object &quot; +
<span class="nc" id="L1908">                    logicalName.getCanonicalName());</span>
        }

<span class="nc" id="L1911">        sendNotification(</span>
                MBeanServerNotification.REGISTRATION_NOTIFICATION,
                logicalName);

<span class="nc" id="L1915">        return context;</span>
    }

    /**
     * Removes a MBean in the repository,
     * sends MBeanServerNotification.UNREGISTRATION_NOTIFICATION,
     * returns ResourceContext for special resources such as ClassLoaders
     * or JMXNamespaces, or null. For regular MBean this method returns
     * ResourceContext.NONE.
     *
     * @return a ResourceContext for special resources such as ClassLoaders
     *         or JMXNamespaces.
     */
    private ResourceContext unregisterFromRepository(
            final Object resource,
            final DynamicMBean object,
            final ObjectName logicalName)
            throws InstanceNotFoundException {

        // Creates a registration context, if needed.
        //
<span class="nc" id="L1936">        final ResourceContext context =</span>
<span class="nc" id="L1937">                makeResourceContextFor(resource, logicalName);</span>


<span class="nc" id="L1940">        repository.remove(logicalName, context);</span>

        // ---------------------
        // Send deletion event
        // ---------------------
<span class="nc bnc" id="L1945" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1946">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L1947">                    DefaultMBeanServerInterceptor.class.getName(),</span>
                    &quot;unregisterMBean&quot;, &quot;Send delete notification of object &quot; +
<span class="nc" id="L1949">                    logicalName.getCanonicalName());</span>
        }

<span class="nc" id="L1952">        sendNotification(MBeanServerNotification.UNREGISTRATION_NOTIFICATION,</span>
                logicalName);
<span class="nc" id="L1954">        return context;</span>
    }


    /**
     * Registers a ClassLoader with the CLR.
     * This method is called by the ResourceContext from within the
     * repository lock.
     * @param loader       The ClassLoader.
     * @param logicalName  The ClassLoader MBean ObjectName.
     */
    private void addClassLoader(ClassLoader loader,
            final ObjectName logicalName) {
        /**
         * Called when the newly registered MBean is a ClassLoader
         * If so, tell the ClassLoaderRepository (CLR) about it.  We do
         * this even if the loader is a PrivateClassLoader.  In that
         * case, the CLR remembers the loader for use when it is
         * explicitly named (e.g. as the loader in createMBean) but
         * does not add it to the list that is consulted by
         * ClassLoaderRepository.loadClass.
         */
<span class="nc" id="L1976">        final ModifiableClassLoaderRepository clr = getInstantiatorCLR();</span>
<span class="nc bnc" id="L1977" title="All 2 branches missed.">        if (clr == null) {</span>
<span class="nc" id="L1978">            final RuntimeException wrapped =</span>
                    new IllegalArgumentException(
                    &quot;Dynamic addition of class loaders&quot; +
                    &quot; is not supported&quot;);
<span class="nc" id="L1982">            throw new RuntimeOperationsException(wrapped,</span>
                    &quot;Exception occurred trying to register&quot; +
                    &quot; the MBean as a class loader&quot;);
        }
<span class="nc" id="L1986">        clr.addClassLoader(logicalName, loader);</span>
<span class="nc" id="L1987">    }</span>

    /**
     * Unregisters a ClassLoader from the CLR.
     * This method is called by the ResourceContext from within the
     * repository lock.
     * @param loader       The ClassLoader.
     * @param logicalName  The ClassLoader MBean ObjectName.
     */
    private void removeClassLoader(ClassLoader loader,
            final ObjectName logicalName) {
        /**
         * Removes the  MBean from the default loader repository.
         */
<span class="nc bnc" id="L2001" title="All 2 branches missed.">        if (loader != server.getClass().getClassLoader()) {</span>
<span class="nc" id="L2002">            final ModifiableClassLoaderRepository clr = getInstantiatorCLR();</span>
<span class="nc bnc" id="L2003" title="All 2 branches missed.">            if (clr != null) {</span>
<span class="nc" id="L2004">                clr.removeClassLoader(logicalName);</span>
            }
        }
<span class="nc" id="L2007">    }</span>


    /**
     * Creates a ResourceContext for a ClassLoader MBean.
     * The resource context makes it possible to add the ClassLoader to
     * (ResourceContext.registering) or resp. remove the ClassLoader from
     * (ResourceContext.unregistered) the CLR
     * when the associated MBean is added to or resp. removed from the
     * repository.
     *
     * @param loader       The ClassLoader MBean being registered or
     *                     unregistered.
     * @param logicalName  The name of the ClassLoader MBean.
     * @return a ResourceContext that takes in charge the addition or removal
     *         of the loader to or from the CLR.
     */
    private ResourceContext createClassLoaderContext(
            final ClassLoader loader,
            final ObjectName logicalName) {
<span class="nc" id="L2027">        return new ResourceContext() {</span>

            public void registering() {
<span class="nc" id="L2030">                addClassLoader(loader, logicalName);</span>
<span class="nc" id="L2031">            }</span>

            public void unregistered() {
<span class="nc" id="L2034">                removeClassLoader(loader, logicalName);</span>
<span class="nc" id="L2035">            }</span>

            public void done() {
<span class="nc" id="L2038">            }</span>
        };
    }

    /**
     * Creates a ResourceContext for the given resource.
     * If the resource does not need a ResourceContext, returns
     * ResourceContext.NONE.
     * At this time, only ClassLoaders need a ResourceContext.
     *
     * @param resource     The resource being registered or unregistered.
     * @param logicalName  The name of the associated MBean.
     * @return
     */
    private ResourceContext makeResourceContextFor(Object resource,
            ObjectName logicalName) {
<span class="nc bnc" id="L2054" title="All 2 branches missed.">        if (resource instanceof ClassLoader) {</span>
<span class="nc" id="L2055">            return createClassLoaderContext((ClassLoader) resource,</span>
                    logicalName);
        }
<span class="nc" id="L2058">        return ResourceContext.NONE;</span>
    }

    private ModifiableClassLoaderRepository getInstantiatorCLR() {
<span class="nc" id="L2062">        return AccessController.doPrivileged(new PrivilegedAction&lt;ModifiableClassLoaderRepository&gt;() {</span>
            @Override
            public ModifiableClassLoaderRepository run() {
<span class="nc bnc" id="L2065" title="All 2 branches missed.">                return instantiator != null ? instantiator.getClassLoaderRepository() : null;</span>
            }
        });
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>