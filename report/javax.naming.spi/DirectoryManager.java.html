<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DirectoryManager.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.naming.spi</a> &gt; <span class="el_source">DirectoryManager.java</span></div><h1>DirectoryManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.naming.spi;

import java.util.Hashtable;

import javax.naming.Context;
import javax.naming.Name;
import javax.naming.Reference;
import javax.naming.Referenceable;
import javax.naming.NamingException;
import javax.naming.CannotProceedException;
import javax.naming.directory.DirContext;
import javax.naming.directory.Attributes;

import com.sun.naming.internal.ResourceManager;
import com.sun.naming.internal.FactoryEnumeration;


/**
  * This class contains methods for supporting &lt;tt&gt;DirContext&lt;/tt&gt;
  * implementations.
  *&lt;p&gt;
  * This class is an extension of &lt;tt&gt;NamingManager&lt;/tt&gt;.  It contains methods
  * for use by service providers for accessing object factories and
  * state factories, and for getting continuation contexts for
  * supporting federation.
  *&lt;p&gt;
  * &lt;tt&gt;DirectoryManager&lt;/tt&gt; is safe for concurrent access by multiple threads.
  *&lt;p&gt;
  * Except as otherwise noted,
  * a &lt;tt&gt;Name&lt;/tt&gt;, &lt;tt&gt;Attributes&lt;/tt&gt;, or environment parameter
  * passed to any method is owned by the caller.
  * The implementation will not modify the object or keep a reference
  * to it, although it may keep a reference to a clone or copy.
  *
  * @author Rosanna Lee
  * @author Scott Seligman
  *
  * @see DirObjectFactory
  * @see DirStateFactory
  * @since 1.3
  */

public class DirectoryManager extends NamingManager {

    /*
     * Disallow anyone from creating one of these.
     */
<span class="nc" id="L73">    DirectoryManager() {}</span>

    /**
      * Creates a context in which to continue a &lt;tt&gt;DirContext&lt;/tt&gt; operation.
      * Operates just like &lt;tt&gt;NamingManager.getContinuationContext()&lt;/tt&gt;,
      * only the continuation context returned is a &lt;tt&gt;DirContext&lt;/tt&gt;.
      *
      * @param cpe
      *         The non-null exception that triggered this continuation.
      * @return A non-null &lt;tt&gt;DirContext&lt;/tt&gt; object for continuing the operation.
      * @exception NamingException If a naming exception occurred.
      *
      * @see NamingManager#getContinuationContext(CannotProceedException)
      */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static DirContext getContinuationDirContext(
            CannotProceedException cpe) throws NamingException {

<span class="fc" id="L91">        Hashtable&lt;Object,Object&gt; env = (Hashtable&lt;Object,Object&gt;)cpe.getEnvironment();</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if (env == null) {</span>
<span class="nc" id="L93">            env = new Hashtable&lt;&gt;(7);</span>
        } else {
            // Make a (shallow) copy of the environment.
<span class="fc" id="L96">            env = (Hashtable&lt;Object,Object&gt;) env.clone();</span>
        }
<span class="fc" id="L98">        env.put(CPE, cpe);</span>

<span class="fc" id="L100">        return (new ContinuationDirContext(cpe, env));</span>
    }

    /**
      * Creates an instance of an object for the specified object,
      * attributes, and environment.
      * &lt;p&gt;
      * This method is the same as &lt;tt&gt;NamingManager.getObjectInstance&lt;/tt&gt;
      * except for the following differences:
      *&lt;ul&gt;
      *&lt;li&gt;
      * It accepts an &lt;tt&gt;Attributes&lt;/tt&gt; parameter that contains attributes
      * associated with the object. The &lt;tt&gt;DirObjectFactory&lt;/tt&gt; might use these
      * attributes to save having to look them up from the directory.
      *&lt;li&gt;
      * The object factories tried must implement either
      * &lt;tt&gt;ObjectFactory&lt;/tt&gt; or &lt;tt&gt;DirObjectFactory&lt;/tt&gt;.
      * If it implements &lt;tt&gt;DirObjectFactory&lt;/tt&gt;,
      * &lt;tt&gt;DirObjectFactory.getObjectInstance()&lt;/tt&gt; is used, otherwise,
      * &lt;tt&gt;ObjectFactory.getObjectInstance()&lt;/tt&gt; is used.
      *&lt;/ul&gt;
      * Service providers that implement the &lt;tt&gt;DirContext&lt;/tt&gt; interface
      * should use this method, not &lt;tt&gt;NamingManager.getObjectInstance()&lt;/tt&gt;.
      *&lt;p&gt;
      *
      * @param refInfo The possibly null object for which to create an object.
      * @param name The name of this object relative to &lt;code&gt;nameCtx&lt;/code&gt;.
      *         Specifying a name is optional; if it is
      *         omitted, &lt;code&gt;name&lt;/code&gt; should be null.
      * @param nameCtx The context relative to which the &lt;code&gt;name&lt;/code&gt;
      *         parameter is specified.  If null, &lt;code&gt;name&lt;/code&gt; is
      *         relative to the default initial context.
      * @param environment The possibly null environment to
      *         be used in the creation of the object factory and the object.
      * @param attrs The possibly null attributes associated with refInfo.
      *         This might not be the complete set of attributes for refInfo;
      *         you might be able to read more attributes from the directory.
      * @return An object created using &lt;code&gt;refInfo&lt;/code&gt; and &lt;tt&gt;attrs&lt;/tt&gt;; or
      *         &lt;code&gt;refInfo&lt;/code&gt; if an object cannot be created by
      *         a factory.
      * @exception NamingException If a naming exception was encountered
      *         while attempting to get a URL context, or if one of the
      *         factories accessed throws a NamingException.
      * @exception Exception If one of the factories accessed throws an
      *         exception, or if an error was encountered while loading
      *         and instantiating the factory and object classes.
      *         A factory should only throw an exception if it does not want
      *         other factories to be used in an attempt to create an object.
      *         See &lt;tt&gt;DirObjectFactory.getObjectInstance()&lt;/tt&gt;.
      * @see NamingManager#getURLContext
      * @see DirObjectFactory
      * @see DirObjectFactory#getObjectInstance
      * @since 1.3
      */
    public static Object
        getObjectInstance(Object refInfo, Name name, Context nameCtx,
                          Hashtable&lt;?,?&gt; environment, Attributes attrs)
        throws Exception {

            ObjectFactory factory;

<span class="nc" id="L161">            ObjectFactoryBuilder builder = getObjectFactoryBuilder();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (builder != null) {</span>
                // builder must return non-null factory
<span class="nc" id="L164">                factory = builder.createObjectFactory(refInfo, environment);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                if (factory instanceof DirObjectFactory) {</span>
<span class="nc" id="L166">                    return ((DirObjectFactory)factory).getObjectInstance(</span>
                        refInfo, name, nameCtx, environment, attrs);
                } else {
<span class="nc" id="L169">                    return factory.getObjectInstance(refInfo, name, nameCtx,</span>
                        environment);
                }
            }

            // use reference if possible
<span class="nc" id="L175">            Reference ref = null;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">            if (refInfo instanceof Reference) {</span>
<span class="nc" id="L177">                ref = (Reference) refInfo;</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            } else if (refInfo instanceof Referenceable) {</span>
<span class="nc" id="L179">                ref = ((Referenceable)(refInfo)).getReference();</span>
            }

            Object answer;

<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (ref != null) {</span>
<span class="nc" id="L185">                String f = ref.getFactoryClassName();</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                if (f != null) {</span>
                    // if reference identifies a factory, use exclusively

<span class="nc" id="L189">                    factory = getObjectFactoryFromReference(ref, f);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                    if (factory instanceof DirObjectFactory) {</span>
<span class="nc" id="L191">                        return ((DirObjectFactory)factory).getObjectInstance(</span>
                            ref, name, nameCtx, environment, attrs);
<span class="nc bnc" id="L193" title="All 2 branches missed.">                    } else if (factory != null) {</span>
<span class="nc" id="L194">                        return factory.getObjectInstance(ref, name, nameCtx,</span>
                                                         environment);
                    }
                    // No factory found, so return original refInfo.
                    // Will reach this point if factory class is not in
                    // class path and reference does not contain a URL for it
<span class="nc" id="L200">                    return refInfo;</span>

                } else {
                    // if reference has no factory, check for addresses
                    // containing URLs
                    // ignore name &amp; attrs params; not used in URL factory

<span class="nc" id="L207">                    answer = processURLAddrs(ref, name, nameCtx, environment);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">                    if (answer != null) {</span>
<span class="nc" id="L209">                        return answer;</span>
                    }
                }
            }

            // try using any specified factories
<span class="nc" id="L215">            answer = createObjectFromFactories(refInfo, name, nameCtx,</span>
                                               environment, attrs);
<span class="nc bnc" id="L217" title="All 2 branches missed.">            return (answer != null) ? answer : refInfo;</span>
    }

    private static Object createObjectFromFactories(Object obj, Name name,
            Context nameCtx, Hashtable&lt;?,?&gt; environment, Attributes attrs)
        throws Exception {

<span class="nc" id="L224">        FactoryEnumeration factories = ResourceManager.getFactories(</span>
            Context.OBJECT_FACTORIES, environment, nameCtx);

<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (factories == null)</span>
<span class="nc" id="L228">            return null;</span>

        ObjectFactory factory;
<span class="nc" id="L231">        Object answer = null;</span>
        // Try each factory until one succeeds
<span class="nc bnc" id="L233" title="All 4 branches missed.">        while (answer == null &amp;&amp; factories.hasMore()) {</span>
<span class="nc" id="L234">            factory = (ObjectFactory)factories.next();</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (factory instanceof DirObjectFactory) {</span>
<span class="nc" id="L236">                answer = ((DirObjectFactory)factory).</span>
<span class="nc" id="L237">                    getObjectInstance(obj, name, nameCtx, environment, attrs);</span>
            } else {
<span class="nc" id="L239">                answer =</span>
<span class="nc" id="L240">                    factory.getObjectInstance(obj, name, nameCtx, environment);</span>
            }
        }
<span class="nc" id="L243">        return answer;</span>
    }

    /**
      * Retrieves the state of an object for binding when given the original
      * object and its attributes.
      * &lt;p&gt;
      * This method is like &lt;tt&gt;NamingManager.getStateToBind&lt;/tt&gt; except
      * for the following differences:
      *&lt;ul&gt;
      *&lt;li&gt;It accepts an &lt;tt&gt;Attributes&lt;/tt&gt; parameter containing attributes
      *    that were passed to the &lt;tt&gt;DirContext.bind()&lt;/tt&gt; method.
      *&lt;li&gt;It returns a non-null &lt;tt&gt;DirStateFactory.Result&lt;/tt&gt; instance
      *    containing the object to be bound, and the attributes to
      *    accompany the binding. Either the object or the attributes may be null.
      *&lt;li&gt;
      * The state factories tried must each implement either
      * &lt;tt&gt;StateFactory&lt;/tt&gt; or &lt;tt&gt;DirStateFactory&lt;/tt&gt;.
      * If it implements &lt;tt&gt;DirStateFactory&lt;/tt&gt;, then
      * &lt;tt&gt;DirStateFactory.getStateToBind()&lt;/tt&gt; is called; otherwise,
      * &lt;tt&gt;StateFactory.getStateToBind()&lt;/tt&gt; is called.
      *&lt;/ul&gt;
      *
      * Service providers that implement the &lt;tt&gt;DirContext&lt;/tt&gt; interface
      * should use this method, not &lt;tt&gt;NamingManager.getStateToBind()&lt;/tt&gt;.
      *&lt;p&gt;
      * See NamingManager.getStateToBind() for a description of how
      * the list of state factories to be tried is determined.
      *&lt;p&gt;
      * The object returned by this method is owned by the caller.
      * The implementation will not subsequently modify it.
      * It will contain either a new &lt;tt&gt;Attributes&lt;/tt&gt; object that is
      * likewise owned by the caller, or a reference to the original
      * &lt;tt&gt;attrs&lt;/tt&gt; parameter.
      *
      * @param obj The non-null object for which to get state to bind.
      * @param name The name of this object relative to &lt;code&gt;nameCtx&lt;/code&gt;,
      *         or null if no name is specified.
      * @param nameCtx The context relative to which the &lt;code&gt;name&lt;/code&gt;
      *         parameter is specified, or null if &lt;code&gt;name&lt;/code&gt; is
      *         relative to the default initial context.
      * @param environment The possibly null environment to
      *         be used in the creation of the state factory and
      *         the object's state.
      * @param attrs The possibly null Attributes that is to be bound with the
      *         object.
      * @return A non-null DirStateFactory.Result containing
      *  the object and attributes to be bound.
      *  If no state factory returns a non-null answer, the result will contain
      *  the object (&lt;tt&gt;obj&lt;/tt&gt;) itself with the original attributes.
      * @exception NamingException If a naming exception was encountered
      *         while using the factories.
      *         A factory should only throw an exception if it does not want
      *         other factories to be used in an attempt to create an object.
      *         See &lt;tt&gt;DirStateFactory.getStateToBind()&lt;/tt&gt;.
      * @see DirStateFactory
      * @see DirStateFactory#getStateToBind
      * @see NamingManager#getStateToBind
      * @since 1.3
      */
    public static DirStateFactory.Result
        getStateToBind(Object obj, Name name, Context nameCtx,
                       Hashtable&lt;?,?&gt; environment, Attributes attrs)
        throws NamingException {

        // Get list of state factories
<span class="nc" id="L309">        FactoryEnumeration factories = ResourceManager.getFactories(</span>
            Context.STATE_FACTORIES, environment, nameCtx);

<span class="nc bnc" id="L312" title="All 2 branches missed.">        if (factories == null) {</span>
            // no factories to try; just return originals
<span class="nc" id="L314">            return new DirStateFactory.Result(obj, attrs);</span>
        }

        // Try each factory until one succeeds
        StateFactory factory;
        Object objanswer;
<span class="nc" id="L320">        DirStateFactory.Result answer = null;</span>
<span class="nc bnc" id="L321" title="All 4 branches missed.">        while (answer == null &amp;&amp; factories.hasMore()) {</span>
<span class="nc" id="L322">            factory = (StateFactory)factories.next();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (factory instanceof DirStateFactory) {</span>
<span class="nc" id="L324">                answer = ((DirStateFactory)factory).</span>
<span class="nc" id="L325">                    getStateToBind(obj, name, nameCtx, environment, attrs);</span>
            } else {
<span class="nc" id="L327">                objanswer =</span>
<span class="nc" id="L328">                    factory.getStateToBind(obj, name, nameCtx, environment);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">                if (objanswer != null) {</span>
<span class="nc" id="L330">                    answer = new DirStateFactory.Result(objanswer, attrs);</span>
                }
            }
        }

<span class="nc bnc" id="L335" title="All 2 branches missed.">        return (answer != null) ? answer :</span>
            new DirStateFactory.Result(obj, attrs); // nothing new
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>