<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImageInputStreamImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.imageio.stream</a> &gt; <span class="el_source">ImageInputStreamImpl.java</span></div><h1>ImageInputStreamImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio.stream;

import java.io.DataInputStream;
import java.io.EOFException;
import java.io.IOException;
import java.nio.ByteOrder;
import java.util.Stack;
import javax.imageio.IIOException;

/**
 * An abstract class implementing the &lt;code&gt;ImageInputStream&lt;/code&gt; interface.
 * This class is designed to reduce the number of methods that must
 * be implemented by subclasses.
 *
 * &lt;p&gt; In particular, this class handles most or all of the details of
 * byte order interpretation, buffering, mark/reset, discarding,
 * closing, and disposing.
 */
public abstract class ImageInputStreamImpl implements ImageInputStream {

<span class="fc" id="L46">    private Stack markByteStack = new Stack();</span>

<span class="fc" id="L48">    private Stack markBitStack = new Stack();</span>

<span class="fc" id="L50">    private boolean isClosed = false;</span>

    // Length of the buffer used for readFully(type[], int, int)
    private static final int BYTE_BUF_LENGTH = 8192;

    /**
     * Byte buffer used for readFully(type[], int, int).  Note that this
     * array is also used for bulk reads in readShort(), readInt(), etc, so
     * it should be large enough to hold a primitive value (i.e. &gt;= 8 bytes).
     * Also note that this array is package protected, so that it can be
     * used by ImageOutputStreamImpl in a similar manner.
     */
<span class="fc" id="L62">    byte[] byteBuf = new byte[BYTE_BUF_LENGTH];</span>

    /**
     * The byte order of the stream as an instance of the enumeration
     * class &lt;code&gt;java.nio.ByteOrder&lt;/code&gt;, where
     * &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt; indicates network byte order
     * and &lt;code&gt;ByteOrder.LITTLE_ENDIAN&lt;/code&gt; indicates the reverse
     * order.  By default, the value is
     * &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt;.
     */
<span class="fc" id="L72">    protected ByteOrder byteOrder = ByteOrder.BIG_ENDIAN;</span>

    /**
     * The current read position within the stream.  Subclasses are
     * responsible for keeping this value current from any method they
     * override that alters the read position.
     */
    protected long streamPos;

    /**
     * The current bit offset within the stream.  Subclasses are
     * responsible for keeping this value current from any method they
     * override that alters the bit offset.
     */
    protected int bitOffset;

    /**
     * The position prior to which data may be discarded.  Seeking
     * to a smaller position is not allowed.  &lt;code&gt;flushedPos&lt;/code&gt;
     * will always be {@literal &gt;= 0}.
     */
<span class="fc" id="L93">    protected long flushedPos = 0;</span>

    /**
     * Constructs an &lt;code&gt;ImageInputStreamImpl&lt;/code&gt;.
     */
<span class="fc" id="L98">    public ImageInputStreamImpl() {</span>
<span class="fc" id="L99">    }</span>

    /**
     * Throws an &lt;code&gt;IOException&lt;/code&gt; if the stream has been closed.
     * Subclasses may call this method from any of their methods that
     * require the stream not to be closed.
     *
     * @exception IOException if the stream is closed.
     */
    protected final void checkClosed() throws IOException {
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if (isClosed) {</span>
<span class="nc" id="L110">            throw new IOException(&quot;closed&quot;);</span>
        }
<span class="fc" id="L112">    }</span>

    public void setByteOrder(ByteOrder byteOrder) {
<span class="nc" id="L115">        this.byteOrder = byteOrder;</span>
<span class="nc" id="L116">    }</span>

    public ByteOrder getByteOrder() {
<span class="nc" id="L119">        return byteOrder;</span>
    }

    /**
     * Reads a single byte from the stream and returns it as an
     * &lt;code&gt;int&lt;/code&gt; between 0 and 255.  If EOF is reached,
     * &lt;code&gt;-1&lt;/code&gt; is returned.
     *
     * &lt;p&gt; Subclasses must provide an implementation for this method.
     * The subclass implementation should update the stream position
     * before exiting.
     *
     * &lt;p&gt; The bit offset within the stream must be reset to zero before
     * the read occurs.
     *
     * @return the value of the next byte in the stream, or &lt;code&gt;-1&lt;/code&gt;
     * if EOF is reached.
     *
     * @exception IOException if the stream has been closed.
     */
    public abstract int read() throws IOException;

    /**
     * A convenience method that calls &lt;code&gt;read(b, 0, b.length)&lt;/code&gt;.
     *
     * &lt;p&gt; The bit offset within the stream is reset to zero before
     * the read occurs.
     *
     * @return the number of bytes actually read, or &lt;code&gt;-1&lt;/code&gt;
     * to indicate EOF.
     *
     * @exception NullPointerException if &lt;code&gt;b&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    public int read(byte[] b) throws IOException {
<span class="nc" id="L155">        return read(b, 0, b.length);</span>
    }

    /**
     * Reads up to &lt;code&gt;len&lt;/code&gt; bytes from the stream, and stores
     * them into &lt;code&gt;b&lt;/code&gt; starting at index &lt;code&gt;off&lt;/code&gt;.
     * If no bytes can be read because the end of the stream has been
     * reached, &lt;code&gt;-1&lt;/code&gt; is returned.
     *
     * &lt;p&gt; The bit offset within the stream must be reset to zero before
     * the read occurs.
     *
     * &lt;p&gt; Subclasses must provide an implementation for this method.
     * The subclass implementation should update the stream position
     * before exiting.
     *
     * @param b an array of bytes to be written to.
     * @param off the starting position within &lt;code&gt;b&lt;/code&gt; to write to.
     * @param len the maximum number of bytes to read.
     *
     * @return the number of bytes actually read, or &lt;code&gt;-1&lt;/code&gt;
     * to indicate EOF.
     *
     * @exception IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is
     * negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off +
     * len&lt;/code&gt; is greater than &lt;code&gt;b.length&lt;/code&gt;.
     * @exception NullPointerException if &lt;code&gt;b&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an I/O error occurs.
     */
    public abstract int read(byte[] b, int off, int len) throws IOException;

    public void readBytes(IIOByteBuffer buf, int len) throws IOException {
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (len &lt; 0) {</span>
<span class="nc" id="L189">            throw new IndexOutOfBoundsException(&quot;len &lt; 0!&quot;);</span>
        }
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (buf == null) {</span>
<span class="nc" id="L192">            throw new NullPointerException(&quot;buf == null!&quot;);</span>
        }

<span class="nc" id="L195">        byte[] data = new byte[len];</span>
<span class="nc" id="L196">        len = read(data, 0, len);</span>

<span class="nc" id="L198">        buf.setData(data);</span>
<span class="nc" id="L199">        buf.setOffset(0);</span>
<span class="nc" id="L200">        buf.setLength(len);</span>
<span class="nc" id="L201">    }</span>

    public boolean readBoolean() throws IOException {
<span class="nc" id="L204">        int ch = this.read();</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (ch &lt; 0) {</span>
<span class="nc" id="L206">            throw new EOFException();</span>
        }
<span class="nc bnc" id="L208" title="All 2 branches missed.">        return (ch != 0);</span>
    }

    public byte readByte() throws IOException {
<span class="fc" id="L212">        int ch = this.read();</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (ch &lt; 0) {</span>
<span class="fc" id="L214">            throw new EOFException();</span>
        }
<span class="nc" id="L216">        return (byte)ch;</span>
    }

    public int readUnsignedByte() throws IOException {
<span class="nc" id="L220">        int ch = this.read();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (ch &lt; 0) {</span>
<span class="nc" id="L222">            throw new EOFException();</span>
        }
<span class="nc" id="L224">        return ch;</span>
    }

    public short readShort() throws IOException {
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (read(byteBuf, 0, 2) &lt; 0) {</span>
<span class="nc" id="L229">            throw new EOFException();</span>
        }

<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (byteOrder == ByteOrder.BIG_ENDIAN) {</span>
<span class="nc" id="L233">            return (short)</span>
                (((byteBuf[0] &amp; 0xff) &lt;&lt; 8) | ((byteBuf[1] &amp; 0xff) &lt;&lt; 0));
        } else {
<span class="nc" id="L236">            return (short)</span>
                (((byteBuf[1] &amp; 0xff) &lt;&lt; 8) | ((byteBuf[0] &amp; 0xff) &lt;&lt; 0));
        }
    }

    public int readUnsignedShort() throws IOException {
<span class="nc" id="L242">        return ((int)readShort()) &amp; 0xffff;</span>
    }

    public char readChar() throws IOException {
<span class="nc" id="L246">        return (char)readShort();</span>
    }

    public int readInt() throws IOException {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (read(byteBuf, 0, 4) &lt; 0) {</span>
<span class="nc" id="L251">            throw new EOFException();</span>
        }

<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (byteOrder == ByteOrder.BIG_ENDIAN) {</span>
<span class="nc" id="L255">            return</span>
                (((byteBuf[0] &amp; 0xff) &lt;&lt; 24) | ((byteBuf[1] &amp; 0xff) &lt;&lt; 16) |
                 ((byteBuf[2] &amp; 0xff) &lt;&lt;  8) | ((byteBuf[3] &amp; 0xff) &lt;&lt;  0));
        } else {
<span class="nc" id="L259">            return</span>
                (((byteBuf[3] &amp; 0xff) &lt;&lt; 24) | ((byteBuf[2] &amp; 0xff) &lt;&lt; 16) |
                 ((byteBuf[1] &amp; 0xff) &lt;&lt;  8) | ((byteBuf[0] &amp; 0xff) &lt;&lt;  0));
        }
    }

    public long readUnsignedInt() throws IOException {
<span class="nc" id="L266">        return ((long)readInt()) &amp; 0xffffffffL;</span>
    }

    public long readLong() throws IOException {
        // REMIND: Once 6277756 is fixed, we should do a bulk read of all 8
        // bytes here as we do in readShort() and readInt() for even better
        // performance (see 6347575 for details).
<span class="nc" id="L273">        int i1 = readInt();</span>
<span class="nc" id="L274">        int i2 = readInt();</span>

<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (byteOrder == ByteOrder.BIG_ENDIAN) {</span>
<span class="nc" id="L277">            return ((long)i1 &lt;&lt; 32) + (i2 &amp; 0xFFFFFFFFL);</span>
        } else {
<span class="nc" id="L279">            return ((long)i2 &lt;&lt; 32) + (i1 &amp; 0xFFFFFFFFL);</span>
        }
    }

    public float readFloat() throws IOException {
<span class="nc" id="L284">        return Float.intBitsToFloat(readInt());</span>
    }

    public double readDouble() throws IOException {
<span class="nc" id="L288">        return Double.longBitsToDouble(readLong());</span>
    }

    public String readLine() throws IOException {
<span class="nc" id="L292">        StringBuffer input = new StringBuffer();</span>
<span class="nc" id="L293">        int c = -1;</span>
<span class="nc" id="L294">        boolean eol = false;</span>

<span class="nc bnc" id="L296" title="All 2 branches missed.">        while (!eol) {</span>
<span class="nc bnc" id="L297" title="All 3 branches missed.">            switch (c = read()) {</span>
            case -1:
            case '\n':
<span class="nc" id="L300">                eol = true;</span>
<span class="nc" id="L301">                break;</span>
            case '\r':
<span class="nc" id="L303">                eol = true;</span>
<span class="nc" id="L304">                long cur = getStreamPosition();</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                if ((read()) != '\n') {</span>
<span class="nc" id="L306">                    seek(cur);</span>
                }
                break;
            default:
<span class="nc" id="L310">                input.append((char)c);</span>
<span class="nc" id="L311">                break;</span>
            }
        }

<span class="nc bnc" id="L315" title="All 4 branches missed.">        if ((c == -1) &amp;&amp; (input.length() == 0)) {</span>
<span class="nc" id="L316">            return null;</span>
        }
<span class="nc" id="L318">        return input.toString();</span>
    }

    public String readUTF() throws IOException {
<span class="nc" id="L322">        this.bitOffset = 0;</span>

        // Fix 4494369: method ImageInputStreamImpl.readUTF()
        // does not work as specified (it should always assume
        // network byte order).
<span class="nc" id="L327">        ByteOrder oldByteOrder = getByteOrder();</span>
<span class="nc" id="L328">        setByteOrder(ByteOrder.BIG_ENDIAN);</span>

        String ret;
        try {
<span class="nc" id="L332">            ret = DataInputStream.readUTF(this);</span>
<span class="nc" id="L333">        } catch (IOException e) {</span>
            // Restore the old byte order even if an exception occurs
<span class="nc" id="L335">            setByteOrder(oldByteOrder);</span>
<span class="nc" id="L336">            throw e;</span>
<span class="nc" id="L337">        }</span>

<span class="nc" id="L339">        setByteOrder(oldByteOrder);</span>
<span class="nc" id="L340">        return ret;</span>
    }

    public void readFully(byte[] b, int off, int len) throws IOException {
        // Fix 4430357 - if off + len &lt; 0, overflow occurred
<span class="pc bpc" id="L345" title="4 of 8 branches missed.">        if (off &lt; 0 || len &lt; 0 || off + len &gt; b.length || off + len &lt; 0) {</span>
<span class="nc" id="L346">            throw new IndexOutOfBoundsException</span>
                (&quot;off &lt; 0 || len &lt; 0 || off + len &gt; b.length!&quot;);
        }

<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        while (len &gt; 0) {</span>
<span class="fc" id="L351">            int nbytes = read(b, off, len);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            if (nbytes == -1) {</span>
<span class="fc" id="L353">                throw new EOFException();</span>
            }
<span class="fc" id="L355">            off += nbytes;</span>
<span class="fc" id="L356">            len -= nbytes;</span>
<span class="fc" id="L357">        }</span>
<span class="nc" id="L358">    }</span>

    public void readFully(byte[] b) throws IOException {
<span class="nc" id="L361">        readFully(b, 0, b.length);</span>
<span class="nc" id="L362">    }</span>

    public void readFully(short[] s, int off, int len) throws IOException {
        // Fix 4430357 - if off + len &lt; 0, overflow occurred
<span class="nc bnc" id="L366" title="All 8 branches missed.">        if (off &lt; 0 || len &lt; 0 || off + len &gt; s.length || off + len &lt; 0) {</span>
<span class="nc" id="L367">            throw new IndexOutOfBoundsException</span>
                (&quot;off &lt; 0 || len &lt; 0 || off + len &gt; s.length!&quot;);
        }

<span class="nc bnc" id="L371" title="All 2 branches missed.">        while (len &gt; 0) {</span>
<span class="nc" id="L372">            int nelts = Math.min(len, byteBuf.length/2);</span>
<span class="nc" id="L373">            readFully(byteBuf, 0, nelts*2);</span>
<span class="nc" id="L374">            toShorts(byteBuf, s, off, nelts);</span>
<span class="nc" id="L375">            off += nelts;</span>
<span class="nc" id="L376">            len -= nelts;</span>
<span class="nc" id="L377">        }</span>
<span class="nc" id="L378">    }</span>

    public void readFully(char[] c, int off, int len) throws IOException {
        // Fix 4430357 - if off + len &lt; 0, overflow occurred
<span class="nc bnc" id="L382" title="All 8 branches missed.">        if (off &lt; 0 || len &lt; 0 || off + len &gt; c.length || off + len &lt; 0) {</span>
<span class="nc" id="L383">            throw new IndexOutOfBoundsException</span>
                (&quot;off &lt; 0 || len &lt; 0 || off + len &gt; c.length!&quot;);
        }

<span class="nc bnc" id="L387" title="All 2 branches missed.">        while (len &gt; 0) {</span>
<span class="nc" id="L388">            int nelts = Math.min(len, byteBuf.length/2);</span>
<span class="nc" id="L389">            readFully(byteBuf, 0, nelts*2);</span>
<span class="nc" id="L390">            toChars(byteBuf, c, off, nelts);</span>
<span class="nc" id="L391">            off += nelts;</span>
<span class="nc" id="L392">            len -= nelts;</span>
<span class="nc" id="L393">        }</span>
<span class="nc" id="L394">    }</span>

    public void readFully(int[] i, int off, int len) throws IOException {
        // Fix 4430357 - if off + len &lt; 0, overflow occurred
<span class="nc bnc" id="L398" title="All 8 branches missed.">        if (off &lt; 0 || len &lt; 0 || off + len &gt; i.length || off + len &lt; 0) {</span>
<span class="nc" id="L399">            throw new IndexOutOfBoundsException</span>
                (&quot;off &lt; 0 || len &lt; 0 || off + len &gt; i.length!&quot;);
        }

<span class="nc bnc" id="L403" title="All 2 branches missed.">        while (len &gt; 0) {</span>
<span class="nc" id="L404">            int nelts = Math.min(len, byteBuf.length/4);</span>
<span class="nc" id="L405">            readFully(byteBuf, 0, nelts*4);</span>
<span class="nc" id="L406">            toInts(byteBuf, i, off, nelts);</span>
<span class="nc" id="L407">            off += nelts;</span>
<span class="nc" id="L408">            len -= nelts;</span>
<span class="nc" id="L409">        }</span>
<span class="nc" id="L410">    }</span>

    public void readFully(long[] l, int off, int len) throws IOException {
        // Fix 4430357 - if off + len &lt; 0, overflow occurred
<span class="nc bnc" id="L414" title="All 8 branches missed.">        if (off &lt; 0 || len &lt; 0 || off + len &gt; l.length || off + len &lt; 0) {</span>
<span class="nc" id="L415">            throw new IndexOutOfBoundsException</span>
                (&quot;off &lt; 0 || len &lt; 0 || off + len &gt; l.length!&quot;);
        }

<span class="nc bnc" id="L419" title="All 2 branches missed.">        while (len &gt; 0) {</span>
<span class="nc" id="L420">            int nelts = Math.min(len, byteBuf.length/8);</span>
<span class="nc" id="L421">            readFully(byteBuf, 0, nelts*8);</span>
<span class="nc" id="L422">            toLongs(byteBuf, l, off, nelts);</span>
<span class="nc" id="L423">            off += nelts;</span>
<span class="nc" id="L424">            len -= nelts;</span>
<span class="nc" id="L425">        }</span>
<span class="nc" id="L426">    }</span>

    public void readFully(float[] f, int off, int len) throws IOException {
        // Fix 4430357 - if off + len &lt; 0, overflow occurred
<span class="nc bnc" id="L430" title="All 8 branches missed.">        if (off &lt; 0 || len &lt; 0 || off + len &gt; f.length || off + len &lt; 0) {</span>
<span class="nc" id="L431">            throw new IndexOutOfBoundsException</span>
                (&quot;off &lt; 0 || len &lt; 0 || off + len &gt; f.length!&quot;);
        }

<span class="nc bnc" id="L435" title="All 2 branches missed.">        while (len &gt; 0) {</span>
<span class="nc" id="L436">            int nelts = Math.min(len, byteBuf.length/4);</span>
<span class="nc" id="L437">            readFully(byteBuf, 0, nelts*4);</span>
<span class="nc" id="L438">            toFloats(byteBuf, f, off, nelts);</span>
<span class="nc" id="L439">            off += nelts;</span>
<span class="nc" id="L440">            len -= nelts;</span>
<span class="nc" id="L441">        }</span>
<span class="nc" id="L442">    }</span>

    public void readFully(double[] d, int off, int len) throws IOException {
        // Fix 4430357 - if off + len &lt; 0, overflow occurred
<span class="nc bnc" id="L446" title="All 8 branches missed.">        if (off &lt; 0 || len &lt; 0 || off + len &gt; d.length || off + len &lt; 0) {</span>
<span class="nc" id="L447">            throw new IndexOutOfBoundsException</span>
                (&quot;off &lt; 0 || len &lt; 0 || off + len &gt; d.length!&quot;);
        }

<span class="nc bnc" id="L451" title="All 2 branches missed.">        while (len &gt; 0) {</span>
<span class="nc" id="L452">            int nelts = Math.min(len, byteBuf.length/8);</span>
<span class="nc" id="L453">            readFully(byteBuf, 0, nelts*8);</span>
<span class="nc" id="L454">            toDoubles(byteBuf, d, off, nelts);</span>
<span class="nc" id="L455">            off += nelts;</span>
<span class="nc" id="L456">            len -= nelts;</span>
<span class="nc" id="L457">        }</span>
<span class="nc" id="L458">    }</span>

    private void toShorts(byte[] b, short[] s, int off, int len) {
<span class="nc" id="L461">        int boff = 0;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (byteOrder == ByteOrder.BIG_ENDIAN) {</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L464">                int b0 = b[boff];</span>
<span class="nc" id="L465">                int b1 = b[boff + 1] &amp; 0xff;</span>
<span class="nc" id="L466">                s[off + j] = (short)((b0 &lt;&lt; 8) | b1);</span>
<span class="nc" id="L467">                boff += 2;</span>
            }
        } else {
<span class="nc bnc" id="L470" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L471">                int b0 = b[boff + 1];</span>
<span class="nc" id="L472">                int b1 = b[boff] &amp; 0xff;</span>
<span class="nc" id="L473">                s[off + j] = (short)((b0 &lt;&lt; 8) | b1);</span>
<span class="nc" id="L474">                boff += 2;</span>
            }
        }
<span class="nc" id="L477">    }</span>

    private void toChars(byte[] b, char[] c, int off, int len) {
<span class="nc" id="L480">        int boff = 0;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (byteOrder == ByteOrder.BIG_ENDIAN) {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L483">                int b0 = b[boff];</span>
<span class="nc" id="L484">                int b1 = b[boff + 1] &amp; 0xff;</span>
<span class="nc" id="L485">                c[off + j] = (char)((b0 &lt;&lt; 8) | b1);</span>
<span class="nc" id="L486">                boff += 2;</span>
            }
        } else {
<span class="nc bnc" id="L489" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L490">                int b0 = b[boff + 1];</span>
<span class="nc" id="L491">                int b1 = b[boff] &amp; 0xff;</span>
<span class="nc" id="L492">                c[off + j] = (char)((b0 &lt;&lt; 8) | b1);</span>
<span class="nc" id="L493">                boff += 2;</span>
            }
        }
<span class="nc" id="L496">    }</span>

    private void toInts(byte[] b, int[] i, int off, int len) {
<span class="nc" id="L499">        int boff = 0;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (byteOrder == ByteOrder.BIG_ENDIAN) {</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L502">                int b0 = b[boff];</span>
<span class="nc" id="L503">                int b1 = b[boff + 1] &amp; 0xff;</span>
<span class="nc" id="L504">                int b2 = b[boff + 2] &amp; 0xff;</span>
<span class="nc" id="L505">                int b3 = b[boff + 3] &amp; 0xff;</span>
<span class="nc" id="L506">                i[off + j] = (b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b3;</span>
<span class="nc" id="L507">                boff += 4;</span>
            }
        } else {
<span class="nc bnc" id="L510" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L511">                int b0 = b[boff + 3];</span>
<span class="nc" id="L512">                int b1 = b[boff + 2] &amp; 0xff;</span>
<span class="nc" id="L513">                int b2 = b[boff + 1] &amp; 0xff;</span>
<span class="nc" id="L514">                int b3 = b[boff] &amp; 0xff;</span>
<span class="nc" id="L515">                i[off + j] = (b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b3;</span>
<span class="nc" id="L516">                boff += 4;</span>
            }
        }
<span class="nc" id="L519">    }</span>

    private void toLongs(byte[] b, long[] l, int off, int len) {
<span class="nc" id="L522">        int boff = 0;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">        if (byteOrder == ByteOrder.BIG_ENDIAN) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L525">                int b0 = b[boff];</span>
<span class="nc" id="L526">                int b1 = b[boff + 1] &amp; 0xff;</span>
<span class="nc" id="L527">                int b2 = b[boff + 2] &amp; 0xff;</span>
<span class="nc" id="L528">                int b3 = b[boff + 3] &amp; 0xff;</span>
<span class="nc" id="L529">                int b4 = b[boff + 4];</span>
<span class="nc" id="L530">                int b5 = b[boff + 5] &amp; 0xff;</span>
<span class="nc" id="L531">                int b6 = b[boff + 6] &amp; 0xff;</span>
<span class="nc" id="L532">                int b7 = b[boff + 7] &amp; 0xff;</span>

<span class="nc" id="L534">                int i0 = (b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b3;</span>
<span class="nc" id="L535">                int i1 = (b4 &lt;&lt; 24) | (b5 &lt;&lt; 16) | (b6 &lt;&lt; 8) | b7;</span>

<span class="nc" id="L537">                l[off + j] = ((long)i0 &lt;&lt; 32) | (i1 &amp; 0xffffffffL);</span>
<span class="nc" id="L538">                boff += 8;</span>
            }
        } else {
<span class="nc bnc" id="L541" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L542">                int b0 = b[boff + 7];</span>
<span class="nc" id="L543">                int b1 = b[boff + 6] &amp; 0xff;</span>
<span class="nc" id="L544">                int b2 = b[boff + 5] &amp; 0xff;</span>
<span class="nc" id="L545">                int b3 = b[boff + 4] &amp; 0xff;</span>
<span class="nc" id="L546">                int b4 = b[boff + 3];</span>
<span class="nc" id="L547">                int b5 = b[boff + 2] &amp; 0xff;</span>
<span class="nc" id="L548">                int b6 = b[boff + 1] &amp; 0xff;</span>
<span class="nc" id="L549">                int b7 = b[boff]     &amp; 0xff;</span>

<span class="nc" id="L551">                int i0 = (b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b3;</span>
<span class="nc" id="L552">                int i1 = (b4 &lt;&lt; 24) | (b5 &lt;&lt; 16) | (b6 &lt;&lt; 8) | b7;</span>

<span class="nc" id="L554">                l[off + j] = ((long)i0 &lt;&lt; 32) | (i1 &amp; 0xffffffffL);</span>
<span class="nc" id="L555">                boff += 8;</span>
            }
        }
<span class="nc" id="L558">    }</span>

    private void toFloats(byte[] b, float[] f, int off, int len) {
<span class="nc" id="L561">        int boff = 0;</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">        if (byteOrder == ByteOrder.BIG_ENDIAN) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L564">                int b0 = b[boff];</span>
<span class="nc" id="L565">                int b1 = b[boff + 1] &amp; 0xff;</span>
<span class="nc" id="L566">                int b2 = b[boff + 2] &amp; 0xff;</span>
<span class="nc" id="L567">                int b3 = b[boff + 3] &amp; 0xff;</span>
<span class="nc" id="L568">                int i = (b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b3;</span>
<span class="nc" id="L569">                f[off + j] = Float.intBitsToFloat(i);</span>
<span class="nc" id="L570">                boff += 4;</span>
            }
        } else {
<span class="nc bnc" id="L573" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L574">                int b0 = b[boff + 3];</span>
<span class="nc" id="L575">                int b1 = b[boff + 2] &amp; 0xff;</span>
<span class="nc" id="L576">                int b2 = b[boff + 1] &amp; 0xff;</span>
<span class="nc" id="L577">                int b3 = b[boff + 0] &amp; 0xff;</span>
<span class="nc" id="L578">                int i = (b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b3;</span>
<span class="nc" id="L579">                f[off + j] = Float.intBitsToFloat(i);</span>
<span class="nc" id="L580">                boff += 4;</span>
            }
        }
<span class="nc" id="L583">    }</span>

    private void toDoubles(byte[] b, double[] d, int off, int len) {
<span class="nc" id="L586">        int boff = 0;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (byteOrder == ByteOrder.BIG_ENDIAN) {</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L589">                int b0 = b[boff];</span>
<span class="nc" id="L590">                int b1 = b[boff + 1] &amp; 0xff;</span>
<span class="nc" id="L591">                int b2 = b[boff + 2] &amp; 0xff;</span>
<span class="nc" id="L592">                int b3 = b[boff + 3] &amp; 0xff;</span>
<span class="nc" id="L593">                int b4 = b[boff + 4];</span>
<span class="nc" id="L594">                int b5 = b[boff + 5] &amp; 0xff;</span>
<span class="nc" id="L595">                int b6 = b[boff + 6] &amp; 0xff;</span>
<span class="nc" id="L596">                int b7 = b[boff + 7] &amp; 0xff;</span>

<span class="nc" id="L598">                int i0 = (b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b3;</span>
<span class="nc" id="L599">                int i1 = (b4 &lt;&lt; 24) | (b5 &lt;&lt; 16) | (b6 &lt;&lt; 8) | b7;</span>
<span class="nc" id="L600">                long l = ((long)i0 &lt;&lt; 32) | (i1 &amp; 0xffffffffL);</span>

<span class="nc" id="L602">                d[off + j] = Double.longBitsToDouble(l);</span>
<span class="nc" id="L603">                boff += 8;</span>
            }
        } else {
<span class="nc bnc" id="L606" title="All 2 branches missed.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L607">                int b0 = b[boff + 7];</span>
<span class="nc" id="L608">                int b1 = b[boff + 6] &amp; 0xff;</span>
<span class="nc" id="L609">                int b2 = b[boff + 5] &amp; 0xff;</span>
<span class="nc" id="L610">                int b3 = b[boff + 4] &amp; 0xff;</span>
<span class="nc" id="L611">                int b4 = b[boff + 3];</span>
<span class="nc" id="L612">                int b5 = b[boff + 2] &amp; 0xff;</span>
<span class="nc" id="L613">                int b6 = b[boff + 1] &amp; 0xff;</span>
<span class="nc" id="L614">                int b7 = b[boff] &amp; 0xff;</span>

<span class="nc" id="L616">                int i0 = (b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b3;</span>
<span class="nc" id="L617">                int i1 = (b4 &lt;&lt; 24) | (b5 &lt;&lt; 16) | (b6 &lt;&lt; 8) | b7;</span>
<span class="nc" id="L618">                long l = ((long)i0 &lt;&lt; 32) | (i1 &amp; 0xffffffffL);</span>

<span class="nc" id="L620">                d[off + j] = Double.longBitsToDouble(l);</span>
<span class="nc" id="L621">                boff += 8;</span>
            }
        }
<span class="nc" id="L624">    }</span>

    public long getStreamPosition() throws IOException {
<span class="fc" id="L627">        checkClosed();</span>
<span class="fc" id="L628">        return streamPos;</span>
    }

    public int getBitOffset() throws IOException {
<span class="fc" id="L632">        checkClosed();</span>
<span class="fc" id="L633">        return bitOffset;</span>
    }

    public void setBitOffset(int bitOffset) throws IOException {
<span class="fc" id="L637">        checkClosed();</span>
<span class="pc bpc" id="L638" title="2 of 4 branches missed.">        if (bitOffset &lt; 0 || bitOffset &gt; 7) {</span>
<span class="nc" id="L639">            throw new IllegalArgumentException(&quot;bitOffset must be betwwen 0 and 7!&quot;);</span>
        }
<span class="fc" id="L641">        this.bitOffset = bitOffset;</span>
<span class="fc" id="L642">    }</span>

    public int readBit() throws IOException {
<span class="nc" id="L645">        checkClosed();</span>

        // Compute final bit offset before we call read() and seek()
<span class="nc" id="L648">        int newBitOffset = (this.bitOffset + 1) &amp; 0x7;</span>

<span class="nc" id="L650">        int val = read();</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">        if (val == -1) {</span>
<span class="nc" id="L652">            throw new EOFException();</span>
        }

<span class="nc bnc" id="L655" title="All 2 branches missed.">        if (newBitOffset != 0) {</span>
            // Move byte position back if in the middle of a byte
<span class="nc" id="L657">            seek(getStreamPosition() - 1);</span>
            // Shift the bit to be read to the rightmost position
<span class="nc" id="L659">            val &gt;&gt;= 8 - newBitOffset;</span>
        }
<span class="nc" id="L661">        this.bitOffset = newBitOffset;</span>

<span class="nc" id="L663">        return val &amp; 0x1;</span>
    }

    public long readBits(int numBits) throws IOException {
<span class="nc" id="L667">        checkClosed();</span>

<span class="nc bnc" id="L669" title="All 4 branches missed.">        if (numBits &lt; 0 || numBits &gt; 64) {</span>
<span class="nc" id="L670">            throw new IllegalArgumentException();</span>
        }
<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (numBits == 0) {</span>
<span class="nc" id="L673">            return 0L;</span>
        }

        // Have to read additional bits on the left equal to the bit offset
<span class="nc" id="L677">        int bitsToRead = numBits + bitOffset;</span>

        // Compute final bit offset before we call read() and seek()
<span class="nc" id="L680">        int newBitOffset = (this.bitOffset + numBits) &amp; 0x7;</span>

        // Read a byte at a time, accumulate
<span class="nc" id="L683">        long accum = 0L;</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">        while (bitsToRead &gt; 0) {</span>
<span class="nc" id="L685">            int val = read();</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">            if (val == -1) {</span>
<span class="nc" id="L687">                throw new EOFException();</span>
            }

<span class="nc" id="L690">            accum &lt;&lt;= 8;</span>
<span class="nc" id="L691">            accum |= val;</span>
<span class="nc" id="L692">            bitsToRead -= 8;</span>
<span class="nc" id="L693">        }</span>

        // Move byte position back if in the middle of a byte
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (newBitOffset != 0) {</span>
<span class="nc" id="L697">            seek(getStreamPosition() - 1);</span>
        }
<span class="nc" id="L699">        this.bitOffset = newBitOffset;</span>

        // Shift away unwanted bits on the right.
<span class="nc" id="L702">        accum &gt;&gt;&gt;= (-bitsToRead); // Negative of bitsToRead == extra bits read</span>

        // Mask out unwanted bits on the left
<span class="nc" id="L705">        accum &amp;= (-1L &gt;&gt;&gt; (64 - numBits));</span>

<span class="nc" id="L707">        return accum;</span>
    }

    /**
     * Returns &lt;code&gt;-1L&lt;/code&gt; to indicate that the stream has unknown
     * length.  Subclasses must override this method to provide actual
     * length information.
     *
     * @return -1L to indicate unknown length.
     */
    public long length() {
<span class="nc" id="L718">        return -1L;</span>
    }

    /**
     * Advances the current stream position by calling
     * &lt;code&gt;seek(getStreamPosition() + n)&lt;/code&gt;.
     *
     * &lt;p&gt; The bit offset is reset to zero.
     *
     * @param n the number of bytes to seek forward.
     *
     * @return an &lt;code&gt;int&lt;/code&gt; representing the number of bytes
     * skipped.
     *
     * @exception IOException if &lt;code&gt;getStreamPosition&lt;/code&gt;
     * throws an &lt;code&gt;IOException&lt;/code&gt; when computing either
     * the starting or ending position.
     */
    public int skipBytes(int n) throws IOException {
<span class="nc" id="L737">        long pos = getStreamPosition();</span>
<span class="nc" id="L738">        seek(pos + n);</span>
<span class="nc" id="L739">        return (int)(getStreamPosition() - pos);</span>
    }

    /**
     * Advances the current stream position by calling
     * &lt;code&gt;seek(getStreamPosition() + n)&lt;/code&gt;.
     *
     * &lt;p&gt; The bit offset is reset to zero.
     *
     * @param n the number of bytes to seek forward.
     *
     * @return a &lt;code&gt;long&lt;/code&gt; representing the number of bytes
     * skipped.
     *
     * @exception IOException if &lt;code&gt;getStreamPosition&lt;/code&gt;
     * throws an &lt;code&gt;IOException&lt;/code&gt; when computing either
     * the starting or ending position.
     */
    public long skipBytes(long n) throws IOException {
<span class="nc" id="L758">        long pos = getStreamPosition();</span>
<span class="nc" id="L759">        seek(pos + n);</span>
<span class="nc" id="L760">        return getStreamPosition() - pos;</span>
    }

    public void seek(long pos) throws IOException {
<span class="fc" id="L764">        checkClosed();</span>

        // This test also covers pos &lt; 0
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">        if (pos &lt; flushedPos) {</span>
<span class="nc" id="L768">            throw new IndexOutOfBoundsException(&quot;pos &lt; flushedPos!&quot;);</span>
        }

<span class="fc" id="L771">        this.streamPos = pos;</span>
<span class="fc" id="L772">        this.bitOffset = 0;</span>
<span class="fc" id="L773">    }</span>

    /**
     * Pushes the current stream position onto a stack of marked
     * positions.
     */
    public void mark() {
        try {
<span class="fc" id="L781">            markByteStack.push(Long.valueOf(getStreamPosition()));</span>
<span class="fc" id="L782">            markBitStack.push(Integer.valueOf(getBitOffset()));</span>
<span class="nc" id="L783">        } catch (IOException e) {</span>
<span class="fc" id="L784">        }</span>
<span class="fc" id="L785">    }</span>

    /**
     * Resets the current stream byte and bit positions from the stack
     * of marked positions.
     *
     * &lt;p&gt; An &lt;code&gt;IOException&lt;/code&gt; will be thrown if the previous
     * marked position lies in the discarded portion of the stream.
     *
     * @exception IOException if an I/O error occurs.
     */
    public void reset() throws IOException {
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">        if (markByteStack.empty()) {</span>
<span class="nc" id="L798">            return;</span>
        }

<span class="fc" id="L801">        long pos = ((Long)markByteStack.pop()).longValue();</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">        if (pos &lt; flushedPos) {</span>
<span class="nc" id="L803">            throw new IIOException</span>
                (&quot;Previous marked position has been discarded!&quot;);
        }
<span class="fc" id="L806">        seek(pos);</span>

<span class="fc" id="L808">        int offset = ((Integer)markBitStack.pop()).intValue();</span>
<span class="fc" id="L809">        setBitOffset(offset);</span>
<span class="fc" id="L810">    }</span>

    public void flushBefore(long pos) throws IOException {
<span class="nc" id="L813">        checkClosed();</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">        if (pos &lt; flushedPos) {</span>
<span class="nc" id="L815">            throw new IndexOutOfBoundsException(&quot;pos &lt; flushedPos!&quot;);</span>
        }
<span class="nc bnc" id="L817" title="All 2 branches missed.">        if (pos &gt; getStreamPosition()) {</span>
<span class="nc" id="L818">            throw new IndexOutOfBoundsException(&quot;pos &gt; getStreamPosition()!&quot;);</span>
        }
        // Invariant: flushedPos &gt;= 0
<span class="nc" id="L821">        flushedPos = pos;</span>
<span class="nc" id="L822">    }</span>

    public void flush() throws IOException {
<span class="nc" id="L825">        flushBefore(getStreamPosition());</span>
<span class="nc" id="L826">    }</span>

    public long getFlushedPosition() {
<span class="nc" id="L829">        return flushedPos;</span>
    }

    /**
     * Default implementation returns false.  Subclasses should
     * override this if they cache data.
     */
    public boolean isCached() {
<span class="nc" id="L837">        return false;</span>
    }

    /**
     * Default implementation returns false.  Subclasses should
     * override this if they cache data in main memory.
     */
    public boolean isCachedMemory() {
<span class="nc" id="L845">        return false;</span>
    }

    /**
     * Default implementation returns false.  Subclasses should
     * override this if they cache data in a temporary file.
     */
    public boolean isCachedFile() {
<span class="nc" id="L853">        return false;</span>
    }

    public void close() throws IOException {
<span class="fc" id="L857">        checkClosed();</span>

<span class="fc" id="L859">        isClosed = true;</span>
<span class="fc" id="L860">    }</span>

    /**
     * Finalizes this object prior to garbage collection.  The
     * &lt;code&gt;close&lt;/code&gt; method is called to close any open input
     * source.  This method should not be called from application
     * code.
     *
     * @exception Throwable if an error occurs during superclass
     * finalization.
     */
    protected void finalize() throws Throwable {
<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (!isClosed) {</span>
            try {
<span class="nc" id="L874">                close();</span>
<span class="nc" id="L875">            } catch (IOException e) {</span>
<span class="nc" id="L876">            }</span>
        }
<span class="nc" id="L878">        super.finalize();</span>
<span class="nc" id="L879">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>