<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CanonicalizerBase.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.org.apache.xml.internal.security.c14n.implementations</a> &gt; <span class="el_source">CanonicalizerBase.java</span></div><h1>CanonicalizerBase.java</h1><pre class="source lang-java linenums">/*
 * reserved comment block
 * DO NOT REMOVE OR ALTER!
 */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.sun.org.apache.xml.internal.security.c14n.implementations;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
import com.sun.org.apache.xml.internal.security.c14n.CanonicalizerSpi;
import com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare;
import com.sun.org.apache.xml.internal.security.signature.NodeFilter;
import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
import com.sun.org.apache.xml.internal.security.utils.Constants;
import com.sun.org.apache.xml.internal.security.utils.UnsyncByteArrayOutputStream;
import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
import org.w3c.dom.Attr;
import org.w3c.dom.Comment;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.ProcessingInstruction;
import org.xml.sax.SAXException;

/**
 * Abstract base class for canonicalization algorithms.
 *
 * @author Christian Geuer-Pollmann &lt;geuerp@apache.org&gt;
 */
public abstract class CanonicalizerBase extends CanonicalizerSpi {
    public static final String XML = &quot;xml&quot;;
    public static final String XMLNS = &quot;xmlns&quot;;

<span class="nc" id="L66">    protected static final AttrCompare COMPARE = new AttrCompare();</span>
    protected static final Attr nullNode;

<span class="nc" id="L69">    private static final byte[] END_PI = {'?','&gt;'};</span>
<span class="nc" id="L70">    private static final byte[] BEGIN_PI = {'&lt;','?'};</span>
<span class="nc" id="L71">    private static final byte[] END_COMM = {'-','-','&gt;'};</span>
<span class="nc" id="L72">    private static final byte[] BEGIN_COMM = {'&lt;','!','-','-'};</span>
<span class="nc" id="L73">    private static final byte[] XA = {'&amp;','#','x','A',';'};</span>
<span class="nc" id="L74">    private static final byte[] X9 = {'&amp;','#','x','9',';'};</span>
<span class="nc" id="L75">    private static final byte[] QUOT = {'&amp;','q','u','o','t',';'};</span>
<span class="nc" id="L76">    private static final byte[] XD = {'&amp;','#','x','D',';'};</span>
<span class="nc" id="L77">    private static final byte[] GT = {'&amp;','g','t',';'};</span>
<span class="nc" id="L78">    private static final byte[] LT = {'&amp;','l','t',';'};</span>
<span class="nc" id="L79">    private static final byte[] END_TAG = {'&lt;','/'};</span>
<span class="nc" id="L80">    private static final byte[] AMP = {'&amp;','a','m','p',';'};</span>
<span class="nc" id="L81">    private static final byte[] equalsStr = {'=','\&quot;'};</span>

    protected static final int NODE_BEFORE_DOCUMENT_ELEMENT = -1;
    protected static final int NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT = 0;
    protected static final int NODE_AFTER_DOCUMENT_ELEMENT = 1;

    static {
        // The null xmlns definition.
        try {
<span class="nc" id="L90">            DocumentBuilder documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();</span>
<span class="nc" id="L91">            nullNode = documentBuilder.newDocument().createAttributeNS(Constants.NamespaceSpecNS, XMLNS);</span>
<span class="nc" id="L92">            nullNode.setValue(&quot;&quot;);</span>
<span class="nc" id="L93">        } catch (Exception e) {</span>
<span class="nc" id="L94">            throw new RuntimeException(&quot;Unable to create nullNode: &quot; + e);</span>
<span class="nc" id="L95">        }</span>
<span class="nc" id="L96">    }</span>

    private List&lt;NodeFilter&gt; nodeFilter;

    private boolean includeComments;
    private Set&lt;Node&gt; xpathNodeSet;
    /**
     * The node to be skipped/excluded from the DOM tree
     * in subtree canonicalizations.
     */
    private Node excludeNode;
<span class="nc" id="L107">    private OutputStream writer = new ByteArrayOutputStream();</span>

    /**
     * Constructor CanonicalizerBase
     *
     * @param includeComments
     */
<span class="nc" id="L114">    public CanonicalizerBase(boolean includeComments) {</span>
<span class="nc" id="L115">        this.includeComments = includeComments;</span>
<span class="nc" id="L116">    }</span>

    /**
     * Method engineCanonicalizeSubTree
     * @inheritDoc
     * @param rootNode
     * @throws CanonicalizationException
     */
    public byte[] engineCanonicalizeSubTree(Node rootNode)
        throws CanonicalizationException {
<span class="nc" id="L126">        return engineCanonicalizeSubTree(rootNode, (Node)null);</span>
    }

    /**
     * Method engineCanonicalizeXPathNodeSet
     * @inheritDoc
     * @param xpathNodeSet
     * @throws CanonicalizationException
     */
    public byte[] engineCanonicalizeXPathNodeSet(Set&lt;Node&gt; xpathNodeSet)
        throws CanonicalizationException {
<span class="nc" id="L137">        this.xpathNodeSet = xpathNodeSet;</span>
<span class="nc" id="L138">        return engineCanonicalizeXPathNodeSetInternal(XMLUtils.getOwnerDocument(this.xpathNodeSet));</span>
    }

    /**
     * Canonicalizes a Subtree node.
     * @param input the root of the subtree to canicalize
     * @return The canonicalize stream.
     * @throws CanonicalizationException
     */
    public byte[] engineCanonicalize(XMLSignatureInput input) throws CanonicalizationException {
        try {
<span class="nc bnc" id="L149" title="All 2 branches missed.">            if (input.isExcludeComments()) {</span>
<span class="nc" id="L150">                includeComments = false;</span>
            }
<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (input.isOctetStream()) {</span>
<span class="nc" id="L153">                return engineCanonicalize(input.getBytes());</span>
            }
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (input.isElement()) {</span>
<span class="nc" id="L156">                return engineCanonicalizeSubTree(input.getSubNode(), input.getExcludeNode());</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            } else if (input.isNodeSet()) {</span>
<span class="nc" id="L158">                nodeFilter = input.getNodeFilters();</span>

<span class="nc" id="L160">                circumventBugIfNeeded(input);</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">                if (input.getSubNode() != null) {</span>
<span class="nc" id="L163">                    return engineCanonicalizeXPathNodeSetInternal(input.getSubNode());</span>
                } else {
<span class="nc" id="L165">                    return engineCanonicalizeXPathNodeSet(input.getNodeSet());</span>
                }
            }
<span class="nc" id="L168">            return null;</span>
<span class="nc" id="L169">        } catch (CanonicalizationException ex) {</span>
<span class="nc" id="L170">            throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L171">        } catch (ParserConfigurationException ex) {</span>
<span class="nc" id="L172">            throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L173">        } catch (IOException ex) {</span>
<span class="nc" id="L174">            throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L175">        } catch (SAXException ex) {</span>
<span class="nc" id="L176">            throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
        }
    }

    /**
     * @param writer The writer to set.
     */
    public void setWriter(OutputStream writer) {
<span class="nc" id="L184">        this.writer = writer;</span>
<span class="nc" id="L185">    }</span>

    /**
     * Canonicalizes a Subtree node.
     *
     * @param rootNode
     *            the root of the subtree to canonicalize
     * @param excludeNode
     *            a node to be excluded from the canonicalize operation
     * @return The canonicalize stream.
     * @throws CanonicalizationException
     */
    protected byte[] engineCanonicalizeSubTree(Node rootNode, Node excludeNode)
        throws CanonicalizationException {
<span class="nc" id="L199">        this.excludeNode = excludeNode;</span>
        try {
<span class="nc" id="L201">            NameSpaceSymbTable ns = new NameSpaceSymbTable();</span>
<span class="nc" id="L202">            int nodeLevel = NODE_BEFORE_DOCUMENT_ELEMENT;</span>
<span class="nc bnc" id="L203" title="All 4 branches missed.">            if (rootNode != null &amp;&amp; Node.ELEMENT_NODE == rootNode.getNodeType()) {</span>
                //Fills the nssymbtable with the definitions of the parent of the root subnode
<span class="nc" id="L205">                getParentNameSpaces((Element)rootNode, ns);</span>
<span class="nc" id="L206">                nodeLevel = NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;</span>
            }
<span class="nc" id="L208">            this.canonicalizeSubTree(rootNode, ns, rootNode, nodeLevel);</span>
<span class="nc" id="L209">            this.writer.flush();</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (this.writer instanceof ByteArrayOutputStream) {</span>
<span class="nc" id="L211">                byte[] result = ((ByteArrayOutputStream)this.writer).toByteArray();</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">                if (reset) {</span>
<span class="nc" id="L213">                    ((ByteArrayOutputStream)this.writer).reset();</span>
                } else {
<span class="nc" id="L215">                    this.writer.close();</span>
                }
<span class="nc" id="L217">                return result;</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">            } else if (this.writer instanceof UnsyncByteArrayOutputStream) {</span>
<span class="nc" id="L219">                byte[] result = ((UnsyncByteArrayOutputStream)this.writer).toByteArray();</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">                if (reset) {</span>
<span class="nc" id="L221">                    ((UnsyncByteArrayOutputStream)this.writer).reset();</span>
                } else {
<span class="nc" id="L223">                    this.writer.close();</span>
                }
<span class="nc" id="L225">                return result;</span>
            } else {
<span class="nc" id="L227">                this.writer.close();</span>
            }
<span class="nc" id="L229">            return null;</span>

<span class="nc" id="L231">        } catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L232">            throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L233">        } catch (IOException ex) {</span>
<span class="nc" id="L234">            throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
        }
    }


    /**
     * Method canonicalizeSubTree, this function is a recursive one.
     *
     * @param currentNode
     * @param ns
     * @param endnode
     * @throws CanonicalizationException
     * @throws IOException
     */
    protected final void canonicalizeSubTree(
        Node currentNode, NameSpaceSymbTable ns, Node endnode, int documentLevel
    ) throws CanonicalizationException, IOException {
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (isVisibleInt(currentNode) == -1) {</span>
<span class="nc" id="L252">            return;</span>
        }
<span class="nc" id="L254">        Node sibling = null;</span>
<span class="nc" id="L255">        Node parentNode = null;</span>
<span class="nc" id="L256">        final OutputStream writer = this.writer;</span>
<span class="nc" id="L257">        final Node excludeNode = this.excludeNode;</span>
<span class="nc" id="L258">        final boolean includeComments = this.includeComments;</span>
<span class="nc" id="L259">        Map&lt;String, byte[]&gt; cache = new HashMap&lt;String, byte[]&gt;();</span>
        do {
<span class="nc bnc" id="L261" title="All 7 branches missed.">            switch (currentNode.getNodeType()) {</span>

            case Node.ENTITY_NODE :
            case Node.NOTATION_NODE :
            case Node.ATTRIBUTE_NODE :
                // illegal node type during traversal
<span class="nc" id="L267">                throw new CanonicalizationException(&quot;empty&quot;);</span>

            case Node.DOCUMENT_FRAGMENT_NODE :
            case Node.DOCUMENT_NODE :
<span class="nc" id="L271">                ns.outputNodePush();</span>
<span class="nc" id="L272">                sibling = currentNode.getFirstChild();</span>
<span class="nc" id="L273">                break;</span>

            case Node.COMMENT_NODE :
<span class="nc bnc" id="L276" title="All 2 branches missed.">                if (includeComments) {</span>
<span class="nc" id="L277">                    outputCommentToWriter((Comment) currentNode, writer, documentLevel);</span>
                }
                break;

            case Node.PROCESSING_INSTRUCTION_NODE :
<span class="nc" id="L282">                outputPItoWriter((ProcessingInstruction) currentNode, writer, documentLevel);</span>
<span class="nc" id="L283">                break;</span>

            case Node.TEXT_NODE :
            case Node.CDATA_SECTION_NODE :
<span class="nc" id="L287">                outputTextToWriter(currentNode.getNodeValue(), writer);</span>
<span class="nc" id="L288">                break;</span>

            case Node.ELEMENT_NODE :
<span class="nc" id="L291">                documentLevel = NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                if (currentNode == excludeNode) {</span>
<span class="nc" id="L293">                    break;</span>
                }
<span class="nc" id="L295">                Element currentElement = (Element)currentNode;</span>
                //Add a level to the nssymbtable. So latter can be pop-back.
<span class="nc" id="L297">                ns.outputNodePush();</span>
<span class="nc" id="L298">                writer.write('&lt;');</span>
<span class="nc" id="L299">                String name = currentElement.getTagName();</span>
<span class="nc" id="L300">                UtfHelpper.writeByte(name, writer, cache);</span>

<span class="nc" id="L302">                Iterator&lt;Attr&gt; attrs = this.handleAttributesSubtree(currentElement, ns);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                if (attrs != null) {</span>
                    //we output all Attrs which are available
<span class="nc bnc" id="L305" title="All 2 branches missed.">                    while (attrs.hasNext()) {</span>
<span class="nc" id="L306">                        Attr attr = attrs.next();</span>
<span class="nc" id="L307">                        outputAttrToWriter(attr.getNodeName(), attr.getNodeValue(), writer, cache);</span>
<span class="nc" id="L308">                    }</span>
                }
<span class="nc" id="L310">                writer.write('&gt;');</span>
<span class="nc" id="L311">                sibling = currentNode.getFirstChild();</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                if (sibling == null) {</span>
<span class="nc" id="L313">                    writer.write(END_TAG);</span>
<span class="nc" id="L314">                    UtfHelpper.writeStringToUtf8(name, writer);</span>
<span class="nc" id="L315">                    writer.write('&gt;');</span>
                    //We finished with this level, pop to the previous definitions.
<span class="nc" id="L317">                    ns.outputNodePop();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                    if (parentNode != null) {</span>
<span class="nc" id="L319">                        sibling = currentNode.getNextSibling();</span>
                    }
                } else {
<span class="nc" id="L322">                    parentNode = currentElement;</span>
                }
<span class="nc" id="L324">                break;</span>

            case Node.DOCUMENT_TYPE_NODE :
            default :
                break;
            }
<span class="nc bnc" id="L330" title="All 4 branches missed.">            while (sibling == null &amp;&amp; parentNode != null) {</span>
<span class="nc" id="L331">                writer.write(END_TAG);</span>
<span class="nc" id="L332">                UtfHelpper.writeByte(((Element)parentNode).getTagName(), writer, cache);</span>
<span class="nc" id="L333">                writer.write('&gt;');</span>
                //We finished with this level, pop to the previous definitions.
<span class="nc" id="L335">                ns.outputNodePop();</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                if (parentNode == endnode) {</span>
<span class="nc" id="L337">                    return;</span>
                }
<span class="nc" id="L339">                sibling = parentNode.getNextSibling();</span>
<span class="nc" id="L340">                parentNode = parentNode.getParentNode();</span>
<span class="nc bnc" id="L341" title="All 4 branches missed.">                if (parentNode == null || Node.ELEMENT_NODE != parentNode.getNodeType()) {</span>
<span class="nc" id="L342">                    documentLevel = NODE_AFTER_DOCUMENT_ELEMENT;</span>
<span class="nc" id="L343">                    parentNode = null;</span>
                }
            }
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if (sibling == null) {</span>
<span class="nc" id="L347">                return;</span>
            }
<span class="nc" id="L349">            currentNode = sibling;</span>
<span class="nc" id="L350">            sibling = currentNode.getNextSibling();</span>
<span class="nc" id="L351">        } while(true);</span>
    }


    private byte[] engineCanonicalizeXPathNodeSetInternal(Node doc)
        throws CanonicalizationException {
        try {
<span class="nc" id="L358">            this.canonicalizeXPathNodeSet(doc, doc);</span>
<span class="nc" id="L359">            this.writer.flush();</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (this.writer instanceof ByteArrayOutputStream) {</span>
<span class="nc" id="L361">                byte[] sol = ((ByteArrayOutputStream)this.writer).toByteArray();</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">                if (reset) {</span>
<span class="nc" id="L363">                    ((ByteArrayOutputStream)this.writer).reset();</span>
                } else {
<span class="nc" id="L365">                    this.writer.close();</span>
                }
<span class="nc" id="L367">                return sol;</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            } else if (this.writer instanceof UnsyncByteArrayOutputStream) {</span>
<span class="nc" id="L369">                byte[] result = ((UnsyncByteArrayOutputStream)this.writer).toByteArray();</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                if (reset) {</span>
<span class="nc" id="L371">                    ((UnsyncByteArrayOutputStream)this.writer).reset();</span>
                } else {
<span class="nc" id="L373">                    this.writer.close();</span>
                }
<span class="nc" id="L375">                return result;</span>
            } else {
<span class="nc" id="L377">                this.writer.close();</span>
            }
<span class="nc" id="L379">            return null;</span>
<span class="nc" id="L380">        } catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L381">            throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L382">        } catch (IOException ex) {</span>
<span class="nc" id="L383">            throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
        }
    }

    /**
     * Canonicalizes all the nodes included in the currentNode and contained in the
     * xpathNodeSet field.
     *
     * @param currentNode
     * @param endnode
     * @throws CanonicalizationException
     * @throws IOException
     */
    protected final void canonicalizeXPathNodeSet(Node currentNode, Node endnode)
        throws CanonicalizationException, IOException {
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (isVisibleInt(currentNode) == -1) {</span>
<span class="nc" id="L399">            return;</span>
        }
<span class="nc" id="L401">        boolean currentNodeIsVisible = false;</span>
<span class="nc" id="L402">        NameSpaceSymbTable ns = new NameSpaceSymbTable();</span>
<span class="nc bnc" id="L403" title="All 4 branches missed.">        if (currentNode != null &amp;&amp; Node.ELEMENT_NODE == currentNode.getNodeType()) {</span>
<span class="nc" id="L404">            getParentNameSpaces((Element)currentNode, ns);</span>
        }
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (currentNode == null) {</span>
<span class="nc" id="L407">            return;</span>
        }
<span class="nc" id="L409">        Node sibling = null;</span>
<span class="nc" id="L410">        Node parentNode = null;</span>
<span class="nc" id="L411">        OutputStream writer = this.writer;</span>
<span class="nc" id="L412">        int documentLevel = NODE_BEFORE_DOCUMENT_ELEMENT;</span>
<span class="nc" id="L413">        Map&lt;String, byte[]&gt; cache = new HashMap&lt;String, byte[]&gt;();</span>
        do {
<span class="nc bnc" id="L415" title="All 7 branches missed.">            switch (currentNode.getNodeType()) {</span>

            case Node.ENTITY_NODE :
            case Node.NOTATION_NODE :
            case Node.ATTRIBUTE_NODE :
                // illegal node type during traversal
<span class="nc" id="L421">                throw new CanonicalizationException(&quot;empty&quot;);</span>

            case Node.DOCUMENT_FRAGMENT_NODE :
            case Node.DOCUMENT_NODE :
<span class="nc" id="L425">                ns.outputNodePush();</span>
<span class="nc" id="L426">                sibling = currentNode.getFirstChild();</span>
<span class="nc" id="L427">                break;</span>

            case Node.COMMENT_NODE :
<span class="nc bnc" id="L430" title="All 4 branches missed.">                if (this.includeComments &amp;&amp; (isVisibleDO(currentNode, ns.getLevel()) == 1)) {</span>
<span class="nc" id="L431">                    outputCommentToWriter((Comment) currentNode, writer, documentLevel);</span>
                }
                break;

            case Node.PROCESSING_INSTRUCTION_NODE :
<span class="nc bnc" id="L436" title="All 2 branches missed.">                if (isVisible(currentNode)) {</span>
<span class="nc" id="L437">                    outputPItoWriter((ProcessingInstruction) currentNode, writer, documentLevel);</span>
                }
                break;

            case Node.TEXT_NODE :
            case Node.CDATA_SECTION_NODE :
<span class="nc bnc" id="L443" title="All 2 branches missed.">                if (isVisible(currentNode)) {</span>
<span class="nc" id="L444">                    outputTextToWriter(currentNode.getNodeValue(), writer);</span>
<span class="nc" id="L445">                    for (Node nextSibling = currentNode.getNextSibling();</span>
<span class="nc bnc" id="L446" title="All 4 branches missed.">                        (nextSibling != null) &amp;&amp; ((nextSibling.getNodeType() == Node.TEXT_NODE)</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                            || (nextSibling.getNodeType() == Node.CDATA_SECTION_NODE));</span>
<span class="nc" id="L448">                        nextSibling = nextSibling.getNextSibling()) {</span>
<span class="nc" id="L449">                        outputTextToWriter(nextSibling.getNodeValue(), writer);</span>
<span class="nc" id="L450">                        currentNode = nextSibling;</span>
<span class="nc" id="L451">                        sibling = currentNode.getNextSibling();</span>
                    }
                }
                break;

            case Node.ELEMENT_NODE :
<span class="nc" id="L457">                documentLevel = NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;</span>
<span class="nc" id="L458">                Element currentElement = (Element) currentNode;</span>
                //Add a level to the nssymbtable. So latter can be pop-back.
<span class="nc" id="L460">                String name = null;</span>
<span class="nc" id="L461">                int i = isVisibleDO(currentNode, ns.getLevel());</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                if (i == -1) {</span>
<span class="nc" id="L463">                    sibling = currentNode.getNextSibling();</span>
<span class="nc" id="L464">                    break;</span>
                }
<span class="nc bnc" id="L466" title="All 2 branches missed.">                currentNodeIsVisible = (i == 1);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                if (currentNodeIsVisible) {</span>
<span class="nc" id="L468">                    ns.outputNodePush();</span>
<span class="nc" id="L469">                    writer.write('&lt;');</span>
<span class="nc" id="L470">                    name = currentElement.getTagName();</span>
<span class="nc" id="L471">                    UtfHelpper.writeByte(name, writer, cache);</span>
                } else {
<span class="nc" id="L473">                    ns.push();</span>
                }

<span class="nc" id="L476">                Iterator&lt;Attr&gt; attrs = handleAttributes(currentElement,ns);</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">                if (attrs != null) {</span>
                    //we output all Attrs which are available
<span class="nc bnc" id="L479" title="All 2 branches missed.">                    while (attrs.hasNext()) {</span>
<span class="nc" id="L480">                        Attr attr = attrs.next();</span>
<span class="nc" id="L481">                        outputAttrToWriter(attr.getNodeName(), attr.getNodeValue(), writer, cache);</span>
<span class="nc" id="L482">                    }</span>
                }
<span class="nc bnc" id="L484" title="All 2 branches missed.">                if (currentNodeIsVisible) {</span>
<span class="nc" id="L485">                    writer.write('&gt;');</span>
                }
<span class="nc" id="L487">                sibling = currentNode.getFirstChild();</span>

<span class="nc bnc" id="L489" title="All 2 branches missed.">                if (sibling == null) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                    if (currentNodeIsVisible) {</span>
<span class="nc" id="L491">                        writer.write(END_TAG);</span>
<span class="nc" id="L492">                        UtfHelpper.writeByte(name, writer, cache);</span>
<span class="nc" id="L493">                        writer.write('&gt;');</span>
                        //We finished with this level, pop to the previous definitions.
<span class="nc" id="L495">                        ns.outputNodePop();</span>
                    } else {
<span class="nc" id="L497">                        ns.pop();</span>
                    }
<span class="nc bnc" id="L499" title="All 2 branches missed.">                    if (parentNode != null) {</span>
<span class="nc" id="L500">                        sibling = currentNode.getNextSibling();</span>
                    }
                } else {
<span class="nc" id="L503">                    parentNode = currentElement;</span>
                }
<span class="nc" id="L505">                break;</span>

            case Node.DOCUMENT_TYPE_NODE :
            default :
                break;
            }
<span class="nc bnc" id="L511" title="All 4 branches missed.">            while (sibling == null &amp;&amp; parentNode != null) {</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">                if (isVisible(parentNode)) {</span>
<span class="nc" id="L513">                    writer.write(END_TAG);</span>
<span class="nc" id="L514">                    UtfHelpper.writeByte(((Element)parentNode).getTagName(), writer, cache);</span>
<span class="nc" id="L515">                    writer.write('&gt;');</span>
                    //We finished with this level, pop to the previous definitions.
<span class="nc" id="L517">                    ns.outputNodePop();</span>
                } else {
<span class="nc" id="L519">                    ns.pop();</span>
                }
<span class="nc bnc" id="L521" title="All 2 branches missed.">                if (parentNode == endnode) {</span>
<span class="nc" id="L522">                    return;</span>
                }
<span class="nc" id="L524">                sibling = parentNode.getNextSibling();</span>
<span class="nc" id="L525">                parentNode = parentNode.getParentNode();</span>
<span class="nc bnc" id="L526" title="All 4 branches missed.">                if (parentNode == null || Node.ELEMENT_NODE != parentNode.getNodeType()) {</span>
<span class="nc" id="L527">                    parentNode = null;</span>
<span class="nc" id="L528">                    documentLevel = NODE_AFTER_DOCUMENT_ELEMENT;</span>
                }
            }
<span class="nc bnc" id="L531" title="All 2 branches missed.">            if (sibling == null) {</span>
<span class="nc" id="L532">                return;</span>
            }
<span class="nc" id="L534">            currentNode = sibling;</span>
<span class="nc" id="L535">            sibling = currentNode.getNextSibling();</span>
<span class="nc" id="L536">        } while(true);</span>
    }

    protected int isVisibleDO(Node currentNode, int level) {
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (nodeFilter != null) {</span>
<span class="nc" id="L541">            Iterator&lt;NodeFilter&gt; it = nodeFilter.iterator();</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L543">                int i = (it.next()).isNodeIncludeDO(currentNode, level);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">                if (i != 1) {</span>
<span class="nc" id="L545">                    return i;</span>
                }
<span class="nc" id="L547">            }</span>
        }
<span class="nc bnc" id="L549" title="All 4 branches missed.">        if ((this.xpathNodeSet != null) &amp;&amp; !this.xpathNodeSet.contains(currentNode)) {</span>
<span class="nc" id="L550">            return 0;</span>
        }
<span class="nc" id="L552">        return 1;</span>
    }

    protected int isVisibleInt(Node currentNode) {
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (nodeFilter != null) {</span>
<span class="nc" id="L557">            Iterator&lt;NodeFilter&gt; it = nodeFilter.iterator();</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L559">                int i = (it.next()).isNodeInclude(currentNode);</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                if (i != 1) {</span>
<span class="nc" id="L561">                    return i;</span>
                }
<span class="nc" id="L563">            }</span>
        }
<span class="nc bnc" id="L565" title="All 4 branches missed.">        if ((this.xpathNodeSet != null) &amp;&amp; !this.xpathNodeSet.contains(currentNode)) {</span>
<span class="nc" id="L566">            return 0;</span>
        }
<span class="nc" id="L568">        return 1;</span>
    }

    protected boolean isVisible(Node currentNode) {
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (nodeFilter != null) {</span>
<span class="nc" id="L573">            Iterator&lt;NodeFilter&gt; it = nodeFilter.iterator();</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">                if (it.next().isNodeInclude(currentNode) != 1) {</span>
<span class="nc" id="L576">                    return false;</span>
                }
            }
        }
<span class="nc bnc" id="L580" title="All 4 branches missed.">        if ((this.xpathNodeSet != null) &amp;&amp; !this.xpathNodeSet.contains(currentNode)) {</span>
<span class="nc" id="L581">            return false;</span>
        }
<span class="nc" id="L583">        return true;</span>
    }

    protected void handleParent(Element e, NameSpaceSymbTable ns) {
<span class="nc bnc" id="L587" title="All 4 branches missed.">        if (!e.hasAttributes() &amp;&amp; e.getNamespaceURI() == null) {</span>
<span class="nc" id="L588">            return;</span>
        }
<span class="nc" id="L590">        NamedNodeMap attrs = e.getAttributes();</span>
<span class="nc" id="L591">        int attrsLength = attrs.getLength();</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">        for (int i = 0; i &lt; attrsLength; i++) {</span>
<span class="nc" id="L593">            Attr attribute = (Attr) attrs.item(i);</span>
<span class="nc" id="L594">            String NName = attribute.getLocalName();</span>
<span class="nc" id="L595">            String NValue = attribute.getNodeValue();</span>

<span class="nc bnc" id="L597" title="All 2 branches missed.">            if (Constants.NamespaceSpecNS.equals(attribute.getNamespaceURI())</span>
<span class="nc bnc" id="L598" title="All 4 branches missed.">                &amp;&amp; (!XML.equals(NName) || !Constants.XML_LANG_SPACE_SpecNS.equals(NValue))) {</span>
<span class="nc" id="L599">                ns.addMapping(NName, NValue, attribute);</span>
            }
        }
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (e.getNamespaceURI() != null) {</span>
<span class="nc" id="L603">            String NName = e.getPrefix();</span>
<span class="nc" id="L604">            String NValue = e.getNamespaceURI();</span>
            String Name;
<span class="nc bnc" id="L606" title="All 4 branches missed.">            if (NName == null || NName.equals(&quot;&quot;)) {</span>
<span class="nc" id="L607">                NName = XMLNS;</span>
<span class="nc" id="L608">                Name = XMLNS;</span>
            } else {
<span class="nc" id="L610">                Name = XMLNS + &quot;:&quot; + NName;</span>
            }
<span class="nc" id="L612">            Attr n = e.getOwnerDocument().createAttributeNS(&quot;http://www.w3.org/2000/xmlns/&quot;, Name);</span>
<span class="nc" id="L613">            n.setValue(NValue);</span>
<span class="nc" id="L614">            ns.addMapping(NName, NValue, n);</span>
        }
<span class="nc" id="L616">    }</span>

    /**
     * Adds to ns the definitions from the parent elements of el
     * @param el
     * @param ns
     */
    protected final void getParentNameSpaces(Element el, NameSpaceSymbTable ns)  {
<span class="nc" id="L624">        Node n1 = el.getParentNode();</span>
<span class="nc bnc" id="L625" title="All 4 branches missed.">        if (n1 == null || Node.ELEMENT_NODE != n1.getNodeType()) {</span>
<span class="nc" id="L626">            return;</span>
        }
        //Obtain all the parents of the element
<span class="nc" id="L629">        List&lt;Element&gt; parents = new ArrayList&lt;Element&gt;();</span>
<span class="nc" id="L630">        Node parent = n1;</span>
<span class="nc bnc" id="L631" title="All 4 branches missed.">        while (parent != null &amp;&amp; Node.ELEMENT_NODE == parent.getNodeType()) {</span>
<span class="nc" id="L632">            parents.add((Element)parent);</span>
<span class="nc" id="L633">            parent = parent.getParentNode();</span>
        }
        //Visit them in reverse order.
<span class="nc" id="L636">        ListIterator&lt;Element&gt; it = parents.listIterator(parents.size());</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">        while (it.hasPrevious()) {</span>
<span class="nc" id="L638">            Element ele = it.previous();</span>
<span class="nc" id="L639">            handleParent(ele, ns);</span>
<span class="nc" id="L640">        }</span>
<span class="nc" id="L641">        parents.clear();</span>
        Attr nsprefix;
<span class="nc bnc" id="L643" title="All 2 branches missed.">        if (((nsprefix = ns.getMappingWithoutRendered(XMLNS)) != null)</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">            &amp;&amp; &quot;&quot;.equals(nsprefix.getValue())) {</span>
<span class="nc" id="L645">            ns.addMappingAndRender(XMLNS, &quot;&quot;, nullNode);</span>
        }
<span class="nc" id="L647">    }</span>

    /**
     * Obtain the attributes to output for this node in XPathNodeSet c14n.
     *
     * @param element
     * @param ns
     * @return the attributes nodes to output.
     * @throws CanonicalizationException
     */
    abstract Iterator&lt;Attr&gt; handleAttributes(Element element, NameSpaceSymbTable ns)
        throws CanonicalizationException;

    /**
     * Obtain the attributes to output for this node in a Subtree c14n.
     *
     * @param element
     * @param ns
     * @return the attributes nodes to output.
     * @throws CanonicalizationException
     */
    abstract Iterator&lt;Attr&gt; handleAttributesSubtree(Element element, NameSpaceSymbTable ns)
        throws CanonicalizationException;

    abstract void circumventBugIfNeeded(XMLSignatureInput input)
        throws CanonicalizationException, ParserConfigurationException, IOException, SAXException;

    /**
     * Outputs an Attribute to the internal Writer.
     *
     * The string value of the node is modified by replacing
     * &lt;UL&gt;
     * &lt;LI&gt;all ampersands (&amp;) with &lt;CODE&gt;&amp;amp;amp;&lt;/CODE&gt;&lt;/LI&gt;
     * &lt;LI&gt;all open angle brackets (&lt;) with &lt;CODE&gt;&amp;amp;lt;&lt;/CODE&gt;&lt;/LI&gt;
     * &lt;LI&gt;all quotation mark characters with &lt;CODE&gt;&amp;amp;quot;&lt;/CODE&gt;&lt;/LI&gt;
     * &lt;LI&gt;and the whitespace characters &lt;CODE&gt;#x9&lt;/CODE&gt;, #xA, and #xD, with character
     * references. The character references are written in uppercase
     * hexadecimal with no leading zeroes (for example, &lt;CODE&gt;#xD&lt;/CODE&gt; is represented
     * by the character reference &lt;CODE&gt;&amp;amp;#xD;&lt;/CODE&gt;)&lt;/LI&gt;
     * &lt;/UL&gt;
     *
     * @param name
     * @param value
     * @param writer
     * @throws IOException
     */
    protected static final void outputAttrToWriter(
        final String name, final String value,
        final OutputStream writer, final Map&lt;String, byte[]&gt; cache
    ) throws IOException {
<span class="nc" id="L697">        writer.write(' ');</span>
<span class="nc" id="L698">        UtfHelpper.writeByte(name, writer, cache);</span>
<span class="nc" id="L699">        writer.write(equalsStr);</span>
        byte[] toWrite;
<span class="nc" id="L701">        final int length = value.length();</span>
<span class="nc" id="L702">        int i = 0;</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">        while (i &lt; length) {</span>
<span class="nc" id="L704">            char c = value.charAt(i++);</span>

<span class="nc bnc" id="L706" title="All 7 branches missed.">            switch (c) {</span>

            case '&amp;' :
<span class="nc" id="L709">                toWrite = AMP;</span>
<span class="nc" id="L710">                break;</span>

            case '&lt;' :
<span class="nc" id="L713">                toWrite = LT;</span>
<span class="nc" id="L714">                break;</span>

            case '&quot;' :
<span class="nc" id="L717">                toWrite = QUOT;</span>
<span class="nc" id="L718">                break;</span>

            case 0x09 :    // '\t'
<span class="nc" id="L721">                toWrite = X9;</span>
<span class="nc" id="L722">                break;</span>

            case 0x0A :    // '\n'
<span class="nc" id="L725">                toWrite = XA;</span>
<span class="nc" id="L726">                break;</span>

            case 0x0D :    // '\r'
<span class="nc" id="L729">                toWrite = XD;</span>
<span class="nc" id="L730">                break;</span>

            default :
<span class="nc bnc" id="L733" title="All 2 branches missed.">                if (c &lt; 0x80) {</span>
<span class="nc" id="L734">                    writer.write(c);</span>
                } else {
<span class="nc" id="L736">                    UtfHelpper.writeCharToUtf8(c, writer);</span>
                }
<span class="nc" id="L738">                continue;</span>
            }
<span class="nc" id="L740">            writer.write(toWrite);</span>
<span class="nc" id="L741">        }</span>

<span class="nc" id="L743">        writer.write('\&quot;');</span>
<span class="nc" id="L744">    }</span>

    /**
     * Outputs a PI to the internal Writer.
     *
     * @param currentPI
     * @param writer where to write the things
     * @throws IOException
     */
    protected void outputPItoWriter(
        ProcessingInstruction currentPI, OutputStream writer, int position
    ) throws IOException {
<span class="nc bnc" id="L756" title="All 2 branches missed.">        if (position == NODE_AFTER_DOCUMENT_ELEMENT) {</span>
<span class="nc" id="L757">            writer.write('\n');</span>
        }
<span class="nc" id="L759">        writer.write(BEGIN_PI);</span>

<span class="nc" id="L761">        final String target = currentPI.getTarget();</span>
<span class="nc" id="L762">        int length = target.length();</span>

<span class="nc bnc" id="L764" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L765">            char c = target.charAt(i);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">            if (c == 0x0D) {</span>
<span class="nc" id="L767">                writer.write(XD);</span>
            } else {
<span class="nc bnc" id="L769" title="All 2 branches missed.">                if (c &lt; 0x80) {</span>
<span class="nc" id="L770">                    writer.write(c);</span>
                } else {
<span class="nc" id="L772">                    UtfHelpper.writeCharToUtf8(c, writer);</span>
                }
            }
        }

<span class="nc" id="L777">        final String data = currentPI.getData();</span>

<span class="nc" id="L779">        length = data.length();</span>

<span class="nc bnc" id="L781" title="All 2 branches missed.">        if (length &gt; 0) {</span>
<span class="nc" id="L782">            writer.write(' ');</span>

<span class="nc bnc" id="L784" title="All 2 branches missed.">            for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L785">                char c = data.charAt(i);</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">                if (c == 0x0D) {</span>
<span class="nc" id="L787">                    writer.write(XD);</span>
                } else {
<span class="nc" id="L789">                    UtfHelpper.writeCharToUtf8(c, writer);</span>
                }
            }
        }

<span class="nc" id="L794">        writer.write(END_PI);</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (position == NODE_BEFORE_DOCUMENT_ELEMENT) {</span>
<span class="nc" id="L796">            writer.write('\n');</span>
        }
<span class="nc" id="L798">    }</span>

    /**
     * Method outputCommentToWriter
     *
     * @param currentComment
     * @param writer writer where to write the things
     * @throws IOException
     */
    protected void outputCommentToWriter(
        Comment currentComment, OutputStream writer, int position
    ) throws IOException {
<span class="nc bnc" id="L810" title="All 2 branches missed.">        if (position == NODE_AFTER_DOCUMENT_ELEMENT) {</span>
<span class="nc" id="L811">            writer.write('\n');</span>
        }
<span class="nc" id="L813">        writer.write(BEGIN_COMM);</span>

<span class="nc" id="L815">        final String data = currentComment.getData();</span>
<span class="nc" id="L816">        final int length = data.length();</span>

<span class="nc bnc" id="L818" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L819">            char c = data.charAt(i);</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">            if (c == 0x0D) {</span>
<span class="nc" id="L821">                writer.write(XD);</span>
            } else {
<span class="nc bnc" id="L823" title="All 2 branches missed.">                if (c &lt; 0x80) {</span>
<span class="nc" id="L824">                    writer.write(c);</span>
                } else {
<span class="nc" id="L826">                    UtfHelpper.writeCharToUtf8(c, writer);</span>
                }
            }
        }

<span class="nc" id="L831">        writer.write(END_COMM);</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">        if (position == NODE_BEFORE_DOCUMENT_ELEMENT) {</span>
<span class="nc" id="L833">            writer.write('\n');</span>
        }
<span class="nc" id="L835">    }</span>

    /**
     * Outputs a Text of CDATA section to the internal Writer.
     *
     * @param text
     * @param writer writer where to write the things
     * @throws IOException
     */
    protected static final void outputTextToWriter(
        final String text, final OutputStream writer
    ) throws IOException {
<span class="nc" id="L847">        final int length = text.length();</span>
        byte[] toWrite;
<span class="nc bnc" id="L849" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L850">            char c = text.charAt(i);</span>

<span class="nc bnc" id="L852" title="All 5 branches missed.">            switch (c) {</span>

            case '&amp;' :
<span class="nc" id="L855">                toWrite = AMP;</span>
<span class="nc" id="L856">                break;</span>

            case '&lt;' :
<span class="nc" id="L859">                toWrite = LT;</span>
<span class="nc" id="L860">                break;</span>

            case '&gt;' :
<span class="nc" id="L863">                toWrite = GT;</span>
<span class="nc" id="L864">                break;</span>

            case 0xD :
<span class="nc" id="L867">                toWrite = XD;</span>
<span class="nc" id="L868">                break;</span>

            default :
<span class="nc bnc" id="L871" title="All 2 branches missed.">                if (c &lt; 0x80) {</span>
<span class="nc" id="L872">                    writer.write(c);</span>
                } else {
<span class="nc" id="L874">                    UtfHelpper.writeCharToUtf8(c, writer);</span>
                }
<span class="nc" id="L876">                continue;</span>
            }
<span class="nc" id="L878">            writer.write(toWrite);</span>
        }
<span class="nc" id="L880">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>