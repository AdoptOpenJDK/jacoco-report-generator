<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CompositeType.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.management.openmbean</a> &gt; <span class="el_source">CompositeType.java</span></div><h1>CompositeType.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package javax.management.openmbean;


// java import
//
import java.util.Set;
import java.util.TreeMap;
import java.util.Collections;
import java.util.Iterator;

// jmx import
//


/**
 * The &lt;code&gt;CompositeType&lt;/code&gt; class is the &lt;i&gt;open type&lt;/i&gt; class
 * whose instances describe the types of {@link CompositeData CompositeData} values.
 *
 *
 * @since 1.5
 */
public class CompositeType extends OpenType&lt;CompositeData&gt; {

    /* Serial version */
    static final long serialVersionUID = -5366242454346948798L;

    /**
     * @serial Sorted mapping of the item names to their descriptions
     */
    private TreeMap&lt;String,String&gt; nameToDescription;

    /**
     * @serial Sorted mapping of the item names to their open types
     */
    private TreeMap&lt;String,OpenType&lt;?&gt;&gt; nameToType;

    /* As this instance is immutable, following three values need only
     * be calculated once.  */
<span class="nc" id="L65">    private transient Integer myHashCode = null;</span>
<span class="nc" id="L66">    private transient String  myToString = null;</span>
<span class="nc" id="L67">    private transient Set&lt;String&gt; myNamesSet = null;</span>


    /* *** Constructor *** */

    /**
     * Constructs a &lt;code&gt;CompositeType&lt;/code&gt; instance, checking for the validity of the given parameters.
     * The validity constraints are described below for each parameter.
     * &lt;p&gt;
     * Note that the contents of the three array parameters
     * &lt;var&gt;itemNames&lt;/var&gt;, &lt;var&gt;itemDescriptions&lt;/var&gt; and &lt;var&gt;itemTypes&lt;/var&gt;
     * are internally copied so that any subsequent modification of these arrays by the caller of this constructor
     * has no impact on the constructed &lt;code&gt;CompositeType&lt;/code&gt; instance.
     * &lt;p&gt;
     * The Java class name of composite data values this composite type represents
     * (ie the class name returned by the {@link OpenType#getClassName() getClassName} method)
     * is set to the string value returned by &lt;code&gt;CompositeData.class.getName()&lt;/code&gt;.
     * &lt;p&gt;
     * @param  typeName  The name given to the composite type this instance represents; cannot be a null or empty string.
     * &lt;br&gt;&amp;nbsp;
     * @param  description  The human readable description of the composite type this instance represents;
     *                      cannot be a null or empty string.
     * &lt;br&gt;&amp;nbsp;
     * @param  itemNames  The names of the items contained in the
     *                    composite data values described by this &lt;code&gt;CompositeType&lt;/code&gt; instance;
     *                    cannot be null and should contain at least one element; no element can be a null or empty string.
     *                    Note that the order in which the item names are given is not important to differentiate a
     *                    &lt;code&gt;CompositeType&lt;/code&gt; instance from another;
     *                    the item names are internally stored sorted in ascending alphanumeric order.
     * &lt;br&gt;&amp;nbsp;
     * @param  itemDescriptions  The descriptions, in the same order as &lt;var&gt;itemNames&lt;/var&gt;, of the items contained in the
     *                           composite data values described by this &lt;code&gt;CompositeType&lt;/code&gt; instance;
     *                           should be of the same size as &lt;var&gt;itemNames&lt;/var&gt;;
     *                           no element can be null or an empty string.
     * &lt;br&gt;&amp;nbsp;
     * @param  itemTypes  The open type instances, in the same order as &lt;var&gt;itemNames&lt;/var&gt;, describing the items contained
     *                    in the composite data values described by this &lt;code&gt;CompositeType&lt;/code&gt; instance;
     *                    should be of the same size as &lt;var&gt;itemNames&lt;/var&gt;;
     *                    no element can be null.
     * &lt;br&gt;&amp;nbsp;
     * @throws IllegalArgumentException  If &lt;var&gt;typeName&lt;/var&gt; or &lt;var&gt;description&lt;/var&gt; is a null or empty string,
     *                                   or &lt;var&gt;itemNames&lt;/var&gt; or &lt;var&gt;itemDescriptions&lt;/var&gt; or &lt;var&gt;itemTypes&lt;/var&gt; is null,
     *                                   or any element of &lt;var&gt;itemNames&lt;/var&gt; or &lt;var&gt;itemDescriptions&lt;/var&gt;
     *                                   is a null or empty string,
     *                                   or any element of &lt;var&gt;itemTypes&lt;/var&gt; is null,
     *                                   or &lt;var&gt;itemNames&lt;/var&gt; or &lt;var&gt;itemDescriptions&lt;/var&gt; or &lt;var&gt;itemTypes&lt;/var&gt;
     *                                   are not of the same size.
     * &lt;br&gt;&amp;nbsp;
     * @throws OpenDataException  If &lt;var&gt;itemNames&lt;/var&gt; contains duplicate item names
     *                            (case sensitive, but leading and trailing whitespaces removed).
     */
    public CompositeType(String        typeName,
                         String        description,
                         String[]      itemNames,
                         String[]      itemDescriptions,
                         OpenType&lt;?&gt;[] itemTypes) throws OpenDataException {

        // Check and construct state defined by parent
        //
<span class="nc" id="L126">        super(CompositeData.class.getName(), typeName, description, false);</span>

        // Check the 3 arrays are not null or empty (ie length==0) and that there is no null element or empty string in them
        //
<span class="nc" id="L130">        checkForNullElement(itemNames, &quot;itemNames&quot;);</span>
<span class="nc" id="L131">        checkForNullElement(itemDescriptions, &quot;itemDescriptions&quot;);</span>
<span class="nc" id="L132">        checkForNullElement(itemTypes, &quot;itemTypes&quot;);</span>
<span class="nc" id="L133">        checkForEmptyString(itemNames, &quot;itemNames&quot;);</span>
<span class="nc" id="L134">        checkForEmptyString(itemDescriptions, &quot;itemDescriptions&quot;);</span>

        // Check the sizes of the 3 arrays are the same
        //
<span class="nc bnc" id="L138" title="All 4 branches missed.">        if ( (itemNames.length != itemDescriptions.length) || (itemNames.length != itemTypes.length) ) {</span>
<span class="nc" id="L139">            throw new IllegalArgumentException(&quot;Array arguments itemNames[], itemDescriptions[] and itemTypes[] &quot;+</span>
                                               &quot;should be of same length (got &quot;+ itemNames.length +&quot;, &quot;+
                                               itemDescriptions.length +&quot; and &quot;+ itemTypes.length +&quot;).&quot;);
        }

        // Initialize internal &quot;names to descriptions&quot; and &quot;names to types&quot; sorted maps,
        // and, by doing so, check there are no duplicate item names
        //
<span class="nc" id="L147">        nameToDescription = new TreeMap&lt;String,String&gt;();</span>
<span class="nc" id="L148">        nameToType        = new TreeMap&lt;String,OpenType&lt;?&gt;&gt;();</span>
        String key;
<span class="nc bnc" id="L150" title="All 2 branches missed.">        for (int i=0; i&lt;itemNames.length; i++) {</span>
<span class="nc" id="L151">            key = itemNames[i].trim();</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (nameToDescription.containsKey(key)) {</span>
<span class="nc" id="L153">                throw new OpenDataException(&quot;Argument's element itemNames[&quot;+ i +&quot;]=\&quot;&quot;+ itemNames[i] +</span>
                                            &quot;\&quot; duplicates a previous item names.&quot;);
            }
<span class="nc" id="L156">            nameToDescription.put(key, itemDescriptions[i].trim());</span>
<span class="nc" id="L157">            nameToType.put(key, itemTypes[i]);</span>
        }
<span class="nc" id="L159">    }</span>

    private static void checkForNullElement(Object[] arg, String argName) {
<span class="nc bnc" id="L162" title="All 4 branches missed.">        if ( (arg == null) || (arg.length == 0) ) {</span>
<span class="nc" id="L163">            throw new IllegalArgumentException(&quot;Argument &quot;+ argName +&quot;[] cannot be null or empty.&quot;);</span>
        }
<span class="nc bnc" id="L165" title="All 2 branches missed.">        for (int i=0; i&lt;arg.length; i++) {</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">            if (arg[i] == null) {</span>
<span class="nc" id="L167">                throw new IllegalArgumentException(&quot;Argument's element &quot;+ argName +&quot;[&quot;+ i +&quot;] cannot be null.&quot;);</span>
            }
        }
<span class="nc" id="L170">    }</span>

    private static void checkForEmptyString(String[] arg, String argName) {
<span class="nc bnc" id="L173" title="All 2 branches missed.">        for (int i=0; i&lt;arg.length; i++) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            if (arg[i].trim().equals(&quot;&quot;)) {</span>
<span class="nc" id="L175">                throw new IllegalArgumentException(&quot;Argument's element &quot;+ argName +&quot;[&quot;+ i +&quot;] cannot be an empty string.&quot;);</span>
            }
        }
<span class="nc" id="L178">    }</span>

    /* *** Composite type specific information methods *** */

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;CompositeType&lt;/code&gt; instance defines an item
     * whose name is &lt;var&gt;itemName&lt;/var&gt;.
     *
     * @param itemName the name of the item.
     *
     * @return true if an item of this name is present.
     */
    public boolean containsKey(String itemName) {

<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (itemName == null) {</span>
<span class="nc" id="L193">            return false;</span>
        }
<span class="nc" id="L195">        return nameToDescription.containsKey(itemName);</span>
    }

    /**
     * Returns the description of the item whose name is &lt;var&gt;itemName&lt;/var&gt;,
     * or &lt;code&gt;null&lt;/code&gt; if this &lt;code&gt;CompositeType&lt;/code&gt; instance does not define any item
     * whose name is &lt;var&gt;itemName&lt;/var&gt;.
     *
     * @param itemName the name of the item.
     *
     * @return the description.
     */
    public String getDescription(String itemName) {

<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (itemName == null) {</span>
<span class="nc" id="L210">            return null;</span>
        }
<span class="nc" id="L212">        return nameToDescription.get(itemName);</span>
    }

    /**
     * Returns the &lt;i&gt;open type&lt;/i&gt; of the item whose name is &lt;var&gt;itemName&lt;/var&gt;,
     * or &lt;code&gt;null&lt;/code&gt; if this &lt;code&gt;CompositeType&lt;/code&gt; instance does not define any item
     * whose name is &lt;var&gt;itemName&lt;/var&gt;.
     *
     * @param itemName the name of the time.
     *
     * @return the type.
     */
    public OpenType&lt;?&gt; getType(String itemName) {

<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (itemName == null) {</span>
<span class="nc" id="L227">            return null;</span>
        }
<span class="nc" id="L229">        return (OpenType&lt;?&gt;) nameToType.get(itemName);</span>
    }

    /**
     * Returns an unmodifiable Set view of all the item names defined by this &lt;code&gt;CompositeType&lt;/code&gt; instance.
     * The set's iterator will return the item names in ascending order.
     *
     * @return a {@link Set} of {@link String}.
     */
    public Set&lt;String&gt; keySet() {

        // Initializes myNamesSet on first call
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (myNamesSet == null) {</span>
<span class="nc" id="L242">            myNamesSet = Collections.unmodifiableSet(nameToDescription.keySet());</span>
        }

<span class="nc" id="L245">        return myNamesSet; // always return the same value</span>
    }


    /**
     * Tests whether &lt;var&gt;obj&lt;/var&gt; is a value which could be
     * described by this &lt;code&gt;CompositeType&lt;/code&gt; instance.
     *
     * &lt;p&gt;If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of
     * &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;,
     * &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;If &lt;var&gt;obj&lt;/var&gt; is an instance of
     * &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, then let
     * {@code ct} be its {@code CompositeType} as returned by {@link
     * CompositeData#getCompositeType()}.  The result is true if
     * {@code this} is &lt;em&gt;assignable from&lt;/em&gt; {@code ct}.  This
     * means that:&lt;/p&gt;
     *
     * &lt;ul&gt;
     * &lt;li&gt;{@link #getTypeName() this.getTypeName()} equals
     * {@code ct.getTypeName()}, and
     * &lt;li&gt;there are no item names present in {@code this} that are
     * not also present in {@code ct}, and
     * &lt;li&gt;for every item in {@code this}, its type is assignable from
     * the type of the corresponding item in {@code ct}.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;A {@code TabularType} is assignable from another {@code
     * TabularType} if they have the same {@linkplain
     * TabularType#getTypeName() typeName} and {@linkplain
     * TabularType#getIndexNames() index name list}, and the
     * {@linkplain TabularType#getRowType() row type} of the first is
     * assignable from the row type of the second.
     *
     * &lt;p&gt;An {@code ArrayType} is assignable from another {@code
     * ArrayType} if they have the same {@linkplain
     * ArrayType#getDimension() dimension}; and both are {@linkplain
     * ArrayType#isPrimitiveArray() primitive arrays} or neither is;
     * and the {@linkplain ArrayType#getElementOpenType() element
     * type} of the first is assignable from the element type of the
     * second.
     *
     * &lt;p&gt;In every other case, an {@code OpenType} is assignable from
     * another {@code OpenType} only if they are equal.&lt;/p&gt;
     *
     * &lt;p&gt;These rules mean that extra items can be added to a {@code
     * CompositeData} without making it invalid for a {@code CompositeType}
     * that does not have those items.&lt;/p&gt;
     *
     * @param  obj  the value whose open type is to be tested for compatibility
     * with this &lt;code&gt;CompositeType&lt;/code&gt; instance.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;var&gt;obj&lt;/var&gt; is a value for this
     * composite type, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isValue(Object obj) {

        // if obj is null or not CompositeData, return false
        //
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (!(obj instanceof CompositeData)) {</span>
<span class="nc" id="L306">            return false;</span>
        }

        // if obj is not a CompositeData, return false
        //
<span class="nc" id="L311">        CompositeData value = (CompositeData) obj;</span>

        // test value's CompositeType is assignable to this CompositeType instance
        //
<span class="nc" id="L315">        CompositeType valueType = value.getCompositeType();</span>
<span class="nc" id="L316">        return this.isAssignableFrom(valueType);</span>
    }

    /**
     * Tests whether values of the given type can be assigned to this
     * open type.  The result is true if the given type is also a
     * CompositeType with the same name ({@link #getTypeName()}), and
     * every item in this type is also present in the given type with
     * the same name and assignable type.  There can be additional
     * items in the given type, which are ignored.
     *
     * @param ot the type to be tested.
     *
     * @return true if {@code ot} is assignable to this open type.
     */
    @Override
    boolean isAssignableFrom(OpenType&lt;?&gt; ot) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (!(ot instanceof CompositeType))</span>
<span class="nc" id="L334">            return false;</span>
<span class="nc" id="L335">        CompositeType ct = (CompositeType) ot;</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (!ct.getTypeName().equals(getTypeName()))</span>
<span class="nc" id="L337">            return false;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        for (String key : keySet()) {</span>
<span class="nc" id="L339">            OpenType&lt;?&gt; otItemType = ct.getType(key);</span>
<span class="nc" id="L340">            OpenType&lt;?&gt; thisItemType = getType(key);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (otItemType == null ||</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                    !thisItemType.isAssignableFrom(otItemType))</span>
<span class="nc" id="L343">                return false;</span>
<span class="nc" id="L344">        }</span>
<span class="nc" id="L345">        return true;</span>
    }


    /* *** Methods overriden from class Object *** */

    /**
     * Compares the specified &lt;code&gt;obj&lt;/code&gt; parameter with this &lt;code&gt;CompositeType&lt;/code&gt; instance for equality.
     * &lt;p&gt;
     * Two &lt;code&gt;CompositeType&lt;/code&gt; instances are equal if and only if all of the following statements are true:
     * &lt;ul&gt;
     * &lt;li&gt;their type names are equal&lt;/li&gt;
     * &lt;li&gt;their items' names and types are equal&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;br&gt;&amp;nbsp;
     * @param  obj  the object to be compared for equality with this &lt;code&gt;CompositeType&lt;/code&gt; instance;
     *              if &lt;var&gt;obj&lt;/var&gt; is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;equals&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
     *
     * @return  &lt;code&gt;true&lt;/code&gt; if the specified object is equal to this &lt;code&gt;CompositeType&lt;/code&gt; instance.
     */
    public boolean equals(Object obj) {

        // if obj is null, return false
        //
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L370">            return false;</span>
        }

        // if obj is not a CompositeType, return false
        //
        CompositeType other;
        try {
<span class="nc" id="L377">            other = (CompositeType) obj;</span>
<span class="nc" id="L378">        } catch (ClassCastException e) {</span>
<span class="nc" id="L379">            return false;</span>
<span class="nc" id="L380">        }</span>

        // Now, really test for equality between this CompositeType instance and the other
        //

        // their names should be equal
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if ( ! this.getTypeName().equals(other.getTypeName()) ) {</span>
<span class="nc" id="L387">            return false;</span>
        }

        // their items names and types should be equal
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if ( ! this.nameToType.equals(other.nameToType) ) {</span>
<span class="nc" id="L392">            return false;</span>
        }

        // All tests for equality were successfull
        //
<span class="nc" id="L397">        return true;</span>
    }

    /**
     * Returns the hash code value for this &lt;code&gt;CompositeType&lt;/code&gt; instance.
     * &lt;p&gt;
     * The hash code of a &lt;code&gt;CompositeType&lt;/code&gt; instance is the sum of the hash codes
     * of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons
     * (ie: name, items names, items types).
     * This ensures that &lt;code&gt; t1.equals(t2) &lt;/code&gt; implies that &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt;
     * for any two &lt;code&gt;CompositeType&lt;/code&gt; instances &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;,
     * as required by the general contract of the method
     * {@link Object#hashCode() Object.hashCode()}.
     * &lt;p&gt;
     * As &lt;code&gt;CompositeType&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once,
     * on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.
     *
     * @return  the hash code value for this &lt;code&gt;CompositeType&lt;/code&gt; instance
     */
    public int hashCode() {

        // Calculate the hash code value if it has not yet been done (ie 1st call to hashCode())
        //
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (myHashCode == null) {</span>
<span class="nc" id="L421">            int value = 0;</span>
<span class="nc" id="L422">            value += this.getTypeName().hashCode();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            for (String key : nameToDescription.keySet()) {</span>
<span class="nc" id="L424">                value += key.hashCode();</span>
<span class="nc" id="L425">                value += this.nameToType.get(key).hashCode();</span>
<span class="nc" id="L426">            }</span>
<span class="nc" id="L427">            myHashCode = Integer.valueOf(value);</span>
        }

        // return always the same hash code for this instance (immutable)
        //
<span class="nc" id="L432">        return myHashCode.intValue();</span>
    }

    /**
     * Returns a string representation of this &lt;code&gt;CompositeType&lt;/code&gt; instance.
     * &lt;p&gt;
     * The string representation consists of
     * the name of this class (ie &lt;code&gt;javax.management.openmbean.CompositeType&lt;/code&gt;), the type name for this instance,
     * and the list of the items names and types string representation of this instance.
     * &lt;p&gt;
     * As &lt;code&gt;CompositeType&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once,
     * on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.
     *
     * @return  a string representation of this &lt;code&gt;CompositeType&lt;/code&gt; instance
     */
    public String toString() {

        // Calculate the string representation if it has not yet been done (ie 1st call to toString())
        //
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (myToString == null) {</span>
<span class="nc" id="L452">            final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L453">            result.append(this.getClass().getName());</span>
<span class="nc" id="L454">            result.append(&quot;(name=&quot;);</span>
<span class="nc" id="L455">            result.append(getTypeName());</span>
<span class="nc" id="L456">            result.append(&quot;,items=(&quot;);</span>
<span class="nc" id="L457">            int i=0;</span>
<span class="nc" id="L458">            Iterator&lt;String&gt; k=nameToType.keySet().iterator();</span>
            String key;
<span class="nc bnc" id="L460" title="All 2 branches missed.">            while (k.hasNext()) {</span>
<span class="nc" id="L461">                key = k.next();</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                if (i &gt; 0) result.append(&quot;,&quot;);</span>
<span class="nc" id="L463">                result.append(&quot;(itemName=&quot;);</span>
<span class="nc" id="L464">                result.append(key);</span>
<span class="nc" id="L465">                result.append(&quot;,itemType=&quot;);</span>
<span class="nc" id="L466">                result.append(nameToType.get(key).toString() +&quot;)&quot;);</span>
<span class="nc" id="L467">                i++;</span>
            }
<span class="nc" id="L469">            result.append(&quot;))&quot;);</span>
<span class="nc" id="L470">            myToString = result.toString();</span>
        }

        // return always the same string representation for this instance (immutable)
        //
<span class="nc" id="L475">        return myToString;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>