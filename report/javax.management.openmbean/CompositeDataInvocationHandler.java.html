<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CompositeDataInvocationHandler.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.management.openmbean</a> &gt; <span class="el_source">CompositeDataInvocationHandler.java</span></div><h1>CompositeDataInvocationHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management.openmbean;

import com.sun.jmx.mbeanserver.MXBeanLookup;
import com.sun.jmx.mbeanserver.MXBeanMapping;
import com.sun.jmx.mbeanserver.MXBeanMappingFactory;
import com.sun.jmx.mbeanserver.DefaultMXBeanMappingFactory;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
   &lt;p&gt;An {@link InvocationHandler} that forwards getter methods to a
   {@link CompositeData}.  If you have an interface that contains
   only getter methods (such as {@code String getName()} or
   {@code boolean isActive()}) then you can use this class in
   conjunction with the {@link Proxy} class to produce an implementation
   of the interface where each getter returns the value of the
   corresponding item in a {@code CompositeData}.&lt;/p&gt;

   &lt;p&gt;For example, suppose you have an interface like this:

   &lt;blockquote&gt;
   &lt;pre&gt;
   public interface NamedNumber {
       public int getNumber();
       public String getName();
   }
   &lt;/pre&gt;
   &lt;/blockquote&gt;

   and a {@code CompositeData} constructed like this:

   &lt;blockquote&gt;
   &lt;pre&gt;
   CompositeData cd =
       new {@link CompositeDataSupport}(
           someCompositeType,
           new String[] {&quot;number&quot;, &quot;name&quot;},
           new Object[] {&lt;b&gt;5&lt;/b&gt;, &quot;five&quot;}
       );
   &lt;/pre&gt;
   &lt;/blockquote&gt;

   then you can construct an object implementing {@code NamedNumber}
   and backed by the object {@code cd} like this:

   &lt;blockquote&gt;
   &lt;pre&gt;
   InvocationHandler handler =
       new CompositeDataInvocationHandler(cd);
   NamedNumber nn = (NamedNumber)
       Proxy.newProxyInstance(NamedNumber.class.getClassLoader(),
                              new Class[] {NamedNumber.class},
                              handler);
   &lt;/pre&gt;
   &lt;/blockquote&gt;

   A call to {@code nn.getNumber()} will then return &lt;b&gt;5&lt;/b&gt;.

   &lt;p&gt;If the first letter of the property defined by a getter is a
   capital, then this handler will look first for an item in the
   {@code CompositeData} beginning with a capital, then, if that is
   not found, for an item beginning with the corresponding lowercase
   letter or code point.  For a getter called {@code getNumber()}, the
   handler will first look for an item called {@code Number}, then for
   {@code number}.  If the getter is called {@code getnumber()}, then
   the item must be called {@code number}.&lt;/p&gt;

   &lt;p&gt;If the method given to {@link #invoke invoke} is the method
   {@code boolean equals(Object)} inherited from {@code Object}, then
   it will return true if and only if the argument is a {@code Proxy}
   whose {@code InvocationHandler} is also a {@code
   CompositeDataInvocationHandler} and whose backing {@code
   CompositeData} is equal (not necessarily identical) to this
   object's.  If the method given to {@code invoke} is the method
   {@code int hashCode()} inherited from {@code Object}, then it will
   return a value that is consistent with this definition of {@code
   equals}: if two objects are equal according to {@code equals}, then
   they will have the same {@code hashCode}.&lt;/p&gt;

   @since 1.6
*/
<span class="nc bnc" id="L108" title="All 2 branches missed.">public class CompositeDataInvocationHandler implements InvocationHandler {</span>
    /**
       &lt;p&gt;Construct a handler backed by the given {@code
       CompositeData}.&lt;/p&gt;

       @param compositeData the {@code CompositeData} that will supply
       information to getters.

       @throws IllegalArgumentException if {@code compositeData}
       is null.
    */
    public CompositeDataInvocationHandler(CompositeData compositeData) {
<span class="nc" id="L120">        this(compositeData, null);</span>
<span class="nc" id="L121">    }</span>

    /**
       &lt;p&gt;Construct a handler backed by the given {@code
       CompositeData}.&lt;/p&gt;

       @param compositeData the {@code CompositeData} that will supply
       information to getters.

       @throws IllegalArgumentException if {@code compositeData}
       is null.
    */
    CompositeDataInvocationHandler(CompositeData compositeData,
<span class="nc" id="L134">                                   MXBeanLookup lookup) {</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (compositeData == null)</span>
<span class="nc" id="L136">            throw new IllegalArgumentException(&quot;compositeData&quot;);</span>
<span class="nc" id="L137">        this.compositeData = compositeData;</span>
<span class="nc" id="L138">        this.lookup = lookup;</span>
<span class="nc" id="L139">    }</span>

    /**
       Return the {@code CompositeData} that was supplied to the
       constructor.
       @return the {@code CompositeData} that this handler is backed
       by.  This is never null.
    */
    public CompositeData getCompositeData() {
<span class="nc bnc" id="L148" title="All 4 branches missed.">        assert compositeData != null;</span>
<span class="nc" id="L149">        return compositeData;</span>
    }

    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
<span class="nc" id="L154">        final String methodName = method.getName();</span>

        // Handle the methods from java.lang.Object
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (method.getDeclaringClass() == Object.class) {</span>
<span class="nc bnc" id="L158" title="All 4 branches missed.">            if (methodName.equals(&quot;toString&quot;) &amp;&amp; args == null)</span>
<span class="nc" id="L159">                return &quot;Proxy[&quot; + compositeData + &quot;]&quot;;</span>
<span class="nc bnc" id="L160" title="All 4 branches missed.">            else if (methodName.equals(&quot;hashCode&quot;) &amp;&amp; args == null)</span>
<span class="nc" id="L161">                return compositeData.hashCode() + 0x43444948;</span>
<span class="nc bnc" id="L162" title="All 4 branches missed.">            else if (methodName.equals(&quot;equals&quot;) &amp;&amp; args.length == 1</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">                &amp;&amp; method.getParameterTypes()[0] == Object.class)</span>
<span class="nc" id="L164">                return equals(proxy, args[0]);</span>
            else {
                /* Either someone is calling invoke by hand, or
                   it is a non-final method from Object overriden
                   by the generated Proxy.  At the time of writing,
                   the only non-final methods in Object that are not
                   handled above are finalize and clone, and these
                   are not overridden in generated proxies.  */
                // this plain Method.invoke is called only if the declaring class
                // is Object and so it's safe.
<span class="nc" id="L174">                return method.invoke(this, args);</span>
            }
        }

<span class="nc" id="L178">        String propertyName = DefaultMXBeanMappingFactory.propertyName(method);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (propertyName == null) {</span>
<span class="nc" id="L180">            throw new IllegalArgumentException(&quot;Method is not getter: &quot; +</span>
<span class="nc" id="L181">                                               method.getName());</span>
        }
        Object openValue;
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (compositeData.containsKey(propertyName))</span>
<span class="nc" id="L185">            openValue = compositeData.get(propertyName);</span>
        else {
<span class="nc" id="L187">            String decap = DefaultMXBeanMappingFactory.decapitalize(propertyName);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (compositeData.containsKey(decap))</span>
<span class="nc" id="L189">                openValue = compositeData.get(decap);</span>
            else {
<span class="nc" id="L191">                final String msg =</span>
                    &quot;No CompositeData item &quot; + propertyName +
<span class="nc bnc" id="L193" title="All 2 branches missed.">                    (decap.equals(propertyName) ? &quot;&quot; : &quot; or &quot; + decap) +</span>
                    &quot; to match &quot; + methodName;
<span class="nc" id="L195">                throw new IllegalArgumentException(msg);</span>
            }
        }
<span class="nc" id="L198">        MXBeanMapping mapping =</span>
<span class="nc" id="L199">            MXBeanMappingFactory.DEFAULT.mappingForType(method.getGenericReturnType(),</span>
                                   MXBeanMappingFactory.DEFAULT);
<span class="nc" id="L201">        return mapping.fromOpenValue(openValue);</span>
    }

    /* This method is called when equals(Object) is
     * called on our proxy and hence forwarded to us.  For example, if we
     * are a proxy for an interface like this:
     * public interface GetString {
     *     public String string();
     * }
     * then we must compare equal to another CompositeDataInvocationHandler
     * proxy for the same interface and where string() returns the same value.
     *
     * You might think that we should also compare equal to another
     * object that implements GetString directly rather than using
     * Proxy, provided that its string() returns the same result as
     * ours, and in fact an earlier version of this class did that (by
     * converting the other object into a CompositeData and comparing
     * that with ours).  But in fact that doesn't make a great deal of
     * sense because there's absolutely no guarantee that the
     * resulting equals would be reflexive (otherObject.equals(this)
     * might be false even if this.equals(otherObject) is true), and,
     * especially, there's no way we could generate a hashCode() that
     * would be equal to otherObject.hashCode() when
     * this.equals(otherObject), because we don't know how
     * otherObject.hashCode() is computed.
     */
    private boolean equals(Object proxy, Object other) {
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (other == null)</span>
<span class="nc" id="L229">            return false;</span>

<span class="nc" id="L231">        final Class&lt;?&gt; proxyClass = proxy.getClass();</span>
<span class="nc" id="L232">        final Class&lt;?&gt; otherClass = other.getClass();</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (proxyClass != otherClass)</span>
<span class="nc" id="L234">            return false;</span>
<span class="nc" id="L235">        InvocationHandler otherih = Proxy.getInvocationHandler(other);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (!(otherih instanceof CompositeDataInvocationHandler))</span>
<span class="nc" id="L237">            return false;</span>
<span class="nc" id="L238">        CompositeDataInvocationHandler othercdih =</span>
            (CompositeDataInvocationHandler) otherih;
<span class="nc" id="L240">        return compositeData.equals(othercdih.compositeData);</span>
    }

    private final CompositeData compositeData;
    private final MXBeanLookup lookup;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>