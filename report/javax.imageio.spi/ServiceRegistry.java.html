<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ServiceRegistry.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.imageio.spi</a> &gt; <span class="el_source">ServiceRegistry.java</span></div><h1>ServiceRegistry.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio.spi;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.ServiceLoader;

/**
 * A registry for service provider instances.
 *
 * &lt;p&gt; A &lt;i&gt;service&lt;/i&gt; is a well-known set of interfaces and (usually
 * abstract) classes.  A &lt;i&gt;service provider&lt;/i&gt; is a specific
 * implementation of a service.  The classes in a provider typically
 * implement the interface or subclass the class defined by the
 * service itself.
 *
 * &lt;p&gt; Service providers are stored in one or more &lt;i&gt;categories&lt;/i&gt;,
 * each of which is defined by a class of interface (described by a
 * &lt;code&gt;Class&lt;/code&gt; object) that all of its members must implement.
 * The set of categories may be changed dynamically.
 *
 * &lt;p&gt; Only a single instance of a given leaf class (that is, the
 * actual class returned by &lt;code&gt;getClass()&lt;/code&gt;, as opposed to any
 * inherited classes or interfaces) may be registered.  That is,
 * suppose that the
 * &lt;code&gt;com.mycompany.mypkg.GreenServiceProvider&lt;/code&gt; class
 * implements the &lt;code&gt;com.mycompany.mypkg.MyService&lt;/code&gt;
 * interface.  If a &lt;code&gt;GreenServiceProvider&lt;/code&gt; instance is
 * registered, it will be stored in the category defined by the
 * &lt;code&gt;MyService&lt;/code&gt; class.  If a new instance of
 * &lt;code&gt;GreenServiceProvider&lt;/code&gt; is registered, it will replace
 * the previous instance.  In practice, service provider objects are
 * usually singletons so this behavior is appropriate.
 *
 * &lt;p&gt; To declare a service provider, a &lt;code&gt;services&lt;/code&gt;
 * subdirectory is placed within the &lt;code&gt;META-INF&lt;/code&gt; directory
 * that is present in every JAR file.  This directory contains a file
 * for each service provider interface that has one or more
 * implementation classes present in the JAR file.  For example, if
 * the JAR file contained a class named
 * &lt;code&gt;com.mycompany.mypkg.MyServiceImpl&lt;/code&gt; which implements the
 * &lt;code&gt;javax.someapi.SomeService&lt;/code&gt; interface, the JAR file
 * would contain a file named: &lt;pre&gt;
 * META-INF/services/javax.someapi.SomeService &lt;/pre&gt;
 *
 * containing the line:
 *
 * &lt;pre&gt;
 * com.mycompany.mypkg.MyService
 * &lt;/pre&gt;
 *
 * &lt;p&gt; The service provider classes should be to be lightweight and
 * quick to load.  Implementations of these interfaces should avoid
 * complex dependencies on other classes and on native code. The usual
 * pattern for more complex services is to register a lightweight
 * proxy for the heavyweight service.
 *
 * &lt;p&gt; An application may customize the contents of a registry as it
 * sees fit, so long as it has the appropriate runtime permission.
 *
 * &lt;p&gt; For more details on declaring service providers, and the JAR
 * format in general, see the &lt;a
 * href=&quot;../../../../technotes/guides/jar/jar.html&quot;&gt;
 * JAR File Specification&lt;/a&gt;.
 *
 * @see RegisterableService
 *
 */
public class ServiceRegistry {

    // Class -&gt; Registry
<span class="fc" id="L102">    private Map categoryMap = new HashMap();</span>

    /**
     * Constructs a &lt;code&gt;ServiceRegistry&lt;/code&gt; instance with a
     * set of categories taken from the &lt;code&gt;categories&lt;/code&gt;
     * argument.
     *
     * @param categories an &lt;code&gt;Iterator&lt;/code&gt; containing
     * &lt;code&gt;Class&lt;/code&gt; objects to be used to define categories.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;categories&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     */
<span class="fc" id="L115">    public ServiceRegistry(Iterator&lt;Class&lt;?&gt;&gt; categories) {</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (categories == null) {</span>
<span class="nc" id="L117">            throw new IllegalArgumentException(&quot;categories == null!&quot;);</span>
        }
<span class="fc bfc" id="L119" title="All 2 branches covered.">        while (categories.hasNext()) {</span>
<span class="fc" id="L120">            Class category = (Class)categories.next();</span>
<span class="fc" id="L121">            SubRegistry reg = new SubRegistry(this, category);</span>
<span class="fc" id="L122">            categoryMap.put(category, reg);</span>
<span class="fc" id="L123">        }</span>
<span class="fc" id="L124">    }</span>

    // The following two methods expose functionality from
    // sun.misc.Service.  If that class is made public, they may be
    // removed.
    //
    // The sun.misc.ServiceConfigurationError class may also be
    // exposed, in which case the references to 'an
    // &lt;code&gt;Error&lt;/code&gt;' below should be changed to 'a
    // &lt;code&gt;ServiceConfigurationError&lt;/code&gt;'.

    /**
     * Searches for implementations of a particular service class
     * using the given class loader.
     *
     * &lt;p&gt; This method transforms the name of the given service class
     * into a provider-configuration filename as described in the
     * class comment and then uses the &lt;code&gt;getResources&lt;/code&gt;
     * method of the given class loader to find all available files
     * with that name.  These files are then read and parsed to
     * produce a list of provider-class names.  The iterator that is
     * returned uses the given class loader to look up and then
     * instantiate each element of the list.
     *
     * &lt;p&gt; Because it is possible for extensions to be installed into
     * a running Java virtual machine, this method may return
     * different results each time it is invoked.
     *
     * @param providerClass a &lt;code&gt;Class&lt;/code&gt;object indicating the
     * class or interface of the service providers being detected.
     *
     * @param loader the class loader to be used to load
     * provider-configuration files and instantiate provider classes,
     * or &lt;code&gt;null&lt;/code&gt; if the system class loader (or, failing that
     * the bootstrap class loader) is to be used.
     *
     * @param &lt;T&gt; the type of the providerClass.
     *
     * @return An &lt;code&gt;Iterator&lt;/code&gt; that yields provider objects
     * for the given service, in some arbitrary order.  The iterator
     * will throw an &lt;code&gt;Error&lt;/code&gt; if a provider-configuration
     * file violates the specified format or if a provider class
     * cannot be found and instantiated.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;providerClass&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     */
    public static &lt;T&gt; Iterator&lt;T&gt; lookupProviders(Class&lt;T&gt; providerClass,
                                                  ClassLoader loader)
    {
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (providerClass == null) {</span>
<span class="nc" id="L175">            throw new IllegalArgumentException(&quot;providerClass == null!&quot;);</span>
        }
<span class="nc" id="L177">        return ServiceLoader.load(providerClass, loader).iterator();</span>
    }

    /**
     * Locates and incrementally instantiates the available providers
     * of a given service using the context class loader.  This
     * convenience method is equivalent to:
     *
     * &lt;pre&gt;
     *   ClassLoader cl = Thread.currentThread().getContextClassLoader();
     *   return Service.providers(service, cl);
     * &lt;/pre&gt;
     *
     * @param providerClass a &lt;code&gt;Class&lt;/code&gt;object indicating the
     * class or interface of the service providers being detected.
     *
     * @param &lt;T&gt; the type of the providerClass.
     *
     * @return An &lt;code&gt;Iterator&lt;/code&gt; that yields provider objects
     * for the given service, in some arbitrary order.  The iterator
     * will throw an &lt;code&gt;Error&lt;/code&gt; if a provider-configuration
     * file violates the specified format or if a provider class
     * cannot be found and instantiated.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;providerClass&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     */
    public static &lt;T&gt; Iterator&lt;T&gt; lookupProviders(Class&lt;T&gt; providerClass) {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (providerClass == null) {</span>
<span class="nc" id="L206">            throw new IllegalArgumentException(&quot;providerClass == null!&quot;);</span>
        }
<span class="nc" id="L208">        return ServiceLoader.load(providerClass).iterator();</span>
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; of &lt;code&gt;Class&lt;/code&gt; objects
     * indicating the current set of categories.  The iterator will be
     * empty if no categories exist.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing
     * &lt;code&gt;Class&lt;/code&gt;objects.
     */
    public Iterator&lt;Class&lt;?&gt;&gt; getCategories() {
<span class="fc" id="L220">        Set keySet = categoryMap.keySet();</span>
<span class="fc" id="L221">        return keySet.iterator();</span>
    }

    /**
     * Returns an Iterator containing the subregistries to which the
     * provider belongs.
     */
    private Iterator getSubRegistries(Object provider) {
<span class="fc" id="L229">        List l = new ArrayList();</span>
<span class="fc" id="L230">        Iterator iter = categoryMap.keySet().iterator();</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L232">            Class c = (Class)iter.next();</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">            if (c.isAssignableFrom(provider.getClass())) {</span>
<span class="fc" id="L234">                l.add((SubRegistry)categoryMap.get(c));</span>
            }
<span class="fc" id="L236">        }</span>
<span class="fc" id="L237">        return l.iterator();</span>
    }

    /**
     * Adds a service provider object to the registry.  The provider
     * is associated with the given category.
     *
     * &lt;p&gt; If &lt;code&gt;provider&lt;/code&gt; implements the
     * &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
     * &lt;code&gt;onRegistration&lt;/code&gt; method will be called.  Its
     * &lt;code&gt;onDeregistration&lt;/code&gt; method will be called each time
     * it is deregistered from a category, for example if a
     * category is removed or the registry is garbage collected.
     *
     * @param provider the service provide object to be registered.
     * @param category the category under which to register the
     * provider.
     * @param &lt;T&gt; the type of the provider.
     *
     * @return true if no provider of the same class was previously
     * registered in the same category category.
     *
     * @exception IllegalArgumentException if &lt;code&gt;provider&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     * @exception ClassCastException if provider does not implement
     * the &lt;code&gt;Class&lt;/code&gt; defined by &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; boolean registerServiceProvider(T provider,
                                               Class&lt;T&gt; category) {
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L269">            throw new IllegalArgumentException(&quot;provider == null!&quot;);</span>
        }
<span class="nc" id="L271">        SubRegistry reg = (SubRegistry)categoryMap.get(category);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (reg == null) {</span>
<span class="nc" id="L273">            throw new IllegalArgumentException(&quot;category unknown!&quot;);</span>
        }
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (!category.isAssignableFrom(provider.getClass())) {</span>
<span class="nc" id="L276">            throw new ClassCastException();</span>
        }

<span class="nc" id="L279">        return reg.registerServiceProvider(provider);</span>
    }

    /**
     * Adds a service provider object to the registry.  The provider
     * is associated within each category present in the registry
     * whose &lt;code&gt;Class&lt;/code&gt; it implements.
     *
     * &lt;p&gt; If &lt;code&gt;provider&lt;/code&gt; implements the
     * &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
     * &lt;code&gt;onRegistration&lt;/code&gt; method will be called once for each
     * category it is registered under.  Its
     * &lt;code&gt;onDeregistration&lt;/code&gt; method will be called each time
     * it is deregistered from a category or when the registry is
     * finalized.
     *
     * @param provider the service provider object to be registered.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;provider&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     */
    public void registerServiceProvider(Object provider) {
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L302">            throw new IllegalArgumentException(&quot;provider == null!&quot;);</span>
        }
<span class="fc" id="L304">        Iterator regs = getSubRegistries(provider);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        while (regs.hasNext()) {</span>
<span class="fc" id="L306">            SubRegistry reg = (SubRegistry)regs.next();</span>
<span class="fc" id="L307">            reg.registerServiceProvider(provider);</span>
<span class="fc" id="L308">        }</span>
<span class="fc" id="L309">    }</span>

    /**
     * Adds a set of service provider objects, taken from an
     * &lt;code&gt;Iterator&lt;/code&gt; to the registry.  Each provider is
     * associated within each category present in the registry whose
     * &lt;code&gt;Class&lt;/code&gt; it implements.
     *
     * &lt;p&gt; For each entry of &lt;code&gt;providers&lt;/code&gt; that implements
     * the &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
     * &lt;code&gt;onRegistration&lt;/code&gt; method will be called once for each
     * category it is registered under.  Its
     * &lt;code&gt;onDeregistration&lt;/code&gt; method will be called each time
     * it is deregistered from a category or when the registry is
     * finalized.
     *
     * @param providers an Iterator containing service provider
     * objects to be registered.
     *
     * @exception IllegalArgumentException if &lt;code&gt;providers&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt; or contains a &lt;code&gt;null&lt;/code&gt; entry.
     */
    public void registerServiceProviders(Iterator&lt;?&gt; providers) {
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (providers == null) {</span>
<span class="nc" id="L333">            throw new IllegalArgumentException(&quot;provider == null!&quot;);</span>
        }
<span class="nc bnc" id="L335" title="All 2 branches missed.">        while (providers.hasNext()) {</span>
<span class="nc" id="L336">            registerServiceProvider(providers.next());</span>
        }
<span class="nc" id="L338">    }</span>

    /**
     * Removes a service provider object from the given category.  If
     * the provider was not previously registered, nothing happens and
     * &lt;code&gt;false&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;true&lt;/code&gt;
     * is returned.  If an object of the same class as
     * &lt;code&gt;provider&lt;/code&gt; but not equal (using &lt;code&gt;==&lt;/code&gt;) to
     * &lt;code&gt;provider&lt;/code&gt; is registered, it will not be
     * deregistered.
     *
     * &lt;p&gt; If &lt;code&gt;provider&lt;/code&gt; implements the
     * &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
     * &lt;code&gt;onDeregistration&lt;/code&gt; method will be called.
     *
     * @param provider the service provider object to be deregistered.
     * @param category the category from which to deregister the
     * provider.
     * @param &lt;T&gt; the type of the provider.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the provider was previously
     * registered in the same category category,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @exception IllegalArgumentException if &lt;code&gt;provider&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     * @exception ClassCastException if provider does not implement
     * the class defined by &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; boolean deregisterServiceProvider(T provider,
                                                 Class&lt;T&gt; category) {
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L372">            throw new IllegalArgumentException(&quot;provider == null!&quot;);</span>
        }
<span class="nc" id="L374">        SubRegistry reg = (SubRegistry)categoryMap.get(category);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (reg == null) {</span>
<span class="nc" id="L376">            throw new IllegalArgumentException(&quot;category unknown!&quot;);</span>
        }
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (!category.isAssignableFrom(provider.getClass())) {</span>
<span class="nc" id="L379">            throw new ClassCastException();</span>
        }
<span class="nc" id="L381">        return reg.deregisterServiceProvider(provider);</span>
    }

    /**
     * Removes a service provider object from all categories that
     * contain it.
     *
     * @param provider the service provider object to be deregistered.
     *
     * @exception IllegalArgumentException if &lt;code&gt;provider&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public void deregisterServiceProvider(Object provider) {
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L395">            throw new IllegalArgumentException(&quot;provider == null!&quot;);</span>
        }
<span class="nc" id="L397">        Iterator regs = getSubRegistries(provider);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        while (regs.hasNext()) {</span>
<span class="nc" id="L399">            SubRegistry reg = (SubRegistry)regs.next();</span>
<span class="nc" id="L400">            reg.deregisterServiceProvider(provider);</span>
<span class="nc" id="L401">        }</span>
<span class="nc" id="L402">    }</span>

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;provider&lt;/code&gt; is currently
     * registered.
     *
     * @param provider the service provider object to be queried.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the given provider has been
     * registered.
     *
     * @exception IllegalArgumentException if &lt;code&gt;provider&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public boolean contains(Object provider) {
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L418">            throw new IllegalArgumentException(&quot;provider == null!&quot;);</span>
        }
<span class="nc" id="L420">        Iterator regs = getSubRegistries(provider);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        while (regs.hasNext()) {</span>
<span class="nc" id="L422">            SubRegistry reg = (SubRegistry)regs.next();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            if (reg.contains(provider)) {</span>
<span class="nc" id="L424">                return true;</span>
            }
<span class="nc" id="L426">        }</span>

<span class="nc" id="L428">        return false;</span>
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all registered
     * service providers in the given category.  If
     * &lt;code&gt;useOrdering&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the iterator
     * will return all of the server provider objects in an arbitrary
     * order.  Otherwise, the ordering will respect any pairwise
     * orderings that have been set.  If the graph of pairwise
     * orderings contains cycles, any providers that belong to a cycle
     * will not be returned.
     *
     * @param category the category to be retrieved from.
     * @param useOrdering &lt;code&gt;true&lt;/code&gt; if pairwise orderings
     * should be taken account in ordering the returned objects.
     * @param &lt;T&gt; the type of the category.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing service provider
     * objects from the given category, possibly in order.
     *
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; Iterator&lt;T&gt; getServiceProviders(Class&lt;T&gt; category,
                                               boolean useOrdering) {
<span class="fc" id="L454">        SubRegistry reg = (SubRegistry)categoryMap.get(category);</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (reg == null) {</span>
<span class="nc" id="L456">            throw new IllegalArgumentException(&quot;category unknown!&quot;);</span>
        }
<span class="fc" id="L458">        return reg.getServiceProviders(useOrdering);</span>
    }

    /**
     * A simple filter interface used by
     * &lt;code&gt;ServiceRegistry.getServiceProviders&lt;/code&gt; to select
     * providers matching an arbitrary criterion.  Classes that
     * implement this interface should be defined in order to make use
     * of the &lt;code&gt;getServiceProviders&lt;/code&gt; method of
     * &lt;code&gt;ServiceRegistry&lt;/code&gt; that takes a &lt;code&gt;Filter&lt;/code&gt;.
     *
     * @see ServiceRegistry#getServiceProviders(Class, ServiceRegistry.Filter, boolean)
     */
    public interface Filter {

        /**
         * Returns &lt;code&gt;true&lt;/code&gt; if the given
         * &lt;code&gt;provider&lt;/code&gt; object matches the criterion defined
         * by this &lt;code&gt;Filter&lt;/code&gt;.
         *
         * @param provider a service provider &lt;code&gt;Object&lt;/code&gt;.
         *
         * @return true if the provider matches the criterion.
         */
        boolean filter(Object provider);
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing service provider
     * objects within a given category that satisfy a criterion
     * imposed by the supplied &lt;code&gt;ServiceRegistry.Filter&lt;/code&gt;
     * object's &lt;code&gt;filter&lt;/code&gt; method.
     *
     * &lt;p&gt; The &lt;code&gt;useOrdering&lt;/code&gt; argument controls the
     * ordering of the results using the same rules as
     * &lt;code&gt;getServiceProviders(Class, boolean)&lt;/code&gt;.
     *
     * @param category the category to be retrieved from.
     * @param filter an instance of &lt;code&gt;ServiceRegistry.Filter&lt;/code&gt;
     * whose &lt;code&gt;filter&lt;/code&gt; method will be invoked.
     * @param useOrdering &lt;code&gt;true&lt;/code&gt; if pairwise orderings
     * should be taken account in ordering the returned objects.
     * @param &lt;T&gt; the type of the category.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing service provider
     * objects from the given category, possibly in order.
     *
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; Iterator&lt;T&gt; getServiceProviders(Class&lt;T&gt; category,
                                               Filter filter,
                                               boolean useOrdering) {
<span class="fc" id="L511">        SubRegistry reg = (SubRegistry)categoryMap.get(category);</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        if (reg == null) {</span>
<span class="nc" id="L513">            throw new IllegalArgumentException(&quot;category unknown!&quot;);</span>
        }
<span class="fc" id="L515">        Iterator iter = getServiceProviders(category, useOrdering);</span>
<span class="fc" id="L516">        return new FilterIterator(iter, filter);</span>
    }

    /**
     * Returns the currently registered service provider object that
     * is of the given class type.  At most one object of a given
     * class is allowed to be registered at any given time.  If no
     * registered object has the desired class type, &lt;code&gt;null&lt;/code&gt;
     * is returned.
     *
     * @param providerClass the &lt;code&gt;Class&lt;/code&gt; of the desired
     * service provider object.
     * @param &lt;T&gt; the type of the provider.
     *
     * @return a currently registered service provider object with the
     * desired &lt;code&gt;Class&lt;/code&gt;type, or &lt;code&gt;null&lt;/code&gt; is none is
     * present.
     *
     * @exception IllegalArgumentException if &lt;code&gt;providerClass&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public &lt;T&gt; T getServiceProviderByClass(Class&lt;T&gt; providerClass) {
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (providerClass == null) {</span>
<span class="nc" id="L539">            throw new IllegalArgumentException(&quot;providerClass == null!&quot;);</span>
        }
<span class="nc" id="L541">        Iterator iter = categoryMap.keySet().iterator();</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L543">            Class c = (Class)iter.next();</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">            if (c.isAssignableFrom(providerClass)) {</span>
<span class="nc" id="L545">                SubRegistry reg = (SubRegistry)categoryMap.get(c);</span>
<span class="nc" id="L546">                T provider = reg.getServiceProviderByClass(providerClass);</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">                if (provider != null) {</span>
<span class="nc" id="L548">                    return provider;</span>
                }
            }
<span class="nc" id="L551">        }</span>
<span class="nc" id="L552">        return null;</span>
    }

    /**
     * Sets a pairwise ordering between two service provider objects
     * within a given category.  If one or both objects are not
     * currently registered within the given category, or if the
     * desired ordering is already set, nothing happens and
     * &lt;code&gt;false&lt;/code&gt; is returned.  If the providers previously
     * were ordered in the reverse direction, that ordering is
     * removed.
     *
     * &lt;p&gt; The ordering will be used by the
     * &lt;code&gt;getServiceProviders&lt;/code&gt; methods when their
     * &lt;code&gt;useOrdering&lt;/code&gt; argument is &lt;code&gt;true&lt;/code&gt;.
     *
     * @param category a &lt;code&gt;Class&lt;/code&gt; object indicating the
     * category under which the preference is to be established.
     * @param firstProvider the preferred provider.
     * @param secondProvider the provider to which
     * &lt;code&gt;firstProvider&lt;/code&gt; is preferred.
     * @param &lt;T&gt; the type of the category.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if a previously unset ordering
     * was established.
     *
     * @exception IllegalArgumentException if either provider is
     * &lt;code&gt;null&lt;/code&gt; or they are the same object.
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; boolean setOrdering(Class&lt;T&gt; category,
                                   T firstProvider,
                                   T secondProvider) {
<span class="nc bnc" id="L586" title="All 4 branches missed.">        if (firstProvider == null || secondProvider == null) {</span>
<span class="nc" id="L587">            throw new IllegalArgumentException(&quot;provider is null!&quot;);</span>
        }
<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (firstProvider == secondProvider) {</span>
<span class="nc" id="L590">            throw new IllegalArgumentException(&quot;providers are the same!&quot;);</span>
        }
<span class="nc" id="L592">        SubRegistry reg = (SubRegistry)categoryMap.get(category);</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (reg == null) {</span>
<span class="nc" id="L594">            throw new IllegalArgumentException(&quot;category unknown!&quot;);</span>
        }
<span class="nc bnc" id="L596" title="All 2 branches missed.">        if (reg.contains(firstProvider) &amp;&amp;</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">            reg.contains(secondProvider)) {</span>
<span class="nc" id="L598">            return reg.setOrdering(firstProvider, secondProvider);</span>
        }
<span class="nc" id="L600">        return false;</span>
    }

    /**
     * Sets a pairwise ordering between two service provider objects
     * within a given category.  If one or both objects are not
     * currently registered within the given category, or if no
     * ordering is currently set between them, nothing happens
     * and &lt;code&gt;false&lt;/code&gt; is returned.
     *
     * &lt;p&gt; The ordering will be used by the
     * &lt;code&gt;getServiceProviders&lt;/code&gt; methods when their
     * &lt;code&gt;useOrdering&lt;/code&gt; argument is &lt;code&gt;true&lt;/code&gt;.
     *
     * @param category a &lt;code&gt;Class&lt;/code&gt; object indicating the
     * category under which the preference is to be disestablished.
     * @param firstProvider the formerly preferred provider.
     * @param secondProvider the provider to which
     * &lt;code&gt;firstProvider&lt;/code&gt; was formerly preferred.
     * @param &lt;T&gt; the type of the category.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if a previously set ordering was
     * disestablished.
     *
     * @exception IllegalArgumentException if either provider is
     * &lt;code&gt;null&lt;/code&gt; or they are the same object.
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     */
    public &lt;T&gt; boolean unsetOrdering(Class&lt;T&gt; category,
                                     T firstProvider,
                                     T secondProvider) {
<span class="nc bnc" id="L632" title="All 4 branches missed.">        if (firstProvider == null || secondProvider == null) {</span>
<span class="nc" id="L633">            throw new IllegalArgumentException(&quot;provider is null!&quot;);</span>
        }
<span class="nc bnc" id="L635" title="All 2 branches missed.">        if (firstProvider == secondProvider) {</span>
<span class="nc" id="L636">            throw new IllegalArgumentException(&quot;providers are the same!&quot;);</span>
        }
<span class="nc" id="L638">        SubRegistry reg = (SubRegistry)categoryMap.get(category);</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">        if (reg == null) {</span>
<span class="nc" id="L640">            throw new IllegalArgumentException(&quot;category unknown!&quot;);</span>
        }
<span class="nc bnc" id="L642" title="All 2 branches missed.">        if (reg.contains(firstProvider) &amp;&amp;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">            reg.contains(secondProvider)) {</span>
<span class="nc" id="L644">            return reg.unsetOrdering(firstProvider, secondProvider);</span>
        }
<span class="nc" id="L646">        return false;</span>
    }

    /**
     * Deregisters all service provider object currently registered
     * under the given category.
     *
     * @param category the category to be emptied.
     *
     * @exception IllegalArgumentException if there is no category
     * corresponding to &lt;code&gt;category&lt;/code&gt;.
     */
    public void deregisterAll(Class&lt;?&gt; category) {
<span class="nc" id="L659">        SubRegistry reg = (SubRegistry)categoryMap.get(category);</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (reg == null) {</span>
<span class="nc" id="L661">            throw new IllegalArgumentException(&quot;category unknown!&quot;);</span>
        }
<span class="nc" id="L663">        reg.clear();</span>
<span class="nc" id="L664">    }</span>

    /**
     * Deregisters all currently registered service providers from all
     * categories.
     */
    public void deregisterAll() {
<span class="nc" id="L671">        Iterator iter = categoryMap.values().iterator();</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L673">            SubRegistry reg = (SubRegistry)iter.next();</span>
<span class="nc" id="L674">            reg.clear();</span>
<span class="nc" id="L675">        }</span>
<span class="nc" id="L676">    }</span>

    /**
     * Finalizes this object prior to garbage collection.  The
     * &lt;code&gt;deregisterAll&lt;/code&gt; method is called to deregister all
     * currently registered service providers.  This method should not
     * be called from application code.
     *
     * @exception Throwable if an error occurs during superclass
     * finalization.
     */
    public void finalize() throws Throwable {
<span class="nc" id="L688">        deregisterAll();</span>
<span class="nc" id="L689">        super.finalize();</span>
<span class="nc" id="L690">    }</span>
}


/**
 * A portion of a registry dealing with a single superclass or
 * interface.
 */
class SubRegistry {

    ServiceRegistry registry;

    Class category;

    // Provider Objects organized by partial oridering
<span class="fc" id="L705">    PartiallyOrderedSet poset = new PartiallyOrderedSet();</span>

    // Class -&gt; Provider Object of that class
<span class="fc" id="L708">    Map&lt;Class&lt;?&gt;,Object&gt; map = new HashMap();</span>

<span class="fc" id="L710">    public SubRegistry(ServiceRegistry registry, Class category) {</span>
<span class="fc" id="L711">        this.registry = registry;</span>
<span class="fc" id="L712">        this.category = category;</span>
<span class="fc" id="L713">    }</span>

    public boolean registerServiceProvider(Object provider) {
<span class="fc" id="L716">        Object oprovider = map.get(provider.getClass());</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">        boolean present =  oprovider != null;</span>

<span class="pc bpc" id="L719" title="1 of 2 branches missed.">        if (present) {</span>
<span class="nc" id="L720">            deregisterServiceProvider(oprovider);</span>
        }
<span class="fc" id="L722">        map.put(provider.getClass(), provider);</span>
<span class="fc" id="L723">        poset.add(provider);</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">        if (provider instanceof RegisterableService) {</span>
<span class="fc" id="L725">            RegisterableService rs = (RegisterableService)provider;</span>
<span class="fc" id="L726">            rs.onRegistration(registry, category);</span>
        }

<span class="pc bpc" id="L729" title="1 of 2 branches missed.">        return !present;</span>
    }

    /**
     * If the provider was not previously registered, do nothing.
     *
     * @return true if the provider was previously registered.
     */
    public boolean deregisterServiceProvider(Object provider) {
<span class="nc" id="L738">        Object oprovider = map.get(provider.getClass());</span>

<span class="nc bnc" id="L740" title="All 2 branches missed.">        if (provider == oprovider) {</span>
<span class="nc" id="L741">            map.remove(provider.getClass());</span>
<span class="nc" id="L742">            poset.remove(provider);</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">            if (provider instanceof RegisterableService) {</span>
<span class="nc" id="L744">                RegisterableService rs = (RegisterableService)provider;</span>
<span class="nc" id="L745">                rs.onDeregistration(registry, category);</span>
            }

<span class="nc" id="L748">            return true;</span>
        }
<span class="nc" id="L750">        return false;</span>
    }

    public boolean contains(Object provider) {
<span class="nc" id="L754">        Object oprovider = map.get(provider.getClass());</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">        return oprovider == provider;</span>
    }

    public boolean setOrdering(Object firstProvider,
                               Object secondProvider) {
<span class="nc" id="L760">        return poset.setOrdering(firstProvider, secondProvider);</span>
    }

    public boolean unsetOrdering(Object firstProvider,
                                 Object secondProvider) {
<span class="nc" id="L765">        return poset.unsetOrdering(firstProvider, secondProvider);</span>
    }

    public Iterator getServiceProviders(boolean useOrdering) {
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">        if (useOrdering) {</span>
<span class="fc" id="L770">            return poset.iterator();</span>
        } else {
<span class="nc" id="L772">            return map.values().iterator();</span>
        }
    }

    public &lt;T&gt; T getServiceProviderByClass(Class&lt;T&gt; providerClass) {
<span class="nc" id="L777">        return (T)map.get(providerClass);</span>
    }

    public void clear() {
<span class="nc" id="L781">        Iterator iter = map.values().iterator();</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L783">            Object provider = iter.next();</span>
<span class="nc" id="L784">            iter.remove();</span>

<span class="nc bnc" id="L786" title="All 2 branches missed.">            if (provider instanceof RegisterableService) {</span>
<span class="nc" id="L787">                RegisterableService rs = (RegisterableService)provider;</span>
<span class="nc" id="L788">                rs.onDeregistration(registry, category);</span>
            }
<span class="nc" id="L790">        }</span>
<span class="nc" id="L791">        poset.clear();</span>
<span class="nc" id="L792">    }</span>

    public void finalize() {
<span class="nc" id="L795">        clear();</span>
<span class="nc" id="L796">    }</span>
}


/**
 * A class for wrapping &lt;code&gt;Iterators&lt;/code&gt; with a filter function.
 * This provides an iterator for a subset without duplication.
 */
class FilterIterator&lt;T&gt; implements Iterator&lt;T&gt; {

    private Iterator&lt;T&gt; iter;
    private ServiceRegistry.Filter filter;

<span class="fc" id="L809">    private T next = null;</span>

    public FilterIterator(Iterator&lt;T&gt; iter,
<span class="fc" id="L812">                          ServiceRegistry.Filter filter) {</span>
<span class="fc" id="L813">        this.iter = iter;</span>
<span class="fc" id="L814">        this.filter = filter;</span>
<span class="fc" id="L815">        advance();</span>
<span class="fc" id="L816">    }</span>

    private void advance() {
<span class="fc bfc" id="L819" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L820">            T elt = iter.next();</span>
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">            if (filter.filter(elt)) {</span>
<span class="nc" id="L822">                next = elt;</span>
<span class="nc" id="L823">                return;</span>
            }
<span class="fc" id="L825">        }</span>

<span class="fc" id="L827">        next = null;</span>
<span class="fc" id="L828">    }</span>

    public boolean hasNext() {
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">        return next != null;</span>
    }

    public T next() {
<span class="nc bnc" id="L835" title="All 2 branches missed.">        if (next == null) {</span>
<span class="nc" id="L836">            throw new NoSuchElementException();</span>
        }
<span class="nc" id="L838">        T o = next;</span>
<span class="nc" id="L839">        advance();</span>
<span class="nc" id="L840">        return o;</span>
    }

    public void remove() {
<span class="nc" id="L844">        throw new UnsupportedOperationException();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>