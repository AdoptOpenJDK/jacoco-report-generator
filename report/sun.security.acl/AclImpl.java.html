<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AclImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.acl</a> &gt; <span class="el_source">AclImpl.java</span></div><h1>AclImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.acl;

import java.io.*;
import java.util.*;
import java.security.Principal;
import java.security.acl.*;

/**
 * An Access Control List (ACL) is encapsulated by this class.
 * @author      Satish Dharmaraj
 */
public class AclImpl extends OwnerImpl implements Acl {
    //
    // Maintain four tables. one each for positive and negative
    // ACLs. One each depending on whether the entity is a group
    // or principal.
    //
<span class="nc" id="L43">    private Hashtable&lt;Principal, AclEntry&gt; allowedUsersTable =</span>
                                        new Hashtable&lt;&gt;(23);
<span class="nc" id="L45">    private Hashtable&lt;Principal, AclEntry&gt; allowedGroupsTable =</span>
                                        new Hashtable&lt;&gt;(23);
<span class="nc" id="L47">    private Hashtable&lt;Principal, AclEntry&gt; deniedUsersTable =</span>
                                        new Hashtable&lt;&gt;(23);
<span class="nc" id="L49">    private Hashtable&lt;Principal, AclEntry&gt; deniedGroupsTable =</span>
                                        new Hashtable&lt;&gt;(23);
<span class="nc" id="L51">    private String aclName = null;</span>
<span class="nc" id="L52">    private Vector&lt;Permission&gt; zeroSet = new Vector&lt;&gt;(1,1);</span>


    /**
     * Constructor for creating an empty ACL.
     */
    public AclImpl(Principal owner, String name) {
<span class="nc" id="L59">        super(owner);</span>
        try {
<span class="nc" id="L61">            setName(owner, name);</span>
<span class="nc" id="L62">        } catch (Exception e) {}</span>
<span class="nc" id="L63">    }</span>

    /**
     * Sets the name of the ACL.
     * @param caller the principal who is invoking this method.
     * @param name the name of the ACL.
     * @exception NotOwnerException if the caller principal is
     * not on the owners list of the Acl.
     */
    public void setName(Principal caller, String name)
      throws NotOwnerException
    {
<span class="nc bnc" id="L75" title="All 2 branches missed.">        if (!isOwner(caller))</span>
<span class="nc" id="L76">            throw new NotOwnerException();</span>

<span class="nc" id="L78">        aclName = name;</span>
<span class="nc" id="L79">    }</span>

    /**
     * Returns the name of the ACL.
     * @return the name of the ACL.
     */
    public String getName() {
<span class="nc" id="L86">        return aclName;</span>
    }

    /**
     * Adds an ACL entry to this ACL. An entry associates a
     * group or a principal with a set of permissions. Each
     * user or group can have one positive ACL entry and one
     * negative ACL entry. If there is one of the type (negative
     * or positive) already in the table, a false value is returned.
     * The caller principal must be a part of the owners list of
     * the ACL in order to invoke this method.
     * @param caller the principal who is invoking this method.
     * @param entry the ACL entry that must be added to the ACL.
     * @return true on success, false if the entry is already present.
     * @exception NotOwnerException if the caller principal
     * is not on the owners list of the Acl.
     */
    public synchronized boolean addEntry(Principal caller, AclEntry entry)
      throws NotOwnerException
    {
<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (!isOwner(caller))</span>
<span class="nc" id="L107">            throw new NotOwnerException();</span>

<span class="nc" id="L109">        Hashtable&lt;Principal, AclEntry&gt; aclTable = findTable(entry);</span>
<span class="nc" id="L110">        Principal key = entry.getPrincipal();</span>

<span class="nc bnc" id="L112" title="All 2 branches missed.">        if (aclTable.get(key) != null)</span>
<span class="nc" id="L113">            return false;</span>

<span class="nc" id="L115">        aclTable.put(key, entry);</span>
<span class="nc" id="L116">        return true;</span>
    }

    /**
     * Removes an ACL entry from this ACL.
     * The caller principal must be a part of the owners list of the ACL
     * in order to invoke this method.
     * @param caller the principal who is invoking this method.
     * @param entry the ACL entry that must be removed from the ACL.
     * @return true on success, false if the entry is not part of the ACL.
     * @exception NotOwnerException if the caller principal is not
     * the owners list of the Acl.
     */
    public synchronized boolean removeEntry(Principal caller, AclEntry entry)
      throws NotOwnerException
    {
<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (!isOwner(caller))</span>
<span class="nc" id="L133">            throw new NotOwnerException();</span>

<span class="nc" id="L135">        Hashtable&lt;Principal, AclEntry&gt; aclTable = findTable(entry);</span>
<span class="nc" id="L136">        Principal key = entry.getPrincipal();</span>

<span class="nc" id="L138">        AclEntry o = aclTable.remove(key);</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        return (o != null);</span>
    }

    /**
     * This method returns the set of allowed permissions for the
     * specified principal. This set of allowed permissions is calculated
     * as follows:
     *
     * If there is no entry for a group or a principal an empty permission
     * set is assumed.
     *
     * The group positive permission set is the union of all
     * the positive permissions of each group that the individual belongs to.
     * The group negative permission set is the union of all
     * the negative permissions of each group that the individual belongs to.
     * If there is a specific permission that occurs in both
     * the postive permission set and the negative permission set,
     * it is removed from both. The group positive and negatoive permission
     * sets are calculated.
     *
     * The individial positive permission set and the individual negative
     * permission set is then calculated. Again abscence of an entry means
     * the empty set.
     *
     * The set of permissions granted to the principal is then calculated using
     * the simple rule: Individual permissions always override the Group permissions.
     * Specifically, individual negative permission set (specific
     * denial of permissions) overrides the group positive permission set.
     * And the individual positive permission set override the group negative
     * permission set.
     *
     * @param user the principal for which the ACL entry is returned.
     * @return The resulting permission set that the principal is allowed.
     */
    public synchronized Enumeration&lt;Permission&gt; getPermissions(Principal user) {

        Enumeration&lt;Permission&gt; individualPositive;
        Enumeration&lt;Permission&gt; individualNegative;
        Enumeration&lt;Permission&gt; groupPositive;
        Enumeration&lt;Permission&gt; groupNegative;

        //
        // canonicalize the sets. That is remove common permissions from
        // positive and negative sets.
        //
<span class="nc" id="L184">        groupPositive =</span>
<span class="nc" id="L185">            subtract(getGroupPositive(user), getGroupNegative(user));</span>
<span class="nc" id="L186">        groupNegative  =</span>
<span class="nc" id="L187">            subtract(getGroupNegative(user), getGroupPositive(user));</span>
<span class="nc" id="L188">        individualPositive =</span>
<span class="nc" id="L189">            subtract(getIndividualPositive(user), getIndividualNegative(user));</span>
<span class="nc" id="L190">        individualNegative =</span>
<span class="nc" id="L191">            subtract(getIndividualNegative(user), getIndividualPositive(user));</span>

        //
        // net positive permissions is individual positive permissions
        // plus (group positive - individual negative).
        //
<span class="nc" id="L197">        Enumeration&lt;Permission&gt; temp1 =</span>
<span class="nc" id="L198">            subtract(groupPositive, individualNegative);</span>
<span class="nc" id="L199">        Enumeration&lt;Permission&gt; netPositive =</span>
<span class="nc" id="L200">            union(individualPositive, temp1);</span>

        // recalculate the enumeration since we lost it in performing the
        // subtraction
        //
<span class="nc" id="L205">        individualPositive =</span>
<span class="nc" id="L206">            subtract(getIndividualPositive(user), getIndividualNegative(user));</span>
<span class="nc" id="L207">        individualNegative =</span>
<span class="nc" id="L208">            subtract(getIndividualNegative(user), getIndividualPositive(user));</span>

        //
        // net negative permissions is individual negative permissions
        // plus (group negative - individual positive).
        //
<span class="nc" id="L214">        temp1 = subtract(groupNegative, individualPositive);</span>
<span class="nc" id="L215">        Enumeration&lt;Permission&gt; netNegative = union(individualNegative, temp1);</span>

<span class="nc" id="L217">        return subtract(netPositive, netNegative);</span>
    }

    /**
     * This method checks whether or not the specified principal
     * has the required permission. If permission is denied
     * permission false is returned, a true value is returned otherwise.
     * This method does not authenticate the principal. It presumes that
     * the principal is a valid authenticated principal.
     * @param principal the name of the authenticated principal
     * @param permission the permission that the principal must have.
     * @return true of the principal has the permission desired, false
     * otherwise.
     */
    public boolean checkPermission(Principal principal, Permission permission)
    {
<span class="nc" id="L233">        Enumeration&lt;Permission&gt; permSet = getPermissions(principal);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        while (permSet.hasMoreElements()) {</span>
<span class="nc" id="L235">            Permission p = permSet.nextElement();</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            if (p.equals(permission))</span>
<span class="nc" id="L237">              return true;</span>
<span class="nc" id="L238">        }</span>
<span class="nc" id="L239">        return false;</span>
    }

    /**
     * returns an enumeration of the entries in this ACL.
     */
    public synchronized Enumeration&lt;AclEntry&gt; entries() {
<span class="nc" id="L246">        return new AclEnumerator(this,</span>
                                 allowedUsersTable, allowedGroupsTable,
                                 deniedUsersTable, deniedGroupsTable);
    }

    /**
     * return a stringified version of the
     * ACL.
     */
    public String toString() {
<span class="nc" id="L256">        StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L257">        Enumeration&lt;AclEntry&gt; entries = entries();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        while (entries.hasMoreElements()) {</span>
<span class="nc" id="L259">            AclEntry entry = entries.nextElement();</span>
<span class="nc" id="L260">            sb.append(entry.toString().trim());</span>
<span class="nc" id="L261">            sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L262">        }</span>

<span class="nc" id="L264">        return sb.toString();</span>
    }

    //
    // Find the table that this entry belongs to. There are 4
    // tables that are maintained. One each for postive and
    // negative ACLs and one each for groups and users.
    // This method figures out which
    // table is the one that this AclEntry belongs to.
    //
    private Hashtable&lt;Principal, AclEntry&gt; findTable(AclEntry entry) {
<span class="nc" id="L275">        Hashtable&lt;Principal, AclEntry&gt; aclTable = null;</span>

<span class="nc" id="L277">        Principal p = entry.getPrincipal();</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (p instanceof Group) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (entry.isNegative())</span>
<span class="nc" id="L280">                aclTable = deniedGroupsTable;</span>
            else
<span class="nc" id="L282">                aclTable = allowedGroupsTable;</span>
        } else {
<span class="nc bnc" id="L284" title="All 2 branches missed.">            if (entry.isNegative())</span>
<span class="nc" id="L285">                aclTable = deniedUsersTable;</span>
            else
<span class="nc" id="L287">                aclTable = allowedUsersTable;</span>
        }
<span class="nc" id="L289">        return aclTable;</span>
    }

    //
    // returns the set e1 U e2.
    //
    private static Enumeration&lt;Permission&gt; union(Enumeration&lt;Permission&gt; e1,
                Enumeration&lt;Permission&gt; e2) {
<span class="nc" id="L297">        Vector&lt;Permission&gt; v = new Vector&lt;&gt;(20, 20);</span>

<span class="nc bnc" id="L299" title="All 2 branches missed.">        while (e1.hasMoreElements())</span>
<span class="nc" id="L300">            v.addElement(e1.nextElement());</span>

<span class="nc bnc" id="L302" title="All 2 branches missed.">        while (e2.hasMoreElements()) {</span>
<span class="nc" id="L303">            Permission o = e2.nextElement();</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">            if (!v.contains(o))</span>
<span class="nc" id="L305">                v.addElement(o);</span>
<span class="nc" id="L306">        }</span>

<span class="nc" id="L308">        return v.elements();</span>
    }

    //
    // returns the set e1 - e2.
    //
    private Enumeration&lt;Permission&gt; subtract(Enumeration&lt;Permission&gt; e1,
                Enumeration&lt;Permission&gt; e2) {
<span class="nc" id="L316">        Vector&lt;Permission&gt; v = new Vector&lt;&gt;(20, 20);</span>

<span class="nc bnc" id="L318" title="All 2 branches missed.">        while (e1.hasMoreElements())</span>
<span class="nc" id="L319">            v.addElement(e1.nextElement());</span>

<span class="nc bnc" id="L321" title="All 2 branches missed.">        while (e2.hasMoreElements()) {</span>
<span class="nc" id="L322">            Permission o = e2.nextElement();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (v.contains(o))</span>
<span class="nc" id="L324">                v.removeElement(o);</span>
<span class="nc" id="L325">        }</span>

<span class="nc" id="L327">        return v.elements();</span>
    }

    private Enumeration&lt;Permission&gt; getGroupPositive(Principal user) {
<span class="nc" id="L331">        Enumeration&lt;Permission&gt; groupPositive = zeroSet.elements();</span>
<span class="nc" id="L332">        Enumeration&lt;Principal&gt; e = allowedGroupsTable.keys();</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        while (e.hasMoreElements()) {</span>
<span class="nc" id="L334">            Group g = (Group)e.nextElement();</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (g.isMember(user)) {</span>
<span class="nc" id="L336">                AclEntry ae = allowedGroupsTable.get(g);</span>
<span class="nc" id="L337">                groupPositive = union(ae.permissions(), groupPositive);</span>
            }
<span class="nc" id="L339">        }</span>
<span class="nc" id="L340">        return groupPositive;</span>
    }

    private Enumeration&lt;Permission&gt; getGroupNegative(Principal user) {
<span class="nc" id="L344">        Enumeration&lt;Permission&gt; groupNegative = zeroSet.elements();</span>
<span class="nc" id="L345">        Enumeration&lt;Principal&gt; e = deniedGroupsTable.keys();</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        while (e.hasMoreElements()) {</span>
<span class="nc" id="L347">            Group g = (Group)e.nextElement();</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">            if (g.isMember(user)) {</span>
<span class="nc" id="L349">                AclEntry ae = deniedGroupsTable.get(g);</span>
<span class="nc" id="L350">                groupNegative = union(ae.permissions(), groupNegative);</span>
            }
<span class="nc" id="L352">        }</span>
<span class="nc" id="L353">        return groupNegative;</span>
    }

    private Enumeration&lt;Permission&gt; getIndividualPositive(Principal user) {
<span class="nc" id="L357">        Enumeration&lt;Permission&gt; individualPositive = zeroSet.elements();</span>
<span class="nc" id="L358">        AclEntry ae = allowedUsersTable.get(user);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (ae != null)</span>
<span class="nc" id="L360">            individualPositive = ae.permissions();</span>
<span class="nc" id="L361">        return individualPositive;</span>
    }

    private Enumeration&lt;Permission&gt; getIndividualNegative(Principal user) {
<span class="nc" id="L365">        Enumeration&lt;Permission&gt; individualNegative = zeroSet.elements();</span>
<span class="nc" id="L366">        AclEntry ae  = deniedUsersTable.get(user);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (ae != null)</span>
<span class="nc" id="L368">            individualNegative = ae.permissions();</span>
<span class="nc" id="L369">        return individualNegative;</span>
    }
}

final class AclEnumerator implements Enumeration&lt;AclEntry&gt; {
    Acl acl;
    Enumeration&lt;AclEntry&gt; u1, u2, g1, g2;

    AclEnumerator(Acl acl, Hashtable&lt;?,AclEntry&gt; u1, Hashtable&lt;?,AclEntry&gt; g1,
<span class="nc" id="L378">                  Hashtable&lt;?,AclEntry&gt; u2, Hashtable&lt;?,AclEntry&gt; g2) {</span>
<span class="nc" id="L379">        this.acl = acl;</span>
<span class="nc" id="L380">        this.u1 = u1.elements();</span>
<span class="nc" id="L381">        this.u2 = u2.elements();</span>
<span class="nc" id="L382">        this.g1 = g1.elements();</span>
<span class="nc" id="L383">        this.g2 = g2.elements();</span>
<span class="nc" id="L384">    }</span>

    public boolean hasMoreElements() {
<span class="nc bnc" id="L387" title="All 2 branches missed.">        return (u1.hasMoreElements() ||</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">                u2.hasMoreElements() ||</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                g1.hasMoreElements() ||</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                g2.hasMoreElements());</span>
    }

    public AclEntry nextElement()
    {
        AclEntry o;
<span class="nc" id="L396">        synchronized (acl) {</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">            if (u1.hasMoreElements())</span>
<span class="nc" id="L398">                return u1.nextElement();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if (u2.hasMoreElements())</span>
<span class="nc" id="L400">                return u2.nextElement();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">            if (g1.hasMoreElements())</span>
<span class="nc" id="L402">                return g1.nextElement();</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (g2.hasMoreElements())</span>
<span class="nc" id="L404">                return g2.nextElement();</span>
<span class="nc" id="L405">        }</span>
<span class="nc" id="L406">        throw new NoSuchElementException(&quot;Acl Enumerator&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>