<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PKCS12KeyStore.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.pkcs12</a> &gt; <span class="el_source">PKCS12KeyStore.java</span></div><h1>PKCS12KeyStore.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.pkcs12;

import java.io.*;
import java.security.AccessController;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.Key;
import java.security.KeyFactory;
import java.security.KeyStore;
import java.security.KeyStoreSpi;
import java.security.KeyStoreException;
import java.security.PKCS12Attribute;
import java.security.PrivateKey;
import java.security.PrivilegedAction;
import java.security.UnrecoverableEntryException;
import java.security.UnrecoverableKeyException;
import java.security.SecureRandom;
import java.security.Security;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.cert.CertificateException;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.KeySpec;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.*;

import java.security.AlgorithmParameters;
import javax.crypto.spec.PBEParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.SecretKey;
import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.security.auth.DestroyFailedException;
import javax.security.auth.x500.X500Principal;

import sun.security.util.Debug;
import sun.security.util.DerInputStream;
import sun.security.util.DerOutputStream;
import sun.security.util.DerValue;
import sun.security.util.ObjectIdentifier;
import sun.security.pkcs.ContentInfo;
import sun.security.x509.AlgorithmId;
import sun.security.pkcs.EncryptedPrivateKeyInfo;


/**
 * This class provides the keystore implementation referred to as &quot;PKCS12&quot;.
 * Implements the PKCS#12 PFX protected using the Password privacy mode.
 * The contents are protected using Password integrity mode.
 *
 * Currently we support following PBE algorithms:
 *  - pbeWithSHAAnd3KeyTripleDESCBC to encrypt private keys
 *  - pbeWithSHAAnd40BitRC2CBC to encrypt certificates
 *
 * Supported encryption of various implementations :
 *
 * Software and mode.     Certificate encryption  Private key encryption
 * ---------------------------------------------------------------------
 * MSIE4 (domestic            40 bit RC2.            40 bit RC2
 * and xport versions)
 * PKCS#12 export.
 *
 * MSIE4, 5 (domestic         40 bit RC2,            40 bit RC2,
 * and export versions)       3 key triple DES       3 key triple DES
 * PKCS#12 import.
 *
 * MSIE5                      40 bit RC2             3 key triple DES,
 * PKCS#12 export.                                   with SHA1 (168 bits)
 *
 * Netscape Communicator      40 bit RC2             3 key triple DES,
 * (domestic and export                              with SHA1 (168 bits)
 * versions) PKCS#12 export
 *
 * Netscape Communicator      40 bit ciphers only    All.
 * (export version)
 * PKCS#12 import.
 *
 * Netscape Communicator      All.                   All.
 * (domestic or fortified
 * version) PKCS#12 import.
 *
 * OpenSSL PKCS#12 code.      All.                   All.
 * ---------------------------------------------------------------------
 *
 * NOTE: PKCS12 KeyStore supports PrivateKeyEntry and TrustedCertficateEntry.
 * PKCS#12 is mainly used to deliver private keys with their associated
 * certificate chain and aliases. In a PKCS12 keystore, entries are
 * identified by the alias, and a localKeyId is required to match the
 * private key with the certificate. Trusted certificate entries are identified
 * by the presence of an trustedKeyUsage attribute.
 *
 * @author Seema Malkani
 * @author Jeff Nisewanger
 * @author Jan Luehe
 *
 * @see KeyProtector
 * @see java.security.KeyStoreSpi
 * @see KeyTool
 *
 *
 */
<span class="fc" id="L130">public final class PKCS12KeyStore extends KeyStoreSpi {</span>

    public static final int VERSION_3 = 3;

<span class="fc" id="L134">    private static final String[] KEY_PROTECTION_ALGORITHM = {</span>
        &quot;keystore.pkcs12.keyProtectionAlgorithm&quot;,
        &quot;keystore.PKCS12.keyProtectionAlgorithm&quot;
    };

    // friendlyName, localKeyId, trustedKeyUsage
<span class="fc" id="L140">    private static final String[] CORE_ATTRIBUTES = {</span>
        &quot;1.2.840.113549.1.9.20&quot;,
        &quot;1.2.840.113549.1.9.21&quot;,
        &quot;2.16.840.1.113894.746875.1.1&quot;
    };

<span class="fc" id="L146">    private static final Debug debug = Debug.getInstance(&quot;pkcs12&quot;);</span>

<span class="fc" id="L148">    private static final int keyBag[]  = {1, 2, 840, 113549, 1, 12, 10, 1, 2};</span>
<span class="fc" id="L149">    private static final int certBag[] = {1, 2, 840, 113549, 1, 12, 10, 1, 3};</span>
<span class="fc" id="L150">    private static final int secretBag[] = {1, 2, 840, 113549, 1, 12, 10, 1, 5};</span>

<span class="fc" id="L152">    private static final int pkcs9Name[]  = {1, 2, 840, 113549, 1, 9, 20};</span>
<span class="fc" id="L153">    private static final int pkcs9KeyId[] = {1, 2, 840, 113549, 1, 9, 21};</span>

<span class="fc" id="L155">    private static final int pkcs9certType[] = {1, 2, 840, 113549, 1, 9, 22, 1};</span>

<span class="fc" id="L157">    private static final int pbeWithSHAAnd40BitRC2CBC[] =</span>
                                        {1, 2, 840, 113549, 1, 12, 1, 6};
<span class="fc" id="L159">    private static final int pbeWithSHAAnd3KeyTripleDESCBC[] =</span>
                                        {1, 2, 840, 113549, 1, 12, 1, 3};
<span class="fc" id="L161">    private static final int pbes2[] = {1, 2, 840, 113549, 1, 5, 13};</span>
    // TODO: temporary Oracle OID
    /*
     * { joint-iso-itu-t(2) country(16) us(840) organization(1) oracle(113894)
     *   jdk(746875) crypto(1) id-at-trustedKeyUsage(1) }
     */
<span class="fc" id="L167">    private static final int TrustedKeyUsage[] =</span>
                                        {2, 16, 840, 1, 113894, 746875, 1, 1};
<span class="fc" id="L169">    private static final int AnyExtendedKeyUsage[] = {2, 5, 29, 37, 0};</span>

    private static ObjectIdentifier PKCS8ShroudedKeyBag_OID;
    private static ObjectIdentifier CertBag_OID;
    private static ObjectIdentifier SecretBag_OID;
    private static ObjectIdentifier PKCS9FriendlyName_OID;
    private static ObjectIdentifier PKCS9LocalKeyId_OID;
    private static ObjectIdentifier PKCS9CertType_OID;
    private static ObjectIdentifier pbeWithSHAAnd40BitRC2CBC_OID;
    private static ObjectIdentifier pbeWithSHAAnd3KeyTripleDESCBC_OID;
    private static ObjectIdentifier pbes2_OID;
    private static ObjectIdentifier TrustedKeyUsage_OID;
    private static ObjectIdentifier[] AnyUsage;

<span class="fc" id="L183">    private int counter = 0;</span>
    private static final int iterationCount = 1024;
    private static final int SALT_LEN = 20;

    // private key count
    // Note: This is a workaround to allow null localKeyID attribute
    // in pkcs12 with one private key entry and associated cert-chain
<span class="fc" id="L190">    private int privateKeyCount = 0;</span>

    // secret key count
<span class="fc" id="L193">    private int secretKeyCount = 0;</span>

    // certificate count
<span class="fc" id="L196">    private int certificateCount = 0;</span>

    // the source of randomness
    private SecureRandom random;

    static {
        try {
<span class="fc" id="L203">            PKCS8ShroudedKeyBag_OID = new ObjectIdentifier(keyBag);</span>
<span class="fc" id="L204">            CertBag_OID = new ObjectIdentifier(certBag);</span>
<span class="fc" id="L205">            SecretBag_OID = new ObjectIdentifier(secretBag);</span>
<span class="fc" id="L206">            PKCS9FriendlyName_OID = new ObjectIdentifier(pkcs9Name);</span>
<span class="fc" id="L207">            PKCS9LocalKeyId_OID = new ObjectIdentifier(pkcs9KeyId);</span>
<span class="fc" id="L208">            PKCS9CertType_OID = new ObjectIdentifier(pkcs9certType);</span>
<span class="fc" id="L209">            pbeWithSHAAnd40BitRC2CBC_OID =</span>
                        new ObjectIdentifier(pbeWithSHAAnd40BitRC2CBC);
<span class="fc" id="L211">            pbeWithSHAAnd3KeyTripleDESCBC_OID =</span>
                        new ObjectIdentifier(pbeWithSHAAnd3KeyTripleDESCBC);
<span class="fc" id="L213">            pbes2_OID = new ObjectIdentifier(pbes2);</span>
<span class="fc" id="L214">            TrustedKeyUsage_OID = new ObjectIdentifier(TrustedKeyUsage);</span>
<span class="fc" id="L215">            AnyUsage = new ObjectIdentifier[]{</span>
                new ObjectIdentifier(AnyExtendedKeyUsage)};
<span class="nc" id="L217">        } catch (IOException ioe) {</span>
            // should not happen
<span class="fc" id="L219">        }</span>
<span class="fc" id="L220">    }</span>

    // A keystore entry and associated attributes
<span class="fc" id="L223">    private static class Entry {</span>
        Date date; // the creation date of this entry
        String alias;
        byte[] keyId;
        Set&lt;KeyStore.Entry.Attribute&gt; attributes;
    }

    // A key entry
<span class="fc" id="L231">    private static class KeyEntry extends Entry {</span>
    }

    // A private key entry and its supporting certificate chain
<span class="fc" id="L235">    private static class PrivateKeyEntry extends KeyEntry {</span>
        byte[] protectedPrivKey;
        Certificate chain[];
    };

    // A secret key
<span class="nc" id="L241">    private static class SecretKeyEntry extends KeyEntry {</span>
        byte[] protectedSecretKey;
    };

    // A certificate entry
    private static class CertEntry extends Entry {
        final X509Certificate cert;
        ObjectIdentifier[] trustedKeyUsage;

        CertEntry(X509Certificate cert, byte[] keyId, String alias) {
<span class="fc" id="L251">            this(cert, keyId, alias, null, null);</span>
<span class="fc" id="L252">        }</span>

        CertEntry(X509Certificate cert, byte[] keyId, String alias,
                ObjectIdentifier[] trustedKeyUsage,
<span class="fc" id="L256">                Set&lt;? extends KeyStore.Entry.Attribute&gt; attributes) {</span>
<span class="fc" id="L257">            this.date = new Date();</span>
<span class="fc" id="L258">            this.cert = cert;</span>
<span class="fc" id="L259">            this.keyId = keyId;</span>
<span class="fc" id="L260">            this.alias = alias;</span>
<span class="fc" id="L261">            this.trustedKeyUsage = trustedKeyUsage;</span>
<span class="fc" id="L262">            this.attributes = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">            if (attributes != null) {</span>
<span class="nc" id="L264">                this.attributes.addAll(attributes);</span>
            }
<span class="fc" id="L266">        }</span>
    }

    /**
     * Private keys and certificates are stored in a map.
     * Map entries are keyed by alias names.
     */
<span class="fc" id="L273">    private Map&lt;String, Entry&gt; entries =</span>
<span class="fc" id="L274">        Collections.synchronizedMap(new LinkedHashMap&lt;String, Entry&gt;());</span>

<span class="fc" id="L276">    private ArrayList&lt;KeyEntry&gt; keyList = new ArrayList&lt;KeyEntry&gt;();</span>
<span class="fc" id="L277">    private LinkedHashMap&lt;X500Principal, X509Certificate&gt; certsMap =</span>
            new LinkedHashMap&lt;X500Principal, X509Certificate&gt;();
<span class="fc" id="L279">    private ArrayList&lt;CertEntry&gt; certEntries = new ArrayList&lt;CertEntry&gt;();</span>

    /**
     * Returns the key associated with the given alias, using the given
     * password to recover it.
     *
     * @param alias the alias name
     * @param password the password for recovering the key
     *
     * @return the requested key, or null if the given alias does not exist
     * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
     *
     * @exception NoSuchAlgorithmException if the algorithm for recovering the
     * key cannot be found
     * @exception UnrecoverableKeyException if the key cannot be recovered
     * (e.g., the given password is wrong).
     */
    public Key engineGetKey(String alias, char[] password)
        throws NoSuchAlgorithmException, UnrecoverableKeyException
    {
<span class="fc" id="L299">        Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));</span>
<span class="fc" id="L300">        Key key = null;</span>

<span class="pc bpc" id="L302" title="2 of 4 branches missed.">        if (entry == null || (!(entry instanceof KeyEntry))) {</span>
<span class="nc" id="L303">            return null;</span>
        }

        // get the encoded private key or secret key
<span class="fc" id="L307">        byte[] encrBytes = null;</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if (entry instanceof PrivateKeyEntry) {</span>
<span class="fc" id="L309">            encrBytes = ((PrivateKeyEntry) entry).protectedPrivKey;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        } else if (entry instanceof SecretKeyEntry) {</span>
<span class="nc" id="L311">            encrBytes = ((SecretKeyEntry) entry).protectedSecretKey;</span>
        } else {
<span class="nc" id="L313">            throw new UnrecoverableKeyException(&quot;Error locating key&quot;);</span>
        }

        byte[] encryptedKey;
        AlgorithmParameters algParams;
        ObjectIdentifier algOid;
        try {
            // get the encrypted private key
<span class="fc" id="L321">            EncryptedPrivateKeyInfo encrInfo =</span>
                        new EncryptedPrivateKeyInfo(encrBytes);
<span class="fc" id="L323">            encryptedKey = encrInfo.getEncryptedData();</span>

            // parse Algorithm parameters
<span class="fc" id="L326">            DerValue val = new DerValue(encrInfo.getAlgorithm().encode());</span>
<span class="fc" id="L327">            DerInputStream in = val.toDerInputStream();</span>
<span class="fc" id="L328">            algOid = in.getOID();</span>
<span class="fc" id="L329">            algParams = parseAlgParameters(algOid, in);</span>

<span class="nc" id="L331">        } catch (IOException ioe) {</span>
<span class="nc" id="L332">            UnrecoverableKeyException uke =</span>
                new UnrecoverableKeyException(&quot;Private key not stored as &quot;
                                 + &quot;PKCS#8 EncryptedPrivateKeyInfo: &quot; + ioe);
<span class="nc" id="L335">            uke.initCause(ioe);</span>
<span class="nc" id="L336">            throw uke;</span>
<span class="fc" id="L337">        }</span>

        try {
            byte[] keyInfo;
            while (true) {
                try {
                    // Use JCE
<span class="fc" id="L344">                    SecretKey skey = getPBEKey(password);</span>
<span class="fc" id="L345">                    Cipher cipher = Cipher.getInstance(</span>
<span class="fc" id="L346">                        mapPBEParamsToAlgorithm(algOid, algParams));</span>
<span class="fc" id="L347">                    cipher.init(Cipher.DECRYPT_MODE, skey, algParams);</span>
<span class="fc" id="L348">                    keyInfo = cipher.doFinal(encryptedKey);</span>
<span class="fc" id="L349">                    break;</span>
<span class="nc" id="L350">                } catch (Exception e) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    if (password.length == 0) {</span>
                        // Retry using an empty password
                        // without a NULL terminator.
<span class="nc" id="L354">                        password = new char[1];</span>
<span class="nc" id="L355">                        continue;</span>
                    }
<span class="nc" id="L357">                    throw e;</span>
                }
            }

            /*
             * Parse the key algorithm and then use a JCA key factory
             * to re-create the key.
             */
<span class="fc" id="L365">            DerValue val = new DerValue(keyInfo);</span>
<span class="fc" id="L366">            DerInputStream in = val.toDerInputStream();</span>
<span class="fc" id="L367">            int i = in.getInteger();</span>
<span class="fc" id="L368">            DerValue[] value = in.getSequence(2);</span>
<span class="fc" id="L369">            AlgorithmId algId = new AlgorithmId(value[0].getOID());</span>
<span class="fc" id="L370">            String keyAlgo = algId.getName();</span>

            // decode private key
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">            if (entry instanceof PrivateKeyEntry) {</span>
<span class="fc" id="L374">                KeyFactory kfac = KeyFactory.getInstance(keyAlgo);</span>
<span class="fc" id="L375">                PKCS8EncodedKeySpec kspec = new PKCS8EncodedKeySpec(keyInfo);</span>
<span class="fc" id="L376">                key = kfac.generatePrivate(kspec);</span>

<span class="pc bpc" id="L378" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L379">                    debug.println(&quot;Retrieved a protected private key (&quot; +</span>
<span class="nc" id="L380">                        key.getClass().getName() + &quot;) at alias '&quot; + alias +</span>
                        &quot;'&quot;);
                }

            // decode secret key
<span class="fc" id="L385">            } else {</span>
<span class="nc" id="L386">                SecretKeyFactory sKeyFactory =</span>
<span class="nc" id="L387">                    SecretKeyFactory.getInstance(keyAlgo);</span>
<span class="nc" id="L388">                byte[] keyBytes = in.getOctetString();</span>
<span class="nc" id="L389">                SecretKeySpec secretKeySpec =</span>
                    new SecretKeySpec(keyBytes, keyAlgo);

                // Special handling required for PBE: needs a PBEKeySpec
<span class="nc bnc" id="L393" title="All 2 branches missed.">                if (keyAlgo.startsWith(&quot;PBE&quot;)) {</span>
<span class="nc" id="L394">                    KeySpec pbeKeySpec =</span>
<span class="nc" id="L395">                        sKeyFactory.getKeySpec(secretKeySpec, PBEKeySpec.class);</span>
<span class="nc" id="L396">                    key = sKeyFactory.generateSecret(pbeKeySpec);</span>
<span class="nc" id="L397">                } else {</span>
<span class="nc" id="L398">                    key = sKeyFactory.generateSecret(secretKeySpec);</span>
                }

<span class="nc bnc" id="L401" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L402">                    debug.println(&quot;Retrieved a protected secret key (&quot; +</span>
<span class="nc" id="L403">                        key.getClass().getName() + &quot;) at alias '&quot; + alias +</span>
                        &quot;'&quot;);
                }
            }
<span class="nc" id="L407">        } catch (Exception e) {</span>
<span class="nc" id="L408">            UnrecoverableKeyException uke =</span>
                new UnrecoverableKeyException(&quot;Get Key failed: &quot; +
<span class="nc" id="L410">                                        e.getMessage());</span>
<span class="nc" id="L411">            uke.initCause(e);</span>
<span class="nc" id="L412">            throw uke;</span>
<span class="fc" id="L413">        }</span>
<span class="fc" id="L414">        return key;</span>
    }

    /**
     * Returns the certificate chain associated with the given alias.
     *
     * @param alias the alias name
     *
     * @return the certificate chain (ordered with the user's certificate first
     * and the root certificate authority last), or null if the given alias
     * does not exist or does not contain a certificate chain (i.e., the given
     * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
     * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
     */
    public Certificate[] engineGetCertificateChain(String alias) {
<span class="fc" id="L429">        Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));</span>
<span class="pc bpc" id="L430" title="2 of 4 branches missed.">        if (entry != null &amp;&amp; entry instanceof PrivateKeyEntry) {</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">            if (((PrivateKeyEntry) entry).chain == null) {</span>
<span class="nc" id="L432">                return null;</span>
            } else {

<span class="pc bpc" id="L435" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L436">                    debug.println(&quot;Retrieved a &quot; +</span>
                        ((PrivateKeyEntry) entry).chain.length +
                        &quot;-certificate chain at alias '&quot; + alias + &quot;'&quot;);
                }

<span class="fc" id="L441">                return ((PrivateKeyEntry) entry).chain.clone();</span>
            }
        } else {
<span class="nc" id="L444">            return null;</span>
        }
    }

    /**
     * Returns the certificate associated with the given alias.
     *
     * &lt;p&gt;If the given alias name identifies a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with that
     * entry is returned. If the given alias name identifies a
     * &lt;i&gt;key entry&lt;/i&gt;, the first element of the certificate chain of that
     * entry is returned, or null if that entry does not have a certificate
     * chain.
     *
     * @param alias the alias name
     *
     * @return the certificate, or null if the given alias does not exist or
     * does not contain a certificate.
     */
    public Certificate engineGetCertificate(String alias) {
<span class="nc" id="L464">        Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (entry == null) {</span>
<span class="nc" id="L466">            return null;</span>
        }
<span class="nc bnc" id="L468" title="All 4 branches missed.">        if (entry instanceof CertEntry &amp;&amp;</span>
            ((CertEntry) entry).trustedKeyUsage != null) {

<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (Arrays.equals(AnyUsage,</span>
                    ((CertEntry) entry).trustedKeyUsage)) {
<span class="nc" id="L474">                    debug.println(&quot;Retrieved a certificate at alias '&quot; + alias +</span>
                        &quot;' (trusted for any purpose)&quot;);
                } else {
<span class="nc" id="L477">                    debug.println(&quot;Retrieved a certificate at alias '&quot; + alias +</span>
                        &quot;' (trusted for limited purposes)&quot;);
                }
            }

<span class="nc" id="L482">            return ((CertEntry) entry).cert;</span>

<span class="nc bnc" id="L484" title="All 2 branches missed.">        } else if (entry instanceof PrivateKeyEntry) {</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (((PrivateKeyEntry) entry).chain == null) {</span>
<span class="nc" id="L486">                return null;</span>
            } else {

<span class="nc bnc" id="L489" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L490">                    debug.println(&quot;Retrieved a certificate at alias '&quot; + alias +</span>
                        &quot;'&quot;);
                }

<span class="nc" id="L494">                return ((PrivateKeyEntry) entry).chain[0];</span>
            }

        } else {
<span class="nc" id="L498">            return null;</span>
        }
    }

    /**
     * Returns the creation date of the entry identified by the given alias.
     *
     * @param alias the alias name
     *
     * @return the creation date of this entry, or null if the given alias does
     * not exist
     */
    public Date engineGetCreationDate(String alias) {
<span class="nc" id="L511">        Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (entry != null) {</span>
<span class="nc" id="L513">            return new Date(entry.date.getTime());</span>
        } else {
<span class="nc" id="L515">            return null;</span>
        }
    }

    /**
     * Assigns the given key to the given alias, protecting it with the given
     * password.
     *
     * &lt;p&gt;If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
     * it must be accompanied by a certificate chain certifying the
     * corresponding public key.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key (and possibly
     * certificate chain).
     *
     * @param alias the alias name
     * @param key the key to be associated with the alias
     * @param password the password to protect the key
     * @param chain the certificate chain for the corresponding public
     * key (only required if the given key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
     *
     * @exception KeyStoreException if the given key cannot be protected, or
     * this operation fails for some other reason
     */
    public synchronized void engineSetKeyEntry(String alias, Key key,
                        char[] password, Certificate[] chain)
        throws KeyStoreException
    {
<span class="nc" id="L545">        KeyStore.PasswordProtection passwordProtection =</span>
            new KeyStore.PasswordProtection(password);

        try {
<span class="nc" id="L549">            setKeyEntry(alias, key, passwordProtection, chain, null);</span>

        } finally {
<span class="nc" id="L552">            try {</span>
<span class="nc" id="L553">                passwordProtection.destroy();</span>
<span class="nc" id="L554">            } catch (DestroyFailedException dfe) {</span>
                // ignore
<span class="nc" id="L556">            }</span>
<span class="nc" id="L557">        }</span>
<span class="nc" id="L558">    }</span>

    /*
     * Sets a key entry (with attributes, when present)
     */
    private void setKeyEntry(String alias, Key key,
        KeyStore.PasswordProtection passwordProtection, Certificate[] chain,
        Set&lt;KeyStore.Entry.Attribute&gt; attributes)
            throws KeyStoreException
    {
        try {
            Entry entry;

<span class="nc bnc" id="L571" title="All 2 branches missed.">            if (key instanceof PrivateKey) {</span>
<span class="nc" id="L572">                PrivateKeyEntry keyEntry = new PrivateKeyEntry();</span>
<span class="nc" id="L573">                keyEntry.date = new Date();</span>

<span class="nc bnc" id="L575" title="All 2 branches missed.">                if ((key.getFormat().equals(&quot;PKCS#8&quot;)) ||</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">                    (key.getFormat().equals(&quot;PKCS8&quot;))) {</span>

<span class="nc bnc" id="L578" title="All 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L579">                        debug.println(&quot;Setting a protected private key (&quot; +</span>
<span class="nc" id="L580">                            key.getClass().getName() + &quot;) at alias '&quot; + alias +</span>
                            &quot;'&quot;);
                        }

                    // Encrypt the private key
<span class="nc" id="L585">                    keyEntry.protectedPrivKey =</span>
<span class="nc" id="L586">                        encryptPrivateKey(key.getEncoded(), passwordProtection);</span>
                } else {
<span class="nc" id="L588">                    throw new KeyStoreException(&quot;Private key is not encoded&quot; +</span>
                                &quot;as PKCS#8&quot;);
                }

                // clone the chain
<span class="nc bnc" id="L593" title="All 2 branches missed.">                if (chain != null) {</span>
                    // validate cert-chain
<span class="nc bnc" id="L595" title="All 4 branches missed.">                    if ((chain.length &gt; 1) &amp;&amp; (!validateChain(chain)))</span>
<span class="nc" id="L596">                       throw new KeyStoreException(&quot;Certificate chain is &quot; +</span>
                                                &quot;not valid&quot;);
<span class="nc" id="L598">                    keyEntry.chain = chain.clone();</span>
<span class="nc" id="L599">                    certificateCount += chain.length;</span>

<span class="nc bnc" id="L601" title="All 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L602">                        debug.println(&quot;Setting a &quot; + chain.length +</span>
                            &quot;-certificate chain at alias '&quot; + alias + &quot;'&quot;);
                    }
                }
<span class="nc" id="L606">                privateKeyCount++;</span>
<span class="nc" id="L607">                entry = keyEntry;</span>

<span class="nc bnc" id="L609" title="All 2 branches missed.">            } else if (key instanceof SecretKey) {</span>
<span class="nc" id="L610">                SecretKeyEntry keyEntry = new SecretKeyEntry();</span>
<span class="nc" id="L611">                keyEntry.date = new Date();</span>

                // Encode secret key in a PKCS#8
<span class="nc" id="L614">                DerOutputStream pkcs8 = new DerOutputStream();</span>
<span class="nc" id="L615">                DerOutputStream secretKeyInfo = new DerOutputStream();</span>
<span class="nc" id="L616">                secretKeyInfo.putInteger(0);</span>
<span class="nc" id="L617">                AlgorithmId algId = AlgorithmId.get(key.getAlgorithm());</span>
<span class="nc" id="L618">                algId.encode(secretKeyInfo);</span>
<span class="nc" id="L619">                secretKeyInfo.putOctetString(key.getEncoded());</span>
<span class="nc" id="L620">                pkcs8.write(DerValue.tag_Sequence, secretKeyInfo);</span>

                // Encrypt the secret key (using same PBE as for private keys)
<span class="nc" id="L623">                keyEntry.protectedSecretKey =</span>
<span class="nc" id="L624">                    encryptPrivateKey(pkcs8.toByteArray(), passwordProtection);</span>

<span class="nc bnc" id="L626" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L627">                    debug.println(&quot;Setting a protected secret key (&quot; +</span>
<span class="nc" id="L628">                        key.getClass().getName() + &quot;) at alias '&quot; + alias +</span>
                        &quot;'&quot;);
                }
<span class="nc" id="L631">                secretKeyCount++;</span>
<span class="nc" id="L632">                entry = keyEntry;</span>

<span class="nc" id="L634">            } else {</span>
<span class="nc" id="L635">                throw new KeyStoreException(&quot;Unsupported Key type&quot;);</span>
            }

<span class="nc" id="L638">            entry.attributes = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">            if (attributes != null) {</span>
<span class="nc" id="L640">                entry.attributes.addAll(attributes);</span>
            }
            // set the keyId to current date
<span class="nc" id="L643">            entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(&quot;UTF8&quot;);</span>
            // set the alias
<span class="nc" id="L645">            entry.alias = alias.toLowerCase(Locale.ENGLISH);</span>
            // add the entry
<span class="nc" id="L647">            entries.put(alias.toLowerCase(Locale.ENGLISH), entry);</span>

<span class="nc" id="L649">        } catch (Exception nsae) {</span>
<span class="nc" id="L650">            throw new KeyStoreException(&quot;Key protection &quot; +</span>
                       &quot; algorithm not found: &quot; + nsae, nsae);
<span class="nc" id="L652">        }</span>
<span class="nc" id="L653">    }</span>

    /**
     * Assigns the given key (that has already been protected) to the given
     * alias.
     *
     * &lt;p&gt;If the protected key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
     * certificate chain certifying the corresponding public key. If the
     * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
     * &lt;code&gt;key&lt;/code&gt; must be encoded as an
     * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key (and possibly
     * certificate chain).
     *
     * @param alias the alias name
     * @param key the key (in protected format) to be associated with the alias
     * @param chain the certificate chain for the corresponding public
     * key (only useful if the protected key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
     *
     * @exception KeyStoreException if this operation fails.
     */
    public synchronized void engineSetKeyEntry(String alias, byte[] key,
                                  Certificate[] chain)
        throws KeyStoreException
    {
        // Private key must be encoded as EncryptedPrivateKeyInfo
        // as defined in PKCS#8
        try {
<span class="nc" id="L685">            new EncryptedPrivateKeyInfo(key);</span>
<span class="nc" id="L686">        } catch (IOException ioe) {</span>
<span class="nc" id="L687">            throw new KeyStoreException(&quot;Private key is not stored&quot;</span>
                    + &quot; as PKCS#8 EncryptedPrivateKeyInfo: &quot; + ioe, ioe);
<span class="nc" id="L689">        }</span>

<span class="nc" id="L691">        PrivateKeyEntry entry = new PrivateKeyEntry();</span>
<span class="nc" id="L692">        entry.date = new Date();</span>

<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L695">            debug.println(&quot;Setting a protected private key at alias '&quot; +</span>
                alias + &quot;'&quot;);
        }

        try {
            // set the keyId to current date
<span class="nc" id="L701">            entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(&quot;UTF8&quot;);</span>
<span class="nc" id="L702">        } catch (UnsupportedEncodingException ex) {</span>
            // Won't happen
<span class="nc" id="L704">        }</span>
        // set the alias
<span class="nc" id="L706">        entry.alias = alias.toLowerCase(Locale.ENGLISH);</span>

<span class="nc" id="L708">        entry.protectedPrivKey = key.clone();</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (chain != null) {</span>
<span class="nc" id="L710">            entry.chain = chain.clone();</span>
<span class="nc" id="L711">            certificateCount += chain.length;</span>

<span class="nc bnc" id="L713" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L714">                debug.println(&quot;Setting a &quot; + entry.chain.length +</span>
                    &quot;-certificate chain at alias '&quot; + alias + &quot;'&quot;);
            }
        }

        // add the entry
<span class="nc" id="L720">        privateKeyCount++;</span>
<span class="nc" id="L721">        entries.put(alias.toLowerCase(Locale.ENGLISH), entry);</span>
<span class="nc" id="L722">    }</span>


    /*
     * Generate random salt
     */
    private byte[] getSalt()
    {
        // Generate a random salt.
<span class="nc" id="L731">        byte[] salt = new byte[SALT_LEN];</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">        if (random == null) {</span>
<span class="nc" id="L733">           random = new SecureRandom();</span>
        }
<span class="nc" id="L735">        random.nextBytes(salt);</span>
<span class="nc" id="L736">        return salt;</span>
    }

    /*
     * Generate PBE Algorithm Parameters
     */
    private AlgorithmParameters getAlgorithmParameters(String algorithm)
        throws IOException
    {
<span class="nc" id="L745">        AlgorithmParameters algParams = null;</span>

        // create PBE parameters from salt and iteration count
<span class="nc" id="L748">        PBEParameterSpec paramSpec =</span>
<span class="nc" id="L749">                new PBEParameterSpec(getSalt(), iterationCount);</span>
        try {
<span class="nc" id="L751">           algParams = AlgorithmParameters.getInstance(algorithm);</span>
<span class="nc" id="L752">           algParams.init(paramSpec);</span>
<span class="nc" id="L753">        } catch (Exception e) {</span>
<span class="nc" id="L754">           throw new IOException(&quot;getAlgorithmParameters failed: &quot; +</span>
<span class="nc" id="L755">                                 e.getMessage(), e);</span>
<span class="nc" id="L756">        }</span>
<span class="nc" id="L757">        return algParams;</span>
    }

    /*
     * parse Algorithm Parameters
     */
    private AlgorithmParameters parseAlgParameters(ObjectIdentifier algorithm,
        DerInputStream in) throws IOException
    {
<span class="fc" id="L766">        AlgorithmParameters algParams = null;</span>
        try {
            DerValue params;
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">            if (in.available() == 0) {</span>
<span class="nc" id="L770">                params = null;</span>
            } else {
<span class="fc" id="L772">                params = in.getDerValue();</span>
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">                if (params.tag == DerValue.tag_Null) {</span>
<span class="nc" id="L774">                   params = null;</span>
                }
            }
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">            if (params != null) {</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">                if (algorithm.equals((Object)pbes2_OID)) {</span>
<span class="nc" id="L779">                    algParams = AlgorithmParameters.getInstance(&quot;PBES2&quot;);</span>
                } else {
<span class="fc" id="L781">                    algParams = AlgorithmParameters.getInstance(&quot;PBE&quot;);</span>
                }
<span class="fc" id="L783">                algParams.init(params.toByteArray());</span>
            }
<span class="nc" id="L785">        } catch (Exception e) {</span>
<span class="nc" id="L786">           throw new IOException(&quot;parseAlgParameters failed: &quot; +</span>
<span class="nc" id="L787">                                 e.getMessage(), e);</span>
<span class="fc" id="L788">        }</span>
<span class="fc" id="L789">        return algParams;</span>
    }

    /*
     * Generate PBE key
     */
    private SecretKey getPBEKey(char[] password) throws IOException
    {
<span class="fc" id="L797">        SecretKey skey = null;</span>

        try {
<span class="fc" id="L800">            PBEKeySpec keySpec = new PBEKeySpec(password);</span>
<span class="fc" id="L801">            SecretKeyFactory skFac = SecretKeyFactory.getInstance(&quot;PBE&quot;);</span>
<span class="fc" id="L802">            skey = skFac.generateSecret(keySpec);</span>
<span class="fc" id="L803">            keySpec.clearPassword();</span>
<span class="nc" id="L804">        } catch (Exception e) {</span>
<span class="nc" id="L805">           throw new IOException(&quot;getSecretKey failed: &quot; +</span>
<span class="nc" id="L806">                                 e.getMessage(), e);</span>
<span class="fc" id="L807">        }</span>
<span class="fc" id="L808">        return skey;</span>
    }

    /*
     * Encrypt private key using Password-based encryption (PBE)
     * as defined in PKCS#5.
     *
     * NOTE: By default, pbeWithSHAAnd3-KeyTripleDES-CBC algorithmID is
     *       used to derive the key and IV.
     *
     * @return encrypted private key encoded as EncryptedPrivateKeyInfo
     */
    private byte[] encryptPrivateKey(byte[] data,
        KeyStore.PasswordProtection passwordProtection)
        throws IOException, NoSuchAlgorithmException, UnrecoverableKeyException
    {
<span class="nc" id="L824">        byte[] key = null;</span>

        try {
            String algorithm;
            AlgorithmParameters algParams;
            AlgorithmId algid;

            // Initialize PBE algorithm and parameters
<span class="nc" id="L832">            algorithm = passwordProtection.getProtectionAlgorithm();</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">            if (algorithm != null) {</span>
<span class="nc" id="L834">                AlgorithmParameterSpec algParamSpec =</span>
<span class="nc" id="L835">                    passwordProtection.getProtectionParameters();</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">                if (algParamSpec != null) {</span>
<span class="nc" id="L837">                    algParams = AlgorithmParameters.getInstance(algorithm);</span>
<span class="nc" id="L838">                    algParams.init(algParamSpec);</span>
                } else {
<span class="nc" id="L840">                    algParams = getAlgorithmParameters(algorithm);</span>
                }
<span class="nc" id="L842">            } else {</span>
                // Check default key protection algorithm for PKCS12 keystores
<span class="nc" id="L844">                algorithm = AccessController.doPrivileged(</span>
<span class="nc" id="L845">                    new PrivilegedAction&lt;String&gt;() {</span>
                        public String run() {
                            String prop =
<span class="nc" id="L848">                                Security.getProperty(</span>
<span class="nc" id="L849">                                    KEY_PROTECTION_ALGORITHM[0]);</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">                            if (prop == null) {</span>
<span class="nc" id="L851">                                prop = Security.getProperty(</span>
<span class="nc" id="L852">                                    KEY_PROTECTION_ALGORITHM[1]);</span>
                            }
<span class="nc" id="L854">                            return prop;</span>
                        }
                    });
<span class="nc bnc" id="L857" title="All 4 branches missed.">                if (algorithm == null || algorithm.isEmpty()) {</span>
<span class="nc" id="L858">                    algorithm = &quot;PBEWithSHA1AndDESede&quot;;</span>
                }
<span class="nc" id="L860">                algParams = getAlgorithmParameters(algorithm);</span>
            }

<span class="nc" id="L863">            ObjectIdentifier pbeOID = mapPBEAlgorithmToOID(algorithm);</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">            if (pbeOID == null) {</span>
<span class="nc" id="L865">                    throw new IOException(&quot;PBE algorithm '&quot; + algorithm +</span>
                        &quot; 'is not supported for key entry protection&quot;);
            }

            // Use JCE
<span class="nc" id="L870">            SecretKey skey = getPBEKey(passwordProtection.getPassword());</span>
<span class="nc" id="L871">            Cipher cipher = Cipher.getInstance(algorithm);</span>
<span class="nc" id="L872">            cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);</span>
<span class="nc" id="L873">            byte[] encryptedKey = cipher.doFinal(data);</span>
<span class="nc" id="L874">            algid = new AlgorithmId(pbeOID, cipher.getParameters());</span>

<span class="nc bnc" id="L876" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L877">                debug.println(&quot;  (Cipher algorithm: &quot; + cipher.getAlgorithm() +</span>
                    &quot;)&quot;);
            }

            // wrap encrypted private key in EncryptedPrivateKeyInfo
            // as defined in PKCS#8
<span class="nc" id="L883">            EncryptedPrivateKeyInfo encrInfo =</span>
                new EncryptedPrivateKeyInfo(algid, encryptedKey);
<span class="nc" id="L885">            key = encrInfo.getEncoded();</span>
<span class="nc" id="L886">        } catch (Exception e) {</span>
<span class="nc" id="L887">            UnrecoverableKeyException uke =</span>
                new UnrecoverableKeyException(&quot;Encrypt Private Key failed: &quot;
<span class="nc" id="L889">                                                + e.getMessage());</span>
<span class="nc" id="L890">            uke.initCause(e);</span>
<span class="nc" id="L891">            throw uke;</span>
<span class="nc" id="L892">        }</span>

<span class="nc" id="L894">        return key;</span>
    }

    /*
     * Map a PBE algorithm name onto its object identifier
     */
    private static ObjectIdentifier mapPBEAlgorithmToOID(String algorithm)
        throws NoSuchAlgorithmException {
        // Check for PBES2 algorithms
<span class="nc bnc" id="L903" title="All 2 branches missed.">        if (algorithm.toLowerCase().startsWith(&quot;pbewithhmacsha&quot;)) {</span>
<span class="nc" id="L904">            return pbes2_OID;</span>
        }
<span class="nc" id="L906">        return AlgorithmId.get(algorithm).getOID();</span>
    }

    /*
     * Map a PBE algorithm parameters onto its algorithm name
     */
    private static String mapPBEParamsToAlgorithm(ObjectIdentifier algorithm,
        AlgorithmParameters algParams) throws NoSuchAlgorithmException {
        // Check for PBES2 algorithms
<span class="pc bpc" id="L915" title="3 of 4 branches missed.">        if (algorithm.equals((Object)pbes2_OID) &amp;&amp; algParams != null) {</span>
<span class="nc" id="L916">            return algParams.toString();</span>
        }
<span class="fc" id="L918">        return algorithm.toString();</span>
    }

    /**
     * Assigns the given certificate to the given alias.
     *
     * &lt;p&gt;If the given alias already exists in this keystore and identifies a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
     * overridden by the given certificate.
     *
     * @param alias the alias name
     * @param cert the certificate
     *
     * @exception KeyStoreException if the given alias already exists and does
     * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation fails
     * for some other reason.
     */
    public synchronized void engineSetCertificateEntry(String alias,
        Certificate cert) throws KeyStoreException
    {
<span class="nc" id="L938">        setCertEntry(alias, cert, null);</span>
<span class="nc" id="L939">    }</span>

    /*
     * Sets a trusted cert entry (with attributes, when present)
     */
    private void setCertEntry(String alias, Certificate cert,
        Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws KeyStoreException {

<span class="nc" id="L947">        Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));</span>
<span class="nc bnc" id="L948" title="All 4 branches missed.">        if (entry != null &amp;&amp; entry instanceof KeyEntry) {</span>
<span class="nc" id="L949">            throw new KeyStoreException(&quot;Cannot overwrite own certificate&quot;);</span>
        }

<span class="nc" id="L952">        CertEntry certEntry =</span>
            new CertEntry((X509Certificate) cert, null, alias, AnyUsage,
                attributes);
<span class="nc" id="L955">        certificateCount++;</span>
<span class="nc" id="L956">        entries.put(alias, certEntry);</span>

<span class="nc bnc" id="L958" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L959">            debug.println(&quot;Setting a trusted certificate at alias '&quot; + alias +</span>
                &quot;'&quot;);
        }
<span class="nc" id="L962">    }</span>

    /**
     * Deletes the entry identified by the given alias from this keystore.
     *
     * @param alias the alias name
     *
     * @exception KeyStoreException if the entry cannot be removed.
     */
    public synchronized void engineDeleteEntry(String alias)
        throws KeyStoreException
    {
<span class="nc bnc" id="L974" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L975">            debug.println(&quot;Removing entry at alias '&quot; + alias + &quot;'&quot;);</span>
        }

<span class="nc" id="L978">        Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">        if (entry instanceof PrivateKeyEntry) {</span>
<span class="nc" id="L980">            PrivateKeyEntry keyEntry = (PrivateKeyEntry) entry;</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">            if (keyEntry.chain != null) {</span>
<span class="nc" id="L982">                certificateCount -= keyEntry.chain.length;</span>
            }
<span class="nc" id="L984">            privateKeyCount--;</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">        } else if (entry instanceof CertEntry) {</span>
<span class="nc" id="L986">            certificateCount--;</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">        } else if (entry instanceof SecretKeyEntry) {</span>
<span class="nc" id="L988">            secretKeyCount--;</span>
        }
<span class="nc" id="L990">        entries.remove(alias.toLowerCase(Locale.ENGLISH));</span>
<span class="nc" id="L991">    }</span>

    /**
     * Lists all the alias names of this keystore.
     *
     * @return enumeration of the alias names
     */
    public Enumeration&lt;String&gt; engineAliases() {
<span class="fc" id="L999">        return Collections.enumeration(entries.keySet());</span>
    }

    /**
     * Checks if the given alias exists in this keystore.
     *
     * @param alias the alias name
     *
     * @return true if the alias exists, false otherwise
     */
    public boolean engineContainsAlias(String alias) {
<span class="nc" id="L1010">        return entries.containsKey(alias.toLowerCase(Locale.ENGLISH));</span>
    }

    /**
     * Retrieves the number of entries in this keystore.
     *
     * @return the number of entries in this keystore
     */
    public int engineSize() {
<span class="nc" id="L1019">        return entries.size();</span>
    }

    /**
     * Returns true if the entry identified by the given alias is a
     * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
     *
     * @return true if the entry identified by the given alias is a
     * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
     */
    public boolean engineIsKeyEntry(String alias) {
<span class="nc" id="L1030">        Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));</span>
<span class="nc bnc" id="L1031" title="All 4 branches missed.">        if (entry != null &amp;&amp; entry instanceof KeyEntry) {</span>
<span class="nc" id="L1032">            return true;</span>
        } else {
<span class="nc" id="L1034">            return false;</span>
        }
    }

    /**
     * Returns true if the entry identified by the given alias is a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
     *
     * @return true if the entry identified by the given alias is a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
     */
    public boolean engineIsCertificateEntry(String alias) {
<span class="nc" id="L1046">        Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));</span>
<span class="nc bnc" id="L1047" title="All 6 branches missed.">        if (entry != null &amp;&amp; entry instanceof CertEntry &amp;&amp;</span>
            ((CertEntry) entry).trustedKeyUsage != null) {
<span class="nc" id="L1049">            return true;</span>
        } else {
<span class="nc" id="L1051">            return false;</span>
        }
    }

    /**
     * Returns the (alias) name of the first keystore entry whose certificate
     * matches the given certificate.
     *
     * &lt;p&gt;This method attempts to match the given certificate with each
     * keystore entry. If the entry being considered
     * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
     * compared to that entry's certificate. If the entry being considered is
     * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
     * element of that entry's certificate chain (if a chain exists).
     *
     * @param cert the certificate to match with.
     *
     * @return the (alias) name of the first entry with matching certificate,
     * or null if no such entry exists in this keystore.
     */
    public String engineGetCertificateAlias(Certificate cert) {
<span class="nc" id="L1072">        Certificate certElem = null;</span>

<span class="nc bnc" id="L1074" title="All 2 branches missed.">        for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {</span>
<span class="nc" id="L1075">            String alias = e.nextElement();</span>
<span class="nc" id="L1076">            Entry entry = entries.get(alias);</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">            if (entry instanceof PrivateKeyEntry) {</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">                if (((PrivateKeyEntry) entry).chain != null) {</span>
<span class="nc" id="L1079">                    certElem = ((PrivateKeyEntry) entry).chain[0];</span>
                }
<span class="nc bnc" id="L1081" title="All 4 branches missed.">            } else if (entry instanceof CertEntry &amp;&amp;</span>
                    ((CertEntry) entry).trustedKeyUsage != null) {
<span class="nc" id="L1083">                certElem = ((CertEntry) entry).cert;</span>
            } else {
                continue;
            }
<span class="nc bnc" id="L1087" title="All 2 branches missed.">            if (certElem.equals(cert)) {</span>
<span class="nc" id="L1088">                return alias;</span>
            }
<span class="nc" id="L1090">        }</span>
<span class="nc" id="L1091">        return null;</span>
    }

    /**
     * Stores this keystore to the given output stream, and protects its
     * integrity with the given password.
     *
     * @param stream the output stream to which this keystore is written.
     * @param password the password to generate the keystore integrity check
     *
     * @exception IOException if there was an I/O problem with data
     * @exception NoSuchAlgorithmException if the appropriate data integrity
     * algorithm could not be found
     * @exception CertificateException if any of the certificates included in
     * the keystore data could not be stored
     */
    public synchronized void engineStore(OutputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
        // password is mandatory when storing
<span class="nc bnc" id="L1111" title="All 2 branches missed.">        if (password == null) {</span>
<span class="nc" id="L1112">           throw new IllegalArgumentException(&quot;password can't be null&quot;);</span>
        }

        // -- Create PFX
<span class="nc" id="L1116">        DerOutputStream pfx = new DerOutputStream();</span>

        // PFX version (always write the latest version)
<span class="nc" id="L1119">        DerOutputStream version = new DerOutputStream();</span>
<span class="nc" id="L1120">        version.putInteger(VERSION_3);</span>
<span class="nc" id="L1121">        byte[] pfxVersion = version.toByteArray();</span>
<span class="nc" id="L1122">        pfx.write(pfxVersion);</span>

        // -- Create AuthSafe
<span class="nc" id="L1125">        DerOutputStream authSafe = new DerOutputStream();</span>

        // -- Create ContentInfos
<span class="nc" id="L1128">        DerOutputStream authSafeContentInfo = new DerOutputStream();</span>

        // -- create safeContent Data ContentInfo
<span class="nc bnc" id="L1131" title="All 4 branches missed.">        if (privateKeyCount &gt; 0 || secretKeyCount &gt; 0) {</span>

<span class="nc bnc" id="L1133" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L1134">                debug.println(&quot;Storing &quot; + (privateKeyCount + secretKeyCount) +</span>
                    &quot; protected key(s) in a PKCS#7 data content-type&quot;);
            }

<span class="nc" id="L1138">            byte[] safeContentData = createSafeContent();</span>
<span class="nc" id="L1139">            ContentInfo dataContentInfo = new ContentInfo(safeContentData);</span>
<span class="nc" id="L1140">            dataContentInfo.encode(authSafeContentInfo);</span>
        }

        // -- create EncryptedContentInfo
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        if (certificateCount &gt; 0) {</span>

<span class="nc bnc" id="L1146" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L1147">                debug.println(&quot;Storing &quot; + certificateCount +</span>
                    &quot; certificate(s) in a PKCS#7 encryptedData content-type&quot;);
            }

<span class="nc" id="L1151">            byte[] encrData = createEncryptedData(password);</span>
<span class="nc" id="L1152">            ContentInfo encrContentInfo =</span>
                new ContentInfo(ContentInfo.ENCRYPTED_DATA_OID,
                                new DerValue(encrData));
<span class="nc" id="L1155">            encrContentInfo.encode(authSafeContentInfo);</span>
        }

        // wrap as SequenceOf ContentInfos
<span class="nc" id="L1159">        DerOutputStream cInfo = new DerOutputStream();</span>
<span class="nc" id="L1160">        cInfo.write(DerValue.tag_SequenceOf, authSafeContentInfo);</span>
<span class="nc" id="L1161">        byte[] authenticatedSafe = cInfo.toByteArray();</span>

        // Create Encapsulated ContentInfo
<span class="nc" id="L1164">        ContentInfo contentInfo = new ContentInfo(authenticatedSafe);</span>
<span class="nc" id="L1165">        contentInfo.encode(authSafe);</span>
<span class="nc" id="L1166">        byte[] authSafeData = authSafe.toByteArray();</span>
<span class="nc" id="L1167">        pfx.write(authSafeData);</span>

        // -- MAC
<span class="nc" id="L1170">        byte[] macData = calculateMac(password, authenticatedSafe);</span>
<span class="nc" id="L1171">        pfx.write(macData);</span>

        // write PFX to output stream
<span class="nc" id="L1174">        DerOutputStream pfxout = new DerOutputStream();</span>
<span class="nc" id="L1175">        pfxout.write(DerValue.tag_Sequence, pfx);</span>
<span class="nc" id="L1176">        byte[] pfxData = pfxout.toByteArray();</span>
<span class="nc" id="L1177">        stream.write(pfxData);</span>
<span class="nc" id="L1178">        stream.flush();</span>
<span class="nc" id="L1179">    }</span>

    /**
     * Gets a &lt;code&gt;KeyStore.Entry&lt;/code&gt; for the specified alias
     * with the specified protection parameter.
     *
     * @param alias get the &lt;code&gt;KeyStore.Entry&lt;/code&gt; for this alias
     * @param protParam the &lt;code&gt;ProtectionParameter&lt;/code&gt;
     *          used to protect the &lt;code&gt;Entry&lt;/code&gt;,
     *          which may be &lt;code&gt;null&lt;/code&gt;
     *
     * @return the &lt;code&gt;KeyStore.Entry&lt;/code&gt; for the specified alias,
     *          or &lt;code&gt;null&lt;/code&gt; if there is no such entry
     *
     * @exception KeyStoreException if the operation failed
     * @exception NoSuchAlgorithmException if the algorithm for recovering the
     *          entry cannot be found
     * @exception UnrecoverableEntryException if the specified
     *          &lt;code&gt;protParam&lt;/code&gt; were insufficient or invalid
     * @exception UnrecoverableKeyException if the entry is a
     *          &lt;code&gt;PrivateKeyEntry&lt;/code&gt; or &lt;code&gt;SecretKeyEntry&lt;/code&gt;
     *          and the specified &lt;code&gt;protParam&lt;/code&gt; does not contain
     *          the information needed to recover the key (e.g. wrong password)
     *
     * @since 1.5
     */
    @Override
    public KeyStore.Entry engineGetEntry(String alias,
                        KeyStore.ProtectionParameter protParam)
                throws KeyStoreException, NoSuchAlgorithmException,
                UnrecoverableEntryException {

<span class="nc bnc" id="L1211" title="All 2 branches missed.">        if (!engineContainsAlias(alias)) {</span>
<span class="nc" id="L1212">            return null;</span>
        }

<span class="nc" id="L1215">        Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">        if (protParam == null) {</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">            if (engineIsCertificateEntry(alias)) {</span>
<span class="nc bnc" id="L1218" title="All 4 branches missed.">                if (entry instanceof CertEntry &amp;&amp;</span>
                    ((CertEntry) entry).trustedKeyUsage != null) {

<span class="nc bnc" id="L1221" title="All 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L1222">                        debug.println(&quot;Retrieved a trusted certificate at &quot; +</span>
                            &quot;alias '&quot; + alias + &quot;'&quot;);
                    }

<span class="nc" id="L1226">                    return new KeyStore.TrustedCertificateEntry(</span>
<span class="nc" id="L1227">                        ((CertEntry)entry).cert, getAttributes(entry));</span>
                }
            } else {
<span class="nc" id="L1230">                throw new UnrecoverableKeyException</span>
                        (&quot;requested entry requires a password&quot;);
            }
        }

<span class="nc bnc" id="L1235" title="All 2 branches missed.">        if (protParam instanceof KeyStore.PasswordProtection) {</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">            if (engineIsCertificateEntry(alias)) {</span>
<span class="nc" id="L1237">                throw new UnsupportedOperationException</span>
                    (&quot;trusted certificate entries are not password-protected&quot;);
<span class="nc bnc" id="L1239" title="All 2 branches missed.">            } else if (engineIsKeyEntry(alias)) {</span>
<span class="nc" id="L1240">                KeyStore.PasswordProtection pp =</span>
                        (KeyStore.PasswordProtection)protParam;
<span class="nc" id="L1242">                char[] password = pp.getPassword();</span>

<span class="nc" id="L1244">                Key key = engineGetKey(alias, password);</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">                if (key instanceof PrivateKey) {</span>
<span class="nc" id="L1246">                    Certificate[] chain = engineGetCertificateChain(alias);</span>

<span class="nc" id="L1248">                    return new KeyStore.PrivateKeyEntry((PrivateKey)key, chain,</span>
<span class="nc" id="L1249">                        getAttributes(entry));</span>

<span class="nc bnc" id="L1251" title="All 2 branches missed.">                } else if (key instanceof SecretKey) {</span>

<span class="nc" id="L1253">                    return new KeyStore.SecretKeyEntry((SecretKey)key,</span>
<span class="nc" id="L1254">                        getAttributes(entry));</span>
                }
<span class="nc bnc" id="L1256" title="All 2 branches missed.">            } else if (!engineIsKeyEntry(alias)) {</span>
<span class="nc" id="L1257">                throw new UnsupportedOperationException</span>
                    (&quot;untrusted certificate entries are not &quot; +
                        &quot;password-protected&quot;);
            }
        }

<span class="nc" id="L1263">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Saves a &lt;code&gt;KeyStore.Entry&lt;/code&gt; under the specified alias.
     * The specified protection parameter is used to protect the
     * &lt;code&gt;Entry&lt;/code&gt;.
     *
     * &lt;p&gt; If an entry already exists for the specified alias,
     * it is overridden.
     *
     * @param alias save the &lt;code&gt;KeyStore.Entry&lt;/code&gt; under this alias
     * @param entry the &lt;code&gt;Entry&lt;/code&gt; to save
     * @param protParam the &lt;code&gt;ProtectionParameter&lt;/code&gt;
     *          used to protect the &lt;code&gt;Entry&lt;/code&gt;,
     *          which may be &lt;code&gt;null&lt;/code&gt;
     *
     * @exception KeyStoreException if this operation fails
     *
     * @since 1.5
     */
    @Override
    public synchronized void engineSetEntry(String alias, KeyStore.Entry entry,
        KeyStore.ProtectionParameter protParam) throws KeyStoreException {

        // get password
<span class="nc bnc" id="L1289" title="All 4 branches missed.">        if (protParam != null &amp;&amp;</span>
            !(protParam instanceof KeyStore.PasswordProtection)) {
<span class="nc" id="L1291">            throw new KeyStoreException(&quot;unsupported protection parameter&quot;);</span>
        }
<span class="nc" id="L1293">        KeyStore.PasswordProtection pProtect = null;</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">        if (protParam != null) {</span>
<span class="nc" id="L1295">            pProtect = (KeyStore.PasswordProtection)protParam;</span>
        }

        // set entry
<span class="nc bnc" id="L1299" title="All 2 branches missed.">        if (entry instanceof KeyStore.TrustedCertificateEntry) {</span>
<span class="nc bnc" id="L1300" title="All 4 branches missed.">            if (protParam != null &amp;&amp; pProtect.getPassword() != null) {</span>
                // pre-1.5 style setCertificateEntry did not allow password
<span class="nc" id="L1302">                throw new KeyStoreException</span>
                    (&quot;trusted certificate entries are not password-protected&quot;);
            } else {
<span class="nc" id="L1305">                KeyStore.TrustedCertificateEntry tce =</span>
                        (KeyStore.TrustedCertificateEntry)entry;
<span class="nc" id="L1307">                setCertEntry(alias, tce.getTrustedCertificate(),</span>
<span class="nc" id="L1308">                    tce.getAttributes());</span>

<span class="nc" id="L1310">                return;</span>
            }
<span class="nc bnc" id="L1312" title="All 2 branches missed.">        } else if (entry instanceof KeyStore.PrivateKeyEntry) {</span>
<span class="nc bnc" id="L1313" title="All 4 branches missed.">            if (pProtect == null || pProtect.getPassword() == null) {</span>
                // pre-1.5 style setKeyEntry required password
<span class="nc" id="L1315">                throw new KeyStoreException</span>
                    (&quot;non-null password required to create PrivateKeyEntry&quot;);
            } else {
<span class="nc" id="L1318">                KeyStore.PrivateKeyEntry pke = (KeyStore.PrivateKeyEntry)entry;</span>
<span class="nc" id="L1319">                setKeyEntry(alias, pke.getPrivateKey(), pProtect,</span>
<span class="nc" id="L1320">                    pke.getCertificateChain(), pke.getAttributes());</span>

<span class="nc" id="L1322">                return;</span>
            }
<span class="nc bnc" id="L1324" title="All 2 branches missed.">        } else if (entry instanceof KeyStore.SecretKeyEntry) {</span>
<span class="nc bnc" id="L1325" title="All 4 branches missed.">            if (pProtect == null || pProtect.getPassword() == null) {</span>
                // pre-1.5 style setKeyEntry required password
<span class="nc" id="L1327">                throw new KeyStoreException</span>
                    (&quot;non-null password required to create SecretKeyEntry&quot;);
            } else {
<span class="nc" id="L1330">                KeyStore.SecretKeyEntry ske = (KeyStore.SecretKeyEntry)entry;</span>
<span class="nc" id="L1331">                setKeyEntry(alias, ske.getSecretKey(), pProtect,</span>
<span class="nc" id="L1332">                    (Certificate[])null, ske.getAttributes());</span>

<span class="nc" id="L1334">                return;</span>
            }
        }

<span class="nc" id="L1338">        throw new KeyStoreException</span>
<span class="nc" id="L1339">                (&quot;unsupported entry type: &quot; + entry.getClass().getName());</span>
    }

    /*
     * Assemble the entry attributes
     */
    private Set&lt;KeyStore.Entry.Attribute&gt; getAttributes(Entry entry) {

<span class="nc bnc" id="L1347" title="All 2 branches missed.">        if (entry.attributes == null) {</span>
<span class="nc" id="L1348">            entry.attributes = new HashSet&lt;&gt;();</span>
        }

        // friendlyName
<span class="nc" id="L1352">        entry.attributes.add(new PKCS12Attribute(</span>
<span class="nc" id="L1353">            PKCS9FriendlyName_OID.toString(), entry.alias));</span>

        // localKeyID
<span class="nc" id="L1356">        byte[] keyIdValue = entry.keyId;</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">        if (keyIdValue != null) {</span>
<span class="nc" id="L1358">            entry.attributes.add(new PKCS12Attribute(</span>
<span class="nc" id="L1359">                PKCS9LocalKeyId_OID.toString(), Debug.toString(keyIdValue)));</span>
        }

        // trustedKeyUsage
<span class="nc bnc" id="L1363" title="All 2 branches missed.">        if (entry instanceof CertEntry) {</span>
<span class="nc" id="L1364">            ObjectIdentifier[] trustedKeyUsageValue =</span>
                ((CertEntry) entry).trustedKeyUsage;
<span class="nc bnc" id="L1366" title="All 2 branches missed.">            if (trustedKeyUsageValue != null) {</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">                if (trustedKeyUsageValue.length == 1) { // omit brackets</span>
<span class="nc" id="L1368">                    entry.attributes.add(new PKCS12Attribute(</span>
<span class="nc" id="L1369">                        TrustedKeyUsage_OID.toString(),</span>
<span class="nc" id="L1370">                        trustedKeyUsageValue[0].toString()));</span>
                } else { // multi-valued
<span class="nc" id="L1372">                    entry.attributes.add(new PKCS12Attribute(</span>
<span class="nc" id="L1373">                        TrustedKeyUsage_OID.toString(),</span>
<span class="nc" id="L1374">                        Arrays.toString(trustedKeyUsageValue)));</span>
                }
            }
        }

<span class="nc" id="L1379">        return entry.attributes;</span>
    }

    /*
     * Generate Hash.
     */
    private byte[] generateHash(byte[] data) throws IOException
    {
<span class="nc" id="L1387">        byte[] digest = null;</span>

        try {
<span class="nc" id="L1390">            MessageDigest md = MessageDigest.getInstance(&quot;SHA1&quot;);</span>
<span class="nc" id="L1391">            md.update(data);</span>
<span class="nc" id="L1392">            digest = md.digest();</span>
<span class="nc" id="L1393">        } catch (Exception e) {</span>
<span class="nc" id="L1394">            throw new IOException(&quot;generateHash failed: &quot; + e, e);</span>
<span class="nc" id="L1395">        }</span>
<span class="nc" id="L1396">        return digest;</span>
    }


    /*
     * Calculate MAC using HMAC algorithm (required for password integrity)
     *
     * Hash-based MAC algorithm combines secret key with message digest to
     * create a message authentication code (MAC)
     */
    private byte[] calculateMac(char[] passwd, byte[] data)
        throws IOException
    {
<span class="nc" id="L1409">        byte[] mData = null;</span>
<span class="nc" id="L1410">        String algName = &quot;SHA1&quot;;</span>

        try {
            // Generate a random salt.
<span class="nc" id="L1414">            byte[] salt = getSalt();</span>

            // generate MAC (MAC key is generated within JCE)
<span class="nc" id="L1417">            Mac m = Mac.getInstance(&quot;HmacPBESHA1&quot;);</span>
<span class="nc" id="L1418">            PBEParameterSpec params =</span>
                        new PBEParameterSpec(salt, iterationCount);
<span class="nc" id="L1420">            SecretKey key = getPBEKey(passwd);</span>
<span class="nc" id="L1421">            m.init(key, params);</span>
<span class="nc" id="L1422">            m.update(data);</span>
<span class="nc" id="L1423">            byte[] macResult = m.doFinal();</span>

            // encode as MacData
<span class="nc" id="L1426">            MacData macData = new MacData(algName, macResult, salt,</span>
                                                iterationCount);
<span class="nc" id="L1428">            DerOutputStream bytes = new DerOutputStream();</span>
<span class="nc" id="L1429">            bytes.write(macData.getEncoded());</span>
<span class="nc" id="L1430">            mData = bytes.toByteArray();</span>
<span class="nc" id="L1431">        } catch (Exception e) {</span>
<span class="nc" id="L1432">            throw new IOException(&quot;calculateMac failed: &quot; + e, e);</span>
<span class="nc" id="L1433">        }</span>
<span class="nc" id="L1434">        return mData;</span>
    }


    /*
     * Validate Certificate Chain
     */
    private boolean validateChain(Certificate[] certChain)
    {
<span class="nc bnc" id="L1443" title="All 2 branches missed.">        for (int i = 0; i &lt; certChain.length-1; i++) {</span>
<span class="nc" id="L1444">            X500Principal issuerDN =</span>
<span class="nc" id="L1445">                ((X509Certificate)certChain[i]).getIssuerX500Principal();</span>
<span class="nc" id="L1446">            X500Principal subjectDN =</span>
<span class="nc" id="L1447">                ((X509Certificate)certChain[i+1]).getSubjectX500Principal();</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">            if (!(issuerDN.equals(subjectDN)))</span>
<span class="nc" id="L1449">                return false;</span>
        }
<span class="nc" id="L1451">        return true;</span>
    }


    /*
     * Create PKCS#12 Attributes, friendlyName, localKeyId and trustedKeyUsage.
     *
     * Although attributes are optional, they could be required.
     * For e.g. localKeyId attribute is required to match the
     * private key with the associated end-entity certificate.
     * The trustedKeyUsage attribute is used to denote a trusted certificate.
     *
     * PKCS8ShroudedKeyBags include unique localKeyID and friendlyName.
     * CertBags may or may not include attributes depending on the type
     * of Certificate. In end-entity certificates, localKeyID should be
     * unique, and the corresponding private key should have the same
     * localKeyID. For trusted CA certs in the cert-chain, localKeyID
     * attribute is not required, hence most vendors don't include it.
     * NSS/Netscape require it to be unique or null, where as IE/OpenSSL
     * ignore it.
     *
     * Here is a list of pkcs12 attribute values in CertBags.
     *
     * PKCS12 Attribute       NSS/Netscape    IE     OpenSSL    J2SE
     * --------------------------------------------------------------
     * LocalKeyId
     * (In EE cert only,
     *  NULL in CA certs)      true          true     true      true
     *
     * friendlyName            unique        same/    same/     unique
     *                                       unique   unique/
     *                                                null
     * trustedKeyUsage         -             -        -         true
     *
     * Note: OpenSSL adds friendlyName for end-entity cert only, and
     * removes the localKeyID and friendlyName for CA certs.
     * If the CertBag did not have a friendlyName, most vendors will
     * add it, and assign it to the DN of the cert.
     */
    private byte[] getBagAttributes(String alias, byte[] keyId,
        Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws IOException {
<span class="nc" id="L1492">        return getBagAttributes(alias, keyId, null, attributes);</span>
    }

    private byte[] getBagAttributes(String alias, byte[] keyId,
        ObjectIdentifier[] trustedUsage,
        Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws IOException {

<span class="nc" id="L1499">        byte[] localKeyID = null;</span>
<span class="nc" id="L1500">        byte[] friendlyName = null;</span>
<span class="nc" id="L1501">        byte[] trustedKeyUsage = null;</span>

        // return null if all three attributes are null
<span class="nc bnc" id="L1504" title="All 6 branches missed.">        if ((alias == null) &amp;&amp; (keyId == null) &amp;&amp; (trustedKeyUsage == null)) {</span>
<span class="nc" id="L1505">            return null;</span>
        }

        // SafeBag Attributes
<span class="nc" id="L1509">        DerOutputStream bagAttrs = new DerOutputStream();</span>

        // Encode the friendlyname oid.
<span class="nc bnc" id="L1512" title="All 2 branches missed.">        if (alias != null) {</span>
<span class="nc" id="L1513">            DerOutputStream bagAttr1 = new DerOutputStream();</span>
<span class="nc" id="L1514">            bagAttr1.putOID(PKCS9FriendlyName_OID);</span>
<span class="nc" id="L1515">            DerOutputStream bagAttrContent1 = new DerOutputStream();</span>
<span class="nc" id="L1516">            DerOutputStream bagAttrValue1 = new DerOutputStream();</span>
<span class="nc" id="L1517">            bagAttrContent1.putBMPString(alias);</span>
<span class="nc" id="L1518">            bagAttr1.write(DerValue.tag_Set, bagAttrContent1);</span>
<span class="nc" id="L1519">            bagAttrValue1.write(DerValue.tag_Sequence, bagAttr1);</span>
<span class="nc" id="L1520">            friendlyName = bagAttrValue1.toByteArray();</span>
        }

        // Encode the localkeyId oid.
<span class="nc bnc" id="L1524" title="All 2 branches missed.">        if (keyId != null) {</span>
<span class="nc" id="L1525">            DerOutputStream bagAttr2 = new DerOutputStream();</span>
<span class="nc" id="L1526">            bagAttr2.putOID(PKCS9LocalKeyId_OID);</span>
<span class="nc" id="L1527">            DerOutputStream bagAttrContent2 = new DerOutputStream();</span>
<span class="nc" id="L1528">            DerOutputStream bagAttrValue2 = new DerOutputStream();</span>
<span class="nc" id="L1529">            bagAttrContent2.putOctetString(keyId);</span>
<span class="nc" id="L1530">            bagAttr2.write(DerValue.tag_Set, bagAttrContent2);</span>
<span class="nc" id="L1531">            bagAttrValue2.write(DerValue.tag_Sequence, bagAttr2);</span>
<span class="nc" id="L1532">            localKeyID = bagAttrValue2.toByteArray();</span>
        }

        // Encode the trustedKeyUsage oid.
<span class="nc bnc" id="L1536" title="All 2 branches missed.">        if (trustedUsage != null) {</span>
<span class="nc" id="L1537">            DerOutputStream bagAttr3 = new DerOutputStream();</span>
<span class="nc" id="L1538">            bagAttr3.putOID(TrustedKeyUsage_OID);</span>
<span class="nc" id="L1539">            DerOutputStream bagAttrContent3 = new DerOutputStream();</span>
<span class="nc" id="L1540">            DerOutputStream bagAttrValue3 = new DerOutputStream();</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">            for (ObjectIdentifier usage : trustedUsage) {</span>
<span class="nc" id="L1542">                bagAttrContent3.putOID(usage);</span>
            }
<span class="nc" id="L1544">            bagAttr3.write(DerValue.tag_Set, bagAttrContent3);</span>
<span class="nc" id="L1545">            bagAttrValue3.write(DerValue.tag_Sequence, bagAttr3);</span>
<span class="nc" id="L1546">            trustedKeyUsage = bagAttrValue3.toByteArray();</span>
        }

<span class="nc" id="L1549">        DerOutputStream attrs = new DerOutputStream();</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">        if (friendlyName != null) {</span>
<span class="nc" id="L1551">            attrs.write(friendlyName);</span>
        }
<span class="nc bnc" id="L1553" title="All 2 branches missed.">        if (localKeyID != null) {</span>
<span class="nc" id="L1554">            attrs.write(localKeyID);</span>
        }
<span class="nc bnc" id="L1556" title="All 2 branches missed.">        if (trustedKeyUsage != null) {</span>
<span class="nc" id="L1557">            attrs.write(trustedKeyUsage);</span>
        }

<span class="nc bnc" id="L1560" title="All 2 branches missed.">        if (attributes != null) {</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">            for (KeyStore.Entry.Attribute attribute : attributes) {</span>
<span class="nc" id="L1562">                String attributeName = attribute.getName();</span>
                // skip friendlyName, localKeyId and trustedKeyUsage
<span class="nc bnc" id="L1564" title="All 2 branches missed.">                if (CORE_ATTRIBUTES[0].equals(attributeName) ||</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">                    CORE_ATTRIBUTES[1].equals(attributeName) ||</span>
<span class="nc bnc" id="L1566" title="All 2 branches missed.">                    CORE_ATTRIBUTES[2].equals(attributeName)) {</span>
<span class="nc" id="L1567">                    continue;</span>
                }
<span class="nc" id="L1569">                attrs.write(((PKCS12Attribute) attribute).getEncoded());</span>
<span class="nc" id="L1570">            }</span>
        }

<span class="nc" id="L1573">        bagAttrs.write(DerValue.tag_Set, attrs);</span>
<span class="nc" id="L1574">        return bagAttrs.toByteArray();</span>
    }

    /*
     * Create EncryptedData content type, that contains EncryptedContentInfo.
     * Includes certificates in individual SafeBags of type CertBag.
     * Each CertBag may include pkcs12 attributes
     * (see comments in getBagAttributes)
     */
    private byte[] createEncryptedData(char[] password)
        throws CertificateException, IOException
    {
<span class="nc" id="L1586">        DerOutputStream out = new DerOutputStream();</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">        for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {</span>

<span class="nc" id="L1589">            String alias = e.nextElement();</span>
<span class="nc" id="L1590">            Entry entry = entries.get(alias);</span>

            // certificate chain
<span class="nc" id="L1593">            int chainLen = 1;</span>
<span class="nc" id="L1594">            Certificate[] certs = null;</span>

<span class="nc bnc" id="L1596" title="All 2 branches missed.">            if (entry instanceof PrivateKeyEntry) {</span>
<span class="nc" id="L1597">                PrivateKeyEntry keyEntry = (PrivateKeyEntry) entry;</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">                    if (keyEntry.chain == null) {</span>
<span class="nc" id="L1599">                        chainLen = 0;</span>
                    } else {
<span class="nc" id="L1601">                        chainLen = keyEntry.chain.length;</span>
                    }
<span class="nc" id="L1603">                certs = keyEntry.chain;</span>

<span class="nc bnc" id="L1605" title="All 2 branches missed.">            } else if (entry instanceof CertEntry) {</span>
<span class="nc" id="L1606">               certs = new Certificate[]{((CertEntry) entry).cert};</span>
            }

<span class="nc bnc" id="L1609" title="All 2 branches missed.">            for (int i = 0; i &lt; chainLen; i++) {</span>
                // create SafeBag of Type CertBag
<span class="nc" id="L1611">                DerOutputStream safeBag = new DerOutputStream();</span>
<span class="nc" id="L1612">                safeBag.putOID(CertBag_OID);</span>

                // create a CertBag
<span class="nc" id="L1615">                DerOutputStream certBag = new DerOutputStream();</span>
<span class="nc" id="L1616">                certBag.putOID(PKCS9CertType_OID);</span>

                // write encoded certs in a context-specific tag
<span class="nc" id="L1619">                DerOutputStream certValue = new DerOutputStream();</span>
<span class="nc" id="L1620">                X509Certificate cert = (X509Certificate) certs[i];</span>
<span class="nc" id="L1621">                certValue.putOctetString(cert.getEncoded());</span>
<span class="nc" id="L1622">                certBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                                        true, (byte) 0), certValue);

                // wrap CertBag in a Sequence
<span class="nc" id="L1626">                DerOutputStream certout = new DerOutputStream();</span>
<span class="nc" id="L1627">                certout.write(DerValue.tag_Sequence, certBag);</span>
<span class="nc" id="L1628">                byte[] certBagValue = certout.toByteArray();</span>

                // Wrap the CertBag encoding in a context-specific tag.
<span class="nc" id="L1631">                DerOutputStream bagValue = new DerOutputStream();</span>
<span class="nc" id="L1632">                bagValue.write(certBagValue);</span>
                // write SafeBag Value
<span class="nc" id="L1634">                safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                                true, (byte) 0), bagValue);

                // write SafeBag Attributes
                // All Certs should have a unique friendlyName.
                // This change is made to meet NSS requirements.
<span class="nc" id="L1640">                byte[] bagAttrs = null;</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">                if (i == 0) {</span>
                    // Only End-Entity Cert should have a localKeyId.
<span class="nc bnc" id="L1643" title="All 2 branches missed.">                    if (entry instanceof KeyEntry) {</span>
<span class="nc" id="L1644">                        KeyEntry keyEntry = (KeyEntry) entry;</span>
<span class="nc" id="L1645">                        bagAttrs =</span>
<span class="nc" id="L1646">                            getBagAttributes(keyEntry.alias, keyEntry.keyId,</span>
                                keyEntry.attributes);
<span class="nc" id="L1648">                    } else {</span>
<span class="nc" id="L1649">                        CertEntry certEntry = (CertEntry) entry;</span>
<span class="nc" id="L1650">                        bagAttrs =</span>
<span class="nc" id="L1651">                            getBagAttributes(certEntry.alias, certEntry.keyId,</span>
                                certEntry.trustedKeyUsage,
                                certEntry.attributes);
<span class="nc" id="L1654">                    }</span>
                } else {
                    // Trusted root CA certs and Intermediate CA certs do not
                    // need to have a localKeyId, and hence localKeyId is null
                    // This change is made to meet NSS/Netscape requirements.
                    // NSS pkcs12 library requires trusted CA certs in the
                    // certificate chain to have unique or null localKeyID.
                    // However, IE/OpenSSL do not impose this restriction.
<span class="nc" id="L1662">                    bagAttrs = getBagAttributes(</span>
<span class="nc" id="L1663">                            cert.getSubjectX500Principal().getName(), null,</span>
                            entry.attributes);
                }
<span class="nc bnc" id="L1666" title="All 2 branches missed.">                if (bagAttrs != null) {</span>
<span class="nc" id="L1667">                    safeBag.write(bagAttrs);</span>
                }

                // wrap as Sequence
<span class="nc" id="L1671">                out.write(DerValue.tag_Sequence, safeBag);</span>
            } // for cert-chain
<span class="nc" id="L1673">        }</span>

        // wrap as SequenceOf SafeBag
<span class="nc" id="L1676">        DerOutputStream safeBagValue = new DerOutputStream();</span>
<span class="nc" id="L1677">        safeBagValue.write(DerValue.tag_SequenceOf, out);</span>
<span class="nc" id="L1678">        byte[] safeBagData = safeBagValue.toByteArray();</span>

        // encrypt the content (EncryptedContentInfo)
<span class="nc" id="L1681">        byte[] encrContentInfo = encryptContent(safeBagData, password);</span>

        // -- SEQUENCE of EncryptedData
<span class="nc" id="L1684">        DerOutputStream encrData = new DerOutputStream();</span>
<span class="nc" id="L1685">        DerOutputStream encrDataContent = new DerOutputStream();</span>
<span class="nc" id="L1686">        encrData.putInteger(0);</span>
<span class="nc" id="L1687">        encrData.write(encrContentInfo);</span>
<span class="nc" id="L1688">        encrDataContent.write(DerValue.tag_Sequence, encrData);</span>
<span class="nc" id="L1689">        return encrDataContent.toByteArray();</span>
    }

    /*
     * Create SafeContent Data content type.
     * Includes encrypted secret key in a SafeBag of type SecretBag.
     * Includes encrypted private key in a SafeBag of type PKCS8ShroudedKeyBag.
     * Each PKCS8ShroudedKeyBag includes pkcs12 attributes
     * (see comments in getBagAttributes)
     */
    private byte[] createSafeContent()
        throws CertificateException, IOException {

<span class="nc" id="L1702">        DerOutputStream out = new DerOutputStream();</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">        for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {</span>

<span class="nc" id="L1705">            String alias = e.nextElement();</span>
<span class="nc" id="L1706">            Entry entry = entries.get(alias);</span>
<span class="nc bnc" id="L1707" title="All 4 branches missed.">            if (entry == null || (!(entry instanceof KeyEntry))) {</span>
<span class="nc" id="L1708">                continue;</span>
            }
<span class="nc" id="L1710">            DerOutputStream safeBag = new DerOutputStream();</span>
<span class="nc" id="L1711">            KeyEntry keyEntry = (KeyEntry) entry;</span>

            // DER encode the private key
<span class="nc bnc" id="L1714" title="All 2 branches missed.">            if (keyEntry instanceof PrivateKeyEntry) {</span>
                // Create SafeBag of type pkcs8ShroudedKeyBag
<span class="nc" id="L1716">                safeBag.putOID(PKCS8ShroudedKeyBag_OID);</span>

                // get the encrypted private key
<span class="nc" id="L1719">                byte[] encrBytes = ((PrivateKeyEntry)keyEntry).protectedPrivKey;</span>
<span class="nc" id="L1720">                EncryptedPrivateKeyInfo encrInfo = null;</span>
                try {
<span class="nc" id="L1722">                    encrInfo = new EncryptedPrivateKeyInfo(encrBytes);</span>

<span class="nc" id="L1724">                } catch (IOException ioe) {</span>
<span class="nc" id="L1725">                    throw new IOException(&quot;Private key not stored as &quot;</span>
                            + &quot;PKCS#8 EncryptedPrivateKeyInfo&quot;
<span class="nc" id="L1727">                            + ioe.getMessage());</span>
<span class="nc" id="L1728">                }</span>

                // Wrap the EncryptedPrivateKeyInfo in a context-specific tag.
<span class="nc" id="L1731">                DerOutputStream bagValue = new DerOutputStream();</span>
<span class="nc" id="L1732">                bagValue.write(encrInfo.getEncoded());</span>
<span class="nc" id="L1733">                safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                                true, (byte) 0), bagValue);

            // DER encode the secret key
<span class="nc bnc" id="L1737" title="All 2 branches missed.">            } else if (keyEntry instanceof SecretKeyEntry) {</span>
                // Create SafeBag of type SecretBag
<span class="nc" id="L1739">                safeBag.putOID(SecretBag_OID);</span>

                // Create a SecretBag
<span class="nc" id="L1742">                DerOutputStream secretBag = new DerOutputStream();</span>
<span class="nc" id="L1743">                secretBag.putOID(PKCS8ShroudedKeyBag_OID);</span>

                // Write secret key in a context-specific tag
<span class="nc" id="L1746">                DerOutputStream secretKeyValue = new DerOutputStream();</span>
<span class="nc" id="L1747">                secretKeyValue.putOctetString(</span>
                    ((SecretKeyEntry) keyEntry).protectedSecretKey);
<span class="nc" id="L1749">                secretBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                                        true, (byte) 0), secretKeyValue);

                // Wrap SecretBag in a Sequence
<span class="nc" id="L1753">                DerOutputStream secretBagSeq = new DerOutputStream();</span>
<span class="nc" id="L1754">                secretBagSeq.write(DerValue.tag_Sequence, secretBag);</span>
<span class="nc" id="L1755">                byte[] secretBagValue = secretBagSeq.toByteArray();</span>

                // Wrap the secret bag in a context-specific tag.
<span class="nc" id="L1758">                DerOutputStream bagValue = new DerOutputStream();</span>
<span class="nc" id="L1759">                bagValue.write(secretBagValue);</span>

                // Write SafeBag value
<span class="nc" id="L1762">                safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                                    true, (byte) 0), bagValue);
            } else {
                continue; // skip this entry
            }

            // write SafeBag Attributes
<span class="nc" id="L1769">            byte[] bagAttrs =</span>
<span class="nc" id="L1770">                getBagAttributes(alias, entry.keyId, entry.attributes);</span>
<span class="nc" id="L1771">            safeBag.write(bagAttrs);</span>

            // wrap as Sequence
<span class="nc" id="L1774">            out.write(DerValue.tag_Sequence, safeBag);</span>
<span class="nc" id="L1775">        }</span>

        // wrap as Sequence
<span class="nc" id="L1778">        DerOutputStream safeBagValue = new DerOutputStream();</span>
<span class="nc" id="L1779">        safeBagValue.write(DerValue.tag_Sequence, out);</span>
<span class="nc" id="L1780">        return safeBagValue.toByteArray();</span>
    }


    /*
     * Encrypt the contents using Password-based (PBE) encryption
     * as defined in PKCS #5.
     *
     * NOTE: Currently pbeWithSHAAnd40BiteRC2-CBC algorithmID is used
     *       to derive the key and IV.
     *
     * @return encrypted contents encoded as EncryptedContentInfo
     */
    private byte[] encryptContent(byte[] data, char[] password)
        throws IOException {

<span class="nc" id="L1796">        byte[] encryptedData = null;</span>

        // create AlgorithmParameters
<span class="nc" id="L1799">        AlgorithmParameters algParams =</span>
<span class="nc" id="L1800">                getAlgorithmParameters(&quot;PBEWithSHA1AndRC2_40&quot;);</span>
<span class="nc" id="L1801">        DerOutputStream bytes = new DerOutputStream();</span>
<span class="nc" id="L1802">        AlgorithmId algId =</span>
                new AlgorithmId(pbeWithSHAAnd40BitRC2CBC_OID, algParams);
<span class="nc" id="L1804">        algId.encode(bytes);</span>
<span class="nc" id="L1805">        byte[] encodedAlgId = bytes.toByteArray();</span>

        try {
            // Use JCE
<span class="nc" id="L1809">            SecretKey skey = getPBEKey(password);</span>
<span class="nc" id="L1810">            Cipher cipher = Cipher.getInstance(&quot;PBEWithSHA1AndRC2_40&quot;);</span>
<span class="nc" id="L1811">            cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);</span>
<span class="nc" id="L1812">            encryptedData = cipher.doFinal(data);</span>

<span class="nc bnc" id="L1814" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L1815">                debug.println(&quot;  (Cipher algorithm: &quot; + cipher.getAlgorithm() +</span>
                    &quot;)&quot;);
            }

<span class="nc" id="L1819">        } catch (Exception e) {</span>
<span class="nc" id="L1820">            throw new IOException(&quot;Failed to encrypt&quot; +</span>
                    &quot; safe contents entry: &quot; + e, e);
<span class="nc" id="L1822">        }</span>

        // create EncryptedContentInfo
<span class="nc" id="L1825">        DerOutputStream bytes2 = new DerOutputStream();</span>
<span class="nc" id="L1826">        bytes2.putOID(ContentInfo.DATA_OID);</span>
<span class="nc" id="L1827">        bytes2.write(encodedAlgId);</span>

        // Wrap encrypted data in a context-specific tag.
<span class="nc" id="L1830">        DerOutputStream tmpout2 = new DerOutputStream();</span>
<span class="nc" id="L1831">        tmpout2.putOctetString(encryptedData);</span>
<span class="nc" id="L1832">        bytes2.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                                        false, (byte)0), tmpout2);

        // wrap EncryptedContentInfo in a Sequence
<span class="nc" id="L1836">        DerOutputStream out = new DerOutputStream();</span>
<span class="nc" id="L1837">        out.write(DerValue.tag_Sequence, bytes2);</span>
<span class="nc" id="L1838">        return out.toByteArray();</span>
    }

    /**
     * Loads the keystore from the given input stream.
     *
     * &lt;p&gt;If a password is given, it is used to check the integrity of the
     * keystore data. Otherwise, the integrity of the keystore is not checked.
     *
     * @param stream the input stream from which the keystore is loaded
     * @param password the (optional) password used to check the integrity of
     * the keystore.
     *
     * @exception IOException if there is an I/O or format problem with the
     * keystore data
     * @exception NoSuchAlgorithmException if the algorithm used to check
     * the integrity of the keystore cannot be found
     * @exception CertificateException if any of the certificates in the
     * keystore could not be loaded
     */
    public synchronized void engineLoad(InputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
        DataInputStream dis;
<span class="fc" id="L1862">        CertificateFactory cf = null;</span>
<span class="fc" id="L1863">        ByteArrayInputStream bais = null;</span>
<span class="fc" id="L1864">        byte[] encoded = null;</span>

<span class="pc bpc" id="L1866" title="1 of 2 branches missed.">        if (stream == null)</span>
<span class="nc" id="L1867">           return;</span>

        // reset the counter
<span class="fc" id="L1870">        counter = 0;</span>

<span class="fc" id="L1872">        DerValue val = new DerValue(stream);</span>
<span class="fc" id="L1873">        DerInputStream s = val.toDerInputStream();</span>
<span class="fc" id="L1874">        int version = s.getInteger();</span>

<span class="pc bpc" id="L1876" title="1 of 2 branches missed.">        if (version != VERSION_3) {</span>
<span class="nc" id="L1877">           throw new IOException(&quot;PKCS12 keystore not in version 3 format&quot;);</span>
        }

<span class="fc" id="L1880">        entries.clear();</span>

        /*
         * Read the authSafe.
         */
        byte[] authSafeData;
<span class="fc" id="L1886">        ContentInfo authSafe = new ContentInfo(s);</span>
<span class="fc" id="L1887">        ObjectIdentifier contentType = authSafe.getContentType();</span>

<span class="pc bpc" id="L1889" title="1 of 2 branches missed.">        if (contentType.equals((Object)ContentInfo.DATA_OID)) {</span>
<span class="fc" id="L1890">           authSafeData = authSafe.getData();</span>
        } else /* signed data */ {
<span class="nc" id="L1892">           throw new IOException(&quot;public key protected PKCS12 not supported&quot;);</span>
        }

<span class="fc" id="L1895">        DerInputStream as = new DerInputStream(authSafeData);</span>
<span class="fc" id="L1896">        DerValue[] safeContentsArray = as.getSequence(2);</span>
<span class="fc" id="L1897">        int count = safeContentsArray.length;</span>

        // reset the counters at the start
<span class="fc" id="L1900">        privateKeyCount = 0;</span>
<span class="fc" id="L1901">        secretKeyCount = 0;</span>
<span class="fc" id="L1902">        certificateCount = 0;</span>

        /*
         * Spin over the ContentInfos.
         */
<span class="fc bfc" id="L1907" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++) {</span>
            byte[] safeContentsData;
            ContentInfo safeContents;
            DerInputStream sci;
<span class="fc" id="L1911">            byte[] eAlgId = null;</span>

<span class="fc" id="L1913">            sci = new DerInputStream(safeContentsArray[i].toByteArray());</span>
<span class="fc" id="L1914">            safeContents = new ContentInfo(sci);</span>
<span class="fc" id="L1915">            contentType = safeContents.getContentType();</span>
<span class="fc" id="L1916">            safeContentsData = null;</span>
<span class="fc bfc" id="L1917" title="All 2 branches covered.">            if (contentType.equals((Object)ContentInfo.DATA_OID)) {</span>

<span class="pc bpc" id="L1919" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L1920">                    debug.println(&quot;Loading PKCS#7 data content-type&quot;);</span>
                }

<span class="fc" id="L1923">                safeContentsData = safeContents.getData();</span>
<span class="pc bpc" id="L1924" title="1 of 2 branches missed.">            } else if (contentType.equals((Object)ContentInfo.ENCRYPTED_DATA_OID)) {</span>
<span class="pc bpc" id="L1925" title="1 of 2 branches missed.">                if (password == null) {</span>
<span class="nc" id="L1926">                   continue;</span>
                }

<span class="pc bpc" id="L1929" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L1930">                    debug.println(&quot;Loading PKCS#7 encryptedData content-type&quot;);</span>
                }

<span class="fc" id="L1933">                DerInputStream edi =</span>
<span class="fc" id="L1934">                                safeContents.getContent().toDerInputStream();</span>
<span class="fc" id="L1935">                int edVersion = edi.getInteger();</span>
<span class="fc" id="L1936">                DerValue[] seq = edi.getSequence(2);</span>
<span class="fc" id="L1937">                ObjectIdentifier edContentType = seq[0].getOID();</span>
<span class="fc" id="L1938">                eAlgId = seq[1].toByteArray();</span>
<span class="pc bpc" id="L1939" title="1 of 2 branches missed.">                if (!seq[2].isContextSpecific((byte)0)) {</span>
<span class="nc" id="L1940">                   throw new IOException(&quot;encrypted content not present!&quot;);</span>
                }
<span class="fc" id="L1942">                byte newTag = DerValue.tag_OctetString;</span>
<span class="pc bpc" id="L1943" title="1 of 2 branches missed.">                if (seq[2].isConstructed())</span>
<span class="nc" id="L1944">                   newTag |= 0x20;</span>
<span class="fc" id="L1945">                seq[2].resetTag(newTag);</span>
<span class="fc" id="L1946">                safeContentsData = seq[2].getOctetString();</span>

                // parse Algorithm parameters
<span class="fc" id="L1949">                DerInputStream in = seq[1].toDerInputStream();</span>
<span class="fc" id="L1950">                ObjectIdentifier algOid = in.getOID();</span>
<span class="fc" id="L1951">                AlgorithmParameters algParams = parseAlgParameters(algOid, in);</span>

                while (true) {
                    try {
                        // Use JCE
<span class="fc" id="L1956">                        SecretKey skey = getPBEKey(password);</span>
<span class="fc" id="L1957">                        Cipher cipher = Cipher.getInstance(algOid.toString());</span>
<span class="fc" id="L1958">                        cipher.init(Cipher.DECRYPT_MODE, skey, algParams);</span>
<span class="fc" id="L1959">                        safeContentsData = cipher.doFinal(safeContentsData);</span>
<span class="fc" id="L1960">                        break;</span>
<span class="nc" id="L1961">                    } catch (Exception e) {</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">                        if (password.length == 0) {</span>
                            // Retry using an empty password
                            // without a NULL terminator.
<span class="nc" id="L1965">                            password = new char[1];</span>
<span class="nc" id="L1966">                            continue;</span>
                        }
<span class="nc" id="L1968">                        throw new IOException(</span>
                            &quot;failed to decrypt safe contents entry: &quot; + e, e);
                    }
                }
<span class="fc" id="L1972">            } else {</span>
<span class="nc" id="L1973">                throw new IOException(&quot;public key protected PKCS12&quot; +</span>
                                        &quot; not supported&quot;);
            }
<span class="fc" id="L1976">            DerInputStream sc = new DerInputStream(safeContentsData);</span>
<span class="fc" id="L1977">            loadSafeContents(sc, password);</span>
        }

        // The MacData is optional.
<span class="pc bpc" id="L1981" title="2 of 4 branches missed.">        if (password != null &amp;&amp; s.available() &gt; 0) {</span>
<span class="fc" id="L1982">           MacData macData = new MacData(s);</span>
           try {
<span class="fc" id="L1984">                String algName =</span>
<span class="fc" id="L1985">                        macData.getDigestAlgName().toUpperCase(Locale.ENGLISH);</span>

                // Change SHA-1 to SHA1
<span class="fc" id="L1988">                algName = algName.replace(&quot;-&quot;, &quot;&quot;);</span>

                // generate MAC (MAC key is created within JCE)
<span class="fc" id="L1991">                Mac m = Mac.getInstance(&quot;HmacPBE&quot; + algName);</span>
<span class="fc" id="L1992">                PBEParameterSpec params =</span>
<span class="fc" id="L1993">                        new PBEParameterSpec(macData.getSalt(),</span>
<span class="fc" id="L1994">                                        macData.getIterations());</span>
<span class="fc" id="L1995">                SecretKey key = getPBEKey(password);</span>
<span class="fc" id="L1996">                m.init(key, params);</span>
<span class="fc" id="L1997">                m.update(authSafeData);</span>
<span class="fc" id="L1998">                byte[] macResult = m.doFinal();</span>

<span class="pc bpc" id="L2000" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2001">                    debug.println(&quot;Checking keystore integrity &quot; +</span>
<span class="nc" id="L2002">                        &quot;(MAC algorithm: &quot; + m.getAlgorithm() + &quot;)&quot;);</span>
                }

<span class="pc bpc" id="L2005" title="1 of 2 branches missed.">                if (!Arrays.equals(macData.getDigest(), macResult)) {</span>
<span class="nc" id="L2006">                   throw new SecurityException(&quot;Failed PKCS12&quot; +</span>
                                        &quot; integrity checking&quot;);
                }
<span class="nc" id="L2009">           } catch (Exception e) {</span>
<span class="nc" id="L2010">                throw new IOException(&quot;Integrity check failed: &quot; + e, e);</span>
<span class="fc" id="L2011">           }</span>
        }

        /*
         * Match up private keys with certificate chains.
         */
<span class="fc" id="L2017">        PrivateKeyEntry[] list =</span>
<span class="fc" id="L2018">            keyList.toArray(new PrivateKeyEntry[keyList.size()]);</span>
<span class="fc bfc" id="L2019" title="All 2 branches covered.">        for (int m = 0; m &lt; list.length; m++) {</span>
<span class="fc" id="L2020">            PrivateKeyEntry entry = list[m];</span>
<span class="pc bpc" id="L2021" title="1 of 2 branches missed.">            if (entry.keyId != null) {</span>
<span class="fc" id="L2022">                ArrayList&lt;X509Certificate&gt; chain =</span>
                                new ArrayList&lt;X509Certificate&gt;();
<span class="fc" id="L2024">                X509Certificate cert = findMatchedCertificate(entry);</span>
<span class="fc bfc" id="L2025" title="All 2 branches covered.">                while (cert != null) {</span>
<span class="fc" id="L2026">                    chain.add(cert);</span>
<span class="fc" id="L2027">                    X500Principal issuerDN = cert.getIssuerX500Principal();</span>
<span class="pc bpc" id="L2028" title="1 of 2 branches missed.">                    if (issuerDN.equals(cert.getSubjectX500Principal())) {</span>
<span class="nc" id="L2029">                        break;</span>
                    }
<span class="fc" id="L2031">                    cert = certsMap.get(issuerDN);</span>
<span class="fc" id="L2032">                }</span>
                /* Update existing KeyEntry in entries table */
<span class="pc bpc" id="L2034" title="1 of 2 branches missed.">                if (chain.size() &gt; 0)</span>
<span class="fc" id="L2035">                    entry.chain = chain.toArray(new Certificate[chain.size()]);</span>
            }
        }

<span class="pc bpc" id="L2039" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc bnc" id="L2040" title="All 2 branches missed.">            if (privateKeyCount &gt; 0) {</span>
<span class="nc" id="L2041">                debug.println(&quot;Loaded &quot; + privateKeyCount +</span>
                    &quot; protected private key(s)&quot;);
            }
<span class="nc bnc" id="L2044" title="All 2 branches missed.">            if (secretKeyCount &gt; 0) {</span>
<span class="nc" id="L2045">                debug.println(&quot;Loaded &quot; + secretKeyCount +</span>
                    &quot; protected secret key(s)&quot;);
            }
<span class="nc bnc" id="L2048" title="All 2 branches missed.">            if (certificateCount &gt; 0) {</span>
<span class="nc" id="L2049">                debug.println(&quot;Loaded &quot; + certificateCount +</span>
                    &quot; certificate(s)&quot;);
            }
        }

<span class="fc" id="L2054">        certEntries.clear();</span>
<span class="fc" id="L2055">        certsMap.clear();</span>
<span class="fc" id="L2056">        keyList.clear();</span>
<span class="fc" id="L2057">    }</span>

    /**
     * Locates a matched CertEntry from certEntries, and returns its cert.
     * @param entry the KeyEntry to match
     * @return a certificate, null if not found
     */
    private X509Certificate findMatchedCertificate(PrivateKeyEntry entry) {
<span class="fc" id="L2065">        CertEntry keyIdMatch = null;</span>
<span class="fc" id="L2066">        CertEntry aliasMatch = null;</span>
<span class="pc bpc" id="L2067" title="1 of 2 branches missed.">        for (CertEntry ce: certEntries) {</span>
<span class="pc bpc" id="L2068" title="1 of 2 branches missed.">            if (Arrays.equals(entry.keyId, ce.keyId)) {</span>
<span class="fc" id="L2069">                keyIdMatch = ce;</span>
<span class="pc bpc" id="L2070" title="1 of 2 branches missed.">                if (entry.alias.equalsIgnoreCase(ce.alias)) {</span>
                    // Full match!
<span class="fc" id="L2072">                    return ce.cert;</span>
                }
<span class="nc bnc" id="L2074" title="All 2 branches missed.">            } else if (entry.alias.equalsIgnoreCase(ce.alias)) {</span>
<span class="nc" id="L2075">                aliasMatch = ce;</span>
            }
<span class="nc" id="L2077">        }</span>
        // keyId match first, for compatibility
<span class="nc bnc" id="L2079" title="All 2 branches missed.">        if (keyIdMatch != null) return keyIdMatch.cert;</span>
<span class="nc bnc" id="L2080" title="All 2 branches missed.">        else if (aliasMatch != null) return aliasMatch.cert;</span>
<span class="nc" id="L2081">        else return null;</span>
    }

    private void loadSafeContents(DerInputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
<span class="fc" id="L2087">        DerValue[] safeBags = stream.getSequence(2);</span>
<span class="fc" id="L2088">        int count = safeBags.length;</span>

        /*
         * Spin over the SafeBags.
         */
<span class="fc bfc" id="L2093" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++) {</span>
            ObjectIdentifier bagId;
            DerInputStream sbi;
            DerValue bagValue;
<span class="fc" id="L2097">            Object bagItem = null;</span>

<span class="fc" id="L2099">            sbi = safeBags[i].toDerInputStream();</span>
<span class="fc" id="L2100">            bagId = sbi.getOID();</span>
<span class="fc" id="L2101">            bagValue = sbi.getDerValue();</span>
<span class="pc bpc" id="L2102" title="1 of 2 branches missed.">            if (!bagValue.isContextSpecific((byte)0)) {</span>
<span class="nc" id="L2103">                throw new IOException(&quot;unsupported PKCS12 bag value type &quot;</span>
                                        + bagValue.tag);
            }
<span class="fc" id="L2106">            bagValue = bagValue.data.getDerValue();</span>
<span class="fc bfc" id="L2107" title="All 2 branches covered.">            if (bagId.equals((Object)PKCS8ShroudedKeyBag_OID)) {</span>
<span class="fc" id="L2108">                PrivateKeyEntry kEntry = new PrivateKeyEntry();</span>
<span class="fc" id="L2109">                kEntry.protectedPrivKey = bagValue.toByteArray();</span>
<span class="fc" id="L2110">                bagItem = kEntry;</span>
<span class="fc" id="L2111">                privateKeyCount++;</span>
<span class="pc bpc" id="L2112" title="1 of 2 branches missed.">            } else if (bagId.equals((Object)CertBag_OID)) {</span>
<span class="fc" id="L2113">                DerInputStream cs = new DerInputStream(bagValue.toByteArray());</span>
<span class="fc" id="L2114">                DerValue[] certValues = cs.getSequence(2);</span>
<span class="fc" id="L2115">                ObjectIdentifier certId = certValues[0].getOID();</span>
<span class="pc bpc" id="L2116" title="1 of 2 branches missed.">                if (!certValues[1].isContextSpecific((byte)0)) {</span>
<span class="nc" id="L2117">                    throw new IOException(&quot;unsupported PKCS12 cert value type &quot;</span>
                                        + certValues[1].tag);
                }
<span class="fc" id="L2120">                DerValue certValue = certValues[1].data.getDerValue();</span>
<span class="fc" id="L2121">                CertificateFactory cf = CertificateFactory.getInstance(&quot;X509&quot;);</span>
                X509Certificate cert;
<span class="fc" id="L2123">                cert = (X509Certificate)cf.generateCertificate</span>
<span class="fc" id="L2124">                        (new ByteArrayInputStream(certValue.getOctetString()));</span>
<span class="fc" id="L2125">                bagItem = cert;</span>
<span class="fc" id="L2126">                certificateCount++;</span>
<span class="pc bnc" id="L2127" title="All 2 branches missed.">            } else if (bagId.equals((Object)SecretBag_OID)) {</span>
<span class="nc" id="L2128">                DerInputStream ss = new DerInputStream(bagValue.toByteArray());</span>
<span class="nc" id="L2129">                DerValue[] secretValues = ss.getSequence(2);</span>
<span class="nc" id="L2130">                ObjectIdentifier secretId = secretValues[0].getOID();</span>
<span class="nc bnc" id="L2131" title="All 2 branches missed.">                if (!secretValues[1].isContextSpecific((byte)0)) {</span>
<span class="nc" id="L2132">                    throw new IOException(</span>
                        &quot;unsupported PKCS12 secret value type &quot;
                                        + secretValues[1].tag);
                }
<span class="nc" id="L2136">                DerValue secretValue = secretValues[1].data.getDerValue();</span>
<span class="nc" id="L2137">                SecretKeyEntry kEntry = new SecretKeyEntry();</span>
<span class="nc" id="L2138">                kEntry.protectedSecretKey = secretValue.getOctetString();</span>
<span class="nc" id="L2139">                bagItem = kEntry;</span>
<span class="nc" id="L2140">                secretKeyCount++;</span>
<span class="nc" id="L2141">            } else {</span>

<span class="nc bnc" id="L2143" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2144">                    debug.println(&quot;Unsupported PKCS12 bag type: &quot; + bagId);</span>
                }
            }

            DerValue[] attrSet;
            try {
<span class="fc" id="L2150">                attrSet = sbi.getSet(3);</span>
<span class="nc" id="L2151">            } catch (IOException e) {</span>
                // entry does not have attributes
                // Note: CA certs can have no attributes
                // OpenSSL generates pkcs12 with no attr for CA certs.
<span class="nc" id="L2155">                attrSet = null;</span>
<span class="fc" id="L2156">            }</span>

<span class="fc" id="L2158">            String alias = null;</span>
<span class="fc" id="L2159">            byte[] keyId = null;</span>
<span class="fc" id="L2160">            ObjectIdentifier[] trustedKeyUsage = null;</span>
<span class="fc" id="L2161">            Set&lt;PKCS12Attribute&gt; attributes = new HashSet&lt;&gt;();</span>

<span class="pc bpc" id="L2163" title="1 of 2 branches missed.">            if (attrSet != null) {</span>
<span class="fc bfc" id="L2164" title="All 2 branches covered.">                for (int j = 0; j &lt; attrSet.length; j++) {</span>
<span class="fc" id="L2165">                    byte[] encoded = attrSet[j].toByteArray();</span>
<span class="fc" id="L2166">                    DerInputStream as = new DerInputStream(encoded);</span>
<span class="fc" id="L2167">                    DerValue[] attrSeq = as.getSequence(2);</span>
<span class="fc" id="L2168">                    ObjectIdentifier attrId = attrSeq[0].getOID();</span>
<span class="fc" id="L2169">                    DerInputStream vs =</span>
<span class="fc" id="L2170">                        new DerInputStream(attrSeq[1].toByteArray());</span>
                    DerValue[] valSet;
                    try {
<span class="fc" id="L2173">                        valSet = vs.getSet(1);</span>
<span class="nc" id="L2174">                    } catch (IOException e) {</span>
<span class="nc" id="L2175">                        throw new IOException(&quot;Attribute &quot; + attrId +</span>
<span class="nc" id="L2176">                                &quot; should have a value &quot; + e.getMessage());</span>
<span class="fc" id="L2177">                    }</span>
<span class="fc bfc" id="L2178" title="All 2 branches covered.">                    if (attrId.equals((Object)PKCS9FriendlyName_OID)) {</span>
<span class="fc" id="L2179">                        alias = valSet[0].getBMPString();</span>
<span class="pc bpc" id="L2180" title="1 of 2 branches missed.">                    } else if (attrId.equals((Object)PKCS9LocalKeyId_OID)) {</span>
<span class="fc" id="L2181">                        keyId = valSet[0].getOctetString();</span>
<span class="nc" id="L2182">                    } else if</span>
<span class="nc bnc" id="L2183" title="All 2 branches missed.">                        (attrId.equals((Object)TrustedKeyUsage_OID)) {</span>
<span class="nc" id="L2184">                        trustedKeyUsage = new ObjectIdentifier[valSet.length];</span>
<span class="nc bnc" id="L2185" title="All 2 branches missed.">                        for (int k = 0; k &lt; valSet.length; k++) {</span>
<span class="nc" id="L2186">                            trustedKeyUsage[k] = valSet[k].getOID();</span>
                        }
                    } else {
<span class="nc" id="L2189">                        attributes.add(new PKCS12Attribute(encoded));</span>
                    }
                }
            }

            /*
             * As per PKCS12 v1.0 friendlyname (alias) and localKeyId (keyId)
             * are optional PKCS12 bagAttributes. But entries in the keyStore
             * are identified by their alias. Hence we need to have an
             * Unfriendlyname in the alias, if alias is null. The keyId
             * attribute is required to match the private key with the
             * certificate. If we get a bagItem of type KeyEntry with a
             * null keyId, we should skip it entirely.
             */
<span class="fc bfc" id="L2203" title="All 2 branches covered.">            if (bagItem instanceof KeyEntry) {</span>
<span class="fc" id="L2204">                KeyEntry entry = (KeyEntry)bagItem;</span>

<span class="pc bpc" id="L2206" title="1 of 2 branches missed.">                if (bagItem instanceof PrivateKeyEntry) {</span>
<span class="pc bpc" id="L2207" title="1 of 2 branches missed.">                    if (keyId == null) {</span>
                       // Insert a localKeyID for the privateKey
                       // Note: This is a workaround to allow null localKeyID
                       // attribute in pkcs12 with one private key entry and
                       // associated cert-chain
<span class="nc bnc" id="L2212" title="All 2 branches missed.">                       if (privateKeyCount == 1) {</span>
<span class="nc" id="L2213">                            keyId = &quot;01&quot;.getBytes(&quot;UTF8&quot;);</span>
                       } else {
                            continue;
                       }
                    }
                }
<span class="fc" id="L2219">                entry.keyId = keyId;</span>
                // restore date if it exists
<span class="fc" id="L2221">                String keyIdStr = new String(keyId, &quot;UTF8&quot;);</span>
<span class="fc" id="L2222">                Date date = null;</span>
<span class="pc bpc" id="L2223" title="1 of 2 branches missed.">                if (keyIdStr.startsWith(&quot;Time &quot;)) {</span>
                    try {
<span class="nc" id="L2225">                        date = new Date(</span>
<span class="nc" id="L2226">                                Long.parseLong(keyIdStr.substring(5)));</span>
<span class="nc" id="L2227">                    } catch (Exception e) {</span>
<span class="nc" id="L2228">                        date = null;</span>
<span class="nc" id="L2229">                    }</span>
                }
<span class="pc bpc" id="L2231" title="1 of 2 branches missed.">                if (date == null) {</span>
<span class="fc" id="L2232">                    date = new Date();</span>
                }
<span class="fc" id="L2234">                entry.date = date;</span>

<span class="pc bpc" id="L2236" title="1 of 2 branches missed.">                if (bagItem instanceof PrivateKeyEntry) {</span>
<span class="fc" id="L2237">                    keyList.add((PrivateKeyEntry) entry);</span>
                }
<span class="pc bpc" id="L2239" title="1 of 2 branches missed.">                if (entry.attributes == null) {</span>
<span class="fc" id="L2240">                    entry.attributes = new HashSet&lt;&gt;();</span>
                }
<span class="fc" id="L2242">                entry.attributes.addAll(attributes);</span>
<span class="pc bpc" id="L2243" title="1 of 2 branches missed.">                if (alias == null) {</span>
<span class="nc" id="L2244">                   alias = getUnfriendlyName();</span>
                }
<span class="fc" id="L2246">                entry.alias = alias;</span>
<span class="fc" id="L2247">                entries.put(alias.toLowerCase(Locale.ENGLISH), entry);</span>

<span class="pc bpc" id="L2249" title="1 of 2 branches missed.">            } else if (bagItem instanceof X509Certificate) {</span>
<span class="fc" id="L2250">                X509Certificate cert = (X509Certificate)bagItem;</span>
                // Insert a localKeyID for the corresponding cert
                // Note: This is a workaround to allow null localKeyID
                // attribute in pkcs12 with one private key entry and
                // associated cert-chain
<span class="pc bpc" id="L2255" title="3 of 4 branches missed.">                if ((keyId == null) &amp;&amp; (privateKeyCount == 1)) {</span>
                    // insert localKeyID only for EE cert or self-signed cert
<span class="nc bnc" id="L2257" title="All 2 branches missed.">                    if (i == 0) {</span>
<span class="nc" id="L2258">                        keyId = &quot;01&quot;.getBytes(&quot;UTF8&quot;);</span>
                    }
                }
                // Trusted certificate
<span class="pc bpc" id="L2262" title="1 of 2 branches missed.">                if (trustedKeyUsage != null) {</span>
<span class="nc bnc" id="L2263" title="All 2 branches missed.">                    if (alias == null) {</span>
<span class="nc" id="L2264">                        alias = getUnfriendlyName();</span>
                    }
<span class="nc" id="L2266">                    CertEntry certEntry =</span>
                        new CertEntry(cert, keyId, alias, trustedKeyUsage,
                            attributes);
<span class="nc" id="L2269">                    entries.put(alias.toLowerCase(Locale.ENGLISH), certEntry);</span>
<span class="nc" id="L2270">                } else {</span>
<span class="fc" id="L2271">                    certEntries.add(new CertEntry(cert, keyId, alias));</span>
                }
<span class="fc" id="L2273">                X500Principal subjectDN = cert.getSubjectX500Principal();</span>
<span class="pc bpc" id="L2274" title="1 of 2 branches missed.">                if (subjectDN != null) {</span>
<span class="pc bpc" id="L2275" title="1 of 2 branches missed.">                    if (!certsMap.containsKey(subjectDN)) {</span>
<span class="fc" id="L2276">                        certsMap.put(subjectDN, cert);</span>
                    }
                }
            }
        }
<span class="fc" id="L2281">    }</span>

    private String getUnfriendlyName() {
<span class="nc" id="L2284">        counter++;</span>
<span class="nc" id="L2285">        return (String.valueOf(counter));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>