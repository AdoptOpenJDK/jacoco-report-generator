<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Snapshot.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.tools.hat.internal.model</a> &gt; <span class="el_source">Snapshot.java</span></div><h1>Snapshot.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


/*
 * The Original Code is HAT. The Initial Developer of the
 * Original Code is Bill Foote, with contributions from others
 * at JavaSoft/Sun.
 */

package com.sun.tools.hat.internal.model;

import java.lang.ref.SoftReference;
import java.util.*;
import com.sun.tools.hat.internal.parser.ReadBuffer;
import com.sun.tools.hat.internal.util.Misc;

/**
 *
 * @author      Bill Foote
 */

/**
 * Represents a snapshot of the Java objects in the VM at one instant.
 * This is the top-level &quot;model&quot; object read out of a single .hprof or .bod
 * file.
 */

public class Snapshot {

<span class="nc" id="L53">    public static long SMALL_ID_MASK = 0x0FFFFFFFFL;</span>
<span class="nc" id="L54">    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];</span>

<span class="nc" id="L56">    private static final JavaField[] EMPTY_FIELD_ARRAY = new JavaField[0];</span>
<span class="nc" id="L57">    private static final JavaStatic[] EMPTY_STATIC_ARRAY = new JavaStatic[0];</span>

    // all heap objects
<span class="nc" id="L60">    private Hashtable&lt;Number, JavaHeapObject&gt; heapObjects =</span>
                 new Hashtable&lt;Number, JavaHeapObject&gt;();

<span class="nc" id="L63">    private Hashtable&lt;Number, JavaClass&gt; fakeClasses =</span>
                 new Hashtable&lt;Number, JavaClass&gt;();

    // all Roots in this Snapshot
<span class="nc" id="L67">    private Vector&lt;Root&gt; roots = new Vector&lt;Root&gt;();</span>

    // name-to-class map
<span class="nc" id="L70">    private Map&lt;String, JavaClass&gt; classes =</span>
                 new TreeMap&lt;String, JavaClass&gt;();

    // new objects relative to a baseline - lazily initialized
    private volatile Map&lt;JavaHeapObject, Boolean&gt; newObjects;

    // allocation site traces for all objects - lazily initialized
    private volatile Map&lt;JavaHeapObject, StackTrace&gt; siteTraces;

    // object-to-Root map for all objects
<span class="nc" id="L80">    private Map&lt;JavaHeapObject, Root&gt; rootsMap =</span>
                 new HashMap&lt;JavaHeapObject, Root&gt;();

    // soft cache of finalizeable objects - lazily initialized
    private SoftReference&lt;Vector&gt; finalizablesCache;

    // represents null reference
    private JavaThing nullThing;

    // java.lang.ref.Reference class
    private JavaClass weakReferenceClass;
    // index of 'referent' field in java.lang.ref.Reference class
    private int referentFieldIndex;

    // java.lang.Class class
    private JavaClass javaLangClass;
    // java.lang.String class
    private JavaClass javaLangString;
    // java.lang.ClassLoader class
    private JavaClass javaLangClassLoader;

    // unknown &quot;other&quot; array class
    private volatile JavaClass otherArrayType;
    // Stuff to exclude from reachable query
    private ReachableExcludes reachableExcludes;
    // the underlying heap dump buffer
    private ReadBuffer readBuf;

    // True iff some heap objects have isNew set
    private boolean hasNewSet;
    private boolean unresolvedObjectsOK;

    // whether object array instances have new style class or
    // old style (element) class.
    private boolean newStyleArrayClass;

    // object id size in the heap dump
<span class="nc" id="L117">    private int identifierSize = 4;</span>

    // minimum object size - accounts for object header in
    // most Java virtual machines - we assume 2 identifierSize
    // (which is true for Sun's hotspot JVM).
    private int minimumObjectSize;

<span class="nc" id="L124">    public Snapshot(ReadBuffer buf) {</span>
<span class="nc" id="L125">        nullThing = new HackJavaValue(&quot;&lt;null&gt;&quot;, 0);</span>
<span class="nc" id="L126">        readBuf = buf;</span>
<span class="nc" id="L127">    }</span>

    public void setSiteTrace(JavaHeapObject obj, StackTrace trace) {
<span class="nc bnc" id="L130" title="All 4 branches missed.">        if (trace != null &amp;&amp; trace.getFrames().length != 0) {</span>
<span class="nc" id="L131">            initSiteTraces();</span>
<span class="nc" id="L132">            siteTraces.put(obj, trace);</span>
        }
<span class="nc" id="L134">    }</span>

    public StackTrace getSiteTrace(JavaHeapObject obj) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (siteTraces != null) {</span>
<span class="nc" id="L138">            return siteTraces.get(obj);</span>
        } else {
<span class="nc" id="L140">            return null;</span>
        }
    }

    public void setNewStyleArrayClass(boolean value) {
<span class="nc" id="L145">        newStyleArrayClass = value;</span>
<span class="nc" id="L146">    }</span>

    public boolean isNewStyleArrayClass() {
<span class="nc" id="L149">        return newStyleArrayClass;</span>
    }

    public void setIdentifierSize(int size) {
<span class="nc" id="L153">        identifierSize = size;</span>
<span class="nc" id="L154">        minimumObjectSize = 2 * size;</span>
<span class="nc" id="L155">    }</span>

    public int getIdentifierSize() {
<span class="nc" id="L158">        return identifierSize;</span>
    }

    public int getMinimumObjectSize() {
<span class="nc" id="L162">        return minimumObjectSize;</span>
    }

    public void addHeapObject(long id, JavaHeapObject ho) {
<span class="nc" id="L166">        heapObjects.put(makeId(id), ho);</span>
<span class="nc" id="L167">    }</span>

    public void addRoot(Root r) {
<span class="nc" id="L170">        r.setIndex(roots.size());</span>
<span class="nc" id="L171">        roots.addElement(r);</span>
<span class="nc" id="L172">    }</span>

    public void addClass(long id, JavaClass c) {
<span class="nc" id="L175">        addHeapObject(id, c);</span>
<span class="nc" id="L176">        putInClassesMap(c);</span>
<span class="nc" id="L177">    }</span>

    JavaClass addFakeInstanceClass(long classID, int instSize) {
        // Create a fake class name based on ID.
<span class="nc" id="L181">        String name = &quot;unknown-class&lt;@&quot; + Misc.toHex(classID) + &quot;&gt;&quot;;</span>

        // Create fake fields convering the given instance size.
        // Create as many as int type fields and for the left over
        // size create byte type fields.
<span class="nc" id="L186">        int numInts = instSize / 4;</span>
<span class="nc" id="L187">        int numBytes = instSize % 4;</span>
<span class="nc" id="L188">        JavaField[] fields = new JavaField[numInts + numBytes];</span>
        int i;
<span class="nc bnc" id="L190" title="All 2 branches missed.">        for (i = 0; i &lt; numInts; i++) {</span>
<span class="nc" id="L191">            fields[i] = new JavaField(&quot;unknown-field-&quot; + i, &quot;I&quot;);</span>
        }
<span class="nc bnc" id="L193" title="All 2 branches missed.">        for (i = 0; i &lt; numBytes; i++) {</span>
<span class="nc" id="L194">            fields[i + numInts] = new JavaField(&quot;unknown-field-&quot; +</span>
                                                i + numInts, &quot;B&quot;);
        }

        // Create fake instance class
<span class="nc" id="L199">        JavaClass c = new JavaClass(name, 0, 0, 0, 0, fields,</span>
                                 EMPTY_STATIC_ARRAY, instSize);
        // Add the class
<span class="nc" id="L202">        addFakeClass(makeId(classID), c);</span>
<span class="nc" id="L203">        return c;</span>
    }


    /**
     * @return true iff it's possible that some JavaThing instances might
     *          isNew set
     *
     * @see JavaThing.isNew()
     */
    public boolean getHasNewSet() {
<span class="nc" id="L214">        return hasNewSet;</span>
    }

    //
    // Used in the body of resolve()
    //
<span class="nc" id="L220">    private static class MyVisitor extends AbstractJavaHeapObjectVisitor {</span>
        JavaHeapObject t;
        public void visit(JavaHeapObject other) {
<span class="nc" id="L223">            other.addReferenceFrom(t);</span>
<span class="nc" id="L224">        }</span>
    }

    // To show heap parsing progress, we print a '.' after this limit
    private static final int DOT_LIMIT = 5000;

    /**
     * Called after reading complete, to initialize the structure
     */
    public void resolve(boolean calculateRefs) {
<span class="nc" id="L234">        System.out.println(&quot;Resolving &quot; + heapObjects.size() + &quot; objects...&quot;);</span>

        // First, resolve the classes.  All classes must be resolved before
        // we try any objects, because the objects use classes in their
        // resolution.
<span class="nc" id="L239">        javaLangClass = findClass(&quot;java.lang.Class&quot;);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (javaLangClass == null) {</span>
<span class="nc" id="L241">            System.out.println(&quot;WARNING:  hprof file does not include java.lang.Class!&quot;);</span>
<span class="nc" id="L242">            javaLangClass = new JavaClass(&quot;java.lang.Class&quot;, 0, 0, 0, 0,</span>
                                 EMPTY_FIELD_ARRAY, EMPTY_STATIC_ARRAY, 0);
<span class="nc" id="L244">            addFakeClass(javaLangClass);</span>
        }
<span class="nc" id="L246">        javaLangString = findClass(&quot;java.lang.String&quot;);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (javaLangString == null) {</span>
<span class="nc" id="L248">            System.out.println(&quot;WARNING:  hprof file does not include java.lang.String!&quot;);</span>
<span class="nc" id="L249">            javaLangString = new JavaClass(&quot;java.lang.String&quot;, 0, 0, 0, 0,</span>
                                 EMPTY_FIELD_ARRAY, EMPTY_STATIC_ARRAY, 0);
<span class="nc" id="L251">            addFakeClass(javaLangString);</span>
        }
<span class="nc" id="L253">        javaLangClassLoader = findClass(&quot;java.lang.ClassLoader&quot;);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (javaLangClassLoader == null) {</span>
<span class="nc" id="L255">            System.out.println(&quot;WARNING:  hprof file does not include java.lang.ClassLoader!&quot;);</span>
<span class="nc" id="L256">            javaLangClassLoader = new JavaClass(&quot;java.lang.ClassLoader&quot;, 0, 0, 0, 0,</span>
                                 EMPTY_FIELD_ARRAY, EMPTY_STATIC_ARRAY, 0);
<span class="nc" id="L258">            addFakeClass(javaLangClassLoader);</span>
        }

<span class="nc bnc" id="L261" title="All 2 branches missed.">        for (JavaHeapObject t : heapObjects.values()) {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (t instanceof JavaClass) {</span>
<span class="nc" id="L263">                t.resolve(this);</span>
            }
<span class="nc" id="L265">        }</span>

        // Now, resolve everything else.
<span class="nc bnc" id="L268" title="All 2 branches missed.">        for (JavaHeapObject t : heapObjects.values()) {</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (!(t instanceof JavaClass)) {</span>
<span class="nc" id="L270">                t.resolve(this);</span>
            }
<span class="nc" id="L272">        }</span>

<span class="nc" id="L274">        heapObjects.putAll(fakeClasses);</span>
<span class="nc" id="L275">        fakeClasses.clear();</span>

<span class="nc" id="L277">        weakReferenceClass = findClass(&quot;java.lang.ref.Reference&quot;);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (weakReferenceClass == null)  {      // JDK 1.1.x</span>
<span class="nc" id="L279">            weakReferenceClass = findClass(&quot;sun.misc.Ref&quot;);</span>
<span class="nc" id="L280">            referentFieldIndex = 0;</span>
        } else {
<span class="nc" id="L282">            JavaField[] fields = weakReferenceClass.getFieldsForInstance();</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">            for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                if (&quot;referent&quot;.equals(fields[i].getName())) {</span>
<span class="nc" id="L285">                    referentFieldIndex = i;</span>
<span class="nc" id="L286">                    break;</span>
                }
            }
        }

<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (calculateRefs) {</span>
<span class="nc" id="L292">            calculateReferencesToObjects();</span>
<span class="nc" id="L293">            System.out.print(&quot;Eliminating duplicate references&quot;);</span>
<span class="nc" id="L294">            System.out.flush();</span>
            // This println refers to the *next* step
        }
<span class="nc" id="L297">        int count = 0;</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        for (JavaHeapObject t : heapObjects.values()) {</span>
<span class="nc" id="L299">            t.setupReferers();</span>
<span class="nc" id="L300">            ++count;</span>
<span class="nc bnc" id="L301" title="All 4 branches missed.">            if (calculateRefs &amp;&amp; count % DOT_LIMIT == 0) {</span>
<span class="nc" id="L302">                System.out.print(&quot;.&quot;);</span>
<span class="nc" id="L303">                System.out.flush();</span>
            }
<span class="nc" id="L305">        }</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (calculateRefs) {</span>
<span class="nc" id="L307">            System.out.println(&quot;&quot;);</span>
        }

        // to ensure that Iterator.remove() on getClasses()
        // result will throw exception..
<span class="nc" id="L312">        classes = Collections.unmodifiableMap(classes);</span>
<span class="nc" id="L313">    }</span>

    private void calculateReferencesToObjects() {
<span class="nc" id="L316">        System.out.print(&quot;Chasing references, expect &quot;</span>
<span class="nc" id="L317">                         + (heapObjects.size() / DOT_LIMIT) + &quot; dots&quot;);</span>
<span class="nc" id="L318">        System.out.flush();</span>
<span class="nc" id="L319">        int count = 0;</span>
<span class="nc" id="L320">        MyVisitor visitor = new MyVisitor();</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">        for (JavaHeapObject t : heapObjects.values()) {</span>
<span class="nc" id="L322">            visitor.t = t;</span>
            // call addReferenceFrom(t) on all objects t references:
<span class="nc" id="L324">            t.visitReferencedObjects(visitor);</span>
<span class="nc" id="L325">            ++count;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (count % DOT_LIMIT == 0) {</span>
<span class="nc" id="L327">                System.out.print(&quot;.&quot;);</span>
<span class="nc" id="L328">                System.out.flush();</span>
            }
<span class="nc" id="L330">        }</span>
<span class="nc" id="L331">        System.out.println();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        for (Root r : roots) {</span>
<span class="nc" id="L333">            r.resolve(this);</span>
<span class="nc" id="L334">            JavaHeapObject t = findThing(r.getId());</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (t != null) {</span>
<span class="nc" id="L336">                t.addReferenceFromRoot(r);</span>
            }
<span class="nc" id="L338">        }</span>
<span class="nc" id="L339">    }</span>

    public void markNewRelativeTo(Snapshot baseline) {
<span class="nc" id="L342">        hasNewSet = true;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        for (JavaHeapObject t : heapObjects.values()) {</span>
            boolean isNew;
<span class="nc" id="L345">            long thingID = t.getId();</span>
<span class="nc bnc" id="L346" title="All 4 branches missed.">            if (thingID == 0L || thingID == -1L) {</span>
<span class="nc" id="L347">                isNew = false;</span>
            } else {
<span class="nc" id="L349">                JavaThing other = baseline.findThing(t.getId());</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                if (other == null) {</span>
<span class="nc" id="L351">                    isNew = true;</span>
                } else {
<span class="nc bnc" id="L353" title="All 2 branches missed.">                    isNew = !t.isSameTypeAs(other);</span>
                }
            }
<span class="nc" id="L356">            t.setNew(isNew);</span>
<span class="nc" id="L357">        }</span>
<span class="nc" id="L358">    }</span>

    public Enumeration&lt;JavaHeapObject&gt; getThings() {
<span class="nc" id="L361">        return heapObjects.elements();</span>
    }


    public JavaHeapObject findThing(long id) {
<span class="nc" id="L366">        Number idObj = makeId(id);</span>
<span class="nc" id="L367">        JavaHeapObject jho = heapObjects.get(idObj);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">        return jho != null? jho : fakeClasses.get(idObj);</span>
    }

    public JavaHeapObject findThing(String id) {
<span class="nc" id="L372">        return findThing(Misc.parseHex(id));</span>
    }

    public JavaClass findClass(String name) {
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (name.startsWith(&quot;0x&quot;)) {</span>
<span class="nc" id="L377">            return (JavaClass) findThing(name);</span>
        } else {
<span class="nc" id="L379">            return classes.get(name);</span>
        }
    }

    /**
     * Return an Iterator of all of the classes in this snapshot.
     **/
    public Iterator getClasses() {
        // note that because classes is a TreeMap
        // classes are already sorted by name
<span class="nc" id="L389">        return classes.values().iterator();</span>
    }

    public JavaClass[] getClassesArray() {
<span class="nc" id="L393">        JavaClass[] res = new JavaClass[classes.size()];</span>
<span class="nc" id="L394">        classes.values().toArray(res);</span>
<span class="nc" id="L395">        return res;</span>
    }

    public synchronized Enumeration getFinalizerObjects() {
        Vector obj;
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (finalizablesCache != null &amp;&amp;</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">            (obj = finalizablesCache.get()) != null) {</span>
<span class="nc" id="L402">            return obj.elements();</span>
        }

<span class="nc" id="L405">        JavaClass clazz = findClass(&quot;java.lang.ref.Finalizer&quot;);</span>
<span class="nc" id="L406">        JavaObject queue = (JavaObject) clazz.getStaticField(&quot;queue&quot;);</span>
<span class="nc" id="L407">        JavaThing tmp = queue.getField(&quot;head&quot;);</span>
<span class="nc" id="L408">        Vector&lt;JavaHeapObject&gt; finalizables = new Vector&lt;JavaHeapObject&gt;();</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">        if (tmp != getNullThing()) {</span>
<span class="nc" id="L410">            JavaObject head = (JavaObject) tmp;</span>
            while (true) {
<span class="nc" id="L412">                JavaHeapObject referent = (JavaHeapObject) head.getField(&quot;referent&quot;);</span>
<span class="nc" id="L413">                JavaThing next = head.getField(&quot;next&quot;);</span>
<span class="nc bnc" id="L414" title="All 4 branches missed.">                if (next == getNullThing() || next.equals(head)) {</span>
<span class="nc" id="L415">                    break;</span>
                }
<span class="nc" id="L417">                head = (JavaObject) next;</span>
<span class="nc" id="L418">                finalizables.add(referent);</span>
<span class="nc" id="L419">            }</span>
        }
<span class="nc" id="L421">        finalizablesCache = new SoftReference&lt;Vector&gt;(finalizables);</span>
<span class="nc" id="L422">        return finalizables.elements();</span>
    }

    public Enumeration&lt;Root&gt; getRoots() {
<span class="nc" id="L426">        return roots.elements();</span>
    }

    public Root[] getRootsArray() {
<span class="nc" id="L430">        Root[] res = new Root[roots.size()];</span>
<span class="nc" id="L431">        roots.toArray(res);</span>
<span class="nc" id="L432">        return res;</span>
    }

    public Root getRootAt(int i) {
<span class="nc" id="L436">        return roots.elementAt(i);</span>
    }

    public ReferenceChain[]
    rootsetReferencesTo(JavaHeapObject target, boolean includeWeak) {
<span class="nc" id="L441">        Vector&lt;ReferenceChain&gt; fifo = new Vector&lt;ReferenceChain&gt;();  // This is slow... A real fifo would help</span>
            // Must be a fifo to go breadth-first
<span class="nc" id="L443">        Hashtable&lt;JavaHeapObject, JavaHeapObject&gt; visited = new Hashtable&lt;JavaHeapObject, JavaHeapObject&gt;();</span>
        // Objects are added here right after being added to fifo.
<span class="nc" id="L445">        Vector&lt;ReferenceChain&gt; result = new Vector&lt;ReferenceChain&gt;();</span>
<span class="nc" id="L446">        visited.put(target, target);</span>
<span class="nc" id="L447">        fifo.addElement(new ReferenceChain(target, null));</span>

<span class="nc bnc" id="L449" title="All 2 branches missed.">        while (fifo.size() &gt; 0) {</span>
<span class="nc" id="L450">            ReferenceChain chain = fifo.elementAt(0);</span>
<span class="nc" id="L451">            fifo.removeElementAt(0);</span>
<span class="nc" id="L452">            JavaHeapObject curr = chain.getObj();</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">            if (curr.getRoot() != null) {</span>
<span class="nc" id="L454">                result.addElement(chain);</span>
                // Even though curr is in the rootset, we want to explore its
                // referers, because they might be more interesting.
            }
<span class="nc" id="L458">            Enumeration referers = curr.getReferers();</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            while (referers.hasMoreElements()) {</span>
<span class="nc" id="L460">                JavaHeapObject t = (JavaHeapObject) referers.nextElement();</span>
<span class="nc bnc" id="L461" title="All 4 branches missed.">                if (t != null &amp;&amp; !visited.containsKey(t)) {</span>
<span class="nc bnc" id="L462" title="All 4 branches missed.">                    if (includeWeak || !t.refersOnlyWeaklyTo(this, curr)) {</span>
<span class="nc" id="L463">                        visited.put(t, t);</span>
<span class="nc" id="L464">                        fifo.addElement(new ReferenceChain(t, chain));</span>
                    }
                }
<span class="nc" id="L467">            }</span>
<span class="nc" id="L468">        }</span>

<span class="nc" id="L470">        ReferenceChain[] realResult = new ReferenceChain[result.size()];</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        for (int i = 0; i &lt; result.size(); i++) {</span>
<span class="nc" id="L472">            realResult[i] =  result.elementAt(i);</span>
        }
<span class="nc" id="L474">        return realResult;</span>
    }

    public boolean getUnresolvedObjectsOK() {
<span class="nc" id="L478">        return unresolvedObjectsOK;</span>
    }

    public void setUnresolvedObjectsOK(boolean v) {
<span class="nc" id="L482">        unresolvedObjectsOK = v;</span>
<span class="nc" id="L483">    }</span>

    public JavaClass getWeakReferenceClass() {
<span class="nc" id="L486">        return weakReferenceClass;</span>
    }

    public int getReferentFieldIndex() {
<span class="nc" id="L490">        return referentFieldIndex;</span>
    }

    public JavaThing getNullThing() {
<span class="nc" id="L494">        return nullThing;</span>
    }

    public void setReachableExcludes(ReachableExcludes e) {
<span class="nc" id="L498">        reachableExcludes = e;</span>
<span class="nc" id="L499">    }</span>

    public ReachableExcludes getReachableExcludes() {
<span class="nc" id="L502">        return reachableExcludes;</span>
    }

    // package privates
    void addReferenceFromRoot(Root r, JavaHeapObject obj) {
<span class="nc" id="L507">        Root root = rootsMap.get(obj);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (root == null) {</span>
<span class="nc" id="L509">            rootsMap.put(obj, r);</span>
        } else {
<span class="nc" id="L511">            rootsMap.put(obj, root.mostInteresting(r));</span>
        }
<span class="nc" id="L513">    }</span>

    Root getRoot(JavaHeapObject obj) {
<span class="nc" id="L516">        return rootsMap.get(obj);</span>
    }

    JavaClass getJavaLangClass() {
<span class="nc" id="L520">        return javaLangClass;</span>
    }

    JavaClass getJavaLangString() {
<span class="nc" id="L524">        return javaLangString;</span>
    }

    JavaClass getJavaLangClassLoader() {
<span class="nc" id="L528">        return javaLangClassLoader;</span>
    }

    JavaClass getOtherArrayType() {
<span class="nc bnc" id="L532" title="All 2 branches missed.">        if (otherArrayType == null) {</span>
<span class="nc" id="L533">            synchronized(this) {</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">                if (otherArrayType == null) {</span>
<span class="nc" id="L535">                    addFakeClass(new JavaClass(&quot;[&lt;other&gt;&quot;, 0, 0, 0, 0,</span>
                                     EMPTY_FIELD_ARRAY, EMPTY_STATIC_ARRAY,
                                     0));
<span class="nc" id="L538">                    otherArrayType = findClass(&quot;[&lt;other&gt;&quot;);</span>
                }
<span class="nc" id="L540">            }</span>
        }
<span class="nc" id="L542">        return otherArrayType;</span>
    }

    JavaClass getArrayClass(String elementSignature) {
        JavaClass clazz;
<span class="nc" id="L547">        synchronized(classes) {</span>
<span class="nc" id="L548">            clazz = findClass(&quot;[&quot; + elementSignature);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            if (clazz == null) {</span>
<span class="nc" id="L550">                clazz = new JavaClass(&quot;[&quot; + elementSignature, 0, 0, 0, 0,</span>
                                   EMPTY_FIELD_ARRAY, EMPTY_STATIC_ARRAY, 0);
<span class="nc" id="L552">                addFakeClass(clazz);</span>
                // This is needed because the JDK only creates Class structures
                // for array element types, not the arrays themselves.  For
                // analysis, though, we need to pretend that there's a
                // JavaClass for the array type, too.
            }
<span class="nc" id="L558">        }</span>
<span class="nc" id="L559">        return clazz;</span>
    }

    ReadBuffer getReadBuffer() {
<span class="nc" id="L563">        return readBuf;</span>
    }

    void setNew(JavaHeapObject obj, boolean isNew) {
<span class="nc" id="L567">        initNewObjects();</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (isNew) {</span>
<span class="nc" id="L569">            newObjects.put(obj, Boolean.TRUE);</span>
        }
<span class="nc" id="L571">    }</span>

    boolean isNew(JavaHeapObject obj) {
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (newObjects != null) {</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">            return newObjects.get(obj) != null;</span>
        } else {
<span class="nc" id="L577">            return false;</span>
        }
    }

    // Internals only below this point
    private Number makeId(long id) {
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (identifierSize == 4) {</span>
<span class="nc" id="L584">            return new Integer((int)id);</span>
        } else {
<span class="nc" id="L586">            return new Long(id);</span>
        }
    }

    private void putInClassesMap(JavaClass c) {
<span class="nc" id="L591">        String name = c.getName();</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">        if (classes.containsKey(name)) {</span>
            // more than one class can have the same name
            // if so, create a unique name by appending
            // - and id string to it.
<span class="nc" id="L596">            name += &quot;-&quot; + c.getIdString();</span>
        }
<span class="nc" id="L598">        classes.put(c.getName(), c);</span>
<span class="nc" id="L599">    }</span>

    private void addFakeClass(JavaClass c) {
<span class="nc" id="L602">        putInClassesMap(c);</span>
<span class="nc" id="L603">        c.resolve(this);</span>
<span class="nc" id="L604">    }</span>

    private void addFakeClass(Number id, JavaClass c) {
<span class="nc" id="L607">        fakeClasses.put(id, c);</span>
<span class="nc" id="L608">        addFakeClass(c);</span>
<span class="nc" id="L609">    }</span>

    private synchronized void initNewObjects() {
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (newObjects == null) {</span>
<span class="nc" id="L613">            synchronized (this) {</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">                if (newObjects == null) {</span>
<span class="nc" id="L615">                    newObjects = new HashMap&lt;JavaHeapObject, Boolean&gt;();</span>
                }
<span class="nc" id="L617">            }</span>
        }
<span class="nc" id="L619">    }</span>

    private synchronized void initSiteTraces() {
<span class="nc bnc" id="L622" title="All 2 branches missed.">        if (siteTraces == null) {</span>
<span class="nc" id="L623">            synchronized (this) {</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                if (siteTraces == null) {</span>
<span class="nc" id="L625">                    siteTraces = new HashMap&lt;JavaHeapObject, StackTrace&gt;();</span>
                }
<span class="nc" id="L627">            }</span>
        }
<span class="nc" id="L629">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>