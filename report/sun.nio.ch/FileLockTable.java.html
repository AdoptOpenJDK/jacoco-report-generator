<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FileLockTable.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.nio.ch</a> &gt; <span class="el_source">FileLockTable.java</span></div><h1>FileLockTable.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2009, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.ch;

import java.nio.channels.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.ref.*;
import java.io.FileDescriptor;
import java.io.IOException;

abstract class FileLockTable {
<span class="nc" id="L36">    protected FileLockTable() {</span>
<span class="nc" id="L37">    }</span>

    /**
     * Creates and returns a file lock table for a channel that is connected to
     * the a system-wide map of all file locks for the Java virtual machine.
     */
    public static FileLockTable newSharedFileLockTable(Channel channel,
                                                       FileDescriptor fd)
        throws IOException
    {
<span class="nc" id="L47">        return new SharedFileLockTable(channel, fd);</span>
    }

    /**
     * Adds a file lock to the table.
     *
     * @throws OverlappingFileLockException if the file lock overlaps
     *         with an existing file lock in the table
     */
    public abstract void add(FileLock fl) throws OverlappingFileLockException;

    /**
     * Remove an existing file lock from the table.
     */
    public abstract void remove(FileLock fl);

    /**
     * Removes all file locks from the table.
     *
     * @return  The list of file locks removed
     */
    public abstract List&lt;FileLock&gt; removeAll();

    /**
     * Replaces an existing file lock in the table.
     */
    public abstract void replace(FileLock fl1, FileLock fl2);
}


/**
 * A file lock table that is over a system-wide map of all file locks.
 */
<span class="nc bnc" id="L80" title="All 2 branches missed.">class SharedFileLockTable extends FileLockTable {</span>

    /**
     * A weak reference to a FileLock.
     * &lt;p&gt;
     * SharedFileLockTable uses a list of file lock references to avoid keeping the
     * FileLock (and FileChannel) alive.
     */
    private static class FileLockReference extends WeakReference&lt;FileLock&gt; {
        private FileKey fileKey;

        FileLockReference(FileLock referent,
                          ReferenceQueue&lt;FileLock&gt; queue,
                          FileKey key) {
<span class="nc" id="L94">            super(referent, queue);</span>
<span class="nc" id="L95">            this.fileKey = key;</span>
<span class="nc" id="L96">        }</span>

        FileKey fileKey() {
<span class="nc" id="L99">            return fileKey;</span>
        }
    }

    // The system-wide map is a ConcurrentHashMap that is keyed on the FileKey.
    // The map value is a list of file locks represented by FileLockReferences.
    // All access to the list must be synchronized on the list.
<span class="nc" id="L106">    private static ConcurrentHashMap&lt;FileKey, List&lt;FileLockReference&gt;&gt; lockMap =</span>
        new ConcurrentHashMap&lt;FileKey, List&lt;FileLockReference&gt;&gt;();

    // reference queue for cleared refs
<span class="nc" id="L110">    private static ReferenceQueue&lt;FileLock&gt; queue = new ReferenceQueue&lt;FileLock&gt;();</span>

    // The connection to which this table is connected
    private final Channel channel;

    // File key for the file that this channel is connected to
    private final FileKey fileKey;

<span class="nc" id="L118">    SharedFileLockTable(Channel channel, FileDescriptor fd) throws IOException {</span>
<span class="nc" id="L119">        this.channel = channel;</span>
<span class="nc" id="L120">        this.fileKey = FileKey.create(fd);</span>
<span class="nc" id="L121">    }</span>

    @Override
    public void add(FileLock fl) throws OverlappingFileLockException {
<span class="nc" id="L125">        List&lt;FileLockReference&gt; list = lockMap.get(fileKey);</span>

        for (;;) {

            // The key isn't in the map so we try to create it atomically
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (list == null) {</span>
<span class="nc" id="L131">                list = new ArrayList&lt;FileLockReference&gt;(2);</span>
                List&lt;FileLockReference&gt; prev;
<span class="nc" id="L133">                synchronized (list) {</span>
<span class="nc" id="L134">                    prev = lockMap.putIfAbsent(fileKey, list);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                    if (prev == null) {</span>
                        // we successfully created the key so we add the file lock
<span class="nc" id="L137">                        list.add(new FileLockReference(fl, queue, fileKey));</span>
<span class="nc" id="L138">                        break;</span>
                    }
<span class="nc" id="L140">                }</span>
                // someone else got there first
<span class="nc" id="L142">                list = prev;</span>
            }

            // There is already a key. It is possible that some other thread
            // is removing it so we re-fetch the value from the map. If it
            // hasn't changed then we check the list for overlapping locks
            // and add the new lock to the list.
<span class="nc" id="L149">            synchronized (list) {</span>
<span class="nc" id="L150">                List&lt;FileLockReference&gt; current = lockMap.get(fileKey);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">                if (list == current) {</span>
<span class="nc" id="L152">                    checkList(list, fl.position(), fl.size());</span>
<span class="nc" id="L153">                    list.add(new FileLockReference(fl, queue, fileKey));</span>
<span class="nc" id="L154">                    break;</span>
                }
<span class="nc" id="L156">                list = current;</span>
<span class="nc" id="L157">            }</span>

        }

        // process any stale entries pending in the reference queue
<span class="nc" id="L162">        removeStaleEntries();</span>
<span class="nc" id="L163">    }</span>

    private void removeKeyIfEmpty(FileKey fk, List&lt;FileLockReference&gt; list) {
<span class="nc bnc" id="L166" title="All 4 branches missed.">        assert Thread.holdsLock(list);</span>
<span class="nc bnc" id="L167" title="All 4 branches missed.">        assert lockMap.get(fk) == list;</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (list.isEmpty()) {</span>
<span class="nc" id="L169">            lockMap.remove(fk);</span>
        }
<span class="nc" id="L171">    }</span>

    @Override
    public void remove(FileLock fl) {
<span class="nc bnc" id="L175" title="All 4 branches missed.">        assert fl != null;</span>

        // the lock must exist so the list of locks must be present
<span class="nc" id="L178">        List&lt;FileLockReference&gt; list = lockMap.get(fileKey);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (list == null) return;</span>

<span class="nc" id="L181">        synchronized (list) {</span>
<span class="nc" id="L182">            int index = 0;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            while (index &lt; list.size()) {</span>
<span class="nc" id="L184">                FileLockReference ref = list.get(index);</span>
<span class="nc" id="L185">                FileLock lock = ref.get();</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                if (lock == fl) {</span>
<span class="nc bnc" id="L187" title="All 6 branches missed.">                    assert (lock != null) &amp;&amp; (lock.acquiredBy() == channel);</span>
<span class="nc" id="L188">                    ref.clear();</span>
<span class="nc" id="L189">                    list.remove(index);</span>
<span class="nc" id="L190">                    break;</span>
                }
<span class="nc" id="L192">                index++;</span>
<span class="nc" id="L193">            }</span>
<span class="nc" id="L194">        }</span>
<span class="nc" id="L195">    }</span>

    @Override
    public List&lt;FileLock&gt; removeAll() {
<span class="nc" id="L199">        List&lt;FileLock&gt; result = new ArrayList&lt;FileLock&gt;();</span>
<span class="nc" id="L200">        List&lt;FileLockReference&gt; list = lockMap.get(fileKey);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (list != null) {</span>
<span class="nc" id="L202">            synchronized (list) {</span>
<span class="nc" id="L203">                int index = 0;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">                while (index &lt; list.size()) {</span>
<span class="nc" id="L205">                    FileLockReference ref = list.get(index);</span>
<span class="nc" id="L206">                    FileLock lock = ref.get();</span>

                    // remove locks obtained by this channel
<span class="nc bnc" id="L209" title="All 4 branches missed.">                    if (lock != null &amp;&amp; lock.acquiredBy() == channel) {</span>
                        // remove the lock from the list
<span class="nc" id="L211">                        ref.clear();</span>
<span class="nc" id="L212">                        list.remove(index);</span>

                        // add to result
<span class="nc" id="L215">                        result.add(lock);</span>
                    } else {
<span class="nc" id="L217">                        index++;</span>
                    }
<span class="nc" id="L219">                }</span>

                // once the lock list is empty we remove it from the map
<span class="nc" id="L222">                removeKeyIfEmpty(fileKey, list);</span>
<span class="nc" id="L223">            }</span>
        }
<span class="nc" id="L225">        return result;</span>
    }

    @Override
    public void replace(FileLock fromLock, FileLock toLock) {
        // the lock must exist so there must be a list
<span class="nc" id="L231">        List&lt;FileLockReference&gt; list = lockMap.get(fileKey);</span>
<span class="nc bnc" id="L232" title="All 4 branches missed.">        assert list != null;</span>

<span class="nc" id="L234">        synchronized (list) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            for (int index=0; index&lt;list.size(); index++) {</span>
<span class="nc" id="L236">                FileLockReference ref = list.get(index);</span>
<span class="nc" id="L237">                FileLock lock = ref.get();</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                if (lock == fromLock) {</span>
<span class="nc" id="L239">                    ref.clear();</span>
<span class="nc" id="L240">                    list.set(index, new FileLockReference(toLock, queue, fileKey));</span>
<span class="nc" id="L241">                    break;</span>
                }
            }
<span class="nc" id="L244">        }</span>
<span class="nc" id="L245">    }</span>

    // Check for overlapping file locks
    private void checkList(List&lt;FileLockReference&gt; list, long position, long size)
        throws OverlappingFileLockException
    {
<span class="nc bnc" id="L251" title="All 4 branches missed.">        assert Thread.holdsLock(list);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        for (FileLockReference ref: list) {</span>
<span class="nc" id="L253">            FileLock fl = ref.get();</span>
<span class="nc bnc" id="L254" title="All 4 branches missed.">            if (fl != null &amp;&amp; fl.overlaps(position, size))</span>
<span class="nc" id="L255">                throw new OverlappingFileLockException();</span>
<span class="nc" id="L256">        }</span>
<span class="nc" id="L257">    }</span>

    // Process the reference queue
    private void removeStaleEntries() {
        FileLockReference ref;
<span class="nc bnc" id="L262" title="All 2 branches missed.">        while ((ref = (FileLockReference)queue.poll()) != null) {</span>
<span class="nc" id="L263">            FileKey fk = ref.fileKey();</span>
<span class="nc" id="L264">            List&lt;FileLockReference&gt; list = lockMap.get(fk);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (list != null) {</span>
<span class="nc" id="L266">                synchronized (list) {</span>
<span class="nc" id="L267">                    list.remove(ref);</span>
<span class="nc" id="L268">                    removeKeyIfEmpty(fk, list);</span>
<span class="nc" id="L269">                }</span>
            }
<span class="nc" id="L271">        }</span>
<span class="nc" id="L272">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>