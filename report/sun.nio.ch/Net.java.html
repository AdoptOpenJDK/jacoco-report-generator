<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Net.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.nio.ch</a> &gt; <span class="el_source">Net.java</span></div><h1>Net.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.ch;

import java.io.*;
import java.net.*;
import java.nio.channels.*;
import java.util.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedExceptionAction;


public class Net {

<span class="nc" id="L39">    private Net() { }</span>

    // unspecified protocol family
<span class="fc" id="L42">    static final ProtocolFamily UNSPEC = new ProtocolFamily() {</span>
        public String name() {
<span class="nc" id="L44">            return &quot;UNSPEC&quot;;</span>
        }
    };

    // set to true if exclusive binding is on for Windows
    private static final boolean exclusiveBind;

    static {
<span class="fc" id="L52">        int availLevel = isExclusiveBindAvailable();</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (availLevel &gt;= 0) {</span>
<span class="nc" id="L54">            String exclBindProp =</span>
<span class="nc" id="L55">                java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L56">                    new PrivilegedAction&lt;String&gt;() {</span>
                        @Override
                        public String run() {
<span class="nc" id="L59">                            return System.getProperty(</span>
                                    &quot;sun.net.useExclusiveBind&quot;);
                        }
                    });
<span class="nc bnc" id="L63" title="All 2 branches missed.">            if (exclBindProp != null) {</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">                exclusiveBind = exclBindProp.length() == 0 ?</span>
<span class="nc" id="L65">                        true : Boolean.parseBoolean(exclBindProp);</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">            } else if (availLevel == 1) {</span>
<span class="nc" id="L67">                exclusiveBind = true;</span>
            } else {
<span class="nc" id="L69">                exclusiveBind = false;</span>
            }
<span class="nc" id="L71">        } else {</span>
<span class="fc" id="L72">            exclusiveBind = false;</span>
        }
    }

    // -- Miscellaneous utilities --

<span class="fc" id="L78">    private static volatile boolean checkedIPv6 = false;</span>
    private static volatile boolean isIPv6Available;

    /**
     * Tells whether dual-IPv4/IPv6 sockets should be used.
     */
    static boolean isIPv6Available() {
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (!checkedIPv6) {</span>
<span class="fc" id="L86">            isIPv6Available = isIPv6Available0();</span>
<span class="fc" id="L87">            checkedIPv6 = true;</span>
        }
<span class="fc" id="L89">        return isIPv6Available;</span>
    }

    /**
     * Returns true if exclusive binding is on
     */
    static boolean useExclusiveBind() {
<span class="fc" id="L96">        return exclusiveBind;</span>
    }

    /**
     * Tells whether IPv6 sockets can join IPv4 multicast groups
     */
    static boolean canIPv6SocketJoinIPv4Group() {
<span class="fc" id="L103">        return canIPv6SocketJoinIPv4Group0();</span>
    }

    /**
     * Tells whether {@link #join6} can be used to join an IPv4
     * multicast group (IPv4 group as IPv4-mapped IPv6 address)
     */
    static boolean canJoin6WithIPv4Group() {
<span class="fc" id="L111">        return canJoin6WithIPv4Group0();</span>
    }

    public static InetSocketAddress checkAddress(SocketAddress sa) {
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (sa == null)</span>
<span class="nc" id="L116">            throw new NullPointerException();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (!(sa instanceof InetSocketAddress))</span>
<span class="fc" id="L118">            throw new UnsupportedAddressTypeException(); // ## needs arg</span>
<span class="fc" id="L119">        InetSocketAddress isa = (InetSocketAddress)sa;</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (isa.isUnresolved())</span>
<span class="nc" id="L121">            throw new UnresolvedAddressException(); // ## needs arg</span>
<span class="fc" id="L122">        InetAddress addr = isa.getAddress();</span>
<span class="pc bpc" id="L123" title="3 of 4 branches missed.">        if (!(addr instanceof Inet4Address || addr instanceof Inet6Address))</span>
<span class="nc" id="L124">            throw new IllegalArgumentException(&quot;Invalid address type&quot;);</span>
<span class="fc" id="L125">        return isa;</span>
    }

    static InetSocketAddress asInetSocketAddress(SocketAddress sa) {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (!(sa instanceof InetSocketAddress))</span>
<span class="nc" id="L130">            throw new UnsupportedAddressTypeException();</span>
<span class="fc" id="L131">        return (InetSocketAddress)sa;</span>
    }

    static void translateToSocketException(Exception x)
        throws SocketException
    {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (x instanceof SocketException)</span>
<span class="nc" id="L138">            throw (SocketException)x;</span>
<span class="nc" id="L139">        Exception nx = x;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (x instanceof ClosedChannelException)</span>
<span class="nc" id="L141">            nx = new SocketException(&quot;Socket is closed&quot;);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        else if (x instanceof NotYetConnectedException)</span>
<span class="nc" id="L143">            nx = new SocketException(&quot;Socket is not connected&quot;);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        else if (x instanceof AlreadyBoundException)</span>
<span class="nc" id="L145">            nx = new SocketException(&quot;Already bound&quot;);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        else if (x instanceof NotYetBoundException)</span>
<span class="nc" id="L147">            nx = new SocketException(&quot;Socket is not bound yet&quot;);</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        else if (x instanceof UnsupportedAddressTypeException)</span>
<span class="nc" id="L149">            nx = new SocketException(&quot;Unsupported address type&quot;);</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        else if (x instanceof UnresolvedAddressException) {</span>
<span class="nc" id="L151">            nx = new SocketException(&quot;Unresolved address&quot;);</span>
        }
<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (nx != x)</span>
<span class="nc" id="L154">            nx.initCause(x);</span>

<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (nx instanceof SocketException)</span>
<span class="nc" id="L157">            throw (SocketException)nx;</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        else if (nx instanceof RuntimeException)</span>
<span class="nc" id="L159">            throw (RuntimeException)nx;</span>
        else
<span class="nc" id="L161">            throw new Error(&quot;Untranslated exception&quot;, nx);</span>
    }

    static void translateException(Exception x,
                                   boolean unknownHostForUnresolved)
        throws IOException
    {
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (x instanceof IOException)</span>
<span class="fc" id="L169">            throw (IOException)x;</span>
        // Throw UnknownHostException from here since it cannot
        // be thrown as a SocketException
<span class="nc bnc" id="L172" title="All 4 branches missed.">        if (unknownHostForUnresolved &amp;&amp;</span>
            (x instanceof UnresolvedAddressException))
        {
<span class="nc" id="L175">             throw new UnknownHostException();</span>
        }
<span class="nc" id="L177">        translateToSocketException(x);</span>
<span class="nc" id="L178">    }</span>

    static void translateException(Exception x)
        throws IOException
    {
<span class="nc" id="L183">        translateException(x, false);</span>
<span class="nc" id="L184">    }</span>

    /**
     * Returns the local address after performing a SecurityManager#checkConnect.
     */
    static InetSocketAddress getRevealedLocalAddress(InetSocketAddress addr) {
<span class="fc" id="L190">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L191" title="All 4 branches covered.">        if (addr == null || sm == null)</span>
<span class="fc" id="L192">            return addr;</span>

        try{
<span class="fc" id="L195">            sm.checkConnect(addr.getAddress().getHostAddress(), -1);</span>
            // Security check passed
<span class="nc" id="L197">        } catch (SecurityException e) {</span>
            // Return loopback address only if security check fails
<span class="nc" id="L199">            addr = getLoopbackAddress(addr.getPort());</span>
<span class="fc" id="L200">        }</span>
<span class="fc" id="L201">        return addr;</span>
    }

    static String getRevealedLocalAddressAsString(InetSocketAddress addr) {
<span class="fc bfc" id="L205" title="All 2 branches covered.">        return System.getSecurityManager() == null ? addr.toString() :</span>
<span class="fc" id="L206">                getLoopbackAddress(addr.getPort()).toString();</span>
    }

    private static InetSocketAddress getLoopbackAddress(int port) {
<span class="fc" id="L210">        return new InetSocketAddress(InetAddress.getLoopbackAddress(),</span>
                                     port);
    }

    /**
     * Returns any IPv4 address of the given network interface, or
     * null if the interface does not have any IPv4 addresses.
     */
    static Inet4Address anyInet4Address(final NetworkInterface interf) {
<span class="fc" id="L219">        return AccessController.doPrivileged(new PrivilegedAction&lt;Inet4Address&gt;() {</span>
            public Inet4Address run() {
<span class="fc" id="L221">                Enumeration&lt;InetAddress&gt; addrs = interf.getInetAddresses();</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">                while (addrs.hasMoreElements()) {</span>
<span class="fc" id="L223">                    InetAddress addr = addrs.nextElement();</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">                    if (addr instanceof Inet4Address) {</span>
<span class="fc" id="L225">                        return (Inet4Address)addr;</span>
                    }
<span class="fc" id="L227">                }</span>
<span class="nc" id="L228">                return null;</span>
            }
        });
    }

    /**
     * Returns an IPv4 address as an int.
     */
    static int inet4AsInt(InetAddress ia) {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (ia instanceof Inet4Address) {</span>
<span class="fc" id="L238">            byte[] addr = ia.getAddress();</span>
<span class="fc" id="L239">            int address  = addr[3] &amp; 0xFF;</span>
<span class="fc" id="L240">            address |= ((addr[2] &lt;&lt; 8) &amp; 0xFF00);</span>
<span class="fc" id="L241">            address |= ((addr[1] &lt;&lt; 16) &amp; 0xFF0000);</span>
<span class="fc" id="L242">            address |= ((addr[0] &lt;&lt; 24) &amp; 0xFF000000);</span>
<span class="fc" id="L243">            return address;</span>
        }
<span class="nc" id="L245">        throw new AssertionError(&quot;Should not reach here&quot;);</span>
    }

    /**
     * Returns an InetAddress from the given IPv4 address
     * represented as an int.
     */
    static InetAddress inet4FromInt(int address) {
<span class="nc" id="L253">        byte[] addr = new byte[4];</span>
<span class="nc" id="L254">        addr[0] = (byte) ((address &gt;&gt;&gt; 24) &amp; 0xFF);</span>
<span class="nc" id="L255">        addr[1] = (byte) ((address &gt;&gt;&gt; 16) &amp; 0xFF);</span>
<span class="nc" id="L256">        addr[2] = (byte) ((address &gt;&gt;&gt; 8) &amp; 0xFF);</span>
<span class="nc" id="L257">        addr[3] = (byte) (address &amp; 0xFF);</span>
        try {
<span class="nc" id="L259">            return InetAddress.getByAddress(addr);</span>
<span class="nc" id="L260">        } catch (UnknownHostException uhe) {</span>
<span class="nc" id="L261">            throw new AssertionError(&quot;Should not reach here&quot;);</span>
        }
    }

    /**
     * Returns an IPv6 address as a byte array
     */
    static byte[] inet6AsByteArray(InetAddress ia) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (ia instanceof Inet6Address) {</span>
<span class="nc" id="L270">            return ia.getAddress();</span>
        }

        // need to construct IPv4-mapped address
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (ia instanceof Inet4Address) {</span>
<span class="nc" id="L275">            byte[] ip4address = ia.getAddress();</span>
<span class="nc" id="L276">            byte[] address = new byte[16];</span>
<span class="nc" id="L277">            address[10] = (byte)0xff;</span>
<span class="nc" id="L278">            address[11] = (byte)0xff;</span>
<span class="nc" id="L279">            address[12] = ip4address[0];</span>
<span class="nc" id="L280">            address[13] = ip4address[1];</span>
<span class="nc" id="L281">            address[14] = ip4address[2];</span>
<span class="nc" id="L282">            address[15] = ip4address[3];</span>
<span class="nc" id="L283">            return address;</span>
        }

<span class="nc" id="L286">        throw new AssertionError(&quot;Should not reach here&quot;);</span>
    }

    // -- Socket options

    static void setSocketOption(FileDescriptor fd, ProtocolFamily family,
                                SocketOption&lt;?&gt; name, Object value)
        throws IOException
    {
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (value == null)</span>
<span class="nc" id="L296">            throw new IllegalArgumentException(&quot;Invalid option value&quot;);</span>

        // only simple values supported by this method
<span class="fc" id="L299">        Class&lt;?&gt; type = name.type();</span>
<span class="pc bpc" id="L300" title="1 of 4 branches missed.">        if (type != Integer.class &amp;&amp; type != Boolean.class)</span>
<span class="nc" id="L301">            throw new AssertionError(&quot;Should not reach here&quot;);</span>

        // special handling
<span class="pc bpc" id="L304" title="2 of 4 branches missed.">        if (name == StandardSocketOptions.SO_RCVBUF ||</span>
            name == StandardSocketOptions.SO_SNDBUF)
        {
<span class="nc" id="L307">            int i = ((Integer)value).intValue();</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (i &lt; 0)</span>
<span class="nc" id="L309">                throw new IllegalArgumentException(&quot;Invalid send/receive buffer size&quot;);</span>
        }
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (name == StandardSocketOptions.SO_LINGER) {</span>
<span class="fc" id="L312">            int i = ((Integer)value).intValue();</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">            if (i &lt; 0)</span>
<span class="fc" id="L314">                value = Integer.valueOf(-1);</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">            if (i &gt; 65535)</span>
<span class="nc" id="L316">                value = Integer.valueOf(65535);</span>
        }
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">        if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="nc" id="L319">            int i = ((Integer)value).intValue();</span>
<span class="nc bnc" id="L320" title="All 4 branches missed.">            if (i &lt; 0 || i &gt; 255)</span>
<span class="nc" id="L321">                throw new IllegalArgumentException(&quot;Invalid IP_TOS value&quot;);</span>
        }
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        if (name == StandardSocketOptions.IP_MULTICAST_TTL) {</span>
<span class="nc" id="L324">            int i = ((Integer)value).intValue();</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">            if (i &lt; 0 || i &gt; 255)</span>
<span class="nc" id="L326">                throw new IllegalArgumentException(&quot;Invalid TTL/hop value&quot;);</span>
        }

        // map option name to platform level/name
<span class="fc" id="L330">        OptionKey key = SocketOptionRegistry.findOption(name, family);</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L332">            throw new AssertionError(&quot;Option not found&quot;);</span>

        int arg;
<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (type == Integer.class) {</span>
<span class="fc" id="L336">            arg = ((Integer)value).intValue();</span>
        } else {
<span class="fc" id="L338">            boolean b = ((Boolean)value).booleanValue();</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">            arg = (b) ? 1 : 0;</span>
        }

<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        boolean mayNeedConversion = (family == UNSPEC);</span>
<span class="fc" id="L343">        setIntOption0(fd, mayNeedConversion, key.level(), key.name(), arg);</span>
<span class="fc" id="L344">    }</span>

    static Object getSocketOption(FileDescriptor fd, ProtocolFamily family,
                                  SocketOption&lt;?&gt; name)
        throws IOException
    {
<span class="fc" id="L350">        Class&lt;?&gt; type = name.type();</span>

        // only simple values supported by this method
<span class="pc bpc" id="L353" title="2 of 4 branches missed.">        if (type != Integer.class &amp;&amp; type != Boolean.class)</span>
<span class="nc" id="L354">            throw new AssertionError(&quot;Should not reach here&quot;);</span>

        // map option name to platform level/name
<span class="fc" id="L357">        OptionKey key = SocketOptionRegistry.findOption(name, family);</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L359">            throw new AssertionError(&quot;Option not found&quot;);</span>

<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        boolean mayNeedConversion = (family == UNSPEC);</span>
<span class="fc" id="L362">        int value = getIntOption0(fd, mayNeedConversion, key.level(), key.name());</span>

<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (type == Integer.class) {</span>
<span class="nc" id="L365">            return Integer.valueOf(value);</span>
        } else {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            return (value == 0) ? Boolean.FALSE : Boolean.TRUE;</span>
        }
    }

    // -- Socket operations --

    private static native boolean isIPv6Available0();

    /*
     * Returns 1 for Windows versions that support exclusive binding by default, 0
     * for those that do not, and -1 for Solaris/Linux/Mac OS
     */
    private static native int isExclusiveBindAvailable();

    private static native boolean canIPv6SocketJoinIPv4Group0();

    private static native boolean canJoin6WithIPv4Group0();

    static FileDescriptor socket(boolean stream) throws IOException {
<span class="fc" id="L386">        return socket(UNSPEC, stream);</span>
    }

    static FileDescriptor socket(ProtocolFamily family, boolean stream)
        throws IOException {
<span class="fc bfc" id="L391" title="All 4 branches covered.">        boolean preferIPv6 = isIPv6Available() &amp;&amp;</span>
            (family != StandardProtocolFamily.INET);
<span class="fc" id="L393">        return IOUtil.newFD(socket0(preferIPv6, stream, false));</span>
    }

    static FileDescriptor serverSocket(boolean stream) {
<span class="fc" id="L397">        return IOUtil.newFD(socket0(isIPv6Available(), stream, true));</span>
    }

    // Due to oddities SO_REUSEADDR on windows reuse is ignored
    private static native int socket0(boolean preferIPv6, boolean stream, boolean reuse);

    public static void bind(FileDescriptor fd, InetAddress addr, int port)
        throws IOException
    {
<span class="fc" id="L406">        bind(UNSPEC, fd, addr, port);</span>
<span class="fc" id="L407">    }</span>

    static void bind(ProtocolFamily family, FileDescriptor fd,
                     InetAddress addr, int port) throws IOException
    {
<span class="fc bfc" id="L412" title="All 4 branches covered.">        boolean preferIPv6 = isIPv6Available() &amp;&amp;</span>
            (family != StandardProtocolFamily.INET);
<span class="fc" id="L414">        bind0(fd, preferIPv6, exclusiveBind, addr, port);</span>
<span class="fc" id="L415">    }</span>

    private static native void bind0(FileDescriptor fd, boolean preferIPv6,
                                     boolean useExclBind, InetAddress addr,
                                     int port)
        throws IOException;

    static native void listen(FileDescriptor fd, int backlog) throws IOException;

    static int connect(FileDescriptor fd, InetAddress remote, int remotePort)
        throws IOException
    {
<span class="fc" id="L427">        return connect(UNSPEC, fd, remote, remotePort);</span>
    }

    static int connect(ProtocolFamily family, FileDescriptor fd, InetAddress remote, int remotePort)
        throws IOException
    {
<span class="pc bpc" id="L433" title="1 of 4 branches missed.">        boolean preferIPv6 = isIPv6Available() &amp;&amp;</span>
            (family != StandardProtocolFamily.INET);
<span class="fc" id="L435">        return connect0(preferIPv6, fd, remote, remotePort);</span>
    }

    private static native int connect0(boolean preferIPv6,
                                       FileDescriptor fd,
                                       InetAddress remote,
                                       int remotePort)
        throws IOException;


    public final static int SHUT_RD = 0;
    public final static int SHUT_WR = 1;
    public final static int SHUT_RDWR = 2;

    static native void shutdown(FileDescriptor fd, int how) throws IOException;

    private static native int localPort(FileDescriptor fd)
        throws IOException;

    private static native InetAddress localInetAddress(FileDescriptor fd)
        throws IOException;

    public static InetSocketAddress localAddress(FileDescriptor fd)
        throws IOException
    {
<span class="fc" id="L460">        return new InetSocketAddress(localInetAddress(fd), localPort(fd));</span>
    }

    private static native int remotePort(FileDescriptor fd)
        throws IOException;

    private static native InetAddress remoteInetAddress(FileDescriptor fd)
        throws IOException;

    static InetSocketAddress remoteAddress(FileDescriptor fd)
        throws IOException
    {
<span class="nc" id="L472">        return new InetSocketAddress(remoteInetAddress(fd), remotePort(fd));</span>
    }

    private static native int getIntOption0(FileDescriptor fd, boolean mayNeedConversion,
                                            int level, int opt)
        throws IOException;

    private static native void setIntOption0(FileDescriptor fd, boolean mayNeedConversion,
                                             int level, int opt, int arg)
        throws IOException;

    static native int poll(FileDescriptor fd, int events, long timeout)
        throws IOException;

    // -- Multicast support --


    /**
     * Join IPv4 multicast group
     */
    static int join4(FileDescriptor fd, int group, int interf, int source)
        throws IOException
    {
<span class="fc" id="L495">        return joinOrDrop4(true, fd, group, interf, source);</span>
    }

    /**
     * Drop membership of IPv4 multicast group
     */
    static void drop4(FileDescriptor fd, int group, int interf, int source)
        throws IOException
    {
<span class="nc" id="L504">        joinOrDrop4(false, fd, group, interf, source);</span>
<span class="nc" id="L505">    }</span>

    private static native int joinOrDrop4(boolean join, FileDescriptor fd, int group, int interf, int source)
        throws IOException;

    /**
     * Block IPv4 source
     */
    static int block4(FileDescriptor fd, int group, int interf, int source)
        throws IOException
    {
<span class="nc" id="L516">        return blockOrUnblock4(true, fd, group, interf, source);</span>
    }

    /**
     * Unblock IPv6 source
     */
    static void unblock4(FileDescriptor fd, int group, int interf, int source)
        throws IOException
    {
<span class="nc" id="L525">        blockOrUnblock4(false, fd, group, interf, source);</span>
<span class="nc" id="L526">    }</span>

    private static native int blockOrUnblock4(boolean block, FileDescriptor fd, int group,
                                              int interf, int source)
        throws IOException;

    /**
     * Join IPv6 multicast group
     */
    static int join6(FileDescriptor fd, byte[] group, int index, byte[] source)
        throws IOException
    {
<span class="nc" id="L538">        return joinOrDrop6(true, fd, group, index, source);</span>
    }

    /**
     * Drop membership of IPv6 multicast group
     */
    static void drop6(FileDescriptor fd, byte[] group, int index, byte[] source)
        throws IOException
    {
<span class="nc" id="L547">        joinOrDrop6(false, fd, group, index, source);</span>
<span class="nc" id="L548">    }</span>

    private static native int joinOrDrop6(boolean join, FileDescriptor fd, byte[] group, int index, byte[] source)
        throws IOException;

    /**
     * Block IPv6 source
     */
    static int block6(FileDescriptor fd, byte[] group, int index, byte[] source)
        throws IOException
    {
<span class="nc" id="L559">        return blockOrUnblock6(true, fd, group, index, source);</span>
    }

    /**
     * Unblock IPv6 source
     */
    static void unblock6(FileDescriptor fd, byte[] group, int index, byte[] source)
        throws IOException
    {
<span class="nc" id="L568">        blockOrUnblock6(false, fd, group, index, source);</span>
<span class="nc" id="L569">    }</span>

    static native int blockOrUnblock6(boolean block, FileDescriptor fd, byte[] group, int index, byte[] source)
        throws IOException;

    static native void setInterface4(FileDescriptor fd, int interf) throws IOException;

    static native int getInterface4(FileDescriptor fd) throws IOException;

    static native void setInterface6(FileDescriptor fd, int index) throws IOException;

    static native int getInterface6(FileDescriptor fd) throws IOException;

    private static native void initIDs();

    static {
<span class="fc" id="L585">        IOUtil.load();</span>
<span class="fc" id="L586">        initIDs();</span>
<span class="fc" id="L587">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>