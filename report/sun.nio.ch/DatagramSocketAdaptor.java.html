<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DatagramSocketAdaptor.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.nio.ch</a> &gt; <span class="el_source">DatagramSocketAdaptor.java</span></div><h1>DatagramSocketAdaptor.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.ch;

import java.io.*;
import java.net.*;
import java.nio.*;
import java.nio.channels.*;


// Make a datagram-socket channel look like a datagram socket.
//
// The methods in this class are defined in exactly the same order as in
// java.net.DatagramSocket so as to simplify tracking future changes to that
// class.
//

public class DatagramSocketAdaptor
    extends DatagramSocket
{

    // The channel being adapted
    private final DatagramChannelImpl dc;

    // Timeout &quot;option&quot; value for receives
<span class="fc" id="L49">    private volatile int timeout = 0;</span>

    // ## super will create a useless impl
    private DatagramSocketAdaptor(DatagramChannelImpl dc) throws IOException {
        // Invoke the DatagramSocketAdaptor(SocketAddress) constructor,
        // passing a dummy DatagramSocketImpl object to aovid any native
        // resource allocation in super class and invoking our bind method
        // before the dc field is initialized.
<span class="fc" id="L57">        super(dummyDatagramSocket);</span>
<span class="fc" id="L58">        this.dc = dc;</span>
<span class="fc" id="L59">    }</span>

    public static DatagramSocket create(DatagramChannelImpl dc) {
        try {
<span class="fc" id="L63">            return new DatagramSocketAdaptor(dc);</span>
<span class="nc" id="L64">        } catch (IOException x) {</span>
<span class="nc" id="L65">            throw new Error(x);</span>
        }
    }

    private void connectInternal(SocketAddress remote)
        throws SocketException
    {
<span class="nc" id="L72">        InetSocketAddress isa = Net.asInetSocketAddress(remote);</span>
<span class="nc" id="L73">        int port = isa.getPort();</span>
<span class="nc bnc" id="L74" title="All 4 branches missed.">        if (port &lt; 0 || port &gt; 0xFFFF)</span>
<span class="nc" id="L75">            throw new IllegalArgumentException(&quot;connect: &quot; + port);</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">        if (remote == null)</span>
<span class="nc" id="L77">            throw new IllegalArgumentException(&quot;connect: null address&quot;);</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L79">            return;</span>
        try {
<span class="nc" id="L81">            dc.connect(remote);</span>
<span class="nc" id="L82">        } catch (Exception x) {</span>
<span class="nc" id="L83">            Net.translateToSocketException(x);</span>
<span class="nc" id="L84">        }</span>
<span class="nc" id="L85">    }</span>

    public void bind(SocketAddress local) throws SocketException {
        try {
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">            if (local == null)</span>
<span class="nc" id="L90">                local = new InetSocketAddress(0);</span>
<span class="fc" id="L91">            dc.bind(local);</span>
<span class="nc" id="L92">        } catch (Exception x) {</span>
<span class="nc" id="L93">            Net.translateToSocketException(x);</span>
<span class="fc" id="L94">        }</span>
<span class="fc" id="L95">    }</span>

    public void connect(InetAddress address, int port) {
        try {
<span class="nc" id="L99">            connectInternal(new InetSocketAddress(address, port));</span>
<span class="nc" id="L100">        } catch (SocketException x) {</span>
            // Yes, j.n.DatagramSocket really does this
<span class="nc" id="L102">        }</span>
<span class="nc" id="L103">    }</span>

    public void connect(SocketAddress remote) throws SocketException {
<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (remote == null)</span>
<span class="nc" id="L107">            throw new IllegalArgumentException(&quot;Address can't be null&quot;);</span>
<span class="nc" id="L108">        connectInternal(remote);</span>
<span class="nc" id="L109">    }</span>

    public void disconnect() {
        try {
<span class="nc" id="L113">            dc.disconnect();</span>
<span class="nc" id="L114">        } catch (IOException x) {</span>
<span class="nc" id="L115">            throw new Error(x);</span>
<span class="nc" id="L116">        }</span>
<span class="nc" id="L117">    }</span>

    public boolean isBound() {
<span class="nc bnc" id="L120" title="All 2 branches missed.">        return dc.localAddress() != null;</span>
    }

    public boolean isConnected() {
<span class="nc bnc" id="L124" title="All 2 branches missed.">        return dc.remoteAddress() != null;</span>
    }

    public InetAddress getInetAddress() {
<span class="nc bnc" id="L128" title="All 2 branches missed.">        return (isConnected()</span>
<span class="nc" id="L129">                ? Net.asInetSocketAddress(dc.remoteAddress()).getAddress()</span>
                : null);
    }

    public int getPort() {
<span class="nc bnc" id="L134" title="All 2 branches missed.">        return (isConnected()</span>
<span class="nc" id="L135">                ? Net.asInetSocketAddress(dc.remoteAddress()).getPort()</span>
                : -1);
    }

    public void send(DatagramPacket p) throws IOException {
<span class="nc" id="L140">        synchronized (dc.blockingLock()) {</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (!dc.isBlocking())</span>
<span class="nc" id="L142">                throw new IllegalBlockingModeException();</span>
            try {
<span class="nc" id="L144">                synchronized (p) {</span>
<span class="nc" id="L145">                    ByteBuffer bb = ByteBuffer.wrap(p.getData(),</span>
<span class="nc" id="L146">                                                    p.getOffset(),</span>
<span class="nc" id="L147">                                                    p.getLength());</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                    if (dc.isConnected()) {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">                        if (p.getAddress() == null) {</span>
                            // Legacy DatagramSocket will send in this case
                            // and set address and port of the packet
<span class="nc" id="L152">                            InetSocketAddress isa = (InetSocketAddress)</span>
<span class="nc" id="L153">                                                    dc.remoteAddress();</span>
<span class="nc" id="L154">                            p.setPort(isa.getPort());</span>
<span class="nc" id="L155">                            p.setAddress(isa.getAddress());</span>
<span class="nc" id="L156">                            dc.write(bb);</span>
<span class="nc" id="L157">                        } else {</span>
                            // Target address may not match connected address
<span class="nc" id="L159">                            dc.send(bb, p.getSocketAddress());</span>
                        }
                    } else {
                        // Not connected so address must be valid or throw
<span class="nc" id="L163">                        dc.send(bb, p.getSocketAddress());</span>
                    }
<span class="nc" id="L165">                }</span>
<span class="nc" id="L166">            } catch (IOException x) {</span>
<span class="nc" id="L167">                Net.translateException(x);</span>
<span class="nc" id="L168">            }</span>
<span class="nc" id="L169">        }</span>
<span class="nc" id="L170">    }</span>

    // Must hold dc.blockingLock()
    //
    private SocketAddress receive(ByteBuffer bb) throws IOException {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (timeout == 0) {</span>
<span class="nc" id="L176">            return dc.receive(bb);</span>
        }

<span class="nc" id="L179">        dc.configureBlocking(false);</span>
        try {
            int n;
            SocketAddress sender;
<span class="nc bnc" id="L183" title="All 2 branches missed.">            if ((sender = dc.receive(bb)) != null)</span>
<span class="nc" id="L184">                return sender;</span>
<span class="nc" id="L185">            long to = timeout;</span>
            for (;;) {
<span class="nc bnc" id="L187" title="All 2 branches missed.">                if (!dc.isOpen())</span>
<span class="nc" id="L188">                     throw new ClosedChannelException();</span>
<span class="nc" id="L189">                long st = System.currentTimeMillis();</span>
<span class="nc" id="L190">                int result = dc.poll(PollArrayWrapper.POLLIN, to);</span>
<span class="nc bnc" id="L191" title="All 4 branches missed.">                if (result &gt; 0 &amp;&amp;</span>
                        ((result &amp; PollArrayWrapper.POLLIN) != 0)) {
<span class="nc bnc" id="L193" title="All 2 branches missed.">                    if ((sender = dc.receive(bb)) != null)</span>
<span class="nc" id="L194">                        return sender;</span>
                }
<span class="nc" id="L196">                to -= System.currentTimeMillis() - st;</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">                if (to &lt;= 0)</span>
<span class="nc" id="L198">                    throw new SocketTimeoutException();</span>

<span class="nc" id="L200">            }</span>
        } finally {
<span class="nc bnc" id="L202" title="All 6 branches missed.">            if (dc.isOpen())</span>
<span class="nc" id="L203">                dc.configureBlocking(true);</span>
        }
    }

    public void receive(DatagramPacket p) throws IOException {
<span class="nc" id="L208">        synchronized (dc.blockingLock()) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (!dc.isBlocking())</span>
<span class="nc" id="L210">                throw new IllegalBlockingModeException();</span>
            try {
<span class="nc" id="L212">                synchronized (p) {</span>
<span class="nc" id="L213">                    ByteBuffer bb = ByteBuffer.wrap(p.getData(),</span>
<span class="nc" id="L214">                                                    p.getOffset(),</span>
<span class="nc" id="L215">                                                    p.getLength());</span>
<span class="nc" id="L216">                    SocketAddress sender = receive(bb);</span>
<span class="nc" id="L217">                    p.setSocketAddress(sender);</span>
<span class="nc" id="L218">                    p.setLength(bb.position() - p.getOffset());</span>
<span class="nc" id="L219">                }</span>
<span class="nc" id="L220">            } catch (IOException x) {</span>
<span class="nc" id="L221">                Net.translateException(x);</span>
<span class="nc" id="L222">            }</span>
<span class="nc" id="L223">        }</span>
<span class="nc" id="L224">    }</span>

    public InetAddress getLocalAddress() {
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L228">            return null;</span>
<span class="nc" id="L229">        SocketAddress local = dc.localAddress();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (local == null)</span>
<span class="nc" id="L231">            local = new InetSocketAddress(0);</span>
<span class="nc" id="L232">        InetAddress result = ((InetSocketAddress)local).getAddress();</span>
<span class="nc" id="L233">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (sm != null) {</span>
            try {
<span class="nc" id="L236">                sm.checkConnect(result.getHostAddress(), -1);</span>
<span class="nc" id="L237">            } catch (SecurityException x) {</span>
<span class="nc" id="L238">                return new InetSocketAddress(0).getAddress();</span>
<span class="nc" id="L239">            }</span>
        }
<span class="nc" id="L241">        return result;</span>
    }

    public int getLocalPort() {
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (isClosed())</span>
<span class="nc" id="L246">            return -1;</span>
        try {
<span class="fc" id="L248">            SocketAddress local = dc.getLocalAddress();</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">            if (local != null) {</span>
<span class="fc" id="L250">                return ((InetSocketAddress)local).getPort();</span>
            }
<span class="nc" id="L252">        } catch (Exception x) {</span>
<span class="nc" id="L253">        }</span>
<span class="nc" id="L254">        return 0;</span>
    }

    public void setSoTimeout(int timeout) throws SocketException {
<span class="nc" id="L258">        this.timeout = timeout;</span>
<span class="nc" id="L259">    }</span>

    public int getSoTimeout() throws SocketException {
<span class="nc" id="L262">        return timeout;</span>
    }

    private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
        throws SocketException
    {
        try {
<span class="nc" id="L269">            dc.setOption(name, value);</span>
<span class="nc" id="L270">        } catch (IOException x) {</span>
<span class="nc" id="L271">            Net.translateToSocketException(x);</span>
<span class="nc" id="L272">        }</span>
<span class="nc" id="L273">    }</span>

    private void setIntOption(SocketOption&lt;Integer&gt; name, int value)
        throws SocketException
    {
        try {
<span class="nc" id="L279">            dc.setOption(name, value);</span>
<span class="nc" id="L280">        } catch (IOException x) {</span>
<span class="nc" id="L281">            Net.translateToSocketException(x);</span>
<span class="nc" id="L282">        }</span>
<span class="nc" id="L283">    }</span>

    private boolean getBooleanOption(SocketOption&lt;Boolean&gt; name) throws SocketException {
        try {
<span class="nc" id="L287">            return dc.getOption(name).booleanValue();</span>
<span class="nc" id="L288">        } catch (IOException x) {</span>
<span class="nc" id="L289">            Net.translateToSocketException(x);</span>
<span class="nc" id="L290">            return false;       // keep compiler happy</span>
        }
    }

    private int getIntOption(SocketOption&lt;Integer&gt; name) throws SocketException {
        try {
<span class="nc" id="L296">            return dc.getOption(name).intValue();</span>
<span class="nc" id="L297">        } catch (IOException x) {</span>
<span class="nc" id="L298">            Net.translateToSocketException(x);</span>
<span class="nc" id="L299">            return -1;          // keep compiler happy</span>
        }
    }

    public void setSendBufferSize(int size) throws SocketException {
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (size &lt;= 0)</span>
<span class="nc" id="L305">            throw new IllegalArgumentException(&quot;Invalid send size&quot;);</span>
<span class="nc" id="L306">        setIntOption(StandardSocketOptions.SO_SNDBUF, size);</span>
<span class="nc" id="L307">    }</span>

    public int getSendBufferSize() throws SocketException {
<span class="nc" id="L310">        return getIntOption(StandardSocketOptions.SO_SNDBUF);</span>
    }

    public void setReceiveBufferSize(int size) throws SocketException {
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (size &lt;= 0)</span>
<span class="nc" id="L315">            throw new IllegalArgumentException(&quot;Invalid receive size&quot;);</span>
<span class="nc" id="L316">        setIntOption(StandardSocketOptions.SO_RCVBUF, size);</span>
<span class="nc" id="L317">    }</span>

    public int getReceiveBufferSize() throws SocketException {
<span class="nc" id="L320">        return getIntOption(StandardSocketOptions.SO_RCVBUF);</span>
    }

    public void setReuseAddress(boolean on) throws SocketException {
<span class="nc" id="L324">        setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);</span>
<span class="nc" id="L325">    }</span>

    public boolean getReuseAddress() throws SocketException {
<span class="nc" id="L328">        return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);</span>

    }

    public void setBroadcast(boolean on) throws SocketException {
<span class="nc" id="L333">        setBooleanOption(StandardSocketOptions.SO_BROADCAST, on);</span>
<span class="nc" id="L334">    }</span>

    public boolean getBroadcast() throws SocketException {
<span class="nc" id="L337">        return getBooleanOption(StandardSocketOptions.SO_BROADCAST);</span>
    }

    public void setTrafficClass(int tc) throws SocketException {
<span class="nc" id="L341">        setIntOption(StandardSocketOptions.IP_TOS, tc);</span>
<span class="nc" id="L342">    }</span>

    public int getTrafficClass() throws SocketException {
<span class="nc" id="L345">        return getIntOption(StandardSocketOptions.IP_TOS);</span>
    }

    public void close() {
        try {
<span class="nc" id="L350">            dc.close();</span>
<span class="nc" id="L351">        } catch (IOException x) {</span>
<span class="nc" id="L352">            throw new Error(x);</span>
<span class="nc" id="L353">        }</span>
<span class="nc" id="L354">    }</span>

    public boolean isClosed() {
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        return !dc.isOpen();</span>
    }

    public DatagramChannel getChannel() {
<span class="nc" id="L361">        return dc;</span>
    }

   /*
    * A dummy implementation of DatagramSocketImpl that can be passed to the
    * DatagramSocket constructor so that no native resources are allocated in
    * super class.
    */
<span class="fc" id="L369">   private static final DatagramSocketImpl dummyDatagramSocket</span>
       = new DatagramSocketImpl()
<span class="fc" id="L371">   {</span>
<span class="nc" id="L372">       protected void create() throws SocketException {}</span>

<span class="nc" id="L374">       protected void bind(int lport, InetAddress laddr) throws SocketException {}</span>

<span class="nc" id="L376">       protected void send(DatagramPacket p) throws IOException {}</span>

<span class="nc" id="L378">       protected int peek(InetAddress i) throws IOException { return 0; }</span>

<span class="nc" id="L380">       protected int peekData(DatagramPacket p) throws IOException { return 0; }</span>

<span class="nc" id="L382">       protected void receive(DatagramPacket p) throws IOException {}</span>

       @Deprecated
<span class="nc" id="L385">       protected void setTTL(byte ttl) throws IOException {}</span>

       @Deprecated
<span class="nc" id="L388">       protected byte getTTL() throws IOException { return 0; }</span>

<span class="nc" id="L390">       protected void setTimeToLive(int ttl) throws IOException {}</span>

<span class="nc" id="L392">       protected int getTimeToLive() throws IOException { return 0;}</span>

<span class="nc" id="L394">       protected void join(InetAddress inetaddr) throws IOException {}</span>

<span class="nc" id="L396">       protected void leave(InetAddress inetaddr) throws IOException {}</span>

       protected void joinGroup(SocketAddress mcastaddr,
<span class="nc" id="L399">                                 NetworkInterface netIf) throws IOException {}</span>

       protected void leaveGroup(SocketAddress mcastaddr,
<span class="nc" id="L402">                                 NetworkInterface netIf) throws IOException {}</span>

<span class="nc" id="L404">       protected void close() {}</span>

<span class="nc" id="L406">       public Object getOption(int optID) throws SocketException { return null;}</span>

<span class="nc" id="L408">       public void setOption(int optID, Object value) throws SocketException {}</span>
   };
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>