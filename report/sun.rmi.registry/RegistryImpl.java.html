<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RegistryImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.rmi.registry</a> &gt; <span class="el_source">RegistryImpl.java</span></div><h1>RegistryImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.rmi.registry;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.io.FilePermission;
import java.io.IOException;
import java.net.*;
import java.rmi.*;
import java.rmi.server.ObjID;
import java.rmi.server.RemoteServer;
import java.rmi.server.ServerNotActiveException;
import java.rmi.registry.Registry;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMIServerSocketFactory;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.CodeSource;
import java.security.Policy;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.security.PermissionCollection;
import java.security.Permissions;
import java.security.ProtectionDomain;
import java.text.MessageFormat;
import sun.rmi.server.LoaderHandler;
import sun.rmi.server.UnicastServerRef;
import sun.rmi.server.UnicastServerRef2;
import sun.rmi.transport.LiveRef;
import sun.rmi.transport.ObjectTable;
import sun.rmi.transport.Target;

/**
 * A &quot;registry&quot; exists on every node that allows RMI connections to
 * servers on that node.  The registry on a particular node contains a
 * transient database that maps names to remote objects.  When the
 * node boots, the registry database is empty.  The names stored in the
 * registry are pure and are not parsed.  A service storing itself in
 * the registry may want to prefix its name of the service by a package
 * name (although not required), to reduce name collisions in the
 * registry.
 *
 * The LocateRegistry class is used to obtain registry for different hosts.
 *
 * @see java.rmi.registry.LocateRegistry
 */
public class RegistryImpl extends java.rmi.server.RemoteServer
        implements Registry
{

    /* indicate compatibility with JDK 1.1.x version of class */
    private static final long serialVersionUID = 4666870661827494597L;
<span class="fc" id="L79">    private Hashtable&lt;String, Remote&gt; bindings</span>
        = new Hashtable&lt;&gt;(101);
<span class="fc" id="L81">    private static Hashtable&lt;InetAddress, InetAddress&gt; allowedAccessCache</span>
        = new Hashtable&lt;&gt;(3);
    private static RegistryImpl registry;
<span class="fc" id="L84">    private static ObjID id = new ObjID(ObjID.REGISTRY_ID);</span>

<span class="fc" id="L86">    private static ResourceBundle resources = null;</span>

    /**
     * Construct a new RegistryImpl on the specified port with the
     * given custom socket factory pair.
     */
    public RegistryImpl(int port,
                        RMIClientSocketFactory csf,
                        RMIServerSocketFactory ssf)
        throws RemoteException
<span class="fc" id="L96">    {</span>
<span class="fc" id="L97">        LiveRef lref = new LiveRef(id, port, csf, ssf);</span>
<span class="fc" id="L98">        setup(new UnicastServerRef2(lref));</span>
<span class="fc" id="L99">    }</span>

    /**
     * Construct a new RegistryImpl on the specified port.
     */
    public RegistryImpl(int port)
        throws RemoteException
<span class="fc" id="L106">    {</span>
<span class="fc" id="L107">        LiveRef lref = new LiveRef(id, port);</span>
<span class="fc" id="L108">        setup(new UnicastServerRef(lref));</span>
<span class="fc" id="L109">    }</span>

    /*
     * Create the export the object using the parameter
     * &lt;code&gt;uref&lt;/code&gt;
     */
    private void setup(UnicastServerRef uref)
        throws RemoteException
    {
        /* Server ref must be created and assigned before remote
         * object 'this' can be exported.
         */
<span class="fc" id="L121">        ref = uref;</span>
<span class="fc" id="L122">        uref.exportObject(this, null, true);</span>
<span class="fc" id="L123">    }</span>

    /**
     * Returns the remote object for specified name in the registry.
     * @exception RemoteException If remote operation failed.
     * @exception NotBound If name is not currently bound.
     */
    public Remote lookup(String name)
        throws RemoteException, NotBoundException
    {
<span class="fc" id="L133">        synchronized (bindings) {</span>
<span class="fc" id="L134">            Remote obj = bindings.get(name);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            if (obj == null)</span>
<span class="fc" id="L136">                throw new NotBoundException(name);</span>
<span class="fc" id="L137">            return obj;</span>
<span class="fc" id="L138">        }</span>
    }

    /**
     * Binds the name to the specified remote object.
     * @exception RemoteException If remote operation failed.
     * @exception AlreadyBoundException If name is already bound.
     */
    public void bind(String name, Remote obj)
        throws RemoteException, AlreadyBoundException, AccessException
    {
<span class="fc" id="L149">        checkAccess(&quot;Registry.bind&quot;);</span>
<span class="fc" id="L150">        synchronized (bindings) {</span>
<span class="fc" id="L151">            Remote curr = bindings.get(name);</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">            if (curr != null)</span>
<span class="nc" id="L153">                throw new AlreadyBoundException(name);</span>
<span class="fc" id="L154">            bindings.put(name, obj);</span>
<span class="pc" id="L155">        }</span>
<span class="fc" id="L156">    }</span>

    /**
     * Unbind the name.
     * @exception RemoteException If remote operation failed.
     * @exception NotBound If name is not currently bound.
     */
    public void unbind(String name)
        throws RemoteException, NotBoundException, AccessException
    {
<span class="fc" id="L166">        checkAccess(&quot;Registry.unbind&quot;);</span>
<span class="fc" id="L167">        synchronized (bindings) {</span>
<span class="fc" id="L168">            Remote obj = bindings.get(name);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            if (obj == null)</span>
<span class="fc" id="L170">                throw new NotBoundException(name);</span>
<span class="fc" id="L171">            bindings.remove(name);</span>
<span class="fc" id="L172">        }</span>
<span class="fc" id="L173">    }</span>

    /**
     * Rebind the name to a new object, replaces any existing binding.
     * @exception RemoteException If remote operation failed.
     */
    public void rebind(String name, Remote obj)
        throws RemoteException, AccessException
    {
<span class="fc" id="L182">        checkAccess(&quot;Registry.rebind&quot;);</span>
<span class="fc" id="L183">        bindings.put(name, obj);</span>
<span class="fc" id="L184">    }</span>

    /**
     * Returns an enumeration of the names in the registry.
     * @exception RemoteException If remote operation failed.
     */
    public String[] list()
        throws RemoteException
    {
        String[] names;
<span class="fc" id="L194">        synchronized (bindings) {</span>
<span class="fc" id="L195">            int i = bindings.size();</span>
<span class="fc" id="L196">            names = new String[i];</span>
<span class="fc" id="L197">            Enumeration&lt;String&gt; enum_ = bindings.keys();</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">            while ((--i) &gt;= 0)</span>
<span class="fc" id="L199">                names[i] = enum_.nextElement();</span>
<span class="pc" id="L200">        }</span>
<span class="fc" id="L201">        return names;</span>
    }

    /**
     * Check that the caller has access to perform indicated operation.
     * The client must be on same the same host as this server.
     */
    public static void checkAccess(String op) throws AccessException {

        try {
            /*
             * Get client host that this registry operation was made from.
             */
<span class="fc" id="L214">            final String clientHostName = getClientHost();</span>
            InetAddress clientHost;

            try {
<span class="fc" id="L218">                clientHost = java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L219">                    new java.security.PrivilegedExceptionAction&lt;InetAddress&gt;() {</span>
                        public InetAddress run()
                            throws java.net.UnknownHostException
                        {
<span class="fc" id="L223">                            return InetAddress.getByName(clientHostName);</span>
                        }
                    });
<span class="nc" id="L226">            } catch (PrivilegedActionException pae) {</span>
<span class="nc" id="L227">                throw (java.net.UnknownHostException) pae.getException();</span>
<span class="fc" id="L228">            }</span>

            // if client not yet seen, make sure client allowed access
<span class="fc bfc" id="L231" title="All 2 branches covered.">            if (allowedAccessCache.get(clientHost) == null) {</span>

<span class="pc bpc" id="L233" title="1 of 2 branches missed.">                if (clientHost.isAnyLocalAddress()) {</span>
<span class="nc" id="L234">                    throw new AccessException(</span>
                        &quot;Registry.&quot; + op + &quot; disallowed; origin unknown&quot;);
                }

                try {
<span class="fc" id="L239">                    final InetAddress finalClientHost = clientHost;</span>

<span class="fc" id="L241">                    java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L242">                        new java.security.PrivilegedExceptionAction&lt;Void&gt;() {</span>
                            public Void run() throws java.io.IOException {
                                /*
                                 * if a ServerSocket can be bound to the client's
                                 * address then that address must be local
                                 */
<span class="fc" id="L248">                                (new ServerSocket(0, 10, finalClientHost)).close();</span>
<span class="fc" id="L249">                                allowedAccessCache.put(finalClientHost,</span>
                                                       finalClientHost);
<span class="fc" id="L251">                                return null;</span>
                            }
                    });
<span class="nc" id="L254">                } catch (PrivilegedActionException pae) {</span>
                    // must have been an IOException

<span class="nc" id="L257">                    throw new AccessException(</span>
                        &quot;Registry.&quot; + op + &quot; disallowed; origin &quot; +
                        clientHost + &quot; is non-local host&quot;);
<span class="fc" id="L260">                }</span>
            }
<span class="fc" id="L262">        } catch (ServerNotActiveException ex) {</span>
            /*
             * Local call from this VM: allow access.
             */
<span class="nc" id="L266">        } catch (java.net.UnknownHostException ex) {</span>
<span class="nc" id="L267">            throw new AccessException(&quot;Registry.&quot; + op +</span>
                                      &quot; disallowed; origin is unknown host&quot;);
<span class="fc" id="L269">        }</span>
<span class="fc" id="L270">    }</span>

    public static ObjID getID() {
<span class="nc" id="L273">        return id;</span>
    }

    /**
     * Retrieves text resources from the locale-specific properties file.
     */
    private static String getTextResource(String key) {
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if (resources == null) {</span>
            try {
<span class="nc" id="L282">                resources = ResourceBundle.getBundle(</span>
                    &quot;sun.rmi.registryresources.rmiregistry&quot;);
<span class="fc" id="L284">            } catch (MissingResourceException mre) {</span>
<span class="nc" id="L285">            }</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">            if (resources == null) {</span>
                // throwing an Error is a bit extreme, methinks
<span class="fc" id="L288">                return (&quot;[missing resource file: &quot; + key + &quot;]&quot;);</span>
            }
        }

<span class="nc" id="L292">        String val = null;</span>
        try {
<span class="nc" id="L294">            val = resources.getString(key);</span>
<span class="nc" id="L295">        } catch (MissingResourceException mre) {</span>
<span class="nc" id="L296">        }</span>

<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (val == null) {</span>
<span class="nc" id="L299">            return (&quot;[missing resource: &quot; + key + &quot;]&quot;);</span>
        } else {
<span class="nc" id="L301">            return (val);</span>
        }
    }

    /**
     * Main program to start a registry. &lt;br&gt;
     * The port number can be specified on the command line.
     */
    public static void main(String args[])
    {
        // Create and install the security manager if one is not installed
        // already.
<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (System.getSecurityManager() == null) {</span>
<span class="fc" id="L314">            System.setSecurityManager(new RMISecurityManager());</span>
        }

        try {
            /*
             * Fix bugid 4147561: When JDK tools are executed, the value of
             * the CLASSPATH environment variable for the shell in which they
             * were invoked is no longer incorporated into the application
             * class path; CLASSPATH's only effect is to be the value of the
             * system property &quot;env.class.path&quot;.  To preserve the previous
             * (JDK1.1 and JDK1.2beta3) behavior of this tool, however, its
             * CLASSPATH should still be considered when resolving classes
             * being unmarshalled.  To effect this old behavior, a class
             * loader that loads from the file path specified in the
             * &quot;env.class.path&quot; property is created and set to be the context
             * class loader before the remote object is exported.
             */
<span class="fc" id="L331">            String envcp = System.getProperty(&quot;env.class.path&quot;);</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            if (envcp == null) {</span>
<span class="fc" id="L333">                envcp = &quot;.&quot;;            // preserve old default behavior</span>
            }
<span class="fc" id="L335">            URL[] urls = sun.misc.URLClassPath.pathToURLs(envcp);</span>
<span class="fc" id="L336">            ClassLoader cl = new URLClassLoader(urls);</span>

            /*
             * Fix bugid 4242317: Classes defined by this class loader should
             * be annotated with the value of the &quot;java.rmi.server.codebase&quot;
             * property, not the &quot;file:&quot; URLs for the CLASSPATH elements.
             */
<span class="fc" id="L343">            sun.rmi.server.LoaderHandler.registerCodebaseLoader(cl);</span>

<span class="fc" id="L345">            Thread.currentThread().setContextClassLoader(cl);</span>

<span class="pc bpc" id="L347" title="1 of 2 branches missed.">            final int regPort = (args.length &gt;= 1) ? Integer.parseInt(args[0])</span>
                                                   : Registry.REGISTRY_PORT;
            try {
<span class="fc" id="L350">                registry = AccessController.doPrivileged(</span>
<span class="fc" id="L351">                    new PrivilegedExceptionAction&lt;RegistryImpl&gt;() {</span>
                        public RegistryImpl run() throws RemoteException {
<span class="fc" id="L353">                            return new RegistryImpl(regPort);</span>
                        }
<span class="fc" id="L355">                    }, getAccessControlContext());</span>
<span class="nc" id="L356">            } catch (PrivilegedActionException ex) {</span>
<span class="nc" id="L357">                throw (RemoteException) ex.getException();</span>
<span class="fc" id="L358">            }</span>

            // prevent registry from exiting
            while (true) {
                try {
<span class="nc" id="L363">                    Thread.sleep(Long.MAX_VALUE);</span>
<span class="nc" id="L364">                } catch (InterruptedException e) {</span>
<span class="nc" id="L365">                }</span>
            }
<span class="fc" id="L367">        } catch (NumberFormatException e) {</span>
<span class="fc" id="L368">            System.err.println(MessageFormat.format(</span>
<span class="fc" id="L369">                getTextResource(&quot;rmiregistry.port.badnumber&quot;),</span>
                args[0] ));
<span class="fc" id="L371">            System.err.println(MessageFormat.format(</span>
<span class="fc" id="L372">                getTextResource(&quot;rmiregistry.usage&quot;),</span>
                &quot;rmiregistry&quot; ));
<span class="nc" id="L374">        } catch (Exception e) {</span>
<span class="nc" id="L375">            e.printStackTrace();</span>
<span class="fc" id="L376">        }</span>
<span class="nc" id="L377">        System.exit(1);</span>
<span class="nc" id="L378">    }</span>

    /**
     * Generates an AccessControlContext with minimal permissions.
     * The approach used here is taken from the similar method
     * getAccessControlContext() in the sun.applet.AppletPanel class.
     */
    private static AccessControlContext getAccessControlContext() {
        // begin with permissions granted to all code in current policy
<span class="fc" id="L387">        PermissionCollection perms = AccessController.doPrivileged(</span>
<span class="fc" id="L388">            new java.security.PrivilegedAction&lt;PermissionCollection&gt;() {</span>
                public PermissionCollection run() {
<span class="fc" id="L390">                    CodeSource codesource = new CodeSource(null,</span>
                        (java.security.cert.Certificate[]) null);
<span class="fc" id="L392">                    Policy p = java.security.Policy.getPolicy();</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">                    if (p != null) {</span>
<span class="fc" id="L394">                        return p.getPermissions(codesource);</span>
                    } else {
<span class="nc" id="L396">                        return new Permissions();</span>
                    }
                }
            });

        /*
         * Anyone can connect to the registry and the registry can connect
         * to and possibly download stubs from anywhere. Downloaded stubs and
         * related classes themselves are more tightly limited by RMI.
         */
<span class="fc" id="L406">        perms.add(new SocketPermission(&quot;*&quot;, &quot;connect,accept&quot;));</span>

<span class="fc" id="L408">        perms.add(new RuntimePermission(&quot;accessClassInPackage.sun.jvmstat.*&quot;));</span>
<span class="fc" id="L409">        perms.add(new RuntimePermission(&quot;accessClassInPackage.sun.jvm.hotspot.*&quot;));</span>

<span class="fc" id="L411">        perms.add(new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;));</span>

        /*
         * Create an AccessControlContext that consists of a single
         * protection domain with only the permissions calculated above.
         */
<span class="fc" id="L417">        ProtectionDomain pd = new ProtectionDomain(</span>
            new CodeSource(null,
                (java.security.cert.Certificate[]) null), perms);
<span class="fc" id="L420">        return new AccessControlContext(new ProtectionDomain[] { pd });</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>