<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DerValue.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.util</a> &gt; <span class="el_source">DerValue.java</span></div><h1>DerValue.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.util;

import java.io.*;
import java.math.BigInteger;
import java.util.Date;
import sun.misc.IOUtils;

/**
 * Represents a single DER-encoded value.  DER encoding rules are a subset
 * of the &quot;Basic&quot; Encoding Rules (BER), but they only support a single way
 * (&quot;Definite&quot; encoding) to encode any given value.
 *
 * &lt;P&gt;All DER-encoded data are triples &lt;em&gt;{type, length, data}&lt;/em&gt;.  This
 * class represents such tagged values as they have been read (or constructed),
 * and provides structured access to the encoded data.
 *
 * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 * data encodings which are defined.  That subset is sufficient for parsing
 * most X.509 certificates, and working with selected additional formats
 * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
 *
 * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
 * and RFC 3280, section 4.1.2.4., we assume that this kind of string will
 * contain ISO-8859-1 characters only.
 *
 *
 * @author David Brownell
 * @author Amit Kapoor
 * @author Hemma Prafullchandra
 */
public class DerValue {
    /** The tag class types */
    public static final byte TAG_UNIVERSAL = (byte)0x000;
    public static final byte TAG_APPLICATION = (byte)0x040;
    public static final byte TAG_CONTEXT = (byte)0x080;
    public static final byte TAG_PRIVATE = (byte)0x0c0;

    /** The DER tag of the value; one of the tag_ constants. */
    public byte                 tag;

    protected DerInputBuffer    buffer;

    /**
     * The DER-encoded data of the value, never null
     */
    public final DerInputStream data;

    private int                 length;

    /*
     * The type starts at the first byte of the encoding, and
     * is one of these tag_* values.  That may be all the type
     * data that is needed.
     */

    /*
     * These tags are the &quot;universal&quot; tags ... they mean the same
     * in all contexts.  (Mask with 0x1f -- five bits.)
     */

    /** Tag value indicating an ASN.1 &quot;BOOLEAN&quot; value. */
    public final static byte    tag_Boolean = 0x01;

    /** Tag value indicating an ASN.1 &quot;INTEGER&quot; value. */
    public final static byte    tag_Integer = 0x02;

    /** Tag value indicating an ASN.1 &quot;BIT STRING&quot; value. */
    public final static byte    tag_BitString = 0x03;

    /** Tag value indicating an ASN.1 &quot;OCTET STRING&quot; value. */
    public final static byte    tag_OctetString = 0x04;

    /** Tag value indicating an ASN.1 &quot;NULL&quot; value. */
    public final static byte    tag_Null = 0x05;

    /** Tag value indicating an ASN.1 &quot;OBJECT IDENTIFIER&quot; value. */
    public final static byte    tag_ObjectId = 0x06;

    /** Tag value including an ASN.1 &quot;ENUMERATED&quot; value */
    public final static byte    tag_Enumerated = 0x0A;

    /** Tag value indicating an ASN.1 &quot;UTF8String&quot; value. */
    public final static byte    tag_UTF8String = 0x0C;

    /** Tag value including a &quot;printable&quot; string */
    public final static byte    tag_PrintableString = 0x13;

    /** Tag value including a &quot;teletype&quot; string */
    public final static byte    tag_T61String = 0x14;

    /** Tag value including an ASCII string */
    public final static byte    tag_IA5String = 0x16;

    /** Tag value indicating an ASN.1 &quot;UTCTime&quot; value. */
    public final static byte    tag_UtcTime = 0x17;

    /** Tag value indicating an ASN.1 &quot;GeneralizedTime&quot; value. */
    public final static byte    tag_GeneralizedTime = 0x18;

    /** Tag value indicating an ASN.1 &quot;GenerallString&quot; value. */
    public final static byte    tag_GeneralString = 0x1B;

    /** Tag value indicating an ASN.1 &quot;UniversalString&quot; value. */
    public final static byte    tag_UniversalString = 0x1C;

    /** Tag value indicating an ASN.1 &quot;BMPString&quot; value. */
    public final static byte    tag_BMPString = 0x1E;

    // CONSTRUCTED seq/set

    /**
     * Tag value indicating an ASN.1
     * &quot;SEQUENCE&quot; (zero to N elements, order is significant).
     */
    public final static byte    tag_Sequence = 0x30;

    /**
     * Tag value indicating an ASN.1
     * &quot;SEQUENCE OF&quot; (one to N elements, order is significant).
     */
    public final static byte    tag_SequenceOf = 0x30;

    /**
     * Tag value indicating an ASN.1
     * &quot;SET&quot; (zero to N members, order does not matter).
     */
    public final static byte    tag_Set = 0x31;

    /**
     * Tag value indicating an ASN.1
     * &quot;SET OF&quot; (one to N members, order does not matter).
     */
    public final static byte    tag_SetOf = 0x31;

    /*
     * These values are the high order bits for the other kinds of tags.
     */

    /**
     * Returns true if the tag class is UNIVERSAL.
     */
<span class="nc bnc" id="L167" title="All 2 branches missed.">    public boolean isUniversal()      { return ((tag &amp; 0x0c0) == 0x000); }</span>

    /**
     * Returns true if the tag class is APPLICATION.
     */
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">    public boolean isApplication()    { return ((tag &amp; 0x0c0) == 0x040); }</span>

    /**
     * Returns true iff the CONTEXT SPECIFIC bit is set in the type tag.
     * This is associated with the ASN.1 &quot;DEFINED BY&quot; syntax.
     */
<span class="fc bfc" id="L178" title="All 2 branches covered.">    public boolean isContextSpecific() { return ((tag &amp; 0x0c0) == 0x080); }</span>

    /**
     * Returns true iff the CONTEXT SPECIFIC TAG matches the passed tag.
     */
    public boolean isContextSpecific(byte cntxtTag) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (!isContextSpecific()) {</span>
<span class="fc" id="L185">            return false;</span>
        }
<span class="fc bfc" id="L187" title="All 2 branches covered.">        return ((tag &amp; 0x01f) == cntxtTag);</span>
    }

<span class="nc bnc" id="L190" title="All 2 branches missed.">    boolean isPrivate()        { return ((tag &amp; 0x0c0) == 0x0c0); }</span>

    /** Returns true iff the CONSTRUCTED bit is set in the type tag. */
<span class="fc bfc" id="L193" title="All 2 branches covered.">    public boolean isConstructed()    { return ((tag &amp; 0x020) == 0x020); }</span>

    /**
     * Returns true iff the CONSTRUCTED TAG matches the passed tag.
     */
    public boolean isConstructed(byte constructedTag) {
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (!isConstructed()) {</span>
<span class="nc" id="L200">            return false;</span>
        }
<span class="nc bnc" id="L202" title="All 2 branches missed.">        return ((tag &amp; 0x01f) == constructedTag);</span>
    }

    /**
     * Creates a PrintableString or UTF8string DER value from a string
     */
<span class="fc" id="L208">    public DerValue(String value) throws IOException {</span>
<span class="fc" id="L209">        boolean isPrintableString = true;</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">        for (int i = 0; i &lt; value.length(); i++) {</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (!isPrintableStringChar(value.charAt(i))) {</span>
<span class="nc" id="L212">                isPrintableString = false;</span>
<span class="nc" id="L213">                break;</span>
            }
        }

<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);</span>
<span class="fc" id="L218">    }</span>

    /**
     * Creates a string type DER value from a String object
     * @param stringTag the tag for the DER value to create
     * @param value the String object to use for the DER value
     */
<span class="fc" id="L225">    public DerValue(byte stringTag, String value) throws IOException {</span>
<span class="fc" id="L226">        data = init(stringTag, value);</span>
<span class="fc" id="L227">    }</span>

    /**
     * Creates a DerValue from a tag and some DER-encoded data.
     *
     * @param tag the DER type tag
     * @param data the DER-encoded data
     */
<span class="fc" id="L235">    public DerValue(byte tag, byte[] data) {</span>
<span class="fc" id="L236">        this.tag = tag;</span>
<span class="fc" id="L237">        buffer = new DerInputBuffer(data.clone());</span>
<span class="fc" id="L238">        length = data.length;</span>
<span class="fc" id="L239">        this.data = new DerInputStream(buffer);</span>
<span class="fc" id="L240">        this.data.mark(Integer.MAX_VALUE);</span>
<span class="fc" id="L241">    }</span>

    /*
     * package private
     */
<span class="fc" id="L246">    DerValue(DerInputBuffer in) throws IOException {</span>
        // XXX must also parse BER-encoded constructed
        // values such as sequences, sets...

<span class="fc" id="L250">        tag = (byte)in.read();</span>
<span class="fc" id="L251">        byte lenByte = (byte)in.read();</span>
<span class="fc" id="L252">        length = DerInputStream.getLength((lenByte &amp; 0xff), in);</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        if (length == -1) {  // indefinite length encoding found</span>
<span class="nc" id="L254">            DerInputBuffer inbuf = in.dup();</span>
<span class="nc" id="L255">            int readLen = inbuf.available();</span>
<span class="nc" id="L256">            int offset = 2;     // for tag and length bytes</span>
<span class="nc" id="L257">            byte[] indefData = new byte[readLen + offset];</span>
<span class="nc" id="L258">            indefData[0] = tag;</span>
<span class="nc" id="L259">            indefData[1] = lenByte;</span>
<span class="nc" id="L260">            DataInputStream dis = new DataInputStream(inbuf);</span>
<span class="nc" id="L261">            dis.readFully(indefData, offset, readLen);</span>
<span class="nc" id="L262">            dis.close();</span>
<span class="nc" id="L263">            DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="nc" id="L264">            inbuf = new DerInputBuffer(derIn.convert(indefData));</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (tag != inbuf.read())</span>
<span class="nc" id="L266">                throw new IOException</span>
                        (&quot;Indefinite length encoding not supported&quot;);
<span class="nc" id="L268">            length = DerInputStream.getLength(inbuf);</span>
<span class="nc" id="L269">            buffer = inbuf.dup();</span>
<span class="nc" id="L270">            buffer.truncate(length);</span>
<span class="nc" id="L271">            data = new DerInputStream(buffer);</span>
            // indefinite form is encoded by sending a length field with a
            // length of 0. - i.e. [1000|0000].
            // the object is ended by sending two zero bytes.
<span class="nc" id="L275">            in.skip(length + offset);</span>
<span class="nc" id="L276">        } else {</span>

<span class="fc" id="L278">            buffer = in.dup();</span>
<span class="fc" id="L279">            buffer.truncate(length);</span>
<span class="fc" id="L280">            data = new DerInputStream(buffer);</span>

<span class="fc" id="L282">            in.skip(length);</span>
        }
<span class="fc" id="L284">    }</span>

    /**
     * Get an ASN.1/DER encoded datum from a buffer.  The
     * entire buffer must hold exactly one datum, including
     * its tag and length.
     *
     * @param buf buffer holding a single DER-encoded datum.
     */
<span class="fc" id="L293">    public DerValue(byte[] buf) throws IOException {</span>
<span class="fc" id="L294">        data = init(true, new ByteArrayInputStream(buf));</span>
<span class="fc" id="L295">    }</span>

    /**
     * Get an ASN.1/DER encoded datum from part of a buffer.
     * That part of the buffer must hold exactly one datum, including
     * its tag and length.
     *
     * @param buf the buffer
     * @param offset start point of the single DER-encoded dataum
     * @param length how many bytes are in the encoded datum
     */
<span class="nc" id="L306">    public DerValue(byte[] buf, int offset, int len) throws IOException {</span>
<span class="nc" id="L307">        data = init(true, new ByteArrayInputStream(buf, offset, len));</span>
<span class="nc" id="L308">    }</span>

    /**
     * Get an ASN1/DER encoded datum from an input stream.  The
     * stream may have additional data following the encoded datum.
     * In case of indefinite length encoded datum, the input stream
     * must hold only one datum.
     *
     * @param in the input stream holding a single DER datum,
     *  which may be followed by additional data
     */
<span class="fc" id="L319">    public DerValue(InputStream in) throws IOException {</span>
<span class="fc" id="L320">        data = init(false, in);</span>
<span class="fc" id="L321">    }</span>

    private DerInputStream init(byte stringTag, String value) throws IOException {
<span class="fc" id="L324">        String enc = null;</span>

<span class="fc" id="L326">        tag = stringTag;</span>

<span class="pc bpc" id="L328" title="3 of 5 branches missed.">        switch (stringTag) {</span>
        case tag_PrintableString:
        case tag_IA5String:
        case tag_GeneralString:
<span class="fc" id="L332">            enc = &quot;ASCII&quot;;</span>
<span class="fc" id="L333">            break;</span>
        case tag_T61String:
<span class="nc" id="L335">            enc = &quot;ISO-8859-1&quot;;</span>
<span class="nc" id="L336">            break;</span>
        case tag_BMPString:
<span class="nc" id="L338">            enc = &quot;UnicodeBigUnmarked&quot;;</span>
<span class="nc" id="L339">            break;</span>
        case tag_UTF8String:
<span class="fc" id="L341">            enc = &quot;UTF8&quot;;</span>
<span class="fc" id="L342">            break;</span>
            // TBD: Need encoder for UniversalString before it can
            // be handled.
        default:
<span class="nc" id="L346">            throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);</span>
        }

<span class="fc" id="L349">        byte[] buf = value.getBytes(enc);</span>
<span class="fc" id="L350">        length = buf.length;</span>
<span class="fc" id="L351">        buffer = new DerInputBuffer(buf);</span>
<span class="fc" id="L352">        DerInputStream result = new DerInputStream(buffer);</span>
<span class="fc" id="L353">        result.mark(Integer.MAX_VALUE);</span>
<span class="fc" id="L354">        return result;</span>
    }

    /*
     * helper routine
     */
    private DerInputStream init(boolean fullyBuffered, InputStream in)
            throws IOException {

<span class="fc" id="L363">        tag = (byte)in.read();</span>
<span class="fc" id="L364">        byte lenByte = (byte)in.read();</span>
<span class="fc" id="L365">        length = DerInputStream.getLength((lenByte &amp; 0xff), in);</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (length == -1) { // indefinite length encoding found</span>
<span class="nc" id="L367">            int readLen = in.available();</span>
<span class="nc" id="L368">            int offset = 2;     // for tag and length bytes</span>
<span class="nc" id="L369">            byte[] indefData = new byte[readLen + offset];</span>
<span class="nc" id="L370">            indefData[0] = tag;</span>
<span class="nc" id="L371">            indefData[1] = lenByte;</span>
<span class="nc" id="L372">            DataInputStream dis = new DataInputStream(in);</span>
<span class="nc" id="L373">            dis.readFully(indefData, offset, readLen);</span>
<span class="nc" id="L374">            dis.close();</span>
<span class="nc" id="L375">            DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="nc" id="L376">            in = new ByteArrayInputStream(derIn.convert(indefData));</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (tag != in.read())</span>
<span class="nc" id="L378">                throw new IOException</span>
                        (&quot;Indefinite length encoding not supported&quot;);
<span class="nc" id="L380">            length = DerInputStream.getLength(in);</span>
        }

<span class="pc bpc" id="L383" title="1 of 4 branches missed.">        if (fullyBuffered &amp;&amp; in.available() != length)</span>
<span class="nc" id="L384">            throw new IOException(&quot;extra data given to DerValue constructor&quot;);</span>

<span class="fc" id="L386">        byte[] bytes = IOUtils.readFully(in, length, true);</span>

<span class="fc" id="L388">        buffer = new DerInputBuffer(bytes);</span>
<span class="fc" id="L389">        return new DerInputStream(buffer);</span>
    }

    /**
     * Encode an ASN1/DER encoded datum onto a DER output stream.
     */
    public void encode(DerOutputStream out)
    throws IOException {
<span class="fc" id="L397">        out.write(tag);</span>
<span class="fc" id="L398">        out.putLength(length);</span>
        // XXX yeech, excess copies ... DerInputBuffer.write(OutStream)
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        if (length &gt; 0) {</span>
<span class="fc" id="L401">            byte[] value = new byte[length];</span>
            // always synchronized on data
<span class="fc" id="L403">            synchronized (data) {</span>
<span class="fc" id="L404">                buffer.reset();</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">                if (buffer.read(value) != length) {</span>
<span class="nc" id="L406">                    throw new IOException(&quot;short DER value read (encode)&quot;);</span>
                }
<span class="fc" id="L408">                out.write(value);</span>
<span class="pc" id="L409">            }</span>
        }
<span class="fc" id="L411">    }</span>

    public final DerInputStream getData() {
<span class="fc" id="L414">        return data;</span>
    }

    public final byte getTag() {
<span class="fc" id="L418">        return tag;</span>
    }

    /**
     * Returns an ASN.1 BOOLEAN
     *
     * @return the boolean held in this DER value
     */
    public boolean getBoolean() throws IOException {
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">        if (tag != tag_Boolean) {</span>
<span class="nc" id="L428">            throw new IOException(&quot;DerValue.getBoolean, not a BOOLEAN &quot; + tag);</span>
        }
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">        if (length != 1) {</span>
<span class="nc" id="L431">            throw new IOException(&quot;DerValue.getBoolean, invalid length &quot;</span>
                                        + length);
        }
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        if (buffer.read() != 0) {</span>
<span class="fc" id="L435">            return true;</span>
        }
<span class="nc" id="L437">        return false;</span>
    }

    /**
     * Returns an ASN.1 OBJECT IDENTIFIER.
     *
     * @return the OID held in this DER value
     */
    public ObjectIdentifier getOID() throws IOException {
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if (tag != tag_ObjectId)</span>
<span class="nc" id="L447">            throw new IOException(&quot;DerValue.getOID, not an OID &quot; + tag);</span>
<span class="fc" id="L448">        return new ObjectIdentifier(buffer);</span>
    }

    private byte[] append(byte[] a, byte[] b) {
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L453">            return b;</span>

<span class="nc" id="L455">        byte[] ret = new byte[a.length + b.length];</span>
<span class="nc" id="L456">        System.arraycopy(a, 0, ret, 0, a.length);</span>
<span class="nc" id="L457">        System.arraycopy(b, 0, ret, a.length, b.length);</span>

<span class="nc" id="L459">        return ret;</span>
    }

    /**
     * Returns an ASN.1 OCTET STRING
     *
     * @return the octet string held in this DER value
     */
    public byte[] getOctetString() throws IOException {
        byte[] bytes;

<span class="pc bpc" id="L470" title="3 of 4 branches missed.">        if (tag != tag_OctetString &amp;&amp; !isConstructed(tag_OctetString)) {</span>
<span class="nc" id="L471">            throw new IOException(</span>
                &quot;DerValue.getOctetString, not an Octet String: &quot; + tag);
        }
<span class="fc" id="L474">        bytes = new byte[length];</span>
        // Note: do not tempt to call buffer.read(bytes) at all. There's a
        // known bug that it returns -1 instead of 0.
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">        if (length == 0) {</span>
<span class="nc" id="L478">            return bytes;</span>
        }
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        if (buffer.read(bytes) != length)</span>
<span class="nc" id="L481">            throw new IOException(&quot;short read on DerValue buffer&quot;);</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">        if (isConstructed()) {</span>
<span class="nc" id="L483">            DerInputStream in = new DerInputStream(bytes);</span>
<span class="nc" id="L484">            bytes = null;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">            while (in.available() != 0) {</span>
<span class="nc" id="L486">                bytes = append(bytes, in.getOctetString());</span>
            }
        }
<span class="fc" id="L489">        return bytes;</span>
    }

    /**
     * Returns an ASN.1 INTEGER value as an integer.
     *
     * @return the integer held in this DER value.
     */
    public int getInteger() throws IOException {
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if (tag != tag_Integer) {</span>
<span class="nc" id="L499">            throw new IOException(&quot;DerValue.getInteger, not an int &quot; + tag);</span>
        }
<span class="fc" id="L501">        return buffer.getInteger(data.available());</span>
    }

    /**
     * Returns an ASN.1 INTEGER value as a BigInteger.
     *
     * @return the integer held in this DER value as a BigInteger.
     */
    public BigInteger getBigInteger() throws IOException {
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">        if (tag != tag_Integer)</span>
<span class="nc" id="L511">            throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);</span>
<span class="fc" id="L512">        return buffer.getBigInteger(data.available(), false);</span>
    }

    /**
     * Returns an ASN.1 INTEGER value as a positive BigInteger.
     * This is just to deal with implementations that incorrectly encode
     * some values as negative.
     *
     * @return the integer held in this DER value as a BigInteger.
     */
    public BigInteger getPositiveBigInteger() throws IOException {
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">        if (tag != tag_Integer)</span>
<span class="nc" id="L524">            throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);</span>
<span class="fc" id="L525">        return buffer.getBigInteger(data.available(), true);</span>
    }

    /**
     * Returns an ASN.1 ENUMERATED value.
     *
     * @return the integer held in this DER value.
     */
    public int getEnumerated() throws IOException {
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        if (tag != tag_Enumerated) {</span>
<span class="nc" id="L535">            throw new IOException(&quot;DerValue.getEnumerated, incorrect tag: &quot;</span>
                                  + tag);
        }
<span class="fc" id="L538">        return buffer.getInteger(data.available());</span>
    }

    /**
     * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
     *
     * @return the bit string held in this value
     */
    public byte[] getBitString() throws IOException {
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        if (tag != tag_BitString)</span>
<span class="nc" id="L548">            throw new IOException(</span>
                &quot;DerValue.getBitString, not a bit string &quot; + tag);

<span class="fc" id="L551">        return buffer.getBitString();</span>
    }

    /**
     * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
     *
     * @return a BitArray representing the bit string held in this value
     */
    public BitArray getUnalignedBitString() throws IOException {
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">        if (tag != tag_BitString)</span>
<span class="nc" id="L561">            throw new IOException(</span>
                &quot;DerValue.getBitString, not a bit string &quot; + tag);

<span class="fc" id="L564">        return buffer.getUnalignedBitString();</span>
    }

    /**
     * Returns the name component as a Java string, regardless of its
     * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
     */
    // TBD: Need encoder for UniversalString before it can be handled.
    public String getAsString() throws IOException {
<span class="fc bfc" id="L573" title="All 2 branches covered.">        if (tag == tag_UTF8String)</span>
<span class="fc" id="L574">            return getUTF8String();</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">        else if (tag == tag_PrintableString)</span>
<span class="fc" id="L576">            return getPrintableString();</span>
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">        else if (tag == tag_T61String)</span>
<span class="nc" id="L578">            return getT61String();</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        else if (tag == tag_IA5String)</span>
<span class="fc" id="L580">            return getIA5String();</span>
        /*
          else if (tag == tag_UniversalString)
          return getUniversalString();
        */
<span class="nc bnc" id="L585" title="All 2 branches missed.">        else if (tag == tag_BMPString)</span>
<span class="nc" id="L586">            return getBMPString();</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        else if (tag == tag_GeneralString)</span>
<span class="nc" id="L588">            return getGeneralString();</span>
        else
<span class="nc" id="L590">            return null;</span>
    }

    /**
     * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
     * based on the parameter.  The bit string must be byte-aligned.
     *
     * @params tagImplicit if true, the tag is assumed implicit.
     * @return the bit string held in this value
     */
    public byte[] getBitString(boolean tagImplicit) throws IOException {
<span class="nc bnc" id="L601" title="All 2 branches missed.">        if (!tagImplicit) {</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">            if (tag != tag_BitString)</span>
<span class="nc" id="L603">                throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;</span>
                                       + tag);
            }
<span class="nc" id="L606">        return buffer.getBitString();</span>
    }

    /**
     * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
     * based on the parameter.  The bit string need not be byte-aligned.
     *
     * @params tagImplicit if true, the tag is assumed implicit.
     * @return the bit string held in this value
     */
    public BitArray getUnalignedBitString(boolean tagImplicit)
    throws IOException {
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">        if (!tagImplicit) {</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">            if (tag != tag_BitString)</span>
<span class="nc" id="L620">                throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;</span>
                                       + tag);
            }
<span class="fc" id="L623">        return buffer.getUnalignedBitString();</span>
    }

    /**
     * Helper routine to return all the bytes contained in the
     * DerInputStream associated with this object.
     */
    public byte[] getDataBytes() throws IOException {
<span class="fc" id="L631">        byte[] retVal = new byte[length];</span>
<span class="fc" id="L632">        synchronized (data) {</span>
<span class="fc" id="L633">            data.reset();</span>
<span class="fc" id="L634">            data.getBytes(retVal);</span>
<span class="pc" id="L635">        }</span>
<span class="fc" id="L636">        return retVal;</span>
    }

    /**
     * Returns an ASN.1 STRING value
     *
     * @return the printable string held in this value
     */
    public String getPrintableString()
    throws IOException {
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">        if (tag != tag_PrintableString)</span>
<span class="nc" id="L647">            throw new IOException(</span>
                &quot;DerValue.getPrintableString, not a string &quot; + tag);

<span class="fc" id="L650">        return new String(getDataBytes(), &quot;ASCII&quot;);</span>
    }

    /**
     * Returns an ASN.1 T61 (Teletype) STRING value
     *
     * @return the teletype string held in this value
     */
    public String getT61String() throws IOException {
<span class="nc bnc" id="L659" title="All 2 branches missed.">        if (tag != tag_T61String)</span>
<span class="nc" id="L660">            throw new IOException(</span>
                &quot;DerValue.getT61String, not T61 &quot; + tag);

<span class="nc" id="L663">        return new String(getDataBytes(), &quot;ISO-8859-1&quot;);</span>
    }

    /**
     * Returns an ASN.1 IA5 (ASCII) STRING value
     *
     * @return the ASCII string held in this value
     */
    public String getIA5String() throws IOException {
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">        if (tag != tag_IA5String)</span>
<span class="nc" id="L673">            throw new IOException(</span>
                &quot;DerValue.getIA5String, not IA5 &quot; + tag);

<span class="fc" id="L676">        return new String(getDataBytes(), &quot;ASCII&quot;);</span>
    }

    /**
     * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
     *
     * @return a string corresponding to the encoded BMPString held in
     * this value
     */
    public String getBMPString() throws IOException {
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        if (tag != tag_BMPString)</span>
<span class="nc" id="L687">            throw new IOException(</span>
                &quot;DerValue.getBMPString, not BMP &quot; + tag);

        // BMPString is the same as Unicode in big endian, unmarked
        // format.
<span class="fc" id="L692">        return new String(getDataBytes(), &quot;UnicodeBigUnmarked&quot;);</span>
    }

    /**
     * Returns the ASN.1 UTF-8 STRING value as a Java String.
     *
     * @return a string corresponding to the encoded UTF8String held in
     * this value
     */
    public String getUTF8String() throws IOException {
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">        if (tag != tag_UTF8String)</span>
<span class="nc" id="L703">            throw new IOException(</span>
                &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);

<span class="fc" id="L706">        return new String(getDataBytes(), &quot;UTF8&quot;);</span>
    }

    /**
     * Returns the ASN.1 GENERAL STRING value as a Java String.
     *
     * @return a string corresponding to the encoded GeneralString held in
     * this value
     */
    public String getGeneralString() throws IOException {
<span class="nc bnc" id="L716" title="All 2 branches missed.">        if (tag != tag_GeneralString)</span>
<span class="nc" id="L717">            throw new IOException(</span>
                &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);

<span class="nc" id="L720">        return new String(getDataBytes(), &quot;ASCII&quot;);</span>
    }

    /**
     * Returns a Date if the DerValue is UtcTime.
     *
     * @return the Date held in this DER value
     */
    public Date getUTCTime() throws IOException {
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">        if (tag != tag_UtcTime) {</span>
<span class="nc" id="L730">            throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);</span>
        }
<span class="fc" id="L732">        return buffer.getUTCTime(data.available());</span>
    }

    /**
     * Returns a Date if the DerValue is GeneralizedTime.
     *
     * @return the Date held in this DER value
     */
    public Date getGeneralizedTime() throws IOException {
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">        if (tag != tag_GeneralizedTime) {</span>
<span class="nc" id="L742">            throw new IOException(</span>
                &quot;DerValue.getGeneralizedTime, not a GeneralizedTime: &quot; + tag);
        }
<span class="fc" id="L745">        return buffer.getGeneralizedTime(data.available());</span>
    }

    /**
     * Returns true iff the other object is a DER value which
     * is bitwise equal to this one.
     *
     * @param other the object being compared with this one
     */
    public boolean equals(Object other) {
<span class="nc bnc" id="L755" title="All 2 branches missed.">        if (other instanceof DerValue)</span>
<span class="nc" id="L756">            return equals((DerValue)other);</span>
        else
<span class="nc" id="L758">            return false;</span>
    }

    /**
     * Bitwise equality comparison.  DER encoded values have a single
     * encoding, so that bitwise equality of the encoded values is an
     * efficient way to establish equivalence of the unencoded values.
     *
     * @param other the object being compared with this one
     */
    public boolean equals(DerValue other) {
<span class="nc bnc" id="L769" title="All 2 branches missed.">        if (this == other) {</span>
<span class="nc" id="L770">            return true;</span>
        }
<span class="nc bnc" id="L772" title="All 2 branches missed.">        if (tag != other.tag) {</span>
<span class="nc" id="L773">            return false;</span>
        }
<span class="nc bnc" id="L775" title="All 2 branches missed.">        if (data == other.data) {</span>
<span class="nc" id="L776">            return true;</span>
        }

        // make sure the order of lock is always consistent to avoid a deadlock
<span class="nc" id="L780">        return (System.identityHashCode(this.data)</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">                &gt; System.identityHashCode(other.data)) ?</span>
<span class="nc" id="L782">                doEquals(this, other):</span>
<span class="nc" id="L783">                doEquals(other, this);</span>
    }

    /**
     * Helper for public method equals()
     */
    private static boolean doEquals(DerValue d1, DerValue d2) {
<span class="nc" id="L790">        synchronized (d1.data) {</span>
<span class="nc" id="L791">            synchronized (d2.data) {</span>
<span class="nc" id="L792">                d1.data.reset();</span>
<span class="nc" id="L793">                d2.data.reset();</span>
<span class="nc" id="L794">                return d1.buffer.equals(d2.buffer);</span>
<span class="nc" id="L795">            }</span>
<span class="nc" id="L796">        }</span>
    }

    /**
     * Returns a printable representation of the value.
     *
     * @return printable representation of the value
     */
    public String toString() {
        try {

<span class="nc" id="L807">            String str = getAsString();</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">            if (str != null)</span>
<span class="nc" id="L809">                return &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">            if (tag == tag_Null)</span>
<span class="nc" id="L811">                return &quot;[DerValue, null]&quot;;</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">            if (tag == tag_ObjectId)</span>
<span class="nc" id="L813">                return &quot;OID.&quot; + getOID();</span>

            // integers
            else
<span class="nc" id="L817">                return &quot;[DerValue, tag = &quot; + tag</span>
                        + &quot;, length = &quot; + length + &quot;]&quot;;
<span class="nc" id="L819">        } catch (IOException e) {</span>
<span class="nc" id="L820">            throw new IllegalArgumentException(&quot;misformatted DER value&quot;);</span>
        }
    }

    /**
     * Returns a DER-encoded value, such that if it's passed to the
     * DerValue constructor, a value equivalent to &quot;this&quot; is returned.
     *
     * @return DER-encoded value, including tag and length.
     */
    public byte[] toByteArray() throws IOException {
<span class="fc" id="L831">        DerOutputStream out = new DerOutputStream();</span>

<span class="fc" id="L833">        encode(out);</span>
<span class="fc" id="L834">        data.reset();</span>
<span class="fc" id="L835">        return out.toByteArray();</span>
    }

    /**
     * For &quot;set&quot; and &quot;sequence&quot; types, this function may be used
     * to return a DER stream of the members of the set or sequence.
     * This operation is not supported for primitive types such as
     * integers or bit strings.
     */
    public DerInputStream toDerInputStream() throws IOException {
<span class="pc bpc" id="L845" title="3 of 4 branches missed.">        if (tag == tag_Sequence || tag == tag_Set)</span>
<span class="fc" id="L846">            return new DerInputStream(buffer);</span>
<span class="nc" id="L847">        throw new IOException(&quot;toDerInputStream rejects tag type &quot; + tag);</span>
    }

    /**
     * Get the length of the encoded value.
     */
    public int length() {
<span class="fc" id="L854">        return length;</span>
    }

    /**
     * Determine if a character is one of the permissible characters for
     * PrintableString:
     * A-Z, a-z, 0-9, space, apostrophe (39), left and right parentheses,
     * plus sign, comma, hyphen, period, slash, colon, equals sign,
     * and question mark.
     *
     * Characters that are *not* allowed in PrintableString include
     * exclamation point, quotation mark, number sign, dollar sign,
     * percent sign, ampersand, asterisk, semicolon, less than sign,
     * greater than sign, at sign, left and right square brackets,
     * backslash, circumflex (94), underscore, back quote (96),
     * left and right curly brackets, vertical line, tilde,
     * and the control codes (0-31 and 127).
     *
     * This list is based on X.680 (the ASN.1 spec).
     */
    public static boolean isPrintableStringChar(char ch) {
<span class="fc bfc" id="L875" title="All 12 branches covered.">        if ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') ||</span>
            (ch &gt;= '0' &amp;&amp; ch &lt;= '9')) {
<span class="fc" id="L877">            return true;</span>
        } else {
<span class="fc bfc" id="L879" title="All 2 branches covered.">            switch (ch) {</span>
                case ' ':       /* space */
                case '\'':      /* apostrophe */
                case '(':       /* left paren */
                case ')':       /* right paren */
                case '+':       /* plus */
                case ',':       /* comma */
                case '-':       /* hyphen */
                case '.':       /* period */
                case '/':       /* slash */
                case ':':       /* colon */
                case '=':       /* equals */
                case '?':       /* question mark */
<span class="fc" id="L892">                    return true;</span>
                default:
<span class="fc" id="L894">                    return false;</span>
            }
        }
    }

    /**
     * Create the tag of the attribute.
     *
     * @params class the tag class type, one of UNIVERSAL, CONTEXT,
     *               APPLICATION or PRIVATE
     * @params form if true, the value is constructed, otherwise it
     * is primitive.
     * @params val the tag value
     */
    public static byte createTag(byte tagClass, boolean form, byte val) {
<span class="fc" id="L909">        byte tag = (byte)(tagClass | val);</span>
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">        if (form) {</span>
<span class="fc" id="L911">            tag |= (byte)0x20;</span>
        }
<span class="fc" id="L913">        return (tag);</span>
    }

    /**
     * Set the tag of the attribute. Commonly used to reset the
     * tag value used for IMPLICIT encodings.
     *
     * @params tag the tag value
     */
    public void resetTag(byte tag) {
<span class="fc" id="L923">        this.tag = tag;</span>
<span class="fc" id="L924">    }</span>

    /**
     * Returns a hashcode for this DerValue.
     *
     * @return a hashcode for this DerValue.
     */
    public int hashCode() {
<span class="nc" id="L932">        return toString().hashCode();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>