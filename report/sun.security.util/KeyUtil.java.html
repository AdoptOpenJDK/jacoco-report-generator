<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KeyUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.util</a> &gt; <span class="el_source">KeyUtil.java</span></div><h1>KeyUtil.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.util;

import java.security.Key;
import java.security.PrivilegedAction;
import java.security.AccessController;
import java.security.InvalidKeyException;
import java.security.interfaces.ECKey;
import java.security.interfaces.RSAKey;
import java.security.interfaces.DSAKey;
import java.security.spec.KeySpec;
import javax.crypto.SecretKey;
import javax.crypto.interfaces.DHKey;
import javax.crypto.interfaces.DHPublicKey;
import javax.crypto.spec.DHParameterSpec;
import javax.crypto.spec.DHPublicKeySpec;
import java.math.BigInteger;

/**
 * A utility class to get key length, valiate keys, etc.
 */
<span class="nc" id="L46">public final class KeyUtil {</span>

    /**
     * Returns the key size of the given key object in bits.
     *
     * @param key the key object, cannot be null
     * @return the key size of the given key object in bits, or -1 if the
     *       key size is not accessible
     */
    public static final int getKeySize(Key key) {
<span class="fc" id="L56">        int size = -1;</span>

<span class="fc bfc" id="L58" title="All 2 branches covered.">        if (key instanceof Length) {</span>
            try {
<span class="fc" id="L60">                Length ruler = (Length)key;</span>
<span class="fc" id="L61">                size = ruler.length();</span>
<span class="nc" id="L62">            } catch (UnsupportedOperationException usoe) {</span>
                // ignore the exception
<span class="fc" id="L64">            }</span>

<span class="pc bpc" id="L66" title="1 of 2 branches missed.">            if (size &gt;= 0) {</span>
<span class="fc" id="L67">                return size;</span>
            }
        }

        // try to parse the length from key specification
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (key instanceof SecretKey) {</span>
<span class="nc" id="L73">            SecretKey sk = (SecretKey)key;</span>
<span class="nc" id="L74">            String format = sk.getFormat();</span>
<span class="nc bnc" id="L75" title="All 4 branches missed.">            if (&quot;RAW&quot;.equals(format) &amp;&amp; sk.getEncoded() != null) {</span>
<span class="nc" id="L76">                size = (sk.getEncoded().length * 8);</span>
            }   // Otherwise, it may be a unextractable key of PKCS#11, or
                // a key we are not able to handle.
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        } else if (key instanceof RSAKey) {</span>
<span class="fc" id="L80">            RSAKey pubk = (RSAKey)key;</span>
<span class="fc" id="L81">            size = pubk.getModulus().bitLength();</span>
<span class="pc bnc" id="L82" title="All 2 branches missed.">        } else if (key instanceof ECKey) {</span>
<span class="nc" id="L83">            ECKey pubk = (ECKey)key;</span>
<span class="nc" id="L84">            size = pubk.getParams().getOrder().bitLength();</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">        } else if (key instanceof DSAKey) {</span>
<span class="nc" id="L86">            DSAKey pubk = (DSAKey)key;</span>
<span class="nc" id="L87">            size = pubk.getParams().getP().bitLength();</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">        } else if (key instanceof DHKey) {</span>
<span class="nc" id="L89">            DHKey pubk = (DHKey)key;</span>
<span class="nc" id="L90">            size = pubk.getParams().getP().bitLength();</span>
        }   // Otherwise, it may be a unextractable key of PKCS#11, or
            // a key we are not able to handle.

<span class="fc" id="L94">        return size;</span>
    }

    /**
     * Returns whether the key is valid or not.
     * &lt;P&gt;
     * Note that this method is only apply to DHPublicKey at present.
     *
     * @param  publicKey
     *         the key object, cannot be null
     *
     * @throws NullPointerException if {@code publicKey} is null
     * @throws InvalidKeyException if {@code publicKey} is invalid
     */
    public static final void validate(Key key)
            throws InvalidKeyException {
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L111">            throw new NullPointerException(</span>
                &quot;The key to be validated cannot be null&quot;);
        }

<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (key instanceof DHPublicKey) {</span>
<span class="fc" id="L116">            validateDHPublicKey((DHPublicKey)key);</span>
        }
<span class="fc" id="L118">    }</span>


    /**
     * Returns whether the key spec is valid or not.
     * &lt;P&gt;
     * Note that this method is only apply to DHPublicKeySpec at present.
     *
     * @param  keySpec
     *         the key spec object, cannot be null
     *
     * @throws NullPointerException if {@code keySpec} is null
     * @throws InvalidKeyException if {@code keySpec} is invalid
     */
    public static final void validate(KeySpec keySpec)
            throws InvalidKeyException {
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (keySpec == null) {</span>
<span class="nc" id="L135">            throw new NullPointerException(</span>
                &quot;The key spec to be validated cannot be null&quot;);
        }

<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (keySpec instanceof DHPublicKeySpec) {</span>
<span class="fc" id="L140">            validateDHPublicKey((DHPublicKeySpec)keySpec);</span>
        }
<span class="fc" id="L142">    }</span>

    /**
     * Returns whether the specified provider is Oracle provider or not.
     * &lt;P&gt;
     * Note that this method is only apply to SunJCE and SunPKCS11 at present.
     *
     * @param  providerName
     *         the provider name
     * @return true if, and only if, the provider of the specified
     *         {@code providerName} is Oracle provider
     */
    public static final boolean isOracleJCEProvider(String providerName) {
<span class="pc bpc" id="L155" title="1 of 4 branches missed.">        return providerName != null &amp;&amp; (providerName.equals(&quot;SunJCE&quot;) ||</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">                                        providerName.startsWith(&quot;SunPKCS11&quot;));</span>
    }

    /**
     * Returns whether the Diffie-Hellman public key is valid or not.
     *
     * Per RFC 2631 and NIST SP800-56A, the following algorithm is used to
     * validate Diffie-Hellman public keys:
     * 1. Verify that y lies within the interval [2,p-1]. If it does not,
     *    the key is invalid.
     * 2. Compute y^q mod p. If the result == 1, the key is valid.
     *    Otherwise the key is invalid.
     */
    private static void validateDHPublicKey(DHPublicKey publicKey)
            throws InvalidKeyException {
<span class="fc" id="L171">        DHParameterSpec paramSpec = publicKey.getParams();</span>

<span class="fc" id="L173">        BigInteger p = paramSpec.getP();</span>
<span class="fc" id="L174">        BigInteger g = paramSpec.getG();</span>
<span class="fc" id="L175">        BigInteger y = publicKey.getY();</span>

<span class="fc" id="L177">        validateDHPublicKey(p, g, y);</span>
<span class="fc" id="L178">    }</span>

    private static void validateDHPublicKey(DHPublicKeySpec publicKeySpec)
            throws InvalidKeyException {
<span class="fc" id="L182">        validateDHPublicKey(publicKeySpec.getP(),</span>
<span class="fc" id="L183">            publicKeySpec.getG(), publicKeySpec.getY());</span>
<span class="fc" id="L184">    }</span>

    private static void validateDHPublicKey(BigInteger p,
            BigInteger g, BigInteger y) throws InvalidKeyException {

        // For better interoperability, the interval is limited to [2, p-2].
<span class="fc" id="L190">        BigInteger leftOpen = BigInteger.ONE;</span>
<span class="fc" id="L191">        BigInteger rightOpen = p.subtract(BigInteger.ONE);</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (y.compareTo(leftOpen) &lt;= 0) {</span>
<span class="nc" id="L193">            throw new InvalidKeyException(</span>
                    &quot;Diffie-Hellman public key is too small&quot;);
        }
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (y.compareTo(rightOpen) &gt;= 0) {</span>
<span class="nc" id="L197">            throw new InvalidKeyException(</span>
                    &quot;Diffie-Hellman public key is too large&quot;);
        }

        // Don't bother to check against the y^q mod p if safe primes are used.
<span class="fc" id="L202">    }</span>

    /**
     * Trim leading (most significant) zeroes from the result.
     *
     * @throws NullPointerException if {@code b} is null
     */
    public static byte[] trimZeroes(byte[] b) {
<span class="fc" id="L210">        int i = 0;</span>
<span class="pc bpc" id="L211" title="1 of 4 branches missed.">        while ((i &lt; b.length - 1) &amp;&amp; (b[i] == 0)) {</span>
<span class="fc" id="L212">            i++;</span>
        }
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (i == 0) {</span>
<span class="fc" id="L215">            return b;</span>
        }
<span class="fc" id="L217">        byte[] t = new byte[b.length - i];</span>
<span class="fc" id="L218">        System.arraycopy(b, i, t, 0, t.length);</span>
<span class="fc" id="L219">        return t;</span>
    }

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>