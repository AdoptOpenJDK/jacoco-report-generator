<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>HostnameChecker.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.util</a> &gt; <span class="el_source">HostnameChecker.java</span></div><h1>HostnameChecker.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.util;

import java.io.IOException;
import java.util.*;

import java.security.Principal;
import java.security.cert.*;

import javax.security.auth.x500.X500Principal;

import sun.security.ssl.Krb5Helper;
import sun.security.x509.X500Name;

import sun.net.util.IPAddressUtil;

/**
 * Class to check hostnames against the names specified in a certificate as
 * required for TLS and LDAP.
 *
 */
public class HostnameChecker {

    // Constant for a HostnameChecker for TLS
    public final static byte TYPE_TLS = 1;
<span class="fc" id="L50">    private final static HostnameChecker INSTANCE_TLS =</span>
                                        new HostnameChecker(TYPE_TLS);

    // Constant for a HostnameChecker for LDAP
    public final static byte TYPE_LDAP = 2;
<span class="fc" id="L55">    private final static HostnameChecker INSTANCE_LDAP =</span>
                                        new HostnameChecker(TYPE_LDAP);

    // constants for subject alt names of type DNS and IP
    private final static int ALTNAME_DNS = 2;
    private final static int ALTNAME_IP  = 7;

    // the algorithm to follow to perform the check. Currently unused.
    private final byte checkType;

<span class="fc" id="L65">    private HostnameChecker(byte checkType) {</span>
<span class="fc" id="L66">        this.checkType = checkType;</span>
<span class="fc" id="L67">    }</span>

    /**
     * Get a HostnameChecker instance. checkType should be one of the
     * TYPE_* constants defined in this class.
     */
    public static HostnameChecker getInstance(byte checkType) {
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        if (checkType == TYPE_TLS) {</span>
<span class="fc" id="L75">            return INSTANCE_TLS;</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">        } else if (checkType == TYPE_LDAP) {</span>
<span class="nc" id="L77">            return INSTANCE_LDAP;</span>
        }
<span class="nc" id="L79">        throw new IllegalArgumentException(&quot;Unknown check type: &quot; + checkType);</span>
    }

    /**
     * Perform the check.
     *
     * @exception CertificateException if the name does not match any of
     * the names specified in the certificate
     */
    public void match(String expectedName, X509Certificate cert)
            throws CertificateException {
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if (isIpAddress(expectedName)) {</span>
<span class="fc" id="L91">           matchIP(expectedName, cert);</span>
        } else {
<span class="fc" id="L93">           matchDNS(expectedName, cert);</span>
        }
<span class="fc" id="L95">    }</span>

    /**
     * Perform the check for Kerberos.
     */
    public static boolean match(String expectedName, Principal principal) {
<span class="nc" id="L101">        String hostName = getServerName(principal);</span>
<span class="nc" id="L102">        return (expectedName.equalsIgnoreCase(hostName));</span>
    }

    /**
     * Return the Server name from Kerberos principal.
     */
    public static String getServerName(Principal principal) {
<span class="nc" id="L109">        return Krb5Helper.getPrincipalHostName(principal);</span>
    }

    /**
     * Test whether the given hostname looks like a literal IPv4 or IPv6
     * address. The hostname does not need to be a fully qualified name.
     *
     * This is not a strict check that performs full input validation.
     * That means if the method returns true, name need not be a correct
     * IP address, rather that it does not represent a valid DNS hostname.
     * Likewise for IP addresses when it returns false.
     */
    private static boolean isIpAddress(String name) {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (IPAddressUtil.isIPv4LiteralAddress(name) ||</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">            IPAddressUtil.isIPv6LiteralAddress(name)) {</span>
<span class="fc" id="L124">            return true;</span>
        } else {
<span class="fc" id="L126">            return false;</span>
        }
    }

    /**
     * Check if the certificate allows use of the given IP address.
     *
     * From RFC2818:
     * In some cases, the URI is specified as an IP address rather than a
     * hostname. In this case, the iPAddress subjectAltName must be present
     * in the certificate and must exactly match the IP in the URI.
     */
    private static void matchIP(String expectedIP, X509Certificate cert)
            throws CertificateException {
<span class="fc" id="L140">        Collection&lt;List&lt;?&gt;&gt; subjAltNames = cert.getSubjectAlternativeNames();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (subjAltNames == null) {</span>
<span class="fc" id="L142">            throw new CertificateException</span>
                                (&quot;No subject alternative names present&quot;);
        }
<span class="fc bfc" id="L145" title="All 2 branches covered.">        for (List&lt;?&gt; next : subjAltNames) {</span>
            // For IP address, it needs to be exact match
<span class="fc bfc" id="L147" title="All 2 branches covered.">            if (((Integer)next.get(0)).intValue() == ALTNAME_IP) {</span>
<span class="fc" id="L148">                String ipAddress = (String)next.get(1);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">                if (expectedIP.equalsIgnoreCase(ipAddress)) {</span>
<span class="fc" id="L150">                    return;</span>
                }
            }
<span class="fc" id="L153">        }</span>
<span class="fc" id="L154">        throw new CertificateException(&quot;No subject alternative &quot; +</span>
                        &quot;names matching &quot; + &quot;IP address &quot; +
                        expectedIP + &quot; found&quot;);
    }

    /**
     * Check if the certificate allows use of the given DNS name.
     *
     * From RFC2818:
     * If a subjectAltName extension of type dNSName is present, that MUST
     * be used as the identity. Otherwise, the (most specific) Common Name
     * field in the Subject field of the certificate MUST be used. Although
     * the use of the Common Name is existing practice, it is deprecated and
     * Certification Authorities are encouraged to use the dNSName instead.
     *
     * Matching is performed using the matching rules specified by
     * [RFC2459].  If more than one identity of a given type is present in
     * the certificate (e.g., more than one dNSName name, a match in any one
     * of the set is considered acceptable.)
     */
    private void matchDNS(String expectedName, X509Certificate cert)
            throws CertificateException {
<span class="fc" id="L176">        Collection&lt;List&lt;?&gt;&gt; subjAltNames = cert.getSubjectAlternativeNames();</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (subjAltNames != null) {</span>
<span class="fc" id="L178">            boolean foundDNS = false;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            for ( List&lt;?&gt; next : subjAltNames) {</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                if (((Integer)next.get(0)).intValue() == ALTNAME_DNS) {</span>
<span class="fc" id="L181">                    foundDNS = true;</span>
<span class="fc" id="L182">                    String dnsName = (String)next.get(1);</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">                    if (isMatched(expectedName, dnsName)) {</span>
<span class="fc" id="L184">                        return;</span>
                    }
                }
<span class="fc" id="L187">            }</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">            if (foundDNS) {</span>
                // if certificate contains any subject alt names of type DNS
                // but none match, reject
<span class="nc" id="L191">                throw new CertificateException(&quot;No subject alternative DNS &quot;</span>
                        + &quot;name matching &quot; + expectedName + &quot; found.&quot;);
            }
        }
<span class="fc" id="L195">        X500Name subjectName = getSubjectX500Name(cert);</span>
<span class="fc" id="L196">        DerValue derValue = subjectName.findMostSpecificAttribute</span>
<span class="fc" id="L197">                                                    (X500Name.commonName_oid);</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (derValue != null) {</span>
            try {
<span class="fc bfc" id="L200" title="All 2 branches covered.">                if (isMatched(expectedName, derValue.getAsString())) {</span>
<span class="fc" id="L201">                    return;</span>
                }
<span class="nc" id="L203">            } catch (IOException e) {</span>
                // ignore
<span class="fc" id="L205">            }</span>
        }
<span class="fc" id="L207">        String msg = &quot;No name matching &quot; + expectedName + &quot; found&quot;;</span>
<span class="fc" id="L208">        throw new CertificateException(msg);</span>
    }


    /**
     * Return the subject of a certificate as X500Name, by reparsing if
     * necessary. X500Name should only be used if access to name components
     * is required, in other cases X500Principal is to be preferred.
     *
     * This method is currently used from within JSSE, do not remove.
     */
    public static X500Name getSubjectX500Name(X509Certificate cert)
            throws CertificateParsingException {
        try {
<span class="fc" id="L222">            Principal subjectDN = cert.getSubjectDN();</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            if (subjectDN instanceof X500Name) {</span>
<span class="fc" id="L224">                return (X500Name)subjectDN;</span>
            } else {
<span class="nc" id="L226">                X500Principal subjectX500 = cert.getSubjectX500Principal();</span>
<span class="nc" id="L227">                return new X500Name(subjectX500.getEncoded());</span>
            }
<span class="nc" id="L229">        } catch (IOException e) {</span>
<span class="nc" id="L230">            throw(CertificateParsingException)</span>
<span class="nc" id="L231">                new CertificateParsingException().initCause(e);</span>
        }
    }


    /**
     * Returns true if name matches against template.&lt;p&gt;
     *
     * The matching is performed as per RFC 2818 rules for TLS and
     * RFC 2830 rules for LDAP.&lt;p&gt;
     *
     * The &lt;code&gt;name&lt;/code&gt; parameter should represent a DNS name.
     * The &lt;code&gt;template&lt;/code&gt; parameter
     * may contain the wildcard character *
     */
    private boolean isMatched(String name, String template) {
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (checkType == TYPE_TLS) {</span>
<span class="fc" id="L248">            return matchAllWildcards(name, template);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        } else if (checkType == TYPE_LDAP) {</span>
<span class="nc" id="L250">            return matchLeftmostWildcard(name, template);</span>
        } else {
<span class="nc" id="L252">            return false;</span>
        }
    }


    /**
     * Returns true if name matches against template.&lt;p&gt;
     *
     * According to RFC 2818, section 3.1 -
     * Names may contain the wildcard character * which is
     * considered to match any single domain name component
     * or component fragment.
     * E.g., *.a.com matches foo.a.com but not
     * bar.foo.a.com. f*.com matches foo.com but not bar.com.
     */
    private static boolean matchAllWildcards(String name,
         String template) {
<span class="fc" id="L269">        name = name.toLowerCase(Locale.ENGLISH);</span>
<span class="fc" id="L270">        template = template.toLowerCase(Locale.ENGLISH);</span>
<span class="fc" id="L271">        StringTokenizer nameSt = new StringTokenizer(name, &quot;.&quot;);</span>
<span class="fc" id="L272">        StringTokenizer templateSt = new StringTokenizer(template, &quot;.&quot;);</span>

<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (nameSt.countTokens() != templateSt.countTokens()) {</span>
<span class="fc" id="L275">            return false;</span>
        }

<span class="fc bfc" id="L278" title="All 2 branches covered.">        while (nameSt.hasMoreTokens()) {</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">            if (!matchWildCards(nameSt.nextToken(),</span>
<span class="fc" id="L280">                        templateSt.nextToken())) {</span>
<span class="nc" id="L281">                return false;</span>
            }
        }
<span class="fc" id="L284">        return true;</span>
    }


    /**
     * Returns true if name matches against template.&lt;p&gt;
     *
     * As per RFC 2830, section 3.6 -
     * The &quot;*&quot; wildcard character is allowed.  If present, it applies only
     * to the left-most name component.
     * E.g. *.bar.com would match a.bar.com, b.bar.com, etc. but not
     * bar.com.
     */
    private static boolean matchLeftmostWildcard(String name,
                         String template) {
<span class="nc" id="L299">        name = name.toLowerCase(Locale.ENGLISH);</span>
<span class="nc" id="L300">        template = template.toLowerCase(Locale.ENGLISH);</span>

        // Retreive leftmost component
<span class="nc" id="L303">        int templateIdx = template.indexOf(&quot;.&quot;);</span>
<span class="nc" id="L304">        int nameIdx = name.indexOf(&quot;.&quot;);</span>

<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (templateIdx == -1)</span>
<span class="nc" id="L307">            templateIdx = template.length();</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (nameIdx == -1)</span>
<span class="nc" id="L309">            nameIdx = name.length();</span>

<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (matchWildCards(name.substring(0, nameIdx),</span>
<span class="nc" id="L312">            template.substring(0, templateIdx))) {</span>

            // match rest of the name
<span class="nc" id="L315">            return template.substring(templateIdx).equals(</span>
<span class="nc" id="L316">                        name.substring(nameIdx));</span>
        } else {
<span class="nc" id="L318">            return false;</span>
        }
    }


    /**
     * Returns true if the name matches against the template that may
     * contain wildcard char * &lt;p&gt;
     */
    private static boolean matchWildCards(String name, String template) {

<span class="fc" id="L329">        int wildcardIdx = template.indexOf(&quot;*&quot;);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (wildcardIdx == -1)</span>
<span class="fc" id="L331">            return name.equals(template);</span>

<span class="nc" id="L333">        boolean isBeginning = true;</span>
<span class="nc" id="L334">        String beforeWildcard = &quot;&quot;;</span>
<span class="nc" id="L335">        String afterWildcard = template;</span>

<span class="nc bnc" id="L337" title="All 2 branches missed.">        while (wildcardIdx != -1) {</span>

            // match in sequence the non-wildcard chars in the template.
<span class="nc" id="L340">            beforeWildcard = afterWildcard.substring(0, wildcardIdx);</span>
<span class="nc" id="L341">            afterWildcard = afterWildcard.substring(wildcardIdx + 1);</span>

<span class="nc" id="L343">            int beforeStartIdx = name.indexOf(beforeWildcard);</span>
<span class="nc bnc" id="L344" title="All 6 branches missed.">            if ((beforeStartIdx == -1) ||</span>
                        (isBeginning &amp;&amp; beforeStartIdx != 0)) {
<span class="nc" id="L346">                return false;</span>
            }
<span class="nc" id="L348">            isBeginning = false;</span>

            // update the match scope
<span class="nc" id="L351">            name = name.substring(beforeStartIdx + beforeWildcard.length());</span>
<span class="nc" id="L352">            wildcardIdx = afterWildcard.indexOf(&quot;*&quot;);</span>
<span class="nc" id="L353">        }</span>
<span class="nc" id="L354">        return name.endsWith(afterWildcard);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>