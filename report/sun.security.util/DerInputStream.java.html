<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DerInputStream.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.util</a> &gt; <span class="el_source">DerInputStream.java</span></div><h1>DerInputStream.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.util;

import java.io.InputStream;
import java.io.IOException;
import java.io.EOFException;
import java.util.Date;
import java.util.Vector;
import java.math.BigInteger;
import java.io.DataInputStream;

/**
 * A DER input stream, used for parsing ASN.1 DER-encoded data such as
 * that found in X.509 certificates.  DER is a subset of BER/1, which has
 * the advantage that it allows only a single encoding of primitive data.
 * (High level data such as dates still support many encodings.)  That is,
 * it uses the &quot;Definite&quot; Encoding Rules (DER) not the &quot;Basic&quot; ones (BER).
 *
 * &lt;P&gt;Note that, like BER/1, DER streams are streams of explicitly
 * tagged data values.  Accordingly, this programming interface does
 * not expose any variant of the java.io.InputStream interface, since
 * that kind of input stream holds untagged data values and using that
 * I/O model could prevent correct parsing of the DER data.
 *
 * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 * data encodings which are defined.  That subset is sufficient for parsing
 * most X.509 certificates.
 *
 *
 * @author David Brownell
 * @author Amit Kapoor
 * @author Hemma Prafullchandra
 */

public class DerInputStream {

    /*
     * This version only supports fully buffered DER.  This is easy to
     * work with, though if large objects are manipulated DER becomes
     * awkward to deal with.  That's where BER is useful, since BER
     * handles streaming data relatively well.
     */
    DerInputBuffer      buffer;

    /** The DER tag of the value; one of the tag_ constants. */
    public byte         tag;

    /**
     * Create a DER input stream from a data buffer.  The buffer is not
     * copied, it is shared.  Accordingly, the buffer should be treated
     * as read-only.
     *
     * @param data the buffer from which to create the string (CONSUMED)
     */
<span class="fc" id="L79">    public DerInputStream(byte[] data) throws IOException {</span>
<span class="fc" id="L80">        init(data, 0, data.length);</span>
<span class="fc" id="L81">    }</span>

    /**
     * Create a DER input stream from part of a data buffer.
     * The buffer is not copied, it is shared.  Accordingly, the
     * buffer should be treated as read-only.
     *
     * @param data the buffer from which to create the string (CONSUMED)
     * @param offset the first index of &lt;em&gt;data&lt;/em&gt; which will
     *          be read as DER input in the new stream
     * @param len how long a chunk of the buffer to use,
     *          starting at &quot;offset&quot;
     */
<span class="fc" id="L94">    public DerInputStream(byte[] data, int offset, int len) throws IOException {</span>
<span class="fc" id="L95">        init(data, offset, len);</span>
<span class="fc" id="L96">    }</span>

    /*
     * private helper routine
     */
    private void init(byte[] data, int offset, int len) throws IOException {
<span class="pc bpc" id="L102" title="2 of 4 branches missed.">        if ((offset+2 &gt; data.length) || (offset+len &gt; data.length)) {</span>
<span class="nc" id="L103">            throw new IOException(&quot;Encoding bytes too short&quot;);</span>
        }
        // check for indefinite length encoding
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if (DerIndefLenConverter.isIndefinite(data[offset+1])) {</span>
<span class="nc" id="L107">            byte[] inData = new byte[len];</span>
<span class="nc" id="L108">            System.arraycopy(data, offset, inData, 0, len);</span>

<span class="nc" id="L110">            DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="nc" id="L111">            buffer = new DerInputBuffer(derIn.convert(inData));</span>
<span class="nc" id="L112">        } else</span>
<span class="fc" id="L113">            buffer = new DerInputBuffer(data, offset, len);</span>
<span class="fc" id="L114">        buffer.mark(Integer.MAX_VALUE);</span>
<span class="fc" id="L115">    }</span>

<span class="fc" id="L117">    DerInputStream(DerInputBuffer buf) {</span>
<span class="fc" id="L118">        buffer = buf;</span>
<span class="fc" id="L119">        buffer.mark(Integer.MAX_VALUE);</span>
<span class="fc" id="L120">    }</span>

    /**
     * Creates a new DER input stream from part of this input stream.
     *
     * @param len how long a chunk of the current input stream to use,
     *          starting at the current position.
     * @param do_skip true if the existing data in the input stream should
     *          be skipped.  If this value is false, the next data read
     *          on this stream and the newly created stream will be the
     *          same.
     */
    public DerInputStream subStream(int len, boolean do_skip)
    throws IOException {
<span class="fc" id="L134">        DerInputBuffer  newbuf = buffer.dup();</span>

<span class="fc" id="L136">        newbuf.truncate(len);</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if (do_skip) {</span>
<span class="fc" id="L138">            buffer.skip(len);</span>
        }
<span class="fc" id="L140">        return new DerInputStream(newbuf);</span>
    }

    /**
     * Return what has been written to this DerInputStream
     * as a byte array. Useful for debugging.
     */
    public byte[] toByteArray() {
<span class="fc" id="L148">        return buffer.toByteArray();</span>
    }

    /*
     * PRIMITIVES -- these are &quot;universal&quot; ASN.1 simple types.
     *
     *  INTEGER, ENUMERATED, BIT STRING, OCTET STRING, NULL
     *  OBJECT IDENTIFIER, SEQUENCE (OF), SET (OF)
     *  UTF8String, PrintableString, T61String, IA5String, UTCTime,
     *  GeneralizedTime, BMPString.
     * Note: UniversalString not supported till encoder is available.
     */

    /**
     * Get an integer from the input stream as an integer.
     *
     * @return the integer held in this DER input stream.
     */
    public int getInteger() throws IOException {
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (buffer.read() != DerValue.tag_Integer) {</span>
<span class="nc" id="L168">            throw new IOException(&quot;DER input, Integer tag error&quot;);</span>
        }
<span class="fc" id="L170">        return buffer.getInteger(getLength(buffer));</span>
    }

    /**
     * Get a integer from the input stream as a BigInteger object.
     *
     * @return the integer held in this DER input stream.
     */
    public BigInteger getBigInteger() throws IOException {
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (buffer.read() != DerValue.tag_Integer) {</span>
<span class="nc" id="L180">            throw new IOException(&quot;DER input, Integer tag error&quot;);</span>
        }
<span class="fc" id="L182">        return buffer.getBigInteger(getLength(buffer), false);</span>
    }

    /**
     * Returns an ASN.1 INTEGER value as a positive BigInteger.
     * This is just to deal with implementations that incorrectly encode
     * some values as negative.
     *
     * @return the integer held in this DER value as a BigInteger.
     */
    public BigInteger getPositiveBigInteger() throws IOException {
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (buffer.read() != DerValue.tag_Integer) {</span>
<span class="nc" id="L194">            throw new IOException(&quot;DER input, Integer tag error&quot;);</span>
        }
<span class="nc" id="L196">        return buffer.getBigInteger(getLength(buffer), true);</span>
    }

    /**
     * Get an enumerated from the input stream.
     *
     * @return the integer held in this DER input stream.
     */
    public int getEnumerated() throws IOException {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (buffer.read() != DerValue.tag_Enumerated) {</span>
<span class="nc" id="L206">            throw new IOException(&quot;DER input, Enumerated tag error&quot;);</span>
        }
<span class="nc" id="L208">        return buffer.getInteger(getLength(buffer));</span>
    }

    /**
     * Get a bit string from the input stream. Padded bits (if any)
     * will be stripped off before the bit string is returned.
     */
    public byte[] getBitString() throws IOException {
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (buffer.read() != DerValue.tag_BitString)</span>
<span class="nc" id="L217">            throw new IOException(&quot;DER input not an bit string&quot;);</span>

<span class="fc" id="L219">        return buffer.getBitString(getLength(buffer));</span>
    }

    /**
     * Get a bit string from the input stream.  The bit string need
     * not be byte-aligned.
     */
    public BitArray getUnalignedBitString() throws IOException {
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        if (buffer.read() != DerValue.tag_BitString)</span>
<span class="nc" id="L228">            throw new IOException(&quot;DER input not a bit string&quot;);</span>

<span class="fc" id="L230">        int length = getLength(buffer) - 1;</span>

        /*
         * First byte = number of excess bits in the last octet of the
         * representation.
         */
<span class="fc" id="L236">        int validBits = length*8 - buffer.read();</span>

<span class="fc" id="L238">        byte[] repn = new byte[length];</span>

<span class="pc bpc" id="L240" title="2 of 4 branches missed.">        if ((length != 0) &amp;&amp; (buffer.read(repn) != length))</span>
<span class="nc" id="L241">            throw new IOException(&quot;short read of DER bit string&quot;);</span>
<span class="fc" id="L242">        return new BitArray(validBits, repn);</span>
    }

    /**
     * Returns an ASN.1 OCTET STRING from the input stream.
     */
    public byte[] getOctetString() throws IOException {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        if (buffer.read() != DerValue.tag_OctetString)</span>
<span class="nc" id="L250">            throw new IOException(&quot;DER input not an octet string&quot;);</span>

<span class="fc" id="L252">        int length = getLength(buffer);</span>
<span class="fc" id="L253">        byte[] retval = new byte[length];</span>
<span class="pc bpc" id="L254" title="1 of 4 branches missed.">        if ((length != 0) &amp;&amp; (buffer.read(retval) != length))</span>
<span class="nc" id="L255">            throw new IOException(&quot;short read of DER octet string&quot;);</span>

<span class="fc" id="L257">        return retval;</span>
    }

    /**
     * Returns the asked number of bytes from the input stream.
     */
    public void getBytes(byte[] val) throws IOException {
<span class="pc bpc" id="L264" title="2 of 4 branches missed.">        if ((val.length != 0) &amp;&amp; (buffer.read(val) != val.length)) {</span>
<span class="nc" id="L265">            throw new IOException(&quot;short read of DER octet string&quot;);</span>
        }
<span class="fc" id="L267">    }</span>

    /**
     * Reads an encoded null value from the input stream.
     */
    public void getNull() throws IOException {
<span class="nc bnc" id="L273" title="All 4 branches missed.">        if (buffer.read() != DerValue.tag_Null || buffer.read() != 0)</span>
<span class="nc" id="L274">            throw new IOException(&quot;getNull, bad data&quot;);</span>
<span class="nc" id="L275">    }</span>

    /**
     * Reads an X.200 style Object Identifier from the stream.
     */
    public ObjectIdentifier getOID() throws IOException {
<span class="fc" id="L281">        return new ObjectIdentifier(this);</span>
    }

    /**
     * Return a sequence of encoded entities.  ASN.1 sequences are
     * ordered, and they are often used, like a &quot;struct&quot; in C or C++,
     * to group data values.  They may have optional or context
     * specific values.
     *
     * @param startLen guess about how long the sequence will be
     *          (used to initialize an auto-growing data structure)
     * @return array of the values in the sequence
     */
    public DerValue[] getSequence(int startLen) throws IOException {
<span class="fc" id="L295">        tag = (byte)buffer.read();</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (tag != DerValue.tag_Sequence)</span>
<span class="nc" id="L297">            throw new IOException(&quot;Sequence tag error&quot;);</span>
<span class="fc" id="L298">        return readVector(startLen);</span>
    }

    /**
     * Return a set of encoded entities.  ASN.1 sets are unordered,
     * though DER may specify an order for some kinds of sets (such
     * as the attributes in an X.500 relative distinguished name)
     * to facilitate binary comparisons of encoded values.
     *
     * @param startLen guess about how large the set will be
     *          (used to initialize an auto-growing data structure)
     * @return array of the values in the sequence
     */
    public DerValue[] getSet(int startLen) throws IOException {
<span class="fc" id="L312">        tag = (byte)buffer.read();</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (tag != DerValue.tag_Set)</span>
<span class="nc" id="L314">            throw new IOException(&quot;Set tag error&quot;);</span>
<span class="fc" id="L315">        return readVector(startLen);</span>
    }

    /**
     * Return a set of encoded entities.  ASN.1 sets are unordered,
     * though DER may specify an order for some kinds of sets (such
     * as the attributes in an X.500 relative distinguished name)
     * to facilitate binary comparisons of encoded values.
     *
     * @param startLen guess about how large the set will be
     *          (used to initialize an auto-growing data structure)
     * @param implicit if true tag is assumed implicit.
     * @return array of the values in the sequence
     */
    public DerValue[] getSet(int startLen, boolean implicit)
        throws IOException {
<span class="fc" id="L331">        tag = (byte)buffer.read();</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">        if (!implicit) {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (tag != DerValue.tag_Set) {</span>
<span class="nc" id="L334">                throw new IOException(&quot;Set tag error&quot;);</span>
            }
        }
<span class="fc" id="L337">        return (readVector(startLen));</span>
    }

    /*
     * Read a &quot;vector&quot; of values ... set or sequence have the
     * same encoding, except for the initial tag, so both use
     * this same helper routine.
     */
    protected DerValue[] readVector(int startLen) throws IOException {
        DerInputStream  newstr;

<span class="fc" id="L348">        byte lenByte = (byte)buffer.read();</span>
<span class="fc" id="L349">        int len = getLength((lenByte &amp; 0xff), buffer);</span>

<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (len == -1) {</span>
           // indefinite length encoding found
<span class="nc" id="L353">           int readLen = buffer.available();</span>
<span class="nc" id="L354">           int offset = 2;     // for tag and length bytes</span>
<span class="nc" id="L355">           byte[] indefData = new byte[readLen + offset];</span>
<span class="nc" id="L356">           indefData[0] = tag;</span>
<span class="nc" id="L357">           indefData[1] = lenByte;</span>
<span class="nc" id="L358">           DataInputStream dis = new DataInputStream(buffer);</span>
<span class="nc" id="L359">           dis.readFully(indefData, offset, readLen);</span>
<span class="nc" id="L360">           dis.close();</span>
<span class="nc" id="L361">           DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="nc" id="L362">           buffer = new DerInputBuffer(derIn.convert(indefData));</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">           if (tag != buffer.read())</span>
<span class="nc" id="L364">                throw new IOException(&quot;Indefinite length encoding&quot; +</span>
                        &quot; not supported&quot;);
<span class="nc" id="L366">           len = DerInputStream.getLength(buffer);</span>
        }

<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (len == 0)</span>
            // return empty array instead of null, which should be
            // used only for missing optionals
<span class="fc" id="L372">            return new DerValue[0];</span>

        /*
         * Create a temporary stream from which to read the data,
         * unless it's not really needed.
         */
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (buffer.available() == len)</span>
<span class="fc" id="L379">            newstr = this;</span>
        else
<span class="fc" id="L381">            newstr = subStream(len, true);</span>

        /*
         * Pull values out of the stream.
         */
<span class="fc" id="L386">        Vector&lt;DerValue&gt; vec = new Vector&lt;DerValue&gt;(startLen);</span>
        DerValue value;

        do {
<span class="fc" id="L390">            value = new DerValue(newstr.buffer);</span>
<span class="fc" id="L391">            vec.addElement(value);</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        } while (newstr.available() &gt; 0);</span>

<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        if (newstr.available() != 0)</span>
<span class="nc" id="L395">            throw new IOException(&quot;extra data at end of vector&quot;);</span>

        /*
         * Now stick them into the array we're returning.
         */
<span class="fc" id="L400">        int             i, max = vec.size();</span>
<span class="fc" id="L401">        DerValue[]      retval = new DerValue[max];</span>

<span class="fc bfc" id="L403" title="All 2 branches covered.">        for (i = 0; i &lt; max; i++)</span>
<span class="fc" id="L404">            retval[i] = vec.elementAt(i);</span>

<span class="fc" id="L406">        return retval;</span>
    }

    /**
     * Get a single DER-encoded value from the input stream.
     * It can often be useful to pull a value from the stream
     * and defer parsing it.  For example, you can pull a nested
     * sequence out with one call, and only examine its elements
     * later when you really need to.
     */
    public DerValue getDerValue() throws IOException {
<span class="fc" id="L417">        return new DerValue(buffer);</span>
    }

    /**
     * Read a string that was encoded as a UTF8String DER value.
     */
    public String getUTF8String() throws IOException {
<span class="nc" id="L424">        return readString(DerValue.tag_UTF8String, &quot;UTF-8&quot;, &quot;UTF8&quot;);</span>
    }

    /**
     * Read a string that was encoded as a PrintableString DER value.
     */
    public String getPrintableString() throws IOException {
<span class="nc" id="L431">        return readString(DerValue.tag_PrintableString, &quot;Printable&quot;,</span>
                          &quot;ASCII&quot;);
    }

    /**
     * Read a string that was encoded as a T61String DER value.
     */
    public String getT61String() throws IOException {
        /*
         * Works for common characters between T61 and ASCII.
         */
<span class="nc" id="L442">        return readString(DerValue.tag_T61String, &quot;T61&quot;, &quot;ISO-8859-1&quot;);</span>
    }

    /**
     * Read a string that was encoded as a IA5tring DER value.
     */
    public String getIA5String() throws IOException {
<span class="nc" id="L449">        return readString(DerValue.tag_IA5String, &quot;IA5&quot;, &quot;ASCII&quot;);</span>
    }

    /**
     * Read a string that was encoded as a BMPString DER value.
     */
    public String getBMPString() throws IOException {
<span class="nc" id="L456">        return readString(DerValue.tag_BMPString, &quot;BMP&quot;,</span>
                          &quot;UnicodeBigUnmarked&quot;);
    }

    /**
     * Read a string that was encoded as a GeneralString DER value.
     */
    public String getGeneralString() throws IOException {
<span class="nc" id="L464">        return readString(DerValue.tag_GeneralString, &quot;General&quot;,</span>
                          &quot;ASCII&quot;);
    }

    /**
     * Private helper routine to read an encoded string from the input
     * stream.
     * @param stringTag the tag for the type of string to read
     * @param stringName a name to display in error messages
     * @param enc the encoder to use to interpret the data. Should
     * correspond to the stringTag above.
     */
    private String readString(byte stringTag, String stringName,
                              String enc) throws IOException {

<span class="nc bnc" id="L479" title="All 2 branches missed.">        if (buffer.read() != stringTag)</span>
<span class="nc" id="L480">            throw new IOException(&quot;DER input not a &quot; +</span>
                                  stringName + &quot; string&quot;);

<span class="nc" id="L483">        int length = getLength(buffer);</span>
<span class="nc" id="L484">        byte[] retval = new byte[length];</span>
<span class="nc bnc" id="L485" title="All 4 branches missed.">        if ((length != 0) &amp;&amp; (buffer.read(retval) != length))</span>
<span class="nc" id="L486">            throw new IOException(&quot;short read of DER &quot; +</span>
                                  stringName + &quot; string&quot;);

<span class="nc" id="L489">        return new String(retval, enc);</span>
    }

    /**
     * Get a UTC encoded time value from the input stream.
     */
    public Date getUTCTime() throws IOException {
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        if (buffer.read() != DerValue.tag_UtcTime)</span>
<span class="nc" id="L497">            throw new IOException(&quot;DER input, UTCtime tag invalid &quot;);</span>
<span class="fc" id="L498">        return buffer.getUTCTime(getLength(buffer));</span>
    }

    /**
     * Get a Generalized encoded time value from the input stream.
     */
    public Date getGeneralizedTime() throws IOException {
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">        if (buffer.read() != DerValue.tag_GeneralizedTime)</span>
<span class="nc" id="L506">            throw new IOException(&quot;DER input, GeneralizedTime tag invalid &quot;);</span>
<span class="fc" id="L507">        return buffer.getGeneralizedTime(getLength(buffer));</span>
    }

    /*
     * Get a byte from the input stream.
     */
    // package private
    int getByte() throws IOException {
<span class="fc" id="L515">        return (0x00ff &amp; buffer.read());</span>
    }

    public int peekByte() throws IOException {
<span class="fc" id="L519">        return buffer.peek();</span>
    }

    // package private
    int getLength() throws IOException {
<span class="fc" id="L524">        return getLength(buffer);</span>
    }

    /*
     * Get a length from the input stream, allowing for at most 32 bits of
     * encoding to be used.  (Not the same as getting a tagged integer!)
     *
     * @return the length or -1 if indefinite length found.
     * @exception IOException on parsing error or unsupported lengths.
     */
    static int getLength(InputStream in) throws IOException {
<span class="fc" id="L535">        return getLength(in.read(), in);</span>
    }

    /*
     * Get a length from the input stream, allowing for at most 32 bits of
     * encoding to be used.  (Not the same as getting a tagged integer!)
     *
     * @return the length or -1 if indefinite length found.
     * @exception IOException on parsing error or unsupported lengths.
     */
    static int getLength(int lenByte, InputStream in) throws IOException {
        int value, tmp;

<span class="fc" id="L548">        tmp = lenByte;</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">        if ((tmp &amp; 0x080) == 0x00) { // short form, 1 byte datum</span>
<span class="fc" id="L550">            value = tmp;</span>
        } else {                     // long form or indefinite
<span class="fc" id="L552">            tmp &amp;= 0x07f;</span>

            /*
             * NOTE:  tmp == 0 indicates indefinite length encoded data.
             * tmp &gt; 4 indicates more than 4Gb of data.
             */
<span class="fc bfc" id="L558" title="All 2 branches covered.">            if (tmp == 0)</span>
<span class="fc" id="L559">                return -1;</span>
<span class="pc bpc" id="L560" title="2 of 4 branches missed.">            if (tmp &lt; 0 || tmp &gt; 4)</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">                throw new IOException(&quot;DerInputStream.getLength(): lengthTag=&quot;</span>
                    + tmp + &quot;, &quot;
                    + ((tmp &lt; 0) ? &quot;incorrect DER encoding.&quot; : &quot;too big.&quot;));

<span class="fc bfc" id="L565" title="All 2 branches covered.">            for (value = 0; tmp &gt; 0; tmp --) {</span>
<span class="fc" id="L566">                value &lt;&lt;= 8;</span>
<span class="fc" id="L567">                value += 0x0ff &amp; in.read();</span>
            }
        }
<span class="fc" id="L570">        return value;</span>
    }

    /**
     * Mark the current position in the buffer, so that
     * a later call to &lt;code&gt;reset&lt;/code&gt; will return here.
     */
<span class="fc" id="L577">    public void mark(int value) { buffer.mark(value); }</span>


    /**
     * Return to the position of the last &lt;code&gt;mark&lt;/code&gt;
     * call.  A mark is implicitly set at the beginning of
     * the stream when it is created.
     */
<span class="fc" id="L585">    public void reset() { buffer.reset(); }</span>


    /**
     * Returns the number of bytes available for reading.
     * This is most useful for testing whether the stream is
     * empty.
     */
<span class="fc" id="L593">    public int available() { return buffer.available(); }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>