<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Cache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.util</a> &gt; <span class="el_source">Cache.java</span></div><h1>Cache.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.util;

import java.util.*;
import java.lang.ref.*;

/**
 * Abstract base class and factory for caches. A cache is a key-value mapping.
 * It has properties that make it more suitable for caching than a Map.
 *
 * The factory methods can be used to obtain two different implementations.
 * They have the following properties:
 *
 *  . keys and values reside in memory
 *
 *  . keys and values must be non-null
 *
 *  . maximum size. Replacements are made in LRU order.
 *
 *  . optional lifetime, specified in seconds.
 *
 *  . safe for concurrent use by multiple threads
 *
 *  . values are held by either standard references or via SoftReferences.
 *    SoftReferences have the advantage that they are automatically cleared
 *    by the garbage collector in response to memory demand. This makes it
 *    possible to simple set the maximum size to a very large value and let
 *    the GC automatically size the cache dynamically depending on the
 *    amount of available memory.
 *
 * However, note that because of the way SoftReferences are implemented in
 * HotSpot at the moment, this may not work perfectly as it clears them fairly
 * eagerly. Performance may be improved if the Java heap size is set to larger
 * value using e.g. java -ms64M -mx128M foo.Test
 *
 * Cache sizing: the memory cache is implemented on top of a LinkedHashMap.
 * In its current implementation, the number of buckets (NOT entries) in
 * (Linked)HashMaps is always a power of two. It is recommended to set the
 * maximum cache size to value that uses those buckets fully. For example,
 * if a cache with somewhere between 500 and 1000 entries is desired, a
 * maximum size of 750 would be a good choice: try 1024 buckets, with a
 * load factor of 0.75f, the number of entries can be calculated as
 * buckets / 4 * 3. As mentioned above, with a SoftReference cache, it is
 * generally reasonable to set the size to a fairly large value.
 *
 * @author Andreas Sterbenz
 */
public abstract class Cache&lt;K,V&gt; {

<span class="fc" id="L74">    protected Cache() {</span>
        // empty
<span class="fc" id="L76">    }</span>

    /**
     * Return the number of currently valid entries in the cache.
     */
    public abstract int size();

    /**
     * Remove all entries from the cache.
     */
    public abstract void clear();

    /**
     * Add an entry to the cache.
     */
    public abstract void put(K key, V value);

    /**
     * Get a value from the cache.
     */
    public abstract V get(Object key);

    /**
     * Remove an entry from the cache.
     */
    public abstract void remove(Object key);

    /**
     * Set the maximum size.
     */
    public abstract void setCapacity(int size);

    /**
     * Set the timeout(in seconds).
     */
    public abstract void setTimeout(int timeout);

    /**
     * accept a visitor
     */
    public abstract void accept(CacheVisitor&lt;K,V&gt; visitor);

    /**
     * Return a new memory cache with the specified maximum size, unlimited
     * lifetime for entries, with the values held by SoftReferences.
     */
    public static &lt;K,V&gt; Cache&lt;K,V&gt; newSoftMemoryCache(int size) {
<span class="fc" id="L123">        return new MemoryCache&lt;&gt;(true, size);</span>
    }

    /**
     * Return a new memory cache with the specified maximum size, the
     * specified maximum lifetime (in seconds), with the values held
     * by SoftReferences.
     */
    public static &lt;K,V&gt; Cache&lt;K,V&gt; newSoftMemoryCache(int size, int timeout) {
<span class="fc" id="L132">        return new MemoryCache&lt;&gt;(true, size, timeout);</span>
    }

    /**
     * Return a new memory cache with the specified maximum size, unlimited
     * lifetime for entries, with the values held by standard references.
     */
    public static &lt;K,V&gt; Cache&lt;K,V&gt; newHardMemoryCache(int size) {
<span class="fc" id="L140">        return new MemoryCache&lt;&gt;(false, size);</span>
    }

    /**
     * Return a dummy cache that does nothing.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;K,V&gt; Cache&lt;K,V&gt; newNullCache() {
<span class="nc" id="L148">        return (Cache&lt;K,V&gt;) NullCache.INSTANCE;</span>
    }

    /**
     * Return a new memory cache with the specified maximum size, the
     * specified maximum lifetime (in seconds), with the values held
     * by standard references.
     */
    public static &lt;K,V&gt; Cache&lt;K,V&gt; newHardMemoryCache(int size, int timeout) {
<span class="nc" id="L157">        return new MemoryCache&lt;&gt;(false, size, timeout);</span>
    }

    /**
     * Utility class that wraps a byte array and implements the equals()
     * and hashCode() contract in a way suitable for Maps and caches.
     */
    public static class EqualByteArray {

        private final byte[] b;
        private volatile int hash;

<span class="fc" id="L169">        public EqualByteArray(byte[] b) {</span>
<span class="fc" id="L170">            this.b = b;</span>
<span class="fc" id="L171">        }</span>

        public int hashCode() {
<span class="fc" id="L174">            int h = hash;</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            if (h == 0) {</span>
<span class="fc" id="L176">                h = b.length + 1;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">                for (int i = 0; i &lt; b.length; i++) {</span>
<span class="fc" id="L178">                    h += (b[i] &amp; 0xff) * 37;</span>
                }
<span class="fc" id="L180">                hash = h;</span>
            }
<span class="fc" id="L182">            return h;</span>
        }

        public boolean equals(Object obj) {
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L187">                return true;</span>
            }
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">            if (obj instanceof EqualByteArray == false) {</span>
<span class="nc" id="L190">                return false;</span>
            }
<span class="fc" id="L192">            EqualByteArray other = (EqualByteArray)obj;</span>
<span class="fc" id="L193">            return Arrays.equals(this.b, other.b);</span>
        }
    }

    public interface CacheVisitor&lt;K,V&gt; {
        public void visit(Map&lt;K,V&gt; map);
    }

}

class NullCache&lt;K,V&gt; extends Cache&lt;K,V&gt; {

<span class="nc" id="L205">    final static Cache&lt;Object,Object&gt; INSTANCE = new NullCache&lt;&gt;();</span>

<span class="nc" id="L207">    private NullCache() {</span>
        // empty
<span class="nc" id="L209">    }</span>

    public int size() {
<span class="nc" id="L212">        return 0;</span>
    }

    public void clear() {
        // empty
<span class="nc" id="L217">    }</span>

    public void put(K key, V value) {
        // empty
<span class="nc" id="L221">    }</span>

    public V get(Object key) {
<span class="nc" id="L224">        return null;</span>
    }

    public void remove(Object key) {
        // empty
<span class="nc" id="L229">    }</span>

    public void setCapacity(int size) {
        // empty
<span class="nc" id="L233">    }</span>

    public void setTimeout(int timeout) {
        // empty
<span class="nc" id="L237">    }</span>

    public void accept(CacheVisitor&lt;K,V&gt; visitor) {
        // empty
<span class="nc" id="L241">    }</span>

}

class MemoryCache&lt;K,V&gt; extends Cache&lt;K,V&gt; {

    private final static float LOAD_FACTOR = 0.75f;

    // XXXX
    private final static boolean DEBUG = false;

    private final Map&lt;K, CacheEntry&lt;K,V&gt;&gt; cacheMap;
    private int maxSize;
    private long lifetime;

    // ReferenceQueue is of type V instead of Cache&lt;K,V&gt;
    // to allow SoftCacheEntry to extend SoftReference&lt;V&gt;
    private final ReferenceQueue&lt;V&gt; queue;

    public MemoryCache(boolean soft, int maxSize) {
<span class="fc" id="L261">        this(soft, maxSize, 0);</span>
<span class="fc" id="L262">    }</span>

<span class="fc" id="L264">    public MemoryCache(boolean soft, int maxSize, int lifetime) {</span>
<span class="fc" id="L265">        this.maxSize = maxSize;</span>
<span class="fc" id="L266">        this.lifetime = lifetime * 1000;</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (soft)</span>
<span class="fc" id="L268">            this.queue = new ReferenceQueue&lt;&gt;();</span>
        else
<span class="fc" id="L270">            this.queue = null;</span>

<span class="fc" id="L272">        int buckets = (int)(maxSize / LOAD_FACTOR) + 1;</span>
<span class="fc" id="L273">        cacheMap = new LinkedHashMap&lt;&gt;(buckets, LOAD_FACTOR, true);</span>
<span class="fc" id="L274">    }</span>

    /**
     * Empty the reference queue and remove all corresponding entries
     * from the cache.
     *
     * This method should be called at the beginning of each public
     * method.
     */
    private void emptyQueue() {
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (queue == null) {</span>
<span class="fc" id="L285">            return;</span>
        }
<span class="fc" id="L287">        int startSize = cacheMap.size();</span>
        while (true) {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L290">            CacheEntry&lt;K,V&gt; entry = (CacheEntry&lt;K,V&gt;)queue.poll();</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">            if (entry == null) {</span>
<span class="fc" id="L292">                break;</span>
            }
<span class="nc" id="L294">            K key = entry.getKey();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (key == null) {</span>
                // key is null, entry has already been removed
<span class="nc" id="L297">                continue;</span>
            }
<span class="nc" id="L299">            CacheEntry&lt;K,V&gt; currentEntry = cacheMap.remove(key);</span>
            // check if the entry in the map corresponds to the expired
            // entry. If not, readd the entry
<span class="nc bnc" id="L302" title="All 4 branches missed.">            if ((currentEntry != null) &amp;&amp; (entry != currentEntry)) {</span>
<span class="nc" id="L303">                cacheMap.put(key, currentEntry);</span>
            }
<span class="nc" id="L305">        }</span>
        if (DEBUG) {
            int endSize = cacheMap.size();
            if (startSize != endSize) {
                System.out.println(&quot;*** Expunged &quot; + (startSize - endSize)
                        + &quot; entries, &quot; + endSize + &quot; entries left&quot;);
            }
        }
<span class="fc" id="L313">    }</span>

    /**
     * Scan all entries and remove all expired ones.
     */
    private void expungeExpiredEntries() {
<span class="fc" id="L319">        emptyQueue();</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (lifetime == 0) {</span>
<span class="fc" id="L321">            return;</span>
        }
<span class="fc" id="L323">        int cnt = 0;</span>
<span class="fc" id="L324">        long time = System.currentTimeMillis();</span>
<span class="fc" id="L325">        for (Iterator&lt;CacheEntry&lt;K,V&gt;&gt; t = cacheMap.values().iterator();</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">                t.hasNext(); ) {</span>
<span class="fc" id="L327">            CacheEntry&lt;K,V&gt; entry = t.next();</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">            if (entry.isValid(time) == false) {</span>
<span class="nc" id="L329">                t.remove();</span>
<span class="nc" id="L330">                cnt++;</span>
            }
<span class="fc" id="L332">        }</span>
        if (DEBUG) {
            if (cnt != 0) {
                System.out.println(&quot;Removed &quot; + cnt
                        + &quot; expired entries, remaining &quot; + cacheMap.size());
            }
        }
<span class="fc" id="L339">    }</span>

    public synchronized int size() {
<span class="nc" id="L342">        expungeExpiredEntries();</span>
<span class="nc" id="L343">        return cacheMap.size();</span>
    }

    public synchronized void clear() {
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if (queue != null) {</span>
            // if this is a SoftReference cache, first invalidate() all
            // entries so that GC does not have to enqueue them
<span class="fc bfc" id="L350" title="All 2 branches covered.">            for (CacheEntry&lt;K,V&gt; entry : cacheMap.values()) {</span>
<span class="fc" id="L351">                entry.invalidate();</span>
<span class="fc" id="L352">            }</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">            while (queue.poll() != null) {</span>
                // empty
            }
        }
<span class="fc" id="L357">        cacheMap.clear();</span>
<span class="fc" id="L358">    }</span>

    public synchronized void put(K key, V value) {
<span class="fc" id="L361">        emptyQueue();</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">        long expirationTime = (lifetime == 0) ? 0 :</span>
<span class="fc" id="L363">                                        System.currentTimeMillis() + lifetime;</span>
<span class="fc" id="L364">        CacheEntry&lt;K,V&gt; newEntry = newEntry(key, value, expirationTime, queue);</span>
<span class="fc" id="L365">        CacheEntry&lt;K,V&gt; oldEntry = cacheMap.put(key, newEntry);</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if (oldEntry != null) {</span>
<span class="fc" id="L367">            oldEntry.invalidate();</span>
<span class="fc" id="L368">            return;</span>
        }
<span class="fc bfc" id="L370" title="All 4 branches covered.">        if (maxSize &gt; 0 &amp;&amp; cacheMap.size() &gt; maxSize) {</span>
<span class="fc" id="L371">            expungeExpiredEntries();</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">            if (cacheMap.size() &gt; maxSize) { // still too large?</span>
<span class="fc" id="L373">                Iterator&lt;CacheEntry&lt;K,V&gt;&gt; t = cacheMap.values().iterator();</span>
<span class="fc" id="L374">                CacheEntry&lt;K,V&gt; lruEntry = t.next();</span>
                if (DEBUG) {
                    System.out.println(&quot;** Overflow removal &quot;
                        + lruEntry.getKey() + &quot; | &quot; + lruEntry.getValue());
                }
<span class="fc" id="L379">                t.remove();</span>
<span class="fc" id="L380">                lruEntry.invalidate();</span>
            }
        }
<span class="fc" id="L383">    }</span>

    public synchronized V get(Object key) {
<span class="fc" id="L386">        emptyQueue();</span>
<span class="fc" id="L387">        CacheEntry&lt;K,V&gt; entry = cacheMap.get(key);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">        if (entry == null) {</span>
<span class="fc" id="L389">            return null;</span>
        }
<span class="fc bfc" id="L391" title="All 2 branches covered.">        long time = (lifetime == 0) ? 0 : System.currentTimeMillis();</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (entry.isValid(time) == false) {</span>
            if (DEBUG) {
                System.out.println(&quot;Ignoring expired entry&quot;);
            }
<span class="nc" id="L396">            cacheMap.remove(key);</span>
<span class="nc" id="L397">            return null;</span>
        }
<span class="fc" id="L399">        return entry.getValue();</span>
    }

    public synchronized void remove(Object key) {
<span class="fc" id="L403">        emptyQueue();</span>
<span class="fc" id="L404">        CacheEntry&lt;K,V&gt; entry = cacheMap.remove(key);</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (entry != null) {</span>
<span class="fc" id="L406">            entry.invalidate();</span>
        }
<span class="fc" id="L408">    }</span>

    public synchronized void setCapacity(int size) {
<span class="fc" id="L411">        expungeExpiredEntries();</span>
<span class="pc bpc" id="L412" title="1 of 4 branches missed.">        if (size &gt; 0 &amp;&amp; cacheMap.size() &gt; size) {</span>
<span class="fc" id="L413">            Iterator&lt;CacheEntry&lt;K,V&gt;&gt; t = cacheMap.values().iterator();</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">            for (int i = cacheMap.size() - size; i &gt; 0; i--) {</span>
<span class="fc" id="L415">                CacheEntry&lt;K,V&gt; lruEntry = t.next();</span>
                if (DEBUG) {
                    System.out.println(&quot;** capacity reset removal &quot;
                        + lruEntry.getKey() + &quot; | &quot; + lruEntry.getValue());
                }
<span class="fc" id="L420">                t.remove();</span>
<span class="fc" id="L421">                lruEntry.invalidate();</span>
            }
        }

<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        maxSize = size &gt; 0 ? size : 0;</span>

        if (DEBUG) {
            System.out.println(&quot;** capacity reset to &quot; + size);
        }
<span class="fc" id="L430">    }</span>

    public synchronized void setTimeout(int timeout) {
<span class="fc" id="L433">        emptyQueue();</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">        lifetime = timeout &gt; 0 ? timeout * 1000L : 0L;</span>

        if (DEBUG) {
            System.out.println(&quot;** lifetime reset to &quot; + timeout);
        }
<span class="fc" id="L439">    }</span>

    // it is a heavyweight method.
    public synchronized void accept(CacheVisitor&lt;K,V&gt; visitor) {
<span class="fc" id="L443">        expungeExpiredEntries();</span>
<span class="fc" id="L444">        Map&lt;K,V&gt; cached = getCachedEntries();</span>

<span class="fc" id="L446">        visitor.visit(cached);</span>
<span class="fc" id="L447">    }</span>

    private Map&lt;K,V&gt; getCachedEntries() {
<span class="fc" id="L450">        Map&lt;K,V&gt; kvmap = new HashMap&lt;&gt;(cacheMap.size());</span>

<span class="fc bfc" id="L452" title="All 2 branches covered.">        for (CacheEntry&lt;K,V&gt; entry : cacheMap.values()) {</span>
<span class="fc" id="L453">            kvmap.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L454">        }</span>

<span class="fc" id="L456">        return kvmap;</span>
    }

    protected CacheEntry&lt;K,V&gt; newEntry(K key, V value,
            long expirationTime, ReferenceQueue&lt;V&gt; queue) {
<span class="fc bfc" id="L461" title="All 2 branches covered.">        if (queue != null) {</span>
<span class="fc" id="L462">            return new SoftCacheEntry&lt;&gt;(key, value, expirationTime, queue);</span>
        } else {
<span class="fc" id="L464">            return new HardCacheEntry&lt;&gt;(key, value, expirationTime);</span>
        }
    }

    private static interface CacheEntry&lt;K,V&gt; {

        boolean isValid(long currentTime);

        void invalidate();

        K getKey();

        V getValue();

    }

    private static class HardCacheEntry&lt;K,V&gt; implements CacheEntry&lt;K,V&gt; {

        private K key;
        private V value;
        private long expirationTime;

<span class="fc" id="L486">        HardCacheEntry(K key, V value, long expirationTime) {</span>
<span class="fc" id="L487">            this.key = key;</span>
<span class="fc" id="L488">            this.value = value;</span>
<span class="fc" id="L489">            this.expirationTime = expirationTime;</span>
<span class="fc" id="L490">        }</span>

        public K getKey() {
<span class="nc" id="L493">            return key;</span>
        }

        public V getValue() {
<span class="fc" id="L497">            return value;</span>
        }

        public boolean isValid(long currentTime) {
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">            boolean valid = (currentTime &lt;= expirationTime);</span>
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">            if (valid == false) {</span>
<span class="nc" id="L503">                invalidate();</span>
            }
<span class="fc" id="L505">            return valid;</span>
        }

        public void invalidate() {
<span class="fc" id="L509">            key = null;</span>
<span class="fc" id="L510">            value = null;</span>
<span class="fc" id="L511">            expirationTime = -1;</span>
<span class="fc" id="L512">        }</span>
    }

    private static class SoftCacheEntry&lt;K,V&gt;
            extends SoftReference&lt;V&gt;
            implements CacheEntry&lt;K,V&gt; {

        private K key;
        private long expirationTime;

        SoftCacheEntry(K key, V value, long expirationTime,
                ReferenceQueue&lt;V&gt; queue) {
<span class="fc" id="L524">            super(value, queue);</span>
<span class="fc" id="L525">            this.key = key;</span>
<span class="fc" id="L526">            this.expirationTime = expirationTime;</span>
<span class="fc" id="L527">        }</span>

        public K getKey() {
<span class="fc" id="L530">            return key;</span>
        }

        public V getValue() {
<span class="fc" id="L534">            return get();</span>
        }

        public boolean isValid(long currentTime) {
<span class="pc bpc" id="L538" title="2 of 4 branches missed.">            boolean valid = (currentTime &lt;= expirationTime) &amp;&amp; (get() != null);</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">            if (valid == false) {</span>
<span class="nc" id="L540">                invalidate();</span>
            }
<span class="fc" id="L542">            return valid;</span>
        }

        public void invalidate() {
<span class="fc" id="L546">            clear();</span>
<span class="fc" id="L547">            key = null;</span>
<span class="fc" id="L548">            expirationTime = -1;</span>
<span class="fc" id="L549">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>