<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ObjectIdentifier.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.util</a> &gt; <span class="el_source">ObjectIdentifier.java</span></div><h1>ObjectIdentifier.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.util;

import java.io.*;
import java.math.BigInteger;
import java.util.Arrays;

/**
 * Represent an ISO Object Identifier.
 *
 * &lt;P&gt;Object Identifiers are arbitrary length hierarchical identifiers.
 * The individual components are numbers, and they define paths from the
 * root of an ISO-managed identifier space.  You will sometimes see a
 * string name used instead of (or in addition to) the numerical id.
 * These are synonyms for the numerical IDs, but are not widely used
 * since most sites do not know all the requisite strings, while all
 * sites can parse the numeric forms.
 *
 * &lt;P&gt;So for example, JavaSoft has the sole authority to assign the
 * meaning to identifiers below the 1.3.6.1.4.1.42.2.17 node in the
 * hierarchy, and other organizations can easily acquire the ability
 * to assign such unique identifiers.
 *
 * @author David Brownell
 * @author Amit Kapoor
 * @author Hemma Prafullchandra
 */

<span class="fc bfc" id="L53" title="All 2 branches covered.">final public</span>
class ObjectIdentifier implements Serializable
{
    /**
     * We use the DER value (no tag, no length) as the internal format
     * @serial
     */
<span class="fc" id="L60">    private byte[] encoding = null;</span>

    private transient volatile String stringForm;

    /*
     * IMPORTANT NOTES FOR CODE CHANGES (bug 4811968) IN JDK 1.7.0
     * ===========================================================
     *
     * (Almost) serialization compatibility with old versions:
     *
     * serialVersionUID is unchanged. Old field &quot;component&quot; is changed to
     * type Object so that &quot;poison&quot; (unknown object type for old versions)
     * can be put inside if there are huge components that cannot be saved
     * as integers.
     *
     * New version use the new filed &quot;encoding&quot; only.
     *
     * Below are all 4 cases in a serialization/deserialization process:
     *
     * 1. old -&gt; old: Not covered here
     * 2. old -&gt; new: There's no &quot;encoding&quot; field, new readObject() reads
     *    &quot;components&quot; and &quot;componentLen&quot; instead and inits correctly.
     * 3. new -&gt; new: &quot;encoding&quot; field exists, new readObject() uses it
     *    (ignoring the other 2 fields) and inits correctly.
     * 4. new -&gt; old: old readObject() only recognizes &quot;components&quot; and
     *    &quot;componentLen&quot; fields. If no huge components are involved, they
     *    are serialized as legal values and old object can init correctly.
     *    Otherwise, old object cannot recognize the form (component not int[])
     *    and throw a ClassNotFoundException at deserialization time.
     *
     * Therfore, for the first 3 cases, exact compatibility is preserved. In
     * the 4th case, non-huge OID is still supportable in old versions, while
     * huge OID is not.
     */
    private static final long serialVersionUID = 8697030238860181294L;

    /**
     * Changed to Object
     * @serial
     */
<span class="fc" id="L100">    private Object      components   = null;          // path from root</span>
    /**
     * @serial
     */
<span class="fc" id="L104">    private int         componentLen = -1;            // how much is used.</span>

    // Is the components field calculated?
<span class="fc" id="L107">    transient private boolean   componentsCalculated = false;</span>

    private void readObject(ObjectInputStream is)
            throws IOException, ClassNotFoundException {
<span class="nc" id="L111">        is.defaultReadObject();</span>

<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (encoding == null) {  // from an old version</span>
<span class="nc" id="L114">            init((int[])components, componentLen);</span>
        }
<span class="nc" id="L116">    }</span>

    private void writeObject(ObjectOutputStream os)
            throws IOException {
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (!componentsCalculated) {</span>
<span class="nc" id="L121">            int[] comps = toIntArray();</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (comps != null) {    // every one understands this</span>
<span class="nc" id="L123">                components = comps;</span>
<span class="nc" id="L124">                componentLen = comps.length;</span>
            } else {
<span class="nc" id="L126">                components = HugeOidNotSupportedByOldJDK.theOne;</span>
            }
<span class="nc" id="L128">            componentsCalculated = true;</span>
        }
<span class="nc" id="L130">        os.defaultWriteObject();</span>
<span class="nc" id="L131">    }</span>

<span class="nc" id="L133">    static class HugeOidNotSupportedByOldJDK implements Serializable {</span>
        private static final long serialVersionUID = 1L;
<span class="nc" id="L135">        static HugeOidNotSupportedByOldJDK theOne = new HugeOidNotSupportedByOldJDK();</span>
    }

    /**
     * Constructs, from a string.  This string should be of the form 1.23.56.
     * Validity check included.
     */
    public ObjectIdentifier (String oid) throws IOException
<span class="fc" id="L143">    {</span>
<span class="fc" id="L144">        int ch = '.';</span>
<span class="fc" id="L145">        int start = 0;</span>
<span class="fc" id="L146">        int end = 0;</span>

<span class="fc" id="L148">        int pos = 0;</span>
<span class="fc" id="L149">        byte[] tmp = new byte[oid.length()];</span>
<span class="fc" id="L150">        int first = 0, second;</span>
<span class="fc" id="L151">        int count = 0;</span>

        try {
<span class="fc" id="L154">            String comp = null;</span>
            do {
<span class="fc" id="L156">                int length = 0; // length of one section</span>
<span class="fc" id="L157">                end = oid.indexOf(ch,start);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">                if (end == -1) {</span>
<span class="fc" id="L159">                    comp = oid.substring(start);</span>
<span class="fc" id="L160">                    length = oid.length() - start;</span>
                } else {
<span class="fc" id="L162">                    comp = oid.substring(start,end);</span>
<span class="fc" id="L163">                    length = end - start;</span>
                }

<span class="pc bpc" id="L166" title="1 of 2 branches missed.">                if (length &gt; 9) {</span>
<span class="nc" id="L167">                    BigInteger bignum = new BigInteger(comp);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                    if (count == 0) {</span>
<span class="nc" id="L169">                        checkFirstComponent(bignum);</span>
<span class="nc" id="L170">                        first = bignum.intValue();</span>
                    } else {
<span class="nc bnc" id="L172" title="All 2 branches missed.">                        if (count == 1) {</span>
<span class="nc" id="L173">                            checkSecondComponent(first, bignum);</span>
<span class="nc" id="L174">                            bignum = bignum.add(BigInteger.valueOf(40*first));</span>
                        } else {
<span class="nc" id="L176">                            checkOtherComponent(count, bignum);</span>
                        }
<span class="nc" id="L178">                        pos += pack7Oid(bignum, tmp, pos);</span>
                    }
<span class="nc" id="L180">                } else {</span>
<span class="fc" id="L181">                    int num = Integer.parseInt(comp);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">                    if (count == 0) {</span>
<span class="fc" id="L183">                        checkFirstComponent(num);</span>
<span class="fc" id="L184">                        first = num;</span>
                    } else {
<span class="fc bfc" id="L186" title="All 2 branches covered.">                        if (count == 1) {</span>
<span class="fc" id="L187">                            checkSecondComponent(first, num);</span>
<span class="fc" id="L188">                            num += 40 * first;</span>
                        } else {
<span class="fc" id="L190">                            checkOtherComponent(count, num);</span>
                        }
<span class="fc" id="L192">                        pos += pack7Oid(num, tmp, pos);</span>
                    }
                }
<span class="fc" id="L195">                start = end + 1;</span>
<span class="fc" id="L196">                count++;</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">            } while (end != -1);</span>

<span class="fc" id="L199">            checkCount(count);</span>
<span class="fc" id="L200">            encoding = new byte[pos];</span>
<span class="fc" id="L201">            System.arraycopy(tmp, 0, encoding, 0, pos);</span>
<span class="fc" id="L202">            this.stringForm = oid;</span>
<span class="nc" id="L203">        } catch (IOException ioe) { // already detected by checkXXX</span>
<span class="nc" id="L204">            throw ioe;</span>
<span class="nc" id="L205">        } catch (Exception e) {</span>
<span class="nc" id="L206">            throw new IOException(&quot;ObjectIdentifier() -- Invalid format: &quot;</span>
<span class="nc" id="L207">                    + e.toString(), e);</span>
<span class="fc" id="L208">        }</span>
<span class="fc" id="L209">    }</span>

    /**
     * Constructor, from an array of integers.
     * Validity check included.
     */
    public ObjectIdentifier (int values []) throws IOException
<span class="fc" id="L216">    {</span>
<span class="fc" id="L217">        checkCount(values.length);</span>
<span class="fc" id="L218">        checkFirstComponent(values[0]);</span>
<span class="fc" id="L219">        checkSecondComponent(values[0], values[1]);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        for (int i=2; i&lt;values.length; i++)</span>
<span class="fc" id="L221">            checkOtherComponent(i, values[i]);</span>
<span class="fc" id="L222">        init(values, values.length);</span>
<span class="fc" id="L223">    }</span>

    /**
     * Constructor, from an ASN.1 encoded input stream.
     * Validity check NOT included.
     * The encoding of the ID in the stream uses &quot;DER&quot;, a BER/1 subset.
     * In this case, that means a triple { typeId, length, data }.
     *
     * &lt;P&gt;&lt;STRONG&gt;NOTE:&lt;/STRONG&gt;  When an exception is thrown, the
     * input stream has not been returned to its &quot;initial&quot; state.
     *
     * @param in DER-encoded data holding an object ID
     * @exception IOException indicates a decoding error
     */
    public ObjectIdentifier (DerInputStream in) throws IOException
<span class="fc" id="L238">    {</span>
        byte    type_id;
        int     bufferEnd;

        /*
         * Object IDs are a &quot;universal&quot; type, and their tag needs only
         * one byte of encoding.  Verify that the tag of this datum
         * is that of an object ID.
         *
         * Then get and check the length of the ID's encoding.  We set
         * up so that we can use in.available() to check for the end of
         * this value in the data stream.
         */
<span class="fc" id="L251">        type_id = (byte) in.getByte ();</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (type_id != DerValue.tag_ObjectId)</span>
<span class="fc" id="L253">            throw new IOException (</span>
                &quot;ObjectIdentifier() -- data isn't an object ID&quot;
                + &quot; (tag = &quot; +  type_id + &quot;)&quot;
                );

<span class="fc" id="L258">        encoding = new byte[in.getLength()];</span>
<span class="fc" id="L259">        in.getBytes(encoding);</span>
<span class="fc" id="L260">        check(encoding);</span>
<span class="fc" id="L261">    }</span>

    /*
     * Constructor, from the rest of a DER input buffer;
     * the tag and length have been removed/verified
     * Validity check NOT included.
     */
    ObjectIdentifier (DerInputBuffer buf) throws IOException
<span class="fc" id="L269">    {</span>
<span class="fc" id="L270">        DerInputStream in = new DerInputStream(buf);</span>
<span class="fc" id="L271">        encoding = new byte[in.available()];</span>
<span class="fc" id="L272">        in.getBytes(encoding);</span>
<span class="fc" id="L273">        check(encoding);</span>
<span class="fc" id="L274">    }</span>

    private void init(int[] components, int length) {
<span class="fc" id="L277">        int pos = 0;</span>
<span class="fc" id="L278">        byte[] tmp = new byte[length*5+1];  // +1 for empty input</span>

<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if (components[1] &lt; Integer.MAX_VALUE - components[0]*40)</span>
<span class="fc" id="L281">            pos += pack7Oid(components[0]*40+components[1], tmp, pos);</span>
        else {
<span class="nc" id="L283">            BigInteger big = BigInteger.valueOf(components[1]);</span>
<span class="nc" id="L284">            big = big.add(BigInteger.valueOf(components[0]*40));</span>
<span class="nc" id="L285">            pos += pack7Oid(big, tmp, pos);</span>
        }

<span class="fc bfc" id="L288" title="All 2 branches covered.">        for (int i=2; i&lt;length; i++) {</span>
<span class="fc" id="L289">            pos += pack7Oid(components[i], tmp, pos);</span>
        }
<span class="fc" id="L291">        encoding = new byte[pos];</span>
<span class="fc" id="L292">        System.arraycopy(tmp, 0, encoding, 0, pos);</span>
<span class="fc" id="L293">    }</span>

    /**
     * This method is kept for compatibility reasons. The new implementation
     * does the check and conversion. All around the JDK, the method is called
     * in static blocks to initialize pre-defined ObjectIdentifieies. No
     * obvious performance hurt will be made after this change.
     *
     * Old doc: Create a new ObjectIdentifier for internal use. The values are
     * neither checked nor cloned.
     */
    public static ObjectIdentifier newInternal(int[] values) {
        try {
<span class="fc" id="L306">            return new ObjectIdentifier(values);</span>
<span class="nc" id="L307">        } catch (IOException ex) {</span>
<span class="nc" id="L308">            throw new RuntimeException(ex);</span>
            // Should not happen, internal calls always uses legal values.
        }
    }

    /*
     * n.b. the only public interface is DerOutputStream.putOID()
     */
    void encode (DerOutputStream out) throws IOException
    {
<span class="fc" id="L318">        out.write (DerValue.tag_ObjectId, encoding);</span>
<span class="fc" id="L319">    }</span>

    /**
     * @deprecated Use equals((Object)oid)
     */
    @Deprecated
    public boolean equals(ObjectIdentifier other) {
<span class="nc" id="L326">        return equals((Object)other);</span>
    }

    /**
     * Compares this identifier with another, for equality.
     *
     * @return true iff the names are identical.
     */
    @Override
    public boolean equals(Object obj) {
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L337">            return true;</span>
        }
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        if (obj instanceof ObjectIdentifier == false) {</span>
<span class="nc" id="L340">            return false;</span>
        }
<span class="fc" id="L342">        ObjectIdentifier other = (ObjectIdentifier)obj;</span>
<span class="fc" id="L343">        return Arrays.equals(encoding, other.encoding);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L348">        return Arrays.hashCode(encoding);</span>
    }

    /**
     * Private helper method for serialization. To be compatible with old
     * versions of JDK.
     * @return components in an int array, if all the components are less than
     *         Integer.MAX_VALUE. Otherwise, null.
     */
    private int[] toIntArray() {
<span class="nc" id="L358">        int length = encoding.length;</span>
<span class="nc" id="L359">        int[] result = new int[20];</span>
<span class="nc" id="L360">        int which = 0;</span>
<span class="nc" id="L361">        int fromPos = 0;</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if ((encoding[i] &amp; 0x80) == 0) {</span>
                // one section [fromPos..i]
<span class="nc bnc" id="L365" title="All 2 branches missed.">                if (i - fromPos + 1 &gt; 4) {</span>
<span class="nc" id="L366">                    BigInteger big = new BigInteger(pack(encoding, fromPos, i-fromPos+1, 7, 8));</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                    if (fromPos == 0) {</span>
<span class="nc" id="L368">                        result[which++] = 2;</span>
<span class="nc" id="L369">                        BigInteger second = big.subtract(BigInteger.valueOf(80));</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                        if (second.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {</span>
<span class="nc" id="L371">                            return null;</span>
                        } else {
<span class="nc" id="L373">                            result[which++] = second.intValue();</span>
                        }
<span class="nc" id="L375">                    } else {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                        if (big.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {</span>
<span class="nc" id="L377">                            return null;</span>
                        } else {
<span class="nc" id="L379">                            result[which++] = big.intValue();</span>
                        }
                    }
<span class="nc" id="L382">                } else {</span>
<span class="nc" id="L383">                    int retval = 0;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">                    for (int j = fromPos; j &lt;= i; j++) {</span>
<span class="nc" id="L385">                        retval &lt;&lt;= 7;</span>
<span class="nc" id="L386">                        byte tmp = encoding[j];</span>
<span class="nc" id="L387">                        retval |= (tmp &amp; 0x07f);</span>
                    }
<span class="nc bnc" id="L389" title="All 2 branches missed.">                    if (fromPos == 0) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                        if (retval &lt; 80) {</span>
<span class="nc" id="L391">                            result[which++] = retval / 40;</span>
<span class="nc" id="L392">                            result[which++] = retval % 40;</span>
                        } else {
<span class="nc" id="L394">                            result[which++] = 2;</span>
<span class="nc" id="L395">                            result[which++] = retval - 80;</span>
                        }
                    } else {
<span class="nc" id="L398">                        result[which++] = retval;</span>
                    }
                }
<span class="nc" id="L401">                fromPos = i+1;</span>
            }
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (which &gt;= result.length) {</span>
<span class="nc" id="L404">                result = Arrays.copyOf(result, which + 10);</span>
            }
        }
<span class="nc" id="L407">        return Arrays.copyOf(result, which);</span>
    }

    /**
     * Returns a string form of the object ID.  The format is the
     * conventional &quot;dot&quot; notation for such IDs, without any
     * user-friendly descriptive strings, since those strings
     * will not be understood everywhere.
     */
    @Override
    public String toString() {
<span class="fc" id="L418">        String s = stringForm;</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        if (s == null) {</span>
<span class="fc" id="L420">            int length = encoding.length;</span>
<span class="fc" id="L421">            StringBuffer sb = new StringBuffer(length * 4);</span>

<span class="fc" id="L423">            int fromPos = 0;</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">            for (int i = 0; i &lt; length; i++) {</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">                if ((encoding[i] &amp; 0x80) == 0) {</span>
                    // one section [fromPos..i]
<span class="fc bfc" id="L427" title="All 2 branches covered.">                    if (fromPos != 0) {  // not the first segment</span>
<span class="fc" id="L428">                        sb.append('.');</span>
                    }
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">                    if (i - fromPos + 1 &gt; 4) { // maybe big integer</span>
<span class="nc" id="L431">                        BigInteger big = new BigInteger(pack(encoding, fromPos, i-fromPos+1, 7, 8));</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                        if (fromPos == 0) {</span>
                            // first section encoded with more than 4 bytes,
                            // must be 2.something
<span class="nc" id="L435">                            sb.append(&quot;2.&quot;);</span>
<span class="nc" id="L436">                            sb.append(big.subtract(BigInteger.valueOf(80)));</span>
                        } else {
<span class="nc" id="L438">                            sb.append(big);</span>
                        }
<span class="nc" id="L440">                    } else { // small integer</span>
<span class="fc" id="L441">                        int retval = 0;</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">                        for (int j = fromPos; j &lt;= i; j++) {</span>
<span class="fc" id="L443">                            retval &lt;&lt;= 7;</span>
<span class="fc" id="L444">                            byte tmp = encoding[j];</span>
<span class="fc" id="L445">                            retval |= (tmp &amp; 0x07f);</span>
                        }
<span class="fc bfc" id="L447" title="All 2 branches covered.">                        if (fromPos == 0) {</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">                            if (retval &lt; 80) {</span>
<span class="fc" id="L449">                                sb.append(retval/40);</span>
<span class="fc" id="L450">                                sb.append('.');</span>
<span class="fc" id="L451">                                sb.append(retval%40);</span>
                            } else {
<span class="fc" id="L453">                                sb.append(&quot;2.&quot;);</span>
<span class="fc" id="L454">                                sb.append(retval - 80);</span>
                            }
                        } else {
<span class="fc" id="L457">                            sb.append(retval);</span>
                        }
                    }
<span class="fc" id="L460">                    fromPos = i+1;</span>
                }
            }
<span class="fc" id="L463">            s = sb.toString();</span>
<span class="fc" id="L464">            stringForm = s;</span>
        }
<span class="fc" id="L466">        return s;</span>
    }

    /**
     * Repack all bits from input to output. On the both sides, only a portion
     * (from the least significant bit) of the 8 bits in a byte is used. This
     * number is defined as the number of useful bits (NUB) for the array. All the
     * used bits from the input byte array and repacked into the output in the
     * exactly same order. The output bits are aligned so that the final bit of
     * the input (the least significant bit in the last byte), when repacked as
     * the final bit of the output, is still at the least significant position.
     * Zeroes will be padded on the left side of the first output byte if
     * necessary. All unused bits in the output are also zeroed.
     *
     * For example: if the input is 01001100 with NUB 8, the output which
     * has a NUB 6 will look like:
     *      00000001 00001100
     * The first 2 bits of the output bytes are unused bits. The other bits
     * turn out to be 000001 001100. While the 8 bits on the right are from
     * the input, the left 4 zeroes are padded to fill the 6 bits space.
     *
     * @param in        the input byte array
     * @param ioffset   start point inside &lt;code&gt;in&lt;/code&gt;
     * @param ilength   number of bytes to repack
     * @param iw        NUB for input
     * @param ow        NUB for output
     * @return          the repacked bytes
     */
    private static byte[] pack(byte[] in, int ioffset, int ilength, int iw, int ow) {
<span class="pc bpc" id="L495" title="2 of 6 branches missed.">        assert (iw &gt; 0 &amp;&amp; iw &lt;= 8): &quot;input NUB must be between 1 and 8&quot;;</span>
<span class="pc bpc" id="L496" title="2 of 6 branches missed.">        assert (ow &gt; 0 &amp;&amp; ow &lt;= 8): &quot;output NUB must be between 1 and 8&quot;;</span>

<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if (iw == ow) {</span>
<span class="nc" id="L499">            return in.clone();</span>
        }

<span class="fc" id="L502">        int bits = ilength * iw;    // number of all used bits</span>
<span class="fc" id="L503">        byte[] out = new byte[(bits+ow-1)/ow];</span>

        // starting from the 0th bit in the input
<span class="fc" id="L506">        int ipos = 0;</span>

        // the number of padding 0's needed in the output, skip them
<span class="fc" id="L509">        int opos = (bits+ow-1)/ow*ow-bits;</span>

<span class="fc bfc" id="L511" title="All 2 branches covered.">        while(ipos &lt; bits) {</span>
<span class="fc" id="L512">            int count = iw - ipos%iw;   // unpacked bits in current input byte</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">            if (count &gt; ow - opos%ow) { // free space available in output byte</span>
<span class="fc" id="L514">                count = ow - opos%ow;   // choose the smaller number</span>
            }
            // and move them!
<span class="fc" id="L517">            out[opos/ow] |=                         // paste!</span>
                (((in[ioffset+ipos/iw]+256)         // locate the byte (+256 so that it's never negative)
                    &gt;&gt; (iw-ipos%iw-count))          // move to the end of a byte
                        &amp; ((1 &lt;&lt; (count))-1))       // zero out all other bits
                            &lt;&lt; (ow-opos%ow-count);  // move to the output position
<span class="fc" id="L522">            ipos += count;  // advance</span>
<span class="fc" id="L523">            opos += count;  // advance</span>
<span class="fc" id="L524">        }</span>
<span class="fc" id="L525">        return out;</span>
    }

    /**
     * Repack from NUB 8 to a NUB 7 OID sub-identifier, remove all
     * unnecessary 0 headings, set the first bit of all non-tail
     * output bytes to 1 (as ITU-T Rec. X.690 8.19.2 says), and
     * paste it into an existing byte array.
     * @param out the existing array to be pasted into
     * @param ooffset the starting position to paste
     * @return the number of bytes pasted
     */
    private static int pack7Oid(byte[] in, int ioffset, int ilength, byte[] out, int ooffset) {
<span class="fc" id="L538">        byte[] pack = pack(in, ioffset, ilength, 8, 7);</span>
<span class="fc" id="L539">        int firstNonZero = pack.length-1;   // paste at least one byte</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">        for (int i=pack.length-2; i&gt;=0; i--) {</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">            if (pack[i] != 0) {</span>
<span class="fc" id="L542">                firstNonZero = i;</span>
            }
<span class="fc" id="L544">            pack[i] |= 0x80;</span>
        }
<span class="fc" id="L546">        System.arraycopy(pack, firstNonZero, out, ooffset, pack.length-firstNonZero);</span>
<span class="fc" id="L547">        return pack.length-firstNonZero;</span>
    }

    /**
     * Repack from NUB 7 to NUB 8, remove all unnecessary 0
     * headings, and paste it into an existing byte array.
     * @param out the existing array to be pasted into
     * @param ooffset the starting position to paste
     * @return the number of bytes pasted
     */
    private static int pack8(byte[] in, int ioffset, int ilength, byte[] out, int ooffset) {
<span class="nc" id="L558">        byte[] pack = pack(in, ioffset, ilength, 7, 8);</span>
<span class="nc" id="L559">        int firstNonZero = pack.length-1;   // paste at least one byte</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">        for (int i=pack.length-2; i&gt;=0; i--) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">            if (pack[i] != 0) {</span>
<span class="nc" id="L562">                firstNonZero = i;</span>
            }
        }
<span class="nc" id="L565">        System.arraycopy(pack, firstNonZero, out, ooffset, pack.length-firstNonZero);</span>
<span class="nc" id="L566">        return pack.length-firstNonZero;</span>
    }

    /**
     * Pack the int into a OID sub-identifier DER encoding
     */
    private static int pack7Oid(int input, byte[] out, int ooffset) {
<span class="fc" id="L573">        byte[] b = new byte[4];</span>
<span class="fc" id="L574">        b[0] = (byte)(input &gt;&gt; 24);</span>
<span class="fc" id="L575">        b[1] = (byte)(input &gt;&gt; 16);</span>
<span class="fc" id="L576">        b[2] = (byte)(input &gt;&gt; 8);</span>
<span class="fc" id="L577">        b[3] = (byte)(input);</span>
<span class="fc" id="L578">        return pack7Oid(b, 0, 4, out, ooffset);</span>
    }

    /**
     * Pack the BigInteger into a OID subidentifier DER encoding
     */
    private static int pack7Oid(BigInteger input, byte[] out, int ooffset) {
<span class="nc" id="L585">        byte[] b = input.toByteArray();</span>
<span class="nc" id="L586">        return pack7Oid(b, 0, b.length, out, ooffset);</span>
    }

    /**
     * Private methods to check validity of OID. They must be --
     * 1. at least 2 components
     * 2. all components must be non-negative
     * 3. the first must be 0, 1 or 2
     * 4. if the first is 0 or 1, the second must be &lt;40
     */

    /**
     * Check the DER encoding. Since DER encoding defines that the integer bits
     * are unsigned, so there's no need to check the MSB.
     */
    private static void check(byte[] encoding) throws IOException {
<span class="fc" id="L602">        int length = encoding.length;</span>
<span class="pc bpc" id="L603" title="2 of 4 branches missed.">        if (length &lt; 1 ||      // too short</span>
                (encoding[length - 1] &amp; 0x80) != 0) {  // not ended
<span class="nc" id="L605">            throw new IOException(&quot;ObjectIdentifier() -- &quot; +</span>
                    &quot;Invalid DER encoding, not ended&quot;);
        }
<span class="fc bfc" id="L608" title="All 2 branches covered.">        for (int i=0; i&lt;length; i++) {</span>
            // 0x80 at the beginning of a subidentifier
<span class="pc bpc" id="L610" title="5 of 6 branches missed.">            if (encoding[i] == (byte)0x80 &amp;&amp;</span>
                    (i==0 || (encoding[i-1] &amp; 0x80) == 0)) {
<span class="nc" id="L612">                throw new IOException(&quot;ObjectIdentifier() -- &quot; +</span>
                        &quot;Invalid DER encoding, useless extra octet detected&quot;);
            }
        }
<span class="fc" id="L616">    }</span>
    private static void checkCount(int count) throws IOException {
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">        if (count &lt; 2) {</span>
<span class="nc" id="L619">            throw new IOException(&quot;ObjectIdentifier() -- &quot; +</span>
                    &quot;Must be at least two oid components &quot;);
        }
<span class="fc" id="L622">    }</span>
    private static void checkFirstComponent(int first) throws IOException {
<span class="pc bpc" id="L624" title="2 of 4 branches missed.">        if (first &lt; 0 || first &gt; 2) {</span>
<span class="nc" id="L625">            throw new IOException(&quot;ObjectIdentifier() -- &quot; +</span>
                    &quot;First oid component is invalid &quot;);
        }
<span class="fc" id="L628">    }</span>
    private static void checkFirstComponent(BigInteger first) throws IOException {
<span class="nc bnc" id="L630" title="All 2 branches missed.">        if (first.signum() == -1 ||</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                first.compareTo(BigInteger.valueOf(2)) == 1) {</span>
<span class="nc" id="L632">            throw new IOException(&quot;ObjectIdentifier() -- &quot; +</span>
                    &quot;First oid component is invalid &quot;);
        }
<span class="nc" id="L635">    }</span>
    private static void checkSecondComponent(int first, int second) throws IOException {
<span class="pc bpc" id="L637" title="2 of 6 branches missed.">        if (second &lt; 0 || first != 2 &amp;&amp; second &gt; 39) {</span>
<span class="nc" id="L638">            throw new IOException(&quot;ObjectIdentifier() -- &quot; +</span>
                    &quot;Second oid component is invalid &quot;);
        }
<span class="fc" id="L641">    }</span>
    private static void checkSecondComponent(int first, BigInteger second) throws IOException {
<span class="nc bnc" id="L643" title="All 4 branches missed.">        if (second.signum() == -1 ||</span>
                first != 2 &amp;&amp;
<span class="nc bnc" id="L645" title="All 2 branches missed.">                second.compareTo(BigInteger.valueOf(39)) == 1) {</span>
<span class="nc" id="L646">            throw new IOException(&quot;ObjectIdentifier() -- &quot; +</span>
                    &quot;Second oid component is invalid &quot;);
        }
<span class="nc" id="L649">    }</span>
    private static void checkOtherComponent(int i, int num) throws IOException {
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">        if (num &lt; 0) {</span>
<span class="nc" id="L652">            throw new IOException(&quot;ObjectIdentifier() -- &quot; +</span>
                    &quot;oid component #&quot; + (i+1) + &quot; must be non-negative &quot;);
        }
<span class="fc" id="L655">    }</span>
    private static void checkOtherComponent(int i, BigInteger num) throws IOException {
<span class="nc bnc" id="L657" title="All 2 branches missed.">        if (num.signum() == -1) {</span>
<span class="nc" id="L658">            throw new IOException(&quot;ObjectIdentifier() -- &quot; +</span>
                    &quot;oid component #&quot; + (i+1) + &quot; must be non-negative &quot;);
        }
<span class="nc" id="L661">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>