<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DerOutputStream.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.util</a> &gt; <span class="el_source">DerOutputStream.java</span></div><h1>DerOutputStream.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.util;

import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.util.Comparator;
import java.util.Arrays;
import java.math.BigInteger;
import java.util.Locale;


/**
 * Output stream marshaling DER-encoded data.  This is eventually provided
 * in the form of a byte array; there is no advance limit on the size of
 * that byte array.
 *
 * &lt;P&gt;At this time, this class supports only a subset of the types of
 * DER data encodings which are defined.  That subset is sufficient for
 * generating most X.509 certificates.
 *
 *
 * @author David Brownell
 * @author Amit Kapoor
 * @author Hemma Prafullchandra
 */
public class DerOutputStream
extends ByteArrayOutputStream implements DerEncoder {
    /**
     * Construct an DER output stream.
     *
     * @param size how large a buffer to preallocate.
     */
<span class="fc" id="L61">    public DerOutputStream(int size) { super(size); }</span>

    /**
     * Construct an DER output stream.
     */
<span class="fc" id="L66">    public DerOutputStream() { }</span>

    /**
     * Writes tagged, pre-marshaled data.  This calcuates and encodes
     * the length, so that the output data is the standard triple of
     * { tag, length, data } used by all DER values.
     *
     * @param tag the DER value tag for the data, such as
     *          &lt;em&gt;DerValue.tag_Sequence&lt;/em&gt;
     * @param buf buffered data, which must be DER-encoded
     */
    public void write(byte tag, byte[] buf) throws IOException {
<span class="fc" id="L78">        write(tag);</span>
<span class="fc" id="L79">        putLength(buf.length);</span>
<span class="fc" id="L80">        write(buf, 0, buf.length);</span>
<span class="fc" id="L81">    }</span>

    /**
     * Writes tagged data using buffer-to-buffer copy.  As above,
     * this writes a standard DER record.  This is often used when
     * efficiently encapsulating values in sequences.
     *
     * @param tag the DER value tag for the data, such as
     *          &lt;em&gt;DerValue.tag_Sequence&lt;/em&gt;
     * @param out buffered data
     */
    public void write(byte tag, DerOutputStream out) throws IOException {
<span class="fc" id="L93">        write(tag);</span>
<span class="fc" id="L94">        putLength(out.count);</span>
<span class="fc" id="L95">        write(out.buf, 0, out.count);</span>
<span class="fc" id="L96">    }</span>

    /**
     * Writes implicitly tagged data using buffer-to-buffer copy.  As above,
     * this writes a standard DER record.  This is often used when
     * efficiently encapsulating implicitly tagged values.
     *
     * @param tag the DER value of the context-specific tag that replaces
     * original tag of the value in the output, such as in
     * &lt;pre&gt;
     *          &lt;em&gt; &lt;field&gt; [N] IMPLICIT &lt;type&gt;&lt;/em&gt;
     * &lt;/pre&gt;
     * For example, &lt;em&gt;JDKLength [1] IMPLICIT INTEGER&lt;/em&gt;, with value=4;
     * would be encoded as &quot;81 01 04&quot;  whereas in explicit
     * tagging it would be encoded as &quot;A1 03 02 01 04&quot;.
     * Notice that the tag is A1 and not 81, this is because with
     * explicit tagging the form is always constructed.
     * @param value original value being implicitly tagged
     */
    public void writeImplicit(byte tag, DerOutputStream value)
    throws IOException {
<span class="nc" id="L117">        write(tag);</span>
<span class="nc" id="L118">        write(value.buf, 1, value.count-1);</span>
<span class="nc" id="L119">    }</span>

    /**
     * Marshals pre-encoded DER value onto the output stream.
     */
    public void putDerValue(DerValue val) throws IOException {
<span class="fc" id="L125">        val.encode(this);</span>
<span class="fc" id="L126">    }</span>

    /*
     * PRIMITIVES -- these are &quot;universal&quot; ASN.1 simple types.
     *
     *  BOOLEAN, INTEGER, BIT STRING, OCTET STRING, NULL
     *  OBJECT IDENTIFIER, SEQUENCE(OF), SET(OF)
     *  PrintableString, T61String, IA5String, UTCTime
     */

    /**
     * Marshals a DER boolean on the output stream.
     */
    public void putBoolean(boolean val) throws IOException {
<span class="nc" id="L140">        write(DerValue.tag_Boolean);</span>
<span class="nc" id="L141">        putLength(1);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (val) {</span>
<span class="nc" id="L143">            write(0xff);</span>
        } else {
<span class="nc" id="L145">            write(0);</span>
        }
<span class="nc" id="L147">    }</span>

    /**
     * Marshals a DER enumerated on the output stream.
     * @param i the enumerated value.
     */
    public void putEnumerated(int i) throws IOException {
<span class="fc" id="L154">        write(DerValue.tag_Enumerated);</span>
<span class="fc" id="L155">        putIntegerContents(i);</span>
<span class="fc" id="L156">    }</span>

    /**
     * Marshals a DER integer on the output stream.
     *
     * @param i the integer in the form of a BigInteger.
     */
    public void putInteger(BigInteger i) throws IOException {
<span class="fc" id="L164">        write(DerValue.tag_Integer);</span>
<span class="fc" id="L165">        byte[]    buf = i.toByteArray(); // least number  of bytes</span>
<span class="fc" id="L166">        putLength(buf.length);</span>
<span class="fc" id="L167">        write(buf, 0, buf.length);</span>
<span class="fc" id="L168">    }</span>

    /**
     * Marshals a DER integer on the output stream.
     * @param i the integer in the form of an Integer.
     */
    public void putInteger(Integer i) throws IOException {
<span class="nc" id="L175">        putInteger(i.intValue());</span>
<span class="nc" id="L176">    }</span>

    /**
     * Marshals a DER integer on the output stream.
     * @param i the integer.
     */
    public void putInteger(int i) throws IOException {
<span class="fc" id="L183">        write(DerValue.tag_Integer);</span>
<span class="fc" id="L184">        putIntegerContents(i);</span>
<span class="fc" id="L185">    }</span>

    private void putIntegerContents(int i) throws IOException {

<span class="fc" id="L189">        byte[] bytes = new byte[4];</span>
<span class="fc" id="L190">        int start = 0;</span>

        // Obtain the four bytes of the int

<span class="fc" id="L194">        bytes[3] = (byte) (i &amp; 0xff);</span>
<span class="fc" id="L195">        bytes[2] = (byte)((i &amp; 0xff00) &gt;&gt;&gt; 8);</span>
<span class="fc" id="L196">        bytes[1] = (byte)((i &amp; 0xff0000) &gt;&gt;&gt; 16);</span>
<span class="fc" id="L197">        bytes[0] = (byte)((i &amp; 0xff000000) &gt;&gt;&gt; 24);</span>

        // Reduce them to the least number of bytes needed to
        // represent this int

<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (bytes[0] == (byte)0xff) {</span>

            // Eliminate redundant 0xff

<span class="nc bnc" id="L206" title="All 2 branches missed.">            for (int j = 0; j &lt; 3; j++) {</span>
<span class="nc bnc" id="L207" title="All 4 branches missed.">                if ((bytes[j] == (byte)0xff) &amp;&amp;</span>
                    ((bytes[j+1] &amp; 0x80) == 0x80))
<span class="nc" id="L209">                    start++;</span>
                else
                    break;
             }
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">         } else if (bytes[0] == 0x00) {</span>

             // Eliminate redundant 0x00

<span class="fc bfc" id="L217" title="All 2 branches covered.">            for (int j = 0; j &lt; 3; j++) {</span>
<span class="pc bpc" id="L218" title="1 of 4 branches missed.">                if ((bytes[j] == 0x00) &amp;&amp;</span>
                    ((bytes[j+1] &amp; 0x80) == 0))
<span class="fc" id="L220">                    start++;</span>
                else
                    break;
            }
        }

<span class="fc" id="L226">        putLength(4 - start);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (int k = start; k &lt; 4; k++)</span>
<span class="fc" id="L228">            write(bytes[k]);</span>
<span class="fc" id="L229">    }</span>

    /**
     * Marshals a DER bit string on the output stream. The bit
     * string must be byte-aligned.
     *
     * @param bits the bit string, MSB first
     */
    public void putBitString(byte[] bits) throws IOException {
<span class="fc" id="L238">        write(DerValue.tag_BitString);</span>
<span class="fc" id="L239">        putLength(bits.length + 1);</span>
<span class="fc" id="L240">        write(0);               // all of last octet is used</span>
<span class="fc" id="L241">        write(bits);</span>
<span class="fc" id="L242">    }</span>

    /**
     * Marshals a DER bit string on the output stream.
     * The bit strings need not be byte-aligned.
     *
     * @param bits the bit string, MSB first
     */
    public void putUnalignedBitString(BitArray ba) throws IOException {
<span class="fc" id="L251">        byte[] bits = ba.toByteArray();</span>

<span class="fc" id="L253">        write(DerValue.tag_BitString);</span>
<span class="fc" id="L254">        putLength(bits.length + 1);</span>
<span class="fc" id="L255">        write(bits.length*8 - ba.length()); // excess bits in last octet</span>
<span class="fc" id="L256">        write(bits);</span>
<span class="fc" id="L257">    }</span>

    /**
     * Marshals a truncated DER bit string on the output stream.
     * The bit strings need not be byte-aligned.
     *
     * @param bits the bit string, MSB first
     */
    public void putTruncatedUnalignedBitString(BitArray ba) throws IOException {
<span class="fc" id="L266">        putUnalignedBitString(ba.truncate());</span>
<span class="fc" id="L267">    }</span>

    /**
     * DER-encodes an ASN.1 OCTET STRING value on the output stream.
     *
     * @param octets the octet string
     */
    public void putOctetString(byte[] octets) throws IOException {
<span class="fc" id="L275">        write(DerValue.tag_OctetString, octets);</span>
<span class="fc" id="L276">    }</span>

    /**
     * Marshals a DER &quot;null&quot; value on the output stream.  These are
     * often used to indicate optional values which have been omitted.
     */
    public void putNull() throws IOException {
<span class="fc" id="L283">        write(DerValue.tag_Null);</span>
<span class="fc" id="L284">        putLength(0);</span>
<span class="fc" id="L285">    }</span>

    /**
     * Marshals an object identifier (OID) on the output stream.
     * Corresponds to the ASN.1 &quot;OBJECT IDENTIFIER&quot; construct.
     */
    public void putOID(ObjectIdentifier oid) throws IOException {
<span class="fc" id="L292">        oid.encode(this);</span>
<span class="fc" id="L293">    }</span>

    /**
     * Marshals a sequence on the output stream.  This supports both
     * the ASN.1 &quot;SEQUENCE&quot; (zero to N values) and &quot;SEQUENCE OF&quot;
     * (one to N values) constructs.
     */
    public void putSequence(DerValue[] seq) throws IOException {
<span class="fc" id="L301">        DerOutputStream bytes = new DerOutputStream();</span>
        int i;

<span class="fc bfc" id="L304" title="All 2 branches covered.">        for (i = 0; i &lt; seq.length; i++)</span>
<span class="fc" id="L305">            seq[i].encode(bytes);</span>

<span class="fc" id="L307">        write(DerValue.tag_Sequence, bytes);</span>
<span class="fc" id="L308">    }</span>

    /**
     * Marshals the contents of a set on the output stream without
     * ordering the elements.  Ok for BER encoding, but not for DER
     * encoding.
     *
     * For DER encoding, use orderedPutSet() or orderedPutSetOf().
     */
    public void putSet(DerValue[] set) throws IOException {
<span class="nc" id="L318">        DerOutputStream bytes = new DerOutputStream();</span>
        int i;

<span class="nc bnc" id="L321" title="All 2 branches missed.">        for (i = 0; i &lt; set.length; i++)</span>
<span class="nc" id="L322">            set[i].encode(bytes);</span>

<span class="nc" id="L324">        write(DerValue.tag_Set, bytes);</span>
<span class="nc" id="L325">    }</span>

    /**
     * Marshals the contents of a set on the output stream.  Sets
     * are semantically unordered, but DER requires that encodings of
     * set elements be sorted into ascending lexicographical order
     * before being output.  Hence sets with the same tags and
     * elements have the same DER encoding.
     *
     * This method supports the ASN.1 &quot;SET OF&quot; construct, but not
     * &quot;SET&quot;, which uses a different order.
     */
    public void putOrderedSetOf(byte tag, DerEncoder[] set) throws IOException {
<span class="fc" id="L338">        putOrderedSet(tag, set, lexOrder);</span>
<span class="fc" id="L339">    }</span>

    /**
     * Marshals the contents of a set on the output stream.  Sets
     * are semantically unordered, but DER requires that encodings of
     * set elements be sorted into ascending tag order
     * before being output.  Hence sets with the same tags and
     * elements have the same DER encoding.
     *
     * This method supports the ASN.1 &quot;SET&quot; construct, but not
     * &quot;SET OF&quot;, which uses a different order.
     */
    public void putOrderedSet(byte tag, DerEncoder[] set) throws IOException {
<span class="nc" id="L352">        putOrderedSet(tag, set, tagOrder);</span>
<span class="nc" id="L353">    }</span>

    /**
     *  Lexicographical order comparison on byte arrays, for ordering
     *  elements of a SET OF objects in DER encoding.
     */
<span class="fc" id="L359">    private static ByteArrayLexOrder lexOrder = new ByteArrayLexOrder();</span>

    /**
     *  Tag order comparison on byte arrays, for ordering elements of
     *  SET objects in DER encoding.
     */
<span class="fc" id="L365">    private static ByteArrayTagOrder tagOrder = new ByteArrayTagOrder();</span>

    /**
     * Marshals a the contents of a set on the output stream with the
     * encodings of its sorted in increasing order.
     *
     * @param order the order to use when sorting encodings of components.
     */
    private void putOrderedSet(byte tag, DerEncoder[] set,
                               Comparator&lt;byte[]&gt; order) throws IOException {
<span class="fc" id="L375">        DerOutputStream[] streams = new DerOutputStream[set.length];</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">        for (int i = 0; i &lt; set.length; i++) {</span>
<span class="fc" id="L378">            streams[i] = new DerOutputStream();</span>
<span class="fc" id="L379">            set[i].derEncode(streams[i]);</span>
        }

        // order the element encodings
<span class="fc" id="L383">        byte[][] bufs = new byte[streams.length][];</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        for (int i = 0; i &lt; streams.length; i++) {</span>
<span class="fc" id="L385">            bufs[i] = streams[i].toByteArray();</span>
        }
<span class="fc" id="L387">        Arrays.&lt;byte[]&gt;sort(bufs, order);</span>

<span class="fc" id="L389">        DerOutputStream bytes = new DerOutputStream();</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">        for (int i = 0; i &lt; streams.length; i++) {</span>
<span class="fc" id="L391">            bytes.write(bufs[i]);</span>
        }
<span class="fc" id="L393">        write(tag, bytes);</span>

<span class="fc" id="L395">    }</span>

    /**
     * Marshals a string as a DER encoded UTF8String.
     */
    public void putUTF8String(String s) throws IOException {
<span class="nc" id="L401">        writeString(s, DerValue.tag_UTF8String, &quot;UTF8&quot;);</span>
<span class="nc" id="L402">    }</span>

    /**
     * Marshals a string as a DER encoded PrintableString.
     */
    public void putPrintableString(String s) throws IOException {
<span class="nc" id="L408">        writeString(s, DerValue.tag_PrintableString, &quot;ASCII&quot;);</span>
<span class="nc" id="L409">    }</span>

    /**
     * Marshals a string as a DER encoded T61String.
     */
    public void putT61String(String s) throws IOException {
        /*
         * Works for characters that are defined in both ASCII and
         * T61.
         */
<span class="nc" id="L419">        writeString(s, DerValue.tag_T61String, &quot;ISO-8859-1&quot;);</span>
<span class="nc" id="L420">    }</span>

    /**
     * Marshals a string as a DER encoded IA5String.
     */
    public void putIA5String(String s) throws IOException {
<span class="nc" id="L426">        writeString(s, DerValue.tag_IA5String, &quot;ASCII&quot;);</span>
<span class="nc" id="L427">    }</span>

    /**
     * Marshals a string as a DER encoded BMPString.
     */
    public void putBMPString(String s) throws IOException {
<span class="nc" id="L433">        writeString(s, DerValue.tag_BMPString, &quot;UnicodeBigUnmarked&quot;);</span>
<span class="nc" id="L434">    }</span>

    /**
     * Marshals a string as a DER encoded GeneralString.
     */
    public void putGeneralString(String s) throws IOException {
<span class="nc" id="L440">        writeString(s, DerValue.tag_GeneralString, &quot;ASCII&quot;);</span>
<span class="nc" id="L441">    }</span>

    /**
     * Private helper routine for writing DER encoded string values.
     * @param s the string to write
     * @param stringTag one of the DER string tags that indicate which
     * encoding should be used to write the string out.
     * @param enc the name of the encoder that should be used corresponding
     * to the above tag.
     */
    private void writeString(String s, byte stringTag, String enc)
        throws IOException {

<span class="nc" id="L454">        byte[] data = s.getBytes(enc);</span>
<span class="nc" id="L455">        write(stringTag);</span>
<span class="nc" id="L456">        putLength(data.length);</span>
<span class="nc" id="L457">        write(data);</span>
<span class="nc" id="L458">    }</span>

    /**
     * Marshals a DER UTC time/date value.
     *
     * &lt;P&gt;YYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
     * and with seconds (even if seconds=0) as per RFC 3280.
     */
    public void putUTCTime(Date d) throws IOException {
<span class="fc" id="L467">        putTime(d, DerValue.tag_UtcTime);</span>
<span class="fc" id="L468">    }</span>

    /**
     * Marshals a DER Generalized Time/date value.
     *
     * &lt;P&gt;YYYYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
     * and with seconds (even if seconds=0) as per RFC 3280.
     */
    public void putGeneralizedTime(Date d) throws IOException {
<span class="fc" id="L477">        putTime(d, DerValue.tag_GeneralizedTime);</span>
<span class="fc" id="L478">    }</span>

    /**
     * Private helper routine for marshalling a DER UTC/Generalized
     * time/date value. If the tag specified is not that for UTC Time
     * then it defaults to Generalized Time.
     * @param d the date to be marshalled
     * @param tag the tag for UTC Time or Generalized Time
     */
    private void putTime(Date d, byte tag) throws IOException {

        /*
         * Format the date.
         */

<span class="fc" id="L493">        TimeZone tz = TimeZone.getTimeZone(&quot;GMT&quot;);</span>
<span class="fc" id="L494">        String pattern = null;</span>

<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (tag == DerValue.tag_UtcTime) {</span>
<span class="fc" id="L497">            pattern = &quot;yyMMddHHmmss'Z'&quot;;</span>
        } else {
<span class="fc" id="L499">            tag = DerValue.tag_GeneralizedTime;</span>
<span class="fc" id="L500">            pattern = &quot;yyyyMMddHHmmss'Z'&quot;;</span>
        }

<span class="fc" id="L503">        SimpleDateFormat sdf = new SimpleDateFormat(pattern, Locale.US);</span>
<span class="fc" id="L504">        sdf.setTimeZone(tz);</span>
<span class="fc" id="L505">        byte[] time = (sdf.format(d)).getBytes(&quot;ISO-8859-1&quot;);</span>

        /*
         * Write the formatted date.
         */

<span class="fc" id="L511">        write(tag);</span>
<span class="fc" id="L512">        putLength(time.length);</span>
<span class="fc" id="L513">        write(time);</span>
<span class="fc" id="L514">    }</span>

    /**
     * Put the encoding of the length in the stream.
     *
     * @params len the length of the attribute.
     * @exception IOException on writing errors.
     */
    public void putLength(int len) throws IOException {
<span class="fc bfc" id="L523" title="All 2 branches covered.">        if (len &lt; 128) {</span>
<span class="fc" id="L524">            write((byte)len);</span>

<span class="fc bfc" id="L526" title="All 2 branches covered.">        } else if (len &lt; (1 &lt;&lt; 8)) {</span>
<span class="fc" id="L527">            write((byte)0x081);</span>
<span class="fc" id="L528">            write((byte)len);</span>

<span class="fc bfc" id="L530" title="All 2 branches covered.">        } else if (len &lt; (1 &lt;&lt; 16)) {</span>
<span class="fc" id="L531">            write((byte)0x082);</span>
<span class="fc" id="L532">            write((byte)(len &gt;&gt; 8));</span>
<span class="fc" id="L533">            write((byte)len);</span>

<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        } else if (len &lt; (1 &lt;&lt; 24)) {</span>
<span class="nc" id="L536">            write((byte)0x083);</span>
<span class="nc" id="L537">            write((byte)(len &gt;&gt; 16));</span>
<span class="nc" id="L538">            write((byte)(len &gt;&gt; 8));</span>
<span class="nc" id="L539">            write((byte)len);</span>

        } else {
<span class="fc" id="L542">            write((byte)0x084);</span>
<span class="fc" id="L543">            write((byte)(len &gt;&gt; 24));</span>
<span class="fc" id="L544">            write((byte)(len &gt;&gt; 16));</span>
<span class="fc" id="L545">            write((byte)(len &gt;&gt; 8));</span>
<span class="fc" id="L546">            write((byte)len);</span>
        }
<span class="fc" id="L548">    }</span>

    /**
     * Put the tag of the attribute in the stream.
     *
     * @params class the tag class type, one of UNIVERSAL, CONTEXT,
     *                            APPLICATION or PRIVATE
     * @params form if true, the value is constructed, otherwise it is
     * primitive.
     * @params val the tag value
     */
    public void putTag(byte tagClass, boolean form, byte val) {
<span class="nc" id="L560">        byte tag = (byte)(tagClass | val);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (form) {</span>
<span class="nc" id="L562">            tag |= (byte)0x20;</span>
        }
<span class="nc" id="L564">        write(tag);</span>
<span class="nc" id="L565">    }</span>

    /**
     *  Write the current contents of this &lt;code&gt;DerOutputStream&lt;/code&gt;
     *  to an &lt;code&gt;OutputStream&lt;/code&gt;.
     *
     *  @exception IOException on output error.
     */
    public void derEncode(OutputStream out) throws IOException {
<span class="nc" id="L574">        out.write(toByteArray());</span>
<span class="nc" id="L575">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>