<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BatchParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.javac</a> &gt; <span class="el_source">BatchParser.java</span></div><h1>BatchParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.javac;

import sun.tools.java.*;
import sun.tools.tree.*;

import java.io.IOException;
import java.io.InputStream;
import java.util.Vector;
import java.util.Enumeration;

/**
 * Batch file parser, this needs more work.
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
@Deprecated
public
class BatchParser extends Parser {
    /**
     * The current package
     */
    protected Identifier pkg;

    /**
     * The current imports
     */
    protected Imports imports;

    /**
     * The classes defined in this file
     */
    protected Vector classes;


    /**
     * The current class
     */
    protected SourceClass sourceClass;

    /**
     * The toplevel environment
     */
    protected Environment toplevelEnv;

    /**
     * Create a batch file parser
     */
    public BatchParser(Environment env, InputStream in) throws IOException {
<span class="nc" id="L76">        super(env, in);</span>

<span class="nc" id="L78">        imports = new Imports(env);</span>
<span class="nc" id="L79">        classes = new Vector();</span>
<span class="nc" id="L80">        toplevelEnv = imports.newEnvironment(env);</span>
<span class="nc" id="L81">    }</span>

    /**
     * Package declaration
     */
    public void packageDeclaration(long where, IdentifierToken t) {
<span class="nc" id="L87">        Identifier nm = t.getName();</span>
        //System.out.println(&quot;package &quot; + nm);
<span class="nc bnc" id="L89" title="All 2 branches missed.">        if (pkg == null) {</span>
            // This code has been changed to pass an IdentifierToken,
            // rather than an Identifier, to setCurrentPackage().  Imports
            // now needs the location of the token.
<span class="nc" id="L93">            pkg = t.getName();</span>
<span class="nc" id="L94">            imports.setCurrentPackage(t);</span>
        } else {
<span class="nc" id="L96">            env.error(where, &quot;package.repeated&quot;);</span>
        }
<span class="nc" id="L98">    }</span>

    /**
     * Import class
     */
    public void importClass(long pos, IdentifierToken t) {
        //System.out.println(&quot;import class &quot; + t);
<span class="nc" id="L105">        imports.addClass(t);</span>
<span class="nc" id="L106">    }</span>

    /**
     * Import package
     */
    public void importPackage(long pos, IdentifierToken t) {
        //System.out.println(&quot;import package &quot; + t);
<span class="nc" id="L113">        imports.addPackage(t);</span>
<span class="nc" id="L114">    }</span>

    /**
     * Define class
     */
    public ClassDefinition beginClass(long where, String doc, int mod,
                                      IdentifierToken t,
                                      IdentifierToken sup,
                                      IdentifierToken interfaces[]) {

        // If this class is nested, the modifier bits set here will
        // be copied into the 'SourceMember' object for the inner class
        // created during the call to 'makeClassDefinition' below.
        // When writing the class file, we will look there for the
        // 'untransformed' modifiers.  The modifiers in the ClassDefinition
        // object will end up as the 'transformed' modifiers.  Note that
        // there are some bits set here that are not legal class modifiers
        // according to the JVMS, e.g., M_PRIVATE and M_STATIC.  These are
        // masked off while writing the class file, but are preserved in
        // the InnerClasses attributes.

<span class="nc" id="L135">        if (tracing) toplevelEnv.dtEnter(&quot;beginClass: &quot; + sourceClass);</span>

<span class="nc" id="L137">        SourceClass outerClass = sourceClass;</span>

<span class="nc bnc" id="L139" title="All 4 branches missed.">        if (outerClass == null &amp;&amp; pkg != null) {</span>
<span class="nc" id="L140">            t = new IdentifierToken(t.getWhere(),</span>
<span class="nc" id="L141">                                    Identifier.lookup(pkg, t.getName()));</span>
        }

        // The defaults for anonymous and local classes should be documented!

<span class="nc bnc" id="L146" title="All 2 branches missed.">        if ((mod &amp; M_ANONYMOUS) != 0) {</span>
<span class="nc" id="L147">            mod |= (M_FINAL | M_PRIVATE);</span>
        }
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if ((mod &amp; M_LOCAL) != 0) {</span>
<span class="nc" id="L150">            mod |= M_PRIVATE;</span>
        }

        // Certain modifiers are implied as follows:
        //
        // 1.  Any interface (nested or not) is implicitly deemed to be abstract,
        //     whether it is explicitly marked so or not.  (Java 1.0.)
        // 2.  A interface which is a member of a type is implicitly deemed to
        //     be static, whether it is explicitly marked so or not.  (InnerClasses)
        // 3a. A type which is a member of an interface is implicitly deemed
        //     to be public, whether it is explicitly marked so or not. (InnerClasses)
        // 3b. A type which is a member of an interface is implicitly deemed
        //     to be static, whether it is explicitly marked so or not. (InnerClasses)

<span class="nc bnc" id="L164" title="All 2 branches missed.">        if ((mod &amp; M_INTERFACE) != 0) {</span>
            // Rule 1.
<span class="nc" id="L166">            mod |= M_ABSTRACT;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">            if (outerClass != null) {</span>
                // Rule 2.
<span class="nc" id="L169">                mod |= M_STATIC;</span>
            }
        }

<span class="nc bnc" id="L173" title="All 4 branches missed.">        if (outerClass != null &amp;&amp; outerClass.isInterface()) {</span>
            // Rule 3a.
            // For interface members, neither 'private' nor 'protected'
            // are legal modifiers.  We avoid setting M_PUBLIC in some
            // cases in order to avoid interfering with error detection
            // and reporting.  This is patched up, after reporting an
            // error, by 'SourceClass.addMember'.
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if ((mod &amp; (M_PRIVATE | M_PROTECTED)) == 0)</span>
<span class="nc" id="L181">                mod |= M_PUBLIC;</span>
            // Rule 3b.
<span class="nc" id="L183">            mod |= M_STATIC;</span>
        }

        // For nested classes, we must transform 'protected' to 'public'
        // and 'private' to package scope.  This must be done later,
        // because any modifiers set here will be copied into the
        // 'MemberDefinition' for the nested class, which must represent
        // the original untransformed modifiers.  Also, compile-time
        // checks should be performed against the actual, untransformed
        // modifiers.  This is in contrast to transformations that implement
        // implicit modifiers, such as M_STATIC and M_FINAL for fields
        // of interfaces.

<span class="nc" id="L196">        sourceClass = (SourceClass)</span>
<span class="nc" id="L197">            toplevelEnv.makeClassDefinition(toplevelEnv, where, t,</span>
                                            doc, mod, sup,
                                            interfaces, outerClass);

<span class="nc" id="L201">        sourceClass.getClassDeclaration().setDefinition(sourceClass, CS_PARSED);</span>
<span class="nc" id="L202">        env = new Environment(toplevelEnv, sourceClass);</span>

<span class="nc" id="L204">        if (tracing) toplevelEnv.dtEvent(&quot;beginClass: SETTING UP DEPENDENCIES&quot;);</span>

        // The code which adds artificial dependencies between
        // classes in the same source file has been moved to
        // BatchEnvironment#parseFile().

<span class="nc" id="L210">        if (tracing) toplevelEnv.dtEvent(&quot;beginClass: ADDING TO CLASS LIST&quot;);</span>

<span class="nc" id="L212">        classes.addElement(sourceClass);</span>

<span class="nc" id="L214">        if (tracing) toplevelEnv.dtExit(&quot;beginClass: &quot; + sourceClass);</span>

<span class="nc" id="L216">        return sourceClass;</span>
    }

    /**
     * Report the current class under construction.
     */
    public ClassDefinition getCurrentClass() {
<span class="nc" id="L223">        return sourceClass;</span>
    }

    /**
     * End class
     */
    public void endClass(long where, ClassDefinition c) {

<span class="nc" id="L231">        if (tracing) toplevelEnv.dtEnter(&quot;endClass: &quot; + sourceClass);</span>

        // c == sourceClass; don't bother to check
<span class="nc" id="L234">        sourceClass.setEndPosition(where);</span>
<span class="nc" id="L235">        SourceClass outerClass = (SourceClass) sourceClass.getOuterClass();</span>
<span class="nc" id="L236">        sourceClass = outerClass;</span>
<span class="nc" id="L237">        env = toplevelEnv;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (sourceClass != null)</span>
<span class="nc" id="L239">            env = new Environment(env, sourceClass);</span>

<span class="nc" id="L241">        if (tracing) toplevelEnv.dtExit(&quot;endClass: &quot; + sourceClass);</span>
<span class="nc" id="L242">    }</span>

    /**
     * Define a method
     */
    public void defineField(long where, ClassDefinition c,
                            String doc, int mod, Type t,
                            IdentifierToken name, IdentifierToken args[],
                            IdentifierToken exp[], Node val) {
        // c == sourceClass; don't bother to check
<span class="nc" id="L252">        Identifier nm = name.getName();</span>
        // Members that are nested classes are not created with 'defineField',
        // so these transformations do not apply to them.  See 'beginClass' above.
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (sourceClass.isInterface()) {</span>
            // Members of interfaces are implicitly public.
<span class="nc bnc" id="L257" title="All 2 branches missed.">            if ((mod &amp; (M_PRIVATE | M_PROTECTED)) == 0)</span>
                // For interface members, neither 'private' nor 'protected'
                // are legal modifiers.  Avoid setting M_PUBLIC in some cases
                // to avoid interfering with later error detection.  This will
                // be fixed up after the error is reported.
<span class="nc" id="L262">                mod |= M_PUBLIC;</span>
            // Methods of interfaces are implicitly abstract.
            // Fields of interfaces are implicitly static and final.
<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (t.isType(TC_METHOD)) {</span>
<span class="nc" id="L266">                mod |= M_ABSTRACT;</span>
            } else {
<span class="nc" id="L268">                mod |= M_STATIC | M_FINAL;</span>
            }
        }
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (nm.equals(idInit)) {</span>
            // The parser reports &quot;idInit&quot; when in reality it has found
            // that there is no method name at all present.
            // So, decide if it's really a constructor, or a syntax error.
<span class="nc" id="L275">            Type rt = t.getReturnType();</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">            Identifier retname = !rt.isType(TC_CLASS) ? idStar /*no match*/</span>
<span class="nc" id="L277">                                                      : rt.getClassName();</span>
<span class="nc" id="L278">            Identifier clsname = sourceClass.getLocalName();</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (clsname.equals(retname)) {</span>
<span class="nc" id="L280">                t = Type.tMethod(Type.tVoid, t.getArgumentTypes());</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            } else if (clsname.equals(retname.getFlatName().getName())) {</span>
                // It appears to be a constructor with spurious qualification.
<span class="nc" id="L283">                t = Type.tMethod(Type.tVoid, t.getArgumentTypes());</span>
<span class="nc" id="L284">                env.error(where, &quot;invalid.method.decl.qual&quot;);</span>
<span class="nc bnc" id="L285" title="All 4 branches missed.">            } else if (retname.isQualified() || retname.equals(idStar)) {</span>
                // It appears to be a type name with no method name.
<span class="nc" id="L287">                env.error(where, &quot;invalid.method.decl.name&quot;);</span>
<span class="nc" id="L288">                return;</span>
            } else {
                // We assume the type name is missing, even though the
                // simple name that's present might have been intended
                // to be a type:  &quot;String (){}&quot; vs. &quot;toString(){}&quot;.
<span class="nc" id="L293">                env.error(where, &quot;invalid.method.decl&quot;);</span>
<span class="nc" id="L294">                return;</span>
            }
        }

<span class="nc bnc" id="L298" title="All 4 branches missed.">        if (args == null &amp;&amp; t.isType(TC_METHOD)) {</span>
<span class="nc" id="L299">            args = new IdentifierToken[0];</span>
        }

<span class="nc bnc" id="L302" title="All 4 branches missed.">        if (exp == null &amp;&amp; t.isType(TC_METHOD)) {</span>
<span class="nc" id="L303">            exp = new IdentifierToken[0];</span>
        }

<span class="nc" id="L306">        MemberDefinition f = env.makeMemberDefinition(env, where, sourceClass,</span>
                                                    doc, mod, t, nm,
                                                    args, exp, val);
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (env.dump()) {</span>
<span class="nc" id="L310">            f.print(System.out);</span>
        }
<span class="nc" id="L312">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>