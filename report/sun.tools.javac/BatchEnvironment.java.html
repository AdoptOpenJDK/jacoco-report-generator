<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BatchEnvironment.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.javac</a> &gt; <span class="el_source">BatchEnvironment.java</span></div><h1>BatchEnvironment.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.javac;

import sun.tools.java.*;
import sun.tools.tree.Node;
import sun.tools.java.Package;

import java.util.*;
import java.io.*;

/**
 * Main environment of the batch version of the Java compiler,
 * this needs more work.
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
@Deprecated
public
class BatchEnvironment extends Environment implements ErrorConsumer {
    /**
     * The stream where error message are printed.
     */
    OutputStream out;

    /**
     * The path we use for finding source files.
     */
    protected ClassPath sourcePath;

    /**
     * The path we use for finding class (binary) files.
     */
    protected ClassPath binaryPath;

    /**
     * A hashtable of resource contexts.
     */
<span class="nc" id="L64">    Hashtable packages = new Hashtable(31);</span>

    /**
     * The classes, in order of appearance.
     */
<span class="nc" id="L69">    Vector classesOrdered = new Vector();</span>

    /**
     * The classes, keyed by ClassDeclaration.
     */
<span class="nc" id="L74">    Hashtable classes = new Hashtable(351);</span>

    /**
     * flags
     */
    public int flags;

    /**
     * Major and minor versions to use for generated class files.
     * Environments that extend BatchEnvironment (such as javadoc's
     * Env class) get the default values below.
     *
     * javac itself may override these versions with values determined
     * from the command line &quot;-target&quot; option.
     */
<span class="nc" id="L89">    public short majorVersion = JAVA_DEFAULT_VERSION;</span>
<span class="nc" id="L90">    public short minorVersion = JAVA_DEFAULT_MINOR_VERSION;</span>

// JCOV
    /**
     * coverage data file
     */
    public File covFile;
// end JCOV

    /**
     * The number of errors and warnings
     */
    public int nerrors;
    public int nwarnings;
    public int ndeprecations;

    /**
     * A list of files containing deprecation warnings.
     */
<span class="nc" id="L109">    Vector deprecationFiles = new Vector();</span>

        /**
         * writes out error messages
         */

        ErrorConsumer errorConsumer;

    /**
     * Old constructors -- these constructors build a BatchEnvironment
     * with an old-style class path.
     */
    public BatchEnvironment(ClassPath path) {
<span class="nc" id="L122">        this(System.out, path);</span>
<span class="nc" id="L123">    }</span>
    public BatchEnvironment(OutputStream out,
                            ClassPath path) {
<span class="nc" id="L126">        this(out, path, (ErrorConsumer) null);</span>
<span class="nc" id="L127">    }</span>
    public BatchEnvironment(OutputStream out,
                            ClassPath path,
                            ErrorConsumer errorConsumer) {
<span class="nc" id="L131">        this(out, path, path, errorConsumer);</span>
<span class="nc" id="L132">    }</span>

    /**
     * New constructors -- these constructors build a BatchEnvironment
     * with a source path and a binary path.
     */
    public BatchEnvironment(ClassPath sourcePath,
                            ClassPath binaryPath) {
<span class="nc" id="L140">        this(System.out, sourcePath, binaryPath);</span>
<span class="nc" id="L141">    }</span>
    public BatchEnvironment(OutputStream out,
                            ClassPath sourcePath,
                            ClassPath binaryPath) {
<span class="nc" id="L145">        this(out, sourcePath, binaryPath, (ErrorConsumer) null);</span>
<span class="nc" id="L146">    }</span>
    public BatchEnvironment(OutputStream out,
                            ClassPath sourcePath,
                            ClassPath binaryPath,
<span class="nc" id="L150">                            ErrorConsumer errorConsumer) {</span>
<span class="nc" id="L151">        this.out = out;</span>
<span class="nc" id="L152">        this.sourcePath = sourcePath;</span>
<span class="nc" id="L153">        this.binaryPath = binaryPath;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        this.errorConsumer = (errorConsumer == null) ? this : errorConsumer;</span>
<span class="nc" id="L155">    }</span>

    /**
     * Factory
     */
    static BatchEnvironment create(OutputStream out,
                                   String srcPathString,
                                   String classPathString,
                                   String sysClassPathString,
                                   String extDirsString){
<span class="nc" id="L165">        ClassPath[] classPaths = classPaths(srcPathString, classPathString,</span>
                                            sysClassPathString, extDirsString);
<span class="nc" id="L167">        return new BatchEnvironment(out, classPaths[0], classPaths[1]);</span>
    }

    protected static ClassPath[] classPaths(String srcPathString,
                                            String classPathString,
                                            String sysClassPathString,
                                            String extDirsString) {
        // Create our source classpath and our binary classpath
        ClassPath sourcePath;
        ClassPath binaryPath;
<span class="nc" id="L177">        StringBuffer binaryPathBuffer = new StringBuffer();</span>

<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (classPathString == null) {</span>
            // The env.class.path property is the user's CLASSPATH
            // environment variable, and it set by the wrapper (ie,
            // javac.exe).
<span class="nc" id="L183">            classPathString = System.getProperty(&quot;env.class.path&quot;);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (classPathString == null) {</span>
<span class="nc" id="L185">                classPathString = &quot;.&quot;;</span>
            }
        }
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (srcPathString == null) {</span>
<span class="nc" id="L189">            srcPathString = classPathString;</span>
        }
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (sysClassPathString == null) {</span>
<span class="nc" id="L192">            sysClassPathString = System.getProperty(&quot;sun.boot.class.path&quot;);</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">            if (sysClassPathString == null) { // shouldn't happen; recover gracefully</span>
<span class="nc" id="L194">                sysClassPathString = classPathString;</span>
            }
        }
<span class="nc" id="L197">        appendPath(binaryPathBuffer, sysClassPathString);</span>

<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (extDirsString == null) {</span>
<span class="nc" id="L200">            extDirsString = System.getProperty(&quot;java.ext.dirs&quot;);</span>
        }
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (extDirsString != null) {</span>
<span class="nc" id="L203">            StringTokenizer st = new StringTokenizer(extDirsString,</span>
                                                     File.pathSeparator);
<span class="nc bnc" id="L205" title="All 2 branches missed.">            while (st.hasMoreTokens()) {</span>
<span class="nc" id="L206">                String dirName = st.nextToken();</span>
<span class="nc" id="L207">                File dir = new File(dirName);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">                if (!dirName.endsWith(File.separator)) {</span>
<span class="nc" id="L209">                    dirName += File.separator;</span>
                }
<span class="nc bnc" id="L211" title="All 2 branches missed.">                if (dir.isDirectory()) {</span>
<span class="nc" id="L212">                    String[] files = dir.list();</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                    for (int i = 0; i &lt; files.length; ++i) {</span>
<span class="nc" id="L214">                        String name = files[i];</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                        if (name.endsWith(&quot;.jar&quot;)) {</span>
<span class="nc" id="L216">                            appendPath(binaryPathBuffer, dirName + name);</span>
                        }
                    }
                }
<span class="nc" id="L220">            }</span>
        }

<span class="nc" id="L223">        appendPath(binaryPathBuffer, classPathString);</span>

<span class="nc" id="L225">        sourcePath = new ClassPath(srcPathString);</span>
<span class="nc" id="L226">        binaryPath = new ClassPath(binaryPathBuffer.toString());</span>

<span class="nc" id="L228">        return new ClassPath[]{sourcePath, binaryPath};</span>
    }

    private static void appendPath(StringBuffer buf, String str) {
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (str.length() &gt; 0) {</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (buf.length() &gt; 0) {</span>
<span class="nc" id="L234">                buf.append(File.pathSeparator);</span>
            }
<span class="nc" id="L236">            buf.append(str);</span>
        }
<span class="nc" id="L238">    }</span>

    /**
     * Return flags
     */
    public int getFlags() {
<span class="nc" id="L244">        return flags;</span>
    }

    /**
     * Return major version to use for generated class files
     */
    public short getMajorVersion() {
<span class="nc" id="L251">        return majorVersion;</span>
    }

    /**
     * Return minor version to use for generated class files
     */
    public short getMinorVersion() {
<span class="nc" id="L258">        return minorVersion;</span>
    }

// JCOV
    /**
     * Return coverage data file
     */
    public File getcovFile() {
<span class="nc" id="L266">        return covFile;</span>
    }
// end JCOV

    /**
     * Return an enumeration of all the currently defined classes
     * in order of appearance to getClassDeclaration().
     */
    public Enumeration getClasses() {
<span class="nc" id="L275">        return classesOrdered.elements();</span>
    }

    /**
     * A set of Identifiers for all packages exempt from the &quot;exists&quot;
     * check in Imports#resolve().  These are the current packages for
     * all classes being compiled as of the first call to isExemptPackage.
     */
    private Set exemptPackages;

    /**
     * Tells whether an Identifier refers to a package which should be
     * exempt from the &quot;exists&quot; check in Imports#resolve().
     */
    public boolean isExemptPackage(Identifier id) {
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (exemptPackages == null) {</span>
            // Collect a list of the packages of all classes currently
            // being compiled.
<span class="nc" id="L293">            setExemptPackages();</span>
        }

<span class="nc" id="L296">        return exemptPackages.contains(id);</span>
    }

    /**
     * Set the set of packages which are exempt from the exists check
     * in Imports#resolve().
     */
    private void setExemptPackages() {
        // The JLS gives us the freedom to define &quot;accessibility&quot; of
        // a package in whatever manner we wish.  After the evaluation
        // of bug 4093217, we have decided to consider a package P
        // accessible if either:
        //
        // 1. The directory corresponding to P exists on the classpath.
        // 2. For any class C currently being compiled, C belongs to
        //    package P.
        // 3. For any class C currently being compiled, C belongs to
        //    package Q and Q is a subpackage of P.
        //
        // In order to implement this, we collect the current packages
        // (and prefixes) of all packages we have found so far.  These
        // will be exempt from the &quot;exists&quot; check in
        // sun.tools.java.Imports#resolve().

<span class="nc" id="L320">        exemptPackages = new HashSet(101);</span>

        // Add all of the current packages and their prefixes to our set.
<span class="nc bnc" id="L323" title="All 2 branches missed.">        for (Enumeration e = getClasses(); e.hasMoreElements(); ) {</span>
<span class="nc" id="L324">            ClassDeclaration c = (ClassDeclaration) e.nextElement();</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (c.getStatus() == CS_PARSED) {</span>
<span class="nc" id="L326">                SourceClass def = (SourceClass) c.getClassDefinition();</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                if (def.isLocal())</span>
<span class="nc" id="L328">                    continue;</span>

<span class="nc" id="L330">                Identifier pkg = def.getImports().getCurrentPackage();</span>

                // Add the name of this package and all of its prefixes
                // to our set.
<span class="nc bnc" id="L334" title="All 4 branches missed.">                while (pkg != idNull &amp;&amp; exemptPackages.add(pkg)) {</span>
<span class="nc" id="L335">                    pkg = pkg.getQualifier();</span>
                }
            }
<span class="nc" id="L338">        }</span>

        // Before we go any further, we make sure java.lang is
        // accessible and that it is not ambiguous.  These checks
        // are performed for &quot;ordinary&quot; packages in
        // sun.tools.java.Imports#resolve().  The reason we perform
        // them specially for java.lang is that we want to report
        // the error once, and outside of any particular file.

        // Check to see if java.lang is accessible.
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (!exemptPackages.contains(idJavaLang)) {</span>
            // Add java.lang to the set of exempt packages.
<span class="nc" id="L350">            exemptPackages.add(idJavaLang);</span>

            try {
<span class="nc bnc" id="L353" title="All 2 branches missed.">                if (!getPackage(idJavaLang).exists()) {</span>
                    // java.lang doesn't exist.
<span class="nc" id="L355">                    error(0, &quot;package.not.found.strong&quot;, idJavaLang);</span>
<span class="nc" id="L356">                    return;</span>
                }
<span class="nc" id="L358">            } catch (IOException ee) {</span>
                // We got an IO exception checking to see if the package
                // java.lang exists.
<span class="nc" id="L361">                error(0, &quot;io.exception.package&quot;, idJavaLang);</span>
<span class="nc" id="L362">            }</span>
        }

        // Next we ensure that java.lang is not both a class and
        // a package.  (Fix for 4101529)
        //
        // This change has been backed out because, on WIN32, it
        // failed to take character case into account.  It will
        // be put back in later.
        //
        // Identifier resolvedName =
        //   resolvePackageQualifiedName(idJavaLang);
        // Identifier topClassName = resolvedName.getTopName();
        //     //if (Imports.importable(topClassName, env)) {
        // if (Imports.importable(topClassName, this)) {
        //    // It is a package and a class.  Emit the error.
        //    error(0, &quot;package.class.conflict.strong&quot;,
        //            idJavaLang, topClassName);
        //    return;
        // }
<span class="nc" id="L382">    }</span>

    /**
     * Get a class, given the fully qualified class name
     */
    public ClassDeclaration getClassDeclaration(Identifier nm) {
<span class="nc" id="L388">        return getClassDeclaration(Type.tClass(nm));</span>
    }

    public ClassDeclaration getClassDeclaration(Type t) {
<span class="nc" id="L392">        ClassDeclaration c = (ClassDeclaration)classes.get(t);</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L394">            classes.put(t, c = new ClassDeclaration(t.getClassName()));</span>
<span class="nc" id="L395">            classesOrdered.addElement(c);</span>
        }
<span class="nc" id="L397">        return c;</span>
    }

    /**
     * Check if a class exists
     * Applies only to package members (non-nested classes).
     */
    public boolean classExists(Identifier nm) {
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (nm.isInner()) {</span>
<span class="nc" id="L406">            nm = nm.getTopName();       // just in case</span>
        }
<span class="nc" id="L408">        Type t = Type.tClass(nm);</span>
        try {
<span class="nc" id="L410">            ClassDeclaration c = (ClassDeclaration)classes.get(t);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            return (c != null) ? c.getName().equals(nm) :</span>
<span class="nc" id="L412">                getPackage(nm.getQualifier()).classExists(nm.getName());</span>
<span class="nc" id="L413">        } catch (IOException e) {</span>
<span class="nc" id="L414">            return true;</span>
        }
    }

    /**
     * Generate a new name similar to the given one.
     * Do it in such a way that repeated compilations of
     * the same source generate the same series of names.
     */

    // This code does not perform as stated above.
    // Correction below is part of fix for bug id 4056065.
    //
    // NOTE: The method 'generateName' has now been folded into its
    // single caller, 'makeClassDefinition', which appears later in
    // this file.

    /*--------------------------*
    public Identifier generateName(ClassDefinition outerClass, Identifier nm) {
        Identifier outerNm = outerClass.getName();
        Identifier flat = outerNm.getFlatName();
        Identifier stem = Identifier.lookup(outerNm.getQualifier(),
                                            flat.getHead());
        for (int i = 1; ; i++) {
            String name = i + (nm.equals(idNull) ? &quot;&quot; : SIG_INNERCLASS + nm);
            Identifier nm1 = Identifier.lookupInner(stem,
                                                    Identifier.lookup(name));
            if (classes.get(Type.tClass(nm1)) == null)
                return nm1;
        }
    }
    *--------------------------*/

    /**
     * Get the package path for a package
     */
    public Package getPackage(Identifier pkg) throws IOException {
<span class="nc" id="L451">        Package p = (Package)packages.get(pkg);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (p == null) {</span>
<span class="nc" id="L453">            packages.put(pkg, p = new Package(sourcePath, binaryPath, pkg));</span>
        }
<span class="nc" id="L455">        return p;</span>
    }

    /**
     * Parse a source file
     */
    public void parseFile(ClassFile file) throws FileNotFoundException {
<span class="nc" id="L462">        long tm = System.currentTimeMillis();</span>
        InputStream input;
        BatchParser p;

<span class="nc" id="L466">        if (tracing) dtEnter(&quot;parseFile: PARSING SOURCE &quot; + file);</span>

<span class="nc" id="L468">        Environment env = new Environment(this, file);</span>

        try {
<span class="nc" id="L471">            input = file.getInputStream();</span>
<span class="nc" id="L472">            env.setCharacterEncoding(getCharacterEncoding());</span>
            //      p = new BatchParser(e, new BufferedInputStream(input));
<span class="nc" id="L474">            p = new BatchParser(env, input);</span>
<span class="nc" id="L475">        } catch(IOException ex) {</span>
<span class="nc" id="L476">            if (tracing) dtEvent(&quot;parseFile: IO EXCEPTION &quot; + file);</span>
<span class="nc" id="L477">            throw new FileNotFoundException();</span>
<span class="nc" id="L478">        }</span>

        try {
<span class="nc" id="L481">            p.parseFile();</span>
<span class="nc" id="L482">        } catch(Exception e) {</span>
<span class="nc" id="L483">            throw new CompilerError(e);</span>
<span class="nc" id="L484">        }</span>

        try {
<span class="nc" id="L487">            input.close();</span>
<span class="nc" id="L488">        } catch (IOException ex) {</span>
            // We're turn with the input, so ignore this.
<span class="nc" id="L490">        }</span>

<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (verbose()) {</span>
<span class="nc" id="L493">            tm = System.currentTimeMillis() - tm;</span>
<span class="nc" id="L494">            output(Main.getText(&quot;benv.parsed_in&quot;, file.getPath(),</span>
<span class="nc" id="L495">                                Long.toString(tm)));</span>
        }

<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (p.classes.size() == 0) {</span>
            // The JLS allows a file to contain no compilation units --
            // that is, it allows a file to contain no classes or interfaces.
            // In this case, we are still responsible for checking that the
            // imports resolve properly.  The way the compiler is organized,
            // this is the last point at which we still have enough information
            // to do so. (Fix for 4041851).
<span class="nc" id="L505">            p.imports.resolve(env);</span>
        } else {
            // In an attempt to see that classes which come from the
            // same source file are all recompiled when any one of them
            // would be recompiled (when using the -depend option) we
            // introduce artificial dependencies between these classes.
            // We do this by calling the addDependency() method, which
            // adds a (potentially unused) class reference to the constant
            // pool of the class.
            //
            // Previously, we added a dependency from every class in the
            // file, to every class in the file.  This introduced, in
            // total, a quadratic number of potentially bogus constant
            // pool entries.  This was bad.  Now we add our artificial
            // dependencies in such a way that the classes are connected
            // in a circle.  While single links is probably sufficient, the
            // code below adds double links just to be diligent.
            // (Fix for 4108286).
            //
            // Note that we don't chain in inner classes.  The links
            // between them and their outerclass should be sufficient
            // here.
            // (Fix for 4107960).
            //
            // The dependency code was previously in BatchParser.java.
<span class="nc" id="L530">            Enumeration e = p.classes.elements();</span>

            // first will not be an inner class.
<span class="nc" id="L533">            ClassDefinition first = (ClassDefinition) e.nextElement();</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">            if (first.isInnerClass()) {</span>
<span class="nc" id="L535">                throw new CompilerError(&quot;BatchEnvironment, first is inner&quot;);</span>
            }

<span class="nc" id="L538">            ClassDefinition current = first;</span>
            ClassDefinition next;
<span class="nc bnc" id="L540" title="All 2 branches missed.">            while (e.hasMoreElements()) {</span>
<span class="nc" id="L541">                next = (ClassDefinition) e.nextElement();</span>
                // Don't chain in inner classes.
<span class="nc bnc" id="L543" title="All 2 branches missed.">                if (next.isInnerClass()) {</span>
<span class="nc" id="L544">                    continue;</span>
                }
<span class="nc" id="L546">                current.addDependency(next.getClassDeclaration());</span>
<span class="nc" id="L547">                next.addDependency(current.getClassDeclaration());</span>
<span class="nc" id="L548">                current = next;</span>
            }
            // Make a circle.  Don't bother to add a dependency if there
            // is only one class in the file.
<span class="nc bnc" id="L552" title="All 2 branches missed.">            if (current != first) {</span>
<span class="nc" id="L553">                current.addDependency(first.getClassDeclaration());</span>
<span class="nc" id="L554">                first.addDependency(current.getClassDeclaration());</span>
            }
        }

<span class="nc" id="L558">        if (tracing) dtExit(&quot;parseFile: SOURCE PARSED &quot; + file);</span>
<span class="nc" id="L559">    }</span>

    /**
     * Load a binary file
     */
    BinaryClass loadFile(ClassFile file) throws IOException {
<span class="nc" id="L565">        long tm = System.currentTimeMillis();</span>
<span class="nc" id="L566">        InputStream input = file.getInputStream();</span>
<span class="nc" id="L567">        BinaryClass c = null;</span>

<span class="nc" id="L569">        if (tracing) dtEnter(&quot;loadFile: LOADING CLASSFILE &quot; + file);</span>

        try {
<span class="nc" id="L572">            DataInputStream is =</span>
                new DataInputStream(new BufferedInputStream(input));
<span class="nc" id="L574">            c = BinaryClass.load(new Environment(this, file), is,</span>
<span class="nc" id="L575">                                 loadFileFlags());</span>
<span class="nc" id="L576">        } catch (ClassFormatError e) {</span>
<span class="nc" id="L577">            error(0, &quot;class.format&quot;, file.getPath(), e.getMessage());</span>
<span class="nc" id="L578">            if (tracing) dtExit(&quot;loadFile: CLASS FORMAT ERROR &quot; + file);</span>
<span class="nc" id="L579">            return null;</span>
<span class="nc" id="L580">        } catch (java.io.EOFException e) {</span>
            // If we get an EOF while processing a class file, then
            // it has been truncated.  We let other I/O errors pass
            // through.  Fix for 4088443.
<span class="nc" id="L584">            error(0, &quot;truncated.class&quot;, file.getPath());</span>
<span class="nc" id="L585">            return null;</span>
<span class="nc" id="L586">        }</span>

<span class="nc" id="L588">        input.close();</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (verbose()) {</span>
<span class="nc" id="L590">            tm = System.currentTimeMillis() - tm;</span>
<span class="nc" id="L591">            output(Main.getText(&quot;benv.loaded_in&quot;, file.getPath(),</span>
<span class="nc" id="L592">                                Long.toString(tm)));</span>
        }

<span class="nc" id="L595">        if (tracing) dtExit(&quot;loadFile: CLASSFILE LOADED &quot; + file);</span>

<span class="nc" id="L597">        return c;</span>
    }

    /**
     * Default flags for loadFile.  Subclasses may override this.
     */
    int loadFileFlags() {
<span class="nc" id="L604">        return 0;</span>
    }

    /**
     * Load a binary class
     */
    boolean needsCompilation(Hashtable check, ClassDeclaration c) {
<span class="nc bnc" id="L611" title="All 4 branches missed.">        switch (c.getStatus()) {</span>

          case CS_UNDEFINED:
<span class="nc" id="L614">            if (tracing) dtEnter(&quot;needsCompilation: UNDEFINED &quot; + c.getName());</span>
<span class="nc" id="L615">            loadDefinition(c);</span>
<span class="nc" id="L616">            return needsCompilation(check, c);</span>

          case CS_UNDECIDED:
<span class="nc" id="L619">            if (tracing) dtEnter(&quot;needsCompilation: UNDECIDED &quot; + c.getName());</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            if (check.get(c) == null) {</span>
<span class="nc" id="L621">                check.put(c, c);</span>

<span class="nc" id="L623">                BinaryClass bin = (BinaryClass)c.getClassDefinition();</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                for (Enumeration e = bin.getDependencies() ; e.hasMoreElements() ;) {</span>
<span class="nc" id="L625">                    ClassDeclaration dep = (ClassDeclaration)e.nextElement();</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                    if (needsCompilation(check, dep)) {</span>
                        // It must be source, dependencies need compilation
<span class="nc" id="L628">                        c.setDefinition(bin, CS_SOURCE);</span>
<span class="nc" id="L629">                        if (tracing) dtExit(&quot;needsCompilation: YES (source) &quot; + c.getName());</span>
<span class="nc" id="L630">                        return true;</span>
                    }
<span class="nc" id="L632">                }</span>
            }
<span class="nc" id="L634">            if (tracing) dtExit(&quot;needsCompilation: NO (undecided) &quot; + c.getName());</span>
<span class="nc" id="L635">            return false;</span>

          case CS_BINARY:
            if (tracing) {
<span class="nc" id="L639">                dtEnter(&quot;needsCompilation: BINARY &quot; + c.getName());</span>
<span class="nc" id="L640">                dtExit(&quot;needsCompilation: NO (binary) &quot; + c.getName());</span>
            }
<span class="nc" id="L642">            return false;</span>

        }

<span class="nc" id="L646">        if (tracing) dtExit(&quot;needsCompilation: YES &quot; + c.getName());</span>
<span class="nc" id="L647">        return true;</span>
    }

    /**
     * Load the definition of a class
     * or at least determine how to load it.
     * The caller must repeat calls to this method
     * until it the state converges to CS_BINARY, CS_PARSED, or the like..
     * @see ClassDeclaration#getClassDefinition
     */
    public void loadDefinition(ClassDeclaration c) {
<span class="nc" id="L658">        if (tracing) dtEnter(&quot;loadDefinition: ENTER &quot; +</span>
<span class="nc" id="L659">                             c.getName() + &quot;, status &quot; + c.getStatus());</span>
<span class="nc bnc" id="L660" title="All 4 branches missed.">        switch (c.getStatus()) {</span>
          case CS_UNDEFINED: {
            if (tracing)
<span class="nc" id="L663">                dtEvent(&quot;loadDefinition: STATUS IS UNDEFINED&quot;);</span>
<span class="nc" id="L664">            Identifier nm = c.getName();</span>
            Package pkg;
            try {
<span class="nc" id="L667">                pkg = getPackage(nm.getQualifier());</span>
<span class="nc" id="L668">            } catch (IOException e) {</span>
                // If we can't get at the package, then we'll just
                // have to set the class to be not found.
<span class="nc" id="L671">                c.setDefinition(null, CS_NOTFOUND);</span>

<span class="nc" id="L673">                error(0, &quot;io.exception&quot;, c);</span>
                if (tracing)
<span class="nc" id="L675">                    dtExit(&quot;loadDefinition: IO EXCEPTION (package)&quot;);</span>
<span class="nc" id="L676">                return;</span>
<span class="nc" id="L677">            }</span>
<span class="nc" id="L678">            ClassFile binfile = pkg.getBinaryFile(nm.getName());</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">            if (binfile == null) {</span>
                // must be source, there is no binary
<span class="nc" id="L681">                c.setDefinition(null, CS_SOURCE);</span>
                if (tracing)
<span class="nc" id="L683">                    dtExit(&quot;loadDefinition: MUST BE SOURCE (no binary) &quot; +</span>
<span class="nc" id="L684">                           c.getName());</span>
<span class="nc" id="L685">                return;</span>
            }

<span class="nc" id="L688">            ClassFile srcfile = pkg.getSourceFile(nm.getName());</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">            if (srcfile == null) {</span>
                if (tracing)
<span class="nc" id="L691">                    dtEvent(&quot;loadDefinition: NO SOURCE &quot; + c.getName());</span>
<span class="nc" id="L692">                BinaryClass bc = null;</span>
                try {
<span class="nc" id="L694">                    bc = loadFile(binfile);</span>
<span class="nc" id="L695">                } catch (IOException e) {</span>
                    // If we can't access the binary, set the class to
                    // be not found.  (bug id 4030497)
<span class="nc" id="L698">                    c.setDefinition(null, CS_NOTFOUND);</span>

<span class="nc" id="L700">                    error(0, &quot;io.exception&quot;, binfile);</span>
                    if (tracing)
<span class="nc" id="L702">                        dtExit(&quot;loadDefinition: IO EXCEPTION (binary)&quot;);</span>
<span class="nc" id="L703">                    return;</span>
<span class="nc" id="L704">                }</span>
<span class="nc bnc" id="L705" title="All 4 branches missed.">                if ((bc != null) &amp;&amp; !bc.getName().equals(nm)) {</span>
<span class="nc" id="L706">                    error(0, &quot;wrong.class&quot;, binfile.getPath(), c, bc);</span>
<span class="nc" id="L707">                    bc = null;</span>
                    if (tracing)
<span class="nc" id="L709">                        dtEvent(&quot;loadDefinition: WRONG CLASS (binary)&quot;);</span>
                }
<span class="nc bnc" id="L711" title="All 2 branches missed.">                if (bc == null) {</span>
                    // no source nor binary found
<span class="nc" id="L713">                    c.setDefinition(null, CS_NOTFOUND);</span>
                    if (tracing)
<span class="nc" id="L715">                        dtExit(&quot;loadDefinition: NOT FOUND (source or binary)&quot;);</span>
<span class="nc" id="L716">                    return;</span>
                }

                // Couldn't find the source, try the one mentioned in the binary
<span class="nc bnc" id="L720" title="All 2 branches missed.">                if (bc.getSource() != null) {</span>
<span class="nc" id="L721">                    srcfile = new ClassFile(new File((String)bc.getSource()));</span>
                    // Look for the source file
<span class="nc" id="L723">                    srcfile = pkg.getSourceFile(srcfile.getName());</span>
<span class="nc bnc" id="L724" title="All 4 branches missed.">                    if ((srcfile != null) &amp;&amp; srcfile.exists()) {</span>
                        if (tracing)
<span class="nc" id="L726">                            dtEvent(&quot;loadDefinition: FILENAME IN BINARY &quot; +</span>
                                    srcfile);
<span class="nc bnc" id="L728" title="All 2 branches missed.">                        if (srcfile.lastModified() &gt; binfile.lastModified()) {</span>
                            // must be source, it is newer than the binary
<span class="nc" id="L730">                            c.setDefinition(bc, CS_SOURCE);</span>
                            if (tracing)
<span class="nc" id="L732">                                dtEvent(&quot;loadDefinition: SOURCE IS NEWER &quot; +</span>
                                        srcfile);
<span class="nc" id="L734">                            bc.loadNested(this);</span>
                            if (tracing)
<span class="nc" id="L736">                                dtExit(&quot;loadDefinition: MUST BE SOURCE &quot; +</span>
<span class="nc" id="L737">                                       c.getName());</span>
<span class="nc" id="L738">                            return;</span>
                        }
<span class="nc bnc" id="L740" title="All 2 branches missed.">                        if (dependencies()) {</span>
<span class="nc" id="L741">                            c.setDefinition(bc, CS_UNDECIDED);</span>
                            if (tracing)
<span class="nc" id="L743">                                dtEvent(&quot;loadDefinition: UNDECIDED &quot; +</span>
<span class="nc" id="L744">                                        c.getName());</span>
                        } else {
<span class="nc" id="L746">                            c.setDefinition(bc, CS_BINARY);</span>
                            if (tracing)
<span class="nc" id="L748">                                dtEvent(&quot;loadDefinition: MUST BE BINARY &quot; +</span>
<span class="nc" id="L749">                                        c.getName());</span>
                        }
<span class="nc" id="L751">                        bc.loadNested(this);</span>
                        if (tracing)
<span class="nc" id="L753">                            dtExit(&quot;loadDefinition: EXIT &quot; +</span>
<span class="nc" id="L754">                                   c.getName() + &quot;, status &quot; + c.getStatus());</span>
<span class="nc" id="L755">                        return;</span>
                    }
                }

                // It must be binary, there is no source
<span class="nc" id="L760">                c.setDefinition(bc, CS_BINARY);</span>
                if (tracing)
<span class="nc" id="L762">                    dtEvent(&quot;loadDefinition: MUST BE BINARY (no source) &quot; +</span>
<span class="nc" id="L763">                                     c.getName());</span>
<span class="nc" id="L764">                bc.loadNested(this);</span>
                if (tracing)
<span class="nc" id="L766">                    dtExit(&quot;loadDefinition: EXIT &quot; +</span>
<span class="nc" id="L767">                           c.getName() + &quot;, status &quot; + c.getStatus());</span>
<span class="nc" id="L768">                return;</span>
            }
<span class="nc" id="L770">            BinaryClass bc = null;</span>
            try {
<span class="nc bnc" id="L772" title="All 2 branches missed.">                if (srcfile.lastModified() &gt; binfile.lastModified()) {</span>
                    // must be source, it is newer than the binary
<span class="nc" id="L774">                    c.setDefinition(null, CS_SOURCE);</span>
                    if (tracing)
<span class="nc" id="L776">                        dtEvent(&quot;loadDefinition: MUST BE SOURCE (younger than binary) &quot; +</span>
<span class="nc" id="L777">                                c.getName());</span>
<span class="nc" id="L778">                    return;</span>
                }
<span class="nc" id="L780">                bc = loadFile(binfile);</span>
<span class="nc" id="L781">            } catch (IOException e) {</span>
<span class="nc" id="L782">                error(0, &quot;io.exception&quot;, binfile);</span>
                if (tracing)
<span class="nc" id="L784">                    dtEvent(&quot;loadDefinition: IO EXCEPTION (binary)&quot;);</span>
<span class="nc" id="L785">            }</span>
<span class="nc bnc" id="L786" title="All 4 branches missed.">            if ((bc != null) &amp;&amp; !bc.getName().equals(nm)) {</span>
<span class="nc" id="L787">                error(0, &quot;wrong.class&quot;, binfile.getPath(), c, bc);</span>
<span class="nc" id="L788">                bc = null;</span>
                if (tracing)
<span class="nc" id="L790">                    dtEvent(&quot;loadDefinition: WRONG CLASS (binary)&quot;);</span>
            }
<span class="nc bnc" id="L792" title="All 2 branches missed.">            if (bc != null) {</span>
<span class="nc" id="L793">                Identifier name = bc.getName();</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">                if (name.equals(c.getName())) {</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">                    if (dependencies()) {</span>
<span class="nc" id="L796">                        c.setDefinition(bc, CS_UNDECIDED);</span>
                        if (tracing)
<span class="nc" id="L798">                            dtEvent(&quot;loadDefinition: UNDECIDED &quot; + name);</span>
                    } else {
<span class="nc" id="L800">                        c.setDefinition(bc, CS_BINARY);</span>
                        if (tracing)
<span class="nc" id="L802">                            dtEvent(&quot;loadDefinition: MUST BE BINARY &quot; + name);</span>
                    }
                } else {
<span class="nc" id="L805">                    c.setDefinition(null, CS_NOTFOUND);</span>
                    if (tracing)
<span class="nc" id="L807">                        dtEvent(&quot;loadDefinition: NOT FOUND (source or binary)&quot;);</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">                    if (dependencies()) {</span>
<span class="nc" id="L809">                        getClassDeclaration(name).setDefinition(bc, CS_UNDECIDED);</span>
                        if (tracing)
<span class="nc" id="L811">                            dtEvent(&quot;loadDefinition: UNDECIDED &quot; + name);</span>
                    } else {
<span class="nc" id="L813">                        getClassDeclaration(name).setDefinition(bc, CS_BINARY);</span>
                        if (tracing)
<span class="nc" id="L815">                            dtEvent(&quot;loadDefinition: MUST BE BINARY &quot; + name);</span>
                    }
                }
<span class="nc" id="L818">            } else {</span>
<span class="nc" id="L819">                c.setDefinition(null, CS_NOTFOUND);</span>
                if (tracing)
<span class="nc" id="L821">                    dtEvent(&quot;loadDefinition: NOT FOUND (source or binary)&quot;);</span>
            }
<span class="nc bnc" id="L823" title="All 4 branches missed.">            if (bc != null &amp;&amp; bc == c.getClassDefinition())</span>
<span class="nc" id="L824">                bc.loadNested(this);</span>
<span class="nc" id="L825">            if (tracing) dtExit(&quot;loadDefinition: EXIT &quot; +</span>
<span class="nc" id="L826">                                c.getName() + &quot;, status &quot; + c.getStatus());</span>
<span class="nc" id="L827">            return;</span>
          }

          case CS_UNDECIDED: {
<span class="nc" id="L831">            if (tracing) dtEvent(&quot;loadDefinition: STATUS IS UNDECIDED&quot;);</span>
<span class="nc" id="L832">            Hashtable tab = new Hashtable();</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">            if (!needsCompilation(tab, c)) {</span>
                // All undecided classes that this class depends on must be binary
<span class="nc bnc" id="L835" title="All 2 branches missed.">                for (Enumeration e = tab.keys() ; e.hasMoreElements() ; ) {</span>
<span class="nc" id="L836">                    ClassDeclaration dep = (ClassDeclaration)e.nextElement();</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">                    if (dep.getStatus() == CS_UNDECIDED) {</span>
                        // must be binary, dependencies need compilation
<span class="nc" id="L839">                        dep.setDefinition(dep.getClassDefinition(), CS_BINARY);</span>
                        if (tracing)
<span class="nc" id="L841">                            dtEvent(&quot;loadDefinition: MUST BE BINARY &quot; + dep);</span>
                    }
<span class="nc" id="L843">                }</span>
            }
<span class="nc" id="L845">            if (tracing) dtExit(&quot;loadDefinition: EXIT &quot; +</span>
<span class="nc" id="L846">                                c.getName() + &quot;, status &quot; + c.getStatus());</span>
<span class="nc" id="L847">            return;</span>
          }

          case CS_SOURCE: {
<span class="nc" id="L851">            if (tracing) dtEvent(&quot;loadDefinition: STATUS IS SOURCE&quot;);</span>
<span class="nc" id="L852">            ClassFile srcfile = null;</span>
<span class="nc" id="L853">            Package pkg = null;</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">            if (c.getClassDefinition() != null) {</span>
                // Use the source file name from the binary class file
                try {
<span class="nc" id="L857">                    pkg = getPackage(c.getName().getQualifier());</span>
<span class="nc" id="L858">                    srcfile = pkg.getSourceFile((String)c.getClassDefinition().getSource());</span>
<span class="nc" id="L859">                } catch (IOException e) {</span>
<span class="nc" id="L860">                    error(0, &quot;io.exception&quot;, c);</span>
                    if (tracing)
<span class="nc" id="L862">                        dtEvent(&quot;loadDefinition: IO EXCEPTION (package)&quot;);</span>
<span class="nc" id="L863">                }</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">                if (srcfile == null) {</span>
<span class="nc" id="L865">                    String fn = (String)c.getClassDefinition().getSource();</span>
<span class="nc" id="L866">                    srcfile = new ClassFile(new File(fn));</span>
<span class="nc" id="L867">                }</span>
            } else {
                // Get a source file name from the package
<span class="nc" id="L870">                Identifier nm = c.getName();</span>
                try {
<span class="nc" id="L872">                    pkg = getPackage(nm.getQualifier());</span>
<span class="nc" id="L873">                    srcfile = pkg.getSourceFile(nm.getName());</span>
<span class="nc" id="L874">                } catch (IOException e)  {</span>
<span class="nc" id="L875">                    error(0, &quot;io.exception&quot;, c);</span>
                    if (tracing)
<span class="nc" id="L877">                        dtEvent(&quot;loadDefinition: IO EXCEPTION (package)&quot;);</span>
<span class="nc" id="L878">                }</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">                if (srcfile == null) {</span>
                    // not found, there is no source
<span class="nc" id="L881">                    c.setDefinition(null, CS_NOTFOUND);</span>
                    if (tracing)
<span class="nc" id="L883">                        dtExit(&quot;loadDefinition: SOURCE NOT FOUND &quot; +</span>
<span class="nc" id="L884">                               c.getName() + &quot;, status &quot; + c.getStatus());</span>
<span class="nc" id="L885">                    return;</span>
                }
            }
            try {
<span class="nc" id="L889">                parseFile(srcfile);</span>
<span class="nc" id="L890">            } catch (FileNotFoundException e) {</span>
<span class="nc" id="L891">                error(0, &quot;io.exception&quot;, srcfile);</span>
<span class="nc" id="L892">                if (tracing) dtEvent(&quot;loadDefinition: IO EXCEPTION (source)&quot;);</span>
<span class="nc" id="L893">            }</span>
<span class="nc bnc" id="L894" title="All 4 branches missed.">            if ((c.getClassDefinition() == null) || (c.getStatus() == CS_SOURCE)) {</span>
                // not found after parsing the file
<span class="nc" id="L896">                error(0, &quot;wrong.source&quot;, srcfile.getPath(), c, pkg);</span>
<span class="nc" id="L897">                c.setDefinition(null, CS_NOTFOUND);</span>
                if (tracing)
<span class="nc" id="L899">                    dtEvent(&quot;loadDefinition: WRONG CLASS (source) &quot; +</span>
<span class="nc" id="L900">                            c.getName());</span>
            }
<span class="nc" id="L902">            if (tracing) dtExit(&quot;loadDefinition: EXIT &quot; +</span>
<span class="nc" id="L903">                                c.getName() + &quot;, status &quot; + c.getStatus());</span>
<span class="nc" id="L904">            return;</span>
          }
        }
<span class="nc" id="L907">        if (tracing) dtExit(&quot;loadDefinition: EXIT &quot; +</span>
<span class="nc" id="L908">                            c.getName() + &quot;, status &quot; + c.getStatus());</span>
<span class="nc" id="L909">    }</span>

    /**
     * Create a new class.
     */
    public ClassDefinition makeClassDefinition(Environment toplevelEnv,
                                               long where,
                                               IdentifierToken name,
                                               String doc, int modifiers,
                                               IdentifierToken superClass,
                                               IdentifierToken interfaces[],
                                               ClassDefinition outerClass) {

<span class="nc" id="L922">        Identifier nm = name.getName();</span>
<span class="nc" id="L923">        long nmpos = name.getWhere();</span>

        Identifier pkgNm;
<span class="nc" id="L926">        String mangledName = null;</span>
<span class="nc" id="L927">        ClassDefinition localContextClass = null;</span>

        // Provide name for a local class.  This used to be set after
        // the class was created, but it is needed for checking within
        // the class constructor.
        // NOTE: It seems that we could always provide the simple name,
        // and thereby avoid the test in 'ClassDefinition.getLocalName()'
        // for the definedness of the local name.  There, if the local
        // name is not set, a simple name is extracted from the result of
        // 'getName()'.  That name can potentially change, however, as
        // it is ultimately derived from 'ClassType.className', which is
        // set by 'Type.changeClassName'.  Better leave this alone...
<span class="nc" id="L939">        Identifier localName = null;</span>

<span class="nc bnc" id="L941" title="All 4 branches missed.">        if (nm.isQualified() || nm.isInner()) {</span>
<span class="nc" id="L942">            pkgNm = nm;</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">        } else if ((modifiers &amp; (M_LOCAL | M_ANONYMOUS)) != 0) {</span>
            // Inaccessible class.  Create a name of the form
            // 'PackageMember.N$localName' or 'PackageMember.N'.
            // Note that the '.' will be converted later to a '$'.
            //   pkgNm = generateName(outerClass, nm);
<span class="nc" id="L948">            localContextClass = outerClass.getTopClass();</span>
            // Always use the smallest number in generating the name that
            // renders the complete name unique within the top-level class.
            // This is required to make the names more predictable, as part
            // of a serialization-related workaround, and satisfies an obscure
            // requirement that the name of a local class be of the form
            // 'PackageMember$1$localName' when this name is unique.
<span class="nc" id="L955">            for (int i = 1 ; ; i++) {</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">                mangledName = i + (nm.equals(idNull) ? &quot;&quot; : SIG_INNERCLASS + nm);</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">                if (localContextClass.getLocalClass(mangledName) == null) {</span>
<span class="nc" id="L958">                    break;</span>
                }
            }
<span class="nc" id="L961">            Identifier outerNm = localContextClass.getName();</span>
<span class="nc" id="L962">            pkgNm = Identifier.lookupInner(outerNm, Identifier.lookup(mangledName));</span>
            //System.out.println(&quot;LOCAL CLASS: &quot; + pkgNm + &quot; IN &quot; + localContextClass);
<span class="nc bnc" id="L964" title="All 2 branches missed.">            if ((modifiers &amp; M_ANONYMOUS) != 0) {</span>
<span class="nc" id="L965">                localName = idNull;</span>
            } else {
                // Local class has a locally-scoped name which is independent of pkgNm.
<span class="nc" id="L968">                localName = nm;</span>
            }
<span class="nc bnc" id="L970" title="All 2 branches missed.">        } else if (outerClass != null) {</span>
            // Accessible inner class.  Qualify name with surrounding class name.
<span class="nc" id="L972">            pkgNm = Identifier.lookupInner(outerClass.getName(), nm);</span>
        } else {
<span class="nc" id="L974">            pkgNm = nm;</span>
        }

        // Find the class
<span class="nc" id="L978">        ClassDeclaration c = toplevelEnv.getClassDeclaration(pkgNm);</span>

        // Make sure this is the first definition
<span class="nc bnc" id="L981" title="All 2 branches missed.">        if (c.isDefined()) {</span>
<span class="nc" id="L982">            toplevelEnv.error(nmpos, &quot;class.multidef&quot;,</span>
<span class="nc" id="L983">                              c.getName(), c.getClassDefinition().getSource());</span>
            // Don't mess with the existing class declarations with same name
<span class="nc" id="L985">            c = new ClassDeclaration (pkgNm);</span>
        }

<span class="nc bnc" id="L988" title="All 4 branches missed.">        if (superClass == null &amp;&amp; !pkgNm.equals(idJavaLangObject)) {</span>
<span class="nc" id="L989">            superClass = new IdentifierToken(idJavaLangObject);</span>
        }

<span class="nc" id="L992">        ClassDefinition sourceClass =</span>
            new SourceClass(toplevelEnv, where, c, doc,
                            modifiers, superClass, interfaces,
                            (SourceClass) outerClass, localName);

<span class="nc bnc" id="L997" title="All 2 branches missed.">        if (outerClass != null) {</span>
            // It is a member of its enclosing class.
<span class="nc" id="L999">            outerClass.addMember(toplevelEnv, new SourceMember(sourceClass));</span>
            // Record local (or anonymous) class in the class whose name will
            // serve as the prefix of the local class name.  This is necessary
            // so that the class may be retrieved from its name, which does not
            // fully represent the class nesting structure.
            // See 'ClassDefinition.getClassDefinition'.
            // This is part of a fix for bugid 4054523 and 4030421.
<span class="nc bnc" id="L1006" title="All 2 branches missed.">            if ((modifiers &amp; (M_LOCAL | M_ANONYMOUS)) != 0) {</span>
<span class="nc" id="L1007">                localContextClass.addLocalClass(sourceClass, mangledName);</span>
            }
        }

        // The local name of an anonymous or local class used to be set here
        // with a call to 'setLocalName'.  This has been moved to the constructor
        // for 'SourceClass', which now takes a 'localName' argument.

<span class="nc" id="L1015">        return sourceClass;</span>
    }

    /**
     * Create a new field.
     */
    public MemberDefinition makeMemberDefinition(Environment origEnv, long where,
                                               ClassDefinition clazz,
                                               String doc, int modifiers,
                                               Type type, Identifier name,
                                               IdentifierToken argNames[],
                                               IdentifierToken expIds[],
                                               Object value) {
<span class="nc" id="L1028">        if (tracing) dtEvent(&quot;makeMemberDefinition: &quot; + name + &quot; IN &quot; + clazz);</span>
<span class="nc" id="L1029">        Vector v = null;</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (argNames != null) {</span>
<span class="nc" id="L1031">            v = new Vector(argNames.length);</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">            for (int i = 0 ; i &lt; argNames.length ; i++) {</span>
<span class="nc" id="L1033">                v.addElement(argNames[i]);</span>
            }
        }
<span class="nc" id="L1036">        SourceMember f = new SourceMember(where, clazz, doc, modifiers,</span>
                                        type, name, v, expIds, (Node)value);
<span class="nc" id="L1038">        clazz.addMember(origEnv, f);</span>
<span class="nc" id="L1039">        return f;</span>
    }

    /**
     * Release resources in classpath.
     */
    public void shutdown() {
        try {
<span class="nc bnc" id="L1047" title="All 2 branches missed.">            if (sourcePath != null) {</span>
<span class="nc" id="L1048">                sourcePath.close();</span>
            }
<span class="nc bnc" id="L1050" title="All 4 branches missed.">            if (binaryPath != null &amp;&amp; binaryPath != sourcePath) {</span>
<span class="nc" id="L1051">                binaryPath.close();</span>
            }
<span class="nc" id="L1053">        } catch (IOException ee) {</span>
<span class="nc" id="L1054">            output(Main.getText(&quot;benv.failed_to_close_class_path&quot;,</span>
<span class="nc" id="L1055">                                ee.toString()));</span>
<span class="nc" id="L1056">        }</span>
<span class="nc" id="L1057">        sourcePath = null;</span>
<span class="nc" id="L1058">        binaryPath = null;</span>

<span class="nc" id="L1060">        super.shutdown();</span>
<span class="nc" id="L1061">    }</span>

    /**
     * Error String
     */
    public
    String errorString(String err, Object arg1, Object arg2, Object arg3) {
<span class="nc" id="L1068">        String key = null;</span>

<span class="nc bnc" id="L1070" title="All 2 branches missed.">        if(err.startsWith(&quot;warn.&quot;))</span>
<span class="nc" id="L1071">            key = &quot;javac.err.&quot; + err.substring(5);</span>
        else
<span class="nc" id="L1073">            key = &quot;javac.err.&quot; + err;</span>

<span class="nc bnc" id="L1075" title="All 2 branches missed.">        return Main.getText(key,</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">                            arg1 != null ? arg1.toString() : null,</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">                            arg2 != null ? arg2.toString() : null,</span>
<span class="nc" id="L1078">                            arg3 != null ? arg3.toString() : null);</span>
    }

    /**
     * The filename where the last errors have occurred
     */
    String errorFileName;

    /**
     * List of outstanding error messages
     */
    ErrorMessage errors;

    /**
     * Insert an error message in the list of outstanding error messages.
     * The list is sorted on input position and contains no duplicates.
     * The return value indicates whether or not the message was
     * actually inserted.
     *
     * The method flushErrors() used to check for duplicate error messages.
     * It would only detect duplicates if they were contiguous.  Removing
     * non-contiguous duplicate error messages is slightly less complicated
     * at insertion time, so the functionality was moved here.  This also
     * saves a miniscule number of allocations.
     */
    protected
    boolean insertError(long where, String message) {
        //output(&quot;ERR = &quot; + message);

<span class="nc bnc" id="L1107" title="All 4 branches missed.">        if (errors == null</span>
            ||  errors.where &gt; where) {
            // If the list is empty, or the error comes before any other
            // errors, insert it at the beginning of the list.
<span class="nc" id="L1111">            ErrorMessage newMsg = new ErrorMessage(where, message);</span>
<span class="nc" id="L1112">            newMsg.next = errors;</span>
<span class="nc" id="L1113">            errors = newMsg;</span>

<span class="nc bnc" id="L1115" title="All 2 branches missed.">        } else if (errors.where == where</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">                   &amp;&amp; errors.message.equals(message)) {</span>
            // The new message is an exact duplicate of the first message
            // in the list.  Don't insert it.
<span class="nc" id="L1119">            return false;</span>

        } else {
            // Okay, we know that the error doesn't come first.  Walk
            // the list until we find the right position for insertion.
<span class="nc" id="L1124">            ErrorMessage current = errors;</span>
            ErrorMessage next;

<span class="nc bnc" id="L1127" title="All 4 branches missed.">            while ((next = current.next) != null</span>
                   &amp;&amp; next.where &lt; where) {
<span class="nc" id="L1129">                current = next;</span>
            }

            // Now walk over any errors with the same location, looking
            // for duplicates.  If we find a duplicate, don't insert the
            // error.
<span class="nc bnc" id="L1135" title="All 4 branches missed.">            while ((next = current.next) != null</span>
                   &amp;&amp; next.where == where) {
<span class="nc bnc" id="L1137" title="All 2 branches missed.">                if (next.message.equals(message)) {</span>
                    // We have found an exact duplicate.  Don't bother to
                    // insert the error.
<span class="nc" id="L1140">                    return false;</span>
                }
<span class="nc" id="L1142">                current = next;</span>
            }

            // Now insert after current.
<span class="nc" id="L1146">            ErrorMessage newMsg = new ErrorMessage(where, message);</span>
<span class="nc" id="L1147">            newMsg.next = current.next;</span>
<span class="nc" id="L1148">            current.next = newMsg;</span>
        }

        // Indicate that the insertion occurred.
<span class="nc" id="L1152">        return true;</span>
    }

    private int errorsPushed;

    /**
     * Maximum number of errors to print.
     */
<span class="nc" id="L1160">    public int errorLimit = 100;</span>

    private boolean hitErrorLimit;

    /**
     * Flush outstanding errors
     */

        public void pushError(String errorFileName, int line, String message,
                                    String referenceText, String referenceTextPointer) {
<span class="nc" id="L1170">                int limit = errorLimit + nwarnings;</span>
<span class="nc bnc" id="L1171" title="All 4 branches missed.">                if (++errorsPushed &gt;= limit &amp;&amp; errorLimit &gt;= 0) {</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">                    if (!hitErrorLimit) {</span>
<span class="nc" id="L1173">                        hitErrorLimit = true;</span>
<span class="nc" id="L1174">                        output(errorString(&quot;too.many.errors&quot;,</span>
                                           new Integer(errorLimit),null,null));
                    }
<span class="nc" id="L1177">                    return;</span>
                }
<span class="nc bnc" id="L1179" title="All 2 branches missed.">                if (errorFileName.endsWith(&quot;.java&quot;)) {</span>
<span class="nc" id="L1180">                    output(errorFileName + &quot;:&quot; + line + &quot;: &quot; + message);</span>
<span class="nc" id="L1181">                    output(referenceText);</span>
<span class="nc" id="L1182">                    output(referenceTextPointer);</span>
                } else {
                    // It wasn't really a source file (probably an error or
                    // warning because of a malformed or badly versioned
                    // class file.
<span class="nc" id="L1187">                    output(errorFileName + &quot;: &quot; + message);</span>
                }
<span class="nc" id="L1189">        }</span>

    public void flushErrors() {
<span class="nc bnc" id="L1192" title="All 2 branches missed.">        if (errors == null) {</span>
<span class="nc" id="L1193">            return;</span>
        }

<span class="nc" id="L1196">        boolean inputAvail = false;</span>
        // Read the file
<span class="nc" id="L1198">        char data[] = null;</span>
<span class="nc" id="L1199">        int dataLength = 0;</span>
        // A malformed file encoding could cause a CharConversionException.
        // If something bad happens while trying to find the source file,
        // don't bother trying to show lines.
        try {
<span class="nc" id="L1204">            FileInputStream in = new FileInputStream(errorFileName);</span>
<span class="nc" id="L1205">            data = new char[in.available()];</span>
<span class="nc" id="L1206">            InputStreamReader reader =</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">                (getCharacterEncoding() != null ?</span>
<span class="nc" id="L1208">                 new InputStreamReader(in, getCharacterEncoding()) :</span>
                 new InputStreamReader(in));
<span class="nc" id="L1210">            dataLength = reader.read(data);</span>
<span class="nc" id="L1211">            reader.close();</span>
<span class="nc" id="L1212">            inputAvail = true;</span>
<span class="nc" id="L1213">        } catch(IOException e) {</span>
            // inputAvail will not be set
<span class="nc" id="L1215">        }</span>

        // Report the errors
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        for (ErrorMessage msg = errors ; msg != null ; msg = msg.next) {</span>
            // There used to be code here which checked
            // for duplicate error messages.  This functionality
            // has been moved to the method insertError().  See
            // the comments on that method for more information.

<span class="nc" id="L1224">            int ln = (int) (msg.where &gt;&gt;&gt; WHEREOFFSETBITS);</span>
<span class="nc" id="L1225">            int off = (int) (msg.where &amp; ((1L &lt;&lt; WHEREOFFSETBITS) - 1));</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">            if (off &gt; dataLength)  off = dataLength;</span>

<span class="nc" id="L1228">            String referenceString = &quot;&quot;;</span>
<span class="nc" id="L1229">            String markerString = &quot;&quot;;</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">            if(inputAvail) {</span>
                int i, j;
<span class="nc bnc" id="L1232" title="All 6 branches missed.">                for (i = off ; (i &gt; 0) &amp;&amp; (data[i - 1] != '\n') &amp;&amp; (data[i - 1] != '\r') ; i--);</span>
<span class="nc bnc" id="L1233" title="All 6 branches missed.">                for (j = off ; (j &lt; dataLength) &amp;&amp; (data[j] != '\n') &amp;&amp; (data[j] != '\r') ; j++);</span>
<span class="nc" id="L1234">                referenceString = new String(data, i, j - i);</span>

<span class="nc" id="L1236">                char strdata[] = new char[(off - i) + 1];</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">                for (j = i ; j &lt; off ; j++) {</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">                    strdata[j-i] = (data[j] == '\t') ? '\t' : ' ';</span>
                }
<span class="nc" id="L1240">                strdata[off-i] = '^';</span>
<span class="nc" id="L1241">                markerString = new String(strdata);</span>
            }

<span class="nc" id="L1244">            errorConsumer.pushError(errorFileName, ln, msg.message,</span>
                                        referenceString, markerString);
        }
<span class="nc" id="L1247">        errors = null;</span>
<span class="nc" id="L1248">    }</span>

    /**
     * Report error
     */
    public
    void reportError(Object src, long where, String err, String msg) {
<span class="nc bnc" id="L1255" title="All 2 branches missed.">        if (src == null) {</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">            if (errorFileName != null) {</span>
<span class="nc" id="L1257">                flushErrors();</span>
<span class="nc" id="L1258">                errorFileName = null;</span>
            }
<span class="nc bnc" id="L1260" title="All 2 branches missed.">            if (err.startsWith(&quot;warn.&quot;)) {</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">                if (warnings()) {</span>
<span class="nc" id="L1262">                    nwarnings++;</span>
<span class="nc" id="L1263">                    output(msg);</span>
                }
<span class="nc" id="L1265">                return;</span>
            }
<span class="nc" id="L1267">            output(&quot;error: &quot; + msg);</span>
<span class="nc" id="L1268">            nerrors++;</span>
<span class="nc" id="L1269">            flags |= F_ERRORSREPORTED;</span>

<span class="nc bnc" id="L1271" title="All 2 branches missed.">        } else if (src instanceof String) {</span>
<span class="nc" id="L1272">            String fileName = (String)src;</span>

            // Flush errors if we've moved on to a new file.
<span class="nc bnc" id="L1275" title="All 2 branches missed.">            if (!fileName.equals(errorFileName)) {</span>
<span class="nc" id="L1276">                flushErrors();</span>
<span class="nc" id="L1277">                errorFileName = fileName;</span>
            }

            // Classify `err' as a warning, deprecation warning, or
            // error message.  Proceed accordingly.
<span class="nc bnc" id="L1282" title="All 2 branches missed.">            if (err.startsWith(&quot;warn.&quot;)) {</span>
<span class="nc bnc" id="L1283" title="All 2 branches missed.">                if (err.indexOf(&quot;is.deprecated&quot;) &gt;= 0) {</span>
                    // This is a deprecation warning.  Add `src' to the
                    // list of files with deprecation warnings.
<span class="nc bnc" id="L1286" title="All 2 branches missed.">                    if (!deprecationFiles.contains(src)) {</span>
<span class="nc" id="L1287">                        deprecationFiles.addElement(src);</span>
                    }

                    // If we are reporting deprecations, try to add it
                    // to our list.  Otherwise, just increment the
                    // deprecation count.
<span class="nc bnc" id="L1293" title="All 2 branches missed.">                    if (deprecation()) {</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">                        if (insertError(where, msg)) {</span>
<span class="nc" id="L1295">                            ndeprecations++;</span>
                        }
                    } else {
<span class="nc" id="L1298">                        ndeprecations++;</span>
                    }
                } else {
                    // This is a regular warning.  If we are reporting
                    // warnings, try to add it to the list.  Otherwise, just
                    // increment the warning count.
<span class="nc bnc" id="L1304" title="All 2 branches missed.">                    if (warnings()) {</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">                        if (insertError(where, msg)) {</span>
<span class="nc" id="L1306">                            nwarnings++;</span>
                        }
                    } else {
<span class="nc" id="L1309">                        nwarnings++;</span>
                    }
                }
            } else {
                // This is an error.  Try to add it to the list of errors.
                // If it isn't a duplicate, increment our error count.
<span class="nc bnc" id="L1315" title="All 2 branches missed.">                if (insertError(where, msg)) {</span>
<span class="nc" id="L1316">                    nerrors++;</span>
<span class="nc" id="L1317">                    flags |= F_ERRORSREPORTED;</span>
                }
            }
<span class="nc bnc" id="L1320" title="All 2 branches missed.">        } else if (src instanceof ClassFile) {</span>
<span class="nc" id="L1321">            reportError(((ClassFile)src).getPath(), where, err, msg);</span>

<span class="nc bnc" id="L1323" title="All 2 branches missed.">        } else if (src instanceof Identifier) {</span>
<span class="nc" id="L1324">            reportError(src.toString(), where, err, msg);</span>

<span class="nc bnc" id="L1326" title="All 2 branches missed.">        } else if (src instanceof ClassDeclaration) {</span>
            try {
<span class="nc" id="L1328">                reportError(((ClassDeclaration)src).getClassDefinition(this), where, err, msg);</span>
<span class="nc" id="L1329">            } catch (ClassNotFound e) {</span>
<span class="nc" id="L1330">                reportError(((ClassDeclaration)src).getName(), where, err, msg);</span>
<span class="nc" id="L1331">            }</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">        } else if (src instanceof ClassDefinition) {</span>
<span class="nc" id="L1333">            ClassDefinition c = (ClassDefinition)src;</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">            if (!err.startsWith(&quot;warn.&quot;)) {</span>
<span class="nc" id="L1335">                c.setError();</span>
            }
<span class="nc" id="L1337">            reportError(c.getSource(), where, err, msg);</span>

<span class="nc bnc" id="L1339" title="All 2 branches missed.">        } else if (src instanceof MemberDefinition) {</span>
<span class="nc" id="L1340">            reportError(((MemberDefinition)src).getClassDeclaration(), where, err, msg);</span>

        } else {
<span class="nc" id="L1343">            output(src + &quot;:error=&quot; + err + &quot;:&quot; + msg);</span>
        }
<span class="nc" id="L1345">    }</span>

    /**
     * Issue an error
     */
    public void error(Object source, long where, String err, Object arg1, Object arg2, Object arg3) {
<span class="nc bnc" id="L1351" title="All 2 branches missed.">        if (errorsPushed &gt;= errorLimit + nwarnings) {</span>
            // Don't bother to queue any more errors if they won't get printed.
<span class="nc" id="L1353">            return;</span>
        }
<span class="nc bnc" id="L1355" title="All 2 branches missed.">        if (System.getProperty(&quot;javac.dump.stack&quot;) != null) {</span>
<span class="nc" id="L1356">            output(&quot;javac.err.&quot;+err+&quot;: &quot;+errorString(err, arg1, arg2, arg3));</span>
<span class="nc" id="L1357">            new Exception(&quot;Stack trace&quot;).printStackTrace(new PrintStream(out));</span>
        }
<span class="nc" id="L1359">        reportError(source, where, err, errorString(err, arg1, arg2, arg3));</span>
<span class="nc" id="L1360">    }</span>

    /**
     * Output a string. This can either be an error message or something
     * for debugging.
     */
    public void output(String msg) {
<span class="nc bnc" id="L1367" title="All 2 branches missed.">        PrintStream out =</span>
            this.out instanceof PrintStream ? (PrintStream)this.out
                                            : new PrintStream(this.out, true);
<span class="nc" id="L1370">        out.println(msg);</span>
<span class="nc" id="L1371">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>