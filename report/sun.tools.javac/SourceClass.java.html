<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SourceClass.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.javac</a> &gt; <span class="el_source">SourceClass.java</span></div><h1>SourceClass.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.javac;

import sun.tools.java.*;
import sun.tools.tree.*;
import sun.tools.tree.CompoundStatement;
import sun.tools.asm.Assembler;
import sun.tools.asm.ConstantPool;
import java.util.Vector;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.io.IOException;
import java.io.OutputStream;
import java.io.DataOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;

/**
 * This class represents an Java class as it is read from
 * an Java source file.
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
@Deprecated
public
class SourceClass extends ClassDefinition {

    /**
     * The toplevel environment, shared with the parser
     */
    Environment toplevelEnv;

    /**
     * The default constructor
     */
    SourceMember defConstructor;

    /**
     * The constant pool
     */
<span class="nc" id="L68">    ConstantPool tab = new ConstantPool();</span>

   /**
     * The list of class dependencies
     */
<span class="nc" id="L73">    Hashtable deps = new Hashtable(11);</span>

    /**
     * The field used to represent &quot;this&quot; in all of my code.
     */
    LocalMember thisArg;

    /**
     * Last token of class, as reported by parser.
     */
    long endPosition;

    /**
     * Access methods for constructors are distinguished from
     * the constructors themselves by a dummy first argument.
     * A unique type used for this purpose and shared by all
     * constructor access methods within a package-member class is
     * maintained here.
     * &lt;p&gt;
     * This field is null except in an outermost class containing
     * one or more classes needing such an access method.
     */
<span class="nc" id="L95">    private Type dummyArgumentType = null;</span>

    /**
     * Constructor
     */
    public SourceClass(Environment env, long where,
                       ClassDeclaration declaration, String documentation,
                       int modifiers, IdentifierToken superClass,
                       IdentifierToken interfaces[],
                       SourceClass outerClass, Identifier localName) {
<span class="nc" id="L105">        super(env.getSource(), where,</span>
              declaration, modifiers, superClass, interfaces);
<span class="nc" id="L107">        setOuterClass(outerClass);</span>

<span class="nc" id="L109">        this.toplevelEnv = env;</span>
<span class="nc" id="L110">        this.documentation = documentation;</span>

<span class="nc bnc" id="L112" title="All 2 branches missed.">        if (ClassDefinition.containsDeprecated(documentation)) {</span>
<span class="nc" id="L113">            this.modifiers |= M_DEPRECATED;</span>
        }

        // Check for a package level class which is declared static.
<span class="nc bnc" id="L117" title="All 4 branches missed.">        if (isStatic() &amp;&amp; outerClass == null) {</span>
<span class="nc" id="L118">            env.error(where, &quot;static.class&quot;, this);</span>
<span class="nc" id="L119">            this.modifiers &amp;=~ M_STATIC;</span>
        }

        // Inner classes cannot be static, nor can they be interfaces
        // (which are implicitly static).  Static classes and interfaces
        // can only occur as top-level entities.
        //
        // Note that we do not have to check for local classes declared
        // to be static (this is currently caught by the parser) but
        // we check anyway in case the parser is modified to allow this.
<span class="nc bnc" id="L129" title="All 6 branches missed.">        if (isLocal() || (outerClass != null &amp;&amp; !outerClass.isTopLevel())) {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (isInterface()) {</span>
<span class="nc" id="L131">                env.error(where, &quot;inner.interface&quot;);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">            } else if (isStatic()) {</span>
<span class="nc" id="L133">                env.error(where, &quot;static.inner.class&quot;, this);</span>
<span class="nc" id="L134">                this.modifiers &amp;=~ M_STATIC;</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                if (innerClassMember != null) {</span>
<span class="nc" id="L136">                    innerClassMember.subModifiers(M_STATIC);</span>
                }
            }
        }

<span class="nc bnc" id="L141" title="All 4 branches missed.">        if (isPrivate() &amp;&amp; outerClass == null) {</span>
<span class="nc" id="L142">            env.error(where, &quot;private.class&quot;, this);</span>
<span class="nc" id="L143">            this.modifiers &amp;=~ M_PRIVATE;</span>
        }
<span class="nc bnc" id="L145" title="All 4 branches missed.">        if (isProtected() &amp;&amp; outerClass == null) {</span>
<span class="nc" id="L146">            env.error(where, &quot;protected.class&quot;, this);</span>
<span class="nc" id="L147">            this.modifiers &amp;=~ M_PROTECTED;</span>
        }
        /*----*
        if ((isPublic() || isProtected()) &amp;&amp; isInsideLocal()) {
            env.error(where, &quot;warn.public.local.class&quot;, this);
        }
         *----*/

        // maybe define an uplevel &quot;A.this&quot; current instance field
<span class="nc bnc" id="L156" title="All 4 branches missed.">        if (!isTopLevel() &amp;&amp; !isLocal()) {</span>
<span class="nc" id="L157">            LocalMember outerArg = ((SourceClass)outerClass).getThisArgument();</span>
<span class="nc" id="L158">            UplevelReference r = getReference(outerArg);</span>
<span class="nc" id="L159">            setOuterMember(r.getLocalField(env));</span>
        }

        // Set simple, unmangled local name for a local or anonymous class.
        // NOTE: It would be OK to do this unconditionally, as null is the
        // correct value for a member (non-local) class.
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (localName != null)</span>
<span class="nc" id="L166">            setLocalName(localName);</span>

        // Check for inner class with same simple name as one of
        // its enclosing classes.  Note that 'getLocalName' returns
        // the simple, unmangled source-level name of any class.
        // The previous version of this code was not careful to avoid
        // mangled local class names.  This version fixes 4047746.
<span class="nc" id="L173">        Identifier thisName = getLocalName();</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (thisName != idNull) {</span>
            // Test above suppresses error for nested anonymous classes,
            // which have an internal &quot;name&quot;, but are not named in source code.
<span class="nc bnc" id="L177" title="All 2 branches missed.">            for (ClassDefinition scope = outerClass; scope != null;</span>
<span class="nc" id="L178">                  scope = scope.getOuterClass()) {</span>
<span class="nc" id="L179">                Identifier outerName = scope.getLocalName();</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                if (thisName.equals(outerName))</span>
<span class="nc" id="L181">                    env.error(where, &quot;inner.redefined&quot;, thisName);</span>
            }
        }
<span class="nc" id="L184">    }</span>

    /**
     * Return last position in this class.
     * @see #getWhere
     */
    public long getEndPosition() {
<span class="nc" id="L191">        return endPosition;</span>
    }

    public void setEndPosition(long endPosition) {
<span class="nc" id="L195">        this.endPosition = endPosition;</span>
<span class="nc" id="L196">    }</span>


// JCOV
    /**
     * Return absolute name of source file
     */
    public String getAbsoluteName() {
<span class="nc" id="L204">        String AbsName = ((ClassFile)getSource()).getAbsoluteName();</span>

<span class="nc" id="L206">        return AbsName;</span>
    }
//end JCOV

    /**
     * Return imports
     */
    public Imports getImports() {
<span class="nc" id="L214">        return toplevelEnv.getImports();</span>
    }

    /**
     * Find or create my &quot;this&quot; argument, which is used for all methods.
     */
    public LocalMember getThisArgument() {
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (thisArg == null) {</span>
<span class="nc" id="L222">            thisArg = new LocalMember(where, this, 0, getType(), idThis);</span>
        }
<span class="nc" id="L224">        return thisArg;</span>
    }

    /**
     * Add a dependency
     */
    public void addDependency(ClassDeclaration c) {
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (tab != null) {</span>
<span class="nc" id="L232">            tab.put(c);</span>
        }
        // If doing -xdepend option, save away list of class dependencies
        //   making sure to NOT include duplicates or the class we are in
        //   (Hashtable's put() makes sure we don't have duplicates)
<span class="nc bnc" id="L237" title="All 4 branches missed.">        if ( toplevelEnv.print_dependencies() &amp;&amp; c != getClassDeclaration() ) {</span>
<span class="nc" id="L238">            deps.put(c,c);</span>
        }
<span class="nc" id="L240">    }</span>

    /**
     * Add a field (check it first)
     */
    public void addMember(Environment env, MemberDefinition f) {
        // Make sure the access permissions are self-consistent:
<span class="nc bnc" id="L247" title="All 2 branches missed.">        switch (f.getModifiers() &amp; (M_PUBLIC | M_PRIVATE | M_PROTECTED)) {</span>
        case M_PUBLIC:
        case M_PRIVATE:
        case M_PROTECTED:
        case 0:
<span class="nc" id="L252">            break;</span>
        default:
<span class="nc" id="L254">            env.error(f.getWhere(), &quot;inconsistent.modifier&quot;, f);</span>
            // Cut out the more restrictive modifier(s):
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (f.isPublic()) {</span>
<span class="nc" id="L257">                f.subModifiers(M_PRIVATE | M_PROTECTED);</span>
            } else {
<span class="nc" id="L259">                f.subModifiers(M_PRIVATE);</span>
            }
            break;
        }

        // Note exemption for synthetic members below.
<span class="nc bnc" id="L265" title="All 6 branches missed.">        if (f.isStatic() &amp;&amp; !isTopLevel() &amp;&amp; !f.isSynthetic()) {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (f.isMethod()) {</span>
<span class="nc" id="L267">                env.error(f.getWhere(), &quot;static.inner.method&quot;, f, this);</span>
<span class="nc" id="L268">                f.subModifiers(M_STATIC);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            } else if (f.isVariable()) {</span>
<span class="nc bnc" id="L270" title="All 4 branches missed.">                if (!f.isFinal() || f.isBlankFinal()) {</span>
<span class="nc" id="L271">                    env.error(f.getWhere(), &quot;static.inner.field&quot;, f.getName(), this);</span>
<span class="nc" id="L272">                    f.subModifiers(M_STATIC);</span>
                }
                // Even if a static passes this test, there is still another
                // check in 'SourceMember.check'.  The check is delayed so
                // that the initializer may be inspected more closely, using
                // 'isConstant()'.  Part of fix for 4095568.
            } else {
                // Static inner classes are diagnosed in 'SourceClass.&lt;init&gt;'.
<span class="nc" id="L280">                f.subModifiers(M_STATIC);</span>
            }
        }

<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (f.isMethod()) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (f.isConstructor()) {</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                if (f.getClassDefinition().isInterface()) {</span>
<span class="nc" id="L287">                    env.error(f.getWhere(), &quot;intf.constructor&quot;);</span>
<span class="nc" id="L288">                    return;</span>
                }
<span class="nc bnc" id="L290" title="All 4 branches missed.">                if (f.isNative() || f.isAbstract() ||</span>
<span class="nc bnc" id="L291" title="All 6 branches missed.">                      f.isStatic() || f.isSynchronized() || f.isFinal()) {</span>
<span class="nc" id="L292">                    env.error(f.getWhere(), &quot;constr.modifier&quot;, f);</span>
<span class="nc" id="L293">                    f.subModifiers(M_NATIVE | M_ABSTRACT |</span>
                                   M_STATIC | M_SYNCHRONIZED | M_FINAL);
                }
<span class="nc bnc" id="L296" title="All 2 branches missed.">            } else if (f.isInitializer()) {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">                if (f.getClassDefinition().isInterface()) {</span>
<span class="nc" id="L298">                    env.error(f.getWhere(), &quot;intf.initializer&quot;);</span>
<span class="nc" id="L299">                    return;</span>
                }
            }

            // f is not allowed to return an array of void
<span class="nc bnc" id="L304" title="All 2 branches missed.">            if ((f.getType().getReturnType()).isVoidArray()) {</span>
<span class="nc" id="L305">                env.error(f.getWhere(), &quot;void.array&quot;);</span>
            }

<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (f.getClassDefinition().isInterface() &amp;&amp;</span>
<span class="nc bnc" id="L309" title="All 6 branches missed.">                (f.isStatic() || f.isSynchronized() || f.isNative()</span>
<span class="nc bnc" id="L310" title="All 6 branches missed.">                 || f.isFinal() || f.isPrivate() || f.isProtected())) {</span>
<span class="nc" id="L311">                env.error(f.getWhere(), &quot;intf.modifier.method&quot;, f);</span>
<span class="nc" id="L312">                f.subModifiers(M_STATIC |  M_SYNCHRONIZED | M_NATIVE |</span>
                               M_FINAL | M_PRIVATE);
            }
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (f.isTransient()) {</span>
<span class="nc" id="L316">                env.error(f.getWhere(), &quot;transient.meth&quot;, f);</span>
<span class="nc" id="L317">                f.subModifiers(M_TRANSIENT);</span>
            }
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (f.isVolatile()) {</span>
<span class="nc" id="L320">                env.error(f.getWhere(), &quot;volatile.meth&quot;, f);</span>
<span class="nc" id="L321">                f.subModifiers(M_VOLATILE);</span>
            }
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (f.isAbstract()) {</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">                if (f.isPrivate()) {</span>
<span class="nc" id="L325">                    env.error(f.getWhere(), &quot;abstract.private.modifier&quot;, f);</span>
<span class="nc" id="L326">                    f.subModifiers(M_PRIVATE);</span>
                }
<span class="nc bnc" id="L328" title="All 2 branches missed.">                if (f.isStatic()) {</span>
<span class="nc" id="L329">                    env.error(f.getWhere(), &quot;abstract.static.modifier&quot;, f);</span>
<span class="nc" id="L330">                    f.subModifiers(M_STATIC);</span>
                }
<span class="nc bnc" id="L332" title="All 2 branches missed.">                if (f.isFinal()) {</span>
<span class="nc" id="L333">                    env.error(f.getWhere(), &quot;abstract.final.modifier&quot;, f);</span>
<span class="nc" id="L334">                    f.subModifiers(M_FINAL);</span>
                }
<span class="nc bnc" id="L336" title="All 2 branches missed.">                if (f.isNative()) {</span>
<span class="nc" id="L337">                    env.error(f.getWhere(), &quot;abstract.native.modifier&quot;, f);</span>
<span class="nc" id="L338">                    f.subModifiers(M_NATIVE);</span>
                }
<span class="nc bnc" id="L340" title="All 2 branches missed.">                if (f.isSynchronized()) {</span>
<span class="nc" id="L341">                    env.error(f.getWhere(),&quot;abstract.synchronized.modifier&quot;,f);</span>
<span class="nc" id="L342">                    f.subModifiers(M_SYNCHRONIZED);</span>
                }
            }
<span class="nc bnc" id="L345" title="All 4 branches missed.">            if (f.isAbstract() || f.isNative()) {</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">                if (f.getValue() != null) {</span>
<span class="nc" id="L347">                    env.error(f.getWhere(), &quot;invalid.meth.body&quot;, f);</span>
<span class="nc" id="L348">                    f.setValue(null);</span>
                }
            } else {
<span class="nc bnc" id="L351" title="All 2 branches missed.">                if (f.getValue() == null) {</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                    if (f.isConstructor()) {</span>
<span class="nc" id="L353">                        env.error(f.getWhere(), &quot;no.constructor.body&quot;, f);</span>
                    } else {
<span class="nc" id="L355">                        env.error(f.getWhere(), &quot;no.meth.body&quot;, f);</span>
                    }
<span class="nc" id="L357">                    f.addModifiers(M_ABSTRACT);</span>
                }
            }
<span class="nc" id="L360">            Vector arguments = f.getArguments();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">            if (arguments != null) {</span>
                // arguments can be null if this is an implicit abstract method
<span class="nc" id="L363">                int argumentLength = arguments.size();</span>
<span class="nc" id="L364">                Type argTypes[] = f.getType().getArgumentTypes();</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                for (int i = 0; i &lt; argTypes.length; i++) {</span>
<span class="nc" id="L366">                    Object arg = arguments.elementAt(i);</span>
<span class="nc" id="L367">                    long where = f.getWhere();</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                    if (arg instanceof MemberDefinition) {</span>
<span class="nc" id="L369">                        where = ((MemberDefinition)arg).getWhere();</span>
<span class="nc" id="L370">                        arg = ((MemberDefinition)arg).getName();</span>
                    }
                    // (arg should be an Identifier now)
<span class="nc bnc" id="L373" title="All 2 branches missed.">                    if (argTypes[i].isType(TC_VOID)</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                        || argTypes[i].isVoidArray()) {</span>
<span class="nc" id="L375">                        env.error(where, &quot;void.argument&quot;, arg);</span>
                    }
                }
            }
<span class="nc bnc" id="L379" title="All 2 branches missed.">        } else if (f.isInnerClass()) {</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            if (f.isVolatile() ||</span>
<span class="nc bnc" id="L381" title="All 6 branches missed.">                f.isTransient() || f.isNative() || f.isSynchronized()) {</span>
<span class="nc" id="L382">                env.error(f.getWhere(), &quot;inner.modifier&quot;, f);</span>
<span class="nc" id="L383">                f.subModifiers(M_VOLATILE | M_TRANSIENT |</span>
                               M_NATIVE | M_SYNCHRONIZED);
            }
            // same check as for fields, below:
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (f.getClassDefinition().isInterface() &amp;&amp;</span>
<span class="nc bnc" id="L388" title="All 4 branches missed.">                  (f.isPrivate() || f.isProtected())) {</span>
<span class="nc" id="L389">                env.error(f.getWhere(), &quot;intf.modifier.field&quot;, f);</span>
<span class="nc" id="L390">                f.subModifiers(M_PRIVATE | M_PROTECTED);</span>
<span class="nc" id="L391">                f.addModifiers(M_PUBLIC);</span>
                // Fix up the class itself to agree with
                // the inner-class member.
<span class="nc" id="L394">                ClassDefinition c = f.getInnerClass();</span>
<span class="nc" id="L395">                c.subModifiers(M_PRIVATE | M_PROTECTED);</span>
<span class="nc" id="L396">                c.addModifiers(M_PUBLIC);</span>
<span class="nc" id="L397">            }</span>
        } else {
<span class="nc bnc" id="L399" title="All 4 branches missed.">            if (f.getType().isType(TC_VOID) || f.getType().isVoidArray()) {</span>
<span class="nc" id="L400">                env.error(f.getWhere(), &quot;void.inst.var&quot;, f.getName());</span>
                // REMIND: set type to error
<span class="nc" id="L402">                return;</span>
            }

<span class="nc bnc" id="L405" title="All 6 branches missed.">            if (f.isSynchronized() || f.isAbstract() || f.isNative()) {</span>
<span class="nc" id="L406">                env.error(f.getWhere(), &quot;var.modifier&quot;, f);</span>
<span class="nc" id="L407">                f.subModifiers(M_SYNCHRONIZED | M_ABSTRACT | M_NATIVE);</span>
            }
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (f.isStrict()) {</span>
<span class="nc" id="L410">                env.error(f.getWhere(), &quot;var.floatmodifier&quot;, f);</span>
<span class="nc" id="L411">                f.subModifiers(M_STRICTFP);</span>
            }
<span class="nc bnc" id="L413" title="All 4 branches missed.">            if (f.isTransient() &amp;&amp; isInterface()) {</span>
<span class="nc" id="L414">                env.error(f.getWhere(), &quot;transient.modifier&quot;, f);</span>
<span class="nc" id="L415">                f.subModifiers(M_TRANSIENT);</span>
            }
<span class="nc bnc" id="L417" title="All 6 branches missed.">            if (f.isVolatile() &amp;&amp; (isInterface() || f.isFinal())) {</span>
<span class="nc" id="L418">                env.error(f.getWhere(), &quot;volatile.modifier&quot;, f);</span>
<span class="nc" id="L419">                f.subModifiers(M_VOLATILE);</span>
            }
<span class="nc bnc" id="L421" title="All 6 branches missed.">            if (f.isFinal() &amp;&amp; (f.getValue() == null) &amp;&amp; isInterface()) {</span>
<span class="nc" id="L422">                env.error(f.getWhere(), &quot;initializer.needed&quot;, f);</span>
<span class="nc" id="L423">                f.subModifiers(M_FINAL);</span>
            }

<span class="nc bnc" id="L426" title="All 2 branches missed.">            if (f.getClassDefinition().isInterface() &amp;&amp;</span>
<span class="nc bnc" id="L427" title="All 4 branches missed.">                  (f.isPrivate() || f.isProtected())) {</span>
<span class="nc" id="L428">                env.error(f.getWhere(), &quot;intf.modifier.field&quot;, f);</span>
<span class="nc" id="L429">                f.subModifiers(M_PRIVATE | M_PROTECTED);</span>
<span class="nc" id="L430">                f.addModifiers(M_PUBLIC);</span>
            }
        }
        // Do not check for repeated methods here:  Types are not yet resolved.
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (!f.isInitializer()) {</span>
<span class="nc" id="L435">            for (MemberDefinition f2 = getFirstMatch(f.getName());</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                         f2 != null; f2 = f2.getNextMatch()) {</span>
<span class="nc bnc" id="L437" title="All 4 branches missed.">                if (f.isVariable() &amp;&amp; f2.isVariable()) {</span>
<span class="nc" id="L438">                    env.error(f.getWhere(), &quot;var.multidef&quot;, f, f2);</span>
<span class="nc" id="L439">                    return;</span>
<span class="nc bnc" id="L440" title="All 4 branches missed.">                } else if (f.isInnerClass() &amp;&amp; f2.isInnerClass() &amp;&amp;</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                           !f.getInnerClass().isLocal() &amp;&amp;</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">                           !f2.getInnerClass().isLocal()) {</span>
                    // Found a duplicate inner-class member.
                    // Duplicate local classes are detected in
                    // 'VarDeclarationStatement.checkDeclaration'.
<span class="nc" id="L446">                    env.error(f.getWhere(), &quot;inner.class.multidef&quot;, f);</span>
<span class="nc" id="L447">                    return;</span>
                }
            }
        }

<span class="nc" id="L452">        super.addMember(env, f);</span>
<span class="nc" id="L453">    }</span>

    /**
     * Create an environment suitable for checking this class.
     * Make sure the source and imports are set right.
     * Make sure the environment contains no context information.
     * (Actually, throw away env altogether and use toplevelEnv instead.)
     */
    public Environment setupEnv(Environment env) {
        // In some cases, we go to some trouble to create the 'env' argument
        // that is discarded.  We should remove the 'env' argument entirely
        // as well as the vestigial code that supports it.  See comments on
        // 'newEnvironment' in 'checkInternal' below.
<span class="nc" id="L466">        return new Environment(toplevelEnv, this);</span>
    }

    /**
     * A source class never reports deprecation, since the compiler
     * allows access to deprecated features that are being compiled
     * in the same job.
     */
    public boolean reportDeprecated(Environment env) {
<span class="nc" id="L475">        return false;</span>
    }

    /**
     * See if the source file of this class is right.
     * @see ClassDefinition#noteUsedBy
     */
    public void noteUsedBy(ClassDefinition ref, long where, Environment env) {
        // If this class is not public, watch for cross-file references.
<span class="nc" id="L484">        super.noteUsedBy(ref, where, env);</span>
<span class="nc" id="L485">        ClassDefinition def = this;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">        while (def.isInnerClass()) {</span>
<span class="nc" id="L487">            def = def.getOuterClass();</span>
        }
<span class="nc bnc" id="L489" title="All 2 branches missed.">        if (def.isPublic()) {</span>
<span class="nc" id="L490">            return;             // already checked</span>
        }
<span class="nc bnc" id="L492" title="All 2 branches missed.">        while (ref.isInnerClass()) {</span>
<span class="nc" id="L493">            ref = ref.getOuterClass();</span>
        }
<span class="nc bnc" id="L495" title="All 2 branches missed.">        if (def.getSource().equals(ref.getSource())) {</span>
<span class="nc" id="L496">            return;             // intra-file reference</span>
        }
<span class="nc" id="L498">        ((SourceClass)def).checkSourceFile(env, where);</span>
<span class="nc" id="L499">    }</span>

    /**
     * Check this class and all its fields.
     */
    public void check(Environment env) throws ClassNotFound {
<span class="nc" id="L505">        if (tracing) env.dtEnter(&quot;SourceClass.check: &quot; + getName());</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (isInsideLocal()) {</span>
            // An inaccessible class gets checked when the surrounding
            // block is checked.
            // QUERY: Should this case ever occur?
            // What would invoke checking of a local class aside from
            // checking the surrounding method body?
<span class="nc" id="L512">            if (tracing) env.dtEvent(&quot;SourceClass.check: INSIDE LOCAL &quot; +</span>
<span class="nc" id="L513">                                     getOuterClass().getName());</span>
<span class="nc" id="L514">            getOuterClass().check(env);</span>
        } else {
<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (isInnerClass()) {</span>
<span class="nc" id="L517">                if (tracing) env.dtEvent(&quot;SourceClass.check: INNER CLASS &quot; +</span>
<span class="nc" id="L518">                                         getOuterClass().getName());</span>
                // Make sure the outer is checked first.
<span class="nc" id="L520">                ((SourceClass)getOuterClass()).maybeCheck(env);</span>
            }
<span class="nc" id="L522">            Vset vset = new Vset();</span>
<span class="nc" id="L523">            Context ctx = null;</span>
            if (tracing)
<span class="nc" id="L525">                env.dtEvent(&quot;SourceClass.check: CHECK INTERNAL &quot; + getName());</span>
<span class="nc" id="L526">            vset = checkInternal(setupEnv(env), ctx, vset);</span>
            // drop vset here
        }
<span class="nc" id="L529">        if (tracing) env.dtExit(&quot;SourceClass.check: &quot; + getName());</span>
<span class="nc" id="L530">    }</span>

    private void maybeCheck(Environment env) throws ClassNotFound {
<span class="nc" id="L533">        if (tracing) env.dtEvent(&quot;SourceClass.maybeCheck: &quot; + getName());</span>
        // Check this class now, if it has not yet been checked.
        // Cf. Main.compile().  Perhaps this code belongs there somehow.
<span class="nc" id="L536">        ClassDeclaration c = getClassDeclaration();</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (c.getStatus() == CS_PARSED) {</span>
            // Set it first to avoid vicious circularity:
<span class="nc" id="L539">            c.setDefinition(this, CS_CHECKED);</span>
<span class="nc" id="L540">            check(env);</span>
        }
<span class="nc" id="L542">    }</span>

    private Vset checkInternal(Environment env, Context ctx, Vset vset)
                throws ClassNotFound {
<span class="nc" id="L546">        Identifier nm = getClassDeclaration().getName();</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (env.verbose()) {</span>
<span class="nc" id="L548">            env.output(&quot;[checking class &quot; + nm + &quot;]&quot;);</span>
        }

        // Save context enclosing class for later access
        // by 'ClassDefinition.resolveName.'
<span class="nc" id="L553">        classContext = ctx;</span>

        // At present, the call to 'newEnvironment' is not needed.
        // The incoming environment to 'basicCheck' is always passed to
        // 'setupEnv', which discards it completely.  This is also the
        // only call to 'newEnvironment', which is now apparently dead code.
<span class="nc" id="L559">        basicCheck(Context.newEnvironment(env, ctx));</span>

        // Validate access for all inner-class components
        // of a qualified name, not just the last one, which
        // is checked below.  Yes, this is a dirty hack...
        // Much of this code was cribbed from 'checkSupers'.
        // Part of fix for 4094658.
<span class="nc" id="L566">        ClassDeclaration sup = getSuperClass();</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (sup != null) {</span>
<span class="nc" id="L568">            long where = getWhere();</span>
<span class="nc" id="L569">            where = IdentifierToken.getWhere(superClassId, where);</span>
<span class="nc" id="L570">            env.resolveExtendsByName(where, this, sup.getName());</span>
        }
<span class="nc bnc" id="L572" title="All 2 branches missed.">        for (int i = 0 ; i &lt; interfaces.length ; i++) {</span>
<span class="nc" id="L573">            ClassDeclaration intf = interfaces[i];</span>
<span class="nc" id="L574">            long where = getWhere();</span>
            // Error localization fails here if interfaces were
            // elided during error recovery from an invalid one.
<span class="nc bnc" id="L577" title="All 4 branches missed.">            if (interfaceIds != null</span>
                &amp;&amp; interfaceIds.length == interfaces.length) {
<span class="nc" id="L579">                where = IdentifierToken.getWhere(interfaceIds[i], where);</span>
            }
<span class="nc" id="L581">            env.resolveExtendsByName(where, this, intf.getName());</span>
        }

        // Does the name already exist in an imported package?
        // See JLS 8.1 for the precise rules.
<span class="nc bnc" id="L586" title="All 4 branches missed.">        if (!isInnerClass() &amp;&amp; !isInsideLocal()) {</span>
            // Discard package qualification for the import checks.
<span class="nc" id="L588">            Identifier simpleName = nm.getName();</span>
            try {
                // We want this to throw a ClassNotFound exception
<span class="nc" id="L591">                Imports imports = toplevelEnv.getImports();</span>
<span class="nc" id="L592">                Identifier ID = imports.resolve(env, simpleName);</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">                if (ID != getName())</span>
<span class="nc" id="L594">                    env.error(where, &quot;class.multidef.import&quot;, simpleName, ID);</span>
<span class="nc" id="L595">            } catch (AmbiguousClass e) {</span>
                // At least one of e.name1 and e.name2 must be different
<span class="nc bnc" id="L597" title="All 2 branches missed.">                Identifier ID = (e.name1 != getName()) ? e.name1 : e.name2;</span>
<span class="nc" id="L598">                env.error(where, &quot;class.multidef.import&quot;, simpleName, ID);</span>
<span class="nc" id="L599">            }  catch (ClassNotFound e) {</span>
                // we want this to happen
<span class="nc" id="L601">            }</span>

            // Make sure that no package with the same fully qualified
            // name exists.  This is required by JLS 7.1.  We only need
            // to perform this check for top level classes -- it isn't
            // necessary for inner classes.  (bug 4101529)
            //
            // This change has been backed out because, on WIN32, it
            // failed to distinguish between java.awt.event and
            // java.awt.Event when looking for a directory.  We will
            // add this back in later.
            //
            // try {
            //  if (env.getPackage(nm).exists()) {
            //      env.error(where, &quot;class.package.conflict&quot;, nm);
            //  }
            // } catch (java.io.IOException ee) {
            //  env.error(where, &quot;io.exception.package&quot;, nm);
            // }

            // Make sure it was defined in the right file
<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (isPublic()) {</span>
<span class="nc" id="L623">                checkSourceFile(env, getWhere());</span>
            }
        }

<span class="nc" id="L627">        vset = checkMembers(env, ctx, vset);</span>
<span class="nc" id="L628">        return vset;</span>
    }

<span class="nc" id="L631">    private boolean sourceFileChecked = false;</span>

    /**
     * See if the source file of this class is of the right name.
     */
    public void checkSourceFile(Environment env, long where) {
        // one error per offending class is sufficient
<span class="nc bnc" id="L638" title="All 2 branches missed.">        if (sourceFileChecked)  return;</span>
<span class="nc" id="L639">        sourceFileChecked = true;</span>

<span class="nc" id="L641">        String fname = getName().getName() + &quot;.java&quot;;</span>
<span class="nc" id="L642">        String src = ((ClassFile)getSource()).getName();</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">        if (!src.equals(fname)) {</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">            if (isPublic()) {</span>
<span class="nc" id="L645">                env.error(where, &quot;public.class.file&quot;, this, fname);</span>
            } else {
<span class="nc" id="L647">                env.error(where, &quot;warn.package.class.file&quot;, this, src, fname);</span>
            }
        }
<span class="nc" id="L650">    }</span>

    // Set true if superclass (but not necessarily superinterfaces) have
    // been checked.  If the superclass is still unresolved, then an error
    // message should have been issued, and we assume that no further
    // resolution is possible.
<span class="nc" id="L656">    private boolean supersChecked = false;</span>

    /**
     * Overrides 'ClassDefinition.getSuperClass'.
     */

    public ClassDeclaration getSuperClass(Environment env) {
<span class="nc" id="L663">        if (tracing) env.dtEnter(&quot;SourceClass.getSuperClass: &quot; + this);</span>
        // Superclass may fail to be set because of error recovery,
        // so resolve types here only if 'checkSupers' has not yet
        // completed its checks on the superclass.
        // QUERY: Can we eliminate the need to resolve superclasses on demand?
        // See comments in 'checkSupers' and in 'ClassDefinition.getInnerClass'.
<span class="nc bnc" id="L669" title="All 6 branches missed.">        if (superClass == null &amp;&amp; superClassId != null &amp;&amp; !supersChecked) {</span>
<span class="nc" id="L670">            resolveTypeStructure(env);</span>
            // We used to report an error here if the superclass was not
            // resolved.  Having moved the call to 'checkSupers' from 'basicCheck'
            // into 'resolveTypeStructure', the errors reported here should have
            // already been reported.  Furthermore, error recovery can null out
            // the superclass, which would cause a spurious error from the test here.
        }
<span class="nc" id="L677">        if (tracing) env.dtExit(&quot;SourceClass.getSuperClass: &quot; + this);</span>
<span class="nc" id="L678">        return superClass;</span>
    }

    /**
     * Check that all superclasses and superinterfaces are defined and
     * well formed.  Among other checks, verify that the inheritance
     * graph is acyclic.  Called from 'resolveTypeStructure'.
     */

    private void checkSupers(Environment env) throws ClassNotFound {

        // *** DEBUG ***
<span class="nc" id="L690">        supersCheckStarted = true;</span>

<span class="nc" id="L692">        if (tracing) env.dtEnter(&quot;SourceClass.checkSupers: &quot; + this);</span>

<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (isInterface()) {</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">            if (isFinal()) {</span>
<span class="nc" id="L696">                Identifier nm = getClassDeclaration().getName();</span>
<span class="nc" id="L697">                env.error(getWhere(), &quot;final.intf&quot;, nm);</span>
                // Interfaces have no superclass.  Superinterfaces
                // are checked below, in code shared with the class case.
<span class="nc" id="L700">            }</span>
        } else {
            // Check superclass.
            // Call to 'getSuperClass(env)' (note argument) attempts
            // 'resolveTypeStructure' if superclass has not successfully
            // been resolved.  Since we have just now called 'resolveSupers'
            // (see our call in 'resolveTypeStructure'), it is not clear
            // that this can do any good.  Why not 'getSuperClass()' here?
<span class="nc bnc" id="L708" title="All 2 branches missed.">            if (getSuperClass(env) != null) {</span>
<span class="nc" id="L709">                long where = getWhere();</span>
<span class="nc" id="L710">                where = IdentifierToken.getWhere(superClassId, where);</span>
                try {
<span class="nc" id="L712">                    ClassDefinition def =</span>
<span class="nc" id="L713">                        getSuperClass().getClassDefinition(env);</span>
                    // Resolve superclass and its ancestors.
<span class="nc" id="L715">                    def.resolveTypeStructure(env);</span>
                    // Access to the superclass should be checked relative
                    // to the surrounding context, not as if the reference
                    // appeared within the class body. Changed 'canAccess'
                    // to 'extendsCanAccess' to fix 4087314.
<span class="nc bnc" id="L720" title="All 2 branches missed.">                    if (!extendsCanAccess(env, getSuperClass())) {</span>
<span class="nc" id="L721">                        env.error(where, &quot;cant.access.class&quot;, getSuperClass());</span>
                        // Might it be a better recovery to let the access go through?
<span class="nc" id="L723">                        superClass = null;</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                    } else if (def.isFinal()) {</span>
<span class="nc" id="L725">                        env.error(where, &quot;super.is.final&quot;, getSuperClass());</span>
                        // Might it be a better recovery to let the access go through?
<span class="nc" id="L727">                        superClass = null;</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">                    } else if (def.isInterface()) {</span>
<span class="nc" id="L729">                        env.error(where, &quot;super.is.intf&quot;, getSuperClass());</span>
<span class="nc" id="L730">                        superClass = null;</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">                    } else if (superClassOf(env, getSuperClass())) {</span>
<span class="nc" id="L732">                        env.error(where, &quot;cyclic.super&quot;);</span>
<span class="nc" id="L733">                        superClass = null;</span>
                    } else {
<span class="nc" id="L735">                        def.noteUsedBy(this, where, env);</span>
                    }
<span class="nc bnc" id="L737" title="All 2 branches missed.">                    if (superClass == null) {</span>
<span class="nc" id="L738">                        def = null;</span>
                    } else {
                        // If we have a valid superclass, check its
                        // supers as well, and so on up to root class.
                        // Call to 'enclosingClassOf' will raise
                        // 'NullPointerException' if 'def' is null,
                        // so omit this check as error recovery.
<span class="nc" id="L745">                        ClassDefinition sup = def;</span>
                        for (;;) {
<span class="nc bnc" id="L747" title="All 2 branches missed.">                            if (enclosingClassOf(sup)) {</span>
                                // Do we need a similar test for
                                // interfaces?  See bugid 4038529.
<span class="nc" id="L750">                                env.error(where, &quot;super.is.inner&quot;);</span>
<span class="nc" id="L751">                                superClass = null;</span>
<span class="nc" id="L752">                                break;</span>
                            }
                            // Since we resolved the superclass and its
                            // ancestors above, we should not discover
                            // any unresolved classes on the superclass
                            // chain.  It should thus be sufficient to
                            // call 'getSuperClass()' (no argument) here.
<span class="nc" id="L759">                            ClassDeclaration s = sup.getSuperClass(env);</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">                            if (s == null) {</span>
                                // Superclass not resolved due to error.
<span class="nc" id="L762">                                break;</span>
                            }
<span class="nc" id="L764">                            sup = s.getClassDefinition(env);</span>
<span class="nc" id="L765">                        }</span>
                    }
<span class="nc" id="L767">                } catch (ClassNotFound e) {</span>
                    // Error is detected in call to 'getClassDefinition'.
                    // The class may actually exist but be ambiguous.
                    // Call env.resolve(e.name) to see if it is.
                    // env.resolve(name) will definitely tell us if the
                    // class is ambiguous, but may not necessarily tell
                    // us if the class is not found.
                    // (part of solution for 4059855)
                reportError: {
                        try {
<span class="nc" id="L777">                            env.resolve(e.name);</span>
<span class="nc" id="L778">                        } catch (AmbiguousClass ee) {</span>
<span class="nc" id="L779">                            env.error(where,</span>
                                      &quot;ambig.class&quot;, ee.name1, ee.name2);
<span class="nc" id="L781">                            superClass = null;</span>
<span class="nc" id="L782">                            break reportError;</span>
<span class="nc" id="L783">                        } catch (ClassNotFound ee) {</span>
                            // fall through
<span class="nc" id="L785">                        }</span>
<span class="nc" id="L786">                        env.error(where, &quot;super.not.found&quot;, e.name, this);</span>
<span class="nc" id="L787">                        superClass = null;</span>
                    } // The break exits this block
<span class="nc" id="L789">                }</span>

<span class="nc" id="L791">            } else {</span>
                // Superclass was null on entry, after call to
                // 'resolveSupers'.  This should normally not happen,
                // as 'resolveSupers' sets 'superClass' to a non-null
                // value for all named classes, except for one special
                // case: 'java.lang.Object', which has no superclass.
<span class="nc bnc" id="L797" title="All 2 branches missed.">                if (isAnonymous()) {</span>
                    // checker should have filled it in first
<span class="nc" id="L799">                    throw new CompilerError(&quot;anonymous super&quot;);</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">                } else  if (!getName().equals(idJavaLangObject)) {</span>
<span class="nc" id="L801">                    throw new CompilerError(&quot;unresolved super&quot;);</span>
                }
            }
        }

        // At this point, if 'superClass' is null due to an error
        // in the user program, a message should have been issued.
<span class="nc" id="L808">        supersChecked = true;</span>

        // Check interfaces
<span class="nc bnc" id="L811" title="All 2 branches missed.">        for (int i = 0 ; i &lt; interfaces.length ; i++) {</span>
<span class="nc" id="L812">            ClassDeclaration intf = interfaces[i];</span>
<span class="nc" id="L813">            long where = getWhere();</span>
<span class="nc bnc" id="L814" title="All 4 branches missed.">            if (interfaceIds != null</span>
                &amp;&amp; interfaceIds.length == interfaces.length) {
<span class="nc" id="L816">                where = IdentifierToken.getWhere(interfaceIds[i], where);</span>
            }
            try {
<span class="nc" id="L819">                ClassDefinition def = intf.getClassDefinition(env);</span>
                // Resolve superinterface and its ancestors.
<span class="nc" id="L821">                def.resolveTypeStructure(env);</span>
                // Check superinterface access in the correct context.
                // Changed 'canAccess' to 'extendsCanAccess' to fix 4087314.
<span class="nc bnc" id="L824" title="All 2 branches missed.">                if (!extendsCanAccess(env, intf)) {</span>
<span class="nc" id="L825">                    env.error(where, &quot;cant.access.class&quot;, intf);</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                } else if (!intf.getClassDefinition(env).isInterface()) {</span>
<span class="nc" id="L827">                    env.error(where, &quot;not.intf&quot;, intf);</span>
<span class="nc bnc" id="L828" title="All 4 branches missed.">                } else if (isInterface() &amp;&amp; implementedBy(env, intf)) {</span>
<span class="nc" id="L829">                    env.error(where, &quot;cyclic.intf&quot;, intf);</span>
                } else {
<span class="nc" id="L831">                    def.noteUsedBy(this, where, env);</span>
                    // Interface is OK, leave it in the interface list.
<span class="nc" id="L833">                    continue;</span>
                }
<span class="nc" id="L835">            } catch (ClassNotFound e) {</span>
                // The interface may actually exist but be ambiguous.
                // Call env.resolve(e.name) to see if it is.
                // env.resolve(name) will definitely tell us if the
                // interface is ambiguous, but may not necessarily tell
                // us if the interface is not found.
                // (part of solution for 4059855)
            reportError2: {
                    try {
<span class="nc" id="L844">                        env.resolve(e.name);</span>
<span class="nc" id="L845">                    } catch (AmbiguousClass ee) {</span>
<span class="nc" id="L846">                        env.error(where,</span>
                                  &quot;ambig.class&quot;, ee.name1, ee.name2);
<span class="nc" id="L848">                        superClass = null;</span>
<span class="nc" id="L849">                        break reportError2;</span>
<span class="nc" id="L850">                    } catch (ClassNotFound ee) {</span>
                        // fall through
<span class="nc" id="L852">                    }</span>
<span class="nc" id="L853">                    env.error(where, &quot;intf.not.found&quot;, e.name, this);</span>
<span class="nc" id="L854">                    superClass = null;</span>
                } // The break exits this block
<span class="nc" id="L856">            }</span>
            // Remove this interface from the list of interfaces
            // as recovery from an error.
<span class="nc" id="L859">            ClassDeclaration newInterfaces[] =</span>
                new ClassDeclaration[interfaces.length - 1];
<span class="nc" id="L861">            System.arraycopy(interfaces, 0, newInterfaces, 0, i);</span>
<span class="nc" id="L862">            System.arraycopy(interfaces, i + 1, newInterfaces, i,</span>
                             newInterfaces.length - i);
<span class="nc" id="L864">            interfaces = newInterfaces;</span>
<span class="nc" id="L865">            --i;</span>
        }
<span class="nc" id="L867">        if (tracing) env.dtExit(&quot;SourceClass.checkSupers: &quot; + this);</span>
<span class="nc" id="L868">    }</span>

    /**
     * Check all of the members of this class.
     * &lt;p&gt;
     * Inner classes are checked in the following way.  Any class which
     * is immediately contained in a block (anonymous and local classes)
     * is checked along with its containing method; see the
     * SourceMember.check() method for more information.  Member classes
     * of this class are checked immediately after this class, unless this
     * class is insideLocal(), in which case, they are checked with the
     * rest of the members.
     */
    private Vset checkMembers(Environment env, Context ctx, Vset vset)
            throws ClassNotFound {

        // bail out if there were any errors
<span class="nc bnc" id="L885" title="All 2 branches missed.">        if (getError()) {</span>
<span class="nc" id="L886">            return vset;</span>
        }

        // Make sure that all of our member classes have been
        // basicCheck'ed before we check the rest of our members.
        // If our member classes haven't been basicCheck'ed, then they
        // may not have &lt;init&gt; methods.  It is important that they
        // have &lt;init&gt; methods so we can process NewInstanceExpressions
        // correctly.  This problem didn't occur before 1.2beta1.
        // This is a fix for bug 4082816.
<span class="nc" id="L896">        for (MemberDefinition f = getFirstMember();</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">                     f != null; f = f.getNextMember()) {</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">            if (f.isInnerClass()) {</span>
                // System.out.println(&quot;Considering &quot; + f + &quot; in &quot; + this);
<span class="nc" id="L900">                SourceClass cdef = (SourceClass) f.getInnerClass();</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">                if (cdef.isMember()) {</span>
<span class="nc" id="L902">                    cdef.basicCheck(env);</span>
                }
            }
        }

<span class="nc bnc" id="L907" title="All 4 branches missed.">        if (isFinal() &amp;&amp; isAbstract()) {</span>
<span class="nc" id="L908">            env.error(where, &quot;final.abstract&quot;, this.getName().getName());</span>
        }

        // This class should be abstract if there are any abstract methods
        // in our parent classes and interfaces which we do not override.
        // There are odd cases when, even though we cannot access some
        // abstract method from our superclass, that abstract method can
        // still force this class to be abstract.  See the discussion in
        // bug id 1240831.
<span class="nc bnc" id="L917" title="All 6 branches missed.">        if (!isInterface() &amp;&amp; !isAbstract() &amp;&amp; mustBeAbstract(env)) {</span>
            // Set the class abstract.
<span class="nc" id="L919">            modifiers |= M_ABSTRACT;</span>

            // Tell the user which methods force this class to be abstract.

            // First list all of the &quot;unimplementable&quot; abstract methods.
<span class="nc" id="L924">            Iterator iter = getPermanentlyAbstractMethods();</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L926">                MemberDefinition method = (MemberDefinition) iter.next();</span>
                // We couldn't override this method even if we
                // wanted to.  Try to make the error message
                // as non-confusing as possible.
<span class="nc" id="L930">                env.error(where, &quot;abstract.class.cannot.override&quot;,</span>
<span class="nc" id="L931">                          getClassDeclaration(), method,</span>
<span class="nc" id="L932">                          method.getDefiningClassDeclaration());</span>
<span class="nc" id="L933">            }</span>

            // Now list all of the traditional abstract methods.
<span class="nc" id="L936">            iter = getMethods(env);</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
                // For each method, check if it is abstract.  If it is,
                // output an appropriate error message.
<span class="nc" id="L940">                MemberDefinition method = (MemberDefinition) iter.next();</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">                if (method.isAbstract()) {</span>
<span class="nc" id="L942">                    env.error(where, &quot;abstract.class&quot;,</span>
<span class="nc" id="L943">                              getClassDeclaration(), method,</span>
<span class="nc" id="L944">                              method.getDefiningClassDeclaration());</span>
                }
<span class="nc" id="L946">            }</span>
        }

        // Check the instance variables in a pre-pass before any constructors.
        // This lets constructors &quot;in-line&quot; any initializers directly.
        // It also lets us do some definite assignment checks on variables.
<span class="nc" id="L952">        Context ctxInit = new Context(ctx);</span>
<span class="nc" id="L953">        Vset vsInst = vset.copy();</span>
<span class="nc" id="L954">        Vset vsClass = vset.copy();</span>

        // Do definite assignment checking on blank finals.
        // Other variables do not need such checks.  The simple textual
        // ordering constraints implemented by MemberDefinition.canReach()
        // are necessary and sufficient for the other variables.
        // Note that within non-static code, all statics are always
        // definitely assigned, and vice-versa.
<span class="nc" id="L962">        for (MemberDefinition f = getFirstMember();</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">                     f != null; f = f.getNextMember()) {</span>
<span class="nc bnc" id="L964" title="All 4 branches missed.">            if (f.isVariable() &amp;&amp; f.isBlankFinal()) {</span>
                // The following allocates a LocalMember object as a proxy
                // to represent the field.
<span class="nc" id="L967">                int number = ctxInit.declareFieldNumber(f);</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">                if (f.isStatic()) {</span>
<span class="nc" id="L969">                    vsClass = vsClass.addVarUnassigned(number);</span>
<span class="nc" id="L970">                    vsInst = vsInst.addVar(number);</span>
                } else {
<span class="nc" id="L972">                    vsInst = vsInst.addVarUnassigned(number);</span>
<span class="nc" id="L973">                    vsClass = vsClass.addVar(number);</span>
                }
            }
        }

        // For instance variable checks, use a context with a &quot;this&quot; parameter.
<span class="nc" id="L979">        Context ctxInst = new Context(ctxInit, this);</span>
<span class="nc" id="L980">        LocalMember thisArg = getThisArgument();</span>
<span class="nc" id="L981">        int thisNumber = ctxInst.declare(env, thisArg);</span>
<span class="nc" id="L982">        vsInst = vsInst.addVar(thisNumber);</span>

        // Do all the initializers in order, checking the definite
        // assignment of blank finals.  Separate static from non-static.
<span class="nc" id="L986">        for (MemberDefinition f = getFirstMember();</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">                     f != null; f = f.getNextMember()) {</span>
            try {
<span class="nc bnc" id="L989" title="All 4 branches missed.">                if (f.isVariable() || f.isInitializer()) {</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">                    if (f.isStatic()) {</span>
<span class="nc" id="L991">                        vsClass = f.check(env, ctxInit, vsClass);</span>
                    } else {
<span class="nc" id="L993">                        vsInst = f.check(env, ctxInst, vsInst);</span>
                    }
                }
<span class="nc" id="L996">            } catch (ClassNotFound ee) {</span>
<span class="nc" id="L997">                env.error(f.getWhere(), &quot;class.not.found&quot;, ee.name, this);</span>
<span class="nc" id="L998">            }</span>
        }

<span class="nc" id="L1001">        checkBlankFinals(env, ctxInit, vsClass, true);</span>

        // Check the rest of the field definitions.
        // (Note:  Re-checking a field is a no-op.)
<span class="nc" id="L1005">        for (MemberDefinition f = getFirstMember();</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                     f != null; f = f.getNextMember()) {</span>
            try {
<span class="nc bnc" id="L1008" title="All 2 branches missed.">                if (f.isConstructor()) {</span>
                    // When checking a constructor, an explicit call to
                    // 'this(...)' makes all blank finals definitely assigned.
                    // See 'MethodExpression.checkValue'.
<span class="nc" id="L1012">                    Vset vsCon = f.check(env, ctxInit, vsInst.copy());</span>
                    // May issue multiple messages for the same variable!!
<span class="nc" id="L1014">                    checkBlankFinals(env, ctxInit, vsCon, false);</span>
                    // (drop vsCon here)
<span class="nc" id="L1016">                } else {</span>
<span class="nc" id="L1017">                    Vset vsFld = f.check(env, ctx, vset.copy());</span>
                    // (drop vsFld here)
                }
<span class="nc" id="L1020">            } catch (ClassNotFound ee) {</span>
<span class="nc" id="L1021">                env.error(f.getWhere(), &quot;class.not.found&quot;, ee.name, this);</span>
<span class="nc" id="L1022">            }</span>
        }

        // Must mark class as checked before visiting inner classes,
        // as they may in turn request checking of the current class
        // as an outer class.  Fix for bug id 4056774.
<span class="nc" id="L1028">        getClassDeclaration().setDefinition(this, CS_CHECKED);</span>

        // Also check other classes in the same nest.
        // All checking of this nest must be finished before any
        // of its classes emit bytecode.
        // Otherwise, the inner classes might not have a chance to
        // add access or class literal fields to the outer class.
<span class="nc" id="L1035">        for (MemberDefinition f = getFirstMember();</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">                     f != null; f = f.getNextMember()) {</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (f.isInnerClass()) {</span>
<span class="nc" id="L1038">                SourceClass cdef = (SourceClass) f.getInnerClass();</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">                if (!cdef.isInsideLocal()) {</span>
<span class="nc" id="L1040">                    cdef.maybeCheck(env);</span>
                }
            }
        }

        // Note:  Since inner classes cannot set up-level variables,
        // the returned vset is always equal to the passed-in vset.
        // Still, we'll return it for the sake of regularity.
<span class="nc" id="L1048">        return vset;</span>
    }

    /** Make sure all my blank finals exist now. */

    private void checkBlankFinals(Environment env, Context ctxInit, Vset vset,
                                  boolean isStatic) {
<span class="nc bnc" id="L1055" title="All 2 branches missed.">        for (int i = 0; i &lt; ctxInit.getVarNumber(); i++) {</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">            if (!vset.testVar(i)) {</span>
<span class="nc" id="L1057">                MemberDefinition ff = ctxInit.getElement(i);</span>
<span class="nc bnc" id="L1058" title="All 4 branches missed.">                if (ff != null &amp;&amp; ff.isBlankFinal()</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">                    &amp;&amp; ff.isStatic() == isStatic</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">                    &amp;&amp; ff.getClassDefinition() == this) {</span>
<span class="nc" id="L1061">                    env.error(ff.getWhere(),</span>
<span class="nc" id="L1062">                              &quot;final.var.not.initialized&quot;, ff.getName());</span>
                }
            }
        }
<span class="nc" id="L1066">    }</span>

    /**
     * Check this class has its superclass and its interfaces.  Also
     * force it to have an &lt;init&gt; method (if it doesn't already have one)
     * and to have all the abstract methods of its parents.
     */
<span class="nc" id="L1073">    private boolean basicChecking = false;</span>
<span class="nc" id="L1074">    private boolean basicCheckDone = false;</span>
    protected void basicCheck(Environment env) throws ClassNotFound {

<span class="nc" id="L1077">        if (tracing) env.dtEnter(&quot;SourceClass.basicCheck: &quot; + getName());</span>

<span class="nc" id="L1079">        super.basicCheck(env);</span>

<span class="nc bnc" id="L1081" title="All 4 branches missed.">        if (basicChecking || basicCheckDone) {</span>
<span class="nc" id="L1082">            if (tracing) env.dtExit(&quot;SourceClass.basicCheck: OK &quot; + getName());</span>
<span class="nc" id="L1083">            return;</span>
        }

<span class="nc" id="L1086">        if (tracing) env.dtEvent(&quot;SourceClass.basicCheck: CHECKING &quot; + getName());</span>

<span class="nc" id="L1088">        basicChecking = true;</span>

<span class="nc" id="L1090">        env = setupEnv(env);</span>

<span class="nc" id="L1092">        Imports imports = env.getImports();</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">        if (imports != null) {</span>
<span class="nc" id="L1094">            imports.resolve(env);</span>
        }

<span class="nc" id="L1097">        resolveTypeStructure(env);</span>

        // Check the existence of the superclass and all interfaces.
        // Also responsible for breaking inheritance cycles.  This call
        // has been moved to 'resolveTypeStructure', just after the call
        // to 'resolveSupers', as inheritance cycles must be broken before
        // resolving types within the members.  Fixes 4073739.
        //   checkSupers(env);

<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (!isInterface()) {</span>

            // Add implicit &lt;init&gt; method, if necessary.
            // QUERY:  What keeps us from adding an implicit constructor
            // when the user explicitly declares one?  Is it truly guaranteed
            // that the declaration for such an explicit constructor will have
            // been processed by the time we arrive here?  In general, 'basicCheck'
            // is called very early, prior to the normal member checking phase.
<span class="nc bnc" id="L1114" title="All 2 branches missed.">            if (!hasConstructor()) {</span>
<span class="nc" id="L1115">                Node code = new CompoundStatement(getWhere(), new Statement[0]);</span>
<span class="nc" id="L1116">                Type t = Type.tMethod(Type.tVoid);</span>

                // Default constructors inherit the access modifiers of their
                // class.  For non-inner classes, this follows from JLS 8.6.7,
                // as the only possible modifier is 'public'.  For the sake of
                // robustness in the presence of errors, we ignore any other
                // modifiers.  For inner classes, the rule needs to be extended
                // in some way to account for the possibility of private and
                // protected classes.  We make the 'obvious' extension, however,
                // the inner classes spec is silent on this issue, and a definitive
                // resolution is needed.  See bugid 4087421.
                // WORKAROUND: A private constructor might need an access method,
                // but it is not possible to create one due to a restriction in
                // the verifier.  (This is a known problem -- see 4015397.)
                // We therefore do not inherit the 'private' modifier from the class,
                // allowing the default constructor to be package private.  This
                // workaround can be observed via reflection, but is otherwise
                // undetectable, as the constructor is always accessible within
                // the class in which its containing (private) class appears.
<span class="nc" id="L1135">                int accessModifiers = getModifiers() &amp;</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">                    (isInnerClass() ? (M_PUBLIC | M_PROTECTED) : M_PUBLIC);</span>
<span class="nc" id="L1137">                env.makeMemberDefinition(env, getWhere(), this, null,</span>
                                         accessModifiers,
                                         t, idInit, null, null, code);
            }
        }

        // Only do the inheritance/override checks if they are turned on.
        // The idea here is that they will be done in javac, but not
        // in javadoc.  See the comment for turnOffChecks(), above.
<span class="nc bnc" id="L1146" title="All 2 branches missed.">        if (doInheritanceChecks) {</span>

            // Verify the compatibility of all inherited method definitions
            // by collecting all of our inheritable methods.
<span class="nc" id="L1150">            collectInheritedMethods(env);</span>
        }

<span class="nc" id="L1153">        basicChecking = false;</span>
<span class="nc" id="L1154">        basicCheckDone = true;</span>
<span class="nc" id="L1155">        if (tracing) env.dtExit(&quot;SourceClass.basicCheck: &quot; + getName());</span>
<span class="nc" id="L1156">    }</span>

    /**
     * Add a group of methods to this class as miranda methods.
     *
     * For a definition of Miranda methods, see the comment above the
     * method addMirandaMethods() in the file
     * sun/tools/java/ClassDeclaration.java
     */
    protected void addMirandaMethods(Environment env,
                                     Iterator mirandas) {

<span class="nc bnc" id="L1168" title="All 2 branches missed.">        while(mirandas.hasNext()) {</span>
<span class="nc" id="L1169">            MemberDefinition method =</span>
<span class="nc" id="L1170">                (MemberDefinition)mirandas.next();</span>

<span class="nc" id="L1172">            addMember(method);</span>

            //System.out.println(&quot;adding miranda method &quot; + newMethod +
            //                   &quot; to &quot; + this);
<span class="nc" id="L1176">        }</span>
<span class="nc" id="L1177">    }</span>

    /**
     * &lt;em&gt;After parsing is complete&lt;/em&gt;, resolve all names
     * except those inside method bodies or initializers.
     * In particular, this is the point at which we find out what
     * kinds of variables and methods there are in the classes,
     * and therefore what is each class's interface to the world.
     * &lt;p&gt;
     * Also perform certain other transformations, such as inserting
     * &quot;this$C&quot; arguments into constructors, and reorganizing structure
     * to flatten qualified member names.
     * &lt;p&gt;
     * Do not perform type-based or name-based consistency checks
     * or normalizations (such as default nullary constructors),
     * and do not attempt to compile code against this class,
     * until after this phase.
     */

<span class="nc" id="L1196">    private boolean resolving = false;</span>

    public void resolveTypeStructure(Environment env) {

        if (tracing)
<span class="nc" id="L1201">            env.dtEnter(&quot;SourceClass.resolveTypeStructure: &quot; + getName());</span>

        // Resolve immediately enclosing type, which in turn
        // forces resolution of all enclosing type declarations.
<span class="nc" id="L1205">        ClassDefinition oc = getOuterClass();</span>
<span class="nc bnc" id="L1206" title="All 6 branches missed.">        if (oc != null &amp;&amp; oc instanceof SourceClass</span>
            &amp;&amp; !((SourceClass)oc).resolved) {
            // Do the outer class first, always.
<span class="nc" id="L1209">            ((SourceClass)oc).resolveTypeStructure(env);</span>
            // (Note:  this.resolved is probably true at this point.)
        }

        // Punt if we've already resolved this class, or are currently
        // in the process of doing so.
<span class="nc bnc" id="L1215" title="All 4 branches missed.">        if (resolved || resolving) {</span>
            if (tracing)
<span class="nc" id="L1217">                env.dtExit(&quot;SourceClass.resolveTypeStructure: OK &quot; + getName());</span>
<span class="nc" id="L1218">            return;</span>
        }

        // Previously, 'resolved' was set here, and served to prevent
        // duplicate resolutions here as well as its function in
        // 'ClassDefinition.addMember'.  Now, 'resolving' serves the
        // former purpose, distinct from that of 'resolved'.
<span class="nc" id="L1225">        resolving = true;</span>

        if (tracing)
<span class="nc" id="L1228">            env.dtEvent(&quot;SourceClass.resolveTypeStructure: RESOLVING &quot; + getName());</span>

<span class="nc" id="L1230">        env = setupEnv(env);</span>

        // Resolve superclass names to class declarations
        // for the immediate superclass and superinterfaces.
<span class="nc" id="L1234">        resolveSupers(env);</span>

        // Check all ancestor superclasses for various
        // errors, verifying definition of all superclasses
        // and superinterfaces.  Also breaks inheritance cycles.
        // Calls 'resolveTypeStructure' recursively for ancestors
        // This call used to appear in 'basicCheck', but was not
        // performed early enough.  Most of the compiler will barf
        // on inheritance cycles!
        try {
<span class="nc" id="L1244">            checkSupers(env);</span>
<span class="nc" id="L1245">        } catch (ClassNotFound ee) {</span>
            // Undefined classes should be reported by 'checkSupers'.
<span class="nc" id="L1247">            env.error(where, &quot;class.not.found&quot;, ee.name, this);</span>
<span class="nc" id="L1248">        }</span>

        for (MemberDefinition
<span class="nc bnc" id="L1251" title="All 2 branches missed.">                 f = getFirstMember() ; f != null ; f = f.getNextMember()) {</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">            if (f instanceof SourceMember)</span>
<span class="nc" id="L1253">                ((SourceMember)f).resolveTypeStructure(env);</span>
        }

<span class="nc" id="L1256">        resolving = false;</span>

        // Mark class as resolved.  If new members are subsequently
        // added to the class, they will be resolved at that time.
        // See 'ClassDefinition.addMember'.  Previously, this variable was
        // set prior to the calls to 'checkSupers' and 'resolveTypeStructure'
        // (which may engender further calls to 'checkSupers').  This could
        // lead to duplicate resolution of implicit constructors, as the call to
        // 'basicCheck' from 'checkSupers' could add the constructor while
        // its class is marked resolved, and thus would resolve the constructor,
        // believing it to be a &quot;late addition&quot;.  It would then be resolved
        // redundantly during the normal traversal of the members, which
        // immediately follows in the code above.
<span class="nc" id="L1269">        resolved = true;</span>

        // Now we have enough information to detect method repeats.
        for (MemberDefinition
<span class="nc bnc" id="L1273" title="All 2 branches missed.">                 f = getFirstMember() ; f != null ; f = f.getNextMember()) {</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">            if (f.isInitializer())  continue;</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">            if (!f.isMethod())  continue;</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">            for (MemberDefinition f2 = f; (f2 = f2.getNextMatch()) != null; ) {</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">                if (!f2.isMethod())  continue;</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">                if (f.getType().equals(f2.getType())) {</span>
<span class="nc" id="L1279">                    env.error(f.getWhere(), &quot;meth.multidef&quot;, f);</span>
<span class="nc" id="L1280">                    continue;</span>
                }
<span class="nc bnc" id="L1282" title="All 2 branches missed.">                if (f.getType().equalArguments(f2.getType())) {</span>
<span class="nc" id="L1283">                    env.error(f.getWhere(), &quot;meth.redef.rettype&quot;, f, f2);</span>
<span class="nc" id="L1284">                    continue;</span>
                }
            }
        }
        if (tracing)
<span class="nc" id="L1289">            env.dtExit(&quot;SourceClass.resolveTypeStructure: &quot; + getName());</span>
<span class="nc" id="L1290">    }</span>

    protected void resolveSupers(Environment env) {
        if (tracing)
<span class="nc" id="L1294">            env.dtEnter(&quot;SourceClass.resolveSupers: &quot; + this);</span>
        // Find the super class
<span class="nc bnc" id="L1296" title="All 4 branches missed.">        if (superClassId != null &amp;&amp; superClass == null) {</span>
<span class="nc" id="L1297">            superClass = resolveSuper(env, superClassId);</span>
            // Special-case java.lang.Object here (not in the parser).
            // In all other cases, if we have a valid 'superClassId',
            // we return with a valid and non-null 'superClass' value.
<span class="nc bnc" id="L1301" title="All 2 branches missed.">            if (superClass == getClassDeclaration()</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">                &amp;&amp; getName().equals(idJavaLangObject)) {</span>
<span class="nc" id="L1303">                    superClass = null;</span>
<span class="nc" id="L1304">                    superClassId = null;</span>
            }
        }
        // Find interfaces
<span class="nc bnc" id="L1308" title="All 4 branches missed.">        if (interfaceIds != null &amp;&amp; interfaces == null) {</span>
<span class="nc" id="L1309">            interfaces = new ClassDeclaration[interfaceIds.length];</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">            for (int i = 0 ; i &lt; interfaces.length ; i++) {</span>
<span class="nc" id="L1311">                interfaces[i] = resolveSuper(env, interfaceIds[i]);</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">                for (int j = 0; j &lt; i; j++) {</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">                    if (interfaces[i] == interfaces[j]) {</span>
<span class="nc" id="L1314">                        Identifier id = interfaceIds[i].getName();</span>
<span class="nc" id="L1315">                        long where = interfaceIds[j].getWhere();</span>
<span class="nc" id="L1316">                        env.error(where, &quot;intf.repeated&quot;, id);</span>
                    }
                }
            }
        }
        if (tracing)
<span class="nc" id="L1322">            env.dtExit(&quot;SourceClass.resolveSupers: &quot; + this);</span>
<span class="nc" id="L1323">    }</span>

    private ClassDeclaration resolveSuper(Environment env, IdentifierToken t) {
<span class="nc" id="L1326">        Identifier name = t.getName();</span>
        if (tracing)
<span class="nc" id="L1328">            env.dtEnter(&quot;SourceClass.resolveSuper: &quot; + name);</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">        if (isInnerClass())</span>
<span class="nc" id="L1330">            name = outerClass.resolveName(env, name);</span>
        else
<span class="nc" id="L1332">            name = env.resolveName(name);</span>
<span class="nc" id="L1333">        ClassDeclaration result = env.getClassDeclaration(name);</span>
        // Result is never null, as a new 'ClassDeclaration' is
        // created if one with the given name does not exist.
<span class="nc" id="L1336">        if (tracing) env.dtExit(&quot;SourceClass.resolveSuper: &quot; + name);</span>
<span class="nc" id="L1337">        return result;</span>
    }

    /**
     * During the type-checking of an outer method body or initializer,
     * this routine is called to check a local class body
     * in the proper context.
     * @param   sup     the named super class or interface (if anonymous)
     * @param   args    the actual arguments (if anonymous)
     */
    public Vset checkLocalClass(Environment env, Context ctx, Vset vset,
                                ClassDefinition sup,
                                Expression args[], Type argTypes[]
                                ) throws ClassNotFound {
<span class="nc" id="L1351">        env = setupEnv(env);</span>

<span class="nc bnc" id="L1353" title="All 4 branches missed.">        if ((sup != null) != isAnonymous()) {</span>
<span class="nc" id="L1354">            throw new CompilerError(&quot;resolveAnonymousStructure&quot;);</span>
        }
<span class="nc bnc" id="L1356" title="All 2 branches missed.">        if (isAnonymous()) {</span>
<span class="nc" id="L1357">            resolveAnonymousStructure(env, sup, args, argTypes);</span>
        }

        // Run the checks in the lexical context from the outer class.
<span class="nc" id="L1361">        vset = checkInternal(env, ctx, vset);</span>

        // This is now done by 'checkInternal' via its call to 'checkMembers'.
        // getClassDeclaration().setDefinition(this, CS_CHECKED);

<span class="nc" id="L1366">        return vset;</span>
    }

    /**
     * As with checkLocalClass, run the inline phase for a local class.
     */
    public void inlineLocalClass(Environment env) {
        for (MemberDefinition
<span class="nc bnc" id="L1374" title="All 2 branches missed.">                 f = getFirstMember(); f != null; f = f.getNextMember()) {</span>
<span class="nc bnc" id="L1375" title="All 6 branches missed.">            if ((f.isVariable() || f.isInitializer()) &amp;&amp; !f.isStatic()) {</span>
<span class="nc" id="L1376">                continue;       // inlined inside of constructors only</span>
            }
            try {
<span class="nc" id="L1379">                ((SourceMember)f).inline(env);</span>
<span class="nc" id="L1380">            } catch (ClassNotFound ee) {</span>
<span class="nc" id="L1381">                env.error(f.getWhere(), &quot;class.not.found&quot;, ee.name, this);</span>
<span class="nc" id="L1382">            }</span>
        }
<span class="nc bnc" id="L1384" title="All 4 branches missed.">        if (getReferencesFrozen() != null &amp;&amp; !inlinedLocalClass) {</span>
<span class="nc" id="L1385">            inlinedLocalClass = true;</span>
            // add more constructor arguments for uplevel references
            for (MemberDefinition
<span class="nc bnc" id="L1388" title="All 2 branches missed.">                     f = getFirstMember(); f != null; f = f.getNextMember()) {</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">                if (f.isConstructor()) {</span>
                    //((SourceMember)f).addUplevelArguments(false);
<span class="nc" id="L1391">                    ((SourceMember)f).addUplevelArguments();</span>
                }
            }
        }
<span class="nc" id="L1395">    }</span>
<span class="nc" id="L1396">    private boolean inlinedLocalClass = false;</span>

    /**
     * Check a class which is inside a local class, but is not itself local.
     */
    public Vset checkInsideClass(Environment env, Context ctx, Vset vset)
                throws ClassNotFound {
<span class="nc bnc" id="L1403" title="All 4 branches missed.">        if (!isInsideLocal() || isLocal()) {</span>
<span class="nc" id="L1404">            throw new CompilerError(&quot;checkInsideClass&quot;);</span>
        }
<span class="nc" id="L1406">        return checkInternal(env, ctx, vset);</span>
    }

    /**
     * Just before checking an anonymous class, decide its true
     * inheritance, and build its (sole, implicit) constructor.
     */
    private void resolveAnonymousStructure(Environment env,
                                           ClassDefinition sup,
                                           Expression args[], Type argTypes[]
                                           ) throws ClassNotFound {

<span class="nc" id="L1418">        if (tracing) env.dtEvent(&quot;SourceClass.resolveAnonymousStructure: &quot; +</span>
                                 this + &quot;, super &quot; + sup);

        // Decide now on the superclass.

        // This check has been removed as part of the fix for 4055017.
        // In the anonymous class created to hold the 'class$' method
        // of an interface, 'superClassId' refers to 'java.lang.Object'.
        /*---------------------*
        if (!(superClass == null &amp;&amp; superClassId.getName() == idNull)) {
            throw new CompilerError(&quot;superclass &quot;+superClass);
        }
        *---------------------*/

<span class="nc bnc" id="L1432" title="All 2 branches missed.">        if (sup.isInterface()) {</span>
            // allow an interface in the &quot;super class&quot; position
<span class="nc bnc" id="L1434" title="All 2 branches missed.">            int ni = (interfaces == null) ? 0 : interfaces.length;</span>
<span class="nc" id="L1435">            ClassDeclaration i1[] = new ClassDeclaration[1+ni];</span>
<span class="nc bnc" id="L1436" title="All 2 branches missed.">            if (ni &gt; 0) {</span>
<span class="nc" id="L1437">                System.arraycopy(interfaces, 0, i1, 1, ni);</span>
<span class="nc bnc" id="L1438" title="All 4 branches missed.">                if (interfaceIds != null &amp;&amp; interfaceIds.length == ni) {</span>
<span class="nc" id="L1439">                    IdentifierToken id1[] = new IdentifierToken[1+ni];</span>
<span class="nc" id="L1440">                    System.arraycopy(interfaceIds, 0, id1, 1, ni);</span>
<span class="nc" id="L1441">                    id1[0] = new IdentifierToken(sup.getName());</span>
                }
            }
<span class="nc" id="L1444">            i1[0] = sup.getClassDeclaration();</span>
<span class="nc" id="L1445">            interfaces = i1;</span>

<span class="nc" id="L1447">            sup = toplevelEnv.getClassDefinition(idJavaLangObject);</span>
        }
<span class="nc" id="L1449">        superClass = sup.getClassDeclaration();</span>

<span class="nc bnc" id="L1451" title="All 2 branches missed.">        if (hasConstructor()) {</span>
<span class="nc" id="L1452">            throw new CompilerError(&quot;anonymous constructor&quot;);</span>
        }

        // Synthesize an appropriate constructor.
<span class="nc" id="L1456">        Type t = Type.tMethod(Type.tVoid, argTypes);</span>
<span class="nc" id="L1457">        IdentifierToken names[] = new IdentifierToken[argTypes.length];</span>
<span class="nc bnc" id="L1458" title="All 2 branches missed.">        for (int i = 0; i &lt; names.length; i++) {</span>
<span class="nc" id="L1459">            names[i] = new IdentifierToken(args[i].getWhere(),</span>
<span class="nc" id="L1460">                                           Identifier.lookup(&quot;$&quot;+i));</span>
        }
<span class="nc bnc" id="L1462" title="All 4 branches missed.">        int outerArg = (sup.isTopLevel() || sup.isLocal()) ? 0 : 1;</span>
<span class="nc" id="L1463">        Expression superArgs[] = new Expression[-outerArg + args.length];</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">        for (int i = outerArg ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L1465">            superArgs[-outerArg + i] = new IdentifierExpression(names[i]);</span>
        }
<span class="nc" id="L1467">        long where = getWhere();</span>
        Expression superExp;
<span class="nc bnc" id="L1469" title="All 2 branches missed.">        if (outerArg == 0) {</span>
<span class="nc" id="L1470">            superExp = new SuperExpression(where);</span>
        } else {
<span class="nc" id="L1472">            superExp = new SuperExpression(where,</span>
                                           new IdentifierExpression(names[0]));
        }
<span class="nc" id="L1475">        Expression superCall = new MethodExpression(where,</span>
                                                    superExp, idInit,
                                                    superArgs);
<span class="nc" id="L1478">        Statement body[] = { new ExpressionStatement(where, superCall) };</span>
<span class="nc" id="L1479">        Node code = new CompoundStatement(where, body);</span>
<span class="nc" id="L1480">        int mod = M_SYNTHETIC; // ISSUE: make M_PRIVATE, with wrapper?</span>
<span class="nc" id="L1481">        env.makeMemberDefinition(env, where, this, null,</span>
                                mod, t, idInit, names, null, code);
<span class="nc" id="L1483">    }</span>

    /**
     * Convert class modifiers to a string for diagnostic purposes.
     * Accepts modifiers applicable to inner classes and that appear
     * in the InnerClasses attribute only, as well as those that may
     * appear in the class modifier proper.
     */

<span class="nc" id="L1492">    private static int classModifierBits[] =</span>
        { ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,
          ACC_INTERFACE, ACC_ABSTRACT, ACC_SUPER, M_ANONYMOUS, M_LOCAL,
          M_STRICTFP, ACC_STRICT};

<span class="nc" id="L1497">    private static String classModifierNames[] =</span>
        { &quot;PUBLIC&quot;, &quot;PRIVATE&quot;, &quot;PROTECTED&quot;, &quot;STATIC&quot;, &quot;FINAL&quot;,
          &quot;INTERFACE&quot;, &quot;ABSTRACT&quot;, &quot;SUPER&quot;, &quot;ANONYMOUS&quot;, &quot;LOCAL&quot;,
          &quot;STRICTFP&quot;, &quot;STRICT&quot;};

    static String classModifierString(int mods) {
<span class="nc" id="L1503">        String s = &quot;&quot;;</span>
<span class="nc bnc" id="L1504" title="All 2 branches missed.">        for (int i = 0; i &lt; classModifierBits.length; i++) {</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">            if ((mods &amp; classModifierBits[i]) != 0) {</span>
<span class="nc" id="L1506">                s = s + &quot; &quot; + classModifierNames[i];</span>
<span class="nc" id="L1507">                mods &amp;= ~classModifierBits[i];</span>
            }
        }
<span class="nc bnc" id="L1510" title="All 2 branches missed.">        if (mods != 0) {</span>
<span class="nc" id="L1511">            s = s + &quot; ILLEGAL:&quot; + Integer.toHexString(mods);</span>
        }
<span class="nc" id="L1513">        return s;</span>
    }

    /**
     * Find or create an access method for a private member,
     * or return null if this is not possible.
     */
    public MemberDefinition getAccessMember(Environment env, Context ctx,
                                          MemberDefinition field, boolean isSuper) {
<span class="nc" id="L1522">        return getAccessMember(env, ctx, field, false, isSuper);</span>
    }

    public MemberDefinition getUpdateMember(Environment env, Context ctx,
                                          MemberDefinition field, boolean isSuper) {
<span class="nc bnc" id="L1527" title="All 2 branches missed.">        if (!field.isVariable()) {</span>
<span class="nc" id="L1528">            throw new CompilerError(&quot;method&quot;);</span>
        }
<span class="nc" id="L1530">        return getAccessMember(env, ctx, field, true, isSuper);</span>
    }

    private MemberDefinition getAccessMember(Environment env, Context ctx,
                                             MemberDefinition field,
                                             boolean isUpdate,
                                             boolean isSuper) {

        // The 'isSuper' argument is really only meaningful when the
        // target member is a method, in which case an 'invokespecial'
        // is needed.  For fields, 'getfield' and 'putfield' instructions
        // are generated in either case, and 'isSuper' currently plays
        // no essential role.  Nonetheless, we maintain the distinction
        // consistently for the time being.

<span class="nc" id="L1545">        boolean isStatic = field.isStatic();</span>
<span class="nc" id="L1546">        boolean isMethod = field.isMethod();</span>

        // Find pre-existing access method.
        // In the case of a field access method, we only look for the getter.
        // A getter is always created whenever a setter is.
        // QUERY: Why doesn't the 'MemberDefinition' object for the field
        // itself just have fields for its getter and setter?
        MemberDefinition af;
<span class="nc bnc" id="L1554" title="All 2 branches missed.">        for (af = getFirstMember(); af != null; af = af.getNextMember()) {</span>
<span class="nc bnc" id="L1555" title="All 2 branches missed.">            if (af.getAccessMethodTarget() == field) {</span>
<span class="nc bnc" id="L1556" title="All 4 branches missed.">                if (isMethod &amp;&amp; af.isSuperAccessMethod() == isSuper) {</span>
<span class="nc" id="L1557">                    break;</span>
                }
                // Distinguish the getter and the setter by the number of
                // arguments.
<span class="nc" id="L1561">                int nargs = af.getType().getArgumentTypes().length;</span>
                // This was (nargs == (isStatic ? 0 : 1) + (isUpdate ? 1 : 0))
                // in order to find a setter as well as a getter.  This caused
                // allocation of multiple getters.
<span class="nc bnc" id="L1565" title="All 4 branches missed.">                if (nargs == (isStatic ? 0 : 1)) {</span>
<span class="nc" id="L1566">                    break;</span>
                }
            }
        }

<span class="nc bnc" id="L1571" title="All 2 branches missed.">        if (af != null) {</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">            if (!isUpdate) {</span>
<span class="nc" id="L1573">                return af;</span>
            } else {
<span class="nc" id="L1575">                MemberDefinition uf = af.getAccessUpdateMember();</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">                if (uf != null) {</span>
<span class="nc" id="L1577">                    return uf;</span>
                }
<span class="nc" id="L1579">            }</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">        } else if (isUpdate) {</span>
            // must find or create the getter before creating the setter
<span class="nc" id="L1582">            af = getAccessMember(env, ctx, field, false, isSuper);</span>
        }

        // If we arrive here, we are creating a new access member.

        Identifier anm;
<span class="nc" id="L1588">        Type dummyType = null;</span>

<span class="nc bnc" id="L1590" title="All 2 branches missed.">        if (field.isConstructor()) {</span>
            // For a constructor, we use the same name as for all
            // constructors (&quot;&lt;init&gt;&quot;), but add a distinguishing
            // argument of an otherwise unused &quot;dummy&quot; type.
<span class="nc" id="L1594">            anm = idInit;</span>
            // Get the dummy class, creating it if necessary.
<span class="nc" id="L1596">            SourceClass outerMostClass = (SourceClass)getTopClass();</span>
<span class="nc" id="L1597">            dummyType = outerMostClass.dummyArgumentType;</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">            if (dummyType == null) {</span>
                // Create dummy class.
<span class="nc" id="L1600">                IdentifierToken sup =</span>
                    new IdentifierToken(0, idJavaLangObject);
<span class="nc" id="L1602">                IdentifierToken interfaces[] = {};</span>
<span class="nc" id="L1603">                IdentifierToken t = new IdentifierToken(0, idNull);</span>
<span class="nc" id="L1604">                int mod = M_ANONYMOUS | M_STATIC | M_SYNTHETIC;</span>
                // If an interface has a public inner class, the dummy class for
                // the constructor must always be accessible. Fix for 4221648.
<span class="nc bnc" id="L1607" title="All 2 branches missed.">                if (outerMostClass.isInterface()) {</span>
<span class="nc" id="L1608">                    mod |= M_PUBLIC;</span>
                }
<span class="nc" id="L1610">                ClassDefinition dummyClass =</span>
<span class="nc" id="L1611">                    toplevelEnv.makeClassDefinition(toplevelEnv,</span>
                                                    0, t, null, mod,
                                                    sup, interfaces,
                                                    outerMostClass);
                // Check the class.
                // It is likely that a full check is not really necessary,
                // but it is essential that the class be marked as parsed.
<span class="nc" id="L1618">                dummyClass.getClassDeclaration().setDefinition(dummyClass, CS_PARSED);</span>
<span class="nc" id="L1619">                Expression argsX[] = {};</span>
<span class="nc" id="L1620">                Type argTypesX[] = {};</span>
                try {
<span class="nc" id="L1622">                    ClassDefinition supcls =</span>
<span class="nc" id="L1623">                        toplevelEnv.getClassDefinition(idJavaLangObject);</span>
<span class="nc" id="L1624">                    dummyClass.checkLocalClass(toplevelEnv, null,</span>
                                               new Vset(), supcls, argsX, argTypesX);
<span class="nc" id="L1626">                } catch (ClassNotFound ee) {};</span>
                // Get class type.
<span class="nc" id="L1628">                dummyType = dummyClass.getType();</span>
<span class="nc" id="L1629">                outerMostClass.dummyArgumentType = dummyType;</span>
            }
<span class="nc" id="L1631">        } else {</span>
            // Otherwise, we use the name &quot;access$N&quot;, for the
            // smallest value of N &gt;= 0 yielding an unused name.
<span class="nc" id="L1634">            for (int i = 0; ; i++) {</span>
<span class="nc" id="L1635">                anm = Identifier.lookup(prefixAccess + i);</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">                if (getFirstMatch(anm) == null) {</span>
<span class="nc" id="L1637">                    break;</span>
                }
            }
        }

        Type argTypes[];
<span class="nc" id="L1643">        Type t = field.getType();</span>

<span class="nc bnc" id="L1645" title="All 2 branches missed.">        if (isStatic) {</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">            if (!isMethod) {</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">                if (!isUpdate) {</span>
<span class="nc" id="L1648">                    Type at[] = { };</span>
<span class="nc" id="L1649">                    argTypes = at;</span>
<span class="nc" id="L1650">                    t = Type.tMethod(t); // nullary getter</span>
<span class="nc" id="L1651">                } else {</span>
<span class="nc" id="L1652">                    Type at[] = { t };</span>
<span class="nc" id="L1653">                    argTypes = at;</span>
<span class="nc" id="L1654">                    t = Type.tMethod(Type.tVoid, argTypes); // unary setter</span>
<span class="nc" id="L1655">                }</span>
            } else {
                // Since constructors are never static, we don't
                // have to worry about a dummy argument here.
<span class="nc" id="L1659">                argTypes = t.getArgumentTypes();</span>
            }
        } else {
            // All access methods for non-static members get an explicit
            // 'this' pointer as an extra argument, as the access methods
            // themselves must be static. EXCEPTION: Access methods for
            // constructors are non-static.
<span class="nc" id="L1666">            Type classType = this.getType();</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">            if (!isMethod) {</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">                if (!isUpdate) {</span>
<span class="nc" id="L1669">                    Type at[] = { classType };</span>
<span class="nc" id="L1670">                    argTypes = at;</span>
<span class="nc" id="L1671">                    t = Type.tMethod(t, argTypes); // nullary getter</span>
<span class="nc" id="L1672">                } else {</span>
<span class="nc" id="L1673">                    Type at[] = { classType, t };</span>
<span class="nc" id="L1674">                    argTypes = at;</span>
<span class="nc" id="L1675">                    t = Type.tMethod(Type.tVoid, argTypes); // unary setter</span>
<span class="nc" id="L1676">                }</span>
            } else {
                // Target is a method, possibly a constructor.
<span class="nc" id="L1679">                Type at[] = t.getArgumentTypes();</span>
<span class="nc" id="L1680">                int nargs = at.length;</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">                if (field.isConstructor()) {</span>
                    // Access method is a constructor.
                    // Requires a dummy argument.
<span class="nc" id="L1684">                    MemberDefinition outerThisArg =</span>
<span class="nc" id="L1685">                        ((SourceMember)field).getOuterThisArg();</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">                    if (outerThisArg != null) {</span>
                        // Outer instance link must be the first argument.
                        // The following is a sanity check that will catch
                        // most cases in which in this requirement is violated.
<span class="nc bnc" id="L1690" title="All 2 branches missed.">                        if (at[0] != outerThisArg.getType()) {</span>
<span class="nc" id="L1691">                            throw new CompilerError(&quot;misplaced outer this&quot;);</span>
                        }
                        // Strip outer 'this' argument.
                        // It will be added back when the access method is checked.
<span class="nc" id="L1695">                        argTypes = new Type[nargs];</span>
<span class="nc" id="L1696">                        argTypes[0] = dummyType;</span>
<span class="nc bnc" id="L1697" title="All 2 branches missed.">                        for (int i = 1; i &lt; nargs; i++) {</span>
<span class="nc" id="L1698">                            argTypes[i] = at[i];</span>
                        }
                    } else {
                        // There is no outer instance.
<span class="nc" id="L1702">                        argTypes = new Type[nargs+1];</span>
<span class="nc" id="L1703">                        argTypes[0] = dummyType;</span>
<span class="nc bnc" id="L1704" title="All 2 branches missed.">                        for (int i = 0; i &lt; nargs; i++) {</span>
<span class="nc" id="L1705">                            argTypes[i+1] = at[i];</span>
                        }
                    }
<span class="nc" id="L1708">                } else {</span>
                    // Access method is static.
                    // Requires an explicit 'this' argument.
<span class="nc" id="L1711">                    argTypes = new Type[nargs+1];</span>
<span class="nc" id="L1712">                    argTypes[0] = classType;</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">                    for (int i = 0; i &lt; nargs; i++) {</span>
<span class="nc" id="L1714">                        argTypes[i+1] = at[i];</span>
                    }
                }
<span class="nc" id="L1717">                t = Type.tMethod(t.getReturnType(), argTypes);</span>
            }
        }

<span class="nc" id="L1721">        int nlen = argTypes.length;</span>
<span class="nc" id="L1722">        long where = field.getWhere();</span>
<span class="nc" id="L1723">        IdentifierToken names[] = new IdentifierToken[nlen];</span>
<span class="nc bnc" id="L1724" title="All 2 branches missed.">        for (int i = 0; i &lt; nlen; i++) {</span>
<span class="nc" id="L1725">            names[i] = new IdentifierToken(where, Identifier.lookup(&quot;$&quot;+i));</span>
        }

<span class="nc" id="L1728">        Expression access = null;</span>
<span class="nc" id="L1729">        Expression thisArg = null;</span>
<span class="nc" id="L1730">        Expression args[] = null;</span>

<span class="nc bnc" id="L1732" title="All 2 branches missed.">        if (isStatic) {</span>
<span class="nc" id="L1733">            args = new Expression[nlen];</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">            for (int i = 0 ; i &lt; nlen ; i++) {</span>
<span class="nc" id="L1735">                args[i] = new IdentifierExpression(names[i]);</span>
            }
        } else {
<span class="nc bnc" id="L1738" title="All 2 branches missed.">            if (field.isConstructor()) {</span>
                // Constructor access method is non-static, so
                // 'this' works normally.
<span class="nc" id="L1741">                thisArg = new ThisExpression(where);</span>
                // Remove dummy argument, as it is not
                // passed to the target method.
<span class="nc" id="L1744">                args = new Expression[nlen-1];</span>
<span class="nc bnc" id="L1745" title="All 2 branches missed.">                for (int i = 1 ; i &lt; nlen ; i++) {</span>
<span class="nc" id="L1746">                    args[i-1] = new IdentifierExpression(names[i]);</span>
                }
            } else {
                // Non-constructor access method is static, so
                // we use the first argument as 'this'.
<span class="nc" id="L1751">                thisArg = new IdentifierExpression(names[0]);</span>
                // Remove first argument.
<span class="nc" id="L1753">                args = new Expression[nlen-1];</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">                for (int i = 1 ; i &lt; nlen ; i++) {</span>
<span class="nc" id="L1755">                    args[i-1] = new IdentifierExpression(names[i]);</span>
                }
            }
<span class="nc" id="L1758">            access = thisArg;</span>
        }

<span class="nc bnc" id="L1761" title="All 2 branches missed.">        if (!isMethod) {</span>
<span class="nc" id="L1762">            access = new FieldExpression(where, access, field);</span>
<span class="nc bnc" id="L1763" title="All 2 branches missed.">            if (isUpdate) {</span>
<span class="nc" id="L1764">                access = new AssignExpression(where, access, args[0]);</span>
            }
        } else {
            // If true, 'isSuper' forces a non-virtual call.
<span class="nc" id="L1768">            access = new MethodExpression(where, access, field, args, isSuper);</span>
        }

        Statement code;
<span class="nc bnc" id="L1772" title="All 2 branches missed.">        if (t.getReturnType().isType(TC_VOID)) {</span>
<span class="nc" id="L1773">            code = new ExpressionStatement(where, access);</span>
        } else {
<span class="nc" id="L1775">            code = new ReturnStatement(where, access);</span>
        }
<span class="nc" id="L1777">        Statement body[] = { code };</span>
<span class="nc" id="L1778">        code = new CompoundStatement(where, body);</span>

        // Access methods are now static (constructors excepted), and no longer final.
        // This change was mandated by the interaction of the access method
        // naming conventions and the restriction against overriding final
        // methods.
<span class="nc" id="L1784">        int mod = M_SYNTHETIC;</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">        if (!field.isConstructor()) {</span>
<span class="nc" id="L1786">            mod |= M_STATIC;</span>
        }

        // Create the synthetic method within the class in which the referenced
        // private member appears.  The 'env' argument to 'makeMemberDefinition'
        // is suspect because it represents the environment at the point at
        // which a reference takes place, while it should represent the
        // environment in which the definition of the synthetic method appears.
        // We get away with this because 'env' is used only to access globals
        // such as 'Environment.error', and also as an argument to
        // 'resolveTypeStructure', which immediately discards it using
        // 'setupEnv'. Apparently, the current definition of 'setupEnv'
        // represents a design change that has not been thoroughly propagated.
        // An access method is declared with same list of exceptions as its
        // target. As the exceptions are simply listed by name, the correctness
        // of this approach requires that the access method be checked
        // (name-resolved) in the same context as its target method  This
        // should always be the case.
<span class="nc" id="L1804">        SourceMember newf = (SourceMember)</span>
<span class="nc" id="L1805">            env.makeMemberDefinition(env, where, this,</span>
                                     null, mod, t, anm, names,
<span class="nc" id="L1807">                                     field.getExceptionIds(), code);</span>
        // Just to be safe, copy over the name-resolved exceptions from the
        // target so that the context in which the access method is checked
        // doesn't matter.
<span class="nc" id="L1811">        newf.setExceptions(field.getExceptions(env));</span>

<span class="nc" id="L1813">        newf.setAccessMethodTarget(field);</span>
<span class="nc bnc" id="L1814" title="All 2 branches missed.">        if (isUpdate) {</span>
<span class="nc" id="L1815">            af.setAccessUpdateMember(newf);</span>
        }
<span class="nc" id="L1817">        newf.setIsSuperAccessMethod(isSuper);</span>

        // The call to 'check' is not needed, as the access method will be
        // checked by the containing class after it is added.  This is the
        // idiom followed in the implementation of class literals. (See
        // 'FieldExpression.java'.) In any case, the context is wrong in the
        // call below.  The access method must be checked in the context in
        // which it is declared, i.e., the class containing the referenced
        // private member, not the (inner) class in which the original member
        // reference occurs.
        //
        // try {
        //     newf.check(env, ctx, new Vset());
        // } catch (ClassNotFound ee) {
        //     env.error(where, &quot;class.not.found&quot;, ee.name, this);
        // }

        // The comment above is inaccurate.  While it is often the case
        // that the containing class will check the access method, this is
        // by no means guaranteed.  In fact, an access method may be added
        // after the checking of its class is complete.  In this case, however,
        // the context in which the class was checked will have been saved in
        // the class definition object (by the fix for 4095716), allowing us
        // to check the field now, and in the correct context.
        // This fixes bug 4098093.

<span class="nc" id="L1843">        Context checkContext = newf.getClassDefinition().getClassContext();</span>
<span class="nc bnc" id="L1844" title="All 2 branches missed.">        if (checkContext != null) {</span>
            //System.out.println(&quot;checking late addition: &quot; + this);
            try {
<span class="nc" id="L1847">                newf.check(env, checkContext, new Vset());</span>
<span class="nc" id="L1848">            } catch (ClassNotFound ee) {</span>
<span class="nc" id="L1849">                env.error(where, &quot;class.not.found&quot;, ee.name, this);</span>
<span class="nc" id="L1850">            }</span>
        }


        //System.out.println(&quot;[Access member '&quot; +
        //                      newf + &quot;' created for field '&quot; +
        //                      field +&quot;' in class '&quot; + this + &quot;']&quot;);

<span class="nc" id="L1858">        return newf;</span>
    }

    /**
     * Find an inner class of 'this', chosen arbitrarily.
     * Result is always an actual class, never an interface.
     * Returns null if none found.
     */
    SourceClass findLookupContext() {
        // Look for an immediate inner class.
<span class="nc" id="L1868">        for (MemberDefinition f = getFirstMember();</span>
<span class="nc bnc" id="L1869" title="All 2 branches missed.">             f != null;</span>
<span class="nc" id="L1870">             f = f.getNextMember()) {</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">            if (f.isInnerClass()) {</span>
<span class="nc" id="L1872">                SourceClass ic = (SourceClass)f.getInnerClass();</span>
<span class="nc bnc" id="L1873" title="All 2 branches missed.">                if (!ic.isInterface()) {</span>
<span class="nc" id="L1874">                    return ic;</span>
                }
            }
        }
        // Look for a class nested within an immediate inner interface.
        // At this point, we have given up on finding a minimally-nested
        // class (which would require a breadth-first traversal).  It doesn't
        // really matter which inner class we find.
<span class="nc" id="L1882">        for (MemberDefinition f = getFirstMember();</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">             f != null;</span>
<span class="nc" id="L1884">             f = f.getNextMember()) {</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">            if (f.isInnerClass()) {</span>
<span class="nc" id="L1886">                SourceClass lc =</span>
<span class="nc" id="L1887">                    ((SourceClass)f.getInnerClass()).findLookupContext();</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">                if (lc != null) {</span>
<span class="nc" id="L1889">                    return lc;</span>
                }
            }
        }
        // No inner classes.
<span class="nc" id="L1894">        return null;</span>
    }

<span class="nc" id="L1897">    private MemberDefinition lookup = null;</span>

    /**
     * Get helper method for class literal lookup.
     */
    public MemberDefinition getClassLiteralLookup(long fwhere) {

        // If we have already created a lookup method, reuse it.
<span class="nc bnc" id="L1905" title="All 2 branches missed.">        if (lookup != null) {</span>
<span class="nc" id="L1906">            return lookup;</span>
        }

        // If the current class is a nested class, make sure we put the
        // lookup method in the outermost class.  Set 'lookup' for the
        // intervening inner classes so we won't have to do the search
        // again.
<span class="nc bnc" id="L1913" title="All 2 branches missed.">        if (outerClass != null) {</span>
<span class="nc" id="L1914">            lookup = outerClass.getClassLiteralLookup(fwhere);</span>
<span class="nc" id="L1915">            return lookup;</span>
        }

        // If we arrive here, there was no existing 'class$' method.

<span class="nc" id="L1920">        ClassDefinition c = this;</span>
<span class="nc" id="L1921">        boolean needNewClass = false;</span>

<span class="nc bnc" id="L1923" title="All 2 branches missed.">        if (isInterface()) {</span>
            // The top-level type is an interface.  Try to find an existing
            // inner class in which to create the helper method.  Any will do.
<span class="nc" id="L1926">            c = findLookupContext();</span>
<span class="nc bnc" id="L1927" title="All 2 branches missed.">            if (c == null) {</span>
                // The interface has no inner classes.  Create an anonymous
                // inner class to hold the helper method, as an interface must
                // not have any methods.  The tests above for prior creation
                // of a 'class$' method assure that only one such class is
                // allocated for each outermost class containing a class
                // literal embedded somewhere within.  Part of fix for 4055017.
<span class="nc" id="L1934">                needNewClass = true;</span>
<span class="nc" id="L1935">                IdentifierToken sup =</span>
                    new IdentifierToken(fwhere, idJavaLangObject);
<span class="nc" id="L1937">                IdentifierToken interfaces[] = {};</span>
<span class="nc" id="L1938">                IdentifierToken t = new IdentifierToken(fwhere, idNull);</span>
<span class="nc" id="L1939">                int mod = M_PUBLIC | M_ANONYMOUS | M_STATIC | M_SYNTHETIC;</span>
<span class="nc" id="L1940">                c = (SourceClass)</span>
<span class="nc" id="L1941">                    toplevelEnv.makeClassDefinition(toplevelEnv,</span>
                                                    fwhere, t, null, mod,
                                                    sup, interfaces, this);
            }
        }


        // The name of the class-getter stub is &quot;class$&quot;
<span class="nc" id="L1949">        Identifier idDClass = Identifier.lookup(prefixClass);</span>
<span class="nc" id="L1950">        Type strarg[] = { Type.tString };</span>

        // Some sanity checks of questionable value.
        //
        // This check became useless after matchMethod() was modified
        // to not return synthetic methods.
        //
        //try {
        //    lookup = c.matchMethod(toplevelEnv, c, idDClass, strarg);
        //} catch (ClassNotFound ee) {
        //    throw new CompilerError(&quot;unexpected missing class&quot;);
        //} catch (AmbiguousMember ee) {
        //    throw new CompilerError(&quot;synthetic name clash&quot;);
        //}
        //if (lookup != null &amp;&amp; lookup.getClassDefinition() == c) {
        //    // Error if method found was not inherited.
        //    throw new CompilerError(&quot;unexpected duplicate&quot;);
        //}
        // Some sanity checks of questionable value.

        /*  // The helper function looks like this.
         *  // It simply maps a checked exception to an unchecked one.
         *  static Class class$(String class$) {
         *    try { return Class.forName(class$); }
         *    catch (ClassNotFoundException forName) {
         *      throw new NoClassDefFoundError(forName.getMessage());
         *    }
         *  }
         */
<span class="nc" id="L1979">        long w = c.getWhere();</span>
<span class="nc" id="L1980">        IdentifierToken arg = new IdentifierToken(w, idDClass);</span>
<span class="nc" id="L1981">        Expression e = new IdentifierExpression(arg);</span>
<span class="nc" id="L1982">        Expression a1[] = { e };</span>
<span class="nc" id="L1983">        Identifier idForName = Identifier.lookup(&quot;forName&quot;);</span>
<span class="nc" id="L1984">        e = new MethodExpression(w, new TypeExpression(w, Type.tClassDesc),</span>
                                 idForName, a1);
<span class="nc" id="L1986">        Statement body = new ReturnStatement(w, e);</span>
        // map the exceptions
<span class="nc" id="L1988">        Identifier idClassNotFound =</span>
<span class="nc" id="L1989">            Identifier.lookup(&quot;java.lang.ClassNotFoundException&quot;);</span>
<span class="nc" id="L1990">        Identifier idNoClassDefFound =</span>
<span class="nc" id="L1991">            Identifier.lookup(&quot;java.lang.NoClassDefFoundError&quot;);</span>
<span class="nc" id="L1992">        Type ctyp = Type.tClass(idClassNotFound);</span>
<span class="nc" id="L1993">        Type exptyp = Type.tClass(idNoClassDefFound);</span>
<span class="nc" id="L1994">        Identifier idGetMessage = Identifier.lookup(&quot;getMessage&quot;);</span>
<span class="nc" id="L1995">        e = new IdentifierExpression(w, idForName);</span>
<span class="nc" id="L1996">        e = new MethodExpression(w, e, idGetMessage, new Expression[0]);</span>
<span class="nc" id="L1997">        Expression a2[] = { e };</span>
<span class="nc" id="L1998">        e = new NewInstanceExpression(w, new TypeExpression(w, exptyp), a2);</span>
<span class="nc" id="L1999">        Statement handler = new CatchStatement(w, new TypeExpression(w, ctyp),</span>
                                               new IdentifierToken(idForName),
                                               new ThrowStatement(w, e));
<span class="nc" id="L2002">        Statement handlers[] = { handler };</span>
<span class="nc" id="L2003">        body = new TryStatement(w, body, handlers);</span>

<span class="nc" id="L2005">        Type mtype = Type.tMethod(Type.tClassDesc, strarg);</span>
<span class="nc" id="L2006">        IdentifierToken args[] = { arg };</span>

        // Use default (package) access.  If private, an access method would
        // be needed in the event that the class literal belonged to an interface.
        // Also, making it private tickles bug 4098316.
<span class="nc" id="L2011">        lookup = toplevelEnv.makeMemberDefinition(toplevelEnv, w,</span>
                                                  c, null,
                                                  M_STATIC | M_SYNTHETIC,
                                                  mtype, idDClass,
                                                  args, null, body);

        // If a new class was created to contain the helper method,
        // check it now.
<span class="nc bnc" id="L2019" title="All 2 branches missed.">        if (needNewClass) {</span>
<span class="nc bnc" id="L2020" title="All 2 branches missed.">            if (c.getClassDeclaration().getStatus() == CS_CHECKED) {</span>
<span class="nc" id="L2021">                throw new CompilerError(&quot;duplicate check&quot;);</span>
            }
<span class="nc" id="L2023">            c.getClassDeclaration().setDefinition(c, CS_PARSED);</span>
<span class="nc" id="L2024">            Expression argsX[] = {};</span>
<span class="nc" id="L2025">            Type argTypesX[] = {};</span>
            try {
<span class="nc" id="L2027">                ClassDefinition sup =</span>
<span class="nc" id="L2028">                    toplevelEnv.getClassDefinition(idJavaLangObject);</span>
<span class="nc" id="L2029">                c.checkLocalClass(toplevelEnv, null,</span>
                                  new Vset(), sup, argsX, argTypesX);
<span class="nc" id="L2031">            } catch (ClassNotFound ee) {};</span>
        }

<span class="nc" id="L2034">        return lookup;</span>
    }


    /**
     * A list of active ongoing compilations. This list
     * is used to stop two compilations from saving the
     * same class.
     */
<span class="nc" id="L2043">    private static Vector active = new Vector();</span>

    /**
     * Compile this class
     */
    public void compile(OutputStream out)
                throws InterruptedException, IOException {
<span class="nc" id="L2050">        Environment env = toplevelEnv;</span>
<span class="nc" id="L2051">        synchronized (active) {</span>
<span class="nc bnc" id="L2052" title="All 2 branches missed.">            while (active.contains(getName())) {</span>
<span class="nc" id="L2053">                active.wait();</span>
            }
<span class="nc" id="L2055">            active.addElement(getName());</span>
<span class="nc" id="L2056">        }</span>

        try {
<span class="nc" id="L2059">            compileClass(env, out);</span>
<span class="nc" id="L2060">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L2061">            throw new CompilerError(e);</span>
        } finally {
<span class="nc" id="L2063">            synchronized (active) {</span>
<span class="nc" id="L2064">                active.removeElement(getName());</span>
<span class="nc" id="L2065">                active.notifyAll();</span>
<span class="nc" id="L2066">            }</span>
<span class="nc" id="L2067">        }</span>
<span class="nc" id="L2068">    }</span>

    /**
     * Verify that the modifier bits included in 'required' are
     * all present in 'mods', otherwise signal an internal error.
     * Note that errors in the source program may corrupt the modifiers,
     * thus we rely on the fact that 'CompilerError' exceptions are
     * silently ignored after an error message has been issued.
     */
    private static void assertModifiers(int mods, int required) {
<span class="nc bnc" id="L2078" title="All 2 branches missed.">        if ((mods &amp; required) != required) {</span>
<span class="nc" id="L2079">            throw new CompilerError(&quot;illegal class modifiers&quot;);</span>
        }
<span class="nc" id="L2081">    }</span>

    protected void compileClass(Environment env, OutputStream out)
                throws IOException, ClassNotFound {
<span class="nc" id="L2085">        Vector variables = new Vector();</span>
<span class="nc" id="L2086">        Vector methods = new Vector();</span>
<span class="nc" id="L2087">        Vector innerClasses = new Vector();</span>
<span class="nc" id="L2088">        CompilerMember init = new CompilerMember(new MemberDefinition(getWhere(), this, M_STATIC, Type.tMethod(Type.tVoid), idClassInit, null, null), new Assembler());</span>
<span class="nc" id="L2089">        Context ctx = new Context((Context)null, init.field);</span>

<span class="nc bnc" id="L2091" title="All 2 branches missed.">        for (ClassDefinition def = this; def.isInnerClass(); def = def.getOuterClass()) {</span>
<span class="nc" id="L2092">            innerClasses.addElement(def);</span>
        }
        // Reverse the order, so that outer levels come first:
<span class="nc" id="L2095">        int ncsize = innerClasses.size();</span>
<span class="nc bnc" id="L2096" title="All 2 branches missed.">        for (int i = ncsize; --i &gt;= 0; )</span>
<span class="nc" id="L2097">            innerClasses.addElement(innerClasses.elementAt(i));</span>
<span class="nc bnc" id="L2098" title="All 2 branches missed.">        for (int i = ncsize; --i &gt;= 0; )</span>
<span class="nc" id="L2099">            innerClasses.removeElementAt(i);</span>

        // System.out.println(&quot;compile class &quot; + getName());

<span class="nc" id="L2103">        boolean haveDeprecated = this.isDeprecated();</span>
<span class="nc" id="L2104">        boolean haveSynthetic = this.isSynthetic();</span>
<span class="nc" id="L2105">        boolean haveConstantValue = false;</span>
<span class="nc" id="L2106">        boolean haveExceptions = false;</span>

        // Generate code for all fields
<span class="nc" id="L2109">        for (SourceMember field = (SourceMember)getFirstMember();</span>
<span class="nc bnc" id="L2110" title="All 2 branches missed.">             field != null;</span>
<span class="nc" id="L2111">             field = (SourceMember)field.getNextMember()) {</span>

            //System.out.println(&quot;compile field &quot; + field.getName());

<span class="nc" id="L2115">            haveDeprecated |= field.isDeprecated();</span>
<span class="nc" id="L2116">            haveSynthetic |= field.isSynthetic();</span>

            try {
<span class="nc bnc" id="L2119" title="All 2 branches missed.">                if (field.isMethod()) {</span>
<span class="nc" id="L2120">                    haveExceptions |=</span>
<span class="nc bnc" id="L2121" title="All 2 branches missed.">                        (field.getExceptions(env).length &gt; 0);</span>

<span class="nc bnc" id="L2123" title="All 2 branches missed.">                    if (field.isInitializer()) {</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">                        if (field.isStatic()) {</span>
<span class="nc" id="L2125">                            field.code(env, init.asm);</span>
                        }
                    } else {
<span class="nc" id="L2128">                        CompilerMember f =</span>
                            new CompilerMember(field, new Assembler());
<span class="nc" id="L2130">                        field.code(env, f.asm);</span>
<span class="nc" id="L2131">                        methods.addElement(f);</span>
<span class="nc" id="L2132">                    }</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">                } else if (field.isInnerClass()) {</span>
<span class="nc" id="L2134">                    innerClasses.addElement(field.getInnerClass());</span>
<span class="nc bnc" id="L2135" title="All 2 branches missed.">                } else if (field.isVariable()) {</span>
<span class="nc" id="L2136">                    field.inline(env);</span>
<span class="nc" id="L2137">                    CompilerMember f = new CompilerMember(field, null);</span>
<span class="nc" id="L2138">                    variables.addElement(f);</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">                    if (field.isStatic()) {</span>
<span class="nc" id="L2140">                        field.codeInit(env, ctx, init.asm);</span>

                    }
<span class="nc" id="L2143">                    haveConstantValue |=</span>
<span class="nc bnc" id="L2144" title="All 2 branches missed.">                        (field.getInitialValue() != null);</span>
                }
<span class="nc" id="L2146">            } catch (CompilerError ee) {</span>
<span class="nc" id="L2147">                ee.printStackTrace();</span>
<span class="nc" id="L2148">                env.error(field, 0, &quot;generic&quot;,</span>
<span class="nc" id="L2149">                          field.getClassDeclaration() + &quot;:&quot; + field +</span>
<span class="nc" id="L2150">                          &quot;@&quot; + ee.toString(), null, null);</span>
<span class="nc" id="L2151">            }</span>
        }
<span class="nc bnc" id="L2153" title="All 2 branches missed.">        if (!init.asm.empty()) {</span>
<span class="nc" id="L2154">           init.asm.add(getWhere(), opc_return, true);</span>
<span class="nc" id="L2155">            methods.addElement(init);</span>
        }

        // bail out if there were any errors
<span class="nc bnc" id="L2159" title="All 2 branches missed.">        if (getNestError()) {</span>
<span class="nc" id="L2160">            return;</span>
        }

<span class="nc" id="L2163">        int nClassAttrs = 0;</span>

        // Insert constants
<span class="nc bnc" id="L2166" title="All 2 branches missed.">        if (methods.size() &gt; 0) {</span>
<span class="nc" id="L2167">            tab.put(&quot;Code&quot;);</span>
        }
<span class="nc bnc" id="L2169" title="All 2 branches missed.">        if (haveConstantValue) {</span>
<span class="nc" id="L2170">            tab.put(&quot;ConstantValue&quot;);</span>
        }

<span class="nc" id="L2173">        String sourceFile = null;</span>
<span class="nc bnc" id="L2174" title="All 2 branches missed.">        if (env.debug_source()) {</span>
<span class="nc" id="L2175">            sourceFile = ((ClassFile)getSource()).getName();</span>
<span class="nc" id="L2176">            tab.put(&quot;SourceFile&quot;);</span>
<span class="nc" id="L2177">            tab.put(sourceFile);</span>
<span class="nc" id="L2178">            nClassAttrs += 1;</span>
        }

<span class="nc bnc" id="L2181" title="All 2 branches missed.">        if (haveExceptions) {</span>
<span class="nc" id="L2182">            tab.put(&quot;Exceptions&quot;);</span>
        }

<span class="nc bnc" id="L2185" title="All 2 branches missed.">        if (env.debug_lines()) {</span>
<span class="nc" id="L2186">            tab.put(&quot;LineNumberTable&quot;);</span>
        }
<span class="nc bnc" id="L2188" title="All 2 branches missed.">        if (haveDeprecated) {</span>
<span class="nc" id="L2189">            tab.put(&quot;Deprecated&quot;);</span>
<span class="nc bnc" id="L2190" title="All 2 branches missed.">            if (this.isDeprecated()) {</span>
<span class="nc" id="L2191">                nClassAttrs += 1;</span>
            }
        }
<span class="nc bnc" id="L2194" title="All 2 branches missed.">        if (haveSynthetic) {</span>
<span class="nc" id="L2195">            tab.put(&quot;Synthetic&quot;);</span>
<span class="nc bnc" id="L2196" title="All 2 branches missed.">            if (this.isSynthetic()) {</span>
<span class="nc" id="L2197">                nClassAttrs += 1;</span>
            }
        }
// JCOV
<span class="nc bnc" id="L2201" title="All 2 branches missed.">        if (env.coverage()) {</span>
<span class="nc" id="L2202">            nClassAttrs += 2;           // AbsoluteSourcePath, TimeStamp</span>
<span class="nc" id="L2203">            tab.put(&quot;AbsoluteSourcePath&quot;);</span>
<span class="nc" id="L2204">            tab.put(&quot;TimeStamp&quot;);</span>
<span class="nc" id="L2205">            tab.put(&quot;CoverageTable&quot;);</span>
        }
// end JCOV
<span class="nc bnc" id="L2208" title="All 2 branches missed.">        if (env.debug_vars()) {</span>
<span class="nc" id="L2209">            tab.put(&quot;LocalVariableTable&quot;);</span>
        }
<span class="nc bnc" id="L2211" title="All 2 branches missed.">        if (innerClasses.size() &gt; 0) {</span>
<span class="nc" id="L2212">            tab.put(&quot;InnerClasses&quot;);</span>
<span class="nc" id="L2213">            nClassAttrs += 1;           // InnerClasses</span>
        }

// JCOV
<span class="nc" id="L2217">        String absoluteSourcePath = &quot;&quot;;</span>
<span class="nc" id="L2218">        long timeStamp = 0;</span>

<span class="nc bnc" id="L2220" title="All 2 branches missed.">        if (env.coverage()) {</span>
<span class="nc" id="L2221">                absoluteSourcePath = getAbsoluteName();</span>
<span class="nc" id="L2222">                timeStamp = System.currentTimeMillis();</span>
<span class="nc" id="L2223">                tab.put(absoluteSourcePath);</span>
        }
// end JCOV
<span class="nc" id="L2226">        tab.put(getClassDeclaration());</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">        if (getSuperClass() != null) {</span>
<span class="nc" id="L2228">            tab.put(getSuperClass());</span>
        }
<span class="nc bnc" id="L2230" title="All 2 branches missed.">        for (int i = 0 ; i &lt; interfaces.length ; i++) {</span>
<span class="nc" id="L2231">            tab.put(interfaces[i]);</span>
        }

        // Sort the methods in order to make sure both constant pool
        // entries and methods are in a deterministic order from run
        // to run (this allows comparing class files for a fixed point
        // to validate the compiler)
<span class="nc" id="L2238">        CompilerMember[] ordered_methods =</span>
<span class="nc" id="L2239">            new CompilerMember[methods.size()];</span>
<span class="nc" id="L2240">        methods.copyInto(ordered_methods);</span>
<span class="nc" id="L2241">        java.util.Arrays.sort(ordered_methods);</span>
<span class="nc bnc" id="L2242" title="All 2 branches missed.">        for (int i=0; i&lt;methods.size(); i++)</span>
<span class="nc" id="L2243">            methods.setElementAt(ordered_methods[i], i);</span>

        // Optimize Code and Collect method constants
<span class="nc bnc" id="L2246" title="All 2 branches missed.">        for (Enumeration e = methods.elements() ; e.hasMoreElements() ; ) {</span>
<span class="nc" id="L2247">            CompilerMember f = (CompilerMember)e.nextElement();</span>
            try {
<span class="nc" id="L2249">                f.asm.optimize(env);</span>
<span class="nc" id="L2250">                f.asm.collect(env, f.field, tab);</span>
<span class="nc" id="L2251">                tab.put(f.name);</span>
<span class="nc" id="L2252">                tab.put(f.sig);</span>
<span class="nc" id="L2253">                ClassDeclaration exp[] = f.field.getExceptions(env);</span>
<span class="nc bnc" id="L2254" title="All 2 branches missed.">                for (int i = 0 ; i &lt; exp.length ; i++) {</span>
<span class="nc" id="L2255">                    tab.put(exp[i]);</span>
                }
<span class="nc" id="L2257">            } catch (Exception ee) {</span>
<span class="nc" id="L2258">                ee.printStackTrace();</span>
<span class="nc" id="L2259">                env.error(f.field, -1, &quot;generic&quot;, f.field.getName() + &quot;@&quot; + ee.toString(), null, null);</span>
<span class="nc" id="L2260">                f.asm.listing(System.out);</span>
<span class="nc" id="L2261">            }</span>
<span class="nc" id="L2262">        }</span>

        // Collect field constants
<span class="nc bnc" id="L2265" title="All 2 branches missed.">        for (Enumeration e = variables.elements() ; e.hasMoreElements() ; ) {</span>
<span class="nc" id="L2266">            CompilerMember f = (CompilerMember)e.nextElement();</span>
<span class="nc" id="L2267">            tab.put(f.name);</span>
<span class="nc" id="L2268">            tab.put(f.sig);</span>

<span class="nc" id="L2270">            Object val = f.field.getInitialValue();</span>
<span class="nc bnc" id="L2271" title="All 2 branches missed.">            if (val != null) {</span>
<span class="nc bnc" id="L2272" title="All 2 branches missed.">                tab.put((val instanceof String) ? new StringExpression(f.field.getWhere(), (String)val) : val);</span>
            }
<span class="nc" id="L2274">        }</span>

        // Collect inner class constants
<span class="nc" id="L2277">        for (Enumeration e = innerClasses.elements();</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">             e.hasMoreElements() ; ) {</span>
<span class="nc" id="L2279">            ClassDefinition inner = (ClassDefinition)e.nextElement();</span>
<span class="nc" id="L2280">            tab.put(inner.getClassDeclaration());</span>

            // If the inner class is local, we do not need to add its
            // outer class here -- the outer_class_info_index is zero.
<span class="nc bnc" id="L2284" title="All 2 branches missed.">            if (!inner.isLocal()) {</span>
<span class="nc" id="L2285">                ClassDefinition outer = inner.getOuterClass();</span>
<span class="nc" id="L2286">                tab.put(outer.getClassDeclaration());</span>
            }

            // If the local name of the class is idNull, don't bother to
            // add it to the constant pool.  We won't need it.
<span class="nc" id="L2291">            Identifier inner_local_name = inner.getLocalName();</span>
<span class="nc bnc" id="L2292" title="All 2 branches missed.">            if (inner_local_name != idNull) {</span>
<span class="nc" id="L2293">                tab.put(inner_local_name.toString());</span>
            }
<span class="nc" id="L2295">        }</span>

        // Write header
<span class="nc" id="L2298">        DataOutputStream data = new DataOutputStream(out);</span>
<span class="nc" id="L2299">        data.writeInt(JAVA_MAGIC);</span>
<span class="nc" id="L2300">        data.writeShort(toplevelEnv.getMinorVersion());</span>
<span class="nc" id="L2301">        data.writeShort(toplevelEnv.getMajorVersion());</span>
<span class="nc" id="L2302">        tab.write(env, data);</span>

        // Write class information
<span class="nc" id="L2305">        int cmods = getModifiers() &amp; MM_CLASS;</span>

        // Certain modifiers are implied:
        // 1.  Any interface (nested or not) is implicitly deemed to be abstract,
        //     whether it is explicitly marked so or not.  (Java 1.0.)
        // 2.  A interface which is a member of a type is implicitly deemed to
        //     be static, whether it is explicitly marked so or not.
        // 3a. A type which is a member of an interface is implicitly deemed
        //     to be public, whether it is explicitly marked so or not.
        // 3b. A type which is a member of an interface is implicitly deemed
        //     to be static, whether it is explicitly marked so or not.
        // All of these rules are implemented in 'BatchParser.beginClass',
        // but the results are verified here.

<span class="nc bnc" id="L2319" title="All 2 branches missed.">        if (isInterface()) {</span>
            // Rule 1.
            // The VM spec states that ACC_ABSTRACT must be set when
            // ACC_INTERFACE is; this was not done by javac prior to 1.2,
            // and the runtime compensates by setting it.  Making sure
            // it is set here will allow the runtime hack to eventually
            // be removed. Rule 2 doesn't apply to transformed modifiers.
<span class="nc" id="L2326">            assertModifiers(cmods, ACC_ABSTRACT);</span>
        } else {
            // Contrary to the JVM spec, we only set ACC_SUPER for classes,
            // not interfaces.  This is a workaround for a bug in IE3.0,
            // which refuses interfaces with ACC_SUPER on.
<span class="nc" id="L2331">            cmods |= ACC_SUPER;</span>
        }

        // If this is a nested class, transform access modifiers.
<span class="nc bnc" id="L2335" title="All 2 branches missed.">        if (outerClass != null) {</span>
            // If private, transform to default (package) access.
            // If protected, transform to public.
            // M_PRIVATE and M_PROTECTED are already masked off by MM_CLASS above.
            // cmods &amp;= ~(M_PRIVATE | M_PROTECTED);
<span class="nc bnc" id="L2340" title="All 2 branches missed.">            if (isProtected()) cmods |= M_PUBLIC;</span>
            // Rule 3a.  Note that Rule 3b doesn't apply to transformed modifiers.
<span class="nc bnc" id="L2342" title="All 2 branches missed.">            if (outerClass.isInterface()) {</span>
<span class="nc" id="L2343">                assertModifiers(cmods, M_PUBLIC);</span>
            }
        }

<span class="nc" id="L2347">        data.writeShort(cmods);</span>

<span class="nc bnc" id="L2349" title="All 2 branches missed.">        if (env.dumpModifiers()) {</span>
<span class="nc" id="L2350">            Identifier cn = getName();</span>
<span class="nc" id="L2351">            Identifier nm =</span>
<span class="nc" id="L2352">                Identifier.lookup(cn.getQualifier(), cn.getFlatName());</span>
<span class="nc" id="L2353">            System.out.println();</span>
<span class="nc" id="L2354">            System.out.println(&quot;CLASSFILE  &quot; + nm);</span>
<span class="nc" id="L2355">            System.out.println(&quot;---&quot; + classModifierString(cmods));</span>
        }

<span class="nc" id="L2358">        data.writeShort(tab.index(getClassDeclaration()));</span>
<span class="nc bnc" id="L2359" title="All 2 branches missed.">        data.writeShort((getSuperClass() != null) ? tab.index(getSuperClass()) : 0);</span>
<span class="nc" id="L2360">        data.writeShort(interfaces.length);</span>
<span class="nc bnc" id="L2361" title="All 2 branches missed.">        for (int i = 0 ; i &lt; interfaces.length ; i++) {</span>
<span class="nc" id="L2362">            data.writeShort(tab.index(interfaces[i]));</span>
        }

        // write variables
<span class="nc" id="L2366">        ByteArrayOutputStream buf = new ByteArrayOutputStream(256);</span>
<span class="nc" id="L2367">        ByteArrayOutputStream attbuf = new ByteArrayOutputStream(256);</span>
<span class="nc" id="L2368">        DataOutputStream databuf = new DataOutputStream(buf);</span>

<span class="nc" id="L2370">        data.writeShort(variables.size());</span>
<span class="nc bnc" id="L2371" title="All 2 branches missed.">        for (Enumeration e = variables.elements() ; e.hasMoreElements() ; ) {</span>
<span class="nc" id="L2372">            CompilerMember f = (CompilerMember)e.nextElement();</span>
<span class="nc" id="L2373">            Object val = f.field.getInitialValue();</span>

<span class="nc" id="L2375">            data.writeShort(f.field.getModifiers() &amp; MM_FIELD);</span>
<span class="nc" id="L2376">            data.writeShort(tab.index(f.name));</span>
<span class="nc" id="L2377">            data.writeShort(tab.index(f.sig));</span>

<span class="nc bnc" id="L2379" title="All 2 branches missed.">            int fieldAtts = (val != null ? 1 : 0);</span>
<span class="nc" id="L2380">            boolean dep = f.field.isDeprecated();</span>
<span class="nc" id="L2381">            boolean syn = f.field.isSynthetic();</span>
<span class="nc bnc" id="L2382" title="All 4 branches missed.">            fieldAtts += (dep ? 1 : 0) + (syn ? 1 : 0);</span>

<span class="nc" id="L2384">            data.writeShort(fieldAtts);</span>
<span class="nc bnc" id="L2385" title="All 2 branches missed.">            if (val != null) {</span>
<span class="nc" id="L2386">                data.writeShort(tab.index(&quot;ConstantValue&quot;));</span>
<span class="nc" id="L2387">                data.writeInt(2);</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">                data.writeShort(tab.index((val instanceof String) ? new StringExpression(f.field.getWhere(), (String)val) : val));</span>
            }
<span class="nc bnc" id="L2390" title="All 2 branches missed.">            if (dep) {</span>
<span class="nc" id="L2391">                data.writeShort(tab.index(&quot;Deprecated&quot;));</span>
<span class="nc" id="L2392">                data.writeInt(0);</span>
            }
<span class="nc bnc" id="L2394" title="All 2 branches missed.">            if (syn) {</span>
<span class="nc" id="L2395">                data.writeShort(tab.index(&quot;Synthetic&quot;));</span>
<span class="nc" id="L2396">                data.writeInt(0);</span>
            }
<span class="nc" id="L2398">        }</span>

        // write methods

<span class="nc" id="L2402">        data.writeShort(methods.size());</span>
<span class="nc bnc" id="L2403" title="All 2 branches missed.">        for (Enumeration e = methods.elements() ; e.hasMoreElements() ; ) {</span>
<span class="nc" id="L2404">            CompilerMember f = (CompilerMember)e.nextElement();</span>

<span class="nc" id="L2406">            int xmods = f.field.getModifiers() &amp; MM_METHOD;</span>
            // Transform floating point modifiers.  M_STRICTFP
            // of member + status of enclosing class turn into
            // ACC_STRICT bit.
<span class="nc bnc" id="L2410" title="All 4 branches missed.">            if (((xmods &amp; M_STRICTFP)!=0) || ((cmods &amp; M_STRICTFP)!=0)) {</span>
<span class="nc" id="L2411">                xmods |= ACC_STRICT;</span>
            } else {
                // Use the default
<span class="nc bnc" id="L2414" title="All 2 branches missed.">                if (env.strictdefault()) {</span>
<span class="nc" id="L2415">                    xmods |= ACC_STRICT;</span>
                }
            }
<span class="nc" id="L2418">            data.writeShort(xmods);</span>

<span class="nc" id="L2420">            data.writeShort(tab.index(f.name));</span>
<span class="nc" id="L2421">            data.writeShort(tab.index(f.sig));</span>
<span class="nc" id="L2422">            ClassDeclaration exp[] = f.field.getExceptions(env);</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">            int methodAtts = ((exp.length &gt; 0) ? 1 : 0);</span>
<span class="nc" id="L2424">            boolean dep = f.field.isDeprecated();</span>
<span class="nc" id="L2425">            boolean syn = f.field.isSynthetic();</span>
<span class="nc bnc" id="L2426" title="All 4 branches missed.">            methodAtts += (dep ? 1 : 0) + (syn ? 1 : 0);</span>

<span class="nc bnc" id="L2428" title="All 2 branches missed.">            if (!f.asm.empty()) {</span>
<span class="nc" id="L2429">                data.writeShort(methodAtts+1);</span>
<span class="nc" id="L2430">                f.asm.write(env, databuf, f.field, tab);</span>
<span class="nc" id="L2431">                int natts = 0;</span>
<span class="nc bnc" id="L2432" title="All 2 branches missed.">                if (env.debug_lines()) {</span>
<span class="nc" id="L2433">                    natts++;</span>
                }
// JCOV
<span class="nc bnc" id="L2436" title="All 2 branches missed.">                if (env.coverage()) {</span>
<span class="nc" id="L2437">                    natts++;</span>
                }
// end JCOV
<span class="nc bnc" id="L2440" title="All 2 branches missed.">                if (env.debug_vars()) {</span>
<span class="nc" id="L2441">                    natts++;</span>
                }
<span class="nc" id="L2443">                databuf.writeShort(natts);</span>

<span class="nc bnc" id="L2445" title="All 2 branches missed.">                if (env.debug_lines()) {</span>
<span class="nc" id="L2446">                    f.asm.writeLineNumberTable(env, new DataOutputStream(attbuf), tab);</span>
<span class="nc" id="L2447">                    databuf.writeShort(tab.index(&quot;LineNumberTable&quot;));</span>
<span class="nc" id="L2448">                    databuf.writeInt(attbuf.size());</span>
<span class="nc" id="L2449">                    attbuf.writeTo(buf);</span>
<span class="nc" id="L2450">                    attbuf.reset();</span>
                }

//JCOV
<span class="nc bnc" id="L2454" title="All 2 branches missed.">                if (env.coverage()) {</span>
<span class="nc" id="L2455">                    f.asm.writeCoverageTable(env, (ClassDefinition)this, new DataOutputStream(attbuf), tab, f.field.getWhere());</span>
<span class="nc" id="L2456">                    databuf.writeShort(tab.index(&quot;CoverageTable&quot;));</span>
<span class="nc" id="L2457">                    databuf.writeInt(attbuf.size());</span>
<span class="nc" id="L2458">                    attbuf.writeTo(buf);</span>
<span class="nc" id="L2459">                    attbuf.reset();</span>
                }
// end JCOV
<span class="nc bnc" id="L2462" title="All 2 branches missed.">                if (env.debug_vars()) {</span>
<span class="nc" id="L2463">                    f.asm.writeLocalVariableTable(env, f.field, new DataOutputStream(attbuf), tab);</span>
<span class="nc" id="L2464">                    databuf.writeShort(tab.index(&quot;LocalVariableTable&quot;));</span>
<span class="nc" id="L2465">                    databuf.writeInt(attbuf.size());</span>
<span class="nc" id="L2466">                    attbuf.writeTo(buf);</span>
<span class="nc" id="L2467">                    attbuf.reset();</span>
                }

<span class="nc" id="L2470">                data.writeShort(tab.index(&quot;Code&quot;));</span>
<span class="nc" id="L2471">                data.writeInt(buf.size());</span>
<span class="nc" id="L2472">                buf.writeTo(data);</span>
<span class="nc" id="L2473">                buf.reset();</span>
<span class="nc" id="L2474">            } else {</span>
//JCOV
<span class="nc bnc" id="L2476" title="All 4 branches missed.">                if ((env.coverage()) &amp;&amp; ((f.field.getModifiers() &amp; M_NATIVE) &gt; 0))</span>
<span class="nc" id="L2477">                    f.asm.addNativeToJcovTab(env, (ClassDefinition)this);</span>
// end JCOV
<span class="nc" id="L2479">                data.writeShort(methodAtts);</span>
            }

<span class="nc bnc" id="L2482" title="All 2 branches missed.">            if (exp.length &gt; 0) {</span>
<span class="nc" id="L2483">                data.writeShort(tab.index(&quot;Exceptions&quot;));</span>
<span class="nc" id="L2484">                data.writeInt(2 + exp.length * 2);</span>
<span class="nc" id="L2485">                data.writeShort(exp.length);</span>
<span class="nc bnc" id="L2486" title="All 2 branches missed.">                for (int i = 0 ; i &lt; exp.length ; i++) {</span>
<span class="nc" id="L2487">                    data.writeShort(tab.index(exp[i]));</span>
                }
            }
<span class="nc bnc" id="L2490" title="All 2 branches missed.">            if (dep) {</span>
<span class="nc" id="L2491">                data.writeShort(tab.index(&quot;Deprecated&quot;));</span>
<span class="nc" id="L2492">                data.writeInt(0);</span>
            }
<span class="nc bnc" id="L2494" title="All 2 branches missed.">            if (syn) {</span>
<span class="nc" id="L2495">                data.writeShort(tab.index(&quot;Synthetic&quot;));</span>
<span class="nc" id="L2496">                data.writeInt(0);</span>
            }
<span class="nc" id="L2498">        }</span>

        // class attributes
<span class="nc" id="L2501">        data.writeShort(nClassAttrs);</span>

<span class="nc bnc" id="L2503" title="All 2 branches missed.">        if (env.debug_source()) {</span>
<span class="nc" id="L2504">            data.writeShort(tab.index(&quot;SourceFile&quot;));</span>
<span class="nc" id="L2505">            data.writeInt(2);</span>
<span class="nc" id="L2506">            data.writeShort(tab.index(sourceFile));</span>
        }

<span class="nc bnc" id="L2509" title="All 2 branches missed.">        if (this.isDeprecated()) {</span>
<span class="nc" id="L2510">            data.writeShort(tab.index(&quot;Deprecated&quot;));</span>
<span class="nc" id="L2511">            data.writeInt(0);</span>
        }
<span class="nc bnc" id="L2513" title="All 2 branches missed.">        if (this.isSynthetic()) {</span>
<span class="nc" id="L2514">            data.writeShort(tab.index(&quot;Synthetic&quot;));</span>
<span class="nc" id="L2515">            data.writeInt(0);</span>
        }

// JCOV
<span class="nc bnc" id="L2519" title="All 2 branches missed.">        if (env.coverage()) {</span>
<span class="nc" id="L2520">            data.writeShort(tab.index(&quot;AbsoluteSourcePath&quot;));</span>
<span class="nc" id="L2521">            data.writeInt(2);</span>
<span class="nc" id="L2522">            data.writeShort(tab.index(absoluteSourcePath));</span>
<span class="nc" id="L2523">            data.writeShort(tab.index(&quot;TimeStamp&quot;));</span>
<span class="nc" id="L2524">            data.writeInt(8);</span>
<span class="nc" id="L2525">            data.writeLong(timeStamp);</span>
        }
// end JCOV

<span class="nc bnc" id="L2529" title="All 2 branches missed.">        if (innerClasses.size() &gt; 0) {</span>
<span class="nc" id="L2530">            data.writeShort(tab.index(&quot;InnerClasses&quot;));</span>
<span class="nc" id="L2531">            data.writeInt(2 + 2*4*innerClasses.size());</span>
<span class="nc" id="L2532">            data.writeShort(innerClasses.size());</span>
<span class="nc" id="L2533">            for (Enumeration e = innerClasses.elements() ;</span>
<span class="nc bnc" id="L2534" title="All 2 branches missed.">                 e.hasMoreElements() ; ) {</span>
                // For each inner class name transformation, we have a record
                // with the following fields:
                //
                //    u2 inner_class_info_index;   // CONSTANT_Class_info index
                //    u2 outer_class_info_index;   // CONSTANT_Class_info index
                //    u2 inner_name_index;         // CONSTANT_Utf8_info index
                //    u2 inner_class_access_flags; // access_flags bitmask
                //
                // The spec states that outer_class_info_index is 0 iff
                // the inner class is not a member of its enclosing class (i.e.
                // it is a local or anonymous class).  The spec also states
                // that if a class is anonymous then inner_name_index should
                // be 0.
                //
                // See also the initInnerClasses() method in BinaryClass.java.

                // Generate inner_class_info_index.
<span class="nc" id="L2552">                ClassDefinition inner = (ClassDefinition)e.nextElement();</span>
<span class="nc" id="L2553">                data.writeShort(tab.index(inner.getClassDeclaration()));</span>

                // Generate outer_class_info_index.
                //
                // Checking isLocal() should probably be enough here,
                // but the check for isAnonymous is added for good
                // measure.
<span class="nc bnc" id="L2560" title="All 4 branches missed.">                if (inner.isLocal() || inner.isAnonymous()) {</span>
<span class="nc" id="L2561">                    data.writeShort(0);</span>
                } else {
                    // Query: what about if inner.isInsideLocal()?
                    // For now we continue to generate a nonzero
                    // outer_class_info_index.
<span class="nc" id="L2566">                    ClassDefinition outer = inner.getOuterClass();</span>
<span class="nc" id="L2567">                    data.writeShort(tab.index(outer.getClassDeclaration()));</span>
                }

                // Generate inner_name_index.
<span class="nc" id="L2571">                Identifier inner_name = inner.getLocalName();</span>
<span class="nc bnc" id="L2572" title="All 2 branches missed.">                if (inner_name == idNull) {</span>
<span class="nc bnc" id="L2573" title="All 2 branches missed.">                    if (!inner.isAnonymous()) {</span>
<span class="nc" id="L2574">                        throw new CompilerError(&quot;compileClass(), anonymous&quot;);</span>
                    }
<span class="nc" id="L2576">                    data.writeShort(0);</span>
                } else {
<span class="nc" id="L2578">                    data.writeShort(tab.index(inner_name.toString()));</span>
                }

                // Generate inner_class_access_flags.
<span class="nc" id="L2582">                int imods = inner.getInnerClassMember().getModifiers()</span>
                            &amp; ACCM_INNERCLASS;

                // Certain modifiers are implied for nested types.
                // See rules 1, 2, 3a, and 3b enumerated above.
                // All of these rules are implemented in 'BatchParser.beginClass',
                // but are verified here.

<span class="nc bnc" id="L2590" title="All 2 branches missed.">                if (inner.isInterface()) {</span>
                    // Rules 1 and 2.
<span class="nc" id="L2592">                    assertModifiers(imods, M_ABSTRACT | M_STATIC);</span>
                }
<span class="nc bnc" id="L2594" title="All 2 branches missed.">                if (inner.getOuterClass().isInterface()) {</span>
                    // Rules 3a and 3b.
<span class="nc" id="L2596">                    imods &amp;= ~(M_PRIVATE | M_PROTECTED); // error recovery</span>
<span class="nc" id="L2597">                    assertModifiers(imods, M_PUBLIC | M_STATIC);</span>
                }

<span class="nc" id="L2600">                data.writeShort(imods);</span>

<span class="nc bnc" id="L2602" title="All 2 branches missed.">                if (env.dumpModifiers()) {</span>
<span class="nc" id="L2603">                    Identifier fn = inner.getInnerClassMember().getName();</span>
<span class="nc" id="L2604">                    Identifier nm =</span>
<span class="nc" id="L2605">                        Identifier.lookup(fn.getQualifier(), fn.getFlatName());</span>
<span class="nc" id="L2606">                    System.out.println(&quot;INNERCLASS &quot; + nm);</span>
<span class="nc" id="L2607">                    System.out.println(&quot;---&quot; + classModifierString(imods));</span>
                }

<span class="nc" id="L2610">            }</span>
        }

        // Cleanup
<span class="nc" id="L2614">        data.flush();</span>
<span class="nc" id="L2615">        tab = null;</span>

// JCOV
        // generate coverage data
<span class="nc bnc" id="L2619" title="All 2 branches missed.">        if (env.covdata()) {</span>
<span class="nc" id="L2620">            Assembler CovAsm = new Assembler();</span>
<span class="nc" id="L2621">            CovAsm.GenVecJCov(env, (ClassDefinition)this, timeStamp);</span>
        }
// end JCOV
<span class="nc" id="L2624">    }</span>

    /**
     * Print out the dependencies for this class (-xdepend) option
     */

    public void printClassDependencies(Environment env) {

        // Only do this if the -xdepend flag is on
<span class="nc bnc" id="L2633" title="All 2 branches missed.">        if ( toplevelEnv.print_dependencies() ) {</span>

            // Name of java source file this class was in (full path)
            //    e.g. /home/ohair/Test.java
<span class="nc" id="L2637">            String src = ((ClassFile)getSource()).getAbsoluteName();</span>

            // Class name, fully qualified
            //   e.g. &quot;java.lang.Object&quot; or &quot;JDKBar&quot; or &quot;sun.tools.javac.Main&quot;
            // Inner class names must be mangled, as ordinary '.' qualification
            // is used internally where the spec requires '$' separators.
            //   String className = getName().toString();
<span class="nc" id="L2644">            String className = Type.mangleInnerType(getName()).toString();</span>

            // Line number where class starts in the src file
<span class="nc" id="L2647">            long startLine = getWhere() &gt;&gt; WHEREOFFSETBITS;</span>

            // Line number where class ends in the src file (not used yet)
<span class="nc" id="L2650">            long endLine = getEndPosition() &gt;&gt; WHEREOFFSETBITS;</span>

            // First line looks like:
            //    CLASS:src,startLine,endLine,className
<span class="nc" id="L2654">            System.out.println( &quot;CLASS:&quot;</span>
                    + src               + &quot;,&quot;
                    + startLine         + &quot;,&quot;
                    + endLine   + &quot;,&quot;
                    + className);

            // For each class this class is dependent on:
            //    CLDEP:className1,className2
            //  where className1 is the name of the class we are in, and
            //        classname2 is the name of the class className1
            //          is dependent on.
<span class="nc bnc" id="L2665" title="All 2 branches missed.">            for(Enumeration e = deps.elements();  e.hasMoreElements(); ) {</span>
<span class="nc" id="L2666">                ClassDeclaration data = (ClassDeclaration) e.nextElement();</span>
                // Mangle name of class dependend on.
<span class="nc" id="L2668">                String depName =</span>
<span class="nc" id="L2669">                    Type.mangleInnerType(data.getName()).toString();</span>
<span class="nc" id="L2670">                env.output(&quot;CLDEP:&quot; + className + &quot;,&quot; + depName);</span>
<span class="nc" id="L2671">            }</span>
        }
<span class="nc" id="L2673">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>