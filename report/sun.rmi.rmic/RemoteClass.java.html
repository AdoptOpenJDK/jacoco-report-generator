<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RemoteClass.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.rmi.rmic</a> &gt; <span class="el_source">RemoteClass.java</span></div><h1>RemoteClass.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.rmi.rmic;

import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.security.MessageDigest;
import java.security.DigestOutputStream;
import java.security.NoSuchAlgorithmException;
import sun.tools.java.Type;
import sun.tools.java.ClassDefinition;
import sun.tools.java.ClassDeclaration;
import sun.tools.java.MemberDefinition;
import sun.tools.java.Identifier;
import sun.tools.java.ClassNotFound;

/**
 * A RemoteClass object encapsulates RMI-specific information about
 * a remote implementation class, i.e. a class that implements
 * one or more remote interfaces.
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 *
 * @author      Peter Jones
 */
public class RemoteClass implements sun.rmi.rmic.RMIConstants {

    /**
     * Create a RemoteClass object representing the remote meta-information
     * of the given class.
     *
     * Returns true if successful.  If the class is not a properly formed
     * remote implementation class or if some other error occurs, the
     * return value will be null, and errors will have been reported to
     * the supplied BatchEnvironment.
     */
    public static RemoteClass forClass(BatchEnvironment env,
                                       ClassDefinition implClassDef)
    {
<span class="nc" id="L69">        RemoteClass rc = new RemoteClass(env, implClassDef);</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (rc.initialize()) {</span>
<span class="nc" id="L71">            return rc;</span>
        } else {
<span class="nc" id="L73">            return null;</span>
        }
    }

    /**
     * Return the ClassDefinition for this class.
     */
    public ClassDefinition getClassDefinition() {
<span class="nc" id="L81">        return implClassDef;</span>
    }

    /**
     * Return the name of the class represented by this object.
     */
    public Identifier getName() {
<span class="nc" id="L88">        return implClassDef.getName();</span>
    }

    /**
     * Return an array of ClassDefinitions representing all of the remote
     * interfaces implemented by this class.
     *
     * A remote interface is any interface that extends Remote,
     * directly or indirectly.  The remote interfaces of a class
     * are the interfaces directly listed in either the class's
     * &quot;implements&quot; clause, or the &quot;implements&quot; clause of any
     * of its superclasses, that are remote interfaces.
     *
     * The order of the array returned is arbitrary, and some elements
     * may be superfluous (i.e., superinterfaces of other interfaces
     * in the array).
     */
    public ClassDefinition[] getRemoteInterfaces() {
<span class="nc" id="L106">        return remoteInterfaces.clone();</span>
    }

    /**
     * Return an array of RemoteClass.Method objects representing all of
     * the remote methods implemented by this class, i.e. all of the
     * methods in the class's remote interfaces.
     *
     * The methods in the array are ordered according to the comparision
     * of the strings consisting of their method name followed by their
     * type signature, so each method's index in the array corresponds
     * to its &quot;operation number&quot; in the JDK 1.1 version of the
     * stub/skeleton protocol.
     */
    public Method[] getRemoteMethods() {
<span class="nc" id="L121">        return remoteMethods.clone();</span>
    }

    /**
     * Return the &quot;interface hash&quot; used to match a stub/skeleton pair for
     * this class in the JDK 1.1 version of the stub/skeleton protocol.
     */
    public long getInterfaceHash() {
<span class="nc" id="L129">        return interfaceHash;</span>
    }

    /**
     * Return string representation of this object, consisting of
     * the string &quot;remote class &quot; followed by the class name.
     */
    public String toString() {
<span class="nc" id="L137">        return &quot;remote class &quot; + implClassDef.getName().toString();</span>
    }

    /** rmic environment for this object */
    private BatchEnvironment env;

    /** the remote implementation class this object corresponds to */
    private ClassDefinition implClassDef;

    /** remote interfaces implemented by this class */
    private ClassDefinition[] remoteInterfaces;

    /** all the remote methods of this class */
    private Method[] remoteMethods;

    /** stub/skeleton &quot;interface hash&quot; for this class */
    private long interfaceHash;

    /** cached definition for certain classes used in this environment */
    private ClassDefinition defRemote;
    private ClassDefinition defException;
    private ClassDefinition defRemoteException;

    /**
     * Create a RemoteClass instance for the given class.  The resulting
     * object is not yet initialized.
     */
<span class="nc" id="L164">    private RemoteClass(BatchEnvironment env, ClassDefinition implClassDef) {</span>
<span class="nc" id="L165">        this.env = env;</span>
<span class="nc" id="L166">        this.implClassDef = implClassDef;</span>
<span class="nc" id="L167">    }</span>

    /**
     * Validate that the remote implementation class is properly formed
     * and fill in the data structures required by the public interface.
     */
    private boolean initialize() {
        /*
         * Verify that the &quot;impl&quot; is really a class, not an interface.
         */
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (implClassDef.isInterface()) {</span>
<span class="nc" id="L178">            env.error(0, &quot;rmic.cant.make.stubs.for.interface&quot;,</span>
<span class="nc" id="L179">                      implClassDef.getName());</span>
<span class="nc" id="L180">            return false;</span>
        }

        /*
         * Initialize cached definitions for the Remote interface and
         * the RemoteException class.
         */
        try {
<span class="nc" id="L188">            defRemote =</span>
<span class="nc" id="L189">                env.getClassDeclaration(idRemote).getClassDefinition(env);</span>
<span class="nc" id="L190">            defException =</span>
<span class="nc" id="L191">                env.getClassDeclaration(idJavaLangException).</span>
<span class="nc" id="L192">                getClassDefinition(env);</span>
<span class="nc" id="L193">            defRemoteException =</span>
<span class="nc" id="L194">                env.getClassDeclaration(idRemoteException).</span>
<span class="nc" id="L195">                getClassDefinition(env);</span>
<span class="nc" id="L196">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L197">            env.error(0, &quot;rmic.class.not.found&quot;, e.name);</span>
<span class="nc" id="L198">            return false;</span>
<span class="nc" id="L199">        }</span>

        /*
         * Here we find all of the remote interfaces of our remote
         * implementation class.  For each class up the superclass
         * chain, add each directly-implemented interface that
         * somehow extends Remote to a list.
         */
<span class="nc" id="L207">        Vector&lt;ClassDefinition&gt; remotesImplemented = // list of remote interfaces found</span>
            new Vector&lt;ClassDefinition&gt;();
<span class="nc" id="L209">        for (ClassDefinition classDef = implClassDef;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">             classDef != null;)</span>
            {
                try {
<span class="nc" id="L213">                    ClassDeclaration[] interfaces = classDef.getInterfaces();</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                    for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="nc" id="L215">                        ClassDefinition interfaceDef =</span>
<span class="nc" id="L216">                            interfaces[i].getClassDefinition(env);</span>
                        /*
                         * Add interface to the list if it extends Remote and
                         * it is not already there.
                         */
<span class="nc bnc" id="L221" title="All 2 branches missed.">                        if (!remotesImplemented.contains(interfaceDef) &amp;&amp;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                            defRemote.implementedBy(env, interfaces[i]))</span>
                            {
<span class="nc" id="L224">                                remotesImplemented.addElement(interfaceDef);</span>
                                /***** &lt;DEBUG&gt; */
<span class="nc bnc" id="L226" title="All 2 branches missed.">                                if (env.verbose()) {</span>
<span class="nc" id="L227">                                    System.out.println(&quot;[found remote interface: &quot; +</span>
<span class="nc" id="L228">                                                       interfaceDef.getName() + &quot;]&quot;);</span>
                                    /***** &lt;/DEBUG&gt; */
                                }
                            }
                    }

                    /*
                     * Verify that the candidate remote implementation class
                     * implements at least one remote interface directly.
                     */
<span class="nc bnc" id="L238" title="All 4 branches missed.">                    if (classDef == implClassDef &amp;&amp; remotesImplemented.isEmpty()) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                        if (defRemote.implementedBy(env,</span>
<span class="nc" id="L240">                                                    implClassDef.getClassDeclaration()))</span>
                            {
                                /*
                                 * This error message is used if the class does
                                 * implement a remote interface through one of
                                 * its superclasses, but not directly.
                                 */
<span class="nc" id="L247">                                env.error(0, &quot;rmic.must.implement.remote.directly&quot;,</span>
<span class="nc" id="L248">                                          implClassDef.getName());</span>
                            } else {
                                /*
                                 * This error message is used if the class never
                                 * implements a remote interface.
                                 */
<span class="nc" id="L254">                                env.error(0, &quot;rmic.must.implement.remote&quot;,</span>
<span class="nc" id="L255">                                          implClassDef.getName());</span>
                            }
<span class="nc" id="L257">                        return false;</span>
                    }

                    /*
                     * Get definition for next superclass.
                     */
<span class="nc bnc" id="L263" title="All 2 branches missed.">                    classDef = (classDef.getSuperClass() != null ?</span>
<span class="nc" id="L264">                                classDef.getSuperClass().getClassDefinition(env) :</span>
                                null);

<span class="nc" id="L267">                } catch (ClassNotFound e) {</span>
<span class="nc" id="L268">                    env.error(0, &quot;class.not.found&quot;, e.name, classDef.getName());</span>
<span class="nc" id="L269">                    return false;</span>
<span class="nc" id="L270">                }</span>
            }

        /*
         * The &quot;remotesImplemented&quot; vector now contains all of the remote
         * interfaces directly implemented by the remote class or by any
         * of its superclasses.
         *
         * At this point, we could optimize the list by removing superfluous
         * entries, i.e. any interfaces that are implemented by some other
         * interface in the list anyway.
         *
         * This should be correct; would it be worthwhile?
         *
         *      for (int i = 0; i &lt; remotesImplemented.size();) {
         *          ClassDefinition interfaceDef =
         *              (ClassDefinition) remotesImplemented.elementAt(i);
         *          boolean isOtherwiseImplemented = false;
         *          for (int j = 0; j &lt; remotesImplemented.size; j++) {
         *              if (j != i &amp;&amp;
         *                  interfaceDef.implementedBy(env, (ClassDefinition)
         *                  remotesImplemented.elementAt(j).
         *                      getClassDeclaration()))
         *              {
         *                  isOtherwiseImplemented = true;
         *                  break;
         *              }
         *          }
         *          if (isOtherwiseImplemented) {
         *              remotesImplemented.removeElementAt(i);
         *          } else {
         *              ++i;
         *          }
         *      }
         */

        /*
         * Now we collect the methods from all of the remote interfaces
         * into a hashtable.
         */
<span class="nc" id="L310">        Hashtable&lt;String, Method&gt; methods = new Hashtable&lt;String, Method&gt;();</span>
<span class="nc" id="L311">        boolean errors = false;</span>
<span class="nc" id="L312">        for (Enumeration&lt;ClassDefinition&gt; enumeration</span>
<span class="nc" id="L313">                 = remotesImplemented.elements();</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">             enumeration.hasMoreElements();)</span>
            {
<span class="nc" id="L316">                ClassDefinition interfaceDef = enumeration.nextElement();</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                if (!collectRemoteMethods(interfaceDef, methods))</span>
<span class="nc" id="L318">                    errors = true;</span>
<span class="nc" id="L319">            }</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (errors)</span>
<span class="nc" id="L321">            return false;</span>

        /*
         * Convert vector of remote interfaces to an array
         * (order is not important for this array).
         */
<span class="nc" id="L327">        remoteInterfaces = new ClassDefinition[remotesImplemented.size()];</span>
<span class="nc" id="L328">        remotesImplemented.copyInto(remoteInterfaces);</span>

        /*
         * Sort table of remote methods into an array.  The elements are
         * sorted in ascending order of the string of the method's name
         * and type signature, so that each elements index is equal to
         * its operation number of the JDK 1.1 version of the stub/skeleton
         * protocol.
         */
<span class="nc" id="L337">        String[] orderedKeys = new String[methods.size()];</span>
<span class="nc" id="L338">        int count = 0;</span>
<span class="nc" id="L339">        for (Enumeration&lt;Method&gt; enumeration = methods.elements();</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">             enumeration.hasMoreElements();)</span>
            {
<span class="nc" id="L342">                Method m = enumeration.nextElement();</span>
<span class="nc" id="L343">                String key = m.getNameAndDescriptor();</span>
                int i;
<span class="nc bnc" id="L345" title="All 2 branches missed.">                for (i = count; i &gt; 0; --i) {</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">                    if (key.compareTo(orderedKeys[i - 1]) &gt;= 0) {</span>
<span class="nc" id="L347">                        break;</span>
                    }
<span class="nc" id="L349">                    orderedKeys[i] = orderedKeys[i - 1];</span>
                }
<span class="nc" id="L351">                orderedKeys[i] = key;</span>
<span class="nc" id="L352">                ++count;</span>
<span class="nc" id="L353">            }</span>
<span class="nc" id="L354">        remoteMethods = new Method[methods.size()];</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">        for (int i = 0; i &lt; remoteMethods.length; i++) {</span>
<span class="nc" id="L356">            remoteMethods[i] = methods.get(orderedKeys[i]);</span>
            /***** &lt;DEBUG&gt; */
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (env.verbose()) {</span>
<span class="nc" id="L359">                System.out.print(&quot;[found remote method &lt;&quot; + i + &quot;&gt;: &quot; +</span>
<span class="nc" id="L360">                                 remoteMethods[i].getOperationString());</span>
<span class="nc" id="L361">                ClassDeclaration[] exceptions =</span>
<span class="nc" id="L362">                    remoteMethods[i].getExceptions();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">                if (exceptions.length &gt; 0)</span>
<span class="nc" id="L364">                    System.out.print(&quot; throws &quot;);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                for (int j = 0; j &lt; exceptions.length; j++) {</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                    if (j &gt; 0)</span>
<span class="nc" id="L367">                        System.out.print(&quot;, &quot;);</span>
<span class="nc" id="L368">                    System.out.print(exceptions[j].getName());</span>
                }
<span class="nc" id="L370">                System.out.println(&quot;]&quot;);</span>
            }
            /***** &lt;/DEBUG&gt; */
        }

        /**
         * Finally, pre-compute the interface hash to be used by
         * stubs/skeletons for this remote class.
         */
<span class="nc" id="L379">        interfaceHash = computeInterfaceHash();</span>

<span class="nc" id="L381">        return true;</span>
    }

    /**
     * Collect and validate all methods from given interface and all of
     * its superinterfaces as remote methods.  Remote methods are added
     * to the supplied hashtable.  Returns true if successful,
     * or false if an error occurred.
     */
    private boolean collectRemoteMethods(ClassDefinition interfaceDef,
                                         Hashtable&lt;String, Method&gt; table)
    {
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (!interfaceDef.isInterface()) {</span>
<span class="nc" id="L394">            throw new Error(</span>
<span class="nc" id="L395">                            &quot;expected interface, not class: &quot; + interfaceDef.getName());</span>
        }

        /*
         * rmic used to enforce that a remote interface could not extend
         * a non-remote interface, i.e. an interface that did not itself
         * extend from Remote.  The current version of rmic does not have
         * this restriction, so the following code is now commented out.
         *
         * Verify that this interface extends Remote, since all interfaces
         * extended by a remote interface must implement Remote.
         *
         *      try {
         *          if (!defRemote.implementedBy(env,
         *              interfaceDef.getClassDeclaration()))
         *          {
         *              env.error(0, &quot;rmic.can.mix.remote.nonremote&quot;,
         *                  interfaceDef.getName());
         *              return false;
         *          }
         *      } catch (ClassNotFound e) {
         *          env.error(0, &quot;class.not.found&quot;, e.name,
         *              interfaceDef.getName());
         *          return false;
         *      }
         */

<span class="nc" id="L422">        boolean errors = false;</span>

        /*
         * Search interface's members for methods.
         */
    nextMember:
<span class="nc" id="L428">        for (MemberDefinition member = interfaceDef.getFirstMember();</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">             member != null;</span>
<span class="nc" id="L430">             member = member.getNextMember())</span>
            {
<span class="nc bnc" id="L432" title="All 2 branches missed.">                if (member.isMethod() &amp;&amp;</span>
<span class="nc bnc" id="L433" title="All 4 branches missed.">                    !member.isConstructor() &amp;&amp; !member.isInitializer())</span>
                    {
                        /*
                         * Verify that each method throws RemoteException.
                         */
<span class="nc" id="L438">                        ClassDeclaration[] exceptions = member.getExceptions(env);</span>
<span class="nc" id="L439">                        boolean hasRemoteException = false;</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">                        for (int i = 0; i &lt; exceptions.length; i++) {</span>
                            /*
                             * rmic used to enforce that a remote method had to
                             * explicitly list RemoteException in its &quot;throws&quot;
                             * clause; i.e., just throwing Exception was not
                             * acceptable.  The current version of rmic does not
                             * have this restriction, so the following code is
                             * now commented out.  Instead, the method is
                             * considered valid if RemoteException is a subclass
                             * of any of the methods declared exceptions.
                             *
                             *  if (exceptions[i].getName().equals(
                             *      idRemoteException))
                             *  {
                             *      hasRemoteException = true;
                             *      break;
                             *  }
                             */
                            try {
<span class="nc bnc" id="L459" title="All 2 branches missed.">                                if (defRemoteException.subClassOf(</span>
                                                                  env, exceptions[i]))
                                    {
<span class="nc" id="L462">                                        hasRemoteException = true;</span>
<span class="nc" id="L463">                                        break;</span>
                                    }
<span class="nc" id="L465">                            } catch (ClassNotFound e) {</span>
<span class="nc" id="L466">                                env.error(0, &quot;class.not.found&quot;, e.name,</span>
<span class="nc" id="L467">                                          interfaceDef.getName());</span>
<span class="nc" id="L468">                                continue nextMember;</span>
<span class="nc" id="L469">                            }</span>
                        }
                        /*
                         * If this method did not throw RemoteException as required,
                         * generate the error but continue, so that multiple such
                         * errors can be reported.
                         */
<span class="nc bnc" id="L476" title="All 2 branches missed.">                        if (!hasRemoteException) {</span>
<span class="nc" id="L477">                            env.error(0, &quot;rmic.must.throw.remoteexception&quot;,</span>
<span class="nc" id="L478">                                      interfaceDef.getName(), member.toString());</span>
<span class="nc" id="L479">                            errors = true;</span>
<span class="nc" id="L480">                            continue nextMember;</span>
                        }

                        /*
                         * Verify that the implementation of this method throws only
                         * java.lang.Exception or its subclasses (fix bugid 4092486).
                         * JRMP does not support remote methods throwing
                         * java.lang.Throwable or other subclasses.
                         */
                        try {
<span class="nc" id="L490">                            MemberDefinition implMethod = implClassDef.findMethod(</span>
<span class="nc" id="L491">                                                                                  env, member.getName(), member.getType());</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                            if (implMethod != null) {           // should not be null</span>
<span class="nc" id="L493">                                exceptions = implMethod.getExceptions(env);</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                                for (int i = 0; i &lt; exceptions.length; i++) {</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">                                    if (!defException.superClassOf(</span>
                                                                   env, exceptions[i]))
                                        {
<span class="nc" id="L498">                                            env.error(0, &quot;rmic.must.only.throw.exception&quot;,</span>
<span class="nc" id="L499">                                                      implMethod.toString(),</span>
<span class="nc" id="L500">                                                      exceptions[i].getName());</span>
<span class="nc" id="L501">                                            errors = true;</span>
<span class="nc" id="L502">                                            continue nextMember;</span>
                                        }
                                }
                            }
<span class="nc" id="L506">                        } catch (ClassNotFound e) {</span>
<span class="nc" id="L507">                            env.error(0, &quot;class.not.found&quot;, e.name,</span>
<span class="nc" id="L508">                                      implClassDef.getName());</span>
<span class="nc" id="L509">                            continue nextMember;</span>
<span class="nc" id="L510">                        }</span>

                        /*
                         * Create RemoteClass.Method object to represent this method
                         * found in a remote interface.
                         */
<span class="nc" id="L516">                        Method newMethod = new Method(member);</span>
                        /*
                         * Store remote method's representation in the table of
                         * remote methods found, keyed by its name and parameter
                         * signature.
                         *
                         * If the table already contains an entry with the same
                         * method name and parameter signature, then we must
                         * replace the old entry with a Method object that
                         * represents a legal combination of the old and the new
                         * methods; specifically, the combined method must have
                         * a throws list that contains (only) all of the checked
                         * exceptions that can be thrown by both the old or
                         * the new method (see bugid 4070653).
                         */
<span class="nc" id="L531">                        String key = newMethod.getNameAndDescriptor();</span>
<span class="nc" id="L532">                        Method oldMethod = table.get(key);</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">                        if (oldMethod != null) {</span>
<span class="nc" id="L534">                            newMethod = newMethod.mergeWith(oldMethod);</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">                            if (newMethod == null) {</span>
<span class="nc" id="L536">                                errors = true;</span>
<span class="nc" id="L537">                                continue nextMember;</span>
                            }
                        }
<span class="nc" id="L540">                        table.put(key, newMethod);</span>
                    }
            }

        /*
         * Recursively collect methods for all superinterfaces.
         */
        try {
<span class="nc" id="L548">            ClassDeclaration[] superDefs = interfaceDef.getInterfaces();</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            for (int i = 0; i &lt; superDefs.length; i++) {</span>
<span class="nc" id="L550">                ClassDefinition superDef =</span>
<span class="nc" id="L551">                    superDefs[i].getClassDefinition(env);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                if (!collectRemoteMethods(superDef, table))</span>
<span class="nc" id="L553">                    errors = true;</span>
            }
<span class="nc" id="L555">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L556">            env.error(0, &quot;class.not.found&quot;, e.name, interfaceDef.getName());</span>
<span class="nc" id="L557">            return false;</span>
<span class="nc" id="L558">        }</span>

<span class="nc bnc" id="L560" title="All 2 branches missed.">        return !errors;</span>
    }

    /**
     * Compute the &quot;interface hash&quot; of the stub/skeleton pair for this
     * remote implementation class.  This is the 64-bit value used to
     * enforce compatibility between a stub and a skeleton using the
     * JDK 1.1 version of the stub/skeleton protocol.
     *
     * It is calculated using the first 64 bits of a SHA digest.  The
     * digest is from a stream consisting of the following data:
     *     (int) stub version number, always 1
     *     for each remote method, in order of operation number:
     *         (UTF) method name
     *         (UTF) method type signature
     *         for each declared exception, in alphabetical name order:
     *             (UTF) name of exception class
     *
     */
    private long computeInterfaceHash() {
<span class="nc" id="L580">        long hash = 0;</span>
<span class="nc" id="L581">        ByteArrayOutputStream sink = new ByteArrayOutputStream(512);</span>
        try {
<span class="nc" id="L583">            MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);</span>
<span class="nc" id="L584">            DataOutputStream out = new DataOutputStream(</span>
                                                        new DigestOutputStream(sink, md));

<span class="nc" id="L587">            out.writeInt(INTERFACE_HASH_STUB_VERSION);</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">            for (int i = 0; i &lt; remoteMethods.length; i++) {</span>
<span class="nc" id="L589">                MemberDefinition m = remoteMethods[i].getMemberDefinition();</span>
<span class="nc" id="L590">                Identifier name = m.getName();</span>
<span class="nc" id="L591">                Type type = m.getType();</span>

<span class="nc" id="L593">                out.writeUTF(name.toString());</span>
                // type signatures already use mangled class names
<span class="nc" id="L595">                out.writeUTF(type.getTypeSignature());</span>

<span class="nc" id="L597">                ClassDeclaration exceptions[] = m.getExceptions(env);</span>
<span class="nc" id="L598">                sortClassDeclarations(exceptions);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">                for (int j = 0; j &lt; exceptions.length; j++) {</span>
<span class="nc" id="L600">                    out.writeUTF(Names.mangleClass(</span>
<span class="nc" id="L601">                                                   exceptions[j].getName()).toString());</span>
                }
            }
<span class="nc" id="L604">            out.flush();</span>

            // use only the first 64 bits of the digest for the hash
<span class="nc" id="L607">            byte hashArray[] = md.digest();</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">            for (int i = 0; i &lt; Math.min(8, hashArray.length); i++) {</span>
<span class="nc" id="L609">                hash += ((long) (hashArray[i] &amp; 0xFF)) &lt;&lt; (i * 8);</span>
            }
<span class="nc" id="L611">        } catch (IOException e) {</span>
<span class="nc" id="L612">            throw new Error(</span>
                            &quot;unexpected exception computing intetrface hash: &quot; + e);
<span class="nc" id="L614">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L615">            throw new Error(</span>
                            &quot;unexpected exception computing intetrface hash: &quot; + e);
<span class="nc" id="L617">        }</span>

<span class="nc" id="L619">        return hash;</span>
    }

    /**
     * Sort array of class declarations alphabetically by their mangled
     * fully-qualified class name.  This is used to feed a method's exceptions
     * in a canonical order into the digest stream for the interface hash
     * computation.
     */
    private void sortClassDeclarations(ClassDeclaration[] decl) {
<span class="nc bnc" id="L629" title="All 2 branches missed.">        for (int i = 1; i &lt; decl.length; i++) {</span>
<span class="nc" id="L630">            ClassDeclaration curr = decl[i];</span>
<span class="nc" id="L631">            String name = Names.mangleClass(curr.getName()).toString();</span>
            int j;
<span class="nc bnc" id="L633" title="All 2 branches missed.">            for (j = i; j &gt; 0; j--) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                if (name.compareTo(</span>
<span class="nc" id="L635">                                   Names.mangleClass(decl[j - 1].getName()).toString()) &gt;= 0)</span>
                    {
<span class="nc" id="L637">                        break;</span>
                    }
<span class="nc" id="L639">                decl[j] = decl[j - 1];</span>
            }
<span class="nc" id="L641">            decl[j] = curr;</span>
        }
<span class="nc" id="L643">    }</span>


    /**
     * A RemoteClass.Method object encapsulates RMI-specific information
     * about a particular remote method in the remote implementation class
     * represented by the outer instance.
     */
    public class Method implements Cloneable {

        /**
         * Return the definition of the actual class member corresponing
         * to this method of a remote interface.
         *
         * REMIND: Can this method be removed?
         */
        public MemberDefinition getMemberDefinition() {
<span class="nc" id="L660">            return memberDef;</span>
        }

        /**
         * Return the name of this method.
         */
        public Identifier getName() {
<span class="nc" id="L667">            return memberDef.getName();</span>
        }

        /**
         * Return the type of this method.
         */
        public Type getType() {
<span class="nc" id="L674">            return memberDef.getType();</span>
        }

        /**
         * Return an array of the exception classes declared to be
         * thrown by this remote method.
         *
         * For methods with the same name and type signature inherited
         * from multiple remote interfaces, the array will contain
         * the set of exceptions declared in all of the interfaces'
         * methods that can be legally thrown in each of them.
         */
        public ClassDeclaration[] getExceptions() {
<span class="nc" id="L687">            return exceptions.clone();</span>
        }

        /**
         * Return the &quot;method hash&quot; used to identify this remote method
         * in the JDK 1.2 version of the stub protocol.
         */
        public long getMethodHash() {
<span class="nc" id="L695">            return methodHash;</span>
        }

        /**
         * Return the string representation of this method.
         */
        public String toString() {
<span class="nc" id="L702">            return memberDef.toString();</span>
        }

        /**
         * Return the string representation of this method appropriate
         * for the construction of a java.rmi.server.Operation object.
         */
        public String getOperationString() {
<span class="nc" id="L710">            return memberDef.toString();</span>
        }

        /**
         * Return a string consisting of this method's name followed by
         * its method descriptor, using the Java VM's notation for
         * method descriptors (see section 4.3.3 of The Java Virtual
         * Machine Specification).
         */
        public String getNameAndDescriptor() {
<span class="nc" id="L720">            return memberDef.getName().toString() +</span>
<span class="nc" id="L721">                memberDef.getType().getTypeSignature();</span>
        }

        /**
         * Member definition for this method, from one of the remote
         * interfaces that this method was found in.
         *
         * Note that this member definition may be only one of several
         * member defintions that correspond to this remote method object,
         * if several of this class's remote interfaces contain methods
         * with the same name and type signature.  Therefore, this member
         * definition may declare more exceptions thrown that this remote
         * method does.
         */
        private MemberDefinition memberDef;

        /** stub &quot;method hash&quot; to identify this method */
        private long methodHash;

        /**
         * Exceptions declared to be thrown by this remote method.
         *
         * This list can include superfluous entries, such as
         * unchecked exceptions and subclasses of other entries.
         */
        private ClassDeclaration[] exceptions;

        /**
         * Create a new Method object corresponding to the given
         * method definition.
         */
        /*
         * Temporarily comment out the private modifier until
         * the VM allows outer class to access inner class's
         * private constructor
         */
<span class="nc" id="L757">        /* private */ Method(MemberDefinition memberDef) {</span>
<span class="nc" id="L758">            this.memberDef = memberDef;</span>
<span class="nc" id="L759">            exceptions = memberDef.getExceptions(env);</span>
<span class="nc" id="L760">            methodHash = computeMethodHash();</span>
<span class="nc" id="L761">        }</span>

        /**
         * Cloning is supported by returning a shallow copy of this object.
         */
        protected Object clone() {
            try {
<span class="nc" id="L768">                return super.clone();</span>
<span class="nc" id="L769">            } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L770">                throw new Error(&quot;clone failed&quot;);</span>
            }
        }

        /**
         * Return a new Method object that is a legal combination of
         * this method object and another one.
         *
         * This requires determining the exceptions declared by the
         * combined method, which must be (only) all of the exceptions
         * declared in both old Methods that may thrown in either of
         * them.
         */
        private Method mergeWith(Method other) {
<span class="nc bnc" id="L784" title="All 2 branches missed.">            if (!getName().equals(other.getName()) ||</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">                !getType().equals(other.getType()))</span>
                {
<span class="nc" id="L787">                    throw new Error(&quot;attempt to merge method \&quot;&quot; +</span>
<span class="nc" id="L788">                                    other.getNameAndDescriptor() + &quot;\&quot; with \&quot;&quot; +</span>
<span class="nc" id="L789">                                    getNameAndDescriptor());</span>
                }

<span class="nc" id="L792">            Vector&lt;ClassDeclaration&gt; legalExceptions</span>
                = new Vector&lt;ClassDeclaration&gt;();
            try {
<span class="nc" id="L795">                collectCompatibleExceptions(</span>
                                            other.exceptions, exceptions, legalExceptions);
<span class="nc" id="L797">                collectCompatibleExceptions(</span>
                                            exceptions, other.exceptions, legalExceptions);
<span class="nc" id="L799">            } catch (ClassNotFound e) {</span>
<span class="nc" id="L800">                env.error(0, &quot;class.not.found&quot;, e.name,</span>
<span class="nc" id="L801">                          getClassDefinition().getName());</span>
<span class="nc" id="L802">                return null;</span>
<span class="nc" id="L803">            }</span>

<span class="nc" id="L805">            Method merged = (Method) clone();</span>
<span class="nc" id="L806">            merged.exceptions = new ClassDeclaration[legalExceptions.size()];</span>
<span class="nc" id="L807">            legalExceptions.copyInto(merged.exceptions);</span>

<span class="nc" id="L809">            return merged;</span>
        }

        /**
         * Add to the supplied list all exceptions in the &quot;from&quot; array
         * that are subclasses of an exception in the &quot;with&quot; array.
         */
        private void collectCompatibleExceptions(ClassDeclaration[] from,
                                                 ClassDeclaration[] with,
                                                 Vector&lt;ClassDeclaration&gt; list)
            throws ClassNotFound
        {
<span class="nc bnc" id="L821" title="All 2 branches missed.">            for (int i = 0; i &lt; from.length; i++) {</span>
<span class="nc" id="L822">                ClassDefinition exceptionDef = from[i].getClassDefinition(env);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">                if (!list.contains(from[i])) {</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">                    for (int j = 0; j &lt; with.length; j++) {</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">                        if (exceptionDef.subClassOf(env, with[j])) {</span>
<span class="nc" id="L826">                            list.addElement(from[i]);</span>
<span class="nc" id="L827">                            break;</span>
                        }
                    }
                }
            }
<span class="nc" id="L832">        }</span>

        /**
         * Compute the &quot;method hash&quot; of this remote method.  The method
         * hash is a long containing the first 64 bits of the SHA digest
         * from the UTF encoded string of the method name and descriptor.
         *
         * REMIND: Should this method share implementation code with
         * the outer class's computeInterfaceHash() method?
         */
        private long computeMethodHash() {
<span class="nc" id="L843">            long hash = 0;</span>
<span class="nc" id="L844">            ByteArrayOutputStream sink = new ByteArrayOutputStream(512);</span>
            try {
<span class="nc" id="L846">                MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);</span>
<span class="nc" id="L847">                DataOutputStream out = new DataOutputStream(</span>
                                                            new DigestOutputStream(sink, md));

<span class="nc" id="L850">                String methodString = getNameAndDescriptor();</span>
                /***** &lt;DEBUG&gt; */
<span class="nc bnc" id="L852" title="All 2 branches missed.">                if (env.verbose()) {</span>
<span class="nc" id="L853">                    System.out.println(&quot;[string used for method hash: \&quot;&quot; +</span>
                                       methodString + &quot;\&quot;]&quot;);
                }
                /***** &lt;/DEBUG&gt; */
<span class="nc" id="L857">                out.writeUTF(methodString);</span>

                // use only the first 64 bits of the digest for the hash
<span class="nc" id="L860">                out.flush();</span>
<span class="nc" id="L861">                byte hashArray[] = md.digest();</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">                for (int i = 0; i &lt; Math.min(8, hashArray.length); i++) {</span>
<span class="nc" id="L863">                    hash += ((long) (hashArray[i] &amp; 0xFF)) &lt;&lt; (i * 8);</span>
                }
<span class="nc" id="L865">            } catch (IOException e) {</span>
<span class="nc" id="L866">                throw new Error(</span>
                                &quot;unexpected exception computing intetrface hash: &quot; + e);
<span class="nc" id="L868">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L869">                throw new Error(</span>
                                &quot;unexpected exception computing intetrface hash: &quot; + e);
<span class="nc" id="L871">            }</span>

<span class="nc" id="L873">            return hash;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>