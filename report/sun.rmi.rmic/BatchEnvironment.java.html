<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BatchEnvironment.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.rmi.rmic</a> &gt; <span class="el_source">BatchEnvironment.java</span></div><h1>BatchEnvironment.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*****************************************************************************/
/*                    Copyright (c) IBM Corporation 1998                     */
/*                                                                           */
/* (C) Copyright IBM Corp. 1998                                              */
/*                                                                           */
/*****************************************************************************/

package sun.rmi.rmic;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.jar.JarFile;
import java.util.jar.Manifest;
import java.util.jar.Attributes;
import sun.tools.java.ClassPath;

/**
 * BatchEnvironment for rmic extends javac's version in four ways:
 * 1. It overrides errorString() to handle looking for rmic-specific
 * error messages in rmic's resource bundle
 * 2. It provides a mechanism for recording intermediate generated
 * files so that they can be deleted later.
 * 3. It holds a reference to the Main instance so that generators
 * can refer to it.
 * 4. It provides access to the ClassPath passed to the constructor.
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */

public class BatchEnvironment extends sun.tools.javac.BatchEnvironment {

    /** instance of Main which created this environment */
    private Main main;

    /**
     * Create a ClassPath object for rmic from a class path string.
     */
    public static ClassPath createClassPath(String classPathString) {
<span class="nc" id="L73">        ClassPath[] paths = classPaths(null, classPathString, null, null);</span>
<span class="nc" id="L74">        return paths[1];</span>
    }

    /**
     * Create a ClassPath object for rmic from the relevant command line
     * options for class path, boot class path, and extension directories.
     */
    public static ClassPath createClassPath(String classPathString,
                                            String sysClassPathString,
                                            String extDirsString)
    {
        /**
         * Previously, this method delegated to the
         * sun.tools.javac.BatchEnvironment.classPaths method in order
         * to supply default values for paths not specified on the
         * command line, expand extensions directories into specific
         * JAR files, and construct the ClassPath object-- but as part
         * of the fix for 6473331, which adds support for Class-Path
         * manifest entries in JAR files, those steps are now handled
         * here directly, with the help of a Path utility class copied
         * from the new javac implementation (see below).
         */
<span class="nc" id="L96">        Path path = new Path();</span>

<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (sysClassPathString == null) {</span>
<span class="nc" id="L99">            sysClassPathString = System.getProperty(&quot;sun.boot.class.path&quot;);</span>
        }
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (sysClassPathString != null) {</span>
<span class="nc" id="L102">            path.addFiles(sysClassPathString);</span>
        }

        /*
         * Class-Path manifest entries are supported for JAR files
         * everywhere except in the boot class path.
         */
<span class="nc" id="L109">        path.expandJarClassPaths(true);</span>

<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (extDirsString == null) {</span>
<span class="nc" id="L112">            extDirsString = System.getProperty(&quot;java.ext.dirs&quot;);</span>
        }
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (extDirsString != null) {</span>
<span class="nc" id="L115">            path.addDirectories(extDirsString);</span>
        }

        /*
         * In the application class path, an empty element means
         * the current working directory.
         */
<span class="nc" id="L122">        path.emptyPathDefault(&quot;.&quot;);</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (classPathString == null) {</span>
            // The env.class.path property is the user's CLASSPATH
            // environment variable, and it set by the wrapper (ie,
            // javac.exe).
<span class="nc" id="L128">            classPathString = System.getProperty(&quot;env.class.path&quot;);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            if (classPathString == null) {</span>
<span class="nc" id="L130">                classPathString = &quot;.&quot;;</span>
            }
        }
<span class="nc" id="L133">        path.addFiles(classPathString);</span>

<span class="nc" id="L135">        return new ClassPath(path.toArray(new String[path.size()]));</span>
    }

    /**
     * Create a BatchEnvironment for rmic with the given class path,
     * stream for messages and Main.
     */
    public BatchEnvironment(OutputStream out, ClassPath path, Main main) {
<span class="nc" id="L143">        super(out, new ClassPath(&quot;&quot;), path);</span>
                                // use empty &quot;sourcePath&quot; (see 4666958)
<span class="nc" id="L145">        this.main = main;</span>
<span class="nc" id="L146">    }</span>

    /**
     * Get the instance of Main which created this environment.
     */
    public Main getMain() {
<span class="nc" id="L152">        return main;</span>
    }

    /**
     * Get the ClassPath.
     */
    public ClassPath getClassPath() {
<span class="nc" id="L159">        return binaryPath;</span>
    }

    /** list of generated source files created in this environment */
<span class="nc" id="L163">    private Vector&lt;File&gt; generatedFiles = new Vector&lt;&gt;();</span>

    /**
     * Remember a generated source file generated so that it
     * can be removed later, if appropriate.
     */
    public void addGeneratedFile(File file) {
<span class="nc" id="L170">        generatedFiles.addElement(file);</span>
<span class="nc" id="L171">    }</span>

    /**
     * Delete all the generated source files made during the execution
     * of this environment (those that have been registered with the
     * &quot;addGeneratedFile&quot; method).
     */
    public void deleteGeneratedFiles() {
<span class="nc" id="L179">        synchronized(generatedFiles) {</span>
<span class="nc" id="L180">            Enumeration&lt;File&gt; enumeration = generatedFiles.elements();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">            while (enumeration.hasMoreElements()) {</span>
<span class="nc" id="L182">                File file = enumeration.nextElement();</span>
<span class="nc" id="L183">                file.delete();</span>
<span class="nc" id="L184">            }</span>
<span class="nc" id="L185">            generatedFiles.removeAllElements();</span>
<span class="nc" id="L186">        }</span>
<span class="nc" id="L187">    }</span>

    /**
     * Release resources, if any.
     */
    public void shutdown() {
<span class="nc" id="L193">        main = null;</span>
<span class="nc" id="L194">        generatedFiles = null;</span>
<span class="nc" id="L195">        super.shutdown();</span>
<span class="nc" id="L196">    }</span>

    /**
     * Return the formatted, localized string for a named error message
     * and supplied arguments.  For rmic error messages, with names that
     * being with &quot;rmic.&quot;, look up the error message in rmic's resource
     * bundle; otherwise, defer to java's superclass method.
     */
    public String errorString(String err,
                              Object arg0, Object arg1, Object arg2)
    {
<span class="nc bnc" id="L207" title="All 4 branches missed.">        if (err.startsWith(&quot;rmic.&quot;) || err.startsWith(&quot;warn.rmic.&quot;)) {</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">            String result =  Main.getText(err,</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                                          (arg0 != null ? arg0.toString() : null),</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                                          (arg1 != null ? arg1.toString() : null),</span>
<span class="nc" id="L211">                                          (arg2 != null ? arg2.toString() : null));</span>

<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (err.startsWith(&quot;warn.&quot;)) {</span>
<span class="nc" id="L214">                result = &quot;warning: &quot; + result;</span>
            }
<span class="nc" id="L216">            return result;</span>
        } else {
<span class="nc" id="L218">            return super.errorString(err, arg0, arg1, arg2);</span>
        }
    }
    public void reset() {
<span class="nc" id="L222">    }</span>

    /**
     * Utility for building paths of directories and JAR files.  This
     * class was copied from com.sun.tools.javac.util.Paths as part of
     * the fix for 6473331, which adds support for Class-Path manifest
     * entries in JAR files.  Diagnostic code is simply commented out
     * because rmic silently ignored these conditions historically.
     */
    private static class Path extends LinkedHashSet&lt;String&gt; {
        private static final long serialVersionUID = 0;
        private static final boolean warn = false;

        private static class PathIterator implements Collection&lt;String&gt; {
<span class="nc" id="L236">            private int pos = 0;</span>
            private final String path;
            private final String emptyPathDefault;

<span class="nc" id="L240">            public PathIterator(String path, String emptyPathDefault) {</span>
<span class="nc" id="L241">                this.path = path;</span>
<span class="nc" id="L242">                this.emptyPathDefault = emptyPathDefault;</span>
<span class="nc" id="L243">            }</span>
<span class="nc" id="L244">            public PathIterator(String path) { this(path, null); }</span>
            public Iterator&lt;String&gt; iterator() {
<span class="nc" id="L246">                return new Iterator&lt;String&gt;() {</span>
                    public boolean hasNext() {
<span class="nc bnc" id="L248" title="All 2 branches missed.">                        return pos &lt;= path.length();</span>
                    }
                    public String next() {
<span class="nc" id="L251">                        int beg = pos;</span>
<span class="nc" id="L252">                        int end = path.indexOf(File.pathSeparator, beg);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">                        if (end == -1)</span>
<span class="nc" id="L254">                            end = path.length();</span>
<span class="nc" id="L255">                        pos = end + 1;</span>

<span class="nc bnc" id="L257" title="All 4 branches missed.">                        if (beg == end &amp;&amp; emptyPathDefault != null)</span>
<span class="nc" id="L258">                            return emptyPathDefault;</span>
                        else
<span class="nc" id="L260">                            return path.substring(beg, end);</span>
                    }
                    public void remove() {
<span class="nc" id="L263">                        throw new UnsupportedOperationException();</span>
                    }
                };
            }

            // required for Collection.
            public int size() {
<span class="nc" id="L270">                throw new UnsupportedOperationException();</span>
            }
            public boolean isEmpty() {
<span class="nc" id="L273">                throw new UnsupportedOperationException();</span>
            }
            public boolean contains(Object o) {
<span class="nc" id="L276">                throw new UnsupportedOperationException();</span>
            }
            public Object[] toArray() {
<span class="nc" id="L279">                throw new UnsupportedOperationException();</span>
            }
            public &lt;T&gt; T[] toArray(T[] a) {
<span class="nc" id="L282">                throw new UnsupportedOperationException();</span>
            }
            public boolean add(String o) {
<span class="nc" id="L285">                throw new UnsupportedOperationException();</span>
            }
            public boolean remove(Object o) {
<span class="nc" id="L288">                throw new UnsupportedOperationException();</span>
            }
            public boolean containsAll(Collection&lt;?&gt; c) {
<span class="nc" id="L291">                throw new UnsupportedOperationException();</span>
            }
            public boolean addAll(Collection&lt;? extends String&gt; c) {
<span class="nc" id="L294">                throw new UnsupportedOperationException();</span>
            }
            public boolean removeAll(Collection&lt;?&gt; c) {
<span class="nc" id="L297">                throw new UnsupportedOperationException();</span>
            }
            public boolean retainAll(Collection&lt;?&gt; c) {
<span class="nc" id="L300">                throw new UnsupportedOperationException();</span>
            }
            public void clear() {
<span class="nc" id="L303">                throw new UnsupportedOperationException();</span>
            }
            public boolean equals(Object o) {
<span class="nc" id="L306">                throw new UnsupportedOperationException();</span>
            }
            public int hashCode() {
<span class="nc" id="L309">                throw new UnsupportedOperationException();</span>
            }
        }

        /** Is this the name of a zip file? */
        private static boolean isZip(String name) {
<span class="nc" id="L315">            return new File(name).isFile();</span>
        }

<span class="nc" id="L318">        private boolean expandJarClassPaths = false;</span>

        public Path expandJarClassPaths(boolean x) {
<span class="nc" id="L321">            expandJarClassPaths = x;</span>
<span class="nc" id="L322">            return this;</span>
        }

        /** What to use when path element is the empty string */
<span class="nc" id="L326">        private String emptyPathDefault = null;</span>

        public Path emptyPathDefault(String x) {
<span class="nc" id="L329">            emptyPathDefault = x;</span>
<span class="nc" id="L330">            return this;</span>
        }

<span class="nc" id="L333">        public Path() { super(); }</span>

        public Path addDirectories(String dirs, boolean warn) {
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (dirs != null)</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                for (String dir : new PathIterator(dirs))</span>
<span class="nc" id="L338">                    addDirectory(dir, warn);</span>
<span class="nc" id="L339">            return this;</span>
        }

        public Path addDirectories(String dirs) {
<span class="nc" id="L343">            return addDirectories(dirs, warn);</span>
        }

        private void addDirectory(String dir, boolean warn) {
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (! new File(dir).isDirectory()) {</span>
//              if (warn)
//                  log.warning(Position.NOPOS,
//                              &quot;dir.path.element.not.found&quot;, dir);
<span class="nc" id="L351">                return;</span>
            }

<span class="nc bnc" id="L354" title="All 2 branches missed.">            for (String direntry : new File(dir).list()) {</span>
<span class="nc" id="L355">                String canonicalized = direntry.toLowerCase();</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">                if (canonicalized.endsWith(&quot;.jar&quot;) ||</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">                    canonicalized.endsWith(&quot;.zip&quot;))</span>
<span class="nc" id="L358">                    addFile(dir + File.separator + direntry, warn);</span>
            }
<span class="nc" id="L360">        }</span>

        public Path addFiles(String files, boolean warn) {
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if (files != null)</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                for (String file : new PathIterator(files, emptyPathDefault))</span>
<span class="nc" id="L365">                    addFile(file, warn);</span>
<span class="nc" id="L366">            return this;</span>
        }

        public Path addFiles(String files) {
<span class="nc" id="L370">            return addFiles(files, warn);</span>
        }

        private void addFile(String file, boolean warn) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">            if (contains(file)) {</span>
                /* Discard duplicates and avoid infinite recursion */
<span class="nc" id="L376">                return;</span>
            }

<span class="nc" id="L379">            File ele = new File(file);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            if (! ele.exists()) {</span>
                /* No such file or directory exist */
<span class="nc bnc" id="L382" title="All 2 branches missed.">                if (warn)</span>
//                      log.warning(Position.NOPOS,
//                          &quot;path.element.not.found&quot;, file);
<span class="nc" id="L385">                    return;</span>
            }

<span class="nc bnc" id="L388" title="All 2 branches missed.">            if (ele.isFile()) {</span>
                /* File is an ordinay file  */
<span class="nc" id="L390">                String arcname = file.toLowerCase();</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">                if (! (arcname.endsWith(&quot;.zip&quot;) ||</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                       arcname.endsWith(&quot;.jar&quot;))) {</span>
                    /* File name don't have right extension */
//                      if (warn)
//                          log.warning(Position.NOPOS,
//                              &quot;invalid.archive.file&quot;, file);
<span class="nc" id="L397">                    return;</span>
                }
            }

            /* Now what we have left is either a directory or a file name
               confirming to archive naming convention */

<span class="nc" id="L404">            super.add(file);</span>
<span class="nc bnc" id="L405" title="All 4 branches missed.">            if (expandJarClassPaths &amp;&amp; isZip(file))</span>
<span class="nc" id="L406">                addJarClassPath(file, warn);</span>
<span class="nc" id="L407">        }</span>

        // Adds referenced classpath elements from a jar's Class-Path
        // Manifest entry.  In some future release, we may want to
        // update this code to recognize URLs rather than simple
        // filenames, but if we do, we should redo all path-related code.
        private void addJarClassPath(String jarFileName, boolean warn) {
            try {
<span class="nc" id="L415">                String jarParent = new File(jarFileName).getParent();</span>
<span class="nc" id="L416">                JarFile jar = new JarFile(jarFileName);</span>

                try {
<span class="nc" id="L419">                    Manifest man = jar.getManifest();</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                    if (man == null) return;</span>

<span class="nc" id="L422">                    Attributes attr = man.getMainAttributes();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                    if (attr == null) return;</span>

<span class="nc" id="L425">                    String path = attr.getValue(Attributes.Name.CLASS_PATH);</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">                    if (path == null) return;</span>

<span class="nc" id="L428">                    for (StringTokenizer st = new StringTokenizer(path);</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                        st.hasMoreTokens();) {</span>
<span class="nc" id="L430">                        String elt = st.nextToken();</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">                        if (jarParent != null)</span>
<span class="nc" id="L432">                            elt = new File(jarParent, elt).getCanonicalPath();</span>
<span class="nc" id="L433">                        addFile(elt, warn);</span>
<span class="nc" id="L434">                    }</span>
                } finally {
<span class="nc" id="L436">                    jar.close();</span>
<span class="nc" id="L437">                }</span>
<span class="nc" id="L438">            } catch (IOException e) {</span>
//              log.error(Position.NOPOS,
//                        &quot;error.reading.file&quot;, jarFileName,
//                        e.getLocalizedMessage());
<span class="nc" id="L442">            }</span>
<span class="nc" id="L443">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>