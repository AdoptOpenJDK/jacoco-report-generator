<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MBeanIntrospector.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jmx.mbeanserver</a> &gt; <span class="el_source">MBeanIntrospector.java</span></div><h1>MBeanIntrospector.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jmx.mbeanserver;


import static com.sun.jmx.mbeanserver.Util.*;

import java.lang.ref.WeakReference;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.Arrays;
import java.util.List;
import java.util.WeakHashMap;

import javax.management.Descriptor;
import javax.management.ImmutableDescriptor;
import javax.management.IntrospectionException;
import javax.management.InvalidAttributeValueException;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanConstructorInfo;
import javax.management.MBeanException;
import javax.management.MBeanInfo;
import javax.management.MBeanNotificationInfo;
import javax.management.MBeanOperationInfo;
import javax.management.NotCompliantMBeanException;
import javax.management.NotificationBroadcaster;
import javax.management.ReflectionException;
import sun.reflect.misc.ReflectUtil;

/**
 * An introspector for MBeans of a certain type.  There is one instance
 * of this class for Standard MBeans, and one for every MXBeanMappingFactory;
 * these two cases correspond to the two concrete subclasses of this abstract
 * class.
 *
 * @param &lt;M&gt; the representation of methods for this kind of MBean:
 * Method for Standard MBeans, ConvertingMethod for MXBeans.
 *
 * @since 1.6
 */
/*
 * Using a type parameter &lt;M&gt; allows us to deal with the fact that
 * Method and ConvertingMethod have no useful common ancestor, on
 * which we could call getName, getGenericReturnType, etc.  A simpler approach
 * would be to wrap every Method in an object that does have a common
 * ancestor with ConvertingMethod.  But that would mean an extra object
 * for every Method in every Standard MBean interface.
 */
<span class="nc" id="L75">abstract class MBeanIntrospector&lt;M&gt; {</span>
<span class="nc" id="L76">    static final class PerInterfaceMap&lt;M&gt;</span>
            extends WeakHashMap&lt;Class&lt;?&gt;, WeakReference&lt;PerInterface&lt;M&gt;&gt;&gt; {}

    /** The map from interface to PerInterface for this type of MBean. */
    abstract PerInterfaceMap&lt;M&gt; getPerInterfaceMap();
    /**
     * The map from concrete implementation class and interface to
     * MBeanInfo for this type of MBean.
     */
    abstract MBeanInfoMap getMBeanInfoMap();

    /** Make an interface analyzer for this type of MBean. */
    abstract MBeanAnalyzer&lt;M&gt; getAnalyzer(Class&lt;?&gt; mbeanInterface)
    throws NotCompliantMBeanException;

    /** True if MBeans with this kind of introspector are MXBeans. */
    abstract boolean isMXBean();

    /** Find the M corresponding to the given Method. */
    abstract M mFrom(Method m);

    /** Get the name of this method. */
    abstract String getName(M m);

    /**
     * Get the return type of this method.  This is the return type
     * of a method in a Java interface, so for MXBeans it is the
     * declared Java type, not the mapped Open Type.
     */
    abstract Type getGenericReturnType(M m);

    /**
     * Get the parameter types of this method in the Java interface
     * it came from.
     */
    abstract Type[] getGenericParameterTypes(M m);

    /**
     * Get the signature of this method as a caller would have to supply
     * it in MBeanServer.invoke.  For MXBeans, the named types will be
     * the mapped Open Types for the parameters.
     */
    abstract String[] getSignature(M m);

    /**
     * Check that this method is valid.  For example, a method in an
     * MXBean interface is not valid if one of its parameters cannot be
     * mapped to an Open Type.
     */
    abstract void checkMethod(M m);

    /**
     * Invoke the method with the given target and arguments.
     *
     * @param cookie Additional information about the target.  For an
     * MXBean, this is the MXBeanLookup associated with the MXBean.
     */
    /*
     * It would be cleaner if the type of the cookie were a
     * type parameter to this class, but that would involve a lot of
     * messy type parameter propagation just to avoid a couple of casts.
     */
    abstract Object invokeM2(M m, Object target, Object[] args, Object cookie)
    throws InvocationTargetException, IllegalAccessException,
            MBeanException;

    /**
     * Test whether the given value is valid for the given parameter of this
     * M.
     */
    abstract boolean validParameter(M m, Object value, int paramNo,
            Object cookie);

    /**
     * Construct an MBeanAttributeInfo for the given attribute based on the
     * given getter and setter.  One but not both of the getter and setter
     * may be null.
     */
    abstract MBeanAttributeInfo getMBeanAttributeInfo(String attributeName,
            M getter, M setter);
    /**
     * Construct an MBeanOperationInfo for the given operation based on
     * the M it was derived from.
     */
    abstract MBeanOperationInfo getMBeanOperationInfo(String operationName,
            M operation);

    /**
     * Get a Descriptor containing fields that MBeans of this kind will
     * always have.  For example, MXBeans will always have &quot;mxbean=true&quot;.
     */
    abstract Descriptor getBasicMBeanDescriptor();

    /**
     * Get a Descriptor containing additional fields beyond the ones
     * from getBasicMBeanDescriptor that MBeans whose concrete class
     * is resourceClass will always have.
     */
    abstract Descriptor getMBeanDescriptor(Class&lt;?&gt; resourceClass);

    /**
     * Get the methods to be analyzed to build the MBean interface.
     */
    final List&lt;Method&gt; getMethods(final Class&lt;?&gt; mbeanType) {
<span class="nc" id="L180">        ReflectUtil.checkPackageAccess(mbeanType);</span>
<span class="nc" id="L181">        return Arrays.asList(mbeanType.getMethods());</span>
    }

    final PerInterface&lt;M&gt; getPerInterface(Class&lt;?&gt; mbeanInterface)
    throws NotCompliantMBeanException {
<span class="nc" id="L186">        PerInterfaceMap&lt;M&gt; map = getPerInterfaceMap();</span>
<span class="nc" id="L187">        synchronized (map) {</span>
<span class="nc" id="L188">            WeakReference&lt;PerInterface&lt;M&gt;&gt; wr = map.get(mbeanInterface);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            PerInterface&lt;M&gt; pi = (wr == null) ? null : wr.get();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">            if (pi == null) {</span>
                try {
<span class="nc" id="L192">                    MBeanAnalyzer&lt;M&gt; analyzer = getAnalyzer(mbeanInterface);</span>
<span class="nc" id="L193">                    MBeanInfo mbeanInfo =</span>
<span class="nc" id="L194">                            makeInterfaceMBeanInfo(mbeanInterface, analyzer);</span>
<span class="nc" id="L195">                    pi = new PerInterface&lt;M&gt;(mbeanInterface, this, analyzer,</span>
                            mbeanInfo);
<span class="nc" id="L197">                    wr = new WeakReference&lt;PerInterface&lt;M&gt;&gt;(pi);</span>
<span class="nc" id="L198">                    map.put(mbeanInterface, wr);</span>
<span class="nc" id="L199">                } catch (Exception x) {</span>
<span class="nc" id="L200">                    throw Introspector.throwException(mbeanInterface,x);</span>
<span class="nc" id="L201">                }</span>
            }
<span class="nc" id="L203">            return pi;</span>
<span class="nc" id="L204">        }</span>
    }

    /**
     * Make the MBeanInfo skeleton for the given MBean interface using
     * the given analyzer.  This will never be the MBeanInfo of any real
     * MBean (because the getClassName() must be a concrete class), but
     * its MBeanAttributeInfo[] and MBeanOperationInfo[] can be inserted
     * into such an MBeanInfo, and its Descriptor can be the basis for
     * the MBeanInfo's Descriptor.
     */
    private MBeanInfo makeInterfaceMBeanInfo(Class&lt;?&gt; mbeanInterface,
            MBeanAnalyzer&lt;M&gt; analyzer) {
<span class="nc" id="L217">        final MBeanInfoMaker maker = new MBeanInfoMaker();</span>
<span class="nc" id="L218">        analyzer.visit(maker);</span>
        final String description =
                &quot;Information on the management interface of the MBean&quot;;
<span class="nc" id="L221">        return maker.makeMBeanInfo(mbeanInterface, description);</span>
    }

    /** True if the given getter and setter are consistent. */
    final boolean consistent(M getter, M setter) {
<span class="nc bnc" id="L226" title="All 4 branches missed.">        return (getter == null || setter == null ||</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                getGenericReturnType(getter).equals(getGenericParameterTypes(setter)[0]));</span>
    }

    /**
     * Invoke the given M on the given target with the given args and cookie.
     * Wrap exceptions appropriately.
     */
    final Object invokeM(M m, Object target, Object[] args, Object cookie)
    throws MBeanException, ReflectionException {
        try {
<span class="nc" id="L237">            return invokeM2(m, target, args, cookie);</span>
<span class="nc" id="L238">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L239">            unwrapInvocationTargetException(e);</span>
<span class="nc" id="L240">            throw new RuntimeException(e); // not reached</span>
<span class="nc" id="L241">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L242">            throw new ReflectionException(e, e.toString());</span>
        }
        /* We do not catch and wrap RuntimeException or Error,
         * because we're in a DynamicMBean, so the logic for DynamicMBeans
         * will do the wrapping.
         */
    }

    /**
     * Invoke the given setter on the given target with the given argument
     * and cookie.  Wrap exceptions appropriately.
     */
    /* If the value is of the wrong type for the method we are about to
     * invoke, we are supposed to throw an InvalidAttributeValueException.
     * Rather than making the check always, we invoke the method, then
     * if it throws an exception we check the type to see if that was
     * what caused the exception.  The assumption is that an exception
     * from an invalid type will arise before any user method is ever
     * called (either in reflection or in OpenConverter).
     */
    final void invokeSetter(String name, M setter, Object target, Object arg,
            Object cookie)
            throws MBeanException, ReflectionException,
            InvalidAttributeValueException {
        try {
<span class="nc" id="L267">            invokeM2(setter, target, new Object[] {arg}, cookie);</span>
<span class="nc" id="L268">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L269">            throw new ReflectionException(e, e.toString());</span>
<span class="nc" id="L270">        } catch (RuntimeException e) {</span>
<span class="nc" id="L271">            maybeInvalidParameter(name, setter, arg, cookie);</span>
<span class="nc" id="L272">            throw e;</span>
<span class="nc" id="L273">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L274">            maybeInvalidParameter(name, setter, arg, cookie);</span>
<span class="nc" id="L275">            unwrapInvocationTargetException(e);</span>
<span class="nc" id="L276">        }</span>
<span class="nc" id="L277">    }</span>

    private void maybeInvalidParameter(String name, M setter, Object arg,
            Object cookie)
            throws InvalidAttributeValueException {
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (!validParameter(setter, arg, 0, cookie)) {</span>
<span class="nc" id="L283">            final String msg =</span>
                    &quot;Invalid value for attribute &quot; + name + &quot;: &quot; + arg;
<span class="nc" id="L285">            throw new InvalidAttributeValueException(msg);</span>
        }
<span class="nc" id="L287">    }</span>

    static boolean isValidParameter(Method m, Object value, int paramNo) {
<span class="nc" id="L290">        Class&lt;?&gt; c = m.getParameterTypes()[paramNo];</span>
        try {
            // Following is expensive but we only call this method to determine
            // if an exception is due to an incompatible parameter type.
            // Plain old c.isInstance doesn't work for primitive types.
<span class="nc" id="L295">            Object a = Array.newInstance(c, 1);</span>
<span class="nc" id="L296">            Array.set(a, 0, value);</span>
<span class="nc" id="L297">            return true;</span>
<span class="nc" id="L298">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L299">            return false;</span>
        }
    }

    private static void
            unwrapInvocationTargetException(InvocationTargetException e)
            throws MBeanException {
<span class="nc" id="L306">        Throwable t = e.getCause();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (t instanceof RuntimeException)</span>
<span class="nc" id="L308">            throw (RuntimeException) t;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">        else if (t instanceof Error)</span>
<span class="nc" id="L310">            throw (Error) t;</span>
        else
<span class="nc bnc" id="L312" title="All 2 branches missed.">            throw new MBeanException((Exception) t,</span>
<span class="nc" id="L313">                    (t == null ? null : t.toString()));</span>
    }

    /** A visitor that constructs the per-interface MBeanInfo. */
<span class="nc" id="L317">    private class MBeanInfoMaker</span>
            implements MBeanAnalyzer.MBeanVisitor&lt;M&gt; {

        public void visitAttribute(String attributeName,
                M getter,
                M setter) {
<span class="nc" id="L323">            MBeanAttributeInfo mbai =</span>
<span class="nc" id="L324">                    getMBeanAttributeInfo(attributeName, getter, setter);</span>

<span class="nc" id="L326">            attrs.add(mbai);</span>
<span class="nc" id="L327">        }</span>

        public void visitOperation(String operationName,
                M operation) {
<span class="nc" id="L331">            MBeanOperationInfo mboi =</span>
<span class="nc" id="L332">                    getMBeanOperationInfo(operationName, operation);</span>

<span class="nc" id="L334">            ops.add(mboi);</span>
<span class="nc" id="L335">        }</span>

        /** Make an MBeanInfo based on the attributes and operations
         *  found in the interface. */
        MBeanInfo makeMBeanInfo(Class&lt;?&gt; mbeanInterface,
                String description) {
<span class="nc" id="L341">            final MBeanAttributeInfo[] attrArray =</span>
<span class="nc" id="L342">                    attrs.toArray(new MBeanAttributeInfo[0]);</span>
<span class="nc" id="L343">            final MBeanOperationInfo[] opArray =</span>
<span class="nc" id="L344">                    ops.toArray(new MBeanOperationInfo[0]);</span>
<span class="nc" id="L345">            final String interfaceClassName =</span>
<span class="nc" id="L346">                    &quot;interfaceClassName=&quot; + mbeanInterface.getName();</span>
<span class="nc" id="L347">            final Descriptor classNameDescriptor =</span>
                    new ImmutableDescriptor(interfaceClassName);
<span class="nc" id="L349">            final Descriptor mbeanDescriptor = getBasicMBeanDescriptor();</span>
<span class="nc" id="L350">            final Descriptor annotatedDescriptor =</span>
<span class="nc" id="L351">                    Introspector.descriptorForElement(mbeanInterface);</span>
            final Descriptor descriptor =
<span class="nc" id="L353">                DescriptorCache.getInstance().union(</span>
                    classNameDescriptor,
                    mbeanDescriptor,
                    annotatedDescriptor);

<span class="nc" id="L358">            return new MBeanInfo(mbeanInterface.getName(),</span>
                    description,
                    attrArray,
                    null,
                    opArray,
                    null,
                    descriptor);
        }

<span class="nc" id="L367">        private final List&lt;MBeanAttributeInfo&gt; attrs = newList();</span>
<span class="nc" id="L368">        private final List&lt;MBeanOperationInfo&gt; ops = newList();</span>
    }

    /*
     * Looking up the MBeanInfo for a given base class (implementation class)
     * is complicated by the fact that we may use the same base class with
     * several different explicit MBean interfaces via the
     * javax.management.StandardMBean class.  It is further complicated
     * by the fact that we have to be careful not to retain a strong reference
     * to any Class object for fear we would prevent a ClassLoader from being
     * garbage-collected.  So we have a first lookup from the base class
     * to a map for each interface that base class might specify giving
     * the MBeanInfo constructed for that base class and interface.
     */
<span class="nc" id="L382">    static class MBeanInfoMap</span>
            extends WeakHashMap&lt;Class&lt;?&gt;, WeakHashMap&lt;Class&lt;?&gt;, MBeanInfo&gt;&gt; {
    }

    /**
     * Return the MBeanInfo for the given resource, based on the given
     * per-interface data.
     */
    final MBeanInfo getMBeanInfo(Object resource, PerInterface&lt;M&gt; perInterface) {
<span class="nc" id="L391">        MBeanInfo mbi =</span>
<span class="nc" id="L392">                getClassMBeanInfo(resource.getClass(), perInterface);</span>
<span class="nc" id="L393">        MBeanNotificationInfo[] notifs = findNotifications(resource);</span>
<span class="nc bnc" id="L394" title="All 4 branches missed.">        if (notifs == null || notifs.length == 0)</span>
<span class="nc" id="L395">            return mbi;</span>
        else {
<span class="nc" id="L397">            return new MBeanInfo(mbi.getClassName(),</span>
<span class="nc" id="L398">                    mbi.getDescription(),</span>
<span class="nc" id="L399">                    mbi.getAttributes(),</span>
<span class="nc" id="L400">                    mbi.getConstructors(),</span>
<span class="nc" id="L401">                    mbi.getOperations(),</span>
                    notifs,
<span class="nc" id="L403">                    mbi.getDescriptor());</span>
        }
    }

    /**
     * Return the basic MBeanInfo for resources of the given class and
     * per-interface data.  This MBeanInfo might not be the final MBeanInfo
     * for instances of the class, because if the class is a
     * NotificationBroadcaster then each instance gets to decide what
     * MBeanNotificationInfo[] to put in its own MBeanInfo.
     */
    final MBeanInfo getClassMBeanInfo(Class&lt;?&gt; resourceClass,
            PerInterface&lt;M&gt; perInterface) {
<span class="nc" id="L416">        MBeanInfoMap map = getMBeanInfoMap();</span>
<span class="nc" id="L417">        synchronized (map) {</span>
<span class="nc" id="L418">            WeakHashMap&lt;Class&lt;?&gt;, MBeanInfo&gt; intfMap = map.get(resourceClass);</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (intfMap == null) {</span>
<span class="nc" id="L420">                intfMap = new WeakHashMap&lt;Class&lt;?&gt;, MBeanInfo&gt;();</span>
<span class="nc" id="L421">                map.put(resourceClass, intfMap);</span>
            }
<span class="nc" id="L423">            Class&lt;?&gt; intfClass = perInterface.getMBeanInterface();</span>
<span class="nc" id="L424">            MBeanInfo mbi = intfMap.get(intfClass);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (mbi == null) {</span>
<span class="nc" id="L426">                MBeanInfo imbi = perInterface.getMBeanInfo();</span>
<span class="nc" id="L427">                Descriptor descriptor =</span>
<span class="nc" id="L428">                        ImmutableDescriptor.union(imbi.getDescriptor(),</span>
<span class="nc" id="L429">                        getMBeanDescriptor(resourceClass));</span>
<span class="nc" id="L430">                mbi = new MBeanInfo(resourceClass.getName(),</span>
<span class="nc" id="L431">                        imbi.getDescription(),</span>
<span class="nc" id="L432">                        imbi.getAttributes(),</span>
<span class="nc" id="L433">                        findConstructors(resourceClass),</span>
<span class="nc" id="L434">                        imbi.getOperations(),</span>
                        (MBeanNotificationInfo[]) null,
                        descriptor);
<span class="nc" id="L437">                intfMap.put(intfClass, mbi);</span>
            }
<span class="nc" id="L439">            return mbi;</span>
<span class="nc" id="L440">        }</span>
    }

    static MBeanNotificationInfo[] findNotifications(Object moi) {
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (!(moi instanceof NotificationBroadcaster))</span>
<span class="nc" id="L445">            return null;</span>
<span class="nc" id="L446">        MBeanNotificationInfo[] mbn =</span>
<span class="nc" id="L447">                ((NotificationBroadcaster) moi).getNotificationInfo();</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (mbn == null)</span>
<span class="nc" id="L449">            return null;</span>
<span class="nc" id="L450">        MBeanNotificationInfo[] result =</span>
                new MBeanNotificationInfo[mbn.length];
<span class="nc bnc" id="L452" title="All 2 branches missed.">        for (int i = 0; i &lt; mbn.length; i++) {</span>
<span class="nc" id="L453">            MBeanNotificationInfo ni = mbn[i];</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">            if (ni.getClass() != MBeanNotificationInfo.class)</span>
<span class="nc" id="L455">                ni = (MBeanNotificationInfo) ni.clone();</span>
<span class="nc" id="L456">            result[i] = ni;</span>
        }
<span class="nc" id="L458">        return result;</span>
    }

    private static MBeanConstructorInfo[] findConstructors(Class&lt;?&gt; c) {
<span class="nc" id="L462">        Constructor&lt;?&gt;[] cons = c.getConstructors();</span>
<span class="nc" id="L463">        MBeanConstructorInfo[] mbc = new MBeanConstructorInfo[cons.length];</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        for (int i = 0; i &lt; cons.length; i++) {</span>
            final String descr = &quot;Public constructor of the MBean&quot;;
<span class="nc" id="L466">            mbc[i] = new MBeanConstructorInfo(descr, cons[i]);</span>
        }
<span class="nc" id="L468">        return mbc;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>