<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MBeanAnalyzer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jmx.mbeanserver</a> &gt; <span class="el_source">MBeanAnalyzer.java</span></div><h1>MBeanAnalyzer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jmx.mbeanserver;

import static com.sun.jmx.mbeanserver.Util.*;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.management.NotCompliantMBeanException;

/**
 * &lt;p&gt;An analyzer for a given MBean interface.  The analyzer can
 * be for Standard MBeans or MXBeans, depending on the MBeanIntrospector
 * passed at construction.
 *
 * &lt;p&gt;The analyzer can
 * visit the attributes and operations of the interface, calling
 * a caller-supplied visitor method for each one.&lt;/p&gt;
 *
 * @param &lt;M&gt; Method or ConvertingMethod according as this is a
 * Standard MBean or an MXBean.
 *
 * @since 1.6
 */
class MBeanAnalyzer&lt;M&gt; {
    static interface MBeanVisitor&lt;M&gt; {
        public void visitAttribute(String attributeName,
                M getter,
                M setter);
        public void visitOperation(String operationName,
                M operation);
    }

    void visit(MBeanVisitor&lt;M&gt; visitor) {
        // visit attributes
<span class="nc bnc" id="L65" title="All 2 branches missed.">        for (Map.Entry&lt;String, AttrMethods&lt;M&gt;&gt; entry : attrMap.entrySet()) {</span>
<span class="nc" id="L66">            String name = entry.getKey();</span>
<span class="nc" id="L67">            AttrMethods&lt;M&gt; am = entry.getValue();</span>
<span class="nc" id="L68">            visitor.visitAttribute(name, am.getter, am.setter);</span>
<span class="nc" id="L69">        }</span>

        // visit operations
<span class="nc bnc" id="L72" title="All 2 branches missed.">        for (Map.Entry&lt;String, List&lt;M&gt;&gt; entry : opMap.entrySet()) {</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">            for (M m : entry.getValue())</span>
<span class="nc" id="L74">                visitor.visitOperation(entry.getKey(), m);</span>
<span class="nc" id="L75">        }</span>
<span class="nc" id="L76">    }</span>

    /* Map op name to method */
<span class="nc" id="L79">    private Map&lt;String, List&lt;M&gt;&gt; opMap = newInsertionOrderMap();</span>
    /* Map attr name to getter and/or setter */
<span class="nc" id="L81">    private Map&lt;String, AttrMethods&lt;M&gt;&gt; attrMap = newInsertionOrderMap();</span>

<span class="nc" id="L83">    private static class AttrMethods&lt;M&gt; {</span>
        M getter;
        M setter;
    }

    /**
     * &lt;p&gt;Return an MBeanAnalyzer for the given MBean interface and
     * MBeanIntrospector.  Calling this method twice with the same
     * parameters may return the same object or two different but
     * equivalent objects.
     */
    // Currently it's two different but equivalent objects.  This only
    // really impacts proxy generation.  For MBean creation, the
    // cached PerInterface object for an MBean interface means that
    // an analyzer will not be recreated for a second MBean using the
    // same interface.
    static &lt;M&gt; MBeanAnalyzer&lt;M&gt; analyzer(Class&lt;?&gt; mbeanType,
            MBeanIntrospector&lt;M&gt; introspector)
            throws NotCompliantMBeanException {
<span class="nc" id="L102">        return new MBeanAnalyzer&lt;M&gt;(mbeanType, introspector);</span>
    }

    private MBeanAnalyzer(Class&lt;?&gt; mbeanType,
            MBeanIntrospector&lt;M&gt; introspector)
<span class="nc" id="L107">            throws NotCompliantMBeanException {</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (!mbeanType.isInterface()) {</span>
<span class="nc" id="L109">            throw new NotCompliantMBeanException(&quot;Not an interface: &quot; +</span>
<span class="nc" id="L110">                    mbeanType.getName());</span>
<span class="nc bnc" id="L111" title="All 4 branches missed.">        } else if (!Modifier.isPublic(mbeanType.getModifiers()) &amp;&amp;</span>
                   !Introspector.ALLOW_NONPUBLIC_MBEAN) {
<span class="nc" id="L113">            throw new NotCompliantMBeanException(&quot;Interface is not public: &quot; +</span>
<span class="nc" id="L114">                mbeanType.getName());</span>
        }

        try {
<span class="nc" id="L118">            initMaps(mbeanType, introspector);</span>
<span class="nc" id="L119">        } catch (Exception x) {</span>
<span class="nc" id="L120">            throw Introspector.throwException(mbeanType,x);</span>
<span class="nc" id="L121">        }</span>
<span class="nc" id="L122">    }</span>

    // Introspect the mbeanInterface and initialize this object's maps.
    //
    private void initMaps(Class&lt;?&gt; mbeanType,
            MBeanIntrospector&lt;M&gt; introspector) throws Exception {
<span class="nc" id="L128">        final List&lt;Method&gt; methods1 = introspector.getMethods(mbeanType);</span>
<span class="nc" id="L129">        final List&lt;Method&gt; methods = eliminateCovariantMethods(methods1);</span>

        /* Run through the methods to detect inconsistencies and to enable
           us to give getter and setter together to visitAttribute. */
<span class="nc bnc" id="L133" title="All 2 branches missed.">        for (Method m : methods) {</span>
<span class="nc" id="L134">            final String name = m.getName();</span>
<span class="nc" id="L135">            final int nParams = m.getParameterTypes().length;</span>

<span class="nc" id="L137">            final M cm = introspector.mFrom(m);</span>

<span class="nc" id="L139">            String attrName = &quot;&quot;;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (name.startsWith(&quot;get&quot;))</span>
<span class="nc" id="L141">                attrName = name.substring(3);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">            else if (name.startsWith(&quot;is&quot;)</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">            &amp;&amp; m.getReturnType() == boolean.class)</span>
<span class="nc" id="L144">                attrName = name.substring(2);</span>

<span class="nc bnc" id="L146" title="All 4 branches missed.">            if (attrName.length() != 0 &amp;&amp; nParams == 0</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">                    &amp;&amp; m.getReturnType() != void.class) {</span>
                // It's a getter
                // Check we don't have both isX and getX
<span class="nc" id="L150">                AttrMethods&lt;M&gt; am = attrMap.get(attrName);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">                if (am == null)</span>
<span class="nc" id="L152">                    am = new AttrMethods&lt;M&gt;();</span>
                else {
<span class="nc bnc" id="L154" title="All 2 branches missed.">                    if (am.getter != null) {</span>
<span class="nc" id="L155">                        final String msg = &quot;Attribute &quot; + attrName +</span>
                                &quot; has more than one getter&quot;;
<span class="nc" id="L157">                        throw new NotCompliantMBeanException(msg);</span>
                    }
                }
<span class="nc" id="L160">                am.getter = cm;</span>
<span class="nc" id="L161">                attrMap.put(attrName, am);</span>
<span class="nc bnc" id="L162" title="All 6 branches missed.">            } else if (name.startsWith(&quot;set&quot;) &amp;&amp; name.length() &gt; 3</span>
                    &amp;&amp; nParams == 1 &amp;&amp;
<span class="nc bnc" id="L164" title="All 2 branches missed.">                    m.getReturnType() == void.class) {</span>
                // It's a setter
<span class="nc" id="L166">                attrName = name.substring(3);</span>
<span class="nc" id="L167">                AttrMethods&lt;M&gt; am = attrMap.get(attrName);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                if (am == null)</span>
<span class="nc" id="L169">                    am = new AttrMethods&lt;M&gt;();</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                else if (am.setter != null) {</span>
<span class="nc" id="L171">                    final String msg = &quot;Attribute &quot; + attrName +</span>
                            &quot; has more than one setter&quot;;
<span class="nc" id="L173">                    throw new NotCompliantMBeanException(msg);</span>
                }
<span class="nc" id="L175">                am.setter = cm;</span>
<span class="nc" id="L176">                attrMap.put(attrName, am);</span>
<span class="nc" id="L177">            } else {</span>
                // It's an operation
<span class="nc" id="L179">                List&lt;M&gt; cms = opMap.get(name);</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                if (cms == null)</span>
<span class="nc" id="L181">                    cms = newList();</span>
<span class="nc" id="L182">                cms.add(cm);</span>
<span class="nc" id="L183">                opMap.put(name, cms);</span>
            }
<span class="nc" id="L185">        }</span>
        /* Check that getters and setters are consistent. */
<span class="nc bnc" id="L187" title="All 2 branches missed.">        for (Map.Entry&lt;String, AttrMethods&lt;M&gt;&gt; entry : attrMap.entrySet()) {</span>
<span class="nc" id="L188">            AttrMethods&lt;M&gt; am = entry.getValue();</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (!introspector.consistent(am.getter, am.setter)) {</span>
<span class="nc" id="L190">                final String msg = &quot;Getter and setter for &quot; + entry.getKey() +</span>
                        &quot; have inconsistent types&quot;;
<span class="nc" id="L192">                throw new NotCompliantMBeanException(msg);</span>
            }
<span class="nc" id="L194">        }</span>
<span class="nc" id="L195">    }</span>

    /**
     * A comparator that defines a total order so that methods have the
     * same name and identical signatures appear next to each others.
     * The methods are sorted in such a way that methods which
     * override each other will sit next to each other, with the
     * overridden method first - e.g. Object getFoo() is placed before
     * Integer getFoo(). This makes it possible to determine whether
     * a method overrides another one simply by looking at the method(s)
     * that precedes it in the list. (see eliminateCovariantMethods).
     **/
<span class="nc" id="L207">    private static class MethodOrder implements Comparator&lt;Method&gt; {</span>
        public int compare(Method a, Method b) {
<span class="nc" id="L209">            final int cmp = a.getName().compareTo(b.getName());</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (cmp != 0) return cmp;</span>
<span class="nc" id="L211">            final Class&lt;?&gt;[] aparams = a.getParameterTypes();</span>
<span class="nc" id="L212">            final Class&lt;?&gt;[] bparams = b.getParameterTypes();</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (aparams.length != bparams.length)</span>
<span class="nc" id="L214">                return aparams.length - bparams.length;</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">            if (!Arrays.equals(aparams, bparams)) {</span>
<span class="nc" id="L216">                return Arrays.toString(aparams).</span>
<span class="nc" id="L217">                        compareTo(Arrays.toString(bparams));</span>
            }
<span class="nc" id="L219">            final Class&lt;?&gt; aret = a.getReturnType();</span>
<span class="nc" id="L220">            final Class&lt;?&gt; bret = b.getReturnType();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            if (aret == bret) return 0;</span>

            // Super type comes first: Object, Number, Integer
<span class="nc bnc" id="L224" title="All 2 branches missed.">            if (aret.isAssignableFrom(bret))</span>
<span class="nc" id="L225">                return -1;</span>
<span class="nc" id="L226">            return +1;      // could assert bret.isAssignableFrom(aret)</span>
        }
<span class="nc" id="L228">        public final static MethodOrder instance = new MethodOrder();</span>
    }


    /* Eliminate methods that are overridden with a covariant return type.
       Reflection will return both the original and the overriding method
       but only the overriding one is of interest.  We return the methods
       in the same order they arrived in.  This isn't required by the spec
       but existing code may depend on it and users may be used to seeing
       operations or attributes appear in a particular order.

       Because of the way this method works, if the same Method appears
       more than once in the given List then it will be completely deleted!
       So don't do that.  */
    static List&lt;Method&gt;
            eliminateCovariantMethods(List&lt;Method&gt; startMethods) {
        // We are assuming that you never have very many methods with the
        // same name, so it is OK to use algorithms that are quadratic
        // in the number of methods with the same name.

<span class="nc" id="L248">        final int len = startMethods.size();</span>
<span class="nc" id="L249">        final Method[] sorted = startMethods.toArray(new Method[len]);</span>
<span class="nc" id="L250">        Arrays.sort(sorted,MethodOrder.instance);</span>
<span class="nc" id="L251">        final Set&lt;Method&gt; overridden = newSet();</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        for (int i=1;i&lt;len;i++) {</span>
<span class="nc" id="L253">            final Method m0 = sorted[i-1];</span>
<span class="nc" id="L254">            final Method m1 = sorted[i];</span>

            // Methods that don't have the same name can't override each other
<span class="nc bnc" id="L257" title="All 2 branches missed.">            if (!m0.getName().equals(m1.getName())) continue;</span>

            // Methods that have the same name and same signature override
            // each other. In that case, the second method overrides the first,
            // due to the way we have sorted them in MethodOrder.
<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (Arrays.equals(m0.getParameterTypes(),</span>
<span class="nc" id="L263">                    m1.getParameterTypes())) {</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                if (!overridden.add(m0))</span>
<span class="nc" id="L265">                    throw new RuntimeException(&quot;Internal error: duplicate Method&quot;);</span>
            }
        }

<span class="nc" id="L269">        final List&lt;Method&gt; methods = newList(startMethods);</span>
<span class="nc" id="L270">        methods.removeAll(overridden);</span>
<span class="nc" id="L271">        return methods;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>