<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MBeanSupport.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jmx.mbeanserver</a> &gt; <span class="el_source">MBeanSupport.java</span></div><h1>MBeanSupport.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jmx.mbeanserver;


import javax.management.Attribute;
import javax.management.AttributeList;
import javax.management.AttributeNotFoundException;
import javax.management.InvalidAttributeValueException;
import javax.management.MBeanException;
import javax.management.MBeanInfo;
import javax.management.MBeanRegistration;
import javax.management.MBeanServer;
import javax.management.NotCompliantMBeanException;
import javax.management.ObjectName;
import javax.management.ReflectionException;
import com.sun.jmx.mbeanserver.MXBeanMappingFactory;
import sun.reflect.misc.ReflectUtil;

/**
 * Base class for MBeans.  There is one instance of this class for
 * every Standard MBean and every MXBean.  We try to limit the amount
 * of information per instance so we can handle very large numbers of
 * MBeans comfortably.
 *
 * @param &lt;M&gt; either Method or ConvertingMethod, for Standard MBeans
 * and MXBeans respectively.
 *
 * @since 1.6
 */
/*
 * We maintain a couple of caches to increase sharing between
 * different MBeans of the same type and also to reduce creation time
 * for the second and subsequent instances of the same type.
 *
 * The first cache maps from an MBean interface to a PerInterface
 * object containing information parsed out of the interface.  The
 * interface is either a Standard MBean interface or an MXBean
 * interface, and there is one cache for each case.
 *
 * The PerInterface includes an MBeanInfo.  This contains the
 * attributes and operations parsed out of the interface's methods,
 * plus a basic Descriptor for the interface containing at least the
 * interfaceClassName field and any fields derived from annotations on
 * the interface.  This MBeanInfo can never be the MBeanInfo for any
 * actual MBean, because an MBeanInfo's getClassName() is the name of
 * a concrete class and we don't know what the class will be.
 * Furthermore a real MBeanInfo may need to add constructors and/or
 * notifications to the MBeanInfo.
 *
 * The PerInterface also contains an MBeanDispatcher which is able to
 * route getAttribute, setAttribute, and invoke to the appropriate
 * method of the interface, including doing any necessary translation
 * of parameters and return values for MXBeans.
 *
 * The PerInterface also contains the original Class for the interface.
 *
 * We need to be careful about references.  When there are no MBeans
 * with a given interface, there must not be any strong references to
 * the interface Class.  Otherwise it could never be garbage collected,
 * and neither could its ClassLoader or any other classes loaded by
 * its ClassLoader.  Therefore the cache must wrap the PerInterface
 * in a WeakReference.  Each instance of MBeanSupport has a strong
 * reference to its PerInterface, which prevents PerInterface instances
 * from being garbage-collected prematurely.
 *
 * The second cache maps from a concrete class and an MBean interface
 * that that class implements to the MBeanInfo for that class and
 * interface.  (The ability to specify an interface separately comes
 * from the class StandardMBean.  MBeans registered directly in the
 * MBean Server will always have the same interface here.)
 *
 * The MBeanInfo in this second cache will be the MBeanInfo from the
 * PerInterface cache for the given itnerface, but with the
 * getClassName() having the concrete class's name, and the public
 * constructors based on the concrete class's constructors.  This
 * MBeanInfo can be shared between all instances of the concrete class
 * specifying the same interface, except instances that are
 * NotificationBroadcasters.  NotificationBroadcasters supply the
 * MBeanNotificationInfo[] in the MBeanInfo based on the instance
 * method NotificationBroadcaster.getNotificationInfo(), so two
 * instances of the same concrete class do not necessarily have the
 * same MBeanNotificationInfo[].  Currently we do not try to detect
 * when they do, although it would probably be worthwhile doing that
 * since it is a very common case.
 *
 * Standard MBeans additionally have the property that
 * getNotificationInfo() must in principle be called every time
 * getMBeanInfo() is called for the MBean, since the returned array is
 * allowed to change over time.  We attempt to reduce the cost of
 * doing this by detecting when the Standard MBean is a subclass of
 * NotificationBroadcasterSupport that does not override
 * getNotificationInfo(), meaning that the MBeanNotificationInfo[] is
 * the one that was supplied to the constructor.  MXBeans do not have
 * this problem because their getNotificationInfo() method is called
 * only once.
 *
 */
public abstract class MBeanSupport&lt;M&gt;
        implements DynamicMBean2, MBeanRegistration {

    &lt;T&gt; MBeanSupport(T resource, Class&lt;T&gt; mbeanInterfaceType)
<span class="nc" id="L126">            throws NotCompliantMBeanException {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (mbeanInterfaceType == null)</span>
<span class="nc" id="L128">            throw new NotCompliantMBeanException(&quot;Null MBean interface&quot;);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (!mbeanInterfaceType.isInstance(resource)) {</span>
<span class="nc" id="L130">            final String msg =</span>
<span class="nc" id="L131">                &quot;Resource class &quot; + resource.getClass().getName() +</span>
<span class="nc" id="L132">                &quot; is not an instance of &quot; + mbeanInterfaceType.getName();</span>
<span class="nc" id="L133">            throw new NotCompliantMBeanException(msg);</span>
        }
<span class="nc" id="L135">        ReflectUtil.checkPackageAccess(mbeanInterfaceType);</span>
<span class="nc" id="L136">        this.resource = resource;</span>
<span class="nc" id="L137">        MBeanIntrospector&lt;M&gt; introspector = getMBeanIntrospector();</span>
<span class="nc" id="L138">        this.perInterface = introspector.getPerInterface(mbeanInterfaceType);</span>
<span class="nc" id="L139">        this.mbeanInfo = introspector.getMBeanInfo(resource, perInterface);</span>
<span class="nc" id="L140">    }</span>

    /** Return the appropriate introspector for this type of MBean. */
    abstract MBeanIntrospector&lt;M&gt; getMBeanIntrospector();

    /**
     * Return a cookie for this MBean.  This cookie will be passed to
     * MBean method invocations where it can supply additional information
     * to the invocation.  For example, with MXBeans it can be used to
     * supply the MXBeanLookup context for resolving inter-MXBean references.
     */
    abstract Object getCookie();

    public final boolean isMXBean() {
<span class="nc" id="L154">        return perInterface.isMXBean();</span>
    }

    // Methods that javax.management.StandardMBean should call from its
    // preRegister and postRegister, given that it is not supposed to
    // call the contained object's preRegister etc methods even if it has them
    public abstract void register(MBeanServer mbs, ObjectName name)
            throws Exception;
    public abstract void unregister();

    public final ObjectName preRegister(MBeanServer server, ObjectName name)
            throws Exception {
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (resource instanceof MBeanRegistration)</span>
<span class="nc" id="L167">            name = ((MBeanRegistration) resource).preRegister(server, name);</span>
<span class="nc" id="L168">        return name;</span>
    }

    public final void preRegister2(MBeanServer server, ObjectName name)
            throws Exception {
<span class="nc" id="L173">        register(server, name);</span>
<span class="nc" id="L174">    }</span>

    public final void registerFailed() {
<span class="nc" id="L177">        unregister();</span>
<span class="nc" id="L178">    }</span>

    public final void postRegister(Boolean registrationDone) {
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (resource instanceof MBeanRegistration)</span>
<span class="nc" id="L182">            ((MBeanRegistration) resource).postRegister(registrationDone);</span>
<span class="nc" id="L183">    }</span>

    public final void preDeregister() throws Exception {
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (resource instanceof MBeanRegistration)</span>
<span class="nc" id="L187">            ((MBeanRegistration) resource).preDeregister();</span>
<span class="nc" id="L188">    }</span>

    public final void postDeregister() {
        // Undo any work from registration.  We do this in postDeregister
        // not preDeregister, because if the user preDeregister throws an
        // exception then the MBean is not unregistered.
        try {
<span class="nc" id="L195">            unregister();</span>
        } finally {
<span class="nc bnc" id="L197" title="All 4 branches missed.">            if (resource instanceof MBeanRegistration)</span>
<span class="nc" id="L198">                ((MBeanRegistration) resource).postDeregister();</span>
        }
<span class="nc" id="L200">    }</span>

    public final Object getAttribute(String attribute)
            throws AttributeNotFoundException,
                   MBeanException,
                   ReflectionException {
<span class="nc" id="L206">        return perInterface.getAttribute(resource, attribute, getCookie());</span>
    }

    public final AttributeList getAttributes(String[] attributes) {
<span class="nc" id="L210">        final AttributeList result = new AttributeList(attributes.length);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        for (String attrName : attributes) {</span>
            try {
<span class="nc" id="L213">                final Object attrValue = getAttribute(attrName);</span>
<span class="nc" id="L214">                result.add(new Attribute(attrName, attrValue));</span>
<span class="nc" id="L215">            } catch (Exception e) {</span>
                // OK: attribute is not included in returned list, per spec
                // XXX: log the exception
<span class="nc" id="L218">            }</span>
        }
<span class="nc" id="L220">        return result;</span>
    }

    public final void setAttribute(Attribute attribute)
            throws AttributeNotFoundException,
                   InvalidAttributeValueException,
                   MBeanException,
                   ReflectionException {
<span class="nc" id="L228">        final String name = attribute.getName();</span>
<span class="nc" id="L229">        final Object value = attribute.getValue();</span>
<span class="nc" id="L230">        perInterface.setAttribute(resource, name, value, getCookie());</span>
<span class="nc" id="L231">    }</span>

    public final AttributeList setAttributes(AttributeList attributes) {
<span class="nc" id="L234">        final AttributeList result = new AttributeList(attributes.size());</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">        for (Object attrObj : attributes) {</span>
            // We can't use AttributeList.asList because it has side-effects
<span class="nc" id="L237">            Attribute attr = (Attribute) attrObj;</span>
            try {
<span class="nc" id="L239">                setAttribute(attr);</span>
<span class="nc" id="L240">                result.add(new Attribute(attr.getName(), attr.getValue()));</span>
<span class="nc" id="L241">            } catch (Exception e) {</span>
                // OK: attribute is not included in returned list, per spec
                // XXX: log the exception
<span class="nc" id="L244">            }</span>
<span class="nc" id="L245">        }</span>
<span class="nc" id="L246">        return result;</span>
    }

    public final Object invoke(String operation, Object[] params,
                         String[] signature)
            throws MBeanException, ReflectionException {
<span class="nc" id="L252">        return perInterface.invoke(resource, operation, params, signature,</span>
<span class="nc" id="L253">                                   getCookie());</span>
    }

    // Overridden by StandardMBeanSupport
    public MBeanInfo getMBeanInfo() {
<span class="nc" id="L258">        return mbeanInfo;</span>
    }

    public final String getClassName() {
<span class="nc" id="L262">        return resource.getClass().getName();</span>
    }

    public final Object getResource() {
<span class="nc" id="L266">        return resource;</span>
    }

    public final Class&lt;?&gt; getMBeanInterface() {
<span class="nc" id="L270">        return perInterface.getMBeanInterface();</span>
    }

    private final MBeanInfo mbeanInfo;
    private final Object resource;
    private final PerInterface&lt;M&gt; perInterface;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>