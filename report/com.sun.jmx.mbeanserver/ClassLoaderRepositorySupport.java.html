<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ClassLoaderRepositorySupport.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jmx.mbeanserver</a> &gt; <span class="el_source">ClassLoaderRepositorySupport.java</span></div><h1>ClassLoaderRepositorySupport.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jmx.mbeanserver;


import static com.sun.jmx.defaults.JmxProperties.MBEANSERVER_LOGGER;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import javax.management.MBeanPermission;

import javax.management.ObjectName;
import javax.management.loading.PrivateClassLoader;
import sun.reflect.misc.ReflectUtil;

/**
 * This class keeps the list of Class Loaders registered in the MBean Server.
 * It provides the necessary methods to load classes using the
 * registered Class Loaders.
 *
 * @since 1.5
 */
<span class="nc" id="L50">final class ClassLoaderRepositorySupport</span>
    implements ModifiableClassLoaderRepository {

    /* We associate an optional ObjectName with each entry so that
       we can remove the correct entry when unregistering an MBean
       that is a ClassLoader.  The same object could be registered
       under two different names (even though this is not recommended)
       so if we did not do this we could disturb the defined
       semantics for the order of ClassLoaders in the repository.  */
    private static class LoaderEntry {
        ObjectName name; // can be null
        ClassLoader loader;

<span class="nc" id="L63">        LoaderEntry(ObjectName name,  ClassLoader loader) {</span>
<span class="nc" id="L64">            this.name = name;</span>
<span class="nc" id="L65">            this.loader = loader;</span>
<span class="nc" id="L66">        }</span>
    }

<span class="nc" id="L69">    private static final LoaderEntry[] EMPTY_LOADER_ARRAY = new LoaderEntry[0];</span>

    /**
     * List of class loaders
     * Only read-only actions should be performed on this object.
     *
     * We do O(n) operations on this array, e.g. when removing
     * a ClassLoader.  The assumption is that the number of elements
     * is small, probably less than ten, and that the vast majority
     * of operations are searches (loadClass) which are by definition
     * linear.
     */
<span class="nc" id="L81">    private LoaderEntry[] loaders = EMPTY_LOADER_ARRAY;</span>

    /**
     * Same behavior as add(Object o) in {@link java.util.List}.
     * Replace the loader list with a new one in which the new
     * loader has been added.
     **/
    private synchronized boolean add(ObjectName name, ClassLoader cl) {
<span class="nc" id="L89">        List&lt;LoaderEntry&gt; l =</span>
<span class="nc" id="L90">            new ArrayList&lt;LoaderEntry&gt;(Arrays.asList(loaders));</span>
<span class="nc" id="L91">        l.add(new LoaderEntry(name, cl));</span>
<span class="nc" id="L92">        loaders = l.toArray(EMPTY_LOADER_ARRAY);</span>
<span class="nc" id="L93">        return true;</span>
    }

    /**
     * Same behavior as remove(Object o) in {@link java.util.List}.
     * Replace the loader list with a new one in which the old loader
     * has been removed.
     *
     * The ObjectName may be null, in which case the entry to
     * be removed must also have a null ObjectName and the ClassLoader
     * values must match.  If the ObjectName is not null, then
     * the first entry with a matching ObjectName is removed,
     * regardless of whether ClassLoader values match.  (In fact,
     * the ClassLoader parameter will usually be null in this case.)
     **/
    private synchronized boolean remove(ObjectName name, ClassLoader cl) {
<span class="nc" id="L109">        final int size = loaders.length;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L111">            LoaderEntry entry = loaders[i];</span>
<span class="nc bnc" id="L112" title="All 4 branches missed.">            boolean match =</span>
                (name == null) ?
                cl == entry.loader :
<span class="nc" id="L115">                name.equals(entry.name);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            if (match) {</span>
<span class="nc" id="L117">                LoaderEntry[] newloaders = new LoaderEntry[size - 1];</span>
<span class="nc" id="L118">                System.arraycopy(loaders, 0, newloaders, 0, i);</span>
<span class="nc" id="L119">                System.arraycopy(loaders, i + 1, newloaders, i,</span>
                                 size - 1 - i);
<span class="nc" id="L121">                loaders = newloaders;</span>
<span class="nc" id="L122">                return true;</span>
            }
        }
<span class="nc" id="L125">        return false;</span>
    }


    /**
     * List of valid search
     */
<span class="nc" id="L132">    private final Map&lt;String,List&lt;ClassLoader&gt;&gt; search =</span>
        new Hashtable&lt;String,List&lt;ClassLoader&gt;&gt;(10);

    /**
     * List of named class loaders.
     */
<span class="nc" id="L138">    private final Map&lt;ObjectName,ClassLoader&gt; loadersWithNames =</span>
        new Hashtable&lt;ObjectName,ClassLoader&gt;(10);

    // from javax.management.loading.DefaultLoaderRepository
    public final Class&lt;?&gt; loadClass(String className)
        throws ClassNotFoundException {
<span class="nc" id="L144">        return  loadClass(loaders, className, null, null);</span>
    }


    // from javax.management.loading.DefaultLoaderRepository
    public final Class&lt;?&gt; loadClassWithout(ClassLoader without, String className)
            throws ClassNotFoundException {
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L152">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L153">                    ClassLoaderRepositorySupport.class.getName(),</span>
                    &quot;loadClassWithout&quot;, className + &quot; without &quot; + without);
        }

        // without is null =&gt; just behave as loadClass
        //
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (without == null)</span>
<span class="nc" id="L160">            return loadClass(loaders, className, null, null);</span>

        // We must try to load the class without the given loader.
        //
<span class="nc" id="L164">        startValidSearch(without, className);</span>
        try {
<span class="nc" id="L166">            return loadClass(loaders, className, without, null);</span>
        } finally {
<span class="nc" id="L168">            stopValidSearch(without, className);</span>
        }
    }


    public final Class&lt;?&gt; loadClassBefore(ClassLoader stop, String className)
            throws ClassNotFoundException {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L176">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L177">                    ClassLoaderRepositorySupport.class.getName(),</span>
                    &quot;loadClassBefore&quot;, className + &quot; before &quot; + stop);
        }

<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (stop == null)</span>
<span class="nc" id="L182">            return loadClass(loaders, className, null, null);</span>

<span class="nc" id="L184">        startValidSearch(stop, className);</span>
        try {
<span class="nc" id="L186">            return loadClass(loaders, className, null, stop);</span>
        } finally {
<span class="nc" id="L188">            stopValidSearch(stop, className);</span>
        }
    }


    private Class&lt;?&gt; loadClass(final LoaderEntry list[],
                               final String className,
                               final ClassLoader without,
                               final ClassLoader stop)
            throws ClassNotFoundException {
<span class="nc" id="L198">        ReflectUtil.checkPackageAccess(className);</span>
<span class="nc" id="L199">        final int size = list.length;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        for(int i=0; i&lt;size; i++) {</span>
            try {
<span class="nc" id="L202">                final ClassLoader cl = list[i].loader;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                if (cl == null) // bootstrap class loader</span>
<span class="nc" id="L204">                    return Class.forName(className, false, null);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                if (cl == without)</span>
<span class="nc" id="L206">                    continue;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">                if (cl == stop)</span>
<span class="nc" id="L208">                    break;</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L210">                    MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L211">                            ClassLoaderRepositorySupport.class.getName(),</span>
                            &quot;loadClass&quot;, &quot;Trying loader = &quot; + cl);
                }
                /* We used to have a special case for &quot;instanceof
                   MLet&quot; here, where we invoked the method
                   loadClass(className, null) to prevent infinite
                   recursion.  But the rule whereby the MLet only
                   consults loaders that precede it in the CLR (via
                   loadClassBefore) means that the recursion can't
                   happen, and the test here caused some legitimate
                   classloading to fail.  For example, if you have
                   dependencies C-&gt;D-&gt;E with loaders {E D C} in the
                   CLR in that order, you would expect to be able to
                   load C.  The problem is that while resolving D, CLR
                   delegation is disabled, so it can't find E.  */
<span class="nc" id="L226">                return Class.forName(className, false, cl);</span>
<span class="nc" id="L227">            } catch (ClassNotFoundException e) {</span>
                // OK: continue with next class
            }
        }

<span class="nc" id="L232">        throw new ClassNotFoundException(className);</span>
    }

    private synchronized void startValidSearch(ClassLoader aloader,
                                               String className)
        throws ClassNotFoundException {
        // Check if we have such a current search
        //
<span class="nc" id="L240">        List&lt;ClassLoader&gt; excluded = search.get(className);</span>
<span class="nc bnc" id="L241" title="All 4 branches missed.">        if ((excluded!= null) &amp;&amp; (excluded.contains(aloader))) {</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L243">                MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L244">                        ClassLoaderRepositorySupport.class.getName(),</span>
                        &quot;startValidSearch&quot;, &quot;Already requested loader = &quot; +
                        aloader + &quot; class = &quot; + className);
            }
<span class="nc" id="L248">            throw new ClassNotFoundException(className);</span>
        }

        // Add an entry
        //
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (excluded == null) {</span>
<span class="nc" id="L254">            excluded = new ArrayList&lt;ClassLoader&gt;(1);</span>
<span class="nc" id="L255">            search.put(className, excluded);</span>
        }
<span class="nc" id="L257">        excluded.add(aloader);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L259">            MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L260">                    ClassLoaderRepositorySupport.class.getName(),</span>
                    &quot;startValidSearch&quot;,
                    &quot;loader = &quot; + aloader + &quot; class = &quot; + className);
        }
<span class="nc" id="L264">    }</span>

    private synchronized void stopValidSearch(ClassLoader aloader,
                                              String className) {

        // Retrieve the search.
        //
<span class="nc" id="L271">        List&lt;ClassLoader&gt; excluded = search.get(className);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (excluded != null) {</span>
<span class="nc" id="L273">            excluded.remove(aloader);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L275">                MBEANSERVER_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L276">                        ClassLoaderRepositorySupport.class.getName(),</span>
                        &quot;stopValidSearch&quot;,
                        &quot;loader = &quot; + aloader + &quot; class = &quot; + className);
            }
        }
<span class="nc" id="L281">    }</span>

    public final void addClassLoader(ClassLoader loader) {
<span class="nc" id="L284">        add(null, loader);</span>
<span class="nc" id="L285">    }</span>

    public final void removeClassLoader(ClassLoader loader) {
<span class="nc" id="L288">        remove(null, loader);</span>
<span class="nc" id="L289">    }</span>

    public final synchronized void addClassLoader(ObjectName name,
                                                  ClassLoader loader) {
<span class="nc" id="L293">        loadersWithNames.put(name, loader);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (!(loader instanceof PrivateClassLoader))</span>
<span class="nc" id="L295">            add(name, loader);</span>
<span class="nc" id="L296">    }</span>

    public final synchronized void removeClassLoader(ObjectName name) {
<span class="nc" id="L299">        ClassLoader loader = loadersWithNames.remove(name);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (!(loader instanceof PrivateClassLoader))</span>
<span class="nc" id="L301">            remove(name, loader);</span>
<span class="nc" id="L302">    }</span>

    public final ClassLoader getClassLoader(ObjectName name) {
<span class="nc" id="L305">        ClassLoader instance = loadersWithNames.get(name);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (instance != null) {</span>
<span class="nc" id="L307">            SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (sm != null) {</span>
<span class="nc" id="L309">                Permission perm =</span>
<span class="nc" id="L310">                        new MBeanPermission(instance.getClass().getName(),</span>
                        null,
                        name,
                        &quot;getClassLoader&quot;);
<span class="nc" id="L314">                sm.checkPermission(perm);</span>
            }
        }
<span class="nc" id="L317">        return instance;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>