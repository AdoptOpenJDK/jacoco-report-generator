<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Attribute.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">Attribute.java</span></div><h1>Attribute.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import com.sun.java.util.jar.pack.ConstantPool.Entry;
import com.sun.java.util.jar.pack.ConstantPool.Index;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import static com.sun.java.util.jar.pack.Constants.*;

/**
 * Represents an attribute in a class-file.
 * Takes care to remember where constant pool indexes occur.
 * Implements the &quot;little language&quot; of Pack200 for describing
 * attribute layouts.
 * @author John Rose
 */
<span class="nc bnc" id="L48" title="All 2 branches missed.">class Attribute implements Comparable&lt;Attribute&gt; {</span>
    // Attribute instance fields.

    Layout def;     // the name and format of this attr
    byte[] bytes;   // the actual bytes
    Object fixups;  // reference relocations, if any are required

<span class="nc" id="L55">    public String name() { return def.name(); }</span>
<span class="nc" id="L56">    public Layout layout() { return def; }</span>
<span class="nc" id="L57">    public byte[] bytes() { return bytes; }</span>
<span class="nc" id="L58">    public int size() { return bytes.length; }</span>
<span class="nc" id="L59">    public Entry getNameRef() { return def.getNameRef(); }</span>

<span class="nc" id="L61">    private Attribute(Attribute old) {</span>
<span class="nc" id="L62">        this.def = old.def;</span>
<span class="nc" id="L63">        this.bytes = old.bytes;</span>
<span class="nc" id="L64">        this.fixups = old.fixups;</span>
<span class="nc" id="L65">    }</span>

<span class="nc" id="L67">    public Attribute(Layout def, byte[] bytes, Object fixups) {</span>
<span class="nc" id="L68">        this.def = def;</span>
<span class="nc" id="L69">        this.bytes = bytes;</span>
<span class="nc" id="L70">        this.fixups = fixups;</span>
<span class="nc" id="L71">        Fixups.setBytes(fixups, bytes);</span>
<span class="nc" id="L72">    }</span>
    public Attribute(Layout def, byte[] bytes) {
<span class="nc" id="L74">        this(def, bytes, null);</span>
<span class="nc" id="L75">    }</span>

    public Attribute addContent(byte[] bytes, Object fixups) {
<span class="nc bnc" id="L78" title="All 4 branches missed.">        assert(isCanonical());</span>
<span class="nc bnc" id="L79" title="All 4 branches missed.">        if (bytes.length == 0 &amp;&amp; fixups == null)</span>
<span class="nc" id="L80">            return this;</span>
<span class="nc" id="L81">        Attribute res = new Attribute(this);</span>
<span class="nc" id="L82">        res.bytes = bytes;</span>
<span class="nc" id="L83">        res.fixups = fixups;</span>
<span class="nc" id="L84">        Fixups.setBytes(fixups, bytes);</span>
<span class="nc" id="L85">        return res;</span>
    }
    public Attribute addContent(byte[] bytes) {
<span class="nc" id="L88">        return addContent(bytes, null);</span>
    }

    public void finishRefs(Index ix) {
<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (fixups != null) {</span>
<span class="nc" id="L93">            Fixups.finishRefs(fixups, bytes, ix);</span>
<span class="nc" id="L94">            fixups = null;</span>
        }
<span class="nc" id="L96">    }</span>

    public boolean isCanonical() {
<span class="nc bnc" id="L99" title="All 2 branches missed.">        return this == def.canon;</span>
    }

    @Override
    public int compareTo(Attribute that) {
<span class="nc" id="L104">        return this.def.compareTo(that.def);</span>
    }

<span class="nc" id="L107">    private static final Map&lt;List&lt;Attribute&gt;, List&lt;Attribute&gt;&gt; canonLists = new HashMap&lt;&gt;();</span>
<span class="nc" id="L108">    private static final Map&lt;Layout, Attribute&gt; attributes = new HashMap&lt;&gt;();</span>
<span class="nc" id="L109">    private static final Map&lt;Layout, Attribute&gt; standardDefs = new HashMap&lt;&gt;();</span>

    // Canonicalized lists of trivial attrs (Deprecated, etc.)
    // are used by trimToSize, in order to reduce footprint
    // of some common cases.  (Note that Code attributes are
    // always zero size.)
    public static List&lt;Attribute&gt; getCanonList(List&lt;Attribute&gt; al) {
<span class="nc" id="L116">        synchronized (canonLists) {</span>
<span class="nc" id="L117">            List&lt;Attribute&gt; cl = canonLists.get(al);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            if (cl == null) {</span>
<span class="nc" id="L119">                cl = new ArrayList&lt;&gt;(al.size());</span>
<span class="nc" id="L120">                cl.addAll(al);</span>
<span class="nc" id="L121">                cl = Collections.unmodifiableList(cl);</span>
<span class="nc" id="L122">                canonLists.put(al, cl);</span>
            }
<span class="nc" id="L124">            return cl;</span>
<span class="nc" id="L125">        }</span>
    }

    // Find the canonical empty attribute with the given ctype, name, layout.
    public static Attribute find(int ctype, String name, String layout) {
<span class="nc" id="L130">        Layout key = Layout.makeKey(ctype, name, layout);</span>
<span class="nc" id="L131">        synchronized (attributes) {</span>
<span class="nc" id="L132">            Attribute a = attributes.get(key);</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc" id="L134">                a = new Layout(ctype, name, layout).canonicalInstance();</span>
<span class="nc" id="L135">                attributes.put(key, a);</span>
            }
<span class="nc" id="L137">            return a;</span>
<span class="nc" id="L138">        }</span>
    }

    public static Layout keyForLookup(int ctype, String name) {
<span class="nc" id="L142">        return Layout.makeKey(ctype, name);</span>
    }

    // Find canonical empty attribute with given ctype and name,
    // and with the standard layout.
    public static Attribute lookup(Map&lt;Layout, Attribute&gt; defs, int ctype,
            String name) {
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (defs == null) {</span>
<span class="nc" id="L150">            defs = standardDefs;</span>
        }
<span class="nc" id="L152">        return defs.get(Layout.makeKey(ctype, name));</span>
    }

    public static Attribute define(Map&lt;Layout, Attribute&gt; defs, int ctype,
            String name, String layout) {
<span class="nc" id="L157">        Attribute a = find(ctype, name, layout);</span>
<span class="nc" id="L158">        defs.put(Layout.makeKey(ctype, name), a);</span>
<span class="nc" id="L159">        return a;</span>
    }

    static {
<span class="nc" id="L163">        Map&lt;Layout, Attribute&gt; sd = standardDefs;</span>
<span class="nc" id="L164">        define(sd, ATTR_CONTEXT_CLASS, &quot;Signature&quot;, &quot;RSH&quot;);</span>
<span class="nc" id="L165">        define(sd, ATTR_CONTEXT_CLASS, &quot;Synthetic&quot;, &quot;&quot;);</span>
<span class="nc" id="L166">        define(sd, ATTR_CONTEXT_CLASS, &quot;Deprecated&quot;, &quot;&quot;);</span>
<span class="nc" id="L167">        define(sd, ATTR_CONTEXT_CLASS, &quot;SourceFile&quot;, &quot;RUH&quot;);</span>
<span class="nc" id="L168">        define(sd, ATTR_CONTEXT_CLASS, &quot;EnclosingMethod&quot;, &quot;RCHRDNH&quot;);</span>
<span class="nc" id="L169">        define(sd, ATTR_CONTEXT_CLASS, &quot;InnerClasses&quot;, &quot;NH[RCHRCNHRUNHFH]&quot;);</span>
<span class="nc" id="L170">        define(sd, ATTR_CONTEXT_CLASS, &quot;BootstrapMethods&quot;, &quot;NH[RMHNH[KLH]]&quot;);</span>

<span class="nc" id="L172">        define(sd, ATTR_CONTEXT_FIELD, &quot;Signature&quot;, &quot;RSH&quot;);</span>
<span class="nc" id="L173">        define(sd, ATTR_CONTEXT_FIELD, &quot;Synthetic&quot;, &quot;&quot;);</span>
<span class="nc" id="L174">        define(sd, ATTR_CONTEXT_FIELD, &quot;Deprecated&quot;, &quot;&quot;);</span>
<span class="nc" id="L175">        define(sd, ATTR_CONTEXT_FIELD, &quot;ConstantValue&quot;, &quot;KQH&quot;);</span>

<span class="nc" id="L177">        define(sd, ATTR_CONTEXT_METHOD, &quot;Signature&quot;, &quot;RSH&quot;);</span>
<span class="nc" id="L178">        define(sd, ATTR_CONTEXT_METHOD, &quot;Synthetic&quot;, &quot;&quot;);</span>
<span class="nc" id="L179">        define(sd, ATTR_CONTEXT_METHOD, &quot;Deprecated&quot;, &quot;&quot;);</span>
<span class="nc" id="L180">        define(sd, ATTR_CONTEXT_METHOD, &quot;Exceptions&quot;, &quot;NH[RCH]&quot;);</span>
<span class="nc" id="L181">        define(sd, ATTR_CONTEXT_METHOD, &quot;MethodParameters&quot;, &quot;NB[RUNHFH]&quot;);</span>
        //define(sd, ATTR_CONTEXT_METHOD, &quot;Code&quot;, &quot;HHNI[B]NH[PHPOHPOHRCNH]NH[RUHNI[B]]&quot;);

<span class="nc" id="L184">        define(sd, ATTR_CONTEXT_CODE, &quot;StackMapTable&quot;,</span>
               (&quot;[NH[(1)]]&quot; +
                &quot;[TB&quot; +
                &quot;(64-127)[(2)]&quot; +
                &quot;(247)[(1)(2)]&quot; +
                &quot;(248-251)[(1)]&quot; +
                &quot;(252)[(1)(2)]&quot; +
                &quot;(253)[(1)(2)(2)]&quot; +
                &quot;(254)[(1)(2)(2)(2)]&quot; +
                &quot;(255)[(1)NH[(2)]NH[(2)]]&quot; +
                &quot;()[]&quot; +
                &quot;]&quot; +
                &quot;[H]&quot; +
                &quot;[TB(7)[RCH](8)[PH]()[]]&quot;));

<span class="nc" id="L199">        define(sd, ATTR_CONTEXT_CODE, &quot;LineNumberTable&quot;, &quot;NH[PHH]&quot;);</span>
<span class="nc" id="L200">        define(sd, ATTR_CONTEXT_CODE, &quot;LocalVariableTable&quot;, &quot;NH[PHOHRUHRSHH]&quot;);</span>
<span class="nc" id="L201">        define(sd, ATTR_CONTEXT_CODE, &quot;LocalVariableTypeTable&quot;, &quot;NH[PHOHRUHRSHH]&quot;);</span>
        //define(sd, ATTR_CONTEXT_CODE, &quot;CharacterRangeTable&quot;, &quot;NH[PHPOHIIH]&quot;);
        //define(sd, ATTR_CONTEXT_CODE, &quot;CoverageTable&quot;, &quot;NH[PHHII]&quot;);

        // Note:  Code and InnerClasses are special-cased elsewhere.
        // Their layout specs. are given here for completeness.
        // The Code spec is incomplete, in that it does not distinguish
        // bytecode bytes or locate CP references.
        // The BootstrapMethods attribute is also special-cased
        // elsewhere as an appendix to the local constant pool.
    }

    // Metadata.
    //
    // We define metadata using similar layouts
    // for all five kinds of metadata attributes and 2 type metadata attributes
    //
    // Regular annotations are a counted list of [RSHNH[RUH(1)]][...]
    //   pack.method.attribute.RuntimeVisibleAnnotations=[NH[(1)]][RSHNH[RUH(1)]][TB...]
    //
    // Parameter annotations are a counted list of regular annotations.
    //   pack.method.attribute.RuntimeVisibleParameterAnnotations=[NB[(1)]][NH[(1)]][RSHNH[RUH(1)]][TB...]
    //
    // RuntimeInvisible annotations are defined similarly...
    // Non-method annotations are defined similarly...
    //
    // Annotation are a simple tagged value [TB...]
    //   pack.attribute.method.AnnotationDefault=[TB...]

    static {
<span class="nc" id="L231">        String mdLayouts[] = {</span>
            Attribute.normalizeLayoutString
<span class="nc" id="L233">            (&quot;&quot;</span>
             +&quot;\n  # parameter_annotations :=&quot;
             +&quot;\n  [ NB[(1)] ]     # forward call to annotations&quot;
             ),
            Attribute.normalizeLayoutString
<span class="nc" id="L238">            (&quot;&quot;</span>
             +&quot;\n  # annotations :=&quot;
             +&quot;\n  [ NH[(1)] ]     # forward call to annotation&quot;
             +&quot;\n  &quot;
            ),
            Attribute.normalizeLayoutString
<span class="nc" id="L244">             (&quot;&quot;</span>
             +&quot;\n  # annotation :=&quot;
             +&quot;\n  [RSH&quot;
             +&quot;\n    NH[RUH (1)]   # forward call to value&quot;
             +&quot;\n    ]&quot;
             ),
            Attribute.normalizeLayoutString
<span class="nc" id="L251">            (&quot;&quot;</span>
             +&quot;\n  # value :=&quot;
             +&quot;\n  [TB # Callable 2 encodes one tagged value.&quot;
             +&quot;\n    (\\B,\\C,\\I,\\S,\\Z)[KIH]&quot;
             +&quot;\n    (\\D)[KDH]&quot;
             +&quot;\n    (\\F)[KFH]&quot;
             +&quot;\n    (\\J)[KJH]&quot;
             +&quot;\n    (\\c)[RSH]&quot;
             +&quot;\n    (\\e)[RSH RUH]&quot;
             +&quot;\n    (\\s)[RUH]&quot;
             +&quot;\n    (\\[)[NH[(0)]] # backward self-call to value&quot;
             +&quot;\n    (\\@)[RSH NH[RUH (0)]] # backward self-call to value&quot;
             +&quot;\n    ()[] ]&quot;
             )
        };
        /*
         * RuntimeVisibleTypeAnnotation and RuntimeInvisibleTypeAnnotatation are
         * similar to RuntimeVisibleAnnotation and RuntimeInvisibleAnnotation,
         * a type-annotation union  and a type-path structure precedes the
         * annotation structure
         */
<span class="nc" id="L272">        String typeLayouts[] = {</span>
            Attribute.normalizeLayoutString
<span class="nc" id="L274">            (&quot;&quot;</span>
             +&quot;\n # type-annotations :=&quot;
             +&quot;\n  [ NH[(1)(2)(3)] ]     # forward call to type-annotations&quot;
            ),
            Attribute.normalizeLayoutString
<span class="nc" id="L279">            ( &quot;&quot;</span>
             +&quot;\n  # type-annotation :=&quot;
             +&quot;\n  [TB&quot;
             +&quot;\n    (0-1) [B] # {CLASS, METHOD}_TYPE_PARAMETER&quot;
             +&quot;\n    (16) [FH] # CLASS_EXTENDS&quot;
             +&quot;\n    (17-18) [BB] # {CLASS, METHOD}_TYPE_PARAMETER_BOUND&quot;
             +&quot;\n    (19-21) [] # FIELD, METHOD_RETURN, METHOD_RECEIVER&quot;
             +&quot;\n    (22) [B] # METHOD_FORMAL_PARAMETER&quot;
             +&quot;\n    (23) [H] # THROWS&quot;
             +&quot;\n    (64-65) [NH[PHOHH]] # LOCAL_VARIABLE, RESOURCE_VARIABLE&quot;
             +&quot;\n    (66) [H] # EXCEPTION_PARAMETER&quot;
             +&quot;\n    (67-70) [PH] # INSTANCEOF, NEW, {CONSTRUCTOR, METHOD}_REFERENCE_RECEIVER&quot;
             +&quot;\n    (71-75) [PHB] # CAST, {CONSTRUCTOR,METHOD}_INVOCATION_TYPE_ARGUMENT, {CONSTRUCTOR, METHOD}_REFERENCE_TYPE_ARGUMENT&quot;
             +&quot;\n    ()[] ]&quot;
            ),
            Attribute.normalizeLayoutString
<span class="nc" id="L295">            (&quot;&quot;</span>
             +&quot;\n # type-path&quot;
             +&quot;\n [ NB[BB] ]&quot;
            )
        };
<span class="nc" id="L300">        Map&lt;Layout, Attribute&gt; sd = standardDefs;</span>
<span class="nc" id="L301">        String defaultLayout     = mdLayouts[3];</span>
<span class="nc" id="L302">        String annotationsLayout = mdLayouts[1] + mdLayouts[2] + mdLayouts[3];</span>
<span class="nc" id="L303">        String paramsLayout      = mdLayouts[0] + annotationsLayout;</span>
<span class="nc" id="L304">        String typesLayout       = typeLayouts[0] + typeLayouts[1] +</span>
                                   typeLayouts[2] + mdLayouts[2] + mdLayouts[3];

<span class="nc bnc" id="L307" title="All 2 branches missed.">        for (int ctype = 0; ctype &lt; ATTR_CONTEXT_LIMIT; ctype++) {</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (ctype != ATTR_CONTEXT_CODE) {</span>
<span class="nc" id="L309">                define(sd, ctype,</span>
                       &quot;RuntimeVisibleAnnotations&quot;,   annotationsLayout);
<span class="nc" id="L311">                define(sd, ctype,</span>
                       &quot;RuntimeInvisibleAnnotations&quot;,  annotationsLayout);

<span class="nc bnc" id="L314" title="All 2 branches missed.">                if (ctype == ATTR_CONTEXT_METHOD) {</span>
<span class="nc" id="L315">                    define(sd, ctype,</span>
                           &quot;RuntimeVisibleParameterAnnotations&quot;,   paramsLayout);
<span class="nc" id="L317">                    define(sd, ctype,</span>
                           &quot;RuntimeInvisibleParameterAnnotations&quot;, paramsLayout);
<span class="nc" id="L319">                    define(sd, ctype,</span>
                           &quot;AnnotationDefault&quot;, defaultLayout);
                }
            }
<span class="nc" id="L323">            define(sd, ctype,</span>
                   &quot;RuntimeVisibleTypeAnnotations&quot;, typesLayout);
<span class="nc" id="L325">            define(sd, ctype,</span>
                   &quot;RuntimeInvisibleTypeAnnotations&quot;, typesLayout);
        }
    }

    public static String contextName(int ctype) {
<span class="nc bnc" id="L331" title="All 5 branches missed.">        switch (ctype) {</span>
<span class="nc" id="L332">        case ATTR_CONTEXT_CLASS: return &quot;class&quot;;</span>
<span class="nc" id="L333">        case ATTR_CONTEXT_FIELD: return &quot;field&quot;;</span>
<span class="nc" id="L334">        case ATTR_CONTEXT_METHOD: return &quot;method&quot;;</span>
<span class="nc" id="L335">        case ATTR_CONTEXT_CODE: return &quot;code&quot;;</span>
        }
<span class="nc" id="L337">        return null;</span>
    }

    /** Base class for any attributed object (Class, Field, Method, Code).
     *  Flags are included because they are used to help transmit the
     *  presence of attributes.  That is, flags are a mix of modifier
     *  bits and attribute indicators.
     */
<span class="nc bnc" id="L345" title="All 2 branches missed.">    public static abstract</span>
<span class="nc" id="L346">    class Holder {</span>

        // We need this abstract method to interpret embedded CP refs.
        protected abstract Entry[] getCPMap();

        protected int flags;             // defined here for convenience
        protected List&lt;Attribute&gt; attributes;

        public int attributeSize() {
<span class="nc bnc" id="L355" title="All 2 branches missed.">            return (attributes == null) ? 0 : attributes.size();</span>
        }

        public void trimToSize() {
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (attributes == null) {</span>
<span class="nc" id="L360">                return;</span>
            }
<span class="nc bnc" id="L362" title="All 2 branches missed.">            if (attributes.isEmpty()) {</span>
<span class="nc" id="L363">                attributes = null;</span>
<span class="nc" id="L364">                return;</span>
            }
<span class="nc bnc" id="L366" title="All 2 branches missed.">            if (attributes instanceof ArrayList) {</span>
<span class="nc" id="L367">                ArrayList&lt;Attribute&gt; al = (ArrayList&lt;Attribute&gt;)attributes;</span>
<span class="nc" id="L368">                al.trimToSize();</span>
<span class="nc" id="L369">                boolean allCanon = true;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                for (Attribute a : al) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                    if (!a.isCanonical()) {</span>
<span class="nc" id="L372">                        allCanon = false;</span>
                    }
<span class="nc bnc" id="L374" title="All 2 branches missed.">                    if (a.fixups != null) {</span>
<span class="nc bnc" id="L375" title="All 4 branches missed.">                        assert(!a.isCanonical());</span>
<span class="nc" id="L376">                        a.fixups = Fixups.trimToSize(a.fixups);</span>
                    }
<span class="nc" id="L378">                }</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">                if (allCanon) {</span>
                    // Replace private writable attribute list
                    // with only trivial entries by public unique
                    // immutable attribute list with the same entries.
<span class="nc" id="L383">                    attributes = getCanonList(al);</span>
                }
            }
<span class="nc" id="L386">        }</span>

        public void addAttribute(Attribute a) {
<span class="nc bnc" id="L389" title="All 2 branches missed.">            if (attributes == null)</span>
<span class="nc" id="L390">                attributes = new ArrayList&lt;&gt;(3);</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">            else if (!(attributes instanceof ArrayList))</span>
<span class="nc" id="L392">                attributes = new ArrayList&lt;&gt;(attributes);  // unfreeze it</span>
<span class="nc" id="L393">            attributes.add(a);</span>
<span class="nc" id="L394">        }</span>

        public Attribute removeAttribute(Attribute a) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">            if (attributes == null)       return null;</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            if (!attributes.contains(a))  return null;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if (!(attributes instanceof ArrayList))</span>
<span class="nc" id="L400">                attributes = new ArrayList&lt;&gt;(attributes);  // unfreeze it</span>
<span class="nc" id="L401">            attributes.remove(a);</span>
<span class="nc" id="L402">            return a;</span>
        }

        public Attribute getAttribute(int n) {
<span class="nc" id="L406">            return attributes.get(n);</span>
        }

        protected void visitRefs(int mode, Collection&lt;Entry&gt; refs) {
<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (attributes == null)  return;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            for (Attribute a : attributes) {</span>
<span class="nc" id="L412">                a.visitRefs(this, mode, refs);</span>
<span class="nc" id="L413">            }</span>
<span class="nc" id="L414">        }</span>

<span class="nc" id="L416">        static final List&lt;Attribute&gt; noAttributes = Arrays.asList(new Attribute[0]);</span>

        public List&lt;Attribute&gt; getAttributes() {
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (attributes == null)</span>
<span class="nc" id="L420">                return noAttributes;</span>
<span class="nc" id="L421">            return attributes;</span>
        }

        public void setAttributes(List&lt;Attribute&gt; attrList) {
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (attrList.isEmpty())</span>
<span class="nc" id="L426">                attributes = null;</span>
            else
<span class="nc" id="L428">                attributes = attrList;</span>
<span class="nc" id="L429">        }</span>

        public Attribute getAttribute(String attrName) {
<span class="nc bnc" id="L432" title="All 2 branches missed.">            if (attributes == null)  return null;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">            for (Attribute a : attributes) {</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                if (a.name().equals(attrName))</span>
<span class="nc" id="L435">                    return a;</span>
<span class="nc" id="L436">            }</span>
<span class="nc" id="L437">            return null;</span>
        }

        public Attribute getAttribute(Layout attrDef) {
<span class="nc bnc" id="L441" title="All 2 branches missed.">            if (attributes == null)  return null;</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            for (Attribute a : attributes) {</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">                if (a.layout() == attrDef)</span>
<span class="nc" id="L444">                    return a;</span>
<span class="nc" id="L445">            }</span>
<span class="nc" id="L446">            return null;</span>
        }

        public Attribute removeAttribute(String attrName) {
<span class="nc" id="L450">            return removeAttribute(getAttribute(attrName));</span>
        }

        public Attribute removeAttribute(Layout attrDef) {
<span class="nc" id="L454">            return removeAttribute(getAttribute(attrDef));</span>
        }

        public void strip(String attrName) {
<span class="nc" id="L458">            removeAttribute(getAttribute(attrName));</span>
<span class="nc" id="L459">        }</span>
    }

    // Lightweight interface to hide details of band structure.
    // Also used for testing.
    public static abstract
<span class="nc" id="L465">    class ValueStream {</span>
<span class="nc" id="L466">        public int getInt(int bandIndex) { throw undef(); }</span>
<span class="nc" id="L467">        public void putInt(int bandIndex, int value) { throw undef(); }</span>
<span class="nc" id="L468">        public Entry getRef(int bandIndex) { throw undef(); }</span>
<span class="nc" id="L469">        public void putRef(int bandIndex, Entry ref) { throw undef(); }</span>
        // Note:  decodeBCI goes w/ getInt/Ref; encodeBCI goes w/ putInt/Ref
<span class="nc" id="L471">        public int decodeBCI(int bciCode) { throw undef(); }</span>
<span class="nc" id="L472">        public int encodeBCI(int bci) { throw undef(); }</span>
<span class="nc" id="L473">        public void noteBackCall(int whichCallable) { /* ignore by default */ }</span>
        private RuntimeException undef() {
<span class="nc" id="L475">            return new UnsupportedOperationException(&quot;ValueStream method&quot;);</span>
        }
    }

    // Element kinds:
    static final byte EK_INT  = 1;     // B H I SH etc.
    static final byte EK_BCI  = 2;     // PH POH etc.
    static final byte EK_BCO  = 3;     // OH etc.
    static final byte EK_FLAG = 4;     // FH etc.
    static final byte EK_REPL = 5;     // NH[...] etc.
    static final byte EK_REF  = 6;     // RUH, RUNH, KQH, etc.
    static final byte EK_UN   = 7;     // TB(...)[...] etc.
    static final byte EK_CASE = 8;     // (...)[...] etc.
    static final byte EK_CALL = 9;     // (0), (1), etc.
    static final byte EK_CBLE = 10;    // [...][...] etc.
    static final byte EF_SIGN  = 1&lt;&lt;0;   // INT is signed
    static final byte EF_DELTA = 1&lt;&lt;1;   // BCI/BCI value is diff'ed w/ previous
    static final byte EF_NULL  = 1&lt;&lt;2;   // null REF is expected/allowed
    static final byte EF_BACK  = 1&lt;&lt;3;   // call, callable, case is backward
    static final int NO_BAND_INDEX = -1;

    /** A &quot;class&quot; of attributes, characterized by a context-type, name
     *  and format.  The formats are specified in a &quot;little language&quot;.
     */
<span class="nc bnc" id="L499" title="All 2 branches missed.">    public static</span>
    class Layout implements Comparable&lt;Layout&gt; {
        int ctype;       // attribute context type, e.g., ATTR_CONTEXT_CODE
        String name;     // name of attribute
        boolean hasRefs; // this kind of attr contains CP refs?
        String layout;   // layout specification
        int bandCount;   // total number of elems
        Element[] elems; // tokenization of layout
        Attribute canon; // canonical instance of this layout

<span class="nc" id="L509">        public int ctype() { return ctype; }</span>
<span class="nc" id="L510">        public String name() { return name; }</span>
<span class="nc" id="L511">        public String layout() { return layout; }</span>
<span class="nc" id="L512">        public Attribute canonicalInstance() { return canon; }</span>

        public Entry getNameRef() {
<span class="nc" id="L515">            return ConstantPool.getUtf8Entry(name());</span>
        }

        public boolean isEmpty() {
<span class="nc" id="L519">            return layout.isEmpty();</span>
        }

<span class="nc" id="L522">        public Layout(int ctype, String name, String layout) {</span>
<span class="nc" id="L523">            this.ctype = ctype;</span>
<span class="nc" id="L524">            this.name = name.intern();</span>
<span class="nc" id="L525">            this.layout = layout.intern();</span>
<span class="nc bnc" id="L526" title="All 4 branches missed.">            assert(ctype &lt; ATTR_CONTEXT_LIMIT);</span>
<span class="nc" id="L527">            boolean hasCallables = layout.startsWith(&quot;[&quot;);</span>
            try {
<span class="nc bnc" id="L529" title="All 2 branches missed.">                if (!hasCallables) {</span>
<span class="nc" id="L530">                    this.elems = tokenizeLayout(this, -1, layout);</span>
                } else {
<span class="nc" id="L532">                    String[] bodies = splitBodies(layout);</span>
                    // Make the callables now, so they can be linked immediately.
<span class="nc" id="L534">                    Element[] lelems = new Element[bodies.length];</span>
<span class="nc" id="L535">                    this.elems = lelems;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                    for (int i = 0; i &lt; lelems.length; i++) {</span>
<span class="nc" id="L537">                        Element ce = this.new Element();</span>
<span class="nc" id="L538">                        ce.kind = EK_CBLE;</span>
<span class="nc" id="L539">                        ce.removeBand();</span>
<span class="nc" id="L540">                        ce.bandIndex = NO_BAND_INDEX;</span>
<span class="nc" id="L541">                        ce.layout = bodies[i];</span>
<span class="nc" id="L542">                        lelems[i] = ce;</span>
                    }
                    // Next fill them in.
<span class="nc bnc" id="L545" title="All 2 branches missed.">                    for (int i = 0; i &lt; lelems.length; i++) {</span>
<span class="nc" id="L546">                        Element ce = lelems[i];</span>
<span class="nc" id="L547">                        ce.body = tokenizeLayout(this, i, bodies[i]);</span>
                    }
                    //System.out.println(Arrays.asList(elems));
                }
<span class="nc" id="L551">            } catch (StringIndexOutOfBoundsException ee) {</span>
                // simplest way to catch syntax errors...
<span class="nc" id="L553">                throw new RuntimeException(&quot;Bad attribute layout: &quot;+layout, ee);</span>
<span class="nc" id="L554">            }</span>
            // Some uses do not make a fresh one for each occurrence.
            // For example, if layout == &quot;&quot;, we only need one attr to share.
<span class="nc" id="L557">            canon = new Attribute(this, noBytes);</span>
<span class="nc" id="L558">        }</span>
<span class="nc" id="L559">        private Layout() {}</span>
        static Layout makeKey(int ctype, String name, String layout) {
<span class="nc" id="L561">            Layout def = new Layout();</span>
<span class="nc" id="L562">            def.ctype = ctype;</span>
<span class="nc" id="L563">            def.name = name.intern();</span>
<span class="nc" id="L564">            def.layout = layout.intern();</span>
<span class="nc bnc" id="L565" title="All 4 branches missed.">            assert(ctype &lt; ATTR_CONTEXT_LIMIT);</span>
<span class="nc" id="L566">            return def;</span>
        }
        static Layout makeKey(int ctype, String name) {
<span class="nc" id="L569">            return makeKey(ctype, name, &quot;&quot;);</span>
        }

        public Attribute addContent(byte[] bytes, Object fixups) {
<span class="nc" id="L573">            return canon.addContent(bytes, fixups);</span>
        }
        public Attribute addContent(byte[] bytes) {
<span class="nc" id="L576">            return canon.addContent(bytes, null);</span>
        }

        @Override
        public boolean equals(Object x) {
<span class="nc bnc" id="L581" title="All 4 branches missed.">            return ( x != null) &amp;&amp; ( x.getClass() == Layout.class ) &amp;&amp;</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                    equals((Layout)x);</span>
        }
        public boolean equals(Layout that) {
<span class="nc bnc" id="L585" title="All 2 branches missed.">            return this.name.equals(that.name)</span>
<span class="nc bnc" id="L586" title="All 4 branches missed.">                &amp;&amp; this.layout.equals(that.layout)</span>
                &amp;&amp; this.ctype == that.ctype;
        }
        @Override
        public int hashCode() {
<span class="nc" id="L591">            return (((17 + name.hashCode())</span>
<span class="nc" id="L592">                    * 37 + layout.hashCode())</span>
                    * 37 + ctype);
        }
        @Override
        public int compareTo(Layout that) {
            int r;
<span class="nc" id="L598">            r = this.name.compareTo(that.name);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">            if (r != 0)  return r;</span>
<span class="nc" id="L600">            r = this.layout.compareTo(that.layout);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">            if (r != 0)  return r;</span>
<span class="nc" id="L602">            return this.ctype - that.ctype;</span>
        }
        @Override
        public String toString() {
<span class="nc" id="L606">            String str = contextName(ctype)+&quot;.&quot;+name+&quot;[&quot;+layout+&quot;]&quot;;</span>
            // If -ea, print out more informative strings!
<span class="nc bnc" id="L608" title="All 4 branches missed.">            assert((str = stringForDebug()) != null);</span>
<span class="nc" id="L609">            return str;</span>
        }
        private String stringForDebug() {
<span class="nc" id="L612">            return contextName(ctype)+&quot;.&quot;+name+Arrays.asList(elems);</span>
        }

<span class="nc bnc" id="L615" title="All 2 branches missed.">        public</span>
        class Element {
            String layout;   // spelling in the little language
            byte flags;      // EF_SIGN, etc.
            byte kind;       // EK_UINT, etc.
            byte len;        // scalar length of element
            byte refKind;    // CONSTANT_String, etc.
            int bandIndex;   // which band does this element govern?
            int value;       // extra parameter
            Element[] body;  // extra data (for replications, unions, calls)

<span class="nc bnc" id="L626" title="All 2 branches missed.">            boolean flagTest(byte mask) { return (flags &amp; mask) != 0; }</span>

<span class="nc" id="L628">            Element() {</span>
<span class="nc" id="L629">                bandIndex = bandCount++;</span>
<span class="nc" id="L630">            }</span>

            void removeBand() {
<span class="nc" id="L633">                --bandCount;</span>
<span class="nc bnc" id="L634" title="All 4 branches missed.">                assert(bandIndex == bandCount);</span>
<span class="nc" id="L635">                bandIndex = NO_BAND_INDEX;</span>
<span class="nc" id="L636">            }</span>

            public boolean hasBand() {
<span class="nc bnc" id="L639" title="All 2 branches missed.">                return bandIndex &gt;= 0;</span>
            }
            public String toString() {
<span class="nc" id="L642">                String str = layout;</span>
                // If -ea, print out more informative strings!
<span class="nc bnc" id="L644" title="All 4 branches missed.">                assert((str = stringForDebug()) != null);</span>
<span class="nc" id="L645">                return str;</span>
            }
            private String stringForDebug() {
<span class="nc" id="L648">                Element[] lbody = this.body;</span>
<span class="nc bnc" id="L649" title="All 3 branches missed.">                switch (kind) {</span>
                case EK_CALL:
<span class="nc" id="L651">                    lbody = null;</span>
<span class="nc" id="L652">                    break;</span>
                case EK_CASE:
<span class="nc bnc" id="L654" title="All 2 branches missed.">                    if (flagTest(EF_BACK))</span>
<span class="nc" id="L655">                        lbody = null;</span>
                    break;
                }
<span class="nc" id="L658">                return layout</span>
<span class="nc bnc" id="L659" title="All 10 branches missed.">                    + (!hasBand()?&quot;&quot;:&quot;#&quot;+bandIndex)</span>
                    + &quot;&lt;&quot;+ (flags==0?&quot;&quot;:&quot;&quot;+flags)+kind+len
                    + (refKind==0?&quot;&quot;:&quot;&quot;+refKind) + &quot;&gt;&quot;
                    + (value==0?&quot;&quot;:&quot;(&quot;+value+&quot;)&quot;)
<span class="nc" id="L663">                    + (lbody==null?&quot;&quot;: &quot;&quot;+Arrays.asList(lbody));</span>
            }
        }

        public boolean hasCallables() {
<span class="nc bnc" id="L668" title="All 4 branches missed.">            return (elems.length &gt; 0 &amp;&amp; elems[0].kind == EK_CBLE);</span>
        }
<span class="nc" id="L670">        static private final Element[] noElems = {};</span>
        public Element[] getCallables() {
<span class="nc bnc" id="L672" title="All 2 branches missed.">            if (hasCallables()) {</span>
<span class="nc" id="L673">                Element[] nelems = Arrays.copyOf(elems, elems.length);</span>
<span class="nc" id="L674">                return nelems;</span>
            } else
<span class="nc" id="L676">                return noElems;  // no callables at all</span>
        }
        public Element[] getEntryPoint() {
<span class="nc bnc" id="L679" title="All 2 branches missed.">            if (hasCallables())</span>
<span class="nc" id="L680">                return elems[0].body;  // body of first callable</span>
            else {
<span class="nc" id="L682">                Element[] nelems = Arrays.copyOf(elems, elems.length);</span>
<span class="nc" id="L683">                return nelems;  // no callables; whole body</span>
            }
        }

        /** Return a sequence of tokens from the given attribute bytes.
         *  Sequence elements will be 1-1 correspondent with my layout tokens.
         */
        public void parse(Holder holder,
                          byte[] bytes, int pos, int len, ValueStream out) {
<span class="nc" id="L692">            int end = parseUsing(getEntryPoint(),</span>
                                 holder, bytes, pos, len, out);
<span class="nc bnc" id="L694" title="All 2 branches missed.">            if (end != pos + len)</span>
<span class="nc" id="L695">                throw new InternalError(&quot;layout parsed &quot;+(end-pos)+&quot; out of &quot;+len+&quot; bytes&quot;);</span>
<span class="nc" id="L696">        }</span>
        /** Given a sequence of tokens, return the attribute bytes.
         *  Sequence elements must be 1-1 correspondent with my layout tokens.
         *  The returned object is a cookie for Fixups.finishRefs, which
         *  must be used to harden any references into integer indexes.
         */
        public Object unparse(ValueStream in, ByteArrayOutputStream out) {
<span class="nc" id="L703">            Object[] fixups = { null };</span>
<span class="nc" id="L704">            unparseUsing(getEntryPoint(), fixups, in, out);</span>
<span class="nc" id="L705">            return fixups[0]; // return ref-bearing cookie, if any</span>
        }

        public String layoutForClassVersion(Package.Version vers) {
<span class="nc bnc" id="L709" title="All 2 branches missed.">            if (vers.lessThan(JAVA6_MAX_CLASS_VERSION)) {</span>
                // Disallow layout syntax in the oldest protocol version.
<span class="nc" id="L711">                return expandCaseDashNotation(layout);</span>
            }
<span class="nc" id="L713">            return layout;</span>
        }
    }

    public static
    class FormatException extends IOException {
        private static final long serialVersionUID = -2542243830788066513L;

        private int ctype;
        private String name;
        String layout;
        public FormatException(String message,
                               int ctype, String name, String layout) {
<span class="nc bnc" id="L726" title="All 2 branches missed.">            super(ATTR_CONTEXT_NAME[ctype]+ &quot; attribute \&quot;&quot; + name + &quot;\&quot;&quot; +</span>
                  (message == null? &quot;&quot; : (&quot;: &quot; + message)));
<span class="nc" id="L728">            this.ctype = ctype;</span>
<span class="nc" id="L729">            this.name = name;</span>
<span class="nc" id="L730">            this.layout = layout;</span>
<span class="nc" id="L731">        }</span>
        public FormatException(String message,
                               int ctype, String name) {
<span class="nc" id="L734">            this(message, ctype, name, null);</span>
<span class="nc" id="L735">        }</span>
    }

    void visitRefs(Holder holder, int mode, final Collection&lt;Entry&gt; refs) {
<span class="nc bnc" id="L739" title="All 2 branches missed.">        if (mode == VRM_CLASSIC) {</span>
<span class="nc" id="L740">            refs.add(getNameRef());</span>
        }
        // else the name is owned by the layout, and is processed elsewhere
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (bytes.length == 0)  return;  // quick exit</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if (!def.hasRefs)       return;  // quick exit</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        if (fixups != null) {</span>
<span class="nc" id="L746">            Fixups.visitRefs(fixups, refs);</span>
<span class="nc" id="L747">            return;</span>
        }
        // References (to a local cpMap) are embedded in the bytes.
<span class="nc" id="L750">        def.parse(holder, bytes, 0, bytes.length,</span>
<span class="nc" id="L751">            new ValueStream() {</span>
                @Override
                public void putInt(int bandIndex, int value) {
<span class="nc" id="L754">                }</span>
                @Override
                public void putRef(int bandIndex, Entry ref) {
<span class="nc" id="L757">                    refs.add(ref);</span>
<span class="nc" id="L758">                }</span>
                @Override
                public int encodeBCI(int bci) {
<span class="nc" id="L761">                    return bci;</span>
                }
            });
<span class="nc" id="L764">    }</span>

    public void parse(Holder holder, byte[] bytes, int pos, int len, ValueStream out) {
<span class="nc" id="L767">        def.parse(holder, bytes, pos, len, out);</span>
<span class="nc" id="L768">    }</span>
    public Object unparse(ValueStream in, ByteArrayOutputStream out) {
<span class="nc" id="L770">        return def.unparse(in, out);</span>
    }

    @Override
    public String toString() {
<span class="nc bnc" id="L775" title="All 2 branches missed.">        return def</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">            +&quot;{&quot;+(bytes == null ? -1 : size())+&quot;}&quot;</span>
<span class="nc" id="L777">            +(fixups == null? &quot;&quot;: fixups.toString());</span>
    }

    /** Remove any informal &quot;pretty printing&quot; from the layout string.
     *  Removes blanks and control chars.
     *  Removes '#' comments (to end of line).
     *  Replaces '\c' by the decimal code of the character c.
     *  Replaces '0xNNN' by the decimal code of the hex number NNN.
     */
    static public
    String normalizeLayoutString(String layout) {
<span class="nc" id="L788">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">        for (int i = 0, len = layout.length(); i &lt; len; ) {</span>
<span class="nc" id="L790">            char ch = layout.charAt(i++);</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">            if (ch &lt;= ' ') {</span>
                // Skip whitespace and control chars
<span class="nc" id="L793">                continue;</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">            } else if (ch == '#') {</span>
                // Skip to end of line.
<span class="nc" id="L796">                int end1 = layout.indexOf('\n', i);</span>
<span class="nc" id="L797">                int end2 = layout.indexOf('\r', i);</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">                if (end1 &lt; 0)  end1 = len;</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">                if (end2 &lt; 0)  end2 = len;</span>
<span class="nc" id="L800">                i = Math.min(end1, end2);</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">            } else if (ch == '\\') {</span>
                // Map a character reference to its decimal code.
<span class="nc" id="L803">                buf.append((int) layout.charAt(i++));</span>
<span class="nc bnc" id="L804" title="All 4 branches missed.">            } else if (ch == '0' &amp;&amp; layout.startsWith(&quot;0x&quot;, i-1)) {</span>
                // Map a hex numeral to its decimal code.
<span class="nc" id="L806">                int start = i-1;</span>
<span class="nc" id="L807">                int end = start+2;</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">                while (end &lt; len) {</span>
<span class="nc" id="L809">                    int dig = layout.charAt(end);</span>
<span class="nc bnc" id="L810" title="All 8 branches missed.">                    if ((dig &gt;= '0' &amp;&amp; dig &lt;= '9') ||</span>
                        (dig &gt;= 'a' &amp;&amp; dig &lt;= 'f'))
<span class="nc" id="L812">                        ++end;</span>
                    else
                        break;
<span class="nc" id="L815">                }</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">                if (end &gt; start) {</span>
<span class="nc" id="L817">                    String num = layout.substring(start, end);</span>
<span class="nc" id="L818">                    buf.append(Integer.decode(num));</span>
<span class="nc" id="L819">                    i = end;</span>
<span class="nc" id="L820">                } else {</span>
<span class="nc" id="L821">                    buf.append(ch);</span>
                }
<span class="nc" id="L823">            } else {</span>
<span class="nc" id="L824">                buf.append(ch);</span>
            }
<span class="nc" id="L826">        }</span>
<span class="nc" id="L827">        String result = buf.toString();</span>
        if (false &amp;&amp; !result.equals(layout)) {
            Utils.log.info(&quot;Normalizing layout string&quot;);
            Utils.log.info(&quot;    From: &quot;+layout);
            Utils.log.info(&quot;    To:   &quot;+result);
        }
<span class="nc" id="L833">        return result;</span>
    }

    /// Subroutines for parsing and unparsing:

    /** Parse the attribute layout language.
&lt;pre&gt;
  attribute_layout:
        ( layout_element )* | ( callable )+
  layout_element:
        ( integral | replication | union | call | reference )

  callable:
        '[' body ']'
  body:
        ( layout_element )+

  integral:
        ( unsigned_int | signed_int | bc_index | bc_offset | flag )
  unsigned_int:
        uint_type
  signed_int:
        'S' uint_type
  any_int:
        ( unsigned_int | signed_int )
  bc_index:
        ( 'P' uint_type | 'PO' uint_type )
  bc_offset:
        'O' any_int
  flag:
        'F' uint_type
  uint_type:
        ( 'B' | 'H' | 'I' | 'V' )

  replication:
        'N' uint_type '[' body ']'

  union:
        'T' any_int (union_case)* '(' ')' '[' (body)? ']'
  union_case:
        '(' union_case_tag (',' union_case_tag)* ')' '[' (body)? ']'
  union_case_tag:
        ( numeral | numeral '-' numeral )
  call:
        '(' numeral ')'

  reference:
        reference_type ( 'N' )? uint_type
  reference_type:
        ( constant_ref | schema_ref | utf8_ref | untyped_ref )
  constant_ref:
        ( 'KI' | 'KJ' | 'KF' | 'KD' | 'KS' | 'KQ' | 'KM' | 'KT' | 'KL' )
  schema_ref:
        ( 'RC' | 'RS' | 'RD' | 'RF' | 'RM' | 'RI' | 'RY' | 'RB' | 'RN' )
  utf8_ref:
        'RU'
  untyped_ref:
        'RQ'

  numeral:
        '(' ('-')? (digit)+ ')'
  digit:
        ( '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' )
 &lt;/pre&gt;
    */
    static //private
    Layout.Element[] tokenizeLayout(Layout self, int curCble, String layout) {
<span class="nc" id="L900">        List&lt;Layout.Element&gt; col = new ArrayList&lt;&gt;(layout.length());</span>
<span class="nc" id="L901">        tokenizeLayout(self, curCble, layout, col);</span>
<span class="nc" id="L902">        Layout.Element[] res = new Layout.Element[col.size()];</span>
<span class="nc" id="L903">        col.toArray(res);</span>
<span class="nc" id="L904">        return res;</span>
    }
    static //private
    void tokenizeLayout(Layout self, int curCble, String layout, List&lt;Layout.Element&gt; col) {
<span class="nc" id="L908">        boolean prevBCI = false;</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">        for (int len = layout.length(), i = 0; i &lt; len; ) {</span>
<span class="nc" id="L910">            int start = i;</span>
            int body;
<span class="nc" id="L912">            Layout.Element e = self.new Element();</span>
            byte kind;
            //System.out.println(&quot;at &quot;+i+&quot;: ...&quot;+layout.substring(i));
            // strip a prefix
<span class="nc bnc" id="L916" title="All 11 branches missed.">            switch (layout.charAt(i++)) {</span>
            /// layout_element: integral
            case 'B': case 'H': case 'I': case 'V': // unsigned_int
<span class="nc" id="L919">                kind = EK_INT;</span>
<span class="nc" id="L920">                --i; // reparse</span>
<span class="nc" id="L921">                i = tokenizeUInt(e, layout, i);</span>
<span class="nc" id="L922">                break;</span>
            case 'S': // signed_int
<span class="nc" id="L924">                kind = EK_INT;</span>
<span class="nc" id="L925">                --i; // reparse</span>
<span class="nc" id="L926">                i = tokenizeSInt(e, layout, i);</span>
<span class="nc" id="L927">                break;</span>
            case 'P': // bc_index
<span class="nc" id="L929">                kind = EK_BCI;</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">                if (layout.charAt(i++) == 'O') {</span>
                    // bc_index: 'PO' tokenizeUInt
<span class="nc" id="L932">                    e.flags |= EF_DELTA;</span>
                    // must follow P or PO:
<span class="nc bnc" id="L934" title="All 2 branches missed.">                    if (!prevBCI)</span>
<span class="nc" id="L935">                        { i = -i; continue; } // fail</span>
<span class="nc" id="L936">                    i++; // move forward</span>
                }
<span class="nc" id="L938">                --i; // reparse</span>
<span class="nc" id="L939">                i = tokenizeUInt(e, layout, i);</span>
<span class="nc" id="L940">                break;</span>
            case 'O': // bc_offset
<span class="nc" id="L942">                kind = EK_BCO;</span>
<span class="nc" id="L943">                e.flags |= EF_DELTA;</span>
                // must follow P or PO:
<span class="nc bnc" id="L945" title="All 2 branches missed.">                if (!prevBCI)</span>
<span class="nc" id="L946">                    { i = -i; continue; } // fail</span>
<span class="nc" id="L947">                i = tokenizeSInt(e, layout, i);</span>
<span class="nc" id="L948">                break;</span>
            case 'F': // flag
<span class="nc" id="L950">                kind = EK_FLAG;</span>
<span class="nc" id="L951">                i = tokenizeUInt(e, layout, i);</span>
<span class="nc" id="L952">                break;</span>
            case 'N': // replication: 'N' uint '[' elem ... ']'
<span class="nc" id="L954">                kind = EK_REPL;</span>
<span class="nc" id="L955">                i = tokenizeUInt(e, layout, i);</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">                if (layout.charAt(i++) != '[')</span>
<span class="nc" id="L957">                    { i = -i; continue; } // fail</span>
<span class="nc" id="L958">                i = skipBody(layout, body = i);</span>
<span class="nc" id="L959">                e.body = tokenizeLayout(self, curCble,</span>
<span class="nc" id="L960">                                        layout.substring(body, i++));</span>
<span class="nc" id="L961">                break;</span>
            case 'T': // union: 'T' any_int union_case* '(' ')' '[' body ']'
<span class="nc" id="L963">                kind = EK_UN;</span>
<span class="nc" id="L964">                i = tokenizeSInt(e, layout, i);</span>
<span class="nc" id="L965">                List&lt;Layout.Element&gt; cases = new ArrayList&lt;&gt;();</span>
                for (;;) {
                    // Keep parsing cases until we hit the default case.
<span class="nc bnc" id="L968" title="All 2 branches missed.">                    if (layout.charAt(i++) != '(')</span>
<span class="nc" id="L969">                        { i = -i; break; } // fail</span>
<span class="nc" id="L970">                    int beg = i;</span>
<span class="nc" id="L971">                    i = layout.indexOf(')', i);</span>
<span class="nc" id="L972">                    String cstr = layout.substring(beg, i++);</span>
<span class="nc" id="L973">                    int cstrlen = cstr.length();</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">                    if (layout.charAt(i++) != '[')</span>
<span class="nc" id="L975">                        { i = -i; break; } // fail</span>
                    // Check for duplication.
<span class="nc bnc" id="L977" title="All 2 branches missed.">                    if (layout.charAt(i) == ']')</span>
<span class="nc" id="L978">                        body = i;  // missing body, which is legal here</span>
                    else
<span class="nc" id="L980">                        i = skipBody(layout, body = i);</span>
<span class="nc" id="L981">                    Layout.Element[] cbody</span>
<span class="nc" id="L982">                        = tokenizeLayout(self, curCble,</span>
<span class="nc" id="L983">                                         layout.substring(body, i++));</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">                    if (cstrlen == 0) {</span>
<span class="nc" id="L985">                        Layout.Element ce = self.new Element();</span>
<span class="nc" id="L986">                        ce.body = cbody;</span>
<span class="nc" id="L987">                        ce.kind = EK_CASE;</span>
<span class="nc" id="L988">                        ce.removeBand();</span>
<span class="nc" id="L989">                        cases.add(ce);</span>
<span class="nc" id="L990">                        break;  // done with the whole union</span>
                    } else {
                        // Parse a case string.
<span class="nc" id="L993">                        boolean firstCaseNum = true;</span>
<span class="nc" id="L994">                        for (int cp = 0, endp;; cp = endp+1) {</span>
                            // Look for multiple case tags:
<span class="nc" id="L996">                            endp = cstr.indexOf(',', cp);</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">                            if (endp &lt; 0)  endp = cstrlen;</span>
<span class="nc" id="L998">                            String cstr1 = cstr.substring(cp, endp);</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">                            if (cstr1.length() == 0)</span>
<span class="nc" id="L1000">                                cstr1 = &quot;empty&quot;;  // will fail parse</span>
                            int value0, value1;
                            // Check for a case range (new in 1.6).
<span class="nc" id="L1003">                            int dash = findCaseDash(cstr1, 0);</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">                            if (dash &gt;= 0) {</span>
<span class="nc" id="L1005">                                value0 = parseIntBefore(cstr1, dash);</span>
<span class="nc" id="L1006">                                value1 = parseIntAfter(cstr1, dash);</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">                                if (value0 &gt;= value1)</span>
<span class="nc" id="L1008">                                    { i = -i; break; } // fail</span>
                            } else {
<span class="nc" id="L1010">                                value0 = value1 = Integer.parseInt(cstr1);</span>
                            }
                            // Add a case for each value in value0..value1
<span class="nc" id="L1013">                            for (;; value0++) {</span>
<span class="nc" id="L1014">                                Layout.Element ce = self.new Element();</span>
<span class="nc" id="L1015">                                ce.body = cbody;  // all cases share one body</span>
<span class="nc" id="L1016">                                ce.kind = EK_CASE;</span>
<span class="nc" id="L1017">                                ce.removeBand();</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">                                if (!firstCaseNum)</span>
                                    // &quot;backward case&quot; repeats a body
<span class="nc" id="L1020">                                    ce.flags |= EF_BACK;</span>
<span class="nc" id="L1021">                                firstCaseNum = false;</span>
<span class="nc" id="L1022">                                ce.value = value0;</span>
<span class="nc" id="L1023">                                cases.add(ce);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                                if (value0 == value1)  break;</span>
                            }
<span class="nc bnc" id="L1026" title="All 2 branches missed.">                            if (endp == cstrlen) {</span>
<span class="nc" id="L1027">                                break;  // done with this case</span>
                            }
                        }
                    }
<span class="nc" id="L1031">                }</span>
<span class="nc" id="L1032">                e.body = new Layout.Element[cases.size()];</span>
<span class="nc" id="L1033">                cases.toArray(e.body);</span>
<span class="nc" id="L1034">                e.kind = kind;</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">                for (int j = 0; j &lt; e.body.length-1; j++) {</span>
<span class="nc" id="L1036">                    Layout.Element ce = e.body[j];</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">                    if (matchCase(e, ce.value) != ce) {</span>
                        // Duplicate tag.
<span class="nc" id="L1039">                        { i = -i; break; } // fail</span>
                    }
                }
<span class="nc" id="L1042">                break;</span>
            case '(': // call: '(' '-'? digit+ ')'
<span class="nc" id="L1044">                kind = EK_CALL;</span>
<span class="nc" id="L1045">                e.removeBand();</span>
<span class="nc" id="L1046">                i = layout.indexOf(')', i);</span>
<span class="nc" id="L1047">                String cstr = layout.substring(start+1, i++);</span>
<span class="nc" id="L1048">                int offset = Integer.parseInt(cstr);</span>
<span class="nc" id="L1049">                int target = curCble + offset;</span>
<span class="nc bnc" id="L1050" title="All 8 branches missed.">                if (!(offset+&quot;&quot;).equals(cstr) ||</span>
                    self.elems == null ||
                    target &lt; 0 ||
                    target &gt;= self.elems.length)
<span class="nc" id="L1054">                    { i = -i; continue; } // fail</span>
<span class="nc" id="L1055">                Layout.Element ce = self.elems[target];</span>
<span class="nc bnc" id="L1056" title="All 4 branches missed.">                assert(ce.kind == EK_CBLE);</span>
<span class="nc" id="L1057">                e.value = target;</span>
<span class="nc" id="L1058">                e.body = new Layout.Element[]{ ce };</span>
                // Is it a (recursive) backward call?
<span class="nc bnc" id="L1060" title="All 2 branches missed.">                if (offset &lt;= 0) {</span>
                    // Yes.  Mark both caller and callee backward.
<span class="nc" id="L1062">                    e.flags  |= EF_BACK;</span>
<span class="nc" id="L1063">                    ce.flags |= EF_BACK;</span>
                }
                break;
            case 'K':  // reference_type: constant_ref
<span class="nc" id="L1067">                kind = EK_REF;</span>
<span class="nc bnc" id="L1068" title="All 10 branches missed.">                switch (layout.charAt(i++)) {</span>
<span class="nc" id="L1069">                case 'I': e.refKind = CONSTANT_Integer; break;</span>
<span class="nc" id="L1070">                case 'J': e.refKind = CONSTANT_Long; break;</span>
<span class="nc" id="L1071">                case 'F': e.refKind = CONSTANT_Float; break;</span>
<span class="nc" id="L1072">                case 'D': e.refKind = CONSTANT_Double; break;</span>
<span class="nc" id="L1073">                case 'S': e.refKind = CONSTANT_String; break;</span>
<span class="nc" id="L1074">                case 'Q': e.refKind = CONSTANT_FieldSpecific; break;</span>

                // new in 1.7:
<span class="nc" id="L1077">                case 'M': e.refKind = CONSTANT_MethodHandle; break;</span>
<span class="nc" id="L1078">                case 'T': e.refKind = CONSTANT_MethodType; break;</span>
<span class="nc" id="L1079">                case 'L': e.refKind = CONSTANT_LoadableValue; break;</span>
<span class="nc" id="L1080">                default: { i = -i; continue; } // fail</span>
                }
                break;
            case 'R': // schema_ref
<span class="nc" id="L1084">                kind = EK_REF;</span>
<span class="nc bnc" id="L1085" title="All 12 branches missed.">                switch (layout.charAt(i++)) {</span>
<span class="nc" id="L1086">                case 'C': e.refKind = CONSTANT_Class; break;</span>
<span class="nc" id="L1087">                case 'S': e.refKind = CONSTANT_Signature; break;</span>
<span class="nc" id="L1088">                case 'D': e.refKind = CONSTANT_NameandType; break;</span>
<span class="nc" id="L1089">                case 'F': e.refKind = CONSTANT_Fieldref; break;</span>
<span class="nc" id="L1090">                case 'M': e.refKind = CONSTANT_Methodref; break;</span>
<span class="nc" id="L1091">                case 'I': e.refKind = CONSTANT_InterfaceMethodref; break;</span>

<span class="nc" id="L1093">                case 'U': e.refKind = CONSTANT_Utf8; break; //utf8_ref</span>
<span class="nc" id="L1094">                case 'Q': e.refKind = CONSTANT_All; break; //untyped_ref</span>

                // new in 1.7:
<span class="nc" id="L1097">                case 'Y': e.refKind = CONSTANT_InvokeDynamic; break;</span>
<span class="nc" id="L1098">                case 'B': e.refKind = CONSTANT_BootstrapMethod; break;</span>
<span class="nc" id="L1099">                case 'N': e.refKind = CONSTANT_AnyMember; break;</span>

<span class="nc" id="L1101">                default: { i = -i; continue; } // fail</span>
                }
                break;
<span class="nc" id="L1104">            default: { i = -i; continue; } // fail</span>
            }

            // further parsing of refs
<span class="nc bnc" id="L1108" title="All 2 branches missed.">            if (kind == EK_REF) {</span>
                // reference: reference_type -&gt;&lt;- ( 'N' )? tokenizeUInt
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                if (layout.charAt(i++) == 'N') {</span>
<span class="nc" id="L1111">                    e.flags |= EF_NULL;</span>
<span class="nc" id="L1112">                    i++; // move forward</span>
                }
<span class="nc" id="L1114">                --i; // reparse</span>
<span class="nc" id="L1115">                i = tokenizeUInt(e, layout, i);</span>
<span class="nc" id="L1116">                self.hasRefs = true;</span>
            }

<span class="nc bnc" id="L1119" title="All 2 branches missed.">            prevBCI = (kind == EK_BCI);</span>

            // store the new element
<span class="nc" id="L1122">            e.kind = kind;</span>
<span class="nc" id="L1123">            e.layout = layout.substring(start, i);</span>
<span class="nc" id="L1124">            col.add(e);</span>
<span class="nc" id="L1125">        }</span>
<span class="nc" id="L1126">    }</span>
    static //private
    String[] splitBodies(String layout) {
<span class="nc" id="L1129">        List&lt;String&gt; bodies = new ArrayList&lt;&gt;();</span>
        // Parse several independent layout bodies:  &quot;[foo][bar]...[baz]&quot;
<span class="nc bnc" id="L1131" title="All 2 branches missed.">        for (int i = 0; i &lt; layout.length(); i++) {</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">            if (layout.charAt(i++) != '[')</span>
<span class="nc" id="L1133">                layout.charAt(-i);  // throw error</span>
            int body;
<span class="nc" id="L1135">            i = skipBody(layout, body = i);</span>
<span class="nc" id="L1136">            bodies.add(layout.substring(body, i));</span>
        }
<span class="nc" id="L1138">        String[] res = new String[bodies.size()];</span>
<span class="nc" id="L1139">        bodies.toArray(res);</span>
<span class="nc" id="L1140">        return res;</span>
    }
    static private
    int skipBody(String layout, int i) {
<span class="nc bnc" id="L1144" title="All 4 branches missed.">        assert(layout.charAt(i-1) == '[');</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        if (layout.charAt(i) == ']')</span>
            // No empty bodies, please.
<span class="nc" id="L1147">            return -i;</span>
        // skip balanced [...[...]...]
<span class="nc bnc" id="L1149" title="All 2 branches missed.">        for (int depth = 1; depth &gt; 0; ) {</span>
<span class="nc bnc" id="L1150" title="All 3 branches missed.">            switch (layout.charAt(i++)) {</span>
<span class="nc" id="L1151">            case '[': depth++; break;</span>
<span class="nc" id="L1152">            case ']': depth--; break;</span>
            }
        }
<span class="nc" id="L1155">        --i;  // get before bracket</span>
<span class="nc bnc" id="L1156" title="All 4 branches missed.">        assert(layout.charAt(i) == ']');</span>
<span class="nc" id="L1157">        return i;  // return closing bracket</span>
    }
    static private
    int tokenizeUInt(Layout.Element e, String layout, int i) {
<span class="nc bnc" id="L1161" title="All 5 branches missed.">        switch (layout.charAt(i++)) {</span>
<span class="nc" id="L1162">        case 'V': e.len = 0; break;</span>
<span class="nc" id="L1163">        case 'B': e.len = 1; break;</span>
<span class="nc" id="L1164">        case 'H': e.len = 2; break;</span>
<span class="nc" id="L1165">        case 'I': e.len = 4; break;</span>
<span class="nc" id="L1166">        default: return -i;</span>
        }
<span class="nc" id="L1168">        return i;</span>
    }
    static private
    int tokenizeSInt(Layout.Element e, String layout, int i) {
<span class="nc bnc" id="L1172" title="All 2 branches missed.">        if (layout.charAt(i) == 'S') {</span>
<span class="nc" id="L1173">            e.flags |= EF_SIGN;</span>
<span class="nc" id="L1174">            ++i;</span>
        }
<span class="nc" id="L1176">        return tokenizeUInt(e, layout, i);</span>
    }

    static private
    boolean isDigit(char c) {
<span class="nc bnc" id="L1181" title="All 4 branches missed.">        return c &gt;= '0' &amp;&amp; c &lt;= '9';</span>
    }

    /** Find an occurrence of hyphen '-' between two numerals. */
    static //private
    int findCaseDash(String layout, int fromIndex) {
<span class="nc bnc" id="L1187" title="All 2 branches missed.">        if (fromIndex &lt;= 0)  fromIndex = 1;  // minimum dash pos</span>
<span class="nc" id="L1188">        int lastDash = layout.length() - 2;  // maximum dash pos</span>
        for (;;) {
<span class="nc" id="L1190">            int dash = layout.indexOf('-', fromIndex);</span>
<span class="nc bnc" id="L1191" title="All 4 branches missed.">            if (dash &lt; 0 || dash &gt; lastDash)  return -1;</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">            if (isDigit(layout.charAt(dash-1))) {</span>
<span class="nc" id="L1193">                char afterDash = layout.charAt(dash+1);</span>
<span class="nc bnc" id="L1194" title="All 4 branches missed.">                if (afterDash == '-' &amp;&amp; dash+2 &lt; layout.length())</span>
<span class="nc" id="L1195">                    afterDash = layout.charAt(dash+2);</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">                if (isDigit(afterDash)) {</span>
                    // matched /[0-9]--?[0-9]/; return position of dash
<span class="nc" id="L1198">                    return dash;</span>
                }
            }
<span class="nc" id="L1201">            fromIndex = dash+1;</span>
<span class="nc" id="L1202">        }</span>
    }
    static
    int parseIntBefore(String layout, int dash) {
<span class="nc" id="L1206">        int end = dash;</span>
<span class="nc" id="L1207">        int beg = end;</span>
<span class="nc bnc" id="L1208" title="All 4 branches missed.">        while (beg &gt; 0 &amp;&amp; isDigit(layout.charAt(beg-1))) {</span>
<span class="nc" id="L1209">            --beg;</span>
        }
<span class="nc bnc" id="L1211" title="All 2 branches missed.">        if (beg == end)  return Integer.parseInt(&quot;empty&quot;);</span>
        // skip backward over a sign
<span class="nc bnc" id="L1213" title="All 4 branches missed.">        if (beg &gt;= 1 &amp;&amp; layout.charAt(beg-1) == '-')  --beg;</span>
<span class="nc bnc" id="L1214" title="All 6 branches missed.">        assert(beg == 0 || !isDigit(layout.charAt(beg-1)));</span>
<span class="nc" id="L1215">        return Integer.parseInt(layout.substring(beg, end));</span>
    }
    static
    int parseIntAfter(String layout, int dash) {
<span class="nc" id="L1219">        int beg = dash+1;</span>
<span class="nc" id="L1220">        int end = beg;</span>
<span class="nc" id="L1221">        int limit = layout.length();</span>
<span class="nc bnc" id="L1222" title="All 4 branches missed.">        if (end &lt; limit &amp;&amp; layout.charAt(end) == '-')  ++end;</span>
<span class="nc bnc" id="L1223" title="All 4 branches missed.">        while (end &lt; limit &amp;&amp; isDigit(layout.charAt(end))) {</span>
<span class="nc" id="L1224">            ++end;</span>
        }
<span class="nc bnc" id="L1226" title="All 2 branches missed.">        if (beg == end)  return Integer.parseInt(&quot;empty&quot;);</span>
<span class="nc" id="L1227">        return Integer.parseInt(layout.substring(beg, end));</span>
    }
    /** For compatibility with 1.5 pack, expand 1-5 into 1,2,3,4,5. */
    static
    String expandCaseDashNotation(String layout) {
<span class="nc" id="L1232">        int dash = findCaseDash(layout, 0);</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">        if (dash &lt; 0)  return layout;  // no dashes (the common case)</span>
<span class="nc" id="L1234">        StringBuilder result = new StringBuilder(layout.length() * 3);</span>
<span class="nc" id="L1235">        int sofar = 0;  // how far have we processed the layout?</span>
        for (;;) {
            // for each dash, collect everything up to the dash
<span class="nc" id="L1238">            result.append(layout.substring(sofar, dash));</span>
<span class="nc" id="L1239">            sofar = dash+1;  // skip the dash</span>
            // then collect intermediate values
<span class="nc" id="L1241">            int value0 = parseIntBefore(layout, dash);</span>
<span class="nc" id="L1242">            int value1 = parseIntAfter(layout, dash);</span>
<span class="nc bnc" id="L1243" title="All 4 branches missed.">            assert(value0 &lt; value1);</span>
<span class="nc" id="L1244">            result.append(&quot;,&quot;);  // close off value0 numeral</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">            for (int i = value0+1; i &lt; value1; i++) {</span>
<span class="nc" id="L1246">                result.append(i);</span>
<span class="nc" id="L1247">                result.append(&quot;,&quot;);  // close off i numeral</span>
            }
<span class="nc" id="L1249">            dash = findCaseDash(layout, sofar);</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">            if (dash &lt; 0)  break;</span>
<span class="nc" id="L1251">        }</span>
<span class="nc" id="L1252">        result.append(layout.substring(sofar));  // collect the rest</span>
<span class="nc" id="L1253">        return result.toString();</span>
    }
    static {
<span class="nc bnc" id="L1256" title="All 4 branches missed.">        assert(expandCaseDashNotation(&quot;1-5&quot;).equals(&quot;1,2,3,4,5&quot;));</span>
<span class="nc bnc" id="L1257" title="All 4 branches missed.">        assert(expandCaseDashNotation(&quot;-2--1&quot;).equals(&quot;-2,-1&quot;));</span>
<span class="nc bnc" id="L1258" title="All 4 branches missed.">        assert(expandCaseDashNotation(&quot;-2-1&quot;).equals(&quot;-2,-1,0,1&quot;));</span>
<span class="nc bnc" id="L1259" title="All 4 branches missed.">        assert(expandCaseDashNotation(&quot;-1-0&quot;).equals(&quot;-1,0&quot;));</span>
<span class="nc" id="L1260">    }</span>

    // Parse attribute bytes, putting values into bands.  Returns new pos.
    // Used when reading a class file (local refs resolved with local cpMap).
    // Also used for ad hoc scanning.
    static
    int parseUsing(Layout.Element[] elems, Holder holder,
                   byte[] bytes, int pos, int len, ValueStream out) {
<span class="nc" id="L1268">        int prevBCI = 0;</span>
<span class="nc" id="L1269">        int prevRBCI = 0;</span>
<span class="nc" id="L1270">        int end = pos + len;</span>
<span class="nc" id="L1271">        int[] buf = { 0 };  // for calls to parseInt, holds 2nd result</span>
<span class="nc bnc" id="L1272" title="All 2 branches missed.">        for (int i = 0; i &lt; elems.length; i++) {</span>
<span class="nc" id="L1273">            Layout.Element e = elems[i];</span>
<span class="nc" id="L1274">            int bandIndex = e.bandIndex;</span>
            int value;
            int BCI, RBCI;
<span class="nc bnc" id="L1277" title="All 9 branches missed.">            switch (e.kind) {</span>
            case EK_INT:
<span class="nc" id="L1279">                pos = parseInt(e, bytes, pos, buf);</span>
<span class="nc" id="L1280">                value = buf[0];</span>
<span class="nc" id="L1281">                out.putInt(bandIndex, value);</span>
<span class="nc" id="L1282">                break;</span>
            case EK_BCI:  // PH, POH
<span class="nc" id="L1284">                pos = parseInt(e, bytes, pos, buf);</span>
<span class="nc" id="L1285">                BCI = buf[0];</span>
<span class="nc" id="L1286">                RBCI = out.encodeBCI(BCI);</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">                if (!e.flagTest(EF_DELTA)) {</span>
                    // PH:  transmit R(bci), store bci
<span class="nc" id="L1289">                    value = RBCI;</span>
                } else {
                    // POH:  transmit D(R(bci)), store bci
<span class="nc" id="L1292">                    value = RBCI - prevRBCI;</span>
                }
<span class="nc" id="L1294">                prevBCI = BCI;</span>
<span class="nc" id="L1295">                prevRBCI = RBCI;</span>
<span class="nc" id="L1296">                out.putInt(bandIndex, value);</span>
<span class="nc" id="L1297">                break;</span>
            case EK_BCO:  // OH
<span class="nc bnc" id="L1299" title="All 4 branches missed.">                assert(e.flagTest(EF_DELTA));</span>
                // OH:  transmit D(R(bci)), store D(bci)
<span class="nc" id="L1301">                pos = parseInt(e, bytes, pos, buf);</span>
<span class="nc" id="L1302">                BCI = prevBCI + buf[0];</span>
<span class="nc" id="L1303">                RBCI = out.encodeBCI(BCI);</span>
<span class="nc" id="L1304">                value = RBCI - prevRBCI;</span>
<span class="nc" id="L1305">                prevBCI = BCI;</span>
<span class="nc" id="L1306">                prevRBCI = RBCI;</span>
<span class="nc" id="L1307">                out.putInt(bandIndex, value);</span>
<span class="nc" id="L1308">                break;</span>
            case EK_FLAG:
<span class="nc" id="L1310">                pos = parseInt(e, bytes, pos, buf);</span>
<span class="nc" id="L1311">                value = buf[0];</span>
<span class="nc" id="L1312">                out.putInt(bandIndex, value);</span>
<span class="nc" id="L1313">                break;</span>
            case EK_REPL:
<span class="nc" id="L1315">                pos = parseInt(e, bytes, pos, buf);</span>
<span class="nc" id="L1316">                value = buf[0];</span>
<span class="nc" id="L1317">                out.putInt(bandIndex, value);</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">                for (int j = 0; j &lt; value; j++) {</span>
<span class="nc" id="L1319">                    pos = parseUsing(e.body, holder, bytes, pos, end-pos, out);</span>
                }
<span class="nc" id="L1321">                break;  // already transmitted the scalar value</span>
            case EK_UN:
<span class="nc" id="L1323">                pos = parseInt(e, bytes, pos, buf);</span>
<span class="nc" id="L1324">                value = buf[0];</span>
<span class="nc" id="L1325">                out.putInt(bandIndex, value);</span>
<span class="nc" id="L1326">                Layout.Element ce = matchCase(e, value);</span>
<span class="nc" id="L1327">                pos = parseUsing(ce.body, holder, bytes, pos, end-pos, out);</span>

<span class="nc" id="L1329">                break;  // already transmitted the scalar value</span>
            case EK_CALL:
                // Adjust band offset if it is a backward call.
<span class="nc bnc" id="L1332" title="All 4 branches missed.">                assert(e.body.length == 1);</span>
<span class="nc bnc" id="L1333" title="All 4 branches missed.">                assert(e.body[0].kind == EK_CBLE);</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">                if (e.flagTest(EF_BACK))</span>
<span class="nc" id="L1335">                    out.noteBackCall(e.value);</span>
<span class="nc" id="L1336">                pos = parseUsing(e.body[0].body, holder, bytes, pos, end-pos, out);</span>
<span class="nc" id="L1337">                break;  // no additional scalar value to transmit</span>
            case EK_REF:
<span class="nc" id="L1339">                pos = parseInt(e, bytes, pos, buf);</span>
<span class="nc" id="L1340">                int localRef = buf[0];</span>
                Entry globalRef;
<span class="nc bnc" id="L1342" title="All 2 branches missed.">                if (localRef == 0) {</span>
<span class="nc" id="L1343">                    globalRef = null;  // N.B. global null reference is -1</span>
                } else {
<span class="nc" id="L1345">                    Entry[] cpMap = holder.getCPMap();</span>
<span class="nc bnc" id="L1346" title="All 4 branches missed.">                    globalRef = (localRef &gt;= 0 &amp;&amp; localRef &lt; cpMap.length</span>
                                    ? cpMap[localRef]
                                    : null);
<span class="nc" id="L1349">                    byte tag = e.refKind;</span>
<span class="nc bnc" id="L1350" title="All 4 branches missed.">                    if (globalRef != null &amp;&amp; tag == CONSTANT_Signature</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">                        &amp;&amp; globalRef.getTag() == CONSTANT_Utf8) {</span>
                        // Cf. ClassReader.readSignatureRef.
<span class="nc" id="L1353">                        String typeName = globalRef.stringValue();</span>
<span class="nc" id="L1354">                        globalRef = ConstantPool.getSignatureEntry(typeName);</span>
                    }
<span class="nc bnc" id="L1356" title="All 2 branches missed.">                    String got = (globalRef == null</span>
                        ? &quot;invalid CP index&quot;
<span class="nc" id="L1358">                        : &quot;type=&quot; + ConstantPool.tagName(globalRef.tag));</span>
<span class="nc bnc" id="L1359" title="All 4 branches missed.">                    if (globalRef == null || !globalRef.tagMatches(tag)) {</span>
<span class="nc" id="L1360">                        throw new IllegalArgumentException(</span>
                                &quot;Bad constant, expected type=&quot; +
<span class="nc" id="L1362">                                ConstantPool.tagName(tag) + &quot; got &quot; + got);</span>
                    }
                }
<span class="nc" id="L1365">                out.putRef(bandIndex, globalRef);</span>
<span class="nc" id="L1366">                break;</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">            default: assert(false);</span>
            }
        }
<span class="nc" id="L1370">        return pos;</span>
    }

    static
    Layout.Element matchCase(Layout.Element e, int value) {
<span class="nc bnc" id="L1375" title="All 4 branches missed.">        assert(e.kind == EK_UN);</span>
<span class="nc" id="L1376">        int lastj = e.body.length-1;</span>
<span class="nc bnc" id="L1377" title="All 2 branches missed.">        for (int j = 0; j &lt; lastj; j++) {</span>
<span class="nc" id="L1378">            Layout.Element ce = e.body[j];</span>
<span class="nc bnc" id="L1379" title="All 4 branches missed.">            assert(ce.kind == EK_CASE);</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">            if (value == ce.value)</span>
<span class="nc" id="L1381">                return ce;</span>
        }
<span class="nc" id="L1383">        return e.body[lastj];</span>
    }

    static private
    int parseInt(Layout.Element e, byte[] bytes, int pos, int[] buf) {
<span class="nc" id="L1388">        int value = 0;</span>
<span class="nc" id="L1389">        int loBits = e.len * 8;</span>
        // Read in big-endian order:
<span class="nc bnc" id="L1391" title="All 2 branches missed.">        for (int bitPos = loBits; (bitPos -= 8) &gt;= 0; ) {</span>
<span class="nc" id="L1392">            value += (bytes[pos++] &amp; 0xFF) &lt;&lt; bitPos;</span>
        }
<span class="nc bnc" id="L1394" title="All 4 branches missed.">        if (loBits &lt; 32 &amp;&amp; e.flagTest(EF_SIGN)) {</span>
            // sign-extend subword value
<span class="nc" id="L1396">            int hiBits = 32 - loBits;</span>
<span class="nc" id="L1397">            value = (value &lt;&lt; hiBits) &gt;&gt; hiBits;</span>
        }
<span class="nc" id="L1399">        buf[0] = value;</span>
<span class="nc" id="L1400">        return pos;</span>
    }

    // Format attribute bytes, drawing values from bands.
    // Used when emptying attribute bands into a package model.
    // (At that point CP refs. are not yet assigned indexes.)
    static
    void unparseUsing(Layout.Element[] elems, Object[] fixups,
                      ValueStream in, ByteArrayOutputStream out) {
<span class="nc" id="L1409">        int prevBCI = 0;</span>
<span class="nc" id="L1410">        int prevRBCI = 0;</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">        for (int i = 0; i &lt; elems.length; i++) {</span>
<span class="nc" id="L1412">            Layout.Element e = elems[i];</span>
<span class="nc" id="L1413">            int bandIndex = e.bandIndex;</span>
            int value;
            int BCI, RBCI;  // &quot;RBCI&quot; is R(BCI), BCI's coded representation
<span class="nc bnc" id="L1416" title="All 9 branches missed.">            switch (e.kind) {</span>
            case EK_INT:
<span class="nc" id="L1418">                value = in.getInt(bandIndex);</span>
<span class="nc" id="L1419">                unparseInt(e, value, out);</span>
<span class="nc" id="L1420">                break;</span>
            case EK_BCI:  // PH, POH
<span class="nc" id="L1422">                value = in.getInt(bandIndex);</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">                if (!e.flagTest(EF_DELTA)) {</span>
                    // PH:  transmit R(bci), store bci
<span class="nc" id="L1425">                    RBCI = value;</span>
                } else {
                    // POH:  transmit D(R(bci)), store bci
<span class="nc" id="L1428">                    RBCI = prevRBCI + value;</span>
                }
<span class="nc bnc" id="L1430" title="All 4 branches missed.">                assert(prevBCI == in.decodeBCI(prevRBCI));</span>
<span class="nc" id="L1431">                BCI = in.decodeBCI(RBCI);</span>
<span class="nc" id="L1432">                unparseInt(e, BCI, out);</span>
<span class="nc" id="L1433">                prevBCI = BCI;</span>
<span class="nc" id="L1434">                prevRBCI = RBCI;</span>
<span class="nc" id="L1435">                break;</span>
            case EK_BCO:  // OH
<span class="nc" id="L1437">                value = in.getInt(bandIndex);</span>
<span class="nc bnc" id="L1438" title="All 4 branches missed.">                assert(e.flagTest(EF_DELTA));</span>
                // OH:  transmit D(R(bci)), store D(bci)
<span class="nc bnc" id="L1440" title="All 4 branches missed.">                assert(prevBCI == in.decodeBCI(prevRBCI));</span>
<span class="nc" id="L1441">                RBCI = prevRBCI + value;</span>
<span class="nc" id="L1442">                BCI = in.decodeBCI(RBCI);</span>
<span class="nc" id="L1443">                unparseInt(e, BCI - prevBCI, out);</span>
<span class="nc" id="L1444">                prevBCI = BCI;</span>
<span class="nc" id="L1445">                prevRBCI = RBCI;</span>
<span class="nc" id="L1446">                break;</span>
            case EK_FLAG:
<span class="nc" id="L1448">                value = in.getInt(bandIndex);</span>
<span class="nc" id="L1449">                unparseInt(e, value, out);</span>
<span class="nc" id="L1450">                break;</span>
            case EK_REPL:
<span class="nc" id="L1452">                value = in.getInt(bandIndex);</span>
<span class="nc" id="L1453">                unparseInt(e, value, out);</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">                for (int j = 0; j &lt; value; j++) {</span>
<span class="nc" id="L1455">                    unparseUsing(e.body, fixups, in, out);</span>
                }
<span class="nc" id="L1457">                break;</span>
            case EK_UN:
<span class="nc" id="L1459">                value = in.getInt(bandIndex);</span>
<span class="nc" id="L1460">                unparseInt(e, value, out);</span>
<span class="nc" id="L1461">                Layout.Element ce = matchCase(e, value);</span>
<span class="nc" id="L1462">                unparseUsing(ce.body, fixups, in, out);</span>
<span class="nc" id="L1463">                break;</span>
            case EK_CALL:
<span class="nc bnc" id="L1465" title="All 4 branches missed.">                assert(e.body.length == 1);</span>
<span class="nc bnc" id="L1466" title="All 4 branches missed.">                assert(e.body[0].kind == EK_CBLE);</span>
<span class="nc" id="L1467">                unparseUsing(e.body[0].body, fixups, in, out);</span>
<span class="nc" id="L1468">                break;</span>
            case EK_REF:
<span class="nc" id="L1470">                Entry globalRef = in.getRef(bandIndex);</span>
                int localRef;
<span class="nc bnc" id="L1472" title="All 2 branches missed.">                if (globalRef != null) {</span>
                    // It's a one-element array, really an lvalue.
<span class="nc" id="L1474">                    fixups[0] = Fixups.addRefWithLoc(fixups[0], out.size(), globalRef);</span>
<span class="nc" id="L1475">                    localRef = 0; // placeholder for fixups</span>
                } else {
<span class="nc" id="L1477">                    localRef = 0; // fixed null value</span>
                }
<span class="nc" id="L1479">                unparseInt(e, localRef, out);</span>
<span class="nc" id="L1480">                break;</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">            default: assert(false); continue;</span>
            }
        }
<span class="nc" id="L1484">    }</span>

    static private
    void unparseInt(Layout.Element e, int value, ByteArrayOutputStream out) {
<span class="nc" id="L1488">        int loBits = e.len * 8;</span>
<span class="nc bnc" id="L1489" title="All 2 branches missed.">        if (loBits == 0) {</span>
            // It is not stored at all ('V' layout).
<span class="nc" id="L1491">            return;</span>
        }
<span class="nc bnc" id="L1493" title="All 2 branches missed.">        if (loBits &lt; 32) {</span>
<span class="nc" id="L1494">            int hiBits = 32 - loBits;</span>
            int codedValue;
<span class="nc bnc" id="L1496" title="All 2 branches missed.">            if (e.flagTest(EF_SIGN))</span>
<span class="nc" id="L1497">                codedValue = (value &lt;&lt; hiBits) &gt;&gt; hiBits;</span>
            else
<span class="nc" id="L1499">                codedValue = (value &lt;&lt; hiBits) &gt;&gt;&gt; hiBits;</span>
<span class="nc bnc" id="L1500" title="All 2 branches missed.">            if (codedValue != value)</span>
<span class="nc" id="L1501">                throw new InternalError(&quot;cannot code in &quot;+e.len+&quot; bytes: &quot;+value);</span>
        }
        // Write in big-endian order:
<span class="nc bnc" id="L1504" title="All 2 branches missed.">        for (int bitPos = loBits; (bitPos -= 8) &gt;= 0; ) {</span>
<span class="nc" id="L1505">            out.write((byte)(value &gt;&gt;&gt; bitPos));</span>
        }
<span class="nc" id="L1507">    }</span>

/*
    /// Testing.
    public static void main(String av[]) {
        int maxVal = 12;
        int iters = 0;
        boolean verbose;
        int ap = 0;
        while (ap &lt; av.length) {
            if (!av[ap].startsWith(&quot;-&quot;))  break;
            if (av[ap].startsWith(&quot;-m&quot;))
                maxVal = Integer.parseInt(av[ap].substring(2));
            else if (av[ap].startsWith(&quot;-i&quot;))
                iters = Integer.parseInt(av[ap].substring(2));
            else
                throw new RuntimeException(&quot;Bad option: &quot;+av[ap]);
            ap++;
        }
        verbose = (iters == 0);
        if (iters &lt;= 0)  iters = 1;
        if (ap == av.length) {
            av = new String[] {
                &quot;HH&quot;,         // ClassFile.version
                &quot;RUH&quot;,        // SourceFile
                &quot;RCHRDNH&quot;,    // EnclosingMethod
                &quot;KQH&quot;,        // ConstantValue
                &quot;NH[RCH]&quot;,    // Exceptions
                &quot;NH[PHH]&quot;,    // LineNumberTable
                &quot;NH[PHOHRUHRSHH]&quot;,      // LocalVariableTable
                &quot;NH[PHPOHIIH]&quot;,         // CharacterRangeTable
                &quot;NH[PHHII]&quot;,            // CoverageTable
                &quot;NH[RCHRCNHRUNHFH]&quot;,    // InnerClasses
                &quot;NH[RMHNH[KLH]]&quot;,       // BootstrapMethods
                &quot;HHNI[B]NH[PHPOHPOHRCNH]NH[RUHNI[B]]&quot;, // Code
                &quot;=AnnotationDefault&quot;,
                // Like metadata, but with a compact tag set:
                &quot;[NH[(1)]]&quot;
                +&quot;[NH[(1)]]&quot;
                +&quot;[RSHNH[RUH(1)]]&quot;
                +&quot;[TB(0,1,3)[KIH](2)[KDH](5)[KFH](4)[KJH](7)[RSH](8)[RSHRUH](9)[RUH](10)[(-1)](6)[NH[(0)]]()[]]&quot;,
                &quot;&quot;
            };
            ap = 0;
        }
        Utils.currentInstance.set(new PackerImpl());
        final int[][] counts = new int[2][3];  // int bci ref
        final Entry[] cpMap = new Entry[maxVal+1];
        for (int i = 0; i &lt; cpMap.length; i++) {
            if (i == 0)  continue;  // 0 =&gt; null
            cpMap[i] = ConstantPool.getLiteralEntry(new Integer(i));
        }
        Package.Class cls = new Package().new Class(&quot;&quot;);
        cls.cpMap = cpMap;
        class TestValueStream extends ValueStream {
            java.util.Random rand = new java.util.Random(0);
            ArrayList history = new ArrayList();
            int ckidx = 0;
            int maxVal;
            boolean verbose;
            void reset() { history.clear(); ckidx = 0; }
            public int getInt(int bandIndex) {
                counts[0][0]++;
                int value = rand.nextInt(maxVal+1);
                history.add(new Integer(bandIndex));
                history.add(new Integer(value));
                return value;
            }
            public void putInt(int bandIndex, int token) {
                counts[1][0]++;
                if (verbose)
                    System.out.print(&quot; &quot;+bandIndex+&quot;:&quot;+token);
                // Make sure this put parallels a previous get:
                int check0 = ((Integer)history.get(ckidx+0)).intValue();
                int check1 = ((Integer)history.get(ckidx+1)).intValue();
                if (check0 != bandIndex || check1 != token) {
                    if (!verbose)
                        System.out.println(history.subList(0, ckidx));
                    System.out.println(&quot; *** Should be &quot;+check0+&quot;:&quot;+check1);
                    throw new RuntimeException(&quot;Failed test!&quot;);
                }
                ckidx += 2;
            }
            public Entry getRef(int bandIndex) {
                counts[0][2]++;
                int value = getInt(bandIndex);
                if (value &lt; 0 || value &gt; maxVal) {
                    System.out.println(&quot; *** Unexpected ref code &quot;+value);
                    return ConstantPool.getLiteralEntry(new Integer(value));
                }
                return cpMap[value];
            }
            public void putRef(int bandIndex, Entry ref) {
                counts[1][2]++;
                if (ref == null) {
                    putInt(bandIndex, 0);
                    return;
                }
                Number refValue = null;
                if (ref instanceof ConstantPool.NumberEntry)
                    refValue = ((ConstantPool.NumberEntry)ref).numberValue();
                int value;
                if (!(refValue instanceof Integer)) {
                    System.out.println(&quot; *** Unexpected ref &quot;+ref);
                    value = -1;
                } else {
                    value = ((Integer)refValue).intValue();
                }
                putInt(bandIndex, value);
            }
            public int encodeBCI(int bci) {
                counts[1][1]++;
                // move LSB to MSB of low byte
                int code = (bci &gt;&gt; 8) &lt;&lt; 8;  // keep high bits
                code += (bci &amp; 0xFE) &gt;&gt; 1;
                code += (bci &amp; 0x01) &lt;&lt; 7;
                return code ^ (8&lt;&lt;8);  // mark it clearly as coded
            }
            public int decodeBCI(int bciCode) {
                counts[0][1]++;
                bciCode ^= (8&lt;&lt;8);  // remove extra mark
                int bci = (bciCode &gt;&gt; 8) &lt;&lt; 8;  // keep high bits
                bci += (bciCode &amp; 0x7F) &lt;&lt; 1;
                bci += (bciCode &amp; 0x80) &gt;&gt; 7;
                return bci;
            }
        }
        TestValueStream tts = new TestValueStream();
        tts.maxVal = maxVal;
        tts.verbose = verbose;
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        for (int i = 0; i &lt; (1 &lt;&lt; 30); i = (i + 1) * 5) {
            int ei = tts.encodeBCI(i);
            int di = tts.decodeBCI(ei);
            if (di != i)  System.out.println(&quot;i=&quot;+Integer.toHexString(i)+
                                             &quot; ei=&quot;+Integer.toHexString(ei)+
                                             &quot; di=&quot;+Integer.toHexString(di));
        }
        while (iters-- &gt; 0) {
            for (int i = ap; i &lt; av.length; i++) {
                String layout = av[i];
                if (layout.startsWith(&quot;=&quot;)) {
                    String name = layout.substring(1);
                    for (Attribute a : standardDefs.values()) {
                        if (a.name().equals(name)) {
                            layout = a.layout().layout();
                            break;
                        }
                    }
                    if (layout.startsWith(&quot;=&quot;)) {
                        System.out.println(&quot;Could not find &quot;+name+&quot; in &quot;+standardDefs.values());
                    }
                }
                Layout self = new Layout(0, &quot;Foo&quot;, layout);
                if (verbose) {
                    System.out.print(&quot;/&quot;+layout+&quot;/ =&gt; &quot;);
                    System.out.println(Arrays.asList(self.elems));
                }
                buf.reset();
                tts.reset();
                Object fixups = self.unparse(tts, buf);
                byte[] bytes = buf.toByteArray();
                // Attach the references to the byte array.
                Fixups.setBytes(fixups, bytes);
                // Patch the references to their frozen values.
                Fixups.finishRefs(fixups, bytes, new Index(&quot;test&quot;, cpMap));
                if (verbose) {
                    System.out.print(&quot;  bytes: {&quot;);
                    for (int j = 0; j &lt; bytes.length; j++) {
                        System.out.print(&quot; &quot;+bytes[j]);
                    }
                    System.out.println(&quot;}&quot;);
                }
                if (verbose) {
                    System.out.print(&quot;  parse: {&quot;);
                }
                self.parse(cls, bytes, 0, bytes.length, tts);
                if (verbose) {
                    System.out.println(&quot;}&quot;);
                }
            }
        }
        for (int j = 0; j &lt;= 1; j++) {
            System.out.print(&quot;values &quot;+(j==0?&quot;read&quot;:&quot;written&quot;)+&quot;: {&quot;);
            for (int k = 0; k &lt; counts[j].length; k++) {
                System.out.print(&quot; &quot;+counts[j][k]);
            }
            System.out.println(&quot; }&quot;);
        }
    }
//*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>