<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Driver.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">Driver.java</span></div><h1>Driver.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.text.MessageFormat;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.jar.JarFile;
import java.util.jar.JarOutputStream;
import java.util.jar.Pack200;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

/** Command line interface for Pack200.
 */
<span class="pc bfc" id="L59" title="All 2 branches covered.">class Driver {</span>
<span class="fc" id="L60">        private static final ResourceBundle RESOURCE =</span>
<span class="fc" id="L61">                ResourceBundle.getBundle(&quot;com.sun.java.util.jar.pack.DriverResource&quot;);</span>

    public static void main(String[] ava) throws IOException {
<span class="fc" id="L64">        List&lt;String&gt; av = new ArrayList&lt;&gt;(Arrays.asList(ava));</span>

<span class="fc" id="L66">        boolean doPack   = true;</span>
<span class="fc" id="L67">        boolean doUnpack = false;</span>
<span class="fc" id="L68">        boolean doRepack = false;</span>
<span class="fc" id="L69">        boolean doZip = true;</span>
<span class="fc" id="L70">        String logFile = null;</span>
<span class="fc" id="L71">        String verboseProp = Utils.DEBUG_VERBOSE;</span>

        {
            // Non-standard, undocumented &quot;--unpack&quot; switch enables unpack mode.
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">            String arg0 = av.isEmpty() ? &quot;&quot; : av.get(0);</span>
<span class="pc bpc" id="L76" title="5 of 10 branches missed.">            switch (arg0) {</span>
                case &quot;--pack&quot;:
<span class="fc" id="L78">                av.remove(0);</span>
<span class="fc" id="L79">                    break;</span>
                case &quot;--unpack&quot;:
<span class="nc" id="L81">                av.remove(0);</span>
<span class="nc" id="L82">                doPack = false;</span>
<span class="nc" id="L83">                doUnpack = true;</span>
                    break;
            }
        }

        // Collect engine properties here:
<span class="fc" id="L89">        Map&lt;String,String&gt; engProps = new HashMap&lt;&gt;();</span>
<span class="fc" id="L90">        engProps.put(verboseProp, System.getProperty(verboseProp));</span>

        String optionMap;
        String[] propTable;
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (doPack) {</span>
<span class="fc" id="L95">            optionMap = PACK200_OPTION_MAP;</span>
<span class="fc" id="L96">            propTable = PACK200_PROPERTY_TO_OPTION;</span>
        } else {
<span class="nc" id="L98">            optionMap = UNPACK200_OPTION_MAP;</span>
<span class="nc" id="L99">            propTable = UNPACK200_PROPERTY_TO_OPTION;</span>
        }

        // Collect argument properties here:
<span class="fc" id="L103">        Map&lt;String,String&gt; avProps = new HashMap&lt;&gt;();</span>
        try {
            for (;;) {
<span class="fc" id="L106">                String state = parseCommandOptions(av, optionMap, avProps);</span>
                // Translate command line options to Pack200 properties:
            eachOpt:
<span class="fc" id="L109">                for (Iterator&lt;String&gt; opti = avProps.keySet().iterator();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">                     opti.hasNext(); ) {</span>
<span class="fc" id="L111">                    String opt = opti.next();</span>
<span class="fc" id="L112">                    String prop = null;</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">                    for (int i = 0; i &lt; propTable.length; i += 2) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">                        if (opt.equals(propTable[1+i])) {</span>
<span class="fc" id="L115">                            prop = propTable[0+i];</span>
<span class="fc" id="L116">                            break;</span>
                        }
                    }
<span class="fc bfc" id="L119" title="All 2 branches covered.">                    if (prop != null) {</span>
<span class="fc" id="L120">                        String val = avProps.get(opt);</span>
<span class="fc" id="L121">                        opti.remove();  // remove opt from avProps</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">                        if (!prop.endsWith(&quot;.&quot;)) {</span>
                            // Normal string or boolean.
<span class="fc bfc" id="L124" title="All 2 branches covered.">                            if (!(opt.equals(&quot;--verbose&quot;)</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">                                  || opt.endsWith(&quot;=&quot;))) {</span>
                                // Normal boolean; convert to T/F.
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">                                boolean flag = (val != null);</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">                                if (opt.startsWith(&quot;--no-&quot;))</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">                                    flag = !flag;</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">                                val = flag? &quot;true&quot;: &quot;false&quot;;</span>
                            }
<span class="fc" id="L132">                            engProps.put(prop, val);</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">                        } else if (prop.contains(&quot;.attribute.&quot;)) {</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">                            for (String val1 : val.split(&quot;\0&quot;)) {</span>
<span class="nc" id="L135">                                String[] val2 = val1.split(&quot;=&quot;, 2);</span>
<span class="nc" id="L136">                                engProps.put(prop+val2[0], val2[1]);</span>
                            }
                        } else {
                            // Collection property: pack.pass.file.cli.NNN
<span class="nc" id="L140">                            int idx = 1;</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">                            for (String val1 : val.split(&quot;\0&quot;)) {</span>
                                String prop1;
                                do {
<span class="nc" id="L144">                                    prop1 = prop+&quot;cli.&quot;+(idx++);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">                                } while (engProps.containsKey(prop1));</span>
<span class="nc" id="L146">                                engProps.put(prop1, val1);</span>
                            }
                        }
                    }
<span class="fc" id="L150">                }</span>

                // See if there is any other action to take.
<span class="fc bfc" id="L153" title="All 2 branches covered.">                if (&quot;--config-file=&quot;.equals(state)) {</span>
<span class="fc" id="L154">                    String propFile = av.remove(0);</span>
<span class="fc" id="L155">                    Properties fileProps = new Properties();</span>
<span class="pc" id="L156">                    try (InputStream propIn = new FileInputStream(propFile)) {</span>
<span class="fc" id="L157">                        fileProps.load(propIn);</span>
<span class="pc bpc" id="L158" title="6 of 8 branches missed.">                    }</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">                    if (engProps.get(verboseProp) != null)</span>
<span class="fc" id="L160">                        fileProps.list(System.out);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">                    for (Map.Entry&lt;Object,Object&gt; me : fileProps.entrySet()) {</span>
<span class="fc" id="L162">                        engProps.put((String) me.getKey(), (String) me.getValue());</span>
<span class="fc" id="L163">                    }</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">                } else if (&quot;--version&quot;.equals(state)) {</span>
<span class="nc" id="L165">                        System.out.println(MessageFormat.format(RESOURCE.getString(DriverResource.VERSION), Driver.class.getName(), &quot;1.31, 07/05/05&quot;));</span>
<span class="nc" id="L166">                    return;</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">                } else if (&quot;--help&quot;.equals(state)) {</span>
<span class="nc" id="L168">                    printUsage(doPack, true, System.out);</span>
<span class="nc" id="L169">                    System.exit(1);</span>
<span class="nc" id="L170">                    return;</span>
                } else {
                    break;
                }
<span class="fc" id="L174">            }</span>
<span class="nc" id="L175">        } catch (IllegalArgumentException ee) {</span>
<span class="nc" id="L176">                System.err.println(MessageFormat.format(RESOURCE.getString(DriverResource.BAD_ARGUMENT), ee));</span>
<span class="nc" id="L177">            printUsage(doPack, false, System.err);</span>
<span class="nc" id="L178">            System.exit(2);</span>
<span class="nc" id="L179">            return;</span>
<span class="fc" id="L180">        }</span>

        // Deal with remaining non-engine properties:
<span class="fc bfc" id="L183" title="All 2 branches covered.">        for (String opt : avProps.keySet()) {</span>
<span class="fc" id="L184">            String val = avProps.get(opt);</span>
<span class="pc bpc" id="L185" title="11 of 14 branches missed.">            switch (opt) {</span>
                case &quot;--repack&quot;:
<span class="fc" id="L187">                    doRepack = true;</span>
<span class="fc" id="L188">                    break;</span>
                case &quot;--no-gzip&quot;:
<span class="nc bnc" id="L190" title="All 2 branches missed.">                    doZip = (val == null);</span>
<span class="nc" id="L191">                    break;</span>
                case &quot;--log-file=&quot;:
<span class="nc" id="L193">                    logFile = val;</span>
<span class="nc" id="L194">                    break;</span>
                default:
<span class="nc" id="L196">                    throw new InternalError(MessageFormat.format(</span>
<span class="nc" id="L197">                            RESOURCE.getString(DriverResource.BAD_OPTION),</span>
<span class="nc" id="L198">                            opt, avProps.get(opt)));</span>
            }
<span class="fc" id="L200">        }</span>

<span class="pc bpc" id="L202" title="3 of 4 branches missed.">        if (logFile != null &amp;&amp; !logFile.equals(&quot;&quot;)) {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (logFile.equals(&quot;-&quot;)) {</span>
<span class="nc" id="L204">                System.setErr(System.out);</span>
            } else {
<span class="nc" id="L206">                OutputStream log = new FileOutputStream(logFile);</span>
                //log = new BufferedOutputStream(out);
<span class="nc" id="L208">                System.setErr(new PrintStream(log));</span>
            }
        }

<span class="fc bfc" id="L212" title="All 2 branches covered.">        boolean verbose = (engProps.get(verboseProp) != null);</span>

<span class="fc" id="L214">        String packfile = &quot;&quot;;</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (!av.isEmpty())</span>
<span class="fc" id="L216">            packfile = av.remove(0);</span>

<span class="fc" id="L218">        String jarfile = &quot;&quot;;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        if (!av.isEmpty())</span>
<span class="fc" id="L220">            jarfile = av.remove(0);</span>

<span class="fc" id="L222">        String newfile = &quot;&quot;;  // output JAR file if --repack</span>
<span class="fc" id="L223">        String bakfile = &quot;&quot;;  // temporary backup of input JAR</span>
<span class="fc" id="L224">        String tmpfile = &quot;&quot;;  // temporary file to be deleted</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if (doRepack) {</span>
            // The first argument is the target JAR file.
            // (Note:  *.pac is nonstandard, but may be necessary
            // if a host OS truncates file extensions.)
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">            if (packfile.toLowerCase().endsWith(&quot;.pack&quot;) ||</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">                packfile.toLowerCase().endsWith(&quot;.pac&quot;) ||</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                packfile.toLowerCase().endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L232">                System.err.println(MessageFormat.format(</span>
<span class="nc" id="L233">                        RESOURCE.getString(DriverResource.BAD_REPACK_OUTPUT),</span>
                        packfile));
<span class="nc" id="L235">                printUsage(doPack, false, System.err);</span>
<span class="nc" id="L236">                System.exit(2);</span>
            }
<span class="fc" id="L238">            newfile = packfile;</span>
            // The optional second argument is the source JAR file.
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (jarfile.equals(&quot;&quot;)) {</span>
                // If only one file is given, it is the only JAR.
                // It serves as both input and output.
<span class="fc" id="L243">                jarfile = newfile;</span>
            }
<span class="fc" id="L245">            tmpfile = createTempFile(newfile, &quot;.pack&quot;).getPath();</span>
<span class="fc" id="L246">            packfile = tmpfile;</span>
<span class="fc" id="L247">            doZip = false;  // no need to zip the temporary file</span>
        }

<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (!av.isEmpty()</span>
            // Accept jarfiles ending with .jar or .zip.
            // Accept jarfile of &quot;-&quot; (stdout), but only if unpacking.
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">            || !(jarfile.toLowerCase().endsWith(&quot;.jar&quot;)</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                 || jarfile.toLowerCase().endsWith(&quot;.zip&quot;)</span>
<span class="nc bnc" id="L255" title="All 4 branches missed.">                 || (jarfile.equals(&quot;-&quot;) &amp;&amp; !doPack))) {</span>
<span class="nc" id="L256">            printUsage(doPack, false, System.err);</span>
<span class="nc" id="L257">            System.exit(2);</span>
<span class="nc" id="L258">            return;</span>
        }

<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if (doRepack)</span>
<span class="fc" id="L262">            doPack = doUnpack = true;</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        else if (doPack)</span>
<span class="nc" id="L264">            doUnpack = false;</span>

<span class="nc" id="L266">        Pack200.Packer jpack = Pack200.newPacker();</span>
<span class="nc" id="L267">        Pack200.Unpacker junpack = Pack200.newUnpacker();</span>

<span class="nc" id="L269">        jpack.properties().putAll(engProps);</span>
<span class="nc" id="L270">        junpack.properties().putAll(engProps);</span>
<span class="nc bnc" id="L271" title="All 4 branches missed.">        if (doRepack &amp;&amp; newfile.equals(jarfile)) {</span>
<span class="nc" id="L272">            String zipc = getZipComment(jarfile);</span>
<span class="nc bnc" id="L273" title="All 4 branches missed.">            if (verbose &amp;&amp; zipc.length() &gt; 0)</span>
<span class="nc" id="L274">                System.out.println(MessageFormat.format(RESOURCE.getString(DriverResource.DETECTED_ZIP_COMMENT), zipc));</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (zipc.indexOf(Utils.PACK_ZIP_ARCHIVE_MARKER_COMMENT) &gt;= 0) {</span>
<span class="nc" id="L276">                    System.out.println(MessageFormat.format(RESOURCE.getString(DriverResource.SKIP_FOR_REPACKED), jarfile));</span>
<span class="nc" id="L277">                        doPack = false;</span>
<span class="nc" id="L278">                        doUnpack = false;</span>
<span class="nc" id="L279">                        doRepack = false;</span>
            }
        }

        try {

<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (doPack) {</span>
                // Mode = Pack.
<span class="nc" id="L287">                JarFile in = new JarFile(new File(jarfile));</span>
                OutputStream out;
                // Packfile must be -, *.gz, *.pack, or *.pac.
<span class="nc bnc" id="L290" title="All 2 branches missed.">                if (packfile.equals(&quot;-&quot;)) {</span>
<span class="nc" id="L291">                    out = System.out;</span>
                    // Send warnings, etc., to stderr instead of stdout.
<span class="nc" id="L293">                    System.setOut(System.err);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">                } else if (doZip) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">                    if (!packfile.endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L296">                    System.err.println(MessageFormat.format(RESOURCE.getString(DriverResource.WRITE_PACK_FILE), packfile));</span>
<span class="nc" id="L297">                        printUsage(doPack, false, System.err);</span>
<span class="nc" id="L298">                        System.exit(2);</span>
                    }
<span class="nc" id="L300">                    out = new FileOutputStream(packfile);</span>
<span class="nc" id="L301">                    out = new BufferedOutputStream(out);</span>
<span class="nc" id="L302">                    out = new GZIPOutputStream(out);</span>
                } else {
<span class="nc bnc" id="L304" title="All 2 branches missed.">                    if (!packfile.toLowerCase().endsWith(&quot;.pack&quot;) &amp;&amp;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                            !packfile.toLowerCase().endsWith(&quot;.pac&quot;)) {</span>
<span class="nc" id="L306">                        System.err.println(MessageFormat.format(RESOURCE.getString(DriverResource.WRITE_PACKGZ_FILE),packfile));</span>
<span class="nc" id="L307">                        printUsage(doPack, false, System.err);</span>
<span class="nc" id="L308">                        System.exit(2);</span>
                    }
<span class="nc" id="L310">                    out = new FileOutputStream(packfile);</span>
<span class="nc" id="L311">                    out = new BufferedOutputStream(out);</span>
                }
<span class="nc" id="L313">                jpack.pack(in, out);</span>
                //in.close();  // p200 closes in but not out
<span class="nc" id="L315">                out.close();</span>
            }

<span class="nc bnc" id="L318" title="All 4 branches missed.">            if (doRepack &amp;&amp; newfile.equals(jarfile)) {</span>
                // If the source and destination are the same,
                // we will move the input JAR aside while regenerating it.
                // This allows us to restore it if something goes wrong.
<span class="nc" id="L322">                File bakf = createTempFile(jarfile, &quot;.bak&quot;);</span>
                // On Windows target must be deleted see 4017593
<span class="nc" id="L324">                bakf.delete();</span>
<span class="nc" id="L325">                boolean okBackup = new File(jarfile).renameTo(bakf);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                if (!okBackup) {</span>
<span class="nc" id="L327">                        throw new Error(MessageFormat.format(RESOURCE.getString(DriverResource.SKIP_FOR_MOVE_FAILED),bakfile));</span>
                } else {
                    // Open jarfile recovery bracket.
<span class="nc" id="L330">                    bakfile = bakf.getPath();</span>
                }
            }

<span class="nc bnc" id="L334" title="All 2 branches missed.">            if (doUnpack) {</span>
                // Mode = Unpack.
                InputStream in;
<span class="nc bnc" id="L337" title="All 2 branches missed.">                if (packfile.equals(&quot;-&quot;))</span>
<span class="nc" id="L338">                    in = System.in;</span>
                else
<span class="nc" id="L340">                    in = new FileInputStream(new File(packfile));</span>
<span class="nc" id="L341">                BufferedInputStream inBuf = new BufferedInputStream(in);</span>
<span class="nc" id="L342">                in = inBuf;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                if (Utils.isGZIPMagic(Utils.readMagic(inBuf))) {</span>
<span class="nc" id="L344">                    in = new GZIPInputStream(in);</span>
                }
<span class="nc bnc" id="L346" title="All 2 branches missed.">                String outfile = newfile.equals(&quot;&quot;)? jarfile: newfile;</span>
                OutputStream fileOut;
<span class="nc bnc" id="L348" title="All 2 branches missed.">                if (outfile.equals(&quot;-&quot;))</span>
<span class="nc" id="L349">                    fileOut = System.out;</span>
                else
<span class="nc" id="L351">                    fileOut = new FileOutputStream(outfile);</span>
<span class="nc" id="L352">                fileOut = new BufferedOutputStream(fileOut);</span>
<span class="nc" id="L353">                try (JarOutputStream out = new JarOutputStream(fileOut)) {</span>
<span class="nc" id="L354">                    junpack.unpack(in, out);</span>
                    // p200 closes in but not out
<span class="nc bnc" id="L356" title="All 8 branches missed.">                }</span>
                // At this point, we have a good jarfile (or newfile, if -r)
            }

<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (!bakfile.equals(&quot;&quot;)) {</span>
                        // On success, abort jarfile recovery bracket.
<span class="nc" id="L362">                        new File(bakfile).delete();</span>
<span class="nc" id="L363">                        bakfile = &quot;&quot;;</span>
            }

        } finally {
            // Close jarfile recovery bracket.
<span class="nc bnc" id="L368" title="All 4 branches missed.">            if (!bakfile.equals(&quot;&quot;)) {</span>
<span class="nc" id="L369">                File jarFile = new File(jarfile);</span>
<span class="nc" id="L370">                jarFile.delete(); // Win32 requires this, see above</span>
<span class="nc" id="L371">                new File(bakfile).renameTo(jarFile);</span>
            }
            // In all cases, delete temporary *.pack.
<span class="nc bnc" id="L374" title="All 4 branches missed.">            if (!tmpfile.equals(&quot;&quot;))</span>
<span class="nc" id="L375">                new File(tmpfile).delete();</span>
        }
<span class="nc" id="L377">    }</span>

    static private
    File createTempFile(String basefile, String suffix) throws IOException {
<span class="fc" id="L381">        File base = new File(basefile);</span>
<span class="fc" id="L382">        String prefix = base.getName();</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        if (prefix.length() &lt; 3)  prefix += &quot;tmp&quot;;</span>

<span class="pc bpc" id="L385" title="1 of 4 branches missed.">        File where = (base.getParentFile() == null &amp;&amp; suffix.equals(&quot;.bak&quot;))</span>
<span class="pc" id="L386">                ? new File(&quot;.&quot;).getAbsoluteFile()</span>
<span class="fc" id="L387">                : base.getParentFile();</span>

<span class="fc bfc" id="L389" title="All 2 branches covered.">        Path tmpfile = (where == null)</span>
<span class="fc" id="L390">                ? Files.createTempFile(prefix, suffix)</span>
<span class="fc" id="L391">                : Files.createTempFile(where.toPath(), prefix, suffix);</span>

<span class="fc" id="L393">        return tmpfile.toFile();</span>
    }

    static private
    void printUsage(boolean doPack, boolean full, PrintStream out) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">        String prog = doPack ? &quot;pack200&quot; : &quot;unpack200&quot;;</span>
<span class="nc" id="L399">        String[] packUsage = (String[])RESOURCE.getObject(DriverResource.PACK_HELP);</span>
<span class="nc" id="L400">        String[] unpackUsage = (String[])RESOURCE.getObject(DriverResource.UNPACK_HELP);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        String[] usage = doPack? packUsage: unpackUsage;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">        for (int i = 0; i &lt; usage.length; i++) {</span>
<span class="nc" id="L403">            out.println(usage[i]);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">            if (!full) {</span>
<span class="nc" id="L405">            out.println(MessageFormat.format(RESOURCE.getString(DriverResource.MORE_INFO), prog));</span>
<span class="nc" id="L406">                break;</span>
            }
        }
<span class="nc" id="L409">    }</span>

    static private
        String getZipComment(String jarfile) throws IOException {
<span class="nc" id="L413">        byte[] tail = new byte[1000];</span>
<span class="nc" id="L414">        long filelen = new File(jarfile).length();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (filelen &lt;= 0)  return &quot;&quot;;</span>
<span class="nc" id="L416">        long skiplen = Math.max(0, filelen - tail.length);</span>
<span class="nc" id="L417">        try (InputStream in = new FileInputStream(new File(jarfile))) {</span>
<span class="nc" id="L418">            in.skip(skiplen);</span>
<span class="nc" id="L419">            in.read(tail);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">            for (int i = tail.length-4; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L421" title="All 8 branches missed.">                if (tail[i+0] == 'P' &amp;&amp; tail[i+1] == 'K' &amp;&amp;</span>
                    tail[i+2] ==  5  &amp;&amp; tail[i+3] ==  6) {
                    // Skip sig4, disks4, entries4, clen4, coff4, cmt2
<span class="nc" id="L424">                    i += 4+4+4+4+4+2;</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">                    if (i &lt; tail.length)</span>
<span class="nc" id="L426">                        return new String(tail, i, tail.length-i, &quot;UTF8&quot;);</span>
<span class="nc" id="L427">                    return &quot;&quot;;</span>
                }
            }
<span class="nc" id="L430">            return &quot;&quot;;</span>
<span class="nc bnc" id="L431" title="All 16 branches missed.">        }</span>
    }

    private static final String PACK200_OPTION_MAP =
        (&quot;&quot;
         +&quot;--repack                 $ \n  -r +&gt;- @--repack              $ \n&quot;
         +&quot;--no-gzip                $ \n  -g +&gt;- @--no-gzip             $ \n&quot;
         +&quot;--strip-debug            $ \n  -G +&gt;- @--strip-debug         $ \n&quot;
         +&quot;--no-keep-file-order     $ \n  -O +&gt;- @--no-keep-file-order  $ \n&quot;
         +&quot;--segment-limit=      *&gt; = \n  -S +&gt;  @--segment-limit=      = \n&quot;
         +&quot;--effort=             *&gt; = \n  -E +&gt;  @--effort=             = \n&quot;
         +&quot;--deflate-hint=       *&gt; = \n  -H +&gt;  @--deflate-hint=       = \n&quot;
         +&quot;--modification-time=  *&gt; = \n  -m +&gt;  @--modification-time=  = \n&quot;
         +&quot;--pass-file=        *&gt; &amp;\0 \n  -P +&gt;  @--pass-file=        &amp;\0 \n&quot;
         +&quot;--unknown-attribute=  *&gt; = \n  -U +&gt;  @--unknown-attribute=  = \n&quot;
         +&quot;--class-attribute=  *&gt; &amp;\0 \n  -C +&gt;  @--class-attribute=  &amp;\0 \n&quot;
         +&quot;--field-attribute=  *&gt; &amp;\0 \n  -F +&gt;  @--field-attribute=  &amp;\0 \n&quot;
         +&quot;--method-attribute= *&gt; &amp;\0 \n  -M +&gt;  @--method-attribute= &amp;\0 \n&quot;
         +&quot;--code-attribute=   *&gt; &amp;\0 \n  -D +&gt;  @--code-attribute=   &amp;\0 \n&quot;
         +&quot;--config-file=      *&gt;   . \n  -f +&gt;  @--config-file=        . \n&quot;

         // Negative options as required by CLIP:
         +&quot;--no-strip-debug  !--strip-debug         \n&quot;
         +&quot;--gzip            !--no-gzip             \n&quot;
         +&quot;--keep-file-order !--no-keep-file-order  \n&quot;

         // Non-Standard Options
         +&quot;--verbose                $ \n  -v +&gt;- @--verbose             $ \n&quot;
         +&quot;--quiet        !--verbose  \n  -q +&gt;- !--verbose               \n&quot;
         +&quot;--log-file=           *&gt; = \n  -l +&gt;  @--log-file=           = \n&quot;
         //+&quot;--java-option=      *&gt; = \n  -J +&gt;  @--java-option=        = \n&quot;
         +&quot;--version                . \n  -V +&gt;  @--version             . \n&quot;
         +&quot;--help               . \n  -? +&gt; @--help . \n  -h +&gt; @--help . \n&quot;

         // Termination:
         +&quot;--           . \n&quot;  // end option sequence here
         +&quot;-   +?    &gt;- . \n&quot;  // report error if -XXX present; else use stdout
         );
    // Note: Collection options use &quot;\0&quot; as a delimiter between arguments.

    // For Java version of unpacker (used for testing only):
    private static final String UNPACK200_OPTION_MAP =
        (&quot;&quot;
         +&quot;--deflate-hint=       *&gt; = \n  -H +&gt;  @--deflate-hint=       = \n&quot;
         +&quot;--verbose                $ \n  -v +&gt;- @--verbose             $ \n&quot;
         +&quot;--quiet        !--verbose  \n  -q +&gt;- !--verbose               \n&quot;
         +&quot;--remove-pack-file       $ \n  -r +&gt;- @--remove-pack-file    $ \n&quot;
         +&quot;--log-file=           *&gt; = \n  -l +&gt;  @--log-file=           = \n&quot;
         +&quot;--config-file=        *&gt; . \n  -f +&gt;  @--config-file=        . \n&quot;

         // Termination:
         +&quot;--           . \n&quot;  // end option sequence here
         +&quot;-   +?    &gt;- . \n&quot;  // report error if -XXX present; else use stdin
         +&quot;--version                . \n  -V +&gt;  @--version             . \n&quot;
         +&quot;--help               . \n  -? +&gt; @--help . \n  -h +&gt; @--help . \n&quot;
         );

<span class="fc" id="L488">    private static final String[] PACK200_PROPERTY_TO_OPTION = {</span>
        Pack200.Packer.SEGMENT_LIMIT, &quot;--segment-limit=&quot;,
        Pack200.Packer.KEEP_FILE_ORDER, &quot;--no-keep-file-order&quot;,
        Pack200.Packer.EFFORT, &quot;--effort=&quot;,
        Pack200.Packer.DEFLATE_HINT, &quot;--deflate-hint=&quot;,
        Pack200.Packer.MODIFICATION_TIME, &quot;--modification-time=&quot;,
        Pack200.Packer.PASS_FILE_PFX, &quot;--pass-file=&quot;,
        Pack200.Packer.UNKNOWN_ATTRIBUTE, &quot;--unknown-attribute=&quot;,
        Pack200.Packer.CLASS_ATTRIBUTE_PFX, &quot;--class-attribute=&quot;,
        Pack200.Packer.FIELD_ATTRIBUTE_PFX, &quot;--field-attribute=&quot;,
        Pack200.Packer.METHOD_ATTRIBUTE_PFX, &quot;--method-attribute=&quot;,
        Pack200.Packer.CODE_ATTRIBUTE_PFX, &quot;--code-attribute=&quot;,
        //Pack200.Packer.PROGRESS, &quot;--progress=&quot;,
        Utils.DEBUG_VERBOSE, &quot;--verbose&quot;,
        Utils.COM_PREFIX+&quot;strip.debug&quot;, &quot;--strip-debug&quot;,
    };

<span class="fc" id="L505">    private static final String[] UNPACK200_PROPERTY_TO_OPTION = {</span>
        Pack200.Unpacker.DEFLATE_HINT, &quot;--deflate-hint=&quot;,
        //Pack200.Unpacker.PROGRESS, &quot;--progress=&quot;,
        Utils.DEBUG_VERBOSE, &quot;--verbose&quot;,
        Utils.UNPACK_REMOVE_PACKFILE, &quot;--remove-pack-file&quot;,
    };

    /*-*
     * Remove a set of command-line options from args,
     * storing them in the map in a canonicalized form.
     * &lt;p&gt;
     * The options string is a newline-separated series of
     * option processing specifiers.
     */
    private static
    String parseCommandOptions(List&lt;String&gt; args,
                               String options,
                               Map&lt;String,String&gt; properties) {
        //System.out.println(args+&quot; // &quot;+properties);

<span class="fc" id="L525">        String resultString = null;</span>

        // Convert options string into optLines dictionary.
<span class="fc" id="L528">        TreeMap&lt;String,String[]&gt; optmap = new TreeMap&lt;&gt;();</span>
    loadOptmap:
<span class="fc bfc" id="L530" title="All 2 branches covered.">        for (String optline : options.split(&quot;\n&quot;)) {</span>
<span class="fc" id="L531">            String[] words = optline.split(&quot;\\p{Space}+&quot;);</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">            if (words.length == 0)    continue loadOptmap;</span>
<span class="fc" id="L533">            String opt = words[0];</span>
<span class="fc" id="L534">            words[0] = &quot;&quot;;  // initial word is not a spec</span>
<span class="pc bpc" id="L535" title="1 of 4 branches missed.">            if (opt.length() == 0 &amp;&amp; words.length &gt;= 1) {</span>
<span class="fc" id="L536">                opt = words[1];  // initial &quot;word&quot; is empty due to leading ' '</span>
<span class="fc" id="L537">                words[1] = &quot;&quot;;</span>
            }
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">            if (opt.length() == 0)    continue loadOptmap;</span>
<span class="fc" id="L540">            String[] prevWords = optmap.put(opt, words);</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">            if (prevWords != null)</span>
<span class="nc" id="L542">            throw new RuntimeException(MessageFormat.format(RESOURCE.getString(DriverResource.DUPLICATE_OPTION), optline.trim()));</span>
        }

        // State machine for parsing a command line.
<span class="fc" id="L546">        ListIterator&lt;String&gt; argp = args.listIterator();</span>
<span class="fc" id="L547">        ListIterator&lt;String&gt; pbp = new ArrayList&lt;String&gt;().listIterator();</span>
    doArgs:
        for (;;) {
            // One trip through this loop per argument.
            // Multiple trips per option only if several options per argument.
            String arg;
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">            if (pbp.hasPrevious()) {</span>
<span class="nc" id="L554">                arg = pbp.previous();</span>
<span class="nc" id="L555">                pbp.remove();</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">            } else if (argp.hasNext()) {</span>
<span class="fc" id="L557">                arg = argp.next();</span>
            } else {
                // No more arguments at all.
                break doArgs;
            }
        tryOpt:
<span class="pc" id="L563">            for (int optlen = arg.length(); ; optlen--) {</span>
                // One time through this loop for each matching arg prefix.
                String opt;
                // Match some prefix of the argument to a key in optmap.
            findOpt:
                for (;;) {
<span class="fc" id="L569">                    opt = arg.substring(0, optlen);</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">                    if (optmap.containsKey(opt))  break findOpt;</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                    if (optlen == 0)              break tryOpt;</span>
                    // Decide on a smaller prefix to search for.
<span class="fc" id="L573">                    SortedMap&lt;String,String[]&gt; pfxmap = optmap.headMap(opt);</span>
                    // pfxmap.lastKey is no shorter than any prefix in optmap.
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">                    int len = pfxmap.isEmpty() ? 0 : pfxmap.lastKey().length();</span>
<span class="fc" id="L576">                    optlen = Math.min(len, optlen - 1);</span>
<span class="fc" id="L577">                    opt = arg.substring(0, optlen);</span>
                    // (Note:  We could cut opt down to its common prefix with
                    // pfxmap.lastKey, but that wouldn't save many cycles.)
<span class="fc" id="L580">                }</span>
<span class="fc" id="L581">                opt = opt.intern();</span>
<span class="pc bpc" id="L582" title="1 of 4 branches missed.">                assert(arg.startsWith(opt));</span>
<span class="pc bpc" id="L583" title="1 of 4 branches missed.">                assert(opt.length() == optlen);</span>
<span class="fc" id="L584">                String val = arg.substring(optlen);  // arg == opt+val</span>

                // Execute the option processing specs for this opt.
                // If no actions are taken, then look for a shorter prefix.
<span class="fc" id="L588">                boolean didAction = false;</span>
<span class="fc" id="L589">                boolean isError = false;</span>

<span class="fc" id="L591">                int pbpMark = pbp.nextIndex();  // in case of backtracking</span>
<span class="fc" id="L592">                String[] specs = optmap.get(opt);</span>
            eachSpec:
<span class="fc bfc" id="L594" title="All 2 branches covered.">                for (String spec : specs) {</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">                    if (spec.length() == 0)     continue eachSpec;</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">                    if (spec.startsWith(&quot;#&quot;))   break eachSpec;</span>
<span class="fc" id="L597">                    int sidx = 0;</span>
<span class="fc" id="L598">                    char specop = spec.charAt(sidx++);</span>

                    // Deal with '+'/'*' prefixes (spec conditions).
                    boolean ok;
<span class="fc bfc" id="L602" title="All 3 branches covered.">                    switch (specop) {</span>
                    case '+':
                        // + means we want an non-empty val suffix.
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">                        ok = (val.length() != 0);</span>
<span class="fc" id="L606">                        specop = spec.charAt(sidx++);</span>
<span class="fc" id="L607">                        break;</span>
                    case '*':
                        // * means we accept empty or non-empty
<span class="fc" id="L610">                        ok = true;</span>
<span class="fc" id="L611">                        specop = spec.charAt(sidx++);</span>
<span class="fc" id="L612">                        break;</span>
                    default:
                        // No condition prefix means we require an exact
                        // match, as indicated by an empty val suffix.
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">                        ok = (val.length() == 0);</span>
                        break;
                    }
<span class="fc bfc" id="L619" title="All 2 branches covered.">                    if (!ok)  continue eachSpec;</span>

<span class="fc" id="L621">                    String specarg = spec.substring(sidx);</span>
<span class="pc bpc" id="L622" title="3 of 8 branches missed.">                    switch (specop) {</span>
                    case '.':  // terminate the option sequence
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">                        resultString = (specarg.length() != 0)? specarg.intern(): opt;</span>
<span class="fc" id="L625">                        break doArgs;</span>
                    case '?':  // abort the option sequence
<span class="nc bnc" id="L627" title="All 2 branches missed.">                        resultString = (specarg.length() != 0)? specarg.intern(): arg;</span>
<span class="nc" id="L628">                        isError = true;</span>
<span class="nc" id="L629">                        break eachSpec;</span>
                    case '@':  // change the effective opt name
<span class="fc" id="L631">                        opt = specarg.intern();</span>
<span class="fc" id="L632">                        break;</span>
                    case '&gt;':  // shift remaining arg val to next arg
<span class="fc" id="L634">                        pbp.add(specarg + val);  // push a new argument</span>
<span class="fc" id="L635">                        val = &quot;&quot;;</span>
<span class="fc" id="L636">                        break;</span>
                    case '!':  // negation option
<span class="nc bnc" id="L638" title="All 2 branches missed.">                        String negopt = (specarg.length() != 0)? specarg.intern(): opt;</span>
<span class="nc" id="L639">                        properties.remove(negopt);</span>
<span class="nc" id="L640">                        properties.put(negopt, null);  // leave placeholder</span>
<span class="nc" id="L641">                        didAction = true;</span>
<span class="nc" id="L642">                        break;</span>
                    case '$':  // normal &quot;boolean&quot; option
                        String boolval;
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">                        if (specarg.length() != 0) {</span>
                            // If there is a given spec token, store it.
<span class="nc" id="L647">                            boolval = specarg;</span>
                        } else {
<span class="fc" id="L649">                            String old = properties.get(opt);</span>
<span class="pc bpc" id="L650" title="3 of 4 branches missed.">                            if (old == null || old.length() == 0) {</span>
<span class="fc" id="L651">                                boolval = &quot;1&quot;;</span>
                            } else {
                                // Increment any previous value as a numeral.
<span class="nc" id="L654">                                boolval = &quot;&quot;+(1+Integer.parseInt(old));</span>
                            }
                        }
<span class="fc" id="L657">                        properties.put(opt, boolval);</span>
<span class="fc" id="L658">                        didAction = true;</span>
<span class="fc" id="L659">                        break;</span>
                    case '=':  // &quot;string&quot; option
                    case '&amp;':  // &quot;collection&quot; option
                        // Read an option.
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">                        boolean append = (specop == '&amp;');</span>
                        String strval;
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">                        if (pbp.hasPrevious()) {</span>
<span class="fc" id="L666">                            strval = pbp.previous();</span>
<span class="fc" id="L667">                            pbp.remove();</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">                        } else if (argp.hasNext()) {</span>
<span class="nc" id="L669">                            strval = argp.next();</span>
                        } else {
<span class="nc" id="L671">                            resultString = arg + &quot; ?&quot;;</span>
<span class="nc" id="L672">                            isError = true;</span>
<span class="nc" id="L673">                            break eachSpec;</span>
                        }
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">                        if (append) {</span>
<span class="nc" id="L676">                            String old = properties.get(opt);</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">                            if (old != null) {</span>
                                // Append new val to old with embedded delim.
<span class="nc" id="L679">                                String delim = specarg;</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                                if (delim.length() == 0)  delim = &quot; &quot;;</span>
<span class="nc" id="L681">                                strval = old + specarg + strval;</span>
                            }
                        }
<span class="fc" id="L684">                        properties.put(opt, strval);</span>
<span class="fc" id="L685">                        didAction = true;</span>
<span class="fc" id="L686">                        break;</span>
                    default:
<span class="nc" id="L688">                        throw new RuntimeException(MessageFormat.format(RESOURCE.getString(DriverResource.BAD_SPEC),opt, spec));</span>
                    }
                }

                // Done processing specs.
<span class="pc bpc" id="L693" title="2 of 4 branches missed.">                if (didAction &amp;&amp; !isError) {</span>
<span class="fc" id="L694">                    continue doArgs;</span>
                }

                // The specs should have done something, but did not.
<span class="nc bnc" id="L698" title="All 2 branches missed.">                while (pbp.nextIndex() &gt; pbpMark) {</span>
                    // Remove anything pushed during these specs.
<span class="nc" id="L700">                    pbp.previous();</span>
<span class="nc" id="L701">                    pbp.remove();</span>
                }

<span class="nc bnc" id="L704" title="All 2 branches missed.">                if (isError) {</span>
<span class="nc" id="L705">                    throw new IllegalArgumentException(resultString);</span>
                }

<span class="nc bnc" id="L708" title="All 2 branches missed.">                if (optlen == 0) {</span>
                    // We cannot try a shorter matching option.
<span class="nc" id="L710">                    break tryOpt;</span>
                }
            }

            // If we come here, there was no matching option.
            // So, push back the argument, and return to caller.
<span class="fc" id="L716">            pbp.add(arg);</span>
<span class="fc" id="L717">            break doArgs;</span>
        }
        // Report number of arguments consumed.
<span class="fc" id="L720">        args.subList(0, argp.nextIndex()).clear();</span>
        // Report any unconsumed partial argument.
<span class="fc bfc" id="L722" title="All 2 branches covered.">        while (pbp.hasPrevious()) {</span>
<span class="fc" id="L723">            args.add(0, pbp.previous());</span>
        }
        //System.out.println(args+&quot; // &quot;+properties+&quot; -&gt; &quot;+resultString);
<span class="fc" id="L726">        return resultString;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>