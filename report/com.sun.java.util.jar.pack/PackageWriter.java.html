<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PackageWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">PackageWriter.java</span></div><h1>PackageWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import com.sun.java.util.jar.pack.ConstantPool.*;
import com.sun.java.util.jar.pack.Package.Class;
import com.sun.java.util.jar.pack.Package.File;
import com.sun.java.util.jar.pack.Package.InnerClass;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import static com.sun.java.util.jar.pack.Constants.*;

/**
 * Writer for a package file.
 * @author John Rose
 */
<span class="nc bnc" id="L49" title="All 2 branches missed.">class PackageWriter extends BandStructure {</span>
    Package pkg;
    OutputStream finalOut;
    Package.Version packageVersion;

<span class="nc" id="L54">    PackageWriter(Package pkg, OutputStream out) throws IOException {</span>
<span class="nc" id="L55">        this.pkg = pkg;</span>
<span class="nc" id="L56">        this.finalOut = out;</span>
        // Caller has specified maximum class file version in the package:
<span class="nc" id="L58">        initHighestClassVersion(pkg.getHighestClassVersion());</span>
<span class="nc" id="L59">    }</span>

    void write() throws IOException {
<span class="nc" id="L62">        boolean ok = false;</span>
        try {
<span class="nc bnc" id="L64" title="All 2 branches missed.">            if (verbose &gt; 0) {</span>
<span class="nc" id="L65">                Utils.log.info(&quot;Setting up constant pool...&quot;);</span>
            }
<span class="nc" id="L67">            setup();</span>

<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (verbose &gt; 0) {</span>
<span class="nc" id="L70">                Utils.log.info(&quot;Packing...&quot;);</span>
            }

            // writeFileHeader() is done last, since it has ultimate counts
            // writeBandHeaders() is called after all other bands are done
<span class="nc" id="L75">            writeConstantPool();</span>
<span class="nc" id="L76">            writeFiles();</span>
<span class="nc" id="L77">            writeAttrDefs();</span>
<span class="nc" id="L78">            writeInnerClasses();</span>
<span class="nc" id="L79">            writeClassesAndByteCodes();</span>
<span class="nc" id="L80">            writeAttrCounts();</span>

<span class="nc bnc" id="L82" title="All 2 branches missed.">            if (verbose &gt; 1)  printCodeHist();</span>

            // choose codings (fill band_headers if needed)
<span class="nc bnc" id="L85" title="All 2 branches missed.">            if (verbose &gt; 0) {</span>
<span class="nc" id="L86">                Utils.log.info(&quot;Coding...&quot;);</span>
            }
<span class="nc" id="L88">            all_bands.chooseBandCodings();</span>

            // now we can write the headers:
<span class="nc" id="L91">            writeFileHeader();</span>

<span class="nc" id="L93">            writeAllBandsTo(finalOut);</span>

<span class="nc" id="L95">            ok = true;</span>
<span class="nc" id="L96">        } catch (Exception ee) {</span>
<span class="nc" id="L97">            Utils.log.warning(&quot;Error on output: &quot;+ee, ee);</span>
            //if (verbose &gt; 0)  ee.printStackTrace();
            // Write partial output only if we are verbose.
<span class="nc bnc" id="L100" title="All 2 branches missed.">            if (verbose &gt; 0)  finalOut.close();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">            if (ee instanceof IOException)  throw (IOException)ee;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">            if (ee instanceof RuntimeException)  throw (RuntimeException)ee;</span>
<span class="nc" id="L103">            throw new Error(&quot;error packing&quot;, ee);</span>
<span class="nc" id="L104">        }</span>
<span class="nc" id="L105">    }</span>

    Set&lt;Entry&gt;                       requiredEntries;  // for the CP
    Map&lt;Attribute.Layout, int[]&gt;     backCountTable;   // for layout callables
    int[][]     attrCounts;       // count attr. occurrences

    void setup() {
<span class="nc" id="L112">        requiredEntries = new HashSet&lt;&gt;();</span>
<span class="nc" id="L113">        setArchiveOptions();</span>
<span class="nc" id="L114">        trimClassAttributes();</span>
<span class="nc" id="L115">        collectAttributeLayouts();</span>
<span class="nc" id="L116">        pkg.buildGlobalConstantPool(requiredEntries);</span>
<span class="nc" id="L117">        setBandIndexes();</span>
<span class="nc" id="L118">        makeNewAttributeBands();</span>
<span class="nc" id="L119">        collectInnerClasses();</span>
<span class="nc" id="L120">    }</span>

    /*
     * Convenience function to choose an archive version based
     * on the class file versions observed within the archive
     * or set the user defined version preset via properties.
     */
    void chooseDefaultPackageVersion() throws IOException {
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (pkg.packageVersion != null) {</span>
<span class="nc" id="L129">            packageVersion = pkg.packageVersion;</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (verbose &gt; 0) {</span>
<span class="nc" id="L131">                Utils.log.info(&quot;package version overridden with: &quot;</span>
                                + packageVersion);
            }
<span class="nc" id="L134">            return;</span>
        }

<span class="nc" id="L137">        Package.Version highV = getHighestClassVersion();</span>
        // set the package version now
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (highV.lessThan(JAVA6_MAX_CLASS_VERSION)) {</span>
            // There are only old classfiles in this segment or resources
<span class="nc" id="L141">            packageVersion = JAVA5_PACKAGE_VERSION;</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        } else if (highV.equals(JAVA6_MAX_CLASS_VERSION) ||</span>
<span class="nc bnc" id="L143" title="All 4 branches missed.">                (highV.equals(JAVA7_MAX_CLASS_VERSION) &amp;&amp; !pkg.cp.haveExtraTags())) {</span>
            // force down the package version if we have jdk7 classes without
            // any Indy references, this is because jdk7 class file (51.0) without
            // Indy is identical to jdk6 class file (50.0).
<span class="nc" id="L147">            packageVersion = JAVA6_PACKAGE_VERSION;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        } else if (highV.equals(JAVA7_MAX_CLASS_VERSION)) {</span>
<span class="nc" id="L149">            packageVersion = JAVA7_PACKAGE_VERSION;</span>
        } else {
            // Normal case.  Use the newest archive format, when available
<span class="nc" id="L152">            packageVersion = JAVA8_PACKAGE_VERSION;</span>
        }

<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (verbose &gt; 0) {</span>
<span class="nc" id="L156">            Utils.log.info(&quot;Highest version class file: &quot; + highV</span>
                    + &quot; package version: &quot; + packageVersion);
        }
<span class="nc" id="L159">    }</span>

    void checkVersion() throws IOException {
<span class="nc bnc" id="L162" title="All 4 branches missed.">        assert(packageVersion != null);</span>

<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (packageVersion.lessThan(JAVA7_PACKAGE_VERSION)) {</span>
            // this bit was reserved for future use in previous versions
<span class="nc bnc" id="L166" title="All 2 branches missed.">            if (testBit(archiveOptions, AO_HAVE_CP_EXTRAS)) {</span>
<span class="nc" id="L167">                throw new IOException(&quot;Format bits for Java 7 must be zero in previous releases&quot;);</span>
            }
        }
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (testBit(archiveOptions, AO_UNUSED_MBZ)) {</span>
<span class="nc" id="L171">            throw new IOException(&quot;High archive option bits are reserved and must be zero: &quot; + Integer.toHexString(archiveOptions));</span>
        }
<span class="nc" id="L173">    }</span>

    void setArchiveOptions() {
        // Decide on some archive options early.
        // Does not decide on: AO_HAVE_SPECIAL_FORMATS,
        // AO_HAVE_CP_NUMBERS, AO_HAVE_FILE_HEADERS.
        // Also, AO_HAVE_FILE_OPTIONS may be forced on later.
<span class="nc" id="L180">        int minModtime = pkg.default_modtime;</span>
<span class="nc" id="L181">        int maxModtime = pkg.default_modtime;</span>
<span class="nc" id="L182">        int minOptions = -1;</span>
<span class="nc" id="L183">        int maxOptions = 0;</span>

        // Import defaults from package (deflate hint, etc.).
<span class="nc" id="L186">        archiveOptions |= pkg.default_options;</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">        for (File file : pkg.files) {</span>
<span class="nc" id="L189">            int modtime = file.modtime;</span>
<span class="nc" id="L190">            int options = file.options;</span>

<span class="nc bnc" id="L192" title="All 2 branches missed.">            if (minModtime == NO_MODTIME) {</span>
<span class="nc" id="L193">                minModtime = maxModtime = modtime;</span>
            } else {
<span class="nc bnc" id="L195" title="All 2 branches missed.">                if (minModtime &gt; modtime)  minModtime = modtime;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                if (maxModtime &lt; modtime)  maxModtime = modtime;</span>
            }
<span class="nc" id="L198">            minOptions &amp;= options;</span>
<span class="nc" id="L199">            maxOptions |= options;</span>
<span class="nc" id="L200">        }</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (pkg.default_modtime == NO_MODTIME) {</span>
            // Make everything else be a positive offset from here.
<span class="nc" id="L203">            pkg.default_modtime = minModtime;</span>
        }
<span class="nc bnc" id="L205" title="All 4 branches missed.">        if (minModtime != NO_MODTIME &amp;&amp; minModtime != maxModtime) {</span>
            // Put them into a band.
<span class="nc" id="L207">            archiveOptions |= AO_HAVE_FILE_MODTIME;</span>
        }
        // If the archive deflation is set do not bother with each file.
<span class="nc bnc" id="L210" title="All 4 branches missed.">        if (!testBit(archiveOptions,AO_DEFLATE_HINT) &amp;&amp; minOptions != -1) {</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (testBit(minOptions, FO_DEFLATE_HINT)) {</span>
                // Every file has the deflate_hint set.
                // Set it for the whole archive, and omit options.
<span class="nc" id="L214">                archiveOptions |= AO_DEFLATE_HINT;</span>
<span class="nc" id="L215">                minOptions -= FO_DEFLATE_HINT;</span>
<span class="nc" id="L216">                maxOptions -= FO_DEFLATE_HINT;</span>
            }
<span class="nc" id="L218">            pkg.default_options |= minOptions;</span>
<span class="nc bnc" id="L219" title="All 4 branches missed.">            if (minOptions != maxOptions</span>
                || minOptions != pkg.default_options) {
<span class="nc" id="L221">                archiveOptions |= AO_HAVE_FILE_OPTIONS;</span>
            }
        }
        // Decide on default version number (majority rule).
<span class="nc" id="L225">        Map&lt;Package.Version, int[]&gt; verCounts = new HashMap&lt;&gt;();</span>
<span class="nc" id="L226">        int bestCount = 0;</span>
<span class="nc" id="L227">        Package.Version bestVersion = null;</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        for (Class cls : pkg.classes) {</span>
<span class="nc" id="L229">            Package.Version version = cls.getVersion();</span>
<span class="nc" id="L230">            int[] var = verCounts.get(version);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if (var == null) {</span>
<span class="nc" id="L232">                var = new int[1];</span>
<span class="nc" id="L233">                verCounts.put(version, var);</span>
            }
<span class="nc" id="L235">            int count = (var[0] += 1);</span>
            //System.out.println(&quot;version=&quot;+version+&quot; count=&quot;+count);
<span class="nc bnc" id="L237" title="All 2 branches missed.">            if (bestCount &lt; count) {</span>
<span class="nc" id="L238">                bestCount = count;</span>
<span class="nc" id="L239">                bestVersion = version;</span>
            }
<span class="nc" id="L241">        }</span>
<span class="nc" id="L242">        verCounts.clear();</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (bestVersion == null)  bestVersion = JAVA_MIN_CLASS_VERSION;  // degenerate case</span>
<span class="nc" id="L244">        pkg.defaultClassVersion = bestVersion;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (verbose &gt; 0)</span>
<span class="nc" id="L246">           Utils.log.info(&quot;Consensus version number in segment is &quot; + bestVersion);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (verbose &gt; 0)</span>
<span class="nc" id="L248">            Utils.log.info(&quot;Highest version number in segment is &quot;</span>
<span class="nc" id="L249">                            + pkg.getHighestClassVersion());</span>

        // Now add explicit pseudo-attrs. to classes with odd versions.
<span class="nc bnc" id="L252" title="All 2 branches missed.">        for (Class cls : pkg.classes) {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (!cls.getVersion().equals(bestVersion)) {</span>
<span class="nc" id="L254">                Attribute a = makeClassFileVersionAttr(cls.getVersion());</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                if (verbose &gt; 1) {</span>
<span class="nc" id="L256">                    Utils.log.fine(&quot;Version &quot;+cls.getVersion() + &quot; of &quot; + cls</span>
                                     + &quot; doesn't match package version &quot;
                                     + bestVersion);
                }
                // Note:  Does not add in &quot;natural&quot; order.  (Who cares?)
<span class="nc" id="L261">                cls.addAttribute(a);</span>
            }
<span class="nc" id="L263">        }</span>

        // Decide if we are transmitting a huge resource file:
<span class="nc bnc" id="L266" title="All 2 branches missed.">        for (File file : pkg.files) {</span>
<span class="nc" id="L267">            long len = file.getFileLength();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (len != (int)len) {</span>
<span class="nc" id="L269">                archiveOptions |= AO_HAVE_FILE_SIZE_HI;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                if (verbose &gt; 0)</span>
<span class="nc" id="L271">                   Utils.log.info(&quot;Note: Huge resource file &quot;+file.getFileName()+&quot; forces 64-bit sizing&quot;);</span>
                break;
            }
<span class="nc" id="L274">        }</span>

        // Decide if code attributes typically have sub-attributes.
        // In that case, to preserve compact 1-byte code headers,
        // we must declare unconditional presence of code flags.
<span class="nc" id="L279">        int cost0 = 0;</span>
<span class="nc" id="L280">        int cost1 = 0;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        for (Class cls : pkg.classes) {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">            for (Class.Method m : cls.getMethods()) {</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                if (m.code != null) {</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                    if (m.code.attributeSize() == 0) {</span>
                        // cost of a useless unconditional flags byte
<span class="nc" id="L286">                        cost1 += 1;</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                    } else if (shortCodeHeader(m.code) != LONG_CODE_HEADER) {</span>
                        // cost of inflating a short header
<span class="nc" id="L289">                        cost0 += 3;</span>
                    }
                }
<span class="nc" id="L292">            }</span>
<span class="nc" id="L293">        }</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (cost0 &gt; cost1) {</span>
<span class="nc" id="L295">            archiveOptions |= AO_HAVE_ALL_CODE_FLAGS;</span>
        }
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (verbose &gt; 0)</span>
<span class="nc" id="L298">            Utils.log.info(&quot;archiveOptions = &quot;</span>
<span class="nc" id="L299">                             +&quot;0b&quot;+Integer.toBinaryString(archiveOptions));</span>
<span class="nc" id="L300">    }</span>

    void writeFileHeader() throws IOException {
<span class="nc" id="L303">        chooseDefaultPackageVersion();</span>
<span class="nc" id="L304">        writeArchiveMagic();</span>
<span class="nc" id="L305">        writeArchiveHeader();</span>
<span class="nc" id="L306">    }</span>

    // Local routine used to format fixed-format scalars
    // in the file_header:
    private void putMagicInt32(int val) throws IOException {
<span class="nc" id="L311">        int res = val;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="nc" id="L313">            archive_magic.putByte(0xFF &amp; (res &gt;&gt;&gt; 24));</span>
<span class="nc" id="L314">            res &lt;&lt;= 8;</span>
        }
<span class="nc" id="L316">    }</span>

    void writeArchiveMagic() throws IOException {
<span class="nc" id="L319">        putMagicInt32(pkg.magic);</span>
<span class="nc" id="L320">    }</span>

    void writeArchiveHeader() throws IOException {
        // for debug only:  number of words optimized away
<span class="nc" id="L324">        int headerSizeForDebug = AH_LENGTH_MIN;</span>

        // AO_HAVE_SPECIAL_FORMATS is set if non-default
        // coding techniques are used, or if there are
        // compressor-defined attributes transmitted.
<span class="nc" id="L329">        boolean haveSpecial = testBit(archiveOptions, AO_HAVE_SPECIAL_FORMATS);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (!haveSpecial) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">            haveSpecial |= (band_headers.length() != 0);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            haveSpecial |= (attrDefsWritten.length != 0);</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (haveSpecial)</span>
<span class="nc" id="L334">                archiveOptions |= AO_HAVE_SPECIAL_FORMATS;</span>
        }
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (haveSpecial)</span>
<span class="nc" id="L337">            headerSizeForDebug += AH_SPECIAL_FORMAT_LEN;</span>

        // AO_HAVE_FILE_HEADERS is set if there is any
        // file or segment envelope information present.
<span class="nc" id="L341">        boolean haveFiles = testBit(archiveOptions, AO_HAVE_FILE_HEADERS);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (!haveFiles) {</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            haveFiles |= (archiveNextCount &gt; 0);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            haveFiles |= (pkg.default_modtime != NO_MODTIME);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            if (haveFiles)</span>
<span class="nc" id="L346">                archiveOptions |= AO_HAVE_FILE_HEADERS;</span>
        }
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (haveFiles)</span>
<span class="nc" id="L349">            headerSizeForDebug += AH_FILE_HEADER_LEN;</span>

        // AO_HAVE_CP_NUMBERS is set if there are any numbers
        // in the global constant pool.  (Numbers are in 15% of classes.)
<span class="nc" id="L353">        boolean haveNumbers = testBit(archiveOptions, AO_HAVE_CP_NUMBERS);</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (!haveNumbers) {</span>
<span class="nc" id="L355">            haveNumbers |= pkg.cp.haveNumbers();</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">            if (haveNumbers)</span>
<span class="nc" id="L357">                archiveOptions |= AO_HAVE_CP_NUMBERS;</span>
        }
<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (haveNumbers)</span>
<span class="nc" id="L360">            headerSizeForDebug += AH_CP_NUMBER_LEN;</span>

        // AO_HAVE_CP_EXTRAS is set if there are constant pool entries
        // beyond the Java 6 version of the class file format.
<span class="nc" id="L364">        boolean haveCPExtra = testBit(archiveOptions, AO_HAVE_CP_EXTRAS);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (!haveCPExtra) {</span>
<span class="nc" id="L366">            haveCPExtra |= pkg.cp.haveExtraTags();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (haveCPExtra)</span>
<span class="nc" id="L368">                archiveOptions |= AO_HAVE_CP_EXTRAS;</span>
        }
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (haveCPExtra)</span>
<span class="nc" id="L371">            headerSizeForDebug += AH_CP_EXTRA_LEN;</span>

        // the archiveOptions are all initialized, sanity check now!.
<span class="nc" id="L374">        checkVersion();</span>

<span class="nc" id="L376">        archive_header_0.putInt(packageVersion.minor);</span>
<span class="nc" id="L377">        archive_header_0.putInt(packageVersion.major);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (verbose &gt; 0)</span>
<span class="nc" id="L379">            Utils.log.info(&quot;Package Version for this segment:&quot; + packageVersion);</span>
<span class="nc" id="L380">        archive_header_0.putInt(archiveOptions); // controls header format</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">        assert(archive_header_0.length() == AH_LENGTH_0);</span>

        final int DUMMY = 0;
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (haveFiles) {</span>
<span class="nc bnc" id="L385" title="All 4 branches missed.">            assert(archive_header_S.length() == AH_ARCHIVE_SIZE_HI);</span>
<span class="nc" id="L386">            archive_header_S.putInt(DUMMY); // (archiveSize1 &gt;&gt;&gt; 32)</span>
<span class="nc bnc" id="L387" title="All 4 branches missed.">            assert(archive_header_S.length() == AH_ARCHIVE_SIZE_LO);</span>
<span class="nc" id="L388">            archive_header_S.putInt(DUMMY); // (archiveSize1 &gt;&gt;&gt; 0)</span>
<span class="nc bnc" id="L389" title="All 4 branches missed.">            assert(archive_header_S.length() == AH_LENGTH_S);</span>
        }

        // Done with unsized part of header....

<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (haveFiles) {</span>
<span class="nc" id="L395">            archive_header_1.putInt(archiveNextCount);  // usually zero</span>
<span class="nc" id="L396">            archive_header_1.putInt(pkg.default_modtime);</span>
<span class="nc" id="L397">            archive_header_1.putInt(pkg.files.size());</span>
        } else {
<span class="nc bnc" id="L399" title="All 4 branches missed.">            assert(pkg.files.isEmpty());</span>
        }

<span class="nc bnc" id="L402" title="All 2 branches missed.">        if (haveSpecial) {</span>
<span class="nc" id="L403">            archive_header_1.putInt(band_headers.length());</span>
<span class="nc" id="L404">            archive_header_1.putInt(attrDefsWritten.length);</span>
        } else {
<span class="nc bnc" id="L406" title="All 4 branches missed.">            assert(band_headers.length() == 0);</span>
<span class="nc bnc" id="L407" title="All 4 branches missed.">            assert(attrDefsWritten.length == 0);</span>
        }

<span class="nc" id="L410">        writeConstantPoolCounts(haveNumbers, haveCPExtra);</span>

<span class="nc" id="L412">        archive_header_1.putInt(pkg.getAllInnerClasses().size());</span>
<span class="nc" id="L413">        archive_header_1.putInt(pkg.defaultClassVersion.minor);</span>
<span class="nc" id="L414">        archive_header_1.putInt(pkg.defaultClassVersion.major);</span>
<span class="nc" id="L415">        archive_header_1.putInt(pkg.classes.size());</span>

        // Sanity:  Make sure we came out to 29 (less optional fields):
<span class="nc bnc" id="L418" title="All 2 branches missed.">        assert(archive_header_0.length() +</span>
<span class="nc" id="L419">               archive_header_S.length() +</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">               archive_header_1.length()</span>
               == headerSizeForDebug);

        // Figure out all the sizes now, first cut:
<span class="nc" id="L424">        archiveSize0 = 0;</span>
<span class="nc" id="L425">        archiveSize1 = all_bands.outputSize();</span>
        // Second cut:
<span class="nc" id="L427">        archiveSize0 += archive_magic.outputSize();</span>
<span class="nc" id="L428">        archiveSize0 += archive_header_0.outputSize();</span>
<span class="nc" id="L429">        archiveSize0 += archive_header_S.outputSize();</span>
        // Make the adjustments:
<span class="nc" id="L431">        archiveSize1 -= archiveSize0;</span>

        // Patch the header:
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (haveFiles) {</span>
<span class="nc" id="L435">            int archiveSizeHi = (int)(archiveSize1 &gt;&gt;&gt; 32);</span>
<span class="nc" id="L436">            int archiveSizeLo = (int)(archiveSize1 &gt;&gt;&gt; 0);</span>
<span class="nc" id="L437">            archive_header_S.patchValue(AH_ARCHIVE_SIZE_HI, archiveSizeHi);</span>
<span class="nc" id="L438">            archive_header_S.patchValue(AH_ARCHIVE_SIZE_LO, archiveSizeLo);</span>
<span class="nc" id="L439">            int zeroLen = UNSIGNED5.getLength(DUMMY);</span>
<span class="nc" id="L440">            archiveSize0 += UNSIGNED5.getLength(archiveSizeHi) - zeroLen;</span>
<span class="nc" id="L441">            archiveSize0 += UNSIGNED5.getLength(archiveSizeLo) - zeroLen;</span>
        }
<span class="nc bnc" id="L443" title="All 2 branches missed.">        if (verbose &gt; 1)</span>
<span class="nc" id="L444">            Utils.log.fine(&quot;archive sizes: &quot;+</span>
                             archiveSize0+&quot;+&quot;+archiveSize1);
<span class="nc bnc" id="L446" title="All 4 branches missed.">        assert(all_bands.outputSize() == archiveSize0+archiveSize1);</span>
<span class="nc" id="L447">    }</span>

    void writeConstantPoolCounts(boolean haveNumbers, boolean haveCPExtra) throws IOException {
<span class="nc bnc" id="L450" title="All 2 branches missed.">        for (byte tag : ConstantPool.TAGS_IN_ORDER) {</span>
<span class="nc" id="L451">            int count = pkg.cp.getIndexByTag(tag).size();</span>
<span class="nc bnc" id="L452" title="All 4 branches missed.">            switch (tag) {</span>
            case CONSTANT_Utf8:
                // The null string is always first.
<span class="nc bnc" id="L455" title="All 2 branches missed.">                if (count &gt; 0)</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                    assert(pkg.cp.getIndexByTag(tag).get(0)</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                           == ConstantPool.getUtf8Entry(&quot;&quot;));</span>
                break;

            case CONSTANT_Integer:
            case CONSTANT_Float:
            case CONSTANT_Long:
            case CONSTANT_Double:
                // Omit counts for numbers if possible.
<span class="nc bnc" id="L465" title="All 2 branches missed.">                if (!haveNumbers) {</span>
<span class="nc bnc" id="L466" title="All 4 branches missed.">                    assert(count == 0);</span>
                    continue;
                }
                break;

            case CONSTANT_MethodHandle:
            case CONSTANT_MethodType:
            case CONSTANT_InvokeDynamic:
            case CONSTANT_BootstrapMethod:
                // Omit counts for newer entities if possible.
<span class="nc bnc" id="L476" title="All 2 branches missed.">                if (!haveCPExtra) {</span>
<span class="nc bnc" id="L477" title="All 4 branches missed.">                    assert(count == 0);</span>
                    continue;
                }
                break;
            }
<span class="nc" id="L482">            archive_header_1.putInt(count);</span>
        }
<span class="nc" id="L484">    }</span>

    protected Index getCPIndex(byte tag) {
<span class="nc" id="L487">        return pkg.cp.getIndexByTag(tag);</span>
    }

// (The following observations are out of date; they apply only to
// &quot;banding&quot; the constant pool itself.  Later revisions of this algorithm
// applied the banding technique to every part of the package file,
// applying the benefits more broadly.)

// Note:  Keeping the data separate in passes (or &quot;bands&quot;) allows the
// compressor to issue significantly shorter indexes for repeated data.
// The difference in zipped size is 4%, which is remarkable since the
// unzipped sizes are the same (only the byte order differs).

// After moving similar data into bands, it becomes natural to delta-encode
// each band.  (This is especially useful if we sort the constant pool first.)
// Delta encoding saves an extra 5% in the output size (13% of the CP itself).
// Because a typical delta usees much less data than a byte, the savings after
// zipping is even better:  A zipped delta-encoded package is 8% smaller than
// a zipped non-delta-encoded package.  Thus, in the zipped file, a banded,
// delta-encoded constant pool saves over 11% (of the total file size) compared
// with a zipped unbanded file.

    void writeConstantPool() throws IOException {
<span class="nc" id="L510">        IndexGroup cp = pkg.cp;</span>

<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (verbose &gt; 0)  Utils.log.info(&quot;Writing CP&quot;);</span>

<span class="nc bnc" id="L514" title="All 2 branches missed.">        for (byte tag : ConstantPool.TAGS_IN_ORDER) {</span>
<span class="nc" id="L515">            Index index = cp.getIndexByTag(tag);</span>

<span class="nc" id="L517">            Entry[] cpMap = index.cpMap;</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">            if (verbose &gt; 0)</span>
<span class="nc" id="L519">                Utils.log.info(&quot;Writing &quot;+cpMap.length+&quot; &quot;+ConstantPool.tagName(tag)+&quot; entries...&quot;);</span>

<span class="nc bnc" id="L521" title="All 2 branches missed.">            if (optDumpBands) {</span>
<span class="nc" id="L522">                try (PrintStream ps = new PrintStream(getDumpStream(index, &quot;.idx&quot;))) {</span>
<span class="nc" id="L523">                    printArrayTo(ps, cpMap, 0, cpMap.length);</span>
<span class="nc bnc" id="L524" title="All 8 branches missed.">                }</span>
            }

<span class="nc bnc" id="L527" title="All 17 branches missed.">            switch (tag) {</span>
            case CONSTANT_Utf8:
<span class="nc" id="L529">                writeUtf8Bands(cpMap);</span>
<span class="nc" id="L530">                break;</span>
            case CONSTANT_Integer:
<span class="nc bnc" id="L532" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L533">                    NumberEntry e = (NumberEntry) cpMap[i];</span>
<span class="nc" id="L534">                    int x = ((Integer)e.numberValue()).intValue();</span>
<span class="nc" id="L535">                    cp_Int.putInt(x);</span>
                }
<span class="nc" id="L537">                break;</span>
            case CONSTANT_Float:
<span class="nc bnc" id="L539" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L540">                    NumberEntry e = (NumberEntry) cpMap[i];</span>
<span class="nc" id="L541">                    float fx = ((Float)e.numberValue()).floatValue();</span>
<span class="nc" id="L542">                    int x = Float.floatToIntBits(fx);</span>
<span class="nc" id="L543">                    cp_Float.putInt(x);</span>
                }
<span class="nc" id="L545">                break;</span>
            case CONSTANT_Long:
<span class="nc bnc" id="L547" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L548">                    NumberEntry e = (NumberEntry) cpMap[i];</span>
<span class="nc" id="L549">                    long x = ((Long)e.numberValue()).longValue();</span>
<span class="nc" id="L550">                    cp_Long_hi.putInt((int)(x &gt;&gt;&gt; 32));</span>
<span class="nc" id="L551">                    cp_Long_lo.putInt((int)(x &gt;&gt;&gt; 0));</span>
                }
<span class="nc" id="L553">                break;</span>
            case CONSTANT_Double:
<span class="nc bnc" id="L555" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L556">                    NumberEntry e = (NumberEntry) cpMap[i];</span>
<span class="nc" id="L557">                    double dx = ((Double)e.numberValue()).doubleValue();</span>
<span class="nc" id="L558">                    long x = Double.doubleToLongBits(dx);</span>
<span class="nc" id="L559">                    cp_Double_hi.putInt((int)(x &gt;&gt;&gt; 32));</span>
<span class="nc" id="L560">                    cp_Double_lo.putInt((int)(x &gt;&gt;&gt; 0));</span>
                }
<span class="nc" id="L562">                break;</span>
            case CONSTANT_String:
<span class="nc bnc" id="L564" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L565">                    StringEntry e = (StringEntry) cpMap[i];</span>
<span class="nc" id="L566">                    cp_String.putRef(e.ref);</span>
                }
<span class="nc" id="L568">                break;</span>
            case CONSTANT_Class:
<span class="nc bnc" id="L570" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L571">                    ClassEntry e = (ClassEntry) cpMap[i];</span>
<span class="nc" id="L572">                    cp_Class.putRef(e.ref);</span>
                }
<span class="nc" id="L574">                break;</span>
            case CONSTANT_Signature:
<span class="nc" id="L576">                writeSignatureBands(cpMap);</span>
<span class="nc" id="L577">                break;</span>
            case CONSTANT_NameandType:
<span class="nc bnc" id="L579" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L580">                    DescriptorEntry e = (DescriptorEntry) cpMap[i];</span>
<span class="nc" id="L581">                    cp_Descr_name.putRef(e.nameRef);</span>
<span class="nc" id="L582">                    cp_Descr_type.putRef(e.typeRef);</span>
                }
<span class="nc" id="L584">                break;</span>
            case CONSTANT_Fieldref:
<span class="nc" id="L586">                writeMemberRefs(tag, cpMap, cp_Field_class, cp_Field_desc);</span>
<span class="nc" id="L587">                break;</span>
            case CONSTANT_Methodref:
<span class="nc" id="L589">                writeMemberRefs(tag, cpMap, cp_Method_class, cp_Method_desc);</span>
<span class="nc" id="L590">                break;</span>
            case CONSTANT_InterfaceMethodref:
<span class="nc" id="L592">                writeMemberRefs(tag, cpMap, cp_Imethod_class, cp_Imethod_desc);</span>
<span class="nc" id="L593">                break;</span>
            case CONSTANT_MethodHandle:
<span class="nc bnc" id="L595" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L596">                    MethodHandleEntry e = (MethodHandleEntry) cpMap[i];</span>
<span class="nc" id="L597">                    cp_MethodHandle_refkind.putInt(e.refKind);</span>
<span class="nc" id="L598">                    cp_MethodHandle_member.putRef(e.memRef);</span>
                }
<span class="nc" id="L600">                break;</span>
            case CONSTANT_MethodType:
<span class="nc bnc" id="L602" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L603">                    MethodTypeEntry e = (MethodTypeEntry) cpMap[i];</span>
<span class="nc" id="L604">                    cp_MethodType.putRef(e.typeRef);</span>
                }
<span class="nc" id="L606">                break;</span>
            case CONSTANT_InvokeDynamic:
<span class="nc bnc" id="L608" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L609">                    InvokeDynamicEntry e = (InvokeDynamicEntry) cpMap[i];</span>
<span class="nc" id="L610">                    cp_InvokeDynamic_spec.putRef(e.bssRef);</span>
<span class="nc" id="L611">                    cp_InvokeDynamic_desc.putRef(e.descRef);</span>
                }
<span class="nc" id="L613">                break;</span>
            case CONSTANT_BootstrapMethod:
<span class="nc bnc" id="L615" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L616">                    BootstrapMethodEntry e = (BootstrapMethodEntry) cpMap[i];</span>
<span class="nc" id="L617">                    cp_BootstrapMethod_ref.putRef(e.bsmRef);</span>
<span class="nc" id="L618">                    cp_BootstrapMethod_arg_count.putInt(e.argRefs.length);</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">                    for (Entry argRef : e.argRefs) {</span>
<span class="nc" id="L620">                        cp_BootstrapMethod_arg.putRef(argRef);</span>
                    }
                }
<span class="nc" id="L623">                break;</span>
            default:
<span class="nc" id="L625">                throw new AssertionError(&quot;unexpected CP tag in package&quot;);</span>
            }
        }
<span class="nc bnc" id="L628" title="All 4 branches missed.">        if (optDumpBands || verbose &gt; 1) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">            for (byte tag = CONSTANT_GroupFirst; tag &lt; CONSTANT_GroupLimit; tag++) {</span>
<span class="nc" id="L630">                Index index = cp.getIndexByTag(tag);</span>
<span class="nc bnc" id="L631" title="All 4 branches missed.">                if (index == null || index.isEmpty())  continue;</span>
<span class="nc" id="L632">                Entry[] cpMap = index.cpMap;</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">                if (verbose &gt; 1)</span>
<span class="nc" id="L634">                    Utils.log.info(&quot;Index group &quot;+ConstantPool.tagName(tag)+&quot; contains &quot;+cpMap.length+&quot; entries.&quot;);</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                if (optDumpBands) {</span>
<span class="nc" id="L636">                    try (PrintStream ps = new PrintStream(getDumpStream(index.debugName, tag, &quot;.gidx&quot;, index))) {</span>
<span class="nc" id="L637">                        printArrayTo(ps, cpMap, 0, cpMap.length, true);</span>
<span class="nc bnc" id="L638" title="All 8 branches missed.">                    }</span>
                }
            }
        }
<span class="nc" id="L642">    }</span>

    void writeUtf8Bands(Entry[] cpMap) throws IOException {
<span class="nc bnc" id="L645" title="All 2 branches missed.">        if (cpMap.length == 0)</span>
<span class="nc" id="L646">            return;  // nothing to write</span>

        // The first element must always be the empty string.
<span class="nc bnc" id="L649" title="All 4 branches missed.">        assert(cpMap[0].stringValue().equals(&quot;&quot;));</span>
        final int SUFFIX_SKIP_1 = 1;
        final int PREFIX_SKIP_2 = 2;

        // Fetch the char arrays, first of all.
<span class="nc" id="L654">        char[][] chars = new char[cpMap.length][];</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">        for (int i = 0; i &lt; chars.length; i++) {</span>
<span class="nc" id="L656">            chars[i] = cpMap[i].stringValue().toCharArray();</span>
        }

        // First band:  Write lengths of shared prefixes.
<span class="nc" id="L660">        int[] prefixes = new int[cpMap.length];  // includes 2 skipped zeroes</span>
<span class="nc" id="L661">        char[] prevChars = {};</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        for (int i = 0; i &lt; chars.length; i++) {</span>
<span class="nc" id="L663">            int prefix = 0;</span>
<span class="nc" id="L664">            char[] curChars = chars[i];</span>
<span class="nc" id="L665">            int limit = Math.min(curChars.length, prevChars.length);</span>
<span class="nc bnc" id="L666" title="All 4 branches missed.">            while (prefix &lt; limit &amp;&amp; curChars[prefix] == prevChars[prefix])</span>
<span class="nc" id="L667">                prefix++;</span>
<span class="nc" id="L668">            prefixes[i] = prefix;</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">            if (i &gt;= PREFIX_SKIP_2)</span>
<span class="nc" id="L670">                cp_Utf8_prefix.putInt(prefix);</span>
            else
<span class="nc bnc" id="L672" title="All 4 branches missed.">                assert(prefix == 0);</span>
<span class="nc" id="L673">            prevChars = curChars;</span>
        }

        // Second band:  Write lengths of unshared suffixes.
        // Third band:  Write the char values in the unshared suffixes.
<span class="nc bnc" id="L678" title="All 2 branches missed.">        for (int i = 0; i &lt; chars.length; i++) {</span>
<span class="nc" id="L679">            char[] str = chars[i];</span>
<span class="nc" id="L680">            int prefix = prefixes[i];</span>
<span class="nc" id="L681">            int suffix = str.length - prefixes[i];</span>
<span class="nc" id="L682">            boolean isPacked = false;</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">            if (suffix == 0) {</span>
                // Zero suffix length is special flag to indicate
                // separate treatment in cp_Utf8_big bands.
                // This suffix length never occurs naturally,
                // except in the one case of a zero-length string.
                // (If it occurs, it is the first, due to sorting.)
                // The zero length string must, paradoxically, be
                // encoded as a zero-length cp_Utf8_big band.
                // This wastes exactly (&amp; tolerably) one null byte.
<span class="nc bnc" id="L692" title="All 2 branches missed.">                isPacked = (i &gt;= SUFFIX_SKIP_1);</span>
                // Do not bother to add an empty &quot;(Utf8_big_0)&quot; band.
                // Also, the initial empty string does not require a band.
<span class="nc bnc" id="L695" title="All 6 branches missed.">            } else if (optBigStrings &amp;&amp; effort &gt; 1 &amp;&amp; suffix &gt; 100) {</span>
<span class="nc" id="L696">                int numWide = 0;</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">                for (int n = 0; n &lt; suffix; n++) {</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">                    if (str[prefix+n] &gt; 127) {</span>
<span class="nc" id="L699">                        numWide++;</span>
                    }
                }
<span class="nc bnc" id="L702" title="All 2 branches missed.">                if (numWide &gt; 100) {</span>
                    // Try packing the chars with an alternate encoding.
<span class="nc" id="L704">                    isPacked = tryAlternateEncoding(i, numWide, str, prefix);</span>
                }
            }
<span class="nc bnc" id="L707" title="All 2 branches missed.">            if (i &lt; SUFFIX_SKIP_1) {</span>
                // No output.
<span class="nc bnc" id="L709" title="All 4 branches missed.">                assert(!isPacked);</span>
<span class="nc bnc" id="L710" title="All 4 branches missed.">                assert(suffix == 0);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">            } else if (isPacked) {</span>
                // Mark packed string with zero-length suffix count.
                // This tells the unpacker to go elsewhere for the suffix bits.
                // Fourth band:  Write unshared suffix with alternate coding.
<span class="nc" id="L715">                cp_Utf8_suffix.putInt(0);</span>
<span class="nc" id="L716">                cp_Utf8_big_suffix.putInt(suffix);</span>
            } else {
<span class="nc bnc" id="L718" title="All 4 branches missed.">                assert(suffix != 0);  // would be ambiguous</span>
                // Normal string.  Save suffix in third and fourth bands.
<span class="nc" id="L720">                cp_Utf8_suffix.putInt(suffix);</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                for (int n = 0; n &lt; suffix; n++) {</span>
<span class="nc" id="L722">                    int ch = str[prefix+n];</span>
<span class="nc" id="L723">                    cp_Utf8_chars.putInt(ch);</span>
                }
            }
        }
<span class="nc bnc" id="L727" title="All 2 branches missed.">        if (verbose &gt; 0) {</span>
<span class="nc" id="L728">            int normCharCount = cp_Utf8_chars.length();</span>
<span class="nc" id="L729">            int packCharCount = cp_Utf8_big_chars.length();</span>
<span class="nc" id="L730">            int charCount = normCharCount + packCharCount;</span>
<span class="nc" id="L731">            Utils.log.info(&quot;Utf8string #CHARS=&quot;+charCount+&quot; #PACKEDCHARS=&quot;+packCharCount);</span>
        }
<span class="nc" id="L733">    }</span>

    private boolean tryAlternateEncoding(int i, int numWide,
                                         char[] str, int prefix) {
<span class="nc" id="L737">        int suffix = str.length - prefix;</span>
<span class="nc" id="L738">        int[] cvals = new int[suffix];</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">        for (int n = 0; n &lt; suffix; n++) {</span>
<span class="nc" id="L740">            cvals[n] = str[prefix+n];</span>
        }
<span class="nc" id="L742">        CodingChooser cc = getCodingChooser();</span>
<span class="nc" id="L743">        Coding bigRegular = cp_Utf8_big_chars.regularCoding;</span>
<span class="nc" id="L744">        String bandName = &quot;(Utf8_big_&quot;+i+&quot;)&quot;;</span>
<span class="nc" id="L745">        int[] sizes = { 0, 0 };</span>
        final int BYTE_SIZE = CodingChooser.BYTE_SIZE;
        final int ZIP_SIZE = CodingChooser.ZIP_SIZE;
<span class="nc bnc" id="L748" title="All 4 branches missed.">        if (verbose &gt; 1 || cc.verbose &gt; 1) {</span>
<span class="nc" id="L749">            Utils.log.fine(&quot;--- chooseCoding &quot;+bandName);</span>
        }
<span class="nc" id="L751">        CodingMethod special = cc.choose(cvals, bigRegular, sizes);</span>
<span class="nc" id="L752">        Coding charRegular = cp_Utf8_chars.regularCoding;</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (verbose &gt; 1)</span>
<span class="nc" id="L754">            Utils.log.fine(&quot;big string[&quot;+i+&quot;] len=&quot;+suffix+&quot; #wide=&quot;+numWide+&quot; size=&quot;+sizes[BYTE_SIZE]+&quot;/z=&quot;+sizes[ZIP_SIZE]+&quot; coding &quot;+special);</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">        if (special != charRegular) {</span>
<span class="nc" id="L756">            int specialZipSize = sizes[ZIP_SIZE];</span>
<span class="nc" id="L757">            int[] normalSizes = cc.computeSize(charRegular, cvals);</span>
<span class="nc" id="L758">            int normalZipSize = normalSizes[ZIP_SIZE];</span>
<span class="nc" id="L759">            int minWin = Math.max(5, normalZipSize/1000);</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">            if (verbose &gt; 1)</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">                Utils.log.fine(&quot;big string[&quot;+i+&quot;] normalSize=&quot;+normalSizes[BYTE_SIZE]+&quot;/z=&quot;+normalSizes[ZIP_SIZE]+&quot; win=&quot;+(specialZipSize&lt;normalZipSize-minWin));</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">            if (specialZipSize &lt; normalZipSize-minWin) {</span>
<span class="nc" id="L763">                IntBand big = cp_Utf8_big_chars.newIntBand(bandName);</span>
<span class="nc" id="L764">                big.initializeValues(cvals);</span>
<span class="nc" id="L765">                return true;</span>
            }
        }
<span class="nc" id="L768">        return false;</span>
    }

    void writeSignatureBands(Entry[] cpMap) throws IOException {
<span class="nc bnc" id="L772" title="All 2 branches missed.">        for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L773">            SignatureEntry e = (SignatureEntry) cpMap[i];</span>
<span class="nc" id="L774">            cp_Signature_form.putRef(e.formRef);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">            for (int j = 0; j &lt; e.classRefs.length; j++) {</span>
<span class="nc" id="L776">                cp_Signature_classes.putRef(e.classRefs[j]);</span>
            }
        }
<span class="nc" id="L779">    }</span>

    void writeMemberRefs(byte tag, Entry[] cpMap, CPRefBand cp_class, CPRefBand cp_desc) throws IOException {
<span class="nc bnc" id="L782" title="All 2 branches missed.">        for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L783">            MemberEntry e = (MemberEntry) cpMap[i];</span>
<span class="nc" id="L784">            cp_class.putRef(e.classRef);</span>
<span class="nc" id="L785">            cp_desc.putRef(e.descRef);</span>
        }
<span class="nc" id="L787">    }</span>

    void writeFiles() throws IOException {
<span class="nc" id="L790">        int numFiles = pkg.files.size();</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">        if (numFiles == 0)  return;</span>
<span class="nc" id="L792">        int options = archiveOptions;</span>
<span class="nc" id="L793">        boolean haveSizeHi  = testBit(options, AO_HAVE_FILE_SIZE_HI);</span>
<span class="nc" id="L794">        boolean haveModtime = testBit(options, AO_HAVE_FILE_MODTIME);</span>
<span class="nc" id="L795">        boolean haveOptions = testBit(options, AO_HAVE_FILE_OPTIONS);</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">        if (!haveOptions) {</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">            for (File file : pkg.files) {</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">                if (file.isClassStub()) {</span>
<span class="nc" id="L799">                    haveOptions = true;</span>
<span class="nc" id="L800">                    options |= AO_HAVE_FILE_OPTIONS;</span>
<span class="nc" id="L801">                    archiveOptions = options;</span>
<span class="nc" id="L802">                    break;</span>
                }
<span class="nc" id="L804">            }</span>
        }
<span class="nc bnc" id="L806" title="All 8 branches missed.">        if (haveSizeHi || haveModtime || haveOptions || !pkg.files.isEmpty()) {</span>
<span class="nc" id="L807">            options |= AO_HAVE_FILE_HEADERS;</span>
<span class="nc" id="L808">            archiveOptions = options;</span>
        }
<span class="nc bnc" id="L810" title="All 2 branches missed.">        for (File file : pkg.files) {</span>
<span class="nc" id="L811">            file_name.putRef(file.name);</span>
<span class="nc" id="L812">            long len = file.getFileLength();</span>
<span class="nc" id="L813">            file_size_lo.putInt((int)len);</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">            if (haveSizeHi)</span>
<span class="nc" id="L815">                file_size_hi.putInt((int)(len &gt;&gt;&gt; 32));</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">            if (haveModtime)</span>
<span class="nc" id="L817">                file_modtime.putInt(file.modtime - pkg.default_modtime);</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">            if (haveOptions)</span>
<span class="nc" id="L819">                file_options.putInt(file.options);</span>
<span class="nc" id="L820">            file.writeTo(file_bits.collectorStream());</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">            if (verbose &gt; 1)</span>
<span class="nc" id="L822">                Utils.log.fine(&quot;Wrote &quot;+len+&quot; bytes of &quot;+file.name.stringValue());</span>
<span class="nc" id="L823">        }</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">        if (verbose &gt; 0)</span>
<span class="nc" id="L825">            Utils.log.info(&quot;Wrote &quot;+numFiles+&quot; resource files&quot;);</span>
<span class="nc" id="L826">    }</span>

    void collectAttributeLayouts() {
<span class="nc" id="L829">        maxFlags = new int[ATTR_CONTEXT_LIMIT];</span>
<span class="nc" id="L830">        allLayouts = new FixedList&lt;&gt;(ATTR_CONTEXT_LIMIT);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">        for (int i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {</span>
<span class="nc" id="L832">            allLayouts.set(i, new HashMap&lt;Attribute.Layout, int[]&gt;());</span>
        }
        // Collect maxFlags and allLayouts.
<span class="nc bnc" id="L835" title="All 2 branches missed.">        for (Class cls : pkg.classes) {</span>
<span class="nc" id="L836">            visitAttributeLayoutsIn(ATTR_CONTEXT_CLASS, cls);</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">            for (Class.Field f : cls.getFields()) {</span>
<span class="nc" id="L838">                visitAttributeLayoutsIn(ATTR_CONTEXT_FIELD, f);</span>
<span class="nc" id="L839">            }</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">            for (Class.Method m : cls.getMethods()) {</span>
<span class="nc" id="L841">                visitAttributeLayoutsIn(ATTR_CONTEXT_METHOD, m);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">                if (m.code != null) {</span>
<span class="nc" id="L843">                    visitAttributeLayoutsIn(ATTR_CONTEXT_CODE, m.code);</span>
                }
<span class="nc" id="L845">            }</span>
<span class="nc" id="L846">        }</span>
        // If there are many species of attributes, use 63-bit flags.
<span class="nc bnc" id="L848" title="All 2 branches missed.">        for (int i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {</span>
<span class="nc" id="L849">            int nl = allLayouts.get(i).size();</span>
<span class="nc" id="L850">            boolean haveLongFlags = haveFlagsHi(i);</span>
            final int TOO_MANY_ATTRS = 32 /*int flag size*/
                - 12 /*typical flag bits in use*/
                + 4  /*typical number of OK overflows*/;
<span class="nc bnc" id="L854" title="All 2 branches missed.">            if (nl &gt;= TOO_MANY_ATTRS) {  // heuristic</span>
<span class="nc" id="L855">                int mask = 1&lt;&lt;(LG_AO_HAVE_XXX_FLAGS_HI+i);</span>
<span class="nc" id="L856">                archiveOptions |= mask;</span>
<span class="nc" id="L857">                haveLongFlags = true;</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">                if (verbose &gt; 0)</span>
<span class="nc" id="L859">                   Utils.log.info(&quot;Note: Many &quot;+Attribute.contextName(i)+&quot; attributes forces 63-bit flags&quot;);</span>
            }
<span class="nc bnc" id="L861" title="All 2 branches missed.">            if (verbose &gt; 1) {</span>
<span class="nc" id="L862">                Utils.log.fine(Attribute.contextName(i)+&quot;.maxFlags = 0x&quot;+Integer.toHexString(maxFlags[i]));</span>
<span class="nc" id="L863">                Utils.log.fine(Attribute.contextName(i)+&quot;.#layouts = &quot;+nl);</span>
            }
<span class="nc bnc" id="L865" title="All 4 branches missed.">            assert(haveFlagsHi(i) == haveLongFlags);</span>
        }
<span class="nc" id="L867">        initAttrIndexLimit();</span>

        // Standard indexes can never conflict with flag bits.  Assert it.
<span class="nc bnc" id="L870" title="All 2 branches missed.">        for (int i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {</span>
<span class="nc bnc" id="L871" title="All 4 branches missed.">            assert((attrFlagMask[i] &amp; maxFlags[i]) == 0);</span>
        }
        // Collect counts for both predefs. and custom defs.
        // Decide on custom, local attribute definitions.
<span class="nc" id="L875">        backCountTable = new HashMap&lt;&gt;();</span>
<span class="nc" id="L876">        attrCounts = new int[ATTR_CONTEXT_LIMIT][];</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">        for (int i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {</span>
            // Now the remaining defs in allLayouts[i] need attr. indexes.
            // Fill up unused flag bits with new defs.
            // Unused bits are those which are not used by predefined attrs,
            // and which are always clear in the classfiles.
<span class="nc" id="L882">            long avHiBits = ~(maxFlags[i] | attrFlagMask[i]);</span>
<span class="nc bnc" id="L883" title="All 4 branches missed.">            assert(attrIndexLimit[i] &gt; 0);</span>
<span class="nc bnc" id="L884" title="All 4 branches missed.">            assert(attrIndexLimit[i] &lt; 64);  // all bits fit into a Java long</span>
<span class="nc" id="L885">            avHiBits &amp;= (1L&lt;&lt;attrIndexLimit[i])-1;</span>
<span class="nc" id="L886">            int nextLoBit = 0;</span>
<span class="nc" id="L887">            Map&lt;Attribute.Layout, int[]&gt; defMap = allLayouts.get(i);</span>
            @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
<span class="nc" id="L889">            Map.Entry&lt;Attribute.Layout, int[]&gt;[] layoutsAndCounts =</span>
<span class="nc" id="L890">                    new Map.Entry[defMap.size()];</span>
<span class="nc" id="L891">            defMap.entrySet().toArray(layoutsAndCounts);</span>
            // Sort by count, most frequent first.
            // Predefs. participate in this sort, though it does not matter.
<span class="nc" id="L894">            Arrays.sort(layoutsAndCounts,</span>
<span class="nc" id="L895">                        new Comparator&lt;Map.Entry&lt;Attribute.Layout, int[]&gt;&gt;() {</span>
                public int compare(Map.Entry&lt;Attribute.Layout, int[]&gt; e0,
                                   Map.Entry&lt;Attribute.Layout, int[]&gt; e1) {
                    // Primary sort key is count, reversed.
<span class="nc" id="L899">                    int r = -(e0.getValue()[0] - e1.getValue()[0]);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">                    if (r != 0)  return r;</span>
<span class="nc" id="L901">                    return e0.getKey().compareTo(e1.getKey());</span>
                }
            });
<span class="nc" id="L904">            attrCounts[i] = new int[attrIndexLimit[i]+layoutsAndCounts.length];</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">            for (int j = 0; j &lt; layoutsAndCounts.length; j++) {</span>
<span class="nc" id="L906">                Map.Entry&lt;Attribute.Layout, int[]&gt; e = layoutsAndCounts[j];</span>
<span class="nc" id="L907">                Attribute.Layout def = e.getKey();</span>
<span class="nc" id="L908">                int count = e.getValue()[0];</span>
                int index;
<span class="nc" id="L910">                Integer predefIndex = attrIndexTable.get(def);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">                if (predefIndex != null) {</span>
                    // The index is already set.
<span class="nc" id="L913">                    index = predefIndex.intValue();</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">                } else if (avHiBits != 0) {</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">                    while ((avHiBits &amp; 1) == 0) {</span>
<span class="nc" id="L916">                        avHiBits &gt;&gt;&gt;= 1;</span>
<span class="nc" id="L917">                        nextLoBit += 1;</span>
                    }
<span class="nc" id="L919">                    avHiBits -= 1;  // clear low bit; we are using it now</span>
                    // Update attrIndexTable:
<span class="nc" id="L921">                    index = setAttributeLayoutIndex(def, nextLoBit);</span>
                } else {
                    // Update attrIndexTable:
<span class="nc" id="L924">                    index = setAttributeLayoutIndex(def, ATTR_INDEX_OVERFLOW);</span>
                }

                // Now that we know the index, record the count of this def.
<span class="nc" id="L928">                attrCounts[i][index] = count;</span>

                // For all callables in the def, keep a tally of back-calls.
<span class="nc" id="L931">                Attribute.Layout.Element[] cbles = def.getCallables();</span>
<span class="nc" id="L932">                final int[] bc = new int[cbles.length];</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">                for (int k = 0; k &lt; cbles.length; k++) {</span>
<span class="nc bnc" id="L934" title="All 4 branches missed.">                    assert(cbles[k].kind == Attribute.EK_CBLE);</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">                    if (!cbles[k].flagTest(Attribute.EF_BACK)) {</span>
<span class="nc" id="L936">                        bc[k] = -1;  // no count to accumulate here</span>
                    }
                }
<span class="nc" id="L939">                backCountTable.put(def, bc);</span>

<span class="nc bnc" id="L941" title="All 2 branches missed.">                if (predefIndex == null) {</span>
                    // Make sure the package CP can name the local attribute.
<span class="nc" id="L943">                    Entry ne = ConstantPool.getUtf8Entry(def.name());</span>
<span class="nc" id="L944">                    String layout = def.layoutForClassVersion(getHighestClassVersion());</span>
<span class="nc" id="L945">                    Entry le = ConstantPool.getUtf8Entry(layout);</span>
<span class="nc" id="L946">                    requiredEntries.add(ne);</span>
<span class="nc" id="L947">                    requiredEntries.add(le);</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">                    if (verbose &gt; 0) {</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">                        if (index &lt; attrIndexLimit[i])</span>
<span class="nc" id="L950">                           Utils.log.info(&quot;Using free flag bit 1&lt;&lt;&quot;+index+&quot; for &quot;+count+&quot; occurrences of &quot;+def);</span>
                        else
<span class="nc" id="L952">                            Utils.log.info(&quot;Using overflow index &quot;+index+&quot; for &quot;+count+&quot; occurrences of &quot;+def);</span>
                    }
                }
            }
        }
        // Later, when emitting attr_definition_bands, we will look at
        // attrDefSeen and attrDefs at position 32/63 and beyond.
        // The attrIndexTable will provide elements of xxx_attr_indexes bands.

        // Done with scratch variables:
<span class="nc" id="L962">        maxFlags = null;</span>
<span class="nc" id="L963">        allLayouts = null;</span>
<span class="nc" id="L964">    }</span>

    // Scratch variables for processing attributes and flags.
    int[] maxFlags;
    List&lt;Map&lt;Attribute.Layout, int[]&gt;&gt; allLayouts;

    void visitAttributeLayoutsIn(int ctype, Attribute.Holder h) {
        // Make note of which flags appear in the class file.
        // Set them in maxFlags.
<span class="nc" id="L973">        maxFlags[ctype] |= h.flags;</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">        for (Attribute a : h.getAttributes()) {</span>
<span class="nc" id="L975">            Attribute.Layout def = a.layout();</span>
<span class="nc" id="L976">            Map&lt;Attribute.Layout, int[]&gt; defMap = allLayouts.get(ctype);</span>
<span class="nc" id="L977">            int[] count = defMap.get(def);</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">            if (count == null) {</span>
<span class="nc" id="L979">                defMap.put(def, count = new int[1]);</span>
            }
<span class="nc bnc" id="L981" title="All 2 branches missed.">            if (count[0] &lt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L982">                count[0] += 1;</span>
            }
<span class="nc" id="L984">        }</span>
<span class="nc" id="L985">    }</span>

    Attribute.Layout[] attrDefsWritten;

    void writeAttrDefs() throws IOException {
<span class="nc" id="L990">        List&lt;Object[]&gt; defList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">        for (int i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {</span>
<span class="nc" id="L992">            int limit = attrDefs.get(i).size();</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">            for (int j = 0; j &lt; limit; j++) {</span>
<span class="nc" id="L994">                int header = i;  // ctype</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">                if (j &lt; attrIndexLimit[i]) {</span>
<span class="nc" id="L996">                    header |= ((j + ADH_BIT_IS_LSB) &lt;&lt; ADH_BIT_SHIFT);</span>
<span class="nc bnc" id="L997" title="All 4 branches missed.">                    assert(header &lt; 0x100);  // must fit into a byte</span>
                    // (...else header is simply ctype, with zero high bits.)
<span class="nc bnc" id="L999" title="All 2 branches missed.">                    if (!testBit(attrDefSeen[i], 1L&lt;&lt;j)) {</span>
                        // either undefined or predefined; nothing to write
<span class="nc" id="L1001">                        continue;</span>
                    }
                }
<span class="nc" id="L1004">                Attribute.Layout def = attrDefs.get(i).get(j);</span>
<span class="nc" id="L1005">                defList.add(new Object[]{ Integer.valueOf(header), def });</span>
<span class="nc bnc" id="L1006" title="All 4 branches missed.">                assert(Integer.valueOf(j).equals(attrIndexTable.get(def)));</span>
            }
        }
        // Sort the new attr defs into some &quot;natural&quot; order.
<span class="nc" id="L1010">        int numAttrDefs = defList.size();</span>
<span class="nc" id="L1011">        Object[][] defs = new Object[numAttrDefs][];</span>
<span class="nc" id="L1012">        defList.toArray(defs);</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">        Arrays.sort(defs, new Comparator&lt;Object[]&gt;() {</span>
            public int compare(Object[] a0, Object[] a1) {
                // Primary sort key is attr def header.
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1017">                int r = ((Comparable)a0[0]).compareTo(a1[0]);</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">                if (r != 0)  return r;</span>
<span class="nc" id="L1019">                Integer ind0 = attrIndexTable.get(a0[1]);</span>
<span class="nc" id="L1020">                Integer ind1 = attrIndexTable.get(a1[1]);</span>
                // Secondary sort key is attribute index.
                // (This must be so, in order to keep overflow attr order.)
<span class="nc bnc" id="L1023" title="All 4 branches missed.">                assert(ind0 != null);</span>
<span class="nc bnc" id="L1024" title="All 4 branches missed.">                assert(ind1 != null);</span>
<span class="nc" id="L1025">                return ind0.compareTo(ind1);</span>
            }
        });
<span class="nc" id="L1028">        attrDefsWritten = new Attribute.Layout[numAttrDefs];</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        try (PrintStream dump = !optDumpBands ? null</span>
<span class="nc" id="L1030">                 : new PrintStream(getDumpStream(attr_definition_headers, &quot;.def&quot;)))</span>
        {
<span class="nc" id="L1032">            int[] indexForDebug = Arrays.copyOf(attrIndexLimit, ATTR_CONTEXT_LIMIT);</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">            for (int i = 0; i &lt; defs.length; i++) {</span>
<span class="nc" id="L1034">                int header = ((Integer)defs[i][0]).intValue();</span>
<span class="nc" id="L1035">                Attribute.Layout def = (Attribute.Layout) defs[i][1];</span>
<span class="nc" id="L1036">                attrDefsWritten[i] = def;</span>
<span class="nc bnc" id="L1037" title="All 4 branches missed.">                assert((header &amp; ADH_CONTEXT_MASK) == def.ctype());</span>
<span class="nc" id="L1038">                attr_definition_headers.putByte(header);</span>
<span class="nc" id="L1039">                attr_definition_name.putRef(ConstantPool.getUtf8Entry(def.name()));</span>
<span class="nc" id="L1040">                String layout = def.layoutForClassVersion(getHighestClassVersion());</span>
<span class="nc" id="L1041">                attr_definition_layout.putRef(ConstantPool.getUtf8Entry(layout));</span>
                // Check that we are transmitting that correct attribute index:
<span class="nc" id="L1043">                boolean debug = false;</span>
<span class="nc bnc" id="L1044" title="All 4 branches missed.">                assert(debug = true);</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L1046">                    int hdrIndex = (header &gt;&gt; ADH_BIT_SHIFT) - ADH_BIT_IS_LSB;</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                    if (hdrIndex &lt; 0)  hdrIndex = indexForDebug[def.ctype()]++;</span>
<span class="nc" id="L1048">                    int realIndex = (attrIndexTable.get(def)).intValue();</span>
<span class="nc bnc" id="L1049" title="All 4 branches missed.">                    assert(hdrIndex == realIndex);</span>
                }
<span class="nc bnc" id="L1051" title="All 2 branches missed.">                if (dump != null) {</span>
<span class="nc" id="L1052">                    int index = (header &gt;&gt; ADH_BIT_SHIFT) - ADH_BIT_IS_LSB;</span>
<span class="nc" id="L1053">                    dump.println(index+&quot; &quot;+def);</span>
                }
            }
<span class="nc bnc" id="L1056" title="All 8 branches missed.">        }</span>
<span class="nc" id="L1057">    }</span>

    void writeAttrCounts() throws IOException {
        // Write the four xxx_attr_calls bands.
<span class="nc bnc" id="L1061" title="All 2 branches missed.">        for (int ctype = 0; ctype &lt; ATTR_CONTEXT_LIMIT; ctype++) {</span>
<span class="nc" id="L1062">            MultiBand xxx_attr_bands = attrBands[ctype];</span>
<span class="nc" id="L1063">            IntBand xxx_attr_calls = getAttrBand(xxx_attr_bands, AB_ATTR_CALLS);</span>
<span class="nc" id="L1064">            Attribute.Layout[] defs = new Attribute.Layout[attrDefs.get(ctype).size()];</span>
<span class="nc" id="L1065">            attrDefs.get(ctype).toArray(defs);</span>
<span class="nc" id="L1066">            for (boolean predef = true; ; predef = false) {</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                for (int ai = 0; ai &lt; defs.length; ai++) {</span>
<span class="nc" id="L1068">                    Attribute.Layout def = defs[ai];</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">                    if (def == null)  continue;  // unused index</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                    if (predef != isPredefinedAttr(ctype, ai))</span>
<span class="nc" id="L1071">                        continue;  // wrong pass</span>
<span class="nc" id="L1072">                    int totalCount = attrCounts[ctype][ai];</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">                    if (totalCount == 0)</span>
<span class="nc" id="L1074">                        continue;  // irrelevant</span>
<span class="nc" id="L1075">                    int[] bc = backCountTable.get(def);</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">                    for (int j = 0; j &lt; bc.length; j++) {</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">                        if (bc[j] &gt;= 0) {</span>
<span class="nc" id="L1078">                            int backCount = bc[j];</span>
<span class="nc" id="L1079">                            bc[j] = -1;  // close out; do not collect further counts</span>
<span class="nc" id="L1080">                            xxx_attr_calls.putInt(backCount);</span>
<span class="nc bnc" id="L1081" title="All 4 branches missed.">                            assert(def.getCallables()[j].flagTest(Attribute.EF_BACK));</span>
<span class="nc" id="L1082">                        } else {</span>
<span class="nc bnc" id="L1083" title="All 4 branches missed.">                            assert(!def.getCallables()[j].flagTest(Attribute.EF_BACK));</span>
                        }
                    }
                }
<span class="nc bnc" id="L1087" title="All 2 branches missed.">                if (!predef)  break;</span>
            }
        }
<span class="nc" id="L1090">    }</span>

    void trimClassAttributes() {
<span class="nc bnc" id="L1093" title="All 2 branches missed.">        for (Class cls : pkg.classes) {</span>
            // Replace &quot;obvious&quot; SourceFile attrs by null.
<span class="nc" id="L1095">            cls.minimizeSourceFile();</span>
            // BootstrapMethods should never have been inserted.
<span class="nc bnc" id="L1097" title="All 4 branches missed.">            assert(cls.getAttribute(Package.attrBootstrapMethodsEmpty) == null);</span>
<span class="nc" id="L1098">        }</span>
<span class="nc" id="L1099">    }</span>

    void collectInnerClasses() {
        // Capture inner classes, removing them from individual classes.
        // Irregular inner classes must stay local, though.
<span class="nc" id="L1104">        Map&lt;ClassEntry, InnerClass&gt; allICMap = new HashMap&lt;&gt;();</span>
        // First, collect a consistent global set.
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        for (Class cls : pkg.classes) {</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">            if (!cls.hasInnerClasses())  continue;</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">            for (InnerClass ic : cls.getInnerClasses()) {</span>
<span class="nc" id="L1109">                InnerClass pic = allICMap.put(ic.thisClass, ic);</span>
<span class="nc bnc" id="L1110" title="All 6 branches missed.">                if (pic != null &amp;&amp; !pic.equals(ic) &amp;&amp; pic.predictable) {</span>
                    // Different ICs.  Choose the better to make global.
<span class="nc" id="L1112">                    allICMap.put(pic.thisClass, pic);</span>
                }
<span class="nc" id="L1114">            }</span>
<span class="nc" id="L1115">        }</span>

<span class="nc" id="L1117">        InnerClass[] allICs = new InnerClass[allICMap.size()];</span>
<span class="nc" id="L1118">        allICMap.values().toArray(allICs);</span>
<span class="nc" id="L1119">        allICMap = null;  // done with it</span>

        // Note: The InnerClasses attribute must be in a valid order,
        // so that A$B always occurs earlier than A$B$C.  This is an
        // important side-effect of sorting lexically by class name.
<span class="nc" id="L1124">        Arrays.sort(allICs);  // put in canonical order</span>
<span class="nc" id="L1125">        pkg.setAllInnerClasses(Arrays.asList(allICs));</span>

        // Next, empty out of every local set the consistent entries.
        // Calculate whether there is any remaining need to have a local
        // set, and whether it needs to be locked.
<span class="nc bnc" id="L1130" title="All 2 branches missed.">        for (Class cls : pkg.classes) {</span>
<span class="nc" id="L1131">            cls.minimizeLocalICs();</span>
<span class="nc" id="L1132">        }</span>
<span class="nc" id="L1133">    }</span>

    void writeInnerClasses() throws IOException {
<span class="nc bnc" id="L1136" title="All 2 branches missed.">        for (InnerClass ic : pkg.getAllInnerClasses()) {</span>
<span class="nc" id="L1137">            int flags = ic.flags;</span>
<span class="nc bnc" id="L1138" title="All 4 branches missed.">            assert((flags &amp; ACC_IC_LONG_FORM) == 0);</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">            if (!ic.predictable) {</span>
<span class="nc" id="L1140">                flags |= ACC_IC_LONG_FORM;</span>
            }
<span class="nc" id="L1142">            ic_this_class.putRef(ic.thisClass);</span>
<span class="nc" id="L1143">            ic_flags.putInt(flags);</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">            if (!ic.predictable) {</span>
<span class="nc" id="L1145">                ic_outer_class.putRef(ic.outerClass);</span>
<span class="nc" id="L1146">                ic_name.putRef(ic.name);</span>
            }
<span class="nc" id="L1148">        }</span>
<span class="nc" id="L1149">    }</span>

    /** If there are any extra InnerClasses entries to write which are
     *  not already implied by the global table, put them into a
     *  local attribute.  This is expected to be rare.
     */
    void writeLocalInnerClasses(Class cls) throws IOException {
<span class="nc" id="L1156">        List&lt;InnerClass&gt; localICs = cls.getInnerClasses();</span>
<span class="nc" id="L1157">        class_InnerClasses_N.putInt(localICs.size());</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">        for(InnerClass ic : localICs) {</span>
<span class="nc" id="L1159">            class_InnerClasses_RC.putRef(ic.thisClass);</span>
            // Is it redundant with the global version?
<span class="nc bnc" id="L1161" title="All 2 branches missed.">            if (ic.equals(pkg.getGlobalInnerClass(ic.thisClass))) {</span>
                // A zero flag means copy a global IC here.
<span class="nc" id="L1163">                class_InnerClasses_F.putInt(0);</span>
            } else {
<span class="nc" id="L1165">                int flags = ic.flags;</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                if (flags == 0)</span>
<span class="nc" id="L1167">                    flags = ACC_IC_LONG_FORM;  // force it to be non-zero</span>
<span class="nc" id="L1168">                class_InnerClasses_F.putInt(flags);</span>
<span class="nc" id="L1169">                class_InnerClasses_outer_RCN.putRef(ic.outerClass);</span>
<span class="nc" id="L1170">                class_InnerClasses_name_RUN.putRef(ic.name);</span>
            }
<span class="nc" id="L1172">        }</span>
<span class="nc" id="L1173">    }</span>

    void writeClassesAndByteCodes() throws IOException {
<span class="nc" id="L1176">        Class[] classes = new Class[pkg.classes.size()];</span>
<span class="nc" id="L1177">        pkg.classes.toArray(classes);</span>
        // Note:  This code respects the order in which caller put classes.
<span class="nc bnc" id="L1179" title="All 2 branches missed.">        if (verbose &gt; 0)</span>
<span class="nc" id="L1180">            Utils.log.info(&quot;  ...scanning &quot;+classes.length+&quot; classes...&quot;);</span>

<span class="nc" id="L1182">        int nwritten = 0;</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">        for (int i = 0; i &lt; classes.length; i++) {</span>
            // Collect the class body, sans bytecodes.
<span class="nc" id="L1185">            Class cls = classes[i];</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if (verbose &gt; 1)</span>
<span class="nc" id="L1187">                Utils.log.fine(&quot;Scanning &quot;+cls);</span>

<span class="nc" id="L1189">            ClassEntry   thisClass  = cls.thisClass;</span>
<span class="nc" id="L1190">            ClassEntry   superClass = cls.superClass;</span>
<span class="nc" id="L1191">            ClassEntry[] interfaces = cls.interfaces;</span>
            // Encode rare case of null superClass as thisClass:
<span class="nc bnc" id="L1193" title="All 4 branches missed.">            assert(superClass != thisClass);  // bad class file!?</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">            if (superClass == null)  superClass = thisClass;</span>
<span class="nc" id="L1195">            class_this.putRef(thisClass);</span>
<span class="nc" id="L1196">            class_super.putRef(superClass);</span>
<span class="nc" id="L1197">            class_interface_count.putInt(cls.interfaces.length);</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">            for (int j = 0; j &lt; interfaces.length; j++) {</span>
<span class="nc" id="L1199">                class_interface.putRef(interfaces[j]);</span>
            }

<span class="nc" id="L1202">            writeMembers(cls);</span>
<span class="nc" id="L1203">            writeAttrs(ATTR_CONTEXT_CLASS, cls, cls);</span>

<span class="nc" id="L1205">            nwritten++;</span>
<span class="nc bnc" id="L1206" title="All 4 branches missed.">            if (verbose &gt; 0 &amp;&amp; (nwritten % 1000) == 0)</span>
<span class="nc" id="L1207">                Utils.log.info(&quot;Have scanned &quot;+nwritten+&quot; classes...&quot;);</span>
        }
<span class="nc" id="L1209">    }</span>

    void writeMembers(Class cls) throws IOException {
<span class="nc" id="L1212">        List&lt;Class.Field&gt; fields = cls.getFields();</span>
<span class="nc" id="L1213">        class_field_count.putInt(fields.size());</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">        for (Class.Field f : fields) {</span>
<span class="nc" id="L1215">            field_descr.putRef(f.getDescriptor());</span>
<span class="nc" id="L1216">            writeAttrs(ATTR_CONTEXT_FIELD, f, cls);</span>
<span class="nc" id="L1217">        }</span>

<span class="nc" id="L1219">        List&lt;Class.Method&gt; methods = cls.getMethods();</span>
<span class="nc" id="L1220">        class_method_count.putInt(methods.size());</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">        for (Class.Method m : methods) {</span>
<span class="nc" id="L1222">            method_descr.putRef(m.getDescriptor());</span>
<span class="nc" id="L1223">            writeAttrs(ATTR_CONTEXT_METHOD, m, cls);</span>
<span class="nc bnc" id="L1224" title="All 8 branches missed.">            assert((m.code != null) == (m.getAttribute(attrCodeEmpty) != null));</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">            if (m.code != null) {</span>
<span class="nc" id="L1226">                writeCodeHeader(m.code);</span>
<span class="nc" id="L1227">                writeByteCodes(m.code);</span>
            }
<span class="nc" id="L1229">        }</span>
<span class="nc" id="L1230">    }</span>

    void writeCodeHeader(Code c) throws IOException {
<span class="nc" id="L1233">        boolean attrsOK = testBit(archiveOptions, AO_HAVE_ALL_CODE_FLAGS);</span>
<span class="nc" id="L1234">        int na = c.attributeSize();</span>
<span class="nc" id="L1235">        int sc = shortCodeHeader(c);</span>
<span class="nc bnc" id="L1236" title="All 4 branches missed.">        if (!attrsOK &amp;&amp; na &gt; 0)</span>
            // We must write flags, and can only do so for long headers.
<span class="nc" id="L1238">            sc = LONG_CODE_HEADER;</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">        if (verbose &gt; 2) {</span>
<span class="nc" id="L1240">            int siglen = c.getMethod().getArgumentSize();</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">            Utils.log.fine(&quot;Code sizes info &quot;+c.max_stack+&quot; &quot;+c.max_locals+&quot; &quot;+c.getHandlerCount()+&quot; &quot;+siglen+&quot; &quot;+na+(sc &gt; 0 ? &quot; SHORT=&quot;+sc : &quot;&quot;));</span>
        }
<span class="nc" id="L1243">        code_headers.putByte(sc);</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        if (sc == LONG_CODE_HEADER) {</span>
<span class="nc" id="L1245">            code_max_stack.putInt(c.getMaxStack());</span>
<span class="nc" id="L1246">            code_max_na_locals.putInt(c.getMaxNALocals());</span>
<span class="nc" id="L1247">            code_handler_count.putInt(c.getHandlerCount());</span>
        } else {
<span class="nc bnc" id="L1249" title="All 6 branches missed.">            assert(attrsOK || na == 0);</span>
<span class="nc bnc" id="L1250" title="All 4 branches missed.">            assert(c.getHandlerCount() &lt; shortCodeHeader_h_limit);</span>
        }
<span class="nc" id="L1252">        writeCodeHandlers(c);</span>
<span class="nc bnc" id="L1253" title="All 4 branches missed.">        if (sc == LONG_CODE_HEADER || attrsOK)</span>
<span class="nc" id="L1254">            writeAttrs(ATTR_CONTEXT_CODE, c, c.thisClass());</span>
<span class="nc" id="L1255">    }</span>

    void writeCodeHandlers(Code c) throws IOException {
        int sum, del;
<span class="nc bnc" id="L1259" title="All 2 branches missed.">        for (int j = 0, jmax = c.getHandlerCount(); j &lt; jmax; j++) {</span>
<span class="nc" id="L1260">            code_handler_class_RCN.putRef(c.handler_class[j]); // null OK</span>
            // Encode end as offset from start, and catch as offset from end,
            // because they are strongly correlated.
<span class="nc" id="L1263">            sum = c.encodeBCI(c.handler_start[j]);</span>
<span class="nc" id="L1264">            code_handler_start_P.putInt(sum);</span>
<span class="nc" id="L1265">            del = c.encodeBCI(c.handler_end[j]) - sum;</span>
<span class="nc" id="L1266">            code_handler_end_PO.putInt(del);</span>
<span class="nc" id="L1267">            sum += del;</span>
<span class="nc" id="L1268">            del = c.encodeBCI(c.handler_catch[j]) - sum;</span>
<span class="nc" id="L1269">            code_handler_catch_PO.putInt(del);</span>
        }
<span class="nc" id="L1271">    }</span>

    // Generic routines for writing attributes and flags of
    // classes, fields, methods, and codes.
    void writeAttrs(int ctype,
                    final Attribute.Holder h,
                    Class cls) throws IOException {
<span class="nc" id="L1278">        MultiBand xxx_attr_bands = attrBands[ctype];</span>
<span class="nc" id="L1279">        IntBand xxx_flags_hi = getAttrBand(xxx_attr_bands, AB_FLAGS_HI);</span>
<span class="nc" id="L1280">        IntBand xxx_flags_lo = getAttrBand(xxx_attr_bands, AB_FLAGS_LO);</span>
<span class="nc" id="L1281">        boolean haveLongFlags = haveFlagsHi(ctype);</span>
<span class="nc bnc" id="L1282" title="All 6 branches missed.">        assert(attrIndexLimit[ctype] == (haveLongFlags? 63: 32));</span>
<span class="nc bnc" id="L1283" title="All 2 branches missed.">        if (h.attributes == null) {</span>
<span class="nc" id="L1284">            xxx_flags_lo.putInt(h.flags);  // no extra bits to set here</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">            if (haveLongFlags)</span>
<span class="nc" id="L1286">                xxx_flags_hi.putInt(0);</span>
<span class="nc" id="L1287">            return;</span>
        }
<span class="nc bnc" id="L1289" title="All 2 branches missed.">        if (verbose &gt; 3)</span>
<span class="nc" id="L1290">            Utils.log.fine(&quot;Transmitting attrs for &quot;+h+&quot; flags=&quot;+Integer.toHexString(h.flags));</span>

<span class="nc" id="L1292">        long flagMask = attrFlagMask[ctype];  // which flags are attr bits?</span>
<span class="nc" id="L1293">        long flagsToAdd = 0;</span>
<span class="nc" id="L1294">        int overflowCount = 0;</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">        for (Attribute a : h.attributes) {</span>
<span class="nc" id="L1296">            Attribute.Layout def = a.layout();</span>
<span class="nc" id="L1297">            int index = (attrIndexTable.get(def)).intValue();</span>
<span class="nc bnc" id="L1298" title="All 4 branches missed.">            assert(attrDefs.get(ctype).get(index) == def);</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">            if (verbose &gt; 3)</span>
<span class="nc" id="L1300">                Utils.log.fine(&quot;add attr @&quot;+index+&quot; &quot;+a+&quot; in &quot;+h);</span>
<span class="nc bnc" id="L1301" title="All 4 branches missed.">            if (index &lt; attrIndexLimit[ctype] &amp;&amp; testBit(flagMask, 1L&lt;&lt;index)) {</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">                if (verbose &gt; 3)</span>
<span class="nc" id="L1303">                    Utils.log.fine(&quot;Adding flag bit 1&lt;&lt;&quot;+index+&quot; in &quot;+Long.toHexString(flagMask));</span>
<span class="nc bnc" id="L1304" title="All 4 branches missed.">                assert(!testBit(h.flags, 1L&lt;&lt;index));</span>
<span class="nc" id="L1305">                flagsToAdd |= (1L&lt;&lt;index);</span>
<span class="nc" id="L1306">                flagMask -= (1L&lt;&lt;index);  // do not use this bit twice here</span>
            } else {
                // an overflow attr.
<span class="nc" id="L1309">                flagsToAdd |= (1L&lt;&lt;X_ATTR_OVERFLOW);</span>
<span class="nc" id="L1310">                overflowCount += 1;</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">                if (verbose &gt; 3)</span>
<span class="nc" id="L1312">                    Utils.log.fine(&quot;Adding overflow attr #&quot;+overflowCount);</span>
<span class="nc" id="L1313">                IntBand xxx_attr_indexes = getAttrBand(xxx_attr_bands, AB_ATTR_INDEXES);</span>
<span class="nc" id="L1314">                xxx_attr_indexes.putInt(index);</span>
                // System.out.println(&quot;overflow @&quot;+index);
            }
<span class="nc bnc" id="L1317" title="All 2 branches missed.">            if (def.bandCount == 0) {</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">                if (def == attrInnerClassesEmpty) {</span>
                    // Special logic to write this attr.
<span class="nc" id="L1320">                    writeLocalInnerClasses((Class) h);</span>
<span class="nc" id="L1321">                    continue;</span>
                }
                // Empty attr; nothing more to write here.
                continue;
            }
<span class="nc bnc" id="L1326" title="All 4 branches missed.">            assert(a.fixups == null);</span>
<span class="nc" id="L1327">            final Band[] ab = attrBandTable.get(def);</span>
<span class="nc bnc" id="L1328" title="All 4 branches missed.">            assert(ab != null);</span>
<span class="nc bnc" id="L1329" title="All 4 branches missed.">            assert(ab.length == def.bandCount);</span>
<span class="nc" id="L1330">            final int[] bc = backCountTable.get(def);</span>
<span class="nc bnc" id="L1331" title="All 4 branches missed.">            assert(bc != null);</span>
<span class="nc bnc" id="L1332" title="All 4 branches missed.">            assert(bc.length == def.getCallables().length);</span>
            // Write one attribute of type def into ab.
<span class="nc bnc" id="L1334" title="All 2 branches missed.">            if (verbose &gt; 2)  Utils.log.fine(&quot;writing &quot;+a+&quot; in &quot;+h);</span>
<span class="nc bnc" id="L1335" title="All 4 branches missed.">            boolean isCV = (ctype == ATTR_CONTEXT_FIELD &amp;&amp; def == attrConstantValue);</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">            if (isCV)  setConstantValueIndex((Class.Field)h);</span>
<span class="nc" id="L1337">            a.parse(cls, a.bytes(), 0, a.size(),</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">                      new Attribute.ValueStream() {</span>
                public void putInt(int bandIndex, int value) {
<span class="nc" id="L1340">                    ((IntBand) ab[bandIndex]).putInt(value);</span>
<span class="nc" id="L1341">                }</span>
                public void putRef(int bandIndex, Entry ref) {
<span class="nc" id="L1343">                    ((CPRefBand) ab[bandIndex]).putRef(ref);</span>
<span class="nc" id="L1344">                }</span>
                public int encodeBCI(int bci) {
<span class="nc" id="L1346">                    Code code = (Code) h;</span>
<span class="nc" id="L1347">                    return code.encodeBCI(bci);</span>
                }
                public void noteBackCall(int whichCallable) {
<span class="nc bnc" id="L1350" title="All 4 branches missed.">                    assert(bc[whichCallable] &gt;= 0);</span>
<span class="nc" id="L1351">                    bc[whichCallable] += 1;</span>
<span class="nc" id="L1352">                }</span>
            });
<span class="nc bnc" id="L1354" title="All 2 branches missed.">            if (isCV)  setConstantValueIndex(null);  // clean up</span>
<span class="nc" id="L1355">        }</span>

<span class="nc bnc" id="L1357" title="All 2 branches missed.">        if (overflowCount &gt; 0) {</span>
<span class="nc" id="L1358">            IntBand xxx_attr_count = getAttrBand(xxx_attr_bands, AB_ATTR_COUNT);</span>
<span class="nc" id="L1359">            xxx_attr_count.putInt(overflowCount);</span>
        }

<span class="nc" id="L1362">        xxx_flags_lo.putInt(h.flags | (int)flagsToAdd);</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">        if (haveLongFlags)</span>
<span class="nc" id="L1364">            xxx_flags_hi.putInt((int)(flagsToAdd &gt;&gt;&gt; 32));</span>
        else
<span class="nc bnc" id="L1366" title="All 4 branches missed.">            assert((flagsToAdd &gt;&gt;&gt; 32) == 0);</span>
<span class="nc bnc" id="L1367" title="All 4 branches missed.">        assert((h.flags &amp; flagsToAdd) == 0)</span>
            : (h+&quot;.flags=&quot;
<span class="nc" id="L1369">                +Integer.toHexString(h.flags)+&quot;^&quot;</span>
<span class="nc" id="L1370">                +Long.toHexString(flagsToAdd));</span>
<span class="nc" id="L1371">    }</span>

    // temporary scratch variables for processing code blocks
    private Code                 curCode;
    private Class                curClass;
    private Entry[] curCPMap;
    private void beginCode(Code c) {
<span class="nc bnc" id="L1378" title="All 4 branches missed.">        assert(curCode == null);</span>
<span class="nc" id="L1379">        curCode = c;</span>
<span class="nc" id="L1380">        curClass = c.m.thisClass();</span>
<span class="nc" id="L1381">        curCPMap = c.getCPMap();</span>
<span class="nc" id="L1382">    }</span>
    private void endCode() {
<span class="nc" id="L1384">        curCode = null;</span>
<span class="nc" id="L1385">        curClass = null;</span>
<span class="nc" id="L1386">        curCPMap = null;</span>
<span class="nc" id="L1387">    }</span>

    // Return an _invokeinit_op variant, if the instruction matches one,
    // else -1.
    private int initOpVariant(Instruction i, Entry newClass) {
<span class="nc bnc" id="L1392" title="All 2 branches missed.">        if (i.getBC() != _invokespecial)  return -1;</span>
<span class="nc" id="L1393">        MemberEntry ref = (MemberEntry) i.getCPRef(curCPMap);</span>
<span class="nc bnc" id="L1394" title="All 2 branches missed.">        if (&quot;&lt;init&gt;&quot;.equals(ref.descRef.nameRef.stringValue()) == false)</span>
<span class="nc" id="L1395">            return -1;</span>
<span class="nc" id="L1396">        ClassEntry refClass = ref.classRef;</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">        if (refClass == curClass.thisClass)</span>
<span class="nc" id="L1398">            return _invokeinit_op+_invokeinit_self_option;</span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">        if (refClass == curClass.superClass)</span>
<span class="nc" id="L1400">            return _invokeinit_op+_invokeinit_super_option;</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">        if (refClass == newClass)</span>
<span class="nc" id="L1402">            return _invokeinit_op+_invokeinit_new_option;</span>
<span class="nc" id="L1403">        return -1;</span>
    }

    // Return a _self_linker_op variant, if the instruction matches one,
    // else -1.
    private int selfOpVariant(Instruction i) {
<span class="nc" id="L1409">        int bc = i.getBC();</span>
<span class="nc bnc" id="L1410" title="All 4 branches missed.">        if (!(bc &gt;= _first_linker_op &amp;&amp; bc &lt;= _last_linker_op))  return -1;</span>
<span class="nc" id="L1411">        MemberEntry ref = (MemberEntry) i.getCPRef(curCPMap);</span>
        // do not optimize this case, simply fall back to regular coding
<span class="nc bnc" id="L1413" title="All 4 branches missed.">        if ((bc == _invokespecial || bc == _invokestatic) &amp;&amp;</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">                ref.tagEquals(CONSTANT_InterfaceMethodref))</span>
<span class="nc" id="L1415">            return -1;</span>
<span class="nc" id="L1416">        ClassEntry refClass = ref.classRef;</span>
<span class="nc" id="L1417">        int self_bc = _self_linker_op + (bc - _first_linker_op);</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">        if (refClass == curClass.thisClass)</span>
<span class="nc" id="L1419">            return self_bc;</span>
<span class="nc bnc" id="L1420" title="All 2 branches missed.">        if (refClass == curClass.superClass)</span>
<span class="nc" id="L1421">            return self_bc + _self_linker_super_flag;</span>
<span class="nc" id="L1422">        return -1;</span>
    }

    void writeByteCodes(Code code) throws IOException {
<span class="nc" id="L1426">        beginCode(code);</span>
<span class="nc" id="L1427">        IndexGroup cp = pkg.cp;</span>

        // true if the previous instruction is an aload to absorb
<span class="nc" id="L1430">        boolean prevAload = false;</span>

        // class of most recent new; helps compress &lt;init&gt; calls
<span class="nc" id="L1433">        Entry newClass = null;</span>

<span class="nc bnc" id="L1435" title="All 2 branches missed.">        for (Instruction i = code.instructionAt(0); i != null; i = i.next()) {</span>
            // %%% Add a stress mode which issues _ref/_byte_escape.
<span class="nc bnc" id="L1437" title="All 2 branches missed.">            if (verbose &gt; 3)  Utils.log.fine(i.toString());</span>

<span class="nc bnc" id="L1439" title="All 2 branches missed.">            if (i.isNonstandard()) {</span>
                // Crash and burn with a complaint if there are funny
                // bytecodes in this class file.
<span class="nc" id="L1442">                String complaint = code.getMethod()</span>
                    +&quot; contains an unrecognized bytecode &quot;+i
                    +&quot;; please use the pass-file option on this class.&quot;;
<span class="nc" id="L1445">                Utils.log.warning(complaint);</span>
<span class="nc" id="L1446">                throw new IOException(complaint);</span>
            }

<span class="nc bnc" id="L1449" title="All 2 branches missed.">            if (i.isWide()) {</span>
<span class="nc bnc" id="L1450" title="All 2 branches missed.">                if (verbose &gt; 1) {</span>
<span class="nc" id="L1451">                    Utils.log.fine(&quot;_wide opcode in &quot;+code);</span>
<span class="nc" id="L1452">                    Utils.log.fine(i.toString());</span>
                }
<span class="nc" id="L1454">                bc_codes.putByte(_wide);</span>
<span class="nc" id="L1455">                codeHist[_wide]++;</span>
            }

<span class="nc" id="L1458">            int bc = i.getBC();</span>

            // Begin &quot;bc_linker&quot; compression.
<span class="nc bnc" id="L1461" title="All 2 branches missed.">            if (bc == _aload_0) {</span>
                // Try to group aload_0 with a following operation.
<span class="nc" id="L1463">                Instruction ni = code.instructionAt(i.getNextPC());</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">                if (selfOpVariant(ni) &gt;= 0) {</span>
<span class="nc" id="L1465">                    prevAload = true;</span>
<span class="nc" id="L1466">                    continue;</span>
                }
            }

            // Test for &lt;init&gt; invocations:
<span class="nc" id="L1471">            int init_bc = initOpVariant(i, newClass);</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">            if (init_bc &gt;= 0) {</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">                if (prevAload) {</span>
                    // get rid of it
<span class="nc" id="L1475">                    bc_codes.putByte(_aload_0);</span>
<span class="nc" id="L1476">                    codeHist[_aload_0]++;</span>
<span class="nc" id="L1477">                    prevAload = false;  //used up</span>
                }
                // Write special bytecode.
<span class="nc" id="L1480">                bc_codes.putByte(init_bc);</span>
<span class="nc" id="L1481">                codeHist[init_bc]++;</span>
<span class="nc" id="L1482">                MemberEntry ref = (MemberEntry) i.getCPRef(curCPMap);</span>
                // Write operand to a separate band.
<span class="nc" id="L1484">                int coding = cp.getOverloadingIndex(ref);</span>
<span class="nc" id="L1485">                bc_initref.putInt(coding);</span>
<span class="nc" id="L1486">                continue;</span>
            }

<span class="nc" id="L1489">            int self_bc = selfOpVariant(i);</span>
<span class="nc bnc" id="L1490" title="All 2 branches missed.">            if (self_bc &gt;= 0) {</span>
<span class="nc" id="L1491">                boolean isField = Instruction.isFieldOp(bc);</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">                boolean isSuper = (self_bc &gt;= _self_linker_op+_self_linker_super_flag);</span>
<span class="nc" id="L1493">                boolean isAload = prevAload;</span>
<span class="nc" id="L1494">                prevAload = false;  //used up</span>
<span class="nc bnc" id="L1495" title="All 2 branches missed.">                if (isAload)</span>
<span class="nc" id="L1496">                    self_bc += _self_linker_aload_flag;</span>
                // Write special bytecode.
<span class="nc" id="L1498">                bc_codes.putByte(self_bc);</span>
<span class="nc" id="L1499">                codeHist[self_bc]++;</span>
                // Write field or method ref to a separate band.
<span class="nc" id="L1501">                MemberEntry ref = (MemberEntry) i.getCPRef(curCPMap);</span>
<span class="nc" id="L1502">                CPRefBand bc_which = selfOpRefBand(self_bc);</span>
<span class="nc" id="L1503">                Index which_ix = cp.getMemberIndex(ref.tag, ref.classRef);</span>
<span class="nc" id="L1504">                bc_which.putRef(ref, which_ix);</span>
<span class="nc" id="L1505">                continue;</span>
            }
<span class="nc bnc" id="L1507" title="All 4 branches missed.">            assert(!prevAload);</span>
            // End &quot;bc_linker&quot; compression.

            // Normal bytecode.
<span class="nc" id="L1511">            codeHist[bc]++;</span>
<span class="nc bnc" id="L1512" title="All 2 branches missed.">            switch (bc) {</span>
            case _tableswitch: // apc:  (df, lo, hi, (hi-lo+1)*(label))
            case _lookupswitch: // apc:  (df, nc, nc*(case, label))
<span class="nc" id="L1515">                bc_codes.putByte(bc);</span>
<span class="nc" id="L1516">                Instruction.Switch isw = (Instruction.Switch) i;</span>
                // Note that we do not write the alignment bytes.
<span class="nc" id="L1518">                int apc = isw.getAlignedPC();</span>
<span class="nc" id="L1519">                int npc = isw.getNextPC();</span>
                // write a length specification into the bytecode stream
<span class="nc" id="L1521">                int caseCount = isw.getCaseCount();</span>
<span class="nc" id="L1522">                bc_case_count.putInt(caseCount);</span>
<span class="nc" id="L1523">                putLabel(bc_label, code, i.getPC(), isw.getDefaultLabel());</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">                for (int j = 0; j &lt; caseCount; j++) {</span>
<span class="nc" id="L1525">                    putLabel(bc_label, code, i.getPC(), isw.getCaseLabel(j));</span>
                }
                // Transmit case values in their own band.
<span class="nc bnc" id="L1528" title="All 2 branches missed.">                if (bc == _tableswitch) {</span>
<span class="nc" id="L1529">                    bc_case_value.putInt(isw.getCaseValue(0));</span>
                } else {
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                    for (int j = 0; j &lt; caseCount; j++) {</span>
<span class="nc" id="L1532">                        bc_case_value.putInt(isw.getCaseValue(j));</span>
                    }
                }
                // Done with the switch.
<span class="nc" id="L1536">                continue;</span>
            }

<span class="nc" id="L1539">            int branch = i.getBranchLabel();</span>
<span class="nc bnc" id="L1540" title="All 2 branches missed.">            if (branch &gt;= 0) {</span>
<span class="nc" id="L1541">                bc_codes.putByte(bc);</span>
<span class="nc" id="L1542">                putLabel(bc_label, code, i.getPC(), branch);</span>
<span class="nc" id="L1543">                continue;</span>
            }
<span class="nc" id="L1545">            Entry ref = i.getCPRef(curCPMap);</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">            if (ref != null) {</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">                if (bc == _new)  newClass = ref;</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">                if (bc == _ldc)  ldcHist[ref.tag]++;</span>
                CPRefBand bc_which;
<span class="nc" id="L1550">                int vbc = bc;</span>
<span class="nc bnc" id="L1551" title="All 7 branches missed.">                switch (i.getCPTag()) {</span>
                case CONSTANT_LoadableValue:
<span class="nc bnc" id="L1553" title="All 7 branches missed.">                    switch (ref.tag) {</span>
                    case CONSTANT_Integer:
<span class="nc" id="L1555">                        bc_which = bc_intref;</span>
<span class="nc bnc" id="L1556" title="All 3 branches missed.">                        switch (bc) {</span>
<span class="nc" id="L1557">                        case _ldc:    vbc = _ildc; break;</span>
<span class="nc" id="L1558">                        case _ldc_w:  vbc = _ildc_w; break;</span>
<span class="nc bnc" id="L1559" title="All 2 branches missed.">                        default:      assert(false);</span>
                        }
                        break;
                    case CONSTANT_Float:
<span class="nc" id="L1563">                        bc_which = bc_floatref;</span>
<span class="nc bnc" id="L1564" title="All 3 branches missed.">                        switch (bc) {</span>
<span class="nc" id="L1565">                        case _ldc:    vbc = _fldc; break;</span>
<span class="nc" id="L1566">                        case _ldc_w:  vbc = _fldc_w; break;</span>
<span class="nc bnc" id="L1567" title="All 2 branches missed.">                        default:      assert(false);</span>
                        }
                        break;
                    case CONSTANT_Long:
<span class="nc" id="L1571">                        bc_which = bc_longref;</span>
<span class="nc bnc" id="L1572" title="All 4 branches missed.">                        assert(bc == _ldc2_w);</span>
<span class="nc" id="L1573">                        vbc = _lldc2_w;</span>
<span class="nc" id="L1574">                        break;</span>
                    case CONSTANT_Double:
<span class="nc" id="L1576">                        bc_which = bc_doubleref;</span>
<span class="nc bnc" id="L1577" title="All 4 branches missed.">                        assert(bc == _ldc2_w);</span>
<span class="nc" id="L1578">                        vbc = _dldc2_w;</span>
<span class="nc" id="L1579">                        break;</span>
                    case CONSTANT_String:
<span class="nc" id="L1581">                        bc_which = bc_stringref;</span>
<span class="nc bnc" id="L1582" title="All 3 branches missed.">                        switch (bc) {</span>
<span class="nc" id="L1583">                        case _ldc:    vbc = _sldc; break;</span>
<span class="nc" id="L1584">                        case _ldc_w:  vbc = _sldc_w; break;</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">                        default:      assert(false);</span>
                        }
                        break;
                    case CONSTANT_Class:
<span class="nc" id="L1589">                        bc_which = bc_classref;</span>
<span class="nc bnc" id="L1590" title="All 3 branches missed.">                        switch (bc) {</span>
<span class="nc" id="L1591">                        case _ldc:    vbc = _cldc; break;</span>
<span class="nc" id="L1592">                        case _ldc_w:  vbc = _cldc_w; break;</span>
<span class="nc bnc" id="L1593" title="All 2 branches missed.">                        default:      assert(false);</span>
                        }
                        break;
                    default:
                        // CONSTANT_MethodHandle, etc.
<span class="nc bnc" id="L1598" title="All 2 branches missed.">                        if (getHighestClassVersion().lessThan(JAVA7_MAX_CLASS_VERSION)) {</span>
<span class="nc" id="L1599">                            throw new IOException(&quot;bad class file major version for Java 7 ldc&quot;);</span>
                        }
<span class="nc" id="L1601">                        bc_which = bc_loadablevalueref;</span>
<span class="nc bnc" id="L1602" title="All 3 branches missed.">                        switch (bc) {</span>
<span class="nc" id="L1603">                        case _ldc:    vbc = _qldc; break;</span>
<span class="nc" id="L1604">                        case _ldc_w:  vbc = _qldc_w; break;</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">                        default:      assert(false);</span>
                        }
                    }
                    break;
                case CONSTANT_Class:
                    // Use a special shorthand for the current class:
<span class="nc bnc" id="L1611" title="All 2 branches missed.">                    if (ref == curClass.thisClass)  ref = null;</span>
<span class="nc" id="L1612">                    bc_which = bc_classref; break;</span>
                case CONSTANT_Fieldref:
<span class="nc" id="L1614">                    bc_which = bc_fieldref; break;</span>
                case CONSTANT_Methodref:
<span class="nc bnc" id="L1616" title="All 2 branches missed.">                    if (ref.tagEquals(CONSTANT_InterfaceMethodref)) {</span>
<span class="nc bnc" id="L1617" title="All 2 branches missed.">                        if (bc == _invokespecial)</span>
<span class="nc" id="L1618">                            vbc = _invokespecial_int;</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">                        if (bc == _invokestatic)</span>
<span class="nc" id="L1620">                            vbc = _invokestatic_int;</span>
<span class="nc" id="L1621">                        bc_which = bc_imethodref;</span>
                    } else {
<span class="nc" id="L1623">                        bc_which = bc_methodref;</span>
                    }
<span class="nc" id="L1625">                    break;</span>
                case CONSTANT_InterfaceMethodref:
<span class="nc" id="L1627">                    bc_which = bc_imethodref; break;</span>
                case CONSTANT_InvokeDynamic:
<span class="nc" id="L1629">                    bc_which = bc_indyref; break;</span>
                default:
<span class="nc" id="L1631">                    bc_which = null;</span>
<span class="nc bnc" id="L1632" title="All 2 branches missed.">                    assert(false);</span>
                }
<span class="nc bnc" id="L1634" title="All 6 branches missed.">                if (ref != null &amp;&amp; bc_which.index != null &amp;&amp; !bc_which.index.contains(ref)) {</span>
                    // Crash and burn with a complaint if there are funny
                    // references for this bytecode instruction.
                    // Example:  invokestatic of a CONSTANT_InterfaceMethodref.
<span class="nc" id="L1638">                    String complaint = code.getMethod() +</span>
                        &quot; contains a bytecode &quot; + i +
                        &quot; with an unsupported constant reference; please use the pass-file option on this class.&quot;;
<span class="nc" id="L1641">                    Utils.log.warning(complaint);</span>
<span class="nc" id="L1642">                    throw new IOException(complaint);</span>
                }
<span class="nc" id="L1644">                bc_codes.putByte(vbc);</span>
<span class="nc" id="L1645">                bc_which.putRef(ref);</span>
                // handle trailing junk
<span class="nc bnc" id="L1647" title="All 2 branches missed.">                if (bc == _multianewarray) {</span>
<span class="nc bnc" id="L1648" title="All 4 branches missed.">                    assert(i.getConstant() == code.getByte(i.getPC()+3));</span>
                    // Just dump the byte into the bipush pile
<span class="nc" id="L1650">                    bc_byte.putByte(0xFF &amp; i.getConstant());</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">                } else if (bc == _invokeinterface) {</span>
<span class="nc bnc" id="L1652" title="All 4 branches missed.">                    assert(i.getLength() == 5);</span>
                    // Make sure the discarded bytes are sane:
<span class="nc bnc" id="L1654" title="All 4 branches missed.">                    assert(i.getConstant() == (1+((MemberEntry)ref).descRef.typeRef.computeSize(true)) &lt;&lt; 8);</span>
<span class="nc bnc" id="L1655" title="All 2 branches missed.">                } else if (bc == _invokedynamic) {</span>
<span class="nc bnc" id="L1656" title="All 2 branches missed.">                    if (getHighestClassVersion().lessThan(JAVA7_MAX_CLASS_VERSION)) {</span>
<span class="nc" id="L1657">                        throw new IOException(&quot;bad class major version for Java 7 invokedynamic&quot;);</span>
                    }
<span class="nc bnc" id="L1659" title="All 4 branches missed.">                    assert(i.getLength() == 5);</span>
<span class="nc bnc" id="L1660" title="All 4 branches missed.">                    assert(i.getConstant() == 0);  // last 2 bytes MBZ</span>
                } else {
                    // Make sure there is nothing else to write.
<span class="nc bnc" id="L1663" title="All 6 branches missed.">                    assert(i.getLength() == ((bc == _ldc)?2:3));</span>
                }
                continue;
            }
<span class="nc" id="L1667">            int slot = i.getLocalSlot();</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">            if (slot &gt;= 0) {</span>
<span class="nc" id="L1669">                bc_codes.putByte(bc);</span>
<span class="nc" id="L1670">                bc_local.putInt(slot);</span>
<span class="nc" id="L1671">                int con = i.getConstant();</span>
<span class="nc bnc" id="L1672" title="All 2 branches missed.">                if (bc == _iinc) {</span>
<span class="nc bnc" id="L1673" title="All 2 branches missed.">                    if (!i.isWide()) {</span>
<span class="nc" id="L1674">                        bc_byte.putByte(0xFF &amp; con);</span>
                    } else {
<span class="nc" id="L1676">                        bc_short.putInt(0xFFFF &amp; con);</span>
                    }
                } else {
<span class="nc bnc" id="L1679" title="All 4 branches missed.">                    assert(con == 0);</span>
                }
                continue;
            }
            // Generic instruction.  Copy the body.
<span class="nc" id="L1684">            bc_codes.putByte(bc);</span>
<span class="nc" id="L1685">            int pc = i.getPC()+1;</span>
<span class="nc" id="L1686">            int npc = i.getNextPC();</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">            if (pc &lt; npc) {</span>
                // Do a few remaining multi-byte instructions.
<span class="nc bnc" id="L1689" title="All 4 branches missed.">                switch (bc) {</span>
                case _sipush:
<span class="nc" id="L1691">                    bc_short.putInt(0xFFFF &amp; i.getConstant());</span>
<span class="nc" id="L1692">                    break;</span>
                case _bipush:
<span class="nc" id="L1694">                    bc_byte.putByte(0xFF &amp; i.getConstant());</span>
<span class="nc" id="L1695">                    break;</span>
                case _newarray:
<span class="nc" id="L1697">                    bc_byte.putByte(0xFF &amp; i.getConstant());</span>
<span class="nc" id="L1698">                    break;</span>
                default:
<span class="nc bnc" id="L1700" title="All 2 branches missed.">                    assert(false);  // that's it</span>
                }
            }
        }
<span class="nc" id="L1704">        bc_codes.putByte(_end_marker);</span>
<span class="nc" id="L1705">        bc_codes.elementCountForDebug++;</span>
<span class="nc" id="L1706">        codeHist[_end_marker]++;</span>
<span class="nc" id="L1707">        endCode();</span>
<span class="nc" id="L1708">    }</span>

<span class="nc" id="L1710">    int[] codeHist = new int[1&lt;&lt;8];</span>
<span class="nc" id="L1711">    int[] ldcHist  = new int[20];</span>
    void printCodeHist() {
<span class="nc bnc" id="L1713" title="All 4 branches missed.">        assert(verbose &gt; 0);</span>
<span class="nc" id="L1714">        String[] hist = new String[codeHist.length];</span>
<span class="nc" id="L1715">        int totalBytes = 0;</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">        for (int bc = 0; bc &lt; codeHist.length; bc++) {</span>
<span class="nc" id="L1717">            totalBytes += codeHist[bc];</span>
        }
<span class="nc bnc" id="L1719" title="All 2 branches missed.">        for (int bc = 0; bc &lt; codeHist.length; bc++) {</span>
<span class="nc bnc" id="L1720" title="All 2 branches missed.">            if (codeHist[bc] == 0) { hist[bc] = &quot;&quot;; continue; }</span>
<span class="nc" id="L1721">            String iname = Instruction.byteName(bc);</span>
<span class="nc" id="L1722">            String count = &quot;&quot; + codeHist[bc];</span>
<span class="nc" id="L1723">            count = &quot;         &quot;.substring(count.length()) + count;</span>
<span class="nc" id="L1724">            String pct = &quot;&quot; + (codeHist[bc] * 10000 / totalBytes);</span>
<span class="nc bnc" id="L1725" title="All 2 branches missed.">            while (pct.length() &lt; 4) {</span>
<span class="nc" id="L1726">                pct = &quot;0&quot; + pct;</span>
            }
<span class="nc" id="L1728">            pct = pct.substring(0, pct.length()-2) + &quot;.&quot; + pct.substring(pct.length()-2);</span>
<span class="nc" id="L1729">            hist[bc] = count + &quot;  &quot; + pct + &quot;%  &quot; + iname;</span>
        }
<span class="nc" id="L1731">        Arrays.sort(hist);</span>
<span class="nc" id="L1732">        System.out.println(&quot;Bytecode histogram [&quot;+totalBytes+&quot;]&quot;);</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">        for (int i = hist.length; --i &gt;= 0; ) {</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">            if (&quot;&quot;.equals(hist[i]))  continue;</span>
<span class="nc" id="L1735">            System.out.println(hist[i]);</span>
        }
<span class="nc bnc" id="L1737" title="All 2 branches missed.">        for (int tag = 0; tag &lt; ldcHist.length; tag++) {</span>
<span class="nc" id="L1738">            int count = ldcHist[tag];</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">            if (count == 0)  continue;</span>
<span class="nc" id="L1740">            System.out.println(&quot;ldc &quot;+ConstantPool.tagName(tag)+&quot; &quot;+count);</span>
        }
<span class="nc" id="L1742">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>