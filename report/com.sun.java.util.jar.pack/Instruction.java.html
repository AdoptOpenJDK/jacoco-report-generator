<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Instruction.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">Instruction.java</span></div><h1>Instruction.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import java.io.IOException;
import java.util.Arrays;
import static com.sun.java.util.jar.pack.Constants.*;

/**
 * A parsed bytecode instruction.
 * Provides accessors to various relevant bits.
 * @author John Rose
 */
<span class="nc bnc" id="L37" title="All 2 branches missed.">class Instruction  {</span>
    protected byte[] bytes;  // bytecodes
    protected int pc;        // location of this instruction
    protected int bc;        // opcode of this instruction
    protected int w;         // 0 if normal, 1 if a _wide prefix at pc
    protected int length;    // bytes in this instruction

    protected boolean special;

<span class="nc" id="L46">    protected Instruction(byte[] bytes, int pc, int bc, int w, int length) {</span>
<span class="nc" id="L47">        reset(bytes, pc, bc, w, length);</span>
<span class="nc" id="L48">    }</span>
    private void reset(byte[] bytes, int pc, int bc, int w, int length) {
<span class="nc" id="L50">        this.bytes = bytes;</span>
<span class="nc" id="L51">        this.pc = pc;</span>
<span class="nc" id="L52">        this.bc = bc;</span>
<span class="nc" id="L53">        this.w = w;</span>
<span class="nc" id="L54">        this.length = length;</span>
<span class="nc" id="L55">    }</span>

    public int getBC() {
<span class="nc" id="L58">        return bc;</span>
    }
    public boolean isWide() {
<span class="nc bnc" id="L61" title="All 2 branches missed.">        return w != 0;</span>
    }
    public byte[] getBytes() {
<span class="nc" id="L64">        return bytes;</span>
    }
    public int getPC() {
<span class="nc" id="L67">        return pc;</span>
    }
    public int getLength() {
<span class="nc" id="L70">        return length;</span>
    }
    public int getNextPC() {
<span class="nc" id="L73">        return pc + length;</span>
    }

    public Instruction next() {
<span class="nc" id="L77">        int npc = pc + length;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        if (npc == bytes.length)</span>
<span class="nc" id="L79">            return null;</span>
        else
<span class="nc" id="L81">            return Instruction.at(bytes, npc, this);</span>
    }

    public boolean isNonstandard() {
<span class="nc" id="L85">        return isNonstandard(bc);</span>
    }

    public void setNonstandardLength(int length) {
<span class="nc bnc" id="L89" title="All 4 branches missed.">        assert(isNonstandard());</span>
<span class="nc" id="L90">        this.length = length;</span>
<span class="nc" id="L91">    }</span>


    /** A fake instruction at this pc whose next() will be at nextpc. */
    public Instruction forceNextPC(int nextpc) {
<span class="nc" id="L96">        int llength = nextpc - pc;</span>
<span class="nc" id="L97">        return new Instruction(bytes, pc, -1, -1, llength);</span>
    }

    public static Instruction at(byte[] bytes, int pc) {
<span class="nc" id="L101">        return Instruction.at(bytes, pc, null);</span>
    }

    public static Instruction at(byte[] bytes, int pc, Instruction reuse) {
<span class="nc" id="L105">        int bc = getByte(bytes, pc);</span>
<span class="nc" id="L106">        int prefix = -1;</span>
<span class="nc" id="L107">        int w = 0;</span>
<span class="nc" id="L108">        int length = BC_LENGTH[w][bc];</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (length == 0) {</span>
            // Hard cases:
<span class="nc bnc" id="L111" title="All 4 branches missed.">            switch (bc) {</span>
            case _wide:
<span class="nc" id="L113">                bc = getByte(bytes, pc+1);</span>
<span class="nc" id="L114">                w = 1;</span>
<span class="nc" id="L115">                length = BC_LENGTH[w][bc];</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">                if (length == 0) {</span>
                    // unknown instruction; treat as one byte
<span class="nc" id="L118">                    length = 1;</span>
                }
                break;
            case _tableswitch:
<span class="nc" id="L122">                return new TableSwitch(bytes, pc);</span>
            case _lookupswitch:
<span class="nc" id="L124">                return new LookupSwitch(bytes, pc);</span>
            default:
                // unknown instruction; treat as one byte
<span class="nc" id="L127">                length = 1;</span>
                break;
            }
        }
<span class="nc bnc" id="L131" title="All 4 branches missed.">        assert(length &gt; 0);</span>
<span class="nc bnc" id="L132" title="All 4 branches missed.">        assert(pc+length &lt;= bytes.length);</span>
        // Speed hack:  Instruction.next reuses self if possible.
<span class="nc bnc" id="L134" title="All 4 branches missed.">        if (reuse != null &amp;&amp; !reuse.special) {</span>
<span class="nc" id="L135">            reuse.reset(bytes, pc, bc, w, length);</span>
<span class="nc" id="L136">            return reuse;</span>
        }
<span class="nc" id="L138">        return new Instruction(bytes, pc, bc, w, length);</span>
    }

    // Return the constant pool reference type, or 0 if none.
    public byte getCPTag() {
<span class="nc" id="L143">        return BC_TAG[w][bc];</span>
    }

    // Return the constant pool index, or -1 if none.
    public int getCPIndex() {
<span class="nc" id="L148">        int indexLoc = BC_INDEX[w][bc];</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (indexLoc == 0)  return -1;</span>
<span class="nc bnc" id="L150" title="All 4 branches missed.">        assert(w == 0);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (length == 2)</span>
<span class="nc" id="L152">            return getByte(bytes, pc+indexLoc);  // _ldc opcode only</span>
        else
<span class="nc" id="L154">            return getShort(bytes, pc+indexLoc);</span>
    }

    public void setCPIndex(int cpi) {
<span class="nc" id="L158">        int indexLoc = BC_INDEX[w][bc];</span>
<span class="nc bnc" id="L159" title="All 4 branches missed.">        assert(indexLoc != 0);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (length == 2)</span>
<span class="nc" id="L161">            setByte(bytes, pc+indexLoc, cpi);  // _ldc opcode only</span>
        else
<span class="nc" id="L163">            setShort(bytes, pc+indexLoc, cpi);</span>
<span class="nc bnc" id="L164" title="All 4 branches missed.">        assert(getCPIndex() == cpi);</span>
<span class="nc" id="L165">    }</span>

    public ConstantPool.Entry getCPRef(ConstantPool.Entry[] cpMap) {
<span class="nc" id="L168">        int index = getCPIndex();</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        return (index &lt; 0) ? null : cpMap[index];</span>
    }

    // Return the slot of the affected local, or -1 if none.
    public int getLocalSlot() {
<span class="nc" id="L174">        int slotLoc = BC_SLOT[w][bc];</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (slotLoc == 0)  return -1;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (w == 0)</span>
<span class="nc" id="L177">            return getByte(bytes, pc+slotLoc);</span>
        else
<span class="nc" id="L179">            return getShort(bytes, pc+slotLoc);</span>
    }

    // Return the target of the branch, or -1 if none.
    public int getBranchLabel() {
<span class="nc" id="L184">        int branchLoc = BC_BRANCH[w][bc];</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (branchLoc == 0)  return -1;</span>
<span class="nc bnc" id="L186" title="All 4 branches missed.">        assert(w == 0);</span>
<span class="nc bnc" id="L187" title="All 6 branches missed.">        assert(length == 3 || length == 5);</span>
        int offset;
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (length == 3)</span>
<span class="nc" id="L190">            offset = (short)getShort(bytes, pc+branchLoc);</span>
        else
<span class="nc" id="L192">            offset = getInt(bytes, pc+branchLoc);</span>
<span class="nc bnc" id="L193" title="All 4 branches missed.">        assert(offset+pc &gt;= 0);</span>
<span class="nc bnc" id="L194" title="All 4 branches missed.">        assert(offset+pc &lt;= bytes.length);</span>
<span class="nc" id="L195">        return offset+pc;</span>
    }

    public void setBranchLabel(int targetPC) {
<span class="nc" id="L199">        int branchLoc = BC_BRANCH[w][bc];</span>
<span class="nc bnc" id="L200" title="All 4 branches missed.">        assert(branchLoc != 0);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (length == 3)</span>
<span class="nc" id="L202">            setShort(bytes, pc+branchLoc, targetPC-pc);</span>
        else
<span class="nc" id="L204">            setInt(bytes, pc+branchLoc, targetPC-pc);</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">        assert(targetPC == getBranchLabel());</span>
<span class="nc" id="L206">    }</span>

    // Return the trailing constant in the instruction (as a signed value).
    // Return 0 if there is none.
    public int getConstant() {
<span class="nc" id="L211">        int conLoc = BC_CON[w][bc];</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (conLoc == 0)  return 0;</span>
<span class="nc bnc" id="L213" title="All 3 branches missed.">        switch (length - conLoc) {</span>
<span class="nc" id="L214">        case 1: return (byte) getByte(bytes, pc+conLoc);</span>
<span class="nc" id="L215">        case 2: return (short) getShort(bytes, pc+conLoc);</span>
        }
<span class="nc bnc" id="L217" title="All 2 branches missed.">        assert(false);</span>
<span class="nc" id="L218">        return 0;</span>
    }

    public void setConstant(int con) {
<span class="nc" id="L222">        int conLoc = BC_CON[w][bc];</span>
<span class="nc bnc" id="L223" title="All 4 branches missed.">        assert(conLoc != 0);</span>
<span class="nc bnc" id="L224" title="All 3 branches missed.">        switch (length - conLoc) {</span>
<span class="nc" id="L225">        case 1: setByte(bytes, pc+conLoc, con); break;</span>
<span class="nc" id="L226">        case 2: setShort(bytes, pc+conLoc, con); break;</span>
        }
<span class="nc bnc" id="L228" title="All 4 branches missed.">        assert(con == getConstant());</span>
<span class="nc" id="L229">    }</span>

    public abstract static class Switch extends Instruction {
        // Each case is a (value, label) pair, indexed 0 &lt;= n &lt; caseCount
        public abstract int  getCaseCount();
        public abstract int  getCaseValue(int n);
        public abstract int  getCaseLabel(int n);
        public abstract void setCaseCount(int caseCount);
        public abstract void setCaseValue(int n, int value);
        public abstract void setCaseLabel(int n, int targetPC);
        protected abstract int getLength(int caseCount);

<span class="nc" id="L241">        public int  getDefaultLabel()             { return intAt(0)+pc; }</span>
<span class="nc" id="L242">        public void setDefaultLabel(int targetPC) { setIntAt(0, targetPC-pc); }</span>

        protected int apc;        // aligned pc (table base)
<span class="nc" id="L245">        protected int intAt(int n) { return getInt(bytes, apc + n*4); }</span>
<span class="nc" id="L246">        protected void setIntAt(int n, int x) { setInt(bytes, apc + n*4, x); }</span>
        protected Switch(byte[] bytes, int pc, int bc) {
<span class="nc" id="L248">            super(bytes, pc, bc, /*w*/0, /*length*/0);</span>
<span class="nc" id="L249">            this.apc = alignPC(pc+1);</span>
<span class="nc" id="L250">            this.special = true;</span>
<span class="nc" id="L251">            length = getLength(getCaseCount());</span>
<span class="nc" id="L252">        }</span>
<span class="nc" id="L253">        public int getAlignedPC() { return apc; }</span>
        public String toString() {
<span class="nc" id="L255">            String s = super.toString();</span>
<span class="nc" id="L256">            s += &quot; Default:&quot;+labstr(getDefaultLabel());</span>
<span class="nc" id="L257">            int caseCount = getCaseCount();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">            for (int i = 0; i &lt; caseCount; i++) {</span>
<span class="nc" id="L259">                s += &quot;\n\tCase &quot;+getCaseValue(i)+&quot;:&quot;+labstr(getCaseLabel(i));</span>
            }
<span class="nc" id="L261">            return s;</span>
        }
        public static int alignPC(int apc) {
<span class="nc bnc" id="L264" title="All 2 branches missed.">            while (apc % 4 != 0)  ++apc;</span>
<span class="nc" id="L265">            return apc;</span>
        }
    }

    public static class TableSwitch extends Switch {
        // apc:  (df, lo, hi, (hi-lo+1)*(label))
<span class="nc" id="L271">        public int getLowCase()        { return intAt(1); }</span>
<span class="nc" id="L272">        public int getHighCase()       { return intAt(2); }</span>
<span class="nc" id="L273">        public int getCaseCount()      { return intAt(2)-intAt(1)+1; }</span>
<span class="nc" id="L274">        public int getCaseValue(int n) { return getLowCase()+n; }</span>
<span class="nc" id="L275">        public int getCaseLabel(int n) { return intAt(3+n)+pc; }</span>

<span class="nc" id="L277">        public void setLowCase(int val)  { setIntAt(1, val); }</span>
<span class="nc" id="L278">        public void setHighCase(int val) { setIntAt(2, val); }</span>
<span class="nc" id="L279">        public void setCaseLabel(int n, int tpc) { setIntAt(3+n, tpc-pc); }</span>
        public void setCaseCount(int caseCount) {
<span class="nc" id="L281">            setHighCase(getLowCase() + caseCount - 1);</span>
<span class="nc" id="L282">            length = getLength(caseCount);</span>
<span class="nc" id="L283">        }</span>
        public void setCaseValue(int n, int val) {
<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (n != 0)  throw new UnsupportedOperationException();</span>
<span class="nc" id="L286">            int caseCount = getCaseCount();</span>
<span class="nc" id="L287">            setLowCase(val);</span>
<span class="nc" id="L288">            setCaseCount(caseCount);  // keep invariant</span>
<span class="nc" id="L289">        }</span>

        TableSwitch(byte[] bytes, int pc) {
<span class="nc" id="L292">            super(bytes, pc, _tableswitch);</span>
<span class="nc" id="L293">        }</span>
        protected int getLength(int caseCount) {
<span class="nc" id="L295">            return (apc-pc) + (3 + caseCount) * 4;</span>
        }
    }

    public static class LookupSwitch extends Switch {
        // apc:  (df, nc, nc*(case, label))
<span class="nc" id="L301">        public int getCaseCount()      { return intAt(1); }</span>
<span class="nc" id="L302">        public int getCaseValue(int n) { return intAt(2+n*2+0); }</span>
<span class="nc" id="L303">        public int getCaseLabel(int n) { return intAt(2+n*2+1)+pc; }</span>

        public void setCaseCount(int caseCount)  {
<span class="nc" id="L306">            setIntAt(1, caseCount);</span>
<span class="nc" id="L307">            length = getLength(caseCount);</span>
<span class="nc" id="L308">        }</span>
<span class="nc" id="L309">        public void setCaseValue(int n, int val) { setIntAt(2+n*2+0, val); }</span>
<span class="nc" id="L310">        public void setCaseLabel(int n, int tpc) { setIntAt(2+n*2+1, tpc-pc); }</span>

        LookupSwitch(byte[] bytes, int pc) {
<span class="nc" id="L313">            super(bytes, pc, _lookupswitch);</span>
<span class="nc" id="L314">        }</span>
        protected int getLength(int caseCount) {
<span class="nc" id="L316">            return (apc-pc) + (2 + caseCount*2) * 4;</span>
        }
    }

    /** Two instructions are equal if they have the same bytes. */
    public boolean equals(Object o) {
<span class="nc bnc" id="L322" title="All 4 branches missed.">        return (o != null) &amp;&amp; (o.getClass() == Instruction.class)</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                &amp;&amp; equals((Instruction) o);</span>
    }

    public int hashCode() {
<span class="nc" id="L327">        int hash = 3;</span>
<span class="nc" id="L328">        hash = 11 * hash + Arrays.hashCode(this.bytes);</span>
<span class="nc" id="L329">        hash = 11 * hash + this.pc;</span>
<span class="nc" id="L330">        hash = 11 * hash + this.bc;</span>
<span class="nc" id="L331">        hash = 11 * hash + this.w;</span>
<span class="nc" id="L332">        hash = 11 * hash + this.length;</span>
<span class="nc" id="L333">        return hash;</span>
    }

    public boolean equals(Instruction that) {
<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (this.pc != that.pc)            return false;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (this.bc != that.bc)            return false;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (this.w  != that.w)             return false;</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (this.length  != that.length)   return false;</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        for (int i = 1; i &lt; length; i++) {</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">            if (this.bytes[this.pc+i] != that.bytes[that.pc+i])</span>
<span class="nc" id="L343">                return false;</span>
        }
<span class="nc" id="L345">        return true;</span>
    }

    static String labstr(int pc) {
<span class="nc bnc" id="L349" title="All 4 branches missed.">        if (pc &gt;= 0 &amp;&amp; pc &lt; 100000)</span>
<span class="nc" id="L350">            return ((100000+pc)+&quot;&quot;).substring(1);</span>
<span class="nc" id="L351">        return pc+&quot;&quot;;</span>
    }
    public String toString() {
<span class="nc" id="L354">        return toString(null);</span>
    }
    public String toString(ConstantPool.Entry[] cpMap) {
<span class="nc" id="L357">        String s = labstr(pc) + &quot;: &quot;;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">        if (bc &gt;= _bytecode_limit) {</span>
<span class="nc" id="L359">            s += Integer.toHexString(bc);</span>
<span class="nc" id="L360">            return s;</span>
        }
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (w == 1)  s += &quot;wide &quot;;</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        String bcname = (bc &lt; BC_NAME.length)? BC_NAME[bc]: null;</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (bcname == null) {</span>
<span class="nc" id="L365">            return s+&quot;opcode#&quot;+bc;</span>
        }
<span class="nc" id="L367">        s += bcname;</span>
<span class="nc" id="L368">        int tag = getCPTag();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (tag != 0)  s += &quot; &quot;+ConstantPool.tagName(tag)+&quot;:&quot;;</span>
<span class="nc" id="L370">        int idx = getCPIndex();</span>
<span class="nc bnc" id="L371" title="All 4 branches missed.">        if (idx &gt;= 0)  s += (cpMap == null) ? &quot;&quot;+idx : &quot;=&quot;+cpMap[idx].stringValue();</span>
<span class="nc" id="L372">        int slt = getLocalSlot();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (slt &gt;= 0)  s += &quot; Local:&quot;+slt;</span>
<span class="nc" id="L374">        int lab = getBranchLabel();</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (lab &gt;= 0)  s += &quot; To:&quot;+labstr(lab);</span>
<span class="nc" id="L376">        int con = getConstant();</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (con != 0)  s += &quot; Con:&quot;+con;</span>
<span class="nc" id="L378">        return s;</span>
    }


    //public static byte constantPoolTagFor(int bc) { return BC_TAG[0][bc]; }

    /// Fetching values from byte arrays:

    public int getIntAt(int off) {
<span class="nc" id="L387">        return getInt(bytes, pc+off);</span>
    }
    public int getShortAt(int off) {
<span class="nc" id="L390">        return getShort(bytes, pc+off);</span>
    }
    public int getByteAt(int off) {
<span class="nc" id="L393">        return getByte(bytes, pc+off);</span>
    }


    public static int getInt(byte[] bytes, int pc) {
<span class="nc" id="L398">        return (getShort(bytes, pc+0) &lt;&lt; 16) + (getShort(bytes, pc+2) &lt;&lt; 0);</span>
    }
    public static int getShort(byte[] bytes, int pc) {
<span class="nc" id="L401">        return (getByte(bytes, pc+0) &lt;&lt; 8) + (getByte(bytes, pc+1) &lt;&lt; 0);</span>
    }
    public static int getByte(byte[] bytes, int pc) {
<span class="nc" id="L404">        return bytes[pc] &amp; 0xFF;</span>
    }


    public static void setInt(byte[] bytes, int pc, int x) {
<span class="nc" id="L409">        setShort(bytes, pc+0, x &gt;&gt; 16);</span>
<span class="nc" id="L410">        setShort(bytes, pc+2, x &gt;&gt; 0);</span>
<span class="nc" id="L411">    }</span>
    public static void setShort(byte[] bytes, int pc, int x) {
<span class="nc" id="L413">        setByte(bytes, pc+0, x &gt;&gt; 8);</span>
<span class="nc" id="L414">        setByte(bytes, pc+1, x &gt;&gt; 0);</span>
<span class="nc" id="L415">    }</span>
    public static void setByte(byte[] bytes, int pc, int x) {
<span class="nc" id="L417">        bytes[pc] = (byte)x;</span>
<span class="nc" id="L418">    }</span>

    // some bytecode classifiers


    public static boolean isNonstandard(int bc) {
<span class="nc bnc" id="L424" title="All 2 branches missed.">        return BC_LENGTH[0][bc] &lt; 0;</span>
    }

    public static int opLength(int bc) {
<span class="nc" id="L428">        int l = BC_LENGTH[0][bc];</span>
<span class="nc bnc" id="L429" title="All 4 branches missed.">        assert(l &gt; 0);</span>
<span class="nc" id="L430">        return l;</span>
    }
    public static int opWideLength(int bc) {
<span class="nc" id="L433">        int l = BC_LENGTH[1][bc];</span>
<span class="nc bnc" id="L434" title="All 4 branches missed.">        assert(l &gt; 0);</span>
<span class="nc" id="L435">        return l;</span>
    }

    public static boolean isLocalSlotOp(int bc) {
<span class="nc bnc" id="L439" title="All 4 branches missed.">        return (bc &lt; BC_SLOT[0].length &amp;&amp; BC_SLOT[0][bc] &gt; 0);</span>
    }

    public static boolean isBranchOp(int bc) {
<span class="nc bnc" id="L443" title="All 4 branches missed.">        return (bc &lt; BC_BRANCH[0].length &amp;&amp; BC_BRANCH[0][bc] &gt; 0);</span>
    }

    public static boolean isCPRefOp(int bc) {
<span class="nc bnc" id="L447" title="All 4 branches missed.">        if (bc &lt; BC_INDEX[0].length &amp;&amp; BC_INDEX[0][bc] &gt; 0)  return true;</span>
<span class="nc bnc" id="L448" title="All 4 branches missed.">        if (bc &gt;= _xldc_op &amp;&amp; bc &lt; _xldc_limit)  return true;</span>
<span class="nc bnc" id="L449" title="All 4 branches missed.">        if (bc == _invokespecial_int || bc == _invokestatic_int) return true;</span>
<span class="nc" id="L450">        return false;</span>
    }

    public static byte getCPRefOpTag(int bc) {
<span class="nc bnc" id="L454" title="All 4 branches missed.">        if (bc &lt; BC_INDEX[0].length &amp;&amp; BC_INDEX[0][bc] &gt; 0)  return BC_TAG[0][bc];</span>
<span class="nc bnc" id="L455" title="All 4 branches missed.">        if (bc &gt;= _xldc_op &amp;&amp; bc &lt; _xldc_limit)  return CONSTANT_LoadableValue;</span>
<span class="nc bnc" id="L456" title="All 4 branches missed.">        if (bc == _invokestatic_int || bc == _invokespecial_int) return CONSTANT_InterfaceMethodref;</span>
<span class="nc" id="L457">        return CONSTANT_None;</span>
    }

    public static boolean isFieldOp(int bc) {
<span class="nc bnc" id="L461" title="All 4 branches missed.">        return (bc &gt;= _getstatic &amp;&amp; bc &lt;= _putfield);</span>
    }

    public static boolean isInvokeInitOp(int bc) {
<span class="nc bnc" id="L465" title="All 4 branches missed.">        return (bc &gt;= _invokeinit_op &amp;&amp; bc &lt; _invokeinit_limit);</span>
    }

    public static boolean isSelfLinkerOp(int bc) {
<span class="nc bnc" id="L469" title="All 4 branches missed.">        return (bc &gt;= _self_linker_op &amp;&amp; bc &lt; _self_linker_limit);</span>
    }

    /// Format definitions.

<span class="nc" id="L474">    static private final byte[][] BC_LENGTH  = new byte[2][0x100];</span>
<span class="nc" id="L475">    static private final byte[][] BC_INDEX   = new byte[2][0x100];</span>
<span class="nc" id="L476">    static private final byte[][] BC_TAG     = new byte[2][0x100];</span>
<span class="nc" id="L477">    static private final byte[][] BC_BRANCH  = new byte[2][0x100];</span>
<span class="nc" id="L478">    static private final byte[][] BC_SLOT    = new byte[2][0x100];</span>
<span class="nc" id="L479">    static private final byte[][] BC_CON     = new byte[2][0x100];</span>
<span class="nc" id="L480">    static private final String[] BC_NAME    = new String[0x100]; // debug only</span>
<span class="nc" id="L481">    static private final String[][] BC_FORMAT  = new String[2][_bytecode_limit]; // debug only</span>
    static {
<span class="nc bnc" id="L483" title="All 2 branches missed.">        for (int i = 0; i &lt; _bytecode_limit; i++) {</span>
<span class="nc" id="L484">            BC_LENGTH[0][i] = -1;</span>
<span class="nc" id="L485">            BC_LENGTH[1][i] = -1;</span>
        }
<span class="nc" id="L487">        def(&quot;b&quot;, _nop, _dconst_1);</span>
<span class="nc" id="L488">        def(&quot;bx&quot;, _bipush);</span>
<span class="nc" id="L489">        def(&quot;bxx&quot;, _sipush);</span>
<span class="nc" id="L490">        def(&quot;bk&quot;, _ldc);                                // do not pack</span>
<span class="nc" id="L491">        def(&quot;bkk&quot;, _ldc_w, _ldc2_w);            // do not pack</span>
<span class="nc" id="L492">        def(&quot;blwbll&quot;, _iload, _aload);</span>
<span class="nc" id="L493">        def(&quot;b&quot;, _iload_0, _saload);</span>
<span class="nc" id="L494">        def(&quot;blwbll&quot;, _istore, _astore);</span>
<span class="nc" id="L495">        def(&quot;b&quot;, _istore_0, _lxor);</span>
<span class="nc" id="L496">        def(&quot;blxwbllxx&quot;, _iinc);</span>
<span class="nc" id="L497">        def(&quot;b&quot;, _i2l, _dcmpg);</span>
<span class="nc" id="L498">        def(&quot;boo&quot;, _ifeq, _jsr);                        // pack oo</span>
<span class="nc" id="L499">        def(&quot;blwbll&quot;, _ret);</span>
<span class="nc" id="L500">        def(&quot;&quot;, _tableswitch, _lookupswitch);   // pack all ints, omit padding</span>
<span class="nc" id="L501">        def(&quot;b&quot;, _ireturn, _return);</span>
<span class="nc" id="L502">        def(&quot;bkf&quot;, _getstatic, _putfield);              // pack kf (base=Field)</span>
<span class="nc" id="L503">        def(&quot;bkm&quot;, _invokevirtual, _invokestatic);      // pack kn (base=Method)</span>
<span class="nc" id="L504">        def(&quot;bkixx&quot;, _invokeinterface);         // pack ki (base=IMethod), omit xx</span>
<span class="nc" id="L505">        def(&quot;bkyxx&quot;, _invokedynamic);           // pack ky (base=Any), omit xx</span>
<span class="nc" id="L506">        def(&quot;bkc&quot;, _new);                               // pack kc</span>
<span class="nc" id="L507">        def(&quot;bx&quot;, _newarray);</span>
<span class="nc" id="L508">        def(&quot;bkc&quot;, _anewarray);                 // pack kc</span>
<span class="nc" id="L509">        def(&quot;b&quot;, _arraylength, _athrow);</span>
<span class="nc" id="L510">        def(&quot;bkc&quot;, _checkcast, _instanceof);    // pack kc</span>
<span class="nc" id="L511">        def(&quot;b&quot;, _monitorenter, _monitorexit);</span>
<span class="nc" id="L512">        def(&quot;&quot;, _wide);</span>
<span class="nc" id="L513">        def(&quot;bkcx&quot;, _multianewarray);           // pack kc</span>
<span class="nc" id="L514">        def(&quot;boo&quot;, _ifnull, _ifnonnull);                // pack oo</span>
<span class="nc" id="L515">        def(&quot;boooo&quot;, _goto_w, _jsr_w);          // pack oooo</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">        for (int i = 0; i &lt; _bytecode_limit; i++) {</span>
            //System.out.println(i+&quot;: l=&quot;+BC_LENGTH[0][i]+&quot; i=&quot;+BC_INDEX[0][i]);
            //assert(BC_LENGTH[0][i] != -1);
<span class="nc bnc" id="L519" title="All 2 branches missed.">            if (BC_LENGTH[0][i] == -1) {</span>
<span class="nc" id="L520">                continue;  // unknown opcode</span>
            }

            // Have a complete mapping, to support spurious _wide prefixes.
<span class="nc bnc" id="L524" title="All 2 branches missed.">            if (BC_LENGTH[1][i] == -1)</span>
<span class="nc" id="L525">                BC_LENGTH[1][i] = (byte)(1+BC_LENGTH[0][i]);</span>
        }

<span class="nc" id="L528">        String names =</span>
  &quot;nop aconst_null iconst_m1 iconst_0 iconst_1 iconst_2 iconst_3 iconst_4 &quot;+
  &quot;iconst_5 lconst_0 lconst_1 fconst_0 fconst_1 fconst_2 dconst_0 dconst_1 &quot;+
  &quot;bipush sipush ldc ldc_w ldc2_w iload lload fload dload aload iload_0 &quot;+
  &quot;iload_1 iload_2 iload_3 lload_0 lload_1 lload_2 lload_3 fload_0 fload_1 &quot;+
  &quot;fload_2 fload_3 dload_0 dload_1 dload_2 dload_3 aload_0 aload_1 aload_2 &quot;+
  &quot;aload_3 iaload laload faload daload aaload baload caload saload istore &quot;+
  &quot;lstore fstore dstore astore istore_0 istore_1 istore_2 istore_3 lstore_0 &quot;+
  &quot;lstore_1 lstore_2 lstore_3 fstore_0 fstore_1 fstore_2 fstore_3 dstore_0 &quot;+
  &quot;dstore_1 dstore_2 dstore_3 astore_0 astore_1 astore_2 astore_3 iastore &quot;+
  &quot;lastore fastore dastore aastore bastore castore sastore pop pop2 dup &quot;+
  &quot;dup_x1 dup_x2 dup2 dup2_x1 dup2_x2 swap iadd ladd fadd dadd isub lsub &quot;+
  &quot;fsub dsub imul lmul fmul dmul idiv ldiv fdiv ddiv irem lrem frem drem &quot;+
  &quot;ineg lneg fneg dneg ishl lshl ishr lshr iushr lushr iand land ior lor &quot;+
  &quot;ixor lxor iinc i2l i2f i2d l2i l2f l2d f2i f2l f2d d2i d2l d2f i2b i2c &quot;+
  &quot;i2s lcmp fcmpl fcmpg dcmpl dcmpg ifeq ifne iflt ifge ifgt ifle if_icmpeq &quot;+
  &quot;if_icmpne if_icmplt if_icmpge if_icmpgt if_icmple if_acmpeq if_acmpne &quot;+
  &quot;goto jsr ret tableswitch lookupswitch ireturn lreturn freturn dreturn &quot;+
  &quot;areturn return getstatic putstatic getfield putfield invokevirtual &quot;+
  &quot;invokespecial invokestatic invokeinterface invokedynamic new newarray &quot;+
  &quot;anewarray arraylength athrow checkcast instanceof monitorenter &quot;+
  &quot;monitorexit wide multianewarray ifnull ifnonnull goto_w jsr_w &quot;;
<span class="nc bnc" id="L550" title="All 2 branches missed.">        for (int bc = 0; names.length() &gt; 0; bc++) {</span>
<span class="nc" id="L551">            int sp = names.indexOf(' ');</span>
<span class="nc" id="L552">            BC_NAME[bc] = names.substring(0, sp);</span>
<span class="nc" id="L553">            names = names.substring(sp+1);</span>
        }
    }
    public static String byteName(int bc) {
        String iname;
<span class="nc bnc" id="L558" title="All 4 branches missed.">        if (bc &lt; BC_NAME.length &amp;&amp; BC_NAME[bc] != null) {</span>
<span class="nc" id="L559">            iname = BC_NAME[bc];</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">        } else if (isSelfLinkerOp(bc)) {</span>
<span class="nc" id="L561">            int idx = (bc - _self_linker_op);</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">            boolean isSuper = (idx &gt;= _self_linker_super_flag);</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (isSuper)  idx -= _self_linker_super_flag;</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">            boolean isAload = (idx &gt;= _self_linker_aload_flag);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if (isAload)  idx -= _self_linker_aload_flag;</span>
<span class="nc" id="L566">            int origBC = _first_linker_op + idx;</span>
<span class="nc bnc" id="L567" title="All 6 branches missed.">            assert(origBC &gt;= _first_linker_op &amp;&amp; origBC &lt;= _last_linker_op);</span>
<span class="nc" id="L568">            iname = BC_NAME[origBC];</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">            iname += (isSuper ? &quot;_super&quot; : &quot;_this&quot;);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">            if (isAload)  iname = &quot;aload_0&amp;&quot; + iname;</span>
<span class="nc" id="L571">            iname = &quot;*&quot;+iname;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        } else if (isInvokeInitOp(bc)) {</span>
<span class="nc" id="L573">            int idx = (bc - _invokeinit_op);</span>
<span class="nc bnc" id="L574" title="All 3 branches missed.">            switch (idx) {</span>
            case _invokeinit_self_option:
<span class="nc" id="L576">                iname = &quot;*invokespecial_init_this&quot;; break;</span>
            case _invokeinit_super_option:
<span class="nc" id="L578">                iname = &quot;*invokespecial_init_super&quot;; break;</span>
            default:
<span class="nc bnc" id="L580" title="All 4 branches missed.">                assert(idx == _invokeinit_new_option);</span>
<span class="nc" id="L581">                iname = &quot;*invokespecial_init_new&quot;; break;</span>
            }
<span class="nc" id="L583">        } else {</span>
<span class="nc bnc" id="L584" title="All 13 branches missed.">            switch (bc) {</span>
<span class="nc" id="L585">            case _ildc:  iname = &quot;*ildc&quot;; break;</span>
<span class="nc" id="L586">            case _fldc:  iname = &quot;*fldc&quot;; break;</span>
<span class="nc" id="L587">            case _ildc_w:  iname = &quot;*ildc_w&quot;; break;</span>
<span class="nc" id="L588">            case _fldc_w:  iname = &quot;*fldc_w&quot;; break;</span>
<span class="nc" id="L589">            case _dldc2_w:  iname = &quot;*dldc2_w&quot;; break;</span>
<span class="nc" id="L590">            case _cldc:  iname = &quot;*cldc&quot;; break;</span>
<span class="nc" id="L591">            case _cldc_w:  iname = &quot;*cldc_w&quot;; break;</span>
<span class="nc" id="L592">            case _qldc:  iname = &quot;*qldc&quot;; break;</span>
<span class="nc" id="L593">            case _qldc_w:  iname = &quot;*qldc_w&quot;; break;</span>
<span class="nc" id="L594">            case _byte_escape:  iname = &quot;*byte_escape&quot;; break;</span>
<span class="nc" id="L595">            case _ref_escape:  iname = &quot;*ref_escape&quot;; break;</span>
<span class="nc" id="L596">            case _end_marker:  iname = &quot;*end&quot;; break;</span>
<span class="nc" id="L597">            default:  iname = &quot;*bc#&quot;+bc; break;</span>
            }
        }
<span class="nc" id="L600">        return iname;</span>
    }
<span class="nc" id="L602">    private static int BW = 4;  // width of classification field</span>
    private static void def(String fmt, int bc) {
<span class="nc" id="L604">        def(fmt, bc, bc);</span>
<span class="nc" id="L605">    }</span>
    private static void def(String fmt, int from_bc, int to_bc) {
<span class="nc" id="L607">        String[] fmts = { fmt, null };</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (fmt.indexOf('w') &gt; 0) {</span>
<span class="nc" id="L609">            fmts[1] = fmt.substring(fmt.indexOf('w'));</span>
<span class="nc" id="L610">            fmts[0] = fmt.substring(0, fmt.indexOf('w'));</span>
        }
<span class="nc bnc" id="L612" title="All 2 branches missed.">        for (int w = 0; w &lt;= 1; w++) {</span>
<span class="nc" id="L613">            fmt = fmts[w];</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">            if (fmt == null)  continue;</span>
<span class="nc" id="L615">            int length = fmt.length();</span>
<span class="nc" id="L616">            int index  = Math.max(0, fmt.indexOf('k'));</span>
<span class="nc" id="L617">            int tag    = CONSTANT_None;</span>
<span class="nc" id="L618">            int branch = Math.max(0, fmt.indexOf('o'));</span>
<span class="nc" id="L619">            int slot   = Math.max(0, fmt.indexOf('l'));</span>
<span class="nc" id="L620">            int con    = Math.max(0, fmt.indexOf('x'));</span>
<span class="nc bnc" id="L621" title="All 4 branches missed.">            if (index &gt; 0 &amp;&amp; index+1 &lt; length) {</span>
<span class="nc bnc" id="L622" title="All 7 branches missed.">                switch (fmt.charAt(index+1)) {</span>
<span class="nc" id="L623">                    case 'c': tag = CONSTANT_Class; break;</span>
<span class="nc" id="L624">                    case 'k': tag = CONSTANT_LoadableValue; break;</span>
<span class="nc" id="L625">                    case 'f': tag = CONSTANT_Fieldref; break;</span>
<span class="nc" id="L626">                    case 'm': tag = CONSTANT_Methodref; break;</span>
<span class="nc" id="L627">                    case 'i': tag = CONSTANT_InterfaceMethodref; break;</span>
<span class="nc" id="L628">                    case 'y': tag = CONSTANT_InvokeDynamic; break;</span>
                }
<span class="nc bnc" id="L630" title="All 4 branches missed.">                assert(tag != CONSTANT_None);</span>
<span class="nc bnc" id="L631" title="All 4 branches missed.">            } else if (index &gt; 0 &amp;&amp; length == 2) {</span>
<span class="nc bnc" id="L632" title="All 4 branches missed.">                assert(from_bc == _ldc);</span>
<span class="nc" id="L633">                tag = CONSTANT_LoadableValue;  // _ldc opcode only</span>
            }
<span class="nc bnc" id="L635" title="All 2 branches missed.">            for (int bc = from_bc; bc &lt;= to_bc; bc++) {</span>
<span class="nc" id="L636">                BC_FORMAT[w][bc] = fmt;</span>
<span class="nc bnc" id="L637" title="All 4 branches missed.">                assert(BC_LENGTH[w][bc] == -1);</span>
<span class="nc" id="L638">                BC_LENGTH[w][bc] = (byte) length;</span>
<span class="nc" id="L639">                BC_INDEX[w][bc]  = (byte) index;</span>
<span class="nc" id="L640">                BC_TAG[w][bc]    = (byte) tag;</span>
<span class="nc bnc" id="L641" title="All 6 branches missed.">                assert(!(index == 0 &amp;&amp; tag != CONSTANT_None));</span>
<span class="nc" id="L642">                BC_BRANCH[w][bc] = (byte) branch;</span>
<span class="nc" id="L643">                BC_SLOT[w][bc]   = (byte) slot;</span>
<span class="nc bnc" id="L644" title="All 6 branches missed.">                assert(branch == 0 || slot == 0);   // not both branch &amp; local</span>
<span class="nc bnc" id="L645" title="All 6 branches missed.">                assert(branch == 0 || index == 0);  // not both branch &amp; cp</span>
<span class="nc bnc" id="L646" title="All 6 branches missed.">                assert(slot == 0   || index == 0);  // not both local &amp; cp</span>
<span class="nc" id="L647">                BC_CON[w][bc]    = (byte) con;</span>
            }
        }
<span class="nc" id="L650">    }</span>

    public static void opcodeChecker(byte[] code, ConstantPool.Entry[] cpMap,
            Package.Version clsVersion) throws FormatException {
<span class="nc" id="L654">        Instruction i = at(code, 0);</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">        while (i != null) {</span>
<span class="nc" id="L656">            int opcode = i.getBC();</span>
<span class="nc bnc" id="L657" title="All 4 branches missed.">            if (opcode &lt; _nop || opcode &gt; _jsr_w) {</span>
<span class="nc" id="L658">                String message = &quot;illegal opcode: &quot; + opcode + &quot; &quot; + i;</span>
<span class="nc" id="L659">                throw new FormatException(message);</span>
            }
<span class="nc" id="L661">            ConstantPool.Entry e = i.getCPRef(cpMap);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            if (e != null) {</span>
<span class="nc" id="L663">                byte tag = i.getCPTag();</span>
<span class="nc" id="L664">                boolean match = e.tagMatches(tag);</span>
<span class="nc bnc" id="L665" title="All 6 branches missed.">                if (!match &amp;&amp;</span>
                        (i.bc == _invokespecial || i.bc == _invokestatic) &amp;&amp;
<span class="nc bnc" id="L667" title="All 2 branches missed.">                        e.tagMatches(CONSTANT_InterfaceMethodref) &amp;&amp;</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">                        clsVersion.greaterThan(Constants.JAVA7_MAX_CLASS_VERSION)) {</span>
<span class="nc" id="L669">                    match = true;</span>
                }
<span class="nc bnc" id="L671" title="All 2 branches missed.">                if (!match) {</span>
<span class="nc" id="L672">                    String message = &quot;illegal reference, expected type=&quot;</span>
<span class="nc" id="L673">                            + ConstantPool.tagName(tag) + &quot;: &quot;</span>
<span class="nc" id="L674">                            + i.toString(cpMap);</span>
<span class="nc" id="L675">                    throw new FormatException(message);</span>
                }
            }
<span class="nc" id="L678">            i = i.next();</span>
<span class="nc" id="L679">        }</span>
<span class="nc" id="L680">    }</span>
    static class FormatException extends IOException {
        private static final long serialVersionUID = 3175572275651367015L;

        FormatException(String message) {
<span class="nc" id="L685">            super(message);</span>
<span class="nc" id="L686">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>