<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PopulationCoding.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">PopulationCoding.java</span></div><h1>PopulationCoding.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import static com.sun.java.util.jar.pack.Constants.*;

/**
 * Population-based coding.
 * See the section &quot;Encodings of Uncorrelated Values&quot; in the Pack200 spec.
 * @author John Rose
 */
// This tactic alone reduces the final zipped rt.jar by about a percent.
<span class="nc bnc" id="L43" title="All 2 branches missed.">class PopulationCoding implements CodingMethod {</span>
    Histogram vHist;   // histogram of all values
    int[]     fValues; // list of favored values
    int       fVlen;   // inclusive max index
    long[]    symtab;  // int map of favored value -&gt; token [1..#fValues]

    CodingMethod favoredCoding;
    CodingMethod tokenCoding;
    CodingMethod unfavoredCoding;

<span class="nc" id="L53">    int L = -1;  //preferred L value for tokenCoding</span>

    public void setFavoredValues(int[] fValues, int fVlen) {
        // Note:  {f} is allFavoredValues[1..fvlen], not [0..fvlen-1].
        // This is because zero is an exceptional favored value index.
<span class="nc bnc" id="L58" title="All 4 branches missed.">        assert(fValues[0] == 0);  // must be empty</span>
<span class="nc bnc" id="L59" title="All 4 branches missed.">        assert(this.fValues == null);  // do not do this twice</span>
<span class="nc" id="L60">        this.fValues = fValues;</span>
<span class="nc" id="L61">        this.fVlen   = fVlen;</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        if (L &gt;= 0) {</span>
<span class="nc" id="L63">            setL(L);  // reassert</span>
        }
<span class="nc" id="L65">    }</span>
    public void setFavoredValues(int[] fValues) {
<span class="nc" id="L67">        int lfVlen = fValues.length-1;</span>
<span class="nc" id="L68">        setFavoredValues(fValues, lfVlen);</span>
<span class="nc" id="L69">    }</span>
    public void setHistogram(Histogram vHist) {
<span class="nc" id="L71">        this.vHist = vHist;</span>
<span class="nc" id="L72">    }</span>
    public void setL(int L) {
<span class="nc" id="L74">        this.L = L;</span>
<span class="nc bnc" id="L75" title="All 6 branches missed.">        if (L &gt;= 0 &amp;&amp; fValues != null &amp;&amp; tokenCoding == null) {</span>
<span class="nc" id="L76">            tokenCoding = fitTokenCoding(fVlen, L);</span>
<span class="nc bnc" id="L77" title="All 4 branches missed.">            assert(tokenCoding != null);</span>
        }
<span class="nc" id="L79">    }</span>

    public static Coding fitTokenCoding(int fVlen, int L) {
        // Find the smallest B s.t. (B,H,0) covers fVlen.
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (fVlen &lt; 256)</span>
            // H/L do not matter when B==1
<span class="nc" id="L85">            return BandStructure.BYTE1;</span>
<span class="nc" id="L86">        Coding longest = BandStructure.UNSIGNED5.setL(L);</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (!longest.canRepresentUnsigned(fVlen))</span>
<span class="nc" id="L88">            return null;  // failure; L is too sharp and fVlen too large</span>
<span class="nc" id="L89">        Coding tc = longest;</span>
<span class="nc" id="L90">        for (Coding shorter = longest; ; ) {</span>
<span class="nc" id="L91">            shorter = shorter.setB(shorter.B()-1);</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">            if (shorter.umax() &lt; fVlen)</span>
<span class="nc" id="L93">                break;</span>
<span class="nc" id="L94">            tc = shorter;  // shorten it by reducing B</span>
        }
<span class="nc" id="L96">        return tc;</span>
    }

    public void setFavoredCoding(CodingMethod favoredCoding) {
<span class="nc" id="L100">        this.favoredCoding = favoredCoding;</span>
<span class="nc" id="L101">    }</span>
    public void setTokenCoding(CodingMethod tokenCoding) {
<span class="nc" id="L103">        this.tokenCoding = tokenCoding;</span>
<span class="nc" id="L104">        this.L = -1;</span>
<span class="nc bnc" id="L105" title="All 4 branches missed.">        if (tokenCoding instanceof Coding &amp;&amp; fValues != null) {</span>
<span class="nc" id="L106">            Coding tc = (Coding) tokenCoding;</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (tc == fitTokenCoding(fVlen, tc.L()))</span>
<span class="nc" id="L108">                this.L = tc.L();</span>
            // Otherwise, it's a non-default coding.
        }
<span class="nc" id="L111">    }</span>
    public void setUnfavoredCoding(CodingMethod unfavoredCoding) {
<span class="nc" id="L113">        this.unfavoredCoding = unfavoredCoding;</span>
<span class="nc" id="L114">    }</span>

    public int favoredValueMaxLength() {
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (L == 0)</span>
<span class="nc" id="L118">            return Integer.MAX_VALUE;</span>
        else
<span class="nc" id="L120">            return BandStructure.UNSIGNED5.setL(L).umax();</span>
    }

    public void resortFavoredValues() {
<span class="nc" id="L124">        Coding tc = (Coding) tokenCoding;</span>
        // Make a local copy before reordering.
<span class="nc" id="L126">        fValues = BandStructure.realloc(fValues, 1+fVlen);</span>
        // Resort favoredValues within each byte-size cadre.
<span class="nc" id="L128">        int fillp = 1;  // skip initial zero</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        for (int n = 1; n &lt;= tc.B(); n++) {</span>
<span class="nc" id="L130">            int nmax = tc.byteMax(n);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            if (nmax &gt; fVlen)</span>
<span class="nc" id="L132">                nmax = fVlen;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">            if (nmax &lt; tc.byteMin(n))</span>
<span class="nc" id="L134">                break;</span>
<span class="nc" id="L135">            int low = fillp;</span>
<span class="nc" id="L136">            int high = nmax+1;</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">            if (high == low)  continue;</span>
<span class="nc bnc" id="L138" title="All 4 branches missed.">            assert(high &gt; low)</span>
                : high+&quot;!&gt;&quot;+low;
<span class="nc bnc" id="L140" title="All 4 branches missed.">            assert(tc.getLength(low) == n)</span>
                : n+&quot; != len(&quot;+(low)+&quot;) == &quot;+
<span class="nc" id="L142">                  tc.getLength(low);</span>
<span class="nc bnc" id="L143" title="All 4 branches missed.">            assert(tc.getLength(high-1) == n)</span>
                : n+&quot; != len(&quot;+(high-1)+&quot;) == &quot;+
<span class="nc" id="L145">                  tc.getLength(high-1);</span>
<span class="nc" id="L146">            int midTarget = low + (high-low)/2;</span>
<span class="nc" id="L147">            int mid = low;</span>
            // Divide the values into cadres, and sort within each.
<span class="nc" id="L149">            int prevCount = -1;</span>
<span class="nc" id="L150">            int prevLimit = low;</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">            for (int i = low; i &lt; high; i++) {</span>
<span class="nc" id="L152">                int val = fValues[i];</span>
<span class="nc" id="L153">                int count = vHist.getFrequency(val);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                if (prevCount != count) {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                    if (n == 1) {</span>
                        // For the single-byte encoding, keep strict order
                        // among frequency groups.
<span class="nc" id="L158">                        Arrays.sort(fValues, prevLimit, i);</span>
<span class="nc" id="L159">                    } else if (Math.abs(mid - midTarget) &gt;</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                               Math.abs(i   - midTarget)) {</span>
                        // Find a single inflection point
                        // close to the middle of the byte-size cadre.
<span class="nc" id="L163">                        mid = i;</span>
                    }
<span class="nc" id="L165">                    prevCount = count;</span>
<span class="nc" id="L166">                    prevLimit = i;</span>
                }
            }
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (n == 1) {</span>
<span class="nc" id="L170">                Arrays.sort(fValues, prevLimit, high);</span>
            } else {
                // Sort up to the midpoint, if any.
<span class="nc" id="L173">                Arrays.sort(fValues, low, mid);</span>
<span class="nc" id="L174">                Arrays.sort(fValues, mid, high);</span>
            }
<span class="nc bnc" id="L176" title="All 4 branches missed.">            assert(tc.getLength(low) == tc.getLength(mid));</span>
<span class="nc bnc" id="L177" title="All 4 branches missed.">            assert(tc.getLength(low) == tc.getLength(high-1));</span>
<span class="nc" id="L178">            fillp = nmax+1;</span>
        }
<span class="nc bnc" id="L180" title="All 4 branches missed.">        assert(fillp == fValues.length);</span>

        // Reset symtab.
<span class="nc" id="L183">        symtab = null;</span>
<span class="nc" id="L184">    }</span>

    public int getToken(int value) {
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (symtab == null)</span>
<span class="nc" id="L188">            symtab = makeSymtab();</span>
<span class="nc" id="L189">        int pos = Arrays.binarySearch(symtab, (long)value &lt;&lt; 32);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (pos &lt; 0)  pos = -pos-1;</span>
<span class="nc bnc" id="L191" title="All 4 branches missed.">        if (pos &lt; symtab.length &amp;&amp; value == (int)(symtab[pos] &gt;&gt;&gt; 32))</span>
<span class="nc" id="L192">            return (int)symtab[pos];</span>
        else
<span class="nc" id="L194">            return 0;</span>
    }

    public int[][] encodeValues(int[] values, int start, int end) {
        // Compute token sequence.
<span class="nc" id="L199">        int[] tokens = new int[end-start];</span>
<span class="nc" id="L200">        int nuv = 0;</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        for (int i = 0; i &lt; tokens.length; i++) {</span>
<span class="nc" id="L202">            int val = values[start+i];</span>
<span class="nc" id="L203">            int tok = getToken(val);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (tok != 0)</span>
<span class="nc" id="L205">                tokens[i] = tok;</span>
            else
<span class="nc" id="L207">                nuv += 1;</span>
        }
        // Compute unfavored value sequence.
<span class="nc" id="L210">        int[] unfavoredValues = new int[nuv];</span>
<span class="nc" id="L211">        nuv = 0;  // reset</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        for (int i = 0; i &lt; tokens.length; i++) {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (tokens[i] != 0)  continue;  // already covered</span>
<span class="nc" id="L214">            int val = values[start+i];</span>
<span class="nc" id="L215">            unfavoredValues[nuv++] = val;</span>
        }
<span class="nc bnc" id="L217" title="All 4 branches missed.">        assert(nuv == unfavoredValues.length);</span>
<span class="nc" id="L218">        return new int[][]{ tokens, unfavoredValues };</span>
    }

    private long[] makeSymtab() {
<span class="nc" id="L222">        long[] lsymtab = new long[fVlen];</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        for (int token = 1; token &lt;= fVlen; token++) {</span>
<span class="nc" id="L224">            lsymtab[token-1] = ((long)fValues[token] &lt;&lt; 32) | token;</span>
        }
        // Index by value:
<span class="nc" id="L227">        Arrays.sort(lsymtab);</span>
<span class="nc" id="L228">        return lsymtab;</span>
    }

    private Coding getTailCoding(CodingMethod c) {
<span class="nc bnc" id="L232" title="All 2 branches missed.">        while (c instanceof AdaptiveCoding)</span>
<span class="nc" id="L233">            c = ((AdaptiveCoding)c).tailCoding;</span>
<span class="nc" id="L234">        return (Coding) c;</span>
    }

    // CodingMethod methods.
    public void writeArrayTo(OutputStream out, int[] a, int start, int end) throws IOException {
<span class="nc" id="L239">        int[][] vals = encodeValues(a, start, end);</span>
<span class="nc" id="L240">        writeSequencesTo(out, vals[0], vals[1]);</span>
<span class="nc" id="L241">    }</span>
    void writeSequencesTo(OutputStream out, int[] tokens, int[] uValues) throws IOException {
<span class="nc" id="L243">        favoredCoding.writeArrayTo(out, fValues, 1, 1+fVlen);</span>
<span class="nc" id="L244">        getTailCoding(favoredCoding).writeTo(out, computeSentinelValue());</span>
<span class="nc" id="L245">        tokenCoding.writeArrayTo(out, tokens, 0, tokens.length);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (uValues.length &gt; 0)</span>
<span class="nc" id="L247">            unfavoredCoding.writeArrayTo(out, uValues, 0, uValues.length);</span>
<span class="nc" id="L248">    }</span>

   int computeSentinelValue() {
<span class="nc" id="L251">        Coding fc = getTailCoding(favoredCoding);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (fc.isDelta()) {</span>
            // repeat the last favored value, using delta=0
<span class="nc" id="L254">            return 0;</span>
        } else {
            // else repeat the shorter of the min or last value
<span class="nc" id="L257">            int min = fValues[1];</span>
<span class="nc" id="L258">            int last = min;</span>
            // (remember that fVlen is an inclusive limit in fValues)
<span class="nc bnc" id="L260" title="All 2 branches missed.">            for (int i = 2; i &lt;= fVlen; i++) {</span>
<span class="nc" id="L261">                last = fValues[i];</span>
<span class="nc" id="L262">                min = moreCentral(min, last);</span>
            }
            int endVal;
<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (fc.getLength(min) &lt;= fc.getLength(last))</span>
<span class="nc" id="L266">                return min;</span>
            else
<span class="nc" id="L268">                return last;</span>
        }
   }

    public void readArrayFrom(InputStream in, int[] a, int start, int end) throws IOException {
        // Parameters are fCode, L, uCode.
<span class="nc" id="L274">        setFavoredValues(readFavoredValuesFrom(in, end-start));</span>
        // Read the tokens.  Read them into the final array, for the moment.
<span class="nc" id="L276">        tokenCoding.readArrayFrom(in, a, start, end);</span>
        // Decode the favored tokens.
<span class="nc" id="L278">        int headp = 0, tailp = -1;</span>
<span class="nc" id="L279">        int uVlen = 0;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        for (int i = start; i &lt; end; i++) {</span>
<span class="nc" id="L281">            int tok = a[i];</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">            if (tok == 0) {</span>
                // Make a linked list, and decode in a second pass.
<span class="nc bnc" id="L284" title="All 2 branches missed.">                if (tailp &lt; 0) {</span>
<span class="nc" id="L285">                    headp = i;</span>
                } else {
<span class="nc" id="L287">                    a[tailp] = i;</span>
                }
<span class="nc" id="L289">                tailp = i;</span>
<span class="nc" id="L290">                uVlen += 1;</span>
            } else {
<span class="nc" id="L292">                a[i] = fValues[tok];</span>
            }
        }
        // Walk the linked list of &quot;zero&quot; locations, decoding unfavored vals.
<span class="nc" id="L296">        int[] uValues = new int[uVlen];</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (uVlen &gt; 0)</span>
<span class="nc" id="L298">            unfavoredCoding.readArrayFrom(in, uValues, 0, uVlen);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        for (int i = 0; i &lt; uVlen; i++) {</span>
<span class="nc" id="L300">            int nextp = a[headp];</span>
<span class="nc" id="L301">            a[headp] = uValues[i];</span>
<span class="nc" id="L302">            headp = nextp;</span>
        }
<span class="nc" id="L304">    }</span>

    int[] readFavoredValuesFrom(InputStream in, int maxForDebug) throws IOException {
<span class="nc" id="L307">        int[] lfValues = new int[1000];  // realloc as needed</span>
        // The set uniqueValuesForDebug records all favored values.
        // As each new value is added, we assert that the value
        // was not already in the set.
<span class="nc" id="L311">        Set&lt;Integer&gt; uniqueValuesForDebug = null;</span>
<span class="nc bnc" id="L312" title="All 4 branches missed.">        assert((uniqueValuesForDebug = new HashSet&lt;&gt;()) != null);</span>
<span class="nc" id="L313">        int fillp = 1;</span>
<span class="nc" id="L314">        maxForDebug += fillp;</span>
<span class="nc" id="L315">        int min = Integer.MIN_VALUE;  // farthest from the center</span>
        //int min2 = Integer.MIN_VALUE;  // emulate buggy 150.7 spec.
<span class="nc" id="L317">        int last = 0;</span>
<span class="nc" id="L318">        CodingMethod fcm = favoredCoding;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        while (fcm instanceof AdaptiveCoding) {</span>
<span class="nc" id="L320">            AdaptiveCoding ac = (AdaptiveCoding) fcm;</span>
<span class="nc" id="L321">            int len = ac.headLength;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            while (fillp + len &gt; lfValues.length) {</span>
<span class="nc" id="L323">                lfValues = BandStructure.realloc(lfValues);</span>
            }
<span class="nc" id="L325">            int newFillp = fillp + len;</span>
<span class="nc" id="L326">            ac.headCoding.readArrayFrom(in, lfValues, fillp, newFillp);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">            while (fillp &lt; newFillp) {</span>
<span class="nc" id="L328">                int val = lfValues[fillp++];</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">                assert(uniqueValuesForDebug.add(val));</span>
<span class="nc bnc" id="L330" title="All 4 branches missed.">                assert(fillp &lt;= maxForDebug);</span>
<span class="nc" id="L331">                last = val;</span>
<span class="nc" id="L332">                min = moreCentral(min, val);</span>
                //min2 = moreCentral2(min2, val, min);
<span class="nc" id="L334">            }</span>
<span class="nc" id="L335">            fcm = ac.tailCoding;</span>
<span class="nc" id="L336">        }</span>
<span class="nc" id="L337">        Coding fc = (Coding) fcm;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (fc.isDelta()) {</span>
<span class="nc" id="L339">            for (long state = 0;;) {</span>
                // Read a new value:
<span class="nc" id="L341">                state += fc.readFrom(in);</span>
                int val;
<span class="nc bnc" id="L343" title="All 2 branches missed.">                if (fc.isSubrange())</span>
<span class="nc" id="L344">                    val = fc.reduceToUnsignedRange(state);</span>
                else
<span class="nc" id="L346">                    val = (int)state;</span>
<span class="nc" id="L347">                state = val;</span>
<span class="nc bnc" id="L348" title="All 6 branches missed.">                if (fillp &gt; 1 &amp;&amp; (val == last || val == min)) //|| val == min2</span>
<span class="nc" id="L349">                    break;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                if (fillp == lfValues.length)</span>
<span class="nc" id="L351">                    lfValues = BandStructure.realloc(lfValues);</span>
<span class="nc" id="L352">                lfValues[fillp++] = val;</span>
<span class="nc bnc" id="L353" title="All 4 branches missed.">                assert(uniqueValuesForDebug.add(val));</span>
<span class="nc bnc" id="L354" title="All 4 branches missed.">                assert(fillp &lt;= maxForDebug);</span>
<span class="nc" id="L355">                last = val;</span>
<span class="nc" id="L356">                min = moreCentral(min, val);</span>
                //min2 = moreCentral(min2, val);
<span class="nc" id="L358">            }</span>
        } else {
            for (;;) {
<span class="nc" id="L361">                int val = fc.readFrom(in);</span>
<span class="nc bnc" id="L362" title="All 6 branches missed.">                if (fillp &gt; 1 &amp;&amp; (val == last || val == min)) //|| val == min2</span>
<span class="nc" id="L363">                    break;</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                if (fillp == lfValues.length)</span>
<span class="nc" id="L365">                    lfValues = BandStructure.realloc(lfValues);</span>
<span class="nc" id="L366">                lfValues[fillp++] = val;</span>
<span class="nc bnc" id="L367" title="All 4 branches missed.">                assert(uniqueValuesForDebug.add(val));</span>
<span class="nc bnc" id="L368" title="All 4 branches missed.">                assert(fillp &lt;= maxForDebug);</span>
<span class="nc" id="L369">                last = val;</span>
<span class="nc" id="L370">                min = moreCentral(min, val);</span>
                //min2 = moreCentral2(min2, val, min);
<span class="nc" id="L372">            }</span>
        }
<span class="nc" id="L374">        return BandStructure.realloc(lfValues, fillp);</span>
    }

    private static int moreCentral(int x, int y) {
<span class="nc" id="L378">        int kx = (x &gt;&gt; 31) ^ (x &lt;&lt; 1);</span>
<span class="nc" id="L379">        int ky = (y &gt;&gt; 31) ^ (y &lt;&lt; 1);</span>
        // bias kx/ky to get an unsigned comparison:
<span class="nc" id="L381">        kx -= Integer.MIN_VALUE;</span>
<span class="nc" id="L382">        ky -= Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        int xy = (kx &lt; ky? x: y);</span>
        // assert that this ALU-ish version is the same:
<span class="nc bnc" id="L385" title="All 4 branches missed.">        assert(xy == moreCentralSlow(x, y));</span>
<span class="nc" id="L386">        return xy;</span>
    }
//  private static int moreCentral2(int x, int y, int min) {
//      // Strict implementation of buggy 150.7 specification.
//      // The bug is that the spec. says absolute-value ties are broken
//      // in favor of positive numbers, but the suggested implementation
//      // (also mentioned in the spec.) breaks ties in favor of negatives.
//      if (x + y == 0)  return (x &gt; y? x : y);
//      return min;
//  }
    private static int moreCentralSlow(int x, int y) {
<span class="nc" id="L397">        int ax = x;</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (ax &lt; 0)  ax = -ax;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (ax &lt; 0)  return y;  //x is MIN_VALUE</span>
<span class="nc" id="L400">        int ay = y;</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (ay &lt; 0)  ay = -ay;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">        if (ay &lt; 0)  return x;  //y is MIN_VALUE</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (ax &lt; ay)  return x;</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (ax &gt; ay)  return y;</span>
        // At this point the absolute values agree, and the negative wins.
<span class="nc bnc" id="L406" title="All 2 branches missed.">        return x &lt; y ? x : y;</span>
    }

<span class="nc" id="L409">    static final int[] LValuesCoded</span>
        = { -1, 4, 8, 16, 32, 64, 128, 192, 224, 240, 248, 252 };

    public byte[] getMetaCoding(Coding dflt) {
<span class="nc" id="L413">        int K = fVlen;</span>
<span class="nc" id="L414">        int LCoded = 0;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (tokenCoding instanceof Coding) {</span>
<span class="nc" id="L416">            Coding tc = (Coding) tokenCoding;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (tc.B() == 1) {</span>
<span class="nc" id="L418">                LCoded = 1;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            } else if (L &gt;= 0) {</span>
<span class="nc bnc" id="L420" title="All 4 branches missed.">                assert(L == tc.L());</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                for (int i = 1; i &lt; LValuesCoded.length; i++) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                    if (LValuesCoded[i] == L) { LCoded = i; break; }</span>
                }
            }
        }
<span class="nc" id="L426">        CodingMethod tokenDflt = null;</span>
<span class="nc bnc" id="L427" title="All 4 branches missed.">        if (LCoded != 0 &amp;&amp; tokenCoding == fitTokenCoding(fVlen, L)) {</span>
            // A simple L value is enough to recover the tokenCoding.
<span class="nc" id="L429">            tokenDflt = tokenCoding;</span>
        }
<span class="nc bnc" id="L431" title="All 2 branches missed.">        int FDef = (favoredCoding == dflt)?1:0;</span>
<span class="nc bnc" id="L432" title="All 4 branches missed.">        int UDef = (unfavoredCoding == dflt || unfavoredCoding == null)?1:0;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        int TDef = (tokenCoding == tokenDflt)?1:0;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        int TDefL = (TDef == 1) ? LCoded : 0;</span>
<span class="nc bnc" id="L435" title="All 6 branches missed.">        assert(TDef == ((TDefL&gt;0)?1:0));</span>
<span class="nc" id="L436">        ByteArrayOutputStream bytes = new ByteArrayOutputStream(10);</span>
<span class="nc" id="L437">        bytes.write(_meta_pop + FDef + 2*UDef + 4*TDefL);</span>
        try {
<span class="nc bnc" id="L439" title="All 2 branches missed.">            if (FDef == 0)  bytes.write(favoredCoding.getMetaCoding(dflt));</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">            if (TDef == 0)  bytes.write(tokenCoding.getMetaCoding(dflt));</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">            if (UDef == 0)  bytes.write(unfavoredCoding.getMetaCoding(dflt));</span>
<span class="nc" id="L442">        } catch (IOException ee) {</span>
<span class="nc" id="L443">            throw new RuntimeException(ee);</span>
<span class="nc" id="L444">        }</span>
<span class="nc" id="L445">        return bytes.toByteArray();</span>
    }
    public static int parseMetaCoding(byte[] bytes, int pos, Coding dflt, CodingMethod res[]) {
<span class="nc" id="L448">        int op = bytes[pos++] &amp; 0xFF;</span>
<span class="nc bnc" id="L449" title="All 4 branches missed.">        if (op &lt; _meta_pop || op &gt;= _meta_limit)  return pos-1; // backup</span>
<span class="nc" id="L450">        op -= _meta_pop;</span>
<span class="nc" id="L451">        int FDef = op % 2;</span>
<span class="nc" id="L452">        int UDef = (op / 2) % 2;</span>
<span class="nc" id="L453">        int TDefL = (op / 4);</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">        int TDef = (TDefL &gt; 0)?1:0;</span>
<span class="nc" id="L455">        int L = LValuesCoded[TDefL];</span>
<span class="nc" id="L456">        CodingMethod[] FCode = {dflt}, TCode = {null}, UCode = {dflt};</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">        if (FDef == 0)</span>
<span class="nc" id="L458">            pos = BandStructure.parseMetaCoding(bytes, pos, dflt, FCode);</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (TDef == 0)</span>
<span class="nc" id="L460">            pos = BandStructure.parseMetaCoding(bytes, pos, dflt, TCode);</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (UDef == 0)</span>
<span class="nc" id="L462">            pos = BandStructure.parseMetaCoding(bytes, pos, dflt, UCode);</span>
<span class="nc" id="L463">        PopulationCoding pop = new PopulationCoding();</span>
<span class="nc" id="L464">        pop.L = L;  // might be -1</span>
<span class="nc" id="L465">        pop.favoredCoding   = FCode[0];</span>
<span class="nc" id="L466">        pop.tokenCoding     = TCode[0];  // might be null!</span>
<span class="nc" id="L467">        pop.unfavoredCoding = UCode[0];</span>
<span class="nc" id="L468">        res[0] = pop;</span>
<span class="nc" id="L469">        return pos;</span>
    }

    private String keyString(CodingMethod m) {
<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (m instanceof Coding)</span>
<span class="nc" id="L474">            return ((Coding)m).keyString();</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (m == null)</span>
<span class="nc" id="L476">            return &quot;none&quot;;</span>
<span class="nc" id="L477">        return m.toString();</span>
    }
    public String toString() {
<span class="nc" id="L480">        PropMap p200 = Utils.currentPropMap();</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">        boolean verbose</span>
            = (p200 != null &amp;&amp;
<span class="nc bnc" id="L483" title="All 2 branches missed.">               p200.getBoolean(Utils.COM_PREFIX+&quot;verbose.pop&quot;));</span>
<span class="nc" id="L484">        StringBuilder res = new StringBuilder(100);</span>
<span class="nc" id="L485">        res.append(&quot;pop(&quot;).append(&quot;fVlen=&quot;).append(fVlen);</span>
<span class="nc bnc" id="L486" title="All 4 branches missed.">        if (verbose &amp;&amp; fValues != null) {</span>
<span class="nc" id="L487">            res.append(&quot; fV=[&quot;);</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">            for (int i = 1; i &lt;= fVlen; i++) {</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">                res.append(i==1?&quot;&quot;:&quot;,&quot;).append(fValues[i]);</span>
            }
<span class="nc" id="L491">            res.append(&quot;;&quot;).append(computeSentinelValue());</span>
<span class="nc" id="L492">            res.append(&quot;]&quot;);</span>
        }
<span class="nc" id="L494">        res.append(&quot; fc=&quot;).append(keyString(favoredCoding));</span>
<span class="nc" id="L495">        res.append(&quot; tc=&quot;).append(keyString(tokenCoding));</span>
<span class="nc" id="L496">        res.append(&quot; uc=&quot;).append(keyString(unfavoredCoding));</span>
<span class="nc" id="L497">        res.append(&quot;)&quot;);</span>
<span class="nc" id="L498">        return res.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>