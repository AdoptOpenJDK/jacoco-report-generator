<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClassReader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">ClassReader.java</span></div><h1>ClassReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import com.sun.java.util.jar.pack.ConstantPool.ClassEntry;
import com.sun.java.util.jar.pack.ConstantPool.DescriptorEntry;
import com.sun.java.util.jar.pack.ConstantPool.Entry;
import com.sun.java.util.jar.pack.ConstantPool.SignatureEntry;
import com.sun.java.util.jar.pack.ConstantPool.MemberEntry;
import com.sun.java.util.jar.pack.ConstantPool.MethodHandleEntry;
import com.sun.java.util.jar.pack.ConstantPool.BootstrapMethodEntry;
import com.sun.java.util.jar.pack.ConstantPool.Utf8Entry;
import com.sun.java.util.jar.pack.Package.Class;
import com.sun.java.util.jar.pack.Package.InnerClass;
import java.io.DataInputStream;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;
import static com.sun.java.util.jar.pack.Constants.*;

/**
 * Reader for a class file that is being incorporated into a package.
 * @author John Rose
 */
<span class="nc bnc" id="L51" title="All 2 branches missed.">class ClassReader {</span>
    int verbose;

    Package pkg;
    Class cls;
    long inPos;
<span class="nc" id="L57">    long constantPoolLimit = -1;</span>
    DataInputStream in;
    Map&lt;Attribute.Layout, Attribute&gt; attrDefs;
    Map&lt;Attribute.Layout, String&gt; attrCommands;
<span class="nc" id="L61">    String unknownAttrCommand = &quot;error&quot;;;</span>

<span class="nc" id="L63">    ClassReader(Class cls, InputStream in) throws IOException {</span>
<span class="nc" id="L64">        this.pkg = cls.getPackage();</span>
<span class="nc" id="L65">        this.cls = cls;</span>
<span class="nc" id="L66">        this.verbose = pkg.verbose;</span>
<span class="nc" id="L67">        this.in = new DataInputStream(new FilterInputStream(in) {</span>
            public int read(byte b[], int off, int len) throws IOException {
<span class="nc" id="L69">                int nr = super.read(b, off, len);</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">                if (nr &gt;= 0)  inPos += nr;</span>
<span class="nc" id="L71">                return nr;</span>
            }
            public int read() throws IOException {
<span class="nc" id="L74">                int ch = super.read();</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">                if (ch &gt;= 0)  inPos += 1;</span>
<span class="nc" id="L76">                return ch;</span>
            }
            public long skip(long n) throws IOException {
<span class="nc" id="L79">                long ns = super.skip(n);</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">                if (ns &gt;= 0)  inPos += ns;</span>
<span class="nc" id="L81">                return ns;</span>
            }
        });
<span class="nc" id="L84">    }</span>

    public void setAttrDefs(Map&lt;Attribute.Layout, Attribute&gt; attrDefs) {
<span class="nc" id="L87">        this.attrDefs = attrDefs;</span>
<span class="nc" id="L88">    }</span>

    public void setAttrCommands(Map&lt;Attribute.Layout, String&gt; attrCommands) {
<span class="nc" id="L91">        this.attrCommands = attrCommands;</span>
<span class="nc" id="L92">    }</span>

    private void skip(int n, String what) throws IOException {
<span class="nc" id="L95">        Utils.log.warning(&quot;skipping &quot;+n+&quot; bytes of &quot;+what);</span>
<span class="nc" id="L96">        long skipped = 0;</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">        while (skipped &lt; n) {</span>
<span class="nc" id="L98">            long j = in.skip(n - skipped);</span>
<span class="nc bnc" id="L99" title="All 4 branches missed.">            assert(j &gt; 0);</span>
<span class="nc" id="L100">            skipped += j;</span>
<span class="nc" id="L101">        }</span>
<span class="nc bnc" id="L102" title="All 4 branches missed.">        assert(skipped == n);</span>
<span class="nc" id="L103">    }</span>

    private int readUnsignedShort() throws IOException {
<span class="nc" id="L106">        return in.readUnsignedShort();</span>
    }

    private int readInt() throws IOException {
<span class="nc" id="L110">        return in.readInt();</span>
    }

    /** Read a 2-byte int, and return the &lt;em&gt;global&lt;/em&gt; CP entry for it. */
    private Entry readRef() throws IOException {
<span class="nc" id="L115">        int i = in.readUnsignedShort();</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        return i == 0 ? null : cls.cpMap[i];</span>
    }

    private Entry readRef(byte tag) throws IOException {
<span class="nc" id="L120">        Entry e = readRef();</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">        assert(!(e instanceof UnresolvedEntry));</span>
<span class="nc" id="L122">        checkTag(e, tag);</span>
<span class="nc" id="L123">        return e;</span>
    }

    /** Throw a ClassFormatException if the entry does not match the expected tag type. */
    private Entry checkTag(Entry e, byte tag) throws ClassFormatException {
<span class="nc bnc" id="L128" title="All 4 branches missed.">        if (e == null || !e.tagMatches(tag)) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            String where = (inPos == constantPoolLimit</span>
                                ? &quot; in constant pool&quot;
                                : &quot; at pos: &quot; + inPos);
<span class="nc bnc" id="L132" title="All 2 branches missed.">            String got = (e == null</span>
                            ? &quot;null CP index&quot;
<span class="nc" id="L134">                            : &quot;type=&quot; + ConstantPool.tagName(e.tag));</span>
<span class="nc" id="L135">            throw new ClassFormatException(&quot;Bad constant, expected type=&quot; +</span>
<span class="nc" id="L136">                    ConstantPool.tagName(tag) +</span>
                    &quot; got &quot;+ got + &quot;, in File: &quot; + cls.file.nameString + where);
        }
<span class="nc" id="L139">        return e;</span>
    }
    private Entry checkTag(Entry e, byte tag, boolean nullOK) throws ClassFormatException {
<span class="nc bnc" id="L142" title="All 4 branches missed.">        return nullOK &amp;&amp; e == null ? null : checkTag(e, tag);</span>
    }

    private Entry readRefOrNull(byte tag) throws IOException {
<span class="nc" id="L146">        Entry e = readRef();</span>
<span class="nc" id="L147">        checkTag(e, tag, true);</span>
<span class="nc" id="L148">        return e;</span>
    }

    private Utf8Entry readUtf8Ref() throws IOException {
<span class="nc" id="L152">        return (Utf8Entry) readRef(CONSTANT_Utf8);</span>
    }

    private ClassEntry readClassRef() throws IOException {
<span class="nc" id="L156">        return (ClassEntry) readRef(CONSTANT_Class);</span>
    }

    private ClassEntry readClassRefOrNull() throws IOException {
<span class="nc" id="L160">        return (ClassEntry) readRefOrNull(CONSTANT_Class);</span>
    }

    private SignatureEntry readSignatureRef() throws IOException {
        // The class file stores a Utf8, but we want a Signature.
<span class="nc" id="L165">        Entry e = readRef(CONSTANT_Signature);</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">        return (e != null &amp;&amp; e.getTag() == CONSTANT_Utf8)</span>
<span class="nc" id="L167">                ? ConstantPool.getSignatureEntry(e.stringValue())</span>
                : (SignatureEntry) e;
    }

    void read() throws IOException {
<span class="nc" id="L172">        boolean ok = false;</span>
        try {
<span class="nc" id="L174">            readMagicNumbers();</span>
<span class="nc" id="L175">            readConstantPool();</span>
<span class="nc" id="L176">            readHeader();</span>
<span class="nc" id="L177">            readMembers(false);  // fields</span>
<span class="nc" id="L178">            readMembers(true);   // methods</span>
<span class="nc" id="L179">            readAttributes(ATTR_CONTEXT_CLASS, cls);</span>
<span class="nc" id="L180">            fixUnresolvedEntries();</span>
<span class="nc" id="L181">            cls.finishReading();</span>
<span class="nc bnc" id="L182" title="All 4 branches missed.">            assert(0 &gt;= in.read(new byte[1]));</span>
<span class="nc" id="L183">            ok = true;</span>
        } finally {
<span class="nc bnc" id="L185" title="All 4 branches missed.">            if (!ok) {</span>
<span class="nc bnc" id="L186" title="All 4 branches missed.">                if (verbose &gt; 0) Utils.log.warning(&quot;Erroneous data at input offset &quot;+inPos+&quot; of &quot;+cls.file);</span>
            }
        }
<span class="nc" id="L189">    }</span>

    void readMagicNumbers() throws IOException {
<span class="nc" id="L192">        cls.magic = in.readInt();</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (cls.magic != JAVA_MAGIC)</span>
<span class="nc" id="L194">            throw new Attribute.FormatException</span>
                (&quot;Bad magic number in class file &quot;
<span class="nc" id="L196">                 +Integer.toHexString(cls.magic),</span>
                 ATTR_CONTEXT_CLASS, &quot;magic-number&quot;, &quot;pass&quot;);
<span class="nc" id="L198">        int minver = (short) readUnsignedShort();</span>
<span class="nc" id="L199">        int majver = (short) readUnsignedShort();</span>
<span class="nc" id="L200">        cls.version = Package.Version.of(majver, minver);</span>

        //System.out.println(&quot;ClassFile.version=&quot;+cls.majver+&quot;.&quot;+cls.minver);
<span class="nc" id="L203">        String bad = checkVersion(cls.version);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (bad != null) {</span>
<span class="nc" id="L205">            throw new Attribute.FormatException</span>
                (&quot;classfile version too &quot;+bad+&quot;: &quot;
                 +cls.version+&quot; in &quot;+cls.file,
                 ATTR_CONTEXT_CLASS, &quot;version&quot;, &quot;pass&quot;);
        }
<span class="nc" id="L210">    }</span>

    private String checkVersion(Package.Version ver) {
<span class="nc" id="L213">        int majver = ver.major;</span>
<span class="nc" id="L214">        int minver = ver.minor;</span>
<span class="nc bnc" id="L215" title="All 6 branches missed.">        if (majver &lt; pkg.minClassVersion.major ||</span>
            (majver == pkg.minClassVersion.major &amp;&amp;
             minver &lt; pkg.minClassVersion.minor)) {
<span class="nc" id="L218">            return &quot;small&quot;;</span>
        }
<span class="nc bnc" id="L220" title="All 6 branches missed.">        if (majver &gt; pkg.maxClassVersion.major ||</span>
            (majver == pkg.maxClassVersion.major &amp;&amp;
             minver &gt; pkg.maxClassVersion.minor)) {
<span class="nc" id="L223">            return &quot;large&quot;;</span>
        }
<span class="nc" id="L225">        return null;  // OK</span>
    }

    void readConstantPool() throws IOException {
<span class="nc" id="L229">        int length = in.readUnsignedShort();</span>
        //System.err.println(&quot;reading CP, length=&quot;+length);

<span class="nc" id="L232">        int[] fixups = new int[length*4];</span>
<span class="nc" id="L233">        int fptr = 0;</span>

<span class="nc" id="L235">        Entry[] cpMap = new Entry[length];</span>
<span class="nc" id="L236">        cpMap[0] = null;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        for (int i = 1; i &lt; length; i++) {</span>
            //System.err.println(&quot;reading CP elt, i=&quot;+i);
<span class="nc" id="L239">            int tag = in.readByte();</span>
<span class="nc bnc" id="L240" title="All 10 branches missed.">            switch (tag) {</span>
                case CONSTANT_Utf8:
<span class="nc" id="L242">                    cpMap[i] = ConstantPool.getUtf8Entry(in.readUTF());</span>
<span class="nc" id="L243">                    break;</span>
                case CONSTANT_Integer:
                    {
<span class="nc" id="L246">                        cpMap[i] = ConstantPool.getLiteralEntry(in.readInt());</span>
                    }
<span class="nc" id="L248">                    break;</span>
                case CONSTANT_Float:
                    {
<span class="nc" id="L251">                        cpMap[i] = ConstantPool.getLiteralEntry(in.readFloat());</span>
                    }
<span class="nc" id="L253">                    break;</span>
                case CONSTANT_Long:
                    {
<span class="nc" id="L256">                        cpMap[i] = ConstantPool.getLiteralEntry(in.readLong());</span>
<span class="nc" id="L257">                        cpMap[++i] = null;</span>
                    }
<span class="nc" id="L259">                    break;</span>
                case CONSTANT_Double:
                    {
<span class="nc" id="L262">                        cpMap[i] = ConstantPool.getLiteralEntry(in.readDouble());</span>
<span class="nc" id="L263">                        cpMap[++i] = null;</span>
                    }
<span class="nc" id="L265">                    break;</span>

                // just read the refs; do not attempt to resolve while reading
                case CONSTANT_Class:
                case CONSTANT_String:
                case CONSTANT_MethodType:
<span class="nc" id="L271">                    fixups[fptr++] = i;</span>
<span class="nc" id="L272">                    fixups[fptr++] = tag;</span>
<span class="nc" id="L273">                    fixups[fptr++] = in.readUnsignedShort();</span>
<span class="nc" id="L274">                    fixups[fptr++] = -1;  // empty ref2</span>
<span class="nc" id="L275">                    break;</span>
                case CONSTANT_Fieldref:
                case CONSTANT_Methodref:
                case CONSTANT_InterfaceMethodref:
                case CONSTANT_NameandType:
<span class="nc" id="L280">                    fixups[fptr++] = i;</span>
<span class="nc" id="L281">                    fixups[fptr++] = tag;</span>
<span class="nc" id="L282">                    fixups[fptr++] = in.readUnsignedShort();</span>
<span class="nc" id="L283">                    fixups[fptr++] = in.readUnsignedShort();</span>
<span class="nc" id="L284">                    break;</span>
                case CONSTANT_InvokeDynamic:
<span class="nc" id="L286">                    fixups[fptr++] = i;</span>
<span class="nc" id="L287">                    fixups[fptr++] = tag;</span>
<span class="nc" id="L288">                    fixups[fptr++] = -1 ^ in.readUnsignedShort();  // not a ref</span>
<span class="nc" id="L289">                    fixups[fptr++] = in.readUnsignedShort();</span>
<span class="nc" id="L290">                    break;</span>
                case CONSTANT_MethodHandle:
<span class="nc" id="L292">                    fixups[fptr++] = i;</span>
<span class="nc" id="L293">                    fixups[fptr++] = tag;</span>
<span class="nc" id="L294">                    fixups[fptr++] = -1 ^ in.readUnsignedByte();</span>
<span class="nc" id="L295">                    fixups[fptr++] = in.readUnsignedShort();</span>
<span class="nc" id="L296">                    break;</span>
                default:
<span class="nc" id="L298">                    throw new ClassFormatException(&quot;Bad constant pool tag &quot; +</span>
                            tag + &quot; in File: &quot; + cls.file.nameString +
                            &quot; at pos: &quot; + inPos);
            }
        }
<span class="nc" id="L303">        constantPoolLimit = inPos;</span>

        // Fix up refs, which might be out of order.
<span class="nc bnc" id="L306" title="All 2 branches missed.">        while (fptr &gt; 0) {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">            if (verbose &gt; 3)</span>
<span class="nc" id="L308">                Utils.log.fine(&quot;CP fixups [&quot;+fptr/4+&quot;]&quot;);</span>
<span class="nc" id="L309">            int flimit = fptr;</span>
<span class="nc" id="L310">            fptr = 0;</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">            for (int fi = 0; fi &lt; flimit; ) {</span>
<span class="nc" id="L312">                int cpi = fixups[fi++];</span>
<span class="nc" id="L313">                int tag = fixups[fi++];</span>
<span class="nc" id="L314">                int ref = fixups[fi++];</span>
<span class="nc" id="L315">                int ref2 = fixups[fi++];</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                if (verbose &gt; 3)</span>
<span class="nc" id="L317">                    Utils.log.fine(&quot;  cp[&quot;+cpi+&quot;] = &quot;+ConstantPool.tagName(tag)+&quot;{&quot;+ref+&quot;,&quot;+ref2+&quot;}&quot;);</span>
<span class="nc bnc" id="L318" title="All 8 branches missed.">                if (ref &gt;= 0 &amp;&amp; cpMap[ref] == null || ref2 &gt;= 0 &amp;&amp; cpMap[ref2] == null) {</span>
                    // Defer.
<span class="nc" id="L320">                    fixups[fptr++] = cpi;</span>
<span class="nc" id="L321">                    fixups[fptr++] = tag;</span>
<span class="nc" id="L322">                    fixups[fptr++] = ref;</span>
<span class="nc" id="L323">                    fixups[fptr++] = ref2;</span>
<span class="nc" id="L324">                    continue;</span>
                }
<span class="nc bnc" id="L326" title="All 8 branches missed.">                switch (tag) {</span>
                case CONSTANT_Class:
<span class="nc" id="L328">                    cpMap[cpi] = ConstantPool.getClassEntry(cpMap[ref].stringValue());</span>
<span class="nc" id="L329">                    break;</span>
                case CONSTANT_String:
<span class="nc" id="L331">                    cpMap[cpi] = ConstantPool.getStringEntry(cpMap[ref].stringValue());</span>
<span class="nc" id="L332">                    break;</span>
                case CONSTANT_Fieldref:
                case CONSTANT_Methodref:
                case CONSTANT_InterfaceMethodref:
<span class="nc" id="L336">                    ClassEntry      mclass = (ClassEntry)      checkTag(cpMap[ref],  CONSTANT_Class);</span>
<span class="nc" id="L337">                    DescriptorEntry mdescr = (DescriptorEntry) checkTag(cpMap[ref2], CONSTANT_NameandType);</span>
<span class="nc" id="L338">                    cpMap[cpi] = ConstantPool.getMemberEntry((byte)tag, mclass, mdescr);</span>
<span class="nc" id="L339">                    break;</span>
                case CONSTANT_NameandType:
<span class="nc" id="L341">                    Utf8Entry mname = (Utf8Entry) checkTag(cpMap[ref],  CONSTANT_Utf8);</span>
<span class="nc" id="L342">                    Utf8Entry mtype = (Utf8Entry) checkTag(cpMap[ref2], CONSTANT_Signature);</span>
<span class="nc" id="L343">                    cpMap[cpi] = ConstantPool.getDescriptorEntry(mname, mtype);</span>
<span class="nc" id="L344">                    break;</span>
                case CONSTANT_MethodType:
<span class="nc" id="L346">                    cpMap[cpi] = ConstantPool.getMethodTypeEntry((Utf8Entry) checkTag(cpMap[ref], CONSTANT_Signature));</span>
<span class="nc" id="L347">                    break;</span>
                case CONSTANT_MethodHandle:
<span class="nc" id="L349">                    byte refKind = (byte)(-1 ^ ref);</span>
<span class="nc" id="L350">                    MemberEntry memRef = (MemberEntry) checkTag(cpMap[ref2], CONSTANT_AnyMember);</span>
<span class="nc" id="L351">                    cpMap[cpi] = ConstantPool.getMethodHandleEntry(refKind, memRef);</span>
<span class="nc" id="L352">                    break;</span>
                case CONSTANT_InvokeDynamic:
<span class="nc" id="L354">                    DescriptorEntry idescr = (DescriptorEntry) checkTag(cpMap[ref2], CONSTANT_NameandType);</span>
<span class="nc" id="L355">                    cpMap[cpi] = new UnresolvedEntry((byte)tag, (-1 ^ ref), idescr);</span>
                    // Note that ref must be resolved later, using the BootstrapMethods attribute.
<span class="nc" id="L357">                    break;</span>
                default:
<span class="nc bnc" id="L359" title="All 2 branches missed.">                    assert(false);</span>
                }
<span class="nc" id="L361">            }</span>
<span class="nc bnc" id="L362" title="All 4 branches missed.">            assert(fptr &lt; flimit);  // Must make progress.</span>
<span class="nc" id="L363">        }</span>

<span class="nc" id="L365">        cls.cpMap = cpMap;</span>
<span class="nc" id="L366">    }</span>

    private /*non-static*/
    class UnresolvedEntry extends Entry {
        final Object[] refsOrIndexes;
<span class="nc" id="L371">        UnresolvedEntry(byte tag, Object... refsOrIndexes) {</span>
<span class="nc" id="L372">            super(tag);</span>
<span class="nc" id="L373">            this.refsOrIndexes = refsOrIndexes;</span>
<span class="nc" id="L374">            ClassReader.this.haveUnresolvedEntry = true;</span>
<span class="nc" id="L375">        }</span>
        Entry resolve() {
<span class="nc" id="L377">            Class cls = ClassReader.this.cls;</span>
            Entry res;
<span class="nc bnc" id="L379" title="All 2 branches missed.">            switch (tag) {</span>
            case CONSTANT_InvokeDynamic:
<span class="nc" id="L381">                BootstrapMethodEntry iboots = cls.bootstrapMethods.get((Integer) refsOrIndexes[0]);</span>
<span class="nc" id="L382">                DescriptorEntry         idescr = (DescriptorEntry) refsOrIndexes[1];</span>
<span class="nc" id="L383">                res = ConstantPool.getInvokeDynamicEntry(iboots, idescr);</span>
<span class="nc" id="L384">                break;</span>
            default:
<span class="nc" id="L386">                throw new AssertionError();</span>
            }
<span class="nc" id="L388">            return res;</span>
        }
<span class="nc" id="L390">        private void unresolved() { throw new RuntimeException(&quot;unresolved entry has no string&quot;); }</span>
<span class="nc" id="L391">        public int compareTo(Object x) { unresolved(); return 0; }</span>
<span class="nc" id="L392">        public boolean equals(Object x) { unresolved(); return false; }</span>
<span class="nc" id="L393">        protected int computeValueHash() { unresolved(); return 0; }</span>
<span class="nc" id="L394">        public String stringValue() { unresolved(); return toString(); }</span>
<span class="nc" id="L395">        public String toString() { return &quot;(unresolved &quot;+ConstantPool.tagName(tag)+&quot;)&quot;; }</span>
    }

    boolean haveUnresolvedEntry;
    private void fixUnresolvedEntries() {
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (!haveUnresolvedEntry)  return;</span>
<span class="nc" id="L401">        Entry[] cpMap = cls.getCPMap();</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">        for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L403">            Entry e = cpMap[i];</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">            if (e instanceof UnresolvedEntry) {</span>
<span class="nc" id="L405">                cpMap[i] = e = ((UnresolvedEntry)e).resolve();</span>
<span class="nc bnc" id="L406" title="All 4 branches missed.">                assert(!(e instanceof UnresolvedEntry));</span>
            }
        }
<span class="nc" id="L409">        haveUnresolvedEntry = false;</span>
<span class="nc" id="L410">    }</span>

    void readHeader() throws IOException {
<span class="nc" id="L413">        cls.flags = readUnsignedShort();</span>
<span class="nc" id="L414">        cls.thisClass = readClassRef();</span>
<span class="nc" id="L415">        cls.superClass = readClassRefOrNull();</span>
<span class="nc" id="L416">        int ni = readUnsignedShort();</span>
<span class="nc" id="L417">        cls.interfaces = new ClassEntry[ni];</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        for (int i = 0; i &lt; ni; i++) {</span>
<span class="nc" id="L419">            cls.interfaces[i] = readClassRef();</span>
        }
<span class="nc" id="L421">    }</span>

    void readMembers(boolean doMethods) throws IOException {
<span class="nc" id="L424">        int nm = readUnsignedShort();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        for (int i = 0; i &lt; nm; i++) {</span>
<span class="nc" id="L426">            readMember(doMethods);</span>
        }
<span class="nc" id="L428">    }</span>

    void readMember(boolean doMethod) throws IOException {
<span class="nc" id="L431">        int    mflags = readUnsignedShort();</span>
<span class="nc" id="L432">        Utf8Entry       mname = readUtf8Ref();</span>
<span class="nc" id="L433">        SignatureEntry  mtype = readSignatureRef();</span>
<span class="nc" id="L434">        DescriptorEntry descr = ConstantPool.getDescriptorEntry(mname, mtype);</span>
        Class.Member m;
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (!doMethod)</span>
<span class="nc" id="L437">            m = cls.new Field(mflags, descr);</span>
        else
<span class="nc" id="L439">            m = cls.new Method(mflags, descr);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        readAttributes(!doMethod ? ATTR_CONTEXT_FIELD : ATTR_CONTEXT_METHOD,</span>
                       m);
<span class="nc" id="L442">    }</span>
    void readAttributes(int ctype, Attribute.Holder h) throws IOException {
<span class="nc" id="L444">        int na = readUnsignedShort();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">        if (na == 0)  return;  // nothing to do here</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (verbose &gt; 3)</span>
<span class="nc" id="L447">            Utils.log.fine(&quot;readAttributes &quot;+h+&quot; [&quot;+na+&quot;]&quot;);</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">        for (int i = 0; i &lt; na; i++) {</span>
<span class="nc" id="L449">            String name = readUtf8Ref().stringValue();</span>
<span class="nc" id="L450">            int length = readInt();</span>
            // See if there is a special command that applies.
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (attrCommands != null) {</span>
<span class="nc" id="L453">                Attribute.Layout lkey = Attribute.keyForLookup(ctype, name);</span>
<span class="nc" id="L454">                String cmd = attrCommands.get(lkey);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">                if (cmd != null) {</span>
<span class="nc bnc" id="L456" title="All 14 branches missed.">                    switch (cmd) {</span>
                        case &quot;pass&quot;:
<span class="nc" id="L458">                            String message1 = &quot;passing attribute bitwise in &quot; + h;</span>
<span class="nc" id="L459">                            throw new Attribute.FormatException(message1, ctype, name, cmd);</span>
                        case &quot;error&quot;:
<span class="nc" id="L461">                            String message2 = &quot;attribute not allowed in &quot; + h;</span>
<span class="nc" id="L462">                            throw new Attribute.FormatException(message2, ctype, name, cmd);</span>
                        case &quot;strip&quot;:
<span class="nc" id="L464">                            skip(length, name + &quot; attribute in &quot; + h);</span>
<span class="nc" id="L465">                            continue;</span>
                    }
                }
            }
            // Find canonical instance of the requested attribute.
<span class="nc" id="L470">            Attribute a = Attribute.lookup(Package.attrDefs, ctype, name);</span>
<span class="nc bnc" id="L471" title="All 4 branches missed.">            if (verbose &gt; 4 &amp;&amp; a != null)</span>
<span class="nc" id="L472">                Utils.log.fine(&quot;pkg_attribute_lookup &quot;+name+&quot; = &quot;+a);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc" id="L474">                a = Attribute.lookup(this.attrDefs, ctype, name);</span>
<span class="nc bnc" id="L475" title="All 4 branches missed.">                if (verbose &gt; 4 &amp;&amp; a != null)</span>
<span class="nc" id="L476">                    Utils.log.fine(&quot;this &quot;+name+&quot; = &quot;+a);</span>
            }
<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc" id="L479">                a = Attribute.lookup(null, ctype, name);</span>
<span class="nc bnc" id="L480" title="All 4 branches missed.">                if (verbose &gt; 4 &amp;&amp; a != null)</span>
<span class="nc" id="L481">                    Utils.log.fine(&quot;null_attribute_lookup &quot;+name+&quot; = &quot;+a);</span>
            }
<span class="nc bnc" id="L483" title="All 4 branches missed.">            if (a == null &amp;&amp; length == 0) {</span>
                // Any zero-length attr is &quot;known&quot;...
                // We can assume an empty attr. has an empty layout.
                // Handles markers like Enum, Bridge, Synthetic, Deprecated.
<span class="nc" id="L487">                a = Attribute.find(ctype, name, &quot;&quot;);</span>
            }
<span class="nc bnc" id="L489" title="All 2 branches missed.">            boolean isStackMap = (ctype == ATTR_CONTEXT_CODE</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                                  &amp;&amp; (name.equals(&quot;StackMap&quot;) ||</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">                                      name.equals(&quot;StackMapX&quot;)));</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (isStackMap) {</span>
                // Known attribute but with a corner case format, &quot;pass&quot; it.
<span class="nc" id="L494">                Code code = (Code) h;</span>
                final int TOO_BIG = 0x10000;
<span class="nc bnc" id="L496" title="All 4 branches missed.">                if (code.max_stack   &gt;= TOO_BIG ||</span>
                    code.max_locals  &gt;= TOO_BIG ||
<span class="nc bnc" id="L498" title="All 2 branches missed.">                    code.getLength() &gt;= TOO_BIG ||</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                    name.endsWith(&quot;X&quot;)) {</span>
                    // No, we don't really know what to do this this one.
                    // Do not compress the rare and strange &quot;u4&quot; and &quot;X&quot; cases.
<span class="nc" id="L502">                    a = null;</span>
                }
            }
<span class="nc bnc" id="L505" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                if (isStackMap) {</span>
                    // Known attribute but w/o a format; pass it.
<span class="nc" id="L508">                    String message = &quot;unsupported StackMap variant in &quot;+h;</span>
<span class="nc" id="L509">                    throw new Attribute.FormatException(message, ctype, name,</span>
                                                        &quot;pass&quot;);
<span class="nc bnc" id="L511" title="All 2 branches missed.">                } else if (&quot;strip&quot;.equals(unknownAttrCommand)) {</span>
                    // Skip the unknown attribute.
<span class="nc" id="L513">                    skip(length, &quot;unknown &quot;+name+&quot; attribute in &quot;+h);</span>
<span class="nc" id="L514">                    continue;</span>
                } else {
<span class="nc" id="L516">                    String message = &quot; is unknown attribute in class &quot; + h;</span>
<span class="nc" id="L517">                    throw new Attribute.FormatException(message, ctype, name,</span>
                                                        unknownAttrCommand);
                }
            }
<span class="nc" id="L521">            long pos0 = inPos;  // in case we want to check it</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">            if (a.layout() == Package.attrCodeEmpty) {</span>
                // These are hardwired.
<span class="nc" id="L524">                Class.Method m = (Class.Method) h;</span>
<span class="nc" id="L525">                m.code = new Code(m);</span>
                try {
<span class="nc" id="L527">                    readCode(m.code);</span>
<span class="nc" id="L528">                } catch (Instruction.FormatException iie) {</span>
<span class="nc" id="L529">                    String message = iie.getMessage() + &quot; in &quot; + h;</span>
<span class="nc" id="L530">                    throw new ClassReader.ClassFormatException(message, iie);</span>
<span class="nc" id="L531">                }</span>
<span class="nc bnc" id="L532" title="All 4 branches missed.">                assert(length == inPos - pos0);</span>
                // Keep empty attribute a...
<span class="nc bnc" id="L534" title="All 2 branches missed.">            } else if (a.layout() == Package.attrBootstrapMethodsEmpty) {</span>
<span class="nc bnc" id="L535" title="All 4 branches missed.">                assert(h == cls);</span>
<span class="nc" id="L536">                readBootstrapMethods(cls);</span>
<span class="nc bnc" id="L537" title="All 4 branches missed.">                assert(length == inPos - pos0);</span>
                // Delete the attribute; it is logically part of the constant pool.
                continue;
<span class="nc bnc" id="L540" title="All 2 branches missed.">            } else if (a.layout() == Package.attrInnerClassesEmpty) {</span>
                // These are hardwired also.
<span class="nc bnc" id="L542" title="All 4 branches missed.">                assert(h == cls);</span>
<span class="nc" id="L543">                readInnerClasses(cls);</span>
<span class="nc bnc" id="L544" title="All 4 branches missed.">                assert(length == inPos - pos0);</span>
                // Keep empty attribute a...
<span class="nc bnc" id="L546" title="All 2 branches missed.">            } else if (length &gt; 0) {</span>
<span class="nc" id="L547">                byte[] bytes = new byte[length];</span>
<span class="nc" id="L548">                in.readFully(bytes);</span>
<span class="nc" id="L549">                a = a.addContent(bytes);</span>
            }
<span class="nc bnc" id="L551" title="All 4 branches missed.">            if (a.size() == 0 &amp;&amp; !a.layout().isEmpty()) {</span>
<span class="nc" id="L552">                throw new ClassFormatException(name +</span>
                        &quot;: attribute length cannot be zero, in &quot; + h);
            }
<span class="nc" id="L555">            h.addAttribute(a);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">            if (verbose &gt; 2)</span>
<span class="nc" id="L557">                Utils.log.fine(&quot;read &quot;+a);</span>
        }
<span class="nc" id="L559">    }</span>

    void readCode(Code code) throws IOException {
<span class="nc" id="L562">        code.max_stack = readUnsignedShort();</span>
<span class="nc" id="L563">        code.max_locals = readUnsignedShort();</span>
<span class="nc" id="L564">        code.bytes = new byte[readInt()];</span>
<span class="nc" id="L565">        in.readFully(code.bytes);</span>
<span class="nc" id="L566">        Entry[] cpMap = cls.getCPMap();</span>
<span class="nc" id="L567">        Instruction.opcodeChecker(code.bytes, cpMap, this.cls.version);</span>
<span class="nc" id="L568">        int nh = readUnsignedShort();</span>
<span class="nc" id="L569">        code.setHandlerCount(nh);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        for (int i = 0; i &lt; nh; i++) {</span>
<span class="nc" id="L571">            code.handler_start[i] = readUnsignedShort();</span>
<span class="nc" id="L572">            code.handler_end[i]   = readUnsignedShort();</span>
<span class="nc" id="L573">            code.handler_catch[i] = readUnsignedShort();</span>
<span class="nc" id="L574">            code.handler_class[i] = readClassRefOrNull();</span>
        }
<span class="nc" id="L576">        readAttributes(ATTR_CONTEXT_CODE, code);</span>
<span class="nc" id="L577">    }</span>

    void readBootstrapMethods(Class cls) throws IOException {
<span class="nc" id="L580">        BootstrapMethodEntry[] bsms = new BootstrapMethodEntry[readUnsignedShort()];</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">        for (int i = 0; i &lt; bsms.length; i++) {</span>
<span class="nc" id="L582">            MethodHandleEntry bsmRef = (MethodHandleEntry) readRef(CONSTANT_MethodHandle);</span>
<span class="nc" id="L583">            Entry[] argRefs = new Entry[readUnsignedShort()];</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">            for (int j = 0; j &lt; argRefs.length; j++) {</span>
<span class="nc" id="L585">                argRefs[j] = readRef(CONSTANT_LoadableValue);</span>
            }
<span class="nc" id="L587">            bsms[i] = ConstantPool.getBootstrapMethodEntry(bsmRef, argRefs);</span>
        }
<span class="nc" id="L589">        cls.setBootstrapMethods(Arrays.asList(bsms));</span>
<span class="nc" id="L590">    }</span>

    void readInnerClasses(Class cls) throws IOException {
<span class="nc" id="L593">        int nc = readUnsignedShort();</span>
<span class="nc" id="L594">        ArrayList&lt;InnerClass&gt; ics = new ArrayList&lt;&gt;(nc);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">        for (int i = 0; i &lt; nc; i++) {</span>
<span class="nc" id="L596">            InnerClass ic =</span>
<span class="nc" id="L597">                new InnerClass(readClassRef(),</span>
<span class="nc" id="L598">                               readClassRefOrNull(),</span>
<span class="nc" id="L599">                               (Utf8Entry)readRefOrNull(CONSTANT_Utf8),</span>
<span class="nc" id="L600">                               readUnsignedShort());</span>
<span class="nc" id="L601">            ics.add(ic);</span>
        }
<span class="nc" id="L603">        cls.innerClasses = ics;  // set directly; do not use setInnerClasses.</span>
        // (Later, ics may be transferred to the pkg.)
<span class="nc" id="L605">    }</span>

    static class ClassFormatException extends IOException {
        private static final long serialVersionUID = -3564121733989501833L;

        public ClassFormatException(String message) {
<span class="nc" id="L611">            super(message);</span>
<span class="nc" id="L612">        }</span>

        public ClassFormatException(String message, Throwable cause) {
<span class="nc" id="L615">            super(message, cause);</span>
<span class="nc" id="L616">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>