<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PackageReader.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">PackageReader.java</span></div><h1>PackageReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import com.sun.java.util.jar.pack.ConstantPool.*;
import com.sun.java.util.jar.pack.Package.Class;
import com.sun.java.util.jar.pack.Package.File;
import com.sun.java.util.jar.pack.Package.InnerClass;
import java.io.ByteArrayOutputStream;
import java.io.EOFException;
import java.io.PrintStream;
import java.io.FilterInputStream;
import java.io.BufferedInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Map;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import static com.sun.java.util.jar.pack.Constants.*;

/**
 * Reader for a package file.
 *
 * @see PackageWriter
 * @author John Rose
 */
<span class="nc bnc" id="L59" title="All 2 branches missed.">class PackageReader extends BandStructure {</span>
    Package pkg;
    byte[] bytes;
    LimitedBuffer in;
    Package.Version packageVersion;

<span class="nc" id="L65">    PackageReader(Package pkg, InputStream in) throws IOException {</span>
<span class="nc" id="L66">        this.pkg = pkg;</span>
<span class="nc" id="L67">        this.in = new LimitedBuffer(in);</span>
<span class="nc" id="L68">    }</span>

    /** A buffered input stream which is careful not to
     *  read its underlying stream ahead of a given mark,
     *  called the 'readLimit'.  This property declares
     *  the maximum number of characters that future reads
     *  can consume from the underlying stream.
     */
<span class="nc bnc" id="L76" title="All 2 branches missed.">    static</span>
    class LimitedBuffer extends BufferedInputStream {
        long served;     // total number of charburgers served
        int  servedPos;  // ...as of this value of super.pos
        long limit;      // current declared limit
        long buffered;
        public boolean atLimit() {
<span class="nc bnc" id="L83" title="All 2 branches missed.">            boolean z = (getBytesServed() == limit);</span>
<span class="nc bnc" id="L84" title="All 6 branches missed.">            assert(!z || limit == buffered);</span>
<span class="nc" id="L85">            return z;</span>
        }
        public long getBytesServed() {
<span class="nc" id="L88">            return served + (pos - servedPos);</span>
        }
        public void setReadLimit(long newLimit) {
<span class="nc bnc" id="L91" title="All 2 branches missed.">            if (newLimit == -1)</span>
<span class="nc" id="L92">                limit = -1;</span>
            else
<span class="nc" id="L94">                limit = getBytesServed() + newLimit;</span>
<span class="nc" id="L95">        }</span>
        public long getReadLimit() {
<span class="nc bnc" id="L97" title="All 2 branches missed.">            if (limit == -1)</span>
<span class="nc" id="L98">                return limit;</span>
            else
<span class="nc" id="L100">                return limit - getBytesServed();</span>
        }
        public int read() throws IOException {
<span class="nc bnc" id="L103" title="All 2 branches missed.">            if (pos &lt; count) {</span>
                // fast path
<span class="nc" id="L105">                return buf[pos++] &amp; 0xFF;</span>
            }
<span class="nc" id="L107">            served += (pos - servedPos);</span>
<span class="nc" id="L108">            int ch = super.read();</span>
<span class="nc" id="L109">            servedPos = pos;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (ch &gt;= 0)  served += 1;</span>
<span class="nc bnc" id="L111" title="All 6 branches missed.">            assert(served &lt;= limit || limit == -1);</span>
<span class="nc" id="L112">            return ch;</span>
        }
        public int read(byte b[], int off, int len) throws IOException {
<span class="nc" id="L115">            served += (pos - servedPos);</span>
<span class="nc" id="L116">            int nr = super.read(b, off, len);</span>
<span class="nc" id="L117">            servedPos = pos;</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            if (nr &gt;= 0)  served += nr;</span>
            //assert(served &lt;= limit || limit == -1);
<span class="nc" id="L120">            return nr;</span>
        }
        public long skip(long n) throws IOException {
<span class="nc" id="L123">            throw new RuntimeException(&quot;no skipping&quot;);</span>
        }
        LimitedBuffer(InputStream originalIn) {
<span class="nc" id="L126">            super(null, 1&lt;&lt;14);</span>
<span class="nc" id="L127">            servedPos = pos;</span>
<span class="nc" id="L128">            super.in = new FilterInputStream(originalIn) {</span>
                public int read() throws IOException {
<span class="nc bnc" id="L130" title="All 2 branches missed.">                    if (buffered == limit)</span>
<span class="nc" id="L131">                        return -1;</span>
<span class="nc" id="L132">                    ++buffered;</span>
<span class="nc" id="L133">                    return super.read();</span>
                }
                public int read(byte b[], int off, int len) throws IOException {
<span class="nc bnc" id="L136" title="All 2 branches missed.">                    if (buffered == limit)</span>
<span class="nc" id="L137">                        return -1;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                    if (limit != -1) {</span>
<span class="nc" id="L139">                        long remaining = limit - buffered;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                        if (len &gt; remaining)</span>
<span class="nc" id="L141">                            len = (int)remaining;</span>
                    }
<span class="nc" id="L143">                    int nr = super.read(b, off, len);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                    if (nr &gt;= 0)  buffered += nr;</span>
<span class="nc" id="L145">                    return nr;</span>
                }
            };
<span class="nc" id="L148">        }</span>
    }

    void read() throws IOException {
<span class="nc" id="L152">        boolean ok = false;</span>
        try {
            //  pack200_archive:
            //        file_header
            //        *band_headers :BYTE1
            //        cp_bands
            //        attr_definition_bands
            //        ic_bands
            //        class_bands
            //        bc_bands
            //        file_bands
<span class="nc" id="L163">            readFileHeader();</span>
<span class="nc" id="L164">            readBandHeaders();</span>
<span class="nc" id="L165">            readConstantPool();  // cp_bands</span>
<span class="nc" id="L166">            readAttrDefs();</span>
<span class="nc" id="L167">            readInnerClasses();</span>
<span class="nc" id="L168">            Class[] classes = readClasses();</span>
<span class="nc" id="L169">            readByteCodes();</span>
<span class="nc" id="L170">            readFiles();     // file_bands</span>
<span class="nc bnc" id="L171" title="All 6 branches missed.">            assert(archiveSize1 == 0 || in.atLimit());</span>
<span class="nc bnc" id="L172" title="All 4 branches missed.">            assert(archiveSize1 == 0 ||</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">                   in.getBytesServed() == archiveSize0+archiveSize1);</span>
<span class="nc" id="L174">            all_bands.doneDisbursing();</span>

            // As a post-pass, build constant pools and inner classes.
<span class="nc bnc" id="L177" title="All 2 branches missed.">            for (int i = 0; i &lt; classes.length; i++) {</span>
<span class="nc" id="L178">                reconstructClass(classes[i]);</span>
            }

<span class="nc" id="L181">            ok = true;</span>
<span class="nc" id="L182">        } catch (Exception ee) {</span>
<span class="nc" id="L183">            Utils.log.warning(&quot;Error on input: &quot;+ee, ee);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (verbose &gt; 0)</span>
<span class="nc" id="L185">                Utils.log.info(&quot;Stream offsets:&quot;+</span>
<span class="nc" id="L186">                                 &quot; served=&quot;+in.getBytesServed()+</span>
                                 &quot; buffered=&quot;+in.buffered+
                                 &quot; limit=&quot;+in.limit);
            //if (verbose &gt; 0)  ee.printStackTrace();
<span class="nc bnc" id="L190" title="All 2 branches missed.">            if (ee instanceof IOException)  throw (IOException)ee;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">            if (ee instanceof RuntimeException)  throw (RuntimeException)ee;</span>
<span class="nc" id="L192">            throw new Error(&quot;error unpacking&quot;, ee);</span>
<span class="nc" id="L193">        }</span>
<span class="nc" id="L194">    }</span>

    // Temporary count values, until band decoding gets rolling.
<span class="nc" id="L197">    int[] tagCount = new int[CONSTANT_Limit];</span>
    int numFiles;
    int numAttrDefs;
    int numInnerClasses;
    int numClasses;

    void readFileHeader() throws IOException {
        //  file_header:
        //        archive_magic archive_header
<span class="nc" id="L206">        readArchiveMagic();</span>
<span class="nc" id="L207">        readArchiveHeader();</span>
<span class="nc" id="L208">    }</span>

    // Local routine used to parse fixed-format scalars
    // in the file_header:
    private int getMagicInt32() throws IOException {
<span class="nc" id="L213">        int res = 0;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="nc" id="L215">            res &lt;&lt;= 8;</span>
<span class="nc" id="L216">            res |= (archive_magic.getByte() &amp; 0xFF);</span>
        }
<span class="nc" id="L218">        return res;</span>
    }

    final static int MAGIC_BYTES = 4;

    void readArchiveMagic() throws IOException {
        // Read a minimum of bytes in the first gulp.
<span class="nc" id="L225">        in.setReadLimit(MAGIC_BYTES + AH_LENGTH_MIN);</span>

        //  archive_magic:
        //        #archive_magic_word :BYTE1[4]
<span class="nc" id="L229">        archive_magic.expectLength(MAGIC_BYTES);</span>
<span class="nc" id="L230">        archive_magic.readFrom(in);</span>

        // read and check magic numbers:
<span class="nc" id="L233">        int magic = getMagicInt32();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (pkg.magic != magic) {</span>
<span class="nc" id="L235">            throw new IOException(&quot;Unexpected package magic number: got &quot;</span>
                    + magic + &quot;; expected &quot; + pkg.magic);
        }
<span class="nc" id="L238">        archive_magic.doneDisbursing();</span>
<span class="nc" id="L239">    }</span>

     // Fixed 6211177, converted to throw IOException
    void checkArchiveVersion() throws IOException {
<span class="nc" id="L243">        Package.Version versionFound = null;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        for (Package.Version v : new Package.Version[] {</span>
                JAVA8_PACKAGE_VERSION,
                JAVA7_PACKAGE_VERSION,
                JAVA6_PACKAGE_VERSION,
                JAVA5_PACKAGE_VERSION
            }) {
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (packageVersion.equals(v)) {</span>
<span class="nc" id="L251">                versionFound = v;</span>
<span class="nc" id="L252">                break;</span>
            }
        }
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (versionFound == null) {</span>
<span class="nc" id="L256">            String expVer =   JAVA8_PACKAGE_VERSION.toString()</span>
                            + &quot;OR&quot;
<span class="nc" id="L258">                            + JAVA7_PACKAGE_VERSION.toString()</span>
                            + &quot; OR &quot;
<span class="nc" id="L260">                            + JAVA6_PACKAGE_VERSION.toString()</span>
                            + &quot; OR &quot;
<span class="nc" id="L262">                            + JAVA5_PACKAGE_VERSION.toString();</span>
<span class="nc" id="L263">            throw new IOException(&quot;Unexpected package minor version: got &quot;</span>
<span class="nc" id="L264">                    +  packageVersion.toString() + &quot;; expected &quot; + expVer);</span>
        }
<span class="nc" id="L266">    }</span>

    void readArchiveHeader() throws IOException {
        //  archive_header:
        //        #archive_minver :UNSIGNED5[1]
        //        #archive_majver :UNSIGNED5[1]
        //        #archive_options :UNSIGNED5[1]
        //        (archive_file_counts) ** (#have_file_headers)
        //        (archive_special_counts) ** (#have_special_formats)
        //        cp_counts
        //        class_counts
        //
        //  archive_file_counts:
        //        #archive_size_hi :UNSIGNED5[1]
        //        #archive_size_lo :UNSIGNED5[1]
        //        #archive_next_count :UNSIGNED5[1]
        //        #archive_modtime :UNSIGNED5[1]
        //        #file_count :UNSIGNED5[1]
        //
        //  class_counts:
        //        #ic_count :UNSIGNED5[1]
        //        #default_class_minver :UNSIGNED5[1]
        //        #default_class_majver :UNSIGNED5[1]
        //        #class_count :UNSIGNED5[1]
        //
        //  archive_special_counts:
        //        #band_headers_size :UNSIGNED5[1]
        //        #attr_definition_count :UNSIGNED5[1]
        //
<span class="nc" id="L295">        archive_header_0.expectLength(AH_LENGTH_0);</span>
<span class="nc" id="L296">        archive_header_0.readFrom(in);</span>

<span class="nc" id="L298">        int minver = archive_header_0.getInt();</span>
<span class="nc" id="L299">        int majver = archive_header_0.getInt();</span>
<span class="nc" id="L300">        packageVersion = Package.Version.of(majver, minver);</span>
<span class="nc" id="L301">        checkArchiveVersion();</span>
<span class="nc" id="L302">        this.initHighestClassVersion(JAVA7_MAX_CLASS_VERSION);</span>

<span class="nc" id="L304">        archiveOptions = archive_header_0.getInt();</span>
<span class="nc" id="L305">        archive_header_0.doneDisbursing();</span>

        // detect archive optional fields in archive header
<span class="nc" id="L308">        boolean haveSpecial = testBit(archiveOptions, AO_HAVE_SPECIAL_FORMATS);</span>
<span class="nc" id="L309">        boolean haveFiles   = testBit(archiveOptions, AO_HAVE_FILE_HEADERS);</span>
<span class="nc" id="L310">        boolean haveNumbers = testBit(archiveOptions, AO_HAVE_CP_NUMBERS);</span>
<span class="nc" id="L311">        boolean haveCPExtra = testBit(archiveOptions, AO_HAVE_CP_EXTRAS);</span>
<span class="nc" id="L312">        initAttrIndexLimit();</span>

        // now we are ready to use the data:
<span class="nc bnc" id="L315" title="All 2 branches missed.">        archive_header_S.expectLength(haveFiles? AH_LENGTH_S: 0);</span>
<span class="nc" id="L316">        archive_header_S.readFrom(in);</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (haveFiles) {</span>
<span class="nc" id="L318">            long sizeHi = archive_header_S.getInt();</span>
<span class="nc" id="L319">            long sizeLo = archive_header_S.getInt();</span>
<span class="nc" id="L320">            archiveSize1 = (sizeHi &lt;&lt; 32) + ((sizeLo &lt;&lt; 32) &gt;&gt;&gt; 32);</span>
            // Set the limit, now, up to the file_bits.
<span class="nc" id="L322">            in.setReadLimit(archiveSize1);  // for debug only</span>
<span class="nc" id="L323">        } else {</span>
<span class="nc" id="L324">            archiveSize1 = 0;</span>
<span class="nc" id="L325">            in.setReadLimit(-1);  // remove limitation</span>
        }
<span class="nc" id="L327">        archive_header_S.doneDisbursing();</span>
<span class="nc" id="L328">        archiveSize0 = in.getBytesServed();</span>

<span class="nc" id="L330">        int remainingHeaders = AH_LENGTH_MIN - AH_LENGTH_0 - AH_LENGTH_S;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (haveFiles)    remainingHeaders += AH_FILE_HEADER_LEN;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (haveSpecial)  remainingHeaders += AH_SPECIAL_FORMAT_LEN;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (haveNumbers)  remainingHeaders += AH_CP_NUMBER_LEN;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (haveCPExtra)  remainingHeaders += AH_CP_EXTRA_LEN;</span>
<span class="nc" id="L335">        archive_header_1.expectLength(remainingHeaders);</span>
<span class="nc" id="L336">        archive_header_1.readFrom(in);</span>

<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (haveFiles) {</span>
<span class="nc" id="L339">            archiveNextCount = archive_header_1.getInt();</span>
<span class="nc" id="L340">            pkg.default_modtime = archive_header_1.getInt();</span>
<span class="nc" id="L341">            numFiles = archive_header_1.getInt();</span>
        } else {
<span class="nc" id="L343">            archiveNextCount = 0;</span>
<span class="nc" id="L344">            numFiles = 0;</span>
        }

<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (haveSpecial) {</span>
<span class="nc" id="L348">            band_headers.expectLength(archive_header_1.getInt());</span>
<span class="nc" id="L349">            numAttrDefs = archive_header_1.getInt();</span>
        } else {
<span class="nc" id="L351">            band_headers.expectLength(0);</span>
<span class="nc" id="L352">            numAttrDefs = 0;</span>
        }

<span class="nc" id="L355">        readConstantPoolCounts(haveNumbers, haveCPExtra);</span>

<span class="nc" id="L357">        numInnerClasses = archive_header_1.getInt();</span>

<span class="nc" id="L359">        minver = (short) archive_header_1.getInt();</span>
<span class="nc" id="L360">        majver = (short) archive_header_1.getInt();</span>
<span class="nc" id="L361">        pkg.defaultClassVersion = Package.Version.of(majver, minver);</span>
<span class="nc" id="L362">        numClasses = archive_header_1.getInt();</span>

<span class="nc" id="L364">        archive_header_1.doneDisbursing();</span>

        // set some derived archive bits
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (testBit(archiveOptions, AO_DEFLATE_HINT)) {</span>
<span class="nc" id="L368">            pkg.default_options |= FO_DEFLATE_HINT;</span>
        }
<span class="nc" id="L370">    }</span>

    void readBandHeaders() throws IOException {
<span class="nc" id="L373">        band_headers.readFrom(in);</span>
<span class="nc" id="L374">        bandHeaderBytePos = 1;  // Leave room to pushback the initial XB byte.</span>
<span class="nc" id="L375">        bandHeaderBytes = new byte[bandHeaderBytePos + band_headers.length()];</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        for (int i = bandHeaderBytePos; i &lt; bandHeaderBytes.length; i++) {</span>
<span class="nc" id="L377">            bandHeaderBytes[i] = (byte) band_headers.getByte();</span>
        }
<span class="nc" id="L379">        band_headers.doneDisbursing();</span>
<span class="nc" id="L380">    }</span>

    void readConstantPoolCounts(boolean haveNumbers, boolean haveCPExtra) throws IOException {
        // size the constant pools:
<span class="nc bnc" id="L384" title="All 2 branches missed.">        for (int k = 0; k &lt; ConstantPool.TAGS_IN_ORDER.length; k++) {</span>
            //  cp_counts:
            //        #cp_Utf8_count :UNSIGNED5[1]
            //        (cp_number_counts) ** (#have_cp_numbers)
            //        #cp_String_count :UNSIGNED5[1]
            //        #cp_Class_count :UNSIGNED5[1]
            //        #cp_Signature_count :UNSIGNED5[1]
            //        #cp_Descr_count :UNSIGNED5[1]
            //        #cp_Field_count :UNSIGNED5[1]
            //        #cp_Method_count :UNSIGNED5[1]
            //        #cp_Imethod_count :UNSIGNED5[1]
            //        (cp_attr_counts) ** (#have_cp_attr_counts)
            //
            //  cp_number_counts:
            //        #cp_Int_count :UNSIGNED5[1]
            //        #cp_Float_count :UNSIGNED5[1]
            //        #cp_Long_count :UNSIGNED5[1]
            //        #cp_Double_count :UNSIGNED5[1]
            //
            //  cp_extra_counts:
            //        #cp_MethodHandle_count :UNSIGNED5[1]
            //        #cp_MethodType_count :UNSIGNED5[1]
            //        #cp_InvokeDynamic_count :UNSIGNED5[1]
            //        #cp_BootstrapMethod_count :UNSIGNED5[1]
            //
<span class="nc" id="L409">            byte tag = ConstantPool.TAGS_IN_ORDER[k];</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (!haveNumbers) {</span>
                // These four counts are optional.
<span class="nc bnc" id="L412" title="All 2 branches missed.">                switch (tag) {</span>
                case CONSTANT_Integer:
                case CONSTANT_Float:
                case CONSTANT_Long:
                case CONSTANT_Double:
<span class="nc" id="L417">                    continue;</span>
                }
            }
<span class="nc bnc" id="L420" title="All 2 branches missed.">            if (!haveCPExtra) {</span>
                // These four counts are optional.
<span class="nc bnc" id="L422" title="All 2 branches missed.">                switch (tag) {</span>
                case CONSTANT_MethodHandle:
                case CONSTANT_MethodType:
                case CONSTANT_InvokeDynamic:
                case CONSTANT_BootstrapMethod:
<span class="nc" id="L427">                    continue;</span>
                }
            }
<span class="nc" id="L430">            tagCount[tag] = archive_header_1.getInt();</span>
        }
<span class="nc" id="L432">    }</span>

    protected Index getCPIndex(byte tag) {
<span class="nc" id="L435">        return pkg.cp.getIndexByTag(tag);</span>
    }
    Index initCPIndex(byte tag, Entry[] cpMap) {
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (verbose &gt; 3) {</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L440">                Utils.log.fine(&quot;cp.add &quot;+cpMap[i]);</span>
            }
        }
<span class="nc" id="L443">        Index index = ConstantPool.makeIndex(ConstantPool.tagName(tag), cpMap);</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (verbose &gt; 1)  Utils.log.fine(&quot;Read &quot;+index);</span>
<span class="nc" id="L445">        pkg.cp.initIndexByTag(tag, index);</span>
<span class="nc" id="L446">        return index;</span>
    }

    void checkLegacy(String bandname) {
<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (packageVersion.lessThan(JAVA7_PACKAGE_VERSION)) {</span>
<span class="nc" id="L451">            throw new RuntimeException(&quot;unexpected band &quot; + bandname);</span>
        }
<span class="nc" id="L453">    }</span>
    void readConstantPool() throws IOException {
        //  cp_bands:
        //        cp_Utf8
        //        *cp_Int :UDELTA5
        //        *cp_Float :UDELTA5
        //        cp_Long
        //        cp_Double
        //        *cp_String :UDELTA5  (cp_Utf8)
        //        *cp_Class :UDELTA5  (cp_Utf8)
        //        cp_Signature
        //        cp_Descr
        //        cp_Field
        //        cp_Method
        //        cp_Imethod

<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (verbose &gt; 0)  Utils.log.info(&quot;Reading CP&quot;);</span>

<span class="nc bnc" id="L471" title="All 2 branches missed.">        for (int k = 0; k &lt; ConstantPool.TAGS_IN_ORDER.length; k++) {</span>
<span class="nc" id="L472">            byte tag = ConstantPool.TAGS_IN_ORDER[k];</span>
<span class="nc" id="L473">            int  len = tagCount[tag];</span>

<span class="nc" id="L475">            Entry[] cpMap = new Entry[len];</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">            if (verbose &gt; 0)</span>
<span class="nc" id="L477">                Utils.log.info(&quot;Reading &quot;+cpMap.length+&quot; &quot;+ConstantPool.tagName(tag)+&quot; entries...&quot;);</span>

<span class="nc bnc" id="L479" title="All 17 branches missed.">            switch (tag) {</span>
            case CONSTANT_Utf8:
<span class="nc" id="L481">                readUtf8Bands(cpMap);</span>
<span class="nc" id="L482">                break;</span>
            case CONSTANT_Integer:
<span class="nc" id="L484">                cp_Int.expectLength(cpMap.length);</span>
<span class="nc" id="L485">                cp_Int.readFrom(in);</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L487">                    int x = cp_Int.getInt();  // coding handles signs OK</span>
<span class="nc" id="L488">                    cpMap[i] = ConstantPool.getLiteralEntry(x);</span>
                }
<span class="nc" id="L490">                cp_Int.doneDisbursing();</span>
<span class="nc" id="L491">                break;</span>
            case CONSTANT_Float:
<span class="nc" id="L493">                cp_Float.expectLength(cpMap.length);</span>
<span class="nc" id="L494">                cp_Float.readFrom(in);</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L496">                    int x = cp_Float.getInt();</span>
<span class="nc" id="L497">                    float fx = Float.intBitsToFloat(x);</span>
<span class="nc" id="L498">                    cpMap[i] = ConstantPool.getLiteralEntry(fx);</span>
                }
<span class="nc" id="L500">                cp_Float.doneDisbursing();</span>
<span class="nc" id="L501">                break;</span>
            case CONSTANT_Long:
                //  cp_Long:
                //        *cp_Long_hi :UDELTA5
                //        *cp_Long_lo :DELTA5
<span class="nc" id="L506">                cp_Long_hi.expectLength(cpMap.length);</span>
<span class="nc" id="L507">                cp_Long_hi.readFrom(in);</span>
<span class="nc" id="L508">                cp_Long_lo.expectLength(cpMap.length);</span>
<span class="nc" id="L509">                cp_Long_lo.readFrom(in);</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L511">                    long hi = cp_Long_hi.getInt();</span>
<span class="nc" id="L512">                    long lo = cp_Long_lo.getInt();</span>
<span class="nc" id="L513">                    long x = (hi &lt;&lt; 32) + ((lo &lt;&lt; 32) &gt;&gt;&gt; 32);</span>
<span class="nc" id="L514">                    cpMap[i] = ConstantPool.getLiteralEntry(x);</span>
                }
<span class="nc" id="L516">                cp_Long_hi.doneDisbursing();</span>
<span class="nc" id="L517">                cp_Long_lo.doneDisbursing();</span>
<span class="nc" id="L518">                break;</span>
            case CONSTANT_Double:
                //  cp_Double:
                //        *cp_Double_hi :UDELTA5
                //        *cp_Double_lo :DELTA5
<span class="nc" id="L523">                cp_Double_hi.expectLength(cpMap.length);</span>
<span class="nc" id="L524">                cp_Double_hi.readFrom(in);</span>
<span class="nc" id="L525">                cp_Double_lo.expectLength(cpMap.length);</span>
<span class="nc" id="L526">                cp_Double_lo.readFrom(in);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L528">                    long hi = cp_Double_hi.getInt();</span>
<span class="nc" id="L529">                    long lo = cp_Double_lo.getInt();</span>
<span class="nc" id="L530">                    long x = (hi &lt;&lt; 32) + ((lo &lt;&lt; 32) &gt;&gt;&gt; 32);</span>
<span class="nc" id="L531">                    double dx = Double.longBitsToDouble(x);</span>
<span class="nc" id="L532">                    cpMap[i] = ConstantPool.getLiteralEntry(dx);</span>
                }
<span class="nc" id="L534">                cp_Double_hi.doneDisbursing();</span>
<span class="nc" id="L535">                cp_Double_lo.doneDisbursing();</span>
<span class="nc" id="L536">                break;</span>
            case CONSTANT_String:
<span class="nc" id="L538">                cp_String.expectLength(cpMap.length);</span>
<span class="nc" id="L539">                cp_String.readFrom(in);</span>
<span class="nc" id="L540">                cp_String.setIndex(getCPIndex(CONSTANT_Utf8));</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L542">                    cpMap[i] = ConstantPool.getLiteralEntry(cp_String.getRef().stringValue());</span>
                }
<span class="nc" id="L544">                cp_String.doneDisbursing();</span>
<span class="nc" id="L545">                break;</span>
            case CONSTANT_Class:
<span class="nc" id="L547">                cp_Class.expectLength(cpMap.length);</span>
<span class="nc" id="L548">                cp_Class.readFrom(in);</span>
<span class="nc" id="L549">                cp_Class.setIndex(getCPIndex(CONSTANT_Utf8));</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L551">                    cpMap[i] = ConstantPool.getClassEntry(cp_Class.getRef().stringValue());</span>
                }
<span class="nc" id="L553">                cp_Class.doneDisbursing();</span>
<span class="nc" id="L554">                break;</span>
            case CONSTANT_Signature:
<span class="nc" id="L556">                readSignatureBands(cpMap);</span>
<span class="nc" id="L557">                break;</span>
            case CONSTANT_NameandType:
                //  cp_Descr:
                //        *cp_Descr_type :DELTA5  (cp_Signature)
                //        *cp_Descr_name :UDELTA5  (cp_Utf8)
<span class="nc" id="L562">                cp_Descr_name.expectLength(cpMap.length);</span>
<span class="nc" id="L563">                cp_Descr_name.readFrom(in);</span>
<span class="nc" id="L564">                cp_Descr_name.setIndex(getCPIndex(CONSTANT_Utf8));</span>
<span class="nc" id="L565">                cp_Descr_type.expectLength(cpMap.length);</span>
<span class="nc" id="L566">                cp_Descr_type.readFrom(in);</span>
<span class="nc" id="L567">                cp_Descr_type.setIndex(getCPIndex(CONSTANT_Signature));</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L569">                    Entry ref  = cp_Descr_name.getRef();</span>
<span class="nc" id="L570">                    Entry ref2 = cp_Descr_type.getRef();</span>
<span class="nc" id="L571">                    cpMap[i] = ConstantPool.getDescriptorEntry((Utf8Entry)ref,</span>
                                                        (SignatureEntry)ref2);
                }
<span class="nc" id="L574">                cp_Descr_name.doneDisbursing();</span>
<span class="nc" id="L575">                cp_Descr_type.doneDisbursing();</span>
<span class="nc" id="L576">                break;</span>
            case CONSTANT_Fieldref:
<span class="nc" id="L578">                readMemberRefs(tag, cpMap, cp_Field_class, cp_Field_desc);</span>
<span class="nc" id="L579">                break;</span>
            case CONSTANT_Methodref:
<span class="nc" id="L581">                readMemberRefs(tag, cpMap, cp_Method_class, cp_Method_desc);</span>
<span class="nc" id="L582">                break;</span>
            case CONSTANT_InterfaceMethodref:
<span class="nc" id="L584">                readMemberRefs(tag, cpMap, cp_Imethod_class, cp_Imethod_desc);</span>
<span class="nc" id="L585">                break;</span>
            case CONSTANT_MethodHandle:
<span class="nc bnc" id="L587" title="All 2 branches missed.">                if (cpMap.length &gt; 0) {</span>
<span class="nc" id="L588">                    checkLegacy(cp_MethodHandle_refkind.name());</span>
                }
<span class="nc" id="L590">                cp_MethodHandle_refkind.expectLength(cpMap.length);</span>
<span class="nc" id="L591">                cp_MethodHandle_refkind.readFrom(in);</span>
<span class="nc" id="L592">                cp_MethodHandle_member.expectLength(cpMap.length);</span>
<span class="nc" id="L593">                cp_MethodHandle_member.readFrom(in);</span>
<span class="nc" id="L594">                cp_MethodHandle_member.setIndex(getCPIndex(CONSTANT_AnyMember));</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L596">                    byte        refKind = (byte)        cp_MethodHandle_refkind.getInt();</span>
<span class="nc" id="L597">                    MemberEntry memRef  = (MemberEntry) cp_MethodHandle_member.getRef();</span>
<span class="nc" id="L598">                    cpMap[i] = ConstantPool.getMethodHandleEntry(refKind, memRef);</span>
                }
<span class="nc" id="L600">                cp_MethodHandle_refkind.doneDisbursing();</span>
<span class="nc" id="L601">                cp_MethodHandle_member.doneDisbursing();</span>
<span class="nc" id="L602">                break;</span>
            case CONSTANT_MethodType:
<span class="nc bnc" id="L604" title="All 2 branches missed.">                if (cpMap.length &gt; 0) {</span>
<span class="nc" id="L605">                    checkLegacy(cp_MethodType.name());</span>
                }
<span class="nc" id="L607">                cp_MethodType.expectLength(cpMap.length);</span>
<span class="nc" id="L608">                cp_MethodType.readFrom(in);</span>
<span class="nc" id="L609">                cp_MethodType.setIndex(getCPIndex(CONSTANT_Signature));</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L611">                    SignatureEntry typeRef  = (SignatureEntry) cp_MethodType.getRef();</span>
<span class="nc" id="L612">                    cpMap[i] = ConstantPool.getMethodTypeEntry(typeRef);</span>
                }
<span class="nc" id="L614">                cp_MethodType.doneDisbursing();</span>
<span class="nc" id="L615">                break;</span>
            case CONSTANT_InvokeDynamic:
<span class="nc bnc" id="L617" title="All 2 branches missed.">                if (cpMap.length &gt; 0) {</span>
<span class="nc" id="L618">                    checkLegacy(cp_InvokeDynamic_spec.name());</span>
                }
<span class="nc" id="L620">                cp_InvokeDynamic_spec.expectLength(cpMap.length);</span>
<span class="nc" id="L621">                cp_InvokeDynamic_spec.readFrom(in);</span>
<span class="nc" id="L622">                cp_InvokeDynamic_spec.setIndex(getCPIndex(CONSTANT_BootstrapMethod));</span>
<span class="nc" id="L623">                cp_InvokeDynamic_desc.expectLength(cpMap.length);</span>
<span class="nc" id="L624">                cp_InvokeDynamic_desc.readFrom(in);</span>
<span class="nc" id="L625">                cp_InvokeDynamic_desc.setIndex(getCPIndex(CONSTANT_NameandType));</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L627">                    BootstrapMethodEntry bss   = (BootstrapMethodEntry) cp_InvokeDynamic_spec.getRef();</span>
<span class="nc" id="L628">                    DescriptorEntry      descr = (DescriptorEntry)      cp_InvokeDynamic_desc.getRef();</span>
<span class="nc" id="L629">                    cpMap[i] = ConstantPool.getInvokeDynamicEntry(bss, descr);</span>
                }
<span class="nc" id="L631">                cp_InvokeDynamic_spec.doneDisbursing();</span>
<span class="nc" id="L632">                cp_InvokeDynamic_desc.doneDisbursing();</span>
<span class="nc" id="L633">                break;</span>
            case CONSTANT_BootstrapMethod:
<span class="nc bnc" id="L635" title="All 2 branches missed.">                if (cpMap.length &gt; 0) {</span>
<span class="nc" id="L636">                    checkLegacy(cp_BootstrapMethod_ref.name());</span>
                }
<span class="nc" id="L638">                cp_BootstrapMethod_ref.expectLength(cpMap.length);</span>
<span class="nc" id="L639">                cp_BootstrapMethod_ref.readFrom(in);</span>
<span class="nc" id="L640">                cp_BootstrapMethod_ref.setIndex(getCPIndex(CONSTANT_MethodHandle));</span>
<span class="nc" id="L641">                cp_BootstrapMethod_arg_count.expectLength(cpMap.length);</span>
<span class="nc" id="L642">                cp_BootstrapMethod_arg_count.readFrom(in);</span>
<span class="nc" id="L643">                int totalArgCount = cp_BootstrapMethod_arg_count.getIntTotal();</span>
<span class="nc" id="L644">                cp_BootstrapMethod_arg.expectLength(totalArgCount);</span>
<span class="nc" id="L645">                cp_BootstrapMethod_arg.readFrom(in);</span>
<span class="nc" id="L646">                cp_BootstrapMethod_arg.setIndex(getCPIndex(CONSTANT_LoadableValue));</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">                for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L648">                    MethodHandleEntry bsm = (MethodHandleEntry) cp_BootstrapMethod_ref.getRef();</span>
<span class="nc" id="L649">                    int argc = cp_BootstrapMethod_arg_count.getInt();</span>
<span class="nc" id="L650">                    Entry[] argRefs = new Entry[argc];</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">                    for (int j = 0; j &lt; argc; j++) {</span>
<span class="nc" id="L652">                        argRefs[j] = cp_BootstrapMethod_arg.getRef();</span>
                    }
<span class="nc" id="L654">                    cpMap[i] = ConstantPool.getBootstrapMethodEntry(bsm, argRefs);</span>
                }
<span class="nc" id="L656">                cp_BootstrapMethod_ref.doneDisbursing();</span>
<span class="nc" id="L657">                cp_BootstrapMethod_arg_count.doneDisbursing();</span>
<span class="nc" id="L658">                cp_BootstrapMethod_arg.doneDisbursing();</span>
<span class="nc" id="L659">                break;</span>
            default:
<span class="nc" id="L661">                throw new AssertionError(&quot;unexpected CP tag in package&quot;);</span>
            }

<span class="nc" id="L664">            Index index = initCPIndex(tag, cpMap);</span>

<span class="nc bnc" id="L666" title="All 2 branches missed.">            if (optDumpBands) {</span>
<span class="nc" id="L667">                try (PrintStream ps = new PrintStream(getDumpStream(index, &quot;.idx&quot;))) {</span>
<span class="nc" id="L668">                    printArrayTo(ps, index.cpMap, 0, index.cpMap.length);</span>
<span class="nc bnc" id="L669" title="All 8 branches missed.">                }</span>
            }
        }

<span class="nc" id="L673">        cp_bands.doneDisbursing();</span>

<span class="nc bnc" id="L675" title="All 4 branches missed.">        if (optDumpBands || verbose &gt; 1) {</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">            for (byte tag = CONSTANT_GroupFirst; tag &lt; CONSTANT_GroupLimit; tag++) {</span>
<span class="nc" id="L677">                Index index = pkg.cp.getIndexByTag(tag);</span>
<span class="nc bnc" id="L678" title="All 4 branches missed.">                if (index == null || index.isEmpty())  continue;</span>
<span class="nc" id="L679">                Entry[] cpMap = index.cpMap;</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                if (verbose &gt; 1)</span>
<span class="nc" id="L681">                    Utils.log.info(&quot;Index group &quot;+ConstantPool.tagName(tag)+&quot; contains &quot;+cpMap.length+&quot; entries.&quot;);</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                if (optDumpBands) {</span>
<span class="nc" id="L683">                    try (PrintStream ps = new PrintStream(getDumpStream(index.debugName, tag, &quot;.gidx&quot;, index))) {</span>
<span class="nc" id="L684">                        printArrayTo(ps, cpMap, 0, cpMap.length, true);</span>
<span class="nc bnc" id="L685" title="All 8 branches missed.">                    }</span>
                }
            }
        }

<span class="nc" id="L690">        setBandIndexes();</span>
<span class="nc" id="L691">    }</span>

    void readUtf8Bands(Entry[] cpMap) throws IOException {
        //  cp_Utf8:
        //        *cp_Utf8_prefix :DELTA5
        //        *cp_Utf8_suffix :UNSIGNED5
        //        *cp_Utf8_chars :CHAR3
        //        *cp_Utf8_big_suffix :DELTA5
        //        (*cp_Utf8_big_chars :DELTA5)
        //          ** length(cp_Utf8_big_suffix)
<span class="nc" id="L701">        int len = cpMap.length;</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">        if (len == 0)</span>
<span class="nc" id="L703">            return;  // nothing to read</span>

        // Bands have implicit leading zeroes, for the empty string:
        final int SUFFIX_SKIP_1 = 1;
        final int PREFIX_SKIP_2 = 2;

        // First band:  Read lengths of shared prefixes.
<span class="nc" id="L710">        cp_Utf8_prefix.expectLength(Math.max(0, len - PREFIX_SKIP_2));</span>
<span class="nc" id="L711">        cp_Utf8_prefix.readFrom(in);</span>

        // Second band:  Read lengths of unshared suffixes:
<span class="nc" id="L714">        cp_Utf8_suffix.expectLength(Math.max(0, len - SUFFIX_SKIP_1));</span>
<span class="nc" id="L715">        cp_Utf8_suffix.readFrom(in);</span>

<span class="nc" id="L717">        char[][] suffixChars = new char[len][];</span>
<span class="nc" id="L718">        int bigSuffixCount = 0;</span>

        // Third band:  Read the char values in the unshared suffixes:
<span class="nc" id="L721">        cp_Utf8_chars.expectLength(cp_Utf8_suffix.getIntTotal());</span>
<span class="nc" id="L722">        cp_Utf8_chars.readFrom(in);</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">            int suffix = (i &lt; SUFFIX_SKIP_1)? 0: cp_Utf8_suffix.getInt();</span>
<span class="nc bnc" id="L725" title="All 4 branches missed.">            if (suffix == 0 &amp;&amp; i &gt;= SUFFIX_SKIP_1) {</span>
                // chars are packed in cp_Utf8_big_chars
<span class="nc" id="L727">                bigSuffixCount += 1;</span>
<span class="nc" id="L728">                continue;</span>
            }
<span class="nc" id="L730">            suffixChars[i] = new char[suffix];</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">            for (int j = 0; j &lt; suffix; j++) {</span>
<span class="nc" id="L732">                int ch = cp_Utf8_chars.getInt();</span>
<span class="nc bnc" id="L733" title="All 4 branches missed.">                assert(ch == (char)ch);</span>
<span class="nc" id="L734">                suffixChars[i][j] = (char)ch;</span>
            }
        }
<span class="nc" id="L737">        cp_Utf8_chars.doneDisbursing();</span>

        // Fourth band:  Go back and size the specially packed strings.
<span class="nc" id="L740">        int maxChars = 0;</span>
<span class="nc" id="L741">        cp_Utf8_big_suffix.expectLength(bigSuffixCount);</span>
<span class="nc" id="L742">        cp_Utf8_big_suffix.readFrom(in);</span>
<span class="nc" id="L743">        cp_Utf8_suffix.resetForSecondPass();</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">            int suffix = (i &lt; SUFFIX_SKIP_1)? 0: cp_Utf8_suffix.getInt();</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">            int prefix = (i &lt; PREFIX_SKIP_2)? 0: cp_Utf8_prefix.getInt();</span>
<span class="nc bnc" id="L747" title="All 4 branches missed.">            if (suffix == 0 &amp;&amp; i &gt;= SUFFIX_SKIP_1) {</span>
<span class="nc bnc" id="L748" title="All 4 branches missed.">                assert(suffixChars[i] == null);</span>
<span class="nc" id="L749">                suffix = cp_Utf8_big_suffix.getInt();</span>
            } else {
<span class="nc bnc" id="L751" title="All 4 branches missed.">                assert(suffixChars[i] != null);</span>
            }
<span class="nc bnc" id="L753" title="All 2 branches missed.">            if (maxChars &lt; prefix + suffix)</span>
<span class="nc" id="L754">                maxChars = prefix + suffix;</span>
        }
<span class="nc" id="L756">        char[] buf = new char[maxChars];</span>

        // Fifth band(s):  Get the specially packed characters.
<span class="nc" id="L759">        cp_Utf8_suffix.resetForSecondPass();</span>
<span class="nc" id="L760">        cp_Utf8_big_suffix.resetForSecondPass();</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">            if (i &lt; SUFFIX_SKIP_1)  continue;</span>
<span class="nc" id="L763">            int suffix = cp_Utf8_suffix.getInt();</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">            if (suffix != 0)  continue;  // already input</span>
<span class="nc" id="L765">            suffix = cp_Utf8_big_suffix.getInt();</span>
<span class="nc" id="L766">            suffixChars[i] = new char[suffix];</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">            if (suffix == 0) {</span>
                // Do not bother to add an empty &quot;(Utf8_big_0)&quot; band.
<span class="nc" id="L769">                continue;</span>
            }
<span class="nc" id="L771">            IntBand packed = cp_Utf8_big_chars.newIntBand(&quot;(Utf8_big_&quot;+i+&quot;)&quot;);</span>
<span class="nc" id="L772">            packed.expectLength(suffix);</span>
<span class="nc" id="L773">            packed.readFrom(in);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">            for (int j = 0; j &lt; suffix; j++) {</span>
<span class="nc" id="L775">                int ch = packed.getInt();</span>
<span class="nc bnc" id="L776" title="All 4 branches missed.">                assert(ch == (char)ch);</span>
<span class="nc" id="L777">                suffixChars[i][j] = (char)ch;</span>
            }
<span class="nc" id="L779">            packed.doneDisbursing();</span>
        }
<span class="nc" id="L781">        cp_Utf8_big_chars.doneDisbursing();</span>

        // Finally, sew together all the prefixes and suffixes.
<span class="nc" id="L784">        cp_Utf8_prefix.resetForSecondPass();</span>
<span class="nc" id="L785">        cp_Utf8_suffix.resetForSecondPass();</span>
<span class="nc" id="L786">        cp_Utf8_big_suffix.resetForSecondPass();</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">            int prefix = (i &lt; PREFIX_SKIP_2)? 0: cp_Utf8_prefix.getInt();</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">            int suffix = (i &lt; SUFFIX_SKIP_1)? 0: cp_Utf8_suffix.getInt();</span>
<span class="nc bnc" id="L790" title="All 4 branches missed.">            if (suffix == 0 &amp;&amp; i &gt;= SUFFIX_SKIP_1)</span>
<span class="nc" id="L791">                suffix = cp_Utf8_big_suffix.getInt();</span>

            // by induction, the buffer is already filled with the prefix
<span class="nc" id="L794">            System.arraycopy(suffixChars[i], 0, buf, prefix, suffix);</span>

<span class="nc" id="L796">            cpMap[i] = ConstantPool.getUtf8Entry(new String(buf, 0, prefix+suffix));</span>
        }

<span class="nc" id="L799">        cp_Utf8_prefix.doneDisbursing();</span>
<span class="nc" id="L800">        cp_Utf8_suffix.doneDisbursing();</span>
<span class="nc" id="L801">        cp_Utf8_big_suffix.doneDisbursing();</span>
<span class="nc" id="L802">    }</span>

    Map&lt;Utf8Entry, SignatureEntry&gt; utf8Signatures;

    void readSignatureBands(Entry[] cpMap) throws IOException {
        //  cp_Signature:
        //        *cp_Signature_form :DELTA5  (cp_Utf8)
        //        *cp_Signature_classes :UDELTA5  (cp_Class)
<span class="nc" id="L810">        cp_Signature_form.expectLength(cpMap.length);</span>
<span class="nc" id="L811">        cp_Signature_form.readFrom(in);</span>
<span class="nc" id="L812">        cp_Signature_form.setIndex(getCPIndex(CONSTANT_Utf8));</span>
<span class="nc" id="L813">        int[] numSigClasses = new int[cpMap.length];</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">        for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L815">            Utf8Entry formRef = (Utf8Entry) cp_Signature_form.getRef();</span>
<span class="nc" id="L816">            numSigClasses[i] = ConstantPool.countClassParts(formRef);</span>
        }
<span class="nc" id="L818">        cp_Signature_form.resetForSecondPass();</span>
<span class="nc" id="L819">        cp_Signature_classes.expectLength(getIntTotal(numSigClasses));</span>
<span class="nc" id="L820">        cp_Signature_classes.readFrom(in);</span>
<span class="nc" id="L821">        cp_Signature_classes.setIndex(getCPIndex(CONSTANT_Class));</span>
<span class="nc" id="L822">        utf8Signatures = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">        for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L824">            Utf8Entry formRef = (Utf8Entry) cp_Signature_form.getRef();</span>
<span class="nc" id="L825">            ClassEntry[] classRefs = new ClassEntry[numSigClasses[i]];</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">            for (int j = 0; j &lt; classRefs.length; j++) {</span>
<span class="nc" id="L827">                classRefs[j] = (ClassEntry) cp_Signature_classes.getRef();</span>
            }
<span class="nc" id="L829">            SignatureEntry se = ConstantPool.getSignatureEntry(formRef, classRefs);</span>
<span class="nc" id="L830">            cpMap[i] = se;</span>
<span class="nc" id="L831">            utf8Signatures.put(se.asUtf8Entry(), se);</span>
        }
<span class="nc" id="L833">        cp_Signature_form.doneDisbursing();</span>
<span class="nc" id="L834">        cp_Signature_classes.doneDisbursing();</span>
<span class="nc" id="L835">    }</span>

    void readMemberRefs(byte tag, Entry[] cpMap, CPRefBand cp_class, CPRefBand cp_desc) throws IOException {
        //  cp_Field:
        //        *cp_Field_class :DELTA5  (cp_Class)
        //        *cp_Field_desc :UDELTA5  (cp_Descr)
        //  cp_Method:
        //        *cp_Method_class :DELTA5  (cp_Class)
        //        *cp_Method_desc :UDELTA5  (cp_Descr)
        //  cp_Imethod:
        //        *cp_Imethod_class :DELTA5  (cp_Class)
        //        *cp_Imethod_desc :UDELTA5  (cp_Descr)
<span class="nc" id="L847">        cp_class.expectLength(cpMap.length);</span>
<span class="nc" id="L848">        cp_class.readFrom(in);</span>
<span class="nc" id="L849">        cp_class.setIndex(getCPIndex(CONSTANT_Class));</span>
<span class="nc" id="L850">        cp_desc.expectLength(cpMap.length);</span>
<span class="nc" id="L851">        cp_desc.readFrom(in);</span>
<span class="nc" id="L852">        cp_desc.setIndex(getCPIndex(CONSTANT_NameandType));</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">        for (int i = 0; i &lt; cpMap.length; i++) {</span>
<span class="nc" id="L854">            ClassEntry      mclass = (ClassEntry     ) cp_class.getRef();</span>
<span class="nc" id="L855">            DescriptorEntry mdescr = (DescriptorEntry) cp_desc.getRef();</span>
<span class="nc" id="L856">            cpMap[i] = ConstantPool.getMemberEntry(tag, mclass, mdescr);</span>
        }
<span class="nc" id="L858">        cp_class.doneDisbursing();</span>
<span class="nc" id="L859">        cp_desc.doneDisbursing();</span>
<span class="nc" id="L860">    }</span>

    void readFiles() throws IOException {
        //  file_bands:
        //        *file_name :UNSIGNED5  (cp_Utf8)
        //        *file_size_hi :UNSIGNED5
        //        *file_size_lo :UNSIGNED5
        //        *file_modtime :DELTA5
        //        *file_options :UNSIGNED5
        //        *file_bits :BYTE1
<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (verbose &gt; 0)</span>
<span class="nc" id="L871">            Utils.log.info(&quot;  ...building &quot;+numFiles+&quot; files...&quot;);</span>
<span class="nc" id="L872">        file_name.expectLength(numFiles);</span>
<span class="nc" id="L873">        file_size_lo.expectLength(numFiles);</span>
<span class="nc" id="L874">        int options = archiveOptions;</span>
<span class="nc" id="L875">        boolean haveSizeHi  = testBit(options, AO_HAVE_FILE_SIZE_HI);</span>
<span class="nc" id="L876">        boolean haveModtime = testBit(options, AO_HAVE_FILE_MODTIME);</span>
<span class="nc" id="L877">        boolean haveOptions = testBit(options, AO_HAVE_FILE_OPTIONS);</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">        if (haveSizeHi)</span>
<span class="nc" id="L879">            file_size_hi.expectLength(numFiles);</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">        if (haveModtime)</span>
<span class="nc" id="L881">            file_modtime.expectLength(numFiles);</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">        if (haveOptions)</span>
<span class="nc" id="L883">            file_options.expectLength(numFiles);</span>

<span class="nc" id="L885">        file_name.readFrom(in);</span>
<span class="nc" id="L886">        file_size_hi.readFrom(in);</span>
<span class="nc" id="L887">        file_size_lo.readFrom(in);</span>
<span class="nc" id="L888">        file_modtime.readFrom(in);</span>
<span class="nc" id="L889">        file_options.readFrom(in);</span>
<span class="nc" id="L890">        file_bits.setInputStreamFrom(in);</span>

<span class="nc" id="L892">        Iterator&lt;Class&gt; nextClass = pkg.getClasses().iterator();</span>

        // Compute file lengths before reading any file bits.
<span class="nc" id="L895">        long totalFileLength = 0;</span>
<span class="nc" id="L896">        long[] fileLengths = new long[numFiles];</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">        for (int i = 0; i &lt; numFiles; i++) {</span>
<span class="nc" id="L898">            long size = ((long)file_size_lo.getInt() &lt;&lt; 32) &gt;&gt;&gt; 32;</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            if (haveSizeHi)</span>
<span class="nc" id="L900">                size += (long)file_size_hi.getInt() &lt;&lt; 32;</span>
<span class="nc" id="L901">            fileLengths[i] = size;</span>
<span class="nc" id="L902">            totalFileLength += size;</span>
        }
<span class="nc bnc" id="L904" title="All 6 branches missed.">        assert(in.getReadLimit() == -1 || in.getReadLimit() == totalFileLength);</span>

<span class="nc" id="L906">        byte[] buf = new byte[1&lt;&lt;16];</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">        for (int i = 0; i &lt; numFiles; i++) {</span>
            // %%% Use a big temp file for file bits?
<span class="nc" id="L909">            Utf8Entry name = (Utf8Entry) file_name.getRef();</span>
<span class="nc" id="L910">            long size = fileLengths[i];</span>
<span class="nc" id="L911">            File file = pkg.new File(name);</span>
<span class="nc" id="L912">            file.modtime = pkg.default_modtime;</span>
<span class="nc" id="L913">            file.options = pkg.default_options;</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">            if (haveModtime)</span>
<span class="nc" id="L915">                file.modtime += file_modtime.getInt();</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">            if (haveOptions)</span>
<span class="nc" id="L917">                file.options |= file_options.getInt();</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">            if (verbose &gt; 1)</span>
<span class="nc" id="L919">                Utils.log.fine(&quot;Reading &quot;+size+&quot; bytes of &quot;+name.stringValue());</span>
<span class="nc" id="L920">            long toRead = size;</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">            while (toRead &gt; 0) {</span>
<span class="nc" id="L922">                int nr = buf.length;</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">                if (nr &gt; toRead)  nr = (int) toRead;</span>
<span class="nc" id="L924">                nr = file_bits.getInputStream().read(buf, 0, nr);</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                if (nr &lt; 0)  throw new EOFException();</span>
<span class="nc" id="L926">                file.addBytes(buf, 0, nr);</span>
<span class="nc" id="L927">                toRead -= nr;</span>
<span class="nc" id="L928">            }</span>
<span class="nc" id="L929">            pkg.addFile(file);</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">            if (file.isClassStub()) {</span>
<span class="nc bnc" id="L931" title="All 4 branches missed.">                assert(file.getFileLength() == 0);</span>
<span class="nc" id="L932">                Class cls = nextClass.next();</span>
<span class="nc" id="L933">                cls.initFile(file);</span>
            }
        }

        // Do the rest of the classes.
<span class="nc bnc" id="L938" title="All 2 branches missed.">        while (nextClass.hasNext()) {</span>
<span class="nc" id="L939">            Class cls = nextClass.next();</span>
<span class="nc" id="L940">            cls.initFile(null);  // implicitly initialize to a trivial one</span>
<span class="nc" id="L941">            cls.file.modtime = pkg.default_modtime;</span>
<span class="nc" id="L942">        }</span>

<span class="nc" id="L944">        file_name.doneDisbursing();</span>
<span class="nc" id="L945">        file_size_hi.doneDisbursing();</span>
<span class="nc" id="L946">        file_size_lo.doneDisbursing();</span>
<span class="nc" id="L947">        file_modtime.doneDisbursing();</span>
<span class="nc" id="L948">        file_options.doneDisbursing();</span>
<span class="nc" id="L949">        file_bits.doneDisbursing();</span>
<span class="nc" id="L950">        file_bands.doneDisbursing();</span>

<span class="nc bnc" id="L952" title="All 4 branches missed.">        if (archiveSize1 != 0 &amp;&amp; !in.atLimit()) {</span>
<span class="nc" id="L953">            throw new RuntimeException(&quot;Predicted archive_size &quot;+</span>
                                       archiveSize1+&quot; != &quot;+
<span class="nc" id="L955">                                       (in.getBytesServed()-archiveSize0));</span>
        }
<span class="nc" id="L957">    }</span>

    void readAttrDefs() throws IOException {
        //  attr_definition_bands:
        //        *attr_definition_headers :BYTE1
        //        *attr_definition_name :UNSIGNED5  (cp_Utf8)
        //        *attr_definition_layout :UNSIGNED5  (cp_Utf8)
<span class="nc" id="L964">        attr_definition_headers.expectLength(numAttrDefs);</span>
<span class="nc" id="L965">        attr_definition_name.expectLength(numAttrDefs);</span>
<span class="nc" id="L966">        attr_definition_layout.expectLength(numAttrDefs);</span>
<span class="nc" id="L967">        attr_definition_headers.readFrom(in);</span>
<span class="nc" id="L968">        attr_definition_name.readFrom(in);</span>
<span class="nc" id="L969">        attr_definition_layout.readFrom(in);</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">        try (PrintStream dump = !optDumpBands ? null</span>
<span class="nc" id="L971">                 : new PrintStream(getDumpStream(attr_definition_headers, &quot;.def&quot;)))</span>
        {
<span class="nc bnc" id="L973" title="All 2 branches missed.">            for (int i = 0; i &lt; numAttrDefs; i++) {</span>
<span class="nc" id="L974">                int       header = attr_definition_headers.getByte();</span>
<span class="nc" id="L975">                Utf8Entry name   = (Utf8Entry) attr_definition_name.getRef();</span>
<span class="nc" id="L976">                Utf8Entry layout = (Utf8Entry) attr_definition_layout.getRef();</span>
<span class="nc" id="L977">                int       ctype  = (header &amp;  ADH_CONTEXT_MASK);</span>
<span class="nc" id="L978">                int       index  = (header &gt;&gt; ADH_BIT_SHIFT) - ADH_BIT_IS_LSB;</span>
<span class="nc" id="L979">                Attribute.Layout def = new Attribute.Layout(ctype,</span>
<span class="nc" id="L980">                                                            name.stringValue(),</span>
<span class="nc" id="L981">                                                            layout.stringValue());</span>
                // Check layout string for Java 6 extensions.
<span class="nc" id="L983">                String pvLayout = def.layoutForClassVersion(getHighestClassVersion());</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">                if (!pvLayout.equals(def.layout())) {</span>
<span class="nc" id="L985">                    throw new IOException(&quot;Bad attribute layout in archive: &quot;+def.layout());</span>
                }
<span class="nc" id="L987">                this.setAttributeLayoutIndex(def, index);</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">                if (dump != null)  dump.println(index+&quot; &quot;+def);</span>
            }
<span class="nc bnc" id="L990" title="All 8 branches missed.">        }</span>
<span class="nc" id="L991">        attr_definition_headers.doneDisbursing();</span>
<span class="nc" id="L992">        attr_definition_name.doneDisbursing();</span>
<span class="nc" id="L993">        attr_definition_layout.doneDisbursing();</span>
        // Attribute layouts define bands, one per layout element.
        // Create them now, all at once.
<span class="nc" id="L996">        makeNewAttributeBands();</span>
<span class="nc" id="L997">        attr_definition_bands.doneDisbursing();</span>
<span class="nc" id="L998">    }</span>

    void readInnerClasses() throws IOException {
        //  ic_bands:
        //        *ic_this_class :UDELTA5  (cp_Class)
        //        *ic_flags :UNSIGNED5
        //        *ic_outer_class :DELTA5  (null or cp_Class)
        //        *ic_name :DELTA5  (null or cp_Utf8)
<span class="nc" id="L1006">        ic_this_class.expectLength(numInnerClasses);</span>
<span class="nc" id="L1007">        ic_this_class.readFrom(in);</span>
<span class="nc" id="L1008">        ic_flags.expectLength(numInnerClasses);</span>
<span class="nc" id="L1009">        ic_flags.readFrom(in);</span>
<span class="nc" id="L1010">        int longICCount = 0;</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">        for (int i = 0; i &lt; numInnerClasses; i++) {</span>
<span class="nc" id="L1012">            int flags = ic_flags.getInt();</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">            boolean longForm = (flags &amp; ACC_IC_LONG_FORM) != 0;</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">            if (longForm) {</span>
<span class="nc" id="L1015">                longICCount += 1;</span>
            }
        }
<span class="nc" id="L1018">        ic_outer_class.expectLength(longICCount);</span>
<span class="nc" id="L1019">        ic_outer_class.readFrom(in);</span>
<span class="nc" id="L1020">        ic_name.expectLength(longICCount);</span>
<span class="nc" id="L1021">        ic_name.readFrom(in);</span>
<span class="nc" id="L1022">        ic_flags.resetForSecondPass();</span>
<span class="nc" id="L1023">        List&lt;InnerClass&gt; icList = new ArrayList&lt;&gt;(numInnerClasses);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">        for (int i = 0; i &lt; numInnerClasses; i++) {</span>
<span class="nc" id="L1025">            int flags = ic_flags.getInt();</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">            boolean longForm = (flags &amp; ACC_IC_LONG_FORM) != 0;</span>
<span class="nc" id="L1027">            flags &amp;= ~ACC_IC_LONG_FORM;</span>
<span class="nc" id="L1028">            ClassEntry thisClass = (ClassEntry) ic_this_class.getRef();</span>
            ClassEntry outerClass;
            Utf8Entry  thisName;
<span class="nc bnc" id="L1031" title="All 2 branches missed.">            if (longForm) {</span>
<span class="nc" id="L1032">                outerClass = (ClassEntry) ic_outer_class.getRef();</span>
<span class="nc" id="L1033">                thisName   = (Utf8Entry)  ic_name.getRef();</span>
            } else {
<span class="nc" id="L1035">                String n = thisClass.stringValue();</span>
<span class="nc" id="L1036">                String[] parse = Package.parseInnerClassName(n);</span>
<span class="nc bnc" id="L1037" title="All 4 branches missed.">                assert(parse != null);</span>
<span class="nc" id="L1038">                String pkgOuter = parse[0];</span>
                //String number = parse[1];
<span class="nc" id="L1040">                String name     = parse[2];</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">                if (pkgOuter == null)</span>
<span class="nc" id="L1042">                    outerClass = null;</span>
                else
<span class="nc" id="L1044">                    outerClass = ConstantPool.getClassEntry(pkgOuter);</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                if (name == null)</span>
<span class="nc" id="L1046">                    thisName   = null;</span>
                else
<span class="nc" id="L1048">                    thisName   = ConstantPool.getUtf8Entry(name);</span>
            }
<span class="nc" id="L1050">            InnerClass ic =</span>
                new InnerClass(thisClass, outerClass, thisName, flags);
<span class="nc bnc" id="L1052" title="All 6 branches missed.">            assert(longForm || ic.predictable);</span>
<span class="nc" id="L1053">            icList.add(ic);</span>
        }
<span class="nc" id="L1055">        ic_flags.doneDisbursing();</span>
<span class="nc" id="L1056">        ic_this_class.doneDisbursing();</span>
<span class="nc" id="L1057">        ic_outer_class.doneDisbursing();</span>
<span class="nc" id="L1058">        ic_name.doneDisbursing();</span>
<span class="nc" id="L1059">        pkg.setAllInnerClasses(icList);</span>
<span class="nc" id="L1060">        ic_bands.doneDisbursing();</span>
<span class="nc" id="L1061">    }</span>

    void readLocalInnerClasses(Class cls) throws IOException {
<span class="nc" id="L1064">        int nc = class_InnerClasses_N.getInt();</span>
<span class="nc" id="L1065">        List&lt;InnerClass&gt; localICs = new ArrayList&lt;&gt;(nc);</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">        for (int i = 0; i &lt; nc; i++) {</span>
<span class="nc" id="L1067">            ClassEntry thisClass = (ClassEntry) class_InnerClasses_RC.getRef();</span>
<span class="nc" id="L1068">            int        flags     =              class_InnerClasses_F.getInt();</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">            if (flags == 0) {</span>
                // A zero flag means copy a global IC here.
<span class="nc" id="L1071">                InnerClass ic = pkg.getGlobalInnerClass(thisClass);</span>
<span class="nc bnc" id="L1072" title="All 4 branches missed.">                assert(ic != null);  // must be a valid global IC reference</span>
<span class="nc" id="L1073">                localICs.add(ic);</span>
<span class="nc" id="L1074">            } else {</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">                if (flags == ACC_IC_LONG_FORM)</span>
<span class="nc" id="L1076">                    flags = 0;  // clear the marker bit</span>
<span class="nc" id="L1077">                ClassEntry outer = (ClassEntry) class_InnerClasses_outer_RCN.getRef();</span>
<span class="nc" id="L1078">                Utf8Entry name   = (Utf8Entry)  class_InnerClasses_name_RUN.getRef();</span>
<span class="nc" id="L1079">                localICs.add(new InnerClass(thisClass, outer, name, flags));</span>
            }
        }
<span class="nc" id="L1082">        cls.setInnerClasses(localICs);</span>
        // cls.expandLocalICs may add more tuples to ics also,
        // or may even delete tuples.
        // We cannot do that now, because we do not know the
        // full contents of the local constant pool yet.
<span class="nc" id="L1087">    }</span>

    static final int NO_FLAGS_YET = 0;  // placeholder for later flag read-in

    Class[] readClasses() throws IOException {
        //  class_bands:
        //        *class_this :DELTA5  (cp_Class)
        //        *class_super :DELTA5  (cp_Class)
        //        *class_interface_count :DELTA5
        //        *class_interface :DELTA5  (cp_Class)
        //        ...(member bands)...
        //        class_attr_bands
        //        code_bands
<span class="nc" id="L1100">        Class[] classes = new Class[numClasses];</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        if (verbose &gt; 0)</span>
<span class="nc" id="L1102">            Utils.log.info(&quot;  ...building &quot;+classes.length+&quot; classes...&quot;);</span>

<span class="nc" id="L1104">        class_this.expectLength(numClasses);</span>
<span class="nc" id="L1105">        class_super.expectLength(numClasses);</span>
<span class="nc" id="L1106">        class_interface_count.expectLength(numClasses);</span>

<span class="nc" id="L1108">        class_this.readFrom(in);</span>
<span class="nc" id="L1109">        class_super.readFrom(in);</span>
<span class="nc" id="L1110">        class_interface_count.readFrom(in);</span>
<span class="nc" id="L1111">        class_interface.expectLength(class_interface_count.getIntTotal());</span>
<span class="nc" id="L1112">        class_interface.readFrom(in);</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">        for (int i = 0; i &lt; classes.length; i++) {</span>
<span class="nc" id="L1114">            ClassEntry   thisClass  = (ClassEntry) class_this.getRef();</span>
<span class="nc" id="L1115">            ClassEntry   superClass = (ClassEntry) class_super.getRef();</span>
<span class="nc" id="L1116">            ClassEntry[] interfaces = new ClassEntry[class_interface_count.getInt()];</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">            for (int j = 0; j &lt; interfaces.length; j++) {</span>
<span class="nc" id="L1118">                interfaces[j] = (ClassEntry) class_interface.getRef();</span>
            }
            // Packer encoded rare case of null superClass as thisClass:
<span class="nc bnc" id="L1121" title="All 2 branches missed.">            if (superClass == thisClass)  superClass = null;</span>
<span class="nc" id="L1122">            Class cls = pkg.new Class(NO_FLAGS_YET,</span>
                                      thisClass, superClass, interfaces);
<span class="nc" id="L1124">            classes[i] = cls;</span>
        }
<span class="nc" id="L1126">        class_this.doneDisbursing();</span>
<span class="nc" id="L1127">        class_super.doneDisbursing();</span>
<span class="nc" id="L1128">        class_interface_count.doneDisbursing();</span>
<span class="nc" id="L1129">        class_interface.doneDisbursing();</span>
<span class="nc" id="L1130">        readMembers(classes);</span>
<span class="nc" id="L1131">        countAndReadAttrs(ATTR_CONTEXT_CLASS, Arrays.asList(classes));</span>
<span class="nc" id="L1132">        pkg.trimToSize();</span>
<span class="nc" id="L1133">        readCodeHeaders();</span>
        //code_bands.doneDisbursing(); // still need to read code attrs
        //class_bands.doneDisbursing(); // still need to read code attrs
<span class="nc" id="L1136">        return classes;</span>
    }

    private int getOutputIndex(Entry e) {
        // Output CPs do not contain signatures.
<span class="nc bnc" id="L1141" title="All 4 branches missed.">        assert(e.tag != CONSTANT_Signature);</span>
<span class="nc" id="L1142">        int k = pkg.cp.untypedIndexOf(e);</span>
        // In the output ordering, input signatures can serve
        // in place of Utf8s.
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        if (k &gt;= 0)</span>
<span class="nc" id="L1146">            return k;</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        if (e.tag == CONSTANT_Utf8) {</span>
<span class="nc" id="L1148">            Entry se = utf8Signatures.get(e);</span>
<span class="nc" id="L1149">            return pkg.cp.untypedIndexOf(se);</span>
        }
<span class="nc" id="L1151">        return -1;</span>
    }

<span class="nc" id="L1154">    Comparator&lt;Entry&gt; entryOutputOrder = new Comparator&lt;Entry&gt;() {</span>
        public int compare(Entry e0, Entry e1) {
<span class="nc" id="L1156">            int k0 = getOutputIndex(e0);</span>
<span class="nc" id="L1157">            int k1 = getOutputIndex(e1);</span>
<span class="nc bnc" id="L1158" title="All 4 branches missed.">            if (k0 &gt;= 0 &amp;&amp; k1 &gt;= 0)</span>
                // If both have keys, use the keys.
<span class="nc" id="L1160">                return k0 - k1;</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">            if (k0 == k1)</span>
                // If neither have keys, use their native tags &amp; spellings.
<span class="nc" id="L1163">                return e0.compareTo(e1);</span>
            // Otherwise, the guy with the key comes first.
<span class="nc bnc" id="L1165" title="All 2 branches missed.">            return (k0 &gt;= 0)? 0-1: 1-0;</span>
        }
    };

    void reconstructClass(Class cls) {
<span class="nc bnc" id="L1170" title="All 2 branches missed.">        if (verbose &gt; 1)  Utils.log.fine(&quot;reconstruct &quot;+cls);</span>

        // check for local .ClassFile.version
<span class="nc" id="L1173">        Attribute retroVersion = cls.getAttribute(attrClassFileVersion);</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">        if (retroVersion != null) {</span>
<span class="nc" id="L1175">            cls.removeAttribute(retroVersion);</span>
<span class="nc" id="L1176">            cls.version = parseClassFileVersionAttr(retroVersion);</span>
        } else {
<span class="nc" id="L1178">            cls.version = pkg.defaultClassVersion;</span>
        }

        // Replace null SourceFile by &quot;obvious&quot; string.
<span class="nc" id="L1182">        cls.expandSourceFile();</span>

        // record the local cp:
<span class="nc" id="L1185">        cls.setCPMap(reconstructLocalCPMap(cls));</span>
<span class="nc" id="L1186">    }</span>

    Entry[] reconstructLocalCPMap(Class cls) {
<span class="nc" id="L1189">        Set&lt;Entry&gt; ldcRefs = ldcRefMap.get(cls);</span>
<span class="nc" id="L1190">        Set&lt;Entry&gt; cpRefs = new HashSet&lt;&gt;();</span>

        // look for constant pool entries:
<span class="nc" id="L1193">        cls.visitRefs(VRM_CLASSIC, cpRefs);</span>

<span class="nc" id="L1195">        ArrayList&lt;BootstrapMethodEntry&gt; bsms = new ArrayList&lt;&gt;();</span>
        /*
         * BootstrapMethod(BSMs) are added here before InnerClasses(ICs),
         * so as to ensure the order. Noting that the BSMs  may be
         * removed if they are not found in the CP, after the ICs expansion.
         */
<span class="nc" id="L1201">        cls.addAttribute(Package.attrBootstrapMethodsEmpty.canonicalInstance());</span>

        // flesh out the local constant pool
<span class="nc" id="L1204">        ConstantPool.completeReferencesIn(cpRefs, true, bsms);</span>

        // Now that we know all our local class references,
        // compute the InnerClasses attribute.
<span class="nc" id="L1208">        int changed = cls.expandLocalICs();</span>

<span class="nc bnc" id="L1210" title="All 2 branches missed.">        if (changed != 0) {</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">            if (changed &gt; 0) {</span>
                // Just visit the expanded InnerClasses attr.
<span class="nc" id="L1213">                cls.visitInnerClassRefs(VRM_CLASSIC, cpRefs);</span>
            } else {
                // Have to recompute from scratch, because of deletions.
<span class="nc" id="L1216">                cpRefs.clear();</span>
<span class="nc" id="L1217">                cls.visitRefs(VRM_CLASSIC, cpRefs);</span>
            }

            // flesh out the local constant pool, again
<span class="nc" id="L1221">            ConstantPool.completeReferencesIn(cpRefs, true, bsms);</span>
        }

        // remove the attr previously set, otherwise add the bsm and
        // references as required
<span class="nc bnc" id="L1226" title="All 2 branches missed.">        if (bsms.isEmpty()) {</span>
<span class="nc" id="L1227">            cls.attributes.remove(Package.attrBootstrapMethodsEmpty.canonicalInstance());</span>
        } else {
<span class="nc" id="L1229">            cpRefs.add(Package.getRefString(&quot;BootstrapMethods&quot;));</span>
<span class="nc" id="L1230">            Collections.sort(bsms);</span>
<span class="nc" id="L1231">            cls.setBootstrapMethods(bsms);</span>
        }

        // construct a local constant pool
<span class="nc" id="L1235">        int numDoubles = 0;</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">        for (Entry e : cpRefs) {</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">            if (e.isDoubleWord())  numDoubles++;</span>
<span class="nc" id="L1238">        }</span>
<span class="nc" id="L1239">        Entry[] cpMap = new Entry[1+numDoubles+cpRefs.size()];</span>
<span class="nc" id="L1240">        int fillp = 1;</span>

        // Add all ldc operands first.
<span class="nc bnc" id="L1243" title="All 2 branches missed.">        if (ldcRefs != null) {</span>
<span class="nc bnc" id="L1244" title="All 4 branches missed.">            assert(cpRefs.containsAll(ldcRefs));</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">            for (Entry e : ldcRefs) {</span>
<span class="nc" id="L1246">                cpMap[fillp++] = e;</span>
<span class="nc" id="L1247">            }</span>
<span class="nc bnc" id="L1248" title="All 4 branches missed.">            assert(fillp == 1+ldcRefs.size());</span>
<span class="nc" id="L1249">            cpRefs.removeAll(ldcRefs);</span>
<span class="nc" id="L1250">            ldcRefs = null;  // done with it</span>
        }

        // Next add all the two-byte references.
<span class="nc" id="L1254">        Set&lt;Entry&gt; wideRefs = cpRefs;</span>
<span class="nc" id="L1255">        cpRefs = null;  // do not use!</span>
<span class="nc" id="L1256">        int narrowLimit = fillp;</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">        for (Entry e : wideRefs) {</span>
<span class="nc" id="L1258">            cpMap[fillp++] = e;</span>
<span class="nc" id="L1259">        }</span>
<span class="nc bnc" id="L1260" title="All 4 branches missed.">        assert(fillp == narrowLimit+wideRefs.size());</span>
<span class="nc" id="L1261">        Arrays.sort(cpMap, 1, narrowLimit, entryOutputOrder);</span>
<span class="nc" id="L1262">        Arrays.sort(cpMap, narrowLimit, fillp, entryOutputOrder);</span>

<span class="nc bnc" id="L1264" title="All 2 branches missed.">        if (verbose &gt; 3) {</span>
<span class="nc" id="L1265">            Utils.log.fine(&quot;CP of &quot;+this+&quot; {&quot;);</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">            for (int i = 0; i &lt; fillp; i++) {</span>
<span class="nc" id="L1267">                Entry e = cpMap[i];</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">                Utils.log.fine(&quot;  &quot;+((e==null)?-1:getOutputIndex(e))</span>
                                   +&quot; : &quot;+e);
            }
<span class="nc" id="L1271">            Utils.log.fine(&quot;}&quot;);</span>
        }

        // Now repack backwards, introducing null elements.
<span class="nc" id="L1275">        int revp = cpMap.length;</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">        for (int i = fillp; --i &gt;= 1; ) {</span>
<span class="nc" id="L1277">            Entry e = cpMap[i];</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">            if (e.isDoubleWord())</span>
<span class="nc" id="L1279">                cpMap[--revp] = null;</span>
<span class="nc" id="L1280">            cpMap[--revp] = e;</span>
<span class="nc" id="L1281">        }</span>
<span class="nc bnc" id="L1282" title="All 4 branches missed.">        assert(revp == 1);  // do not process the initial null</span>

<span class="nc" id="L1284">        return cpMap;</span>
    }

    void readMembers(Class[] classes) throws IOException {
        //  class_bands:
        //        ...
        //        *class_field_count :DELTA5
        //        *class_method_count :DELTA5
        //
        //        *field_descr :DELTA5  (cp_Descr)
        //        field_attr_bands
        //
        //        *method_descr :MDELTA5  (cp_Descr)
        //        method_attr_bands
        //        ...
<span class="nc bnc" id="L1299" title="All 4 branches missed.">        assert(classes.length == numClasses);</span>
<span class="nc" id="L1300">        class_field_count.expectLength(numClasses);</span>
<span class="nc" id="L1301">        class_method_count.expectLength(numClasses);</span>
<span class="nc" id="L1302">        class_field_count.readFrom(in);</span>
<span class="nc" id="L1303">        class_method_count.readFrom(in);</span>

        // Make a pre-pass over field and method counts to size the descrs:
<span class="nc" id="L1306">        int totalNF = class_field_count.getIntTotal();</span>
<span class="nc" id="L1307">        int totalNM = class_method_count.getIntTotal();</span>
<span class="nc" id="L1308">        field_descr.expectLength(totalNF);</span>
<span class="nc" id="L1309">        method_descr.expectLength(totalNM);</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">        if (verbose &gt; 1)  Utils.log.fine(&quot;expecting #fields=&quot;+totalNF+</span>
                &quot; and #methods=&quot;+totalNM+&quot; in #classes=&quot;+numClasses);

<span class="nc" id="L1313">        List&lt;Class.Field&gt; fields = new ArrayList&lt;&gt;(totalNF);</span>
<span class="nc" id="L1314">        field_descr.readFrom(in);</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">        for (int i = 0; i &lt; classes.length; i++) {</span>
<span class="nc" id="L1316">            Class c = classes[i];</span>
<span class="nc" id="L1317">            int nf = class_field_count.getInt();</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">            for (int j = 0; j &lt; nf; j++) {</span>
<span class="nc" id="L1319">                Class.Field f = c.new Field(NO_FLAGS_YET, (DescriptorEntry)</span>
<span class="nc" id="L1320">                                            field_descr.getRef());</span>
<span class="nc" id="L1321">                fields.add(f);</span>
            }
        }
<span class="nc" id="L1324">        class_field_count.doneDisbursing();</span>
<span class="nc" id="L1325">        field_descr.doneDisbursing();</span>
<span class="nc" id="L1326">        countAndReadAttrs(ATTR_CONTEXT_FIELD, fields);</span>
<span class="nc" id="L1327">        fields = null;  // release to GC</span>

<span class="nc" id="L1329">        List&lt;Class.Method&gt; methods = new ArrayList&lt;&gt;(totalNM);</span>
<span class="nc" id="L1330">        method_descr.readFrom(in);</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">        for (int i = 0; i &lt; classes.length; i++) {</span>
<span class="nc" id="L1332">            Class c = classes[i];</span>
<span class="nc" id="L1333">            int nm = class_method_count.getInt();</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">            for (int j = 0; j &lt; nm; j++) {</span>
<span class="nc" id="L1335">                Class.Method m = c.new Method(NO_FLAGS_YET, (DescriptorEntry)</span>
<span class="nc" id="L1336">                                              method_descr.getRef());</span>
<span class="nc" id="L1337">                methods.add(m);</span>
            }
        }
<span class="nc" id="L1340">        class_method_count.doneDisbursing();</span>
<span class="nc" id="L1341">        method_descr.doneDisbursing();</span>
<span class="nc" id="L1342">        countAndReadAttrs(ATTR_CONTEXT_METHOD, methods);</span>

        // Up to this point, Code attributes look like empty attributes.
        // Now we start to special-case them.  The empty canonical Code
        // attributes stay in the method attribute lists, however.
<span class="nc" id="L1347">        allCodes = buildCodeAttrs(methods);</span>
<span class="nc" id="L1348">    }</span>

    Code[] allCodes;
    List&lt;Code&gt; codesWithFlags;
<span class="nc" id="L1352">    Map&lt;Class, Set&lt;Entry&gt;&gt; ldcRefMap = new HashMap&lt;&gt;();</span>

    Code[] buildCodeAttrs(List&lt;Class.Method&gt; methods) {
<span class="nc" id="L1355">        List&lt;Code&gt; codes = new ArrayList&lt;&gt;(methods.size());</span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">        for (Class.Method m : methods) {</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">            if (m.getAttribute(attrCodeEmpty) != null) {</span>
<span class="nc" id="L1358">                m.code = new Code(m);</span>
<span class="nc" id="L1359">                codes.add(m.code);</span>
            }
<span class="nc" id="L1361">        }</span>
<span class="nc" id="L1362">        Code[] a = new Code[codes.size()];</span>
<span class="nc" id="L1363">        codes.toArray(a);</span>
<span class="nc" id="L1364">        return a;</span>
    }

    void readCodeHeaders() throws IOException {
        //  code_bands:
        //        *code_headers :BYTE1
        //
        //        *code_max_stack :UNSIGNED5
        //        *code_max_na_locals :UNSIGNED5
        //        *code_handler_count :UNSIGNED5
        //        ...
        //        code_attr_bands
<span class="nc" id="L1376">        boolean attrsOK = testBit(archiveOptions, AO_HAVE_ALL_CODE_FLAGS);</span>
<span class="nc" id="L1377">        code_headers.expectLength(allCodes.length);</span>
<span class="nc" id="L1378">        code_headers.readFrom(in);</span>
<span class="nc" id="L1379">        List&lt;Code&gt; longCodes = new ArrayList&lt;&gt;(allCodes.length / 10);</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        for (int i = 0; i &lt; allCodes.length; i++) {</span>
<span class="nc" id="L1381">            Code c = allCodes[i];</span>
<span class="nc" id="L1382">            int sc = code_headers.getByte();</span>
<span class="nc bnc" id="L1383" title="All 4 branches missed.">            assert(sc == (sc &amp; 0xFF));</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">            if (verbose &gt; 2)</span>
<span class="nc" id="L1385">                Utils.log.fine(&quot;codeHeader &quot;+c+&quot; = &quot;+sc);</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">            if (sc == LONG_CODE_HEADER) {</span>
                // We will read ms/ml/nh/flags from bands shortly.
<span class="nc" id="L1388">                longCodes.add(c);</span>
<span class="nc" id="L1389">                continue;</span>
            }
            // Short code header is the usual case:
<span class="nc" id="L1392">            c.setMaxStack(     shortCodeHeader_max_stack(sc) );</span>
<span class="nc" id="L1393">            c.setMaxNALocals(  shortCodeHeader_max_na_locals(sc) );</span>
<span class="nc" id="L1394">            c.setHandlerCount( shortCodeHeader_handler_count(sc) );</span>
<span class="nc bnc" id="L1395" title="All 4 branches missed.">            assert(shortCodeHeader(c) == sc);</span>
        }
<span class="nc" id="L1397">        code_headers.doneDisbursing();</span>
<span class="nc" id="L1398">        code_max_stack.expectLength(longCodes.size());</span>
<span class="nc" id="L1399">        code_max_na_locals.expectLength(longCodes.size());</span>
<span class="nc" id="L1400">        code_handler_count.expectLength(longCodes.size());</span>

        // Do the long headers now.
<span class="nc" id="L1403">        code_max_stack.readFrom(in);</span>
<span class="nc" id="L1404">        code_max_na_locals.readFrom(in);</span>
<span class="nc" id="L1405">        code_handler_count.readFrom(in);</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">        for (Code c : longCodes) {</span>
<span class="nc" id="L1407">            c.setMaxStack(     code_max_stack.getInt() );</span>
<span class="nc" id="L1408">            c.setMaxNALocals(  code_max_na_locals.getInt() );</span>
<span class="nc" id="L1409">            c.setHandlerCount( code_handler_count.getInt() );</span>
<span class="nc" id="L1410">        }</span>
<span class="nc" id="L1411">        code_max_stack.doneDisbursing();</span>
<span class="nc" id="L1412">        code_max_na_locals.doneDisbursing();</span>
<span class="nc" id="L1413">        code_handler_count.doneDisbursing();</span>

<span class="nc" id="L1415">        readCodeHandlers();</span>

<span class="nc bnc" id="L1417" title="All 2 branches missed.">        if (attrsOK) {</span>
            // Code attributes are common (debug info not stripped).
<span class="nc" id="L1419">            codesWithFlags = Arrays.asList(allCodes);</span>
        } else {
            // Code attributes are very sparse (debug info is stripped).
<span class="nc" id="L1422">            codesWithFlags = longCodes;</span>
        }
<span class="nc" id="L1424">        countAttrs(ATTR_CONTEXT_CODE, codesWithFlags);</span>
        // do readAttrs later, after BCs are scanned
<span class="nc" id="L1426">    }</span>

    void readCodeHandlers() throws IOException {
        //  code_bands:
        //        ...
        //        *code_handler_start_P :BCI5
        //        *code_handler_end_PO :BRANCH5
        //        *code_handler_catch_PO :BRANCH5
        //        *code_handler_class_RCN :UNSIGNED5  (null or cp_Class)
        //        ...
<span class="nc" id="L1436">        int nh = 0;</span>
<span class="nc bnc" id="L1437" title="All 2 branches missed.">        for (int i = 0; i &lt; allCodes.length; i++) {</span>
<span class="nc" id="L1438">            Code c = allCodes[i];</span>
<span class="nc" id="L1439">            nh += c.getHandlerCount();</span>
        }

<span class="nc" id="L1442">        ValueBand[] code_handler_bands = {</span>
            code_handler_start_P,
            code_handler_end_PO,
            code_handler_catch_PO,
            code_handler_class_RCN
        };

<span class="nc bnc" id="L1449" title="All 2 branches missed.">        for (int i = 0; i &lt; code_handler_bands.length; i++) {</span>
<span class="nc" id="L1450">            code_handler_bands[i].expectLength(nh);</span>
<span class="nc" id="L1451">            code_handler_bands[i].readFrom(in);</span>
        }

<span class="nc bnc" id="L1454" title="All 2 branches missed.">        for (int i = 0; i &lt; allCodes.length; i++) {</span>
<span class="nc" id="L1455">            Code c = allCodes[i];</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">            for (int j = 0, jmax = c.getHandlerCount(); j &lt; jmax; j++) {</span>
<span class="nc" id="L1457">                c.handler_class[j] = code_handler_class_RCN.getRef();</span>
                // For now, just record the raw BCI codes.
                // We must wait until we have instruction boundaries.
<span class="nc" id="L1460">                c.handler_start[j] = code_handler_start_P.getInt();</span>
<span class="nc" id="L1461">                c.handler_end[j]   = code_handler_end_PO.getInt();</span>
<span class="nc" id="L1462">                c.handler_catch[j] = code_handler_catch_PO.getInt();</span>
            }
        }
<span class="nc bnc" id="L1465" title="All 2 branches missed.">        for (int i = 0; i &lt; code_handler_bands.length; i++) {</span>
<span class="nc" id="L1466">            code_handler_bands[i].doneDisbursing();</span>
        }
<span class="nc" id="L1468">    }</span>

    void fixupCodeHandlers() {
        // Actually decode (renumber) the BCIs now.
<span class="nc bnc" id="L1472" title="All 2 branches missed.">        for (int i = 0; i &lt; allCodes.length; i++) {</span>
<span class="nc" id="L1473">            Code c = allCodes[i];</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">            for (int j = 0, jmax = c.getHandlerCount(); j &lt; jmax; j++) {</span>
<span class="nc" id="L1475">                int sum = c.handler_start[j];</span>
<span class="nc" id="L1476">                c.handler_start[j] = c.decodeBCI(sum);</span>
<span class="nc" id="L1477">                sum += c.handler_end[j];</span>
<span class="nc" id="L1478">                c.handler_end[j]   = c.decodeBCI(sum);</span>
<span class="nc" id="L1479">                sum += c.handler_catch[j];</span>
<span class="nc" id="L1480">                c.handler_catch[j] = c.decodeBCI(sum);</span>
            }
        }
<span class="nc" id="L1483">    }</span>

    // Generic routines for reading attributes of
    // classes, fields, methods, and codes.
    // The holders is a global list, already collected,
    // of attribute &quot;customers&quot;.
    void countAndReadAttrs(int ctype, Collection&lt;? extends Attribute.Holder&gt; holders)
            throws IOException {
        //  class_attr_bands:
        //        *class_flags :UNSIGNED5
        //        *class_attr_count :UNSIGNED5
        //        *class_attr_indexes :UNSIGNED5
        //        *class_attr_calls :UNSIGNED5
        //        *class_Signature_RS :UNSIGNED5 (cp_Signature)
        //        class_metadata_bands
        //        *class_SourceFile_RU :UNSIGNED5 (cp_Utf8)
        //        *class_EnclosingMethod_RM :UNSIGNED5 (cp_Method)
        //        ic_local_bands
        //        *class_ClassFile_version_minor_H :UNSIGNED5
        //        *class_ClassFile_version_major_H :UNSIGNED5
        //        class_type_metadata_bands
        //
        //  field_attr_bands:
        //        *field_flags :UNSIGNED5
        //        *field_attr_count :UNSIGNED5
        //        *field_attr_indexes :UNSIGNED5
        //        *field_attr_calls :UNSIGNED5
        //        *field_Signature_RS :UNSIGNED5 (cp_Signature)
        //        field_metadata_bands
        //        *field_ConstantValue_KQ :UNSIGNED5 (cp_Int, etc.; see note)
        //        field_type_metadata_bands
        //
        //  method_attr_bands:
        //        *method_flags :UNSIGNED5
        //        *method_attr_count :UNSIGNED5
        //        *method_attr_indexes :UNSIGNED5
        //        *method_attr_calls :UNSIGNED5
        //        *method_Signature_RS :UNSIGNED5 (cp_Signature)
        //        method_metadata_bands
        //        *method_Exceptions_N :UNSIGNED5
        //        *method_Exceptions_RC :UNSIGNED5  (cp_Class)
        //        *method_MethodParameters_NB: BYTE1
        //        *method_MethodParameters_RUN: UNSIGNED5 (cp_Utf8)
        //        *method_MethodParameters_FH:  UNSIGNED5 (flag)
        //        method_type_metadata_bands
        //
        //  code_attr_bands:
        //        *code_flags :UNSIGNED5
        //        *code_attr_count :UNSIGNED5
        //        *code_attr_indexes :UNSIGNED5
        //        *code_attr_calls :UNSIGNED5
        //        *code_LineNumberTable_N :UNSIGNED5
        //        *code_LineNumberTable_bci_P :BCI5
        //        *code_LineNumberTable_line :UNSIGNED5
        //        *code_LocalVariableTable_N :UNSIGNED5
        //        *code_LocalVariableTable_bci_P :BCI5
        //        *code_LocalVariableTable_span_O :BRANCH5
        //        *code_LocalVariableTable_name_RU :UNSIGNED5 (cp_Utf8)
        //        *code_LocalVariableTable_type_RS :UNSIGNED5 (cp_Signature)
        //        *code_LocalVariableTable_slot :UNSIGNED5
        //        code_type_metadata_bands

<span class="nc" id="L1545">        countAttrs(ctype, holders);</span>
<span class="nc" id="L1546">        readAttrs(ctype, holders);</span>
<span class="nc" id="L1547">    }</span>

    // Read flags and count the attributes that are to be placed
    // on the given holders.
    void countAttrs(int ctype, Collection&lt;? extends Attribute.Holder&gt; holders)
            throws IOException {
        // Here, xxx stands for one of class, field, method, code.
<span class="nc" id="L1554">        MultiBand xxx_attr_bands = attrBands[ctype];</span>
<span class="nc" id="L1555">        long flagMask = attrFlagMask[ctype];</span>
<span class="nc bnc" id="L1556" title="All 2 branches missed.">        if (verbose &gt; 1) {</span>
<span class="nc" id="L1557">            Utils.log.fine(&quot;scanning flags and attrs for &quot;+</span>
<span class="nc" id="L1558">                    Attribute.contextName(ctype)+&quot;[&quot;+holders.size()+&quot;]&quot;);</span>
        }

        // Fetch the attribute layout definitions which govern the bands
        // we are about to read.
<span class="nc" id="L1563">        List&lt;Attribute.Layout&gt; defList = attrDefs.get(ctype);</span>
<span class="nc" id="L1564">        Attribute.Layout[] defs = new Attribute.Layout[defList.size()];</span>
<span class="nc" id="L1565">        defList.toArray(defs);</span>
<span class="nc" id="L1566">        IntBand xxx_flags_hi = getAttrBand(xxx_attr_bands, AB_FLAGS_HI);</span>
<span class="nc" id="L1567">        IntBand xxx_flags_lo = getAttrBand(xxx_attr_bands, AB_FLAGS_LO);</span>
<span class="nc" id="L1568">        IntBand xxx_attr_count = getAttrBand(xxx_attr_bands, AB_ATTR_COUNT);</span>
<span class="nc" id="L1569">        IntBand xxx_attr_indexes = getAttrBand(xxx_attr_bands, AB_ATTR_INDEXES);</span>
<span class="nc" id="L1570">        IntBand xxx_attr_calls = getAttrBand(xxx_attr_bands, AB_ATTR_CALLS);</span>

        // Count up the number of holders which have overflow attrs.
<span class="nc" id="L1573">        int overflowMask = attrOverflowMask[ctype];</span>
<span class="nc" id="L1574">        int overflowHolderCount = 0;</span>
<span class="nc" id="L1575">        boolean haveLongFlags = haveFlagsHi(ctype);</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">        xxx_flags_hi.expectLength(haveLongFlags? holders.size(): 0);</span>
<span class="nc" id="L1577">        xxx_flags_hi.readFrom(in);</span>
<span class="nc" id="L1578">        xxx_flags_lo.expectLength(holders.size());</span>
<span class="nc" id="L1579">        xxx_flags_lo.readFrom(in);</span>
<span class="nc bnc" id="L1580" title="All 4 branches missed.">        assert((flagMask &amp; overflowMask) == overflowMask);</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">        for (Attribute.Holder h : holders) {</span>
<span class="nc" id="L1582">            int flags = xxx_flags_lo.getInt();</span>
<span class="nc" id="L1583">            h.flags = flags;</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">            if ((flags &amp; overflowMask) != 0)</span>
<span class="nc" id="L1585">                overflowHolderCount += 1;</span>
<span class="nc" id="L1586">        }</span>

        // For each holder with overflow attrs, read a count.
<span class="nc" id="L1589">        xxx_attr_count.expectLength(overflowHolderCount);</span>
<span class="nc" id="L1590">        xxx_attr_count.readFrom(in);</span>
<span class="nc" id="L1591">        xxx_attr_indexes.expectLength(xxx_attr_count.getIntTotal());</span>
<span class="nc" id="L1592">        xxx_attr_indexes.readFrom(in);</span>

        // Now it's time to check flag bits that indicate attributes.
        // We accumulate (a) a list of attribute types for each holder
        // (class/field/method/code), and also we accumulate (b) a total
        // count for each attribute type.
<span class="nc" id="L1598">        int[] totalCounts = new int[defs.length];</span>
<span class="nc bnc" id="L1599" title="All 2 branches missed.">        for (Attribute.Holder h : holders) {</span>
<span class="nc bnc" id="L1600" title="All 4 branches missed.">            assert(h.attributes == null);</span>
            // System.out.println(&quot;flags=&quot;+h.flags+&quot; using fm=&quot;+flagMask);
<span class="nc" id="L1602">            long attrBits = ((h.flags &amp; flagMask) &lt;&lt; 32) &gt;&gt;&gt; 32;</span>
            // Clean up the flags now.
<span class="nc" id="L1604">            h.flags -= (int)attrBits;   // strip attr bits</span>
<span class="nc bnc" id="L1605" title="All 4 branches missed.">            assert(h.flags == (char)h.flags);  // 16 bits only now</span>
<span class="nc bnc" id="L1606" title="All 6 branches missed.">            assert((ctype != ATTR_CONTEXT_CODE) || h.flags == 0);</span>
<span class="nc bnc" id="L1607" title="All 2 branches missed.">            if (haveLongFlags)</span>
<span class="nc" id="L1608">                attrBits += (long)xxx_flags_hi.getInt() &lt;&lt; 32;</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">            if (attrBits == 0)  continue;  // no attrs on this guy</span>

<span class="nc" id="L1611">            int noa = 0;  // number of overflow attrs</span>
<span class="nc" id="L1612">            long overflowBit = (attrBits &amp; overflowMask);</span>
<span class="nc bnc" id="L1613" title="All 4 branches missed.">            assert(overflowBit &gt;= 0);</span>
<span class="nc" id="L1614">            attrBits -= overflowBit;</span>
<span class="nc bnc" id="L1615" title="All 2 branches missed.">            if (overflowBit != 0) {</span>
<span class="nc" id="L1616">                noa = xxx_attr_count.getInt();</span>
            }

<span class="nc" id="L1619">            int nfa = 0;  // number of flag attrs</span>
<span class="nc" id="L1620">            long bits = attrBits;</span>
<span class="nc bnc" id="L1621" title="All 2 branches missed.">            for (int ai = 0; bits != 0; ai++) {</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">                if ((bits &amp; (1L&lt;&lt;ai)) == 0)  continue;</span>
<span class="nc" id="L1623">                bits -= (1L&lt;&lt;ai);</span>
<span class="nc" id="L1624">                nfa += 1;</span>
            }
<span class="nc" id="L1626">            List&lt;Attribute&gt; ha = new ArrayList&lt;&gt;(nfa + noa);</span>
<span class="nc" id="L1627">            h.attributes = ha;</span>
<span class="nc" id="L1628">            bits = attrBits;  // iterate again</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">            for (int ai = 0; bits != 0; ai++) {</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">                if ((bits &amp; (1L&lt;&lt;ai)) == 0)  continue;</span>
<span class="nc" id="L1631">                bits -= (1L&lt;&lt;ai);</span>
<span class="nc" id="L1632">                totalCounts[ai] += 1;</span>
                // This definition index is live in this holder.
<span class="nc bnc" id="L1634" title="All 2 branches missed.">                if (defs[ai] == null)  badAttrIndex(ai, ctype);</span>
<span class="nc" id="L1635">                Attribute canonical = defs[ai].canonicalInstance();</span>
<span class="nc" id="L1636">                ha.add(canonical);</span>
<span class="nc" id="L1637">                nfa -= 1;</span>
            }
<span class="nc bnc" id="L1639" title="All 4 branches missed.">            assert(nfa == 0);</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">            for (; noa &gt; 0; noa--) {</span>
<span class="nc" id="L1641">                int ai = xxx_attr_indexes.getInt();</span>
<span class="nc" id="L1642">                totalCounts[ai] += 1;</span>
                // This definition index is live in this holder.
<span class="nc bnc" id="L1644" title="All 2 branches missed.">                if (defs[ai] == null)  badAttrIndex(ai, ctype);</span>
<span class="nc" id="L1645">                Attribute canonical = defs[ai].canonicalInstance();</span>
<span class="nc" id="L1646">                ha.add(canonical);</span>
            }
<span class="nc" id="L1648">        }</span>

<span class="nc" id="L1650">        xxx_flags_hi.doneDisbursing();</span>
<span class="nc" id="L1651">        xxx_flags_lo.doneDisbursing();</span>
<span class="nc" id="L1652">        xxx_attr_count.doneDisbursing();</span>
<span class="nc" id="L1653">        xxx_attr_indexes.doneDisbursing();</span>

        // Now each holder has a list of canonical attribute instances.
        // For layouts with no elements, we are done.  However, for
        // layouts with bands, we must replace each canonical (empty)
        // instance with a value-bearing one, initialized from the
        // appropriate bands.

        // Make a small pass to detect and read backward call counts.
<span class="nc" id="L1662">        int callCounts = 0;</span>
<span class="nc" id="L1663">        for (boolean predef = true; ; predef = false) {</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">            for (int ai = 0; ai &lt; defs.length; ai++) {</span>
<span class="nc" id="L1665">                Attribute.Layout def = defs[ai];</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">                if (def == null)  continue;  // unused index</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">                if (predef != isPredefinedAttr(ctype, ai))</span>
<span class="nc" id="L1668">                    continue;  // wrong pass</span>
<span class="nc" id="L1669">                int totalCount = totalCounts[ai];</span>
<span class="nc bnc" id="L1670" title="All 2 branches missed.">                if (totalCount == 0)</span>
<span class="nc" id="L1671">                    continue;  // irrelevant</span>
<span class="nc" id="L1672">                Attribute.Layout.Element[] cbles = def.getCallables();</span>
<span class="nc bnc" id="L1673" title="All 2 branches missed.">                for (int j = 0; j &lt; cbles.length; j++) {</span>
<span class="nc bnc" id="L1674" title="All 4 branches missed.">                    assert(cbles[j].kind == Attribute.EK_CBLE);</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">                    if (cbles[j].flagTest(Attribute.EF_BACK))</span>
<span class="nc" id="L1676">                        callCounts += 1;</span>
                }
            }
<span class="nc bnc" id="L1679" title="All 2 branches missed.">            if (!predef)  break;</span>
        }
<span class="nc" id="L1681">        xxx_attr_calls.expectLength(callCounts);</span>
<span class="nc" id="L1682">        xxx_attr_calls.readFrom(in);</span>

        // Finally, size all the attribute bands.
<span class="nc" id="L1685">        for (boolean predef = true; ; predef = false) {</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">            for (int ai = 0; ai &lt; defs.length; ai++) {</span>
<span class="nc" id="L1687">                Attribute.Layout def = defs[ai];</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">                if (def == null)  continue;  // unused index</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">                if (predef != isPredefinedAttr(ctype, ai))</span>
<span class="nc" id="L1690">                    continue;  // wrong pass</span>
<span class="nc" id="L1691">                int totalCount = totalCounts[ai];</span>
<span class="nc" id="L1692">                Band[] ab = attrBandTable.get(def);</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">                if (def == attrInnerClassesEmpty) {</span>
                    // Special case.
                    // Size the bands as if using the following layout:
                    //    [RCH TI[ (0)[] ()[RCNH RUNH] ]].
<span class="nc" id="L1697">                    class_InnerClasses_N.expectLength(totalCount);</span>
<span class="nc" id="L1698">                    class_InnerClasses_N.readFrom(in);</span>
<span class="nc" id="L1699">                    int tupleCount = class_InnerClasses_N.getIntTotal();</span>
<span class="nc" id="L1700">                    class_InnerClasses_RC.expectLength(tupleCount);</span>
<span class="nc" id="L1701">                    class_InnerClasses_RC.readFrom(in);</span>
<span class="nc" id="L1702">                    class_InnerClasses_F.expectLength(tupleCount);</span>
<span class="nc" id="L1703">                    class_InnerClasses_F.readFrom(in);</span>
                    // Drop remaining columns wherever flags are zero:
<span class="nc" id="L1705">                    tupleCount -= class_InnerClasses_F.getIntCount(0);</span>
<span class="nc" id="L1706">                    class_InnerClasses_outer_RCN.expectLength(tupleCount);</span>
<span class="nc" id="L1707">                    class_InnerClasses_outer_RCN.readFrom(in);</span>
<span class="nc" id="L1708">                    class_InnerClasses_name_RUN.expectLength(tupleCount);</span>
<span class="nc" id="L1709">                    class_InnerClasses_name_RUN.readFrom(in);</span>
<span class="nc bnc" id="L1710" title="All 4 branches missed.">                } else if (!optDebugBands &amp;&amp; totalCount == 0) {</span>
                    // Expect no elements at all.  Skip quickly. however if we
                    // are debugging bands, read all bands regardless
<span class="nc bnc" id="L1713" title="All 2 branches missed.">                    for (int j = 0; j &lt; ab.length; j++) {</span>
<span class="nc" id="L1714">                        ab[j].doneWithUnusedBand();</span>
                    }
                } else {
                    // Read these bands in sequence.
<span class="nc" id="L1718">                    boolean hasCallables = def.hasCallables();</span>
<span class="nc bnc" id="L1719" title="All 2 branches missed.">                    if (!hasCallables) {</span>
<span class="nc" id="L1720">                        readAttrBands(def.elems, totalCount, new int[0], ab);</span>
                    } else {
<span class="nc" id="L1722">                        Attribute.Layout.Element[] cbles = def.getCallables();</span>
                        // At first, record initial calls.
                        // Later, forward calls may also accumulate here:
<span class="nc" id="L1725">                        int[] forwardCounts = new int[cbles.length];</span>
<span class="nc" id="L1726">                        forwardCounts[0] = totalCount;</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">                        for (int j = 0; j &lt; cbles.length; j++) {</span>
<span class="nc bnc" id="L1728" title="All 4 branches missed.">                            assert(cbles[j].kind == Attribute.EK_CBLE);</span>
<span class="nc" id="L1729">                            int entryCount = forwardCounts[j];</span>
<span class="nc" id="L1730">                            forwardCounts[j] = -1;  // No more, please!</span>
<span class="nc bnc" id="L1731" title="All 4 branches missed.">                            if (totalCount &gt; 0 &amp;&amp; cbles[j].flagTest(Attribute.EF_BACK))</span>
<span class="nc" id="L1732">                                entryCount += xxx_attr_calls.getInt();</span>
<span class="nc" id="L1733">                            readAttrBands(cbles[j].body, entryCount, forwardCounts, ab);</span>
                        }
                    }
                    // mark them read,  to satisfy asserts
<span class="nc bnc" id="L1737" title="All 4 branches missed.">                    if (optDebugBands &amp;&amp; totalCount == 0) {</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">                        for (int j = 0; j &lt; ab.length; j++) {</span>
<span class="nc" id="L1739">                            ab[j].doneDisbursing();</span>
                        }
                    }
                }
            }
<span class="nc bnc" id="L1744" title="All 2 branches missed.">            if (!predef)  break;</span>
        }
<span class="nc" id="L1746">        xxx_attr_calls.doneDisbursing();</span>
<span class="nc" id="L1747">    }</span>

    void badAttrIndex(int ai, int ctype) throws IOException {
<span class="nc" id="L1750">        throw new IOException(&quot;Unknown attribute index &quot;+ai+&quot; for &quot;+</span>
                                   ATTR_CONTEXT_NAME[ctype]+&quot; attribute&quot;);
    }

    void readAttrs(int ctype, Collection&lt;? extends Attribute.Holder&gt; holders)
            throws IOException {
        // Decode band values into attributes.
<span class="nc" id="L1757">        Set&lt;Attribute.Layout&gt; sawDefs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1758">        ByteArrayOutputStream buf = new ByteArrayOutputStream();</span>
<span class="nc bnc" id="L1759" title="All 2 branches missed.">        for (final Attribute.Holder h : holders) {</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">            if (h.attributes == null)  continue;</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">            for (ListIterator&lt;Attribute&gt; j = h.attributes.listIterator(); j.hasNext(); ) {</span>
<span class="nc" id="L1762">                Attribute a = j.next();</span>
<span class="nc" id="L1763">                Attribute.Layout def = a.layout();</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">                if (def.bandCount == 0) {</span>
<span class="nc bnc" id="L1765" title="All 2 branches missed.">                    if (def == attrInnerClassesEmpty) {</span>
                        // Special logic to read this attr.
<span class="nc" id="L1767">                        readLocalInnerClasses((Class) h);</span>
<span class="nc" id="L1768">                        continue;</span>
                    }
                    // Canonical empty attr works fine (e.g., Synthetic).
                    continue;
                }
<span class="nc" id="L1773">                sawDefs.add(def);</span>
<span class="nc bnc" id="L1774" title="All 4 branches missed.">                boolean isCV = (ctype == ATTR_CONTEXT_FIELD &amp;&amp; def == attrConstantValue);</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">                if (isCV)  setConstantValueIndex((Class.Field)h);</span>
<span class="nc bnc" id="L1776" title="All 2 branches missed.">                if (verbose &gt; 2)</span>
<span class="nc" id="L1777">                    Utils.log.fine(&quot;read &quot;+a+&quot; in &quot;+h);</span>
<span class="nc" id="L1778">                final Band[] ab = attrBandTable.get(def);</span>
                // Read one attribute of type def from ab into a byte array.
<span class="nc" id="L1780">                buf.reset();</span>
<span class="nc" id="L1781">                Object fixups = a.unparse(new Attribute.ValueStream() {</span>
                    public int getInt(int bandIndex) {
<span class="nc" id="L1783">                        return ((IntBand) ab[bandIndex]).getInt();</span>
                    }
                    public Entry getRef(int bandIndex) {
<span class="nc" id="L1786">                        return ((CPRefBand) ab[bandIndex]).getRef();</span>
                    }
                    public int decodeBCI(int bciCode) {
<span class="nc" id="L1789">                        Code code = (Code) h;</span>
<span class="nc" id="L1790">                        return code.decodeBCI(bciCode);</span>
                    }
                }, buf);
                // Replace the canonical attr with the one just read.
<span class="nc" id="L1794">                j.set(a.addContent(buf.toByteArray(), fixups));</span>
<span class="nc bnc" id="L1795" title="All 2 branches missed.">                if (isCV)  setConstantValueIndex(null);  // clean up</span>
<span class="nc" id="L1796">            }</span>
<span class="nc" id="L1797">        }</span>

        // Mark the bands we just used as done disbursing.
<span class="nc bnc" id="L1800" title="All 2 branches missed.">        for (Attribute.Layout def : sawDefs) {</span>
<span class="nc bnc" id="L1801" title="All 2 branches missed.">            if (def == null)  continue;  // unused index</span>
<span class="nc" id="L1802">            Band[] ab = attrBandTable.get(def);</span>
<span class="nc bnc" id="L1803" title="All 2 branches missed.">            for (int j = 0; j &lt; ab.length; j++) {</span>
<span class="nc" id="L1804">                ab[j].doneDisbursing();</span>
            }
<span class="nc" id="L1806">        }</span>

<span class="nc bnc" id="L1808" title="All 2 branches missed.">        if (ctype == ATTR_CONTEXT_CLASS) {</span>
<span class="nc" id="L1809">            class_InnerClasses_N.doneDisbursing();</span>
<span class="nc" id="L1810">            class_InnerClasses_RC.doneDisbursing();</span>
<span class="nc" id="L1811">            class_InnerClasses_F.doneDisbursing();</span>
<span class="nc" id="L1812">            class_InnerClasses_outer_RCN.doneDisbursing();</span>
<span class="nc" id="L1813">            class_InnerClasses_name_RUN.doneDisbursing();</span>
        }

<span class="nc" id="L1816">        MultiBand xxx_attr_bands = attrBands[ctype];</span>
<span class="nc bnc" id="L1817" title="All 2 branches missed.">        for (int i = 0; i &lt; xxx_attr_bands.size(); i++) {</span>
<span class="nc" id="L1818">            Band b = xxx_attr_bands.get(i);</span>
<span class="nc bnc" id="L1819" title="All 2 branches missed.">            if (b instanceof MultiBand)</span>
<span class="nc" id="L1820">                b.doneDisbursing();</span>
        }
<span class="nc" id="L1822">        xxx_attr_bands.doneDisbursing();</span>
<span class="nc" id="L1823">    }</span>

    private
    void readAttrBands(Attribute.Layout.Element[] elems,
                       int count, int[] forwardCounts,
                       Band[] ab)
            throws IOException {
<span class="nc bnc" id="L1830" title="All 2 branches missed.">        for (int i = 0; i &lt; elems.length; i++) {</span>
<span class="nc" id="L1831">            Attribute.Layout.Element e = elems[i];</span>
<span class="nc" id="L1832">            Band eBand = null;</span>
<span class="nc bnc" id="L1833" title="All 2 branches missed.">            if (e.hasBand()) {</span>
<span class="nc" id="L1834">                eBand = ab[e.bandIndex];</span>
<span class="nc" id="L1835">                eBand.expectLength(count);</span>
<span class="nc" id="L1836">                eBand.readFrom(in);</span>
            }
<span class="nc bnc" id="L1838" title="All 5 branches missed.">            switch (e.kind) {</span>
            case Attribute.EK_REPL:
                // Recursive call.
<span class="nc" id="L1841">                int repCount = ((IntBand)eBand).getIntTotal();</span>
                // Note:  getIntTotal makes an extra pass over this band.
<span class="nc" id="L1843">                readAttrBands(e.body, repCount, forwardCounts, ab);</span>
<span class="nc" id="L1844">                break;</span>
            case Attribute.EK_UN:
<span class="nc" id="L1846">                int remainingCount = count;</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">                for (int j = 0; j &lt; e.body.length; j++) {</span>
                    int caseCount;
<span class="nc bnc" id="L1849" title="All 2 branches missed.">                    if (j == e.body.length-1) {</span>
<span class="nc" id="L1850">                        caseCount = remainingCount;</span>
                    } else {
<span class="nc" id="L1852">                        caseCount = 0;</span>
<span class="nc" id="L1853">                        for (int j0 = j;</span>
                             (j == j0)
<span class="nc bnc" id="L1855" title="All 4 branches missed.">                             || (j &lt; e.body.length</span>
<span class="nc bnc" id="L1856" title="All 2 branches missed.">                                 &amp;&amp; e.body[j].flagTest(Attribute.EF_BACK));</span>
<span class="nc" id="L1857">                             j++) {</span>
<span class="nc" id="L1858">                            caseCount += ((IntBand)eBand).getIntCount(e.body[j].value);</span>
                        }
<span class="nc" id="L1860">                        --j;  // back up to last occurrence of this body</span>
                    }
<span class="nc" id="L1862">                    remainingCount -= caseCount;</span>
<span class="nc" id="L1863">                    readAttrBands(e.body[j].body, caseCount, forwardCounts, ab);</span>
                }
<span class="nc bnc" id="L1865" title="All 4 branches missed.">                assert(remainingCount == 0);</span>
                break;
            case Attribute.EK_CALL:
<span class="nc bnc" id="L1868" title="All 4 branches missed.">                assert(e.body.length == 1);</span>
<span class="nc bnc" id="L1869" title="All 4 branches missed.">                assert(e.body[0].kind == Attribute.EK_CBLE);</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">                if (!e.flagTest(Attribute.EF_BACK)) {</span>
                    // Backward calls are pre-counted, but forwards are not.
                    // Push the present count forward.
<span class="nc bnc" id="L1873" title="All 4 branches missed.">                    assert(forwardCounts[e.value] &gt;= 0);</span>
<span class="nc" id="L1874">                    forwardCounts[e.value] += count;</span>
                }
                break;
            case Attribute.EK_CBLE:
<span class="nc bnc" id="L1878" title="All 2 branches missed.">                assert(false);</span>
                break;
            }
        }
<span class="nc" id="L1882">    }</span>

    void readByteCodes() throws IOException {
        //  bc_bands:
        //        *bc_codes :BYTE1
        //        *bc_case_count :UNSIGNED5
        //        *bc_case_value :DELTA5
        //        *bc_byte :BYTE1
        //        *bc_short :DELTA5
        //        *bc_local :UNSIGNED5
        //        *bc_label :BRANCH5
        //        *bc_intref :DELTA5  (cp_Int)
        //        *bc_floatref :DELTA5  (cp_Float)
        //        *bc_longref :DELTA5  (cp_Long)
        //        *bc_doubleref :DELTA5  (cp_Double)
        //        *bc_stringref :DELTA5  (cp_String)
        //        *bc_classref :UNSIGNED5  (current class or cp_Class)
        //        *bc_fieldref :DELTA5  (cp_Field)
        //        *bc_methodref :UNSIGNED5  (cp_Method)
        //        *bc_imethodref :DELTA5  (cp_Imethod)
        //        *bc_thisfield :UNSIGNED5 (cp_Field, only for current class)
        //        *bc_superfield :UNSIGNED5 (cp_Field, only for current super)
        //        *bc_thismethod :UNSIGNED5 (cp_Method, only for current class)
        //        *bc_supermethod :UNSIGNED5 (cp_Method, only for current super)
        //        *bc_initref :UNSIGNED5 (cp_Field, only for most recent new)
        //        *bc_escref :UNSIGNED5 (cp_All)
        //        *bc_escrefsize :UNSIGNED5
        //        *bc_escsize :UNSIGNED5
        //        *bc_escbyte :BYTE1
<span class="nc" id="L1911">        bc_codes.elementCountForDebug = allCodes.length;</span>
<span class="nc" id="L1912">        bc_codes.setInputStreamFrom(in);</span>
<span class="nc" id="L1913">        readByteCodeOps();  // reads from bc_codes and bc_case_count</span>
<span class="nc" id="L1914">        bc_codes.doneDisbursing();</span>

        // All the operand bands have now been sized.  Read them all in turn.
<span class="nc" id="L1917">        Band[] operand_bands = {</span>
            bc_case_value,
            bc_byte, bc_short,
            bc_local, bc_label,
            bc_intref, bc_floatref,
            bc_longref, bc_doubleref, bc_stringref,
            bc_loadablevalueref,
            bc_classref, bc_fieldref,
            bc_methodref, bc_imethodref,
            bc_indyref,
            bc_thisfield, bc_superfield,
            bc_thismethod, bc_supermethod,
            bc_initref,
            bc_escref, bc_escrefsize, bc_escsize
        };
<span class="nc bnc" id="L1932" title="All 2 branches missed.">        for (int i = 0; i &lt; operand_bands.length; i++) {</span>
<span class="nc" id="L1933">            operand_bands[i].readFrom(in);</span>
        }
<span class="nc" id="L1935">        bc_escbyte.expectLength(bc_escsize.getIntTotal());</span>
<span class="nc" id="L1936">        bc_escbyte.readFrom(in);</span>

<span class="nc" id="L1938">        expandByteCodeOps();</span>

        // Done fetching values from operand bands:
<span class="nc" id="L1941">        bc_case_count.doneDisbursing();</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">        for (int i = 0; i &lt; operand_bands.length; i++) {</span>
<span class="nc" id="L1943">            operand_bands[i].doneDisbursing();</span>
        }
<span class="nc" id="L1945">        bc_escbyte.doneDisbursing();</span>
<span class="nc" id="L1946">        bc_bands.doneDisbursing();</span>

        // We must delay the parsing of Code attributes until we
        // have a complete model of bytecodes, for BCI encodings.
<span class="nc" id="L1950">        readAttrs(ATTR_CONTEXT_CODE, codesWithFlags);</span>
        // Ditto for exception handlers in codes.
<span class="nc" id="L1952">        fixupCodeHandlers();</span>
        // Now we can finish with class_bands; cf. readClasses().
<span class="nc" id="L1954">        code_bands.doneDisbursing();</span>
<span class="nc" id="L1955">        class_bands.doneDisbursing();</span>
<span class="nc" id="L1956">    }</span>

    private void readByteCodeOps() throws IOException {
        // scratch buffer for collecting code::
<span class="nc" id="L1960">        byte[] buf = new byte[1&lt;&lt;12];</span>
        // record of all switch opcodes (these are variable-length)
<span class="nc" id="L1962">        List&lt;Integer&gt; allSwitchOps = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">        for (int k = 0; k &lt; allCodes.length; k++) {</span>
<span class="nc" id="L1964">            Code c = allCodes[k];</span>
        scanOneMethod:
<span class="nc" id="L1966">            for (int i = 0; ; i++) {</span>
<span class="nc" id="L1967">                int bc = bc_codes.getByte();</span>
<span class="nc bnc" id="L1968" title="All 2 branches missed.">                if (i + 10 &gt; buf.length)  buf = realloc(buf);</span>
<span class="nc" id="L1969">                buf[i] = (byte)bc;</span>
<span class="nc" id="L1970">                boolean isWide = false;</span>
<span class="nc bnc" id="L1971" title="All 2 branches missed.">                if (bc == _wide) {</span>
<span class="nc" id="L1972">                    bc = bc_codes.getByte();</span>
<span class="nc" id="L1973">                    buf[++i] = (byte)bc;</span>
<span class="nc" id="L1974">                    isWide = true;</span>
                }
<span class="nc bnc" id="L1976" title="All 4 branches missed.">                assert(bc == (0xFF &amp; bc));</span>
                // Adjust expectations of various band sizes.
<span class="nc bnc" id="L1978" title="All 10 branches missed.">                switch (bc) {</span>
                case _tableswitch:
                case _lookupswitch:
<span class="nc" id="L1981">                    bc_case_count.expectMoreLength(1);</span>
<span class="nc" id="L1982">                    allSwitchOps.add(bc);</span>
<span class="nc" id="L1983">                    break;</span>
                case _iinc:
<span class="nc" id="L1985">                    bc_local.expectMoreLength(1);</span>
<span class="nc bnc" id="L1986" title="All 2 branches missed.">                    if (isWide)</span>
<span class="nc" id="L1987">                        bc_short.expectMoreLength(1);</span>
                    else
<span class="nc" id="L1989">                        bc_byte.expectMoreLength(1);</span>
<span class="nc" id="L1990">                    break;</span>
                case _sipush:
<span class="nc" id="L1992">                    bc_short.expectMoreLength(1);</span>
<span class="nc" id="L1993">                    break;</span>
                case _bipush:
<span class="nc" id="L1995">                    bc_byte.expectMoreLength(1);</span>
<span class="nc" id="L1996">                    break;</span>
                case _newarray:
<span class="nc" id="L1998">                    bc_byte.expectMoreLength(1);</span>
<span class="nc" id="L1999">                    break;</span>
                case _multianewarray:
<span class="nc bnc" id="L2001" title="All 4 branches missed.">                    assert(getCPRefOpBand(bc) == bc_classref);</span>
<span class="nc" id="L2002">                    bc_classref.expectMoreLength(1);</span>
<span class="nc" id="L2003">                    bc_byte.expectMoreLength(1);</span>
<span class="nc" id="L2004">                    break;</span>
                case _ref_escape:
<span class="nc" id="L2006">                    bc_escrefsize.expectMoreLength(1);</span>
<span class="nc" id="L2007">                    bc_escref.expectMoreLength(1);</span>
<span class="nc" id="L2008">                    break;</span>
                case _byte_escape:
<span class="nc" id="L2010">                    bc_escsize.expectMoreLength(1);</span>
                    // bc_escbyte will have to be counted too
<span class="nc" id="L2012">                    break;</span>
                default:
<span class="nc bnc" id="L2014" title="All 2 branches missed.">                    if (Instruction.isInvokeInitOp(bc)) {</span>
<span class="nc" id="L2015">                        bc_initref.expectMoreLength(1);</span>
<span class="nc" id="L2016">                        break;</span>
                    }
<span class="nc bnc" id="L2018" title="All 2 branches missed.">                    if (Instruction.isSelfLinkerOp(bc)) {</span>
<span class="nc" id="L2019">                        CPRefBand bc_which = selfOpRefBand(bc);</span>
<span class="nc" id="L2020">                        bc_which.expectMoreLength(1);</span>
<span class="nc" id="L2021">                        break;</span>
                    }
<span class="nc bnc" id="L2023" title="All 2 branches missed.">                    if (Instruction.isBranchOp(bc)) {</span>
<span class="nc" id="L2024">                        bc_label.expectMoreLength(1);</span>
<span class="nc" id="L2025">                        break;</span>
                    }
<span class="nc bnc" id="L2027" title="All 2 branches missed.">                    if (Instruction.isCPRefOp(bc)) {</span>
<span class="nc" id="L2028">                        CPRefBand bc_which = getCPRefOpBand(bc);</span>
<span class="nc" id="L2029">                        bc_which.expectMoreLength(1);</span>
<span class="nc bnc" id="L2030" title="All 4 branches missed.">                        assert(bc != _multianewarray);  // handled elsewhere</span>
                        break;
                    }
<span class="nc bnc" id="L2033" title="All 2 branches missed.">                    if (Instruction.isLocalSlotOp(bc)) {</span>
<span class="nc" id="L2034">                        bc_local.expectMoreLength(1);</span>
<span class="nc" id="L2035">                        break;</span>
                    }
                    break;
                case _end_marker:
                    {
                        // Transfer from buf to a more permanent place:
<span class="nc" id="L2041">                        c.bytes = realloc(buf, i);</span>
<span class="nc" id="L2042">                        break scanOneMethod;</span>
                    }
                }
            }
        }

        // To size instruction bands correctly, we need info on switches:
<span class="nc" id="L2049">        bc_case_count.readFrom(in);</span>
<span class="nc bnc" id="L2050" title="All 2 branches missed.">        for (Integer i : allSwitchOps) {</span>
<span class="nc" id="L2051">            int bc = i.intValue();</span>
<span class="nc" id="L2052">            int caseCount = bc_case_count.getInt();</span>
<span class="nc" id="L2053">            bc_label.expectMoreLength(1+caseCount); // default label + cases</span>
<span class="nc bnc" id="L2054" title="All 2 branches missed.">            bc_case_value.expectMoreLength(bc == _tableswitch ? 1 : caseCount);</span>
<span class="nc" id="L2055">        }</span>
<span class="nc" id="L2056">        bc_case_count.resetForSecondPass();</span>
<span class="nc" id="L2057">    }</span>

    private void expandByteCodeOps() throws IOException {
        // scratch buffer for collecting code:
<span class="nc" id="L2061">        byte[] buf = new byte[1&lt;&lt;12];</span>
        // scratch buffer for collecting instruction boundaries:
<span class="nc" id="L2063">        int[] insnMap = new int[1&lt;&lt;12];</span>
        // list of label carriers, for label decoding post-pass:
<span class="nc" id="L2065">        int[] labels = new int[1&lt;&lt;10];</span>
        // scratch buffer for registering CP refs:
<span class="nc" id="L2067">        Fixups fixupBuf = new Fixups();</span>

<span class="nc bnc" id="L2069" title="All 2 branches missed.">        for (int k = 0; k &lt; allCodes.length; k++) {</span>
<span class="nc" id="L2070">            Code code = allCodes[k];</span>
<span class="nc" id="L2071">            byte[] codeOps = code.bytes;</span>
<span class="nc" id="L2072">            code.bytes = null;  // just for now, while we accumulate bits</span>

<span class="nc" id="L2074">            Class curClass = code.thisClass();</span>

<span class="nc" id="L2076">            Set&lt;Entry&gt; ldcRefSet = ldcRefMap.get(curClass);</span>
<span class="nc bnc" id="L2077" title="All 2 branches missed.">            if (ldcRefSet == null)</span>
<span class="nc" id="L2078">                ldcRefMap.put(curClass, ldcRefSet = new HashSet&lt;&gt;());</span>

<span class="nc" id="L2080">            ClassEntry thisClass  = curClass.thisClass;</span>
<span class="nc" id="L2081">            ClassEntry superClass = curClass.superClass;</span>
<span class="nc" id="L2082">            ClassEntry newClass   = null;  // class of last _new opcode</span>

<span class="nc" id="L2084">            int pc = 0;  // fill pointer in buf; actual bytecode PC</span>
<span class="nc" id="L2085">            int numInsns = 0;</span>
<span class="nc" id="L2086">            int numLabels = 0;</span>
<span class="nc" id="L2087">            boolean hasEscs = false;</span>
<span class="nc" id="L2088">            fixupBuf.clear();</span>
<span class="nc bnc" id="L2089" title="All 2 branches missed.">            for (int i = 0; i &lt; codeOps.length; i++) {</span>
<span class="nc" id="L2090">                int bc = Instruction.getByte(codeOps, i);</span>
<span class="nc" id="L2091">                int curPC = pc;</span>
<span class="nc" id="L2092">                insnMap[numInsns++] = curPC;</span>
<span class="nc bnc" id="L2093" title="All 2 branches missed.">                if (pc + 10 &gt; buf.length)  buf = realloc(buf);</span>
<span class="nc bnc" id="L2094" title="All 2 branches missed.">                if (numInsns+10 &gt; insnMap.length)  insnMap = realloc(insnMap);</span>
<span class="nc bnc" id="L2095" title="All 2 branches missed.">                if (numLabels+10 &gt; labels.length)  labels = realloc(labels);</span>
<span class="nc" id="L2096">                boolean isWide = false;</span>
<span class="nc bnc" id="L2097" title="All 2 branches missed.">                if (bc == _wide) {</span>
<span class="nc" id="L2098">                    buf[pc++] = (byte) bc;</span>
<span class="nc" id="L2099">                    bc = Instruction.getByte(codeOps, ++i);</span>
<span class="nc" id="L2100">                    isWide = true;</span>
                }
<span class="nc bnc" id="L2102" title="All 7 branches missed.">                switch (bc) {</span>
                case _tableswitch: // apc:  (df, lo, hi, (hi-lo+1)*(label))
                case _lookupswitch: // apc:  (df, nc, nc*(case, label))
                    {
<span class="nc" id="L2106">                        int caseCount = bc_case_count.getInt();</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">                        while ((pc + 30 + caseCount*8) &gt; buf.length)</span>
<span class="nc" id="L2108">                            buf = realloc(buf);</span>
<span class="nc" id="L2109">                        buf[pc++] = (byte) bc;</span>
                        //initialize apc, df, lo, hi bytes to reasonable bits:
<span class="nc" id="L2111">                        Arrays.fill(buf, pc, pc+30, (byte)0);</span>
<span class="nc" id="L2112">                        Instruction.Switch isw = (Instruction.Switch)</span>
<span class="nc" id="L2113">                            Instruction.at(buf, curPC);</span>
                        //isw.setDefaultLabel(getLabel(bc_label, code, curPC));
<span class="nc" id="L2115">                        isw.setCaseCount(caseCount);</span>
<span class="nc bnc" id="L2116" title="All 2 branches missed.">                        if (bc == _tableswitch) {</span>
<span class="nc" id="L2117">                            isw.setCaseValue(0, bc_case_value.getInt());</span>
                        } else {
<span class="nc bnc" id="L2119" title="All 2 branches missed.">                            for (int j = 0; j &lt; caseCount; j++) {</span>
<span class="nc" id="L2120">                                isw.setCaseValue(j, bc_case_value.getInt());</span>
                            }
                        }
                        // Make our getLabel calls later.
<span class="nc" id="L2124">                        labels[numLabels++] = curPC;</span>
<span class="nc" id="L2125">                        pc = isw.getNextPC();</span>
<span class="nc" id="L2126">                        continue;</span>
                    }
                case _iinc:
                    {
<span class="nc" id="L2130">                        buf[pc++] = (byte) bc;</span>
<span class="nc" id="L2131">                        int local = bc_local.getInt();</span>
                        int delta;
<span class="nc bnc" id="L2133" title="All 2 branches missed.">                        if (isWide) {</span>
<span class="nc" id="L2134">                            delta = bc_short.getInt();</span>
<span class="nc" id="L2135">                            Instruction.setShort(buf, pc, local); pc += 2;</span>
<span class="nc" id="L2136">                            Instruction.setShort(buf, pc, delta); pc += 2;</span>
                        } else {
<span class="nc" id="L2138">                            delta = (byte) bc_byte.getByte();</span>
<span class="nc" id="L2139">                            buf[pc++] = (byte)local;</span>
<span class="nc" id="L2140">                            buf[pc++] = (byte)delta;</span>
                        }
<span class="nc" id="L2142">                        continue;</span>
                    }
                case _sipush:
                    {
<span class="nc" id="L2146">                        int val = bc_short.getInt();</span>
<span class="nc" id="L2147">                        buf[pc++] = (byte) bc;</span>
<span class="nc" id="L2148">                        Instruction.setShort(buf, pc, val); pc += 2;</span>
<span class="nc" id="L2149">                        continue;</span>
                    }
                case _bipush:
                case _newarray:
                    {
<span class="nc" id="L2154">                        int val = bc_byte.getByte();</span>
<span class="nc" id="L2155">                        buf[pc++] = (byte) bc;</span>
<span class="nc" id="L2156">                        buf[pc++] = (byte) val;</span>
<span class="nc" id="L2157">                        continue;</span>
                    }
                case _ref_escape:
                    {
                        // Note that insnMap has one entry for this.
<span class="nc" id="L2162">                        hasEscs = true;</span>
<span class="nc" id="L2163">                        int size = bc_escrefsize.getInt();</span>
<span class="nc" id="L2164">                        Entry ref = bc_escref.getRef();</span>
<span class="nc bnc" id="L2165" title="All 2 branches missed.">                        if (size == 1)  ldcRefSet.add(ref);</span>
                        int fmt;
<span class="nc bnc" id="L2167" title="All 3 branches missed.">                        switch (size) {</span>
<span class="nc" id="L2168">                        case 1: fixupBuf.addU1(pc, ref); break;</span>
<span class="nc" id="L2169">                        case 2: fixupBuf.addU2(pc, ref); break;</span>
<span class="nc bnc" id="L2170" title="All 2 branches missed.">                        default: assert(false); fmt = 0;</span>
                        }
<span class="nc" id="L2172">                        buf[pc+0] = buf[pc+1] = 0;</span>
<span class="nc" id="L2173">                        pc += size;</span>
                    }
<span class="nc" id="L2175">                    continue;</span>
                case _byte_escape:
                    {
                        // Note that insnMap has one entry for all these bytes.
<span class="nc" id="L2179">                        hasEscs = true;</span>
<span class="nc" id="L2180">                        int size = bc_escsize.getInt();</span>
<span class="nc bnc" id="L2181" title="All 2 branches missed.">                        while ((pc + size) &gt; buf.length)</span>
<span class="nc" id="L2182">                            buf = realloc(buf);</span>
<span class="nc bnc" id="L2183" title="All 2 branches missed.">                        while (size-- &gt; 0) {</span>
<span class="nc" id="L2184">                            buf[pc++] = (byte) bc_escbyte.getByte();</span>
                        }
                    }
<span class="nc" id="L2187">                    continue;</span>
                default:
<span class="nc bnc" id="L2189" title="All 2 branches missed.">                    if (Instruction.isInvokeInitOp(bc)) {</span>
<span class="nc" id="L2190">                        int idx = (bc - _invokeinit_op);</span>
<span class="nc" id="L2191">                        int origBC = _invokespecial;</span>
                        ClassEntry classRef;
<span class="nc bnc" id="L2193" title="All 3 branches missed.">                        switch (idx) {</span>
                        case _invokeinit_self_option:
<span class="nc" id="L2195">                            classRef = thisClass; break;</span>
                        case _invokeinit_super_option:
<span class="nc" id="L2197">                            classRef = superClass; break;</span>
                        default:
<span class="nc bnc" id="L2199" title="All 4 branches missed.">                            assert(idx == _invokeinit_new_option);</span>
<span class="nc" id="L2200">                            classRef = newClass; break;</span>
                        }
<span class="nc" id="L2202">                        buf[pc++] = (byte) origBC;</span>
<span class="nc" id="L2203">                        int coding = bc_initref.getInt();</span>
                        // Find the nth overloading of &lt;init&gt; in classRef.
<span class="nc" id="L2205">                        MemberEntry ref = pkg.cp.getOverloadingForIndex(CONSTANT_Methodref, classRef, &quot;&lt;init&gt;&quot;, coding);</span>
<span class="nc" id="L2206">                        fixupBuf.addU2(pc, ref);</span>
<span class="nc" id="L2207">                        buf[pc+0] = buf[pc+1] = 0;</span>
<span class="nc" id="L2208">                        pc += 2;</span>
<span class="nc bnc" id="L2209" title="All 4 branches missed.">                        assert(Instruction.opLength(origBC) == (pc - curPC));</span>
                        continue;
                    }
<span class="nc bnc" id="L2212" title="All 2 branches missed.">                    if (Instruction.isSelfLinkerOp(bc)) {</span>
<span class="nc" id="L2213">                        int idx = (bc - _self_linker_op);</span>
<span class="nc bnc" id="L2214" title="All 2 branches missed.">                        boolean isSuper = (idx &gt;= _self_linker_super_flag);</span>
<span class="nc bnc" id="L2215" title="All 2 branches missed.">                        if (isSuper)  idx -= _self_linker_super_flag;</span>
<span class="nc bnc" id="L2216" title="All 2 branches missed.">                        boolean isAload = (idx &gt;= _self_linker_aload_flag);</span>
<span class="nc bnc" id="L2217" title="All 2 branches missed.">                        if (isAload)  idx -= _self_linker_aload_flag;</span>
<span class="nc" id="L2218">                        int origBC = _first_linker_op + idx;</span>
<span class="nc" id="L2219">                        boolean isField = Instruction.isFieldOp(origBC);</span>
                        CPRefBand bc_which;
<span class="nc bnc" id="L2221" title="All 2 branches missed.">                        ClassEntry which_cls  = isSuper ? superClass : thisClass;</span>
                        Index which_ix;
<span class="nc bnc" id="L2223" title="All 2 branches missed.">                        if (isField) {</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">                            bc_which = isSuper ? bc_superfield  : bc_thisfield;</span>
<span class="nc" id="L2225">                            which_ix = pkg.cp.getMemberIndex(CONSTANT_Fieldref, which_cls);</span>
                        } else {
<span class="nc bnc" id="L2227" title="All 2 branches missed.">                            bc_which = isSuper ? bc_supermethod : bc_thismethod;</span>
<span class="nc" id="L2228">                            which_ix = pkg.cp.getMemberIndex(CONSTANT_Methodref, which_cls);</span>
                        }
<span class="nc bnc" id="L2230" title="All 4 branches missed.">                        assert(bc_which == selfOpRefBand(bc));</span>
<span class="nc" id="L2231">                        MemberEntry ref = (MemberEntry) bc_which.getRef(which_ix);</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">                        if (isAload) {</span>
<span class="nc" id="L2233">                            buf[pc++] = (byte) _aload_0;</span>
<span class="nc" id="L2234">                            curPC = pc;</span>
                            // Note: insnMap keeps the _aload_0 separate.
<span class="nc" id="L2236">                            insnMap[numInsns++] = curPC;</span>
                        }
<span class="nc" id="L2238">                        buf[pc++] = (byte) origBC;</span>
<span class="nc" id="L2239">                        fixupBuf.addU2(pc, ref);</span>
<span class="nc" id="L2240">                        buf[pc+0] = buf[pc+1] = 0;</span>
<span class="nc" id="L2241">                        pc += 2;</span>
<span class="nc bnc" id="L2242" title="All 4 branches missed.">                        assert(Instruction.opLength(origBC) == (pc - curPC));</span>
                        continue;
                    }
<span class="nc bnc" id="L2245" title="All 2 branches missed.">                    if (Instruction.isBranchOp(bc)) {</span>
<span class="nc" id="L2246">                        buf[pc++] = (byte) bc;</span>
<span class="nc bnc" id="L2247" title="All 4 branches missed.">                        assert(!isWide);  // no wide prefix for branches</span>
<span class="nc" id="L2248">                        int nextPC = curPC + Instruction.opLength(bc);</span>
                        // Make our getLabel calls later.
<span class="nc" id="L2250">                        labels[numLabels++] = curPC;</span>
                        //Instruction.at(buf, curPC).setBranchLabel(getLabel(bc_label, code, curPC));
<span class="nc bnc" id="L2252" title="All 2 branches missed.">                        while (pc &lt; nextPC)  buf[pc++] = 0;</span>
                        continue;
                    }
<span class="nc bnc" id="L2255" title="All 2 branches missed.">                    if (Instruction.isCPRefOp(bc)) {</span>
<span class="nc" id="L2256">                        CPRefBand bc_which = getCPRefOpBand(bc);</span>
<span class="nc" id="L2257">                        Entry ref = bc_which.getRef();</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">                        if (ref == null) {</span>
<span class="nc bnc" id="L2259" title="All 2 branches missed.">                            if (bc_which == bc_classref) {</span>
                                // Shorthand for class self-references.
<span class="nc" id="L2261">                                ref = thisClass;</span>
                            } else {
<span class="nc bnc" id="L2263" title="All 2 branches missed.">                                assert(false);</span>
                            }
                        }
<span class="nc" id="L2266">                        int origBC = bc;</span>
<span class="nc" id="L2267">                        int size = 2;</span>
<span class="nc bnc" id="L2268" title="All 7 branches missed.">                        switch (bc) {</span>
                        case _invokestatic_int:
<span class="nc" id="L2270">                            origBC = _invokestatic;</span>
<span class="nc" id="L2271">                            break;</span>
                        case _invokespecial_int:
<span class="nc" id="L2273">                            origBC = _invokespecial;</span>
<span class="nc" id="L2274">                            break;</span>
                        case _ildc:
                        case _cldc:
                        case _fldc:
                        case _sldc:
                        case _qldc:
<span class="nc" id="L2280">                            origBC = _ldc;</span>
<span class="nc" id="L2281">                            size = 1;</span>
<span class="nc" id="L2282">                            ldcRefSet.add(ref);</span>
<span class="nc" id="L2283">                            break;</span>
                        case _ildc_w:
                        case _cldc_w:
                        case _fldc_w:
                        case _sldc_w:
                        case _qldc_w:
<span class="nc" id="L2289">                            origBC = _ldc_w;</span>
<span class="nc" id="L2290">                            break;</span>
                        case _lldc2_w:
                        case _dldc2_w:
<span class="nc" id="L2293">                            origBC = _ldc2_w;</span>
<span class="nc" id="L2294">                            break;</span>
                        case _new:
<span class="nc" id="L2296">                            newClass = (ClassEntry) ref;</span>
                            break;
                        }
<span class="nc" id="L2299">                        buf[pc++] = (byte) origBC;</span>
                        int fmt;
<span class="nc bnc" id="L2301" title="All 3 branches missed.">                        switch (size) {</span>
<span class="nc" id="L2302">                        case 1: fixupBuf.addU1(pc, ref); break;</span>
<span class="nc" id="L2303">                        case 2: fixupBuf.addU2(pc, ref); break;</span>
<span class="nc bnc" id="L2304" title="All 2 branches missed.">                        default: assert(false); fmt = 0;</span>
                        }
<span class="nc" id="L2306">                        buf[pc+0] = buf[pc+1] = 0;</span>
<span class="nc" id="L2307">                        pc += size;</span>
<span class="nc bnc" id="L2308" title="All 2 branches missed.">                        if (origBC == _multianewarray) {</span>
                            // Copy the trailing byte also.
<span class="nc" id="L2310">                            int val = bc_byte.getByte();</span>
<span class="nc" id="L2311">                            buf[pc++] = (byte) val;</span>
<span class="nc bnc" id="L2312" title="All 2 branches missed.">                        } else if (origBC == _invokeinterface) {</span>
<span class="nc" id="L2313">                            int argSize = ((MemberEntry)ref).descRef.typeRef.computeSize(true);</span>
<span class="nc" id="L2314">                            buf[pc++] = (byte)( 1 + argSize );</span>
<span class="nc" id="L2315">                            buf[pc++] = 0;</span>
<span class="nc bnc" id="L2316" title="All 2 branches missed.">                        } else if (origBC == _invokedynamic) {</span>
<span class="nc" id="L2317">                            buf[pc++] = 0;</span>
<span class="nc" id="L2318">                            buf[pc++] = 0;</span>
                        }
<span class="nc bnc" id="L2320" title="All 4 branches missed.">                        assert(Instruction.opLength(origBC) == (pc - curPC));</span>
                        continue;
                    }
<span class="nc bnc" id="L2323" title="All 2 branches missed.">                    if (Instruction.isLocalSlotOp(bc)) {</span>
<span class="nc" id="L2324">                        buf[pc++] = (byte) bc;</span>
<span class="nc" id="L2325">                        int local = bc_local.getInt();</span>
<span class="nc bnc" id="L2326" title="All 2 branches missed.">                        if (isWide) {</span>
<span class="nc" id="L2327">                            Instruction.setShort(buf, pc, local);</span>
<span class="nc" id="L2328">                            pc += 2;</span>
<span class="nc bnc" id="L2329" title="All 2 branches missed.">                            if (bc == _iinc) {</span>
<span class="nc" id="L2330">                                int iVal = bc_short.getInt();</span>
<span class="nc" id="L2331">                                Instruction.setShort(buf, pc, iVal);</span>
<span class="nc" id="L2332">                                pc += 2;</span>
<span class="nc" id="L2333">                            }</span>
                        } else {
<span class="nc" id="L2335">                            Instruction.setByte(buf, pc, local);</span>
<span class="nc" id="L2336">                            pc += 1;</span>
<span class="nc bnc" id="L2337" title="All 2 branches missed.">                            if (bc == _iinc) {</span>
<span class="nc" id="L2338">                                int iVal = bc_byte.getByte();</span>
<span class="nc" id="L2339">                                Instruction.setByte(buf, pc, iVal);</span>
<span class="nc" id="L2340">                                pc += 1;</span>
                            }
                        }
<span class="nc bnc" id="L2343" title="All 4 branches missed.">                        assert(Instruction.opLength(bc) == (pc - curPC));</span>
                        continue;
                    }
                    // Random bytecode.  Just copy it.
<span class="nc bnc" id="L2347" title="All 2 branches missed.">                    if (bc &gt;= _bytecode_limit)</span>
<span class="nc" id="L2348">                        Utils.log.warning(&quot;unrecognized bytescode &quot;+bc</span>
<span class="nc" id="L2349">                                            +&quot; &quot;+Instruction.byteName(bc));</span>
<span class="nc bnc" id="L2350" title="All 4 branches missed.">                    assert(bc &lt; _bytecode_limit);</span>
<span class="nc" id="L2351">                    buf[pc++] = (byte) bc;</span>
<span class="nc bnc" id="L2352" title="All 4 branches missed.">                    assert(Instruction.opLength(bc) == (pc - curPC));</span>
                    continue;
                }
            }
            // now make a permanent copy of the bytecodes
<span class="nc" id="L2357">            code.setBytes(realloc(buf, pc));</span>
<span class="nc" id="L2358">            code.setInstructionMap(insnMap, numInsns);</span>
            // fix up labels, now that code has its insnMap
<span class="nc" id="L2360">            Instruction ibr = null;  // temporary branch instruction</span>
<span class="nc bnc" id="L2361" title="All 2 branches missed.">            for (int i = 0; i &lt; numLabels; i++) {</span>
<span class="nc" id="L2362">                int curPC = labels[i];</span>
                // (Note:  Passing ibr in allows reuse, a speed hack.)
<span class="nc" id="L2364">                ibr = Instruction.at(code.bytes, curPC, ibr);</span>
<span class="nc bnc" id="L2365" title="All 2 branches missed.">                if (ibr instanceof Instruction.Switch) {</span>
<span class="nc" id="L2366">                    Instruction.Switch isw = (Instruction.Switch) ibr;</span>
<span class="nc" id="L2367">                    isw.setDefaultLabel(getLabel(bc_label, code, curPC));</span>
<span class="nc" id="L2368">                    int caseCount = isw.getCaseCount();</span>
<span class="nc bnc" id="L2369" title="All 2 branches missed.">                    for (int j = 0; j &lt; caseCount; j++) {</span>
<span class="nc" id="L2370">                        isw.setCaseLabel(j, getLabel(bc_label, code, curPC));</span>
                    }
<span class="nc" id="L2372">                } else {</span>
<span class="nc" id="L2373">                    ibr.setBranchLabel(getLabel(bc_label, code, curPC));</span>
                }
            }
<span class="nc bnc" id="L2376" title="All 2 branches missed.">            if (fixupBuf.size() &gt; 0) {</span>
<span class="nc bnc" id="L2377" title="All 2 branches missed.">                if (verbose &gt; 2)</span>
<span class="nc" id="L2378">                    Utils.log.fine(&quot;Fixups in code: &quot;+fixupBuf);</span>
<span class="nc" id="L2379">                code.addFixups(fixupBuf);</span>
            }
        }
<span class="nc" id="L2382">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>