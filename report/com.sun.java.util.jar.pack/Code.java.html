<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Code.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">Code.java</span></div><h1>Code.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import com.sun.java.util.jar.pack.Package.Class;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Collection;
import static com.sun.java.util.jar.pack.Constants.*;

/**
 * Represents a chunk of bytecodes.
 * @author John Rose
 */
<span class="nc bnc" id="L38" title="All 2 branches missed.">class Code extends Attribute.Holder {</span>
    Class.Method m;

<span class="nc" id="L41">    public Code(Class.Method m) {</span>
<span class="nc" id="L42">        this.m = m;</span>
<span class="nc" id="L43">    }</span>

    public Class.Method getMethod() {
<span class="nc" id="L46">        return m;</span>
    }
    public Class thisClass() {
<span class="nc" id="L49">        return m.thisClass();</span>
    }
    public Package getPackage() {
<span class="nc" id="L52">        return m.thisClass().getPackage();</span>
    }

    public ConstantPool.Entry[] getCPMap() {
<span class="nc" id="L56">        return m.getCPMap();</span>
    }

<span class="nc" id="L59">    static private final ConstantPool.Entry[] noRefs = ConstantPool.noRefs;</span>

    // The following fields are used directly by the ClassReader, etc.
    int max_stack;
    int max_locals;

<span class="nc" id="L65">    ConstantPool.Entry handler_class[] = noRefs;</span>
<span class="nc" id="L66">    int handler_start[] = noInts;</span>
<span class="nc" id="L67">    int handler_end[] = noInts;</span>
<span class="nc" id="L68">    int handler_catch[] = noInts;</span>

    byte[] bytes;
    Fixups fixups;  // reference relocations, if any are required
    Object insnMap; // array of instruction boundaries

<span class="nc" id="L74">    int getLength() { return bytes.length; }</span>

    int getMaxStack() {
<span class="nc" id="L77">        return max_stack;</span>
    }
    void setMaxStack(int ms) {
<span class="nc" id="L80">        max_stack = ms;</span>
<span class="nc" id="L81">    }</span>

    int getMaxNALocals() {
<span class="nc" id="L84">        int argsize = m.getArgumentSize();</span>
<span class="nc" id="L85">        return max_locals - argsize;</span>
    }
    void setMaxNALocals(int ml) {
<span class="nc" id="L88">        int argsize = m.getArgumentSize();</span>
<span class="nc" id="L89">        max_locals = argsize + ml;</span>
<span class="nc" id="L90">    }</span>

    int getHandlerCount() {
<span class="nc bnc" id="L93" title="All 4 branches missed.">        assert(handler_class.length == handler_start.length);</span>
<span class="nc bnc" id="L94" title="All 4 branches missed.">        assert(handler_class.length == handler_end.length);</span>
<span class="nc bnc" id="L95" title="All 4 branches missed.">        assert(handler_class.length == handler_catch.length);</span>
<span class="nc" id="L96">        return handler_class.length;</span>
    }
    void setHandlerCount(int h) {
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (h &gt; 0) {</span>
<span class="nc" id="L100">            handler_class = new ConstantPool.Entry[h];</span>
<span class="nc" id="L101">            handler_start = new int[h];</span>
<span class="nc" id="L102">            handler_end   = new int[h];</span>
<span class="nc" id="L103">            handler_catch = new int[h];</span>
            // caller must fill these in ASAP
        }
<span class="nc" id="L106">    }</span>

    void setBytes(byte[] bytes) {
<span class="nc" id="L109">        this.bytes = bytes;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (fixups != null)</span>
<span class="nc" id="L111">            fixups.setBytes(bytes);</span>
<span class="nc" id="L112">    }</span>

    void setInstructionMap(int[] insnMap, int mapLen) {
        //int[] oldMap = null;
        //assert((oldMap = getInstructionMap()) != null);
<span class="nc" id="L117">        this.insnMap = allocateInstructionMap(insnMap, mapLen);</span>
        //assert(Arrays.equals(oldMap, getInstructionMap()));
<span class="nc" id="L119">    }</span>
    void setInstructionMap(int[] insnMap) {
<span class="nc" id="L121">        setInstructionMap(insnMap, insnMap.length);</span>
<span class="nc" id="L122">    }</span>

    int[] getInstructionMap() {
<span class="nc" id="L125">        return expandInstructionMap(getInsnMap());</span>
    }

    void addFixups(Collection&lt;Fixups.Fixup&gt; moreFixups) {
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (fixups == null) {</span>
<span class="nc" id="L130">            fixups = new Fixups(bytes);</span>
        }
<span class="nc bnc" id="L132" title="All 4 branches missed.">        assert(fixups.getBytes() == bytes);</span>
<span class="nc" id="L133">        fixups.addAll(moreFixups);</span>
<span class="nc" id="L134">    }</span>

    public void trimToSize() {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (fixups != null) {</span>
<span class="nc" id="L138">            fixups.trimToSize();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (fixups.size() == 0)</span>
<span class="nc" id="L140">                fixups = null;</span>
        }
<span class="nc" id="L142">        super.trimToSize();</span>
<span class="nc" id="L143">    }</span>

    protected void visitRefs(int mode, Collection&lt;ConstantPool.Entry&gt; refs) {
<span class="nc" id="L146">        int verbose = getPackage().verbose;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (verbose &gt; 2)</span>
<span class="nc" id="L148">            System.out.println(&quot;Reference scan &quot;+this);</span>
<span class="nc" id="L149">        refs.addAll(Arrays.asList(handler_class));</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (fixups != null) {</span>
<span class="nc" id="L151">            fixups.visitRefs(refs);</span>
        } else {
            // References (to a local cpMap) are embedded in the bytes.
<span class="nc" id="L154">            ConstantPool.Entry[] cpMap = getCPMap();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            for (Instruction i = instructionAt(0); i != null; i = i.next()) {</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                if (verbose &gt; 4)</span>
<span class="nc" id="L157">                    System.out.println(i);</span>
<span class="nc" id="L158">                int cpref = i.getCPIndex();</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">                if (cpref &gt;= 0) {</span>
<span class="nc" id="L160">                    refs.add(cpMap[cpref]);</span>
                }
            }
        }
        // Handle attribute list:
<span class="nc" id="L165">        super.visitRefs(mode, refs);</span>
<span class="nc" id="L166">    }</span>

    // Since bytecodes are the single largest contributor to
    // package size, it's worth a little bit of trouble
    // to reduce the per-bytecode memory footprint.
    // In the current scheme, half of the bulk of these arrays
    // due to bytes, and half to shorts.  (Ints are insignificant.)
    // Given an average of 1.8 bytes per instruction, this means
    // instruction boundary arrays are about a 75% overhead--tolerable.
    // (By using bytes, we get 33% savings over just shorts and ints.
    // Using both bytes and shorts gives 66% savings over just ints.)
    static final boolean shrinkMaps = true;

    private Object allocateInstructionMap(int[] insnMap, int mapLen) {
<span class="nc" id="L180">        int PClimit = getLength();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (shrinkMaps &amp;&amp; PClimit &lt;= Byte.MAX_VALUE - Byte.MIN_VALUE) {</span>
<span class="nc" id="L182">            byte[] map = new byte[mapLen+1];</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            for (int i = 0; i &lt; mapLen; i++) {</span>
<span class="nc" id="L184">                map[i] = (byte)(insnMap[i] + Byte.MIN_VALUE);</span>
            }
<span class="nc" id="L186">            map[mapLen] = (byte)(PClimit + Byte.MIN_VALUE);</span>
<span class="nc" id="L187">            return map;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        } else if (shrinkMaps &amp;&amp; PClimit &lt; Short.MAX_VALUE - Short.MIN_VALUE) {</span>
<span class="nc" id="L189">            short[] map = new short[mapLen+1];</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">            for (int i = 0; i &lt; mapLen; i++) {</span>
<span class="nc" id="L191">                map[i] = (short)(insnMap[i] + Short.MIN_VALUE);</span>
            }
<span class="nc" id="L193">            map[mapLen] = (short)(PClimit + Short.MIN_VALUE);</span>
<span class="nc" id="L194">            return map;</span>
        } else {
<span class="nc" id="L196">            int[] map = Arrays.copyOf(insnMap, mapLen + 1);</span>
<span class="nc" id="L197">            map[mapLen] = PClimit;</span>
<span class="nc" id="L198">            return map;</span>
        }
    }
    private int[] expandInstructionMap(Object map0) {
        int[] imap;
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (map0 instanceof byte[]) {</span>
<span class="nc" id="L204">            byte[] map = (byte[]) map0;</span>
<span class="nc" id="L205">            imap = new int[map.length-1];</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            for (int i = 0; i &lt; imap.length; i++) {</span>
<span class="nc" id="L207">                imap[i] = map[i] - Byte.MIN_VALUE;</span>
            }
<span class="nc bnc" id="L209" title="All 2 branches missed.">        } else if (map0 instanceof short[]) {</span>
<span class="nc" id="L210">            short[] map = (short[]) map0;</span>
<span class="nc" id="L211">            imap = new int[map.length-1];</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            for (int i = 0; i &lt; imap.length; i++) {</span>
<span class="nc" id="L213">                imap[i] = map[i] - Byte.MIN_VALUE;</span>
            }
<span class="nc" id="L215">        } else {</span>
<span class="nc" id="L216">            int[] map = (int[]) map0;</span>
<span class="nc" id="L217">            imap = Arrays.copyOfRange(map, 0, map.length - 1);</span>
        }
<span class="nc" id="L219">        return imap;</span>
    }

    Object getInsnMap() {
        // Build a map of instruction boundaries.
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (insnMap != null) {</span>
<span class="nc" id="L225">            return insnMap;</span>
        }
<span class="nc" id="L227">        int[] map = new int[getLength()];</span>
<span class="nc" id="L228">        int fillp = 0;</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        for (Instruction i = instructionAt(0); i != null; i = i.next()) {</span>
<span class="nc" id="L230">            map[fillp++] = i.getPC();</span>
        }
        // Make it byte[], short[], or int[] according to the max BCI.
<span class="nc" id="L233">        insnMap = allocateInstructionMap(map, fillp);</span>
        //assert(assertBCICodingsOK());
<span class="nc" id="L235">        return insnMap;</span>
    }

    /** Encode the given BCI as an instruction boundary number.
     *  For completeness, irregular (non-boundary) BCIs are
     *  encoded compactly immediately after the boundary numbers.
     *  This encoding is the identity mapping outside 0..length,
     *  and it is 1-1 everywhere.  All by itself this technique
     *  improved zipped rt.jar compression by 2.6%.
     */
    public int encodeBCI(int bci) {
<span class="nc bnc" id="L246" title="All 4 branches missed.">        if (bci &lt;= 0 || bci &gt; getLength())  return bci;</span>
<span class="nc" id="L247">        Object map0 = getInsnMap();</span>
        int i, len;
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (shrinkMaps &amp;&amp; map0 instanceof byte[]) {</span>
<span class="nc" id="L250">            byte[] map = (byte[]) map0;</span>
<span class="nc" id="L251">            len = map.length;</span>
<span class="nc" id="L252">            i = Arrays.binarySearch(map, (byte)(bci + Byte.MIN_VALUE));</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        } else if (shrinkMaps &amp;&amp; map0 instanceof short[]) {</span>
<span class="nc" id="L254">            short[] map = (short[]) map0;</span>
<span class="nc" id="L255">            len = map.length;</span>
<span class="nc" id="L256">            i = Arrays.binarySearch(map, (short)(bci + Short.MIN_VALUE));</span>
<span class="nc" id="L257">        } else {</span>
<span class="nc" id="L258">            int[] map = (int[]) map0;</span>
<span class="nc" id="L259">            len = map.length;</span>
<span class="nc" id="L260">            i = Arrays.binarySearch(map, bci);</span>
        }
<span class="nc bnc" id="L262" title="All 4 branches missed.">        assert(i != -1);</span>
<span class="nc bnc" id="L263" title="All 4 branches missed.">        assert(i != 0);</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">        assert(i != len);</span>
<span class="nc bnc" id="L265" title="All 4 branches missed.">        assert(i != -len-1);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        return (i &gt;= 0) ? i : len + bci - (-i-1);</span>
    }
    public int decodeBCI(int bciCode) {
<span class="nc bnc" id="L269" title="All 4 branches missed.">        if (bciCode &lt;= 0 || bciCode &gt; getLength())  return bciCode;</span>
<span class="nc" id="L270">        Object map0 = getInsnMap();</span>
        int i, len;
        // len == map.length
        // If bciCode &lt; len, result is map[bciCode], the common and fast case.
        // Otherwise, let map[i] be the smallest map[*] larger than bci.
        // Then, required by the return statement of encodeBCI:
        //   bciCode == len + bci - i
        // Thus:
        //   bci-i == bciCode-len
        //   map[i]-adj-i == bciCode-len ; adj in (0..map[i]-map[i-1])
        // We can solve this by searching for adjacent entries
        // map[i-1], map[i] such that:
        //   map[i-1]-(i-1) &lt;= bciCode-len &lt; map[i]-i
        // This can be approximated by searching map[i] for bciCode and then
        // linear searching backward.  Given the right i, we then have:
        //   bci == bciCode-len + i
        // This linear search is at its worst case for indexes in the beginning
        // of a large method, but it's not clear that this is a problem in
        // practice, since BCIs are usually on instruction boundaries.
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (shrinkMaps &amp;&amp; map0 instanceof byte[]) {</span>
<span class="nc" id="L290">            byte[] map = (byte[]) map0;</span>
<span class="nc" id="L291">            len = map.length;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (bciCode &lt; len)</span>
<span class="nc" id="L293">                return map[bciCode] - Byte.MIN_VALUE;</span>
<span class="nc" id="L294">            i = Arrays.binarySearch(map, (byte)(bciCode + Byte.MIN_VALUE));</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (i &lt; 0)  i = -i-1;</span>
<span class="nc" id="L296">            int key = bciCode-len + Byte.MIN_VALUE;</span>
<span class="nc" id="L297">            for (;; i--) {</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                if (map[i-1]-(i-1) &lt;= key)  break;</span>
            }
<span class="nc bnc" id="L300" title="All 2 branches missed.">        } else if (shrinkMaps &amp;&amp; map0 instanceof short[]) {</span>
<span class="nc" id="L301">            short[] map = (short[]) map0;</span>
<span class="nc" id="L302">            len = map.length;</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (bciCode &lt; len)</span>
<span class="nc" id="L304">                return map[bciCode] - Short.MIN_VALUE;</span>
<span class="nc" id="L305">            i = Arrays.binarySearch(map, (short)(bciCode + Short.MIN_VALUE));</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (i &lt; 0)  i = -i-1;</span>
<span class="nc" id="L307">            int key = bciCode-len + Short.MIN_VALUE;</span>
<span class="nc" id="L308">            for (;; i--) {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">                if (map[i-1]-(i-1) &lt;= key)  break;</span>
            }
<span class="nc" id="L311">        } else {</span>
<span class="nc" id="L312">            int[] map = (int[]) map0;</span>
<span class="nc" id="L313">            len = map.length;</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">            if (bciCode &lt; len)</span>
<span class="nc" id="L315">                return map[bciCode];</span>
<span class="nc" id="L316">            i = Arrays.binarySearch(map, bciCode);</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (i &lt; 0)  i = -i-1;</span>
<span class="nc" id="L318">            int key = bciCode-len;</span>
<span class="nc" id="L319">            for (;; i--) {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">                if (map[i-1]-(i-1) &lt;= key)  break;</span>
            }
        }
<span class="nc" id="L323">        return bciCode-len + i;</span>
    }

    public void finishRefs(ConstantPool.Index ix) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (fixups != null) {</span>
<span class="nc" id="L328">            fixups.finishRefs(ix);</span>
<span class="nc" id="L329">            fixups = null;</span>
        }
        // Code attributes are finished in ClassWriter.writeAttributes.
<span class="nc" id="L332">    }</span>

    Instruction instructionAt(int pc) {
<span class="nc" id="L335">        return Instruction.at(bytes, pc);</span>
    }

    static boolean flagsRequireCode(int flags) {
        // A method's flags force it to have a Code attribute,
        // if the flags are neither native nor abstract.
<span class="nc bnc" id="L341" title="All 2 branches missed.">        return (flags &amp; (Modifier.NATIVE | Modifier.ABSTRACT)) == 0;</span>
    }

    public String toString() {
<span class="nc" id="L345">        return m+&quot;.Code&quot;;</span>
    }

    /// Fetching values from my own array.
<span class="nc" id="L349">    public int getInt(int pc)    { return Instruction.getInt(bytes, pc); }</span>
<span class="nc" id="L350">    public int getShort(int pc)  { return Instruction.getShort(bytes, pc); }</span>
<span class="nc" id="L351">    public int getByte(int pc)   { return Instruction.getByte(bytes, pc); }</span>
<span class="nc" id="L352">    void setInt(int pc, int x)   { Instruction.setInt(bytes, pc, x); }</span>
<span class="nc" id="L353">    void setShort(int pc, int x) { Instruction.setShort(bytes, pc, x); }</span>
<span class="nc" id="L354">    void setByte(int pc, int x)  { Instruction.setByte(bytes, pc, x); }</span>

/* TEST CODE ONLY
    private boolean assertBCICodingsOK() {
        boolean ok = true;
        int len = java.lang.reflect.Array.getLength(insnMap);
        int base = 0;
        if (insnMap.getClass().getComponentType() == Byte.TYPE)
            base = Byte.MIN_VALUE;
        if (insnMap.getClass().getComponentType() == Short.TYPE)
            base = Short.MIN_VALUE;
        for (int i = -1, imax = getLength()+1; i &lt;= imax; i++) {
            int bci = i;
            int enc = Math.min(-999, bci-1);
            int dec = enc;
            try {
                enc = encodeBCI(bci);
                dec = decodeBCI(enc);
            } catch (RuntimeException ee) {
                ee.printStackTrace();
            }
            if (dec == bci) {
                //System.out.println(&quot;BCI=&quot;+bci+(enc&lt;len?&quot;&quot;:&quot;   &quot;)+&quot; enc=&quot;+enc);
                continue;
            }
            if (ok) {
                for (int q = 0; q &lt;= 1; q++) {
                    StringBuffer sb = new StringBuffer();
                    sb.append(&quot;bci &quot;+(q==0?&quot;map&quot;:&quot;del&quot;)+&quot;[&quot;+len+&quot;] = {&quot;);
                    for (int j = 0; j &lt; len; j++) {
                        int mapi = ((Number)java.lang.reflect.Array.get(insnMap, j)).intValue() - base;
                        mapi -= j*q;
                        sb.append(&quot; &quot;+mapi);
                    }
                    sb.append(&quot; }&quot;);
                    System.out.println(&quot;*** &quot;+sb);
                }
            }
            System.out.println(&quot;*** BCI=&quot;+bci+&quot; enc=&quot;+enc+&quot; dec=&quot;+dec);
            ok = false;
        }
        return ok;
    }
//*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>