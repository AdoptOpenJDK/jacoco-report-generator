<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CodingChooser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">CodingChooser.java</span></div><h1>CodingChooser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;
import static com.sun.java.util.jar.pack.Constants.*;
/**
 * Heuristic chooser of basic encodings.
 * Runs &quot;zip&quot; to measure the apparent information content after coding.
 * @author John Rose
 */
<span class="nc bnc" id="L46" title="All 2 branches missed.">class CodingChooser {</span>
    int verbose;
    int effort;
<span class="nc" id="L49">    boolean optUseHistogram = true;</span>
<span class="nc" id="L50">    boolean optUsePopulationCoding = true;</span>
<span class="nc" id="L51">    boolean optUseAdaptiveCoding = true;</span>
    boolean disablePopCoding;
    boolean disableRunCoding;
<span class="nc" id="L54">    boolean topLevel = true;</span>

    // Derived from effort; &gt;1 (&lt;1) means try more (less) experiments
    // when looking to beat a best score.
    double fuzz;

    Coding[] allCodingChoices;
    Choice[] choices;
    ByteArrayOutputStream context;
    CodingChooser popHelper;
    CodingChooser runHelper;

    Random stress;  // If not null, stress mode oracle.

    // Element in sorted set of coding choices:
    static
    class Choice {
        final Coding coding;
        final int index;       // index in choices
        final int[] distance;  // cache of distance
<span class="nc" id="L74">        Choice(Coding coding, int index, int[] distance) {</span>
<span class="nc" id="L75">            this.coding   = coding;</span>
<span class="nc" id="L76">            this.index    = index;</span>
<span class="nc" id="L77">            this.distance = distance;</span>
<span class="nc" id="L78">        }</span>
        // These variables are reset and reused:
        int searchOrder; // order in which it is checked
        int minDistance; // min distance from already-checked choices
        int zipSize;     // size of encoding in sample, zipped output
        int byteSize;    // size of encoding in sample (debug only)
        int histSize;    // size of encoding, according to histogram

        void reset() {
<span class="nc" id="L87">            searchOrder = Integer.MAX_VALUE;</span>
<span class="nc" id="L88">            minDistance = Integer.MAX_VALUE;</span>
<span class="nc" id="L89">            zipSize = byteSize = histSize = -1;</span>
<span class="nc" id="L90">        }</span>

        boolean isExtra() {
<span class="nc bnc" id="L93" title="All 2 branches missed.">            return index &lt; 0;</span>
        }

        public String toString() {
<span class="nc" id="L97">            return stringForDebug();</span>
        }

        private String stringForDebug() {
<span class="nc" id="L101">            String s = &quot;&quot;;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">            if (searchOrder &lt; Integer.MAX_VALUE)</span>
<span class="nc" id="L103">                s += &quot; so: &quot;+searchOrder;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">            if (minDistance &lt; Integer.MAX_VALUE)</span>
<span class="nc" id="L105">                s += &quot; md: &quot;+minDistance;</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">            if (zipSize &gt; 0)</span>
<span class="nc" id="L107">                s += &quot; zs: &quot;+zipSize;</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            if (byteSize &gt; 0)</span>
<span class="nc" id="L109">                s += &quot; bs: &quot;+byteSize;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (histSize &gt; 0)</span>
<span class="nc" id="L111">                s += &quot; hs: &quot;+histSize;</span>
<span class="nc" id="L112">            return &quot;Choice[&quot;+index+&quot;] &quot;+s+&quot; &quot;+coding;</span>
        }
    }

<span class="nc" id="L116">    CodingChooser(int effort, Coding[] allCodingChoices) {</span>
<span class="nc" id="L117">        PropMap p200 = Utils.currentPropMap();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (p200 != null) {</span>
<span class="nc" id="L119">            this.verbose</span>
<span class="nc" id="L120">                = Math.max(p200.getInteger(Utils.DEBUG_VERBOSE),</span>
<span class="nc" id="L121">                           p200.getInteger(Utils.COM_PREFIX+&quot;verbose.coding&quot;));</span>
<span class="nc" id="L122">            this.optUseHistogram</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                = !p200.getBoolean(Utils.COM_PREFIX+&quot;no.histogram&quot;);</span>
<span class="nc" id="L124">            this.optUsePopulationCoding</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">                = !p200.getBoolean(Utils.COM_PREFIX+&quot;no.population.coding&quot;);</span>
<span class="nc" id="L126">            this.optUseAdaptiveCoding</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                = !p200.getBoolean(Utils.COM_PREFIX+&quot;no.adaptive.coding&quot;);</span>
<span class="nc" id="L128">            int lstress</span>
<span class="nc" id="L129">                = p200.getInteger(Utils.COM_PREFIX+&quot;stress.coding&quot;);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (lstress != 0)</span>
<span class="nc" id="L131">                this.stress = new Random(lstress);</span>
        }

<span class="nc" id="L134">        this.effort = effort;</span>
        // The following line &quot;makes sense&quot; but is too much
        // work for a simple heuristic.
        //if (effort &gt; 5)  zipDef.setLevel(effort);

<span class="nc" id="L139">        this.allCodingChoices = allCodingChoices;</span>

        // If effort = 9, look carefully at any solution
        // whose initial metrics are within 1% of the best
        // so far.  If effort = 1, look carefully only at
        // solutions whose initial metrics promise a 1% win.
<span class="nc" id="L145">        this.fuzz = 1 + (0.0025 * (effort-MID_EFFORT));</span>

<span class="nc" id="L147">        int nc = 0;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        for (int i = 0; i &lt; allCodingChoices.length; i++) {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            if (allCodingChoices[i] == null)  continue;</span>
<span class="nc" id="L150">            nc++;</span>
        }
<span class="nc" id="L152">        choices = new Choice[nc];</span>
<span class="nc" id="L153">        nc = 0;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        for (int i = 0; i &lt; allCodingChoices.length; i++) {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (allCodingChoices[i] == null)  continue;</span>
<span class="nc" id="L156">            int[] distance = new int[choices.length];</span>
<span class="nc" id="L157">            choices[nc++] = new Choice(allCodingChoices[i], i, distance);</span>
        }
<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (int i = 0; i &lt; choices.length; i++) {</span>
<span class="nc" id="L160">            Coding ci = choices[i].coding;</span>
<span class="nc bnc" id="L161" title="All 4 branches missed.">            assert(ci.distanceFrom(ci) == 0);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="nc" id="L163">                Coding cj = choices[j].coding;</span>
<span class="nc" id="L164">                int dij = ci.distanceFrom(cj);</span>
<span class="nc bnc" id="L165" title="All 4 branches missed.">                assert(dij &gt; 0);</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">                assert(dij == cj.distanceFrom(ci));</span>
<span class="nc" id="L167">                choices[i].distance[j] = dij;</span>
<span class="nc" id="L168">                choices[j].distance[i] = dij;</span>
            }
        }
<span class="nc" id="L171">    }</span>

    Choice makeExtraChoice(Coding coding) {
<span class="nc" id="L174">        int[] distance = new int[choices.length];</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        for (int i = 0; i &lt; distance.length; i++) {</span>
<span class="nc" id="L176">            Coding ci = choices[i].coding;</span>
<span class="nc" id="L177">            int dij = coding.distanceFrom(ci);</span>
<span class="nc bnc" id="L178" title="All 4 branches missed.">            assert(dij &gt; 0);</span>
<span class="nc bnc" id="L179" title="All 4 branches missed.">            assert(dij == ci.distanceFrom(coding));</span>
<span class="nc" id="L180">            distance[i] = dij;</span>
        }
<span class="nc" id="L182">        Choice c = new Choice(coding, -1, distance);</span>
<span class="nc" id="L183">        c.reset();</span>
<span class="nc" id="L184">        return c;</span>
    }

    ByteArrayOutputStream getContext() {
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (context == null)</span>
<span class="nc" id="L189">            context = new ByteArrayOutputStream(1 &lt;&lt; 16);</span>
<span class="nc" id="L190">        return context;</span>
    }

    // These variables are reset and reused:
    private int[] values;
    private int start, end;  // slice of values
    private int[] deltas;
    private int min, max;
    private Histogram vHist;
    private Histogram dHist;
    private int searchOrder;
    private Choice regularChoice;
    private Choice bestChoice;
    private CodingMethod bestMethod;
    private int bestByteSize;
    private int bestZipSize;
    private int targetSize;   // fuzzed target byte size

    private void reset(int[] values, int start, int end) {
<span class="nc" id="L209">        this.values = values;</span>
<span class="nc" id="L210">        this.start = start;</span>
<span class="nc" id="L211">        this.end = end;</span>
<span class="nc" id="L212">        this.deltas = null;</span>
<span class="nc" id="L213">        this.min = Integer.MAX_VALUE;</span>
<span class="nc" id="L214">        this.max = Integer.MIN_VALUE;</span>
<span class="nc" id="L215">        this.vHist = null;</span>
<span class="nc" id="L216">        this.dHist = null;</span>
<span class="nc" id="L217">        this.searchOrder = 0;</span>
<span class="nc" id="L218">        this.regularChoice = null;</span>
<span class="nc" id="L219">        this.bestChoice = null;</span>
<span class="nc" id="L220">        this.bestMethod = null;</span>
<span class="nc" id="L221">        this.bestZipSize = Integer.MAX_VALUE;</span>
<span class="nc" id="L222">        this.bestByteSize = Integer.MAX_VALUE;</span>
<span class="nc" id="L223">        this.targetSize = Integer.MAX_VALUE;</span>
<span class="nc" id="L224">    }</span>

    public static final int MIN_EFFORT = 1;
    public static final int MID_EFFORT = 5;
    public static final int MAX_EFFORT = 9;

    public static final int POP_EFFORT = MID_EFFORT-1;
    public static final int RUN_EFFORT = MID_EFFORT-2;

    public static final int BYTE_SIZE = 0;
    public static final int ZIP_SIZE = 1;

    CodingMethod choose(int[] values, int start, int end, Coding regular, int[] sizes) {
        // Save the value array
<span class="nc" id="L238">        reset(values, start, end);</span>

<span class="nc bnc" id="L240" title="All 4 branches missed.">        if (effort &lt;= MIN_EFFORT || start &gt;= end) {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            if (sizes != null) {</span>
<span class="nc" id="L242">                int[] computed = computeSizePrivate(regular);</span>
<span class="nc" id="L243">                sizes[BYTE_SIZE] = computed[BYTE_SIZE];</span>
<span class="nc" id="L244">                sizes[ZIP_SIZE]  = computed[ZIP_SIZE];</span>
            }
<span class="nc" id="L246">            return regular;</span>
        }

<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (optUseHistogram) {</span>
<span class="nc" id="L250">            getValueHistogram();</span>
<span class="nc" id="L251">            getDeltaHistogram();</span>
        }

<span class="nc bnc" id="L254" title="All 2 branches missed.">        for (int i = start; i &lt; end; i++) {</span>
<span class="nc" id="L255">            int val = values[i];</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (min &gt; val)  min = val;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            if (max &lt; val)  max = val;</span>
        }

        // Find all the preset choices that might be worth looking at:
<span class="nc" id="L261">        int numChoices = markUsableChoices(regular);</span>

<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (stress != null) {</span>
            // Make a random choice.
<span class="nc" id="L265">            int rand = stress.nextInt(numChoices*2 + 4);</span>
<span class="nc" id="L266">            CodingMethod coding = null;</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            for (int i = 0; i &lt; choices.length; i++) {</span>
<span class="nc" id="L268">                Choice c = choices[i];</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">                if (c.searchOrder &gt;= 0 &amp;&amp; rand-- == 0) {</span>
<span class="nc" id="L270">                    coding = c.coding;</span>
<span class="nc" id="L271">                    break;</span>
                }
            }
<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (coding == null) {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">                if ((rand &amp; 7) != 0) {</span>
<span class="nc" id="L276">                    coding = regular;</span>
                } else {
                    // Pick a totally random coding 6% of the time.
<span class="nc" id="L279">                    coding = stressCoding(min, max);</span>
                }
            }
<span class="nc bnc" id="L282" title="All 6 branches missed.">            if (!disablePopCoding</span>
                &amp;&amp; optUsePopulationCoding
                &amp;&amp; effort &gt;= POP_EFFORT) {
<span class="nc" id="L285">                coding = stressPopCoding(coding);</span>
            }
<span class="nc bnc" id="L287" title="All 6 branches missed.">            if (!disableRunCoding</span>
                &amp;&amp; optUseAdaptiveCoding
                &amp;&amp; effort &gt;= RUN_EFFORT) {
<span class="nc" id="L290">                coding = stressAdaptiveCoding(coding);</span>
            }
<span class="nc" id="L292">            return coding;</span>
        }

<span class="nc" id="L295">        double searchScale = 1.0;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        for (int x = effort; x &lt; MAX_EFFORT; x++) {</span>
<span class="nc" id="L297">            searchScale /= 1.414;  // every 2 effort points doubles work</span>
        }
<span class="nc" id="L299">        int searchOrderLimit = (int)Math.ceil( numChoices * searchScale );</span>

        // Start by evaluating the &quot;regular&quot; choice.
<span class="nc" id="L302">        bestChoice = regularChoice;</span>
<span class="nc" id="L303">        evaluate(regularChoice);</span>
<span class="nc" id="L304">        int maxd = updateDistances(regularChoice);</span>

        // save these first-cut numbers for later
<span class="nc" id="L307">        int zipSize1 = bestZipSize;</span>
<span class="nc" id="L308">        int byteSize1 = bestByteSize;</span>

<span class="nc bnc" id="L310" title="All 4 branches missed.">        if (regularChoice.coding == regular &amp;&amp; topLevel) {</span>
            // Give credit for being the default; no band header is needed.
            // Rather than increasing every other size value by the band
            // header amount, we decrement this one metric, to give it an edge.
            // Decreasing zipSize by a byte length is conservatively correct,
            // especially considering that the escape byte is not likely to
            // zip well with other bytes in the band.
<span class="nc" id="L317">            int X = BandStructure.encodeEscapeValue(_meta_canon_max, regular);</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">            if (regular.canRepresentSigned(X)) {</span>
<span class="nc" id="L319">                int Xlen = regular.getLength(X);  // band coding header</span>
                //regularChoice.histSize -= Xlen; // keep exact byteSize
                //regularChoice.byteSize -= Xlen; // keep exact byteSize
<span class="nc" id="L322">                regularChoice.zipSize -= Xlen;</span>
<span class="nc" id="L323">                bestByteSize = regularChoice.byteSize;</span>
<span class="nc" id="L324">                bestZipSize = regularChoice.zipSize;</span>
            }
        }

<span class="nc" id="L328">        int dscale = 1;</span>
        // Continually select a new choice to evaluate.
<span class="nc bnc" id="L330" title="All 2 branches missed.">        while (searchOrder &lt; searchOrderLimit) {</span>
            Choice nextChoice;
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (dscale &gt; maxd)  dscale = 1;  // cycle dscale values!</span>
<span class="nc" id="L333">            int dhi = maxd / dscale;</span>
<span class="nc" id="L334">            int dlo = maxd / (dscale *= 2) + 1;</span>
<span class="nc" id="L335">            nextChoice = findChoiceNear(bestChoice, dhi, dlo);</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (nextChoice == null)  continue;</span>
<span class="nc bnc" id="L337" title="All 4 branches missed.">            assert(nextChoice.coding.canRepresent(min, max));</span>
<span class="nc" id="L338">            evaluate(nextChoice);</span>
<span class="nc" id="L339">            int nextMaxd = updateDistances(nextChoice);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            if (nextChoice == bestChoice) {</span>
<span class="nc" id="L341">                maxd = nextMaxd;</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                if (verbose &gt; 5)  Utils.log.info(&quot;maxd = &quot;+maxd);</span>
            }
<span class="nc" id="L344">        }</span>

        // Record best &quot;plain coding&quot; choice.
<span class="nc" id="L347">        Coding plainBest = bestChoice.coding;</span>
<span class="nc bnc" id="L348" title="All 4 branches missed.">        assert(plainBest == bestMethod);</span>

<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (verbose &gt; 2) {</span>
<span class="nc" id="L351">            Utils.log.info(&quot;chooser: plain result=&quot;+bestChoice+&quot; after &quot;+bestChoice.searchOrder+&quot; rounds, &quot;+(regularChoice.zipSize-bestZipSize)+&quot; fewer bytes than regular &quot;+regular);</span>
        }
<span class="nc" id="L353">        bestChoice = null;</span>

<span class="nc bnc" id="L355" title="All 8 branches missed.">        if (!disablePopCoding</span>
            &amp;&amp; optUsePopulationCoding
            &amp;&amp; effort &gt;= POP_EFFORT
            &amp;&amp; bestMethod instanceof Coding) {
<span class="nc" id="L359">            tryPopulationCoding(plainBest);</span>
        }

<span class="nc bnc" id="L362" title="All 8 branches missed.">        if (!disableRunCoding</span>
            &amp;&amp; optUseAdaptiveCoding
            &amp;&amp; effort &gt;= RUN_EFFORT
            &amp;&amp; bestMethod instanceof Coding) {
<span class="nc" id="L366">            tryAdaptiveCoding(plainBest);</span>
        }

        // Pass back the requested information:
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (sizes != null) {</span>
<span class="nc" id="L371">            sizes[BYTE_SIZE] = bestByteSize;</span>
<span class="nc" id="L372">            sizes[ZIP_SIZE]  = bestZipSize;</span>
        }
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (verbose &gt; 1) {</span>
<span class="nc" id="L375">            Utils.log.info(&quot;chooser: result=&quot;+bestMethod+&quot; &quot;+</span>
                             (zipSize1-bestZipSize)+
                             &quot; fewer bytes than regular &quot;+regular+
<span class="nc" id="L378">                             &quot;; win=&quot;+pct(zipSize1-bestZipSize, zipSize1));</span>
        }
<span class="nc" id="L380">        CodingMethod lbestMethod = this.bestMethod;</span>
<span class="nc" id="L381">        reset(null, 0, 0);  // for GC</span>
<span class="nc" id="L382">        return lbestMethod;</span>
    }
    CodingMethod choose(int[] values, int start, int end, Coding regular) {
<span class="nc" id="L385">        return choose(values, start, end, regular, null);</span>
    }
    CodingMethod choose(int[] values, Coding regular, int[] sizes) {
<span class="nc" id="L388">        return choose(values, 0, values.length, regular, sizes);</span>
    }
    CodingMethod choose(int[] values, Coding regular) {
<span class="nc" id="L391">        return choose(values, 0, values.length, regular, null);</span>
    }

    private int markUsableChoices(Coding regular) {
<span class="nc" id="L395">        int numChoices = 0;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">        for (int i = 0; i &lt; choices.length; i++) {</span>
<span class="nc" id="L397">            Choice c = choices[i];</span>
<span class="nc" id="L398">            c.reset();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if (!c.coding.canRepresent(min, max)) {</span>
                // Mark as already visited:
<span class="nc" id="L401">                c.searchOrder = -1;</span>
<span class="nc bnc" id="L402" title="All 4 branches missed.">                if (verbose &gt; 1 &amp;&amp; c.coding == regular) {</span>
<span class="nc" id="L403">                    Utils.log.info(&quot;regular coding cannot represent [&quot;+min+&quot;..&quot;+max+&quot;]: &quot;+regular);</span>
                }
                continue;
            }
<span class="nc bnc" id="L407" title="All 2 branches missed.">            if (c.coding == regular)</span>
<span class="nc" id="L408">                regularChoice = c;</span>
<span class="nc" id="L409">            numChoices++;</span>
        }
<span class="nc bnc" id="L411" title="All 4 branches missed.">        if (regularChoice == null &amp;&amp; regular.canRepresent(min, max)) {</span>
<span class="nc" id="L412">            regularChoice = makeExtraChoice(regular);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            if (verbose &gt; 1) {</span>
<span class="nc" id="L414">                Utils.log.info(&quot;*** regular choice is extra: &quot;+regularChoice.coding);</span>
            }
        }
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (regularChoice == null) {</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">            for (int i = 0; i &lt; choices.length; i++) {</span>
<span class="nc" id="L419">                Choice c = choices[i];</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                if (c.searchOrder != -1) {</span>
<span class="nc" id="L421">                    regularChoice = c;  // arbitrary pick</span>
<span class="nc" id="L422">                    break;</span>
                }
            }
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (verbose &gt; 1) {</span>
<span class="nc" id="L426">                Utils.log.info(&quot;*** regular choice does not apply &quot;+regular);</span>
<span class="nc" id="L427">                Utils.log.info(&quot;    using instead &quot;+regularChoice.coding);</span>
            }
        }
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (verbose &gt; 2) {</span>
<span class="nc" id="L431">            Utils.log.info(&quot;chooser: #choices=&quot;+numChoices+&quot; [&quot;+min+&quot;..&quot;+max+&quot;]&quot;);</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">            if (verbose &gt; 4) {</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">                for (int i = 0; i &lt; choices.length; i++) {</span>
<span class="nc" id="L434">                    Choice c = choices[i];</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                    if (c.searchOrder &gt;= 0)</span>
<span class="nc" id="L436">                        Utils.log.info(&quot;  &quot;+c);</span>
                }
            }
        }
<span class="nc" id="L440">        return numChoices;</span>
    }

    // Find an arbitrary choice at least dlo away from a previously
    // evaluated choices, and at most dhi.  Try also to regulate its
    // min distance to all previously evaluated choices, in this range.
    private Choice findChoiceNear(Choice near, int dhi, int dlo) {
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (verbose &gt; 5)</span>
<span class="nc" id="L448">            Utils.log.info(&quot;findChoice &quot;+dhi+&quot;..&quot;+dlo+&quot; near: &quot;+near);</span>
<span class="nc" id="L449">        int[] distance = near.distance;</span>
<span class="nc" id="L450">        Choice found = null;</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">        for (int i = 0; i &lt; choices.length; i++) {</span>
<span class="nc" id="L452">            Choice c = choices[i];</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">            if (c.searchOrder &lt; searchOrder)</span>
<span class="nc" id="L454">                continue;  // already searched</span>
            // Distance from &quot;near&quot; guy must be in bounds:
<span class="nc bnc" id="L456" title="All 4 branches missed.">            if (distance[i] &gt;= dlo &amp;&amp; distance[i] &lt;= dhi) {</span>
                // Try also to keep min-distance from other guys in bounds:
<span class="nc bnc" id="L458" title="All 4 branches missed.">                if (c.minDistance &gt;= dlo &amp;&amp; c.minDistance &lt;= dhi) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">                    if (verbose &gt; 5)</span>
<span class="nc" id="L460">                        Utils.log.info(&quot;findChoice =&gt; good &quot;+c);</span>
<span class="nc" id="L461">                    return c;</span>
                }
<span class="nc" id="L463">                found = c;</span>
            }
        }
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (verbose &gt; 5)</span>
<span class="nc" id="L467">            Utils.log.info(&quot;findChoice =&gt; found &quot;+found);</span>
<span class="nc" id="L468">        return found;</span>
    }

    private void evaluate(Choice c) {
<span class="nc bnc" id="L472" title="All 4 branches missed.">        assert(c.searchOrder == Integer.MAX_VALUE);</span>
<span class="nc" id="L473">        c.searchOrder = searchOrder++;</span>
        boolean mustComputeSize;
<span class="nc bnc" id="L475" title="All 4 branches missed.">        if (c == bestChoice || c.isExtra()) {</span>
<span class="nc" id="L476">            mustComputeSize = true;</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">        } else if (optUseHistogram) {</span>
<span class="nc" id="L478">            Histogram hist = getHistogram(c.coding.isDelta());</span>
<span class="nc" id="L479">            c.histSize = (int)Math.ceil(hist.getBitLength(c.coding) / 8);</span>
<span class="nc" id="L480">            c.byteSize = c.histSize;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            mustComputeSize = (c.byteSize &lt;= targetSize);</span>
<span class="nc" id="L482">        } else {</span>
<span class="nc" id="L483">            mustComputeSize = true;</span>
        }
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if (mustComputeSize) {</span>
<span class="nc" id="L486">            int[] sizes = computeSizePrivate(c.coding);</span>
<span class="nc" id="L487">            c.byteSize = sizes[BYTE_SIZE];</span>
<span class="nc" id="L488">            c.zipSize  = sizes[ZIP_SIZE];</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">            if (noteSizes(c.coding, c.byteSize, c.zipSize))</span>
<span class="nc" id="L490">                bestChoice = c;</span>
        }
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (c.histSize &gt;= 0) {</span>
<span class="nc bnc" id="L493" title="All 4 branches missed.">            assert(c.byteSize == c.histSize);  // models should agree</span>
        }
<span class="nc bnc" id="L495" title="All 2 branches missed.">        if (verbose &gt; 4) {</span>
<span class="nc" id="L496">            Utils.log.info(&quot;evaluated &quot;+c);</span>
        }
<span class="nc" id="L498">    }</span>

    private boolean noteSizes(CodingMethod c, int byteSize, int zipSize) {
<span class="nc bnc" id="L501" title="All 6 branches missed.">        assert(zipSize &gt; 0 &amp;&amp; byteSize &gt; 0);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        boolean better = (zipSize &lt; bestZipSize);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (verbose &gt; 3)</span>
<span class="nc bnc" id="L504" title="All 4 branches missed.">            Utils.log.info(&quot;computed size &quot;+c+&quot; &quot;+byteSize+&quot;/zs=&quot;+zipSize+</span>
                             ((better &amp;&amp; bestMethod != null)?
                              (&quot; better by &quot;+
<span class="nc" id="L507">                               pct(bestZipSize - zipSize, zipSize)): &quot;&quot;));</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (better) {</span>
<span class="nc" id="L509">            bestMethod = c;</span>
<span class="nc" id="L510">            bestZipSize = zipSize;</span>
<span class="nc" id="L511">            bestByteSize = byteSize;</span>
<span class="nc" id="L512">            targetSize = (int)(byteSize * fuzz);</span>
<span class="nc" id="L513">            return true;</span>
        } else {
<span class="nc" id="L515">            return false;</span>
        }
    }


    private int updateDistances(Choice c) {
        // update all minDistance values in still unevaluated choices
<span class="nc" id="L522">        int[] distance = c.distance;</span>
<span class="nc" id="L523">        int maxd = 0;  // how far is c from everybody else?</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">        for (int i = 0; i &lt; choices.length; i++) {</span>
<span class="nc" id="L525">            Choice c2 = choices[i];</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">            if (c2.searchOrder &lt; searchOrder)</span>
<span class="nc" id="L527">                continue;</span>
<span class="nc" id="L528">            int d = distance[i];</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">            if (verbose &gt; 5)</span>
<span class="nc" id="L530">                Utils.log.info(&quot;evaluate dist &quot;+d+&quot; to &quot;+c2);</span>
<span class="nc" id="L531">            int mind = c2.minDistance;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">            if (mind &gt; d)</span>
<span class="nc" id="L533">                c2.minDistance = mind = d;</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">            if (maxd &lt; d)</span>
<span class="nc" id="L535">                maxd = d;</span>
        }
        // Now maxd has the distance of the farthest outlier
        // from all evaluated choices.
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (verbose &gt; 5)</span>
<span class="nc" id="L540">            Utils.log.info(&quot;evaluate maxd =&gt; &quot;+maxd);</span>
<span class="nc" id="L541">        return maxd;</span>
    }

    // Compute the coded size of a sequence of values.
    // The first int is the size in uncompressed bytes.
    // The second is an estimate of the compressed size of these bytes.
    public void computeSize(CodingMethod c, int[] values, int start, int end, int[] sizes) {
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (end &lt;= start) {</span>
<span class="nc" id="L549">            sizes[BYTE_SIZE] = sizes[ZIP_SIZE] = 0;</span>
<span class="nc" id="L550">            return;</span>
        }
        try {
<span class="nc" id="L553">            resetData();</span>
<span class="nc" id="L554">            c.writeArrayTo(byteSizer, values, start, end);</span>
<span class="nc" id="L555">            sizes[BYTE_SIZE] = getByteSize();</span>
<span class="nc" id="L556">            sizes[ZIP_SIZE] = getZipSize();</span>
<span class="nc" id="L557">        } catch (IOException ee) {</span>
<span class="nc" id="L558">            throw new RuntimeException(ee); // cannot happen</span>
<span class="nc" id="L559">        }</span>
<span class="nc" id="L560">    }</span>
    public void computeSize(CodingMethod c, int[] values, int[] sizes) {
<span class="nc" id="L562">        computeSize(c, values, 0, values.length, sizes);</span>
<span class="nc" id="L563">    }</span>
    public int[] computeSize(CodingMethod c, int[] values, int start, int end) {
<span class="nc" id="L565">        int[] sizes = { 0, 0 };</span>
<span class="nc" id="L566">        computeSize(c, values, start, end, sizes);</span>
<span class="nc" id="L567">        return sizes;</span>
    }
    public int[] computeSize(CodingMethod c, int[] values) {
<span class="nc" id="L570">        return computeSize(c, values, 0, values.length);</span>
    }
    // This version uses the implicit local arguments
    private int[] computeSizePrivate(CodingMethod c) {
<span class="nc" id="L574">        int[] sizes = { 0, 0 };</span>
<span class="nc" id="L575">        computeSize(c, values, start, end, sizes);</span>
<span class="nc" id="L576">        return sizes;</span>
    }
    public int computeByteSize(CodingMethod cm, int[] values, int start, int end) {
<span class="nc" id="L579">        int len = end-start;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (len &lt; 0) {</span>
<span class="nc" id="L581">            return 0;</span>
        }
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (cm instanceof Coding) {</span>
<span class="nc" id="L584">            Coding c = (Coding) cm;</span>
<span class="nc" id="L585">            int size = c.getLength(values, start, end);</span>
            int size2;
<span class="nc bnc" id="L587" title="All 4 branches missed.">            assert(size == (size2=countBytesToSizer(cm, values, start, end)))</span>
                : (cm+&quot; : &quot;+size+&quot; != &quot;+size2);
<span class="nc" id="L589">            return size;</span>
        }
<span class="nc" id="L591">        return countBytesToSizer(cm, values, start, end);</span>
    }
    private int countBytesToSizer(CodingMethod cm, int[] values, int start, int end) {
        try {
<span class="nc" id="L595">            byteOnlySizer.reset();</span>
<span class="nc" id="L596">            cm.writeArrayTo(byteOnlySizer, values, start, end);</span>
<span class="nc" id="L597">            return byteOnlySizer.getSize();</span>
<span class="nc" id="L598">        } catch (IOException ee) {</span>
<span class="nc" id="L599">            throw new RuntimeException(ee); // cannot happen</span>
        }
    }

    int[] getDeltas(int min, int max) {
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if ((min|max) != 0)</span>
<span class="nc" id="L605">            return Coding.makeDeltas(values, start, end, min, max);</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">        if (deltas == null) {</span>
<span class="nc" id="L607">            deltas = Coding.makeDeltas(values, start, end, 0, 0);</span>
        }
<span class="nc" id="L609">        return deltas;</span>
    }
    Histogram getValueHistogram() {
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (vHist == null) {</span>
<span class="nc" id="L613">            vHist = new Histogram(values, start, end);</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">            if (verbose &gt; 3) {</span>
<span class="nc" id="L615">                vHist.print(&quot;vHist&quot;, System.out);</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">            } else if (verbose &gt; 1) {</span>
<span class="nc" id="L617">                vHist.print(&quot;vHist&quot;, null, System.out);</span>
            }
        }
<span class="nc" id="L620">        return vHist;</span>
    }
    Histogram getDeltaHistogram() {
<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (dHist == null) {</span>
<span class="nc" id="L624">            dHist = new Histogram(getDeltas(0, 0));</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">            if (verbose &gt; 3) {</span>
<span class="nc" id="L626">                dHist.print(&quot;dHist&quot;, System.out);</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">            } else if (verbose &gt; 1) {</span>
<span class="nc" id="L628">                dHist.print(&quot;dHist&quot;, null, System.out);</span>
            }
        }
<span class="nc" id="L631">        return dHist;</span>
    }
    Histogram getHistogram(boolean isDelta) {
<span class="nc bnc" id="L634" title="All 2 branches missed.">        return isDelta ? getDeltaHistogram(): getValueHistogram();</span>
    }

    private void tryPopulationCoding(Coding plainCoding) {
        // assert(plainCoding.canRepresent(min, max));
<span class="nc" id="L639">        Histogram hist = getValueHistogram();</span>
        // Start with &quot;reasonable&quot; default codings.
        final int approxL = 64;
<span class="nc" id="L642">        Coding favoredCoding = plainCoding.getValueCoding();</span>
<span class="nc" id="L643">        Coding tokenCoding = BandStructure.UNSIGNED5.setL(approxL);</span>
<span class="nc" id="L644">        Coding unfavoredCoding = plainCoding.getValueCoding();</span>
        // There's going to be a band header.  Estimate conservatively large.
        final int BAND_HEADER = 4;
        // Keep a running model of the predicted sizes of the F/T/U sequences.
        int currentFSize;
        int currentTSize;
        int currentUSize;
        // Start by assuming a degenerate favored-value length of 0,
        // which looks like a bunch of zero tokens followed by the
        // original sequence.
        // The {F} list ends with a repeated F value; find worst case:
<span class="nc" id="L655">        currentFSize =</span>
<span class="nc" id="L656">            BAND_HEADER + Math.max(favoredCoding.getLength(min),</span>
<span class="nc" id="L657">                                   favoredCoding.getLength(max));</span>
        // The {T} list starts out a bunch of zeros, each of length 1.
<span class="nc" id="L659">        final int ZERO_LEN = tokenCoding.getLength(0);</span>
<span class="nc" id="L660">        currentTSize = ZERO_LEN * (end-start);</span>
        // The {U} list starts out a copy of the plainCoding:
<span class="nc" id="L662">        currentUSize = (int) Math.ceil(hist.getBitLength(unfavoredCoding) / 8);</span>

<span class="nc" id="L664">        int bestPopSize = (currentFSize + currentTSize + currentUSize);</span>
<span class="nc" id="L665">        int bestPopFVC  = 0;</span>

        // Record all the values, in decreasing order of favor.
<span class="nc" id="L668">        int[] allFavoredValues = new int[1+hist.getTotalLength()];</span>
        //int[] allPopSizes    = new int[1+hist.getTotalLength()];

        // What sizes are &quot;interesting&quot;?
<span class="nc" id="L672">        int targetLowFVC = -1;</span>
<span class="nc" id="L673">        int targetHighFVC = -1;</span>

        // For each length, adjust the currentXSize model, and look for a win.
<span class="nc" id="L676">        int[][] matrix = hist.getMatrix();</span>
<span class="nc" id="L677">        int mrow = -1;</span>
<span class="nc" id="L678">        int mcol = 1;</span>
<span class="nc" id="L679">        int mrowFreq = 0;</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">        for (int fvcount = 1; fvcount &lt;= hist.getTotalLength(); fvcount++) {</span>
            // The {F} list gets an additional member.
            // Take it from the end of the current matrix row.
            // (It's the end, so that we get larger favored values first.)
<span class="nc bnc" id="L684" title="All 2 branches missed.">            if (mcol == 1) {</span>
<span class="nc" id="L685">                mrow += 1;</span>
<span class="nc" id="L686">                mrowFreq = matrix[mrow][0];</span>
<span class="nc" id="L687">                mcol = matrix[mrow].length;</span>
            }
<span class="nc" id="L689">            int thisValue = matrix[mrow][--mcol];</span>
<span class="nc" id="L690">            allFavoredValues[fvcount] = thisValue;</span>
<span class="nc" id="L691">            int thisVLen = favoredCoding.getLength(thisValue);</span>
<span class="nc" id="L692">            currentFSize += thisVLen;</span>
            // The token list replaces occurrences of zero with a new token:
<span class="nc" id="L694">            int thisVCount = mrowFreq;</span>
<span class="nc" id="L695">            int thisToken = fvcount;</span>
<span class="nc" id="L696">            currentTSize += (tokenCoding.getLength(thisToken)</span>
                             - ZERO_LEN) * thisVCount;
            // The unfavored list loses occurrences of the newly favored value.
            // (This is the whole point of the exercise!)
<span class="nc" id="L700">            currentUSize -= thisVLen * thisVCount;</span>
<span class="nc" id="L701">            int currentSize = (currentFSize + currentTSize + currentUSize);</span>
            //allPopSizes[fvcount] = currentSize;
<span class="nc bnc" id="L703" title="All 2 branches missed.">            if (bestPopSize &gt; currentSize) {</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                if (currentSize &lt;= targetSize) {</span>
<span class="nc" id="L705">                    targetHighFVC = fvcount;</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                    if (targetLowFVC &lt; 0)</span>
<span class="nc" id="L707">                        targetLowFVC = fvcount;</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">                    if (verbose &gt; 4)</span>
<span class="nc" id="L709">                        Utils.log.info(&quot;better pop-size at fvc=&quot;+fvcount+</span>
<span class="nc" id="L710">                                         &quot; by &quot;+pct(bestPopSize-currentSize,</span>
                                                    bestPopSize));
                }
<span class="nc" id="L713">                bestPopSize = currentSize;</span>
<span class="nc" id="L714">                bestPopFVC = fvcount;</span>
            }
        }
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (targetLowFVC &lt; 0) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if (verbose &gt; 1) {</span>
                // Complete loss.
<span class="nc bnc" id="L720" title="All 2 branches missed.">                if (verbose &gt; 1)</span>
<span class="nc" id="L721">                    Utils.log.info(&quot;no good pop-size; best was &quot;+</span>
                                     bestPopSize+&quot; at &quot;+bestPopFVC+
                                     &quot; worse by &quot;+
<span class="nc" id="L724">                                     pct(bestPopSize-bestByteSize,</span>
                                         bestByteSize));
            }
<span class="nc" id="L727">            return;</span>
        }
<span class="nc bnc" id="L729" title="All 2 branches missed.">        if (verbose &gt; 1)</span>
<span class="nc" id="L730">            Utils.log.info(&quot;initial best pop-size at fvc=&quot;+bestPopFVC+</span>
                             &quot; in [&quot;+targetLowFVC+&quot;..&quot;+targetHighFVC+&quot;]&quot;+
<span class="nc" id="L732">                             &quot; by &quot;+pct(bestByteSize-bestPopSize,</span>
                                        bestByteSize));
<span class="nc" id="L734">        int oldZipSize = bestZipSize;</span>
        // Now close onto a specific coding, testing more rigorously
        // with the zipSize metric.
        // Questions to decide:
        //   1. How many favored values?
        //   2. What token coding (TC)?
        //   3. Sort favored values by value within length brackets?
        //   4. What favored coding?
        //   5. What unfavored coding?
        // Steps 1/2/3 are interdependent, and may be iterated.
        // Steps 4 and 5 may be decided independently afterward.
<span class="nc" id="L745">        int[] LValuesCoded = PopulationCoding.LValuesCoded;</span>
<span class="nc" id="L746">        List&lt;Coding&gt; bestFits = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L747">        List&lt;Coding&gt; fullFits = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L748">        List&lt;Coding&gt; longFits = new ArrayList&lt;&gt;();</span>
        final int PACK_TO_MAX_S = 1;
<span class="nc bnc" id="L750" title="All 2 branches missed.">        if (bestPopFVC &lt;= 255) {</span>
<span class="nc" id="L751">            bestFits.add(BandStructure.BYTE1);</span>
        } else {
<span class="nc" id="L753">            int bestB = Coding.B_MAX;</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">            boolean doFullAlso = (effort &gt; POP_EFFORT);</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">            if (doFullAlso)</span>
<span class="nc" id="L756">                fullFits.add(BandStructure.BYTE1.setS(PACK_TO_MAX_S));</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            for (int i = LValuesCoded.length-1; i &gt;= 1; i--) {</span>
<span class="nc" id="L758">                int L = LValuesCoded[i];</span>
<span class="nc" id="L759">                Coding c0 = PopulationCoding.fitTokenCoding(targetLowFVC,  L);</span>
<span class="nc" id="L760">                Coding c1 = PopulationCoding.fitTokenCoding(bestPopFVC,    L);</span>
<span class="nc" id="L761">                Coding c3 = PopulationCoding.fitTokenCoding(targetHighFVC, L);</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">                if (c1 != null) {</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">                    if (!bestFits.contains(c1))</span>
<span class="nc" id="L764">                        bestFits.add(c1);</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">                    if (bestB &gt; c1.B())</span>
<span class="nc" id="L766">                        bestB = c1.B();</span>
                }
<span class="nc bnc" id="L768" title="All 2 branches missed.">                if (doFullAlso) {</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                    if (c3 == null)  c3 = c1;</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">                    for (int B = c0.B(); B &lt;= c3.B(); B++) {</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">                        if (B == c1.B())  continue;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">                        if (B == 1)  continue;</span>
<span class="nc" id="L773">                        Coding c2 = c3.setB(B).setS(PACK_TO_MAX_S);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">                        if (!fullFits.contains(c2))</span>
<span class="nc" id="L775">                            fullFits.add(c2);</span>
                    }
                }
            }
            // interleave all B greater than bestB with best and full fits
<span class="nc bnc" id="L780" title="All 2 branches missed.">            for (Iterator&lt;Coding&gt; i = bestFits.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L781">                Coding c = i.next();</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">                if (c.B() &gt; bestB) {</span>
<span class="nc" id="L783">                    i.remove();</span>
<span class="nc" id="L784">                    longFits.add(0, c);</span>
                }
<span class="nc" id="L786">            }</span>
        }
<span class="nc" id="L788">        List&lt;Coding&gt; allFits = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L789">        for (Iterator&lt;Coding&gt; i = bestFits.iterator(),</span>
<span class="nc" id="L790">                      j = fullFits.iterator(),</span>
<span class="nc" id="L791">                      k = longFits.iterator();</span>
<span class="nc bnc" id="L792" title="All 6 branches missed.">             i.hasNext() || j.hasNext() || k.hasNext(); ) {</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">            if (i.hasNext())  allFits.add(i.next());</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">            if (j.hasNext())  allFits.add(j.next());</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">            if (k.hasNext())  allFits.add(k.next());</span>
        }
<span class="nc" id="L797">        bestFits.clear();</span>
<span class="nc" id="L798">        fullFits.clear();</span>
<span class="nc" id="L799">        longFits.clear();</span>
<span class="nc" id="L800">        int maxFits = allFits.size();</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">        if (effort == POP_EFFORT)</span>
<span class="nc" id="L802">            maxFits = 2;</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">        else if (maxFits &gt; 4) {</span>
<span class="nc" id="L804">            maxFits -= 4;</span>
<span class="nc" id="L805">            maxFits = (maxFits * (effort-POP_EFFORT)</span>
                       ) / (MAX_EFFORT-POP_EFFORT);
<span class="nc" id="L807">            maxFits += 4;</span>
        }
<span class="nc bnc" id="L809" title="All 2 branches missed.">        if (allFits.size() &gt; maxFits) {</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">            if (verbose &gt; 4)</span>
<span class="nc" id="L811">                Utils.log.info(&quot;allFits before clip: &quot;+allFits);</span>
<span class="nc" id="L812">            allFits.subList(maxFits, allFits.size()).clear();</span>
        }
<span class="nc bnc" id="L814" title="All 2 branches missed.">        if (verbose &gt; 3)</span>
<span class="nc" id="L815">            Utils.log.info(&quot;allFits: &quot;+allFits);</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">        for (Coding tc : allFits) {</span>
<span class="nc" id="L817">            boolean packToMax = false;</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">            if (tc.S() == PACK_TO_MAX_S) {</span>
                // Kludge:  setS(PACK_TO_MAX_S) means packToMax here.
<span class="nc" id="L820">                packToMax = true;</span>
<span class="nc" id="L821">                tc = tc.setS(0);</span>
            }
            int fVlen;
<span class="nc bnc" id="L824" title="All 2 branches missed.">            if (!packToMax) {</span>
<span class="nc" id="L825">                fVlen = bestPopFVC;</span>
<span class="nc bnc" id="L826" title="All 4 branches missed.">                assert(tc.umax() &gt;= fVlen);</span>
<span class="nc bnc" id="L827" title="All 6 branches missed.">                assert(tc.B() == 1 || tc.setB(tc.B()-1).umax() &lt; fVlen);</span>
            } else {
<span class="nc" id="L829">                fVlen = Math.min(tc.umax(), targetHighFVC);</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">                if (fVlen &lt; targetLowFVC)</span>
<span class="nc" id="L831">                    continue;</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">                if (fVlen == bestPopFVC)</span>
<span class="nc" id="L833">                    continue;  // redundant test</span>
            }
<span class="nc" id="L835">            PopulationCoding pop = new PopulationCoding();</span>
<span class="nc" id="L836">            pop.setHistogram(hist);</span>
<span class="nc" id="L837">            pop.setL(tc.L());</span>
<span class="nc" id="L838">            pop.setFavoredValues(allFavoredValues, fVlen);</span>
<span class="nc bnc" id="L839" title="All 4 branches missed.">            assert(pop.tokenCoding == tc);  // predict correctly</span>
<span class="nc" id="L840">            pop.resortFavoredValues();</span>
<span class="nc" id="L841">            int[] tcsizes =</span>
<span class="nc" id="L842">                computePopSizePrivate(pop,</span>
                                      favoredCoding, unfavoredCoding);
<span class="nc" id="L844">            noteSizes(pop, tcsizes[BYTE_SIZE], BAND_HEADER+tcsizes[ZIP_SIZE]);</span>
<span class="nc" id="L845">        }</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">        if (verbose &gt; 3) {</span>
<span class="nc" id="L847">            Utils.log.info(&quot;measured best pop, size=&quot;+bestByteSize+</span>
                             &quot;/zs=&quot;+bestZipSize+
                             &quot; better by &quot;+
<span class="nc" id="L850">                             pct(oldZipSize-bestZipSize, oldZipSize));</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">            if (bestZipSize &lt; oldZipSize) {</span>
<span class="nc" id="L852">                Utils.log.info(&quot;&gt;&gt;&gt; POP WINS BY &quot;+</span>
                                 (oldZipSize - bestZipSize));
            }
        }
<span class="nc" id="L856">    }</span>

    private
    int[] computePopSizePrivate(PopulationCoding pop,
                                Coding favoredCoding,
                                Coding unfavoredCoding) {
<span class="nc bnc" id="L862" title="All 2 branches missed.">        if (popHelper == null) {</span>
<span class="nc" id="L863">            popHelper = new CodingChooser(effort, allCodingChoices);</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">            if (stress != null)</span>
<span class="nc" id="L865">                popHelper.addStressSeed(stress.nextInt());</span>
<span class="nc" id="L866">            popHelper.topLevel = false;</span>
<span class="nc" id="L867">            popHelper.verbose -= 1;</span>
<span class="nc" id="L868">            popHelper.disablePopCoding = true;</span>
<span class="nc" id="L869">            popHelper.disableRunCoding = this.disableRunCoding;</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">            if (effort &lt; MID_EFFORT)</span>
                // No nested run codings.
<span class="nc" id="L872">                popHelper.disableRunCoding = true;</span>
        }
<span class="nc" id="L874">        int fVlen = pop.fVlen;</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">        if (verbose &gt; 2) {</span>
<span class="nc" id="L876">            Utils.log.info(&quot;computePopSizePrivate fvlen=&quot;+fVlen+</span>
                             &quot; tc=&quot;+pop.tokenCoding);
<span class="nc" id="L878">            Utils.log.info(&quot;{ //BEGIN&quot;);</span>
        }

        // Find good coding choices for the token and unfavored sequences.
<span class="nc" id="L882">        int[] favoredValues = pop.fValues;</span>
<span class="nc" id="L883">        int[][] vals = pop.encodeValues(values, start, end);</span>
<span class="nc" id="L884">        int[] tokens = vals[0];</span>
<span class="nc" id="L885">        int[] unfavoredValues = vals[1];</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">        if (verbose &gt; 2)</span>
<span class="nc" id="L887">            Utils.log.info(&quot;-- refine on fv[&quot;+fVlen+&quot;] fc=&quot;+favoredCoding);</span>
<span class="nc" id="L888">        pop.setFavoredCoding(popHelper.choose(favoredValues, 1, 1+fVlen, favoredCoding));</span>
<span class="nc bnc" id="L889" title="All 4 branches missed.">        if (pop.tokenCoding instanceof Coding &amp;&amp;</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">            (stress == null || stress.nextBoolean())) {</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">            if (verbose &gt; 2)</span>
<span class="nc" id="L892">                Utils.log.info(&quot;-- refine on tv[&quot;+tokens.length+&quot;] tc=&quot;+pop.tokenCoding);</span>
<span class="nc" id="L893">            CodingMethod tc = popHelper.choose(tokens, (Coding) pop.tokenCoding);</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">            if (tc != pop.tokenCoding) {</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">                if (verbose &gt; 2)</span>
<span class="nc" id="L896">                    Utils.log.info(&quot;&gt;&gt;&gt; refined tc=&quot;+tc);</span>
<span class="nc" id="L897">                pop.setTokenCoding(tc);</span>
            }
        }
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (unfavoredValues.length == 0)</span>
<span class="nc" id="L901">            pop.setUnfavoredCoding(null);</span>
        else {
<span class="nc bnc" id="L903" title="All 2 branches missed.">            if (verbose &gt; 2)</span>
<span class="nc" id="L904">                Utils.log.info(&quot;-- refine on uv[&quot;+unfavoredValues.length+&quot;] uc=&quot;+pop.unfavoredCoding);</span>
<span class="nc" id="L905">            pop.setUnfavoredCoding(popHelper.choose(unfavoredValues, unfavoredCoding));</span>
        }
<span class="nc bnc" id="L907" title="All 2 branches missed.">        if (verbose &gt; 3) {</span>
<span class="nc" id="L908">            Utils.log.info(&quot;finish computePopSizePrivate fvlen=&quot;+fVlen+</span>
                             &quot; fc=&quot;+pop.favoredCoding+
                             &quot; tc=&quot;+pop.tokenCoding+
                             &quot; uc=&quot;+pop.unfavoredCoding);
            //pop.hist.print(&quot;pop-hist&quot;, null, System.out);
<span class="nc" id="L913">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L914">            sb.append(&quot;fv = {&quot;);</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">            for (int i = 1; i &lt;= fVlen; i++) {</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">                if ((i % 10) == 0)</span>
<span class="nc" id="L917">                    sb.append('\n');</span>
<span class="nc" id="L918">                sb.append(&quot; &quot;).append(favoredValues[i]);</span>
            }
<span class="nc" id="L920">            sb.append('\n');</span>
<span class="nc" id="L921">            sb.append(&quot;}&quot;);</span>
<span class="nc" id="L922">            Utils.log.info(sb.toString());</span>
        }
<span class="nc bnc" id="L924" title="All 2 branches missed.">        if (verbose &gt; 2) {</span>
<span class="nc" id="L925">            Utils.log.info(&quot;} //END&quot;);</span>
        }
<span class="nc bnc" id="L927" title="All 2 branches missed.">        if (stress != null) {</span>
<span class="nc" id="L928">            return null;  // do not bother with size computation</span>
        }
        int[] sizes;
        try {
<span class="nc" id="L932">            resetData();</span>
            // Write the array of favored values.
<span class="nc" id="L934">            pop.writeSequencesTo(byteSizer, tokens, unfavoredValues);</span>
<span class="nc" id="L935">            sizes = new int[] { getByteSize(), getZipSize() };</span>
<span class="nc" id="L936">        } catch (IOException ee) {</span>
<span class="nc" id="L937">            throw new RuntimeException(ee); // cannot happen</span>
<span class="nc" id="L938">        }</span>
<span class="nc" id="L939">        int[] checkSizes = null;</span>
<span class="nc bnc" id="L940" title="All 4 branches missed.">        assert((checkSizes = computeSizePrivate(pop)) != null);</span>
<span class="nc bnc" id="L941" title="All 4 branches missed.">        assert(checkSizes[BYTE_SIZE] == sizes[BYTE_SIZE])</span>
            : (checkSizes[BYTE_SIZE]+&quot; != &quot;+sizes[BYTE_SIZE]);
<span class="nc" id="L943">        return sizes;</span>
    }

    private void tryAdaptiveCoding(Coding plainCoding) {
<span class="nc" id="L947">        int oldZipSize = bestZipSize;</span>
        // Scan the value sequence, determining whether an interesting
        // run occupies too much space.  (&quot;Too much&quot; means, say 5% more
        // than the average integer size of the band as a whole.)
        // Try to find a better coding for those segments.
<span class="nc" id="L952">        int   lstart  = this.start;</span>
<span class="nc" id="L953">        int   lend    = this.end;</span>
<span class="nc" id="L954">        int[] lvalues = this.values;</span>
<span class="nc" id="L955">        int len = lend-lstart;</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">        if (plainCoding.isDelta()) {</span>
<span class="nc" id="L957">            lvalues = getDeltas(0,0); //%%% not quite right!</span>
<span class="nc" id="L958">            lstart = 0;</span>
<span class="nc" id="L959">            lend = lvalues.length;</span>
        }
<span class="nc" id="L961">        int[] sizes = new int[len+1];</span>
<span class="nc" id="L962">        int fillp = 0;</span>
<span class="nc" id="L963">        int totalSize = 0;</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">        for (int i = lstart; i &lt; lend; i++) {</span>
<span class="nc" id="L965">            int val = lvalues[i];</span>
<span class="nc" id="L966">            sizes[fillp++] = totalSize;</span>
<span class="nc" id="L967">            int size = plainCoding.getLength(val);</span>
<span class="nc bnc" id="L968" title="All 4 branches missed.">            assert(size &lt; Integer.MAX_VALUE);</span>
            //System.out.println(&quot;len &quot;+val+&quot; = &quot;+size);
<span class="nc" id="L970">            totalSize += size;</span>
        }
<span class="nc" id="L972">        sizes[fillp++] = totalSize;</span>
<span class="nc bnc" id="L973" title="All 4 branches missed.">        assert(fillp == sizes.length);</span>
<span class="nc" id="L974">        double avgSize = (double)totalSize / len;</span>
        double sizeFuzz;
        double sizeFuzz2;
        double sizeFuzz3;
<span class="nc bnc" id="L978" title="All 2 branches missed.">        if (effort &gt;= MID_EFFORT) {</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">            if (effort &gt; MID_EFFORT+1)</span>
<span class="nc" id="L980">                sizeFuzz = 1.001;</span>
            else
<span class="nc" id="L982">                sizeFuzz = 1.003;</span>
        } else {
<span class="nc bnc" id="L984" title="All 2 branches missed.">            if (effort &gt; RUN_EFFORT)</span>
<span class="nc" id="L985">                sizeFuzz = 1.01;</span>
            else
<span class="nc" id="L987">                sizeFuzz = 1.03;</span>
        }
        // for now:
<span class="nc" id="L990">        sizeFuzz *= sizeFuzz; // double the thresh</span>
<span class="nc" id="L991">        sizeFuzz2 = (sizeFuzz*sizeFuzz);</span>
<span class="nc" id="L992">        sizeFuzz3 = (sizeFuzz*sizeFuzz*sizeFuzz);</span>
        // Find some mesh scales we like.
<span class="nc" id="L994">        double[] dmeshes = new double[1 + (effort-RUN_EFFORT)];</span>
<span class="nc" id="L995">        double logLen = Math.log(len);</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">        for (int i = 0; i &lt; dmeshes.length; i++) {</span>
<span class="nc" id="L997">            dmeshes[i] = Math.exp(logLen*(i+1)/(dmeshes.length+1));</span>
        }
<span class="nc" id="L999">        int[] meshes = new int[dmeshes.length];</span>
<span class="nc" id="L1000">        int mfillp = 0;</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">        for (int i = 0; i &lt; dmeshes.length; i++) {</span>
<span class="nc" id="L1002">            int m = (int)Math.round(dmeshes[i]);</span>
<span class="nc" id="L1003">            m = AdaptiveCoding.getNextK(m-1);</span>
<span class="nc bnc" id="L1004" title="All 4 branches missed.">            if (m &lt;= 0 || m &gt;= len)  continue;</span>
<span class="nc bnc" id="L1005" title="All 4 branches missed.">            if (mfillp &gt; 0 &amp;&amp; m == meshes[mfillp-1])  continue;</span>
<span class="nc" id="L1006">            meshes[mfillp++] = m;</span>
        }
<span class="nc" id="L1008">        meshes = BandStructure.realloc(meshes, mfillp);</span>
        // There's going to be a band header.  Estimate conservatively large.
        final int BAND_HEADER = 4; // op, KB, A, B
        // Threshold values for a &quot;too big&quot; mesh.
<span class="nc" id="L1012">        int[]    threshes = new int[meshes.length];</span>
<span class="nc" id="L1013">        double[] fuzzes   = new double[meshes.length];</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">        for (int i = 0; i &lt; meshes.length; i++) {</span>
<span class="nc" id="L1015">            int mesh = meshes[i];</span>
            double lfuzz;
<span class="nc bnc" id="L1017" title="All 2 branches missed.">            if (mesh &lt; 10)</span>
<span class="nc" id="L1018">                lfuzz = sizeFuzz3;</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">            else if (mesh &lt; 100)</span>
<span class="nc" id="L1020">                lfuzz = sizeFuzz2;</span>
            else
<span class="nc" id="L1022">                lfuzz = sizeFuzz;</span>
<span class="nc" id="L1023">            fuzzes[i] = lfuzz;</span>
<span class="nc" id="L1024">            threshes[i] = BAND_HEADER + (int)Math.ceil(mesh * avgSize * lfuzz);</span>
        }
<span class="nc bnc" id="L1026" title="All 2 branches missed.">        if (verbose &gt; 1) {</span>
<span class="nc" id="L1027">            System.out.print(&quot;tryAdaptiveCoding [&quot;+len+&quot;]&quot;+</span>
                             &quot; avgS=&quot;+avgSize+&quot; fuzz=&quot;+sizeFuzz+
                             &quot; meshes: {&quot;);
<span class="nc bnc" id="L1030" title="All 2 branches missed.">            for (int i = 0; i &lt; meshes.length; i++) {</span>
<span class="nc" id="L1031">                System.out.print(&quot; &quot; + meshes[i] + &quot;(&quot; + threshes[i] + &quot;)&quot;);</span>
            }
<span class="nc" id="L1033">            Utils.log.info(&quot; }&quot;);</span>
        }
<span class="nc bnc" id="L1035" title="All 2 branches missed.">        if (runHelper == null) {</span>
<span class="nc" id="L1036">            runHelper = new CodingChooser(effort, allCodingChoices);</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (stress != null)</span>
<span class="nc" id="L1038">                runHelper.addStressSeed(stress.nextInt());</span>
<span class="nc" id="L1039">            runHelper.topLevel = false;</span>
<span class="nc" id="L1040">            runHelper.verbose -= 1;</span>
<span class="nc" id="L1041">            runHelper.disableRunCoding = true;</span>
<span class="nc" id="L1042">            runHelper.disablePopCoding = this.disablePopCoding;</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            if (effort &lt; MID_EFFORT)</span>
                // No nested pop codings.
<span class="nc" id="L1045">                runHelper.disablePopCoding = true;</span>
        }
<span class="nc bnc" id="L1047" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L1048">            i = AdaptiveCoding.getNextK(i-1);</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">            if (i &gt; len)  i = len;</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            for (int j = meshes.length-1; j &gt;= 0; j--) {</span>
<span class="nc" id="L1051">                int mesh   = meshes[j];</span>
<span class="nc" id="L1052">                int thresh = threshes[j];</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                if (i+mesh &gt; len)  continue;</span>
<span class="nc" id="L1054">                int size = sizes[i+mesh] - sizes[i];</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">                if (size &gt;= thresh) {</span>
                    // Found a size bulge.
<span class="nc" id="L1057">                    int bend  = i+mesh;</span>
<span class="nc" id="L1058">                    int bsize = size;</span>
<span class="nc" id="L1059">                    double bigSize = avgSize * fuzzes[j];</span>
<span class="nc bnc" id="L1060" title="All 4 branches missed.">                    while (bend &lt; len &amp;&amp; (bend-i) &lt;= len/2) {</span>
<span class="nc" id="L1061">                        int bend0 = bend;</span>
<span class="nc" id="L1062">                        int bsize0 = bsize;</span>
<span class="nc" id="L1063">                        bend += mesh;</span>
<span class="nc" id="L1064">                        bend = i+AdaptiveCoding.getNextK(bend-i-1);</span>
<span class="nc bnc" id="L1065" title="All 4 branches missed.">                        if (bend &lt; 0 || bend &gt; len)</span>
<span class="nc" id="L1066">                            bend = len;</span>
<span class="nc" id="L1067">                        bsize = sizes[bend]-sizes[i];</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                        if (bsize &lt; BAND_HEADER + (bend-i) * bigSize) {</span>
<span class="nc" id="L1069">                            bsize = bsize0;</span>
<span class="nc" id="L1070">                            bend = bend0;</span>
<span class="nc" id="L1071">                            break;</span>
                        }
<span class="nc" id="L1073">                    }</span>
<span class="nc" id="L1074">                    int nexti = bend;</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">                    if (verbose &gt; 2) {</span>
<span class="nc" id="L1076">                        Utils.log.info(&quot;bulge at &quot;+i+&quot;[&quot;+(bend-i)+&quot;] of &quot;+</span>
<span class="nc" id="L1077">                                         pct(bsize - avgSize*(bend-i),</span>
                                             avgSize*(bend-i)));
<span class="nc" id="L1079">                        Utils.log.info(&quot;{ //BEGIN&quot;);</span>
                    }
                    CodingMethod begcm, midcm, endcm;
<span class="nc" id="L1082">                    midcm = runHelper.choose(this.values,</span>
                                             this.start+i,
                                             this.start+bend,
                                             plainCoding);
<span class="nc bnc" id="L1086" title="All 2 branches missed.">                    if (midcm == plainCoding) {</span>
                        // No use working further.
<span class="nc" id="L1088">                        begcm = plainCoding;</span>
<span class="nc" id="L1089">                        endcm = plainCoding;</span>
                    } else {
<span class="nc" id="L1091">                        begcm = runHelper.choose(this.values,</span>
                                                 this.start,
                                                 this.start+i,
                                                 plainCoding);
<span class="nc" id="L1095">                        endcm = runHelper.choose(this.values,</span>
                                                 this.start+bend,
                                                 this.start+len,
                                                 plainCoding);
                    }
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                    if (verbose &gt; 2)</span>
<span class="nc" id="L1101">                        Utils.log.info(&quot;} //END&quot;);</span>
<span class="nc bnc" id="L1102" title="All 4 branches missed.">                    if (begcm == midcm &amp;&amp; i &gt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">                        AdaptiveCoding.isCodableLength(bend)) {</span>
<span class="nc" id="L1104">                        i = 0;</span>
                    }
<span class="nc bnc" id="L1106" title="All 4 branches missed.">                    if (midcm == endcm &amp;&amp; bend &lt; len) {</span>
<span class="nc" id="L1107">                        bend = len;</span>
                    }
<span class="nc bnc" id="L1109" title="All 6 branches missed.">                    if (begcm != plainCoding ||</span>
                        midcm != plainCoding ||
                        endcm != plainCoding) {
                        CodingMethod chain;
<span class="nc" id="L1113">                        int hlen = 0;</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">                        if (bend == len) {</span>
<span class="nc" id="L1115">                            chain = midcm;</span>
                        } else {
<span class="nc" id="L1117">                            chain = new AdaptiveCoding(bend-i, midcm, endcm);</span>
<span class="nc" id="L1118">                            hlen += BAND_HEADER;</span>
                        }
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                        if (i &gt; 0) {</span>
<span class="nc" id="L1121">                            chain = new AdaptiveCoding(i, begcm, chain);</span>
<span class="nc" id="L1122">                            hlen += BAND_HEADER;</span>
                        }
<span class="nc" id="L1124">                        int[] chainSize = computeSizePrivate(chain);</span>
<span class="nc" id="L1125">                        noteSizes(chain,</span>
                                  chainSize[BYTE_SIZE],
                                  chainSize[ZIP_SIZE]+hlen);
                    }
<span class="nc" id="L1129">                    i = nexti;</span>
<span class="nc" id="L1130">                    break;</span>
                }
            }
        }
<span class="nc bnc" id="L1134" title="All 2 branches missed.">        if (verbose &gt; 3) {</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">            if (bestZipSize &lt; oldZipSize) {</span>
<span class="nc" id="L1136">                Utils.log.info(&quot;&gt;&gt;&gt; RUN WINS BY &quot;+</span>
                                 (oldZipSize - bestZipSize));
            }
        }
<span class="nc" id="L1140">    }</span>

    static private
    String pct(double num, double den) {
<span class="nc" id="L1144">        return (Math.round((num / den)*10000)/100.0)+&quot;%&quot;;</span>
    }

<span class="nc bnc" id="L1147" title="All 2 branches missed.">    static</span>
    class Sizer extends OutputStream {
        final OutputStream out;  // if non-null, copy output here also
<span class="nc" id="L1150">        Sizer(OutputStream out) {</span>
<span class="nc" id="L1151">            this.out = out;</span>
<span class="nc" id="L1152">        }</span>
        Sizer() {
<span class="nc" id="L1154">            this(null);</span>
<span class="nc" id="L1155">        }</span>
        private int count;
        public void write(int b) throws IOException {
<span class="nc" id="L1158">            count++;</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">            if (out != null)  out.write(b);</span>
<span class="nc" id="L1160">        }</span>
        public void write(byte b[], int off, int len) throws IOException {
<span class="nc" id="L1162">            count += len;</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">            if (out != null)  out.write(b, off, len);</span>
<span class="nc" id="L1164">        }</span>
        public void reset() {
<span class="nc" id="L1166">            count = 0;</span>
<span class="nc" id="L1167">        }</span>
<span class="nc" id="L1168">        public int getSize() { return count; }</span>

        public String toString() {
<span class="nc" id="L1171">            String str = super.toString();</span>
            // If -ea, print out more informative strings!
<span class="nc bnc" id="L1173" title="All 4 branches missed.">            assert((str = stringForDebug()) != null);</span>
<span class="nc" id="L1174">            return str;</span>
        }
        String stringForDebug() {
<span class="nc" id="L1177">            return &quot;&lt;Sizer &quot;+getSize()+&quot;&gt;&quot;;</span>
        }
    }

<span class="nc" id="L1181">    private Sizer zipSizer  = new Sizer();</span>
<span class="nc" id="L1182">    private Deflater zipDef = new Deflater();</span>
<span class="nc" id="L1183">    private DeflaterOutputStream zipOut = new DeflaterOutputStream(zipSizer, zipDef);</span>
<span class="nc" id="L1184">    private Sizer byteSizer = new Sizer(zipOut);</span>
<span class="nc" id="L1185">    private Sizer byteOnlySizer = new Sizer();</span>

    private void resetData() {
<span class="nc" id="L1188">        flushData();</span>
<span class="nc" id="L1189">        zipDef.reset();</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">        if (context != null) {</span>
            // Prepend given salt to the test output.
            try {
<span class="nc" id="L1193">                context.writeTo(byteSizer);</span>
<span class="nc" id="L1194">            } catch (IOException ee) {</span>
<span class="nc" id="L1195">                throw new RuntimeException(ee); // cannot happen</span>
<span class="nc" id="L1196">            }</span>
        }
<span class="nc" id="L1198">        zipSizer.reset();</span>
<span class="nc" id="L1199">        byteSizer.reset();</span>
<span class="nc" id="L1200">    }</span>
    private void flushData() {
        try {
<span class="nc" id="L1203">            zipOut.finish();</span>
<span class="nc" id="L1204">        } catch (IOException ee) {</span>
<span class="nc" id="L1205">            throw new RuntimeException(ee); // cannot happen</span>
<span class="nc" id="L1206">        }</span>
<span class="nc" id="L1207">    }</span>
    private int getByteSize() {
<span class="nc" id="L1209">        return byteSizer.getSize();</span>
    }
    private int getZipSize() {
<span class="nc" id="L1212">        flushData();</span>
<span class="nc" id="L1213">        return zipSizer.getSize();</span>
    }


    /// Stress-test helpers.

    void addStressSeed(int x) {
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        if (stress == null)  return;</span>
<span class="nc" id="L1221">        stress.setSeed(x + ((long)stress.nextInt() &lt;&lt; 32));</span>
<span class="nc" id="L1222">    }</span>

    // Pick a random pop-coding.
    private CodingMethod stressPopCoding(CodingMethod coding) {
<span class="nc bnc" id="L1226" title="All 4 branches missed.">        assert(stress != null);  // this method is only for testing</span>
        // Don't turn it into a pop coding if it's already something special.
<span class="nc bnc" id="L1228" title="All 2 branches missed.">        if (!(coding instanceof Coding))  return coding;</span>
<span class="nc" id="L1229">        Coding valueCoding = ((Coding)coding).getValueCoding();</span>
<span class="nc" id="L1230">        Histogram hist = getValueHistogram();</span>
<span class="nc" id="L1231">        int fVlen = stressLen(hist.getTotalLength());</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">        if (fVlen == 0)  return coding;</span>
<span class="nc" id="L1233">        List&lt;Integer&gt; popvals = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">        if (stress.nextBoolean()) {</span>
            // Build the population from the value list.
<span class="nc" id="L1236">            Set&lt;Integer&gt; popset = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">            for (int i = start; i &lt; end; i++) {</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">                if (popset.add(values[i]))  popvals.add(values[i]);</span>
            }
<span class="nc" id="L1240">        } else {</span>
<span class="nc" id="L1241">            int[][] matrix = hist.getMatrix();</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">            for (int mrow = 0; mrow &lt; matrix.length; mrow++) {</span>
<span class="nc" id="L1243">                int[] row = matrix[mrow];</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">                for (int mcol = 1; mcol &lt; row.length; mcol++) {</span>
<span class="nc" id="L1245">                    popvals.add(row[mcol]);</span>
                }
            }
        }
<span class="nc" id="L1249">        int reorder = stress.nextInt();</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">        if ((reorder &amp; 7) &lt;= 2) {</span>
            // Lose the order.
<span class="nc" id="L1252">            Collections.shuffle(popvals, stress);</span>
        } else {
            // Keep the order, mostly.
<span class="nc bnc" id="L1255" title="All 2 branches missed.">            if (((reorder &gt;&gt;&gt;= 3) &amp; 7) &lt;= 2)  Collections.sort(popvals);</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">            if (((reorder &gt;&gt;&gt;= 3) &amp; 7) &lt;= 2)  Collections.reverse(popvals);</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">            if (((reorder &gt;&gt;&gt;= 3) &amp; 7) &lt;= 2)  Collections.rotate(popvals, stressLen(popvals.size()));</span>
        }
<span class="nc bnc" id="L1259" title="All 2 branches missed.">        if (popvals.size() &gt; fVlen) {</span>
            // Cut the list down.
<span class="nc bnc" id="L1261" title="All 2 branches missed.">            if (((reorder &gt;&gt;&gt;= 3) &amp; 7) &lt;= 2) {</span>
                // Cut at end.
<span class="nc" id="L1263">                popvals.subList(fVlen,   popvals.size()).clear();</span>
            } else {
                // Cut at start.
<span class="nc" id="L1266">                popvals.subList(0, popvals.size()-fVlen).clear();</span>
            }
        }
<span class="nc" id="L1269">        fVlen = popvals.size();</span>
<span class="nc" id="L1270">        int[] fvals = new int[1+fVlen];</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">        for (int i = 0; i &lt; fVlen; i++) {</span>
<span class="nc" id="L1272">            fvals[1+i] = (popvals.get(i)).intValue();</span>
        }
<span class="nc" id="L1274">        PopulationCoding pop = new PopulationCoding();</span>
<span class="nc" id="L1275">        pop.setFavoredValues(fvals, fVlen);</span>
<span class="nc" id="L1276">        int[] lvals = PopulationCoding.LValuesCoded;</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">        for (int i = 0; i &lt; lvals.length / 2; i++) {</span>
<span class="nc" id="L1278">            int popl = lvals[stress.nextInt(lvals.length)];</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">            if (popl &lt; 0)  continue;</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">            if (PopulationCoding.fitTokenCoding(fVlen, popl) != null) {</span>
<span class="nc" id="L1281">                pop.setL(popl);</span>
<span class="nc" id="L1282">                break;</span>
            }
        }
<span class="nc bnc" id="L1285" title="All 2 branches missed.">        if (pop.tokenCoding == null) {</span>
<span class="nc" id="L1286">            int lmin = fvals[1], lmax = lmin;</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">            for (int i = 2; i &lt;= fVlen; i++) {</span>
<span class="nc" id="L1288">                int val = fvals[i];</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                if (lmin &gt; val)  lmin = val;</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">                if (lmax &lt; val)  lmax = val;</span>
            }
<span class="nc" id="L1292">            pop.tokenCoding = stressCoding(lmin, lmax);</span>
        }

<span class="nc" id="L1295">        computePopSizePrivate(pop, valueCoding, valueCoding);</span>
<span class="nc" id="L1296">        return pop;</span>
    }

    // Pick a random adaptive coding.
    private CodingMethod stressAdaptiveCoding(CodingMethod coding) {
<span class="nc bnc" id="L1301" title="All 4 branches missed.">        assert(stress != null);  // this method is only for testing</span>
        // Don't turn it into a run coding if it's already something special.
<span class="nc bnc" id="L1303" title="All 2 branches missed.">        if (!(coding instanceof Coding))  return coding;</span>
<span class="nc" id="L1304">        Coding plainCoding = (Coding)coding;</span>
<span class="nc" id="L1305">        int len = end-start;</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">        if (len &lt; 2)  return coding;</span>
        // Decide how many spans we'll create.
<span class="nc" id="L1308">        int spanlen = stressLen(len-1)+1;</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">        if (spanlen == len)  return coding;</span>
        try {
<span class="nc bnc" id="L1311" title="All 4 branches missed.">            assert(!disableRunCoding);</span>
<span class="nc" id="L1312">            disableRunCoding = true;  // temporary, while I decide spans</span>
<span class="nc" id="L1313">            int[] allValues = values.clone();</span>
<span class="nc" id="L1314">            CodingMethod result = null;</span>
<span class="nc" id="L1315">            int scan  = this.end;</span>
<span class="nc" id="L1316">            int lstart = this.start;</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">            for (int split; scan &gt; lstart; scan = split) {</span>
                int thisspan;
<span class="nc bnc" id="L1319" title="All 2 branches missed.">                int rand = (scan - lstart &lt; 100)? -1: stress.nextInt();</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">                if ((rand &amp; 7) != 0) {</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">                    thisspan = (spanlen==1? spanlen: stressLen(spanlen-1)+1);</span>
                } else {
                    // Every so often generate a value based on KX/KB format.
<span class="nc" id="L1324">                    int KX = (rand &gt;&gt;&gt;= 3) &amp; AdaptiveCoding.KX_MAX;</span>
<span class="nc" id="L1325">                    int KB = (rand &gt;&gt;&gt;= 3) &amp; AdaptiveCoding.KB_MAX;</span>
                    for (;;) {
<span class="nc" id="L1327">                        thisspan = AdaptiveCoding.decodeK(KX, KB);</span>
<span class="nc bnc" id="L1328" title="All 2 branches missed.">                        if (thisspan &lt;= scan - lstart)  break;</span>
                        // Try smaller and smaller codings:
<span class="nc bnc" id="L1330" title="All 2 branches missed.">                        if (KB != AdaptiveCoding.KB_DEFAULT)</span>
<span class="nc" id="L1331">                            KB = AdaptiveCoding.KB_DEFAULT;</span>
                        else
<span class="nc" id="L1333">                            KX -= 1;</span>
                    }
                    //System.out.println(&quot;KX=&quot;+KX+&quot; KB=&quot;+KB+&quot; K=&quot;+thisspan);
<span class="nc bnc" id="L1336" title="All 4 branches missed.">                    assert(AdaptiveCoding.isCodableLength(thisspan));</span>
                }
<span class="nc bnc" id="L1338" title="All 2 branches missed.">                if (thisspan &gt; scan - lstart)  thisspan = scan - lstart;</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">                while (!AdaptiveCoding.isCodableLength(thisspan)) {</span>
<span class="nc" id="L1340">                    --thisspan;</span>
                }
<span class="nc" id="L1342">                split = scan - thisspan;</span>
<span class="nc bnc" id="L1343" title="All 4 branches missed.">                assert(split &lt; scan);</span>
<span class="nc bnc" id="L1344" title="All 4 branches missed.">                assert(split &gt;= lstart);</span>
                // Choose a coding for the span [split..scan).
<span class="nc" id="L1346">                CodingMethod sc = choose(allValues, split, scan, plainCoding);</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">                if (result == null) {</span>
<span class="nc" id="L1348">                    result = sc;  // the caboose</span>
                } else {
<span class="nc" id="L1350">                    result = new AdaptiveCoding(scan-split, sc, result);</span>
                }
            }
<span class="nc" id="L1353">            return result;</span>
        } finally {
<span class="nc" id="L1355">            disableRunCoding = false; // return to normal value</span>
        }
    }

    // Return a random value in [0..len], gently biased toward extremes.
    private Coding stressCoding(int min, int max) {
<span class="nc bnc" id="L1361" title="All 4 branches missed.">        assert(stress != null);  // this method is only for testing</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">        for (int i = 0; i &lt; 100; i++) {</span>
<span class="nc" id="L1363">            Coding c = Coding.of(stress.nextInt(Coding.B_MAX)+1,</span>
<span class="nc" id="L1364">                                 stress.nextInt(Coding.H_MAX)+1,</span>
<span class="nc" id="L1365">                                 stress.nextInt(Coding.S_MAX+1));</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">            if (c.B() == 1)  c = c.setH(256);</span>
<span class="nc bnc" id="L1367" title="All 4 branches missed.">            if (c.H() == 256 &amp;&amp; c.B() &gt;= 5)  c = c.setB(4);</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">            if (stress.nextBoolean()) {</span>
<span class="nc" id="L1369">                Coding dc = c.setD(1);</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                if (dc.canRepresent(min, max))  return dc;</span>
            }
<span class="nc bnc" id="L1372" title="All 2 branches missed.">            if (c.canRepresent(min, max))  return c;</span>
        }
<span class="nc" id="L1374">        return BandStructure.UNSIGNED5;</span>
    }

    // Return a random value in [0..len], gently biased toward extremes.
    private int stressLen(int len) {
<span class="nc bnc" id="L1379" title="All 4 branches missed.">        assert(stress != null);  // this method is only for testing</span>
<span class="nc bnc" id="L1380" title="All 4 branches missed.">        assert(len &gt;= 0);</span>
<span class="nc" id="L1381">        int rand = stress.nextInt(100);</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">        if (rand &lt; 20)</span>
<span class="nc" id="L1383">            return Math.min(len/5, rand);</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">        else if (rand &lt; 40)</span>
<span class="nc" id="L1385">            return len;</span>
        else
<span class="nc" id="L1387">            return stress.nextInt(len);</span>
    }

    // For debug only.
/*
    public static
    int[] readValuesFrom(InputStream instr) {
        return readValuesFrom(new InputStreamReader(instr));
    }
    public static
    int[] readValuesFrom(Reader inrdr) {
        inrdr = new BufferedReader(inrdr);
        final StreamTokenizer in = new StreamTokenizer(inrdr);
        final int TT_NOTHING = -99;
        in.commentChar('#');
        return readValuesFrom(new Iterator() {
            int token = TT_NOTHING;
            private int getToken() {
                if (token == TT_NOTHING) {
                    try {
                        token = in.nextToken();
                        assert(token != TT_NOTHING);
                    } catch (IOException ee) {
                        throw new RuntimeException(ee);
                    }
                }
                return token;
            }
            public boolean hasNext() {
                return getToken() != StreamTokenizer.TT_EOF;
            }
            public Object next() {
                int ntok = getToken();
                token = TT_NOTHING;
                switch (ntok) {
                case StreamTokenizer.TT_EOF:
                    throw new NoSuchElementException();
                case StreamTokenizer.TT_NUMBER:
                    return Integer.valueOf((int) in.nval);
                default:
                    assert(false);
                    return null;
                }
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        });
    }
    public static
    int[] readValuesFrom(Iterator iter) {
        return readValuesFrom(iter, 0);
    }
    public static
    int[] readValuesFrom(Iterator iter, int initSize) {
        int[] na = new int[Math.max(10, initSize)];
        int np = 0;
        while (iter.hasNext()) {
            Integer val = (Integer) iter.next();
            if (np == na.length) {
                na = BandStructure.realloc(na);
            }
            na[np++] = val.intValue();
        }
        if (np != na.length) {
            na = BandStructure.realloc(na, np);
        }
        return na;
    }

    public static
    void main(String[] av) throws IOException {
        int effort = MID_EFFORT;
        int ap = 0;
        if (ap &lt; av.length &amp;&amp; av[ap].equals(&quot;-e&quot;)) {
            ap++;
            effort = Integer.parseInt(av[ap++]);
        }
        int verbose = 1;
        if (ap &lt; av.length &amp;&amp; av[ap].equals(&quot;-v&quot;)) {
            ap++;
            verbose = Integer.parseInt(av[ap++]);
        }
        Coding[] bcs = BandStructure.getBasicCodings();
        CodingChooser cc = new CodingChooser(effort, bcs);
        if (ap &lt; av.length &amp;&amp; av[ap].equals(&quot;-p&quot;)) {
            ap++;
            cc.optUsePopulationCoding = false;
        }
        if (ap &lt; av.length &amp;&amp; av[ap].equals(&quot;-a&quot;)) {
            ap++;
            cc.optUseAdaptiveCoding = false;
        }
        cc.verbose = verbose;
        int[] values = readValuesFrom(System.in);
        int[] sizes = {0,0};
        CodingMethod cm = cc.choose(values, BandStructure.UNSIGNED5, sizes);
        System.out.println(&quot;size: &quot;+sizes[BYTE_SIZE]+&quot;/zs=&quot;+sizes[ZIP_SIZE]);
        System.out.println(cm);
    }
//*/

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>