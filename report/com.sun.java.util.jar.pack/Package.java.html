<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Package.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">Package.java</span></div><h1>Package.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import java.util.jar.Pack200;
import com.sun.java.util.jar.pack.Attribute.Layout;
import com.sun.java.util.jar.pack.ConstantPool.ClassEntry;
import com.sun.java.util.jar.pack.ConstantPool.DescriptorEntry;
import com.sun.java.util.jar.pack.ConstantPool.BootstrapMethodEntry;
import com.sun.java.util.jar.pack.ConstantPool.Index;
import com.sun.java.util.jar.pack.ConstantPool.LiteralEntry;
import com.sun.java.util.jar.pack.ConstantPool.Utf8Entry;
import com.sun.java.util.jar.pack.ConstantPool.Entry;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.SequenceInputStream;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.jar.JarFile;
import static com.sun.java.util.jar.pack.Constants.*;

/**
 * Define the main data structure transmitted by pack/unpack.
 * @author John Rose
 */
<span class="nc bnc" id="L63" title="All 2 branches missed.">class Package {</span>
    int verbose;
    {
<span class="nc" id="L66">        PropMap pmap = Utils.currentPropMap();</span>
<span class="nc bnc" id="L67" title="All 4 branches missed.">        if (pmap != null)</span>
<span class="nc" id="L68">            verbose = pmap.getInteger(Utils.DEBUG_VERBOSE);</span>
    }

<span class="nc" id="L71">    final int magic = JAVA_PACKAGE_MAGIC;</span>

<span class="nc" id="L73">    int default_modtime = NO_MODTIME;</span>
<span class="nc" id="L74">    int default_options = 0;  // FO_DEFLATE_HINT</span>

<span class="nc" id="L76">    Version defaultClassVersion = null;</span>

    // These fields can be adjusted by driver properties.
    final Version minClassVersion;
    final Version maxClassVersion;
    // null, indicates that consensus rules during package write
    final Version packageVersion;

<span class="nc" id="L84">    Version observedHighestClassVersion = null;</span>


    // What constants are used in this unit?
<span class="nc" id="L88">    ConstantPool.IndexGroup cp = new ConstantPool.IndexGroup();</span>

    /*
     * typically used by the PackageReader to set the defaults, in which
     * case we take the defaults.
     */
<span class="nc" id="L94">    public Package() {</span>
<span class="nc" id="L95">        minClassVersion = JAVA_MIN_CLASS_VERSION;</span>
<span class="nc" id="L96">        maxClassVersion = JAVA_MAX_CLASS_VERSION;</span>
<span class="nc" id="L97">        packageVersion = null;</span>
<span class="nc" id="L98">    }</span>


    /*
     * Typically used by the PackerImpl during before packing, the defaults are
     * overridden by the users preferences.
     */
<span class="nc" id="L105">    public Package(Version minClassVersion, Version maxClassVersion, Version packageVersion) {</span>
        // Fill in permitted range of major/minor version numbers.
<span class="nc bnc" id="L107" title="All 2 branches missed.">        this.minClassVersion = minClassVersion == null</span>
                ? JAVA_MIN_CLASS_VERSION
                : minClassVersion;
<span class="nc bnc" id="L110" title="All 2 branches missed.">        this.maxClassVersion = maxClassVersion == null</span>
                ? JAVA_MAX_CLASS_VERSION
                : maxClassVersion;
<span class="nc" id="L113">        this.packageVersion  = packageVersion;</span>
<span class="nc" id="L114">    }</span>


    public void reset() {
<span class="nc" id="L118">        cp = new ConstantPool.IndexGroup();</span>
<span class="nc" id="L119">        classes.clear();</span>
<span class="nc" id="L120">        files.clear();</span>
<span class="nc" id="L121">        BandStructure.nextSeqForDebug = 0;</span>
<span class="nc" id="L122">        observedHighestClassVersion = null;</span>
<span class="nc" id="L123">    }</span>

    // Special empty versions of Code and InnerClasses, used for markers.
    public static final Attribute.Layout attrCodeEmpty;
    public static final Attribute.Layout attrBootstrapMethodsEmpty;
    public static final Attribute.Layout attrInnerClassesEmpty;
    public static final Attribute.Layout attrSourceFileSpecial;
    public static final Map&lt;Attribute.Layout, Attribute&gt; attrDefs;
    static {
<span class="nc" id="L132">        Map&lt;Layout, Attribute&gt; ad = new HashMap&lt;&gt;(3);</span>
<span class="nc" id="L133">        attrCodeEmpty = Attribute.define(ad, ATTR_CONTEXT_METHOD,</span>
<span class="nc" id="L134">                                         &quot;Code&quot;, &quot;&quot;).layout();</span>
<span class="nc" id="L135">        attrBootstrapMethodsEmpty = Attribute.define(ad, ATTR_CONTEXT_CLASS,</span>
<span class="nc" id="L136">                                                     &quot;BootstrapMethods&quot;, &quot;&quot;).layout();</span>
<span class="nc" id="L137">        attrInnerClassesEmpty = Attribute.define(ad, ATTR_CONTEXT_CLASS,</span>
<span class="nc" id="L138">                                                 &quot;InnerClasses&quot;, &quot;&quot;).layout();</span>
<span class="nc" id="L139">        attrSourceFileSpecial = Attribute.define(ad, ATTR_CONTEXT_CLASS,</span>
<span class="nc" id="L140">                                                 &quot;SourceFile&quot;, &quot;RUNH&quot;).layout();</span>
<span class="nc" id="L141">        attrDefs = Collections.unmodifiableMap(ad);</span>
    }

    Version getDefaultClassVersion() {
<span class="nc" id="L145">        return defaultClassVersion;</span>
    }

    /** Return the highest version number of all classes,
     *  or 0 if there are no classes.
     */
    private void setHighestClassVersion() {
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (observedHighestClassVersion != null)</span>
<span class="nc" id="L153">            return;</span>
<span class="nc" id="L154">        Version res = JAVA_MIN_CLASS_VERSION;  // initial low value</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        for (Class cls : classes) {</span>
<span class="nc" id="L156">            Version ver = cls.getVersion();</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (res.lessThan(ver))  res = ver;</span>
<span class="nc" id="L158">        }</span>
<span class="nc" id="L159">        observedHighestClassVersion = res;</span>
<span class="nc" id="L160">    }</span>

    Version getHighestClassVersion() {
<span class="nc" id="L163">        setHighestClassVersion();</span>
<span class="nc" id="L164">        return observedHighestClassVersion;</span>
    }

    // What Java classes are in this unit?

<span class="nc" id="L169">    ArrayList&lt;Package.Class&gt; classes = new ArrayList&lt;&gt;();</span>

    public List&lt;Package.Class&gt; getClasses() {
<span class="nc" id="L172">        return classes;</span>
    }

<span class="nc bnc" id="L175" title="All 2 branches missed.">    public final</span>
    class Class extends Attribute.Holder implements Comparable&lt;Class&gt; {
<span class="nc" id="L177">        public Package getPackage() { return Package.this; }</span>

        // Optional file characteristics and data source (a &quot;class stub&quot;)
        File file;

        // File header
        int magic;
        Version version;

        // Local constant pool (one-way mapping of index =&gt; package cp).
        Entry[] cpMap;

        // Class header
        //int flags;  // in Attribute.Holder.this.flags
        ClassEntry thisClass;
        ClassEntry superClass;
        ClassEntry[] interfaces;

        // Class parts
        ArrayList&lt;Field&gt; fields;
        ArrayList&lt;Method&gt; methods;
        //ArrayList attributes;  // in Attribute.Holder.this.attributes
        // Note that InnerClasses may be collected at the package level.
        ArrayList&lt;InnerClass&gt; innerClasses;
        ArrayList&lt;BootstrapMethodEntry&gt; bootstrapMethods;

<span class="nc" id="L203">        Class(int flags, ClassEntry thisClass, ClassEntry superClass, ClassEntry[] interfaces) {</span>
<span class="nc" id="L204">            this.magic      = JAVA_MAGIC;</span>
<span class="nc" id="L205">            this.version    = defaultClassVersion;</span>
<span class="nc" id="L206">            this.flags      = flags;</span>
<span class="nc" id="L207">            this.thisClass  = thisClass;</span>
<span class="nc" id="L208">            this.superClass = superClass;</span>
<span class="nc" id="L209">            this.interfaces = interfaces;</span>

<span class="nc" id="L211">            boolean added = classes.add(this);</span>
<span class="nc bnc" id="L212" title="All 4 branches missed.">            assert(added);</span>
<span class="nc" id="L213">        }</span>

<span class="nc" id="L215">        Class(String classFile) {</span>
            // A blank class; must be read with a ClassReader, etc.
<span class="nc" id="L217">            initFile(newStub(classFile));</span>
<span class="nc" id="L218">        }</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">        List&lt;Field&gt; getFields() { return fields == null ? noFields : fields; }</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        List&lt;Method&gt; getMethods() { return methods == null ? noMethods : methods; }</span>

        public String getName() {
<span class="nc" id="L224">            return thisClass.stringValue();</span>
        }

        Version getVersion() {
<span class="nc" id="L228">            return this.version;</span>
        }

        // Note:  equals and hashCode are identity-based.
        public int compareTo(Class that) {
<span class="nc" id="L233">            String n0 = this.getName();</span>
<span class="nc" id="L234">            String n1 = that.getName();</span>
<span class="nc" id="L235">            return n0.compareTo(n1);</span>
        }

        String getObviousSourceFile() {
<span class="nc" id="L239">            return Package.getObviousSourceFile(getName());</span>
        }

        private void transformSourceFile(boolean minimize) {
            // Replace &quot;obvious&quot; SourceFile by null.
<span class="nc" id="L244">            Attribute olda = getAttribute(attrSourceFileSpecial);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">            if (olda == null)</span>
<span class="nc" id="L246">                return;  // no SourceFile attr.</span>
<span class="nc" id="L247">            String obvious = getObviousSourceFile();</span>
<span class="nc" id="L248">            List&lt;Entry&gt; ref = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L249">            olda.visitRefs(this, VRM_PACKAGE, ref);</span>
<span class="nc" id="L250">            Utf8Entry sfName = (Utf8Entry) ref.get(0);</span>
<span class="nc" id="L251">            Attribute a = olda;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">            if (sfName == null) {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">                if (minimize) {</span>
                    // A pair of zero bytes.  Cannot use predef. layout.
<span class="nc" id="L255">                    a = Attribute.find(ATTR_CONTEXT_CLASS, &quot;SourceFile&quot;, &quot;H&quot;);</span>
<span class="nc" id="L256">                    a = a.addContent(new byte[2]);</span>
                } else {
                    // Expand null attribute to the obvious string.
<span class="nc" id="L259">                    byte[] bytes = new byte[2];</span>
<span class="nc" id="L260">                    sfName = getRefString(obvious);</span>
<span class="nc" id="L261">                    Object f = null;</span>
<span class="nc" id="L262">                    f = Fixups.addRefWithBytes(f, bytes, sfName);</span>
<span class="nc" id="L263">                    a = attrSourceFileSpecial.addContent(bytes, f);</span>
<span class="nc" id="L264">                }</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            } else if (obvious.equals(sfName.stringValue())) {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">                if (minimize) {</span>
                    // Replace by an all-zero attribute.
<span class="nc" id="L268">                    a = attrSourceFileSpecial.addContent(new byte[2]);</span>
                } else {
<span class="nc bnc" id="L270" title="All 2 branches missed.">                    assert(false);</span>
                }
            }
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (a != olda) {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">                if (verbose &gt; 2)</span>
<span class="nc" id="L275">                    Utils.log.fine(&quot;recoding obvious SourceFile=&quot;+obvious);</span>
<span class="nc" id="L276">                List&lt;Attribute&gt; newAttrs = new ArrayList&lt;&gt;(getAttributes());</span>
<span class="nc" id="L277">                int where = newAttrs.indexOf(olda);</span>
<span class="nc" id="L278">                newAttrs.set(where, a);</span>
<span class="nc" id="L279">                setAttributes(newAttrs);</span>
            }
<span class="nc" id="L281">        }</span>

        void minimizeSourceFile() {
<span class="nc" id="L284">            transformSourceFile(true);</span>
<span class="nc" id="L285">        }</span>
        void expandSourceFile() {
<span class="nc" id="L287">            transformSourceFile(false);</span>
<span class="nc" id="L288">        }</span>

        protected Entry[] getCPMap() {
<span class="nc" id="L291">            return cpMap;</span>
        }

        protected void setCPMap(Entry[] cpMap) {
<span class="nc" id="L295">            this.cpMap = cpMap;</span>
<span class="nc" id="L296">        }</span>

        boolean hasBootstrapMethods() {
<span class="nc bnc" id="L299" title="All 4 branches missed.">            return bootstrapMethods != null &amp;&amp; !bootstrapMethods.isEmpty();</span>
        }

        List&lt;BootstrapMethodEntry&gt; getBootstrapMethods() {
<span class="nc" id="L303">            return bootstrapMethods;</span>
        }

        BootstrapMethodEntry[] getBootstrapMethodMap() {
<span class="nc bnc" id="L307" title="All 2 branches missed.">            return (hasBootstrapMethods())</span>
<span class="nc" id="L308">                    ? bootstrapMethods.toArray(new BootstrapMethodEntry[bootstrapMethods.size()])</span>
                    : null;
        }

        void setBootstrapMethods(Collection&lt;BootstrapMethodEntry&gt; bsms) {
<span class="nc bnc" id="L313" title="All 4 branches missed.">            assert(bootstrapMethods == null);  // do not do this twice</span>
<span class="nc" id="L314">            bootstrapMethods = new ArrayList&lt;&gt;(bsms);</span>
<span class="nc" id="L315">        }</span>

        boolean hasInnerClasses() {
<span class="nc bnc" id="L318" title="All 2 branches missed.">            return innerClasses != null;</span>
        }
        List&lt;InnerClass&gt; getInnerClasses() {
<span class="nc" id="L321">            return innerClasses;</span>
        }

        public void setInnerClasses(Collection&lt;InnerClass&gt; ics) {
<span class="nc bnc" id="L325" title="All 2 branches missed.">            innerClasses = (ics == null) ? null : new ArrayList&lt;&gt;(ics);</span>
            // Edit the attribute list, if necessary.
<span class="nc" id="L327">            Attribute a = getAttribute(attrInnerClassesEmpty);</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">            if (innerClasses != null &amp;&amp; a == null)</span>
<span class="nc" id="L329">                addAttribute(attrInnerClassesEmpty.canonicalInstance());</span>
<span class="nc bnc" id="L330" title="All 4 branches missed.">            else if (innerClasses == null &amp;&amp; a != null)</span>
<span class="nc" id="L331">                removeAttribute(a);</span>
<span class="nc" id="L332">        }</span>

        /** Given a global map of ICs (keyed by thisClass),
         *  compute the subset of its Map.values which are
         *  required to be present in the local InnerClasses
         *  attribute.  Perform this calculation without
         *  reference to any actual InnerClasses attribute.
         *  &lt;p&gt;
         *  The order of the resulting list is consistent
         *  with that of Package.this.allInnerClasses.
         */
        public List&lt;InnerClass&gt; computeGloballyImpliedICs() {
<span class="nc" id="L344">            Set&lt;Entry&gt; cpRefs = new HashSet&lt;&gt;();</span>
            {   // This block temporarily displaces this.innerClasses.
<span class="nc" id="L346">                ArrayList&lt;InnerClass&gt; innerClassesSaved = innerClasses;</span>
<span class="nc" id="L347">                innerClasses = null;  // ignore for the moment</span>
<span class="nc" id="L348">                visitRefs(VRM_CLASSIC, cpRefs);</span>
<span class="nc" id="L349">                innerClasses = innerClassesSaved;</span>
            }
<span class="nc" id="L351">            ConstantPool.completeReferencesIn(cpRefs, true);</span>

<span class="nc" id="L353">            Set&lt;Entry&gt; icRefs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">            for (Entry e : cpRefs) {</span>
                // Restrict cpRefs to InnerClasses entries only.
<span class="nc bnc" id="L356" title="All 2 branches missed.">                if (!(e instanceof ClassEntry))  continue;</span>
                // For every IC reference, add its outers also.
<span class="nc bnc" id="L358" title="All 2 branches missed.">                while (e != null) {</span>
<span class="nc" id="L359">                    InnerClass ic = getGlobalInnerClass(e);</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">                    if (ic == null)  break;</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">                    if (!icRefs.add(e))  break;</span>
<span class="nc" id="L362">                    e = ic.outerClass;</span>
                    // If we add A$B$C to the mix, we must also add A$B.
<span class="nc" id="L364">                }</span>
<span class="nc" id="L365">            }</span>
            // This loop is structured this way so as to accumulate
            // entries into impliedICs in an order which reflects
            // the order of allInnerClasses.
<span class="nc" id="L369">            ArrayList&lt;InnerClass&gt; impliedICs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">            for (InnerClass ic : allInnerClasses) {</span>
                // This one is locally relevant if it describes
                // a member of the current class, or if the current
                // class uses it somehow.  In the particular case
                // where thisClass is an inner class, it will already
                // be a member of icRefs.
<span class="nc bnc" id="L376" title="All 4 branches missed.">                if (icRefs.contains(ic.thisClass)</span>
                    || ic.outerClass == this.thisClass) {
                    // Add every relevant class to the IC attribute:
<span class="nc bnc" id="L379" title="All 2 branches missed.">                    if (verbose &gt; 1)</span>
<span class="nc" id="L380">                        Utils.log.fine(&quot;Relevant IC: &quot;+ic);</span>
<span class="nc" id="L381">                    impliedICs.add(ic);</span>
                }
<span class="nc" id="L383">            }</span>
<span class="nc" id="L384">            return impliedICs;</span>
        }

        // Helper for both minimizing and expanding.
        // Computes a symmetric difference.
        private List&lt;InnerClass&gt; computeICdiff() {
<span class="nc" id="L390">            List&lt;InnerClass&gt; impliedICs = computeGloballyImpliedICs();</span>
<span class="nc" id="L391">            List&lt;InnerClass&gt; actualICs  = getInnerClasses();</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (actualICs == null)</span>
<span class="nc" id="L393">                actualICs = Collections.emptyList();</span>

            // Symmetric difference is calculated from I, A like this:
            //  diff = (I+A) - (I*A)
            // Note that the center C is unordered, but the result
            // preserves the original ordering of I and A.
            //
            // Class file rules require that outers precede inners.
            // So, add I before A, in case A$B$Z is local, but A$B
            // is implicit.  The reverse is never the case.
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (actualICs.isEmpty()) {</span>
<span class="nc" id="L404">                return impliedICs;</span>
                // Diff is I since A is empty.
            }
<span class="nc bnc" id="L407" title="All 2 branches missed.">            if (impliedICs.isEmpty()) {</span>
<span class="nc" id="L408">                return actualICs;</span>
                // Diff is A since I is empty.
            }
            // (I*A) is non-trivial
<span class="nc" id="L412">            Set&lt;InnerClass&gt; center = new HashSet&lt;&gt;(actualICs);</span>
<span class="nc" id="L413">            center.retainAll(new HashSet&lt;&gt;(impliedICs));</span>
<span class="nc" id="L414">            impliedICs.addAll(actualICs);</span>
<span class="nc" id="L415">            impliedICs.removeAll(center);</span>
            // Diff is now I^A = (I+A)-(I*A).
<span class="nc" id="L417">            return impliedICs;</span>
        }

        /** When packing, anticipate the effect of expandLocalICs.
         *  Replace the local ICs by their symmetric difference
         *  with the globally implied ICs for this class; if this
         *  difference is empty, remove the local ICs altogether.
         *  &lt;p&gt;
         *  An empty local IC attribute is reserved to signal
         *  the unpacker to delete the attribute altogether,
         *  so a missing local IC attribute signals the unpacker
         *  to use the globally implied ICs changed.
         */
        void minimizeLocalICs() {
<span class="nc" id="L431">            List&lt;InnerClass&gt; diff = computeICdiff();</span>
<span class="nc" id="L432">            List&lt;InnerClass&gt; actualICs = innerClasses;</span>
            List&lt;InnerClass&gt; localICs;  // will be the diff, modulo edge cases
<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (diff.isEmpty()) {</span>
                // No diff, so transmit no attribute.
<span class="nc" id="L436">                localICs = null;</span>
<span class="nc bnc" id="L437" title="All 4 branches missed.">                if (actualICs != null &amp;&amp; actualICs.isEmpty()) {</span>
                    // Odd case:  No implied ICs, and a zero length attr.
                    // Do not support it directly.
<span class="nc bnc" id="L440" title="All 2 branches missed.">                    if (verbose &gt; 0)</span>
<span class="nc" id="L441">                        Utils.log.info(&quot;Warning: Dropping empty InnerClasses attribute from &quot;+this);</span>
                }
<span class="nc bnc" id="L443" title="All 2 branches missed.">            } else if (actualICs == null) {</span>
                // No local IC attribute, even though some are implied.
                // Signal with trivial attribute.
<span class="nc" id="L446">                localICs = Collections.emptyList();</span>
            } else {
                // Transmit a non-empty diff, which will create
                // a local ICs attribute.
<span class="nc" id="L450">                localICs = diff;</span>
            }
            // Reduce the set to the symmetric difference.
<span class="nc" id="L453">            setInnerClasses(localICs);</span>
<span class="nc bnc" id="L454" title="All 4 branches missed.">            if (verbose &gt; 1 &amp;&amp; localICs != null)</span>
<span class="nc" id="L455">                Utils.log.fine(&quot;keeping local ICs in &quot;+this+&quot;: &quot;+localICs);</span>
<span class="nc" id="L456">        }</span>

        /** When unpacking, undo the effect of minimizeLocalICs.
         *  Must return negative if any IC tuples may have been deleted.
         *  Otherwise, return positive if any IC tuples were added.
         */
        int expandLocalICs() {
<span class="nc" id="L463">            List&lt;InnerClass&gt; localICs = innerClasses;</span>
            List&lt;InnerClass&gt; actualICs;
            int changed;
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (localICs == null) {</span>
                // Diff was empty.  (Common case.)
<span class="nc" id="L468">                List&lt;InnerClass&gt; impliedICs = computeGloballyImpliedICs();</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">                if (impliedICs.isEmpty()) {</span>
<span class="nc" id="L470">                    actualICs = null;</span>
<span class="nc" id="L471">                    changed = 0;</span>
                } else {
<span class="nc" id="L473">                    actualICs = impliedICs;</span>
<span class="nc" id="L474">                    changed = 1;  // added more tuples</span>
                }
<span class="nc bnc" id="L476" title="All 2 branches missed.">            } else if (localICs.isEmpty()) {</span>
                // It was a non-empty diff, but the local ICs were absent.
<span class="nc" id="L478">                actualICs = null;</span>
<span class="nc" id="L479">                changed = 0;  // [] =&gt; null, no tuple change</span>
            } else {
                // Non-trivial diff was transmitted.
<span class="nc" id="L482">                actualICs = computeICdiff();</span>
                // If we only added more ICs, return +1.
<span class="nc bnc" id="L484" title="All 2 branches missed.">                changed = actualICs.containsAll(localICs)? +1: -1;</span>
            }
<span class="nc" id="L486">            setInnerClasses(actualICs);</span>
<span class="nc" id="L487">            return changed;</span>
        }

        public abstract
        class Member extends Attribute.Holder implements Comparable&lt;Member&gt; {
            DescriptorEntry descriptor;

<span class="nc" id="L494">            protected Member(int flags, DescriptorEntry descriptor) {</span>
<span class="nc" id="L495">                this.flags = flags;</span>
<span class="nc" id="L496">                this.descriptor = descriptor;</span>
<span class="nc" id="L497">            }</span>

<span class="nc" id="L499">            public Class thisClass() { return Class.this; }</span>

            public DescriptorEntry getDescriptor() {
<span class="nc" id="L502">                return descriptor;</span>
            }
            public String getName() {
<span class="nc" id="L505">                return descriptor.nameRef.stringValue();</span>
            }
            public String getType() {
<span class="nc" id="L508">                return descriptor.typeRef.stringValue();</span>
            }

            protected Entry[] getCPMap() {
<span class="nc" id="L512">                return cpMap;</span>
            }
            protected void visitRefs(int mode, Collection&lt;Entry&gt; refs) {
<span class="nc bnc" id="L515" title="All 2 branches missed.">                if (verbose &gt; 2)  Utils.log.fine(&quot;visitRefs &quot;+this);</span>
                // Careful:  The descriptor is used by the package,
                // but the classfile breaks it into component refs.
<span class="nc bnc" id="L518" title="All 2 branches missed.">                if (mode == VRM_CLASSIC) {</span>
<span class="nc" id="L519">                    refs.add(descriptor.nameRef);</span>
<span class="nc" id="L520">                    refs.add(descriptor.typeRef);</span>
                } else {
<span class="nc" id="L522">                    refs.add(descriptor);</span>
                }
                // Handle attribute list:
<span class="nc" id="L525">                super.visitRefs(mode, refs);</span>
<span class="nc" id="L526">            }</span>

            public String toString() {
<span class="nc" id="L529">                return Class.this + &quot;.&quot; + descriptor.prettyString();</span>
            }
        }

<span class="nc bnc" id="L533" title="All 2 branches missed.">        public</span>
        class Field extends Member {
            // Order is significant for fields:  It is visible to reflection.
            int order;

<span class="nc" id="L538">            public Field(int flags, DescriptorEntry descriptor) {</span>
<span class="nc" id="L539">                super(flags, descriptor);</span>
<span class="nc bnc" id="L540" title="All 4 branches missed.">                assert(!descriptor.isMethod());</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                if (fields == null)</span>
<span class="nc" id="L542">                    fields = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L543">                boolean added = fields.add(this);</span>
<span class="nc bnc" id="L544" title="All 4 branches missed.">                assert(added);</span>
<span class="nc" id="L545">                order = fields.size();</span>
<span class="nc" id="L546">            }</span>

            public byte getLiteralTag() {
<span class="nc" id="L549">                return descriptor.getLiteralTag();</span>
            }

            public int compareTo(Member o) {
<span class="nc" id="L553">                Field that = (Field)o;</span>
<span class="nc" id="L554">                return this.order - that.order;</span>
            }
        }

<span class="nc bnc" id="L558" title="All 2 branches missed.">        public</span>
        class Method extends Member {
            // Code attribute is specially hardwired.
            Code code;

<span class="nc" id="L563">            public Method(int flags, DescriptorEntry descriptor) {</span>
<span class="nc" id="L564">                super(flags, descriptor);</span>
<span class="nc bnc" id="L565" title="All 4 branches missed.">                assert(descriptor.isMethod());</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">                if (methods == null)</span>
<span class="nc" id="L567">                    methods = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L568">                boolean added = methods.add(this);</span>
<span class="nc bnc" id="L569" title="All 4 branches missed.">                assert(added);</span>
<span class="nc" id="L570">            }</span>

            public void trimToSize() {
<span class="nc" id="L573">                super.trimToSize();</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">                if (code != null)</span>
<span class="nc" id="L575">                    code.trimToSize();</span>
<span class="nc" id="L576">            }</span>

            public int getArgumentSize() {
<span class="nc" id="L579">                int argSize  = descriptor.typeRef.computeSize(true);</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                int thisSize = Modifier.isStatic(flags) ? 0 : 1;</span>
<span class="nc" id="L581">                return thisSize + argSize;</span>
            }

            // Sort methods in a canonical order (by type, then by name).
            public int compareTo(Member o) {
<span class="nc" id="L586">                Method that = (Method)o;</span>
<span class="nc" id="L587">                return this.getDescriptor().compareTo(that.getDescriptor());</span>
            }

            public void strip(String attrName) {
<span class="nc bnc" id="L591" title="All 2 branches missed.">                if (&quot;Code&quot;.equals(attrName))</span>
<span class="nc" id="L592">                    code = null;</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">                if (code != null)</span>
<span class="nc" id="L594">                    code.strip(attrName);</span>
<span class="nc" id="L595">                super.strip(attrName);</span>
<span class="nc" id="L596">            }</span>
            protected void visitRefs(int mode, Collection&lt;Entry&gt; refs) {
<span class="nc" id="L598">                super.visitRefs(mode, refs);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">                if (code != null) {</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                    if (mode == VRM_CLASSIC) {</span>
<span class="nc" id="L601">                        refs.add(getRefString(&quot;Code&quot;));</span>
                    }
<span class="nc" id="L603">                    code.visitRefs(mode, refs);</span>
                }
<span class="nc" id="L605">            }</span>
        }

        public void trimToSize() {
<span class="nc" id="L609">            super.trimToSize();</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">            for (int isM = 0; isM &lt;= 1; isM++) {</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">                ArrayList&lt;? extends Member&gt; members = (isM == 0) ? fields : methods;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                if (members == null)  continue;</span>
<span class="nc" id="L613">                members.trimToSize();</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">                for (Member m : members) {</span>
<span class="nc" id="L615">                    m.trimToSize();</span>
<span class="nc" id="L616">                }</span>
            }
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if (innerClasses != null) {</span>
<span class="nc" id="L619">                innerClasses.trimToSize();</span>
            }
<span class="nc" id="L621">        }</span>

        public void strip(String attrName) {
<span class="nc bnc" id="L624" title="All 2 branches missed.">            if (&quot;InnerClass&quot;.equals(attrName))</span>
<span class="nc" id="L625">                innerClasses = null;</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">            for (int isM = 0; isM &lt;= 1; isM++) {</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">                ArrayList&lt;? extends Member&gt; members = (isM == 0) ? fields : methods;</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">                if (members == null)  continue;</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">                for (Member m : members) {</span>
<span class="nc" id="L630">                    m.strip(attrName);</span>
<span class="nc" id="L631">                }</span>
            }
<span class="nc" id="L633">            super.strip(attrName);</span>
<span class="nc" id="L634">        }</span>

        protected void visitRefs(int mode, Collection&lt;Entry&gt; refs) {
<span class="nc bnc" id="L637" title="All 2 branches missed.">            if (verbose &gt; 2)  Utils.log.fine(&quot;visitRefs &quot;+this);</span>
<span class="nc" id="L638">            refs.add(thisClass);</span>
<span class="nc" id="L639">            refs.add(superClass);</span>
<span class="nc" id="L640">            refs.addAll(Arrays.asList(interfaces));</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">            for (int isM = 0; isM &lt;= 1; isM++) {</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">                ArrayList&lt;? extends Member&gt; members = (isM == 0) ? fields : methods;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                if (members == null)  continue;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                for (Member m : members) {</span>
<span class="nc" id="L645">                    boolean ok = false;</span>
                    try {
<span class="nc" id="L647">                        m.visitRefs(mode, refs);</span>
<span class="nc" id="L648">                        ok = true;</span>
                    } finally {
<span class="nc bnc" id="L650" title="All 4 branches missed.">                        if (!ok)</span>
<span class="nc" id="L651">                            Utils.log.warning(&quot;Error scanning &quot;+m);</span>
                    }
<span class="nc" id="L653">                }</span>
            }
<span class="nc" id="L655">            visitInnerClassRefs(mode, refs);</span>
            // Handle attribute list:
<span class="nc" id="L657">            super.visitRefs(mode, refs);</span>
<span class="nc" id="L658">        }</span>

        protected void visitInnerClassRefs(int mode, Collection&lt;Entry&gt; refs) {
<span class="nc" id="L661">            Package.visitInnerClassRefs(innerClasses, mode, refs);</span>
<span class="nc" id="L662">        }</span>

        // Hook called by ClassReader when it's done.
        void finishReading() {
<span class="nc" id="L666">            trimToSize();</span>
<span class="nc" id="L667">            maybeChooseFileName();</span>
<span class="nc" id="L668">        }</span>

        public void initFile(File file) {
<span class="nc bnc" id="L671" title="All 4 branches missed.">            assert(this.file == null);  // set-once</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">            if (file == null) {</span>
                // Build a trivial stub.
<span class="nc" id="L674">                file = newStub(canonicalFileName());</span>
            }
<span class="nc" id="L676">            this.file = file;</span>
<span class="nc bnc" id="L677" title="All 4 branches missed.">            assert(file.isClassStub());</span>
<span class="nc" id="L678">            file.stubClass = this;</span>
<span class="nc" id="L679">            maybeChooseFileName();</span>
<span class="nc" id="L680">        }</span>

        public void maybeChooseFileName() {
<span class="nc bnc" id="L683" title="All 2 branches missed.">            if (thisClass == null) {</span>
<span class="nc" id="L684">                return;  // do not choose yet</span>
            }
<span class="nc" id="L686">            String canonName = canonicalFileName();</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">            if (file.nameString.equals(&quot;&quot;)) {</span>
<span class="nc" id="L688">                file.nameString = canonName;</span>
            }
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if (file.nameString.equals(canonName)) {</span>
                // The file name is predictable.  Transmit &quot;&quot;.
<span class="nc" id="L692">                file.name = getRefString(&quot;&quot;);</span>
<span class="nc" id="L693">                return;</span>
            }
            // If name has not yet been looked up, find it now.
<span class="nc bnc" id="L696" title="All 2 branches missed.">            if (file.name == null) {</span>
<span class="nc" id="L697">                file.name = getRefString(file.nameString);</span>
            }
<span class="nc" id="L699">        }</span>

        public String canonicalFileName() {
<span class="nc bnc" id="L702" title="All 2 branches missed.">            if (thisClass == null)  return null;</span>
<span class="nc" id="L703">            return thisClass.stringValue() + &quot;.class&quot;;</span>
        }

        public java.io.File getFileName(java.io.File parent) {
<span class="nc" id="L707">            String name = file.name.stringValue();</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">            if (name.equals(&quot;&quot;))</span>
<span class="nc" id="L709">                name = canonicalFileName();</span>
<span class="nc" id="L710">            String fname = name.replace('/', java.io.File.separatorChar);</span>
<span class="nc" id="L711">            return new java.io.File(parent, fname);</span>
        }
        public java.io.File getFileName() {
<span class="nc" id="L714">            return getFileName(null);</span>
        }

        public String toString() {
<span class="nc" id="L718">            return thisClass.stringValue();</span>
        }
    }

    void addClass(Class c) {
<span class="nc bnc" id="L723" title="All 4 branches missed.">        assert(c.getPackage() == this);</span>
<span class="nc" id="L724">        boolean added = classes.add(c);</span>
<span class="nc bnc" id="L725" title="All 4 branches missed.">        assert(added);</span>
        // Make sure the class is represented in the total file order:
<span class="nc bnc" id="L727" title="All 2 branches missed.">        if (c.file == null)  c.initFile(null);</span>
<span class="nc" id="L728">        addFile(c.file);</span>
<span class="nc" id="L729">    }</span>

    // What non-class files are in this unit?
<span class="nc" id="L732">    ArrayList&lt;File&gt; files = new ArrayList&lt;&gt;();</span>

    public List&lt;File&gt; getFiles() {
<span class="nc" id="L735">        return files;</span>
    }

    public List&lt;File&gt; getClassStubs() {
<span class="nc" id="L739">        List&lt;File&gt; classStubs = new ArrayList&lt;&gt;(classes.size());</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">        for (Class cls : classes) {</span>
<span class="nc bnc" id="L741" title="All 4 branches missed.">            assert(cls.file.isClassStub());</span>
<span class="nc" id="L742">            classStubs.add(cls.file);</span>
<span class="nc" id="L743">        }</span>
<span class="nc" id="L744">        return classStubs;</span>
    }

<span class="nc bnc" id="L747" title="All 2 branches missed.">    public final class File implements Comparable&lt;File&gt; {</span>
        String nameString;  // true name of this file
        Utf8Entry name;
<span class="nc" id="L750">        int modtime = NO_MODTIME;</span>
<span class="nc" id="L751">        int options = 0;  // random flag bits, such as deflate_hint</span>
        Class stubClass;  // if this is a stub, here's the class
<span class="nc" id="L753">        ArrayList&lt;byte[]&gt; prepend = new ArrayList&lt;&gt;();  // list of byte[]</span>
<span class="nc" id="L754">        java.io.ByteArrayOutputStream append = new ByteArrayOutputStream();</span>

<span class="nc" id="L756">        File(Utf8Entry name) {</span>
<span class="nc" id="L757">            this.name = name;</span>
<span class="nc" id="L758">            this.nameString = name.stringValue();</span>
            // caller must fill in contents
<span class="nc" id="L760">        }</span>
<span class="nc" id="L761">        File(String nameString) {</span>
<span class="nc" id="L762">            nameString = fixupFileName(nameString);</span>
<span class="nc" id="L763">            this.name = getRefString(nameString);</span>
<span class="nc" id="L764">            this.nameString = name.stringValue();</span>
<span class="nc" id="L765">        }</span>

        public boolean isDirectory() {
            // JAR directory.  Useless.
<span class="nc" id="L769">            return nameString.endsWith(&quot;/&quot;);</span>
        }
        public boolean isClassStub() {
<span class="nc bnc" id="L772" title="All 2 branches missed.">            return (options &amp; FO_IS_CLASS_STUB) != 0;</span>
        }
        public Class getStubClass() {
<span class="nc bnc" id="L775" title="All 4 branches missed.">            assert(isClassStub());</span>
<span class="nc bnc" id="L776" title="All 4 branches missed.">            assert(stubClass != null);</span>
<span class="nc" id="L777">            return stubClass;</span>
        }
        public boolean isTrivialClassStub() {
<span class="nc bnc" id="L780" title="All 2 branches missed.">            return isClassStub()</span>
<span class="nc bnc" id="L781" title="All 8 branches missed.">                &amp;&amp; name.stringValue().equals(&quot;&quot;)</span>
                &amp;&amp; (modtime == NO_MODTIME || modtime == default_modtime)
                &amp;&amp; (options &amp;~ FO_IS_CLASS_STUB) == 0;
        }

        // The nameString is the key.  Ignore other things.
        // (Note:  The name might be &quot;&quot;, in the case of a trivial class stub.)
        public boolean equals(Object o) {
<span class="nc bnc" id="L789" title="All 4 branches missed.">            if (o == null || (o.getClass() != File.class))</span>
<span class="nc" id="L790">                return false;</span>
<span class="nc" id="L791">            File that = (File)o;</span>
<span class="nc" id="L792">            return that.nameString.equals(this.nameString);</span>
        }
        public int hashCode() {
<span class="nc" id="L795">            return nameString.hashCode();</span>
        }
        // Simple alphabetic sort.  PackageWriter uses a better comparator.
        public int compareTo(File that) {
<span class="nc" id="L799">            return this.nameString.compareTo(that.nameString);</span>
        }
        public String toString() {
<span class="nc" id="L802">            return nameString+&quot;{&quot;</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">                +(isClassStub()?&quot;*&quot;:&quot;&quot;)</span>
<span class="nc bnc" id="L804" title="All 4 branches missed.">                +(BandStructure.testBit(options,FO_DEFLATE_HINT)?&quot;@&quot;:&quot;&quot;)</span>
                +(modtime==NO_MODTIME?&quot;&quot;:&quot;M&quot;+modtime)
<span class="nc bnc" id="L806" title="All 2 branches missed.">                +(getFileLength()==0?&quot;&quot;:&quot;[&quot;+getFileLength()+&quot;]&quot;)</span>
                +&quot;}&quot;;
        }

        public java.io.File getFileName() {
<span class="nc" id="L811">            return getFileName(null);</span>
        }
        public java.io.File getFileName(java.io.File parent) {
<span class="nc" id="L814">            String lname = this.nameString;</span>
            //if (name.startsWith(&quot;./&quot;))  name = name.substring(2);
<span class="nc" id="L816">            String fname = lname.replace('/', java.io.File.separatorChar);</span>
<span class="nc" id="L817">            return new java.io.File(parent, fname);</span>
        }

        public void addBytes(byte[] bytes) {
<span class="nc" id="L821">            addBytes(bytes, 0, bytes.length);</span>
<span class="nc" id="L822">        }</span>
        public void addBytes(byte[] bytes, int off, int len) {
<span class="nc bnc" id="L824" title="All 2 branches missed.">            if (((append.size() | len) &lt;&lt; 2) &lt; 0) {</span>
<span class="nc" id="L825">                prepend.add(append.toByteArray());</span>
<span class="nc" id="L826">                append.reset();</span>
            }
<span class="nc" id="L828">            append.write(bytes, off, len);</span>
<span class="nc" id="L829">        }</span>
        public long getFileLength() {
<span class="nc" id="L831">            long len = 0;</span>
<span class="nc bnc" id="L832" title="All 4 branches missed.">            if (prepend == null || append == null)  return 0;</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">            for (byte[] block : prepend) {</span>
<span class="nc" id="L834">                len += block.length;</span>
<span class="nc" id="L835">            }</span>
<span class="nc" id="L836">            len += append.size();</span>
<span class="nc" id="L837">            return len;</span>
        }
        public void writeTo(OutputStream out) throws IOException {
<span class="nc bnc" id="L840" title="All 4 branches missed.">            if (prepend == null || append == null)  return;</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">            for (byte[] block : prepend) {</span>
<span class="nc" id="L842">                out.write(block);</span>
<span class="nc" id="L843">            }</span>
<span class="nc" id="L844">            append.writeTo(out);</span>
<span class="nc" id="L845">        }</span>
        public void readFrom(InputStream in) throws IOException {
<span class="nc" id="L847">            byte[] buf = new byte[1 &lt;&lt; 16];</span>
            int nr;
<span class="nc bnc" id="L849" title="All 2 branches missed.">            while ((nr = in.read(buf)) &gt; 0) {</span>
<span class="nc" id="L850">                addBytes(buf, 0, nr);</span>
            }
<span class="nc" id="L852">        }</span>
        public InputStream getInputStream() {
<span class="nc" id="L854">            InputStream in = new ByteArrayInputStream(append.toByteArray());</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">            if (prepend.isEmpty())  return in;</span>
<span class="nc" id="L856">            List&lt;InputStream&gt; isa = new ArrayList&lt;&gt;(prepend.size()+1);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">            for (byte[] bytes : prepend) {</span>
<span class="nc" id="L858">                isa.add(new ByteArrayInputStream(bytes));</span>
<span class="nc" id="L859">            }</span>
<span class="nc" id="L860">            isa.add(in);</span>
<span class="nc" id="L861">            return new SequenceInputStream(Collections.enumeration(isa));</span>
        }

        protected void visitRefs(int mode, Collection&lt;Entry&gt; refs) {
<span class="nc bnc" id="L865" title="All 4 branches missed.">            assert(name != null);</span>
<span class="nc" id="L866">            refs.add(name);</span>
<span class="nc" id="L867">        }</span>
    }

    File newStub(String classFileNameString) {
<span class="nc" id="L871">        File stub = new File(classFileNameString);</span>
<span class="nc" id="L872">        stub.options |= FO_IS_CLASS_STUB;</span>
<span class="nc" id="L873">        stub.prepend = null;</span>
<span class="nc" id="L874">        stub.append = null;  // do not collect data</span>
<span class="nc" id="L875">        return stub;</span>
    }

    private static String fixupFileName(String name) {
<span class="nc" id="L879">        String fname = name.replace(java.io.File.separatorChar, '/');</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">        if (fname.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L881">            throw new IllegalArgumentException(&quot;absolute file name &quot;+fname);</span>
        }
<span class="nc" id="L883">        return fname;</span>
    }

    void addFile(File file) {
<span class="nc" id="L887">        boolean added = files.add(file);</span>
<span class="nc bnc" id="L888" title="All 4 branches missed.">        assert(added);</span>
<span class="nc" id="L889">    }</span>

    // Is there a globally declared table of inner classes?
<span class="nc" id="L892">    List&lt;InnerClass&gt; allInnerClasses = new ArrayList&lt;&gt;();</span>
    Map&lt;ClassEntry, InnerClass&gt;   allInnerClassesByThis;

    public
    List&lt;InnerClass&gt; getAllInnerClasses() {
<span class="nc" id="L897">        return allInnerClasses;</span>
    }

    public
    void setAllInnerClasses(Collection&lt;InnerClass&gt; ics) {
<span class="nc bnc" id="L902" title="All 4 branches missed.">        assert(ics != allInnerClasses);</span>
<span class="nc" id="L903">        allInnerClasses.clear();</span>
<span class="nc" id="L904">        allInnerClasses.addAll(ics);</span>

        // Make an index:
<span class="nc" id="L907">        allInnerClassesByThis = new HashMap&lt;&gt;(allInnerClasses.size());</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">        for (InnerClass ic : allInnerClasses) {</span>
<span class="nc" id="L909">            Object pic = allInnerClassesByThis.put(ic.thisClass, ic);</span>
<span class="nc bnc" id="L910" title="All 4 branches missed.">            assert(pic == null);  // caller must ensure key uniqueness!</span>
<span class="nc" id="L911">        }</span>
<span class="nc" id="L912">    }</span>

    /** Return a global inner class record for the given thisClass. */
    public
    InnerClass getGlobalInnerClass(Entry thisClass) {
<span class="nc bnc" id="L917" title="All 4 branches missed.">        assert(thisClass instanceof ClassEntry);</span>
<span class="nc" id="L918">        return allInnerClassesByThis.get(thisClass);</span>
    }

    static
    class InnerClass implements Comparable&lt;InnerClass&gt; {
        final ClassEntry thisClass;
        final ClassEntry outerClass;
        final Utf8Entry name;
        final int flags;

        // Can name and outerClass be derived from thisClass?
        final boolean predictable;

        // About 30% of inner classes are anonymous (in rt.jar).
        // About 60% are class members; the rest are named locals.
        // Nearly all have predictable outers and names.

        InnerClass(ClassEntry thisClass, ClassEntry outerClass,
<span class="nc" id="L936">                   Utf8Entry name, int flags) {</span>
<span class="nc" id="L937">            this.thisClass = thisClass;</span>
<span class="nc" id="L938">            this.outerClass = outerClass;</span>
<span class="nc" id="L939">            this.name = name;</span>
<span class="nc" id="L940">            this.flags = flags;</span>
<span class="nc" id="L941">            this.predictable = computePredictable();</span>
<span class="nc" id="L942">        }</span>

        private boolean computePredictable() {
            //System.out.println(&quot;computePredictable &quot;+outerClass+&quot; &quot;+this.name);
<span class="nc" id="L946">            String[] parse = parseInnerClassName(thisClass.stringValue());</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">            if (parse == null)  return false;</span>
<span class="nc" id="L948">            String pkgOuter = parse[0];</span>
            //String number = parse[1];
<span class="nc" id="L950">            String lname     = parse[2];</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">            String haveName  = (this.name == null)  ? null : this.name.stringValue();</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">            String haveOuter = (outerClass == null) ? null : outerClass.stringValue();</span>
<span class="nc bnc" id="L953" title="All 4 branches missed.">            boolean lpredictable = (lname == haveName &amp;&amp; pkgOuter == haveOuter);</span>
            //System.out.println(&quot;computePredictable =&gt; &quot;+predictable);
<span class="nc" id="L955">            return lpredictable;</span>
        }

        public boolean equals(Object o) {
<span class="nc bnc" id="L959" title="All 4 branches missed.">            if (o == null || o.getClass() != InnerClass.class)</span>
<span class="nc" id="L960">                return false;</span>
<span class="nc" id="L961">            InnerClass that = (InnerClass)o;</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">            return eq(this.thisClass, that.thisClass)</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">                &amp;&amp; eq(this.outerClass, that.outerClass)</span>
<span class="nc bnc" id="L964" title="All 4 branches missed.">                &amp;&amp; eq(this.name, that.name)</span>
                &amp;&amp; this.flags == that.flags;
        }
        private static boolean eq(Object x, Object y) {
<span class="nc bnc" id="L968" title="All 4 branches missed.">            return (x == null)? y == null: x.equals(y);</span>
        }
        public int hashCode() {
<span class="nc" id="L971">            return thisClass.hashCode();</span>
        }
        public int compareTo(InnerClass that) {
<span class="nc" id="L974">            return this.thisClass.compareTo(that.thisClass);</span>
        }

        protected void visitRefs(int mode, Collection&lt;Entry&gt; refs) {
<span class="nc" id="L978">            refs.add(thisClass);</span>
<span class="nc bnc" id="L979" title="All 4 branches missed.">            if (mode == VRM_CLASSIC || !predictable) {</span>
                // If the name can be demangled, the package omits
                // the products of demangling.  Otherwise, include them.
<span class="nc" id="L982">                refs.add(outerClass);</span>
<span class="nc" id="L983">                refs.add(name);</span>
            }
<span class="nc" id="L985">        }</span>

        public String toString() {
<span class="nc" id="L988">            return thisClass.stringValue();</span>
        }
    }

    // Helper for building InnerClasses attributes.
    static private
    void visitInnerClassRefs(Collection&lt;InnerClass&gt; innerClasses, int mode, Collection&lt;Entry&gt; refs) {
<span class="nc bnc" id="L995" title="All 2 branches missed.">        if (innerClasses == null) {</span>
<span class="nc" id="L996">            return;  // no attribute; nothing to do</span>
        }
<span class="nc bnc" id="L998" title="All 2 branches missed.">        if (mode == VRM_CLASSIC) {</span>
<span class="nc" id="L999">            refs.add(getRefString(&quot;InnerClasses&quot;));</span>
        }
<span class="nc bnc" id="L1001" title="All 2 branches missed.">        if (innerClasses.size() &gt; 0) {</span>
            // Count the entries themselves:
<span class="nc bnc" id="L1003" title="All 2 branches missed.">            for (InnerClass c : innerClasses) {</span>
<span class="nc" id="L1004">                c.visitRefs(mode, refs);</span>
<span class="nc" id="L1005">            }</span>
        }
<span class="nc" id="L1007">    }</span>

    static String[] parseInnerClassName(String n) {
        //System.out.println(&quot;parseInnerClassName &quot;+n);
        String pkgOuter, number, name;
        int dollar1, dollar2;  // pointers to $ in the pattern
        // parse n = (&lt;pkg&gt;/)*&lt;outer&gt;($&lt;number&gt;)?($&lt;name&gt;)?
<span class="nc" id="L1014">        int nlen = n.length();</span>
<span class="nc" id="L1015">        int pkglen = lastIndexOf(SLASH_MIN,  SLASH_MAX,  n, n.length()) + 1;</span>
<span class="nc" id="L1016">        dollar2    = lastIndexOf(DOLLAR_MIN, DOLLAR_MAX, n, n.length());</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">        if (dollar2 &lt; pkglen)  return null;</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">        if (isDigitString(n, dollar2+1, nlen)) {</span>
            // n = (&lt;pkg&gt;/)*&lt;outer&gt;$&lt;number&gt;
<span class="nc" id="L1020">            number = n.substring(dollar2+1, nlen);</span>
<span class="nc" id="L1021">            name = null;</span>
<span class="nc" id="L1022">            dollar1 = dollar2;</span>
<span class="nc" id="L1023">        } else if ((dollar1</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                    = lastIndexOf(DOLLAR_MIN, DOLLAR_MAX, n, dollar2-1))</span>
                   &gt; pkglen
<span class="nc bnc" id="L1026" title="All 2 branches missed.">                   &amp;&amp; isDigitString(n, dollar1+1, dollar2)) {</span>
            // n = (&lt;pkg&gt;/)*&lt;outer&gt;$&lt;number&gt;$&lt;name&gt;
<span class="nc" id="L1028">            number = n.substring(dollar1+1, dollar2);</span>
<span class="nc" id="L1029">            name = n.substring(dollar2+1, nlen).intern();</span>
        } else {
            // n = (&lt;pkg&gt;/)*&lt;outer&gt;$&lt;name&gt;
<span class="nc" id="L1032">            dollar1 = dollar2;</span>
<span class="nc" id="L1033">            number = null;</span>
<span class="nc" id="L1034">            name = n.substring(dollar2+1, nlen).intern();</span>
        }
<span class="nc bnc" id="L1036" title="All 2 branches missed.">        if (number == null)</span>
<span class="nc" id="L1037">            pkgOuter = n.substring(0, dollar1).intern();</span>
        else
<span class="nc" id="L1039">            pkgOuter = null;</span>
        //System.out.println(&quot;parseInnerClassName parses &quot;+pkgOuter+&quot; &quot;+number+&quot; &quot;+name);
<span class="nc" id="L1041">        return new String[] { pkgOuter, number, name };</span>
    }

    private static final int SLASH_MIN = '.';
    private static final int SLASH_MAX = '/';
    private static final int DOLLAR_MIN = 0;
    private static final int DOLLAR_MAX = '-';
    static {
<span class="nc bnc" id="L1049" title="All 4 branches missed.">        assert(lastIndexOf(DOLLAR_MIN, DOLLAR_MAX, &quot;x$$y$&quot;, 4) == 2);</span>
<span class="nc bnc" id="L1050" title="All 4 branches missed.">        assert(lastIndexOf(SLASH_MIN,  SLASH_MAX,  &quot;x//y/&quot;, 4) == 2);</span>
    }

    private static int lastIndexOf(int chMin, int chMax, String str, int pos) {
<span class="nc bnc" id="L1054" title="All 2 branches missed.">        for (int i = pos; --i &gt;= 0; ) {</span>
<span class="nc" id="L1055">            int ch = str.charAt(i);</span>
<span class="nc bnc" id="L1056" title="All 4 branches missed.">            if (ch &gt;= chMin &amp;&amp; ch &lt;= chMax) {</span>
<span class="nc" id="L1057">                return i;</span>
            }
<span class="nc" id="L1059">        }</span>
<span class="nc" id="L1060">        return -1;</span>
    }

    private static boolean isDigitString(String x, int beg, int end) {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">        if (beg == end)  return false;  // null string</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        for (int i = beg; i &lt; end; i++) {</span>
<span class="nc" id="L1066">            char ch = x.charAt(i);</span>
<span class="nc bnc" id="L1067" title="All 4 branches missed.">            if (!(ch &gt;= '0' &amp;&amp; ch &lt;= '9'))  return false;</span>
        }
<span class="nc" id="L1069">        return true;</span>
    }

    static String getObviousSourceFile(String className) {
<span class="nc" id="L1073">        String n = className;</span>
<span class="nc" id="L1074">        int pkglen = lastIndexOf(SLASH_MIN,  SLASH_MAX,  n, n.length()) + 1;</span>
<span class="nc" id="L1075">        n = n.substring(pkglen);</span>
<span class="nc" id="L1076">        int cutoff = n.length();</span>
        for (;;) {
            // Work backwards, finding all '$', '#', etc.
<span class="nc" id="L1079">            int dollar2 = lastIndexOf(DOLLAR_MIN, DOLLAR_MAX, n, cutoff-1);</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">            if (dollar2 &lt; 0)</span>
<span class="nc" id="L1081">                break;</span>
<span class="nc" id="L1082">            cutoff = dollar2;</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            if (cutoff == 0)</span>
<span class="nc" id="L1084">                break;</span>
<span class="nc" id="L1085">        }</span>
<span class="nc" id="L1086">        String obvious = n.substring(0, cutoff)+&quot;.java&quot;;</span>
<span class="nc" id="L1087">        return obvious;</span>
    }
/*
    static {
        assert(getObviousSourceFile(&quot;foo&quot;).equals(&quot;foo.java&quot;));
        assert(getObviousSourceFile(&quot;foo/bar&quot;).equals(&quot;bar.java&quot;));
        assert(getObviousSourceFile(&quot;foo/bar$baz&quot;).equals(&quot;bar.java&quot;));
        assert(getObviousSourceFile(&quot;foo/bar#baz#1&quot;).equals(&quot;bar.java&quot;));
        assert(getObviousSourceFile(&quot;foo.bar.baz#1&quot;).equals(&quot;baz.java&quot;));
    }
*/

    static Utf8Entry getRefString(String s) {
<span class="nc" id="L1100">        return ConstantPool.getUtf8Entry(s);</span>
    }

    static LiteralEntry getRefLiteral(Comparable&lt;?&gt; s) {
<span class="nc" id="L1104">        return ConstantPool.getLiteralEntry(s);</span>
    }

    void stripAttributeKind(String what) {
        // what is one of { Debug, Compile, Constant, Exceptions, InnerClasses }
<span class="nc bnc" id="L1109" title="All 2 branches missed.">        if (verbose &gt; 0)</span>
<span class="nc" id="L1110">            Utils.log.info(&quot;Stripping &quot;+what.toLowerCase()+&quot; data and attributes...&quot;);</span>
<span class="nc bnc" id="L1111" title="All 18 branches missed.">        switch (what) {</span>
            case &quot;Debug&quot;:
<span class="nc" id="L1113">                strip(&quot;SourceFile&quot;);</span>
<span class="nc" id="L1114">                strip(&quot;LineNumberTable&quot;);</span>
<span class="nc" id="L1115">                strip(&quot;LocalVariableTable&quot;);</span>
<span class="nc" id="L1116">                strip(&quot;LocalVariableTypeTable&quot;);</span>
<span class="nc" id="L1117">                break;</span>
            case &quot;Compile&quot;:
                // Keep the inner classes normally.
                // Although they have no effect on execution,
                // the Reflection API exposes them, and JCK checks them.
                // NO: // strip(&quot;InnerClasses&quot;);
<span class="nc" id="L1123">                strip(&quot;Deprecated&quot;);</span>
<span class="nc" id="L1124">                strip(&quot;Synthetic&quot;);</span>
<span class="nc" id="L1125">                break;</span>
            case &quot;Exceptions&quot;:
                // Keep the exceptions normally.
                // Although they have no effect on execution,
                // the Reflection API exposes them, and JCK checks them.
<span class="nc" id="L1130">                strip(&quot;Exceptions&quot;);</span>
<span class="nc" id="L1131">                break;</span>
            case &quot;Constant&quot;:
<span class="nc" id="L1133">                stripConstantFields();</span>
                break;
        }
<span class="nc" id="L1136">    }</span>

    public void trimToSize() {
<span class="nc" id="L1139">        classes.trimToSize();</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">        for (Class c : classes) {</span>
<span class="nc" id="L1141">            c.trimToSize();</span>
<span class="nc" id="L1142">        }</span>
<span class="nc" id="L1143">        files.trimToSize();</span>
<span class="nc" id="L1144">    }</span>

    public void strip(String attrName) {
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        for (Class c : classes) {</span>
<span class="nc" id="L1148">            c.strip(attrName);</span>
<span class="nc" id="L1149">        }</span>
<span class="nc" id="L1150">    }</span>

    public void stripConstantFields() {
<span class="nc bnc" id="L1153" title="All 2 branches missed.">        for (Class c : classes) {</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">            for (Iterator&lt;Class.Field&gt; j = c.fields.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L1155">                Class.Field f = j.next();</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">                if (Modifier.isFinal(f.flags)</span>
                    // do not strip non-static finals:
<span class="nc bnc" id="L1158" title="All 2 branches missed.">                    &amp;&amp; Modifier.isStatic(f.flags)</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">                    &amp;&amp; f.getAttribute(&quot;ConstantValue&quot;) != null</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">                    &amp;&amp; !f.getName().startsWith(&quot;serial&quot;)) {</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">                    if (verbose &gt; 2) {</span>
<span class="nc" id="L1162">                        Utils.log.fine(&quot;&gt;&gt; Strip &quot;+this+&quot; ConstantValue&quot;);</span>
<span class="nc" id="L1163">                        j.remove();</span>
                    }
                }
<span class="nc" id="L1166">            }</span>
<span class="nc" id="L1167">        }</span>
<span class="nc" id="L1168">    }</span>

    protected void visitRefs(int mode, Collection&lt;Entry&gt; refs) {
<span class="nc bnc" id="L1171" title="All 2 branches missed.">        for ( Class c : classes) {</span>
<span class="nc" id="L1172">            c.visitRefs(mode, refs);</span>
<span class="nc" id="L1173">        }</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">        if (mode != VRM_CLASSIC) {</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">            for (File f : files) {</span>
<span class="nc" id="L1176">                f.visitRefs(mode, refs);</span>
<span class="nc" id="L1177">            }</span>
<span class="nc" id="L1178">            visitInnerClassRefs(allInnerClasses, mode, refs);</span>
        }
<span class="nc" id="L1180">    }</span>

    // Use this before writing the package file.
    // It sorts files into a new order which seems likely to
    // compress better.  It also moves classes to the end of the
    // file order.  It also removes JAR directory entries, which
    // are useless.
    void reorderFiles(boolean keepClassOrder, boolean stripDirectories) {
        // First reorder the classes, if that is allowed.
<span class="nc bnc" id="L1189" title="All 2 branches missed.">        if (!keepClassOrder) {</span>
            // In one test with rt.jar, this trick gained 0.7%
<span class="nc" id="L1191">            Collections.sort(classes);</span>
        }

        // Remove stubs from resources; maybe we'll add them on at the end,
        // if there are some non-trivial ones.  The best case is that
        // modtimes and options are not transmitted, and the stub files
        // for class files do not need to be transmitted at all.
        // Also
<span class="nc" id="L1199">        List&lt;File&gt; stubs = getClassStubs();</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">        for (Iterator&lt;File&gt; i = files.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1201">            File file = i.next();</span>
<span class="nc bnc" id="L1202" title="All 4 branches missed.">            if (file.isClassStub() ||</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">                (stripDirectories &amp;&amp; file.isDirectory())) {</span>
<span class="nc" id="L1204">                i.remove();</span>
            }
<span class="nc" id="L1206">        }</span>

        // Sort the remaining non-class files.
        // We sort them by file type.
        // This keeps files of similar format near each other.
        // Put class files at the end, keeping their fixed order.
        // Be sure the JAR file's required manifest stays at the front. (4893051)
<span class="nc" id="L1213">        Collections.sort(files, new Comparator&lt;File&gt;() {</span>
                public int compare(File r0, File r1) {
                    // Get the file name.
<span class="nc" id="L1216">                    String f0 = r0.nameString;</span>
<span class="nc" id="L1217">                    String f1 = r1.nameString;</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">                    if (f0.equals(f1)) return 0;</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">                    if (JarFile.MANIFEST_NAME.equals(f0))  return 0-1;</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">                    if (JarFile.MANIFEST_NAME.equals(f1))  return 1-0;</span>
                    // Extract file basename.
<span class="nc" id="L1222">                    String n0 = f0.substring(1+f0.lastIndexOf('/'));</span>
<span class="nc" id="L1223">                    String n1 = f1.substring(1+f1.lastIndexOf('/'));</span>
                    // Extract basename extension.
<span class="nc" id="L1225">                    String x0 = n0.substring(1+n0.lastIndexOf('.'));</span>
<span class="nc" id="L1226">                    String x1 = n1.substring(1+n1.lastIndexOf('.'));</span>
                    int r;
                    // Primary sort key is file extension.
<span class="nc" id="L1229">                    r = x0.compareTo(x1);</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">                    if (r != 0)  return r;</span>
<span class="nc" id="L1231">                    r = f0.compareTo(f1);</span>
<span class="nc" id="L1232">                    return r;</span>
                }
            });

        // Add back the class stubs after sorting, before trimStubs.
<span class="nc" id="L1237">        files.addAll(stubs);</span>
<span class="nc" id="L1238">    }</span>

    void trimStubs() {
        // Restore enough non-trivial stubs to carry the needed class modtimes.
<span class="nc bnc" id="L1242" title="All 2 branches missed.">        for (ListIterator&lt;File&gt; i = files.listIterator(files.size()); i.hasPrevious(); ) {</span>
<span class="nc" id="L1243">            File file = i.previous();</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">            if (!file.isTrivialClassStub()) {</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">                if (verbose &gt; 1)</span>
<span class="nc" id="L1246">                    Utils.log.fine(&quot;Keeping last non-trivial &quot;+file);</span>
                break;
            }
<span class="nc bnc" id="L1249" title="All 2 branches missed.">            if (verbose &gt; 2)</span>
<span class="nc" id="L1250">                Utils.log.fine(&quot;Removing trivial &quot;+file);</span>
<span class="nc" id="L1251">            i.remove();</span>
<span class="nc" id="L1252">        }</span>

<span class="nc bnc" id="L1254" title="All 2 branches missed.">        if (verbose &gt; 0) {</span>
<span class="nc" id="L1255">            Utils.log.info(&quot;Transmitting &quot;+files.size()+&quot; files, including per-file data for &quot;+getClassStubs().size()+&quot; classes out of &quot;+classes.size());</span>
        }
<span class="nc" id="L1257">    }</span>

    // Use this before writing the package file.
    void buildGlobalConstantPool(Set&lt;Entry&gt; requiredEntries) {
<span class="nc bnc" id="L1261" title="All 2 branches missed.">        if (verbose &gt; 1)</span>
<span class="nc" id="L1262">            Utils.log.fine(&quot;Checking for unused CP entries&quot;);</span>
<span class="nc" id="L1263">        requiredEntries.add(getRefString(&quot;&quot;));  // uconditionally present</span>
<span class="nc" id="L1264">        visitRefs(VRM_PACKAGE, requiredEntries);</span>
<span class="nc" id="L1265">        ConstantPool.completeReferencesIn(requiredEntries, false);</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">        if (verbose &gt; 1)</span>
<span class="nc" id="L1267">            Utils.log.fine(&quot;Sorting CP entries&quot;);</span>
<span class="nc" id="L1268">        Index   cpAllU = ConstantPool.makeIndex(&quot;unsorted&quot;, requiredEntries);</span>
<span class="nc" id="L1269">        Index[] byTagU = ConstantPool.partitionByTag(cpAllU);</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">        for (int i = 0; i &lt; ConstantPool.TAGS_IN_ORDER.length; i++) {</span>
<span class="nc" id="L1271">            byte tag = ConstantPool.TAGS_IN_ORDER[i];</span>
            // Work on all entries of a given kind.
<span class="nc" id="L1273">            Index ix = byTagU[tag];</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">            if (ix == null)  continue;</span>
<span class="nc" id="L1275">            ConstantPool.sort(ix);</span>
<span class="nc" id="L1276">            cp.initIndexByTag(tag, ix);</span>
<span class="nc" id="L1277">            byTagU[tag] = null;  // done with it</span>
        }
<span class="nc bnc" id="L1279" title="All 2 branches missed.">        for (int i = 0; i &lt; byTagU.length; i++) {</span>
<span class="nc" id="L1280">            Index ix = byTagU[i];</span>
<span class="nc bnc" id="L1281" title="All 4 branches missed.">            assert(ix == null);  // all consumed</span>
        }
<span class="nc bnc" id="L1283" title="All 2 branches missed.">        for (int i = 0; i &lt; ConstantPool.TAGS_IN_ORDER.length; i++) {</span>
<span class="nc" id="L1284">            byte tag = ConstantPool.TAGS_IN_ORDER[i];</span>
<span class="nc" id="L1285">            Index ix = cp.getIndexByTag(tag);</span>
<span class="nc bnc" id="L1286" title="All 4 branches missed.">            assert(ix.assertIsSorted());</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">            if (verbose &gt; 2)  Utils.log.fine(ix.dumpString());</span>
        }
<span class="nc" id="L1289">    }</span>

    // Use this before writing the class files.
    void ensureAllClassFiles() {
<span class="nc" id="L1293">        Set&lt;File&gt; fileSet = new HashSet&lt;&gt;(files);</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">        for (Class cls : classes) {</span>
            // Add to the end of ths list:
<span class="nc bnc" id="L1296" title="All 2 branches missed.">            if (!fileSet.contains(cls.file))</span>
<span class="nc" id="L1297">                files.add(cls.file);</span>
<span class="nc" id="L1298">        }</span>
<span class="nc" id="L1299">    }</span>

<span class="nc" id="L1301">    static final List&lt;Object&gt; noObjects = Arrays.asList(new Object[0]);</span>
<span class="nc" id="L1302">    static final List&lt;Class.Field&gt; noFields = Arrays.asList(new Class.Field[0]);</span>
<span class="nc" id="L1303">    static final List&lt;Class.Method&gt; noMethods = Arrays.asList(new Class.Method[0]);</span>
<span class="nc" id="L1304">    static final List&lt;InnerClass&gt; noInnerClasses = Arrays.asList(new InnerClass[0]);</span>

    protected static final class Version {

        public final short major;
        public final short minor;

<span class="nc" id="L1311">        private Version(short major, short minor) {</span>
<span class="nc" id="L1312">            this.major = major;</span>
<span class="nc" id="L1313">            this.minor = minor;</span>
<span class="nc" id="L1314">        }</span>

        public String toString() {
<span class="nc" id="L1317">            return major + &quot;.&quot; + minor;</span>
        }

        public boolean equals(Object that) {
<span class="nc bnc" id="L1321" title="All 6 branches missed.">            return that instanceof Version</span>
                    &amp;&amp; major == ((Version)that).major
                    &amp;&amp; minor == ((Version)that).minor;
        }

        public int intValue() {
<span class="nc" id="L1327">            return (major &lt;&lt; 16) + minor;</span>
        }

        public int hashCode() {
<span class="nc" id="L1331">            return (major &lt;&lt; 16) + 7 + minor;</span>
        }

        public static Version of(int major, int minor) {
<span class="nc" id="L1335">            return new Version((short)major, (short)minor);</span>
        }

        public static Version of(byte[] bytes) {
<span class="nc" id="L1339">           int minor = ((bytes[0] &amp; 0xFF) &lt;&lt; 8) | (bytes[1] &amp; 0xFF);</span>
<span class="nc" id="L1340">           int major = ((bytes[2] &amp; 0xFF) &lt;&lt; 8) | (bytes[3] &amp; 0xFF);</span>
<span class="nc" id="L1341">           return new Version((short)major, (short)minor);</span>
        }

        public static Version of(int major_minor) {
<span class="nc" id="L1345">            short minor = (short)major_minor;</span>
<span class="nc" id="L1346">            short major = (short)(major_minor &gt;&gt;&gt; 16);</span>
<span class="nc" id="L1347">            return new Version(major, minor);</span>
        }

        public static Version makeVersion(PropMap props, String partialKey) {
<span class="nc" id="L1351">            int min = props.getInteger(Utils.COM_PREFIX</span>
                    + partialKey + &quot;.minver&quot;, -1);
<span class="nc" id="L1353">            int maj = props.getInteger(Utils.COM_PREFIX</span>
                    + partialKey + &quot;.majver&quot;, -1);
<span class="nc bnc" id="L1355" title="All 4 branches missed.">            return min &gt;= 0 &amp;&amp; maj &gt;= 0 ? Version.of(maj, min) : null;</span>
        }
        public byte[] asBytes() {
<span class="nc" id="L1358">            byte[] bytes = {</span>
                (byte) (minor &gt;&gt; 8), (byte) minor,
                (byte) (major &gt;&gt; 8), (byte) major
            };
<span class="nc" id="L1362">            return bytes;</span>
        }
        public int compareTo(Version that) {
<span class="nc" id="L1365">            return this.intValue() - that.intValue();</span>
        }

        public boolean lessThan(Version that) {
<span class="nc bnc" id="L1369" title="All 2 branches missed.">            return compareTo(that) &lt; 0 ;</span>
        }

        public boolean greaterThan(Version that) {
<span class="nc bnc" id="L1373" title="All 2 branches missed.">            return compareTo(that) &gt; 0 ;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>