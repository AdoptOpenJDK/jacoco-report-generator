<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Fixups.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">Fixups.java</span></div><h1>Fixups.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import com.sun.java.util.jar.pack.ConstantPool.Entry;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.Objects;

/**
 * Collection of relocatable constant pool references.
 * It operates with respect to a particular byte array,
 * and stores some of its state in the bytes themselves.
 * &lt;p&gt;
 * As a Collection, it can be iterated over, but it is not a List,
 * since it does not natively support indexed access.
 * &lt;p&gt;
 *
 * @author John Rose
 */
<span class="nc bnc" id="L46" title="All 2 branches missed.">final class Fixups extends AbstractCollection&lt;Fixups.Fixup&gt; {</span>
    byte[] bytes;    // the subject of the relocations
    int head;        // desc locating first reloc
    int tail;        // desc locating last reloc
    int size;        // number of relocations
    Entry[] entries; // [0..size-1] relocations
    int[] bigDescs;  // descs which cannot be stored in the bytes

    // A &quot;desc&quot; (descriptor) is a bit-encoded pair of a location
    // and format.  Every fixup occurs at a &quot;desc&quot;.  Until final
    // patching, bytes addressed by descs may also be used to
    // link this data structure together.  If the bytes are missing,
    // or if the &quot;desc&quot; is too large to encode in the bytes,
    // it is kept in the bigDescs array.

<span class="nc" id="L61">    Fixups(byte[] bytes) {</span>
<span class="nc" id="L62">        this.bytes = bytes;</span>
<span class="nc" id="L63">        entries = new Entry[3];</span>
<span class="nc" id="L64">        bigDescs = noBigDescs;</span>
<span class="nc" id="L65">    }</span>
    Fixups() {
        // If there are no bytes, all descs are kept in bigDescs.
<span class="nc" id="L68">        this((byte[])null);</span>
<span class="nc" id="L69">    }</span>
    Fixups(byte[] bytes, Collection&lt;Fixup&gt; fixups) {
<span class="nc" id="L71">        this(bytes);</span>
<span class="nc" id="L72">        addAll(fixups);</span>
<span class="nc" id="L73">    }</span>
    Fixups(Collection&lt;Fixup&gt; fixups) {
<span class="nc" id="L75">        this((byte[])null);</span>
<span class="nc" id="L76">        addAll(fixups);</span>
<span class="nc" id="L77">    }</span>

    private static final int MINBIGSIZE = 1;
    // cleverly share empty bigDescs:
<span class="nc" id="L81">    private static final int[] noBigDescs = {MINBIGSIZE};</span>

    @Override
    public int size() {
<span class="nc" id="L85">        return size;</span>
    }

    public void trimToSize() {
<span class="nc bnc" id="L89" title="All 2 branches missed.">        if (size != entries.length) {</span>
<span class="nc" id="L90">            Entry[] oldEntries = entries;</span>
<span class="nc" id="L91">            entries = new Entry[size];</span>
<span class="nc" id="L92">            System.arraycopy(oldEntries, 0, entries, 0, size);</span>
        }
<span class="nc" id="L94">        int bigSize = bigDescs[BIGSIZE];</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (bigSize == MINBIGSIZE) {</span>
<span class="nc" id="L96">            bigDescs = noBigDescs;</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">        } else if (bigSize != bigDescs.length) {</span>
<span class="nc" id="L98">            int[] oldBigDescs = bigDescs;</span>
<span class="nc" id="L99">            bigDescs = new int[bigSize];</span>
<span class="nc" id="L100">            System.arraycopy(oldBigDescs, 0, bigDescs, 0, bigSize);</span>
        }
<span class="nc" id="L102">    }</span>

    public void visitRefs(Collection&lt;Entry&gt; refs) {
<span class="nc bnc" id="L105" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L106">            refs.add(entries[i]);</span>
        }
<span class="nc" id="L108">    }</span>

    @Override
    public void clear() {
<span class="nc bnc" id="L112" title="All 2 branches missed.">        if (bytes != null) {</span>
            // Clean the bytes:
<span class="nc bnc" id="L114" title="All 2 branches missed.">            for (Fixup fx : this) {</span>
                //System.out.println(&quot;clean &quot;+fx);
<span class="nc" id="L116">                storeIndex(fx.location(), fx.format(), 0);</span>
<span class="nc" id="L117">            }</span>
        }
<span class="nc" id="L119">        size = 0;</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (bigDescs != noBigDescs)</span>
<span class="nc" id="L121">            bigDescs[BIGSIZE] = MINBIGSIZE;</span>
        // do not trim to size, however
<span class="nc" id="L123">    }</span>

    public byte[] getBytes() {
<span class="nc" id="L126">        return bytes;</span>
    }

    public void setBytes(byte[] newBytes) {
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (bytes == newBytes)  return;</span>
<span class="nc" id="L131">        ArrayList&lt;Fixup&gt; old = null;</span>
<span class="nc bnc" id="L132" title="All 4 branches missed.">        assert((old = new ArrayList&lt;&gt;(this)) != null);</span>
<span class="nc bnc" id="L133" title="All 4 branches missed.">        if (bytes == null || newBytes == null) {</span>
            // One or the other representations is deficient.
            // Construct a checkpoint.
<span class="nc" id="L136">            ArrayList&lt;Fixup&gt; save = new ArrayList&lt;&gt;(this);</span>
<span class="nc" id="L137">            clear();</span>
<span class="nc" id="L138">            bytes = newBytes;</span>
<span class="nc" id="L139">            addAll(save);</span>
<span class="nc" id="L140">        } else {</span>
            // assume newBytes is some sort of bitwise copy of the old bytes
<span class="nc" id="L142">            bytes = newBytes;</span>
        }
<span class="nc bnc" id="L144" title="All 4 branches missed.">        assert(old.equals(new ArrayList&lt;&gt;(this)));</span>
<span class="nc" id="L145">    }</span>

    private static final int LOC_SHIFT = 1;
    private static final int FMT_MASK = 0x1;
    private static final byte UNUSED_BYTE = 0;
    private static final byte OVERFLOW_BYTE = -1;
    // fill pointer of bigDescs array is in element [0]
    private static final int BIGSIZE = 0;

    // Format values:
    private static final int U2_FORMAT = 0;
    private static final int U1_FORMAT = 1;

    // Special values for the static methods.
    private static final int SPECIAL_LOC = 0;
    private static final int SPECIAL_FMT = U2_FORMAT;

<span class="nc" id="L162">    static int fmtLen(int fmt) { return 1+(fmt-U1_FORMAT)/(U2_FORMAT-U1_FORMAT); }</span>
<span class="nc" id="L163">    static int descLoc(int desc) { return desc &gt;&gt;&gt; LOC_SHIFT; }</span>
<span class="nc" id="L164">    static int descFmt(int desc) { return desc  &amp;  FMT_MASK; }</span>
<span class="nc" id="L165">    static int descEnd(int desc) { return descLoc(desc) + fmtLen(descFmt(desc)); }</span>
    static int makeDesc(int loc, int fmt) {
<span class="nc" id="L167">        int desc = (loc &lt;&lt; LOC_SHIFT) | fmt;</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">        assert(descLoc(desc) == loc);</span>
<span class="nc bnc" id="L169" title="All 4 branches missed.">        assert(descFmt(desc) == fmt);</span>
<span class="nc" id="L170">        return desc;</span>
    }
    int fetchDesc(int loc, int fmt) {
<span class="nc" id="L173">        byte b1 = bytes[loc];</span>
<span class="nc bnc" id="L174" title="All 4 branches missed.">        assert(b1 != OVERFLOW_BYTE);</span>
        int value;
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (fmt == U2_FORMAT) {</span>
<span class="nc" id="L177">            byte b2 = bytes[loc+1];</span>
<span class="nc" id="L178">            value = ((b1 &amp; 0xFF) &lt;&lt; 8) + (b2 &amp; 0xFF);</span>
<span class="nc" id="L179">        } else {</span>
<span class="nc" id="L180">            value = (b1 &amp; 0xFF);</span>
        }
        // Stored loc field is difference between its own loc and next loc.
<span class="nc" id="L183">        return value + (loc &lt;&lt; LOC_SHIFT);</span>
    }
    boolean storeDesc(int loc, int fmt, int desc) {
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (bytes == null)</span>
<span class="nc" id="L187">            return false;</span>
<span class="nc" id="L188">        int value = desc - (loc &lt;&lt; LOC_SHIFT);</span>
        byte b1, b2;
<span class="nc bnc" id="L190" title="All 3 branches missed.">        switch (fmt) {</span>
        case U2_FORMAT:
<span class="nc bnc" id="L192" title="All 4 branches missed.">            assert(bytes[loc+0] == UNUSED_BYTE);</span>
<span class="nc bnc" id="L193" title="All 4 branches missed.">            assert(bytes[loc+1] == UNUSED_BYTE);</span>
<span class="nc" id="L194">            b1 = (byte)(value &gt;&gt; 8);</span>
<span class="nc" id="L195">            b2 = (byte)(value &gt;&gt; 0);</span>
<span class="nc bnc" id="L196" title="All 4 branches missed.">            if (value == (value &amp; 0xFFFF) &amp;&amp; b1 != OVERFLOW_BYTE) {</span>
<span class="nc" id="L197">                bytes[loc+0] = b1;</span>
<span class="nc" id="L198">                bytes[loc+1] = b2;</span>
<span class="nc bnc" id="L199" title="All 4 branches missed.">                assert(fetchDesc(loc, fmt) == desc);</span>
<span class="nc" id="L200">                return true;</span>
            }
            break;
        case U1_FORMAT:
<span class="nc bnc" id="L204" title="All 4 branches missed.">            assert(bytes[loc] == UNUSED_BYTE);</span>
<span class="nc" id="L205">            b1 = (byte)value;</span>
<span class="nc bnc" id="L206" title="All 4 branches missed.">            if (value == (value &amp; 0xFF) &amp;&amp; b1 != OVERFLOW_BYTE) {</span>
<span class="nc" id="L207">                bytes[loc] = b1;</span>
<span class="nc bnc" id="L208" title="All 4 branches missed.">                assert(fetchDesc(loc, fmt) == desc);</span>
<span class="nc" id="L209">                return true;</span>
            }
            break;
<span class="nc bnc" id="L212" title="All 2 branches missed.">        default: assert(false);</span>
        }
        // Failure.  Caller must allocate a bigDesc.
<span class="nc" id="L215">        bytes[loc] = OVERFLOW_BYTE;</span>
<span class="nc bnc" id="L216" title="All 6 branches missed.">        assert(fmt==U1_FORMAT || (bytes[loc+1]=(byte)bigDescs[BIGSIZE])!=999);</span>
<span class="nc" id="L217">        return false;</span>
    }
    void storeIndex(int loc, int fmt, int value) {
<span class="nc" id="L220">        storeIndex(bytes, loc, fmt, value);</span>
<span class="nc" id="L221">    }</span>
    static
    void storeIndex(byte[] bytes, int loc, int fmt, int value) {
<span class="nc bnc" id="L224" title="All 3 branches missed.">        switch (fmt) {</span>
        case U2_FORMAT:
<span class="nc bnc" id="L226" title="All 4 branches missed.">            assert(value == (value &amp; 0xFFFF)) : (value);</span>
<span class="nc" id="L227">            bytes[loc+0] = (byte)(value &gt;&gt; 8);</span>
<span class="nc" id="L228">            bytes[loc+1] = (byte)(value &gt;&gt; 0);</span>
<span class="nc" id="L229">            break;</span>
        case U1_FORMAT:
<span class="nc bnc" id="L231" title="All 4 branches missed.">            assert(value == (value &amp; 0xFF)) : (value);</span>
<span class="nc" id="L232">            bytes[loc] = (byte)value;</span>
<span class="nc" id="L233">            break;</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        default: assert(false);</span>
        }
<span class="nc" id="L236">    }</span>

    void addU1(int pc, Entry ref) {
<span class="nc" id="L239">        add(pc, U1_FORMAT, ref);</span>
<span class="nc" id="L240">    }</span>

    void addU2(int pc, Entry ref) {
<span class="nc" id="L243">        add(pc, U2_FORMAT, ref);</span>
<span class="nc" id="L244">    }</span>

    /** Simple and necessary tuple to present each fixup. */
    public static
    class Fixup implements Comparable&lt;Fixup&gt; {
        int desc;         // location and format of reloc
        Entry entry;      // which entry to plug into the bytes
<span class="nc" id="L251">        Fixup(int desc, Entry entry) {</span>
<span class="nc" id="L252">            this.desc = desc;</span>
<span class="nc" id="L253">            this.entry = entry;</span>
<span class="nc" id="L254">        }</span>
<span class="nc" id="L255">        public Fixup(int loc, int fmt, Entry entry) {</span>
<span class="nc" id="L256">            this.desc = makeDesc(loc, fmt);</span>
<span class="nc" id="L257">            this.entry = entry;</span>
<span class="nc" id="L258">        }</span>
<span class="nc" id="L259">        public int location() { return descLoc(desc); }</span>
<span class="nc" id="L260">        public int format() { return descFmt(desc); }</span>
<span class="nc" id="L261">        public Entry entry() { return entry; }</span>
        @Override
        public int compareTo(Fixup that) {
            // Ordering depends only on location.
<span class="nc" id="L265">            return this.location() - that.location();</span>
        }
        @Override
        public boolean equals(Object x) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (!(x instanceof Fixup))  return false;</span>
<span class="nc" id="L270">            Fixup that = (Fixup) x;</span>
<span class="nc bnc" id="L271" title="All 4 branches missed.">            return this.desc == that.desc &amp;&amp; this.entry == that.entry;</span>
        }
        @Override
        public int hashCode() {
<span class="nc" id="L275">            int hash = 7;</span>
<span class="nc" id="L276">            hash = 59 * hash + this.desc;</span>
<span class="nc" id="L277">            hash = 59 * hash + Objects.hashCode(this.entry);</span>
<span class="nc" id="L278">            return hash;</span>
        }
        @Override
        public String toString() {
<span class="nc bnc" id="L282" title="All 2 branches missed.">            return &quot;@&quot;+location()+(format()==U1_FORMAT?&quot;.1&quot;:&quot;&quot;)+&quot;=&quot;+entry;</span>
        }
    }

<span class="nc bnc" id="L286" title="All 2 branches missed.">    private</span>
<span class="nc" id="L287">    class Itr implements Iterator&lt;Fixup&gt; {</span>
<span class="nc" id="L288">        int index = 0;               // index into entries</span>
<span class="nc" id="L289">        int bigIndex = BIGSIZE+1;    // index into bigDescs</span>
<span class="nc" id="L290">        int next = head;             // desc pointing to next fixup</span>
        @Override
<span class="nc bnc" id="L292" title="All 2 branches missed.">        public boolean hasNext() { return index &lt; size; }</span>
        @Override
<span class="nc" id="L294">        public void remove() { throw new UnsupportedOperationException(); }</span>
        @Override
        public Fixup next() {
<span class="nc" id="L297">            int thisIndex = index;</span>
<span class="nc" id="L298">            return new Fixup(nextDesc(), entries[thisIndex]);</span>
        }
        int nextDesc() {
<span class="nc" id="L301">            index++;</span>
<span class="nc" id="L302">            int thisDesc = next;</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (index &lt; size) {</span>
                // Fetch next desc eagerly, in case this fixup gets finalized.
<span class="nc" id="L305">                int loc = descLoc(thisDesc);</span>
<span class="nc" id="L306">                int fmt = descFmt(thisDesc);</span>
<span class="nc bnc" id="L307" title="All 4 branches missed.">                if (bytes != null &amp;&amp; bytes[loc] != OVERFLOW_BYTE) {</span>
<span class="nc" id="L308">                    next = fetchDesc(loc, fmt);</span>
                } else {
                    // The unused extra byte is &quot;asserted&quot; to be equal to BI.
                    // This helps keep the overflow descs in sync.
<span class="nc bnc" id="L312" title="All 8 branches missed.">                    assert(fmt==U1_FORMAT || bytes == null || bytes[loc+1]==(byte)bigIndex);</span>
<span class="nc" id="L313">                    next = bigDescs[bigIndex++];</span>
                }
            }
<span class="nc" id="L316">            return thisDesc;</span>
        }
    }

    @Override
    public Iterator&lt;Fixup&gt; iterator() {
<span class="nc" id="L322">        return new Itr();</span>
    }
    public void add(int location, int format, Entry entry) {
<span class="nc" id="L325">        addDesc(makeDesc(location, format), entry);</span>
<span class="nc" id="L326">    }</span>
    @Override
    public boolean add(Fixup f) {
<span class="nc" id="L329">        addDesc(f.desc, f.entry);</span>
<span class="nc" id="L330">        return true;</span>
    }

    @Override
    public boolean addAll(Collection&lt;? extends Fixup&gt; c) {
<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (c instanceof Fixups) {</span>
            // Use knowledge of Itr structure to avoid building little structs.
<span class="nc" id="L337">            Fixups that = (Fixups) c;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            if (that.size == 0)  return false;</span>
<span class="nc bnc" id="L339" title="All 4 branches missed.">            if (this.size == 0 &amp;&amp; entries.length &lt; that.size)</span>
<span class="nc" id="L340">                growEntries(that.size);  // presize exactly</span>
<span class="nc" id="L341">            Entry[] thatEntries = that.entries;</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">            for (Itr i = that.new Itr(); i.hasNext(); ) {</span>
<span class="nc" id="L343">                int ni = i.index;</span>
<span class="nc" id="L344">                addDesc(i.nextDesc(), thatEntries[ni]);</span>
<span class="nc" id="L345">            }</span>
<span class="nc" id="L346">            return true;</span>
        } else {
<span class="nc" id="L348">            return super.addAll(c);</span>
        }
    }
    // Here is how things get added:
    private void addDesc(int thisDesc, Entry entry) {
<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (entries.length == size)</span>
<span class="nc" id="L354">            growEntries(size * 2);</span>
<span class="nc" id="L355">        entries[size] = entry;</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (size == 0) {</span>
<span class="nc" id="L357">            head = tail = thisDesc;</span>
        } else {
<span class="nc" id="L359">            int prevDesc = tail;</span>
            // Store new desc in previous tail.
<span class="nc" id="L361">            int prevLoc = descLoc(prevDesc);</span>
<span class="nc" id="L362">            int prevFmt = descFmt(prevDesc);</span>
<span class="nc" id="L363">            int prevLen = fmtLen(prevFmt);</span>
<span class="nc" id="L364">            int thisLoc = descLoc(thisDesc);</span>
            // The collection must go in ascending order, and not overlap.
<span class="nc bnc" id="L366" title="All 2 branches missed.">            if (thisLoc &lt; prevLoc + prevLen)</span>
<span class="nc" id="L367">                badOverlap(thisLoc);</span>
<span class="nc" id="L368">            tail = thisDesc;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">            if (!storeDesc(prevLoc, prevFmt, thisDesc)) {</span>
                // overflow
<span class="nc" id="L371">                int bigSize = bigDescs[BIGSIZE];</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                if (bigDescs.length == bigSize)</span>
<span class="nc" id="L373">                    growBigDescs();</span>
                //System.out.println(&quot;bigDescs[&quot;+bigSize+&quot;] = &quot;+thisDesc);
<span class="nc" id="L375">                bigDescs[bigSize++] = thisDesc;</span>
<span class="nc" id="L376">                bigDescs[BIGSIZE] = bigSize;</span>
            }
        }
<span class="nc" id="L379">        size += 1;</span>
<span class="nc" id="L380">    }</span>
    private void badOverlap(int thisLoc) {
<span class="nc" id="L382">        throw new IllegalArgumentException(&quot;locs must be ascending and must not overlap:  &quot;+thisLoc+&quot; &gt;&gt; &quot;+this);</span>
    }

    private void growEntries(int newSize) {
<span class="nc" id="L386">        Entry[] oldEntries = entries;</span>
<span class="nc" id="L387">        entries = new Entry[Math.max(3, newSize)];</span>
<span class="nc" id="L388">        System.arraycopy(oldEntries, 0, entries, 0, oldEntries.length);</span>
<span class="nc" id="L389">    }</span>
    private void growBigDescs() {
<span class="nc" id="L391">        int[] oldBigDescs = bigDescs;</span>
<span class="nc" id="L392">        bigDescs = new int[oldBigDescs.length * 2];</span>
<span class="nc" id="L393">        System.arraycopy(oldBigDescs, 0, bigDescs, 0, oldBigDescs.length);</span>
<span class="nc" id="L394">    }</span>

    /// Static methods that optimize the use of this class.
    static Object addRefWithBytes(Object f, byte[] bytes, Entry e) {
<span class="nc" id="L398">        return add(f, bytes, 0, U2_FORMAT, e);</span>
    }
    static Object addRefWithLoc(Object f, int loc, Entry entry) {
<span class="nc" id="L401">        return add(f, null, loc, U2_FORMAT, entry);</span>
    }
    private static
    Object add(Object prevFixups,
               byte[] bytes, int loc, int fmt,
               Entry e) {
        Fixups f;
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (prevFixups == null) {</span>
<span class="nc bnc" id="L409" title="All 4 branches missed.">            if (loc == SPECIAL_LOC &amp;&amp; fmt == SPECIAL_FMT) {</span>
                // Special convention:  If the attribute has a
                // U2 relocation at position zero, store the Entry
                // rather than building a Fixups structure.
<span class="nc" id="L413">                return e;</span>
            }
<span class="nc" id="L415">            f = new Fixups(bytes);</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">        } else if (!(prevFixups instanceof Fixups)) {</span>
            // Recognize the special convention:
<span class="nc" id="L418">            Entry firstEntry = (Entry) prevFixups;</span>
<span class="nc" id="L419">            f = new Fixups(bytes);</span>
<span class="nc" id="L420">            f.add(SPECIAL_LOC, SPECIAL_FMT, firstEntry);</span>
<span class="nc" id="L421">        } else {</span>
<span class="nc" id="L422">            f = (Fixups) prevFixups;</span>
<span class="nc bnc" id="L423" title="All 4 branches missed.">            assert(f.bytes == bytes);</span>
        }
<span class="nc" id="L425">        f.add(loc, fmt, e);</span>
<span class="nc" id="L426">        return f;</span>
    }

    public static
    void setBytes(Object fixups, byte[] bytes) {
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (fixups instanceof Fixups) {</span>
<span class="nc" id="L432">            Fixups f = (Fixups) fixups;</span>
<span class="nc" id="L433">            f.setBytes(bytes);</span>
        }
<span class="nc" id="L435">    }</span>

    public static
    Object trimToSize(Object fixups) {
<span class="nc bnc" id="L439" title="All 2 branches missed.">        if (fixups instanceof Fixups) {</span>
<span class="nc" id="L440">            Fixups f = (Fixups) fixups;</span>
<span class="nc" id="L441">            f.trimToSize();</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            if (f.size() == 0)</span>
<span class="nc" id="L443">                fixups = null;</span>
        }
<span class="nc" id="L445">        return fixups;</span>
    }

    // Iterate over all the references in this set of fixups.
    public static
    void visitRefs(Object fixups, Collection&lt;Entry&gt; refs) {
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (fixups == null) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        } else if (!(fixups instanceof Fixups)) {</span>
            // Special convention; see above.
<span class="nc" id="L454">            refs.add((Entry) fixups);</span>
        } else {
<span class="nc" id="L456">            Fixups f = (Fixups) fixups;</span>
<span class="nc" id="L457">            f.visitRefs(refs);</span>
        }
<span class="nc" id="L459">    }</span>

    // Clear out this set of fixups by replacing each reference
    // by a hardcoded coding of its reference, drawn from ix.
    public static
    void finishRefs(Object fixups, byte[] bytes, ConstantPool.Index ix) {
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (fixups == null)</span>
<span class="nc" id="L466">            return;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">        if (!(fixups instanceof Fixups)) {</span>
            // Special convention; see above.
<span class="nc" id="L469">            int index = ix.indexOf((Entry) fixups);</span>
<span class="nc" id="L470">            storeIndex(bytes, SPECIAL_LOC, SPECIAL_FMT, index);</span>
<span class="nc" id="L471">            return;</span>
        }
<span class="nc" id="L473">        Fixups f = (Fixups) fixups;</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">        assert(f.bytes == bytes);</span>
<span class="nc" id="L475">        f.finishRefs(ix);</span>
<span class="nc" id="L476">    }</span>

    void finishRefs(ConstantPool.Index ix) {
<span class="nc bnc" id="L479" title="All 2 branches missed.">        if (isEmpty())</span>
<span class="nc" id="L480">            return;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">        for (Fixup fx : this) {</span>
<span class="nc" id="L482">            int index = ix.indexOf(fx.entry);</span>
            //System.out.println(&quot;finish &quot;+fx+&quot; = &quot;+index);
            // Note that the iterator has already fetched the
            // bytes we are about to overwrite.
<span class="nc" id="L486">            storeIndex(fx.location(), fx.format(), index);</span>
<span class="nc" id="L487">        }</span>
        // Further iterations should do nothing:
<span class="nc" id="L489">        bytes = null;  // do not clean them</span>
<span class="nc" id="L490">        clear();</span>
<span class="nc" id="L491">    }</span>

/*
    /// Testing.
    public static void main(String[] av) {
        byte[] bytes = new byte[1 &lt;&lt; 20];
        ConstantPool cp = new ConstantPool();
        Fixups f = new Fixups(bytes);
        boolean isU1 = false;
        int span = 3;
        int nextLoc = 0;
        int[] locs = new int[100];
        final int[] indexes = new int[100];
        int iptr = 1;
        for (int loc = 0; loc &lt; bytes.length; loc++) {
            if (loc == nextLoc &amp;&amp; loc+1 &lt; bytes.length) {
                int fmt = (isU1 ? U1_FORMAT : U2_FORMAT);
                Entry e = ConstantPool.getUtf8Entry(&quot;L&quot;+loc);
                f.add(loc, fmt, e);
                isU1 ^= true;
                if (iptr &lt; 10) {
                    // Make it close in.
                    nextLoc += fmtLen(fmt) + (iptr &lt; 5 ? 0 : 1);
                } else {
                    nextLoc += span;
                    span = (int)(span * 1.77);
                }
                // Here are the bytes that would have gone here:
                locs[iptr] = loc;
                if (fmt == U1_FORMAT) {
                    indexes[iptr++] = (loc &amp; 0xFF);
                } else {
                    indexes[iptr++] = ((loc &amp; 0xFF) &lt;&lt; 8) | ((loc+1) &amp; 0xFF);
                    ++loc;  // skip a byte
                }
                continue;
            }
            bytes[loc] = (byte)loc;
        }
        System.out.println(&quot;size=&quot;+f.size()
                           +&quot; overflow=&quot;+(f.bigDescs[BIGSIZE]-1));
        System.out.println(&quot;Fixups: &quot;+f);
        // Test collection contents.
        assert(iptr == 1+f.size());
        List l = new ArrayList(f);
        Collections.sort(l);  // should not change the order
        if (!l.equals(new ArrayList(f)))  System.out.println(&quot;** disordered&quot;);
        f.setBytes(null);
        if (!l.equals(new ArrayList(f)))  System.out.println(&quot;** bad set 1&quot;);
        f.setBytes(bytes);
        if (!l.equals(new ArrayList(f)))  System.out.println(&quot;** bad set 2&quot;);
        Fixups f3 = new Fixups(f);
        if (!l.equals(new ArrayList(f3))) System.out.println(&quot;** bad set 3&quot;);
        Iterator fi = f.iterator();
        for (int i = 1; i &lt; iptr; i++) {
            Fixup fx = (Fixup) fi.next();
            if (fx.location() != locs[i]) {
                System.out.println(&quot;** &quot;+fx+&quot; != &quot;+locs[i]);
            }
            if (fx.format() == U1_FORMAT)
                System.out.println(fx+&quot; -&gt; &quot;+bytes[locs[i]]);
            else
                System.out.println(fx+&quot; -&gt; &quot;+bytes[locs[i]]+&quot; &quot;+bytes[locs[i]+1]);
        }
        assert(!fi.hasNext());
        indexes[0] = 1;  // like iptr
        Index ix = new Index(&quot;ix&quot;) {
            public int indexOf(Entry e) {
                return indexes[indexes[0]++];
            }
        };
        f.finishRefs(ix);
        for (int loc = 0; loc &lt; bytes.length; loc++) {
            if (bytes[loc] != (byte)loc) {
                System.out.println(&quot;** [&quot;+loc+&quot;] = &quot;+bytes[loc]+&quot; != &quot;+(byte)loc);
            }
        }
    }
//*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>