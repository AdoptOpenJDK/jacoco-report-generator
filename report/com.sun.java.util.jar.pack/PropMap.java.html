<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PropMap.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.java.util.jar.pack</a> &gt; <span class="el_source">PropMap.java</span></div><h1>PropMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.util.jar.pack;

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.jar.Pack200;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * Control block for publishing Pack200 options to the other classes.
 */

<span class="fc bfc" id="L51" title="All 2 branches covered.">final class PropMap implements SortedMap&lt;String, String&gt;  {</span>
<span class="nc" id="L52">    private final TreeMap&lt;String, String&gt; theMap = new TreeMap&lt;&gt;();;</span>

    // type is erased, elements are of type java.beans.PropertyChangeListener
<span class="nc" id="L55">    private final List&lt;Object&gt; listenerList = new ArrayList&lt;&gt;(1);</span>

    void addListener(Object listener) {
<span class="nc bnc" id="L58" title="All 4 branches missed.">        assert Beans.isPropertyChangeListener(listener);</span>
<span class="nc" id="L59">        listenerList.add(listener);</span>
<span class="nc" id="L60">    }</span>

    void removeListener(Object listener) {
<span class="nc bnc" id="L63" title="All 4 branches missed.">        assert Beans.isPropertyChangeListener(listener);</span>
<span class="nc" id="L64">        listenerList.remove(listener);</span>
<span class="nc" id="L65">    }</span>

    // Override:
    public String put(String key, String value) {
<span class="nc" id="L69">        String oldValue = theMap.put(key, value);</span>
<span class="nc bnc" id="L70" title="All 4 branches missed.">        if (value != oldValue &amp;&amp; !listenerList.isEmpty()) {</span>
<span class="nc bnc" id="L71" title="All 4 branches missed.">            assert Beans.isBeansPresent();</span>
            // Post the property change event.
<span class="nc" id="L73">            Object event = Beans.newPropertyChangeEvent(this, key, oldValue, value);</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">            for (Object listener : listenerList) {</span>
<span class="nc" id="L75">                Beans.invokePropertyChange(listener, event);</span>
<span class="nc" id="L76">            }</span>
        }
<span class="nc" id="L78">        return oldValue;</span>
    }

    // All this other stuff is private to the current package.
    // Outide clients of Pack200 do not need to use it; they can
    // get by with generic SortedMap functionality.
    private static Map&lt;String, String&gt; defaultProps;
    static {
<span class="fc" id="L86">        Properties props = new Properties();</span>

        // Allow implementation selected via -Dpack.disable.native=true
<span class="fc" id="L89">        props.put(Utils.DEBUG_DISABLE_NATIVE,</span>
<span class="fc" id="L90">                  String.valueOf(Boolean.getBoolean(Utils.DEBUG_DISABLE_NATIVE)));</span>

        // Set the DEBUG_VERBOSE from system
<span class="fc" id="L93">        props.put(Utils.DEBUG_VERBOSE,</span>
<span class="fc" id="L94">                  String.valueOf(Integer.getInteger(Utils.DEBUG_VERBOSE,0)));</span>

        // Set the PACK_TIMEZONE_NO_UTC
<span class="fc" id="L97">        props.put(Utils.PACK_DEFAULT_TIMEZONE,</span>
<span class="fc" id="L98">                  String.valueOf(Boolean.getBoolean(Utils.PACK_DEFAULT_TIMEZONE)));</span>

        // The segment size is unlimited
<span class="fc" id="L101">        props.put(Pack200.Packer.SEGMENT_LIMIT, &quot;-1&quot;);</span>

        // Preserve file ordering by default.
<span class="fc" id="L104">        props.put(Pack200.Packer.KEEP_FILE_ORDER, Pack200.Packer.TRUE);</span>

        // Preserve all modification times by default.
<span class="fc" id="L107">        props.put(Pack200.Packer.MODIFICATION_TIME, Pack200.Packer.KEEP);</span>

        // Preserve deflation hints by default.
<span class="fc" id="L110">        props.put(Pack200.Packer.DEFLATE_HINT, Pack200.Packer.KEEP);</span>

        // Pass through files with unrecognized attributes by default.
<span class="fc" id="L113">        props.put(Pack200.Packer.UNKNOWN_ATTRIBUTE, Pack200.Packer.PASS);</span>

        // Pass through files with unrecognized format by default, also
        // allow system property to be set
<span class="fc" id="L117">        props.put(Utils.CLASS_FORMAT_ERROR,</span>
<span class="fc" id="L118">                System.getProperty(Utils.CLASS_FORMAT_ERROR, Pack200.Packer.PASS));</span>

        // Default effort is 5, midway between 1 and 9.
<span class="fc" id="L121">        props.put(Pack200.Packer.EFFORT, &quot;5&quot;);</span>

        // Define certain attribute layouts by default.
        // Do this after the previous props are put in place,
        // to allow override if necessary.
<span class="fc" id="L126">        String propFile = &quot;intrinsic.properties&quot;;</span>

<span class="fc" id="L128">        try (InputStream propStr = PackerImpl.class.getResourceAsStream(propFile)) {</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">            if (propStr == null) {</span>
<span class="fc" id="L130">                throw new RuntimeException(propFile + &quot; cannot be loaded&quot;);</span>
            }
<span class="nc" id="L132">            props.load(propStr);</span>
<span class="pc bpc" id="L133" title="7 of 8 branches missed.">        } catch (IOException ee) {</span>
<span class="nc" id="L134">            throw new RuntimeException(ee);</span>
<span class="nc" id="L135">        }</span>

<span class="nc bnc" id="L137" title="All 2 branches missed.">        for (Map.Entry&lt;Object, Object&gt; e : props.entrySet()) {</span>
<span class="nc" id="L138">            String key = (String) e.getKey();</span>
<span class="nc" id="L139">            String val = (String) e.getValue();</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (key.startsWith(&quot;attribute.&quot;)) {</span>
<span class="nc" id="L141">                e.setValue(Attribute.normalizeLayoutString(val));</span>
            }
<span class="nc" id="L143">        }</span>

        @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
<span class="nc" id="L146">        HashMap&lt;String, String&gt; temp = new HashMap(props);  // shrink to fit</span>
<span class="nc" id="L147">        defaultProps = temp;</span>
<span class="nc" id="L148">    }</span>

<span class="nc" id="L150">    PropMap() {</span>
<span class="nc" id="L151">        theMap.putAll(defaultProps);</span>
<span class="nc" id="L152">    }</span>

    // Return a view of this map which includes only properties
    // that begin with the given prefix.  This is easy because
    // the map is sorted, and has a subMap accessor.
    SortedMap&lt;String, String&gt; prefixMap(String prefix) {
<span class="nc" id="L158">        int len = prefix.length();</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (len == 0)</span>
<span class="nc" id="L160">            return this;</span>
<span class="nc" id="L161">        char nextch = (char)(prefix.charAt(len-1) + 1);</span>
<span class="nc" id="L162">        String limit = prefix.substring(0, len-1)+nextch;</span>
        //System.out.println(prefix+&quot; =&gt; &quot;+subMap(prefix, limit));
<span class="nc" id="L164">        return subMap(prefix, limit);</span>
    }

    String getProperty(String s) {
<span class="nc" id="L168">        return get(s);</span>
    }
    String getProperty(String s, String defaultVal) {
<span class="nc" id="L171">        String val = getProperty(s);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (val == null)</span>
<span class="nc" id="L173">            return defaultVal;</span>
<span class="nc" id="L174">        return val;</span>
    }
    String setProperty(String s, String val) {
<span class="nc" id="L177">        return put(s, val);</span>
    }

    // Get sequence of props for &quot;prefix&quot;, and &quot;prefix.*&quot;.
    List&lt;String&gt; getProperties(String prefix) {
<span class="nc" id="L182">        Collection&lt;String&gt; values = prefixMap(prefix).values();</span>
<span class="nc" id="L183">        List&lt;String&gt; res = new ArrayList&lt;&gt;(values.size());</span>
<span class="nc" id="L184">        res.addAll(values);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        while (res.remove(null));</span>
<span class="nc" id="L186">        return res;</span>
    }

    private boolean toBoolean(String val) {
<span class="nc" id="L190">        return Boolean.valueOf(val).booleanValue();</span>
    }
    boolean getBoolean(String s) {
<span class="nc" id="L193">        return toBoolean(getProperty(s));</span>
    }
    boolean setBoolean(String s, boolean val) {
<span class="nc" id="L196">        return toBoolean(setProperty(s, String.valueOf(val)));</span>
    }
    int toInteger(String val) {
<span class="nc" id="L199">        return toInteger(val, 0);</span>
    }
    int toInteger(String val, int def) {
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (val == null)  return def;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (Pack200.Packer.TRUE.equals(val))   return 1;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (Pack200.Packer.FALSE.equals(val))  return 0;</span>
<span class="nc" id="L205">        return Integer.parseInt(val);</span>
    }
    int getInteger(String s, int def) {
<span class="nc" id="L208">        return toInteger(getProperty(s), def);</span>
    }
    int getInteger(String s) {
<span class="nc" id="L211">        return toInteger(getProperty(s));</span>
    }
    int setInteger(String s, int val) {
<span class="nc" id="L214">        return toInteger(setProperty(s, String.valueOf(val)));</span>
    }

    long toLong(String val) {
        try {
<span class="nc bnc" id="L219" title="All 2 branches missed.">            return val == null ? 0 : Long.parseLong(val);</span>
<span class="nc" id="L220">        } catch (java.lang.NumberFormatException nfe) {</span>
<span class="nc" id="L221">            throw new IllegalArgumentException(&quot;Invalid value&quot;);</span>
        }
    }
    long getLong(String s) {
<span class="nc" id="L225">        return toLong(getProperty(s));</span>
    }
    long setLong(String s, long val) {
<span class="nc" id="L228">        return toLong(setProperty(s, String.valueOf(val)));</span>
    }

    int getTime(String s) {
<span class="nc" id="L232">        String sval = getProperty(s, &quot;0&quot;);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (Utils.NOW.equals(sval)) {</span>
<span class="nc" id="L234">            return (int)((System.currentTimeMillis()+500)/1000);</span>
        }
<span class="nc" id="L236">        long lval = toLong(sval);</span>
        final long recentSecondCount = 1000000000;

<span class="nc bnc" id="L239" title="All 4 branches missed.">        if (lval &lt; recentSecondCount*10 &amp;&amp; !&quot;0&quot;.equals(sval))</span>
<span class="nc" id="L240">            Utils.log.warning(&quot;Supplied modtime appears to be seconds rather than milliseconds: &quot;+sval);</span>

<span class="nc" id="L242">        return (int)((lval+500)/1000);</span>
    }

    void list(PrintStream out) {
<span class="nc" id="L246">        PrintWriter outw = new PrintWriter(out);</span>
<span class="nc" id="L247">        list(outw);</span>
<span class="nc" id="L248">        outw.flush();</span>
<span class="nc" id="L249">    }</span>
    void list(PrintWriter out) {
<span class="nc" id="L251">        out.println(&quot;#&quot;+Utils.PACK_ZIP_ARCHIVE_MARKER_COMMENT+&quot;[&quot;);</span>
<span class="nc" id="L252">        Set&lt;Map.Entry&lt;String, String&gt;&gt; defaults = defaultProps.entrySet();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; e : theMap.entrySet()) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (defaults.contains(e))  continue;</span>
<span class="nc" id="L255">            out.println(&quot;  &quot; + e.getKey() + &quot; = &quot; + e.getValue());</span>
<span class="nc" id="L256">        }</span>
<span class="nc" id="L257">        out.println(&quot;#]&quot;);</span>
<span class="nc" id="L258">    }</span>

    @Override
    public int size() {
<span class="nc" id="L262">        return theMap.size();</span>
    }

    @Override
    public boolean isEmpty() {
<span class="nc" id="L267">        return theMap.isEmpty();</span>
    }

    @Override
    public boolean containsKey(Object key) {
<span class="nc" id="L272">        return theMap.containsKey(key);</span>
    }

    @Override
    public boolean containsValue(Object value) {
<span class="nc" id="L277">        return theMap.containsValue(value);</span>
    }

    @Override
    public String get(Object key) {
<span class="nc" id="L282">        return theMap.get(key);</span>
    }

    @Override
    public String remove(Object key) {
<span class="nc" id="L287">       return theMap.remove(key);</span>
    }

    @Override
    public void putAll(Map&lt;? extends String, ? extends String&gt; m) {
<span class="nc" id="L292">       theMap.putAll(m);</span>
<span class="nc" id="L293">    }</span>

    @Override
    public void clear() {
<span class="nc" id="L297">        theMap.clear();</span>
<span class="nc" id="L298">    }</span>

    @Override
    public Set&lt;String&gt; keySet() {
<span class="nc" id="L302">       return theMap.keySet();</span>
    }

    @Override
    public Collection&lt;String&gt; values() {
<span class="nc" id="L307">       return theMap.values();</span>
    }

    @Override
    public Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet() {
<span class="nc" id="L312">        return theMap.entrySet();</span>
    }

    @Override
    public Comparator&lt;? super String&gt; comparator() {
<span class="nc" id="L317">        return theMap.comparator();</span>
    }

    @Override
    public SortedMap&lt;String, String&gt; subMap(String fromKey, String toKey) {
<span class="nc" id="L322">        return theMap.subMap(fromKey, toKey);</span>
    }

    @Override
    public SortedMap&lt;String, String&gt; headMap(String toKey) {
<span class="nc" id="L327">        return theMap.headMap(toKey);</span>
    }

    @Override
    public SortedMap&lt;String, String&gt; tailMap(String fromKey) {
<span class="nc" id="L332">        return theMap.tailMap(fromKey);</span>
    }

    @Override
    public String firstKey() {
<span class="nc" id="L337">        return theMap.firstKey();</span>
    }

    @Override
    public String lastKey() {
<span class="nc" id="L342">       return theMap.lastKey();</span>
    }

    /**
     * A class that provides access to the java.beans.PropertyChangeListener
     * and java.beans.PropertyChangeEvent without creating a static dependency
     * on java.beans. This class can be removed once the addPropertyChangeListener
     * and removePropertyChangeListener methods are removed from Packer and
     * Unpacker.
     */
<span class="nc" id="L352">    private static class Beans {</span>
<span class="nc" id="L353">        private static final Class&lt;?&gt; propertyChangeListenerClass =</span>
<span class="nc" id="L354">            getClass(&quot;java.beans.PropertyChangeListener&quot;);</span>

<span class="nc" id="L356">        private static final Class&lt;?&gt; propertyChangeEventClass =</span>
<span class="nc" id="L357">            getClass(&quot;java.beans.PropertyChangeEvent&quot;);</span>

<span class="nc" id="L359">        private static final Method propertyChangeMethod =</span>
<span class="nc" id="L360">            getMethod(propertyChangeListenerClass,</span>
                      &quot;propertyChange&quot;,
                      propertyChangeEventClass);

<span class="nc" id="L364">        private static final Constructor&lt;?&gt; propertyEventCtor =</span>
<span class="nc" id="L365">            getConstructor(propertyChangeEventClass,</span>
                           Object.class,
                           String.class,
                           Object.class,
                           Object.class);

        private static Class&lt;?&gt; getClass(String name) {
            try {
<span class="nc" id="L373">                return Class.forName(name, true, Beans.class.getClassLoader());</span>
<span class="nc" id="L374">            } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L375">                return null;</span>
            }
        }
        private static Constructor&lt;?&gt; getConstructor(Class&lt;?&gt; c, Class&lt;?&gt;... types) {
            try {
<span class="nc bnc" id="L380" title="All 2 branches missed.">                return (c == null) ? null : c.getDeclaredConstructor(types);</span>
<span class="nc" id="L381">            } catch (NoSuchMethodException x) {</span>
<span class="nc" id="L382">                throw new AssertionError(x);</span>
            }
        }

        private static Method getMethod(Class&lt;?&gt; c, String name, Class&lt;?&gt;... types) {
            try {
<span class="nc bnc" id="L388" title="All 2 branches missed.">                return (c == null) ? null : c.getMethod(name, types);</span>
<span class="nc" id="L389">            } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L390">                throw new AssertionError(e);</span>
            }
        }

        /**
         * Returns {@code true} if java.beans is present.
         */
        static boolean isBeansPresent() {
<span class="nc bnc" id="L398" title="All 4 branches missed.">            return propertyChangeListenerClass != null &amp;&amp;</span>
                   propertyChangeEventClass != null;
        }

        /**
         * Returns {@code true} if the given object is a PropertyChangeListener
         */
        static boolean isPropertyChangeListener(Object obj) {
<span class="nc bnc" id="L406" title="All 2 branches missed.">            if (propertyChangeListenerClass == null) {</span>
<span class="nc" id="L407">                return false;</span>
            } else {
<span class="nc" id="L409">                return propertyChangeListenerClass.isInstance(obj);</span>
            }
        }

        /**
         * Returns a new PropertyChangeEvent with the given source, property
         * name, old and new values.
         */
        static Object newPropertyChangeEvent(Object source, String prop,
                                             Object oldValue, Object newValue)
        {
            try {
<span class="nc" id="L421">                return propertyEventCtor.newInstance(source, prop, oldValue, newValue);</span>
<span class="nc" id="L422">            } catch (InstantiationException | IllegalAccessException x) {</span>
<span class="nc" id="L423">                throw new AssertionError(x);</span>
<span class="nc" id="L424">            } catch (InvocationTargetException x) {</span>
<span class="nc" id="L425">                Throwable cause = x.getCause();</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">                if (cause instanceof Error)</span>
<span class="nc" id="L427">                    throw (Error)cause;</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                if (cause instanceof RuntimeException)</span>
<span class="nc" id="L429">                    throw (RuntimeException)cause;</span>
<span class="nc" id="L430">                throw new AssertionError(x);</span>
            }
        }

        /**
         * Invokes the given PropertyChangeListener's propertyChange method
         * with the given event.
         */
        static void invokePropertyChange(Object listener, Object ev) {
            try {
<span class="nc" id="L440">                propertyChangeMethod.invoke(listener, ev);</span>
<span class="nc" id="L441">            } catch (IllegalAccessException x) {</span>
<span class="nc" id="L442">                throw new AssertionError(x);</span>
<span class="nc" id="L443">            } catch (InvocationTargetException x) {</span>
<span class="nc" id="L444">                Throwable cause = x.getCause();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">                if (cause instanceof Error)</span>
<span class="nc" id="L446">                    throw (Error)cause;</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                if (cause instanceof RuntimeException)</span>
<span class="nc" id="L448">                    throw (RuntimeException)cause;</span>
<span class="nc" id="L449">                throw new AssertionError(x);</span>
<span class="nc" id="L450">            }</span>
<span class="nc" id="L451">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>