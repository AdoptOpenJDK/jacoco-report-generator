<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>TypeAnnotationParser.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.reflect.annotation</a> &gt; <span class="el_source">TypeAnnotationParser.java</span></div><h1>TypeAnnotationParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.reflect.annotation;

import java.lang.annotation.*;
import java.lang.reflect.*;
import java.nio.ByteBuffer;
import java.nio.BufferUnderflowException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import sun.misc.JavaLangAccess;
import sun.reflect.ConstantPool;
import static sun.reflect.annotation.TypeAnnotation.*;

/**
 * TypeAnnotationParser implements the logic needed to parse
 * TypeAnnotations from an array of bytes.
 */
<span class="nc" id="L46">public final class TypeAnnotationParser {</span>
<span class="fc" id="L47">    private static final TypeAnnotation[] EMPTY_TYPE_ANNOTATION_ARRAY = new TypeAnnotation[0];</span>

    /**
     * Build an AnnotatedType from the parameters supplied.
     *
     * This method and {@code buildAnnotatedTypes} are probably
     * the entry points you are looking for.
     *
     * @param rawAnnotations the byte[] encoding of all type annotations on this declaration
     * @param cp the ConstantPool needed to parse the embedded Annotation
     * @param decl the declaration this type annotation is on
     * @param container the Class this type annotation is on (may be the same as decl)
     * @param type the type the AnnotatedType corresponds to
     * @param filter the type annotation targets included in this AnnotatedType
     */
    public static AnnotatedType buildAnnotatedType(byte[] rawAnnotations,
            ConstantPool cp,
            AnnotatedElement decl,
            Class&lt;?&gt; container,
            Type type,
            TypeAnnotationTarget filter) {
<span class="fc" id="L68">        TypeAnnotation[] tas = parseTypeAnnotations(rawAnnotations,</span>
                                                    cp,
                                                    decl,
                                                    container);
<span class="fc" id="L72">        List&lt;TypeAnnotation&gt; l = new ArrayList&lt;&gt;(tas.length);</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">        for (TypeAnnotation t : tas) {</span>
<span class="fc" id="L74">            TypeAnnotationTargetInfo ti = t.getTargetInfo();</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">            if (ti.getTarget() == filter)</span>
<span class="fc" id="L76">                l.add(t);</span>
        }
<span class="fc" id="L78">        TypeAnnotation[] typeAnnotations = l.toArray(new TypeAnnotation[0]);</span>
<span class="fc" id="L79">        return AnnotatedTypeFactory.buildAnnotatedType(type,</span>
                                                       LocationInfo.BASE_LOCATION,
                                                       typeAnnotations,
                                                       typeAnnotations,
                                                       decl);
    }

    /**
     * Build an array of AnnotatedTypes from the parameters supplied.
     *
     * This method and {@code buildAnnotatedType} are probably
     * the entry points you are looking for.
     *
     * @param rawAnnotations the byte[] encoding of all type annotations on this declaration
     * @param cp the ConstantPool needed to parse the embedded Annotation
     * @param decl the declaration this type annotation is on
     * @param container the Class this type annotation is on (may be the same as decl)
     * @param types the Types the AnnotatedTypes corresponds to
     * @param filter the type annotation targets that included in this AnnotatedType
     */
    public static AnnotatedType[] buildAnnotatedTypes(byte[] rawAnnotations,
            ConstantPool cp,
            AnnotatedElement decl,
            Class&lt;?&gt; container,
            Type[] types,
            TypeAnnotationTarget filter) {
<span class="fc" id="L105">        int size = types.length;</span>
<span class="fc" id="L106">        AnnotatedType[] result = new AnnotatedType[size];</span>
<span class="fc" id="L107">        Arrays.fill(result, AnnotatedTypeFactory.EMPTY_ANNOTATED_TYPE);</span>
        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L109">        ArrayList[] l = new ArrayList[size]; // array of ArrayList&lt;TypeAnnotation&gt;</span>

<span class="fc" id="L111">        TypeAnnotation[] tas = parseTypeAnnotations(rawAnnotations,</span>
                                                    cp,
                                                    decl,
                                                    container);
<span class="fc bfc" id="L115" title="All 2 branches covered.">        for (TypeAnnotation t : tas) {</span>
<span class="fc" id="L116">            TypeAnnotationTargetInfo ti = t.getTargetInfo();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">            if (ti.getTarget() == filter) {</span>
<span class="fc" id="L118">                int pos = ti.getCount();</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">                if (l[pos] == null) {</span>
<span class="fc" id="L120">                    ArrayList&lt;TypeAnnotation&gt; tmp = new ArrayList&lt;&gt;(tas.length);</span>
<span class="fc" id="L121">                    l[pos] = tmp;</span>
                }
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L124">                ArrayList&lt;TypeAnnotation&gt; tmp = l[pos];</span>
<span class="fc" id="L125">                tmp.add(t);</span>
            }
        }
<span class="fc bfc" id="L128" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L130">            ArrayList&lt;TypeAnnotation&gt; list = l[i];</span>
            TypeAnnotation[] typeAnnotations;
<span class="fc bfc" id="L132" title="All 2 branches covered.">            if (list != null) {</span>
<span class="fc" id="L133">                typeAnnotations = list.toArray(new TypeAnnotation[list.size()]);</span>
            } else {
<span class="fc" id="L135">                typeAnnotations = EMPTY_TYPE_ANNOTATION_ARRAY;</span>
            }
<span class="fc" id="L137">            result[i] = AnnotatedTypeFactory.buildAnnotatedType(types[i],</span>
                                                                LocationInfo.BASE_LOCATION,
                                                                typeAnnotations,
                                                                typeAnnotations,
                                                                decl);

        }
<span class="fc" id="L144">        return result;</span>
    }

    // Class helpers

    /**
     * Build an AnnotatedType for the class decl's supertype.
     *
     * @param rawAnnotations the byte[] encoding of all type annotations on this declaration
     * @param cp the ConstantPool needed to parse the embedded Annotation
     * @param decl the Class which annotated supertype is being built
     */
    public static AnnotatedType buildAnnotatedSuperclass(byte[] rawAnnotations,
            ConstantPool cp,
            Class&lt;?&gt; decl) {
<span class="fc" id="L159">        Type supertype = decl.getGenericSuperclass();</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (supertype == null)</span>
<span class="nc" id="L161">            return AnnotatedTypeFactory.EMPTY_ANNOTATED_TYPE;</span>
<span class="fc" id="L162">        return buildAnnotatedType(rawAnnotations,</span>
                                  cp,
                                  decl,
                                  decl,
                                  supertype,
                                  TypeAnnotationTarget.CLASS_EXTENDS);
    }

    /**
     * Build an array of AnnotatedTypes for the class decl's implemented
     * interfaces.
     *
     * @param rawAnnotations the byte[] encoding of all type annotations on this declaration
     * @param cp the ConstantPool needed to parse the embedded Annotation
     * @param decl the Class whose annotated implemented interfaces is being built
     */
    public static AnnotatedType[] buildAnnotatedInterfaces(byte[] rawAnnotations,
            ConstantPool cp,
            Class&lt;?&gt; decl) {
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (decl == Object.class ||</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">                decl.isArray() ||</span>
<span class="pc bpc" id="L183" title="2 of 4 branches missed.">                decl.isPrimitive() ||</span>
                decl == Void.TYPE)
<span class="nc" id="L185">            return AnnotatedTypeFactory.EMPTY_ANNOTATED_TYPE_ARRAY;</span>
<span class="fc" id="L186">        return buildAnnotatedTypes(rawAnnotations,</span>
                                   cp,
                                   decl,
                                   decl,
<span class="fc" id="L190">                                   decl.getGenericInterfaces(),</span>
                                   TypeAnnotationTarget.CLASS_IMPLEMENTS);
    }

    // TypeVariable helpers

    /**
     * Parse regular annotations on a TypeVariable declared on genericDecl.
     *
     * Regular Annotations on TypeVariables are stored in the type
     * annotation byte[] in the class file.
     *
     * @param genericsDecl the declaration declaring the type variable
     * @param typeVarIndex the 0-based index of this type variable in the declaration
     */
    public static &lt;D extends GenericDeclaration&gt; Annotation[] parseTypeVariableAnnotations(D genericDecl,
            int typeVarIndex) {
        AnnotatedElement decl;
        TypeAnnotationTarget predicate;
<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (genericDecl instanceof Class) {</span>
<span class="fc" id="L210">            decl = (Class&lt;?&gt;)genericDecl;</span>
<span class="fc" id="L211">            predicate = TypeAnnotationTarget.CLASS_TYPE_PARAMETER;</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        } else if (genericDecl instanceof Executable) {</span>
<span class="fc" id="L213">            decl = (Executable)genericDecl;</span>
<span class="fc" id="L214">            predicate = TypeAnnotationTarget.METHOD_TYPE_PARAMETER;</span>
        } else {
<span class="nc" id="L216">            throw new AssertionError(&quot;Unknown GenericDeclaration &quot; + genericDecl + &quot;\nthis should not happen.&quot;);</span>
        }
<span class="fc" id="L218">        List&lt;TypeAnnotation&gt; typeVarAnnos = TypeAnnotation.filter(parseAllTypeAnnotations(decl),</span>
                                                                  predicate);
<span class="fc" id="L220">        List&lt;Annotation&gt; res = new ArrayList&lt;&gt;(typeVarAnnos.size());</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        for (TypeAnnotation t : typeVarAnnos)</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            if (t.getTargetInfo().getCount() == typeVarIndex)</span>
<span class="fc" id="L223">                res.add(t.getAnnotation());</span>
<span class="fc" id="L224">        return res.toArray(new Annotation[0]);</span>
    }

    /**
     * Build an array of AnnotatedTypes for the declaration decl's bounds.
     *
     * @param bounds the bounds corresponding to the annotated bounds
     * @param decl the declaration whose annotated bounds is being built
     * @param typeVarIndex the index of this type variable on the decl
     */
    public static &lt;D extends GenericDeclaration&gt; AnnotatedType[] parseAnnotatedBounds(Type[] bounds,
            D decl,
            int typeVarIndex) {
<span class="fc" id="L237">        return parseAnnotatedBounds(bounds, decl, typeVarIndex, LocationInfo.BASE_LOCATION);</span>
    }
    //helper for above
    private static &lt;D extends GenericDeclaration&gt; AnnotatedType[] parseAnnotatedBounds(Type[] bounds,
            D decl,
            int typeVarIndex,
            LocationInfo loc) {
<span class="fc" id="L244">        List&lt;TypeAnnotation&gt; candidates = fetchBounds(decl);</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (bounds != null) {</span>
<span class="fc" id="L246">            int startIndex = 0;</span>
<span class="fc" id="L247">            AnnotatedType[] res = new AnnotatedType[bounds.length];</span>
<span class="fc" id="L248">            Arrays.fill(res, AnnotatedTypeFactory.EMPTY_ANNOTATED_TYPE);</span>

            // Adjust bounds index
            //
            // Figure out if the type annotations for this bound starts with 0
            // or 1. The spec says within a bound the 0:th type annotation will
            // always be on an bound of a Class type (not Interface type). So
            // if the programmer starts with an Interface type for the first
            // (and following) bound(s) the implicit Object bound is considered
            // the first (that is 0:th) bound and type annotations start on
            // index 1.
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">            if (bounds.length &gt; 0) {</span>
<span class="fc" id="L260">                Type b0 = bounds[0];</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">                if (!(b0 instanceof Class&lt;?&gt;)) {</span>
<span class="nc" id="L262">                    startIndex = 1;</span>
                } else {
<span class="fc" id="L264">                    Class&lt;?&gt; c = (Class&lt;?&gt;)b0;</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">                    if (c.isInterface()) {</span>
<span class="fc" id="L266">                        startIndex = 1;</span>
                    }
                }
            }

<span class="fc bfc" id="L271" title="All 2 branches covered.">            for (int i = 0; i &lt; bounds.length; i++) {</span>
<span class="fc" id="L272">                List&lt;TypeAnnotation&gt; l = new ArrayList&lt;&gt;(candidates.size());</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">                for (TypeAnnotation t : candidates) {</span>
<span class="fc" id="L274">                    TypeAnnotationTargetInfo tInfo = t.getTargetInfo();</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">                    if (tInfo.getSecondaryIndex() == i + startIndex &amp;&amp;</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">                            tInfo.getCount() == typeVarIndex) {</span>
<span class="fc" id="L277">                        l.add(t);</span>
                    }
<span class="fc" id="L279">                    res[i] = AnnotatedTypeFactory.buildAnnotatedType(bounds[i],</span>
                                                                     loc,
<span class="fc" id="L281">                                                                     l.toArray(new TypeAnnotation[0]),</span>
<span class="fc" id="L282">                                                                     candidates.toArray(new TypeAnnotation[0]),</span>
                                                                     (AnnotatedElement)decl);
<span class="fc" id="L284">                }</span>
            }
<span class="fc" id="L286">            return res;</span>
        }
<span class="nc" id="L288">        return new AnnotatedType[0];</span>
    }
    private static &lt;D extends GenericDeclaration&gt; List&lt;TypeAnnotation&gt; fetchBounds(D decl) {
        AnnotatedElement boundsDecl;
        TypeAnnotationTarget target;
<span class="fc bfc" id="L293" title="All 2 branches covered.">        if (decl instanceof Class) {</span>
<span class="fc" id="L294">            target = TypeAnnotationTarget.CLASS_TYPE_PARAMETER_BOUND;</span>
<span class="fc" id="L295">            boundsDecl = (Class)decl;</span>
        } else {
<span class="fc" id="L297">            target = TypeAnnotationTarget.METHOD_TYPE_PARAMETER_BOUND;</span>
<span class="fc" id="L298">            boundsDecl = (Executable)decl;</span>
        }
<span class="fc" id="L300">        return TypeAnnotation.filter(TypeAnnotationParser.parseAllTypeAnnotations(boundsDecl), target);</span>
    }

    /*
     * Parse all type annotations on the declaration supplied. This is needed
     * when you go from for example an annotated return type on a method that
     * is a type variable declared on the class. In this case you need to
     * 'jump' to the decl of the class and parse all type annotations there to
     * find the ones that are applicable to the type variable.
     */
    static TypeAnnotation[] parseAllTypeAnnotations(AnnotatedElement decl) {
        Class&lt;?&gt; container;
        byte[] rawBytes;
<span class="fc" id="L313">        JavaLangAccess javaLangAccess = sun.misc.SharedSecrets.getJavaLangAccess();</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (decl instanceof Class) {</span>
<span class="fc" id="L315">            container = (Class&lt;?&gt;)decl;</span>
<span class="fc" id="L316">            rawBytes = javaLangAccess.getRawClassTypeAnnotations(container);</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        } else if (decl instanceof Executable) {</span>
<span class="fc" id="L318">            container = ((Executable)decl).getDeclaringClass();</span>
<span class="fc" id="L319">            rawBytes = javaLangAccess.getRawExecutableTypeAnnotations((Executable)decl);</span>
        } else {
            // Should not reach here. Assert?
<span class="nc" id="L322">            return EMPTY_TYPE_ANNOTATION_ARRAY;</span>
        }
<span class="fc" id="L324">        return parseTypeAnnotations(rawBytes, javaLangAccess.getConstantPool(container),</span>
                                    decl, container);
    }

    /* Parse type annotations encoded as an array of bytes */
    private static TypeAnnotation[] parseTypeAnnotations(byte[] rawAnnotations,
            ConstantPool cp,
            AnnotatedElement baseDecl,
            Class&lt;?&gt; container) {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (rawAnnotations == null)</span>
<span class="fc" id="L334">            return EMPTY_TYPE_ANNOTATION_ARRAY;</span>

<span class="fc" id="L336">        ByteBuffer buf = ByteBuffer.wrap(rawAnnotations);</span>
<span class="fc" id="L337">        int annotationCount = buf.getShort() &amp; 0xFFFF;</span>
<span class="fc" id="L338">        List&lt;TypeAnnotation&gt; typeAnnotations = new ArrayList&lt;&gt;(annotationCount);</span>

        // Parse each TypeAnnotation
<span class="fc bfc" id="L341" title="All 2 branches covered.">        for (int i = 0; i &lt; annotationCount; i++) {</span>
<span class="fc" id="L342">             TypeAnnotation ta = parseTypeAnnotation(buf, cp, baseDecl, container);</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">             if (ta != null)</span>
<span class="fc" id="L344">                 typeAnnotations.add(ta);</span>
        }

<span class="fc" id="L347">        return typeAnnotations.toArray(EMPTY_TYPE_ANNOTATION_ARRAY);</span>
    }


    // Helper
    static Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; mapTypeAnnotations(TypeAnnotation[] typeAnnos) {
<span class="fc" id="L353">        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; result =</span>
            new LinkedHashMap&lt;&gt;();
<span class="fc bfc" id="L355" title="All 2 branches covered.">        for (TypeAnnotation t : typeAnnos) {</span>
<span class="fc" id="L356">            Annotation a = t.getAnnotation();</span>
<span class="fc" id="L357">            Class&lt;? extends Annotation&gt; klass = a.annotationType();</span>
<span class="fc" id="L358">            AnnotationType type = AnnotationType.getInstance(klass);</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">            if (type.retention() == RetentionPolicy.RUNTIME)</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">                if (result.put(klass, a) != null)</span>
<span class="nc" id="L361">                    throw new AnnotationFormatError(&quot;Duplicate annotation for class: &quot;+klass+&quot;: &quot; + a);</span>
        }
<span class="fc" id="L363">        return result;</span>
    }

    // Position codes
    // Regular type parameter annotations
    private static final byte CLASS_TYPE_PARAMETER = 0x00;
    private static final byte METHOD_TYPE_PARAMETER = 0x01;
    // Type Annotations outside method bodies
    private static final byte CLASS_EXTENDS = 0x10;
    private static final byte CLASS_TYPE_PARAMETER_BOUND = 0x11;
    private static final byte METHOD_TYPE_PARAMETER_BOUND = 0x12;
    private static final byte FIELD = 0x13;
    private static final byte METHOD_RETURN = 0x14;
    private static final byte METHOD_RECEIVER = 0x15;
    private static final byte METHOD_FORMAL_PARAMETER = 0x16;
    private static final byte THROWS = 0x17;
    // Type Annotations inside method bodies
    private static final byte LOCAL_VARIABLE = (byte)0x40;
    private static final byte RESOURCE_VARIABLE = (byte)0x41;
    private static final byte EXCEPTION_PARAMETER = (byte)0x42;
    private static final byte INSTANCEOF = (byte)0x43;
    private static final byte NEW = (byte)0x44;
    private static final byte CONSTRUCTOR_REFERENCE = (byte)0x45;
    private static final byte METHOD_REFERENCE = (byte)0x46;
    private static final byte CAST = (byte)0x47;
    private static final byte CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT = (byte)0x48;
    private static final byte METHOD_INVOCATION_TYPE_ARGUMENT = (byte)0x49;
    private static final byte CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT = (byte)0x4A;
    private static final byte METHOD_REFERENCE_TYPE_ARGUMENT = (byte)0x4B;

    private static TypeAnnotation parseTypeAnnotation(ByteBuffer buf,
            ConstantPool cp,
            AnnotatedElement baseDecl,
            Class&lt;?&gt; container) {
<span class="fc" id="L397">        TypeAnnotationTargetInfo ti = parseTargetInfo(buf);</span>
<span class="fc" id="L398">        LocationInfo locationInfo = LocationInfo.parseLocationInfo(buf);</span>
<span class="fc" id="L399">        Annotation a = AnnotationParser.parseAnnotation(buf, cp, container, false);</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        if (ti == null) // Inside a method for example</span>
<span class="nc" id="L401">            return null;</span>
<span class="fc" id="L402">        return new TypeAnnotation(ti, locationInfo, a, baseDecl);</span>
    }

    private static TypeAnnotationTargetInfo parseTargetInfo(ByteBuffer buf) {
<span class="fc" id="L406">        byte posCode = buf.get();</span>
<span class="pc bpc" id="L407" title="6 of 14 branches missed.">        switch(posCode) {</span>
        case CLASS_TYPE_PARAMETER:
        case METHOD_TYPE_PARAMETER: {
<span class="fc" id="L410">            byte index = buf.get();</span>
            TypeAnnotationTargetInfo res;
<span class="fc bfc" id="L412" title="All 2 branches covered.">            if (posCode == CLASS_TYPE_PARAMETER)</span>
<span class="fc" id="L413">                res = new TypeAnnotationTargetInfo(TypeAnnotationTarget.CLASS_TYPE_PARAMETER,</span>
                        index);
            else
<span class="fc" id="L416">                res = new TypeAnnotationTargetInfo(TypeAnnotationTarget.METHOD_TYPE_PARAMETER,</span>
                        index);
<span class="fc" id="L418">            return res;</span>
            } // unreachable break;
        case CLASS_EXTENDS: {
<span class="fc" id="L421">            short index = buf.getShort();</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">            if (index == -1) {</span>
<span class="fc" id="L423">                return new TypeAnnotationTargetInfo(TypeAnnotationTarget.CLASS_EXTENDS);</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">            } else if (index &gt;= 0) {</span>
<span class="fc" id="L425">                TypeAnnotationTargetInfo res = new TypeAnnotationTargetInfo(TypeAnnotationTarget.CLASS_IMPLEMENTS,</span>
                        index);
<span class="fc" id="L427">                return res;</span>
<span class="nc" id="L428">            }} break;</span>
        case CLASS_TYPE_PARAMETER_BOUND:
<span class="fc" id="L430">            return parse2ByteTarget(TypeAnnotationTarget.CLASS_TYPE_PARAMETER_BOUND, buf);</span>
        case METHOD_TYPE_PARAMETER_BOUND:
<span class="fc" id="L432">            return parse2ByteTarget(TypeAnnotationTarget.METHOD_TYPE_PARAMETER_BOUND, buf);</span>
        case FIELD:
<span class="fc" id="L434">            return new TypeAnnotationTargetInfo(TypeAnnotationTarget.FIELD);</span>
        case METHOD_RETURN:
<span class="fc" id="L436">            return new TypeAnnotationTargetInfo(TypeAnnotationTarget.METHOD_RETURN);</span>
        case METHOD_RECEIVER:
<span class="nc" id="L438">            return new TypeAnnotationTargetInfo(TypeAnnotationTarget.METHOD_RECEIVER);</span>
        case METHOD_FORMAL_PARAMETER: {
<span class="fc" id="L440">            byte index = buf.get();</span>
<span class="fc" id="L441">            return new TypeAnnotationTargetInfo(TypeAnnotationTarget.METHOD_FORMAL_PARAMETER,</span>
                    index);
            } //unreachable break;
        case THROWS:
<span class="fc" id="L445">            return parseShortTarget(TypeAnnotationTarget.THROWS, buf);</span>

        /*
         * The ones below are inside method bodies, we don't care about them for core reflection
         * other than adjusting for them in the byte stream.
         */
        case LOCAL_VARIABLE:
        case RESOURCE_VARIABLE:
<span class="nc" id="L453">            short length = buf.getShort();</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">            for (int i = 0; i &lt; length; ++i) {</span>
<span class="nc" id="L455">                short offset = buf.getShort();</span>
<span class="nc" id="L456">                short varLength = buf.getShort();</span>
<span class="nc" id="L457">                short index = buf.getShort();</span>
            }
<span class="nc" id="L459">            return null;</span>
        case EXCEPTION_PARAMETER: {
<span class="nc" id="L461">            byte index = buf.get();</span>
            }
<span class="nc" id="L463">            return null;</span>
        case INSTANCEOF:
        case NEW:
        case CONSTRUCTOR_REFERENCE:
        case METHOD_REFERENCE: {
<span class="nc" id="L468">            short offset = buf.getShort();</span>
            }
<span class="nc" id="L470">            return null;</span>
        case CAST:
        case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
        case METHOD_INVOCATION_TYPE_ARGUMENT:
        case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
        case METHOD_REFERENCE_TYPE_ARGUMENT: {
<span class="nc" id="L476">            short offset = buf.getShort();</span>
<span class="nc" id="L477">            byte index = buf.get();</span>
            }
<span class="nc" id="L479">            return null;</span>

        default:
            // will throw error below
            break;
        }
<span class="nc" id="L485">        throw new AnnotationFormatError(&quot;Could not parse bytes for type annotations&quot;);</span>
    }

    private static TypeAnnotationTargetInfo parseShortTarget(TypeAnnotationTarget target, ByteBuffer buf) {
<span class="fc" id="L489">        short index = buf.getShort();</span>
<span class="fc" id="L490">        return new TypeAnnotationTargetInfo(target, index);</span>
    }
    private static TypeAnnotationTargetInfo parse2ByteTarget(TypeAnnotationTarget target, ByteBuffer buf) {
<span class="fc" id="L493">        byte count = buf.get();</span>
<span class="fc" id="L494">        byte secondaryIndex = buf.get();</span>
<span class="fc" id="L495">        return new TypeAnnotationTargetInfo(target,</span>
                                            count,
                                            secondaryIndex);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>