<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AnnotationInvocationHandler.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.reflect.annotation</a> &gt; <span class="el_source">AnnotationInvocationHandler.java</span></div><h1>AnnotationInvocationHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.reflect.annotation;

import java.lang.annotation.*;
import java.lang.reflect.*;
import java.io.Serializable;
import java.util.*;
import java.lang.annotation.*;
import java.security.AccessController;
import java.security.PrivilegedAction;

/**
 * InvocationHandler for dynamic proxy implementation of Annotation.
 *
 * @author  Josh Bloch
 * @since   1.5
 */
<span class="fc bfc" id="L42" title="All 2 branches covered.">class AnnotationInvocationHandler implements InvocationHandler, Serializable {</span>
    private static final long serialVersionUID = 6182022883658399397L;
    private final Class&lt;? extends Annotation&gt; type;
    private final Map&lt;String, Object&gt; memberValues;

<span class="fc" id="L47">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) {</span>
<span class="fc" id="L48">        this.type = type;</span>
<span class="fc" id="L49">        this.memberValues = memberValues;</span>
<span class="fc" id="L50">    }</span>

    public Object invoke(Object proxy, Method method, Object[] args) {
<span class="fc" id="L53">        String member = method.getName();</span>
<span class="fc" id="L54">        Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span>

        // Handle Object and Annotation methods
<span class="pc bpc" id="L57" title="2 of 6 branches missed.">        if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp;</span>
            paramTypes[0] == Object.class)
<span class="fc" id="L59">            return equalsImpl(args[0]);</span>
<span class="pc bpc" id="L60" title="1 of 4 branches missed.">        assert paramTypes.length == 0;</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">        if (member.equals(&quot;toString&quot;))</span>
<span class="fc" id="L62">            return toStringImpl();</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">        if (member.equals(&quot;hashCode&quot;))</span>
<span class="fc" id="L64">            return hashCodeImpl();</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">        if (member.equals(&quot;annotationType&quot;))</span>
<span class="fc" id="L66">            return type;</span>

        // Handle annotation member accessors
<span class="fc" id="L69">        Object result = memberValues.get(member);</span>

<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        if (result == null)</span>
<span class="nc" id="L72">            throw new IncompleteAnnotationException(type, member);</span>

<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        if (result instanceof ExceptionProxy)</span>
<span class="nc" id="L75">            throw ((ExceptionProxy) result).generateException();</span>

<span class="fc bfc" id="L77" title="All 4 branches covered.">        if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0)</span>
<span class="fc" id="L78">            result = cloneArray(result);</span>

<span class="fc" id="L80">        return result;</span>
    }

    /**
     * This method, which clones its array argument, would not be necessary
     * if Cloneable had a public clone method.
     */
    private Object cloneArray(Object array) {
<span class="fc" id="L88">        Class&lt;?&gt; type = array.getClass();</span>

<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (type == byte[].class) {</span>
<span class="nc" id="L91">            byte[] byteArray = (byte[])array;</span>
<span class="nc" id="L92">            return byteArray.clone();</span>
        }
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (type == char[].class) {</span>
<span class="nc" id="L95">            char[] charArray = (char[])array;</span>
<span class="nc" id="L96">            return charArray.clone();</span>
        }
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        if (type == double[].class) {</span>
<span class="nc" id="L99">            double[] doubleArray = (double[])array;</span>
<span class="nc" id="L100">            return doubleArray.clone();</span>
        }
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if (type == float[].class) {</span>
<span class="nc" id="L103">            float[] floatArray = (float[])array;</span>
<span class="nc" id="L104">            return floatArray.clone();</span>
        }
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if (type == int[].class) {</span>
<span class="nc" id="L107">            int[] intArray = (int[])array;</span>
<span class="nc" id="L108">            return intArray.clone();</span>
        }
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        if (type == long[].class) {</span>
<span class="nc" id="L111">            long[] longArray = (long[])array;</span>
<span class="nc" id="L112">            return longArray.clone();</span>
        }
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (type == short[].class) {</span>
<span class="nc" id="L115">            short[] shortArray = (short[])array;</span>
<span class="nc" id="L116">            return shortArray.clone();</span>
        }
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (type == boolean[].class) {</span>
<span class="nc" id="L119">            boolean[] booleanArray = (boolean[])array;</span>
<span class="nc" id="L120">            return booleanArray.clone();</span>
        }

<span class="fc" id="L123">        Object[] objectArray = (Object[])array;</span>
<span class="fc" id="L124">        return objectArray.clone();</span>
    }


    /**
     * Implementation of dynamicProxy.toString()
     */
    private String toStringImpl() {
<span class="fc" id="L132">        StringBuffer result = new StringBuffer(128);</span>
<span class="fc" id="L133">        result.append('@');</span>
<span class="fc" id="L134">        result.append(type.getName());</span>
<span class="fc" id="L135">        result.append('(');</span>
<span class="fc" id="L136">        boolean firstMember = true;</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">        for (Map.Entry&lt;String, Object&gt; e : memberValues.entrySet()) {</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            if (firstMember)</span>
<span class="fc" id="L139">                firstMember = false;</span>
            else
<span class="nc" id="L141">                result.append(&quot;, &quot;);</span>

<span class="fc" id="L143">            result.append(e.getKey());</span>
<span class="fc" id="L144">            result.append('=');</span>
<span class="fc" id="L145">            result.append(memberValueToString(e.getValue()));</span>
<span class="fc" id="L146">        }</span>
<span class="fc" id="L147">        result.append(')');</span>
<span class="fc" id="L148">        return result.toString();</span>
    }

    /**
     * Translates a member value (in &quot;dynamic proxy return form&quot;) into a string
     */
    private static String memberValueToString(Object value) {
<span class="fc" id="L155">        Class&lt;?&gt; type = value.getClass();</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (!type.isArray())    // primitive, string, class, enum const,</span>
                                // or annotation
<span class="fc" id="L158">            return value.toString();</span>

<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (type == byte[].class)</span>
<span class="nc" id="L161">            return Arrays.toString((byte[]) value);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (type == char[].class)</span>
<span class="nc" id="L163">            return Arrays.toString((char[]) value);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (type == double[].class)</span>
<span class="nc" id="L165">            return Arrays.toString((double[]) value);</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (type == float[].class)</span>
<span class="nc" id="L167">            return Arrays.toString((float[]) value);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (type == int[].class)</span>
<span class="nc" id="L169">            return Arrays.toString((int[]) value);</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (type == long[].class)</span>
<span class="nc" id="L171">            return Arrays.toString((long[]) value);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (type == short[].class)</span>
<span class="nc" id="L173">            return Arrays.toString((short[]) value);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (type == boolean[].class)</span>
<span class="nc" id="L175">            return Arrays.toString((boolean[]) value);</span>
<span class="nc" id="L176">        return Arrays.toString((Object[]) value);</span>
    }

    /**
     * Implementation of dynamicProxy.equals(Object o)
     */
    private Boolean equalsImpl(Object o) {
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (o == this)</span>
<span class="nc" id="L184">            return true;</span>

<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (!type.isInstance(o))</span>
<span class="nc" id="L187">            return false;</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        for (Method memberMethod : getMemberMethods()) {</span>
<span class="fc" id="L189">            String member = memberMethod.getName();</span>
<span class="fc" id="L190">            Object ourValue = memberValues.get(member);</span>
<span class="fc" id="L191">            Object hisValue = null;</span>
<span class="fc" id="L192">            AnnotationInvocationHandler hisHandler = asOneOfUs(o);</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">            if (hisHandler != null) {</span>
<span class="fc" id="L194">                hisValue = hisHandler.memberValues.get(member);</span>
            } else {
                try {
<span class="nc" id="L197">                    hisValue = memberMethod.invoke(o);</span>
<span class="nc" id="L198">                } catch (InvocationTargetException e) {</span>
<span class="nc" id="L199">                    return false;</span>
<span class="nc" id="L200">                } catch (IllegalAccessException e) {</span>
<span class="nc" id="L201">                    throw new AssertionError(e);</span>
<span class="nc" id="L202">                }</span>
            }
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if (!memberValueEquals(ourValue, hisValue))</span>
<span class="fc" id="L205">                return false;</span>
        }
<span class="fc" id="L207">        return true;</span>
    }

    /**
     * Returns an object's invocation handler if that object is a dynamic
     * proxy with a handler of type AnnotationInvocationHandler.
     * Returns null otherwise.
     */
    private AnnotationInvocationHandler asOneOfUs(Object o) {
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (Proxy.isProxyClass(o.getClass())) {</span>
<span class="fc" id="L217">            InvocationHandler handler = Proxy.getInvocationHandler(o);</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            if (handler instanceof AnnotationInvocationHandler)</span>
<span class="fc" id="L219">                return (AnnotationInvocationHandler) handler;</span>
        }
<span class="nc" id="L221">        return null;</span>
    }

    /**
     * Returns true iff the two member values in &quot;dynamic proxy return form&quot;
     * are equal using the appropriate equality function depending on the
     * member type.  The two values will be of the same type unless one of
     * the containing annotations is ill-formed.  If one of the containing
     * annotations is ill-formed, this method will return false unless the
     * two members are identical object references.
     */
    private static boolean memberValueEquals(Object v1, Object v2) {
<span class="fc" id="L233">        Class&lt;?&gt; type = v1.getClass();</span>

        // Check for primitive, string, class, enum const, annotation,
        // or ExceptionProxy
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (!type.isArray())</span>
<span class="fc" id="L238">            return v1.equals(v2);</span>

        // Check for array of string, class, enum const, annotation,
        // or ExceptionProxy
<span class="pc bpc" id="L242" title="1 of 4 branches missed.">        if (v1 instanceof Object[] &amp;&amp; v2 instanceof Object[])</span>
<span class="fc" id="L243">            return Arrays.equals((Object[]) v1, (Object[]) v2);</span>

        // Check for ill formed annotation(s)
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        if (v2.getClass() != type)</span>
<span class="nc" id="L247">            return false;</span>

        // Deal with array of primitives
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (type == byte[].class)</span>
<span class="nc" id="L251">            return Arrays.equals((byte[]) v1, (byte[]) v2);</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (type == char[].class)</span>
<span class="nc" id="L253">            return Arrays.equals((char[]) v1, (char[]) v2);</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (type == double[].class)</span>
<span class="nc" id="L255">            return Arrays.equals((double[]) v1, (double[]) v2);</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if (type == float[].class)</span>
<span class="nc" id="L257">            return Arrays.equals((float[]) v1, (float[]) v2);</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (type == int[].class)</span>
<span class="fc" id="L259">            return Arrays.equals((int[]) v1, (int[]) v2);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (type == long[].class)</span>
<span class="nc" id="L261">            return Arrays.equals((long[]) v1, (long[]) v2);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (type == short[].class)</span>
<span class="nc" id="L263">            return Arrays.equals((short[]) v1, (short[]) v2);</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">        assert type == boolean[].class;</span>
<span class="nc" id="L265">        return Arrays.equals((boolean[]) v1, (boolean[]) v2);</span>
    }

    /**
     * Returns the member methods for our annotation type.  These are
     * obtained lazily and cached, as they're expensive to obtain
     * and we only need them if our equals method is invoked (which should
     * be rare).
     */
    private Method[] getMemberMethods() {
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (memberMethods == null) {</span>
<span class="fc" id="L276">            memberMethods = AccessController.doPrivileged(</span>
<span class="fc" id="L277">                new PrivilegedAction&lt;Method[]&gt;() {</span>
                    public Method[] run() {
<span class="fc" id="L279">                        final Method[] mm = type.getDeclaredMethods();</span>
<span class="fc" id="L280">                        AccessibleObject.setAccessible(mm, true);</span>
<span class="fc" id="L281">                        return mm;</span>
                    }
                });
        }
<span class="fc" id="L285">        return memberMethods;</span>
    }
<span class="fc" id="L287">    private transient volatile Method[] memberMethods = null;</span>

    /**
     * Implementation of dynamicProxy.hashCode()
     */
    private int hashCodeImpl() {
<span class="fc" id="L293">        int result = 0;</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">        for (Map.Entry&lt;String, Object&gt; e : memberValues.entrySet()) {</span>
<span class="fc" id="L295">            result += (127 * e.getKey().hashCode()) ^</span>
<span class="fc" id="L296">                memberValueHashCode(e.getValue());</span>
<span class="fc" id="L297">        }</span>
<span class="fc" id="L298">        return result;</span>
    }

    /**
     * Computes hashCode of a member value (in &quot;dynamic proxy return form&quot;)
     */
    private static int memberValueHashCode(Object value) {
<span class="fc" id="L305">        Class&lt;?&gt; type = value.getClass();</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (!type.isArray())    // primitive, string, class, enum const,</span>
                                // or annotation
<span class="fc" id="L308">            return value.hashCode();</span>

<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (type == byte[].class)</span>
<span class="nc" id="L311">            return Arrays.hashCode((byte[]) value);</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (type == char[].class)</span>
<span class="nc" id="L313">            return Arrays.hashCode((char[]) value);</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        if (type == double[].class)</span>
<span class="nc" id="L315">            return Arrays.hashCode((double[]) value);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (type == float[].class)</span>
<span class="nc" id="L317">            return Arrays.hashCode((float[]) value);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">        if (type == int[].class)</span>
<span class="fc" id="L319">            return Arrays.hashCode((int[]) value);</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        if (type == long[].class)</span>
<span class="nc" id="L321">            return Arrays.hashCode((long[]) value);</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        if (type == short[].class)</span>
<span class="nc" id="L323">            return Arrays.hashCode((short[]) value);</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (type == boolean[].class)</span>
<span class="nc" id="L325">            return Arrays.hashCode((boolean[]) value);</span>
<span class="fc" id="L326">        return Arrays.hashCode((Object[]) value);</span>
    }

    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
<span class="nc" id="L331">        s.defaultReadObject();</span>


        // Check to make sure that types have not evolved incompatibly

<span class="nc" id="L336">        AnnotationType annotationType = null;</span>
        try {
<span class="nc" id="L338">            annotationType = AnnotationType.getInstance(type);</span>
<span class="nc" id="L339">        } catch(IllegalArgumentException e) {</span>
            // Class is no longer an annotation type; time to punch out
<span class="nc" id="L341">            throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span>
<span class="nc" id="L342">        }</span>

<span class="nc" id="L344">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span>


        // If there are annotation members without values, that
        // situation is handled by the invoke method.
<span class="nc bnc" id="L349" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) {</span>
<span class="nc" id="L350">            String name = memberValue.getKey();</span>
<span class="nc" id="L351">            Class&lt;?&gt; memberType = memberTypes.get(name);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            if (memberType != null) {  // i.e. member still exists</span>
<span class="nc" id="L353">                Object value = memberValue.getValue();</span>
<span class="nc bnc" id="L354" title="All 4 branches missed.">                if (!(memberType.isInstance(value) ||</span>
                      value instanceof ExceptionProxy)) {
<span class="nc" id="L356">                    memberValue.setValue(</span>
                        new AnnotationTypeMismatchExceptionProxy(
<span class="nc" id="L358">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span>
<span class="nc" id="L359">                                annotationType.members().get(name)));</span>
                }
            }
<span class="nc" id="L362">        }</span>
<span class="nc" id="L363">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>