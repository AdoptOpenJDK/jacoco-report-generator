<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AnnotationParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.reflect.annotation</a> &gt; <span class="el_source">AnnotationParser.java</span></div><h1>AnnotationParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.reflect.annotation;

import java.lang.annotation.*;
import java.util.*;
import java.nio.ByteBuffer;
import java.nio.BufferUnderflowException;
import java.lang.reflect.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import sun.reflect.ConstantPool;

import sun.reflect.generics.parser.SignatureParser;
import sun.reflect.generics.tree.TypeSignature;
import sun.reflect.generics.factory.GenericsFactory;
import sun.reflect.generics.factory.CoreReflectionFactory;
import sun.reflect.generics.visitor.Reifier;
import sun.reflect.generics.scope.ClassScope;

/**
 * Parser for Java programming language annotations.  Translates
 * annotation byte streams emitted by compiler into annotation objects.
 *
 * @author  Josh Bloch
 * @since   1.5
 */
<span class="pc bfc" id="L51" title="All 2 branches covered.">public class AnnotationParser {</span>
    /**
     * Parses the annotations described by the specified byte array.
     * resolving constant references in the specified constant pool.
     * The array must contain an array of annotations as described
     * in the RuntimeVisibleAnnotations_attribute:
     *
     *   u2 num_annotations;
     *   annotation annotations[num_annotations];
     *
     * @throws AnnotationFormatError if an annotation is found to be
     *         malformed.
     */
    public static Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; parseAnnotations(
                byte[] rawAnnotations,
                ConstantPool constPool,
                Class&lt;?&gt; container) {
<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (rawAnnotations == null)</span>
<span class="fc" id="L69">            return Collections.emptyMap();</span>

        try {
<span class="fc" id="L72">            return parseAnnotations2(rawAnnotations, constPool, container, null);</span>
<span class="nc" id="L73">        } catch(BufferUnderflowException e) {</span>
<span class="nc" id="L74">            throw new AnnotationFormatError(&quot;Unexpected end of annotations.&quot;);</span>
<span class="nc" id="L75">        } catch(IllegalArgumentException e) {</span>
            // Type mismatch in constant pool
<span class="nc" id="L77">            throw new AnnotationFormatError(e);</span>
        }
    }

    /**
     * Like {@link #parseAnnotations(byte[], sun.reflect.ConstantPool, Class)}
     * with an additional parameter {@code selectAnnotationClasses} which selects the
     * annotation types to parse (other than selected are quickly skipped).&lt;p&gt;
     * This method is only used to parse select meta annotations in the construction
     * phase of {@link AnnotationType} instances to prevent infinite recursion.
     *
     * @param selectAnnotationClasses an array of annotation types to select when parsing
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;) // selectAnnotationClasses is used safely
    static Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; parseSelectAnnotations(
                byte[] rawAnnotations,
                ConstantPool constPool,
                Class&lt;?&gt; container,
                Class&lt;? extends Annotation&gt; ... selectAnnotationClasses) {
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (rawAnnotations == null)</span>
<span class="fc" id="L98">            return Collections.emptyMap();</span>

        try {
<span class="fc" id="L101">            return parseAnnotations2(rawAnnotations, constPool, container, selectAnnotationClasses);</span>
<span class="nc" id="L102">        } catch(BufferUnderflowException e) {</span>
<span class="nc" id="L103">            throw new AnnotationFormatError(&quot;Unexpected end of annotations.&quot;);</span>
<span class="nc" id="L104">        } catch(IllegalArgumentException e) {</span>
            // Type mismatch in constant pool
<span class="nc" id="L106">            throw new AnnotationFormatError(e);</span>
        }
    }

    private static Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; parseAnnotations2(
                byte[] rawAnnotations,
                ConstantPool constPool,
                Class&lt;?&gt; container,
                Class&lt;? extends Annotation&gt;[] selectAnnotationClasses) {
<span class="fc" id="L115">        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; result =</span>
            new LinkedHashMap&lt;Class&lt;? extends Annotation&gt;, Annotation&gt;();
<span class="fc" id="L117">        ByteBuffer buf = ByteBuffer.wrap(rawAnnotations);</span>
<span class="fc" id="L118">        int numAnnotations = buf.getShort() &amp; 0xFFFF;</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">        for (int i = 0; i &lt; numAnnotations; i++) {</span>
<span class="fc" id="L120">            Annotation a = parseAnnotation2(buf, constPool, container, false, selectAnnotationClasses);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            if (a != null) {</span>
<span class="fc" id="L122">                Class&lt;? extends Annotation&gt; klass = a.annotationType();</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">                if (AnnotationType.getInstance(klass).retention() == RetentionPolicy.RUNTIME &amp;&amp;</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">                    result.put(klass, a) != null) {</span>
<span class="nc" id="L125">                        throw new AnnotationFormatError(</span>
                            &quot;Duplicate annotation for class: &quot;+klass+&quot;: &quot; + a);
            }
        }
        }
<span class="fc" id="L130">        return result;</span>
    }

    /**
     * Parses the parameter annotations described by the specified byte array.
     * resolving constant references in the specified constant pool.
     * The array must contain an array of annotations as described
     * in the RuntimeVisibleParameterAnnotations_attribute:
     *
     *    u1 num_parameters;
     *    {
     *        u2 num_annotations;
     *        annotation annotations[num_annotations];
     *    } parameter_annotations[num_parameters];
     *
     * Unlike parseAnnotations, rawAnnotations must not be null!
     * A null value must be handled by the caller.  This is so because
     * we cannot determine the number of parameters if rawAnnotations
     * is null.  Also, the caller should check that the number
     * of parameters indicated by the return value of this method
     * matches the actual number of method parameters.  A mismatch
     * indicates that an AnnotationFormatError should be thrown.
     *
     * @throws AnnotationFormatError if an annotation is found to be
     *         malformed.
     */
    public static Annotation[][] parseParameterAnnotations(
                    byte[] rawAnnotations,
                    ConstantPool constPool,
                    Class&lt;?&gt; container) {
        try {
<span class="fc" id="L161">            return parseParameterAnnotations2(rawAnnotations, constPool, container);</span>
<span class="nc" id="L162">        } catch(BufferUnderflowException e) {</span>
<span class="nc" id="L163">            throw new AnnotationFormatError(</span>
                &quot;Unexpected end of parameter annotations.&quot;);
<span class="nc" id="L165">        } catch(IllegalArgumentException e) {</span>
            // Type mismatch in constant pool
<span class="nc" id="L167">            throw new AnnotationFormatError(e);</span>
        }
    }

    private static Annotation[][] parseParameterAnnotations2(
                    byte[] rawAnnotations,
                    ConstantPool constPool,
                    Class&lt;?&gt; container) {
<span class="fc" id="L175">        ByteBuffer buf = ByteBuffer.wrap(rawAnnotations);</span>
<span class="fc" id="L176">        int numParameters = buf.get() &amp; 0xFF;</span>
<span class="fc" id="L177">        Annotation[][] result = new Annotation[numParameters][];</span>

<span class="fc bfc" id="L179" title="All 2 branches covered.">        for (int i = 0; i &lt; numParameters; i++) {</span>
<span class="fc" id="L180">            int numAnnotations = buf.getShort() &amp; 0xFFFF;</span>
<span class="fc" id="L181">            List&lt;Annotation&gt; annotations =</span>
                new ArrayList&lt;Annotation&gt;(numAnnotations);
<span class="fc bfc" id="L183" title="All 2 branches covered.">            for (int j = 0; j &lt; numAnnotations; j++) {</span>
<span class="fc" id="L184">                Annotation a = parseAnnotation(buf, constPool, container, false);</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">                if (a != null) {</span>
<span class="fc" id="L186">                    AnnotationType type = AnnotationType.getInstance(</span>
<span class="fc" id="L187">                                              a.annotationType());</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                    if (type.retention() == RetentionPolicy.RUNTIME)</span>
<span class="fc" id="L189">                        annotations.add(a);</span>
                }
            }
<span class="fc" id="L192">            result[i] = annotations.toArray(EMPTY_ANNOTATIONS_ARRAY);</span>
        }
<span class="fc" id="L194">        return result;</span>
    }

<span class="fc" id="L197">    private static final Annotation[] EMPTY_ANNOTATIONS_ARRAY =</span>
                    new Annotation[0];

    /**
     * Parses the annotation at the current position in the specified
     * byte buffer, resolving constant references in the specified constant
     * pool.  The cursor of the byte buffer must point to an &quot;annotation
     * structure&quot; as described in the RuntimeVisibleAnnotations_attribute:
     *
     * annotation {
     *    u2    type_index;
     *       u2    num_member_value_pairs;
     *       {    u2    member_name_index;
     *             member_value value;
     *       }    member_value_pairs[num_member_value_pairs];
     *    }
     * }
     *
     * Returns the annotation, or null if the annotation's type cannot
     * be found by the VM, or is not a valid annotation type.
     *
     * @param exceptionOnMissingAnnotationClass if true, throw
     * TypeNotPresentException if a referenced annotation type is not
     * available at runtime
     */
    static Annotation parseAnnotation(ByteBuffer buf,
                                              ConstantPool constPool,
                                              Class&lt;?&gt; container,
                                              boolean exceptionOnMissingAnnotationClass) {
<span class="fc" id="L226">       return parseAnnotation2(buf, constPool, container, exceptionOnMissingAnnotationClass, null);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static Annotation parseAnnotation2(ByteBuffer buf,
                                              ConstantPool constPool,
                                              Class&lt;?&gt; container,
                                              boolean exceptionOnMissingAnnotationClass,
                                              Class&lt;? extends Annotation&gt;[] selectAnnotationClasses) {
<span class="fc" id="L235">        int typeIndex = buf.getShort() &amp; 0xFFFF;</span>
<span class="fc" id="L236">        Class&lt;? extends Annotation&gt; annotationClass = null;</span>
<span class="fc" id="L237">        String sig = &quot;[unknown]&quot;;</span>
        try {
            try {
<span class="fc" id="L240">                sig = constPool.getUTF8At(typeIndex);</span>
<span class="fc" id="L241">                annotationClass = (Class&lt;? extends Annotation&gt;)parseSig(sig, container);</span>
<span class="nc" id="L242">            } catch (IllegalArgumentException ex) {</span>
                // support obsolete early jsr175 format class files
<span class="nc" id="L244">                annotationClass = (Class&lt;? extends Annotation&gt;)constPool.getClassAt(typeIndex);</span>
<span class="fc" id="L245">            }</span>
<span class="nc" id="L246">        } catch (NoClassDefFoundError e) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (exceptionOnMissingAnnotationClass)</span>
                // note: at this point sig is &quot;[unknown]&quot; or VM-style
                // name instead of a binary name
<span class="nc" id="L250">                throw new TypeNotPresentException(sig, e);</span>
<span class="nc" id="L251">            skipAnnotation(buf, false);</span>
<span class="nc" id="L252">            return null;</span>
        }
<span class="nc" id="L254">        catch (TypeNotPresentException e) {</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">            if (exceptionOnMissingAnnotationClass)</span>
<span class="nc" id="L256">                throw e;</span>
<span class="nc" id="L257">            skipAnnotation(buf, false);</span>
<span class="nc" id="L258">            return null;</span>
<span class="fc" id="L259">        }</span>
<span class="fc bfc" id="L260" title="All 4 branches covered.">        if (selectAnnotationClasses != null &amp;&amp; !contains(selectAnnotationClasses, annotationClass)) {</span>
<span class="fc" id="L261">            skipAnnotation(buf, false);</span>
<span class="fc" id="L262">            return null;</span>
        }
<span class="fc" id="L264">        AnnotationType type = null;</span>
        try {
<span class="fc" id="L266">            type = AnnotationType.getInstance(annotationClass);</span>
<span class="nc" id="L267">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L268">            skipAnnotation(buf, false);</span>
<span class="nc" id="L269">            return null;</span>
<span class="fc" id="L270">        }</span>

<span class="fc" id="L272">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = type.memberTypes();</span>
<span class="fc" id="L273">        Map&lt;String, Object&gt; memberValues =</span>
<span class="fc" id="L274">            new LinkedHashMap&lt;String, Object&gt;(type.memberDefaults());</span>

<span class="fc" id="L276">        int numMembers = buf.getShort() &amp; 0xFFFF;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        for (int i = 0; i &lt; numMembers; i++) {</span>
<span class="fc" id="L278">            int memberNameIndex = buf.getShort() &amp; 0xFFFF;</span>
<span class="fc" id="L279">            String memberName = constPool.getUTF8At(memberNameIndex);</span>
<span class="fc" id="L280">            Class&lt;?&gt; memberType = memberTypes.get(memberName);</span>

<span class="pc bpc" id="L282" title="1 of 2 branches missed.">            if (memberType == null) {</span>
                // Member is no longer present in annotation type; ignore it
<span class="nc" id="L284">                skipMemberValue(buf);</span>
            } else {
<span class="fc" id="L286">                Object value = parseMemberValue(memberType, buf, constPool, container);</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">                if (value instanceof AnnotationTypeMismatchExceptionProxy)</span>
<span class="nc" id="L288">                    ((AnnotationTypeMismatchExceptionProxy) value).</span>
<span class="nc" id="L289">                        setMember(type.members().get(memberName));</span>
<span class="fc" id="L290">                memberValues.put(memberName, value);</span>
            }
        }
<span class="fc" id="L293">        return annotationForMap(annotationClass, memberValues);</span>
    }

    /**
     * Returns an annotation of the given type backed by the given
     * member -&gt; value map.
     */
    public static Annotation annotationForMap(final Class&lt;? extends Annotation&gt; type,
                                              final Map&lt;String, Object&gt; memberValues)
    {
<span class="fc" id="L303">        return AccessController.doPrivileged(new PrivilegedAction&lt;Annotation&gt;() {</span>
            public Annotation run() {
<span class="fc" id="L305">                return (Annotation) Proxy.newProxyInstance(</span>
<span class="fc" id="L306">                    type.getClassLoader(), new Class&lt;?&gt;[] { type },</span>
                    new AnnotationInvocationHandler(type, memberValues));
            }});
    }

    /**
     * Parses the annotation member value at the current position in the
     * specified byte buffer, resolving constant references in the specified
     * constant pool.  The cursor of the byte buffer must point to a
     * &quot;member_value structure&quot; as described in the
     * RuntimeVisibleAnnotations_attribute:
     *
     *  member_value {
     *    u1 tag;
     *    union {
     *       u2   const_value_index;
     *       {
     *           u2   type_name_index;
     *           u2   const_name_index;
     *       } enum_const_value;
     *       u2   class_info_index;
     *       annotation annotation_value;
     *       {
     *           u2    num_values;
     *           member_value values[num_values];
     *       } array_value;
     *    } value;
     * }
     *
     * The member must be of the indicated type. If it is not, this
     * method returns an AnnotationTypeMismatchExceptionProxy.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static Object parseMemberValue(Class&lt;?&gt; memberType,
                                          ByteBuffer buf,
                                          ConstantPool constPool,
                                          Class&lt;?&gt; container) {
<span class="fc" id="L343">        Object result = null;</span>
<span class="fc" id="L344">        int tag = buf.get();</span>
<span class="fc bfc" id="L345" title="All 5 branches covered.">        switch(tag) {</span>
          case 'e':
<span class="fc" id="L347">              return parseEnumValue((Class&lt;? extends Enum&lt;?&gt;&gt;)memberType, buf, constPool, container);</span>
          case 'c':
<span class="fc" id="L349">              result = parseClassValue(buf, constPool, container);</span>
<span class="fc" id="L350">              break;</span>
          case '@':
<span class="fc" id="L352">              result = parseAnnotation(buf, constPool, container, true);</span>
<span class="fc" id="L353">              break;</span>
          case '[':
<span class="fc" id="L355">              return parseArray(memberType, buf, constPool, container);</span>
          default:
<span class="fc" id="L357">              result = parseConst(tag, buf, constPool);</span>
        }

<span class="pc bpc" id="L360" title="1 of 2 branches missed.">        if (!(result instanceof ExceptionProxy) &amp;&amp;</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">            !memberType.isInstance(result))</span>
<span class="nc" id="L362">            result = new AnnotationTypeMismatchExceptionProxy(</span>
<span class="nc" id="L363">                result.getClass() + &quot;[&quot; + result + &quot;]&quot;);</span>
<span class="fc" id="L364">        return result;</span>
    }

    /**
     * Parses the primitive or String annotation member value indicated by
     * the specified tag byte at the current position in the specified byte
     * buffer, resolving constant reference in the specified constant pool.
     * The cursor of the byte buffer must point to an annotation member value
     * of the type indicated by the specified tag, as described in the
     * RuntimeVisibleAnnotations_attribute:
     *
     *       u2   const_value_index;
     */
    private static Object parseConst(int tag,
                                     ByteBuffer buf, ConstantPool constPool) {
<span class="fc" id="L379">        int constIndex = buf.getShort() &amp; 0xFFFF;</span>
<span class="pc bpc" id="L380" title="6 of 10 branches missed.">        switch(tag) {</span>
          case 'B':
<span class="nc" id="L382">            return Byte.valueOf((byte) constPool.getIntAt(constIndex));</span>
          case 'C':
<span class="nc" id="L384">            return Character.valueOf((char) constPool.getIntAt(constIndex));</span>
          case 'D':
<span class="nc" id="L386">            return Double.valueOf(constPool.getDoubleAt(constIndex));</span>
          case 'F':
<span class="nc" id="L388">            return Float.valueOf(constPool.getFloatAt(constIndex));</span>
          case 'I':
<span class="fc" id="L390">            return Integer.valueOf(constPool.getIntAt(constIndex));</span>
          case 'J':
<span class="fc" id="L392">            return Long.valueOf(constPool.getLongAt(constIndex));</span>
          case 'S':
<span class="nc" id="L394">            return Short.valueOf((short) constPool.getIntAt(constIndex));</span>
          case 'Z':
<span class="fc bfc" id="L396" title="All 2 branches covered.">            return Boolean.valueOf(constPool.getIntAt(constIndex) != 0);</span>
          case 's':
<span class="fc" id="L398">            return constPool.getUTF8At(constIndex);</span>
          default:
<span class="nc" id="L400">            throw new AnnotationFormatError(</span>
                &quot;Invalid member-value tag in annotation: &quot; + tag);
        }
    }

    /**
     * Parses the Class member value at the current position in the
     * specified byte buffer, resolving constant references in the specified
     * constant pool.  The cursor of the byte buffer must point to a &quot;class
     * info index&quot; as described in the RuntimeVisibleAnnotations_attribute:
     *
     *       u2   class_info_index;
     */
    private static Object parseClassValue(ByteBuffer buf,
                                          ConstantPool constPool,
                                          Class&lt;?&gt; container) {
<span class="fc" id="L416">        int classIndex = buf.getShort() &amp; 0xFFFF;</span>
        try {
            try {
<span class="fc" id="L419">                String sig = constPool.getUTF8At(classIndex);</span>
<span class="fc" id="L420">                return parseSig(sig, container);</span>
<span class="nc" id="L421">            } catch (IllegalArgumentException ex) {</span>
                // support obsolete early jsr175 format class files
<span class="nc" id="L423">                return constPool.getClassAt(classIndex);</span>
            }
<span class="nc" id="L425">        } catch (NoClassDefFoundError e) {</span>
<span class="nc" id="L426">            return new TypeNotPresentExceptionProxy(&quot;[unknown]&quot;, e);</span>
        }
<span class="nc" id="L428">        catch (TypeNotPresentException e) {</span>
<span class="nc" id="L429">            return new TypeNotPresentExceptionProxy(e.typeName(), e.getCause());</span>
        }
    }

    private static Class&lt;?&gt; parseSig(String sig, Class&lt;?&gt; container) {
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        if (sig.equals(&quot;V&quot;)) return void.class;</span>
<span class="fc" id="L435">        SignatureParser parser = SignatureParser.make();</span>
<span class="fc" id="L436">        TypeSignature typeSig = parser.parseTypeSig(sig);</span>
<span class="fc" id="L437">        GenericsFactory factory = CoreReflectionFactory.make(container, ClassScope.make(container));</span>
<span class="fc" id="L438">        Reifier reify = Reifier.make(factory);</span>
<span class="fc" id="L439">        typeSig.accept(reify);</span>
<span class="fc" id="L440">        Type result = reify.getResult();</span>
<span class="fc" id="L441">        return toClass(result);</span>
    }
    static Class&lt;?&gt; toClass(Type o) {
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if (o instanceof GenericArrayType)</span>
<span class="nc" id="L445">            return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),</span>
                                     0)
<span class="nc" id="L447">                .getClass();</span>
<span class="fc" id="L448">        return (Class)o;</span>
    }

    /**
     * Parses the enum constant member value at the current position in the
     * specified byte buffer, resolving constant references in the specified
     * constant pool.  The cursor of the byte buffer must point to a
     * &quot;enum_const_value structure&quot; as described in the
     * RuntimeVisibleAnnotations_attribute:
     *
     *       {
     *           u2   type_name_index;
     *           u2   const_name_index;
     *       } enum_const_value;
     */
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    private static Object parseEnumValue(Class&lt;? extends Enum&gt; enumType, ByteBuffer buf,
                                         ConstantPool constPool,
                                         Class&lt;?&gt; container) {
<span class="fc" id="L467">        int typeNameIndex = buf.getShort() &amp; 0xFFFF;</span>
<span class="fc" id="L468">        String typeName  = constPool.getUTF8At(typeNameIndex);</span>
<span class="fc" id="L469">        int constNameIndex = buf.getShort() &amp; 0xFFFF;</span>
<span class="fc" id="L470">        String constName = constPool.getUTF8At(constNameIndex);</span>

<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (!typeName.endsWith(&quot;;&quot;)) {</span>
            // support now-obsolete early jsr175-format class files.
<span class="nc bnc" id="L474" title="All 2 branches missed.">            if (!enumType.getName().equals(typeName))</span>
<span class="nc" id="L475">            return new AnnotationTypeMismatchExceptionProxy(</span>
                typeName + &quot;.&quot; + constName);
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">        } else if (enumType != parseSig(typeName, container)) {</span>
<span class="nc" id="L478">            return new AnnotationTypeMismatchExceptionProxy(</span>
                typeName + &quot;.&quot; + constName);
        }

        try {
<span class="fc" id="L483">            return  Enum.valueOf(enumType, constName);</span>
<span class="nc" id="L484">        } catch(IllegalArgumentException e) {</span>
<span class="nc" id="L485">            return new EnumConstantNotPresentExceptionProxy(</span>
                (Class&lt;? extends Enum&lt;?&gt;&gt;)enumType, constName);
        }
    }

    /**
     * Parses the array value at the current position in the specified byte
     * buffer, resolving constant references in the specified constant pool.
     * The cursor of the byte buffer must point to an array value struct
     * as specified in the RuntimeVisibleAnnotations_attribute:
     *
     *       {
     *           u2    num_values;
     *           member_value values[num_values];
     *       } array_value;
     *
     * If the array values do not match arrayType, an
     * AnnotationTypeMismatchExceptionProxy will be returned.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private static Object parseArray(Class&lt;?&gt; arrayType,
                                     ByteBuffer buf,
                                     ConstantPool constPool,
                                     Class&lt;?&gt; container) {
<span class="fc" id="L509">        int length = buf.getShort() &amp; 0xFFFF;  // Number of array components</span>
<span class="fc" id="L510">        Class&lt;?&gt; componentType = arrayType.getComponentType();</span>

<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        if (componentType == byte.class) {</span>
<span class="nc" id="L513">            return parseByteArray(length, buf, constPool);</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">        } else if (componentType == char.class) {</span>
<span class="nc" id="L515">            return parseCharArray(length, buf, constPool);</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">        } else if (componentType == double.class) {</span>
<span class="nc" id="L517">            return parseDoubleArray(length, buf, constPool);</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">        } else if (componentType == float.class) {</span>
<span class="nc" id="L519">            return parseFloatArray(length, buf, constPool);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">        } else if (componentType == int.class) {</span>
<span class="fc" id="L521">            return parseIntArray(length, buf, constPool);</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        } else if (componentType == long.class) {</span>
<span class="nc" id="L523">            return parseLongArray(length, buf, constPool);</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        } else if (componentType == short.class) {</span>
<span class="nc" id="L525">            return parseShortArray(length, buf, constPool);</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">        } else if (componentType == boolean.class) {</span>
<span class="nc" id="L527">            return parseBooleanArray(length, buf, constPool);</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">        } else if (componentType == String.class) {</span>
<span class="fc" id="L529">            return parseStringArray(length, buf, constPool);</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">        } else if (componentType == Class.class) {</span>
<span class="fc" id="L531">            return parseClassArray(length, buf, constPool, container);</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">        } else if (componentType.isEnum()) {</span>
<span class="fc" id="L533">            return parseEnumArray(length, (Class&lt;? extends Enum&lt;?&gt;&gt;)componentType, buf,</span>
                                  constPool, container);
        } else {
<span class="pc bpc" id="L536" title="2 of 4 branches missed.">            assert componentType.isAnnotation();</span>
<span class="fc" id="L537">            return parseAnnotationArray(length, (Class &lt;? extends Annotation&gt;)componentType, buf,</span>
                                        constPool, container);
        }
    }

    private static Object parseByteArray(int length,
                                  ByteBuffer buf, ConstantPool constPool) {
<span class="nc" id="L544">        byte[] result = new byte[length];</span>
<span class="nc" id="L545">        boolean typeMismatch = false;</span>
<span class="nc" id="L546">        int tag = 0;</span>

<span class="nc bnc" id="L548" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L549">            tag = buf.get();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">            if (tag == 'B') {</span>
<span class="nc" id="L551">                int index = buf.getShort() &amp; 0xFFFF;</span>
<span class="nc" id="L552">                result[i] = (byte) constPool.getIntAt(index);</span>
<span class="nc" id="L553">            } else {</span>
<span class="nc" id="L554">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L555">                typeMismatch = true;</span>
            }
        }
<span class="nc bnc" id="L558" title="All 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    private static Object parseCharArray(int length,
                                  ByteBuffer buf, ConstantPool constPool) {
<span class="nc" id="L563">        char[] result = new char[length];</span>
<span class="nc" id="L564">        boolean typeMismatch = false;</span>
<span class="nc" id="L565">        byte tag = 0;</span>

<span class="nc bnc" id="L567" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L568">            tag = buf.get();</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">            if (tag == 'C') {</span>
<span class="nc" id="L570">                int index = buf.getShort() &amp; 0xFFFF;</span>
<span class="nc" id="L571">                result[i] = (char) constPool.getIntAt(index);</span>
<span class="nc" id="L572">            } else {</span>
<span class="nc" id="L573">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L574">                typeMismatch = true;</span>
            }
        }
<span class="nc bnc" id="L577" title="All 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    private static Object parseDoubleArray(int length,
                                    ByteBuffer buf, ConstantPool constPool) {
<span class="nc" id="L582">        double[] result = new  double[length];</span>
<span class="nc" id="L583">        boolean typeMismatch = false;</span>
<span class="nc" id="L584">        int tag = 0;</span>

<span class="nc bnc" id="L586" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L587">            tag = buf.get();</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">            if (tag == 'D') {</span>
<span class="nc" id="L589">                int index = buf.getShort() &amp; 0xFFFF;</span>
<span class="nc" id="L590">                result[i] = constPool.getDoubleAt(index);</span>
<span class="nc" id="L591">            } else {</span>
<span class="nc" id="L592">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L593">                typeMismatch = true;</span>
            }
        }
<span class="nc bnc" id="L596" title="All 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    private static Object parseFloatArray(int length,
                                   ByteBuffer buf, ConstantPool constPool) {
<span class="nc" id="L601">        float[] result = new float[length];</span>
<span class="nc" id="L602">        boolean typeMismatch = false;</span>
<span class="nc" id="L603">        int tag = 0;</span>

<span class="nc bnc" id="L605" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L606">            tag = buf.get();</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">            if (tag == 'F') {</span>
<span class="nc" id="L608">                int index = buf.getShort() &amp; 0xFFFF;</span>
<span class="nc" id="L609">                result[i] = constPool.getFloatAt(index);</span>
<span class="nc" id="L610">            } else {</span>
<span class="nc" id="L611">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L612">                typeMismatch = true;</span>
            }
        }
<span class="nc bnc" id="L615" title="All 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    private static Object parseIntArray(int length,
                                 ByteBuffer buf, ConstantPool constPool) {
<span class="fc" id="L620">        int[] result = new  int[length];</span>
<span class="fc" id="L621">        boolean typeMismatch = false;</span>
<span class="fc" id="L622">        int tag = 0;</span>

<span class="pc bpc" id="L624" title="1 of 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L625">            tag = buf.get();</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">            if (tag == 'I') {</span>
<span class="nc" id="L627">                int index = buf.getShort() &amp; 0xFFFF;</span>
<span class="nc" id="L628">                result[i] = constPool.getIntAt(index);</span>
<span class="nc" id="L629">            } else {</span>
<span class="nc" id="L630">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L631">                typeMismatch = true;</span>
            }
        }
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    private static Object parseLongArray(int length,
                                  ByteBuffer buf, ConstantPool constPool) {
<span class="nc" id="L639">        long[] result = new long[length];</span>
<span class="nc" id="L640">        boolean typeMismatch = false;</span>
<span class="nc" id="L641">        int tag = 0;</span>

<span class="nc bnc" id="L643" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L644">            tag = buf.get();</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">            if (tag == 'J') {</span>
<span class="nc" id="L646">                int index = buf.getShort() &amp; 0xFFFF;</span>
<span class="nc" id="L647">                result[i] = constPool.getLongAt(index);</span>
<span class="nc" id="L648">            } else {</span>
<span class="nc" id="L649">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L650">                typeMismatch = true;</span>
            }
        }
<span class="nc bnc" id="L653" title="All 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    private static Object parseShortArray(int length,
                                   ByteBuffer buf, ConstantPool constPool) {
<span class="nc" id="L658">        short[] result = new short[length];</span>
<span class="nc" id="L659">        boolean typeMismatch = false;</span>
<span class="nc" id="L660">        int tag = 0;</span>

<span class="nc bnc" id="L662" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L663">            tag = buf.get();</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">            if (tag == 'S') {</span>
<span class="nc" id="L665">                int index = buf.getShort() &amp; 0xFFFF;</span>
<span class="nc" id="L666">                result[i] = (short) constPool.getIntAt(index);</span>
<span class="nc" id="L667">            } else {</span>
<span class="nc" id="L668">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L669">                typeMismatch = true;</span>
            }
        }
<span class="nc bnc" id="L672" title="All 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    private static Object parseBooleanArray(int length,
                                     ByteBuffer buf, ConstantPool constPool) {
<span class="nc" id="L677">        boolean[] result = new boolean[length];</span>
<span class="nc" id="L678">        boolean typeMismatch = false;</span>
<span class="nc" id="L679">        int tag = 0;</span>

<span class="nc bnc" id="L681" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L682">            tag = buf.get();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">            if (tag == 'Z') {</span>
<span class="nc" id="L684">                int index = buf.getShort() &amp; 0xFFFF;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">                result[i] = (constPool.getIntAt(index) != 0);</span>
<span class="nc" id="L686">            } else {</span>
<span class="nc" id="L687">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L688">                typeMismatch = true;</span>
            }
        }
<span class="nc bnc" id="L691" title="All 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    private static Object parseStringArray(int length,
                                    ByteBuffer buf,  ConstantPool constPool) {
<span class="fc" id="L696">        String[] result = new String[length];</span>
<span class="fc" id="L697">        boolean typeMismatch = false;</span>
<span class="fc" id="L698">        int tag = 0;</span>

<span class="fc bfc" id="L700" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L701">            tag = buf.get();</span>
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">            if (tag == 's') {</span>
<span class="fc" id="L703">                int index = buf.getShort() &amp; 0xFFFF;</span>
<span class="fc" id="L704">                result[i] = constPool.getUTF8At(index);</span>
<span class="fc" id="L705">            } else {</span>
<span class="nc" id="L706">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L707">                typeMismatch = true;</span>
            }
        }
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    private static Object parseClassArray(int length,
                                          ByteBuffer buf,
                                          ConstantPool constPool,
                                          Class&lt;?&gt; container) {
<span class="fc" id="L717">        Object[] result = new Class&lt;?&gt;[length];</span>
<span class="fc" id="L718">        boolean typeMismatch = false;</span>
<span class="fc" id="L719">        int tag = 0;</span>

<span class="fc bfc" id="L721" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L722">            tag = buf.get();</span>
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">            if (tag == 'c') {</span>
<span class="fc" id="L724">                result[i] = parseClassValue(buf, constPool, container);</span>
            } else {
<span class="nc" id="L726">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L727">                typeMismatch = true;</span>
            }
        }
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    private static Object parseEnumArray(int length, Class&lt;? extends Enum&lt;?&gt;&gt; enumType,
                                         ByteBuffer buf,
                                         ConstantPool constPool,
                                         Class&lt;?&gt; container) {
<span class="fc" id="L737">        Object[] result = (Object[]) Array.newInstance(enumType, length);</span>
<span class="fc" id="L738">        boolean typeMismatch = false;</span>
<span class="fc" id="L739">        int tag = 0;</span>

<span class="fc bfc" id="L741" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L742">            tag = buf.get();</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">            if (tag == 'e') {</span>
<span class="fc" id="L744">                result[i] = parseEnumValue(enumType, buf, constPool, container);</span>
            } else {
<span class="nc" id="L746">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L747">                typeMismatch = true;</span>
            }
        }
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    private static Object parseAnnotationArray(int length,
                                               Class&lt;? extends Annotation&gt; annotationType,
                                               ByteBuffer buf,
                                               ConstantPool constPool,
                                               Class&lt;?&gt; container) {
<span class="fc" id="L758">        Object[] result = (Object[]) Array.newInstance(annotationType, length);</span>
<span class="fc" id="L759">        boolean typeMismatch = false;</span>
<span class="fc" id="L760">        int tag = 0;</span>

<span class="fc bfc" id="L762" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L763">            tag = buf.get();</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">            if (tag == '@') {</span>
<span class="fc" id="L765">                result[i] = parseAnnotation(buf, constPool, container, true);</span>
            } else {
<span class="nc" id="L767">                skipMemberValue(tag, buf);</span>
<span class="nc" id="L768">                typeMismatch = true;</span>
            }
        }
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">        return typeMismatch ? exceptionProxy(tag) : result;</span>
    }

    /**
     * Return an appropriate exception proxy for a mismatching array
     * annotation where the erroneous array has the specified tag.
     */
    private static ExceptionProxy exceptionProxy(int tag) {
<span class="nc" id="L779">        return new AnnotationTypeMismatchExceptionProxy(</span>
            &quot;Array with component tag: &quot; + tag);
    }

    /**
     * Skips the annotation at the current position in the specified
     * byte buffer.  The cursor of the byte buffer must point to
     * an &quot;annotation structure&quot; OR two bytes into an annotation
     * structure (i.e., after the type index).
     *
     * @parameter complete true if the byte buffer points to the beginning
     *     of an annotation structure (rather than two bytes in).
     */
    private static void skipAnnotation(ByteBuffer buf, boolean complete) {
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">        if (complete)</span>
<span class="nc" id="L794">            buf.getShort();   // Skip type index</span>
<span class="fc" id="L795">        int numMembers = buf.getShort() &amp; 0xFFFF;</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">        for (int i = 0; i &lt; numMembers; i++) {</span>
<span class="fc" id="L797">            buf.getShort();   // Skip memberNameIndex</span>
<span class="fc" id="L798">            skipMemberValue(buf);</span>
        }
<span class="fc" id="L800">    }</span>

    /**
     * Skips the annotation member value at the current position in the
     * specified byte buffer.  The cursor of the byte buffer must point to a
     * &quot;member_value structure.&quot;
     */
    private static void skipMemberValue(ByteBuffer buf) {
<span class="fc" id="L808">        int tag = buf.get();</span>
<span class="fc" id="L809">        skipMemberValue(tag, buf);</span>
<span class="fc" id="L810">    }</span>

    /**
     * Skips the annotation member value at the current position in the
     * specified byte buffer.  The cursor of the byte buffer must point
     * immediately after the tag in a &quot;member_value structure.&quot;
     */
    private static void skipMemberValue(int tag, ByteBuffer buf) {
<span class="pc bpc" id="L818" title="1 of 4 branches missed.">        switch(tag) {</span>
          case 'e': // Enum value
<span class="fc" id="L820">            buf.getInt();  // (Two shorts, actually.)</span>
<span class="fc" id="L821">            break;</span>
          case '@':
<span class="nc" id="L823">            skipAnnotation(buf, true);</span>
<span class="nc" id="L824">            break;</span>
          case '[':
<span class="fc" id="L826">            skipArray(buf);</span>
<span class="fc" id="L827">            break;</span>
          default:
            // Class, primitive, or String
<span class="fc" id="L830">            buf.getShort();</span>
        }
<span class="fc" id="L832">    }</span>

    /**
     * Skips the array value at the current position in the specified byte
     * buffer.  The cursor of the byte buffer must point to an array value
     * struct.
     */
    private static void skipArray(ByteBuffer buf) {
<span class="fc" id="L840">        int length = buf.getShort() &amp; 0xFFFF;</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++)</span>
<span class="fc" id="L842">            skipMemberValue(buf);</span>
<span class="fc" id="L843">    }</span>

    /**
     * Searches for given {@code element} in given {@code array} by identity.
     * Returns {@code true} if found {@code false} if not.
     */
    private static boolean contains(Object[] array, Object element) {
<span class="fc bfc" id="L850" title="All 2 branches covered.">        for (Object e : array)</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">            if (e == element)</span>
<span class="fc" id="L852">                return true;</span>
<span class="fc" id="L853">        return false;</span>
    }

    /*
     * This method converts the annotation map returned by the parseAnnotations()
     * method to an array.  It is called by Field.getDeclaredAnnotations(),
     * Method.getDeclaredAnnotations(), and Constructor.getDeclaredAnnotations().
     * This avoids the reflection classes to load the Annotation class until
     * it is needed.
     */
<span class="fc" id="L863">    private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];</span>
    public static Annotation[] toArray(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations) {
<span class="fc" id="L865">        return annotations.values().toArray(EMPTY_ANNOTATION_ARRAY);</span>
    }

<span class="nc" id="L868">    static Annotation[] getEmptyAnnotationArray() { return EMPTY_ANNOTATION_ARRAY; }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>