<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AlgorithmId.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.x509</a> &gt; <span class="el_source">AlgorithmId.java</span></div><h1>AlgorithmId.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.x509;

import java.io.*;
import java.util.*;
import java.security.*;

import sun.security.util.*;


/**
 * This class identifies algorithms, such as cryptographic transforms, each
 * of which may be associated with parameters.  Instances of this base class
 * are used when this runtime environment has no special knowledge of the
 * algorithm type, and may also be used in other cases.  Equivalence is
 * defined according to OID and (where relevant) parameters.
 *
 * &lt;P&gt;Subclasses may be used, for example when when the algorithm ID has
 * associated parameters which some code (e.g. code using public keys) needs
 * to have parsed.  Two examples of such algorithms are Diffie-Hellman key
 * exchange, and the Digital Signature Standard Algorithm (DSS/DSA).
 *
 * &lt;P&gt;The OID constants defined in this class correspond to some widely
 * used algorithms, for which conventional string names have been defined.
 * This class is not a general repository for OIDs, or for such string names.
 * Note that the mappings between algorithm IDs and algorithm names is
 * not one-to-one.
 *
 *
 * @author David Brownell
 * @author Amit Kapoor
 * @author Hemma Prafullchandra
 */
public class AlgorithmId implements Serializable, DerEncoder {

    /** use serialVersionUID from JDK 1.1. for interoperability */
    private static final long serialVersionUID = 7205873507486557157L;

    /**
     * The object identitifer being used for this algorithm.
     */
    private ObjectIdentifier algid;

    // The (parsed) parameters
    private AlgorithmParameters algParams;
<span class="pc" id="L70">    private boolean constructedFromDer = true;</span>

    /**
     * Parameters for this algorithm.  These are stored in unparsed
     * DER-encoded form; subclasses can be made to automaticaly parse
     * them so there is fast access to these parameters.
     */
    protected DerValue          params;


    /**
     * Constructs an algorithm ID which will be initialized
     * separately, for example by deserialization.
     * @deprecated use one of the other constructors.
     */
    @Deprecated
<span class="nc" id="L86">    public AlgorithmId() { }</span>

    /**
     * Constructs a parameterless algorithm ID.
     *
     * @param oid the identifier for the algorithm
     */
<span class="fc" id="L93">    public AlgorithmId(ObjectIdentifier oid) {</span>
<span class="fc" id="L94">        algid = oid;</span>
<span class="fc" id="L95">    }</span>

    /**
     * Constructs an algorithm ID with algorithm parameters.
     *
     * @param oid the identifier for the algorithm.
     * @param algparams the associated algorithm parameters.
     */
<span class="fc" id="L103">    public AlgorithmId(ObjectIdentifier oid, AlgorithmParameters algparams) {</span>
<span class="fc" id="L104">        algid = oid;</span>
<span class="fc" id="L105">        algParams = algparams;</span>
<span class="fc" id="L106">        constructedFromDer = false;</span>
<span class="fc" id="L107">    }</span>

    private AlgorithmId(ObjectIdentifier oid, DerValue params)
<span class="fc" id="L110">            throws IOException {</span>
<span class="fc" id="L111">        this.algid = oid;</span>
<span class="fc" id="L112">        this.params = params;</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (this.params != null) {</span>
<span class="fc" id="L114">            decodeParams();</span>
        }
<span class="fc" id="L116">    }</span>

    protected void decodeParams() throws IOException {
<span class="fc" id="L119">        String algidString = algid.toString();</span>
        try {
<span class="fc" id="L121">            algParams = AlgorithmParameters.getInstance(algidString);</span>
<span class="nc" id="L122">        } catch (NoSuchAlgorithmException e) {</span>
            /*
             * This algorithm parameter type is not supported, so we cannot
             * parse the parameters.
             */
<span class="nc" id="L127">            algParams = null;</span>
<span class="nc" id="L128">            return;</span>
<span class="fc" id="L129">        }</span>

        // Decode (parse) the parameters
<span class="fc" id="L132">        algParams.init(params.toByteArray());</span>
<span class="fc" id="L133">    }</span>

    /**
     * Marshal a DER-encoded &quot;AlgorithmID&quot; sequence on the DER stream.
     */
    public final void encode(DerOutputStream out) throws IOException {
<span class="fc" id="L139">        derEncode(out);</span>
<span class="fc" id="L140">    }</span>

    /**
     * DER encode this object onto an output stream.
     * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
     *
     * @param out
     * the output stream on which to write the DER encoding.
     *
     * @exception IOException on encoding error.
     */
    public void derEncode (OutputStream out) throws IOException {
<span class="fc" id="L152">        DerOutputStream bytes = new DerOutputStream();</span>
<span class="fc" id="L153">        DerOutputStream tmp = new DerOutputStream();</span>

<span class="fc" id="L155">        bytes.putOID(algid);</span>
        // Setup params from algParams since no DER encoding is given
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (constructedFromDer == false) {</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">            if (algParams != null) {</span>
<span class="fc" id="L159">                params = new DerValue(algParams.getEncoded());</span>
            } else {
<span class="nc" id="L161">                params = null;</span>
            }
        }
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (params == null) {</span>
            // Changes backed out for compatibility with Solaris

            // Several AlgorithmId should omit the whole parameter part when
            // it's NULL. They are ---
            // rfc3370 2.1: Implementations SHOULD generate SHA-1
            // AlgorithmIdentifiers with absent parameters.
            // rfc3447 C1: When id-sha1, id-sha224, id-sha256, id-sha384 and
            // id-sha512 are used in an AlgorithmIdentifier the parameters
            // (which are optional) SHOULD be omitted.
            // rfc3279 2.3.2: The id-dsa algorithm syntax includes optional
            // domain parameters... When omitted, the parameters component
            // MUST be omitted entirely
            // rfc3370 3.1: When the id-dsa-with-sha1 algorithm identifier
            // is used, the AlgorithmIdentifier parameters field MUST be absent.
            /*if (
                algid.equals((Object)SHA_oid) ||
                algid.equals((Object)SHA224_oid) ||
                algid.equals((Object)SHA256_oid) ||
                algid.equals((Object)SHA384_oid) ||
                algid.equals((Object)SHA512_oid) ||
                algid.equals((Object)DSA_oid) ||
                algid.equals((Object)sha1WithDSA_oid)) {
                ; // no parameter part encoded
            } else {
                bytes.putNull();
            }*/
<span class="fc" id="L191">            bytes.putNull();</span>
        } else {
<span class="fc" id="L193">            bytes.putDerValue(params);</span>
        }
<span class="fc" id="L195">        tmp.write(DerValue.tag_Sequence, bytes);</span>
<span class="fc" id="L196">        out.write(tmp.toByteArray());</span>
<span class="fc" id="L197">    }</span>


    /**
     * Returns the DER-encoded X.509 AlgorithmId as a byte array.
     */
    public final byte[] encode() throws IOException {
<span class="fc" id="L204">        DerOutputStream out = new DerOutputStream();</span>
<span class="fc" id="L205">        derEncode(out);</span>
<span class="fc" id="L206">        return out.toByteArray();</span>
    }

    /**
     * Returns the ISO OID for this algorithm.  This is usually converted
     * to a string and used as part of an algorithm name, for example
     * &quot;OID.1.3.14.3.2.13&quot; style notation.  Use the &lt;code&gt;getName&lt;/code&gt;
     * call when you do not need to ensure cross-system portability
     * of algorithm names, or need a user friendly name.
     */
    public final ObjectIdentifier getOID () {
<span class="fc" id="L217">        return algid;</span>
    }

    /**
     * Returns a name for the algorithm which may be more intelligible
     * to humans than the algorithm's OID, but which won't necessarily
     * be comprehensible on other systems.  For example, this might
     * return a name such as &quot;MD5withRSA&quot; for a signature algorithm on
     * some systems.  It also returns names like &quot;OID.1.2.3.4&quot;, when
     * no particular name for the algorithm is known.
     */
    public String getName() {
<span class="fc" id="L229">        String algName = nameTable.get(algid);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (algName != null) {</span>
<span class="fc" id="L231">            return algName;</span>
        }
<span class="pc bpc" id="L233" title="3 of 4 branches missed.">        if ((params != null) &amp;&amp; algid.equals((Object)specifiedWithECDSA_oid)) {</span>
            try {
<span class="nc" id="L235">                AlgorithmId paramsId =</span>
<span class="nc" id="L236">                        AlgorithmId.parse(new DerValue(getEncodedParams()));</span>
<span class="nc" id="L237">                String paramsName = paramsId.getName();</span>
<span class="nc" id="L238">                algName = makeSigAlg(paramsName, &quot;EC&quot;);</span>
<span class="nc" id="L239">            } catch (IOException e) {</span>
                // ignore
<span class="nc" id="L241">            }</span>
        }
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        return (algName == null) ? algid.toString() : algName;</span>
    }

    public AlgorithmParameters getParameters() {
<span class="fc" id="L247">        return algParams;</span>
    }

    /**
     * Returns the DER encoded parameter, which can then be
     * used to initialize java.security.AlgorithmParamters.
     *
     * @return DER encoded parameters, or null not present.
     */
    public byte[] getEncodedParams() throws IOException {
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">        return (params == null) ? null : params.toByteArray();</span>
    }

    /**
     * Returns true iff the argument indicates the same algorithm
     * with the same parameters.
     */
    public boolean equals(AlgorithmId other) {
<span class="pc bpc" id="L265" title="2 of 4 branches missed.">        boolean paramsEqual =</span>
<span class="pc" id="L266">          (params == null ? other.params == null : params.equals(other.params));</span>
<span class="pc bpc" id="L267" title="2 of 4 branches missed.">        return (algid.equals((Object)other.algid) &amp;&amp; paramsEqual);</span>
    }

    /**
     * Compares this AlgorithmID to another.  If algorithm parameters are
     * available, they are compared.  Otherwise, just the object IDs
     * for the algorithm are compared.
     *
     * @param other preferably an AlgorithmId, else an ObjectIdentifier
     */
    public boolean equals(Object other) {
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (this == other) {</span>
<span class="nc" id="L279">            return true;</span>
        }
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (other instanceof AlgorithmId) {</span>
<span class="nc" id="L282">            return equals((AlgorithmId) other);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">        } else if (other instanceof ObjectIdentifier) {</span>
<span class="nc" id="L284">            return equals((ObjectIdentifier) other);</span>
        } else {
<span class="nc" id="L286">            return false;</span>
        }
    }

    /**
     * Compares two algorithm IDs for equality.  Returns true iff
     * they are the same algorithm, ignoring algorithm parameters.
     */
    public final boolean equals(ObjectIdentifier id) {
<span class="nc" id="L295">        return algid.equals((Object)id);</span>
    }

    /**
     * Returns a hashcode for this AlgorithmId.
     *
     * @return a hashcode for this AlgorithmId.
     */
    public int hashCode() {
<span class="nc" id="L304">        StringBuilder sbuf = new StringBuilder();</span>
<span class="nc" id="L305">        sbuf.append(algid.toString());</span>
<span class="nc" id="L306">        sbuf.append(paramsToString());</span>
<span class="nc" id="L307">        return sbuf.toString().hashCode();</span>
    }

    /**
     * Provides a human-readable description of the algorithm parameters.
     * This may be redefined by subclasses which parse those parameters.
     */
    protected String paramsToString() {
<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (params == null) {</span>
<span class="fc" id="L316">            return &quot;&quot;;</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        } else if (algParams != null) {</span>
<span class="fc" id="L318">            return algParams.toString();</span>
        } else {
<span class="nc" id="L320">            return &quot;, params unparsed&quot;;</span>
        }
    }

    /**
     * Returns a string describing the algorithm and its parameters.
     */
    public String toString() {
<span class="fc" id="L328">        return getName() + paramsToString();</span>
    }

    /**
     * Parse (unmarshal) an ID from a DER sequence input value.  This form
     * parsing might be used when expanding a value which has already been
     * partially unmarshaled as a set or sequence member.
     *
     * @exception IOException on error.
     * @param val the input value, which contains the algid and, if
     *          there are any parameters, those parameters.
     * @return an ID for the algorithm.  If the system is configured
     *          appropriately, this may be an instance of a class
     *          with some kind of special support for this algorithm.
     *          In that case, you may &quot;narrow&quot; the type of the ID.
     */
    public static AlgorithmId parse(DerValue val) throws IOException {
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">        if (val.tag != DerValue.tag_Sequence) {</span>
<span class="nc" id="L346">            throw new IOException(&quot;algid parse error, not a sequence&quot;);</span>
        }

        /*
         * Get the algorithm ID and any parameters.
         */
        ObjectIdentifier        algid;
        DerValue                params;
<span class="fc" id="L354">        DerInputStream          in = val.toDerInputStream();</span>

<span class="fc" id="L356">        algid = in.getOID();</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (in.available() == 0) {</span>
<span class="fc" id="L358">            params = null;</span>
        } else {
<span class="fc" id="L360">            params = in.getDerValue();</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">            if (params.tag == DerValue.tag_Null) {</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">                if (params.length() != 0) {</span>
<span class="nc" id="L363">                    throw new IOException(&quot;invalid NULL&quot;);</span>
                }
<span class="fc" id="L365">                params = null;</span>
            }
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            if (in.available() != 0) {</span>
<span class="nc" id="L368">                throw new IOException(&quot;Invalid AlgorithmIdentifier: extra data&quot;);</span>
            }
        }

<span class="fc" id="L372">        return new AlgorithmId(algid, params);</span>
    }

    /**
     * Returns one of the algorithm IDs most commonly associated
     * with this algorithm name.
     *
     * @param algname the name being used
     * @deprecated use the short get form of this method.
     * @exception NoSuchAlgorithmException on error.
     */
    @Deprecated
    public static AlgorithmId getAlgorithmId(String algname)
            throws NoSuchAlgorithmException {
<span class="fc" id="L386">        return get(algname);</span>
    }

    /**
     * Returns one of the algorithm IDs most commonly associated
     * with this algorithm name.
     *
     * @param algname the name being used
     * @exception NoSuchAlgorithmException on error.
     */
    public static AlgorithmId get(String algname)
            throws NoSuchAlgorithmException {
        ObjectIdentifier oid;
        try {
<span class="fc" id="L400">            oid = algOID(algname);</span>
<span class="nc" id="L401">        } catch (IOException ioe) {</span>
<span class="nc" id="L402">            throw new NoSuchAlgorithmException</span>
                (&quot;Invalid ObjectIdentifier &quot; + algname);
<span class="fc" id="L404">        }</span>

<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (oid == null) {</span>
<span class="nc" id="L407">            throw new NoSuchAlgorithmException</span>
                (&quot;unrecognized algorithm name: &quot; + algname);
        }
<span class="fc" id="L410">        return new AlgorithmId(oid);</span>
    }

    /**
     * Returns one of the algorithm IDs most commonly associated
     * with this algorithm parameters.
     *
     * @param algparams the associated algorithm parameters.
     * @exception NoSuchAlgorithmException on error.
     */
    public static AlgorithmId get(AlgorithmParameters algparams)
            throws NoSuchAlgorithmException {
        ObjectIdentifier oid;
<span class="nc" id="L423">        String algname = algparams.getAlgorithm();</span>
        try {
<span class="nc" id="L425">            oid = algOID(algname);</span>
<span class="nc" id="L426">        } catch (IOException ioe) {</span>
<span class="nc" id="L427">            throw new NoSuchAlgorithmException</span>
                (&quot;Invalid ObjectIdentifier &quot; + algname);
<span class="nc" id="L429">        }</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (oid == null) {</span>
<span class="nc" id="L431">            throw new NoSuchAlgorithmException</span>
                (&quot;unrecognized algorithm name: &quot; + algname);
        }
<span class="nc" id="L434">        return new AlgorithmId(oid, algparams);</span>
    }

    /*
     * Translates from some common algorithm names to the
     * OID with which they're usually associated ... this mapping
     * is the reverse of the one below, except in those cases
     * where synonyms are supported or where a given algorithm
     * is commonly associated with multiple OIDs.
     *
     * XXX This method needs to be enhanced so that we can also pass the
     * scope of the algorithm name to it, e.g., the algorithm name &quot;DSA&quot;
     * may have a different OID when used as a &quot;Signature&quot; algorithm than when
     * used as a &quot;KeyPairGenerator&quot; algorithm.
     */
    private static ObjectIdentifier algOID(String name) throws IOException {
        // See if algname is in printable OID (&quot;dot-dot&quot;) notation
<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (name.indexOf('.') != -1) {</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">            if (name.startsWith(&quot;OID.&quot;)) {</span>
<span class="nc" id="L453">                return new ObjectIdentifier(name.substring(&quot;OID.&quot;.length()));</span>
            } else {
<span class="fc" id="L455">                return new ObjectIdentifier(name);</span>
            }
        }

        // Digesting algorithms
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;MD5&quot;)) {</span>
<span class="nc" id="L461">            return AlgorithmId.MD5_oid;</span>
        }
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;MD2&quot;)) {</span>
<span class="nc" id="L464">            return AlgorithmId.MD2_oid;</span>
        }
<span class="pc bpc" id="L466" title="2 of 4 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA&quot;) || name.equalsIgnoreCase(&quot;SHA1&quot;)</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">            || name.equalsIgnoreCase(&quot;SHA-1&quot;)) {</span>
<span class="nc" id="L468">            return AlgorithmId.SHA_oid;</span>
        }
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA-256&quot;) ||</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">            name.equalsIgnoreCase(&quot;SHA256&quot;)) {</span>
<span class="nc" id="L472">            return AlgorithmId.SHA256_oid;</span>
        }
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA-384&quot;) ||</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">            name.equalsIgnoreCase(&quot;SHA384&quot;)) {</span>
<span class="nc" id="L476">            return AlgorithmId.SHA384_oid;</span>
        }
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA-512&quot;) ||</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">            name.equalsIgnoreCase(&quot;SHA512&quot;)) {</span>
<span class="nc" id="L480">            return AlgorithmId.SHA512_oid;</span>
        }
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA-224&quot;) ||</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">            name.equalsIgnoreCase(&quot;SHA224&quot;)) {</span>
<span class="nc" id="L484">            return AlgorithmId.SHA224_oid;</span>
        }

        // Various public key algorithms
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;RSA&quot;)) {</span>
<span class="nc" id="L489">            return AlgorithmId.RSAEncryption_oid;</span>
        }
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;Diffie-Hellman&quot;)</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">            || name.equalsIgnoreCase(&quot;DH&quot;)) {</span>
<span class="nc" id="L493">            return AlgorithmId.DH_oid;</span>
        }
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;DSA&quot;)) {</span>
<span class="nc" id="L496">            return AlgorithmId.DSA_oid;</span>
        }
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;EC&quot;)) {</span>
<span class="nc" id="L499">            return EC_oid;</span>
        }
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;ECDH&quot;)) {</span>
<span class="nc" id="L502">            return AlgorithmId.ECDH_oid;</span>
        }

        // Secret key algorithms
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;AES&quot;)) {</span>
<span class="nc" id="L507">            return AlgorithmId.AES_oid;</span>
        }

        // Common signature types
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;MD5withRSA&quot;)</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">            || name.equalsIgnoreCase(&quot;MD5/RSA&quot;)) {</span>
<span class="nc" id="L513">            return AlgorithmId.md5WithRSAEncryption_oid;</span>
        }
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;MD2withRSA&quot;)</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">            || name.equalsIgnoreCase(&quot;MD2/RSA&quot;)) {</span>
<span class="nc" id="L517">            return AlgorithmId.md2WithRSAEncryption_oid;</span>
        }
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHAwithDSA&quot;)</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">            || name.equalsIgnoreCase(&quot;SHA1withDSA&quot;)</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">            || name.equalsIgnoreCase(&quot;SHA/DSA&quot;)</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">            || name.equalsIgnoreCase(&quot;SHA1/DSA&quot;)</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">            || name.equalsIgnoreCase(&quot;DSAWithSHA1&quot;)</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">            || name.equalsIgnoreCase(&quot;DSS&quot;)</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">            || name.equalsIgnoreCase(&quot;SHA-1/DSA&quot;)) {</span>
<span class="nc" id="L526">            return AlgorithmId.sha1WithDSA_oid;</span>
        }
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA224WithDSA&quot;)) {</span>
<span class="nc" id="L529">            return AlgorithmId.sha224WithDSA_oid;</span>
        }
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA256WithDSA&quot;)) {</span>
<span class="nc" id="L532">            return AlgorithmId.sha256WithDSA_oid;</span>
        }
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA1WithRSA&quot;)</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">            || name.equalsIgnoreCase(&quot;SHA1/RSA&quot;)) {</span>
<span class="nc" id="L536">            return AlgorithmId.sha1WithRSAEncryption_oid;</span>
        }
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA1withECDSA&quot;)</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">                || name.equalsIgnoreCase(&quot;ECDSA&quot;)) {</span>
<span class="nc" id="L540">            return AlgorithmId.sha1WithECDSA_oid;</span>
        }
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA224withECDSA&quot;)) {</span>
<span class="nc" id="L543">            return AlgorithmId.sha224WithECDSA_oid;</span>
        }
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA256withECDSA&quot;)) {</span>
<span class="nc" id="L546">            return AlgorithmId.sha256WithECDSA_oid;</span>
        }
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA384withECDSA&quot;)) {</span>
<span class="nc" id="L549">            return AlgorithmId.sha384WithECDSA_oid;</span>
        }
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">        if (name.equalsIgnoreCase(&quot;SHA512withECDSA&quot;)) {</span>
<span class="nc" id="L552">            return AlgorithmId.sha512WithECDSA_oid;</span>
        }

        // See if any of the installed providers supply a mapping from
        // the given algorithm name to an OID string
        String oidString;
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">        if (!initOidTable) {</span>
<span class="fc" id="L559">            Provider[] provs = Security.getProviders();</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">            for (int i=0; i&lt;provs.length; i++) {</span>
<span class="fc" id="L561">                for (Enumeration&lt;Object&gt; enum_ = provs[i].keys();</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">                     enum_.hasMoreElements(); ) {</span>
<span class="fc" id="L563">                    String alias = (String)enum_.nextElement();</span>
<span class="fc" id="L564">                    String upperCaseAlias = alias.toUpperCase(Locale.ENGLISH);</span>
                    int index;
<span class="fc bfc" id="L566" title="All 2 branches covered.">                    if (upperCaseAlias.startsWith(&quot;ALG.ALIAS&quot;) &amp;&amp;</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">                            (index=upperCaseAlias.indexOf(&quot;OID.&quot;, 0)) != -1) {</span>
<span class="fc" id="L568">                        index += &quot;OID.&quot;.length();</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">                        if (index == alias.length()) {</span>
                            // invalid alias entry
<span class="nc" id="L571">                            break;</span>
                        }
<span class="fc bfc" id="L573" title="All 2 branches covered.">                        if (oidTable == null) {</span>
<span class="fc" id="L574">                            oidTable = new HashMap&lt;String,ObjectIdentifier&gt;();</span>
                        }
<span class="fc" id="L576">                        oidString = alias.substring(index);</span>
<span class="fc" id="L577">                        String stdAlgName = provs[i].getProperty(alias);</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">                        if (stdAlgName != null) {</span>
<span class="fc" id="L579">                            stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);</span>
                        }
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">                        if (stdAlgName != null &amp;&amp;</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">                                oidTable.get(stdAlgName) == null) {</span>
<span class="fc" id="L583">                            oidTable.put(stdAlgName,</span>
                                         new ObjectIdentifier(oidString));
                        }
                    }
<span class="fc" id="L587">                }</span>
            }

<span class="pc bpc" id="L590" title="1 of 2 branches missed.">            if (oidTable == null) {</span>
<span class="nc" id="L591">                oidTable = new HashMap&lt;String,ObjectIdentifier&gt;(1);</span>
            }
<span class="fc" id="L593">            initOidTable = true;</span>
        }

<span class="fc" id="L596">        return oidTable.get(name.toUpperCase(Locale.ENGLISH));</span>
    }

    private static ObjectIdentifier oid(int ... values) {
<span class="fc" id="L600">        return ObjectIdentifier.newInternal(values);</span>
    }

<span class="fc" id="L603">    private static boolean initOidTable = false;</span>
    private static Map&lt;String,ObjectIdentifier&gt; oidTable;
    private static final Map&lt;ObjectIdentifier,String&gt; nameTable;

    /*****************************************************************/

    /*
     * HASHING ALGORITHMS
     */

    /**
     * Algorithm ID for the MD2 Message Digest Algorthm, from RFC 1319.
     * OID = 1.2.840.113549.2.2
     */
<span class="fc" id="L617">    public static final ObjectIdentifier MD2_oid =</span>
<span class="fc" id="L618">    ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 2, 2});</span>

    /**
     * Algorithm ID for the MD5 Message Digest Algorthm, from RFC 1321.
     * OID = 1.2.840.113549.2.5
     */
<span class="fc" id="L624">    public static final ObjectIdentifier MD5_oid =</span>
<span class="fc" id="L625">    ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 2, 5});</span>

    /**
     * Algorithm ID for the SHA1 Message Digest Algorithm, from FIPS 180-1.
     * This is sometimes called &quot;SHA&quot;, though that is often confusing since
     * many people refer to FIPS 180 (which has an error) as defining SHA.
     * OID = 1.3.14.3.2.26. Old SHA-0 OID: 1.3.14.3.2.18.
     */
<span class="fc" id="L633">    public static final ObjectIdentifier SHA_oid =</span>
<span class="fc" id="L634">    ObjectIdentifier.newInternal(new int[] {1, 3, 14, 3, 2, 26});</span>

<span class="fc" id="L636">    public static final ObjectIdentifier SHA224_oid =</span>
<span class="fc" id="L637">    ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 4});</span>

<span class="fc" id="L639">    public static final ObjectIdentifier SHA256_oid =</span>
<span class="fc" id="L640">    ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 1});</span>

<span class="fc" id="L642">    public static final ObjectIdentifier SHA384_oid =</span>
<span class="fc" id="L643">    ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 2});</span>

<span class="fc" id="L645">    public static final ObjectIdentifier SHA512_oid =</span>
<span class="fc" id="L646">    ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 3});</span>

    /*
     * COMMON PUBLIC KEY TYPES
     */
<span class="fc" id="L651">    private static final int DH_data[] = { 1, 2, 840, 113549, 1, 3, 1 };</span>
<span class="fc" id="L652">    private static final int DH_PKIX_data[] = { 1, 2, 840, 10046, 2, 1 };</span>
<span class="fc" id="L653">    private static final int DSA_OIW_data[] = { 1, 3, 14, 3, 2, 12 };</span>
<span class="fc" id="L654">    private static final int DSA_PKIX_data[] = { 1, 2, 840, 10040, 4, 1 };</span>
<span class="fc" id="L655">    private static final int RSA_data[] = { 2, 5, 8, 1, 1 };</span>
<span class="fc" id="L656">    private static final int RSAEncryption_data[] =</span>
                                 { 1, 2, 840, 113549, 1, 1, 1 };

    public static final ObjectIdentifier DH_oid;
    public static final ObjectIdentifier DH_PKIX_oid;
    public static final ObjectIdentifier DSA_oid;
    public static final ObjectIdentifier DSA_OIW_oid;
<span class="fc" id="L663">    public static final ObjectIdentifier EC_oid = oid(1, 2, 840, 10045, 2, 1);</span>
<span class="fc" id="L664">    public static final ObjectIdentifier ECDH_oid = oid(1, 3, 132, 1, 12);</span>
    public static final ObjectIdentifier RSA_oid;
    public static final ObjectIdentifier RSAEncryption_oid;

    /*
     * COMMON SECRET KEY TYPES
     */
<span class="fc" id="L671">    public static final ObjectIdentifier AES_oid =</span>
<span class="fc" id="L672">                                            oid(2, 16, 840, 1, 101, 3, 4, 1);</span>

    /*
     * COMMON SIGNATURE ALGORITHMS
     */
<span class="fc" id="L677">    private static final int md2WithRSAEncryption_data[] =</span>
                                       { 1, 2, 840, 113549, 1, 1, 2 };
<span class="fc" id="L679">    private static final int md5WithRSAEncryption_data[] =</span>
                                       { 1, 2, 840, 113549, 1, 1, 4 };
<span class="fc" id="L681">    private static final int sha1WithRSAEncryption_data[] =</span>
                                       { 1, 2, 840, 113549, 1, 1, 5 };
<span class="fc" id="L683">    private static final int sha1WithRSAEncryption_OIW_data[] =</span>
                                       { 1, 3, 14, 3, 2, 29 };
<span class="fc" id="L685">    private static final int sha224WithRSAEncryption_data[] =</span>
                                       { 1, 2, 840, 113549, 1, 1, 14 };
<span class="fc" id="L687">    private static final int sha256WithRSAEncryption_data[] =</span>
                                       { 1, 2, 840, 113549, 1, 1, 11 };
<span class="fc" id="L689">    private static final int sha384WithRSAEncryption_data[] =</span>
                                       { 1, 2, 840, 113549, 1, 1, 12 };
<span class="fc" id="L691">    private static final int sha512WithRSAEncryption_data[] =</span>
                                       { 1, 2, 840, 113549, 1, 1, 13 };
<span class="fc" id="L693">    private static final int shaWithDSA_OIW_data[] =</span>
                                       { 1, 3, 14, 3, 2, 13 };
<span class="fc" id="L695">    private static final int sha1WithDSA_OIW_data[] =</span>
                                       { 1, 3, 14, 3, 2, 27 };
<span class="fc" id="L697">    private static final int dsaWithSHA1_PKIX_data[] =</span>
                                       { 1, 2, 840, 10040, 4, 3 };

    public static final ObjectIdentifier md2WithRSAEncryption_oid;
    public static final ObjectIdentifier md5WithRSAEncryption_oid;
    public static final ObjectIdentifier sha1WithRSAEncryption_oid;
    public static final ObjectIdentifier sha1WithRSAEncryption_OIW_oid;
    public static final ObjectIdentifier sha224WithRSAEncryption_oid;
    public static final ObjectIdentifier sha256WithRSAEncryption_oid;
    public static final ObjectIdentifier sha384WithRSAEncryption_oid;
    public static final ObjectIdentifier sha512WithRSAEncryption_oid;
    public static final ObjectIdentifier shaWithDSA_OIW_oid;
    public static final ObjectIdentifier sha1WithDSA_OIW_oid;
    public static final ObjectIdentifier sha1WithDSA_oid;
<span class="fc" id="L711">    public static final ObjectIdentifier sha224WithDSA_oid =</span>
<span class="fc" id="L712">                                            oid(2, 16, 840, 1, 101, 3, 4, 3, 1);</span>
<span class="fc" id="L713">    public static final ObjectIdentifier sha256WithDSA_oid =</span>
<span class="fc" id="L714">                                            oid(2, 16, 840, 1, 101, 3, 4, 3, 2);</span>

<span class="fc" id="L716">    public static final ObjectIdentifier sha1WithECDSA_oid =</span>
<span class="fc" id="L717">                                            oid(1, 2, 840, 10045, 4, 1);</span>
<span class="fc" id="L718">    public static final ObjectIdentifier sha224WithECDSA_oid =</span>
<span class="fc" id="L719">                                            oid(1, 2, 840, 10045, 4, 3, 1);</span>
<span class="fc" id="L720">    public static final ObjectIdentifier sha256WithECDSA_oid =</span>
<span class="fc" id="L721">                                            oid(1, 2, 840, 10045, 4, 3, 2);</span>
<span class="fc" id="L722">    public static final ObjectIdentifier sha384WithECDSA_oid =</span>
<span class="fc" id="L723">                                            oid(1, 2, 840, 10045, 4, 3, 3);</span>
<span class="fc" id="L724">    public static final ObjectIdentifier sha512WithECDSA_oid =</span>
<span class="fc" id="L725">                                            oid(1, 2, 840, 10045, 4, 3, 4);</span>
<span class="fc" id="L726">    public static final ObjectIdentifier specifiedWithECDSA_oid =</span>
<span class="fc" id="L727">                                            oid(1, 2, 840, 10045, 4, 3);</span>

    /**
     * Algorithm ID for the PBE encryption algorithms from PKCS#5 and
     * PKCS#12.
     */
<span class="fc" id="L733">    public static final ObjectIdentifier pbeWithMD5AndDES_oid =</span>
<span class="fc" id="L734">        ObjectIdentifier.newInternal(new int[]{1, 2, 840, 113549, 1, 5, 3});</span>
<span class="fc" id="L735">    public static final ObjectIdentifier pbeWithMD5AndRC2_oid =</span>
<span class="fc" id="L736">        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 5, 6});</span>
<span class="fc" id="L737">    public static final ObjectIdentifier pbeWithSHA1AndDES_oid =</span>
<span class="fc" id="L738">        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 5, 10});</span>
<span class="fc" id="L739">    public static final ObjectIdentifier pbeWithSHA1AndRC2_oid =</span>
<span class="fc" id="L740">        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 5, 11});</span>
<span class="fc" id="L741">    public static ObjectIdentifier pbeWithSHA1AndDESede_oid =</span>
<span class="fc" id="L742">        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 3});</span>
<span class="fc" id="L743">    public static ObjectIdentifier pbeWithSHA1AndRC2_40_oid =</span>
<span class="fc" id="L744">        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 6});</span>

    static {
    /*
     * Note the preferred OIDs are named simply with no &quot;OIW&quot; or
     * &quot;PKIX&quot; in them, even though they may point to data from these
     * specs; e.g. SHA_oid, DH_oid, DSA_oid, SHA1WithDSA_oid...
     */
    /**
     * Algorithm ID for Diffie Hellman Key agreement, from PKCS #3.
     * Parameters include public values P and G, and may optionally specify
     * the length of the private key X.  Alternatively, algorithm parameters
     * may be derived from another source such as a Certificate Authority's
     * certificate.
     * OID = 1.2.840.113549.1.3.1
     */
<span class="fc" id="L760">        DH_oid = ObjectIdentifier.newInternal(DH_data);</span>

    /**
     * Algorithm ID for the Diffie Hellman Key Agreement (DH), from RFC 3279.
     * Parameters may include public values P and G.
     * OID = 1.2.840.10046.2.1
     */
<span class="fc" id="L767">        DH_PKIX_oid = ObjectIdentifier.newInternal(DH_PKIX_data);</span>

    /**
     * Algorithm ID for the Digital Signing Algorithm (DSA), from the
     * NIST OIW Stable Agreements part 12.
     * Parameters may include public values P, Q, and G; or these may be
     * derived from
     * another source such as a Certificate Authority's certificate.
     * OID = 1.3.14.3.2.12
     */
<span class="fc" id="L777">        DSA_OIW_oid = ObjectIdentifier.newInternal(DSA_OIW_data);</span>

    /**
     * Algorithm ID for the Digital Signing Algorithm (DSA), from RFC 3279.
     * Parameters may include public values P, Q, and G; or these may be
     * derived from another source such as a Certificate Authority's
     * certificate.
     * OID = 1.2.840.10040.4.1
     */
<span class="fc" id="L786">        DSA_oid = ObjectIdentifier.newInternal(DSA_PKIX_data);</span>

    /**
     * Algorithm ID for RSA keys used for any purpose, as defined in X.509.
     * The algorithm parameter is a single value, the number of bits in the
     * public modulus.
     * OID = 2.5.8.1.1
     */
<span class="fc" id="L794">        RSA_oid = ObjectIdentifier.newInternal(RSA_data);</span>

    /**
     * Algorithm ID for RSA keys used with RSA encryption, as defined
     * in PKCS #1.  There are no parameters associated with this algorithm.
     * OID = 1.2.840.113549.1.1.1
     */
<span class="fc" id="L801">        RSAEncryption_oid = ObjectIdentifier.newInternal(RSAEncryption_data);</span>

    /**
     * Identifies a signing algorithm where an MD2 digest is encrypted
     * using an RSA private key; defined in PKCS #1.  Use of this
     * signing algorithm is discouraged due to MD2 vulnerabilities.
     * OID = 1.2.840.113549.1.1.2
     */
<span class="fc" id="L809">        md2WithRSAEncryption_oid =</span>
<span class="fc" id="L810">            ObjectIdentifier.newInternal(md2WithRSAEncryption_data);</span>

    /**
     * Identifies a signing algorithm where an MD5 digest is
     * encrypted using an RSA private key; defined in PKCS #1.
     * OID = 1.2.840.113549.1.1.4
     */
<span class="fc" id="L817">        md5WithRSAEncryption_oid =</span>
<span class="fc" id="L818">            ObjectIdentifier.newInternal(md5WithRSAEncryption_data);</span>

    /**
     * Identifies a signing algorithm where a SHA1 digest is
     * encrypted using an RSA private key; defined by RSA DSI.
     * OID = 1.2.840.113549.1.1.5
     */
<span class="fc" id="L825">        sha1WithRSAEncryption_oid =</span>
<span class="fc" id="L826">            ObjectIdentifier.newInternal(sha1WithRSAEncryption_data);</span>

    /**
     * Identifies a signing algorithm where a SHA1 digest is
     * encrypted using an RSA private key; defined in NIST OIW.
     * OID = 1.3.14.3.2.29
     */
<span class="fc" id="L833">        sha1WithRSAEncryption_OIW_oid =</span>
<span class="fc" id="L834">            ObjectIdentifier.newInternal(sha1WithRSAEncryption_OIW_data);</span>

    /**
     * Identifies a signing algorithm where a SHA224 digest is
     * encrypted using an RSA private key; defined by PKCS #1.
     * OID = 1.2.840.113549.1.1.14
     */
<span class="fc" id="L841">        sha224WithRSAEncryption_oid =</span>
<span class="fc" id="L842">            ObjectIdentifier.newInternal(sha224WithRSAEncryption_data);</span>

    /**
     * Identifies a signing algorithm where a SHA256 digest is
     * encrypted using an RSA private key; defined by PKCS #1.
     * OID = 1.2.840.113549.1.1.11
     */
<span class="fc" id="L849">        sha256WithRSAEncryption_oid =</span>
<span class="fc" id="L850">            ObjectIdentifier.newInternal(sha256WithRSAEncryption_data);</span>

    /**
     * Identifies a signing algorithm where a SHA384 digest is
     * encrypted using an RSA private key; defined by PKCS #1.
     * OID = 1.2.840.113549.1.1.12
     */
<span class="fc" id="L857">        sha384WithRSAEncryption_oid =</span>
<span class="fc" id="L858">            ObjectIdentifier.newInternal(sha384WithRSAEncryption_data);</span>

    /**
     * Identifies a signing algorithm where a SHA512 digest is
     * encrypted using an RSA private key; defined by PKCS #1.
     * OID = 1.2.840.113549.1.1.13
     */
<span class="fc" id="L865">        sha512WithRSAEncryption_oid =</span>
<span class="fc" id="L866">            ObjectIdentifier.newInternal(sha512WithRSAEncryption_data);</span>

    /**
     * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a
     * SHA digest is signed using the Digital Signing Algorithm (DSA).
     * This should not be used.
     * OID = 1.3.14.3.2.13
     */
<span class="fc" id="L874">        shaWithDSA_OIW_oid = ObjectIdentifier.newInternal(shaWithDSA_OIW_data);</span>

    /**
     * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a
     * SHA1 digest is signed using the Digital Signing Algorithm (DSA).
     * OID = 1.3.14.3.2.27
     */
<span class="fc" id="L881">        sha1WithDSA_OIW_oid = ObjectIdentifier.newInternal(sha1WithDSA_OIW_data);</span>

    /**
     * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a
     * SHA1 digest is signed using the Digital Signing Algorithm (DSA).
     * OID = 1.2.840.10040.4.3
     */
<span class="fc" id="L888">        sha1WithDSA_oid = ObjectIdentifier.newInternal(dsaWithSHA1_PKIX_data);</span>

<span class="fc" id="L890">        nameTable = new HashMap&lt;ObjectIdentifier,String&gt;();</span>
<span class="fc" id="L891">        nameTable.put(MD5_oid, &quot;MD5&quot;);</span>
<span class="fc" id="L892">        nameTable.put(MD2_oid, &quot;MD2&quot;);</span>
<span class="fc" id="L893">        nameTable.put(SHA_oid, &quot;SHA-1&quot;);</span>
<span class="fc" id="L894">        nameTable.put(SHA224_oid, &quot;SHA-224&quot;);</span>
<span class="fc" id="L895">        nameTable.put(SHA256_oid, &quot;SHA-256&quot;);</span>
<span class="fc" id="L896">        nameTable.put(SHA384_oid, &quot;SHA-384&quot;);</span>
<span class="fc" id="L897">        nameTable.put(SHA512_oid, &quot;SHA-512&quot;);</span>
<span class="fc" id="L898">        nameTable.put(RSAEncryption_oid, &quot;RSA&quot;);</span>
<span class="fc" id="L899">        nameTable.put(RSA_oid, &quot;RSA&quot;);</span>
<span class="fc" id="L900">        nameTable.put(DH_oid, &quot;Diffie-Hellman&quot;);</span>
<span class="fc" id="L901">        nameTable.put(DH_PKIX_oid, &quot;Diffie-Hellman&quot;);</span>
<span class="fc" id="L902">        nameTable.put(DSA_oid, &quot;DSA&quot;);</span>
<span class="fc" id="L903">        nameTable.put(DSA_OIW_oid, &quot;DSA&quot;);</span>
<span class="fc" id="L904">        nameTable.put(EC_oid, &quot;EC&quot;);</span>
<span class="fc" id="L905">        nameTable.put(ECDH_oid, &quot;ECDH&quot;);</span>

<span class="fc" id="L907">        nameTable.put(AES_oid, &quot;AES&quot;);</span>

<span class="fc" id="L909">        nameTable.put(sha1WithECDSA_oid, &quot;SHA1withECDSA&quot;);</span>
<span class="fc" id="L910">        nameTable.put(sha224WithECDSA_oid, &quot;SHA224withECDSA&quot;);</span>
<span class="fc" id="L911">        nameTable.put(sha256WithECDSA_oid, &quot;SHA256withECDSA&quot;);</span>
<span class="fc" id="L912">        nameTable.put(sha384WithECDSA_oid, &quot;SHA384withECDSA&quot;);</span>
<span class="fc" id="L913">        nameTable.put(sha512WithECDSA_oid, &quot;SHA512withECDSA&quot;);</span>
<span class="fc" id="L914">        nameTable.put(md5WithRSAEncryption_oid, &quot;MD5withRSA&quot;);</span>
<span class="fc" id="L915">        nameTable.put(md2WithRSAEncryption_oid, &quot;MD2withRSA&quot;);</span>
<span class="fc" id="L916">        nameTable.put(sha1WithDSA_oid, &quot;SHA1withDSA&quot;);</span>
<span class="fc" id="L917">        nameTable.put(sha1WithDSA_OIW_oid, &quot;SHA1withDSA&quot;);</span>
<span class="fc" id="L918">        nameTable.put(shaWithDSA_OIW_oid, &quot;SHA1withDSA&quot;);</span>
<span class="fc" id="L919">        nameTable.put(sha224WithDSA_oid, &quot;SHA224withDSA&quot;);</span>
<span class="fc" id="L920">        nameTable.put(sha256WithDSA_oid, &quot;SHA256withDSA&quot;);</span>
<span class="fc" id="L921">        nameTable.put(sha1WithRSAEncryption_oid, &quot;SHA1withRSA&quot;);</span>
<span class="fc" id="L922">        nameTable.put(sha1WithRSAEncryption_OIW_oid, &quot;SHA1withRSA&quot;);</span>
<span class="fc" id="L923">        nameTable.put(sha224WithRSAEncryption_oid, &quot;SHA224withRSA&quot;);</span>
<span class="fc" id="L924">        nameTable.put(sha256WithRSAEncryption_oid, &quot;SHA256withRSA&quot;);</span>
<span class="fc" id="L925">        nameTable.put(sha384WithRSAEncryption_oid, &quot;SHA384withRSA&quot;);</span>
<span class="fc" id="L926">        nameTable.put(sha512WithRSAEncryption_oid, &quot;SHA512withRSA&quot;);</span>
<span class="fc" id="L927">        nameTable.put(pbeWithMD5AndDES_oid, &quot;PBEWithMD5AndDES&quot;);</span>
<span class="fc" id="L928">        nameTable.put(pbeWithMD5AndRC2_oid, &quot;PBEWithMD5AndRC2&quot;);</span>
<span class="fc" id="L929">        nameTable.put(pbeWithSHA1AndDES_oid, &quot;PBEWithSHA1AndDES&quot;);</span>
<span class="fc" id="L930">        nameTable.put(pbeWithSHA1AndRC2_oid, &quot;PBEWithSHA1AndRC2&quot;);</span>
<span class="fc" id="L931">        nameTable.put(pbeWithSHA1AndDESede_oid, &quot;PBEWithSHA1AndDESede&quot;);</span>
<span class="fc" id="L932">        nameTable.put(pbeWithSHA1AndRC2_40_oid, &quot;PBEWithSHA1AndRC2_40&quot;);</span>
<span class="fc" id="L933">    }</span>

    /**
     * Creates a signature algorithm name from a digest algorithm
     * name and a encryption algorithm name.
     */
    public static String makeSigAlg(String digAlg, String encAlg) {
<span class="fc" id="L940">        digAlg = digAlg.replace(&quot;-&quot;, &quot;&quot;);</span>
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">        if (encAlg.equalsIgnoreCase(&quot;EC&quot;)) encAlg = &quot;ECDSA&quot;;</span>

<span class="fc" id="L943">        return digAlg + &quot;with&quot; + encAlg;</span>
    }

    /**
     * Extracts the encryption algorithm name from a signature
     * algorithm name.
      */
    public static String getEncAlgFromSigAlg(String signatureAlgorithm) {
<span class="fc" id="L951">        signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);</span>
<span class="fc" id="L952">        int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);</span>
<span class="fc" id="L953">        String keyAlgorithm = null;</span>
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">        if (with &gt; 0) {</span>
<span class="nc" id="L955">            int and = signatureAlgorithm.indexOf(&quot;AND&quot;, with + 4);</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">            if (and &gt; 0) {</span>
<span class="nc" id="L957">                keyAlgorithm = signatureAlgorithm.substring(with + 4, and);</span>
            } else {
<span class="nc" id="L959">                keyAlgorithm = signatureAlgorithm.substring(with + 4);</span>
            }
<span class="nc bnc" id="L961" title="All 2 branches missed.">            if (keyAlgorithm.equalsIgnoreCase(&quot;ECDSA&quot;)) {</span>
<span class="nc" id="L962">                keyAlgorithm = &quot;EC&quot;;</span>
            }
        }
<span class="fc" id="L965">        return keyAlgorithm;</span>
    }

    /**
     * Extracts the digest algorithm name from a signature
     * algorithm name.
      */
    public static String getDigAlgFromSigAlg(String signatureAlgorithm) {
<span class="nc" id="L973">        signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);</span>
<span class="nc" id="L974">        int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">        if (with &gt; 0) {</span>
<span class="nc" id="L976">            return signatureAlgorithm.substring(0, with);</span>
        }
<span class="nc" id="L978">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>